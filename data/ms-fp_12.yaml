- en: The Actor Model in Practice
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践中的Actor模型
- en: In the previous chapter, we started to look at the actors model as one of their
    concurrency models available in Scala. In [Chapter 9](6b6045c0-bf4d-4ae9-adc1-fdaf23985329.xhtml), *Libraries
    for Pure Functional Programming*, we saw how challenges of asynchronous and multithreaded
    programming can be solved using IO and the infrastructure it provides. However,
    this kind of technology is still not widely adopted. In practice, when working
    with multithreading, concurrency, and asynchrony in Scala, you will need to deal
    with more robust libraries in real-world situations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们开始探讨actor模型作为Scala中可用的一种并发模型。在[第9章](6b6045c0-bf4d-4ae9-adc1-fdaf23985329.xhtml)，*纯函数式编程库*中，我们看到了如何使用IO及其提供的基础设施来解决异步和多线程编程的挑战。然而，这种技术仍然没有得到广泛的应用。在实践中，当你在Scala中处理多线程、并发和异步时，你将需要在现实场景中处理更健壮的库。
- en: 'In this chapter, we will look at the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Akka overview
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Akka概述
- en: Defining, creating, and messaging actors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义、创建和消息传递actor
- en: Working with actor systems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与actor系统一起工作
- en: Akka overview
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Akka概述
- en: Akka is an implementation of the actor model, which we discussed in the previous
    chapter for its industrial purposes. If the Cats effect focuses on experimentation
    and trials with new technologies, then Akka focuses on providing the industry
    with the tools that can solve large-scale problems. Of course, we can expect cats
    to mature to that level as well, however, if you are going to work with concurrency
    and asynchrony in Scala in a real-world situation, it is likely you will encounter
    Akka.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Akka是actor模型的实现，我们在上一章中讨论了其在工业应用中的目的。如果Cats效应专注于对新技术的实验和尝试，那么Akka则专注于为行业提供解决大规模问题的工具。当然，我们也可以期待Cats达到那个水平，然而，如果你打算在现实世界中用Scala处理并发和异步，你很可能会遇到Akka。
- en: The purpose of this book is to make you comfortable with modern technologies
    in functional programming that are in demand in real-world situations. Since concurrent
    and asynchronous programming is ubiquitous, we are going to discuss the tools
    that are most widely used to tackle its challenges. We will start by looking at
    the principles on which Akka is built.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的目的在于让你熟悉在现实场景中需求旺盛的函数式编程的现代技术。由于并发和异步编程无处不在，我们将讨论最广泛使用的工具来应对其挑战。我们将从查看Akka构建的基础原则开始。
- en: Principles of Akka
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Akka原理
- en: The central abstraction of Akka is an actor. An actor is an entity that can
    receive and send messages to other actors.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Akka的核心抽象是actor。actor是一个可以接收和向其他actor发送消息的实体。
- en: Actors are lightweight concurrency primitives. Similarly to how you can have
    millions of Fibres in cats, you can have millions of actors in Akka. This is because
    they utilize asynchrony and provide abstractions on top of standard Java virtual
    machine threads. By utilizing the resources of the JVM, you can have millions
    of actors in parallel on a single machine.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Actors是轻量级的并发原语。类似于你可以在cats中有数百万个Fibres，你可以在Akka中有数百万个actors。这是因为它们利用异步并提供在标准Java虚拟机线程之上的抽象。通过利用JVM的资源，你可以在单台机器上并行运行数百万个actors。
- en: Akka is built with scaling in mind. The library does not stop at providing you
    with the abstractions for actors themselves. Similarly to how cats has an infrastructure
    of libraries for various specific cases of functional programming, Akka has a
    host of libraries for special cases of asynchronous programming. You will encounter
    an HTTP server as part of this library, which is an infrastructure to allow you
    to communicate between actors that reside on different machines.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Akka在设计时就考虑了可扩展性。该库不仅为你提供了actor本身的抽象。类似于cats有针对各种特定函数式编程情况的库基础设施，Akka也有大量针对异步编程特殊情况的库。你将在这个库中遇到一个HTTP服务器，这是一个允许你与位于不同机器上的actors进行通信的基础设施。
- en: The purpose of the actors model is to provide you with a concurrency framework
    that will reduce your mental overhead and allow for robust and scalable software.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Actors模型的目的在于为你提供一个并发框架，这将减少你的心理负担，并允许构建健壮和可扩展的软件。
- en: To overcome the challenges that concurrent programming poses, Akka imposes a
    range of pretty harsh restrictions on a programmer. One can expect to benefit
    from the model only if they follow these restrictions. It is important to remember
    that the rules the actor model imposes are not encoded and enforced by the compiler.
    So it is up to you to follow them. Breaking them at will is easy. It is important
    to remember that if you do so, it is very likely that you are going to end up
    with even more of a headache than you had without the actor model.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服并发编程带来的挑战，Akka对程序员施加了一系列相当严格的限制。只有遵循这些限制，人们才能从模型中受益。重要的是要记住，actor模型强加的规则不是由编译器编码和执行的。所以，遵循它们的责任在于你。随意打破它们是很容易的。重要的是要记住，如果你这样做，你可能会遇到比没有actor模型时更大的麻烦。
- en: Encapsulation
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装
- en: One problem with concurrent programming is the shared mutable state. Akka eliminates
    this problem by providing a restriction that it is impossible to access your actors
    as ordinary objects. This means your business logic does not have a single variable
    that would store an actor. Hence, it is impossible to access the values defined
    on the actors by ordinary object-oriented means.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程的一个问题是共享可变状态。Akka通过提供一种限制来消除这个问题，即无法将actor作为普通对象访问。这意味着你的业务逻辑没有单个变量来存储actor。因此，不可能通过普通面向对象的方式访问actor上定义的值。
- en: The actors are exposed to the outer world via proxy types—`ActorRef`s. The Akka
    library defines this type, and only safe operations are permitted on an actor.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过代理类型——`ActorRef`s——将actor暴露给外部世界。Akka库定义了这种类型，并且只允许在actor上执行安全操作。
- en: If you want to do something with an actor, you should do so via this proxy.
    Also, you do not instantiate an actor as an ordinary Java or Scala object. You
    do not call a constructor on it. Instead, you will instruct `ActorSystem` to instantiate
    it. With these constraints, it becomes impossible to accept the data of an actor
    by any means other than messaging it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想对actor做些什么，你应该通过这个代理来做。此外，你不会将actor作为普通的Java或Scala对象实例化。你不会在它上面调用构造函数。相反，你将指示`ActorSystem`来实例化它。有了这些约束，就变得不可能通过任何其他方式接受actor的数据，除了通过消息传递。
- en: Messaging
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息传递
- en: Every actor has a mailbox, where any other messages can be sent. Akka guarantees
    that the messages are handled by the actor one at a time, and no concurrent handling
    happens. In fact, the actor model provides a guarantee that no more than one thread
    accesses the internal state of an actor at a time. However, keep in mind that
    it is up to the programmer to follow the actor model precisely. It is easy to
    break the model by spawning extra threads (e.g. with a `Future`) in an actor,
    thus breaking the single-threaded access guarantee.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 每个actor都有一个邮箱，任何其他消息都可以发送到那里。Akka保证消息一次由actor处理，不会发生并发处理。实际上，actor模型提供了一种保证，即一次只有一个线程可以访问actor的内部状态。然而，请记住，遵循actor模型的责任在于程序员。通过在actor中产生额外的线程（例如使用`Future`）来打破模型是很容易的，从而破坏单一线程访问保证。
- en: This restriction is essential to enforce in the presence of other convenient
    concurrency libraries, such as Future. Akka works hand-in-hand with Scala Future.
    It is important to remember that futures start and work from other threads. So,
    the moment you start a Future in Akka, you lose the guarantee of single-threaded
    access to the state of an actor. If you follow this road, you will need to specify
    the synchronization and utilize the monitor mechanism provided to you by the JVM.
    This is an anti-pattern, it kills the very purpose of Akka, and is a big no-no
    in actor programming.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在存在其他方便的并发库，如Future的情况下，这种限制是强制执行的。Akka与Scala Future紧密协作。重要的是要记住，未来（futures）是从其他线程开始和工作的。所以，当你开始在Akka中启动一个Future时，你就失去了对actor状态的单一线程访问保证。如果你继续这条路，你需要指定同步并利用JVM为你提供的监控机制。这是一个反模式，它破坏了Akka的初衷，在actor编程中是绝对禁止的。
- en: Remember that the model is going to help you only if you follow its rules, and
    there is nothing to enforce you to do so.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，只有当你遵循其规则时，模型才会帮助你，而且没有任何东西可以强制你这样做。
- en: No leaking of mutable state
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不泄露可变状态
- en: Another thing that you must look out for when programming with Akka is leaking
    mutable state of the actors. Remember the previous principle that no more than
    a single thread must access the inner state of an actor? Well, if you send a reference
    to a mutable object that is owned by one actor to another one, this object may
    be accessed from two threads at a time in parallel. If you leak mutable state
    to other actors, you may end up with a worse headache than when starting a Future
    from an actor. In the case of starting a Future, at least you have control over
    that Future and the thread it started from; you can define some monitors and 
    protocols to access the actor's state. Of course, you should not do it, but in
    theory, it is possible.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Akka进行编程时，你必须注意的另一件事是actor的可变状态的泄露。还记得之前的原则，即不能有超过一个线程访问actor的内部状态吗？好吧，如果你将一个由一个actor拥有的可变对象的引用发送给另一个actor，这个对象可能同时被两个线程并行访问。如果你将可变状态泄露给其他actor，你可能会遇到比从actor启动Future时更糟糕的头痛。在启动Future的情况下，至少你可以控制那个Future和它启动的线程；你可以定义一些监视器和协议来访问actor的状态。当然，你不应该这样做，但在理论上，这是可能的。
- en: However, if you leak a reference to a mutable state from one actor to another,
    you will have no control whatsoever over how that actor will use it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你从一个actor向另一个actor泄露了一个可变状态的引用，你将无法控制该actor如何使用它。
- en: Again, this rule is not enforced by Akka. In Akka, you can pass any object as
    a message to another actor. This includes mutable references. So, you should be
    aware of the possibility and actively avoid it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这个规则不是由Akka强制执行的。在Akka中，你可以将任何对象作为消息传递给另一个actor。这包括可变引用。因此，你应该意识到这种可能性，并积极避免它。
- en: Fault-tolerance and supervision
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容错性和监督
- en: Akka is built with resilience and fault-tolerance in mind. This means that if
    an actor fails as a result of an exception, there is a well-defined way it will
    automatically restart and restore its state. Akka organizes actors in hierarchies,
    and parent actors are responsible for the performance of their children. So, if
    a child fails, its parent is supposed to be responsible for restarting it. The
    idea is that the external world should not be affected by the problems of an actor's
    subordinates. If the problem happens, it is the supervisor's responsibility to
    solve it rather than escalating it further. And when the child actor restarts,
    it should be able to restore itself to the state it was at when it failed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Akka在设计时考虑了弹性和容错性。这意味着如果一个actor因为异常而失败，它将有一个定义良好的方式自动重启并恢复其状态。Akka将actor组织成层次结构，父actor负责其子actor的性能。所以，如果一个子actor失败了，它的父actor应该负责重启它。理念是外部世界不应该受到actor下属问题的干扰。如果出现问题，解决这个问题的责任在管理者，而不是进一步升级问题。而且当子actor重启时，它应该能够恢复到它失败时的状态。
- en: Messaging guarantees
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息保证
- en: Akka is built to be deployed in clusters, over the network. This means that
    you have fewer delivery guarantees about the messages than when you are working
    on a single JVM application. If you are sending a message from an actor that resides
    in one computer to an actor on another side of the world, you cannot guarantee
    that this message will get delivered.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Akka被设计成可以在集群中、通过网络进行部署。这意味着你对于消息的传递保证比在单个JVM应用程序中要少。如果你从一个计算机上的actor向世界另一端的actor发送消息，你不能保证这个消息会被传递。
- en: So, the actor model as implemented by Akka requires you to build your applications
    with no guarantees whatsoever about delivering the messages. Your application
    must be robust to the situations of the impossibility of message-delivery.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，由Akka实现的actor模型要求你在构建应用程序时不要对消息传递有任何保证。你的应用程序必须能够应对无法传递消息的情况。
- en: However, Akka provides you with a guarantee about the order in which messages
    from one actor to another get delivered. This means that if from the same actor,
    you send a message before another, you can be sure that message also arrives before
    the second one.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Akka为你提供了关于从actor到actor的消息传递顺序的保证。这意味着如果你从一个actor发送一个消息在另一个消息之前，你可以确信这个消息也会在第二个消息之前到达。
- en: The best thing to do after learning the preceding theory is to have a look at
    how it works in practice. Next, we will be discussing an example that relies on
    the numerous functionalities that Akka exposes. We will be learning these functionalities
    as we encounter them.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习前面的理论之后，最好的做法是看看它在实际中的应用情况。接下来，我们将讨论一个依赖于Akka提供的众多功能的例子。我们将随着遇到这些功能来学习它们。
- en: Asynchrony
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步
- en: Remember when we discussed IO, we stressed the importance of asynchrony and
    non-blocking computations? Threads of the underlying operating system are scarce,
    and on a system with high load, you need to utilize them well. Blocking is not
    a wise utilization of the threads.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们讨论IO时，强调了异步和非阻塞计算的重要性吗？底层操作系统的线程是稀缺的，在一个高负载的系统上，你需要很好地利用它们。阻塞并不是线程的明智利用方式。
- en: We have discussed that you should not invoke other threads from the current
    actor. The motivation for this is to prevent access to the mutable state of the
    current actor from more than one thread. We have discussed that whenever we need
    to process something, we schedule the processing as a message to the current actor.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过，你不应该从当前actor调用其他线程。这样做的原因是为了防止多个线程访问当前actor的可变状态。我们已经讨论过，每次我们需要处理某些事情时，我们都将处理作为消息调度给当前actor。
- en: 'Therefore, to enforce single-threaded processing, you might be tempted to block
    on a future from a message-handling logic, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了强制单线程处理，你可能会倾向于在消息处理逻辑上阻塞一个future，如下所示：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'However, this blocks the underlying thread. Blocking turns an actor that does
    so into a heavyweight concurrency primitive. If you use it in a setting of a high-load
    application, it will eat system-concurrency resources fast. The rationale here
    is the same as when we were discussing IO. Bottom line: do not block your concurrency
    primitives because the threads are scarce. If you need to wait for the result
    of some asynchronous computation to continue the current computation, make sure
    that that the computation will send this actor a message when it finishes, register
    a handler on the current actor saying what to do once the task finishes, and release
    the current thread.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这会阻塞底层线程。阻塞将一个执行此操作的actor变成了一个重量级的并发原语。如果你在高负载应用的环境中使用它，它会快速消耗系统并发资源。这里的理由与我们在讨论IO时相同。总之：不要阻塞你的并发原语，因为线程是稀缺的。如果你需要等待某些异步计算的结果以继续当前计算，确保计算完成时向该actor发送消息，在当前actor上注册一个处理程序，说明任务完成后要做什么，并释放当前线程。
- en: Defining, creating, and messaging actors
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义、创建和消息传递actor
- en: 'The actors are defined as classes that inherit from the `Actor` class from
    the Akka library:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Actor被定义为从Akka库中的`Actor`类继承的类：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Actor exposes the following abstract API:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Actor公开以下抽象API：
- en: '![](img/2ccebe72-90ba-46e7-a07d-2ff51a1a18a5.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2ccebe72-90ba-46e7-a07d-2ff51a1a18a5.png)'
- en: The only method that is abstract in `Actor` is the `receive` method. Akka calls
    this method when an actor needs to handle an incoming message. It returns a partial
    function from `Any` to `Unit`. This means that it is capable of handling a message
    from a domain of all objects, and it is supposed to produce some side effects
    while handling this message, which is indicated by the `Unit` return type. That
    function is a partial function, which means that it can handle only a part of
    the input `Any` domain that your actor is interested in.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Actor`中唯一抽象的方法是`receive`方法。Akka在actor需要处理传入消息时调用此方法。它返回一个从`Any`到`Unit`的偏函数。这意味着它能够处理来自所有对象域的消息，并且它应该在处理此消息时产生一些副作用，这由`Unit`返回类型表示。该函数是一个偏函数，这意味着它只能处理actor感兴趣的部分`Any`输入域。'
- en: 'When your define an actor, you override this method to define what the actor
    must do:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义一个actor时，你重写此方法来定义actor必须做什么：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The message is defined as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 消息定义如下：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So, when an actor receives the ping message, it will output the `hello world` string
    to the log. We can construct the log with the help of the following function:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当actor收到ping消息时，它将输出`hello world`字符串到日志。我们可以通过以下函数来构建日志：
- en: '![](img/dc14022b-24bb-4ca5-aa76-8a5172aa424e.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dc14022b-24bb-4ca5-aa76-8a5172aa424e.png)'
- en: 'This function is defined over the following object:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数定义在以下对象上：
- en: '![](img/d981b63f-57f1-4421-93f1-8bd8ea6c92e8.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d981b63f-57f1-4421-93f1-8bd8ea6c92e8.png)'
- en: One of the abstractions Akka relies upon is the event system. Events can be
    used to track the changes in the state of an actor and restore it to the previous state
    in case of failure. Since logging is also an event stream in a sense, Akka provides
    you with an elaborate logging infrastructure that also integrates with its general
    event system. When constructing a logger, you will need to provide the `ActorSystem` you
    are defining it for, as well as the reference to the current actor. You will then
    be able to display the log messages properly while specifying the current actor.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Akka所依赖的一种抽象是事件系统。事件可以用来跟踪演员状态的变化，并在失败的情况下将其恢复到之前的状态。从某种意义上说，日志记录也是一个事件流，因此Akka为你提供了一个详尽的日志基础设施，它还与其通用事件系统集成。在构建记录器时，你需要提供为其定义的`ActorSystem`以及当前演员的引用。然后你将能够正确地显示日志消息，同时指定当前演员。
- en: Notice that here, to construct the logger, we are accessing some other API defined
    on the actor. We are calling the context method and its member-system method.
    So, next, let's have a look at the API the actor exposes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这里，为了构建记录器，我们正在访问在演员上定义的其他API。我们正在调用上下文方法和其成员系统方法。因此，接下来，让我们看看演员公开的API。
- en: All of the concrete members of the `Actor` class can be divided into several
    groups.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Actor`类的所有具体成员可以分为几个组。'
- en: Callbacks
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调
- en: 'The following methods belong to the callbacks group:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法属于回调组：
- en: '![](img/25f95e92-7c78-49ad-8573-5fcc394b2e4a.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/25f95e92-7c78-49ad-8573-5fcc394b2e4a.png)'
- en: The Akka framework in different situations calls these callbacks. For example, `postStop`
    is called after the actor stops. `preStart` is called before the actor starts. `preRestart`
    is called before, and `afterRestart` is called after, the actor has restarted.
    The restart callbacks take a `reason` as an argument. The `reason` is an exception
    due to which this actor had to restart itself. It is also part of Akka's fault-tolerance
    strategy. When building your actors, you should keep the possibility of such restarting
    in mind.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Akka框架在不同情况下会调用这些回调。例如，`postStop`在演员停止后调用。`preStart`在演员开始前调用。`preRestart`在演员重启前调用，`afterRestart`在演员重启后调用。重启回调接受一个`reason`参数。`reason`是由于此演员需要重启而导致的异常。它也是Akka的容错策略的一部分。在构建您的演员时，您应该考虑到这种重启的可能性。
- en: 'Finally, the `unhandled` method is called whenever a message arrives at an
    actor that it is not capable of handling it:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当演员收到它无法处理的任何消息时，会调用`unhandled`方法：
- en: '![](img/2edac43e-39d2-4353-98d2-dcf08e60b1fb.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2edac43e-39d2-4353-98d2-dcf08e60b1fb.png)'
- en: Remember that we have discussed that the `receive` method returns a partial
    function. This means it is defined only on a part of its domain type. So, whenever
    a message arrives at an actor that it is not able to handle, the unhandled callback
    is called instead.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们讨论过`receive`方法返回一个部分函数。这意味着它只在其域类型的一部分上定义。因此，每当演员收到它无法处理的任何消息时，就会调用未处理的回调。
- en: Supervision
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监督
- en: 'Also, part of the fault-tolerance strategy that Actor provides is the `supervisorStrategy`
    method:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Actor提供的容错策略的一部分是`supervisorStrategy`方法：
- en: '![](img/959743bd-0a01-4bcd-80d4-22fdf7ac5aa6.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/959743bd-0a01-4bcd-80d4-22fdf7ac5aa6.png)'
- en: 'You can override this method to provide the actor with different ways to supervise
    its children. Supervision is the concept of watching the children''s life cycle
    and taking actions on significant events, such as when an actor fails with an
    exception. In Akka, parent actors are supposed to supervise child actors. The
    supervision strategy is defined as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以重写此方法以提供不同的方式来监督其子演员。监督是观察子演员的生命周期并在重要事件上采取行动的概念，例如当演员因异常失败时。在Akka中，父演员应该监督子演员。监督策略定义如下：
- en: '![](img/0a2d5019-f626-4dbb-b4d7-8e8452f3cde8.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0a2d5019-f626-4dbb-b4d7-8e8452f3cde8.png)'
- en: 'As you can see, there are two subclasses defined for this class, and the documentation
    suggests you shouldn''t implement additional subclasses because an incorrect implementation
    can lead to erroneous behavior:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，为此类定义了两个子类，并且文档建议您不要实现额外的子类，因为不正确的实现可能导致错误的行为：
- en: '![](img/567857e7-750d-44b1-ae49-91a467650602.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/567857e7-750d-44b1-ae49-91a467650602.png)'
- en: '`AllForOneStrategy` will apply a given action to all of the children if one
    fails:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`AllForOneStrategy`如果其中一个子演员失败，将对所有子演员应用给定的操作：'
- en: '![](img/fb9fa2ed-b0ab-4631-a5cb-91a3b60deb7a.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fb9fa2ed-b0ab-4631-a5cb-91a3b60deb7a.png)'
- en: '`OneForOneStrategy` will apply an action only to the child that failed.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`OneForOneStrategy`将只对失败的子演员应用操作。'
- en: 'Notice also that both strategies are parameterized by various parameters that
    define how it should handle situations with failed children. One of these parameters
    is `Decider`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这两种策略都是通过定义如何处理失败子代的情况的各种参数来参数化的。其中一个参数是 `Decider`：
- en: '![](img/bffb40cc-0a99-4fb7-b544-e37b43f5b96b.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bffb40cc-0a99-4fb7-b544-e37b43f5b96b.png)'
- en: The `Decider` type is a partial function from a `Throwable` to a `Directive`.
    It takes a `Throwable` (which can be an `Exception` or an `Error`) that has occurred
    in the actor, and the job of `Decider` is to provide information to the actor
    system on how to handle this exception.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Decider` 类型是从 `Throwable` 到 `Directive` 的部分函数。它接受在演员中发生的 `Throwable`（可以是 `Exception`
    或 `Error`），`Decider` 的任务是向演员系统提供如何处理这个异常的信息。'
- en: '`Directive` defines what to do on a given exception with an actor:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Directive` 定义了在给定异常下对演员应该做什么：'
- en: '![](img/1761d58a-5690-4282-a2b8-f97dc47c8726.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1761d58a-5690-4282-a2b8-f97dc47c8726.png)'
- en: There are four subclasses to the `Directive` trait. The `Escalate` directive
    escalates the exception to the parent of the supervising actor. So, when the child
    fails, the parent will also fail and will rely on its own parent to handle the
    exception.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Directive` 特质有四个子类。`Escalate` 指令将异常提升到监督演员的父母。因此，当子代失败时，父母也会失败，并将依赖于自己的父母来处理异常。'
- en: '![](img/b6d3f406-a07e-49ab-bdf4-a663bde60bff.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b6d3f406-a07e-49ab-bdf4-a663bde60bff.png)'
- en: 'The `Restart` directive will discard the actor that failed and will create
    a new actor in its place:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Restart` 指令将丢弃失败的演员，并在其位置创建一个新的演员：'
- en: '![](img/699d3e4a-9b5c-4502-97b1-ca92edd3a756.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/699d3e4a-9b5c-4502-97b1-ca92edd3a756.png)'
- en: 'The `Resume` directive will instruct the actor that had an exception to continue
    processing the messages:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`Resume` 指令将指示发生异常的演员继续处理消息：'
- en: '![](img/dd04c5b5-d99c-4a2f-8d86-08b3f6510817.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dd04c5b5-d99c-4a2f-8d86-08b3f6510817.png)'
- en: The exception will be ignored, and no action will be taken to handle it. The
    child actor will continue as it did previously.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 异常将被忽略，并且不会采取任何行动来处理它。子演员将继续像之前一样执行。
- en: Finally, the `Stop` directive will stop the current actor without starting another
    one in its place.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Stop` 指令将停止当前演员，而不会在其位置启动另一个演员。
- en: '![](img/690b5fd8-cbdc-47b2-a035-cf5816285b79.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/690b5fd8-cbdc-47b2-a035-cf5816285b79.png)'
- en: The preceding infrastructure provides you with the capability to construct hierarchies
    where parents are responsible for the sound operation of the children. This approach
    provides a separation of concerns and enables a degree of local reasoning. This
    means that actor systems handle the failures as early as possible instead of propagating
    them up the hierarchy.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的基础设施为你提供了构建层次结构的能力，其中父母负责孩子的正常运行。这种方法提供了关注点的分离，并允许一定程度的地方推理。这意味着演员系统尽可能早地处理失败，而不是将它们传播到层次结构中。
- en: Hierarchies also provide you with a measure of abstraction, because you no longer
    care about the children of a given actor, you can treat a given actor as a single
    point of responsibility for the task that it was asked to do. A single point of
    responsibility is similar to how, in organizations, you have a single person responsible
    for a department, and whenever you need the department to do something, you talk
    to the responsible person. You expect them to run the department properly. Akka
    is built the same way. Whenever you have a concern, you have an actor responsible
    for this concern. It may or may not have child actors that help them work on this
    concern, however, as an outside observer, you do not need to be aware of these
    factors. You do not need to care about the errors that happen to these subordinates.
    This is, of course, only if the errors in question can be localized to a given
    department. If the error is more significant than what the department can handle,
    it propagates up the chain.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 层次结构也为你提供了一种抽象度量的方式，因为你不再关心特定演员的子代，你可以将特定演员视为对其请求执行的任务负责的单一点。单一点的责任类似于在组织中，你有一个单个人负责一个部门，并且每当你需要部门做某事时，你都会与负责人交谈。你期望他们能妥善管理部门。Akka就是以这种方式构建的。无论何时你有疑虑，你都会有一个演员负责这个疑虑。它可能或可能没有子演员来帮助它处理这个疑虑，然而，作为一个外部观察者，你不需要意识到这些因素。你不需要关心这些下属发生的错误。当然，前提是这些错误可以定位到特定的部门。如果错误比部门能处理的更严重，它就会向上传播到链中。
- en: Context and references
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文和参考
- en: 'Apart from the callbacks that give you control over how an actor reacts to
    various life cycle events, an actor has an API for managing the context of its
    execution:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 除了给你控制演员如何响应各种生命周期事件的回调之外，演员还有一个用于管理其执行上下文的 API：
- en: '![](img/40ddd79e-c87b-4272-ba80-9259143b5b82.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/40ddd79e-c87b-4272-ba80-9259143b5b82.png)'
- en: Actors have references to the `ActorRef` of themselves and the sender actor.
    These references are supposed to be accessed from the `receive` method. Through
    them, you can interact with the sender actor, as well as with this actor as with
    `ActorRefs`. This means that you can send messages to these actors, and do other
    things you would usually do as an external observer.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 演员对其自身的 `ActorRef` 和发送者演员有引用。这些引用应该从 `receive` 方法中访问。通过它们，你可以与发送者演员以及作为 `ActorRefs`
    的此演员进行交互。这意味着你可以向这些演员发送消息，并执行通常作为外部观察者会做的事情。
- en: 'Aside from references, an actor has a `context` reference that provides information
    and control over the context of the actor''s execution:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 除了引用之外，演员还有一个 `context` 引用，它提供了关于演员执行上下文的信息和控制：
- en: '![](img/fc9246f3-5227-497f-93f9-fbc0d272072f.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fc9246f3-5227-497f-93f9-fbc0d272072f.png)'
- en: '`ActorContext` provides various APIs that may be useful when handling messages.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActorContext` 提供了在处理消息时可能有用的各种 API。'
- en: Managing the actor hierarchy
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理演员层次结构
- en: 'The central concept for managing actor hierarchies is the `ActorContext` type.
    It is defined as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 管理演员层次结构的核心概念是 `ActorContext` 类型。它定义如下：
- en: '![](img/fc5a0f1c-4894-4143-a1b2-11a3d1f58994.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fc5a0f1c-4894-4143-a1b2-11a3d1f58994.png)'
- en: '`ActorContext` allows you to perform various operations on the actor''s hierarchy.
    For example, you can create new actors with the `actorOf` method which is defined
    as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActorContext` 允许你在演员的层次结构上执行各种操作。例如，你可以使用 `actorOf` 方法创建新的演员，该方法定义如下：'
- en: '![](img/163211b8-7a6f-4932-8721-1c7d1f255821.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/163211b8-7a6f-4932-8721-1c7d1f255821.png)'
- en: So, with `ActorContext`, you can create child actors of this actor. We will
    cover the exact procedure of creating a new actor with the `Props` object a bit
    later when we will be discussing actor systems.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用 `ActorContext`，你可以创建此演员的子演员。我们将在稍后讨论演员系统时详细介绍使用 `Props` 对象创建新演员的确切步骤。
- en: 'The current actor is capable of accessing the child actors it created with
    the `child` and `children` methods:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当前演员能够通过 `child` 和 `children` 方法访问它创建的子演员：
- en: '![](img/53a40c8c-2f71-46df-b2c1-4465d9de6d87.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/53a40c8c-2f71-46df-b2c1-4465d9de6d87.png)'
- en: 'Similarly, you can access the parent actor of this actor:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以访问此演员的父演员：
- en: '![](img/b641a011-3b0a-4f1f-8949-5480b56506b8.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b641a011-3b0a-4f1f-8949-5480b56506b8.png)'
- en: '`ActorSystem` is a collection of actors:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActorSystem` 是演员的集合：'
- en: '![](img/e60a61b8-c8a0-4ec9-bbb1-3c1c9917aafc.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e60a61b8-c8a0-4ec9-bbb1-3c1c9917aafc.png)'
- en: We will cover actor systems later in the *Creating actors* section, but for
    now, you should understand that `ActorSystem` is accessible from `ActorContext`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 *创建演员* 部分稍后讨论演员系统，但就目前而言，你应该了解 `ActorSystem` 可以从 `ActorContext` 访问。
- en: Managing the life cycle
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理生命周期
- en: 'Akka context provides you with various methods for the life cycle management
    of an actor:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Akka 上下文为你提供了管理演员生命周期的各种方法：
- en: '![](img/2c94e188-dc0e-4886-aa96-ec50765e342f.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2c94e188-dc0e-4886-aa96-ec50765e342f.png)'
- en: 'You can stop this or another actor from using `ActorContext`. A widespread
    pattern with actor-based programming is the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以停止此演员或其他演员使用 `ActorContext`。基于演员的编程中的一种常见模式如下：
- en: '[PRE4]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding idiom is often used to terminate actors that have accomplished
    their job and have nothing more to do.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 上述习语通常用于终止已完成工作且没有更多事情要做的演员。
- en: 'Actors can change their behavior. The behavior of an actor is defined by its `receive` method:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 演员可以改变其行为。演员的行为由其 `receive` 方法定义：
- en: '![](img/4620ed59-abf7-46e8-a168-2b7283d58050.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4620ed59-abf7-46e8-a168-2b7283d58050.png)'
- en: However, as part of handling messages, you may want to change the way messages
    are handled by an actor. For this purpose, you can use the `become` method.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，作为处理消息的一部分，你可能想要改变演员处理消息的方式。为此，你可以使用 `become` 方法。
- en: 'An actor remembers past behaviors you have overridden and keeps them in a stack.
    This means that you can call an `unbecome` method to pop the current behavior
    from the stack and use the previous behavior:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 演员会记住你覆盖的过去行为，并将它们保存在堆栈中。这意味着你可以调用 `unbecome` 方法从堆栈中弹出当前行为并使用之前的行为：
- en: '![](img/4c290aa0-49c7-4c81-99fb-6c3ecc692fb0.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4c290aa0-49c7-4c81-99fb-6c3ecc692fb0.png)'
- en: Supervision
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监督
- en: 'An actor can watch another actor for its life cycle events:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一个演员可以监视另一个演员的生命周期事件：
- en: '![](img/79306989-d400-4770-86ff-ef281efec625.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/79306989-d400-4770-86ff-ef281efec625.png)'
- en: Whenever you need this actor to be aware of when another actor terminates, you
    can instruct it to watch that other actor with actor context. When that actor
    terminates, the supervising actor will receive a `Terminated` message. You can
    register a handler of a `Terminated` message the same way you handle any other
    message from the received message.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要此演员意识到另一个演员何时终止时，您可以指示它使用演员上下文来监视那个演员。当那个演员终止时，监督演员将收到一个`Terminated`消息。您可以像处理接收到的任何其他消息一样注册`Terminated`消息的处理程序。
- en: Creating actors
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建演员
- en: 'All of the actors belong to some `ActorSystem`, which is a hierarchy of actors:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的演员都属于某个`ActorSystem`，这是一个演员的层次结构：
- en: '![](img/a72921b6-f7eb-47dc-a80e-516cbd03e19f.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a72921b6-f7eb-47dc-a80e-516cbd03e19f.png)'
- en: 'The most important methods when creating new actors are as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新演员时最重要的方法如下：
- en: '![](img/d90a0218-399b-493a-8722-eae9736f6fbf.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d90a0218-399b-493a-8722-eae9736f6fbf.png)'
- en: 'Every actor is created using an `actorOf` method called over an actor system
    or an actor context. You can create the actor system itself using its companion-object
    API:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 每个演员都是通过在演员系统或演员上下文中调用名为`actorOf`的方法来创建的。您可以使用其伴随者对象API创建演员系统本身：
- en: '![](img/a14197d5-79bb-4316-aad0-4da716b6a298.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a14197d5-79bb-4316-aad0-4da716b6a298.png)'
- en: 'When calling this method, you can specify the name of this system. You can
    also specify the configuration that defines certain aspects of the behavior of
    the actor system. The configuration is a file that is placed under the path specified
    under the `CLASSPATH` environmental variable. `CLASSPATH` is a standard way to
    let a JVM program know where to look for the classes it uses. For example, in
    an SBT project, you can place the configuration under the following path under
    the project root directory: `src/main/resources/application.conf`. In this configuration
    file, we can, for example, disable logging of so-called dead letters—messages
    intended for nonexistent actors:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用此方法时，您可以指定此系统的名称。您还可以指定定义演员系统行为某些方面的配置。配置是一个放置在`CLASSPATH`环境变量指定的路径下的文件。`CLASSPATH`是让JVM程序知道它使用的类所在位置的标准方式。例如，在一个SBT项目中，您可以在项目根目录下的以下路径放置配置文件：`src/main/resources/application.conf`。在这个配置文件中，例如，我们可以禁用所谓的死信的日志记录——为不存在的演员发送的消息：
- en: '[PRE5]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The configuration is quite flexible and grants you a degree of control of how
    your actor system is executed. For more information, please consult the Akka documentation
    on configuration.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 配置非常灵活，并赋予您一定程度的控制权，以确定您的演员系统如何执行。有关更多信息，请参阅Akka关于配置的文档。
- en: You are also able to specify which execution context this `ActorSystem` is going
    to use to run its actors. Just as when we discussed IO, for a concurrency library,
    we need a way to specify what threading strategy the library should use. Finally,
    you can provide a class loader to `ActorSystem`, which will be used for things
    such as resolving configurations. All these parameters are optional. If you do
    not specify one of them, Akka will use reasonable defaults.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以指定`ActorSystem`将要使用哪个执行上下文来运行其演员。正如我们在讨论IO时讨论的那样，对于并发库，我们需要一种方式来指定库应该使用哪种线程策略。最后，您可以为`ActorSystem`提供一个类加载器，它将被用于解析配置等操作。所有这些参数都是可选的。如果您没有指定其中一个，Akka将使用合理的默认值。
- en: 'Now, let''s have a look at how we run our Hello World example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何运行我们的Hello World示例：
- en: '[PRE6]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'First, we create `ActorSystem`. We create a `HelloWorld` actor. We do not call
    its constructor. We do so by using a `Props` object. We specify the class that
    we are going to create in the `Props` type parameters. We also specify the name
    of the actor to be created. `Props` is a case class defined as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建`ActorSystem`。我们创建一个`HelloWorld`演员。我们不调用其构造函数。我们通过使用`Props`对象来这样做。我们在`Props`类型参数中指定我们将要创建的类。我们还指定要创建的演员的名称。`Props`是一个如下定义的案例类：
- en: '![](img/31dba49b-53c3-4c23-ae9a-589db0a2530d.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/31dba49b-53c3-4c23-ae9a-589db0a2530d.png)'
- en: 'Its companion also defines a bunch of convenience methods to create `Props`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 其伴随者还定义了一组方便的方法来创建`Props`：
- en: '![](img/70dfb8dc-8937-441f-be6e-87915eb3ae7a.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/70dfb8dc-8937-441f-be6e-87915eb3ae7a.png)'
- en: After we create an actor with the help of `Props`, we can send a message to
    this actor. We do so with the `!` operator that `ActorRef` defines.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用`Props`的帮助下创建演员后，我们可以向这个演员发送消息。我们使用`ActorRef`定义的`!`运算符来这样做。
- en: Actor parameters
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演员参数
- en: Ordinary classes can have constructors that take arguments that can be used
    to parametrize the resulting instance. In the same way, an alternative version
    of the `Props` factory method can be used to create an actor with constructor
    parameters.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 普通类可以有接受参数的构造函数，这些参数可以用来参数化生成的实例。同样，可以使用`Props`工厂方法的替代版本来创建具有构造函数参数的演员。
- en: 'Imagine we have an actor whose constructor takes arguments:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个演员，其构造函数接受参数：
- en: '[PRE7]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding actor specifies the name of a person it is going to greet when
    it does its output. Also, notice how it accepts a string as a message. This is
    to show that you can send any object as a message to an actor.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的演员指定了它在输出时将要问候的人的名字。同时，注意它如何接受一个字符串作为消息。这是为了表明你可以向演员发送任何对象作为消息。
- en: 'When you have an actor that takes constructor parameters, a standard practice
    is to declare a `Props` factory method as a companion of an actor:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个接受构造函数参数的演员时，一个标准做法是在演员的伴生对象中声明一个`Props`工厂方法：
- en: '[PRE8]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This method abstracts away the `Props` needed to create this actor. Now, you
    can construct this actor and use it as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法抽象掉了创建此演员所需的`Props`。现在，你可以按照以下方式构建此演员并使用它：
- en: '[PRE9]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/b071d3b3-0f7d-4e40-bc2c-208bf3d3a267.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b071d3b3-0f7d-4e40-bc2c-208bf3d3a267.png)'
- en: Working with actor systems
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与演员系统一起工作
- en: The strength of the actor model is that actors are lightweight, which means
    you can use millions of them on a single JVM running on an ordinary computer.
    Most of the time, you are not going to use a single actor but many actors. This
    requires a model to handle multiple actors.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 演员模型的优势在于演员轻量级，这意味着你可以在单个普通计算机上运行的JVM上使用数百万个演员。大多数时候，你不会使用单个演员，而是使用多个演员。这需要一个模型来处理多个演员。
- en: In Akka, actors are organized in hierarchical trees—meaning that every actor
    has a parent and can have multiple children. Next, we will have a look at a slightly
    more complicated example that will showcase how actors work in hierarchies.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在Akka中，演员以分层树的形式组织——这意味着每个演员都有一个父演员，并且可以有多个子演员。接下来，我们将查看一个稍微复杂一点的例子，该例子将展示演员在分层中的工作方式。
- en: Task specification
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务规范
- en: Imagine we need to have multiple actors that all output a greeting to a given
    name to the log. Imagine also that we need to abstract away the fact that there
    are multiple actors in the system from the end user. We are going to do so by
    creating a single supervising actor that is going to be in charge of the execution
    of all its child actors. The child actors will be the actors that output the greeting
    message to the log, and the parent actor will be a manager that represents them.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要有多个演员，它们都将问候消息输出到日志中的给定名字。假设还需要从最终用户那里抽象出系统中存在多个演员的事实。我们将通过创建一个单一的监督演员来实现这一点，该演员将负责执行所有子演员的执行。子演员将是向日志输出问候消息的演员，而父演员将是一个代表他们的管理者。
- en: The protocol is going to be as follows. First, create a `GreetingsManager` actor.
    Then, you are going to send a `SpawnGreeters` message to spawn a number of greeter
    actors parameterized by the number of greeters required. These spawned greeters
    must override the ones we already had. That overriding is done by stopping the
    previous actors and creating new ones.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 协议将如下所示。首先，创建一个`GreetingsManager`演员。然后，你将发送一个`SpawnGreeters`消息来生成所需数量的问候演员。这些生成的问候演员必须覆盖我们已有的演员。这种覆盖是通过停止之前的演员并创建新的演员来完成的。
- en: Next, the user sends a `SayHello` message to the manager actor, which will instruct
    all of its children to perform output to the log. However, in a situation where
    the manager does not have any child actors spawned, we are going to output an
    error that asks the user to spawn the actors first.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，用户向管理演员发送一个`SayHello`消息，这将指示其所有子演员向日志执行输出。然而，在管理演员没有生成任何子演员的情况下，我们将输出一个错误，要求用户首先生成演员。
- en: Implementation
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: 'Let''s start by defining the `Greeter` actor, as it is the simpler one:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义`Greeter`演员开始，因为它更简单：
- en: '[PRE10]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The actor is going to accept a say hello message that is parameterized by the
    name the actor is supposed to greet. On receiving this message, it is going to
    perform a log output.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 演员将接受一个参数化的问候消息，该参数指定演员应该问候的名字。在接收到此消息后，它将执行日志输出。
- en: The `Greeter` actor has the means for the other actors to stop it. We have already
    discussed that one of the requirements of the task is that the manager actor should
    be able to terminate its existing actress to spawn a new actor. This can be accomplished
    by sending a message to this `Greeter` actor.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`Greeter` 角色有其他角色停止它的手段。我们已经讨论过，任务的一个要求是管理角色应该能够终止现有的演员以创建新的演员。这可以通过向这个 `Greeter`
    角色发送消息来实现。'
- en: That message will use the `context stop self` pattern and will report to the
    sender actor that it is dead with the `Dead` message. Note that `context stop
    self` terminates the `self` actor only once it is done processing its current
    message. So the `sender ! Dead` code will be executed once the actor is still
    alive. The actor will terminate after it finishes processing the `Die` message.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 那条消息将使用 `context stop self` 模式，并将使用 `Dead` 消息向发送者角色报告它已经死亡。请注意，`context stop
    self` 只在处理完当前消息后才会终止 `self` 角色一次。因此，`sender ! Dead` 代码将在角色仍然存活时执行。角色将在处理完 `Die`
    消息后终止。
- en: 'We are using case classes as messages to communicate between actors because
    they are convenient for pattern-matching. The entire protocol looks as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用案例类作为消息在角色之间进行通信，因为它们在模式匹配方面很方便。整个协议如下所示：
- en: '[PRE11]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We will introduce every message as we encounter it.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在遇到每个消息时介绍它。
- en: 'Also, notice that Akka has a built-in message that can be used to stop actors. Whenever
    you send `PoisonPill` to an actor, its default behavior is to terminate itself:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意 Akka 有一个内置的消息可以用来停止角色。每次你向一个角色发送 `PoisonPill` 时，它的默认行为是终止自己：
- en: '![](img/ed8d9a2a-d0e7-45a3-acd8-e5908b6203e1.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ed8d9a2a-d0e7-45a3-acd8-e5908b6203e1.png)'
- en: The reason we are not using `PoisonPill` here is that it does not play well
    with the pattern that we are going to use down the line.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不使用 `PoisonPill` 的原因是因为它与我们将要使用的模式不太兼容。
- en: 'Next, let''s start working on the `GreetingsManager` actor:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们开始处理 `GreetingsManager` 角色吧：
- en: '[PRE12]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `receive` method is set to `baseReceive`. The reason we are not defining
    the API the actor exposes directly under `receive` is that we are going to leverage
    the `context become` functionality to change the behavior of the actor. `context
    become` can be used to override the functionality of the receive method. Every
    new behavior is going to be implemented as a separate method inside of this actor,
    for easy switching.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`receive` 方法被设置为 `baseReceive`。我们不直接在 `receive` 下定义角色暴露的 API 的原因是我们打算利用 `context
    become` 功能来改变角色的行为。`context become` 可以用来覆盖 `receive` 方法的功能。每个新的行为都将在这个角色的内部作为单独的方法实现，以便于切换。'
- en: The `baseReceive` method enables the actor to handle two API messages: `SpawnGreeters`
    and `SayHello`. They will manage the underlying greeters and instruct them to
    perform output.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`baseReceive` 方法使角色能够处理两个 API 消息：`SpawnGreeters` 和 `SayHello`。它们将管理底层的问候者并指示它们执行输出。'
- en: Notice that both of these methods follows a pattern. First, they optionally
    perform a log output, after that, they call the `resolveGreeters` method, and
    finally, they use the `context become` pattern to change the behavior of the current
    actor.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这两个方法都遵循一个模式。首先，它们可以选择性地执行日志输出，然后调用 `resolveGreeters` 方法，最后使用 `context become`
    模式来改变当前角色的行为。
- en: The reaction to both of these messages depends on whether or not the `Greeter`
    actors are spawned. If they are not, then in the case of the `SpawnGreeters` message,
    we are going to spawn them as usual. In the case of `SayHello`, we are going to
    output an error that we are not able to operate due to the absence of greeters.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对这两条消息的反应取决于 `Greeter` 角色是否被创建。如果它们没有被创建，那么在 `SpawnGreeters` 消息的情况下，我们将像往常一样创建它们。在
    `SayHello` 的情况下，我们将输出一个错误，因为我们无法操作，因为没有问候者。
- en: If there are child actors, we are going to terminate them all in the case of
    `SpawnGreeter` to create new ones. In case of `SayHello`, we are going to instruct
    the child actors to output the greeting to the log.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有子角色，在 `SpawnGreeter` 的情况下，我们将终止所有子角色以创建新的角色。在 `SayHello` 的情况下，我们将指示子角色将问候输出到日志。
- en: In principle, you can track the state of all of your child actors from a mutable
    variable inside this actor. So, whenever you spawn a child actor, you save the
    references to it to a collection inside of this actor. This way, you will be able
    to quickly check for whether or not we have the child actors defined.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在原则上，你可以从actor内部的可变变量中跟踪所有子actor的状态。因此，每次你创建一个子actor时，你都会将其引用保存到actor内部的集合中。这样，你将能够快速检查我们是否已经定义了子actor。
- en: However, in this example, we are going to explore how to check for child actors
    using the built-in actor-hierarchy-management API.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这个例子中，我们将探讨如何使用内置的actor-hierarchy-management API来检查子actor。
- en: The API is asynchronous and messaging-based. We have discussed already that
    it is crucial for the actors to be non-blocking. They are lightweight concurrency
    primitives, and threads are scarce, hence, to keep actors lightweight, we need
    to make sure that they utilize as little of their threading as necessary. Hence,
    we cannot afford to block on a children's query operation. The strategy is to
    request the children, register listeners to the responses as reactions to actor
    messages, and release the thread the actor is using to execute this strategy.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 该API是异步和基于消息的。我们已经讨论过，对于actor来说，非阻塞至关重要。它们是轻量级的并发原语，线程稀缺，因此，为了保持actor轻量级，我们需要确保它们尽可能少地使用线程。因此，我们不能在子查询操作上阻塞。策略是请求子actor，注册监听器以作为actor消息的反应来响应，并释放actor正在使用的线程来执行此策略。
- en: This strategy is what you see in the `baseReceive` example. The `resolveGreeters`
    method initiates the children resolution, and the results are going to arrive
    at the actor back as a message. We are going to change the `receive` implementation
    of this actor to handle this message.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略就是你在`baseReceive`示例中看到的内容。`resolveGreeters`方法启动了子actor的解析，结果将以消息的形式返回给actor。我们将改变此actor的`receive`实现以处理此消息。
- en: Once the appropriate response arrives, these new behaviors will perform the
    requested functionality. We have separate behaviors for the `SpawnGreeters` and
    `SayHello` messages. Notice also that we parametrize these behaviors by the original
    sender of the current message and the data they provide. So, we will be able to
    execute the response request when we are ready, as well as notify the requester
    of the successful execution of this request.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦收到适当的响应，这些新行为将执行请求的功能。我们为`SpawnGreeters`和`SayHello`消息分别设置了不同的行为。注意，我们还通过当前消息的原始发送者和他们提供的数据来参数化这些行为。因此，当我们准备好时，我们将能够执行响应请求，并通知请求者此请求的成功执行。
- en: 'Let''s have a look at how the `resolveGreeters` function is implemented:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`resolveGreeters`函数是如何实现的：
- en: '[PRE13]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `actorSelection` API is documented as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`actorSelection` API的文档如下：'
- en: '![](img/b8f4b986-83a2-40b3-b4b5-415ff57a0cd5.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b8f4b986-83a2-40b3-b4b5-415ff57a0cd5.png)'
- en: 'In Akka, every actor has a name and a chain of parent actors it belongs to.
    Every actor also has a name. This allows you to identify actors by a path to them.
    For example, let''s have a look again at the output of our hello world application:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在Akka中，每个actor都有一个名称和它所属的父actor链。每个actor也有一个名称。这允许你通过它们的路径来识别actor。例如，让我们再次看看我们的hello
    world应用程序的输出：
- en: '![](img/043dba65-e46f-47c1-b428-3b9701d07526.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/043dba65-e46f-47c1-b428-3b9701d07526.png)'
- en: 'The log provides a path to the current actor in square brackets:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 日志提供了当前actor的路径，用方括号括起来：
- en: '[PRE14]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In Akka, it is possible to query actors by their path. It is possible to query
    entire slices of actors and send messages to entire collections of actors.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在Akka中，你可以通过它们的路径来查询actor。你可以查询actor的整个切片，并向actor的整个集合发送消息。
- en: So, the actor selection function is a function that accepts a path to the actor
    that can include wildcards to query lots of actors at the same time, and it will
    return an actor selection under a Future.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，actor选择函数是一个接受actor路径的函数，该路径可以包含通配符以同时查询多个actor，并且它将在Future下返回actor选择。
- en: Actor-selection provides you with some of the capabilities you would have on
    an ordinary `ActorRef`. However, for the `resolveGreeters` function, our objective
    is to check whether the greeters exist at all. This can be done by calling a `resolveOne`
    function and observing whether it returns a successful Future or a failed Future.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Actor选择为你提供了在普通`ActorRef`上的一些能力。然而，对于`resolveGreeters`函数，我们的目标是检查greeters是否存在。这可以通过调用`resolveOne`函数并观察它是否返回成功的Future或失败的Future来实现。
- en: '`resolveOne` takes the timeout as an argument and produces a Future that is
    going to result in a random actor from the collection of actors you are selecting.
    If the selection is empty, it is going to fail.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`resolveOne` 方法接受超时作为参数，并生成一个将导致从你选择的演员集合中随机选择一个演员的 Future。如果选择为空，它将失败。'
- en: 'After that, we have an Akka pattern for Future interoperability. The pattern
    is called the pipe pattern, and in our example, it follows some transformations
    of the Future we are going to ignore for a moment:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们有一个 Akka 的 Future 互操作模式。这个模式被称为管道模式，在我们的例子中，它遵循我们将暂时忽略的 Future 的某些转换：
- en: '[PRE15]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `pipeTo` method is available on actor references via a Rich Wrapper:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`pipeTo` 方法通过 Rich Wrapper 可在演员引用上使用：'
- en: '![](img/2710b86f-8d7c-422a-8eea-e3535bb87bbf.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2710b86f-8d7c-422a-8eea-e3535bb87bbf.png)'
- en: 'The API it injects is as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 它注入的 API 如下所示：
- en: '![](img/762c1a4d-e518-4794-9ca9-a0982c4fbfc6.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/762c1a4d-e518-4794-9ca9-a0982c4fbfc6.png)'
- en: As we have discussed already, it is an anti-pattern to call a Future from an
    actor. Whenever you have an asynchronous computation that this actor depends upon,
    you need to make sure that this computation sends a message to this actor upon
    termination, and defines how to handle the message from the actor. Akka defines
    such a pattern for futures—the pipe pattern. The pattern makes sure that the message
    will be sent to a given actor upon future completion.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所讨论的，从一个演员中调用 Future 是一种反模式。每当这个演员依赖于异步计算时，你需要确保这个计算在终止时向这个演员发送消息，并定义如何处理来自演员的消息。Akka
    为 Future 定义了这样一个模式——管道模式。这个模式确保在 Future 完成后，消息将被发送到指定的演员。
- en: In our example, we request the `actorSelection` results and schedule a message
    with the results of this resolution to be sent to the current actor.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们请求 `actorSelection` 的结果，并安排一个带有此解析结果的消息发送到当前演员。
- en: 'The transformations we are doing before the pattern are required to make sure
    that the failed future also sends a message to the current actor:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在模式之前进行的转换是必要的，以确保失败的 Future 也会向当前演员发送消息：
- en: '[PRE16]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Finally, we use the map method to wrap the result of this future into a message
    that we want to send to the actor.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 map 方法将这个 Future 的结果封装成我们想要发送给演员的消息。
- en: 'Let''s have a look at how `actorSelection` works in practice with a small example.
    Consider the following case clause added to the base handler:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个小示例来看看 `actorSelection` 在实际中的工作方式。考虑以下添加到基本处理器的案例子句：
- en: '[PRE17]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Our actor manager is now capable of receiving a `resolve` string as a message,
    upon which it will perform an actor-selection of all the current greeters and
    put the results into the log.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的演员管理器能够接收一个 `resolve` 字符串作为消息，在此之后，它将对所有当前问候者进行演员选择并将结果放入日志中。
- en: 'We can run the resolution as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下运行解析：
- en: '[PRE18]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We are working under the Future Monadic flow here. This is because, on some
    occasions, we are going to wait on the response of an actor system before we proceed.
    Let's have a look at the example line by line.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用 Future Monadic 流程。这是因为，在某些情况下，在继续之前，我们将等待演员系统的响应。让我们逐行查看示例。
- en: 'First, we have a `resolve` message sent to the current actor:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们向当前演员发送一个 `resolve` 消息：
- en: '[PRE19]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `?` operator is injected by the following Rich Wrapper in Akka.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`?` 操作符是由 Akka 中的以下 Rich Wrapper 注入的。'
- en: '[PRE20]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we have an ask pattern:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个 ask 模式：
- en: '![](img/c703fcdb-3913-4a96-8838-881beec0721f.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c703fcdb-3913-4a96-8838-881beec0721f.png)'
- en: 'Here is the API it injects:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是它注入的 API：
- en: '![](img/34897b3c-0519-4d02-ab28-482b6f96c686.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/34897b3c-0519-4d02-ab28-482b6f96c686.png)'
- en: The pattern sends a message to an actor reference, just like the ordinary `!`
    operator. However, it also expects the actor to respond to the current actor.
    The response message is returned under a Future. Under the hood, this ask method
    creates a temporary child actor that actually sends the message to the original
    addressee. If the addressee responds to this temporary actor, the response will
    be available as the Future's result.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式向一个演员引用发送消息，就像普通的 `!` 操作符一样。然而，它还期望演员对当前演员做出响应。响应消息在 Future 下返回。在底层，这个 ask
    方法创建了一个临时子演员，实际上是将消息发送给原始收件人。如果收件人响应这个临时演员，响应将作为 Future 的结果可用。
- en: 'We are using the ask pattern because we want to suspend the execution of the
    example until the manager reports that the actors were successfully created. The
    first line of this example models a case where the greeting manager had no child
    actors. With the second line, we create the child actors and wait until they are
    created. The next line will test how actor-selection works against a non-empty
    selection:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用ask模式，因为我们希望暂停示例的执行，直到管理者报告演员已成功创建。这个示例的第一行模拟了问候管理器没有子演员的情况。在第二行，我们创建子演员并等待它们被创建。下一行将测试如何对非空选择进行演员选择：
- en: '[PRE21]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'With this line, we are sending 10 resolve messages to the greeting manager.
    The result of the execution of the program is as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行，我们向问候管理器发送了10个解决消息。程序执行的输出结果如下：
- en: '![](img/c82a8925-cb91-4fea-9de4-86d3dfc010c5.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c82a8925-cb91-4fea-9de4-86d3dfc010c5.png)'
- en: The result is nondeterministic. This means that every time we send a message
    to the actor, we are not sure which actor will be returned. Notice how, at first,
    the greeter with ID `6` is returned, and on subsequent invocations, the greeter
    with ID `1` is returned.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是非确定性的。这意味着每次我们向演员发送消息时，我们都不确定哪个演员会被返回。注意，最初返回的是ID为`6`的问候者，而在后续调用中，返回的是ID为`1`的问候者。
- en: 'Let''s now have a look at how this pattern plays with the rest of the application.
    Let''s explore the `SayHello` message-handling example first. After calling `resolveGreeters`,
    we use the `context become` pattern to change the way the actor handles messages
    and set a new `receive` function to `sayingHello`. Let''s have a look at how `sayingHello`
    is defined:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个模式如何与应用程序的其他部分协同工作。首先，让我们探索`SayHello`消息处理示例。在调用`resolveGreeters`之后，我们使用`context
    become`模式来改变演员处理消息的方式，并将新的`receive`函数设置为`sayingHello`。让我们看看`sayingHello`是如何定义的：
- en: '[PRE22]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`sayingHello` is going to react on the `GreeterResolution` message. This is
    precisely the message we are sending from the result of the `Greeter` functions
    we just discussed. The message has the following definition:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`sayingHello`将响应`GreeterResolution`消息。这正是我们从刚才讨论的`Greeter`函数的结果中发送的消息。该消息的定义如下：'
- en: '[PRE23]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'So we have two cases of the payload of that message—the success and failure.
    We have a failure in which there are no greeters registered:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，该消息的有效负载有两种情况——成功和失败。我们有一个没有注册问候者的失败情况：
- en: '[PRE24]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this case, we log an error saying that there are no greeters. We then switch
    the actor''s receive logic back to base and report to the original requester that
    the job is done, so that it is aware that the actor system has finished processing
    its request, in case the requester needs to wait upon such an event:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们记录一个错误，说明没有问候者。然后，我们将演员的接收逻辑切换回基本状态，并向原始请求者报告工作已完成，以便它知道演员系统已经完成了对请求的处理，以防请求者需要等待此类事件：
- en: '[PRE25]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the case of a successful resolution of greeters, we select the greeters using
    actor-selection logic and send the message to this selection. Finally, we switch
    back to base-handling logic and report to the requester that the job is done.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在问候者成功解决的情况下，我们使用演员选择逻辑选择问候者，并将消息发送到这个选择。最后，我们将回到基本处理逻辑，并向请求者报告工作已完成。
- en: 'Now, let''s have a look at how the spawning greeters logic works:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看孵化问候者的逻辑是如何工作的：
- en: '[PRE26]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The method takes a requester actor and the number of greeters to create. Let''s
    have a look at the message handlers:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法需要一个请求者演员和要创建的问候者数量。让我们看看消息处理器：
- en: '[PRE27]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If there are no children registered, we send a `GreetersCreationAuthorised`
    message to ourselves specifying that it is safe to create greeters. We need this
    authorization because sometimes it is not safe to create new greeters—namely when
    the current actor has old greeters still alive. In this case, we can have naming
    conflicts we want to avoid:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有注册子演员，我们向自己发送一个`GreetersCreationAuthorised`消息，指定创建问候者是安全的。我们需要这种授权，因为有时创建新的问候者并不安全——即当当前演员仍有旧的问候者存活时。在这种情况下，我们可能会遇到我们想要避免的命名冲突：
- en: '[PRE28]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In case the resolution was successful, we must kill this actor''s greeters
    first. We output a warning message to that log specifying that we are going to
    kill the existing greeters. After that, we obtain the children from the actor
    context. `children` provides us with an iterator of all the children of this actor.
    We are then going to filter the actors by name with a regular expression:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果解决结果是成功的，我们必须首先杀死这个演员的问候者。我们向日志输出一条警告消息，指定我们将要杀死现有的问候者。之后，我们从演员上下文中获取子代。"children"为我们提供了这个演员所有子代的迭代器。然后我们将使用正则表达式按名称过滤演员：
- en: '[PRE29]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Above, `raw` is needed so that `\` is not treated as an escape character, but
    is interpreted literally. `r` turns the string it is called on into a regular
    expression object – this API is a part of Scala Core library. `unapplySeq` attempts
    to match the regex it is called on against the string passed to it as an argument.
    If the match succeeds, the method returns `Some`, otherwise –  `None`. See Scala
    Core API on `scala.util.matching.Regex` for more information.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，`raw`是必需的，这样`\`就不会被视为转义字符，而是按字面意思解释。"r"将调用它的字符串转换为正则表达式对象——这个API是Scala核心库的一部分。"unapplySeq"尝试将其调用的正则表达式与作为参数传递给它的字符串进行匹配。如果匹配成功，该方法返回`Some`，否则返回`None`。有关更多信息，请参阅`scala.util.matching.Regex`的Scala核心API。
- en: In case we have any other children, only the greeters that follow a specific
    naming convention will get selected. We do not have any other children in this
    example. However, it is still a good idea to identify the target children.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还有其他子代，只有遵循特定命名约定的问候者会被选中。在这个例子中，我们没有其他子代。然而，仍然是一个好主意来识别目标子代。
- en: 'After we have filtered the actors to kill, we send them a termination message:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们过滤出要杀死的演员后，我们向他们发送终止消息：
- en: '[PRE30]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We are using the ask pattern again in the body of the `traverse` method to produce
    a Future. The greeter actors will respond with a message reporting that they were
    terminated. This allows us to block the execution asynchronously and continue
    once all the greeters are dead. We can achieve this by using the ask pattern to
    track the termination of individual actors, then combine the returned Futures
    into one Future with the `traverse` method. This Future will succeed once all
    of the actors are terminated.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`traverse`方法的主体中再次使用ask模式来产生一个Future。问候者演员将响应一条消息，报告他们已被终止。这允许我们异步阻塞执行，一旦所有问候者都死亡，再继续。我们可以通过使用ask模式跟踪单个演员的终止，然后使用`traverse`方法将返回的Futures组合成一个Future来实现这一点。一旦所有演员都终止，这个Future将成功。
- en: 'Finally, we wrap the Future''s contents into the `GreetersTerminated` message.
    Next, let''s look at the `GreetersTerminated` branch:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将Future的内容包装到`GreetersTerminated`消息中。接下来，让我们看看`GreetersTerminated`分支：
- en: '[PRE31]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We output the report of the termination to the log and send the authorization
    message to `self` to begin the greeters'' creation process:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将终止报告输出到日志，并发送授权消息到`self`以开始创建问候者的过程：
- en: '[PRE32]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`GreetersCreationAuthorised` is a branch that will only be executed once it
    is safe to create new greeters. It will create new greeters from a loop:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`GreetersCreationAuthorised`是一个分支，只有当创建新的问候者是安全的时候才会执行。它将从循环中创建新的问候者：'
- en: '[PRE33]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here, the second argument to `actorOf` is defined as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`actorOf`的第二个参数定义如下：
- en: '[PRE34]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, we notify the requesting actor that the job of creating the greeters
    is completed. Finally, we switch the context back to `baseReceive`. Now, let''s
    write a test program to see how the example works:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通知请求者创建问候者的工作已完成。最后，我们将上下文切换回`baseReceive`。现在，让我们编写一个测试程序来看看示例是如何工作的：
- en: '[PRE35]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We first send a hello message to an empty greeter manager. Then, we spawn the
    greeters with a corresponding message. Then we send the `SpawnGreeters` message once
    more, to see how the greeters manager will first kill its existing greeters and
    only then spawn the new ones. Finally, we send the `SayHello` message again.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先向一个空的问候者管理器发送一条问候消息。然后，我们用相应的消息生成问候者。然后我们再次发送`SpawnGreeters`消息，看看问候者管理器将首先杀死现有的问候者，然后才生成新的问候者。最后，我们再次发送`SayHello`消息。
- en: We have two messages and two possible states of the manager's children greeters.
    This gives us four possible combinations. Every one of the messages in the example
    checks the behavior of each of these cases. Notice, how we are using the ask pattern
    to block the execution flow asynchronously until the actor responds that it has
    completed the operation. This makes sure that we do not send messages too early.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个消息和两个可能的状态，即管理者的孩子问候者的可能状态。这给我们提供了四种可能的组合。示例中的每条消息都检查这些情况中每一个的行为。注意，我们是如何使用询问模式来异步阻塞执行流程，直到演员响应已完成操作。这确保了我们不会过早地发送消息。
- en: 'The output of the message looks as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 消息的输出如下所示：
- en: '![](img/e79ee941-80c6-459d-9a3e-26d3ece93739.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e79ee941-80c6-459d-9a3e-26d3ece93739.png)'
- en: Summary
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the Akka framework, which is a de-facto standard
    for actor-oriented programming in Scala. We have learnt how to create new actors,
    how to define them, and how to run an actor-based application. We saw how actors
    are organized into actor systems, and how they work together in hierarchies. Also,
    we briefly discussed the patterns that Akka provides for working with actors and
    futures.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Akka框架，它是Scala中面向演员编程的事实标准。我们学习了如何创建新的演员，如何定义它们，以及如何运行基于演员的应用程序。我们看到了演员是如何组织成演员系统，以及它们如何在层次结构中协同工作的。此外，我们还简要讨论了Akka为与演员和未来对象一起工作提供的模式。
- en: In the next chapter, we will see the usage of the actors model in practice by
    looking at an example application implemented with this model.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过查看使用此模型实现的示例应用程序，来了解演员模型在实际中的应用。
- en: Questions
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the principles of the Actor model in Akka's implementation?
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Akka实现中的演员模型原则是什么？
- en: How do you define an actor in Akka?
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在Akka中定义一个演员？
- en: How do you create a new actor?
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何创建一个新的演员？
- en: How do you send a message to an actor?
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何向演员发送消息？
- en: What is the ask pattern and how do you use it?
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 询问模式是什么？你如何使用它？
- en: What is the pipe pattern and how do you use it?
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管道模式是什么？你如何使用它？
