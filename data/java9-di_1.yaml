- en: Why Dependency Injection?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么需要依赖注入？
- en: In software development, very often someone else might already have found effective
    solutions to the problems you are facing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，非常常见的情况是，其他人可能已经找到了解决你所面临问题的有效解决方案。
- en: 'As a developer, you don''t need to reinvent the wheel every time. Instead,
    you need to refer to the well-established practices and methodologies. Have you
    guessed what we are talking about? That''s correct: *design* *p**atterns*.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名开发者，你不需要每次都重新发明轮子。相反，你需要参考已经建立起来的实践和方法。你猜到了我们在谈论什么吗？没错：*设计* *模* *式*。
- en: 'This chapter is crafted to cover the following interesting topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在涵盖以下有趣的主题：
- en: What design patterns are and their benefits
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计模式是什么以及它们的益处
- en: '**Dependency Injection Principle** (**DIP**)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖注入原则**（**DIP**）'
- en: '**Inversion of Control** (**IoC**)—a design methodology to implement DIP'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制反转**（**IoC**）——一种实现DIP的设计方法'
- en: Various design patterns to implement IoC
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现IoC的各种设计模式
- en: '**Dependency Injection** (**DI**)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖注入**（**DI**）'
- en: Various types to implement DI
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现DI的多种方式
- en: How an IoC container is helpful to apply a DI
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用IoC容器来应用DI
- en: Design patterns
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式
- en: By definition, a **design pattern** is a set of proven de facto industry standards
    and best practices for resolving recurring problems. Design patterns are not ready-made
    solutions. Rather, they're a way or template to implement and apply the best possible
    solution for your problem.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，**设计模式**是一套经过验证的事实上的行业标准最佳实践，用于解决重复出现的问题。设计模式不是现成的解决方案。相反，它们是实现和运用最佳解决方案的方式或模板，以解决你的问题。
- en: It's equally true that if a design pattern is not implemented in the right way,
    it creates a lot of problems rather than solving the one you expected to solve.
    So it's very important to know which design pattern, if any, is right for a specific
    scenario.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 同样真实的是，如果一个设计模式没有正确实现，它可能会造成很多问题，而不是解决你期望解决的问题。因此，了解哪种设计模式（如果有的话）适合特定场景非常重要。
- en: Design patterns are a common paradigm to describe the problem and how to solve
    it. It's usually not language specific. Design patterns can protect you from the
    design problems that generally occur in the later stages of development.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是描述问题和解决方法的通用范式。它通常不是语言特定的。设计模式可以保护你免受开发后期通常出现的设计问题。
- en: 'There are numerous advantages to using design patterns, as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用设计模式有许多优势，如下所示：
- en: Improves software reusability
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高软件的可重用性
- en: Development cycle becomes faster
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发周期变得更快
- en: Makes the code more readable and maintainable
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使代码更易于阅读和维护
- en: Increases the efficiency and enhances the overall software development
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高效率和增强整体软件开发
- en: Provides common vocabulary to describe problems and best possible solutions
    in a more abstract way
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了描述问题和最佳解决方案的通用词汇，以更抽象的方式
- en: And you can count many more. In the following sections, we will gain a deep
    understanding of how to make your code modular, loosely coupled, independent,
    testable, and maintainable, by following certain principles and patterns.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以数出更多。在接下来的章节中，我们将深入了解如何通过遵循某些原则和模式，使你的代码模块化、松散耦合、独立、可测试和可维护。
- en: This chapter will cover in-depth ideas about the **Dependency Inversion Principle**
    (**DIP**), the Inversion of Control paradigm, and DI design pattern.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将深入探讨关于**依赖倒置原则**（**DIP**）、控制反转范式和DI设计模式的理念。
- en: Most developers use the terms *design principle* and *design pattern* interchangeably,
    even though there is a difference between them.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发者将*设计原则*和*设计模式*这两个术语互换使用，尽管它们之间是有区别的。
- en: '**Design principle**: Generically, this is a guideline about what is the right
    way and what is the wrong way to design your application. Design principles always
    talk about what to do instead of how to do it.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**设计原则**：一般来说，这是一条关于如何正确和错误地设计你的应用的指南。设计原则总是谈论应该做什么，而不是如何做。'
- en: '**Design patterns**: A generic and reusable solution for commonly occurring
    problems. Design patterns talk about how to solve the problems in a given software
    design context by providing clear methodologies.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**设计模式**：针对常见问题的通用和可重用解决方案。设计模式讨论的是如何在给定的软件设计环境中通过提供清晰的方法论来解决这些问题。'
- en: The first step towards making your code cleaner, readable, decoupled, maintainable,
    and modular is to learn the design principle called **DIP**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使你的代码更干净、可读、解耦、可维护和模块化的第一步是学习被称为**DIP**的设计原则。
- en: Dependency Inversion Principle
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖倒置原则
- en: 'DIP provides high-level guidance to make your code loosely coupled. It says
    the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: DIP为你的代码提供高级指导，以使其松散耦合。它说以下内容：
- en: High-level modules should not depend on low-level modules for their responsibilities.
    Both should depend on abstractions.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级模块不应该依赖于低级模块来执行其责任。两者都应该依赖于抽象。
- en: Abstractions should not depend on details. Details should depend on abstractions.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象不应该依赖于细节。细节应该依赖于抽象。
- en: Changes are always risky when they're made in dependent code. DIP talks about
    keeping a chunk of code (dependency) away from the main program to which it is
    not directly related.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当在依赖代码中进行更改时，变化总是有风险的。DIP讨论的是将一块代码（依赖）与它不直接相关的程序主体隔离开来。
- en: To reduce the coupling, DIP suggests eliminating the direct dependency of low-level
    modules on high-level modules to perform their responsibilities. Instead, make
    the high-level module rely on abstraction (a contract) that forms the generic
    low-level behavior.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少耦合，DIP建议消除低级模块对高级模块的直接依赖以执行其责任。相反，让高级模块依赖于抽象（一个合同），它形成了通用的低级行为。
- en: This way, the actual implementation of low-level modules can be changed without
    making any changes in high-level modules. This produces great flexibility and
    molecularity in the system. As far as any low-level implementation is bound to
    abstraction, high-level modules can invoke it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，低级模块的实际实现可以改变，而无需在高级模块中进行任何更改。这为系统带来了极大的灵活性和分子性。只要任何低级实现都绑定在抽象上，高级模块就可以调用它。
- en: Let's have a look at a sample suboptimal design where we can apply DIP to improve
    the structure of the application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例次优设计，在这个设计中我们可以应用DIP来改进应用程序的结构。
- en: 'Consider a scenario where you are designing a module that simply generates
    balance sheets for a local store. You are fetching data from a database, processing
    it with complex business logic, and exporting it into HTML format. If you design
    this in a procedural way, then the flow of the system would be something like
    the following diagram:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个场景，你正在设计一个模块，该模块仅生成本地商店的资产负债表。你从数据库中获取数据，使用复杂的业务逻辑进行处理，并将其导出为HTML格式。如果你以程序化的方式设计它，那么系统的流程将类似于以下图示：
- en: '![](img/00005.gif)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00005.gif)'
- en: 'A single module takes care of fetching data, applying business logic to generate
    balance sheet data, and exporting it into HTML format. This is not the best design.
    Let''s separate the whole functionality into three different modules, as shown
    in the following diagram:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单独的模块负责获取数据，应用业务逻辑以生成资产负债表数据，并将其导出为HTML格式。这不是最佳设计。让我们将整个功能分成三个不同的模块，如图所示：
- en: '![](img/00006.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00006.jpeg)'
- en: '**Fetch Database Module :** This will fetch data from a database'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取数据库模块：** 这将从数据库中获取数据'
- en: '**Export HTML Module: ** This will export the data in HTML'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导出HTML模块：** 这将导出HTML格式的数据'
- en: '**Balance Sheet Module:** This will take data from a database module, process
    it, and give it to the export module to export it in HTML'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资产负债表模块：** 这将从数据库模块获取数据，处理它，并将其交给导出模块以导出为HTML'
- en: In this case, the balance sheet module is a high-level module, and fetch database and
    export HTML are low-level modules.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，资产负债表模块是一个高级模块，而获取数据库和导出HTML是低级模块。
- en: 'The code of the `FetchDatabase` moduleshould look something like the following
    snippet:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`FetchDatabase`模块的代码应该看起来像以下片段：'
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `ExportHTML` module will take the list of data and export it into HTML
    file format. The code should look as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExportHTML`模块将获取数据列表并将其导出为HTML文件格式。代码应该如下所示：'
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The code for our parent module—the `BalanceSheet` module that takes the data
    from the fetch database module and sends to the export HTML module—should look
    as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们父模块——从获取数据库模块获取数据并发送到导出HTML模块的`BalanceSheet`模块——的代码应该如下所示：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: At first glance, this design looks good, as we separated the responsibilities
    of fetching and exporting the data into individual child modules. Good design
    can accommodate any future changes without breaking the system. Will this design
    make our system fragile in case of any future changes? Let us have a look at that.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，这个设计看起来不错，因为我们已经将获取和导出数据的责任分离到单独的子模块中。好的设计可以适应任何未来的变化而不会破坏系统。这个设计在未来的任何变化中会不会使我们的系统变得脆弱呢？让我们来看看。
- en: 'After some time, you need to fetch the data from external web services along
    with the database. Also, you need to export the data in PDF format rather than
    HTML format. To incorporate this change, you will create new classes/modules to
    fetch data from web services and to export the PDF as per the following snippet:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一段时间，您需要从外部网络服务以及数据库中获取数据。此外，您需要将数据导出为 PDF 格式而不是 HTML 格式。为了实现这一变化，您将创建新的类/模块来从网络服务获取数据，并按照以下代码片段导出
    PDF：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To accommodate the new ways of fetching and exporting data, the balance sheet
    module needs some sort of flag. Based on the value of this flag, the respective
    child module will be instantiated in the balance sheet module. The updated code
    of the `BalanceSheet` module would be as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应新的获取和导出数据的方式，资产负债表模块需要某种形式的标志。根据该标志的值，相应的子模块将在资产负债表模块中实例化。`BalanceSheet`
    模块的更新代码如下：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Great work! Our application is able to handle two different input and output
    methods to generate balance sheets. But wait a minute; what happens when you need
    to add more  methods (fetch and export data) in the future? For example, you might
    need to fetch the data from google drive and export the balance sheet in Excel
    format.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 伟大的工作！我们的应用程序能够处理两种不同的输入和输出方法来生成资产负债表。但是等等；当你未来需要添加更多方法（获取和导出数据）时会发生什么？例如，你可能需要从谷歌驱动器获取数据并将资产负债表导出为
    Excel 格式。
- en: 'For every new method of input and output, you need to update your main module,
    the balance sheet module. When a module is dependent on another concrete implementation,
    it''s said to be tightly coupled on that. This breaks the fundamental principle:
    open for extension but closed for modification.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个新的输入和输出方法，您需要更新您的主体模块，即资产负债表模块。当一个模块依赖于另一个具体实现时，它在该模块上被认为是紧密耦合的。这违反了基本原则：对扩展开放，但对修改封闭。
- en: 'Let''s recall what DIP talks about: high-level modules should not depend on
    low-level modules for their responsibilities. Both should depend on abstractions.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下 DIP 讨论的内容：高级模块不应依赖于低级模块来履行其职责。两者都应依赖于抽象。
- en: This is the fundamental problem in our design. In our case, the balance sheet (high-level)
    module tightly depends on fetch database and export HTML data (low-level) modules.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们设计中的基本问题。在我们的案例中，资产负债表（高级）模块紧密依赖于获取数据库和导出 HTML 数据（低级）模块。
- en: As we have seen, principles always show the solution to design problems. It
    doesn't talk about how to implement it. In our case, DIP talks about removing
    the tight dependency of low-level modules on high-level modules.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，原则总是显示设计问题的解决方案。它不讨论如何实现它。在我们的案例中，DIP 讨论的是消除低级模块对高级模块的紧密依赖。
- en: But how do we do that? This is where IoC comes into the picture. IoC shows a
    way of defining abstraction between modules. In short, IoC is the way to implement
    DIP.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何做到这一点？这就是 IoC 出现的地方。IoC 展示了在模块之间定义抽象的方法。简而言之，IoC 是实现 DIP 的方式。
- en: Inversion of Control
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制反转
- en: IoC is a design methodology used to build a loosely coupled system in software
    engineering by inverting the control of flow from your main program to some other
    entity or framework.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: IoC 是一种设计方法，用于通过将控制流从主程序反转到某个其他实体或框架来构建软件工程中的松耦合系统。
- en: Here, the control refers to any additional activities a program is handling
    other than its main activities, such as creating and maintaining the dependency
    objects, managing the application flow, and so on.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，控制指的是程序除了其主要活动之外处理的任何其他活动，例如创建和维护依赖对象、管理应用程序流程等。
- en: Unlike procedural programming style, where a program handles multiple unrelated
    things all together, IoC defines a guideline where you need to break the main
    program in multiple independent programs (modules) based on responsibility and
    arrange them in such a way that they are loosely coupled.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与过程式编程风格不同，其中程序一次性处理多个不相关的事物，IoC 定义了一个指导方针，即您需要根据责任将主程序分解为多个独立的程序（模块），并以一种方式安排它们，使它们松耦合。
- en: In our example, we break the functionality into separate modules. The missing
    part was how to arrange them to make them decoupled, and we will learn how IoC
    makes that arrangement. By inverting (changing) the control, your application
    becomes decoupled, testable, extensible, and maintainable.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将功能分解为独立的模块。缺失的部分是如何安排它们以实现解耦，我们将学习 IoC 如何实现这种安排。通过反转（改变）控制，您的应用程序变得解耦、可测试、可扩展和可维护。
- en: Implementing DIP through IoC
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 IoC 实现DIP
- en: DIP suggests that high-level modules should not depend on low-level modules.
    Both should depend on abstraction. IoC provides a way to achieve the abstraction
    between high-level and low-level modules.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: DIP建议高级模块不应依赖于低级模块。两者都应依赖于抽象。IoC提供了一种在高级模块和低级模块之间实现抽象的方法。
- en: Let's see how we can apply DIP through IoC on our Balance Sheet example. The
    fundamental design problem is that high-level modules (balance sheet) tightly
    depend on low-level (fetch and export data) modules.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在我们的资产负债表示例中通过IoC应用DIP。基本的设计问题是高级模块（资产负债表）紧密依赖于低级（获取和导出数据）模块。
- en: 'Our goal is to break this dependency. To achieve this, IoC suggests inverting
    the control. In IoC, inverting the control can be achieved in the following ways:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是打破这种依赖。为了实现这一点，IoC建议反转控制。在IoC中，反转控制可以通过以下方式实现：
- en: '**Inverting the interface**: Make sure the high-level module defines the interface,
    and low-level modules follow it'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反转接口**：确保高级模块定义接口，而低级模块遵循它'
- en: '**Inverting object creation**: Change the creation of dependency from your
    main modules to some other program or framework'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反转对象创建**：将依赖关系从主模块更改为其他程序或框架'
- en: '**Inverting flow**: Change the flow of application'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反转流程**：改变应用程序的流程'
- en: Inverting the interface
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反转接口
- en: Inverting the interface means inverting the interaction control from low-level
    modules to high-level modules. Your high-level module should decide which low-level
    modules can interact with it, rather than keep changing itself to integrate each
    new low-level module.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 反转接口意味着将交互控制从低级模块反转到高级模块。您的高级模块应该决定哪些低级模块可以与之交互，而不是不断改变自己以集成每个新的低级模块。
- en: 'After inverting the interface, our design would be as per the following diagram:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在反转接口后，我们的设计将如下所示：
- en: '![](img/00007.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00007.jpeg)'
- en: In this design, the balance sheet module (high-level) is interacting with fetch
    data and export data (low-level) modules with common interface. The very clear
    benefits of this design are that you can add new fetch data and export data (low-level)
    modules without changing anything on the balance sheet module (high-level).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个设计中，资产负债表模块（高级）通过通用接口与获取数据和导出数据（低级）模块进行交互。这种设计的明显好处是，您可以在不更改资产负债表模块（高级）的情况下添加新的获取数据和导出数据（低级）模块。
- en: As far as low-level modules are compatible with the interface, the high-level
    modules will be happy to work with it. With this new design, high-level modules
    are not dependent on low-level modules, and both are interacting through an abstraction
    (interface). Separating the interface from the implementation is a prerequisite
    to achieve DIP.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 只要低级模块与接口兼容，高级模块就会很高兴与之合作。在这个新设计中，高级模块不依赖于低级模块，两者都通过抽象（接口）进行交互。将接口与实现分离是实现DIP的前提条件。
- en: 'Let''s change our code as per this new design. First, we need to create two
    interfaces: to fetch the data and export the data as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们根据这个新设计更改我们的代码。首先，我们需要创建两个接口：获取数据和导出数据如下：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, all low-level modules must implement these interfaces as per the following
    snippet:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，所有低级模块必须按照以下片段实现这些接口：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, the balance sheet  module needs to rely on interfaces to interact
    with low-level modules. So the updated `BalanceSheet` module should look like
    the following snippet:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，资产负债表模块需要依赖接口与低级模块交互。因此，更新的`BalanceSheet`模块应如下所示：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You may have observed that, the `generateBalanceSheet()` method became more
    straightforward. It allows us to work with additional fetch and export modules
    without any change. It is thanks to the mechanism of inverting the interface that
    makes this possible.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，`generateBalanceSheet()`方法变得更加简单。它允许我们无需任何更改即可与额外的获取和导出模块一起工作。这要归功于反转接口的机制，使得这一切成为可能。
- en: This design looks perfect; but still, there is one problem. If you noticed,
    the balance sheet module is still keeping the responsibility of creating low-level
    module objects (`exportDataObj `and `fetchDataObj`). In other words, object creation
    dependency is still with the high-level modules.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计看起来很完美；但仍然有一个问题。如果您注意到了，资产负债表模块仍然保留着创建低级模块对象（`exportDataObj`和`fetchDataObj`）的责任。换句话说，对象创建的依赖性仍然存在于高级模块中。
- en: Because of this, the Balance Sheet module is not 100 percent decoupled from
    the low-level modules, even after implementing interface inversion. You will end
    up instantiating low-level modules with if/else blocks based on some flag, and
    the high-level module keeps changing for adding additional low-level modules integration.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使在实现接口反转之后，资产负债表模块也不是完全解耦于底层模块。您最终将根据某些标志使用if/else块实例化底层模块，而高级模块会不断变化以添加额外的底层模块集成。
- en: To overcome this, you need to invert the object creation from your higher-level
    module to some other entity or framework. This is the second way of implementing
    IoC.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这个问题，您需要将对象创建从您的高级模块反转到其他实体或框架。这是实现IoC的第二种方式。
- en: Inverting object creation
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象创建反转
- en: Once the abstraction between modules is set, there is no need to keep the logic
    of creating dependency objects in higher-level modules. Let us understand the
    importance of inversion of object creation design with one more example.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦模块之间的抽象设置完成，就无需在高级模块中保留创建依赖对象的逻辑。让我们通过另一个例子来了解对象创建设计反转的重要性。
- en: Suppose you are designing a war game. Your player can shoot the enemy with various
    weapons. You created separate classes (low-level module) for each of the weapons.
    While playing the game, your player can add the weapon based on points earned.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在设计一款战争游戏。您的玩家可以使用各种武器射击敌人。您为每种武器创建了单独的类（底层模块）。在游戏过程中，您的玩家可以根据获得的分数添加武器。
- en: 'Also, the player can change the weapon. To implement inversion of interface,
    we created an interface called `Weapon`, which will be implemented by all weapon
    modules, as per the following diagram:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，玩家可以更换武器。为了实现接口反转，我们创建了一个名为`Weapon`的接口，所有武器模块都将实现该接口，具体如下所示：
- en: '![](img/00008.gif)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00008.gif)'
- en: 'Assume that there are three weapons initially that you kept in the game. If
    you keep weapon creation code in your player module, the logic of choosing a weapon
    would be as per the following snippet:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 假设游戏开始时有三种武器，您将它们保留在游戏中。如果您在玩家模块中保留武器创建代码，选择武器的逻辑将如下所示：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Since the player module is taking care of creating the object of weapons, we
    are passing a flag in the `chooseWeapon()` method. Let us assume that, over a
    period of time, you add a few more weapons to the game. You end up changing the
    code of the `Player` module every time you add a new weapon.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于玩家模块负责创建武器对象，我们在`chooseWeapon()`方法中传递一个标志。让我们假设，在一段时间内，您向游戏中添加了一些更多的武器。每次添加新武器时，您都需要更改`Player`模块的代码。
- en: The solution to this problem is to invert the object creation process from your
    main module to another entity or framework.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是反转对象创建过程，从主模块到另一个实体或框架。
- en: 'Let''s first apply this solution to our `Player` module. The updated code would
    be as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先把这个解决方案应用到我们的`Player`模块。更新的代码如下：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can observe the following things:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以观察到以下事项：
- en: In the `chooseWeapon()` method, we are passing the object of weapons through
    the interface. The `Player` module is no longer handling the creation of weapon
    objects.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`chooseWeapon()`方法中，我们通过接口传递武器对象。`Player`模块不再处理武器对象的创建。
- en: This way, the `Player` (higher-level) module is completely decoupled from `Weapon`
    (low-level) modules.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这样，`Player`（高级）模块就完全解耦于`Weapon`（底层）模块。
- en: Both modules interact through the interface, defined by higher-level modules.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个模块通过由高级模块定义的接口进行交互。
- en: For any new weapon added into the system, you do not need to change anything
    in the player module.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于系统中新添加的任何武器，您无需在玩家模块中进行任何更改。
- en: 'Let''s apply this solution (invert creating object) to our balance sheet module.
    The updated code for the `BalanceSheet` module would be as per the following snippet:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个解决方案（反转创建对象）应用到我们的资产负债表模块。`BalanceSheet`模块的更新代码如下所示：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here are some quick observations:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些快速观察：
- en: Objects of fetch data and export data modules are created outside the balance
    sheet module, and passed through `configureFetchData()` and `configureExportData()`
    methods
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取数据和导出数据模块的对象是在资产负债表模块外部创建的，并通过`configureFetchData()`和`configureExportData()`方法传递
- en: The balance sheet module is now  100 percent decoupled from fetch data and export
    data modules
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资产负债表模块现在已完全解耦于获取数据和导出数据模块
- en: For any new type of fetch and export data, no change is required in balance
    sheet modules
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于任何新的获取和导出数据类型，资产负债表模块无需进行任何更改
- en: 'At this moment, the relation between DIP and IoC can be described as per the
    following diagram:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时候，DIP和IoC之间的关系可以按照以下图示描述：
- en: '![](img/00009.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00009.jpeg)'
- en: Finally, we implemented **DIP** through **IoC** and solved one of the most fundamental
    problems of interdependency between modules.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过**IoC**实现了**DIP**，并解决了模块之间相互依赖的最基本问题之一。
- en: But hold on, something is not complete yet. We have seen that keeping the object
    creation away from your main module will eliminate the risk of accommodating changes
    and make your code decoupled. But we haven't explored how to create and pass the
    dependency object from outside code into your module. There are various ways of
    inverting object creation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等，还有一些事情还没有完成。我们已经看到，将对象创建与主模块分离可以消除适应变化的风险，并使代码解耦。但我们还没有探讨如何从外部代码创建并传递依赖对象到模块中。有各种反转对象创建的方法。
- en: Different ways to invert object creation
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反转对象创建的不同方法
- en: 'We have seen how inversion of object creation helps us to decouple the modules.
    You can achieve the inversion of object creation with multiple design patterns
    as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，对象创建反转如何帮助我们解耦模块。您可以通过以下多种设计模式实现对象创建反转：
- en: Factory pattern
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂模式
- en: Service locator
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务定位器
- en: Dependency injection
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入
- en: Inversion of object creation through the factory pattern
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过工厂模式实现对象创建反转
- en: The factory pattern takes the responsibility of creating an object from a client
    who uses it. It generates the object of classes that are following a common interface.
    A client has to pass only type of the implementation it wants and the factory
    will create that object.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式负责从使用它的客户端创建对象。它生成遵循公共接口的类的对象。客户端只需传递它想要的实现类型，工厂就会创建该对象。
- en: 'If we apply the factory pattern to our balance sheet example, the process of
    inverting of object creation is depicted as per the following diagram:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将工厂模式应用于我们的平衡表示例，对象创建反转的过程如下所示：
- en: '![](img/00010.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00010.jpeg)'
- en: Client (in our case, it's a balance sheet module) talks to the factory—Hey factory,
    can you please give me the fetch data object? Here is the type.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端（在我们的例子中，是平衡表模块）与工厂交谈——嘿，工厂，你能给我一个fetch数据对象吗？这是类型。
- en: The factory takes the type, creates the object, and passes it to the client
    (the balance sheet module).
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂接收类型，创建对象，并将其传递给客户端（平衡表模块）。
- en: The factory can create the object of the same type only.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该工厂只能创建相同类型的对象。
- en: The factory class is a complete black box for its clients. They know it's a
    static method to get objects.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂类对其客户端来说是一个完整的黑盒。它们知道这是一个用于获取对象的静态方法。
- en: 'The Balance Sheet module can get `FetchData` objects from `FetchDataFactory`.
    The code of `FetchDataFactory` will be as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 平衡表模块可以从`FetchDataFactory`获取`FetchData`对象。`FetchDataFactory`的代码如下：
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To use this factory, you need to update the `configureFetchData()` method of
    a balance sheet module as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此工厂，您需要更新平衡表模块的`configureFetchData()`方法如下：
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For export data, you need to create a separate factory as per the following
    snippet:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于导出数据，您需要根据以下代码片段创建一个单独的工厂：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If a new fetch data or export data type is introduced, you need to change it
    in its respective factory class only.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果引入了新的fetch数据或导出数据类型，您只需在其相应的工厂类中更改即可。
- en: Inversion of object creation through service locator
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过服务定位器实现对象创建反转
- en: 'The service locator pattern works more or less the same as to the factory pattern.
    The service locator can find the existing object and send it to the client rather
    than create a new one every time, as with the factory pattern. Instead of getting
    into detail, we will just look briefly at how the service locator works to create
    objects. The flow of the service locator can be described as per the following
    diagram:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 服务定位器模式与工厂模式大致相同。服务定位器可以找到现有的对象并将其发送给客户端，而不是像工厂模式那样每次都创建一个新的对象。我们不会深入细节，只是简要地看看服务定位器如何创建对象。服务定位器的流程可以按照以下图示描述：
- en: '![](img/00011.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00011.jpeg)'
- en: '**Client** is relying on **Service Locator** to find services. Here, *service*
    means any kind of dependency'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**依赖于**服务定位器**来查找服务。在这里，*服务*意味着任何类型的依赖'
- en: '**Service Locator** takes the name of the service, and returns the object of
    service back to the client'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务定位器**获取服务的名称，并将服务的对象返回给客户端'
- en: 'If our balance sheet module uses the service locator, the code of the `configureFetchData()`
    method would be like the following snippet:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的资产负债表模块使用服务定位器，`configureFetchData()` 方法的代码将如下所示：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Similar to fetch data, you need to design a separate service locator for export
    data. For any new fetch data or export data type, the changes need to be done
    in the service locator.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 与获取数据类似，你需要为导出数据设计一个单独的服务定位器。对于任何新的获取数据或导出数据类型，都需要在服务定位器中进行更改。
- en: Another way of inverting the object creation is DI.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 反转对象创建的另一种方法是 DI。
- en: Dependency injection
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: '**DI** is one of the ways to invert the object creation process from your module
    to other code or entity. The term *injection* refers to the process of passing
    the dependent object into a software component.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**DI** 是将对象创建过程从你的模块反转到其他代码或实体的方法之一。术语 *注入* 指的是将依赖对象传递到软件组件的过程。'
- en: Since DI is one of the ways to implement **IoC**, it relies on abstraction to
    set the dependency. The client object doesn't know which class will be used to
    provide functionality at compile time. The dependency will be resolved at runtime.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 DI 是实现 **IoC** 的方法之一，它依赖于抽象来设置依赖。客户端对象不知道在编译时将使用哪个类来提供功能。依赖将在运行时解决。
- en: 'A dependent object does not directly call to the client object; instead, the
    client object will call a dependent object whenever required. It''s similar to
    the Hollywood principle: Don''t call us, we''ll call you when we need to.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖对象不会直接调用客户端对象；相反，客户端对象将在需要时调用依赖对象。这类似于好莱坞原则：不要调用我们，当我们需要时我们会调用你。
- en: Dependency injection types
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入类型
- en: 'In DI, you need to set the entry point in a client object from which the dependency
    can be injected. Based on these entry points, DI can be implemented with the following
    types:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DI 中，你需要设置客户端对象中的入口点，以便可以注入依赖。基于这些入口点，DI 可以通过以下类型实现：
- en: Constructor injection
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数注入
- en: Setter injection
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置器注入
- en: Interface injection
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口注入
- en: Constructor injection
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数注入
- en: This is the most common way to inject dependency. In this approach, you need
    to pass the dependent object through a public constructor of a client object. Please
    note that in case of construction injection, you need to pass all the dependency
    objects in the constructor of a client object.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是注入依赖最常见的方式。在这种方法中，你需要通过客户端对象的公共构造函数传递依赖对象。请注意，在构造函数注入的情况下，你需要将所有依赖对象传递给客户端对象的构造函数。
- en: Constructor injection can control the order of instantiation and consequently
    reduce the risk of circular dependency. All mandatory dependencies can be passed
    through constructor injection.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数注入可以控制实例化的顺序，从而降低循环依赖的风险。所有必需的依赖都可以通过构造函数注入传递。
- en: 'In our `BalanceSheet` example, we need to pass two objects in a constructor,
    because it has two dependencies: one is for fetch data, and the second is for
    export data types, as per the following snippet:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `BalanceSheet` 示例中，我们需要在构造函数中传递两个对象，因为它有两个依赖：一个是用于获取数据，另一个是用于导出数据类型，如下面的代码片段所示：
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: All dependencies are injected from a constructor of a client object. Since constructors
    are called only once, it's clear that the dependency object will not be changed
    until the existence of a client object. If a client uses constructor injection,
    then extending and overriding it would be difficult sometimes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 所有依赖都从客户端对象的构造函数注入。由于构造函数只调用一次，很明显，依赖对象将在客户端对象存在期间不会改变。如果客户端使用构造函数注入，那么有时扩展和重写它可能会很困难。
- en: Setter injection
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置器注入
- en: As its name suggests, here dependency injection is done through setter methods
    exposed publicly. Any dependency not required at the time of client object instantiation
    is called **optional dependency**. They can be set at a later stage after a client
    object is created.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，在这里，依赖注入是通过公开的设置方法来实现的。任何在客户端对象实例化时不需要的依赖项被称为 **可选依赖**。它们可以在客户端对象创建后稍后设置。
- en: '**Setter injection** is a perfect fit for optional or conditional dependency.
    Let''s apply a setter injection to the `BalanceSheet` module.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**设置器注入** 是可选或条件依赖的完美选择。让我们将设置器注入应用于 `BalanceSheet` 模块。'
- en: 'The code would look as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将如下所示：
- en: '[PRE16]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For each dependency, you need to put separate setter methods. Since the dependencies
    are set through the setter method, the object or a framework which supplies the
    dependencies need to call the setter methods at an appropriate time to make sure
    dependencies are available before a client object starts using it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个依赖项，你需要单独放置设置方法。由于依赖项是通过设置方法设置的，因此提供依赖项的对象或框架需要在适当的时间调用设置方法，以确保在客户端对象开始使用之前依赖项是可用的。
- en: Interface injection
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口注入
- en: '**Interface injection** defines a way by which the dependency provider should
    talk to a client. It abstracts the process of passing dependency. The dependency
    provider defines an interface that all clients need to implement. This method
    is not so frequently used.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口注入**定义了依赖提供者与客户端之间通信的方式。它抽象了传递依赖的过程。依赖提供者定义了一个所有客户端都需要实现的接口。这种方法并不常用。'
- en: Technically, interface injection and setter injection are the same. They both
    use some sort of method to inject dependency. However, for interface injection,
    the method is defined by objects which provide the dependency.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，接口注入和设置注入是相同的。它们都使用某种方法来注入依赖。然而，对于接口注入，方法是依赖提供者对象定义的。
- en: 'Let''s apply interface injection to our balance sheet module:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将接口注入应用于我们的资产负债表模块：
- en: '[PRE17]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We have created interface `IFetchAndExport` and defined methods to inject dependencies.
    The dependency provider class knows how to pass the dependency through this interface.
    Our client object (Balance Sheet module) implements this method to set dependencies.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已创建接口`IFetchAndExport`并定义了注入依赖的方法。依赖提供者类知道如何通过这个接口传递依赖。我们的客户端对象（资产负债表模块）实现这个方法来设置依赖。
- en: IoC containers
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IoC容器
- en: So far, we have talked about the code or framework that plays the role of dependency
    provider. It can be any custom code or full-fledged **IoC** container. Some developers
    refer to it as a *DI container*, but we will simply call it a *container*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了扮演依赖提供者角色的代码或框架。它可以是我们自定义的任何代码或完整的**IoC**容器。一些开发者将其称为**DI容器**，但我们将简单地称之为**容器**。
- en: If we write custom code to supply dependency, things get smoother until we have
    just a single level of dependency. Take the scenario where our client classes
    are also dependent of some other modules. This results in chained or nested dependencies.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编写自定义代码来提供依赖项，直到我们只有一个依赖级别，事情才会变得顺利。考虑我们的客户端类也依赖于某些其他模块的情况。这会导致链式或嵌套依赖。
- en: In this situation, implementing dependency injection will become quite complicated
    through manual code. That is where we need to rely on containers.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，通过手动代码实现依赖注入将变得相当复杂。这就是我们需要依赖容器的地方。
- en: A container takes care of creating, configuring, and managing objects. You just
    need to do configuration, and the container will take care of object instantiation
    and dependency management with ease. You don't need to write any custom code such
    as that we wrote while implementing **IoC** with factory or service locator patterns.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 容器负责创建、配置和管理对象。你只需进行配置，容器就会轻松地处理对象的实例化和依赖管理。你不需要编写任何自定义代码，例如我们在使用工厂模式或服务定位器模式实现**IoC**时编写的代码。
- en: So, as a developer, your life is cool. You just give a hint about your dependency,
    and the container will handle the rest and you can focus on implementing business
    logic.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作为一个开发者，你的生活很酷。你只需给出关于依赖项的提示，容器就会处理其余的事情，你就可以专注于实现业务逻辑。
- en: 'If we choose containers to set dependencies for our Balance Sheet module, the
    container will create the objects of all dependencies first. Then, it will create
    an object of the Balance Sheet class and pass the dependencies in it. A container
    will do all these things silently and give you the object of the Balance Sheet
    module with all dependencies set in it. This process can be described with the
    following diagram:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择容器为我们的资产负债表模块设置依赖项，容器将首先创建所有依赖项的对象。然后，它将创建资产负债表类的对象，并在其中传递依赖项。容器会默默地完成所有这些事情，并给你一个所有依赖项都已设置的资产负债表模块的对象。这个过程可以用以下图表来描述：
- en: '![](img/00012.gif)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00012.gif)'
- en: 'In conclusion, the following are the advantages of using containers over manual
    code to manage dependency:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，使用容器而不是手动代码管理依赖的优势如下：
- en: Isolating the process of object creation from your code and making your code
    more clean and readable.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将对象创建的过程从你的代码中隔离出来，使你的代码更加清晰和易于阅读。
- en: Removing object wiring (setting dependency) code from your client module. The
    container will take care of object wiring.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从您的客户端模块中移除对象连接（设置依赖项）代码。容器将负责对象连接。
- en: Making your modules 100 percent loose coupling.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使您的模块实现100%的松散耦合。
- en: Managing the entire lifecycle of the modules. This is very helpful when you
    want to configure the objects for various scopes, such as request, session, and
    so on in application execution.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理模块的整个生命周期。当您想在应用程序执行中为各种范围配置对象时，例如请求、会话等，这非常有帮助。
- en: Swapping out the dependency is just a matter of configuration—no change is required
    in the code.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换依赖项只需配置即可——不需要在代码中进行任何更改。
- en: It is a more centralized way to handle object life span and dependency management.
    This is useful when you want to apply some common logic across the dependencies,
    for example, AOP in Spring. We will see details about AOP in [Chapter 6](part0156.html#4KONO0-255b24dd0eb24162a557b7d0d84b0b16), *Aspect-Oriented
    Programming and Interceptors*.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一种更集中的方式来处理对象的生命周期和依赖管理。当您想在依赖项中应用一些通用逻辑时，例如在 Spring 中的 AOP，这非常有用。我们将在[第 6
    章](part0156.html#4KONO0-255b24dd0eb24162a557b7d0d84b0b16)中看到有关 AOP 的详细信息，*面向切面编程和拦截器*。
- en: Your module can benefit from advanced features that ship with containers.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的模块可以受益于容器提供的先进功能。
- en: Spring, Google Guice, and Dagger are some of the IoC containers available today
    for Java. Starting from Enterprise Edition version 6, Java introduced **Context
    Dependency Injection** (**CDI**), a dependency injection framework in Enterprise
    Edition. It's more or less similar to Spring's annotation-based DI implementation.
    Out of all the preceding containers, Spring is the most popular and widely used
    IoC container today.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Spring、Google Guice 和 Dagger 是目前可用于 Java 的 IoC 容器之一。从企业版 6.0 版本开始，Java 引入了 **上下文依赖注入**（**CDI**），这是一个企业版中的依赖注入框架。它与
    Spring 的基于注解的 DI 实现大致相似。在所有上述容器中，Spring 是目前最流行和最广泛使用的 IoC 容器。
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In the software paradigm, it's always recommended to break the whole system
    down into small modules that can work independently for specific tasks. DIP is
    one of the important principles to build a modular system. In this chapter, we
    saw how high-level modules should not depend on low-level modules, and both should
    depend on abstraction (the concept of DIP).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件范式下，始终建议将整个系统分解成可以独立执行特定任务的小模块。DIP 是构建模块化系统的重要原则之一。在本章中，我们看到了高级模块不应依赖于低级模块，两者都应依赖于抽象（DIP
    的概念）。
- en: We learned in detail how we can achieve DIP through IoC. Setting inversion of
    control makes a system loosely coupled. We also learned various design patterns
    such as factory, service locator, and dependency injection to implement IoC.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们详细学习了如何通过 IoC 实现DIP。设置控制反转可以使系统松散耦合。我们还学习了各种设计模式，如工厂、服务定位器和依赖注入，以实现 IoC。
- en: After that, we learned about the various types of the dependency injection pattern.
    Finally, we discussed **IoC** containers and how they're useful when building
    modular systems.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们学习了依赖注入模式的多种类型。最后，我们讨论了 IoC 容器及其在构建模块化系统中的有用性。
- en: In the next chapter, we will talk about modularity concepts and dependency injection
    in Java 9.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论 Java 9 中的模块化概念和依赖注入。
