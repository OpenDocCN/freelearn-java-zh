- en: Transformers and Custom Operators
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Transformers和自定义操作符
- en: In RxJava, there are ways to implement your own custom operators using the `compose()`
    and `lift()` methods, which exist on both `Observable` and `Flowable`. Most of
    the time, you will likely want to compose existing RxJava operators to create
    a new operator. But on occasion, you may find yourself needing an operator that
    must be built from scratch. The latter is a lot more work, but we will cover how
    to do both of these tasks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在RxJava中，有使用`compose()`和`lift()`方法实现自定义操作符的方法，这两个方法都存在于`Observable`和`Flowable`上。大多数时候，你可能会想要组合现有的RxJava操作符来创建一个新的操作符。但有时，你可能需要从头开始构建的操作符。后者工作量更大，但我们将介绍如何完成这两个任务。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Composing new operators with existing operators using `compose()` and Transformers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`compose()`和Transformers组合现有操作符
- en: The `to()` operator
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`to()`操作符'
- en: Implementing operators from scratch with `lift()`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`lift()`从头实现操作符
- en: RxJava2-Extras and RxJava2Extensions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxJava2-Extras和RxJava2Extensions
- en: Transformers
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Transformers
- en: When working with RxJava, you may find yourself wanting to reuse pieces of an
    `Observable` or `Flowable` chain and somehow consolidate these operators into
    a new operator. Good developers find opportunities to reuse code, and RxJava provides
    this ability using `ObservableTransformer` and `FlowableTransformer`, which you
    can pass to the `compose()` operator.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用RxJava时，你可能希望重用`Observable`或`Flowable`链的一部分，并以某种方式将这些操作符合并成一个新的操作符。优秀的开发者会寻找重用代码的机会，RxJava通过`ObservableTransformer`和`FlowableTransformer`提供了这种能力，你可以将这些传递给`compose()`操作符。
- en: ObservableTransformer
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ObservableTransformer
- en: 'Bring back [*Google Guava*](http://search.maven.org/#artifactdetails%7Ccom.google.guava%7Cguava%7C21.0%7Cbundle)
    as a dependency. In [Chapter 3](de58a40c-f55f-442f-b12e-7c022e08644e.xhtml), *Basic
    Operators*, we covered the `collect()` operator and used it to turn  `Observable<T>`
    into a `Single<ImmutableList<T>>`. Effectively, we want to collect `T` emissions
    into a Google Guava `ImmutableList<T>`. Suppose we do this operation enough times
    until it starts to feel redundant. Here, we use this `ImmutableList` operation
    for two different `Observable` subscriptions:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 将[*Google Guava*](http://search.maven.org/#artifactdetails%7Ccom.google.guava%7Cguava%7C21.0%7Cbundle)作为依赖项恢复。在[第3章](de58a40c-f55f-442f-b12e-7c022e08644e.xhtml)“基本操作符”中，我们介绍了`collect()`操作符，并使用它将`Observable<T>`转换为`Single<ImmutableList<T>>`。实际上，我们希望将`T`的发射项收集到Google
    Guava的`ImmutableList<T>`中。假设我们重复进行此操作足够多次，直到它开始显得冗余。在这里，我们使用这个`ImmutableList`操作来处理两个不同的`Observable`订阅：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output is as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Take a look at this part of the Observable chain used in two places above:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 看看上面两个地方使用的Observable链的这部分：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a bit redundant to invoke twice, so is it possible that we can compose
    these operators into a single operator that collects emissions into an `ImmutableList`?
    As a matter of fact, yes! To target an `Observable<T>`, you can implement `ObservableTransformer<T,R>`.
    This type has an `apply()` method that accepts an `Observable<T>` upstream and
    returns an `Observable<R>` downstream. In your implementation, you can return
    an `Observable` chain that adds on any operators to the upstream, and after those
    transformations, it returns an `Observable<R>`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 两次调用有点冗余，那么我们能否将这些操作符组合成一个单独的操作符，该操作符将发射项收集到`ImmutableList`中？实际上，可以！为了针对`Observable<T>`，你可以实现`ObservableTransformer<T,R>`。这个类型有一个`apply()`方法，它接受上游的`Observable<T>`并返回下游的`Observable<R>`。在你的实现中，你可以返回一个添加了任何操作符到上游的`Observable`链，并在这些转换之后返回一个`Observable<R>`。
- en: 'For our example, we will target any generic type `T` for a given `Observable<T>`,
    and `R` will be an `ImmutableList<T>` emitted through an `Observable<ImmutableList<T>>`.
    We will package all of this up in an `ObservableTransformer<T,ImmutableList<T>>`
    implementation, as shown in the following code snippet:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将针对给定的`Observable<T>`的任何通用类型`T`，`R`将是通过`Observable<ImmutableList<T>>`发射的`ImmutableList<T>`。我们将把这个所有东西打包在一个`ObservableTransformer<T,ImmutableList<T>>`实现中，如下面的代码片段所示：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since `collect()` returns a `Single`, we will invoke `toObservable()` on it
    since `ObservableTransformer` expects an `Observable`, not `Single`, to be returned.
    It is not uncommon for Transformers to be delivered through static factory methods,
    so that is what we did here.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`collect()`返回一个`Single`，因此我们需要在它上面调用`toObservable()`，因为`ObservableTransformer`期望返回一个`Observable`，而不是`Single`。Transformers通过静态工厂方法提供的情况并不少见，所以我们在这里就是这样做的。
- en: 'Since there is only one single abstract method in `ObservableTransformer`,
    we can streamline this more using a lambda instead. This reads a bit easier, as
    it reads left-to-right/top-to-bottom and expresses *for a given upstream Observable,
    return it with these operators added to the downstream*:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`ObservableTransformer`中只有一个抽象方法，我们可以使用lambda表达式来简化这一点。这样读起来更容易，因为它从左到右/从上到下读取，并表达出“对于给定的上游Observable，返回添加了这些操作符的下游Observable”：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To invoke a Transformer into an `Observable` chain, you pass it to the `compose()`
    operator. When called on an `Observable<T>`, the `compose()` operator accepts
    an `ObservableTransformer<T,R>` and returns the transformed `Observable<R>`. This
    allows you to reuse Rx logic and invoke it in multiple places, and now we can
    call `compose(toImmutableList())` on both of our `Observable` operations:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个Transformer加入到`Observable`链中，你需要将它传递给`compose()`操作符。当在`Observable<T>`上调用时，`compose()`操作符接受一个`ObservableTransformer<T,R>`并返回转换后的`Observable<R>`。这允许你在多个地方重用Rx逻辑，现在我们可以在两个`Observable`操作上调用`compose(toImmutableList())`：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output is as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It is common for APIs to organize Transformers in a static factory class. In
    a real-world application, you may store your `toImmutableList()` Transformer inside
    a `GuavaTransformers` class. Then, you can invoke it by calling `compose(GuavaTransformers.toImmutableList())`
    in your `Observable` operation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在API中，将Transformers组织在静态工厂类中是很常见的。在实际应用中，你可能会在`GuavaTransformers`类中存储你的`toImmutableList()`
    Transformer。然后，你可以在`Observable`操作中通过调用`compose(GuavaTransformers.toImmutableList())`来调用它。
- en: Note for this example, we could actually make the `toImmutableList()` a reusable
    singleton since it does not take any parameters.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在这个例子中，实际上我们可以将`toImmutableList()`制作成一个可重用的单例，因为它不接受任何参数。
- en: 'You can also create Transformers that target specific emission types and accept
    arguments. For example, you can create a `joinToString()` Transformer that accepts
    a separator argument and concatenates `String` emissions with that separator.
    Usage of this `ObservableTransformer` will only compile when invoked on an `Observable<String>`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以创建针对特定发射类型并接受参数的Transformers。例如，你可以创建一个接受分隔符参数并将`String`发射与该分隔符连接的`joinToString()`
    Transformer。只有当在`Observable<String>`上调用时，此`ObservableTransformer`的使用才会编译：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Transformers are a great way to reuse a series of operators that perform a common
    task, and leveraging them can greatly increase your Rx code reusability. Usually,
    you will get the most flexibility and speed by implementing them through static
    factory methods, but you can also extend `ObservableTransformer` onto your own
    class implementation.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Transformers是重用一系列执行共同任务的操作符的绝佳方式，利用它们可以极大地提高你的Rx代码的可重用性。通常，通过实现静态工厂方法，你可以获得最大的灵活性和速度，但你也可以将`ObservableTransformer`扩展到你的类实现中。
- en: As we will learn in [Chapter 12](42947483-7be8-4693-a7e4-2527ad9f180b.xhtml),
    *Using RxJava with Kotlin*, the Kotlin language enables powerful language features
    that streamline RxJava even more. Instead of using Transformers, you can leverage
    extension functions to add operators to the `Observable` and `Flowable` types
    without inheritance. We will learn more about this later.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在[第12章](42947483-7be8-4693-a7e4-2527ad9f180b.xhtml)中学习的那样，*使用Kotlin与RxJava*，Kotlin语言提供了强大的语言特性，可以进一步简化RxJava。你不需要使用Transformers，而是可以利用扩展函数将操作符添加到`Observable`和`Flowable`类型，而无需继承。我们将在稍后了解更多关于这一点。
- en: FlowableTransformer
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FlowableTransformer
- en: When you implement your own `ObservableTransformer`, you might want to create
    a `FlowableTransformer` counterpart as well. This way, you can use your operator
    on both Observables and Flowables.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当你实现自己的`ObservableTransformer`时，你可能还想创建一个`FlowableTransformer`对应物。这样，你就可以在你的操作符上使用Observables和Flowables。
- en: The `FlowableTransformer` is not much different from `ObservableTransformer`.
    Of course, it will support backpressure since it is composed with Flowables. Otherwise,
    it is pretty much the same in its usage except that you obviously pass it to `compose()`
    on a `Flowable`, not `Observable`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`FlowableTransformer`与`ObservableTransformer`没有太大区别。当然，它将支持背压，因为它与Flowables组合。在其他方面，它的使用几乎相同，只是你显然需要在`Flowable`上而不是`Observable`上传递它到`compose()`。'
- en: 'Here, we take our `toImmutableList()` method returning an `ObservableTransformer` and
    implement it as `FlowableTransformer` instead:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将我们的`toImmutableList()`方法返回一个`ObservableTransformer`，并将其实现为`FlowableTransformer`：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You should be able to make a similar conversion to `FlowableTransformer` for
    our `joinToString()` example as well.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你也应该能够将类似的转换应用到我们的`joinToString()`示例中的`FlowableTransformer`。
- en: You might consider creating separate static utility classes to store your `FlowableTransformers`
    and `ObservableTransformers` separately to prevent name clashes. Our `FlowableTransformer`
    and `ObservableTransformer` variants of `toImmutableList()` cannot exist in the
    same static utility class unless they have different method names. But it might
    be cleaner to put them in separate classes, such as `MyObservableTransformers`
    and `MyFlowableTransformers`. You could also have them in separate packages with
    the same class name, `MyTransformers`, one for Observables and the other for Flowables.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以考虑创建单独的静态实用类来分别存储你的 `FlowableTransformers` 和 `ObservableTransformers`，以防止名称冲突。我们的
    `FlowableTransformer` 和 `ObservableTransformer` 的 `toImmutableList()` 变体不能存在于同一个静态实用类中，除非它们有不同的方法名称。但将它们放在单独的类中可能更干净，例如
    `MyObservableTransformers` 和 `MyFlowableTransformers`。你也可以将它们放在具有相同类名 `MyTransformers`
    的单独包中，一个用于 Observables，另一个用于 Flowables。
- en: Avoiding shared state with Transformers
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免与 Transformers 共享状态
- en: When you start creating your own Transformers and custom operators (covered
    later), an easy way to shoot yourself in the foot is to share states between more
    than one subscription. This can quickly create unwanted side effects and buggy
    applications and is one of the reasons you have to tread carefully as you create
    your own operators.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始创建自己的 Transformers 和自定义操作符（稍后介绍）时，一个容易犯的错误是在多个订阅之间共享状态。这可能会迅速产生不希望出现的副作用和有缺陷的应用程序，这也是你创建自己的操作符时必须谨慎行事的原因之一。
- en: 'Say, you want to create an `ObservableTransformer<T,IndexedValue<T>>`, which
    pairs each emission with its consecutive index starting at 0\. First, you create
    an `IndexedValue<T>` class to simply pair each `T` value with an `int index`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想创建一个 `ObservableTransformer<T,IndexedValue<T>>`，它将每个发射项与其连续的索引（从 0 开始）配对。首先，你创建一个
    `IndexedValue<T>` 类来简单地将每个 `T` 值与一个 `int index` 配对：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, you create an `ObservableTransformer<T,IndexedValue<T>>` that uses an `AtomicInteger`
    to increment and attach an integer to each emission. But there is something wrong
    with our implementation here:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你创建一个 `ObservableTransformer<T,IndexedValue<T>>`，它使用 `AtomicInteger` 来递增并将一个整数附加到每个发射项。但我们的实现中存在一些问题：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'See anything wrong yet? Try to run this `Observable` operation, which has two
    Observers and uses this `withIndex()` Transformer. Look at the output carefully:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 看到什么问题了吗？尝试运行这个具有两个观察者并使用此 `withIndex()` Transformers 的 `Observable` 操作。仔细查看输出：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that a single instance of  `AtomicInteger` was shared between both subscriptions,
    which means its state was shared as well. On the second subscription, instead
    of starting over at `0`, it picks up at the index left by the previous subscription
    and starts at index `5` since the previous subscription ended at `4`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`AtomicInteger` 的单个实例在两个订阅之间共享，这意味着其状态也被共享。在第二个订阅中，它不会从 `0` 开始，而是从上一个订阅留下的索引处开始，由于上一个订阅在
    `4` 结束，所以从索引 `5` 开始。
- en: Unless you have some stateful behaviors you are deliberately implementing, this
    is probably an unwanted side-effect that can result in maddening bugs. Constants
    are usually fine, but a mutable shared state between subscriptions is often something
    you want to avoid.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你故意实现某些有状态的行为，否则这可能是可能产生令人沮丧的错误的不希望出现的副作用。常量通常没问题，但订阅之间的可变共享状态通常是你要避免的。
- en: 'A quick and easy way to create a new resource (such as `AtomicInteger`) for
    each subscription is to wrap everything in `Observable.defer()`, including the
    `AtomicInteger` instance. This way, a new `AtomicInteger` is created each time
    with the returned indexing operations:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个订阅创建一个新的资源（如 `AtomicInteger`）的快速简单方法是将一切包裹在 `Observable.defer()` 中，包括 `AtomicInteger`
    实例。这样，每次都会创建一个新的 `AtomicInteger`，并返回索引操作：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can also create an `AtomicInteger` within `Observable.fromCallable()` and
    use `flatMap()` on it to the `Observable` that uses it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在 `Observable.fromCallable()` 中创建一个 `AtomicInteger`，并使用 `flatMap()` 在它上面创建一个使用它的
    `Observable`。
- en: 'In this particular example, you can also use `Observable.zip()` or `zipWith()`
    with `Observable.range()`. Since this is a pure Rx approach as well, no state
    will be shared between multiple subscribers, and this will also solve our problem:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的例子中，你也可以使用 `Observable.zip()` 或 `zipWith()` 与 `Observable.range()`。由于这也是一个纯
    Rx 方法，多个订阅者之间不会共享状态，这也会解决我们的问题：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Again, inadvertent shared state and side-effects are dangerous in Rx! Whatever
    implementation you use to create your Transformer, it is better to rely on pure
    Rx factories and operators in your implementation if possible. Avoid creating
    imperative states and objects that risk being shared across subscriptions unless
    you are fulfilling some strange business requirement where a shared state is explicitly
    wanted.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，在 Rx 中，意外的共享状态和副作用是危险的！无论你使用什么实现来创建你的 Transformer，如果可能的话，最好在你的实现中依赖纯 Rx
    工厂和操作符。除非你满足某些奇怪的业务需求，其中明确需要共享状态，否则请避免创建可能被订阅共享的状态和对象。
- en: Using to() for fluent conversion
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 to() 进行流畅转换
- en: On rare occasions, you may find yourself having to pass an `Observable` to another
    API that converts it into a proprietary type. This can be done simply by passing
    an `Observable` as an argument to a factory that does this conversion. However,
    this does not always feel fluent, and this is where the `to()` operator comes
    in.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在罕见的情况下，你可能发现自己需要将一个 `Observable` 传递给另一个 API，该 API 将其转换为专有类型。这可以通过将 `Observable`
    作为参数传递给执行此转换的工厂来完成。然而，这并不总是感觉流畅，这就是 `to()` 操作符发挥作用的地方。
- en: 'For example, JavaFX has a `Binding<T>` type that houses a mutable value of
    type `T`, and it will notify affected user interface elements to update when it
    changes. RxJavaFX has `JavaFxObserver.toBinding()` and `JavaFxSubscriber.toBinding()`
    factories, which can turn an `Observable<T>` or `Flowable<T>` into a JavaFX `Binding<T>`.
    Here is a simple JavaFX `Application` that uses `Binding<String>` built-off `Observable<String>`,
    which is used to bind to a `textProperty()` operator of `label`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，JavaFX 有一个 `Binding<T>` 类型，它包含一个可变值，类型为 `T`，并且当它发生变化时，会通知受影响的用户界面元素进行更新。RxJavaFX
    有 `JavaFxObserver.toBinding()` 和 `JavaFxSubscriber.toBinding()` 工厂，可以将 `Observable<T>`
    或 `Flowable<T>` 转换为 JavaFX 的 `Binding<T>`。以下是一个简单的 JavaFX `Application`，它使用基于
    `Observable<String>` 构建的 `Binding<String>`，该 `Binding<String>` 用于绑定到 `label` 的
    `textProperty()` 操作符：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Since we have gotten so used to fluent programming with RxJava, would it not
    be nice to make the conversion of the `Observable<String>` to a `Binding<String>`
    part of the `Observable` chain too? This way, we do not have to break our fluent
    style and save intermediary variables. That can be done with the `to()` operator,
    which simply accepts an `Function<Observable<T>,R>` to turn an `Observable<T>`
    into any arbitrary `R` type. In this case, we can turn our `Observable<String>` into
    a `Binding<String>`at the end of our `Observable` chain using `to()`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经习惯了使用 RxJava 进行流畅编程，将 `Observable<String>` 转换为 `Binding<String>` 的过程也变成
    `Observable` 链的一部分不是很好吗？这样，我们就不必打破我们的流畅风格，也不必保存中间变量。这可以通过 `to()` 操作符来完成，它简单地接受一个
    `Function<Observable<T>,R>` 来将 `Observable<T>` 转换为任何任意的 `R` 类型。在这种情况下，我们可以在 `Observable`
    链的末尾使用 `to()` 将我们的 `Observable<String>` 转换为 `Binding<String>`：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Simple but helpful, right? When you are dealing with proprietary non-Rx types
    that can be built off Rx Observabes and Flowables, this is a handy utility to
    maintain the fluent Rx style, especially when interoperating with binding frameworks.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 简单但很有帮助，对吧？当你处理基于 Rx Observables 和 Flowables 构建的专有非 Rx 类型时，这是一个方便的实用工具，可以保持流畅的
    Rx 风格，尤其是在与绑定框架交互时。
- en: Operators
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作符
- en: Ideally, you will rarely get to a point where you need to build your own operator
    from scratch by implementing `ObservableOperator` or `FlowableOperator`. `ObservableTransformer`
    and `FlowableTransformer` will hopefully satisfy most cases where you can use
    existing operators to compose new ones, and this is usually the safest route.
    But on occasion, you may find yourself having to do something that the existing
    operators cannot do or not do easily. After you exhaust all other options, you
    may have to create an operator that manipulates each `onNext()`, `onComplete()`,
    and `onError()` event between the upstream and the downstream.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，你很少需要从头开始实现 `ObservableOperator` 或 `FlowableOperator` 来构建自己的操作符。`ObservableTransformer`
    和 `FlowableTransformer` 希望能满足大多数可以使用现有操作符组合新操作符的情况，这通常是 safest 的途径。但有时，你可能发现自己必须做一些现有操作符无法做到或不方便做到的事情。在你用尽所有其他选项之后，你可能不得不创建一个操作符，该操作符在上游和下游之间操作每个
    `onNext()`、`onComplete()` 和 `onError()` 事件。
- en: Before you go out and create your own operator, try to use existing operators
    first with `compose()` and a Transformer. After that fails, it is recommended
    that you post a question on StackOverflow and ask the RxJava community whether
    such an operator exists or can be composed easily. The RxJava community is very
    active on StackOverflow and they will likely provide a solution and only escalate
    the complexity of the solution as required.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在你出去创建自己的操作符之前，先尝试使用现有的操作符，通过 `compose()` 和转换器来实现。如果这还失败了，建议你在 StackOverflow
    上发帖询问，看看 RxJava 社区是否存在这样的操作符或者是否可以轻松组合。RxJava 社区在 StackOverflow 上非常活跃，他们可能会提供一个解决方案，并且只在需要时增加解决方案的复杂性。
- en: Note that David Karnok's [*RxJava2Extensions*](https://github.com/akarnokd/RxJava2Extensions)
    and Dave Moten's [*RxJava2-Extras*](https://github.com/davidmoten/rxjava2-extras)
    have many useful Transformers and operators to augment RxJava as well. You should
    check out these libraries to see whether they fulfill your needs.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，David Karnok 的 [*RxJava2Extensions*](https://github.com/akarnokd/RxJava2Extensions)
    和 Dave Moten 的 [*RxJava2-Extras*](https://github.com/davidmoten/rxjava2-extras)
    包含许多有用的转换器和操作符，可以增强 RxJava。你应该查看这些库，看看它们是否满足你的需求。
- en: If it is determined that there are no existing solutions, then proceed carefully
    to build your own operator. Again, it is recommended that you solicit help from
    StackOverflow first. Building a native operator is no easy task, and getting insight
    and experience from an Rx expert is highly valuable and most likely necessary.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果确定没有现有的解决方案，那么请谨慎地构建自己的操作符。再次强调，建议你首先在 StackOverflow 上寻求帮助。构建一个原生操作符并不容易，从
    Rx 专家那里获得见解和经验是非常有价值的，并且很可能是有必要的。
- en: Implementing an ObservableOperator
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 `ObservableOperator`
- en: Implementing your own `ObservableOperator` (as well as `FlowableTransformer`)
    is more involved than creating an `ObservableTransformer`. Instead of composing
    a series of existing operators, you intercept the `onNext()`, `onComplete()`,
    `onError()`, and `onSubscribe()` calls from the upstream by implementing your
    own `Observer` instead. This `Observer` will then logically pass the `onNext()`,
    `onComplete()`, and `onError()` events to the downstream `Observer` in a way that
    fulfills the desired operation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `ObservableOperator`（以及 `FlowableTransformer`）比创建 `ObservableTransformer`
    更复杂。不是通过组合一系列现有的操作符，而是通过实现自己的 `Observer` 来拦截来自上游的 `onNext()`、`onComplete()`、`onError()`
    和 `onSubscribe()` 调用。这个 `Observer` 将逻辑上传递 `onNext()`、`onComplete()` 和 `onError()`
    事件到下游 `Observer`，以实现所需操作。
- en: Say, you want to create your own `doOnEmpty()` operator that will execute an `Action`
    when `onComplete()` is called and no emissions have occurred. To create your own
    `ObservableOperator<Downstream,Upstream>` (where `Upstream` is the upstream emission
    type and `Downstream` is the downstream emission type), you will need to implement
    its `apply()` method. This accepts an `Observer<Downstream>` `observer` argument and
    returns an `Observer<Upstream>`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想创建自己的 `doOnEmpty()` 操作符，该操作符在调用 `onComplete()` 且没有发生任何发射时执行一个 `Action`。要创建自己的
    `ObservableOperator<Downstream,Upstream>`（其中 `Upstream` 是上游发射类型，`Downstream` 是下游发射类型），你需要实现其
    `apply()` 方法。这个方法接受一个 `Observer<Downstream>` 参数 `observer` 并返回一个 `Observer<Upstream>`。
- en: 'You can then use this `ObservableOperator` by calling it in the `lift()` operator
    in your `Observable` chain, as shown here:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在 `Observable` 链中的 `lift()` 操作符中调用它来使用这个 `ObservableOperator`，如下所示：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output is as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Inside `apply()`, you take the passed `Observer` that accepts events for the
    downstream. You create another `Observer` (in this case, we should use a `DisposableObserver`
    that handles disposal requests for us) to receive emissions and events from the
    upstream and relay them to the downstream `Observer`. You can manipulate the events
    to execute the desired logic as well as add any side-effects.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `apply()` 中，你接收传递的 `Observer`，该 `Observer` 接受下游的事件。你创建另一个 `Observer`（在这种情况下，我们应该使用一个
    `DisposableObserver`，它可以为我们处理销毁请求）来接收上游的发射和事件，并将它们传递给下游 `Observer`。你可以操纵事件以执行所需的逻辑，以及添加任何副作用。
- en: In this case, we simply passed the events from the upstream to the downstream
    untampered but track whether `onNext()` was called to flag if emissions were present.
    When `onComplete()` is called and no emissions are present, it will execute the
    user-specified action within `onComplete()`. It is usually a good idea to wrap
    any code that could throw runtime errors in `try-catch` and pass those captured
    errors to `onError()`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只是将上游的事件原封不动地传递到下游，但会跟踪是否调用了`onNext()`以标记是否有发射发生。当调用`onComplete()`且没有发射发生时，它将在`onComplete()`中执行用户指定的操作。通常，将可能抛出运行时错误的任何代码包裹在`try-catch`中，并将捕获的错误传递给`onError()`是一个好主意。
- en: With `ObservableOperator`, it may seem odd that you get the downstream as an
    input and have to produce an `Observer` for the upstream as the output. With the
    `map()` operator, for example, the function receives the upstream value and returns
    the value to be emitted toward the downstream. The reason for this is that code
    from an `ObservableOperator` gets executed at subscription time where the call
    travels from the end `Observer` (downstream) toward the source `Observable` (upstream).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ObservableOperator`时，你可能觉得奇怪，你得到的是下游作为输入，而必须为上游生成一个`Observer`作为输出。例如，在使用`map()`操作符时，函数接收上游的值并返回要向下游发射的值。这是因为来自`ObservableOperator`的代码在订阅时执行，此时调用是从末端的`Observer`（下游）向源`Observable`（上游）传递。
- en: 'Since it is a single abstract method class, you can also express your `ObservableOperator`
    implementation as a lambda, as shown here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是一个单抽象方法类，你也可以将你的`ObservableOperator`实现表达为一个lambda，如下所示：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Just like `Transformers`, be mindful when creating custom operators to not share
    states between subscriptions unless you absolutely mean to. This is a relatively
    simple operator because it is a simple reactive building block, but operators
    can be made enormously complex. This is especially the case when the operators
    deal with concurrency (for example, `observeOn()` and `subscribeOn()`) or share
    states between subscriptions (for example, `replay()`). The implementations of
    `groupBy()`, `flatMap()`, and `window()` are complicated and intricate as well.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`Transformers`一样，在创建自定义操作符时要小心，除非你确实想要这样做，否则不要在订阅之间共享状态。这是一个相对简单的操作符，因为它是一个简单的响应式构建块，但操作符可以变得极其复杂。这尤其适用于操作符处理并发（例如，`observeOn()`和`subscribeOn()`)或订阅之间共享状态（例如，`replay()`）时。`groupBy()`、`flatMap()`和`window()`的实现同样复杂和错综。
- en: There are a couple of rules in the `Observable` contract you must follow when
    calling the three events. Never call `onComplete()` after `onError()` has occurred
    (or vice versa). Do not call `onNext()` after `onComplete()` or `onError()` is
    called, and do not call any events after disposal. Breaking these rules can have
    unintended consequences downstream.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用三个事件时，`Observable`契约中有一些规则你必须遵守。在`onError()`发生之后（或反之）永远不要调用`onComplete()`。在调用`onComplete()`或`onError()`之后，不要调用`onNext()`，并且在销毁之后不要调用任何事件。违反这些规则可能会产生意外的后果。
- en: 'Another thing that needs to be pointed out is that `onNext()`, `onComplete()`,
    and `onError()` calls can be manipulated and mixed as needed. For example, `toList()`
    does not pass an `onNext()`call downstream for every `onNext()`it receives from
    the upstream. It will keep collecting these emissions in an internal list. When
    `onComplete()` is called from the upstream, it will call `onNext()` on the downstream
    to pass that list before it calls `onComplete()`. Here, we implement our own `myToList()`
    operator to understand how `toList()` could work, even though in normal circumstances,
    we should use `collect()` or `toList()`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要指出的是，`onNext()`、`onComplete()`和`onError()`调用可以根据需要被操作和混合。例如，`toList()`不会为从上游接收到的每个`onNext()`调用都向下游传递一个`onNext()`调用。它将在内部列表中持续收集这些发射。当上游调用`onComplete()`时，它将在调用`onComplete()`之前在下游上调用`onNext()`以传递该列表。在这里，我们实现了自己的`myToList()`操作符来理解`toList()`是如何工作的，尽管在正常情况下，我们应该使用`collect()`或`toList()`：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Before you start getting ambitious in creating your own operators, it might
    be good to study the source code of RxJava or other libraries, such as RxJava2-Extras.
    Operators can be difficult to implement correctly as you need to have a good understanding
    of how to build reactive patterns from imperative ones. You will also want to
    test the heck out of it (which we will cover in [Chapter 10](ec80132f-c411-4cc1-87b2-7a8ebba089b8.xhtml), *Testing
    and Debugging*) in order to ensure that it behaves correctly before putting it
    in production.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始雄心勃勃地创建自己的操作符之前，研究RxJava或其他库（如RxJava2-Extras）的源代码可能是个好主意。操作符的正确实现可能很困难，因为你需要很好地理解如何从命令式模式构建响应式模式。你也会想彻底测试它（我们将在第10章[Testing
    and Debugging](ec80132f-c411-4cc1-87b2-7a8ebba089b8.xhtml)中介绍），以确保在生产之前它表现正确。
- en: FlowableOperator
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FlowableOperator
- en: 'When you create your own `ObservableOperator`, you will most likely want to
    create a `FlowableOperator` counterpart as well. This way, your operator can be
    used for both Observables and Flowables. Thankfully, `FlowableOperator` is implemented
    in a similar manner to `ObservableOperator`, as shown here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建自己的`ObservableOperator`时，你很可能会同时创建一个`FlowableOperator`的对应物。这样，你的操作符就可以用于Observables和Flowables。幸运的是，`FlowableOperator`的实现方式与`ObservableOperator`类似，如下所示：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Instead of Observers, we used Subscribers, which hopefully is not surprising
    at this point. The `Subscriber` passed via `apply()` receives events for the downstream,
    and the implemented `Subscriber` receives events from the upstream, which it relays
    to the downstream (just as we used `DisposableObserver`, we use `DisposableSubscriber`
    to handle disposal/unsubscription for us). Just like earlier, `onComplete()` will
    verify that no emissions occurred and run the specified action if that is the
    case.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有使用观察者，而是使用了订阅者，希望这一点不会让你感到惊讶。通过`apply()`传递的`Subscriber`接收下游的事件，而实现的`Subscriber`接收上游的事件，并将其转发到下游（就像我们使用了`DisposableObserver`一样，我们使用`DisposableSubscriber`来处理销毁/取消订阅）。就像之前一样，`onComplete()`将验证没有发生发射，并在这种情况下运行指定的操作。
- en: 'And of course, you can express your `FlowableOperator`as a lambda too:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以将你的`FlowableOperator`表达为lambda表达式：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Again, be studious and thorough when you start implementing your own operators,
    especially as they pass a threshold of complexity. Strive to use existing operators
    to compose Transformers, and hit StackOverflow or the RxJava community to see
    whether others can point out an obvious solution first. Implementing operators
    is something you should be conservative about and only pursue when all other options
    have been exhausted.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，当你开始实现自己的操作符时，要勤奋并彻底，尤其是在它们达到复杂性的阈值时。努力使用现有的操作符来组合Transformers，并在StackOverflow或RxJava社区中寻求帮助，看看其他人是否能首先指出明显的解决方案。实现操作符是一件你应该谨慎对待的事情，只有在所有其他选项都已用尽时才追求。
- en: Custom Transformers and operators for Singles, Maybes, and Completables
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单独为Singles、Maybes和Completables创建的Transformer和操作符
- en: There are Transformer and operator counterparts for `Single`, `Maybe`, and `Completable`.
    When you want to create an `Observable` or `Flowable` operator that yields `Single`,
    you might find it easier to convert it back into an `Observable`/`Flowable` by
    calling its `toObservable()` or `toFlowable()` operators. This also applies to
    `Maybe`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Single`、`Maybe`和`Completable`，都有对应的Transformer和操作符。当你想要创建一个产生`Single`的`Observable`或`Flowable`操作符时，你可能发现通过调用其`toObservable()`或`toFlowable()`操作符将其转换回`Observable`/`Flowable`可能更容易。这也适用于`Maybe`。
- en: If on some rare occasion you need to create a Transformer or operator specifically
    to take a `Single` and transform it into another `Single`, you will want to use `SingleTransformer`
    or `SingleOperator`. `Maybe` and `Completable` will have counterparts with `MaybeTransformer`/`MaybeOperator`
    and `CompletableTransformer`/`CompletableOperator`, respectively. The implementation
    of `apply()` for all of these should largely be the same experience, and you will
    use `SingleObserver`, `MaybeObserver`, and `CompletableObserver` to proxy the
    upstream and downstream.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在某些罕见的情况下，你需要创建一个专门用于将`Single`转换为另一个`Single`的`Transformer`或操作符，你将想要使用`SingleTransformer`或`SingleOperator`。`Maybe`和`Completable`将分别有`MaybeTransformer`/`MaybeOperator`和`CompletableTransformer`/`CompletableOperator`的对应物。所有这些`apply()`的实现应该有类似的体验，你将使用`SingleObserver`、`MaybeObserver`和`CompletableObserver`来代理上游和下游。
- en: 'Here is an example of a `SingleTransformer` that takes `Single<Collection<T>>`
    and maps the emitted `Collection` to an unmodifable collection:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个`SingleTransformer`的示例，它接受`Single<Collection<T>>`并将发射的`Collection`映射到一个不可修改的集合：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Using RxJava2-Extras and RxJava2Extensions
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RxJava2-Extras和RxJava2Extensions
- en: If you are interested in learning about additional operators beyond what RxJava
    provides, it may be worthwhile to explore the [*RxJava2-Extras*](https://github.com/davidmoten/rxjava2-extras)
    and [*RxJava2Extensions*](https://github.com/akarnokd/RxJava2Extensions) libraries.
    While neither of these libraries are at a 1.0 version, useful operators, Transformers,
    and `Observable`/`Flowable` factories are continually added as an ongoing project.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣想要了解RxJava提供的额外操作符，那么探索[*RxJava2-Extras*](https://github.com/davidmoten/rxjava2-extras)和[*RxJava2Extensions*](https://github.com/akarnokd/RxJava2Extensions)库可能是有价值的。虽然这两个库都没有达到1.0版本，但有用的操作符、转换器和`Observable`/`Flowable`工厂作为持续项目不断添加。
- en: 'Two useful operators are `toListWhile()` and `collectWhile()`. These will buffer
    emissions into a list or collection while they meet a certain condition. Because
    a `BiPredicate` passes both the list/collection and the next `T` item as lamda
    input parameters, you can use this to buffer items but cut off the moment something
    changes about the emissions. Here, we keep collecting strings into a list but
    push that list forward when the length changes (kind of like `distinctUntilChanged()`).
    We also will qualify a list being empty, as that is the start of the next buffer,
    as well as sample an item from the list to compare lengths with the next emission:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 两个有用的操作符是`toListWhile()`和`collectWhile()`。这些操作符会在满足一定条件时将发射项缓冲到列表或集合中。由于`BiPredicate`将列表/集合和下一个`T`项作为lambda输入参数传递，你可以使用这个功能来缓冲项目，但在发射项发生变化时停止缓冲。在这里，我们持续将字符串收集到列表中，但在长度变化时将列表向前推进（类似于`distinctUntilChanged()`）。我们还将检查列表是否为空，因为这是下一个缓冲的开始，以及从列表中采样一个项目来与下一个发射项比较长度：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Spend some quality time with RxJava2-Extras and RxJava2Extensions to learn about
    their custom operators. This way, you will not have to reinvent something that
    may already be done, and there are already many powerful factories and operators.
    One of my personal favorites is a resettable `cache()` operator, which works like
    the cache we studied in [Chapter 5](4d0b16d7-cc3c-4c9c-8666-7f80c96bd779.xhtml), *Multicasting*,
    but it can be cleared and then resubscribed to the source at any time. It can
    also clear the cache at fixed time intervals or periods of no activity, preventing
    stale caches from persisting.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在RxJava2-Extras和RxJava2Extensions上花费一些高质量的时间来了解它们的自定义操作符。这样，你就不必重新发明可能已经存在的东西，而且已经有很多强大的工厂和操作符。我个人最喜欢的一个是可重置的`cache()`操作符，它的工作方式类似于我们在[第5章](4d0b16d7-cc3c-4c9c-8666-7f80c96bd779.xhtml)中学习的缓存，*多播*，但它可以在任何时间清除并重新订阅到源。它还可以在固定的时间间隔或无活动期间清除缓存，防止过时的缓存持久化。
- en: Summary
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we got our feet wet by creating our own operators. It is preferable
    to use `ObservableTransformer` and `FlowableTransformer` to compose existing operators
    together to create new ones, and even with that, you need to be cautious when
    introducing stateful resources that cause undesirable side-effects. When all else
    fails, you can create your own `ObservableOperator` or `FlowableOperator` and
    create an operator at a low level that intercepts and relays each emission and
    event. This can be tricky and you should exhaust all other options, but with careful
    study and testing, creating operators can be a valuable advanced skill to have.
    Just be careful to not reinvent the wheel and seek guidance from the Rx community
    as you start dabbling in custom operators.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过创建自己的操作符来入门。使用`ObservableTransformer`和`FlowableTransformer`将现有操作符组合在一起以创建新的操作符更为可取，即使如此，引入可能导致不希望副作用的状态资源时也需要谨慎。当所有其他方法都失败时，你可以创建自己的`ObservableOperator`或`FlowableOperator`，并在低级别创建一个拦截和转发每个发射项和事件的操作符。这可能很棘手，你应该尝试所有其他选项，但通过仔细研究和测试，创建操作符可以是一项有价值的先进技能。只是要小心不要重复造轮子，并在开始尝试自定义操作符时寻求Rx社区的帮助。
- en: If you truly are interested in implementing your own operators (at a low level,
    not with Transformers), definitely study existing operators in RxJava and other
    reputable RxJava extension libraries. It is easy to hack an operator together
    and believe nothing will go wrong, when in fact there are a lot of complications
    you can overlook. Your operator needs to be serialized, cancellable, concurrent,
    and handle re-entrancy (which occurs when an emission invokes a request on the
    same thread). Of course, some operators are simpler than others, but you should
    never assume without committed study first.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真正对实现自己的操作符（在低级别上，而不是使用Transformers）感兴趣，那么一定要研究RxJava和其他信誉良好的RxJava扩展库中的现有操作符。很容易拼凑出一个操作符并相信一切都会顺利进行，但实际上有很多你可能忽略的复杂性。你的操作符需要支持序列化、可取消、并发，并处理重入性（当发射操作在同一个线程上引发请求时发生）。当然，有些操作符比其他操作符简单，但你绝不应该在没有深入研究之前就做出假设。
- en: In the next chapter, we will learn about the different strategies to do unit
    testing against RxJava APIs and utilities. Whether you create your own custom
    operators or you have an Rx project at work, automated testing is something you
    will want to be proficient in. We will also learn how to debug RxJava applications,
    which is not always easy, but it can be done effectively.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于针对RxJava API和实用工具进行单元测试的不同策略。无论你是否创建了自己的自定义操作符，或者在工作中有一个Rx项目，自动化测试都是你想要熟练掌握的技能。我们还将学习如何调试RxJava应用程序，这并不总是容易，但可以有效地完成。
