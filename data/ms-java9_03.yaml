- en: Java 9 Language Enhancements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 9 语言增强
- en: In the previous chapter, we gained insight into some exciting new features contained
    in Java 9\. Our focus was on javac, the JDK libraries, and test suites. We learned
    about memory management improvements including memory allocation, heap optimizations,
    and enhanced garbage collection. We also covered changes to the compilation process,
    type testing, annotations, and runtime compiler tests.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了 Java 9 中包含的一些令人兴奋的新特性。我们的重点是 javac、JDK 库和测试套件。我们了解了内存管理改进，包括内存分配、堆优化和增强的垃圾回收。我们还涵盖了编译过程、类型测试、注解和运行时编译器测试的变更。
- en: This chapter covers some changes in Java 9 that impact variable handlers, depreciation
    warnings, improvements on Project Coin changes implemented in Java 7, and import
    statement processing. These represent changes to the Java language itself.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了 Java 9 中对变量处理器、弃用警告、Java 7 中实现的 Project Coin 变更的改进以及导入语句处理的一些变更。这些变更代表了
    Java 语言本身的变更。
- en: 'The topics we will cover here are:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里讨论的主题包括：
- en: Variable handlers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量处理器
- en: Import statement depreciation warnings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入语句弃用警告
- en: Project Coin
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Project Coin
- en: Import statement processing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入语句处理
- en: Working with variable handlers [JEP 193]
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用变量处理器 [JEP 193]
- en: 'Variable handlers are typed references to variables and are governed by the
    `java.lang.invoke.VarHandle` abstract class. The `VarHandle` method''s signature
    is polymorphic. This provides for great variability in both method signatures
    and return types. Here is a code sample demonstrating how a `VarHandle` might
    be used:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 变量处理器是变量的类型化引用，并由 `java.lang.invoke.VarHandle` 抽象类管理。`VarHandle` 方法的签名是多态的。这为方法签名和返回类型提供了极大的可变性。以下是一个代码示例，演示了如何使用
    `VarHandle`：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see in the preceding code snippet, the `VarHandle.lookup()` performs
    the same operation as those that are performed by a `MethodHandle.lookup()` method.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，`VarHandle.lookup()` 执行的操作与 `MethodHandle.lookup()` 方法执行的操作相同。
- en: 'The aim of this JEP was to standardize the way in which methods of the following
    classes are invoked:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本 JEP 的目标是标准化以下类的方法调用方式：
- en: '`java.util.concurrent.atomic`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.concurrent.atomic`'
- en: '`sun.misc.Unsafe`</li>'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sun.misc.Unsafe`'
- en: 'Specifically, methods that:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，以下类的方法调用方式：
- en: accessed/mutated object fields
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问/修改对象字段
- en: accessed/mutated elements of an array
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问/修改数组元素
- en: 'In addition, this JEP resulted in two fence operations for memory ordering
    and object reachability. In the spirit of due diligence, special attention was
    given to ensure the JVM''s safety. It was important to ensure that memory errors
    did not result from these changes. Data integrity, usability, and, of course,
    performance were key components of the aforementioned due diligence and are explained
    as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，本 JEP 导致了两个用于内存排序和对象可达性的栅栏操作。本着尽职尽责的精神，特别关注确保 JVM 的安全性。重要的是要确保这些变更不会导致内存错误。数据完整性、可用性和当然，性能是上述尽职尽责的关键组成部分，以下将进行解释：
- en: '**Safety**: Corrupt memory states must not be possible.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：必须不可能出现损坏的内存状态。'
- en: '**Data integrity**: Ensure access to an object''s field uses identical rules
    used by:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据完整性**：确保访问对象字段的规则与以下规则相同：'
- en: '`getfield` byte code'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getfield` 字节码'
- en: '`putfield` byte code'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`putfield` 字节码'
- en: '**Usability**: The benchmark for usability was the `sun.misc.Unsafe` API. The
    goal was to make the new API easier to use than the benchmark.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：可用性的基准是 `sun.misc.Unsafe` API。目标是使新 API 比基准更容易使用。'
- en: '**Performance**: There could be no degradation of performance compared to the
    use of the `sun.misc.Unsafe` API. The goal was to outperform that API.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：与使用 `sun.misc.Unsafe` API 相比，性能不能下降。目标是超越该 API。'
- en: In Java, a fence operation is what javac does to force a constraint on memory
    in the form of a barrier instruction. These operations occur before and after
    the barrier instruction, essentially fencing them in.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，栅栏操作是 javac 强制对内存施加约束的形式，这种约束以屏障指令的形式出现。这些操作发生在屏障指令之前和之后，本质上是在这些操作周围设置栅栏。
- en: Working with the AtoMiC Toolkit
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 AtoMiC 工具包
- en: The `java.util.concurrent.atomic` package is a collection of 12 sub-classes
    that support operations on single variables that are thread-safe and lock-free.
    In this context, thread-safe refers to code that accesses or mutates a shared
    single variable without impeding on other threads executing on the variable at
    the same time. This superclass was introduced in Java 7.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.concurrent.atomic` 包包含 12 个子类，支持对线程安全和无锁的单个变量进行操作。在这个上下文中，线程安全指的是访问或修改共享单个变量的代码，而不会阻碍其他线程同时在该变量上执行。这个超类是在
    Java 7 中引入的。'
- en: 'Here is a list of the 12 sub-classes in the AtoMiC Toolkit. The class names,
    as you would expect, are self-descriptive:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 AtoMiC 工具包中 12 个子类的一个列表。正如你所期望的，类名具有自描述性：
- en: '| **Atomic subclass** |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **原子子类** |'
- en: '| `java.util.concurrent.atomic.AtomicBoolean` |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.concurrent.atomic.AtomicBoolean` |'
- en: '| `java.util.concurrent.atomic.AtomicInteger` |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.concurrent.atomic.AtomicInteger` |'
- en: '| `java.util.concurrent.atomic.AtomicIntegerArray` |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.concurrent.atomic.AtomicIntegerArray` |'
- en: '| `java.util.concurrent.atomic.AtomicIntegerFieldUpdater<T>` |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.concurrent.atomic.AtomicIntegerFieldUpdater<T>` |'
- en: '| `java.util.concurrent.atomic.AtomicLong` |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.concurrent.atomic.AtomicLong` |'
- en: '| `java.util.concurrent.atomic.AtomicLongArray` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.concurrent.atomic.AtomicLongArray` |'
- en: '| `java.util.concurrent.atomic.AtomicLongFieldUpdater<T>` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.concurrent.atomic.AtomicLongFieldUpdater<T>` |'
- en: '| `java.util.concurrent.atomic.AtomicMarkableReference<V>` |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.concurrent.atomic.AtomicMarkableReference<V>` |'
- en: '| `java.util.concurrent.atomic.AtomicReference<V>` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.concurrent.atomic.AtomicReference<V>` |'
- en: '| `java.util.concurrent.atomic.AtomicReferenceArray<E>` |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.concurrent.atomic.AtomicReferenceArray<E>` |'
- en: '| `java.util.concurrent.atomic.AtomicReferenceFieldUpdater<T,V>` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.concurrent.atomic.AtomicReferenceFieldUpdater<T,V>` |'
- en: '| `java.util.concurrent.atomic.AtomicStampedReference<V>` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.concurrent.atomic.AtomicStampedReference<V>` |'
- en: Volatile variables, fields, and array elements can be asynchronously modified
    by concurrent threads.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 可变变量、字段和数组元素可以被并发线程异步修改。
- en: In Java, the `volatile` keyword is used to inform the javac utility to read
    the value, field, or array element from the main memory and not to cache them.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，`volatile` 关键字用于通知 javac 工具从主内存中读取值、字段或数组元素，而不是将它们缓存。
- en: 'Here is a code snippet that demonstrates the use of the volatile keyword for
    an instance variable:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个代码片段，演示了如何使用 `volatile` 关键字对一个实例变量进行操作：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using the sun.misc.Unsafe class
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `sun.misc.Unsafe` 类
- en: The `sun.misc.Unsafe` class, like other `sun` classes, is not officially documented
    or supported. It has been used to circumvent some of Java's built-in memory management
    safety features. While this can be viewed as a window to greater control and flexibility
    in our code, it is a terrible programming practice.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`sun.misc.Unsafe` 类，像其他 `sun` 类一样，并未官方文档化或支持。它曾被用来绕过 Java 内置的某些内存管理安全特性。虽然这可以被视为在代码中获得更多控制和灵活性的窗口，但它是一种糟糕的编程实践。'
- en: 'The class had a single private constructor, so an instance of the class could
    not easily be instantiated. So, if we tried to instantiate an instance with `myUnsafe
    = new Unsafe()`, a `SecurityException` would be thrown in most circumstances.
    This somewhat unreachable class has over 100 methods that permitted operations
    on arrays, classes, and objects. Here is a brief sampling of those methods:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 该类有一个单独的私有构造函数，因此无法轻松实例化该类的实例。所以，如果我们尝试使用 `myUnsafe = new Unsafe()` 实例化一个实例，在大多数情况下都会抛出
    `SecurityException`。这个相对难以触及的类有超过 100 个方法，允许对数组、类和对象进行操作。以下是这些方法的简要示例：
- en: '| **Arrays** | **Classes** | **Objects** |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| **数组** | **类** | **对象** |'
- en: '| `arrayBaseOffset` | `defineAnonymousClass` | `allocateInstance` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `arrayBaseOffset` | `defineAnonymousClass` | `allocateInstance` |'
- en: '| `arrayIndexScale` | `defineClass` | `objectFieldOffset` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `arrayIndexScale` | `defineClass` | `objectFieldOffset` |'
- en: '|  | `ensureClassInitialized` |  |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '|  | `ensureClassInitialized` |  |'
- en: '|  | `staticFieldOffset` |  |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '|  | `staticFieldOffset` |  |'
- en: 'Here is a secondary grouping of the `sun.misc.Unsafe` class method for information,
    memory, and synchronization:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `sun.misc.Unsafe` 类方法的一个关于信息、内存和同步的次要分组：
- en: '| **Information** | **Memory** | **Synchronization** |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| **信息** | **内存** | **同步** |'
- en: '| `addressSize` | `allocateMemory` | `compareAndSwapInt` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `addressSize` | `allocateMemory` | `compareAndSwapInt` |'
- en: '| `pageSize` | `copyMemory` | `monitorEnter` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `pageSize` | `copyMemory` | `monitorEnter` |'
- en: '|  | `freeMemory` | `monitorExit` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '|  | `freeMemory` | `monitorExit` |'
- en: '|  | `getAddress` | `putOrderedEdit` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '|  | `getAddress` | `putOrderedEdit` |'
- en: '|  | `getInt` | `tryMonitorEnter` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '|  | `getInt` | `tryMonitorEnter` |'
- en: '|  | `putInt` |  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '|  | `putInt` |  |'
- en: The `sun.misc.Unsafe` class was earmarked for removal in Java 9\. There was
    actually some opposition to this decision in the programming industry. To put
    their concerns to rest, the class has been depreciated, but will not be completely
    removed. A special flag can be sent to the JVM to utilize the original API.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`sun.misc.Unsafe`类在Java 9中被标记为删除。实际上，在编程行业中对此决策有一些反对意见。为了平息他们的担忧，该类已被弃用，但不会完全删除。可以向JVM发送一个特殊标志来利用原始API。'
- en: Eliding depreciation warnings on import statements [JEP 211]
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在导入语句上省略弃用警告 [JEP 211]
- en: This is one of the more simplistic JEPs for Java 9\. Quite often, when we compile
    our programs, we receive many warnings and errors. The compiler errors must be
    fixed as they are typically syntactical in nature. The warnings, on the other
    hand, should be reviewed and appropriately addressed. Some of the warning messages
    are ignored by developers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些Java 9中较为简单的JEP之一。我们经常在编译程序时接收到许多警告和错误。编译器错误必须修复，因为它们通常是语法性的。另一方面，警告应该被审查并适当处理。一些警告消息被开发者忽略。
- en: 'This JEP provides slight relief in the number of warnings we receive. Specifically,
    depreciation warnings caused by import statements are no longer generated. Prior
    to Java 9, we could suppress deprecated warning messages with the following annotation:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个JEP在接收到警告的数量上提供了一些缓解。具体来说，由于导入语句引起的弃用警告不再生成。在Java 9之前，我们可以使用以下注解来抑制弃用警告消息：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, with Java 9, the compiler will suppress depreciated warnings if one or
    more of the following cases is true:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着Java 9的到来，编译器将在以下情况之一为真时抑制弃用警告：
- en: If the `@Deprecated` annotation is used
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用了`@Deprecated`注解
- en: If the `@SuppressWarnings` annotation is used
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用了`@SuppressWarnings`注解
- en: If the use of the warning-generating code and the declaration are within the
    ancestor class
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果生成警告的代码的使用和声明在祖先类内
- en: If the use of the warning-generating code is within an import statement
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果生成警告的代码的使用在导入语句内
- en: The fourth condition listed was an addition in Java 9.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的第四个条件是在Java 9中添加的。
- en: Milling Project Coin [JEP 213]
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 磨削项目硬币 [JEP 213]
- en: 'Project Coin was a feature set of minor changes introduced in Java 7\. These
    changes are listed as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Project Coin是在Java 7中引入的较小更改的功能集。以下列出了这些更改：
- en: Strings in `switch` statements
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch`语句中的字符串'
- en: Binary integral literals
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制整型文字
- en: Using underscores in numeric literals
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数字文字中使用下划线
- en: Implementing multi-catch
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现多捕获
- en: Allowing for more precise re-throwing of exceptions
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许更精确地重新抛出异常
- en: Generic instance creation improvements
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型实例创建改进
- en: Addition of the `try-with-resources` statement
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了`try-with-resources`语句
- en: Improvements to invoking `varargs` methods
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`varargs`方法的改进
- en: 'Detailed information can be found in the following Oracle presentation: [http://www.oracle.com/us/technologies/java/project-coin-428201.pdf](http://www.oracle.com/us/technologies/java/project-coin-428201.pdf).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 详细信息可以在以下Oracle演示文稿中找到：[http://www.oracle.com/us/technologies/java/project-coin-428201.pdf](http://www.oracle.com/us/technologies/java/project-coin-428201.pdf)。
- en: JEP 213 focused on improvements to Project Coin's enhancements. There were five
    such enhancements, each detailed as follows.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: JEP 213专注于对Project Coin增强功能的改进。共有五个这样的增强，如下详细说明。
- en: Using the @SafeVarargs annotation
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用@SafeVarargs注解
- en: In Java 9, we can use the `@SafeVarargs` annotation with private instance methods.
    When we use this annotation, we are asserting that the method does not contain
    any harmful operations on the `varargs` passed as parameters to the method.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9中，我们可以使用`@SafeVarargs`注解与私有实例方法。当我们使用这个注解时，我们正在断言该方法不包含对作为方法参数传递的`varargs`执行任何有害操作。
- en: 'The syntax for usage is:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的语法如下：
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Use of the `@SafeVarargs` annotation is restricted to:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`@SafeVarargs`注解的使用限制为：'
- en: Static methods
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态方法
- en: Final instance methods
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终实例方法
- en: Private instance methods
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有实例方法
- en: The try-with-resource statement
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: try-with-resource语句
- en: 'The `try-with-resource` statement previously required a new variable to be
    declared for each resource in the statement when a final variable was used. Here
    is the syntax for the `try-with-resource` statement prior to Java 9 (in Java 7
    or 8):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用最终变量时，`try-with-resource`语句之前需要为语句中的每个资源声明一个新变量。以下是Java 9之前（在Java 7或8）`try-with-resource`语句的语法：
- en: '[PRE4]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is a code snippet using the preceding syntax:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用上述语法的代码片段：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, with Java 9, the `try-with-resource` statement can manage final variables
    without requiring a new variable declaration. So, we can now rewrite the earlier
    code, as shown here in Java 9:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着Java 9的推出，`try-with-resource`语句可以管理final变量，而无需声明新变量。因此，我们现在可以重写之前的代码，如下所示，在Java
    9中：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, the `xmlScanner` object reference is contained inside the `try-with-resource`
    statement block, which provides for automatic resource management. The resource
    will automatically be closed as soon as the `try-with-resource` statement block
    is exited.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`xmlScanner`对象引用包含在`try-with-resource`语句块中，这提供了自动资源管理。资源将在`try-with-resource`语句块退出时自动关闭。
- en: You can also use a `finally` block as part of the `try-with-resource` statement.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将`finally`块作为`try-with-resource`语句的一部分使用。
- en: Using the diamond operator
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用菱形运算符
- en: Introduced in Java 9, the diamond operator can be used with anonymous classes
    if the inferred data type is denotable. When a data type is inferred, it suggests
    that the Java Compiler can determine the data types in a method's invocation.
    This includes the declaration and any included arguments.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9中引入的菱形运算符，如果推断的数据类型是可表示的，则可以与匿名类一起使用。当推断数据类型时，这表明Java编译器可以确定方法调用中的数据类型。这包括声明和任何包含的参数。
- en: The diamond operator is the less-than and greater-than symbol pair (`<>` ).
    It is not new to Java 9; rather, the specific use with anonymous classes is.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 菱形运算符是小于和大于符号对（`<>`）。它对Java 9来说并不新鲜；相反，与匿名类的特定使用才是。
- en: 'The diamond operator was introduced in Java 7 and made instantiating generic
    classes simpler. Here is a pre-Java 7 example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 菱形运算符是在Java 7中引入的，使得实例化泛型类变得更加简单。以下是一个Java 7之前的示例：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, in Java 7, we could rewrite it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在Java 7中，我们可以这样重写：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The problem was that this method could not be used for anonymous classes. Here
    is an example in Java 8 that works fine:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于这个方法不能用于匿名类。以下是一个Java 8中的示例，它运行良好：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'While the preceding code works fine, when we change it to use the diamond operator,
    as shown here, a compiler error will occur:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的代码运行良好，但当我们将其更改为使用菱形运算符，如这里所示时，将发生编译器错误：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The error results from using the diamond operator with anonymous inner classes.
    Java 9 to the rescue. While the preceding code results in a compile time error
    in Java 8, it works fine in Java 9.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 错误是由使用菱形运算符和匿名内部类引起的。Java 9来拯救。虽然前面的代码在Java 8中会导致编译时错误，但在Java 9中运行良好。
- en: Discontinuing use of the underscore
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 停止使用下划线
- en: 'The underscore character ( `_` ) can no longer be used as a legal identifier
    name. Earlier attempts to remove the underscore in an identifier name were incomplete.
    The use of such would generate a combination of errors and warnings. With Java
    9, the warnings are now errors. Consider the following sample code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 下划线字符（`_`）不能再用作合法的标识符名称。之前尝试从标识符名称中删除下划线的尝试是不完整的。这样的使用将生成错误和警告的组合。在Java 9中，这些警告现在是错误。考虑以下示例代码：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code, in Java 8, will result in compiler warnings for `int _ =
    319;` and `if ( _ > 300 )` statements. The warning is *as of release 9, '_' is
    a keyword, and may not be used as an identifier*. So, in Java 9, you will not
    be able to use the underscore by itself as a legal identifier.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8中，前面的代码将对`int _ = 319;`和`if (_ > 300)`语句产生编译器警告。警告是自版本9起，`_`是一个关键字，不能用作标识符。因此，在Java
    9中，您将无法使用下划线本身作为合法的标识符。
- en: It is considered bad programming practice to use identifier names that are not
    self-descriptive. So, the use of the underscore character by itself as an identifier
    name should not be a problematic change.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 被认为是不良的编程实践，使用不具有自我描述性的标识符名称。因此，仅使用下划线字符作为标识符名称不应是一个有问题的更改。
- en: Making use of private interface methods
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用私有接口方法
- en: Lambda expressions were a big part of the Java 8 release. As a follow-up to
    that improvement, private methods in interfaces are now feasible. Previously,
    we could not share data between non-abstract methods of an interface. With Java
    9, this data sharing is possible. Interface methods can now be private. Let's
    look at some sample code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式是Java 8发布的一个重要部分。作为该改进的后续，接口中的私有方法现在可行。以前，我们无法在接口的非抽象方法之间共享数据。随着Java
    9的推出，这种数据共享成为可能。接口方法现在可以是私有的。让我们看看一些示例代码。
- en: 'This first code snippet is how we might code an interface in Java 8:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个代码片段是我们在Java 8中编写接口的方式：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, in Java 9, we can rewrite this code. As you can see next, the redundant
    code has been moved into a single private method called `characterTravel`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 Java 9 中，我们可以重写这段代码。正如您接下来可以看到的，冗余的代码已被移动到单个名为 `characterTravel` 的私有方法中：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Processing import statements correctly [JEP 216]
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正确处理导入语句 [JEP 216]
- en: JEP 216 was issued as a fix to javac in regards to how import statements are
    processed. Prior to Java 9, there were instances where the order of import statements
    would impact if the source code was accepted or not.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: JEP 216 作为对 javac 处理导入语句的修复而发布。在 Java 9 之前，存在一些情况下导入语句的顺序会影响源代码是否被接受。
- en: When we develop applications in Java, we typically add import statements as
    we need them, resulting in an unordered list of import statements. IDEs do a great
    job of color-coding import statements that are not used, as well as informing
    us of import statements we need but that have not been included. It should not
    matter what order the import statements are in; there is no applicable hierarchy.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 Java 中开发应用程序时，我们通常会根据需要添加导入语句，从而形成一个无序的导入语句列表。IDEs 在对未使用的导入语句进行着色编码以及通知我们所需但尚未包含的导入语句方面做得很好。导入语句的顺序无关紧要；没有适用的层次结构。
- en: javac compiles classes in two primary steps. Specific to handling import statements,
    these steps are type resolution and member resolution. The type resolution consists
    of a review of the abstract syntax tree to identify declarations of classes and
    interfaces. The member resolution includes determining the class hierarchy and
    individual class variables and members.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: javac 以两个主要步骤编译类。对于处理导入语句，这些步骤是类型解析和成员解析。类型解析包括对抽象语法树的审查，以识别类和接口的声明。成员解析包括确定类层次结构和单个类变量和成员。
- en: 'With Java 9, the order we list import statements in our classes and files will
    no longer impact the compilation process. Let''s look at an example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 9 中，我们在类和文件中列出导入语句的顺序将不再影响编译过程。让我们来看一个例子：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding example, type resolution occurs and results in the following
    realizations:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，类型解析发生，并得出以下认识：
- en: '`SamplePackage.OuterPackage` exists'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SamplePackage.OuterPackage` 存在'
- en: '`SamplePackage.OuterPackage.Nested` exists'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SamplePackage.OuterPackage.Nested` 存在'
- en: '`SamplePackage.Thing.Innner` exists'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SamplePackage.Thing.Innner` 存在'
- en: 'The next step is member resolution, and this is where the problem existed prior
    to Java 9\. Here is an overview of the sequential steps javac would use to conduct
    the member resolution for our sample code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是成员解析，这是 Java 9 之前存在的问题所在。以下是 javac 对我们的示例代码进行成员解析的顺序步骤概述：
- en: Resolution of `SamplePackage.OuterPackage` begins.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SamplePackage.OuterPackage` 的解析开始。'
- en: The `SamplePackage.OuterPackage.Nested` import is processed.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SamplePackage.OuterPackage.Nested` 的导入被处理。'
- en: Resolution of the `SamplePackage.Outer.Nested` class begins.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SamplePackage.Outer.Nested` 类的解析开始。'
- en: The inner interface is type checked, although, because it is not in scope at
    this point, inner cannot be resolved.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内部接口进行了类型检查，尽管如此，由于它目前不在作用域内，因此内部无法解析。
- en: Resolution of `SamplePackage.Thing` begins. This step includes importing all
    member types of `SamplePackage.Thing` into scope.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SamplePackage.Thing` 的解析开始。此步骤包括将 `SamplePackage.Thing` 的所有成员类型导入作用域。'
- en: So the error occurs, in our example, because `Inner` is out of scope when resolution
    is attempted. If steps 4 and 5 were swapped, it would not have been a problem.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的例子中，错误发生是因为在尝试解析时 `Inner` 不在作用域内。如果步骤 4 和 5 互换，则不会出现问题。
- en: 'The solution to the problem, implemented in Java 9, was to break the member
    resolution steps into additional sub-steps. Here are those steps:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 中解决问题的方案是将成员解析步骤分解为额外的子步骤。以下是这些步骤：
- en: Analyze the import statements.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析导入语句。
- en: Create the hierarchy (class and interfaces).
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建层次结构（类和接口）。
- en: Analyze class headers and type parameters.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析类头和类型参数。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered changes in Java 9 with regards to variable handlers
    and how they relate to the Atomic Toolkit. We also covered depreciation warnings
    and why they are now suppressed under specific circumstances. Five enhancements
    to changes introduced with Java 7 as part of Project Coin were also reviewed.
    Finally, we explored the improvements to import statement processing.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Java 9 中关于变量处理器及其与 Atomic Toolkit 相关性的变化。我们还介绍了弃用警告及其在特定情况下被抑制的原因。还回顾了
    Project Coin 的一部分，即 Java 7 引入的五个变化增强。最后，我们探讨了导入语句处理方面的改进。
- en: In the next chapter, we will examine the structure of a Java module as specified
    by Project Jigsaw. We will take a deep dive into how Project Jigsaw is implemented
    as part of the Java platform. Code snippets from a sample e-commerce application
    are used throughout the chapter to demonstrate Java 9's modular system. Internal
    changes to the Java platform, in regards to the modular system, are also discussed.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨由 Project Jigsaw 规定的 Java 模块结构。我们将深入探讨 Project Jigsaw 作为 Java 平台一部分的实现方式。本章中使用了来自一个示例电子商务应用的代码片段，以展示
    Java 9 的模块化系统。同时，还讨论了 Java 平台在模块化系统方面的内部变化。
