- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: FIRST Tests and the Test Pyramid
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FIRST 测试和测试金字塔
- en: So far in this book, we’ve seen the value of writing unit tests that run quickly
    and give repeatable results. Called FIRST tests, these provide rapid feedback
    on our design. They are the gold standard of unit tests. We’ve also seen how the
    hexagonal architecture helps us design our code in a way that gets the maximum
    amount covered by FIRST unit tests. But we’ve also limited ourselves to testing
    only our domain model – the core of our application logic. We simply have no tests
    covering how our domain model behaves once it connects to the outside world.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，我们已经看到了编写快速运行并给出可重复结果的单元测试的价值。被称为 FIRST 测试，这些测试为我们提供了关于设计的快速反馈。它们是单元测试的黄金标准。我们还看到了如何通过六边形架构帮助我们以最大程度地覆盖
    FIRST 单元测试的方式来设计我们的代码。但我们也将自己限制在仅测试我们的领域模型——我们应用程序逻辑的核心。我们简单地没有测试覆盖领域模型连接到外部世界后的行为。
- en: In this chapter, we will cover all the other kinds of tests that we need. We
    will introduce the test pyramid, which is a way of thinking about the different
    kinds of tests needed, and how many of each we should have. We’ll discuss what
    each kind of test covers and useful techniques and tools to help. We’ll also bring
    the whole system together by introducing CI/CD pipelines and test environments,
    outlining the critical role they play in combining code components to create a
    system for our end users.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖我们需要的所有其他类型的测试。我们将介绍测试金字塔，这是一种思考所需不同类型测试及其数量的方法。我们将讨论每种测试覆盖的内容以及有用的技术和工具来帮助。我们还将通过介绍
    CI/CD 管道和测试环境，概述它们在将代码组件组合成最终用户系统中的关键作用。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: The test pyramid
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试金字塔
- en: Unit tests – FIRST tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试 – FIRST 测试
- en: Integration tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试
- en: End-to-end and user acceptance tests
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端到端和用户验收测试
- en: CI/CD pipelines and test environments
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CI/CD 管道和测试环境
- en: Wordz – integration test for our database
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wordz – 数据库的集成测试
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter10](https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter10).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter10](https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter10)找到。
- en: To run this code, we will need to install the open source Postgres database
    locally.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此代码，我们需要在本地安装开源的 Postgres 数据库。
- en: 'To install Postgres, do the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Postgres，请执行以下操作：
- en: Go to [https://www.postgresql.org/download/](https://www.postgresql.org/download/)
    in your browser.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的浏览器中转到[https://www.postgresql.org/download/](https://www.postgresql.org/download/)。
- en: 'Click on the correct installer for your operating system:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击您操作系统的正确安装程序：
- en: '![Figure 10.1 – Postgres installer selection](img/Figure_10.1_B18384.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – Postgres 安装程序选择](img/Figure_10.1_B18384.jpg)'
- en: Figure 10.1 – Postgres installer selection
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – Postgres 安装程序选择
- en: Follow the instructions for your operating system.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照您操作系统的说明进行操作。
- en: The test pyramid
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试金字塔
- en: A very useful way of thinking about different kinds of tests is by using the
    **test pyramid**. It is a simple graphical representation of the different kinds
    of tests we need around our code and the relative numbers of each. This section
    introduces the key ideas behind the test pyramid.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用**测试金字塔**来思考不同类型的测试是一种非常有用的方法。它是我们代码周围不同类型测试及其相对数量的简单图形表示。本节介绍了测试金字塔背后的关键思想。
- en: 'The test pyramid in graphic form looks as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 测试金字塔的图形形式如下所示：
- en: '![Figure 10.2 – The test pyramid](img/Figure_10.2_B18384.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 测试金字塔](img/Figure_10.2_B18384.jpg)'
- en: Figure 10.2 – The test pyramid
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 测试金字塔
- en: We can see from the previous graphic that tests are divided into four layers.
    We have unit tests at the bottom. Integration tests are layered on top of those.
    The pyramid is completed by end-to-end and user acceptance tests at the top. The
    graphic shows unit tests in our system are the highest in number, with fewer integration
    tests and the least number of acceptance tests.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图形中我们可以看到，测试被分为四层。我们在底部有单元测试。集成测试建立在那些之上。金字塔由顶部的端到端和用户验收测试完成。图形显示我们的系统中的单元测试数量最多，集成测试较少，验收测试最少。
- en: 'Some of these kinds of tests are new to this book. Let’s define what they are:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书中的一些测试类型是新的。让我们定义它们是什么：
- en: '**Unit tests**'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**'
- en: These are familiar. They are the FIRST tests we have been using up until now.
    One defining feature of these tests is that they do not require the presence of
    any external systems, such as databases or payment processors.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是熟悉的。它们是我们迄今为止一直在使用的FIRST测试。这些测试的一个定义特征是它们不需要任何外部系统的存在，例如数据库或支付处理器。
- en: '**Integration tests**'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**'
- en: These tests verify that a software component is correctly integrated with an
    external system, such as a database. These tests are slow and critically dependent
    on the external environment being available and correctly set up for our test.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试验证软件组件是否正确地与外部系统（如数据库）集成。这些测试速度较慢，并且关键依赖于外部环境是否可用以及是否正确设置以供我们的测试使用。
- en: '**End-to-end tests**'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端到端测试**'
- en: These are the broadest of all tests. An end-to-end test represents something
    very close to the end user experience. This test is performed against all the
    real components of the system – possibly in test environments with test data –
    using the same commands as a real user would use.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是最广泛的测试。端到端测试代表的是非常接近最终用户体验的东西。这个测试是对系统的所有真实组件进行的，可能在测试环境中使用测试数据，使用与真实用户相同的命令。
- en: '**User** **acceptance tests**'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户** **验收测试**'
- en: This is where the real system is tested as a user would use it. Here, we can
    confirm that the final system is fit for purpose, according to the requirements
    the user has given us.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在用户会使用它的方式测试真实系统的地方。在这里，我们可以确认最终系统符合用户给出的要求，适合使用。
- en: 'It’s not obvious at first why having fewer tests of any kind would be an advantage.
    After all, everything up until now in this book has positively praised the value
    of testing. Why do we not simply have *all the tests*? The answer is a pragmatic
    one: not all tests are created equal. They don’t all offer equal value to us as
    developers.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 起初并不明显，为什么减少任何类型的测试数量会是一个优势。毕竟，到目前为止，这本书中所有内容都积极赞扬了测试的价值。为什么我们不简单地进行*所有测试*呢？答案是一个实用主义的观点：并非所有测试都是平等的。它们并不都为我们作为开发者提供相同的价值。
- en: The reason for the shape of this pyramid is to reflect the practical value of
    each layer of testing. Unit tests written as FIRST tests are *fast* and *repeatable*.
    If we could build a system out of only these unit tests, we surely would. But
    unit tests do not exercise every part of our code base. Specifically, they do
    not exercise connections from our code to the outside world. Nor do they exercise
    our application in the same way as a user would use it. As we progress up through
    the layers of testing, we move away from testing the *internal* components of
    our software and move toward testing how it interacts with *external* systems
    and, ultimately, the end user of our application.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个金字塔形状的原因是为了反映每个测试层的实际价值。作为FIRST测试编写的单元测试是*快速*和*可重复的*。如果我们能够仅用这些单元测试构建一个系统，我们当然会的。但是单元测试并不测试我们代码库的每个部分。具体来说，它们并不测试我们的代码与外部世界的连接，也不以用户使用它的方式测试我们的应用程序。随着我们通过测试层级的提升，我们逐渐从测试软件的*内部*组件转向测试它与*外部*系统以及最终我们的应用程序用户的交互。
- en: 'The test pyramid is about *balance*. It aims to create layers of tests that
    achieve the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 测试金字塔是关于*平衡*的。它的目标是创建能够实现以下目标的测试层：
- en: Run as quickly as possible
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能快地运行
- en: Cover as much code as possible
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能覆盖尽可能多的代码
- en: Prevent as many defects as possible
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能预防尽可能多的缺陷
- en: Minimize duplication of the test effort
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化测试工作的重复
- en: In the following sections, we will look at a breakdown of the tests involved
    at each layer of the test pyramid. We’ll consider the strengths and weaknesses
    of each kind of test, allowing us to understand what the test pyramid is guiding
    us toward.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将查看测试金字塔每一层所涉及的测试的分解。我们将考虑每种测试的优缺点，使我们能够理解测试金字塔引导我们走向的方向。
- en: Unit tests – FIRST tests
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试 – FIRST测试
- en: In this section, we’re going to look at the base of the test pyramid, which
    consists of unit tests. We’ll examine why this layer is critical to success.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨测试金字塔的基础，它由单元测试组成。我们将研究为什么这一层对成功至关重要。
- en: By now, we’re very familiar with FIRST unit tests. The preceding chapters have
    covered these in detail. They are the gold standard of unit tests. They are fast
    to run. They are repeatable and reliable. They run isolated from each other, so
    we can run one, or run many and run them in any order we choose. FIRST tests are
    the powerhouses of TDD, enabling us to work with a rapid feedback loop as we code.
    Ideally, all our code would fall under this feedback loop. It provides a fast,
    efficient way to work. At every step, we can execute code and prove to ourselves
    that it is working as we intended. As a helpful byproduct, by writing tests that
    exercise each possible desirable behavior in our code, we will end up exercising
    every possible code path. We will get 100% *meaningful* test coverage of code
    under unit tests when we work in this way.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，我们对FIRST单元测试非常熟悉。前几章已经详细介绍了这些内容。它们是单元测试的黄金标准。它们运行速度快。它们可重复且可靠。它们相互独立运行，因此我们可以选择运行一个或多个，并且可以按任何顺序运行。FIRST测试是TDD的强大动力，使我们能够在编码时拥有快速的反馈循环。理想情况下，所有代码都应包含在这个反馈循环中。它提供了一种快速、高效的工作方式。在每一步，我们都可以执行代码并证明它按预期工作。作为有益的副产品，通过编写测试来锻炼我们代码中每个可能的可取行为，我们将最终锻炼到每个可能的代码路径。当我们这样工作时，我们将获得100%的*有意义*测试覆盖率。
- en: Because of their advantages, unit tests form the bedrock of our testing strategy.
    They are represented as the base of the test pyramid.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们的优点，单元测试构成了我们测试策略的基础。它们在测试金字塔中代表基础。
- en: 'Unit tests have advantages and limitations, as summarized in the following
    table:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试具有优点和局限性，如下表总结：
- en: '| **Advantages** | **Limitations** |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| **优点** | **局限性** |'
- en: '| --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| These are the fastest-running tests and provide the fastest possible feedback
    loop for our code. | The smaller scope of these tests means that having all unit
    tests pass is no guarantee that the system as a whole is working correctly. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 这些是运行最快的测试，为我们提供了代码的最快反馈循环。 | 这些测试的范围较小，因此所有单元测试通过并不能保证整个系统运行正确。 |'
- en: '| Stable and repeatable, having no dependencies on things outside of our control.
    | They can be written with too strong a tie to implementation details, making
    future additions and refactoring difficult. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 稳定且可重复，不依赖于我们无法控制的事物。 | 可能会与实现细节过于紧密地绑定，使得未来的添加和重构变得困难。 |'
- en: '| Can provide very detailed coverage of a specific set of logic. Locate defects
    accurately. | Not helpful for testing interactions with external systems. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 可以提供非常详细的特定逻辑覆盖。准确定位缺陷。 | 对于测试与外部系统的交互没有帮助。 |'
- en: Table 10.1 – Unit test advantages and disadvantages
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.1 – 单元测试的优点和缺点
- en: In any system, we expect to have the largest number of tests at the unit level.
    The test pyramid represents this graphically.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何系统中，我们都期望在单元级别拥有最多的测试。测试金字塔以图形方式表示这一点。
- en: We can’t achieve full coverage by using unit tests alone in the real world but
    we can improve our situation. By applying the hexagonal architecture to our application,
    we can get the majority of code under unit tests. Our fast-running unit tests
    can cover a lot of ground like this and provide a lot of confidence in our application
    logic. We can get as far as knowing that if the external systems behave as we
    expect them to, our domain layer code will be able to correctly handle every use
    case we have thought about.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，仅使用单元测试无法实现全面覆盖，但我们可以改善我们的情况。通过将六边形架构应用于我们的应用程序，我们可以使大部分代码处于单元测试之下。我们快速运行的单元测试可以覆盖大量内容，并为我们应用程序的逻辑提供大量信心。我们可以知道，如果外部系统按我们预期的方式表现，我们的领域层代码将能够正确处理我们考虑过的每个用例。
- en: 'The test position when using unit tests alone is shown in the following diagram:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单元测试单独进行测试时的测试位置如图所示：
- en: '![Figure 10.3 – Unit tests cover the domain model](img/Figure_10.3_B18384.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 单元测试覆盖领域模型](img/Figure_10.3_B18384.jpg)'
- en: Figure 10.3 – Unit tests cover the domain model
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 单元测试覆盖领域模型
- en: Unit tests only test components of our domain model. They do not test external
    systems, nor do they use external systems. They rely on test doubles to simulate
    our external systems for us. This gives us advantages in development cycle speed
    but has the drawback that our connections to those external systems remain untested.
    If we have a piece of unit-tested code that accesses a repository interface, we
    know that its logic works with a stub repository. Its internal logic will even
    have 100% test coverage and this will be valid. But we won’t know if it will work
    with the real repository yet.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试只测试我们的领域模型组件。它们不测试外部系统，也不使用外部系统。它们依赖于测试替身来模拟我们的外部系统。这给我们带来了开发周期速度上的优势，但缺点是那些外部系统的连接仍然未经过测试。如果我们有一段经过单元测试的代码访问存储库接口，我们知道它的逻辑与存根存储库兼容。它的内部逻辑甚至有100%的测试覆盖率，这是有效的。但我们还不知道它是否与真实存储库兼容。
- en: The adapter layer code is responsible for those connections, and it is not tested
    at the unit test level. To test this layer, we’re going to need a different approach
    to testing. We will need to test what happens when our domain layer code is integrated
    with actual external systems.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器层代码负责这些连接，并且它不在单元测试级别进行测试。为了测试这一层，我们需要一种不同的测试方法。我们需要测试当我们的领域层代码与实际外部系统集成时会发生什么。
- en: The next section looks at how we test these external systems adapters using
    a kind of testing known as integration tests.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将探讨如何使用一种称为集成测试的测试方法来测试这些外部系统适配器。
- en: Integration tests
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: 'In this section, we’re going to look at the next layer up in the test pyramid:
    integration testing. We’ll see why it’s important, review helpful tools, and understand
    the role of integration testing in the overall scheme of things.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨测试金字塔中的下一层：集成测试。我们将了解其重要性，回顾有用的工具，并理解集成测试在整个方案中的作用。
- en: '**Integration tests** exist to test that our code will successfully integrate
    with external systems. Our core application logic is tested by unit tests, which,
    by design, do not interact with external systems. This means that we need to test
    behavior with those external systems at some point.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成测试**存在是为了测试我们的代码能否成功与外部系统集成。我们的核心应用程序逻辑通过单元测试进行测试，而单元测试的设计原则是不与外部系统交互。这意味着我们需要在某个时候测试与那些外部系统的行为。'
- en: 'Integration tests are the second layer up in the test pyramid. They have advantages
    and limitations, as summarized in the following table:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试是测试金字塔的第二层。它们具有优点和局限性，如下表总结：
- en: '| **Advantages** | **Limitations** |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| **优点** | **局限性** |'
- en: '| --- | --- |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Test that software components interact correctly when connected | Require
    test environments to be set up and maintained |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 测试软件组件在连接时是否正确交互 | 需要设置和维护测试环境 |'
- en: '| Provide a closer simulation of the software system as it will be used live
    | Tests run more slowly than unit tests |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 提供更接近实际使用软件系统的模拟 | 测试运行速度比单元测试慢 |'
- en: '|  | Susceptible to problems in the test environment, such as incorrect data
    or network connection failures |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '|  | 易受测试环境中的问题影响，例如数据错误或网络连接故障 |'
- en: Table 10.2 – Integration test advantages and disadvantages
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.2 – 集成测试的优点和缺点
- en: There should be fewer integration tests than unit tests. Ideally, far fewer.
    While unit tests avoided many problems of testing external systems by using test
    doubles, integration tests must now face those challenges. By nature, they are
    more difficult to set up. They *can* be less repeatable. They generally run more
    slowly than unit tests do, as they wait for responses from external systems.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试的数量应该少于单元测试。理想情况下，要少得多。虽然单元测试通过使用测试替身避免了测试外部系统的许多问题，但集成测试现在必须面对这些挑战。本质上，它们更难设置。它们*可以*更不可重复。它们通常比单元测试运行得更慢，因为它们需要等待外部系统的响应。
- en: To give a sense of this, a typical system might have thousands of unit tests
    and hundreds of acceptance tests. In between, we have several integration tests.
    Many integration tests point to a design opportunity. We can refactor the code
    so that our integration test is pushed down to being a unit test or promoted to
    being an acceptance test.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让大家有一个概念，一个典型的系统可能有数千个单元测试和数百个验收测试。在这两者之间，我们有几个集成测试。许多集成测试指向设计机会。我们可以重构代码，使我们的集成测试被推到单元测试或提升为验收测试。
- en: Another reason to have fewer integration tests is due to **flaky tests**. A
    flaky test is a nickname given to a test that sometimes passes and sometimes fails.
    When it fails, it is due to some problem interacting with the external system
    and not a defect in the code we are testing. Such a failure is called a **false
    negative** test result – a result that can mislead us.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个减少集成测试数量的原因是由于**不稳定的测试**。不稳定的测试是对有时通过有时失败的测试的昵称。当它失败时，是由于与外部系统交互中存在某些问题，而不是我们正在测试的代码中的缺陷。这种失败被称为**假阴性**测试结果——一个可能会误导我们的结果。
- en: Flaky tests are a nuisance precisely because we cannot immediately tell the
    root cause of the failure. Without diving into error logs, we only know that the
    test failed. This leads to developers learning to ignore these failed tests, often
    choosing to re-run the test suite several times until the flaky test passes. The
    problem here is that we are training developers to have less faith in their tests.
    We are training them to ignore test failures. This is not a good place to be.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 不稳定的测试是一个麻烦，正是因为我们无法立即知道失败的根本原因。在没有深入错误日志的情况下，我们只知道测试失败了。这导致开发者学会忽略这些失败的测试，通常选择多次重新运行测试套件，直到不稳定的测试通过。这里的问题是，我们正在训练开发者对他们的测试失去信心。我们正在训练他们忽略测试失败。这并不是一个好的地方。
- en: What should an integration test cover?
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成测试应该覆盖什么内容？
- en: In our design so far, we have decoupled external systems from our domain code
    using the *Dependency Inversion Principle*. We have created an interface defining
    how we use that external system. There will be some implementation of this interface,
    which is what our integration test will be covering. In hexagonal architecture
    terms, this is an *adapter*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们目前的设计中，我们使用*依赖倒置原则*将外部系统从我们的领域代码中解耦。我们创建了一个接口，定义了我们如何使用该外部系统。将会有一些这个接口的实现，这就是我们的集成测试将要覆盖的内容。在六边形架构术语中，这被称为*适配器*。
- en: This adapter should only contain the minimum amount of code necessary to interact
    with the external system in a way that satisfies our interface. It should have
    no application logic in it at all. That should be inside the domain layer and
    covered by unit tests. We call this a *thin adapter*, doing only enough work to
    adapt to the external system. This means our integration test is nicely limited
    in scope.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个适配器应该只包含与外部系统交互所需的最小代码量，以满足我们的接口。它不应该包含任何应用程序逻辑。这些逻辑应该在领域层内部，并由单元测试覆盖。我们称之为*瘦适配器*，只做足够的工作以适应外部系统。这意味着我们的集成测试在范围上得到了很好的限制。
- en: 'We can represent the scope of an integration test like so:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样表示集成测试的范围：
- en: '![Figure 10.4 – Integration tests cover the adapter layer](img/Figure_10.4_B18384.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – 集成测试覆盖适配器层](img/Figure_10.4_B18384.jpg)'
- en: Figure 10.4 – Integration tests cover the adapter layer
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 集成测试覆盖适配器层
- en: Integration tests only test the adapter layer components, those pieces of code
    that directly interact with external systems, such as databases and web endpoints.
    The integration test will create an instance of the adapter under test and arrange
    for it to connect to *a version* of the external service. This is important. We’re
    still not connecting to the production services yet. Until the integration test
    passes, we’re not sure that our adapter code works correctly. So, we don’t want
    to access real services just yet. We also want to have that extra level of control
    over these services. We want to be able to safely and easily create test accounts
    and fake data to use with our adapter. That means we need a collection of live-like
    services and databases to use. That means they have to live and run somewhere.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试只测试适配器层组件，那些直接与外部系统交互的代码片段，例如数据库和Web端点。集成测试将创建一个适配器实例，并安排它连接到外部服务的*一个版本*。这是很重要的。我们还没有连接到生产服务。直到集成测试通过，我们才确信我们的适配器代码工作正确。因此，我们还不希望访问真实的服务。我们还希望对这些服务有额外的控制级别。我们希望能够安全且容易地创建测试账户和伪造数据来与适配器一起使用。这意味着我们需要一组类似真实的服务和数据库来使用。这意味着它们必须存在于某个地方并运行。
- en: '**Test environments** are the name given to the arrangement of external systems
    we use in integration tests. It is an environment for running web services and
    data sources, specifically for testing.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试环境**是我们为集成测试所使用的那些外部系统的配置名称。这是一个运行Web服务和数据源的环境，专门用于测试。'
- en: A test environment enables our code to connect to test versions of real external
    systems. It’s one step closer to production readiness, compared to the unit test
    level. There are some challenges involved in using test environments, however.
    Let’s look into the good practices for testing integrations with databases and
    web services.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 测试环境使我们的代码能够连接到真实外部系统的测试版本。与单元测试级别相比，这更接近生产就绪状态。然而，使用测试环境涉及一些挑战。让我们来看看测试数据库和Web服务集成时的良好实践。
- en: Testing database adapters
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试数据库适配器
- en: The basic approach to testing a database adapter is to set up a database server
    in the test environment and get the code under test to connect to it. The integration
    test will preload a known dataset into the database as part of its Arrange step.
    The test then runs the code that interacts with the database in the Act step.
    The Assert step can inspect the database to see if expected database changes happened.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 测试数据库适配器的基本方法是在测试环境中设置数据库服务器，并让待测试的代码连接到它。集成测试作为其安排步骤的一部分，将预加载已知数据集到数据库中。然后，测试在行动步骤中运行与数据库交互的代码。断言步骤可以检查数据库，以查看是否发生了预期的数据库更改。
- en: 'The biggest challenge in testing a database is that it remembers data. Now,
    this might seem a little obvious, as that is the entire point of using a database
    in the first place. But it conflicts with one of the goals of testing: to have
    isolated, repeatable tests. As an example, if our test created a new user account
    for user `testuser1` and that was stored in the database, we would have a problem
    running that test again. It would not be able to create `testuser1` and instead
    would receive a **user already** **exists** error.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 测试数据库的最大挑战是它记得数据。现在，这可能看起来有点明显，因为使用数据库的初衷就是如此。但它与测试的一个目标相冲突：拥有隔离、可重复的测试。例如，如果我们的测试为用户`testuser1`创建了一个新用户账户并将其存储在数据库中，我们再次运行该测试时就会遇到问题。它将无法创建`testuser1`，而是会收到**用户已存在**的错误。
- en: 'There are different approaches to overcoming this problem, each with trade-offs:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的方法可以克服这个问题，每种方法都有其权衡：
- en: '**Delete all data from the database before and after each** **test case**'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在每个** **测试用例前后从数据库中删除所有数据**'
- en: This approach preserves the isolation of our tests, but it is slow. We have
    to recreate the test database schema before every test.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法保留了测试的隔离性，但速度较慢。我们必须在每次测试之前重新创建测试数据库模式。
- en: '**Delete all data before and after the full set of adapter** **tests run**'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在适配器测试运行前后删除所有数据**'
- en: We delete data less often, allowing several related tests to run against the
    same database. This loses test isolation due to the stored data, as the database
    will not be in the state expected at the start of the next test. We have to run
    tests in a particular order, and they must all pass, to avoid spoiling the database
    state for the next test. This is not a good approach.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们较少地删除数据，允许多个相关测试针对同一数据库运行。由于存储的数据，这会失去测试隔离性，因为数据库将不会处于下一次测试开始时预期的状态。我们必须按特定顺序运行测试，并且它们都必须通过，以避免破坏下一次测试的数据库状态。这不是一个好的方法。
- en: '**Use** **randomized data**'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用** **随机化数据**'
- en: Instead of creating *testuser1* in our test, we randomize names. So, on one
    run, we might get `testuser-cfee-0a9b-931f`. On the next run, the randomly chosen
    username would be something else. The state stored in the database will not conflict
    with another run of the same test. This is another way to preserve test isolation.
    However, it does mean that tests can be harder to read. It requires periodic cleanup
    of the test database.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试中，我们不是创建`testuser1`，而是随机化名称。因此，在某一轮测试中，我们可能会得到`testuser-cfee-0a9b-931f`。在下一轮测试中，随机选择的用户名将不同。存储在数据库中的状态不会与同一测试的另一轮运行冲突。这是另一种保持测试隔离性的方法。然而，这也意味着测试可能更难阅读。它需要定期清理测试数据库。
- en: '**Rollback transactions**'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回滚事务**'
- en: We can add data required by our tests inside a database transaction. We can
    roll back the transaction at the end of the test.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在数据库事务中添加测试所需的数据。我们可以在测试结束时回滚事务。
- en: '**Ignore** **the problem**'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**忽略** **问题**'
- en: Sometimes, if we work with read-only databases, we can add test data that will
    never be accessed by the production code and leave it there. If this works, it
    is an attractive option requiring no extra effort.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，如果我们与只读数据库一起工作，我们可以添加永远不会被生产代码访问的测试数据，并将其保留在那里。如果这可行，这是一个吸引人的选项，不需要额外的工作。
- en: Tools such as *database-rider*, available from [https://database-rider.github.io/getting-started/](https://database-rider.github.io/getting-started/),
    assist by providing library code to connect to databases and initialize them with
    test data.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如 *database-rider* 这样的工具，可以从 [https://database-rider.github.io/getting-started/](https://database-rider.github.io/getting-started/)
    获取，通过提供连接数据库和用测试数据初始化它们的库代码来协助测试。
- en: Testing web services
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试网络服务
- en: A similar approach is used to test the integration with web services. A test
    version of the web service is set to run in the test environment. The adapter
    code is set to connect to this test version of the web service, instead of the
    real version. Our integration test can then examine how the adapter code behaves.
    There might be additional web APIs on the test service to allow inspection by
    the assertions in our test.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的方法用于测试与网络服务的集成。将网络服务的测试版本设置为在测试环境中运行。适配器代码被设置为连接到这个网络服务的测试版本，而不是真实版本。然后我们的集成测试可以检查适配器代码的行为。测试服务可能会有额外的网络
    API，以便我们的测试中的断言进行检查。
- en: Again, the disadvantages are a slower running test and the risk of flaky tests
    due to issues as trivial as network congestion.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，缺点是测试运行速度较慢，以及由于像网络拥塞这样微不足道的问题而导致测试不稳定的风险。
- en: Sandbox APIs
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 沙盒 API
- en: Sometimes, hosting our own local service might be impossible, or at least undesirable.
    Third-party vendors are usually unwilling to release test versions of their service
    for us to use in our test environment. Instead, they typically offer a **sandbox
    API**. This is a version of their service that the third party hosts, not us.
    It is disconnected from their production systems. This sandbox allows us to create
    test accounts and test data, safe from affecting anything real in production.
    It will respond to our requests as their production versions will respond, but
    without taking any action such as taking payment. Consider them test simulators
    for real services.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，托管我们自己的本地服务可能是不可能的，或者至少是不受欢迎的。第三方供应商通常不愿意发布测试版的服务供我们在测试环境中使用。相反，他们通常会提供一个
    **沙盒 API**。这是第三方托管而不是我们自己的服务版本。它与他们的生产系统断开连接。这个沙盒允许我们创建测试账户和测试数据，安全地避免影响生产中的任何真实内容。它将像他们的生产版本一样对我们的请求做出响应，但不会采取任何行动，例如收取费用。把它们看作是真实服务的测试模拟器。
- en: Consumer-driven contract testing
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消费者驱动的合同测试
- en: A useful approach to testing interactions with web services is called **consumer-driven
    contract testing**. We consider our code as having a contract with the external
    service. We agree to call certain API functions on the external service, supplying
    data in the form required. We need the external service to respond to us predictably,
    with data in a known format and well-understood status codes. This forms a *contract*
    between the two parties – our code and the external service API.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一种测试与网络服务交互的有用方法是称为 **消费者驱动的合同测试**。我们将我们的代码视为与外部服务有一个合同。我们同意在外部服务上调用某些 API 函数，并按所需的形式提供数据。我们需要外部服务以可预测的方式对我们做出响应，提供已知格式和易于理解的状态码。这形成了双方之间的
    *合同* – 我们的代码和外部服务 API。
- en: 'Consumer-driven contract testing involves two components, based on that contract,
    often using code generated by tools. This is represented in the following figure:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者驱动的合同测试涉及两个组件，基于该合同，通常使用由工具生成的代码。这在上面的图中表示：
- en: '![Figure 10.5 – Consumer-driven contract testing](img/Figure_10.5_B18384.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.5 – 消费者驱动的合同测试](img/Figure_10.5_B18384.jpg)'
- en: Figure 10.5 – Consumer-driven contract testing
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – 消费者驱动的合同测试
- en: The preceding diagram shows that we’ve captured the expected interactions with
    an external service as an API contract. Our adapter for that service will be coded
    to implement that API contract. When using consumer-driven contract testing, we
    end up with two tests, which test either side of that contract. If we consider
    a service to be a black box, we have a public interface presented by the black
    box, and an implementation, whose details are hidden inside that black box. A
    contract test is two tests. One test confirms that the outside interface is compatible
    with our code. The other test confirms that the implementation of that interface
    works and gives the expected results.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示显示，我们已经将预期与外部服务的交互捕获为 API 合同。我们为该服务编写的适配器将实现该 API 合同。当使用消费者驱动的合同测试时，我们最终得到两个测试，分别测试该合同的两侧。如果我们认为一个服务是一个黑盒，那么我们有一个由黑盒提供的公共接口，以及一个实现，其细节隐藏在黑盒内部。合同测试是两个测试。一个测试确认外部接口与我们的代码兼容。另一个测试确认该接口的实现工作正常并给出预期的结果。
- en: 'A typical contract test will need two pieces of code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的合同测试将需要两段代码：
- en: '**A stub of the external service**: A stub of the external service is generated.
    If we are calling a payment processor, this stub simulates the payment processor
    locally. This allows us to use it as a test double for the payment processor service
    as we write our adapter code. We can write an integration test against our adapter,
    configuring it to call this stub. This allows us to test our adapter code logic
    without accessing the external system. We can verify that the adapter sends the
    correct API calls to that external service and handles the expected responses
    correctly.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部服务的存根**：生成外部服务的存根。如果我们正在调用支付处理器，这个存根在本地模拟支付处理器。这允许我们将其用作编写适配器代码时的测试替身。我们可以针对我们的适配器编写集成测试，配置它调用这个存根。这允许我们在不访问外部系统的情况下测试适配器代码逻辑。我们可以验证适配器是否向该外部服务发送正确的API调用，并正确处理预期的响应。'
- en: '**A replay of a set of calls to the real external service**: The contract also
    allows us to run tests against the real external service – possibly in sandbox
    mode. We’re not testing the functionality of the external service here – we assume
    that the service provider has done that. Instead, we are verifying that what we
    believe about its API is true. Our adapter has been coded to make certain API
    calls in certain orders. This test verifies that this assumption is correct. If
    the test passes, we know that our understanding of the external service API was
    correct and also that it has not changed. If this test was previously working
    but now fails, that would be an early indication that the external service has
    changed its API. We would then need to update our adapter code to follow that.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对真实外部服务的一系列调用的回放**：合同还允许我们对真实的外部服务进行测试——可能是在沙盒模式下。在这里，我们不是测试外部服务的功能——我们假设服务提供商已经完成了这项工作。相反，我们正在验证我们对其实际API的理解是否正确。我们的适配器已经编写了按特定顺序进行某些API调用的代码。这个测试验证了这个假设的正确性。如果测试通过，我们就知道我们对外部服务API的理解是正确的，而且它没有发生变化。如果这个测试之前是有效的但现在失败了，那将是一个早期迹象，表明外部服务已经更改了其API。那时，我们需要更新我们的适配器代码以适应这一变化。'
- en: One recommended tool for doing this is called Pact, available at [https://docs.pact.io](https://docs.pact.io).
    Read the guides there for more details on this interesting technique.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 用于此的一个推荐工具称为Pact，可在[https://docs.pact.io](https://docs.pact.io)找到。阅读那里的指南以获取有关此有趣技术的更多详细信息。
- en: 'We’ve seen that integration tests get us one step nearer to production. In
    the next section, we look at the final level of testing in the test pyramid, which
    is the most live-like so far: user acceptance tests.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到集成测试让我们更接近生产环境。在下一节中，我们将探讨测试金字塔中的最终测试级别，这是迄今为止最接近真实环境的：用户验收测试。
- en: End-to-end and user acceptance tests
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端到端测试和用户验收测试
- en: In this section, we will progress to the top of the test pyramid. We’ll review
    what end-to-end and user acceptance tests are and what they add to unit and integration
    testing.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将逐步推进到测试金字塔的顶端。我们将回顾端到端测试和用户验收测试是什么，以及它们为单元测试和集成测试增添了什么。
- en: At the top of the test pyramid lies two similar kinds of tests called **end-to-end
    tests** and **user acceptance tests**. Technically, they are the same kind of
    test. In each case, we start up the software fully configured to run in its most
    live-like test environment, or possibly in production. The idea is that the system
    is tested as a whole from one end to the other.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 测试金字塔的顶端有两种类似的测试，称为**端到端测试**和**用户验收测试**。技术上，它们是同一种测试。在每种情况下，我们都启动了完全配置的软件，以在与其最相似的真实测试环境中运行，或者可能在生产环境中运行。想法是，系统从一端到另一端作为一个整体进行测试。
- en: One specific use of an end-to-end test is for **user acceptance testing** (**UAT**).
    Here, several key end-to-end test scenarios are run. If they all pass, the software
    is declared fit for purpose and accepted by the users. This is often a contractual
    stage in commercial development, where the buyer of the software formally agrees
    that the development contract has been satisfied. It’s still end-to-end testing
    that is being used to determine that, with cherry-picked test cases.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试的一个特定用途是进行**用户验收测试**（**UAT**）。在这里，运行了几个关键的端到端测试场景。如果它们都通过了，软件就被宣布适合使用，并被用户接受。这通常是商业开发中的一个合同阶段，其中软件的购买者正式同意开发合同已经得到满足。这仍然是使用精选测试用例进行端到端测试来决定这一点。
- en: 'These tests have advantages and limitations, as summarized in the following
    table:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试具有优点和局限性，如下表所示：
- en: '| **Advantages** | **Limitations** |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| **优点** | **局限性** |'
- en: '| --- | --- |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Most comprehensive testing of functionality available. We are testing at
    the same level that a user of our system – either person or machine – would experience
    our system. | Slowest tests to run. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 最全面的功能测试。我们正在测试的级别与我们的系统用户 – 无论是人还是机器 – 经历我们的系统相同。 | 运行速度最慢的测试。 |'
- en: '| Tests at this level are concerned with pure behavior as observed from outside
    the system. We could refactor and rearchitect large parts of the system and still
    have these tests protect us. | Reliability issues – many problems in the setup
    and environment of our system can cause false negative test failures. This is
    termed “brittleness” – our tests are highly dependent on their environment working
    correctly. Environments can be broken due to circumstances beyond our control.
    |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 在这个级别的测试关注的是从系统外部观察到的纯行为。我们可以重构和重新设计系统的很大一部分，同时仍然有这些测试保护我们。 | 可靠性问题 – 我们系统设置和环境中的许多问题都可以导致假阴性测试失败。这被称为“脆弱性”
    – 我们的测试高度依赖于它们的环境正确工作。环境可能由于我们无法控制的情况而损坏。 |'
- en: '| Contractually important – these tests are the essence of what the end user
    cares about. | These are the most challenging of all the tests to write, due to
    the extensive environment setup requirements. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 合同上重要的 – 这些测试是终端用户关心的本质。 | 这些是所有测试中最具挑战性的，因为它们需要大量的环境设置要求。 |'
- en: Table 10.3 – End-to-end test advantages and disadvantages
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.3 – 端到端测试的优点和缺点
- en: Acceptance tests having a spot at the top of the pyramid is a reflection that
    we don’t need many of them. The majority of our code should now be covered by
    unit and integration tests, assuring us that our application logic works, as well
    as our connections to external systems.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在金字塔顶端放置验收测试反映的是我们不需要很多这样的测试。现在，我们的大部分代码应该由单元测试和集成测试覆盖，确保我们的应用程序逻辑以及与外部系统的连接都是正确的。
- en: 'The obvious question is *what’s left to test*? We don’t want to duplicate testing
    that has already been done at the unit and integration levels. But we do need
    some way to validate that the software *as a whole* is going to work as expected.
    This is the job of end-to-end testing. This is where we configure our software
    so that it connects to real databases and real external services. Our production
    code has passed all the unit tests with test doubles. These test passes suggest
    our code *should* work when we connect these real external services. But *should*
    is a wonderful weasel word in software development. Now, is the time to verify
    that it does, using an end-to-end test. We can represent the coverage of these
    tests using the following diagram:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 显然的问题是*还需要测试什么*？我们不希望重复在单元和集成级别已经完成的测试。但我们需要某种方式来验证软件*整体*将按预期工作。这是端到端测试的工作。这是我们在配置软件时使其连接到真实数据库和真实外部服务的地方。我们的生产代码已经通过了所有单元测试和测试替身。这些测试通过表明，当我们连接这些真实的外部服务时，我们的代码*应该*能够正常工作。但*应该*是软件开发中的一个美好的狡猾词汇。现在，是时候通过端到端测试来验证这一点了。我们可以使用以下图表来表示这些测试的覆盖率：
- en: '![Figure 10.6 – End-to-end/user acceptance tests cover the entire code base](img/Figure_10.6_B18384.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – 端到端/用户验收测试覆盖整个代码库](img/Figure_10.6_B18384.jpg)'
- en: Figure 10.6 – End-to-end/user acceptance tests cover the entire code base
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – 端到端/用户验收测试覆盖整个代码库
- en: End-to-end tests cover the entire code base, both the domain model and the adapter
    layer. As such, it repeats testing work already done by unit and integration tests.
    The main technical aspect we want to test in end-to-end testing is that our software
    is configured and wired up correctly. Throughout this book, we have used *dependency
    inversion and injection* to isolate us from external systems. We’ve created test
    doubles and injected those. Now, we must create actual production code, the real
    adapter layer components that connect to the production systems. We inject those
    into our system during its initialization and configuration. This sets the code
    up to work for real.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试覆盖整个代码库，包括领域模型和适配器层。因此，它重复了单元和集成测试已经完成的工作。我们在端到端测试中想要测试的主要技术方面是，我们的软件配置和连接是正确的。在这本书的整个过程中，我们使用了*依赖倒置和注入*来隔离我们与外部系统。我们创建了测试替身并将它们注入。现在，我们必须创建实际的生成代码，即连接到生产系统的真实适配器层组件。我们在系统的初始化和配置期间将这些注入到我们的系统中。这使代码能够真正地工作。
- en: End-to-end tests will then duplicate a *small amount* of happy path testing
    already covered by unit and integration tests. The purpose here is *not* to verify
    the behaviors that we have already tested. Instead, these tests verify that we
    have injected the correct production objects, by confirming that the system as
    a whole behaves correctly when connected to production services.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试将复制一小部分已经被单元和集成测试覆盖的愉快路径测试。这里的目的是*不是*验证我们已经测试过的行为。相反，这些测试通过确认整个系统在连接到生产服务时表现正确，来验证我们已经注入了正确的生产对象。
- en: 'A user acceptance test builds on this idea by running through key test scenarios
    considered critical to accepting the software as complete. These will be end-to-end
    tests at a technical level. But their purpose is broader than the technical goal
    of ensuring our system is correctly configured. They are more of a legal contractual
    nature: *Have we built what was asked of us?* By using the iterative approach
    in this book together with its technical practices, there’s a higher chance that
    we will have done so.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 用户验收测试基于这一理念，通过运行关键测试场景来接受软件作为完整产品。这些将在技术层面上进行端到端测试。但他们的目的比确保我们的系统正确配置的技术目标更广泛：*我们是否构建了我们被要求构建的内容？*
    通过结合本书中的迭代方法及其技术实践，我们有更高的可能性做到了这一点。
- en: Acceptance testing tools
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验收测试工具
- en: Various testing libraries exist to help us write automated acceptance and end-to-end
    tests. Tasks such as connecting to a database or calling an HTTP web API are common
    to this kind of testing. We can leverage libraries for these tasks, instead of
    writing code ourselves.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着各种测试库来帮助我们编写自动化的验收和端到端测试。连接数据库或调用 HTTP Web API 这样的任务对于这类测试来说是常见的。我们可以利用库来完成这些任务，而不是自己编写代码。
- en: The main differentiator among these tools is the way they interact with our
    software. Some are intended to simulate a user clicking a desktop GUI, or a browser-based
    web UI. Others will make HTTP calls to our software, exercising a web endpoint.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具之间的主要区别在于它们与我们软件的交互方式。有些旨在模拟用户点击桌面 GUI 或基于浏览器的 Web UI。其他工具将向我们的软件发出 HTTP
    请求，测试 Web 端点。
- en: 'Here are a few popular acceptance testing tools to consider:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些值得考虑的流行验收测试工具：
- en: '**RestEasy**'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RestEasy**'
- en: 'A popular tool for testing REST APIs: [https://resteasy.dev/](https://resteasy.dev/)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一个流行的用于测试 REST API 的工具：[https://resteasy.dev/](https://resteasy.dev/)
- en: '**RestAssured**'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RestAssured**'
- en: 'Another popular tool for testing REST APIs that takes a fluent approach to
    inspecting JSON responses: [https://rest-assured.io/](https://rest-assured.io/)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个流行的用于测试 REST API 的工具，它采用流畅的方法来检查 JSON 响应：[https://rest-assured.io/](https://rest-assured.io/)
- en: '**Selenium**'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Selenium**'
- en: 'A popular tool for testing web UIs through the browser: [https://www.selenium.dev/](https://www.selenium.dev/)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一个流行的通过浏览器测试 Web UI 的工具：[https://www.selenium.dev/](https://www.selenium.dev/)
- en: '**Cucumber**'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cucumber**'
- en: Available from [https://cucumber.io/](https://cucumber.io/). Cucumber allows
    English language-like descriptions of tests to be written by domain experts. At
    least, that’s the theory. I’ve never seen anybody other than a developer write
    Cucumber tests in any project I’ve been part of.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 可从 [https://cucumber.io/](https://cucumber.io/) 获取。Cucumber 允许领域专家用类似英语的描述来编写测试。至少，这是理论。我在参与的任何项目中都没有见过除了开发者之外的人编写
    Cucumber 测试。
- en: Acceptance tests form the final piece of the test pyramid and allow our application
    to be tested under conditions that resemble the production environment. All that
    is needed is a way to automate running all those layers of testing. That’s where
    CI/CD pipelines come in, and they are the subject of the next section.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 验收测试构成了测试金字塔的最后一部分，允许我们的应用程序在类似于生产环境的情况下进行测试。所需的一切就是自动化运行所有这些测试层的方法。这就是 CI/CD
    流水线发挥作用的地方，它们是下一节的主题。
- en: CI/CD pipelines and test environments
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CI/CD 流水线和测试环境
- en: CI/CD pipelines and test environments are an important part of software engineering.
    They are a part of the development workflow that takes us from writing code to
    having systems in the hands of users. In this section, we’re going to look at
    what the terms mean and how we can use these ideas in our projects.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD 流水线和测试环境是软件工程的重要组成部分。它们是开发工作流程的一部分，将我们从编写代码带到用户手中的系统。在本节中，我们将探讨这些术语的含义以及我们如何在项目中使用这些想法。
- en: What is a CI/CD pipeline?
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 CI/CD 流水线？
- en: 'Let’s start with defining the terms:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义这些术语开始：
- en: CI stands for **continuous integration**
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CI 代表 **持续集成**
- en: Integration is where we take individual software components and join them together
    to make a whole. CI means we do this all the time as we write new code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 集成是指我们将单个软件组件组合在一起，形成一个整体。持续集成意味着我们在编写新代码时一直这样做。
- en: CD stands for either **continuous delivery** or **continuous deployment**
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CD代表**持续交付**或**持续部署**
- en: We’ll cover the difference later, but in both cases, the idea is that we are
    taking the latest and greatest version of our integrated software and delivering
    it to a stakeholder. The goal of continuous delivery is that we could – if we
    wanted to – deploy every single code change to production with a single click
    of a button.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会讨论两者的区别，但在两种情况下，我们的想法都是将我们集成软件的最新和最佳版本交付给利益相关者。持续交付的目标是，如果我们愿意，我们可以通过点击一个按钮将每一个代码更改部署到生产环境中。
- en: It’s important to note that CI/CD is an engineering *discipline* – not a set
    of tools. However we achieve it, CI/CD has the goal of growing a single system
    that is always in a usable state.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，CI/CD是一种**工程学科**——而不是一系列工具。然而我们如何实现它，CI/CD的目标是构建一个始终处于可用状态的单一系统。
- en: Why do we need continuous integration?
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们为什么需要持续集成？
- en: In terms of the test pyramid, the reason we need CI/CD is to pull all the testing
    together. We need a mechanism to build the whole of our software, using the latest
    code. We need to run all the tests and ensure they all pass before we can package
    and deploy the code. If any tests fail, we know the code is not suitable for deployment.
    To ensure we get fast feedback, we must run the tests in order of fastest to slowest.
    Our CI pipeline will run unit tests first, followed by integration tests, followed
    by end-to-end and acceptance tests. If any tests fail, the build will produce
    a report of test failures for that stage, then stop the build. If all the tests
    pass, we package our code up ready for deployment.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试金字塔的术语中，我们需要CI/CD的原因是将所有测试集中在一起。我们需要一个机制来构建我们软件的整体，使用最新的代码。在我们打包和部署代码之前，我们需要运行所有测试并确保它们全部通过。如果任何测试失败，我们知道代码不适合部署。为了确保我们能够快速获得反馈，我们必须按照从快到慢的顺序运行测试。我们的CI管道将首先运行单元测试，然后是集成测试，接着是端到端和验收测试。如果任何测试失败，构建将生成该阶段的测试失败报告，然后停止构建。如果所有测试都通过，我们将打包我们的代码，准备部署。
- en: More generally, the idea of **integration** is fundamental to building software,
    whether we work alone or in a development team. When working alone, following
    the practices in this book, we’re building software out of several building blocks.
    Some we have made ourselves, while for others, we’ve selected a suitable library
    component and used that. We’ve also written adapters – components that allow us
    to access external systems. All of that needs integrating – bringing together
    as a whole – to turn our lines of code into a working system.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 更普遍地说，**集成**的概念对于构建软件是基本的，无论我们是单独工作还是在开发团队中工作。当我们单独工作时，遵循本书中的实践，我们正在用几个构建块构建软件。其中一些是我们自己制作的，而对于其他一些，我们选择了合适的库组件并使用了它。我们还编写了适配器——允许我们访问外部系统的组件。所有这些都需要集成——作为一个整体组合在一起——以将我们的代码行转换成一个工作系统。
- en: When working in a team, integration is even more important. We need to not only
    bring together the pieces we have written but also all the other pieces written
    by the rest of our team. Integrating work in progress from colleagues is urgent.
    We end up building on what others have already written. As we work outside of
    the main integrated code base, there is a risk of not including the latest design
    decisions and pieces of reusable code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当在一个团队中工作时，集成甚至更为重要。我们不仅需要将我们编写的部分组合在一起，还需要将团队其他成员编写的所有其他部分也组合在一起。整合同事正在进行的工作是紧急的。我们最终是在别人已经编写的基础上进行构建。当我们工作在主集成代码库之外时，存在不包含最新设计决策和可重用代码片段的风险。
- en: 'The following figure shows the goal of CI:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了持续集成的目标：
- en: '![Figure 10.7 – Continuous integration](img/Figure_10.7_B18384.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7 – 持续集成](img/Figure_10.7_B18384.jpg)'
- en: Figure 10.7 – Continuous integration
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 持续集成
- en: The motivation behind CI was to avoid the classic waterfall development trap,
    where a team wrote code as isolated individuals while following a plan and only
    integrated it at the end. Many times, that integration failed to produce working
    software. There was often some misunderstanding or missing piece that meant components
    did not fit together. At this late stage of a waterfall project, mistakes are
    expensive to fix.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成的动机是为了避免经典的瀑布式开发陷阱，即团队作为独立的个体编写代码，遵循计划，只在最后进行集成。很多时候，这种集成无法产生可工作的软件。通常存在一些误解或缺失的部分，意味着组件无法配合。在瀑布项目的这个后期阶段，错误修复成本很高。
- en: It’s not just big teams and big projects that suffer from this. My turning point
    was while writing a flight simulator game for Britain’s RAF Red Arrows display
    team. Two of us worked on that game to a common API we had agreed on. When we
    first attempted to integrate our parts – at 03:00 A.M., in front of the company
    managing director, of course – the game ran for about three frames and then crashed.
    Oops! Our lack of CI provided an embarrassing lesson. It would have been good
    to know that was going to happen a lot earlier, especially without the managing
    director watching.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅大型团队和大型项目会受到影响。我的转折点是在为英国皇家空军红箭表演队编写飞行模拟游戏时。我们两个人共同使用我们商定的API来开发这款游戏。当我们第一次尝试集成我们的部分时——当然是在凌晨3点，在公司总经理面前——游戏运行了大约三帧然后崩溃了。哎呀！我们缺乏持续集成提供了尴尬的教训。如果早点知道会发生这种情况会更好，尤其是在总经理在场的情况下。
- en: Why do we need continuous delivery?
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么我们需要持续交付？
- en: 'If CI is all about keeping our software components together as an ever-growing
    whole, then CD is about getting that whole into the hands of people who care about
    it. The following figure illustrates CD:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果持续集成是关于保持我们的软件组件作为一个不断增长的整体的统一，那么持续部署就是将这个整体交付给关心它的人。以下图示说明了持续部署：
- en: '![Figure 10.8 – Continuous delivery](img/Figure_10.8_B18384.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图10.8 – 持续交付](img/Figure_10.8_B18384.jpg)'
- en: Figure 10.8 – Continuous delivery
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 – 持续交付
- en: 'Delivering a stream of value to end users is a core tenet of agile development.
    No matter which flavor of agile methodology you use, getting features into the
    hands of users has always been the goal. We want to deliver usable features at
    regular, short intervals. Doing this provides three benefits:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 向最终用户交付一系列价值是敏捷开发的核心原则。无论你使用哪种敏捷方法论，将特性交付给用户始终是目标。我们希望定期、短间隔地交付可用的特性。这样做提供了三个好处：
- en: '**Users get the value** **they want**'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户获得他们想要的价值**'
- en: End users don’t care about our development process. They only care about getting
    solutions to their problems. Whether that’s the problem of being entertained while
    waiting for an Uber ride, or the problem of paying everyone’s wages in a multinational
    business, our user just wants their problem gone. Getting valuable features to
    our users becomes a competitive advantage.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最终用户并不关心我们的开发过程。他们只关心得到解决他们问题的方案。无论是等待优步乘车时的娱乐问题，还是跨国企业支付所有人工资的问题，我们的用户只想看到问题得到解决。将具有价值的特性带给我们的用户成为一种竞争优势。
- en: '**We gain valuable** **user feedback**'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们获得宝贵的** **用户反馈**'
- en: '*Yes, that’s what I asked for – but it isn’t what I meant!* That is extremely
    valuable user feedback that agile approaches deliver. Once an end user sees the
    feature as we have implemented it, sometimes, it becomes clear that it isn’t quite
    solving their problem. We can correct this quickly.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*是的，这就是我要求的——但这并不是我的本意!* 这是非常宝贵的用户反馈，敏捷方法可以提供。一旦最终用户看到我们实现的功能，有时，它就会变得明显，它并没有完全解决他们的问题。我们可以迅速纠正这一点。'
- en: '**Aligns the code base and** **development team**'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使代码库和** **开发团队** **保持一致**'
- en: To pull off this feat, you do need to have your team and workflows together.
    You can’t effectively do this unless your workflow results in known working software
    being continuously available as a single whole.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这项壮举，你需要让你的团队和工作流程协同一致。除非你的工作流程能够产生已知可工作的软件作为一个整体持续可用，否则你无法有效地做到这一点。
- en: Continuous delivery or continuous deployment?
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续交付还是持续部署？
- en: 'Exact definitions of these terms seem to vary, but we can think of them like
    this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这些术语的确切定义似乎各不相同，但我们可以这样思考：
- en: '**Continuous delivery**'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续交付**'
- en: We deliver software to internal stakeholders, such as product owners and QA
    engineers
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向内部利益相关者交付软件，例如产品所有者和QA工程师
- en: '**Continuous deployment**'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续部署**'
- en: We deliver software into production and to end users
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将软件交付到生产环境和最终用户手中
- en: Out of the two, continuous *deployment* sets a much higher bar. It requires
    that once we integrate code into our pipeline, that code is ready to go live –
    into production, to real users. This is, of course, hard. It needs top-class test
    automation to give us confidence that our code is ready to deploy. It also benefits
    from having a fast rollback system in production – some means of quickly reverting
    a deployment if we discover a defect not covered by our tests. Continuous deployment
    is the ultimate workflow. For all who achieve it, deploying new code last thing
    on Friday simply holds no fear. Well, maybe a little less fear.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个中，持续**部署**设定了一个更高的标准。它要求一旦我们将代码集成到我们的流水线中，该代码就准备好上线——进入生产环境，面向真实用户。这当然是困难的。它需要顶级的测试自动化来让我们对我们的代码准备好部署有信心。它还受益于在生产环境中拥有快速的回滚系统——如果我们发现测试未覆盖的缺陷，有一些快速回滚部署的方法。持续部署是终极工作流程。对于所有实现它的人来说，周五最后部署新代码根本不会感到恐惧。嗯，也许稍微少一点恐惧。
- en: Practical CI/CD pipelines
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际的 CI/CD 流水线
- en: 'Most projects use a CI tool to handle the sequencing chores. Popular tools
    are provided by Jenkins, GitLab, CircleCI, Travis CI, and Azure DevOps. They all
    work similarly, executing separate build stages sequentially. That’s where the
    name pipeline comes from – it resembles a pipe being loaded at one end with the
    next build stage and coming out of the other end of the pipe, as shown in the
    following diagram:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数项目使用 CI 工具来处理序列任务。流行的工具由 Jenkins、GitLab、CircleCI、Travis CI 和 Azure DevOps
    提供。它们都类似地工作，依次执行单独的构建阶段。这就是“流水线”这个名字的由来——它类似于一端装满下一个构建阶段，从管道的另一端出来的管道，如下面的图所示：
- en: '![Figure 10.9 – Stages in a CI pipeline](img/Figure_10.9_B18384.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.9 – CI 流水线中的阶段](img/Figure_10.9_B18384.jpg)'
- en: Figure 10.9 – Stages in a CI pipeline
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 – CI 流水线中的阶段
- en: 'A CI pipeline comprises the following steps:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: CI 流水线包括以下步骤：
- en: '**Source control**: Having a common location in which to store the code is
    essential to CI/CD. It is the place where code gets integrated. The pipeline starts
    here, by pulling down the latest version of the source code and performing a clean
    build. This prevents errors caused by older versions of code being present on
    the computer.'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**源代码控制**：有一个共同的存储代码的位置对于 CI/CD 是至关重要的。这是代码集成的地点。流水线从这里开始，通过拉取最新的源代码并执行干净的构建。这防止了由于计算机上存在代码的旧版本而引起的错误。'
- en: '`.jar` file, to run on the JVM.'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 JVM 上运行的 `.jar` 文件。
- en: '**Static code analysis**: Linters and other analysis tools check the source
    code for stylistic violations, such as variable length and naming conventions.
    The development team can choose to fail the build when specific code issues are
    detected by static analysis.'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**静态代码分析**：代码检查器和其它分析工具检查源代码中的风格违规，例如变量长度和命名约定。开发团队可以选择在静态分析检测到特定的代码问题时失败构建。'
- en: '**Unit tests**: All the unit tests are run against the built code. If any fail,
    the pipeline stops. Test failure messages are reported.'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**单元测试**：所有单元测试都是针对构建后的代码运行的。如果任何测试失败，则流水线停止。测试失败信息会被报告。'
- en: '**Integration tests**: All integration tests are run against the built code.
    If any fail, the pipeline is stopped and error messages are reported.'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**集成测试**：所有集成测试都是针对构建后的代码运行的。如果任何测试失败，则流水线停止，并报告错误信息。'
- en: '**Acceptance tests**: All acceptance tests are run against the built code.
    If all tests pass, the code is considered to be working and ready for delivery/deployment.'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**验收测试**：所有验收测试都是针对构建后的代码运行的。如果所有测试都通过，则代码被认为是正常工作并准备好交付/部署的。'
- en: '`.jar` file containing an embedded web server.'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含嵌入式 Web 服务器的 `.jar` 文件。
- en: What happens next depends on the needs of the project. The packaged code may
    be deployed to production automatically or it may simply be placed in some internal
    repository, for access by product owners and QA engineers. Formal deployment would
    then happen later, after quality gatekeeping.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来会发生什么取决于项目的需求。打包的代码可能会自动部署到生产环境，或者它可能只是放置在一些内部仓库中，供产品所有者和 QA 工程师访问。正式部署将在质量门控制之后发生。
- en: Test environments
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试环境
- en: One obvious problem caused by needing a CI pipeline to run integration tests
    is having a place to run those tests. Ordinarily, in production, our application
    integrates with external systems such as databases and payment providers. When
    we run our CI pipeline, we do not want our code to process payments or write to
    production databases. Yet we *do* want to test that the code *could* integrate
    with those things, once we configure it to connect to those real systems.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 需要CI管道运行集成测试所引起的一个明显问题是需要一个运行这些测试的地方。通常，在生产环境中，我们的应用程序与外部系统（如数据库和支付提供商）集成。当我们运行CI管道时，我们不希望我们的代码处理支付或写入生产数据库。然而，我们确实希望测试代码*能够*与这些系统集成，一旦我们配置它连接到这些真实系统。
- en: The solution is to create a **test environment**. These are collections of databases
    and simulated external systems that lie under our control. If our code needs to
    integrate with a database of user details, we can create a copy of that user database
    and run it locally. During testing, we can arrange for our code to connect to
    this local database, instead of the production version. External payment providers
    often provide a sandbox API. This is a version of their service that, again, does
    not connect to any of their real customers. It features simulated behavior for
    their service. In effect, it is an external test double.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是创建一个**测试环境**。这些是我们控制下的数据库和模拟外部系统的集合。如果我们的代码需要与用户详情数据库集成，我们可以创建该用户数据库的副本并在本地运行它。在测试期间，我们可以安排我们的代码连接到这个本地数据库，而不是生产版本。外部支付提供商通常提供沙箱API。这是他们服务的一个版本，它再次不连接到他们的任何真实客户。它具有模拟其服务的行为。实际上，它是一个外部测试替身。
- en: This kind of setup is called a **live-like** or **staging** environment. It
    allows our code to be tested with more realistic integration. Our unit tests use
    stubs and mocks. Our integration tests can now use these richer test environments.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置被称为**类似实时**或**预发布**环境。它允许我们的代码在更真实的集成中进行测试。我们的单元测试使用存根和模拟。我们的集成测试现在可以使用这些更丰富的测试环境。
- en: Advantages and challenges of using test environments
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用测试环境的优势和挑战
- en: 'Test environments offer both advantages and disadvantages, as summarized in
    the following table:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 测试环境既有优势也有劣势，如下表总结：
- en: '| **Advantages** | **Challenges** |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| **优势** | **挑战** |'
- en: '| --- | --- |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **The environment** **is self-contained**We can create it and destroy it
    at will. It will not affect production systems. | **Not** **production environments**No
    matter how live-like we make them, these environments are simulations. The risk
    is that our fake environments give us false positives – tests that pass only because
    they are using fake data. This can give us false confidence, leading us to deploy
    code that will fail in production.The real test happens when we set our code live.
    Always. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| **环境** **是自包含的**我们可以随意创建和销毁它。它不会影响生产系统。 | **不是** **生产环境**无论我们如何使其类似实时，这些环境都是模拟。风险是，我们的假环境给出假阳性结果——仅因为它们使用了假数据而通过的测试。这可能会给我们带来错误的信心，导致我们部署在生产环境中会失败的代码。真正的测试发生在我们设置代码为实时时。总是。|'
- en: '| **More realistic** **than stubs**The environment gets us one step closer
    to testing under production loads and conditions. | **Extra effort to create**
    **and maintain**More development work is needed to set these environments up and
    keep them in step with the test code. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| **比存根更真实**环境让我们更接近在生产和条件下进行测试。 | **创建和维护需要额外努力**需要更多开发工作来设置这些环境并保持它们与测试代码同步。|'
- en: '| **Check assumptions about** **external systems**Third-party sandbox environments
    allow us to confirm that our code uses the latest, correct API, as published by
    the supplier. | **Privacy concerns**Simply copying over a chunk of production
    data isn’t good enough for a test environment. If that data contains **personally
    identifiable information** (**PII**) as defined by GDPR or HIPAA, then we can’t
    legally use it directly. We have to create an extra step to anonymize that data
    or generate pseudo-realistic random test data. Neither is trivial. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| **检查关于** **外部系统**的假设第三方沙箱环境使我们能够确认我们的代码使用了供应商发布的最新、正确的API。 | **隐私问题**简单地复制生产数据块并不足以用于测试环境。如果这些数据包含根据GDPR或HIPAA定义的**个人身份信息**（**PII**），那么我们无法直接合法地使用它。我们必须创建一个额外的步骤来匿名化这些数据或生成伪真实的随机测试数据。这两者都不简单。|'
- en: Table 10.4 – Test environments advantages and challenges
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.4 – 测试环境的优势和挑战
- en: Testing in production
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生产环境中的测试
- en: I can hear the gasps already! Running our tests in production is generally a
    terrible idea. Our tests might introduce fake orders that our production system
    treats as real ones. We may have to add test user accounts, which can present
    a security risk. Worse still, because we are in a testing phase, there is a very
    good chance that our code does not work yet. This can cause all sorts of problems
    – all while connected to production systems.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经听到了惊呼声！在生产中运行我们的测试通常是一个糟糕的想法。我们的测试可能会引入假订单，我们的生产系统会将其视为真实订单。我们可能需要添加测试用户账户，这可能会带来安全风险。更糟糕的是，因为我们处于测试阶段，我们的代码可能还没有工作。这可能会引起各种问题——所有这些都是在连接到生产系统的情况下发生的。
- en: Despite these concerns, sometimes, things must be tested in production. Big
    data companies such as Google and Meta both have things that can only be tested
    live due to the sheer scale of their data. There is no way a meaningful live-like
    test environment can be created; it will simply be too small. What can we do in
    cases like this?
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有这些担忧，有时，某些事情必须在生产中进行测试。像谷歌和Meta这样的大数据公司，由于数据规模巨大，他们有一些东西只能通过实际运行来测试。无法创建一个有意义的类似真实环境的测试环境；它将太小。在这种情况下我们能做什么呢？
- en: 'The approach is to mitigate the risks. Two techniques are valuable here: blue-green
    deployment and traffic partitioning.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法是减轻风险。这里有两种技术很有价值：蓝绿部署和流量分区。
- en: Blue-green deployment
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 蓝绿部署
- en: '**Blue-green deployment** is a deployment technique designed for the rapid
    rollback of failed deployments. It works by dividing the production servers into
    two groups. They are referred to as *blue* and *green*, chosen as they are neutral
    colors that both denote success. Our production code will be running on one group
    of servers at any one time. Let’s say we are currently running on the blue group.
    Our next deployment will then be to the green group. This is shown in the following
    diagram:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**蓝绿部署**是一种旨在快速回滚失败部署的部署技术。它通过将生产服务器分为两组来实现。它们被称为*蓝色*和*绿色*，因为它们是中性的颜色，都表示成功。我们的生产代码将随时运行在服务器组中的一组。假设我们目前正在运行在蓝色组。我们的下一个部署将是绿色组。如下面的图所示：'
- en: '![Figure 10.10 – Blue-green deployment](img/Figure_10.10_B18384.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图10.10 – 蓝绿部署](img/Figure_10.10_B18384.jpg)'
- en: Figure 10.10 – Blue-green deployment
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 – 蓝绿部署
- en: Once the code has been deployed to the green group, we switch over the production
    configuration to connect to green group servers. We retain the previous working
    production code on the blue servers. If our testing goes well against the green
    group, then we’re done. Production is now working with the latest green group
    code. If the testing fails, we revert that configuration to connect to the blue
    servers once again. It’s a fast rollback system that enables our experimentation.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码已部署到绿色组，我们就切换生产配置以连接到绿色组服务器。我们在蓝色服务器上保留之前工作的生产代码。如果我们对绿色组的测试顺利，那么我们就完成了。现在生产正在使用最新的绿色组代码。如果测试失败，我们将该配置回滚以再次连接到蓝色服务器。这是一个快速回滚系统，使我们能够进行实验。
- en: Traffic partitioning
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流量分区
- en: 'In addition to blue-green deployment, we can limit the amount of traffic that
    we send to our test servers. Instead of flipping production to wholly use the
    new code under test, we can simply send a small percentage of user traffic there.
    So, 99% of users might be routed to our blue servers, which we know to work. 1%
    can be routed to our new code under test in the green servers, as shown in the
    following diagram:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 除了蓝绿部署之外，我们还可以限制发送到测试服务器的流量。我们不必将生产完全切换到测试中的新代码，我们只需将一小部分用户流量发送到那里。所以，99%的用户可能会被路由到我们已知的蓝色服务器，1%可以路由到绿色服务器上正在测试的新代码，如下面的图所示：
- en: '![Figure 10.11 – Traffic partitioning](img/Figure_10.11_B18384.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图10.11 – 流量分区](img/Figure_10.11_B18384.jpg)'
- en: Figure 10.11 – Traffic partitioning
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11 – 流量分区
- en: If defects are discovered, only 1% of users will be affected before we revert
    to 100% blue servers. This gives us a rapid rollback, mitigating problems in production
    caused by a failed deployment.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发现缺陷，在我们回滚到100%蓝色服务器之前，只有1%的用户会受到 影响。这使我们能够快速回滚，减轻由失败的部署在生产中引起的问题。
- en: We’ve now covered the roles of different kinds of tests and seen how they fit
    into a coherent system known as the test pyramid. In the next section, we’ll apply
    some of this knowledge to our Wordz application by writing an integration test.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经涵盖了不同类型测试的角色，并看到了它们如何融入一个被称为测试金字塔的连贯系统。在下一节中，我们将通过编写集成测试将一些知识应用到我们的Wordz应用程序中。
- en: Wordz – integration test for our database
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Wordz – 我们数据库的集成测试
- en: In this section, we’ll review an integration test for our Wordz application
    to get a feel for what they look like. We’ll cover the details of writing these
    tests and setting up the test tools in [*Chapter 14*](B18384_14.xhtml#_idTextAnchor293),
    *Driving the Database Layer*, and [*Chapter 15*](B18384_15.xhtml#_idTextAnchor306),
    *Driving the* *Web Layer*.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾我们的Wordz应用程序的集成测试，以了解它们的样子。我们将在[*第14章*](B18384_14.xhtml#_idTextAnchor293)，*驱动数据库层*和[*第15章*](B18384_15.xhtml#_idTextAnchor306)，*驱动Web层*中详细说明编写这些测试和设置测试工具的细节。
- en: Fetching a word from the database
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从数据库中获取一个单词
- en: 'As part of our earlier design work, we identified that Wordz would need a place
    to store the candidate words to be guessed. We defined an interface called `WordRepository`
    to isolate us from the details of storage. At that iteration, we had only got
    as far as defining one method on the interface:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的设计工作中，我们确定Wordz需要一个地方来存储要猜测的候选单词。我们定义了一个名为`WordRepository`的接口来隔离我们与存储细节。在那个迭代中，我们只定义了一个接口上的方法：
- en: '[PRE0]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The implementation of this WordRepository interface will access the database
    and return a word given its `wordNumber`. We will defer implementing this to [*Chapter
    14*](B18384_14.xhtml#_idTextAnchor293), *Driving the Database Layer*. For now,
    let’s take an early look at what the integration test will look like, at a high
    level. The test uses open source libraries to help write the test, and to provide
    the database. We’ve chosen the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这个WordRepository接口的实现将访问数据库，并返回一个给定其`wordNumber`的单词。我们将推迟到[*第14章*](B18384_14.xhtml#_idTextAnchor293)，*驱动数据库层*中实现这一功能。现在，让我们先看看集成测试的大致样子。这个测试使用开源库来帮助编写测试，并提供数据库。我们选择了以下内容：
- en: An open source library called `database-rider` (available from [https://database-rider.github.io/getting-started/](https://database-rider.github.io/getting-started/))
    as a test tool
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`database-rider`的开源库（可在[https://database-rider.github.io/getting-started/](https://database-rider.github.io/getting-started/)获取）作为测试工具
- en: Postgres, a popular open source relational database, to store our data
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Postgres，一个流行的开源关系型数据库，用于存储我们的数据
- en: 'Here is the test code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是测试代码：
- en: '[PRE1]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `fetchesWord()` test method is marked by the `@DataSet` annotation. This
    annotation is provided by the *database-rider* test framework and it forms the
    Arrange step of our test. It specifies a file of known test data that the framework
    will load into the database before the test runs. The data file is located underneath
    the root folder of `src/test/resources`. The parameter in the annotation gives
    the rest of the path. In our case, the file will be located at `src/test/resources/adapters/data/wordTable.json`.
    Its content looks like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchesWord()`测试方法由`@DataSet`注解标记。这个注解由*database-rider*测试框架提供，并形成我们测试的安排步骤。它指定了一个已知测试数据文件，该框架将在测试运行之前将其加载到数据库中。数据文件位于`src/test/resources`根文件夹下。注解中的参数给出了其余路径。在我们的情况下，文件将位于`src/test/resources/adapters/data/wordTable.json`。其内容如下：'
- en: '[PRE2]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This JSON file tells the `database-rider` framework that we would like to insert
    a single row into a database table named `WORD`, with column values of `1`, `27`,
    and `ARISE`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这个JSON文件告诉`database-rider`框架，我们希望向名为`WORD`的数据库表中插入一行，列值为`1`、`27`和`ARISE`。
- en: We’re not going to write the adapter code to make this test pass just yet. There
    are several steps we would need to take to get this test to compile, including
    downloading various libraries and getting the Postgres database up and running.
    We’ll cover these steps in detail in [*Chapter 14*](B18384_14.xhtml#_idTextAnchor293),
    *Driving the* *Database Layer*.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在还不打算编写适配器代码来使这个测试通过。我们需要采取几个步骤来使这个测试能够编译，包括下载各种库和启动Postgres数据库。我们将在[*第14章*](B18384_14.xhtml#_idTextAnchor293)，*驱动数据库层*中详细说明这些步骤。
- en: 'The overview of this integration test code is that it is testing a new class
    called `WordRepositoryPostgres` that we will write. That class will contain the
    database access code. We can see the tell-tale JDBC object, `javax.sql.DataSource`,
    which represents a database instance. This is the clue that we are testing integration
    with a database. We can see new annotations from the database testing library:
    `@DBRider` and `@DataSet`. Finally, we can see something instantly recognizable
    – the Arrange, Act, and Assert steps of a test:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这段集成测试代码的概述是，它正在测试一个名为`WordRepositoryPostgres`的新类，这是我们将要编写的。这个类将包含数据库访问代码。我们可以看到标志性的JDBC对象，`javax.sql.DataSource`，它代表一个数据库实例。这是我们在测试与数据库集成时的线索。我们可以看到来自数据库测试库的新注解：`@DBRider`和`@DataSet`。最后，我们可以看到一些立即可以识别的东西——测试的安排、行动和断言步骤：
- en: The Arrange step creates a `WordRepositoryPostgres` object, which will contain
    our database code. It works with the `database-rider` library’s `@DataSet` annotation
    to put some known data into the database before the test runs.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安排步骤创建一个`WordRepositoryPostgres`对象，它将包含我们的数据库代码。它使用`database-rider`库的`@DataSet`注解在测试运行之前将一些已知数据放入数据库中。
- en: The Act step calls the `fetchWordByNumber()` method, passing in the numeric
    `wordNumber` we want to test. This number aligns with the contents of the `wordTable.json`
    file.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行动步骤调用`fetchWordByNumber()`方法，传入我们想要测试的数字`wordNumber`。这个数字与`wordTable.json`文件的内容相匹配。
- en: The Assert step confirms the expected word, `ARISE`, is returned from the database.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断言步骤确认从数据库返回的预期单词，`ARISE`。
- en: As we can see, integration tests aren’t so different from unit tests in essence.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，集成测试在本质上与单元测试并没有太大的不同。
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we’ve seen how the test pyramid is a system that organizes
    our testing efforts, keeping FIRST unit tests firmly as the foundation for all
    we do, but not neglecting other testing concerns. First, we introduced the ideas
    of integration and acceptance testing as ways of testing more of our system. Then,
    we looked at how the techniques of CI and CD keep our software components brought
    together and ready to release at frequent intervals. We’ve seen how to bring the
    whole build process together using CI pipelines, possibly going on to CD. We’ve
    made a little progress on Wordz by writing an integration test for the `WordRepositoryPostgres`
    adapter, setting us up to write the database code itself.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了测试金字塔是如何作为一个系统来组织我们的测试努力的，它坚定地将FIRST单元测试作为我们所有工作的基础，但并没有忽视其他测试关注点。首先，我们介绍了集成测试和验收测试作为测试我们系统更多部分的方法。然后，我们探讨了CI和CD技术如何保持我们的软件组件在一起，并频繁地准备好发布。我们看到了如何使用CI管道将整个构建过程整合在一起，可能继续到CD。我们在Wordz上取得了一点点进展，通过为`WordRepositoryPostgres`适配器编写集成测试，为我们编写数据库代码本身奠定了基础。
- en: In the next chapter, we’ll take a look at the role of manual testing in our
    projects. It’s clear by now that we automate as much testing as we can, meaning
    that the role of manual testing no longer means following huge test plans. Yet,
    manual testing is still very valuable. How has the role changed? We’ll review
    that next.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨手动测试在我们项目中的作用。现在很明显，我们将尽可能多地自动化测试，这意味着手动测试的角色不再意味着遵循庞大的测试计划。然而，手动测试仍然非常有价值。这个角色是如何变化的？我们将在下一章回顾。
- en: Questions and answers
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题与答案
- en: 'The following are some questions and their answers regarding this chapter’s
    material:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于本章材料的问题及其答案：
- en: Why is the test pyramid represented as a pyramid shape?
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么测试金字塔被表示为金字塔形状？
- en: The shape depicts a broad foundation of many unit tests. It shows layers of
    testing above that exercise a closer approximation to the final, integrated system.
    It also shows that we expect fewer tests at those higher levels of integration.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 形状描述了一个由许多单元测试组成的广泛基础。它显示了在那些测试更高层次集成系统的测试层。它还显示我们预计在那些更高层次的集成级别上测试较少。
- en: What are the trade-offs between unit, integration, and acceptance tests?
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试、集成测试和验收测试之间的权衡是什么？
- en: 'Unit tests: Fast, repeatable. Don’t test connections to external systems.'
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试：快速、可重复。不要测试与外部系统的连接。
- en: 'Integration tests: Slower, sometimes unrepeatable. They test the connection
    to the external system.'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试：较慢，有时不可重复。它们测试与外部系统的连接。
- en: 'Acceptance tests: Slowest of all. They can be flaky but offer the most comprehensive
    tests of the whole system.'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验收测试：所有测试中最慢的。它们可能不可靠，但提供了对整个系统最全面的测试。
- en: Does the test pyramid guarantee correctness?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试金字塔是否保证了正确性？
- en: No. Testing can only ever reveal the presence of a defect, *never* the absence
    of one. The value of extensive testing is in how many defects we avoid putting
    into production.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 不。测试只能揭示缺陷的存在，*永远*不能揭示其不存在。广泛测试的价值在于我们避免了多少缺陷进入生产环境。
- en: Does the test pyramid only apply to object-oriented programming?
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试金字塔是否仅适用于面向对象编程？
- en: No. This strategy of test coverage applies to any programming paradigm. We can
    write code using any paradigm - object-oriented, functional, procedural, or declarative.
    The various kinds of tests only depend on whether our code accesses external systems
    or makes up purely internal components.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 不。这种测试覆盖率策略适用于任何编程范式。我们可以使用任何范式编写代码 - 面向对象、函数式、过程式或声明式。各种类型的测试只取决于我们的代码是否访问外部系统或仅由内部组件组成。
- en: Why don’t we prefer end-to-end tests, given they test the whole system?
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们不优先选择端到端测试，尽管它们测试整个系统？
- en: End-to-end tests run slowly. They depend directly on having either production
    databases and web services running, or a test environment running containing test
    versions of those things. The network connections required, and things such as
    database setup, can result in tests giving us false negative results. They fail
    because of the environment, not because the code was incorrect. Because of these
    reasons, we engineer our system to make maximum use of fast, repeatable unit tests.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '端到端测试运行缓慢。它们直接依赖于生产数据库和Web服务的运行，或者运行包含那些事物测试版本的测试环境。所需的网络连接以及诸如数据库设置之类的事情可能导致测试给出错误阴性结果。它们失败是因为环境，而不是因为代码错误。由于这些原因，我们设计系统以最大限度地利用快速、可重复的单元测试。 '
- en: Further reading
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章所涵盖的主题，请查看以下资源：
- en: '*Introduction to consumer-driven* *contract testing*'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*消费者驱动测试简介*'
- en: Pact.io produce a popular open source contract testing tool that’s available
    on their website, [https://docs.pact.io](https://docs.pact.io). The website features
    an explanatory video and a useful introduction to the benefits of contract-driven
    testing.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Pact.io在其网站上提供了一种流行的开源合同测试工具，[https://docs.pact.io](https://docs.pact.io)。该网站提供了解释视频和关于合同驱动测试益处的有用介绍。
- en: '*Database-rider database* *testing library*'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据库-rider 数据库测试库*'
- en: An open source database integration testing library that works with JUnit5\.
    It is available from [https://database-rider.github.io/getting-started/](https://database-rider.github.io/getting-started/).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 一个与JUnit5兼容的开源数据库集成测试库。它可以从[https://database-rider.github.io/getting-started/](https://database-rider.github.io/getting-started/)获取。
- en: '*Modern Software Engineering, Dave Farley,* *ISBN 978-0137314911*'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*现代软件工程，Dave Farley*，*ISBN 978-0137314911*'
- en: This book explains in detail the reasons behind CD and various technical practices
    such as trunk-based development to help us achieve that. Highly recommended.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 本书详细解释了持续交付背后的原因以及各种技术实践，如基于主干的开发，以帮助我们实现这一目标。强烈推荐。
- en: '*Minimum CD*'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最小化持续交付*'
- en: 'Details on what is needed for CD: [https://minimumcd.org/minimumcd/](https://minimumcd.org/minimumcd/).'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 关于持续交付所需信息的详细信息：[https://minimumcd.org/minimumcd/](https://minimumcd.org/minimumcd/).
