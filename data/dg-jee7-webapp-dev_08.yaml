- en: Chapter 8. AngularJS and Java RESTful Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. AngularJS和Java RESTful服务
- en: '|   | *"Slow – Anything faster than 50ms is imperceptible to humans and thus
    can be considered ''instant''.* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"慢 - 任何超过50毫秒的东西对人类来说都是不可察觉的，因此可以被认为是‘瞬间’。"* |   |'
- en: '|   | --*Misko Hevery, co-creator of AngularJS* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*AngularJS的共同创造者Misko Hevery* |'
- en: 'For this chapter, we shall move out of the comfort zone of JSF and explore
    a different mode of web application. Most of you will be familiar with popular
    social media like Google Mail, Facebook, and Twitter and their web-user interfaces.
    These web applications have a special user experience and information architecture
    that gives the illusion of the interaction taking place on one single web page.
    However, behind the scenes, these applications depend on standard technologies:
    HTML5, CSS, and client-side JavaScript. They all use AJAX calls to communicate
    over HTTP to a back-end server. When the server side application sends data to
    the web client, only a partial part of the page is updated. In contemporary use,
    many digital sites take advantage of the RESTful service endpoints on the application
    backend. Some sophisticated enterprise applications may deliver notices to the
    working multiple users using **Server Sent Events** (**SSE**), and the more leading-edge
    ones lean on the newly minted HTML5 WebSocket specification to deliver a full-duplex
    communication between the client and the server. Incidentally, the full Java EE
    7 specification from the Java Community Process supports JAX-RS, SSE, and WebSocket.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将走出JSF的舒适区，探索一种不同的Web应用程序模式。你们大多数人都会熟悉像Google Mail、Facebook和Twitter这样的流行社交媒体及其Web用户界面。这些Web应用程序具有特殊用户体验和信息架构，给人一种交互发生在单个网页上的错觉。然而，在幕后，这些应用程序依赖于标准技术：HTML5、CSS和客户端JavaScript。它们都使用AJAX调用通过HTTP与后端服务器通信。当服务器端应用程序向Web客户端发送数据时，只有页面的一部分被更新。在当代使用中，许多数字网站利用应用程序后端上的RESTful服务端点。一些复杂的企业应用程序可能使用**服务器发送事件**（**SSE**）向多个工作用户发送通知，而更前沿的一些则依赖于新近制定的HTML5
    WebSocket规范，以在客户端和服务器之间提供全双工通信。顺便提一下，来自Java Community Process的完整Java EE 7规范支持JAX-RS、SSE和WebSocket。
- en: Single-page applications
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单页应用程序
- en: The design philosophy behind building an application on a single page such that
    it resembles a desktop application is in marked contrast to the JavaServer Faces'
    original design of navigation links between pages. JSF 1.0 was created in the
    early noughties, long before the rediscovery of the `XMLHttpRequest` JavaScript
    object and Google Maps in 2005, so that historical note should not be a surprise
    ([http://en.wikipedia.org/wiki/JavaServer_Faces](http://en.wikipedia.org/wiki/JavaServer_Faces)).
    It is entirely possible to write JSF as a single-page application, but I would
    not recommend the effort of forcing a square peg into a round hole! JSF lends
    itself to applications that are extremely stateful in nature and design, where
    the customer journey is based on page-to-page navigation. In the previous chapters,
    we have already covered a great deal about stateful web applications with JSF,
    flow scopes, conversations, and view-scoped beans. If you are not thorough with
    those concepts, then I strongly recommend you revise the material again. We shall
    press on now with the alternate design mode.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在单页面上构建应用程序的设计理念，使其类似于桌面应用程序，与JavaServer Faces原始的页面间导航链接设计形成鲜明对比。JSF 1.0是在2000年代初创建的，远在2005年重新发现`XMLHttpRequest`
    JavaScript对象和Google Maps之前，所以这个历史注释不应令人惊讶（[http://en.wikipedia.org/wiki/JavaServer_Faces](http://en.wikipedia.org/wiki/JavaServer_Faces)）。完全有可能将JSF编写为单页应用程序，但我不会推荐将方钉强行塞入圆孔的努力！JSF适合于本质和设计上极度状态化的应用程序，其中客户旅程基于页面间的导航。在前几章中，我们已经详细介绍了使用JSF的状态化Web应用程序、流作用域、会话和视图作用域的bean。如果您对这些概念不熟悉，我强烈建议您再次复习这些材料。现在，我们将继续探讨另一种设计模式。
- en: 'Let''s list the beneficial characteristics of single-page applications:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列出单页应用程序的有益特性：
- en: SPAs often feature a website or web application that fits on a single page.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SPAs通常具有适合单页的网站或Web应用程序。
- en: They rely on the modern digital JavaScript techniques including AJAX, HTML5,
    and CSS.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们依赖于现代数字JavaScript技术，包括AJAX、HTML5和CSS。
- en: Instead of loading whole pages during navigation, this type of application manipulates
    the **Document Object Model** (**DOM**) in order to provide page updates.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在导航期间，此类应用程序不是加载整个页面，而是操作**文档对象模型**（**DOM**）以提供页面更新。
- en: These applications typically employ an HTML-templating engine to render the
    content locally on the client side. There is a separation of concerns between
    the presentation logic on the client and the business logic on the server side.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些应用程序通常使用 HTML 模板引擎在客户端本地渲染内容。客户端的表示逻辑和服务器端的业务逻辑之间存在关注点的分离。
- en: SPAs communicate dynamically with a web server, usually with RESTful services,
    with JSON as a popular payload type.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单页应用程序与网络服务器动态通信，通常使用 RESTful 服务，JSON 作为流行的有效载荷类型。
- en: 'There are some drawbacks for single-page applications that the content strategists,
    technical lead developers, and, obviously, the stakeholder businessperson should
    be aware of:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 单页应用程序存在一些缺点，内容策略师、技术负责人开发人员和显然的股东商业人士都应该了解：
- en: It may be hard to apply Search Engine Optimization to an SPA.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将搜索引擎优化应用到单页应用程序中可能有些困难。
- en: Using the back button in the browser may cause lost data entries; SPAs do not
    play well with web browser history.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用浏览器中的后退按钮可能会导致数据条目丢失；单页应用程序与网页浏览器历史记录不兼容。
- en: SPA requires a higher degree of application development knowledge to deal with
    reactive programming and concepts. Notably, engineers should be aware of factors
    concerning trade-off round scalability, resilience, event-driven handling, and
    notifications, and be responsive.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单页应用程序需要更高程度的应用开发知识来处理响应式编程和概念。值得注意的是，工程师应该意识到关于权衡可扩展性、弹性、事件驱动处理和通知的因素，并保持响应。
- en: Finally, allow me to offer you a word of advice. Digital interface developers
    in the industry have JavaScript, HTML5, and CSS skills. In this chapter, you will
    learn to acknowledge that the JavaScript programming capability is equally as
    important as the Java server-side requirement. In other words, working with AngularJS
    and similar client-side frameworks tends to be a full-stack engagement.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我给你一些建议。行业中的数字界面开发人员拥有 JavaScript、HTML5 和 CSS 技能。在本章中，你将学会认识到 JavaScript
    编程能力与 Java 服务器端需求同样重要。换句话说，使用 AngularJS 和类似的客户端框架往往是一种全栈参与。
- en: The caseworker application
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案件工作者应用程序
- en: For this chapter, we are going to look at one particular type of single-page
    application for international governments called a caseworker system. The business
    users of the caseworkers will sit on desks, and for the majority of their day,
    process applicants through stages of applying for a product.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将探讨一种特定类型的单页应用程序，这种应用程序适用于国际政府，称为案件工作者系统。案件工作者的业务用户将坐在办公桌前，他们的大部分时间都在处理申请人的产品申请阶段。
- en: 'The following is a screenshot of the application:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该应用程序的截图：
- en: '![The caseworker application](img/image00418.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![案件工作者应用程序](img/image00418.jpeg)'
- en: Screenshot of the caseworker application, xen national force
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 案件工作者应用程序截图，xen national force
- en: The application is called **xen-national-force**, and it is designed to process
    passports through a miniature workflow. It is far from serving the requirements
    of a true business application. For example, there is no user input security implemented
    in order to keep things as simple as possible. It works very well for only one
    caseworker and there is a very obvious design flaw from the user-experience side.
    However, the xen-national-force application demonstrates how to build a system
    having master-detail records with CRUD operations using AngularJS, and it features
    a basic Finite State Machine implementation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序名为 **xen-national-force**，它被设计用来通过微型工作流程处理护照。它远远不能满足真实商业应用的需求。例如，为了尽可能简化，没有实现用户输入安全。它仅适用于一个案件工作者，并且从用户体验的角度来看存在一个非常明显的设计缺陷。然而，xen-national-force
    应用程序展示了如何使用 AngularJS 构建具有 CRUD 操作的主从记录系统，并且它具有基本的有限状态机实现。
- en: We shall now move on to learning about the popular AngularJS framework.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将转向学习流行的 AngularJS 框架。
- en: AngularJS
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AngularJS
- en: 'How would we wire up the text input with the message area in the `div` element
    with jQuery? One plausible approach would be to write event handlers and callback
    functions like the following fragment of a JavaScript module:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用 jQuery 将文本输入与 `div` 元素中的消息区域连接起来？一个可行的方法是编写如下事件处理程序和回调函数的 JavaScript
    模块片段：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The designers of AngularJS realized that there was an opportunity for improvement.
    The same example can be re-written using AngularJS, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 的设计者意识到有改进的机会。相同的示例可以使用 AngularJS 重新编写，如下所示：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding fragment is entirely in HTML. It includes the AngularJS framework
    from a remote server, **Content Delivery Network** (**CDN**). The body HTML element
    is annotated with a non-standard attribute, `ng-app`, in order to declare that
    this DOM node is part of the overall template. The other attribute, `ng-init`,
    declares a data model before the template is rendered on the client side. AngularJS
    needs to know where to start templating or modifying the DOM dynamically; therefore,
    every page starts with the `ng-app` attribute. Usually, the `ng-app` attribute
    is applied to the HTML `body` element. An AngularJS template would be useless
    without access to a data model, and this is the purpose of the `ng-init` attribute.
    It sets up a scoped variable called `greeting-name` and assigns it the String
    literal value, `Mr. Anderson`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的片段完全是 HTML。它从一个远程服务器包含了 AngularJS 框架，**内容分发网络**（**CDN**）。HTML 的主体元素被一个非标准属性
    `ng-app` 标注，以声明这个 DOM 节点是整体模板的一部分。另一个属性 `ng-init` 在客户端渲染模板之前声明了一个数据模型。AngularJS
    需要知道从哪里开始模板或动态修改 DOM；因此，每个页面都以 `ng-app` 属性开始。通常，`ng-app` 属性应用于 HTML 的 `body` 元素。没有访问数据模型，AngularJS
    模板将毫无用处，这就是 `ng-init` 属性的目的。它设置了一个作用域变量 `greeting-name` 并将其赋值为字符串字面量 `Mr. Anderson`。
- en: 'Note the additional attribute type `ng-model` and the special, double curly
    bracket syntax: `{{customer-name}}`. The attribute is a special extension provided
    by the AngularJS framework that identifies the data model inline, and the curly
    brackets represent a special HTML templating syntax called directive. Here we
    applied the `ng-model` attribute to the input field element. When the page is
    loaded, the input text field is shown with the text `Mr Anderson`. The code also
    allows the user to enter text in the input field and simultaneously updates the
    message area. There is no programming required for this simple case; in fact it
    is declarative. So what is the secret sauce? The following code shows one form
    of two-way binding. Let''s extend it to demonstrate the complete two-way binding:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意额外的属性类型 `ng-model` 和特殊的双大括号语法：`{{customer-name}}`。这个属性是 AngularJS 框架提供的一个特殊扩展，用于在行内标识数据模型，而大括号代表一种特殊的
    HTML 模板语法，称为指令。在这里，我们将 `ng-model` 属性应用于输入字段元素。当页面加载时，输入文本字段显示文本 `Mr Anderson`。代码还允许用户在输入字段中输入文本，并同时更新消息区域。在这个简单的情况下，不需要编程；实际上，它是声明式的。那么，秘诀是什么呢？下面的代码展示了双向绑定的一种形式。让我们扩展它来演示完整的双向绑定：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We introduced the HTML `button` elements with a new attribute, `ng-click`. The
    value of the attribute is an AngularJS JavaScript expression. Each button updates
    the data model with a new name. Effectively, they reset the name in the input
    field and the message area. How cool is that? There is no jQuery programming in
    there at all. AngularJS has many special custom attributes such as `ng-repeat`,
    `ng-switch`, and `ng-option`, which we will encounter later in this chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了带有新属性 `ng-click` 的 HTML `button` 元素。属性的值是一个 AngularJS JavaScript 表达式。每个按钮都会用新的名字更新数据模型。实际上，它们重置了输入字段和消息区域中的名字。这有多酷？这里根本不需要
    jQuery 编程。AngularJS 有许多特殊的自定义属性，如 `ng-repeat`、`ng-switch` 和 `ng-option`，我们将在本章后面遇到。
- en: You might be wondering about these bindings and templates being very clever;
    so how does it work on the client side?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道这些绑定和模板非常聪明；那么客户端是如何工作的呢？
- en: How does AngularJS work?
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AngularJS 是如何工作的？
- en: AngularJS is loaded in a web browser as part of the HTML page content. The strongest
    part of the framework is that it encourages the separation of concerns. The presentation
    view should be mixed deliberately with business logic and the data model. There
    are a couple of reasons for this. When the Angular JS framework is loaded a page
    is triggered, the framework marches up and down the DOM and looks for certain
    non-standard attributes called directives. It parses and processes this markup
    with the compiler. Effectively, AngularJS transforms the statically loaded DOM
    and produces a rendered view. The framework takes these directives and creates
    associations, binding, and extra behavior.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 作为 HTML 页面内容的一部分在网页浏览器中加载。框架最强大的部分是它鼓励关注点的分离。表示视图应该故意与业务逻辑和数据模型混合。这有几个原因。当
    Angular JS 框架加载页面时，框架会在 DOM 中上下移动并寻找某些非标准属性，称为指令。它使用编译器解析和处理这个标记。实际上，AngularJS
    将静态加载的 DOM 转换为渲染视图。框架将这些指令创建关联、绑定和额外的行为。
- en: The `ng-app` attribute is linked to a directive that initializes the application.
    The `ng-init` is linked to a directive that allows the programmer to set up a
    data model. It can be used to assign values to the variables. The `ng-model` is
    associated with directive access or stores the value that is associated with an
    HTML Input element. AngularJS allows the developers to write custom directives.
    You may want to write one in the future to get access to the DOM.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`ng-app` 属性与一个初始化应用的指令相关联。`ng-init` 与一个允许程序员设置数据模型的指令相关联。它可以用来给变量赋值。`ng-model`
    与指令访问相关联或存储与 HTML 输入元素相关联的值。AngularJS 允许开发者编写自定义指令。你可能将来会想编写一个来获取对 DOM 的访问权限。'
- en: AngularJS works on the idea of nested scopes within a template view. A scope
    is an execution context for expressions. Scopes can be organized in an hierarchical
    fashion such that they mimic the DOM model.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 在模板视图中基于嵌套作用域工作。作用域是表达式的执行上下文。作用域可以以层次结构组织，以便它们模仿 DOM 模型。
- en: '![How does AngularJS work?](img/image00419.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![AngularJS 的工作原理](img/image00419.jpeg)'
- en: How AngularJS works in principle
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 的基本工作原理
- en: AngularJS relies on the JavaScript modules that define controllers and other
    logic. Modules can be dependent on other modules; however, unlike RequireJS, modules
    that are a part of disparate JavaScript files are not automatically loaded in
    the application. A scope is the glue that binds the presentation and the data
    model. A scope is the place in the AngularJS where watchers and listeners are
    defined. Most of the time, the framework will automatically handle expression
    handling and data binding, and handle the notifications between JavaScript modules
    and DOM element components. After the compilation phase, AngularJS moves on to
    the linking phase and associates expressions to the module controller methods
    and other resources.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 依赖于定义控制器和其他逻辑的 JavaScript 模块。模块可以依赖于其他模块；然而，与 RequireJS 不同，不属于不同 JavaScript
    文件的模块不会自动加载到应用程序中。作用域是绑定表示和数据模型的粘合剂。作用域是 AngularJS 中定义观察者和监听器的地方。大多数时候，框架将自动处理表达式处理和数据绑定，并处理
    JavaScript 模块和 DOM 元素组件之间的通知。在编译阶段之后，AngularJS 继续到链接阶段，并将表达式关联到模块控制器方法和其他资源。
- en: 'Let''s summarize these steps:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结这些步骤：
- en: AngularJS framework bootstraps itself. In particular, it searches the DOM for
    an HTML element with the `ng-app` attribute. This is the trigger point for the
    framework.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AngularJS 框架启动自身。特别是，它搜索 DOM 中带有 `ng-app` 属性的 HTML 元素。这是框架的触发点。
- en: Once the `ng-app` element is found, AngularJS creates a dependency injector.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦找到 `ng-app` 元素，AngularJS 就会创建一个依赖注入器。
- en: It then compiles the static DOM into rendering an intermediate view, collecting
    directives as it goes.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它将静态 DOM 编译成渲染中间视图，在过程中收集指令。
- en: AngularJS then starts to link and compose the directives with their associated
    scope. This is an algorithmic and hierarchical operation. The framework creates
    an initial scope called the root scope before executing the linking phase.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，AngularJS 开始将指令与它们关联的作用域进行链接和组合。这是一个算法性和层次性的操作。在执行链接阶段之前，框架创建了一个初始作用域，称为根作用域。
- en: Finally, AngularJS invokes an apply call using the root scope, and during this
    stage, the view is rendered.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，AngularJS 使用根作用域调用 apply 调用，在这个阶段，视图被渲染。
- en: 'Let''s look at the view of the caseworker. In the book''s source code, you
    will find the Gradle project called **xen-force-angularjs**. It follows the Maven
    convention for Java EE projects. Our discussion will be split into two sections.
    We will look at the frontend code that consists of HTML5, JavaScript, and some
    CSS. Afterwards, we will delve into the Java server-side backend. Let''s have
    a look at the following figure:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看案件工作者的视图。在书籍的源代码中，你会找到一个名为 **xen-force-angularjs** 的 Gradle 项目。它遵循 Java
    EE 项目的 Maven 惯例。我们的讨论将分为两个部分。我们将查看由 HTML5、JavaScript 和一些 CSS 组成的前端代码。之后，我们将深入研究
    Java 服务器端后端。让我们看看以下这张图：
- en: '![How does AngularJS work?](img/image00420.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![AngularJS 的工作原理](img/image00420.jpeg)'
- en: Th relationship of directives to business logic in AngularJS
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 指令与 AngularJS 中的业务逻辑之间的关系
- en: Caseworker overview
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案件工作者概述
- en: The caseworker project shows a master-detail application. Our worker starts
    the application and sees a list of case records, which contains the names and
    the passport details for each applicant. This is the master record. Each case
    record may have a zero or more task records attached. Those are the details records
    of the master. Each master record also contains a state property that shows where
    each applicant is in the process. Our user is permitted to access all of the case
    records and move the current state from start to finish.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 案件工作者项目展示了一个主从应用程序。我们的工作人员启动应用程序，看到一系列案件记录，其中包含每个申请人的姓名和护照详情。这是主记录。每个案件记录可能附有零个或多个任务记录。那些是主记录的详细记录。每个主记录还包含一个状态属性，显示每个申请人在过程中的位置。我们的用户被允许访问所有案件记录并将当前状态从开始移动到结束。
- en: Caseworker main view
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案件工作者主视图
- en: There is only one HTML file in the caseworker example, and it serves as the
    template in the `src/main/webapp/index.xhtml` file. Remember, this is meant to
    be a single-page application!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在案件工作者示例中只有一个 HTML 文件，它作为 `src/main/webapp/index.xhtml` 文件中的模板。记住，这是一个单页应用程序！
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The HTML tag element is attributed with an AngularJS directive, `ng-app`, which
    specifies the name of the scoped value that serves as the application. We have
    the usual `head` and `body` elements. We include the CSS files Bootstrap (`bootstrap.css`)
    and the application's style file, `main.css`. There is not much difference until
    we arrive at the `Body` tag, which is declared with the `ng-controller` attribute.
    The `ng-controller` directive attaches a controller to the view. The controller
    is the JavaScript object that is part of the MVC pattern. So the entire `body`
    tag element in the DOM is bound to the JavaScript object called `CaseRecordController`.
    We will see the code for it later, but first, let's dive just a little bit deeper.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 标签元素被赋予了一个 AngularJS 指令 `ng-app`，它指定了作为应用程序的作用域值名称。我们有常见的 `head` 和 `body`
    元素。我们包含了 CSS 文件 Bootstrap (`bootstrap.css`) 和应用程序的样式文件 `main.css`。直到我们到达带有 `ng-controller`
    属性的 `Body` 标签，没有太多区别。`ng-controller` 指令将控制器附加到视图中。控制器是 MVC 模式的一部分 JavaScript 对象。因此，DOM
    中的整个 `body` 标签元素绑定到名为 `CaseRecordController` 的 JavaScript 对象。我们稍后会看到它的代码，但首先，让我们深入一点。
- en: As you examine the code further, you will notice another controller directive
    on the `div` element with the CSS selector named `action-bar`. This element is
    associated with a different controller called `NewCaseRecordModalController`.
    Every time an `ng-controller` directive is attributed, AngularJS creates a brand
    new scope. So scopes can be nested with one another. This is the key concept in
    the AngularJS framework. The scope exists on the element that is associated with
    and enclosing other nested scopes, should they exist.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你进一步检查代码，你会在名为 `action-bar` 的 CSS 选择器的 `div` 元素上注意到另一个控制器指令。这个元素与一个名为 `NewCaseRecordModalController`
    的不同控制器相关联。每当一个 `ng-controller` 指令被赋予属性时，AngularJS 就会创建一个新的作用域。因此，作用域可以相互嵌套。这是
    AngularJS 框架中的关键概念。如果存在，作用域存在于与嵌套作用域相关联并包含它们的元素上。
- en: The main view renders a table of the case records. The preceding code renders
    the first and last names of the applicant, their sex, their date of birth, their
    ISO country code, their passport number, and their passport's expiration date.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 主视图渲染了一个案件记录的表格。前面的代码渲染了申请人的姓名、性别、出生日期、ISO 国家代码、护照号码和护照的有效期。
- en: 'The following is the next part of the content that renders the master table
    row:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内容是渲染主表行的下一部分：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There are several parts to this code content. The `ng-repeat-start` is a special
    directive that allows the content to be iterated using an expression. The expression
    is a form selection query that AngularJS evaluates dynamically. So, the `<"caseRecord
    in caseRecords">` expression means an overall iteration of the objects in the
    scope named `caseRecords`, and assigning each element as an object called `caseRecord`.
    We use the AngularJS binding directive expressions to render the information for
    each case record in the appropriate table cell element. We do this for the cell
    `{{caseRecord.lastName}}`, then rinse and repeat.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码内容有几个部分。`ng-repeat-start` 是一个特殊的指令，它允许使用表达式迭代内容。表达式是一个 AngularJS 动态评估的表单选择查询。因此，`<"caseRecord
    in caseRecords">` 表达式意味着对名为 `caseRecords` 的作用域中对象的总体迭代，并将每个元素分配为一个名为 `caseRecord`
    的对象。我们使用 AngularJS 绑定指令表达式在适当的表格单元格元素中渲染每个案件记录的信息。我们对 `{{caseRecord.lastName}}`
    单元格这样做，然后重复此过程。
- en: The first data cell is special, because it renders an embedded `div` element.
    It illustrates how to associate a Boolean value and provides an expanding and
    collapsing association to the case record. We must create a scope on the `div`
    and associate the appropriate controller `NewCaseRecordModalController` with the
    `ng-controller` attribute. We take advantage of the `ng-click` directive to invoke
    a method on the controller called `showOrHideTasks()`. Notice that we pass the
    parent of the scope, which contains the current `CaseRecord` as the table is being
    rendered. There is another directive, `ng-class`, that associates the icon element
    with the appropriate glyph icon from Bootstrap by setting the CSS selector. This
    code opens and closes a secondary row in the table view, which renders a task
    view. It also updates the glyph icon correctly based on whether the task view
    is open or closed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个数据单元格是特殊的，因为它渲染了一个嵌入的 `div` 元素。它说明了如何关联一个布尔值，并提供了一个展开和折叠的关联到案例记录。我们必须在 `div`
    上创建一个作用域，并将适当的控制器 `NewCaseRecordModalController` 与 `ng-controller` 属性关联起来。我们利用
    `ng-click` 指令来调用控制器上的 `showOrHideTasks()` 方法。注意，我们传递作用域的父元素，其中包含当前的 `CaseRecord`，因为表格正在渲染。还有一个名为
    `ng-class` 的指令，它通过设置 CSS 选择器将图标元素与 Bootstrap 中的适当矢量图标关联起来。此代码在表格视图中打开和关闭一个二级行，渲染任务视图。它还根据任务视图是打开还是关闭来正确更新矢量图标。
- en: 'The third part of this table view content now follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此表格视图内容的第三部分现在如下所示：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The secondary row in the master table has an `ng-repeat-end` directive, which
    informs AngularJS which DOM element finishes the loop iteration for each `CaseRecord`
    element. There is actually another directive called `ng-repeat` that combines
    `ng-repeat-start` and `ng-repeat-end` for a single DOM element. That directive
    is usually for rendering the simple rows in a table.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 主表格中的二级行有一个 `ng-repeat-end` 指令，它通知 AngularJS 每个案例记录元素结束循环迭代的 DOM 元素。实际上还有一个名为
    `ng-repeat` 的指令，它将 `ng-repeat-start` 和 `ng-repeat-end` 结合到一个单个 DOM 元素上。该指令通常用于渲染表格中的简单行。
- en: The `ng-if` directive conditionally adds or removes content from the DOM. We
    use this `ng-if` to show and hide the task view area for each case record element.
    AngularJS provides other similar directives called `ng-show` and `ng-hide`, but
    those do not dynamically add or remove content from the DOM.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`ng-if` 指令条件性地向 DOM 中添加或删除内容。我们使用这个 `ng-if` 来显示或隐藏每个案例记录元素的任务视图区域。AngularJS
    提供了其他类似的指令，称为 `ng-show` 和 `ng-hide`，但它们不会动态地从 DOM 中添加或删除内容。'
- en: Tip
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Why would we choose `ng-if` over `ng-show`? Suppose you have hundreds of case
    record elements in your database, would we want to render all of those cases and
    their task history on the web frontend?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们会选择 `ng-if` 而不是 `ng-show`？假设你的数据库中有数百个案例记录元素，我们是否想在 Web 前端渲染所有这些案例及其任务历史？
- en: We have a `div-layer` element dedicated for showing the tasks associated with
    a case record. Look at the CSS selector, `case-record-task-view`. We add content
    to display each `task` element as a table. There is an example for using the `ng-repeat`
    that has an expression task, in `caseRecord.tasks`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个 `div-layer` 元素，专门用于显示与案例记录关联的任务。看看 CSS 选择器，`case-record-task-view`。我们添加内容以显示每个
    `task` 元素作为表格。有一个使用 `ng-repeat` 的示例，它有一个表达式任务，在 `caseRecord.tasks` 中。
- en: There are two other inner `div` layers. The first element is bound to the logic
    to edit the current case record and references the controller called `NewCaseRecordModalController`.
    The second element allows the user to create a new task, and it references a new
    controller called `NewTaskModalController`. We will see the JavaScript code for
    these controllers later on.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个其他的内部 `div` 层。第一个元素绑定到编辑当前案例记录的逻辑，并引用名为 `NewCaseRecordModalController` 的控制器。第二个元素允许用户创建一个新的任务，并引用一个名为
    `NewTaskModalController` 的新控制器。我们将在稍后看到这些控制器的 JavaScript 代码。
- en: 'The following screenshot illustrates the expansion and contraction for show
    tasks:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了显示任务的展开和收缩：
- en: '![Caseworker main view](img/image00421.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![案件工作者主视图](img/image00421.jpeg)'
- en: This screenshot depicts the expansion and contraction of the secondary row element
    with `ng-if`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这张截图展示了使用 `ng-if` 的二级行元素的展开和收缩。
- en: 'To complete the content for the table view, we write table data rows to show
    the properties of the `task` element:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成表格视图的内容，我们写入表格数据行以显示 `task` 元素的属性：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the fourth part of the view, we take full advantage of the AngularJS two-way
    binding to render an HTML `checkbox` element and associate it with the Boolean
    property, `caseRecord.completed`. Using the CSS selector, we dynamically change
    the text of the task name with the class selector expression, `class="done-{{task.completed}}"`.
    When the user changes the checkbox, the following CSS is chosen:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图的第四部分，我们充分利用AngularJS的双向绑定来渲染一个HTML `checkbox`元素，并将其与布尔属性`caseRecord.completed`关联。使用CSS选择器，我们使用类选择器表达式`class="done-{{task.completed}}"`动态更改任务名称的文本。当用户更改复选框时，选择以下CSS：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When the task is completed, the text is struck through! We added an `ng-change`
    directive to the checkbox element, which AngularJS associates with a change event.
    AngularJS invokes the method, `updateProjectTaskCompleted()` on the controller
    `NewTaskModalController`. This method invokes a `WebSocket` call. We will explain
    the code behind it soon! Notice that the method call passes the current `task`
    element, because we are still in the rendering scope.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当任务完成时，文本会被划掉！我们向复选框元素添加了`ng-change`指令，AngularJS将其与一个改变事件关联。AngularJS调用控制器`NewTaskModalController`上的`updateProjectTaskCompleted()`方法。此方法调用一个`WebSocket`调用。我们很快会解释其背后的代码！请注意，方法调用传递了当前的`task`元素，因为我们仍然处于渲染作用域中。
- en: In order to complete the task view, we have a `div` layer associated with the
    controller `NewTaskModalController` with glyph icon buttons to edit and remove
    a task. As you can see, we need to pass in `$parent.task` in order to reference
    the element loop variable.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成任务视图，我们有一个与控制器`NewTaskModalController`关联的`div`层，带有用于编辑和删除任务的图标按钮。正如你所看到的，我们需要传递`$parent.task`以便引用元素循环变量。
- en: It's time to look at the project organization and then the individual JavaScript
    modules, controllers, and factories.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候查看项目组织以及单个JavaScript模块、控制器和工厂了。
- en: Project organization
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目组织
- en: 'The project is organized into a Java EE web application. We put all our JavaScript
    code into the folders that follow the convention for AngularJS, because it is
    likely that we are professionally working in a full-stack environment and sharing
    the code base with mixed skills. The AngularJS controllers are placed under `app/controllers`,
    while the factories and services are placed under `app/service`, as shown in the
    following structure:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 项目被组织成一个Java EE网络应用程序。我们将所有的JavaScript代码放入遵循AngularJS约定的文件夹中，因为我们很可能在一个全栈环境中专业工作，并与具有混合技能的代码库共享。AngularJS控制器放在`app/controllers`下，而工厂和服务放在`app/service`下，如下所示的结构：
- en: '`src/main/webapp/app/controllers`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/app/controllers`'
- en: '`src/main/webapp/app/controllers/main.js`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/app/controllers/main.js`'
- en: '`src/main/webapp/app/controllers/newcaserecord-modal.js`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/app/controllers/newcaserecord-modal.js`'
- en: '`src/main/webapp/app/controllers/newtask-modal.js`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/app/controllers/newtask-modal.js`'
- en: '`src/main/webapp/app/services`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/app/services`'
- en: '`src/main/webapp/app/services/iso-countries.js`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/app/services/iso-countries.js`'
- en: '`src/main/webapp/app/services/shared-services.js`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/app/services/shared-services.js`'
- en: 'Next, we put the third-party JavaScript libraries into their designated area:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将第三方JavaScript库放入指定的区域：
- en: '`src/main/webapp/javascripts`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/javascripts`'
- en: '`src/main/webapp/javascripts/angular.js`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/javascripts/angular.js`'
- en: '`src/main/webapp/javascripts/bootstrap.js`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/javascripts/bootstrap.js`'
- en: '`src/main/webapp/javascripts/jquery-2.1.3.js`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/javascripts/jquery-2.1.3.js`'
- en: '`src/main/webapp/javascripts/ui-bootstrap-0.12.1.js`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/javascripts/ui-bootstrap-0.12.1.js`'
- en: '`src/main/webapp/javascripts/ui-bootstrap-tpl-0.12.1.js`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/javascripts/ui-bootstrap-tpl-0.12.1.js`'
- en: 'Note that our caseworker application also depends on Bootstrap, jQuery, and
    the extension library, Bootstrap UI for AngularJS. We include all these libraries
    explicitly in the last part of the content for the main view `index.html`, which
    is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的案件工作者应用程序还依赖于Bootstrap、jQuery和扩展库，Bootstrap UI for AngularJS。我们在主视图`index.html`的内容最后部分明确包含了所有这些库，如下所示：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As I said earlier, we've kept the code base simpler for the purpose of demonstration,
    but we could have used RequireJS to handle the dependency loading.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所说，为了演示的目的，我们保持了代码库的简单性，但我们本可以使用RequireJS来处理依赖加载。
- en: Tip
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you don't explicitly load jQuery before AngularJS, then it will load its
    own smaller version of jQuery called **jq-lite**. So if your application depends
    on the full version of the jQuery library, please ensure it is loaded before AngularJS.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有在 AngularJS 之前明确加载 jQuery，那么它将加载自己的较小版本的 jQuery，称为 **jq-lite**。所以如果你的应用程序依赖于
    jQuery 库的完整版本，请确保它在 AngularJS 加载之前加载。
- en: 'The final step is to put the CSS in their own special area:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将 CSS 放入它们自己的特殊区域：
- en: '`src/main/webapp/styles`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/styles`'
- en: '`src/main/webapp/styles/bootstrap.css`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/styles/bootstrap.css`'
- en: '`src/main/webapp/styles/bootstrap-theme.css`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/styles/bootstrap-theme.css`'
- en: '`src/main/webapp/styles/main.css`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/webapp/styles/main.css`'
- en: The preceding files are loaded at the top of the main view, inside the usual
    `head` HTML element.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 上述文件在主视图的顶部加载，位于常规的 `head` HTML 元素内。
- en: Application main controller
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序主控制器
- en: 'The first module in our AngularJS application declares the name of the application.
    The following is the declaration in the file: `src/main/webapp/app/controllers/main.js`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 AngularJS 应用程序中的第一个模块声明了应用程序的名称。以下是在文件 `src/main/webapp/app/controllers/main.js`
    中的声明：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The framework exports a function object called `angular`, and it has a method
    called `module` that defines a module. The first argument is the name of the module
    and the second argument is an array of the dependent module names. The `module()`
    method returns an AngularJS module object to the caller. From there, we declare
    the initial controller.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架导出一个名为 `angular` 的函数对象，并且它有一个名为 `module` 的方法，用于定义一个模块。第一个参数是模块的名称，第二个参数是依赖模块名称的数组。`module()`
    方法将 AngularJS 模块对象返回给调用者。从那里，我们声明初始控制器。
- en: The module `ui.bootstrap` contains AngularJS and Bootstrap integrations. The
    module `newcaserecord` is part of the caseworker application and defines a controller,
    which inserts and amends the master records. The module `newtask` defines a controller,
    which inserts, amends, and removes the details records. The `sharedService` defines
    a factory provider that performs utility functions for the application, and, finally,
    `isoCountries` defines another provider that holds a list of the ISO passport
    countries.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 模块 `ui.bootstrap` 包含 AngularJS 和 Bootstrap 的集成。模块 `newcaserecord` 是案件工作人员应用程序的一部分，并定义了一个控制器，用于插入和修改主记录。模块
    `newtask` 定义了一个控制器，用于插入、修改和删除详细记录。`sharedService` 定义了一个工厂提供者，执行应用程序的实用函数，最后，`isoCountries`
    定义了另一个提供者，包含 ISO 护照国家的列表。
- en: 'AngularJS framework has a fluent API for defining modules, controllers, and
    providers; therefore, we could write an almost declarative JavaScript like the
    following code extract shows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 框架有一个流畅的 API 用于定义模块、控制器和提供者；因此，我们可以编写类似于以下代码摘录的几乎声明式的 JavaScript：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding coding style is a matter of taste and the disadvantage is that
    all your modules are lumped together. A lot of professional developers prefer
    to assign the actual Angular module objects to global module variables.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 上述编码风格是个人喜好问题，其缺点是所有模块都被合并在一起。许多专业开发者更喜欢将实际的 Angular 模块对象分配给全局模块变量。
- en: 'The body tag element in the view defines a controller:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 视图中的 `body` 标签元素定义了一个控制器：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following extract shows the controller `CaseRecordController` that binds
    the user interface to a client-side data model:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下摘录显示了将用户界面绑定到客户端数据模型的控制器 `CaseRecordController`：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The controller method in the AngularJS object accepts the first parameter as
    the name. The second argument is the function object and as conventional wisdom,
    we pass in an anonymous JavaScript function with arguments.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 对象中的控制器方法接受第一个参数作为名称。第二个参数是函数对象，按照惯例，我们传递一个带有参数的匿名 JavaScript 函数。
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The parameters are all object modules that AngularJS injects to the controller.
    AngularJS defines standard modules beginning with the dollar character (`$`).
    The module `$scope` is a special parameter that denotes the current scope. The
    module `$http` represents a core AngularJS service with methods that communicate
    with a remote HTTP server. The module `$log` is another core service for logging
    to the console. The other parameters `UpdateTaskStatusFactory`, `sharedService`,
    and `isoCountries` are factories and services that our application provides. AngularJS,
    like many JavaScript modern digital frameworks, encourages modular programming
    and avoids polluting the global scope as much as possible.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 参数都是 AngularJS 注入到控制器中的对象模块。AngularJS 定义了以美元符号（`$`）开头的标准模块。模块 `$scope` 是一个特殊参数，表示当前作用域。模块
    `$http` 代表一个核心 AngularJS 服务，具有与远程 HTTP 服务器通信的方法。模块 `$log` 是另一个核心服务，用于向控制台记录日志。其他参数
    `UpdateTaskStatusFactory`、`sharedService` 和 `isoCountries` 是我们应用程序提供的工厂和服务。AngularJS，像许多现代
    JavaScript 数字框架一样，鼓励模块化编程，并尽可能避免污染全局作用域。
- en: So what does this controller do? First, for demonstration purposes, the controller
    initializes a dummy JSON record, `$scope.caseRecord`, just in case the server
    is not available by the time the page view loads. Next, we define a property for
    the list of records, `$scope.caseRecords`. Yes, adding custom properties to the
    AngularJS `$scope` is the way to communicate from the data model to the user interface.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这个控制器具体做什么呢？首先，出于演示目的，控制器初始化了一个虚拟的 JSON 记录，`$scope.caseRecord`，以防在页面视图加载时服务器不可用。接下来，我们为记录列表定义了一个属性，`$scope.caseRecords`。是的，向
    AngularJS `$scope` 添加自定义属性是数据模型与用户界面通信的方式。
- en: We define properties for the controller, `$scope.isoCountries`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为控制器定义了属性，`$scope.isoCountries`。
- en: 'We define our first function, `getCaseRecords()`, which is as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了第一个函数，`getCaseRecords()`，如下所示：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This function makes a RESTful GET request to the remote server from the same
    host that serves the page view. The URL would be something like this: `http://localhost:8080/xen-national-force/rest/caseworker/list`.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数从同一主机向远程服务器发出 RESTful GET 请求，该主机提供页面视图。URL 可能类似于这样：`http://localhost:8080/xen-national-force/rest/caseworker/list`。
- en: We leverage the fluent API to perform an action once the server returns a JSON
    result. The anonymous function overwrites the `$scope.caseRecords` property with
    the latest data.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用流畅的 API 在服务器返回 JSON 结果后执行一个操作。匿名函数用最新的数据覆盖了 `$scope.caseRecords` 属性。
- en: Incidentally, as we construct the function object `CaseRecordController`, we
    invoke the method `getCaseRecords()` in order to kick start the application.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，当我们构建 `CaseRecordController` 的函数对象时，我们调用 `getCaseRecords()` 方法来启动应用程序。
- en: In AngularJS, we can pass information from one controller to another using a
    factory service that our application creates or by making an HTTP request to the
    server. It is also possible to listen to the events that AngularJS publishes on
    a broadcast channel.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AngularJS 中，我们可以通过创建应用程序创建的工厂服务或通过向服务器发出 HTTP 请求，将信息从一个控制器传递到另一个控制器。还有可能监听
    AngularJS 在广播频道上发布的事件。
- en: 'The following code in `CaseRecordController` demonstrates how to update the
    user interface on all messages but one:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `CaseRecordController` 中的以下代码演示了如何更新除一条消息之外的所有消息的用户界面：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we register an event handler on the AngularJS scope in order to retrieve
    a notification from our `SharedService` provider. The `$on()` method registers
    a listener on a specific event type. The first parameter is the message type,
    and the second parameter is the callback. Inside the function callback, we make
    an HTTP request to retrieve the entire set of case records from the server side
    if the message, and therefore the custom event, is not `showTasksCaseRecord`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在 AngularJS 作用域上注册了一个事件处理器，以便从我们的 `SharedService` 提供者获取通知。`$on()` 方法在特定事件类型上注册了一个监听器。第一个参数是消息类型，第二个参数是回调函数。在函数回调内部，如果消息（因此是自定义事件）不是
    `showTasksCaseRecord`，我们就会向服务器发出 HTTP 请求以检索整个案例记录集。
- en: Tip
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Inside the handler callback, we read the entire the dataset, which could be
    thousands of case records in a real enterprise application. Therefore, we can
    improve the performance of the REST call-and-response code. We should, however,
    resist the urge to descend down the path of too early optimization. You should
    prefer to just get the user story working.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理程序回调函数内部，我们读取整个数据集，这在实际的企业应用程序中可能是数千个案例记录。因此，我们可以提高REST调用和响应代码的性能。然而，我们应该抵制过早优化的诱惑。你应该优先考虑让用户故事工作。
- en: The other methods in the controller, `connect()` and `send()`, establish a WebSocket
    channel to the server and send a JSON message down to the server respectively.
    We will examine the `UpdateTaskStatusFactory` module, and the final method, `updateProjectTaskCompleted()`,
    in a later section.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器中的其他方法，`connect()` 和 `send()`，分别建立到服务器的WebSocket通道并向服务器发送JSON消息。我们将在稍后的部分检查
    `UpdateTaskStatusFactory` 模块，以及最后的 `updateProjectTaskCompleted()` 方法。
- en: If you've never developed, professionally, any JavaScript before, then this
    chapter might appear very daunting initially. However, please persevere as it
    is really only about having enough patience to succeed. In this regard, I have
    prepared a simplistic diagram of the AngularJS scopes as they appear in our caseworker
    application.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前从未专业地开发过任何JavaScript，那么这个章节可能一开始看起来非常令人畏惧。然而，请坚持下去，因为这实际上只是关于有足够的耐心才能成功。在这方面，我准备了一个简化的AngularJS作用域图，它在我们案件工作人员应用程序中呈现的样子。
- en: '![Application main controller](img/image00422.jpeg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序主控制器](img/image00422.jpeg)'
- en: AngularJS scopes in the caseworker application
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 案件工作人员应用程序中的AngularJS作用域
- en: This preceding diagram charts the journey of the progress and helps us understand
    where we are going. It also establishes the concept of how AngularJS binds scopes
    in an hierarchical fashion resembling the DOM itself. Behind the scenes, AngularJS
    creates internal scopes to handle the repeatable DOM elements that render the
    HTML `table` element, which is the list of the case records. Developers cannot
    access these internal data except by programming with expressions, and we should
    treat them as opaque objects.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表描绘了进度之旅，帮助我们了解我们将要走向何方。它还建立了AngularJS如何以类似于DOM本身的方式分层绑定作用域的概念。幕后，AngularJS创建内部作用域来处理渲染HTML
    `table` 元素的重复性DOM元素，这是案例记录的列表。开发者只能通过编程表达式来访问这些内部数据，我们应该将它们视为不透明对象。
- en: Tip
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: At the time of writing, there is a Google Chrome plugin called Batarang ([https://chrome.google.com/webstore/detail/angularjs-batarang-stable/](https://chrome.google.com/webstore/detail/angularjs-batarang-stable/)),
    which I would have strongly recommended to examine the AngularJS scope inside
    the browser. Sadly, it seems that the tool is no longer maintained. It is still
    worth checking if someone has adopted it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，有一个名为Batarang的Google Chrome插件（[https://chrome.google.com/webstore/detail/angularjs-batarang-stable/](https://chrome.google.com/webstore/detail/angularjs-batarang-stable/)），我强烈推荐检查浏览器中的AngularJS作用域。遗憾的是，这个工具似乎不再维护。如果有人采用了它，仍然值得检查。
- en: New case record controller
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新案例记录控制器
- en: We have placed the code to create and edit the case records in a separate file
    called `newcaserecord-modal.js`, which contains the user-defined AngularJS module
    `newcaserecord`. This module has dependencies on other modules, some of them mentioned
    before. The `ui.bootstrap.modal` is a special module from the AngularJS UI Bootstrap
    third-party framework. The module defines the Bootstrap components written by
    the AngularJS team. In particular, it has a helpful modal dialog extension, which
    we use throughout the caseworker application.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建和编辑案例记录的代码放置在一个名为 `newcaserecord-modal.js` 的单独文件中，该文件包含用户定义的AngularJS模块
    `newcaserecord`。此模块依赖于其他模块，其中一些之前已经提到。`ui.bootstrap.modal` 是来自AngularJS UI Bootstrap第三方框架的一个特殊模块。该模块定义了AngularJS团队编写的Bootstrap组件。特别是，它有一个有用的模态对话框扩展，我们在整个案件工作人员应用程序中使用。
- en: 'The following is the shortened code for the `newcaserecord` module and the
    `NewCaseRecordModalController`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为 `newcaserecord` 模块和 `NewCaseRecordModalController` 的简短代码：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The controller function object accepts injected parameters such as `$http`,
    `$log`, and `sharedService`. We also inject the `$modal` instance, which allows
    us to open modal dialogs in the controller.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器函数对象接受注入的参数，如 `$http`、`$log` 和 `sharedService`。我们还注入了 `$modal` 实例，这使得我们可以在控制器中打开模态对话框。
- en: Since each controller has its own scope injected into it, we need to provide
    elements of the data model in order to be accessible to the view. So we create
    an empty case record in the scope as `$scope.caseRecord`. We also set up return
    data and the ISO countries list.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个控制器都注入了自己的作用域，我们需要提供数据模型元素以便视图可以访问。因此，我们在作用域中创建了一个空的案例记录 `$scope.caseRecord`。我们还设置了返回数据和ISO国家列表。
- en: The function `$scope.openCreateCaseRecordDialog()` generates a modal dialog,
    so the user is allowed to enter a master case record.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `$scope.openCreateCaseRecordDialog()` 生成一个模态对话框，因此用户可以输入主案例记录。
- en: Tip
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Allowing a user to create arbitrary application passport records would be probably
    forbidden and restricted to any employee except to the administrators and managers.
    Our demonstration application has no concept of roles and permissions at all.
    Developers should be careful to avoid introducing zero-day exploits into their
    digital applications.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 允许用户创建任意应用程序护照记录可能会被禁止，并且仅限于管理员和经理以外的任何员工。我们的演示应用程序根本没有任何角色和权限的概念。开发者应该小心，避免将零日漏洞引入他们的数字应用程序中。
- en: 'The UI Bootstrap extension accepts several parameters. The first parameter
    is a reference to the HTML template directive. The second parameter refers to
    another controller called `newCaseRecordModalInstanceController`, which is responsible
    for handling the interaction with the dialog. The third argument is a resolver
    and it permits the library code to find the reference data in the user''s modal
    inside the enclosing scope:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: UI Bootstrap 扩展接受多个参数。第一个参数是HTML模板指令的引用。第二个参数指的是另一个名为 `newCaseRecordModalInstanceController`
    的控制器，该控制器负责处理与对话框的交互。第三个参数是解析器，它允许库代码在封装作用域内找到用户模态中的引用数据：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The next part of the controller, `NewCaseRecordModalController` handles the
    callback after the modal dialog completes successfully, because the user entered
    the data and pressed the confirm button. We register two function objects as parameters
    on the object called `then`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器的下一部分，`NewCaseRecordModalController` 处理模态对话框成功完成后的回调，因为用户输入了数据并按下了确认按钮。我们在名为
    `then` 的对象上注册了两个函数对象作为参数。
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first function is the callback handler that contains the code to make a
    REST POST request to the server with the case record data. The second function
    is reserved for when the dialog is dismissed. You will notice that AngularJS employs
    fluent interfaces. The code should be fairly understandable even if you don't
    happen to know everything about JavaScript and the framework.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数是回调处理程序，其中包含将案例记录数据发送到服务器的REST POST请求的代码。第二个函数保留用于对话框被取消的情况。你会注意到AngularJS使用了流畅的接口。即使你不了解JavaScript和框架的所有内容，代码也应该相当容易理解。
- en: 'So let''s look at the code for the modal dialog instance, namely the object
    `newCaseRecordModalInstanceController`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看模态对话框实例的代码，即对象 `newCaseRecordModalInstanceController`：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you notice, this variable is not quite an encapsulated module in JavaScript;
    rather, the `newCaseRecordModalInstanceController` function is declared in the
    global scope. I suppose there are always exceptions to the rule. The UI Bootstrap
    code invokes this controller function through the `$modalInstance.open()` call.
    The framework supplies the three arguments, the scope `$scope`, the modal instance
    `$modalInstance`, and the case record `caseRecord` to the function. We assign
    the case record to the supplied scope in order to write-back the data from the
    modal dialog. There, the function object implements two methods, `ok()` and `cancel()`,
    that handle the confirmation and cancellation of the dialog respectively.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到，这个变量并不是一个封装的JavaScript模块；相反，`newCaseRecordModalInstanceController` 函数是在全局作用域中声明的。我想总有例外。UI
    Bootstrap 代码通过 `$modalInstance.open()` 调用调用这个控制器函数。框架向该函数提供三个参数，即作用域 `$scope`、模态实例
    `$modalInstance` 和案例记录 `caseRecord`。我们将案例记录分配给提供的作用域，以便从模态对话框中写回数据。在那里，函数对象实现了两个方法，`ok()`
    和 `cancel()`，分别处理对话框的确认和取消。
- en: We only need to write the HTML directive for the dialog.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要编写对话框的HTML指令。
- en: The case record modal view template
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例记录模态视图模板
- en: As we know, all the content for the site is inside a single page application.
    HTML directives are also found in the view, `index.html`. How do you write a directive
    into the page content without it appearing in the view? Is the secret sauce something
    to do with CSS?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，网站的所有内容都在一个单页应用程序中。HTML指令也出现在视图`index.html`中。如何在页面内容中写入指令而不在视图中显示？秘诀是否与CSS有关？
- en: Although styling is a good idea, it is not the correct answer. The AngularJS
    designers take advantage of the formal definition for the HTML Script tag, which
    is the element that embeds or references the executable script.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然样式化是一个好主意，但这并不是正确答案。AngularJS设计者利用了HTML Script标签的正式定义，这是嵌入或引用可执行脚本的元素。
- en: 'The following is the HTML directive for inserting a new case record into the
    application:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将新案件记录插入应用程序的HTML指令：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding HTML directive defines a UI Bootstrap modal dialog, because the
    HTML `script` tag is denoted with the type attribute of `text/ng-template`. All
    AngularJS directives require an identifier. This directive contains a header,
    footer, and main as we can see from the CSS. The main `div` layer is an HTML form.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的HTML指令定义了一个UI Bootstrap模式对话框，因为HTML `script`标签被标记为`text/ng-template`类型的属性。所有AngularJS指令都需要一个标识符。从CSS中我们可以看到，该指令包含一个标题、页脚和主体。主要的`div`层是一个HTML表单。
- en: Each input field in the form is bound to the data model in the instance of `newCaseRecordModalInstanceController`.
    The case record was assigned to the scope as soon as the UI Bootstrap invoked
    the function object. Hence, the `ng-model` data model, `$scope.caseRecord.firstName`
    is available to the HTML text input element reserved for first names.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 表单中的每个输入字段都与`newCaseRecordModalInstanceController`实例中的数据模型绑定。一旦UI Bootstrap调用了函数对象，案件记录就被分配到了作用域中。因此，`ng-model`数据模型`$scope.caseRecord.firstName`对保留用于姓氏的HTML文本输入元素是可用的。
- en: AngularJS has an elegant additional markup for validating the form input elements.
    You can see the additional required attribute on almost all of the inputs. Unfortunately,
    as this book cannot delve into deeper details of validation checking, I want to
    draw your attention to two subtle validation checks.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS有一个优雅的额外标记用于验证表单输入元素。你可以在几乎所有输入上看到额外的必需属性。不幸的是，由于本书无法深入探讨验证检查的细节，我想将你的注意力引向两个微妙的验证检查。
- en: 'The data input exploits the UI Bootstrap date picker component to allow the
    case worker to easily enter dates:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 数据输入利用UI Bootstrap日期选择器组件，使案件工作人员能够轻松输入日期：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The format of the date is defined by the attribute, `datepicker-popup`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 日期的格式由`datepicker-popup`属性定义。
- en: 'Lastly, we display a drop-down list of the ISO passport country names in an
    HTML `select` element. The code for this part is as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在HTML `select`元素中显示ISO护照国家名称的下拉列表。这部分代码如下：
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `isoCountries` is a service instance, which we will see later. Since that
    module was injected into the `NewCaseRecordModalController` module and the scope
    of the latter happens to enclose the modal instance scope, AngularJS allow us
    to access the service. The `isoCountries` instance contains a list of the passport
    countries in a key and value dictionary. The code allows us to associate the ISO
    code `AUS` with the country name Australia. The `ng-option` attribute accepts
    an expression, which resembles an SQL query. We declaratively inform AngularJS
    how to derive the display name (`item.country`) and the input form value (`item.code`)
    for each HTML `option` element.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`isoCountries`是一个服务实例，我们将在后面看到。由于该模块被注入到`NewCaseRecordModalController`模块中，并且后者的作用域恰好包围了模式实例作用域，AngularJS允许我们访问该服务。`isoCountries`实例包含一个护照国家的键值字典列表。代码允许我们将ISO代码`AUS`与国家名称澳大利亚关联起来。`ng-option`属性接受一个表达式，类似于SQL查询。我们声明性地通知AngularJS如何为每个HTML
    `option`元素推导显示名称（`item.country`）和输入表单值（`item.code`）。'
- en: 'The following is a screenshot of the create case record modal dialog with the
    date picker:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个带有日期选择器的创建案件记录模式对话框的截图：
- en: '![The case record modal view template](img/image00423.jpeg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![案件记录模式视图模板](img/image00423.jpeg)'
- en: A screenshot of the create case record modal dialog with date picker in full
    effect
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 带有日期选择器的创建案件记录模式对话框的截图，日期选择器效果全开
- en: Let's move onto the task record controller that is similar to the case record
    controller.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到与案件记录控制器类似的任务记录控制器。
- en: New task record controller
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的任务记录控制器
- en: As a caseworker uses the system, he or she is able to expand and collapse the
    task record associated with the case record. The user can create, edit, and amend
    tasks, and can also change the state of the case.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当案件工作人员使用系统时，他们能够展开和折叠与案例记录相关的任务记录。用户可以创建、编辑和修改任务，还可以更改案件的状态。
- en: 'The AngularJS module `newtask` is defined thus:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 模块 `newtask` 定义如下：
- en: '[PRE24]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We add a configuration change to AngularJS around the HTTP remoting. There
    is a subtle bug with the HTTP DELETE request. The JAX-RS reference implementation,
    Jersey, which is present in the GlassFish and Payara application server, raises
    an HTTP error with a response code 415: `Unsupported Media Type`. This forces
    AngularJS to send the MIME type, as JSON on the DELETE requests solves the issue.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 AngularJS 的 HTTP 远程处理周围添加了一个配置更改。HTTP DELETE 请求中存在一个微妙的错误。存在于 GlassFish
    和 Payara 应用服务器中的 JAX-RS 引用实现 Jersey，在响应代码 415 时引发了一个 HTTP 错误：“不支持的媒体类型”。这迫使 AngularJS
    在 DELETE 请求中发送 MIME 类型，将 JSON 作为解决方法。
- en: 'Since the code for the task controller is so similar, only the create part
    of CRUD will be revealed in this book. Refer to the source for the other methods.
    The following is the source code for `NewTaskModalController`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于任务控制器的代码非常相似，本书中仅揭示 CRUD 的创建部分。有关其他方法的源代码，请参阅源文件。以下为 `NewTaskModalController`
    的源代码：
- en: '[PRE25]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this controller, instead of `$scope.caseRecord`, we have an empty, default
    `$scope.task` object. Every `Task` object has a reference to the parent through
    the property, `caseRecordId`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在此控制器中，我们有一个空的、默认的 `$scope.task` 对象，而不是 `$scope.caseRecord`。每个 `Task` 对象都通过
    `caseRecordId` 属性引用其父对象。
- en: The function, `openNewTaskDialog()` opens a UI Bootstrap modal dialog that allows
    the user to enter a brand task. The method wires up the modal dialog with the
    AngularJS scope of the current `Task` object. The big difference is the REST URL
    endpoint, which is in the form of `rest/caseworker/item/'+caseRecordId+'/task`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `openNewTaskDialog()` 打开一个 UI Bootstrap 模态对话框，允许用户输入一个新任务。该方法将模态对话框与当前 `Task`
    对象的 AngularJS 作用域连接起来。主要区别是 REST URL 端点，其形式为 `rest/caseworker/item/'+caseRecordId+'/task`。
- en: We use the UI Bootstrap `$modal` object and create a modal dialog instance as
    before, except that we now pass different arguments. The arguments are the HTML
    directive ID, which is `newTaskContent.html`; the controller is called `newTaskModalInstanceController`,and
    the resolver function. AngularJS invokes the resolver function, which is defined
    as an anonymous function, in order to reference the enclosing `Task` object.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 UI Bootstrap 的 `$modal` 对象，并创建一个与之前相同的模态对话框实例，但现在我们传递了不同的参数。这些参数是 HTML
    指令 ID，即 `newTaskContent.html`；控制器名为 `newTaskModalInstanceController`，以及解析函数。AngularJS
    调用解析函数，该函数定义为一个匿名函数，以便引用封装的 `Task` 对象。
- en: In the callback function for the `modalInstance` object, we conveniently reset
    the `Task` object so that the user is not surprised by stale form data when the
    dialog is raised again. We set the broadcast message in `sharedService`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `modalInstance` 对象的回调函数中，我们方便地重置了 `Task` 对象，这样当对话框再次弹出时，用户不会被过时的表单数据所惊讶。我们在
    `sharedService` 中设置了广播消息。
- en: 'The code to handle the modal instance in the task dialog is almost the same:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 处理任务对话框中模态实例的代码几乎相同：
- en: '[PRE26]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The function `newTaskModalInstanceController` accepts three arguments: the
    `$scope` that binds the modal instance dialog, `$modalInstance` itself, and the
    `Task` object. The last argument, the `Task` object, is resolved and we set it
    as a property on the scope in order to easily render the view in the template.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`newTaskModalInstanceController` 函数接受三个参数：绑定模态实例对话框的 `$scope`，`$modalInstance`
    本身，以及 `Task` 对象。最后一个参数，即 `Task` 对象，被解析，并将其设置为作用域上的一个属性，以便在模板中轻松渲染视图。'
- en: The task modal view template
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务模态视图模板
- en: The AngularJS directive `newTaskContent.html` renders the view for the modal
    dialog that lets the user enter a new task. There are only four properties, so
    this view is shorter than the case record.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 指令 `newTaskContent.html` 渲染允许用户输入新任务的模态对话框视图。由于只有四个属性，因此此视图比案例记录更短。
- en: 'The definition for this view is as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此视图的定义如下：
- en: '[PRE27]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This view also follows the UI Bootstrap CSS style for modal dialogs. We demonstrate
    an HTML `text area` element associated with a data model, which is the `Task`
    object. Each form field has an `ng-model` association. For the target date, we
    reuse the date picker and we illustrate how to use the HTML `checkbox` element.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此视图也遵循UI Bootstrap CSS样式用于模态对话框。我们演示了一个与数据模型关联的HTML `text area`元素，该数据模型是`Task`对象。每个表单字段都有一个`ng-model`关联。对于目标日期，我们重用了日期选择器，并说明了如何使用HTML
    `checkbox`元素。
- en: The code for editing and deleting task records looks roughly the same. However,
    for editing, we don't reset the task record after the user confirms the modal
    dialog, and for deletion, we show only a read-only view of the task record; the
    modal dialog is simply a confirmation.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑和删除任务记录的代码看起来大致相同。然而，对于编辑，用户在确认模态对话框后不会重置任务记录，而对于删除，我们只显示任务记录的只读视图；模态对话框只是一个确认。
- en: Let's see how we handle the change of state.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何处理状态的变化。
- en: State change
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态变化
- en: 'A case record exists in the following states:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 案例记录存在于以下状态：
- en: '| State | Description |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 状态 | 描述 |'
- en: '| --- | --- |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Start | Every new applicant in the system begins at this initial state |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 开始 | 系统中的每位新申请人都是从这一初始状态开始的 |'
- en: '| End | At the end of the process, the applicant''s case finishes in this end
    state |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 结束 | 在流程结束时，申请人的案例将结束在这个最终状态 |'
- en: '| Reviewing | The case worker is reviewing the applicant''s record |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 审查 | 案例工作人员正在审查申请人的记录 |'
- en: '| Decision | The case has been reviewed and the business is taking a decision
    |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 决定 | 案例已经审查完毕，业务正在做出决定 |'
- en: '| Accepted | The case has been accepted and the applicant is being notified
    |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 接受 | 案例已被接受，申请人正在被通知 |'
- en: '| Rejected | The case has been rejected and the applicant is being rejected
    |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 拒绝 | 案例已被拒绝，申请人正在被拒绝 |'
- en: All these business requirements are captured in Finite State Machine.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些业务需求都被捕获在有限状态机中。
- en: Controller code
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器代码
- en: 'By now the code should be familiar to you. The controller method `changeStateCaseRecordDialog()`
    in `NewTaskModalController` is as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，代码应该对您来说已经很熟悉了。`NewTaskModalController`中的控制器方法`changeStateCaseRecordDialog()`如下所示：
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Since we are just editing an existing case record, we copy the properties of
    `CaseRecord` from the enclosing scope into the controller scope. Remember, the
    outside scope is the main module.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只是在编辑现有的案例记录，所以我们把`CaseRecord`的属性从封装作用域复制到控制器作用域。记住，外部作用域是主模块。
- en: Every JSON case record sent by the server (as we will see later) has a property
    called `nextStates`, which is a list of the next possible states that the user
    can move a record to. To take an example, the `Start` state has only one possible
    next state, which is called `Reviewing`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器发送的每个JSON案例记录（我们稍后会看到）都有一个名为`nextStates`的属性，它是一个列表，包含用户可以将记录移动到的下一个可能的状态。以一个例子来说，`开始`状态只有一个可能的后继状态，称为`Reviewing`。
- en: Each case record object has a `currentState` property. We push the current state
    on to the list of subsequent states stored in the current scope. This array `$scope.nextStates`
    allows the dialog HTML directive to render a drop-down menu in the view.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 每个案例记录对象都有一个`currentState`属性。我们将当前状态推送到当前作用域中存储的后继状态列表。这个数组`$scope.nextStates`允许对话框HTML指令在视图中渲染下拉菜单。
- en: You can see that this function, `changeStateCaseRecordDialog()`, opens a UI
    Bootstrap modal dialog.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，这个函数`changeStateCaseRecordDialog()`打开了一个UI Bootstrap模态对话框。
- en: The template view code
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板视图代码
- en: 'So let''s inspect the HTML directive for the state change:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们检查状态变化的HTML指令：
- en: '[PRE29]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding directive, identified as `changeStateCaseRecordContent.html`,
    is essentially a read-only view of the entire case record. The only modifiable
    part is the HTML `select` element that displays the next possible states for the
    case record. In order to generate the HTML `option` element, there is a different
    form of expression for the attribute `ng-options`, which is declared as `state
    for state in caseRecord.nextStates`. This expression implies that the option name
    and the value are the same for the array String, which is as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的指令，标识为`changeStateCaseRecordContent.html`，本质上是对整个案例记录的只读视图。唯一可修改的部分是显示案例记录下一个可能状态的HTML
    `select`元素。为了生成HTML `option`元素，有一个不同的表达式形式用于`ng-options`属性，它声明为`state for state
    in caseRecord.nextStates`。这个表达式意味着数组String的选项名称和值是相同的，如下所示：
- en: '![The template view code](img/image00424.jpeg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![模板视图代码](img/image00424.jpeg)'
- en: Change state for a case record
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 更改案例记录的状态
- en: The modal instance code is essentially the same. The corresponding function
    associated with the dialog is called `moveStateRecordModalInstanceController()`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 模态实例代码基本上是相同的。与对话框相关联的相应函数被称为 `moveStateRecordModalInstanceController()`。
- en: '[PRE30]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Before we finish off this long example of AngularJS and the client side, we
    shall cover a couple of more functions. These functions are part of the module
    that defines `NewCaseRecordModalController`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束这个关于 AngularJS 和客户端的漫长示例之前，我们将介绍几个更多功能。这些功能是定义 `NewCaseRecordModalController`
    模块的组成部分。
- en: Toggling the task display state
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切换任务显示状态
- en: 'The first function `showOrHideTasks()`, toggles the display property `showTasks`
    in the case record. It also invokes an HTTP PUT request with the case record JSON
    data to the server. The code is as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数 `showOrHideTasks()`，切换案件记录中的显示属性 `showTasks`。它还会向服务器发送一个带有案件记录 JSON 数据的
    HTTP PUT 请求。代码如下：
- en: '[PRE31]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The second function `getIconClass()` is a bit of cheat mode. It returns the
    Bootstrap CSS glyph selector depending on the display state. AngularJS does have
    a conditional expression for `ng-class`; however, at the time of writing, the
    author could not get it to work for the array of case record elements. Therefore,
    this function exists in the code base as a work around.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数 `getIconClass()` 是一种作弊模式。它根据显示状态返回 Bootstrap CSS 图标选择器。AngularJS 确实有一个用于
    `ng-class` 的条件表达式；然而，在编写本文时，作者无法使其对案件记录元素数组起作用。因此，这个函数作为代码库中的解决方案存在。
- en: '[PRE32]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you are interested, the correct code for the client-side that should work
    is the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣，客户端应该工作的正确代码如下：
- en: '[PRE33]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We will jump over to the server-side now.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将跳转到服务器端。
- en: Server-side Java
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端 Java
- en: Our Java EE application for the caseworker system is built around RESTful services,
    Java WebSocket, JSON-P, and Java Persistence.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为案件工作者系统构建的 Java EE 应用程序是基于 RESTful 服务、Java WebSocket、JSON-P 和 Java 持久性的。
- en: Tip
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This section of the book relies on a prior understanding of Java EE development
    from the elementary level. I recommend that you read the sister book *Java EE
    7 Development Handbook*, especially if you find some of these topics difficult
    to follow.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 本书本节依赖于对 Java EE 开发从基础水平到高级水平的前期理解。我建议您阅读姊妹书籍 *Java EE 7 开发手册*，特别是如果您发现这些主题难以理解的话。
- en: Entity objects
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体对象
- en: The server-side would be nothing without a couple of domain objects. It should
    not be surprising that these are called `CaseRecord` and `Task`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 没有几个领域对象，服务器端将什么都不是。这些被称为 `CaseRecord` 和 `Task` 的名称并不令人惊讶。
- en: 'The following is the extracted `CaseRecord` entity object with full annotations:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从 `CaseRecord` 实体对象中提取的带有完整注解的代码：
- en: '[PRE34]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'For these entities, we leverage the popular Hibernate Validator annotations
    to ensure that the information is correctly saved into the database. The detailed
    entity `Task` is as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些实体，我们利用流行的 Hibernate Validator 注解来确保信息被正确地保存到数据库中。详细的 `Task` 实体如下：
- en: '[PRE35]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The entities map very closely to the JavaScript objects that we have seen on
    the client side. In practice, a business application in a different domain might
    choose an alternative design such as a facade, aggregation, or projection of the
    data model.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 实体对象映射非常紧密地对应于我们在客户端看到的 JavaScript 对象。在实践中，不同领域的业务应用程序可能会选择替代设计，例如数据模型的门面、聚合或投影。
- en: Of course, these entities have a persistence layer in order to retrieve and
    store information into the database. In the source code, there is a `CaseRecordTaskService`
    that has the responsibility to persist the `CaseRecord` and `Task` records.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些实体都有一个持久层，以便将信息检索和存储到数据库中。在源代码中，有一个 `CaseRecordTaskService` 负责持久化 `CaseRecord`
    和 `Task` 记录。
- en: RESTful communication
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RESTful 通信
- en: 'The stateless session EJB class `CaseWorkerRESTServerEndpoint` serves as our
    RESTful endpoint:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态的会话 EJB 类 `CaseWorkerRESTServerEndpoint` 作为我们的 RESTful 端点：
- en: '[PRE36]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This class is annotated with `@Path` with the initial URI for this endpoint.
    This relative URI `/caseworker/` matches the AngularJS client side. We inject
    the persistent stateful session EJB `CaseRecordTaskService` into this endpoint,
    and we also set up a JSON generator factory that will print the JSON output. We
    use the standard Java EE 7 JSON generator factory throughout.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类用 `@Path` 注解了此端点的初始 URI。这个相对 URI `/caseworker/` 与 AngularJS 客户端匹配。我们将持久状态会话
    EJB `CaseRecordTaskService` 注入到这个端点中，并且我们还设置了一个 JSON 生成器工厂，它将打印 JSON 输出。我们在整个
    Java EE 7 中使用标准的 JSON 生成器工厂。
- en: Retrieval of case records
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 案件记录检索
- en: To handle the retrieval of caseworker records, I shall demonstrate how to handle
    an asynchronous operation with JAX-RS. We need a managed executor from the application
    server and also to ensure that the web application supports the `async` operations
    after deployment.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理案例工作者记录的检索，我将演示如何使用JAX-RS处理异步操作。我们需要从应用程序服务器中获取一个管理的执行器，并确保在部署后Web应用程序支持`async`操作。
- en: 'For Java EE 7, it is crucially important to enable the asynchronous support
    in the Web XML deployment descriptor (`src/main/web-app/WEB/web.xml`). This file
    is as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java EE 7来说，在Web XML部署描述符（`src/main/web-app/WEB/web.xml`）中启用异步支持至关重要。此文件如下：
- en: '[PRE37]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The important XML element is `<async-supported>` and we set its body content
    to true. We also set the URI for receiving the REST queries for the entire application,
    as `/rest`. So taking the class `CaseWorkerRESTServerEndpoint` together, the full
    relative URI, so far, is `/rest/caseworker`. Finally, we declare to the Java EE
    7 application server that our application requires a managed executor with the
    addition of XML elements around `<resource-env-ref>`. This managed executor is
    referred to by the name, `concurrent/LongRunningTasksExecutor` (the JNDI lookup
    name).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的XML元素是`<async-supported>`，我们将其内容设置为true。我们还设置了整个应用程序接收REST查询的URI，即`/rest`。因此，结合`CaseWorkerRESTServerEndpoint`类，完整的相对URI到目前为止是`/rest/caseworker`。最后，我们通过在`<resource-env-ref>`周围添加XML元素向Java
    EE 7应用程序服务器声明我们的应用程序需要一个管理的执行器。这个管理的执行器被称为`concurrent/LongRunningTasksExecutor`（JNDI查找名称）。
- en: 'We shall use it now in the first REST query method:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将在第一个REST查询方法中使用它：
- en: '[PRE38]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We annotate the method `getCaseRecordList()` with `@GET` to handle the HTTP
    GET request from the full relative URI, `/rest/caseworker/list`. This method works
    asynchronously. It relies on the injected `ManagedExecutorService` instance, which
    is a thread pool executor that Java EE 7 manages. In order to participate in the
    service, we supplied a method argument, the `AsyncResponse` object, that is annotated
    with `@Suspended`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`@GET`注解标注`getCaseRecordList()`方法来处理来自完整相对URI `/rest/caseworker/list`的HTTP
    GET请求。此方法异步执行。它依赖于注入的`ManagedExecutorService`实例，这是一个Java EE 7管理的线程池执行器。为了参与服务，我们提供了一个方法参数，即标注了`@Suspended`的`AsyncResponse`对象。
- en: The body of our `getCaseRecordList()` method submits a worker instance (`java.lang.Runnable`)
    to the managed executor service. The worker retrieves a list of case records from
    the persistence service and turns them into a JSON output. The output is converted
    into a String and we ask the `AsyncResponse` instance, through its `resume()`
    method, to start sending data down the output channel to the client. We annotate
    the method `getCaseRecordList()` with the JAX RS `@Produces` to declare the MIME
    type `application.json` of the output content.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`getCaseRecordList()`方法的主体将一个工作实例（`java.lang.Runnable`）提交给管理的执行器服务。该工作实例从持久化服务检索一系列案例记录并将它们转换为JSON输出。输出被转换为字符串，然后我们通过`AsyncResponse`实例的`resume()`方法请求开始通过输出通道向客户端发送数据。我们使用JAX
    RS的`@Produces`注解来标注`getCaseRecordList()`方法，以声明输出内容的MIME类型为`application.json`。
- en: Tip
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Incidentally, there are two `@Produces` annotations in Java EE 7\. One is a
    part of JAX-RS and the other is a CDI.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，Java EE 7中有两个`@Produces`注解。一个是JAX-RS的一部分，另一个是CDI。
- en: 'We also have a REST endpoint for the retrieval of a specific case record by
    its ID. Let''s take a look at how we can achieve this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个通过ID检索特定案例记录的REST端点。让我们看看我们如何实现这一点：
- en: '[PRE39]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The method `retrieveCase()` is annotated with `@GET` for an HTTP GET request.
    It has the relative URI of `/rest/caseworker/item/{id}`. The method searches for
    the case record by ID and creates a JSON representation of it. It sends the output
    to the client synchronously. Just a quick note: we removed the sanity checking
    code in these extracts in order to save space.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`retrieveCase()`方法被标注为`@GET`以处理HTTP GET请求。它具有相对URI `/rest/caseworker/item/{id}`。该方法通过ID搜索案例记录并创建其JSON表示。它同步地将输出发送到客户端。简短说明：为了节省空间，我们在这些摘录中移除了健全性检查代码。'
- en: Creating a case record
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建案例记录
- en: We've covered the retrieval side and now we move onto creational REST endpoints.
    In our system, a web client may create a case record using REST calls. The following
    code inserts a new case record into the application. The relative URI for creating
    a new case record is `/rest/caseworker/item`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了检索方面，现在我们转向创建REST端点。在我们的系统中，Web客户端可以使用REST调用创建案例记录。以下代码将一个新的案例记录插入到应用程序中。创建新案例记录的相对URI是`/rest/caseworker/item`。
- en: '[PRE40]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The method `createCase()` is longer, because it transfers the data inside the
    JSON-P object instance to a `CaseRecord` entity. We annotate the method with `@POST`
    to denote that this endpoint handles HTTP POST requests. This is a long-winded
    boilerplate, which is solved through data-type binding on other non-Java EE 7
    frameworks like GSON ([https://code.google.com/p/google-gson/](https://code.google.com/p/google-gson/))
    or Faster Jackson Processing API for JSON ([http://wiki.fasterxml.com/JacksonInFiveMinutes](http://wiki.fasterxml.com/JacksonInFiveMinutes)),
    but I must demonstrate the standard approach here. We will have to wait until
    the specification body delivers JSON-B (Java JSON Binding API) before we can streamline
    this code.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`createCase()` 方法较长，因为它将 JSON-P 对象实例内部的数据传输到 `CaseRecord` 实体中。我们使用 `@POST`
    注解该方法，表示此端点处理 HTTP POST 请求。这是一段冗长的样板代码，通过在其他非 Java EE 7 框架（如 GSON [https://code.google.com/p/google-gson/](https://code.google.com/p/google-gson/)）或
    Faster Jackson 处理 JSON API ([http://wiki.fasterxml.com/JacksonInFiveMinutes](http://wiki.fasterxml.com/JacksonInFiveMinutes)）上的数据类型绑定来解决。但在这里我必须展示标准方法。我们得等到规范主体交付
    JSON-B（Java JSON 绑定 API）之后，我们才能使这段代码更加精简。'
- en: Updating a case record
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新案例记录
- en: Updating a case record, is very similar to creating a new record, except that
    we first search for a record by its ID and then update the record field by field
    from the JSON input.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 更新案例记录与创建新记录非常相似，不同之处在于我们首先通过其 ID 搜索记录，然后从 JSON 输入逐字段更新记录字段。
- en: 'The method `updateCase()` is as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateCase()` 方法如下：'
- en: '[PRE41]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This RESTful endpoint is annotated with `@PUT` in order to handle an HTTP PUT
    request. This time, the relative URI is `/rest/caseworker/item/{id}` that denotes
    that the client must supply a case record ID. Again, we copy the values from the
    JSON object and overwrite the properties in the `CaseRecord` that was retrieved
    from persistence; then we save the record. We generate a JSON representation of
    the record and set that as a response that JAX-RS will send back to the client.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 RESTful 端点使用 `@PUT` 注解来处理 HTTP PUT 请求。这次，相对 URI 是 `/rest/caseworker/item/{id}`，表示客户端必须提供案例记录
    ID。同样，我们复制 JSON 对象中的值，并覆盖从持久化中检索到的 `CaseRecord` 中的属性；然后我们保存记录。我们生成记录的 JSON 表示，并将其设置为
    JAX-RS 将发送回客户端的响应。
- en: The static instance FMT2 is a `java.text.SimpleDateFormat`, which translates
    between the expiration date and date-of-birth String and the `java.util.Date`
    instances. The pattern format is yyyy-MM-dd. The `BasicStateMachine` instance
    is the implementation of the finite state machine. The `FSM_START` is a singleton
    instance of one of the possible states. Refer to the book's source code in order
    to see how it is implemented.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 静态实例 FMT2 是一个 `java.text.SimpleDateFormat`，它在过期日期和出生日期字符串与 `java.util.Date`
    实例之间进行转换。模式格式是 yyyy-MM-dd。`BasicStateMachine` 实例是有限状态机的实现。`FSM_START` 是可能状态之一的一个单例实例。请参考书籍的源代码，以了解其实现方式。
- en: Creating a task record
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建任务记录
- en: We shall now examine the create, update, and delete endpoints for the task record
    in quick succession. Retrieval has already been settled because every `CaseRecord`
    instance has a collection of zero or more `Task` entities, which fulfilled the
    master detail arrangement.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将迅速检查任务记录的创建、更新和删除端点。检索已经解决，因为每个 `CaseRecord` 实例都有一个零个或多个 `Task` 实体的集合，这满足了主从详细安排。
- en: 'Creating and updating a task record are very similar operations. So let''s
    study the create method first:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和更新任务记录是非常相似的操作。所以让我们首先研究创建方法：
- en: '[PRE42]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We annotate the method `createNewTaskOnCase()` with `@POST`. The relative URI
    is `/rest/caseworker/item/{caseId}/task`. The client submits the parent case record
    and the method uses this ID to retrieve the appropriate `CaseRecord`. It's probably
    a good idea to cross-reference with the AngularJS client side from the new task
    record controller. Inside the `createNewTaskOnCase()`, we removed the sanity checking
    code again in order to concentrate on the substance. The next part of the code
    is mapping JSON to the Java entity. Afterwards, we add the `Task` entity to `CaseRecord`
    and then persist the master record. The method is complete once we write the response.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `@POST` 注解 `createNewTaskOnCase()` 方法。相对 URI 是 `/rest/caseworker/item/{caseId}/task`。客户端提交父案例记录，该方法使用此
    ID 来检索适当的 `CaseRecord`。与从新任务记录控制器引用 AngularJS 客户端端点交叉引用可能是个好主意。在 `createNewTaskOnCase()`
    内部，我们再次移除了健全性检查代码，以便专注于实质内容。代码的下一部分是将 JSON 映射到 Java 实体。之后，我们将 `Task` 实体添加到 `CaseRecord`
    中，然后持久化主记录。一旦我们写入响应，该方法就完成了。
- en: Updating a task record
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新任务记录
- en: 'The method `updateTaskOnCase()` performs an update of the task. We annotate
    this method with `@PUT` and with two RESTful arguments. The relative URI is `/rest/caseworker/item/{caseId}/task/{taskId}`.
    The code for updating a task record is as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateTaskOnCase()`方法执行任务更新。我们用`@PUT`注解这个方法，并使用两个RESTful参数。相对URI是`/rest/caseworker/item/{caseId}/task/{taskId}`。更新任务记录的代码如下：'
- en: '[PRE43]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: With our two coordinates `caseRecordId` and `TaskId`, we locate the appropriate
    `Task` entity and then update the properties from the JSON input. Here, we take
    advantage of the Java 8 Lambdas and Stream API for a functional approach. We save
    the entity and render the JSON response from the current `CaseRecord` entity.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的两个坐标`caseRecordId`和`TaskId`，我们定位适当的`Task`实体，然后从JSON输入中更新属性。在这里，我们利用Java
    8 Lambdas和Stream API进行函数式方法。我们保存实体，并从当前的`CaseRecord`实体渲染JSON响应。
- en: Deleting a task record
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除任务记录
- en: 'Last, but not the least, we provide the client side frontend a means to removing
    the task records from the case records. The code it as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们为客户端前端提供了一种从案例记录中删除任务记录的方法。代码如下：
- en: '[PRE44]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: For an HTTP DELETE request, we annotate the method `deleteTaskFromCase()` with
    `@DELETE`. The relative URI for this method is the strictly RESTful service endpoint
    of `/rest/caseworker/item/{caseId}/task/{taskId}`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 对于HTTP DELETE请求，我们用`@DELETE`注解`deleteTaskFromCase()`方法。这个方法的相对URI是严格RESTful服务端点`/rest/caseworker/item/{caseId}/task/{taskId}`。
- en: In this method, the tricky part is to search for the actual `Task` record. Here,
    Java 8 Lambda and the stream functions make this a very comprehensive and pleasant
    task. With the `Task` entity correctly identified, we remove it from the parent
    `CaseRecord` and then save the master record with persistence. At the end of the
    message, we send a JSON response of `CaseRecord`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，棘手的部分是搜索实际的`Task`记录。在这里，Java 8 Lambda和流函数使这项任务变得非常全面且令人愉快。在正确识别了`Task`实体后，我们从父`CaseRecord`中删除它，然后使用持久性保存主记录。在消息的末尾，我们发送一个`CaseRecord`的JSON响应。
- en: This covers the JAX-RS side of the application; we shall now move on to the
    Java EE WebSocket support.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了应用程序的JAX-RS方面；我们现在将转向Java EE WebSocket支持。
- en: WebSocket communication
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebSocket通信
- en: WebSocket is an HTML protocol extension that allows a client and server to participate
    in full duplex asynchronous communication across a network. It works by an initial
    handshake between two endpoints across backwards-compatible HTTP before switching
    to the faster TCP/IP streams. The WebSocket specification (RFC 6455) is part of
    the conglomerate of the HTML5 technologies driven by **Web Hypertext Application
    Technology Working Group** (**WHATWG**) ([https://whatwg.org](https://whatwg.org))
    and **Internet Engineering Task Force** (**IETF**) ([https://www.ietf.org](https://www.ietf.org)).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket是一种HTML协议扩展，允许客户端和服务器在网络中进行全双工异步通信。它通过在向后兼容的HTTP之前进行两个端点的初始握手来工作，然后切换到更快的TCP/IP流。WebSocket规范（RFC
    6455）是HTML5技术集合的一部分，由**Web Hypertext Application Technology Working Group**（**WHATWG**）([https://whatwg.org](https://whatwg.org))和**Internet
    Engineering Task Force**（**IETF**）([https://www.ietf.org](https://www.ietf.org))推动。
- en: WebSocket support has been available since the Java EE 7 release, and the related
    JSCP specification is JSR 356 ([https://jcp.org/en/jsr/detail?id=356](https://jcp.org/en/jsr/detail?id=356)).
    We can develop JavaEE WebSocket with either annotations or directly against the
    API. It is easier to write with annotations, as we will see.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket支持自Java EE 7版本发布以来就已经可用，相关的JSCP规范是JSR 356 ([https://jcp.org/en/jsr/detail?id=356](https://jcp.org/en/jsr/detail?id=356))。我们可以使用注解或直接针对API来开发JavaEE
    WebSocket。使用注解编写更容易，正如我们将看到的。
- en: AngularJS client side
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AngularJS客户端
- en: 'It is helpful to review again the AngularJS client side around the new task
    record controller and the application main controller. Let''s examine the method
    `updateProjectTaskCompleted()` in the controller `CaseRecordController`. Whenever
    the user decides the task is complete by selecting or deselecting the HTML `checkbox`
    element, we wire up the frontend to send a WebSocket message via the `send()`
    method:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在新任务记录控制器和应用程序主控制器周围再次审查AngularJS客户端是有帮助的。让我们检查`CaseRecordController`中的`updateProjectTaskCompleted()`方法。每当用户通过选择或取消选择HTML
    `checkbox`元素来决定任务是否完成时，我们通过`send()`方法将前端连接起来，发送WebSocket消息：
- en: '[PRE45]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The entire local JavaScript task record is sent over as JSON.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 整个本地的JavaScript任务记录都作为JSON发送。
- en: In order to provide the WebSocket communication generally across to other modules
    on the client side, AngularJS recommends that we define a factory or service.
    A factory is usually initialized only once. A service, on the other hand, adds
    functionality and returns different instances depending on the calling context.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在客户端的其它模块中提供WebSocket通信，AngularJS建议我们定义一个工厂或服务。工厂通常只初始化一次。另一方面，服务添加功能，并返回不同的实例，这取决于调用上下文。
- en: 'The following is the missing factory:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 以下缺失的工厂：
- en: '[PRE46]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The idiom for defining an AngularJS factory resembles the defining of a controller
    or a module, strongly. With the main module `myApp`, we invoke the library `factory()`
    method with two arguments: the name of the factory and the function callback that
    defines the service. The factory has only one dependency on the default logging
    module, `$log`.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 定义AngularJS工厂的惯用语与定义控制器或模块非常相似。在主模块`myApp`中，我们使用两个参数调用库的`factory()`方法：工厂的名称和定义服务的函数回调。工厂只依赖于默认的日志模块`$log`。
- en: 'This `connect()` method initializes an HTML5 WebSocket with the URL by instantiating
    a WebSocket instance. With the handle, we register optional callbacks to deal
    with events: when the WebSocket is opened, closed, receives a message, or there
    is an error. Each callback dumps a message to the web browser''s console log.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`connect()`方法通过实例化WebSocket实例来初始化一个HTML5 WebSocket。通过句柄，我们注册可选的回调来处理事件：当WebSocket打开、关闭、接收消息或发生错误时。每个回调都会将消息输出到Web浏览器的控制台日志。
- en: We define a couple of `send()` methods that send the message body content down
    the WebSocket to the peer. In WebSocket parlance, the remote endpoint is known
    as the peer, because there is no distinction between the client and server endpoints.
    Both sides can start a connection to the other and begin communicating; hence
    the term full duplex.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了几个`send()`方法，这些方法将消息体内容发送到WebSocket的对方。在WebSocket术语中，远程端点被称为对方，因为客户端和服务器端点之间没有区别。双方都可以开始与对方建立连接并开始通信；因此，术语全双工。
- en: Server-side WebSocket endpoints
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器端WebSocket端点
- en: As mentioned earlier, in Java EE 7 we can quickly develop WebSocket endpoints
    using the standard annotations. The Java WebSocket API closely follows the IETF
    specification, and you will recognize the similarities with the many JavaScript
    implementations inside a web browser. There is far too much to the configuration
    and to the different approaches of annotation and programming directly to the
    library that can be reasonably squeezed in this digital Java EE book.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在Java EE 7中，我们可以快速使用标准注解开发WebSocket端点。Java WebSocket API紧密遵循IETF规范，你会在浏览器内的许多JavaScript实现中认识到这些相似之处。配置和不同注解方法以及直接编程到库的方法太多，无法合理地压缩在这本数字Java
    EE书中。
- en: Nevertheless, the essential Java class is actually annotated as a stateless
    session EJB as well as a WebSocket. This should not be surprising, because the
    Java EE specification allows this mixture of annotations in certain cases.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，关键的Java类实际上被注解为无状态会话EJB以及WebSocket。这并不令人惊讶，因为Java EE规范允许在某些情况下混合使用这些注解。
- en: 'The following is the endpoint in `CaseRecordUpdateTaskWebSocketEndpoint`:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在`CaseRecordUpdateTaskWebSocketEndpoint`中的端点：
- en: '[PRE47]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We annotate the bean with `@ServerEndpoint` to denote a server-side endpoint.
    The notion of *server-side* is essentially a Java EE nomenclature to declare an
    intention that this endpoint lives on an application server. There are also such
    things as `@ClientEndpoint` connections.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`@ServerEndpoint`注解bean来表示服务器端端点。*服务器端*的概念基本上是Java EE术语，用于声明这个端点位于应用程序服务器上。还有像`@ClientEndpoint`这样的连接。
- en: Instead of callbacks, Java EE uses annotated methods to handle the opening,
    closing, and failure events around the WebSocket with `@OnOpen`, `@OnClose`, and
    `@OnError` respectively.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是回调，Java EE使用注解方法来处理WebSocket周围的开启、关闭和失败事件，分别使用`@OnOpen`、`@OnClose`和`@OnError`。
- en: To handle the receiving of a message on WebSocket correctly, a POJO or bean
    must only have one method annotated with `@Message`. Behind the scenes, the library
    framework transforms the message into a String for the simplest case as we have
    here. It is possible to send binary and complex data types down and across the
    wire.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确处理WebSocket上的消息接收，POJO或bean必须只有一个方法被注解为`@Message`。在幕后，库框架将消息转换为一个字符串，以处理我们这里的最简单情况。可以发送二进制和复杂的数据类型通过线和网络。
- en: Inside the `updateTaskStatus()` method, we leverage the JSON-P API to parse
    the text into the salient properties of a task. From the input text message, we
    require the case record ID, the task ID and the completion properties of the task.
    We retrieve the matching `CaseRecord` entity from persistence and filter the collection
    of the `Task` objects for the correct item. Once we have it, we set the completed
    property and persist the entire record back to persistence.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `updateTaskStatus()` 方法内部，我们利用 JSON-P API 将文本解析为任务的显著属性。从输入文本消息中，我们需要案例记录
    ID、任务 ID 和任务的完成属性。我们从持久化中检索匹配的 `CaseRecord` 实体，并过滤 `Task` 对象集合以找到正确项。一旦我们找到它，我们就设置完成属性，并将整个记录持久化回持久化存储。
- en: WebSockets are permitted to return a response back to the peer. We send the
    response synchronously, as we do here, with a text message like `OK` or `NOT FOUND`.
    Readers should be aware that it also possible to send responses asynchronously.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: WebSockets 允许向对等方返回一个响应。我们像这里一样同步发送响应，使用像“OK”或“NOT FOUND”这样的文本消息。读者应该知道，也可以异步发送响应。
- en: We have reached the end of the server-side discussion.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了服务器端的最后一点。
- en: Consider your design requirements
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑你的设计需求
- en: AngularJS is a powerful JavaScript MVC framework for the client side. Developers,
    designers, and digital managers are always looking at the next exciting technology.
    People often tend to gauge the impact of a new framework. It is fair to say that
    AngularJS is a game changer because of the ease of the developing components that
    are bound to the model. The effort for not implementing such potential error-prone
    code with jQuery, by default, is huge!
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 是一个强大的客户端 JavaScript MVC 框架。开发者、设计师和数字经理们总是期待着下一个令人兴奋的技术。人们常常倾向于评估新框架的影响。可以公平地说，AngularJS
    是一个变革者，因为它使得与模型绑定的组件开发变得容易。默认情况下，不使用 jQuery 实现这种潜在的错误代码所付出的努力是巨大的！
- en: We know that AngularJS is suited for single-page applications. Does that mean
    that your next enterprise application must be a SPA? Well, the practicing consultant's
    answer is that it always depends on your goals. SPA is suited to limited customer
    journeys and in cases where the experience happens mostly in one place. The caseworker
    application is of this type, because the person is assessing the passport applicants
    on a case-by-case basis, and therefore, they stay in and work on one web page
    most of the time during their working day.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 AngularJS 适合单页应用。这意味着你的下一个企业应用必须是一个 SPA 吗？嗯，实践顾问的回答是，这总是取决于你的目标。SPA 适合有限的客户旅程，以及在体验主要发生在同一个地方的情况下。案例工作人员应用就是这种类型，因为工作人员是逐个评估护照申请人的，因此，他们在工作日的大部分时间都待在一个网页上工作。
- en: The caseworker application demonstrates a master-detail relationship. Your next
    enterprise application may probably require the involvement of a more complicated
    set of use stories. Your domain might require an extensive set of entities. A
    single SPA might not cover all the areas. For one thing, you will need many more
    JavaScript modules, controllers and factories, and HTML directives to fully surround
    the bounded context of the system.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 案例工作人员应用演示了主从关系。你的下一个企业应用可能需要更复杂的一组用例。你的领域可能需要广泛的实体集。一个单独的 SPA 可能无法涵盖所有领域。首先，你需要更多的
    JavaScript 模块、控制器和工厂，以及 HTML 指令，以完全包围系统的边界上下文。
- en: So what to do with these complicated requirements? One approach is to bundle
    all of the JavaScript logic on the client script into one download. Tools for
    this such as GruntJS, which we briefly covered in the last chapter, can then merge,
    compress, and optimize files. We can take advantage of the Java EE strengths with
    more than one web page and navigation.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 那对于这些复杂的需求我们该怎么办呢？一种方法是将所有 JavaScript 逻辑打包到客户端脚本中，然后下载。例如，GruntJS 这样的工具，我们在上一章中简要介绍过，可以将文件合并、压缩和优化。我们可以利用
    Java EE 的优势，在多个网页和导航中。
- en: Array collection of single-page applications
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单页应用数组集合
- en: We can structure an SPA into a linear sequence so that the customer journey
    of the system almost follows a workflow. There are domains such as warehouse order
    management, engineering, and financial trading where such an approach might make
    sense. In such domains, the business user works in a series of complex steps in
    order to process bulk units of work from A to B. The advantages of an array of
    SPAs are won if they have a short linear sequence consisting of, perhaps, three
    or four steps, but will be lost if the length of the chain is greater than or
    equal to seven.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将SPA结构化为线性序列，以便系统的客户旅程几乎遵循工作流程。在仓库订单管理、工程和金融交易等领域，这种做法可能是有意义的。在这些领域，业务用户通过一系列复杂的步骤来处理从A到B的大量工作单元。如果SPA数组具有短线性序列，可能包括三到四个步骤，那么它们的优势就会被获得，但如果链的长度大于或等于七个，这些优势就会丧失。
- en: Hierarchical collection of single-page applications
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单页应用程序的分层集合
- en: The other approach is to descend fully from a linear sequence into the hierarchical
    tree structure of SPA. This approach is extremely specialized, and it is advisable
    to seek some architectural assurance that this path is sustainable for your business.
    Why would a business want to organize SPA in this fashion? Your stakeholder may
    want to sustain the organizational function in a way that mirrors the domain exactly.
    The design approach is a risky procedure because it introduces inflexibility in
    the overall model, and in my humble opinion, appears to be authority power led
    by the management rather than being organic. If the hierarchy tree is organized
    in a length by breadth manner rather than length by depth, ask yourself why?
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是完全从线性序列下降到SPA的分层树结构。这种方法非常专业，建议在寻求一些架构保证以确认这条路径对您的业务是可持续的。为什么企业会希望以这种方式组织SPA？您的利益相关者可能希望以与领域完全一致的方式维持组织功能。设计方法是一种风险程序，因为它在整体模型中引入了僵化性，在我看来，这似乎是由管理层领导的权威权力，而不是有机的。如果层次树是按长度和宽度而不是按长度和深度组织的话，问问自己为什么？
- en: In these times, where engineers and architects are looking at micro-services
    in order to scale and have a single business function in an elegant box, an HSPA
    might indeed be useful. The tree structure size should be around 10 nodes.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些工程师和建筑师都在寻找微服务以实现扩展并优雅地将单一业务功能封装在单个盒子中的时代，HSPA可能确实很有用。树结构的大小应该大约有10个节点。
- en: Summary
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this long chapter, we covered client-side AngularJS development with a caseworker
    application. We learned how the AngularJS framework manipulates the DOM and how
    it provides the binding between the data and the rendering of the elements using
    the MVC. We also learned some AngularJS concepts like scopes, modules, controllers,
    and factories.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一长章节中，我们介绍了使用案例工作者应用程序进行客户端AngularJS开发。我们学习了AngularJS框架如何操作DOM，以及它是如何通过MVC提供数据与元素渲染之间的绑定。我们还学习了AngularJS的一些概念，如作用域、模块、控制器和工厂。
- en: Using the study example, we illustrated how AngularJS communicates to a remote
    server using RESTful service invocations from the client side. We also studied
    the WebSocket interaction briefly. On the client side of JavaScript, we went through
    the entire CRUD idiom in the caseworker application.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 通过研究示例，我们说明了AngularJS如何从客户端使用RESTful服务调用与远程服务器进行通信。我们还简要研究了WebSocket交互。在JavaScript客户端方面，我们在案例工作者应用程序中走过了整个CRUD习语。
- en: On the server side, we saw the implementation of the RESTful services with JAX-RS,
    which covered the four standard HTTP method requests. We also learnt about the
    Java WebSocket implementation.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，我们看到了使用JAX-RS实现的RESTful服务的实现，它涵盖了四个标准的HTTP方法请求。我们还学习了Java WebSocket的实现。
- en: AngularJS fits the mode of applications that single page applications need.
    However, this may or may not be appropriate to your business requirements. Adopting
    AngularJS requires full stack knowledge of both JavaScript programming and Java
    EE development. Moving to a framework like AngularJS exposes your business to
    the risk of hiring, retaining, and learning more technologies.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS适合需要单页应用程序模式的应用。然而，这可能或可能不适合您的业务需求。采用AngularJS需要具备JavaScript编程和Java
    EE开发的全面知识。转向像AngularJS这样的框架会使您的业务面临招聘、保留和学习更多技术的风险。
- en: 'There is also another side of the triangle to consider: organizational dynamics.
    Apple Inc., USA famously divided their then agile teams that worked on the online
    shopping store into a pure server and client division. The only communication
    allowed between them was an agreed upon programming interface. This division happened
    when the iPhone was being developed (circa 2005-2007), which obviously predates
    AngularJS. Your team might operate differently, but the concept of design-by-contract
    is still relevant, because it showed what can be achieved, especially in terms
    of RESTful services.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个三角形的另一面需要考虑：组织动态。苹果公司（美国）著名地将当时负责在线购物商店的敏捷团队分为纯服务器和客户端部门。他们之间唯一允许的通信是一个商定的编程接口。这种划分发生在
    iPhone 开发期间（大约 2005-2007 年），显然早于 AngularJS。你的团队可能有所不同，但设计合同的概念仍然相关，因为它展示了可以实现什么，特别是在
    RESTful 服务方面。
- en: 'I will leave you with a second quote from Misko Hevery, co-creator of AngularJS.
    He said:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我将留给你们来自 AngularJS 共同创造者 Misko Hevery 的第二句引言。他说：
- en: '*"Limited – You can''t really show more than 2000 pieces of information to
    a human on a single page. Anything more than that is really bad UI, and humans
    can''t process this anyway."*'
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"有限 – 你实际上无法在单页面上向人类展示超过 2000 件信息。超过这个数量真的很糟糕的用户界面，而且人类无论如何都无法处理这些信息。"*'
- en: Exercises
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Download the source code for the xen-national-force caseworker application and
    study the implementation for a few hours. What do you notice? Compile the code
    and deploy the resultant WAR to your application server of choice.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载 xen-national-force 案件工作人员应用程序的源代码，并研究实现方法几个小时。你注意到了什么？编译代码并将生成的 WAR 部署到您选择的应用程序服务器上。
- en: With the material from this chapter, create your CRUD AngularJS application
    with just one simple entity, `EMPLOYEE`. This entity should have an employee ID,
    name, and social security number. Build the client side with AngularJS and the
    server side with JAX-RS. (In the book's source code, there is a blank project
    that will help you get started.)
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用本章的材料，创建一个只有一个简单实体 `EMPLOYEE` 的 CRUD AngularJS 应用程序。这个实体应该有一个员工 ID、姓名和社会安全号码。客户端使用
    AngularJS 构建，服务器端使用 JAX-RS 构建。（在本书的源代码中，有一个空白项目可以帮助你开始。）
- en: 'While building the EMPLOYEE CRUD from the previous question in AngularJS and
    JavaEE, did you use the modal dialog from UI Bootstrap? If not, investigate other
    means of rendering the view to insert, update, and delete records. (Hint: One
    possible way is dynamically showing and hiding different `DIV` elements.)'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在从上一个问题构建 AngularJS 和 JavaEE 中的 EMPLOYEE CRUD 时，你是否使用了 UI Bootstrap 的模态对话框？如果没有，调查其他渲染视图以插入、更新和删除记录的方法。（提示：一种可能的方式是动态显示和隐藏不同的
    `DIV` 元素。）
- en: There is an obvious design flaw with the caseworker application. Did you find
    it? When the caseworker shows and hides a task view, it updates the persistence
    database; explain why is this a problem?
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 案件工作人员应用程序存在一个明显的设计缺陷。你是否发现了？当案件工作人员显示或隐藏任务视图时，它会更新持久化数据库；解释为什么这是一个问题？
- en: Imagine that from today, you have become the project lead for the entire xen-national-force
    team, and suddenly, the business decides that they want instant notifications
    to be broadcast to other caseworkers once a state has been changed. Explain at
    a technical level how this user story might be achieved. Think about the challenges
    on the AngularJS client side. How might you build the Java EE server side?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 想象一下，从今天起，你已经成为整个 xen-national-force 团队的项目负责人，并且业务突然决定他们想要在状态改变后立即向其他案件工作人员广播通知。在技术层面上解释这个用户故事可能如何实现。考虑
    AngularJS 客户端的挑战。你将如何构建 Java EE 服务器端？
- en: Study the factory module (`iso-countries.js`) in xen-national-force that is
    responsible for the maintaining a collection of the ISO passport country names
    and their codes. How is this module used in the frontend? Where does it get used?
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 研究一下 xen-national-force 中的工厂模块 (`iso-countries.js`)，它负责维护 ISO 护照国家名称及其代码的集合。这个模块在前端是如何使用的？它在哪些地方被使用？
- en: Instead of using a dedicated Boolean property in the `CaseRecord` JPA entity
    to denote if the task view is shown or not, write an AngularJS factory module
    that stores this information for all the case records locally on the client side.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要在 `CaseRecord` JPA 实体中使用专门的布尔属性来表示任务视图是否显示，而是编写一个 AngularJS 工厂模块，该模块在客户端本地存储所有案件记录的信息。
- en: The sample caseworker application retrieves every record in the database and
    returns it to the user. Suppose the real system had 1,000 case records. What could
    be an issue with this functionality? How would you solve it? If the caseworker
    is not able to see all the records, explain how do you ensure that they get to
    see relevant cases? What do you need to implement on both the AngularJS client
    and the Java EE server side?
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 样本案件工作者应用程序检索数据库中的所有记录并将其返回给用户。假设真实系统有1,000个案件记录。这个功能可能存在什么问题？你会如何解决这个问题？如果案件工作者无法看到所有记录，请解释你将如何确保他们能看到相关案件？你需要在AngularJS客户端和Java
    EE服务器端实现哪些功能？
