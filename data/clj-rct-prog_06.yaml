- en: Chapter 6. Building a Simple ClojureScript Game with Reagi
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章：使用Reagi构建简单的ClojureScript游戏
- en: In the previous chapter, we learned how a framework for **Compositional Event
    Systems** (**CES**) works by building our own framework, which we called *respondent*.
    It gave us a great insight into the main abstractions involved in such a piece
    of software as well as a good overview of `core.async`, Clojure's library for
    asynchronous programming and the foundation of our framework.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们通过构建自己的框架，将其命名为 *respondent*，学习了**组合事件系统**（**CES**）的工作原理。这使我们深刻理解了此类软件中涉及的主要抽象，并对
    `core.async`、Clojure 的异步编程库以及我们框架的基础有了良好的概述。
- en: Respondent is but a toy framework, however. We paid little attention to cross-cutting
    concerns such as memory efficiency and exception handling. That is okay as we
    used it as a vehicle for learning more about handling and composing event systems
    with `core.async`. Additionally, its design is intentionally similar to Reagi's
    design.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Respondent只是一个玩具框架。我们没有过多关注诸如内存效率和异常处理等横切关注点。这没关系，因为我们使用它作为学习如何使用 `core.async`
    处理和组合事件系统的工具。此外，其设计有意与Reagi的设计相似。
- en: 'In this chapter, we will:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Learn about Reagi, a CES framework built on top of `core.async`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Reagi，这是一个建立在 `core.async` 之上的CES框架
- en: Use Reagi to build the rudiments of a ClojureScript game that will teach us
    how to handle user input in a clean and maintainable way
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Reagi构建ClojureScript游戏的基础，这将教会我们如何以干净和可维护的方式处理用户输入
- en: Briefly compare Reagi to other CES frameworks and get a feel for when to use
    each one
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简要比较Reagi与其他CES框架，并了解何时使用每个框架
- en: Setting up the project
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目
- en: Have you ever played Asteroids? If you haven't, Asteroids is an arcade space
    shooter first released by Atari in 1979\. In Asteroids, you are the pilot of a
    ship flying through space. As you do so, you get surrounded by asteroids and flying
    saucers you have to shoot and destroy.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你玩过Asteroids吗？如果你没有，Asteroids是一款1979年由Atari首次发布的街机太空射击游戏。在Asteroids中，你是飞船的飞行员，在太空中飞行。在这个过程中，你会被围绕的陨石和外星飞碟所包围，你必须射击并摧毁它们。
- en: 'Developing the whole game in one chapter is too ambitious and would distract
    us from the subject of this book. We will limit ourselves to making sure we have
    a ship on the screen we can fly around as well as shoot space bullets into the
    void. By the end of this chapter, we will have something that looks like what
    is shown in the following screenshot:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在一章中开发整个游戏过于雄心勃勃，会分散我们对本书主题的注意力。我们将限制自己确保屏幕上有一个我们可以飞行的飞船，并且可以向虚空射击太空子弹。到本章结束时，我们将拥有以下截图所示的内容：
- en: '![Setting up the project](img/00017.jpeg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![设置项目](img/00017.jpeg)'
- en: 'To get started, we will create a `newClojureScript` project using the same
    leiningen template we used in the previous chapter, `cljs-start` (see [https://github.com/magomimmo/cljs-start](https://github.com/magomimmo/cljs-start)):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们将使用与上一章相同的leiningen模板 `cljs-start`（见[https://github.com/magomimmo/cljs-start](https://github.com/magomimmo/cljs-start)）创建一个
    `newClojureScript` 项目：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, add the following dependencies to your project file:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将以下依赖项添加到你的项目文件中：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The last dependency, monet (see [https://github.com/rm-hull/monet](https://github.com/rm-hull/monet)),
    is a ClojureScript library you can use to work with HTML 5 Canvas. It is a high-level
    wrapper on top of the Canvas API and makes interacting with it a lot simpler.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个依赖项是monet（见[https://github.com/rm-hull/monet](https://github.com/rm-hull/monet)），这是一个ClojureScript库，你可以用它来处理HTML
    5 Canvas。它是Canvas API的高级包装器，使得与之交互变得更加简单。
- en: 'Before we continue, it''s probably a good idea to make sure our setup is working
    properly. Change into the project directory, start a Clojure REPL, and then start
    the embedded web server:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，确保我们的设置正常工作可能是个好主意。切换到项目目录，启动Clojure REPL，然后启动嵌入式Web服务器：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will compile the ClojureScript source files to JavaScript and start the
    sample web server. In your browser, navigate to `http://localhost:3000/`. If you
    see something like the following, we are good to go:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这将编译ClojureScript源文件到JavaScript并启动示例Web服务器。在你的浏览器中，导航到 `http://localhost:3000/`。如果你看到以下内容，我们就准备好了：
- en: '![Setting up the project](img/00018.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![设置项目](img/00018.jpeg)'
- en: 'As we will be working with HTML 5 Canvas, we need an actual canvas to render
    to. Let''s update our HTML document to include that. It''s located under `dev-resources/public/index.html`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用HTML 5 Canvas，我们需要一个实际的画布来渲染。让我们更新我们的HTML文档以包含它。它位于 `dev-resources/public/index.html`
    下：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have added a `canvas` DOM element to our document. All rendering will happen
    in this context.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的文档中添加了一个`canvas`DOM元素。所有渲染都将在这个上下文中发生。
- en: Game entities
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏实体
- en: 'Our game will have only two entities: one representing the spaceship and the
    other representing bullets. To better organize the code, we will put all entity-related
    code in its own file, `src/cljs/reagi_game/entities.cljs`. This file will also
    contain some of the rendering logic, so we''ll need to require `monet`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏将只有两个实体：一个代表飞船，另一个代表子弹。为了更好地组织代码，我们将所有与实体相关的代码放在自己的文件中，即`src/cljs/reagi_game/entities.cljs`。此文件还将包含一些渲染逻辑，因此我们需要引入`monet`：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we''ll add a few helper functions to avoid repeating ourselves too much:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一些辅助函数以避免过多重复：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first three functions are simply a shorter way of getting data out of our
    shape data structure. The `shape-data` function creates a structure. Note that
    we are using `atoms`, one of Clojure's reference types, to represent a shape's
    position and angle.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个函数只是从我们的形状数据结构中获取数据的一种更简短的方式。`shape-data`函数创建一个结构。请注意，我们正在使用Clojure的引用类型之一`atoms`来表示形状的位置和角度。
- en: This way, we can safely pass our shape data into monet's rendering functions
    and still be able to update it in a consistent way.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就可以安全地将我们的形状数据传递给monet的渲染函数，并且仍然能够以一致的方式更新它。
- en: 'Next up is our ship constructor function. This is where the bulk of the interaction
    with monet happens:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们的飞船构造函数。这是与monet交互最频繁的地方：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There is quite a bit going on, so let's break it down.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了很多事情，所以让我们分解一下。
- en: '`canvas/entity` is a monet constructor and expects you to provide three arguments
    that describe our ship: its initial x, y coordinates and angle, an update function
    that gets called in the draw loop, and a draw function that is responsible for
    actually drawing the shape onto the screen after each update.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`canvas/entity`是一个monet构造函数，并期望你提供三个描述我们的飞船的参数：其初始x、y坐标和角度，一个在绘制循环中被调用的更新函数，以及一个负责在每次更新后将形状绘制到屏幕上的绘制函数。'
- en: 'The update function is fairly straightforward:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 更新函数相当直接：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We simply update its attributes to the current values from the ship's atoms.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是将其属性更新为飞船的原子中的当前值。
- en: 'The next function, responsible for drawing, interacts with monet''s API more
    heavily:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数，负责绘制，与monet的API交互更为频繁：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We start by saving the current context so that we can restore things such as
    drawing style and canvas positioning later. Next, we translate the canvas to the
    ship's x,y coordinates and rotate it according to its angle. We then start drawing
    our shape, a triangle, and finish by restoring our saved context.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先保存当前上下文，以便稍后可以恢复诸如绘图样式和画布定位之类的设置。接下来，我们将画布平移到飞船的x、y坐标，并根据其角度旋转。然后我们开始绘制我们的形状，一个三角形，最后通过恢复我们保存的上下文来完成。
- en: 'The next function also creates an entity, our bullet:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数也创建了一个实体，我们的子弹：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As before, let''s inspect the `update` and `drawing` functions. We''ll start
    with `update`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，让我们检查`update`和`drawing`函数。我们首先从`update`开始：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Bullets have a little more logic in their update function. As you fire them
    from the ship, we might create hundreds of these entities, so it''s a good practice
    to get rid of them as soon as they go off the visible canvas area. That''s the
    first thing the function does: it uses `geom/contained?` to check whether the
    entity is within the dimensions of the canvas, removing it when it isn''t.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 子弹在其更新函数中包含更多的逻辑。当你从飞船发射它们时，我们可能会创建数百个这样的实体，因此，一旦它们离开可见画布区域，立即将它们销毁是一个好习惯。这是函数做的第一件事：它使用`geom/contained?`来检查实体是否在画布的尺寸内，不在时将其移除。
- en: Different from the ship, however, bullets don't need user input in order to
    move. Once fired, they move on their own. That's why the next thing we do is call
    `move-forward!` We haven't implemented this function yet, so we had to declare
    it beforehand. We'll get to it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与飞船不同的是，子弹不需要用户输入来移动。一旦发射，它们就会自行移动。这就是为什么我们接下来要做的是调用`move-forward!`。我们还没有实现这个函数，所以我们必须提前声明它。我们将稍后处理它。
- en: Once the bullet's coordinates and angle have been updated, we simply return
    the new entity.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦子弹的坐标和角度被更新，我们就简单地返回新的实体。
- en: 'The draw function is a bit simpler than the ship''s version mostly due to its
    shape being simpler; it''s just a red circle:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制函数比飞船版本简单一些，主要是因为其形状更简单；它只是一个红色的圆圈：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we''ll move on to the functions responsible for updating our shape''s
    coordinates and angle, starting with `move!`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将继续编写负责更新我们的形状坐标和角度的函数，从 `move!` 开始：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To keep things simple, both the ship and bullets use the same speed value to
    calculate their positioning, here defined as `200`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，船和子弹都使用相同的速度值来计算它们的位置，这里定义为 `200`。
- en: '`move!` takes two arguments: the shape map and a function `f`. This function
    will either be the `+` (plus) or the `-` (minus) function, depending on whether
    we''re moving forward or backward, respectively. Next, it updates the shape''s
    x,y coordinates using some basic trigonometry.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`move!` 接受两个参数：形状映射和一个函数 `f`。这个函数将是 `+`（加）或 `-`（减）函数，具体取决于我们是向前还是向后移动。接下来，它使用一些基本的三角学来更新形状的
    x,y 坐标。'
- en: 'If you''re wondering why we are passing the plus and minus functions as arguments,
    it''s all about not repeating ourselves, as the next two functions show:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道为什么我们传递加法和减法函数作为参数，这完全是为了避免重复，如以下两个函数所示：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With movement taken care of, the next step is to write the rotation functions:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理了移动之后，下一步是编写旋转函数：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'So far, we''ve got ship movement covered! But what good is our ship if we can''t
    fire bullets? Let''s make sure we have that covered as well:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了船的移动！但如果我们不能发射子弹，我们的船又有什么用呢？让我们确保我们也覆盖了这一点：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `fire!` function takes two arguments: a reference to the game canvas and
    the ship. It then creates a new bullet by calling `make-bullet-entity` and adds
    it to the canvas.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`fire!` 函数接受两个参数：游戏画布的引用和船。然后它通过调用 `make-bullet-entity` 创建一个新的子弹并将其添加到画布上。'
- en: Note how we use Clojure's `gensym` function to create a unique key for the new
    entity. We use this key to remove an entity from the game.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何使用 Clojure 的 `gensym` 函数为新的实体创建一个唯一的键。我们使用这个键从游戏中删除一个实体。
- en: This concludes the code for the `entities` namespace.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了 `entities` 命名空间的代码。
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '`gensym` is quite heavily used in writing hygienic macros as you can be sure
    that the generated symbols will not clash with any local bindings belonging to
    the code using the macro. Macros are beyond the scope of this book, but you might
    find this series of macro exercises useful in the learning process, at [https://github.com/leonardoborges/clojure-macros-workshop](https://github.com/leonardoborges/clojure-macros-workshop).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写卫生宏时，`gensym` 被广泛使用，因为你可以确信生成的符号不会与使用宏的代码的任何局部绑定冲突。宏超出了本书的范围，但你可能会在以下宏练习系列中找到有用的学习过程，请访问
    [https://github.com/leonardoborges/clojure-macros-workshop](https://github.com/leonardoborges/clojure-macros-workshop)。
- en: Putting it all together
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整合所有内容
- en: 'We''re now ready to assemble our game. Go ahead and open the core namespace
    file, `src/cljs/reagi_game/core.cljs`, and add the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好组装我们的游戏了。请打开核心命名空间文件 `src/cljs/reagi_game/core.cljs`，并添加以下内容：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We start by creating `monet-canvas` from a reference to our `canvas` DOM element.
    We then create our ship data, placing it at the center of the canvas, and add
    the entity to `monet-canvas`. Finally, we start a draw-loop, which will handle
    our animations using the browser's native capabilities—internally it calls `window.requestAnimationFrame()`,
    if available, but it falls back to `window.setTimemout()` otherwise.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从我们的 `canvas` DOM 元素的引用创建 `monet-canvas`。然后我们创建我们的船数据，将其放置在画布的中心，并将实体添加到
    `monet-canvas`。最后，我们启动一个绘制循环，它将使用浏览器的本地功能来处理我们的动画——内部它调用 `window.requestAnimationFrame()`，如果可用，否则回退到
    `window.setTimemout()`。
- en: If you were to try the application now, this would be enough to draw the ship
    on the middle of the screen, but nothing else would happen as we haven't started
    handling user input yet.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在尝试应用程序，这将足以在屏幕中间绘制船，但除了我们没有开始处理用户输入之外，不会发生任何事情。
- en: 'As far as user input goes, we''re concerned with a few actions:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 就用户输入而言，我们关注以下几个动作：
- en: 'Ship movement: rotation, forward, and backward'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 船的移动：旋转、前进和后退
- en: Firing the ship's gun
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发射船的炮
- en: Pausing the game
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停游戏
- en: 'To account for these actions, we''ll define some constants that represent the
    ASCII codes of the keys involved:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这些动作，我们将定义一些代表相关键的 ASCII 码的常量：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This should look sensible as we are using the keys traditionally used for these
    types of actions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该看起来是有意义的，因为我们使用的是传统上用于这些动作的键。
- en: Modeling user input as event streams
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将用户输入建模为事件流
- en: 'One of the things discussed in the earlier chapters is that if you can think
    of events as a list of things that haven''t happened yet; you can probably model
    it as an event stream. In our case, this list is composed by the keys the player
    presses during the game and can be visualized like so:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中讨论的一个问题是，如果你可以将事件视为尚未发生的一系列事物，那么你很可能可以将它建模为事件流。在我们的情况下，这个列表由玩家在游戏中按下的键组成，可以像这样可视化：
- en: '![Modeling user input as event streams](img/00019.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![将用户输入建模为事件流](img/00019.jpeg)'
- en: There is a catch though. Most games need to handle simultaneously pressed keys.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有一个问题。大多数游戏需要同时处理按下的键。
- en: Say you're flying the spaceship forwards. You don't want to have to stop it
    in order to rotate it to the left and then continue moving forwards. What you
    want is to press left at the same time you're pressing up and have the ship respond
    accordingly.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在向前飞行太空船。你不想停下来旋转它向左，然后再继续向前移动。你想要的是在按下向上键的同时按下左键，让飞船相应地做出反应。
- en: 'This hints at the fact that we need to be able to tell whether the player is
    currently pressing multiple keys. Traditionally this is done in JavaScript by
    keeping track of which keys are being held down in a map-like object, using flags.
    Something similar to the following snippet:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这暗示我们需要能够判断玩家是否正在同时按下多个键。传统上，在JavaScript中通过跟踪在类似映射的对象中按下的键来做到这一点，使用标志。类似于以下片段：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, later in the game loop, you would check whether there are multiple keys
    being pressed:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在游戏循环的稍后阶段，你会检查是否有多个键被按下：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: While this code works, it relies on mutating the `keysPressed` object which
    isn't ideal.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码可以工作，但它依赖于修改`keysPressed`对象，这不是理想的做法。
- en: Additionally, with a setup similar to the preceding one, the `keysPressed` object
    is global to the application as it is needed both in the `keyup`/`keydown` event
    handlers as well as in the game loop itself.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，与前面的设置类似，`keysPressed`对象对应用程序是全局的，因为它既需要在`keyup`/`keydown`事件处理程序中，也需要在游戏循环本身中。
- en: In functional programming, we strive to eliminate or reduce the amount of global
    mutable state in order to write readable, maintainable code that is less error-prone.
    We will apply these principles here.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，我们努力消除或减少全局可变状态的数量，以编写可读性、可维护性高且错误率低的代码。我们将在这里应用这些原则。
- en: 'As seen in the preceding JavaScript example, we can register callbacks to be
    notified whenever a `keyup` or `keydown` event happens. This is useful as we can
    easily turn them into event streams:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述JavaScript示例所示，我们可以注册回调，以便在`keyup`或`keydown`事件发生时得到通知。这很有用，因为我们可以轻松地将它们转换为事件流：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Both `keydown-stream` and `keyup-stream` return a new stream to which they deliver
    events whenever they happen. Each event is tagged with a keyword, so we can easily
    identify its type.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`keydown-stream`和`keyup-stream`都返回一个新的流，它们在事件发生时将事件传递到该流。每个事件都带有关键字标记，这样我们就可以轻松地识别其类型。'
- en: We would like to handle both types of events simultaneously and as such we need
    a way to combine these two streams into a single one.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望同时处理这两种类型的事件，因此我们需要一种方法将这两个流合并为一个单一的流。
- en: 'There are many ways in which we can combine streams, for example, using operators
    such as `zip` and `flatmap`. For this instance, however, we are interested in
    the `merge` operator. `merge` creates a new stream that emits values from both
    streams as they arrive:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过多种方式组合流，例如使用`zip`和`flatmap`等操作符。然而，在这个例子中，我们对`merge`操作符感兴趣。`merge`创建一个新的流，它会随着流的到达从两个流中发出值：
- en: '![Modeling user input as event streams](img/00020.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![将用户输入建模为事件流](img/00020.jpeg)'
- en: 'This gives us enough to start creating our stream of active keys. Based on
    what we have discussed so far, our stream looks something like the following at
    the moment:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了足够的资源来开始创建我们的活动键流。根据我们迄今为止所讨论的内容，我们的流目前看起来如下所示：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To keep track of which keys are currently pressed, we will use a ClojureScript
    set. This way we don't have to worry about setting flags to true or false—we can
    simply perform standard set operations and add/remove keys from the data structure.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪当前按下的键，我们将使用ClojureScript集合。这样我们就不必担心设置标志为真或假——我们可以简单地执行标准的集合操作，并从数据结构中添加/删除键。
- en: The next thing we need is a way to accumulate the pressed keys into this set
    as new events are emitted from the merged stream.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一种方法，将按下的键累积到这个集合中，因为合并流会发出新的事件。
- en: In functional programming, whenever we wish to accumulate or aggregate some
    type of data over a sequence of values, we use `reduce`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，每当我们要在一系列值上累积或聚合某种类型的数据时，我们使用`reduce`。
- en: Most—if not all—CES frameworks have this function built-in. RxJava calls it
    `scan`. Reagi, on the other hand, calls it `reduce`, making it intuitive to functional
    programmers in general.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数——如果不是所有——CES框架都有这个内置函数。RxJava称之为`scan`。另一方面，Reagi称之为`reduce`，这使得它对一般函数式程序员来说很直观。
- en: 'That is the function we will use to finish the implementation of `active-keys-stream`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 那是我们将用来完成`active-keys-stream`实现的函数：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`r/reduce` takes three arguments: a reducing function, an optional initial/seed
    value, and the stream to reduce over.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`r/reduce`接受三个参数：一个减少函数、一个可选的初始/种子值，以及要减少的流。'
- en: Our seed value is an empty set as initially the user hasn't yet pressed any
    keys. Then, our reducing function checks the event type, removing or adding the
    key from/to the set as appropriate.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的种子值是一个空集，因为最初用户还没有按下任何键。然后，我们的减少函数检查事件类型，根据需要从集合中删除或添加键。
- en: 'As a result, what we have is a stream like the one represented as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到的是一个类似于以下表示的流：
- en: '![Modeling user input as event streams](img/00021.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![将用户输入建模为事件流](img/00021.jpeg)'
- en: Working with the active keys stream
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理活动键流
- en: The ground work we've done so far will make sure we can easily handle game events
    in a clean and maintainable way. The main idea behind having a stream representing
    the game keys is that now we can partition it much like we would a normal list.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止所做的基础工作将确保我们可以轻松地以干净和可维护的方式处理游戏事件。拥有表示游戏键的流背后的主要思想是，现在我们可以像处理正常列表一样对其进行分区。
- en: 'For instance, if we''re interested in all events where the key pressed is `UP`,
    we would run the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们对所有按键为`UP`的事件感兴趣，我们会运行以下代码：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Similarly, for events involving the `FIRE` key, we could do the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对于涉及`FIRE`键的事件，我们可以做以下操作：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This works because in Clojure, sets can be used as predicates. We can quickly
    verify this at the REPL:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为在Clojure中，集合可以用作谓词。我们可以在REPL中快速验证这一点：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: By representing the events as a stream, we can easily operate on them using
    familiar sequence functions such as `map` and `filter`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将事件表示为流，我们可以轻松地使用熟悉的序列函数，如`map`和`filter`，来操作它们。
- en: 'Writing code like this, however, is a little repetitive. The two previous examples
    are pretty much saying something along these lines: filter all events matching
    a given predicate `pred` and then map the `f` function over them. We can abstract
    this pattern in a function we''ll call `filter-map`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，编写这样的代码有点重复。前两个例子基本上是在说类似的话：过滤所有匹配给定谓词`pred`的事件，然后对它们应用`f`函数。我们可以在一个我们称之为`filter-map`的函数中抽象这个模式：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With this helper function in place, it becomes easy to handle our game actions:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了这个辅助函数之后，处理我们的游戏动作变得容易：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The only thing missing now is taking care of pausing the animations when the
    player presses the `PAUSE` key. We follow the same logic as above, but with a
    slight change:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在唯一缺少的是在玩家按下`PAUSE`键时暂停动画。我们遵循与上面相同的逻辑，但略有变化：
- en: '[PRE28]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Monet makes a flag available that tells us whether it is currently updating
    the animation state. We use that as a cheap mechanism to "pause" the game.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Monet提供了一个标志，告诉我们是否正在更新动画状态。我们使用这个标志作为一个便宜的机制来“暂停”游戏。
- en: Note that `active-keys-stream` pushes events as they happen so, if a user is
    holding a button down for any amount of time, we will get multiple events for
    that key. As such, we would probably get multiple occurrences of the `PAUSE` key
    in a very short amount of time. This would cause the game to frantically stop/start.
    In order to prevent this from happening, we throttle the filtered stream and ignore
    all `PAUSE` events that happen in a window shorter than 100 milliseconds.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`active-keys-stream`会在事件发生时推送事件，因此，如果用户按住按钮任何时间长度，我们都会为该键获得多个事件。因此，我们可能会在非常短的时间内多次遇到`PAUSE`键。这会导致游戏疯狂地停止/开始。为了防止这种情况发生，我们限制过滤流的速率，并忽略所有在100毫秒窗口内发生的`PAUSE`事件。
- en: 'To make sure we didn''t miss anything, this is what our `src/cljs/reagi_game/core.cljs`
    file should look like, in full:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们没有遗漏任何东西，这是我们的`src/cljs/reagi_game/core.cljs`文件应该看起来像的，完整版：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This completes the code and we're now ready to have a look at the results.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了代码，我们现在可以查看结果。
- en: 'If you still have the server running from earlier in this chapter, simply exit
    the REPL, start it again, and start the embedded web server:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在本章的早期部分仍然运行着服务器，只需退出 REPL，再次启动它，并启动嵌入的 Web 服务器：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This will compile the latest version of our ClojureScript source to JavaScript.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这将编译我们 ClojureScript 源代码的最新版本到 JavaScript。
- en: 'Alternatively, you can leave the REPL running and simply ask `cljsbuild` to
    auto-compile the source code from another terminal window:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以让 REPL 保持运行状态，并在另一个终端窗口中简单地要求 `cljsbuild` 自动编译源代码：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now you can point your browser to `http://localhost:3000/` and fly around your
    spaceship! Don't forget to shoot some bullets as well!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以将你的浏览器指向 `http://localhost:3000/` 并在你的宇宙飞船周围飞翔！别忘了射击一些子弹哦！
- en: Reagi and other CES frameworks
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reagi 和其他 CES 框架
- en: 'Back in [Chapter 4](part0033_split_000.html#page "Chapter 4. Introduction to
    core.async"), *Introduction to core.async*, we had an overview of the main differences
    between `core.async` and CES. Another question that might have arisen in this
    chapter is this: how do we decide which CES framework to use?'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[第 4 章](part0033_split_000.html#page "第 4 章。核心异步简介")，*核心异步简介*，我们概述了 `core.async`
    和 CES 之间的主要区别。在这一章中可能出现的另一个问题是：我们如何决定使用哪个 CES 框架？
- en: 'The answer is less clear than before and often depends on the specifics of
    the tool being looked at. We have learned about two such tools so far: Reactive
    Extensions (encompassing RxJS, RxJava, and RxClojure) and Reagi.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 答案没有以前那么明确，通常取决于正在查看的工具的具体情况。到目前为止，我们已经了解了两种这样的工具：响应式扩展（包括 RxJS、RxJava 和 RxClojure）和
    Reagi。
- en: '**Reactive Extensions** (**Rx**) is a much more mature framework. Its first
    version for the .NET platform was released in 2011 and the ideas in it have since
    evolved substantially.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应式扩展**（**Rx**）是一个更加成熟的框架。它的第一个 .NET 平台版本于 2011 年发布，其中的理念自那时起已经得到了显著的发展。'
- en: Additionally, ports for other platforms such as RxJava are being heavily used
    in production by big names such as Netflix.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，像 Netflix 这样的知名公司正在生产中大量使用其他平台如 RxJava 的端口。
- en: A drawback of Rx is that if you would like to use it both in the browser and
    on the server, you have to use two separate frameworks, RxJS and RxJava, respectively.
    While they do share the same API, they are different codebases, which can incur
    bugs that might have been solved in one port but not yet in another.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Rx 的一个缺点是，如果你想在浏览器和服务器上同时使用它，你必须分别使用两个不同的框架，即 RxJS 和 RxJava。虽然它们确实共享相同的 API，但它们是不同的代码库，这可能导致一个端口中已经解决的错误在另一个端口中尚未解决。
- en: For Clojure developers, it also means relying more on interoperability to interact
    with the full API of Rx.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Clojure 开发者来说，这也意味着更多地依赖互操作性来与 Rx 的完整 API 进行交互。
- en: Reagi, on the other hand, is a new player in this space but builds on the solid
    foundation laid out by `core.async`. It is fully developed in Clojure and solves
    the in-browser/on-server issue by compiling to both Clojure and ClojureScript.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Reagi 是这个领域的新参与者，但它建立在 `core.async` 的坚实基础之上。它是完全在 Clojure 中开发的，并通过编译为 Clojure
    和 ClojureScript 解决了在浏览器/服务器上的问题。
- en: Reagi also allows seamless integration with `core.async` via functions such
    as `port` and `subscribe`, which allow channels to be created from event streams.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Reagi 还允许通过 `port` 和 `subscribe` 等函数无缝集成 `core.async`，这些函数允许从事件流中创建通道。
- en: Moreover, the use of `core.async` in ClojureScript applications is becoming
    ubiquitous, so chances are you already have it as a dependency. This makes Reagi
    an attractive option for the times when we need a higher level of abstraction
    than the one provided by `core.async`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`core.async` 在 ClojureScript 应用程序中的使用正在变得无处不在，所以你很可能已经将其作为依赖项。这使得 Reagi 在我们需要比
    `core.async` 提供的更高层次抽象时成为一个有吸引力的选择。
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how we can use the techniques from reactive programming
    we have learned so far in order to write code that is cleaner and easier to maintain.
    To do so, we insisted on thinking about asynchronous events simply as lists and
    saw how that way of thinking lends itself quite easily to being modeled as an
    event stream. All our game has to do, then, is operate on these streams using
    familiar sequence processing functions.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用我们迄今为止学到的反应式编程技术来编写更干净、更容易维护的代码。为此，我们坚持将异步事件简单地视为列表，并看到这种思维方式如何很容易地被建模为事件流。然后，我们的游戏只需要使用熟悉的序列处理函数对这些流进行操作。
- en: We also learned the basics of Reagi, a framework for CES similar to the one
    we created in [Chapter 4](part0033_split_000.html#page "Chapter 4. Introduction
    to core.async"), *Introduction to core.async*, but that is more feature rich and
    robust.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了Reagi的基础知识，这是一个类似于我们在[第4章](part0033_split_000.html#page "第4章。核心.async简介")中创建的CES框架，即*核心.async简介*，但它功能更丰富且更健壮。
- en: In the next chapter, we will take a break from CES and see how a more traditional
    reactive approach based on data flows can be useful.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将暂时放下CES，看看基于数据流的传统反应式方法如何有用。
