- en: Persisting Data Using a Database
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据库持久化数据
- en: In this chapter, we will look at choosing a database management system. The
    choice of systems depends on various factors, such as visualization and reporting,
    security, scalability, and cost, to name a few. There are also various kinds of
    databases, and one of them is the relational database. This kind of database is
    designed in such a way that it recognizes relations within the stored information.
    In most cases, SQL is used to query and maintain relational databases systems.
    Additionally, we will learn to develop the data in that database along with your
    application and implement data access with Spring.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨选择数据库管理系统。系统的选择取决于各种因素，例如可视化与报告、安全性、可扩展性和成本，仅举几例。还有各种类型的数据库，其中之一就是关系型数据库。这种数据库的设计方式使其能够识别存储信息中的关系。在大多数情况下，SQL用于查询和维护关系型数据库系统。此外，我们还将学习如何在数据库中开发与你的应用程序相关的数据，并使用Spring实现数据访问。
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Choose a database management system
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择数据库管理系统
- en: Develop the data in that database along with your application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据库中开发与你的应用程序相关的数据
- en: Implement data access with the help of Spring
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Spring的帮助下实现数据访问
- en: Relational Databases and SQL
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关系型数据库和SQL
- en: The final chapter of this book is about persistence, in other words, using a
    database.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本书最后一章关于持久化，换句话说，就是使用数据库。
- en: There is software that does not need to store any state. Some software is just
    fired up for a certain task; it performs it and returns its results; some lies
    in the middle of other components and relays messages back and forth. Many software
    systems, however, need to store some state; they are said to **persist** the state.
    There are different forms of data storage, but we will focus on what is most prevalent
    in business applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有些软件不需要存储任何状态。有些软件只是为了执行特定任务而启动；执行任务并返回结果；有些则位于其他组件之间，来回传递消息。然而，许多软件系统需要存储一些状态；它们被称为**持久化**状态。数据存储有不同的形式，但我们将关注在商业应用中最普遍的形式。
- en: Many different answers may come up. A saved game file on your hard disk may
    not sound like persistence at first, but it is a very valid answer. It is important
    that you understand that most software need some amount of storage, and that the
    form of storage differs widely.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有许多不同的答案。硬盘上的保存游戏文件一开始可能听起来不像是持久化，但它是一个非常有效的答案。重要的是要理解，大多数软件都需要一定量的存储，并且存储的形式差异很大。
- en: Relational Database Management Systems (RDBMS)
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关系型数据库管理系统（RDBMS）
- en: '**Relational Database Management Systems**, **RDBMS** for short, are systems
    that can store data in a relational database. Strictly speaking, the **database**
    is only the data within that is managed by the system. Very often, we do not make
    this distinction in everyday speech and just call this **management system** a
    **relational database**, or even just database.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**关系型数据库管理系统**（**RDBMS**），简称**RDBMS**，是能够存储关系型数据库中的数据的系统。严格来说，**数据库**仅指由系统管理的那些数据。在日常生活中，我们通常不区分这一点，而将这个**管理系统**称为**关系型数据库**，甚至只是数据库。'
- en: Without diving deep into database theory, relational in this context refers
    to relational algebras as introduced by Edgar F Codd in 1970\. In short, it means
    we store data in tables, pre-defining the set of columns for a table (with names
    and types), with each entity taking up a row in it. Databases such as these are
    almost invariably described and queried using the query language SQL; therefore,
    they are sometimes called **SQL databases**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在不深入数据库理论的情况下，这里的“关系型”指的是1970年由爱德华·F·科德提出的关系代数。简而言之，这意味着我们以表格的形式存储数据，预先定义表格的列集（包括名称和类型），每个实体占据表格中的一行。这类数据库几乎总是使用查询语言SQL进行描述和查询；因此，它们有时被称为**SQL数据库**。
- en: 'The well-founded semantics of relational algebras are the basis of how to store
    data in an RDBMS and also how to query such data. The original work that is the
    foundation of database theory can be found in Edgar F Codd''s 1970 work ''*A Relational
    Model of Data for Large Shared Data Banks'', Communications of the ACM, 13 (6):
    377–387* ([https://doi.org/10.1145%2F362384.362685](https://doi.org/10.1145%2F362384.362685)).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 关系代数的坚实基础语义是RDBMS中存储数据和查询此类数据的基础。数据库理论的奠基性工作可以在爱德华·F·科德1970年的作品《*大型共享数据银行的数据关系模型*》，《ACM通讯》，第13卷（6）：377–387中找到（[https://doi.org/10.1145%2F362384.362685](https://doi.org/10.1145%2F362384.362685))。
- en: There are many good articles on this for different levels of expertise, which
    can be found on Wikipedia or universities' websites. It is worthwhile reading
    even if you are already familiar with SQL databases.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个话题，有针对不同专业水平的许多优秀文章，可以在维基百科或大学网站上找到。即使你已经熟悉SQL数据库，阅读这些文章也是值得的。
- en: Relational databases are the industry standard, with popular open source software
    such as PostgresQL and MySQL, and expensive enterprise-grade solutions such as
    Oracle and MS SQL Server. They are the best solution for many challenges, and
    still a very good solution for most others, and this has made them prevalent.
    However, for a number of special cases, they are deemed to be too inflexible or
    too slow. This has given rise to a large number of alternative solutions that
    are often collectively known as **NoSQL** to differentiate them from the more
    standard SQL databases. The increased speed or flexibility comes with some cost,
    so they are not a general replacement. Even though Spring offers support for some
    of them, none of this is in scope for this book.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库是行业标准，拥有如PostgreSQL和MySQL等流行的开源软件，以及如Oracle和MS SQL Server等昂贵的企业级解决方案。它们是许多挑战的最佳解决方案，对于大多数其他情况来说，仍然是一个非常不错的解决方案，这也使得它们变得普遍。然而，对于许多特殊情况，它们被认为过于不灵活或过于缓慢。这导致了大量替代解决方案的出现，这些解决方案通常统称为**NoSQL**，以区别于更标准的SQL数据库。虽然速度或灵活性的提升伴随着一些成本，但它们并不是一个通用的替代品。尽管Spring对这些中的某些提供了支持，但本书的范围并不包括这些内容。
- en: Instead, we will focus on SQL databases and the excellent support Spring has
    for these in a number of aspects. We will see how to connect to an RDBMS (even
    to integrate one), how to evolve the database alongside our code, and how to access
    the data. This last aspect in particular, is facilitated, as we will see shortly.
    But, first, we need an RDBMS to connect to.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将专注于SQL数据库，以及Spring在这些方面的出色支持。我们将看到如何连接到RDBMS（甚至如何集成一个），如何随着我们的代码一起演进数据库，以及如何访问数据。特别是最后一个方面，我们将很快看到它是如何被简化的。但首先，我们需要一个RDBMS来连接。
- en: The H2 Embedded Database
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: H2嵌入式数据库
- en: Many database systems are heavyweight, can store terabytes of data (or, for
    some, that is the memory they take up, and they can store petabytes), they have
    fail-over and backup strategies built in, and an elaborate security concept. Sometimes,
    all of this is too much.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 许多数据库系统都是重量级的，可以存储数TB的数据（或者对于某些系统来说，这就是它们占用的内存，它们可以存储PB级别的数据），它们内置了故障转移和备份策略，以及一个复杂的安全概念。有时，所有这些功能都过于复杂。
- en: '**H2** is special in that it is small, it is written in Java, it can be embedded
    in your program, and it can store all the data in-memory. Yes, that''s right—
    it will be all in one place, and it will work out of the box. H2 can be used in
    production systems, if required, since it is fast and supports most of SQL. Often,
    however, it will be used only during development.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**H2**数据库特别之处在于它体积小，是用Java编写的，可以嵌入到你的程序中，并且可以将所有数据存储在内存中。是的，没错——它将全部在一个地方，并且会直接工作。如果需要，H2可以用于生产系统，因为它速度快，支持大多数SQL功能。然而，通常它只会在开发期间使用。'
- en: Let's dive right in and use it in our project!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接进入并在我们的项目中使用它！
- en: Utilizing the H2 Console
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用H2控制台
- en: The aim here is to embed the in-memory H2 database. You want to add persistence
    to your application. Since you are newly developing the application, you need
    some playground, so you decide not to access your company's enterprise database,
    but to start with an in-memory solution that can be swapped for an external database
    as the need arises.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目的是嵌入内存中的H2数据库。你想要给你的应用程序添加持久性。由于你正在开发新应用程序，你需要一个游乐场，因此你决定不访问公司的企业数据库，而是从内存中的解决方案开始，当需要时可以替换为外部数据库。
- en: 'Before beginning, locate the blogmania app from the folder present at [https://bit.ly/2qIrUEE](https://bit.ly/2qIrUEE).
    The steps for completion are as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，从[https://bit.ly/2qIrUEE](https://bit.ly/2qIrUEE)提供的文件夹中找到blogmania应用程序。完成步骤如下：
- en: 'In the POM, in a convenient spot within the `<dependencies>` element, add the
    following dependencies:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在POM中，在`<dependencies>`元素的一个方便位置，添加以下依赖项：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Upon starting, Spring Boot will auto-discover the database and give you access
    to a pre-configured database instance through the use of injected DataSource beans.
    Everything you need is now there!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动时，Spring Boot会自动发现数据库，并使用注入的DataSource beans让你能够访问一个预配置的数据库实例。现在你需要的一切都在那里了！
- en: 'However, there is not much to be seen just yet. Let''s turn to another feature
    that can be very helpful during development: the H2 console. This comes with the
    H2 database and is enabled in Spring Boot when the Spring Boot Devtools are available
    (which they are in our application). Go to [https://bit.ly/2QpSiP0](https://bit.ly/2QpSiP0)
    to access the complete code for the `BlogmaniaApplication.java` file.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，目前还没有太多可以看的东西。让我们转向另一个在开发过程中非常有用的功能：H2 控制台。这随 H2 数据库一起提供，并在 Spring Boot Devtools
    可用时（在我们的应用程序中它们是可用的）启用。访问 [https://bit.ly/2QpSiP0](https://bit.ly/2QpSiP0) 以获取
    `BlogmaniaApplication.java` 文件的完整代码。
- en: 'Now start the application. Point your browser to `http://localhost:8080/h2-console`,
    and — voilà! — you are now seeing the H2 console login screen:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在开始应用程序。将您的浏览器指向 `http://localhost:8080/h2-console`，然后——哇！——您现在看到的是 H2 控制台登录屏幕：
- en: '![](img/d38304fd-9edb-4ec6-ab9f-7b03bfc76eee.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d38304fd-9edb-4ec6-ab9f-7b03bfc76eee.png)'
- en: This console could be used to access any SQL database. The fields are prefilled
    with exactly the correct values to go into the embedded in-memory test database,
    so just click the Connect button.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个控制台可以用来访问任何 SQL 数据库。字段已预先填充了正确的值，以便进入嵌入的内存测试数据库，所以只需点击连接按钮。
- en: 'The next screen is a bit overwhelming at first. To help you get started, find
    the ''Sample SQL Script'' section in the middle of the screen; when you click
    on it, the script will be copied to the SQL statement window at the top. Press
    the Run button to actually run the script:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个屏幕一开始可能会让人感到有些不知所措。为了帮助您开始，请在屏幕中间找到“示例 SQL 脚本”部分；当您点击它时，脚本将被复制到顶部的 SQL 语句窗口中。按下运行按钮以实际运行脚本：
- en: '![](img/0cdd20e1-d542-42a0-9529-12765719df92.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0cdd20e1-d542-42a0-9529-12765719df92.png)'
- en: You have now created a table, put some data in it, and updated it! The new table
    called TEST will now appear in the tree to the left. You may want to explore the
    console to get familiar with it.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您现在已创建了一个表，向其中添加了一些数据，并对其进行了更新！新表 TEST 将现在出现在左侧的树中。您可能想探索控制台，以便熟悉它。
- en: As you have witnessed, now there is a database that can be used and viewed for
    debugging. However, detailed knowledge of this is outside the scope of this book.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见证的，现在有一个数据库可用于调试和查看。然而，对这个的深入了解超出了本书的范围。
- en: 'Unfortunately, the console does not play well with Spring Security. So, if
    we had that enabled, we would have to relax access a bit. In the security configuration,
    you must perform one change in the configure (`WebSecurity`) method to just take
    the H2 console out of the security loop. That method should then look like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，控制台与 Spring Security 不兼容。因此，如果我们启用了它，我们就必须稍微放松一下访问权限。在安全配置中，您必须在 `WebSecurity`
    方法中执行一个更改，以将 H2 控制台从安全循环中移除。该方法应如下所示：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Before going into production, it would be a good idea to undo these changes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入生产之前，撤销这些更改是个好主意。
- en: The Gist of SQL
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL 的要点
- en: SQL is a database language to define, create, read, update, and delete data.
    The initialism has no official meaning. However, it is usually thought to be an
    abbreviation of **Structured Query Language**, and it is sometimes pronounced
    "sequel" but this is, in fact, a relic of its predecessor.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 是一种数据库语言，用于定义、创建、读取、更新和删除数据。这个缩写没有官方含义。然而，它通常被认为是 **结构化查询语言（Structured Query
    Language**）的缩写，有时发音为“sequel”，但这实际上是其前身的一个遗迹。
- en: SQL handles data in tables. These tables have a defined number of columns, each
    with a specific type. The database system is strongly typed and can even check
    constraints over the values in a table. A part of SQL referred to as the **Data
    Definition Language** (**DDL**) is responsible for declaring and creating these
    tables.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 在表中处理数据。这些表有定义的列数，每列都有特定的类型。数据库系统是强类型的，甚至可以检查表中的值约束。SQL 中被称为 **数据定义语言（DDL**）的一部分负责声明和创建这些表。
- en: Another part of the language, the **Data Manipulation Language** (**DML**),
    is responsible for working on the data. The two sub-languages are only logically
    separated; they share much of their syntax.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 语言的一部分，**数据操纵语言（DML**），负责处理数据。这两种子语言在逻辑上是分开的；它们在语法上有很多相似之处。
- en: DDL Table Creation
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DDL 表创建
- en: 'We have seen the language in action in the last exercise. Let''s look closer:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一个练习中已经看到了该语言的实际应用。让我们更仔细地看看：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This bit of DDL defines a table called test with two columns: one column called
    `id`, and another one called `name`. The id column has the type INT, which can
    store integer values. The name column, on the other hand, can store strings of
    a variable number of characters, up to a maximum length of 255.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这段DDL定义了一个名为test的表，包含两列：一列名为`id`，另一列名为`name`。`id`列的类型为INT，可以存储整数值。另一方面，`name`列可以存储可变数量的字符串，最大长度为255。
- en: It is customary to write all SQL keywords in uppercase. This, however, is only
    a convention, and SQL is case-agnostic.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会将所有SQL关键字写成大写。然而，这只是一个约定，SQL对大小写不敏感。
- en: Slightly contested, but still widespread is the convention to use lowercase
    for identifiers. SQL is case-agnostic here as well.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然存在一些争议，但使用小写字母作为标识符的约定仍然很普遍。SQL在这里也不区分大小写。
- en: The id column is meant to store an identifier for the row. This is also called
    a `key` in databases. Identifiers should be unique within a table and adding the
    keywords PRIMARY KEY will make the database enforce this constraint.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`id`列的目的是存储行的标识符。这也在数据库中被称为`key`。标识符应在表中是唯一的，添加PRIMARY KEY关键字将使数据库强制执行此约束。'
- en: Most databases can be forced to use identifiers with only the specified case.
    This is asking for trouble.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数数据库可以强制使用指定的大小写来使用标识符。这可能会带来麻烦。
- en: There is a lot of standardization in SQL, but, unfortunately, each database
    has its quirks or extensions. For instance, the normal type for storing strings
    of characters is called VARCHAR2 in Oracle, and it cannot store empty strings,
    because empty strings are handled the same as the special NULL values.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: SQL有很多标准化，但不幸的是，每个数据库都有自己的怪癖或扩展。例如，在Oracle中，用于存储字符字符串的正常类型称为VARCHAR2，它不能存储空字符串，因为空字符串被处理得与特殊的NULL值相同。
- en: DML Data Manipulation
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DML数据操纵
- en: 'The next lines, in contrast, are DML and manipulate data:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，接下来的几行是DML（数据操纵语言）并操作数据：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These lines are quite self-explanatory. Note that SELECT statements can also
    have a WHERE clause. This little SQL is enough to carry us through the remainder
    of the chapter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行相当直观。请注意，SELECT语句也可以有WHERE子句。这段简短的SQL足以让我们完成本章的剩余部分。
- en: Accessing the Database from Java with JDBC and JdbcTemplate
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JDBC和JdbcTemplate从Java访问数据库
- en: Before we actually access data, it is good to have some data to play around
    with. Normally, data is persistent, but in our current setup, H2 will be empty
    on each start of the application. In cases such as these, Spring Boot offers to
    execute certain SQL scripts upon application start.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实际访问数据之前，拥有一些可以操作的数据是很有用的。通常，数据是持久的，但在我们当前的设置中，每次应用程序启动时H2都会为空。在这种情况下，Spring
    Boot提供在应用程序启动时执行某些SQL脚本的功能。
- en: Importing Initial Data
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入初始数据
- en: The first script is called `schema.sql` and contain SQL statements (DDL) to
    create the tables used in our application (usually CREATE TABLE statements). The
    second one is `data.sql` and contains SQL statements (DML) to create some data
    (usually INSERT statements). As resource files, they live in the `src/main/resources`
    folder. The example files for this chapter can be found at [https://bit.ly/2Dzb03G](https://bit.ly/2Dzb03G).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第一份脚本称为`schema.sql`，包含用于我们应用程序中的SQL语句（DDL，数据定义语言），用于创建表（通常是CREATE TABLE语句）。第二份是`data.sql`，包含用于创建一些数据的SQL语句（DML，数据操纵语言）（通常是INSERT语句）。作为资源文件，它们位于`src/main/resources`文件夹中。本章的示例文件可以在[https://bit.ly/2Dzb03G](https://bit.ly/2Dzb03G)找到。
- en: Plain JDBC
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的JDBC
- en: JDBC is the standard interface to use relational databases from Java. The initialism
    means Java Database Connectivity. The standard provides a uniform API to access
    RDBMS from different vendors. The database driver containing the actual low-level
    implementation is supplied by the vendor, while the interfaces and common classes
    are part of the standard Java runtime environment.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: JDBC是使用Java访问关系数据库的标准接口。其缩写意为Java Database Connectivity。该标准提供了一致的API来访问不同供应商的RDBMS。包含实际低级实现的数据库驱动程序由供应商提供，而接口和常用类是Java运行时环境的一部分。
- en: Plain JDBC Examples
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的JDBC示例
- en: 'Most of what is found in the API is easy to follow through and well documented.
    However, it turns out to be quite cumbersome to use. Users need to take a close
    look at database resources such as connections, and failure to properly close
    those may exhaust the configured connection limit of the database. All this is
    complicated by the use of checked exceptions, even in places where nothing can
    be done about the failure by the application programmer. Consider the following
    excerpt (full code for all examples to be found in the `JdbcDemonstratingRepository`
    class):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: API中大部分内容都很容易理解，并且有很好的文档。然而，使用起来相当繁琐。用户需要仔细查看数据库资源，如连接，如果未能正确关闭这些资源，可能会耗尽数据库配置的连接限制。所有这些都因使用了检查异常而变得复杂，即使在应用程序程序员无法处理失败的地方也是如此。考虑以下摘录（所有示例的完整代码可以在`JdbcDemonstratingRepository`类中找到）：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Go to [https://bit.ly/2Qm2tnM](https://bit.ly/2Qm2tnM) to access the complete
    code for the `JdbcDemonstratingRepository.java file`. This is surely not the way
    we want to write code. All it does is retrieve a single number!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[https://bit.ly/2Qm2tnM](https://bit.ly/2Qm2tnM)访问`JdbcDemonstratingRepository.java`文件的完整代码。这绝对不是我们想要编写代码的方式。它所做的只是检索一个数字！
- en: Plain JDBC Since Java 7
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 7以来的纯JDBC
- en: 'The bulk of this code is concerned with error handling. Complex queries will
    require more work on the result set but the same amount of error handling, so
    the ratio will improve, but for small queries, the overhead is unpardonable. Most
    people decide not to catch the exceptions in the smallest possible scope, abandoning
    a bit of accuracy in error reporting. Fortunately, all the mentioned classes implement
    `AutoClosable`, which allows us to write this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的大部分内容都与错误处理有关。复杂的查询需要对结果集进行更多的工作，但错误处理的量是相同的，因此比率会提高，但对于小查询，开销是无法容忍的。大多数人决定不在尽可能小的范围内捕获异常，从而牺牲了一部分错误报告的准确性。幸运的是，所有提到的类都实现了`AutoClosable`接口，这使得我们可以编写如下代码：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is really much better and as good as it gets for simple queries. The try-with-resources
    mechanism ensures that, no matter what errors may arise, all resources will be
    closed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于简单的查询来说真的非常好，可以说是最好的了。try-with-resources机制确保无论可能发生什么错误，所有资源都将被关闭。
- en: 'For a discussion of possible complications, you may refer to this question
    on StackOverflow: [https://stackoverflow.com/questions/8066501/how-should-i-use-try-with-resources-with-jdbc](https://stackoverflow.com/questions/8066501/how-should-i-use-try-with-resources-with-jdbc).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 关于可能出现的复杂性的讨论，您可以参考StackOverflow上的这个问题：[https://stackoverflow.com/questions/8066501/how-should-i-use-try-with-resources-with-jdbc](https://stackoverflow.com/questions/8066501/how-should-i-use-try-with-resources-with-jdbc)。
- en: JDBC Resources to Handle
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需要处理的JDBC资源
- en: 'These JDBC resources are as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些JDBC资源如下：
- en: A connection to the database. Everything runs in the context of this, and it
    incurs network traffic to establish the connection (in the case of a remote database).
    Transactions and rollback, if required, are on the connection level.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库连接。所有操作都在这个上下文中运行，并且建立连接时会产生网络流量（对于远程数据库）。如果需要，事务和回滚在连接级别上执行。
- en: A statement that encapsulates a single SQL statement.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装单个SQL语句的语句。
- en: A set of results of the operation. Transmission of this result over the network
    may well be in chunks and batches; the result may be big (as big as your whole
    database), so take care to process it correctly.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作结果集的一组结果。通过网络传输此结果可能是在块和批次中进行的；结果可能很大（可能像你的整个数据库一样大），因此请确保正确处理。
- en: Spring to the Rescue – JdbcTemplate
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring拯救——JdbcTemplate
- en: The `JdbcTemplate` class is the central class in the Spring JDBC package. It
    simplifies the use of JDBC and helps to avoid common errors. It can do all the
    work for simple use cases and provides extension points for callback interfaces
    for more advanced use cases. In addition, it performs **exception translation**,
    the usefulness of which will be discussed later in this chapter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`JdbcTemplate`类是Spring JDBC包中的核心类。它简化了JDBC的使用，并有助于避免常见错误。它可以为简单用例完成所有工作，并为更高级用例提供回调接口的扩展点。此外，它执行**异常转换**，其有用性将在本章后面讨论。'
- en: The name of the class contains the word **template** and is often not well understood.
    It refers to the **template method** design pattern, which is one of the 23 well-known
    patterns described in the book *Design Patterns* (Gamma, Helm, Johnson, Vlissides;
    Addison-Wesley 1994; ISBN 0-201-63361-2).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 类名中包含单词**template**，通常理解得不是很好。它指的是**模板方法**设计模式，这是书中描述的23个著名模式之一（Gamma, Helm,
    Johnson, Vlissides；Addison-Wesley 1994；ISBN 0-201-63361-2）。
- en: In short, the complete workflow of JDBC (getting the connection, creating a
    statement, …, closing statement, and returning the connection) is performed within
    `JdbcTemplate`. To make the behavior flexible, this workflow calls callback functions
    at various places that the user of `JdbcTemplate` can optionally provide.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，JDBC（获取连接、创建语句……、关闭语句和返回连接）的完整工作流程是在`JdbcTemplate`中执行的。为了使行为更灵活，这个工作流程在`JdbcTemplate`用户可以选择提供的地方调用回调函数。
- en: 'Let''s have a look at how simple database access can be:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看数据库访问可以有多简单：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Yes, that is really a one-liner!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这确实是一行代码！
- en: Of course, this example was trimmed a bit to increase the effect. Nevertheless,
    even complex scenarios are much easier to handle with `JdbcTemplate` than with
    plain JDBC.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个例子被稍微剪裁了一下，以增强效果。尽管如此，即使是复杂场景，使用`JdbcTemplate`也比使用纯JDBC更容易处理。
- en: 'In detail: Creating the JdbcTemplate'
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 详细说明：创建JdbcTemplate
- en: 'We left out the details of how to get the `JdbcTemplate` instance and what
    side effects will arise. Let''s catch up on that now. The following is again an
    excerpt from the same class:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了如何获取`JdbcTemplate`实例以及可能出现的副作用。现在让我们来补充这一点。以下又是从同一个类中摘录的内容：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `@Repository` annotation is a Spring annotation that is itself annotated
    with `@Component` and will mark this class as a Spring bean (we have already seen
    it in *[Chapter 1](9c691a93-c936-4976-b836-8ec08d62bffb.xhtml): Spring Project
    and Framework*). It is just a more semantic version, just like the `@Service`
    annotation. It will prepare the whole code for exception translation when using
    JPA, but this is outside the scope of this book.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Repository`注解是一个Spring注解，它本身被`@Component`注解，并将这个类标记为Spring Bean（我们已经在*[第1章](9c691a93-c936-4976-b836-8ec08d62bffb.xhtml)：Spring项目和框架*）中见过）。这只是更语义化的版本，就像`@Service`注解一样。它将为使用JPA时的异常转换准备整个代码，但这超出了本书的范围。'
- en: 'Spring will wire in an instance of `javax.sql.DataSource` for us. This is not
    a Spring-specific class, but Spring Boot will create it automatically for us in
    our simple configuration (remember, all we did was add two dependencies to the
    POM) and connect it to our database, the embedded H2 instance. Such a `DataSource`
    has only one purpose: to acquire database connections.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Spring会为我们连接一个`javax.sql.DataSource`实例。这不是一个Spring特定的类，但Spring Boot会自动为我们创建它，并在我们的简单配置中连接到我们的数据库，嵌入式H2实例。这样的`DataSource`只有一个目的：获取数据库连接。
- en: 'This DataSource is then used to create an instance of `JdbcTemplate`. It is
    customary to create the instance in the constructor and reuse it throughout the
    class. It is thread-safe. There may be a need to further configure the template,
    but when the defaults are fine, there is one even easier way: just autowire the
    global `JdbcTemplate` bean (that is the approach taken in the other repository
    classes in the example application).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这个数据源被用来创建`JdbcTemplate`的一个实例。通常，我们会在构造函数中创建这个实例，并在整个类中重用它。它是线程安全的。可能需要进一步配置模板，但当默认值足够时，还有一个更简单的方法：只需自动装配全局的`JdbcTemplate`
    Bean（这是示例应用程序中其他仓库类所采取的方法）。
- en: Now we have the instance of the central workhorse of Spring JDBC support and
    can perform the simple query (it will be explained later). This is the simplest
    way to use `JdbcTemplate`; for more advanced needs, there are a plethora of options
    that we will explore shortly. But, first, let's turn our attention to a case when
    there is a failure.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有了Spring JDBC支持的中央工作马力的实例，可以执行简单的查询（稍后将会解释）。这是使用`JdbcTemplate`的最简单方法；对于更高级的需求，我们将很快探索大量的选项。但是，首先，让我们将注意力转向一个出现失败的情况。
- en: Exception Translation
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常转换
- en: Normally, JDBC throws checked exceptions in the `SQLException` hierarchy in
    the event of a problem. There was and is great debate on whether checked exceptions
    ever were a good idea in Java. The majority tends to prefer unchecked (or **runtime**)
    exceptions these days. Spring's `JdbcTemplate` will translate these into exceptions
    in the `DataAccessException` hierarchy, which are Spring-specific and unchecked.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，JDBC 在出现问题时会抛出 `SQLException` 层次结构中的检查型异常。关于检查型异常是否曾是 Java 中的好主意，一直存在很大的争议。如今，大多数人倾向于选择未检查的（或**运行时**）异常。Spring
    的 `JdbcTemplate` 将这些转换为 `DataAccessException` 层次结构中的异常，这些异常是 Spring 特有的且未检查的。
- en: As an added benefit, these exceptions are database technology-agnostic. You
    will also get the same set of exceptions for JPA or access to NoSQL databases.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的优势，这些异常与数据库技术无关。你也会为 JPA 或 NoSQL 数据库访问得到相同的一组异常。
- en: 'The exceptions in the `DataAccessException` hierarchy are more detailed than
    those in the `SQLException` hierarchy. The following table lists some of the most
    important ones:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataAccessException` 层次结构中的异常比 `SQLException` 层次结构中的异常更详细。以下表格列出了其中一些最重要的异常：'
- en: '![](img/48093b75-b337-4e8a-917b-0d4c850c2e80.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/48093b75-b337-4e8a-917b-0d4c850c2e80.png)'
- en: Advanced Queries
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级查询
- en: While exploring the `JdbcTemplate` class, we come across many methods, most
    of them overloaded. This is overwhelming at first, but there is a certain multi-dimensional
    order to it. We have already seen the basic `queryForObject()` method in its simplest
    form, and we are now going to look at some of the overloaded versions.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索 `JdbcTemplate` 类时，我们会遇到许多方法，其中大多数都是重载的。一开始可能会感到不知所措，但其中确实存在某种多维度的顺序。我们已经看到了其最简单的
    `queryForObject()` 方法，现在我们将查看一些重载版本。
- en: First of all, it is important to note that `queryForObject()`, in all its variants,
    is supposed to return exactly one object. That means the SQL must return one row,
    and in the basic version, we have seen, only a single column. Otherwise, it will
    throw `IncorrectResultSizeDataAccessException`. It will not return null except
    when the query returns an SQL NULL.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，重要的是要注意，`queryForObject()` 在所有变体中都应该返回一个精确的对象。这意味着 SQL 必须返回一行，在基本版本中，我们已经看到了，只有一列。否则，它将抛出
    `IncorrectResultSizeDataAccessException`。除非查询返回 SQL NULL，否则它不会返回 null。
- en: 'The examples up to now built upon a simple SQL query that you can find in `JdbcDemonstratingRepository:
    SELECT 42 FROM dual`. This query does not contain any variable parts, it will
    return exactly one row with exactly one column of the integer type. First, let''s
    add some variation by introducing variables.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '到目前为止的示例都是基于一个简单的 SQL 查询，你可以在 `JdbcDemonstratingRepository: SELECT 42 FROM
    dual` 中找到这个查询。这个查询不包含任何变量部分，它将返回一个正好有一列整型的单行。首先，让我们通过引入变量来增加一些变化。'
- en: What is **dual**? A standard SQL SELECT query requires not only the values or
    column names (right after the SELECT), but also a table expression to draw the
    data from. Many databases are generous in what they accept here, and you can just
    leave out the FROM part when selecting constant values.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是**双重**？标准的 SQL SELECT 查询不仅需要值或列名（在 SELECT 后面直接），还需要一个表表达式来提取数据。许多数据库在这里非常宽容，你可以在选择常量值时省略
    FROM 部分。
- en: Other RDBMS, however, are strict, notably Oracle. You have to give a table here,
    and take note that the constant will be returned once for each row in the table.
    For that purpose, Oracle comes with a predefined table, DUAL. It has one column,
    DUMMY, defined to be VARCHAR2(1), and contains one row with a value X. Others
    RDBMS have adopted this, as you have seen with H2 here.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，其他 RDBMS，尤其是 Oracle，则非常严格。你必须在这里提供一个表，并注意常量将针对表中的每一行返回一次。为此，Oracle 提供了一个预定义的表，DUAL。它有一个名为
    DUMMY 的列，定义为 VARCHAR2(1)，并包含一个值为 X 的行。其他 RDBMS 也采用了这种方法，正如你在 H2 中所看到的。
- en: 'Variable parts in queries are marked with a single question mark, which substitutes
    an SQL expression. We can change the SQL query like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 查询中的变量部分用一个问号标记，它代替一个 SQL 表达式。我们可以这样更改 SQL 查询：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The intention is clear, but how do we pass a value to this? The `queryForObject()` method
    is overloaded for this purpose with an `Object... args` parameter, so the simplest
    thing to do is just add the additional value at the end of the call! (There is
    also another overloaded version, taking an `Object[] args` parameter, that stems
    from before `var-arg` parameters were introduced in Java. We will ignore this
    version.)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 目意明确，但我们如何传递一个值给它？`queryForObject()`方法为此目的重载了一个`Object... args`参数，所以最简单的事情就是只需在调用末尾添加额外的值！（还有一个重载版本，它接受一个`Object[]
    args`参数，这源于在Java中引入可变参数之前。我们将忽略这个版本。）
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Other Result Types
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他结果类型
- en: 'All our queries up to now contained a single `Integer.class` parameter to map
    the result from the database to a Java type. Most SQL types map into Java types
    quite naturally, and there is a lot of flexibility; we could have used `BigDecimal.class`
    or even `double.class` instead. To demonstrate that, let''s query the database
    for its current time:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止的所有查询都包含一个`Integer.class`参数，用于将数据库结果映射到Java类型。大多数SQL类型映射到Java类型相当自然，并且有很大的灵活性；我们可以使用`BigDecimal.class`或甚至`double.class`。为了演示这一点，让我们查询数据库的当前时间：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This demonstrates nicely that we can either use `java.sql.Timestamp`, a low-level
    type created to match closely the values that an SQL database driver may return,
    or the new `Java 8 DateTime-API type LocalDateTime`. These conversions are conveniently
    performed for us by Spring!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好地说明了我们可以使用`java.sql.Timestamp`，这是一个为了与SQL数据库驱动程序可能返回的值紧密匹配而创建的低级别类型，或者使用新的`Java
    8 DateTime-API类型LocalDateTime`。这些转换由Spring方便地为我们执行！
- en: Returning Multiple Values
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回多个值
- en: 'If there is more than just one value in the result set, or if there may be
    zero, it is better to request a list of results, and `JdbcTemplate` offers just
    such a method:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结果集中有多个值，或者可能为零，最好请求一个结果列表，`JdbcTemplate`正好提供了这样的方法：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will get us a list of all the full names of all the authors in the database
    (remember they were imported in the `data.sql startup` script): [Administrator,
    Peter Quinn, Paul Nipkow, Catherine Sakai].'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们获取数据库中所有作者的全名列表（记住它们是在`data.sql startup`脚本中导入的）：[管理员, 彼得·奎恩, 保罗·尼普科, 凯瑟琳·萨卡伊]。
- en: The restriction that remains is that the query may only return a single column
    to convert into the given type. The next step is to query multiple columns at
    once.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的限制是查询只能返回一个列转换为给定类型。下一步是同时查询多个列。
- en: Returning Structured Data
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回结构化数据
- en: 'A query that returns more than one column poses the problem of how to represent
    these columns in Java. There are two approaches to tackle this—return the data
    as a map or make use of callback functions. The map approach is very convenient
    for one-off queries:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 返回多个列的查询提出了如何在Java中表示这些列的问题。有两种方法可以解决这个问题——将数据作为映射返回或使用回调函数。对于一次性查询，映射方法非常方便：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The result is a `Map<String, Object>`, which in this case contains `{USERNAME=admin,
    FULLNAME=Administrator}`. (Note that H2 returns column names all in uppercase,
    even if it accepts them as lowercase in the query.)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个`Map<String, Object>`，在这个例子中包含`{USERNAME=admin, FULLNAME=管理员}`。（注意，H2将列名全部返回为大写，即使它在查询中接受小写。）
- en: 'The corresponding call to get a list is this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 获取列表的相应调用如下：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that there is a slight asymmetry here; to get a map instead of a single
    object, we have to change `queryForObject()` into `queryForMap()`, while to get
    a list of maps instead a list of single objects, we use the same `queryForList()`
    call, but leave out the expected type.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里有一点不对称；要获取映射而不是单个对象，我们必须将`queryForObject()`改为`queryForMap()`，而要获取映射列表而不是单个对象列表，我们使用相同的`queryForList()`调用，但省略了预期的类型。
- en: Mapping Rows
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射行
- en: 'Using maps is simple, but we would prefer proper objects for our application
    instead of these maps. Instead of taking the maps and converting them afterward,
    Spring allows us to tap into the process of mapping each row of a result into
    a list element, using the `RowMapper<T>` interface. This interface is generic;
    its type parameter determines the type of the return value of the query method:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用映射很简单，但我们更希望我们的应用程序使用适当的对象而不是这些映射。Spring允许我们通过使用`RowMapper<T>`接口来参与将结果集中的每一行映射到列表元素的流程。此接口是泛型的；其类型参数决定了查询方法返回值的类型：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Mapping Rows (short)
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射行（简短）
- en: 'Luckily, `RowMapper<T>` is and always has been an interface with just one abstract
    method, which allows us to use it as a functional interface in Java 8\. Thus,
    the previous code can be shortened to the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`RowMapper<T>`始终是一个只有一个抽象方法的接口，这使得我们可以在Java 8中将其用作函数式接口。因此，前面的代码可以缩短为以下内容：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Of course, the mere mention of `RowMapper<Author>` in the extended version
    also serves as a kind of documentation; the second version mentions neither the
    type nor the actual mapping of rows. This is made worse by the fact that the `query()`
    method allows two further callbacks to be given: `RowCallbackHandler` and `ResultSetExtractor<T>`.
    So, look out for the two parameters `rs` and `rowNum` to spot the `RowMapper<T>`
    or store the mapper in a variable. Often, the following may be the most readable
    compromise:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在扩展版本中仅仅提及`RowMapper<Author>`也充当了一种文档；第二个版本既没有提及类型，也没有提及实际的映射。由于`query()`方法允许提供两个额外的回调：`RowCallbackHandler`和`ResultSetExtractor<T>`，这使得情况变得更糟。因此，请注意`rs`和`rowNum`这两个参数，以找到`RowMapper<T>`或将映射器存储在变量中。通常，以下可能是最易读的折衷方案：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: One other very important thing to note is that a `RowMapper<T>` is supposed
    to directly map one row to one object. In particular, authors are not supposed
    to `call next()` on the given SQL `ResultSet`. In many cases, this is just what
    we want.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的非常重要的事情是，`RowMapper<T>`应该直接将一行映射到一个对象。特别是，作者不应该在给定的SQL `ResultSet`上调用`next()`。在许多情况下，这正是我们想要的。
- en: 'Advanced Mapping: Row-Spanning'
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级映射：行跨
- en: Sometimes, more than one row of the `ResultSet` will be mapped into just one
    entity in our application. This technique has been used in `AuthorRepository`
    in the database-intro application. Why would we want that?
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，`ResultSet`的多行将被映射到我们应用程序中的一个实体。这种技术在数据库入门应用程序的`AuthorRepository`中已被使用。我们为什么想要这样做呢？
- en: 'An author can have more than one role, and the way to map this into tables
    in an RDBMS is to split the entity in two tables: one for the author proper, and
    one for the roles. To fetch the author by name, there are two methods.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 作者可以拥有多个角色，将它们映射到关系数据库管理系统（RDBMS）中的表的方法是将实体拆分为两个表：一个用于作者本身，另一个用于角色。要按名称检索作者，有两种方法。
- en: First, fetch the author's row from the author table by name and look up the
    ID. Then, using that ID, fetch the roles from the role table. This is very straightforward
    but requires two trips to the database.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过名称从作者表中检索作者的行并查找ID。然后，使用该ID从角色表中检索角色。这非常直接，但需要两次数据库访问。
- en: We can fetch from both the author and the role table at once using an SQL JOIN
    operation. For an author with just one role, this is straightforward as well,
    but when an author has more than one role, then the operation will return the
    author data more than once. Therefore, we need to advance the result set and de-duplicate
    it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用SQL JOIN操作同时从作者和角色表中检索数据。对于一个只有一个角色的作者来说，这同样简单，但当作者有多个角色时，操作将多次返回作者数据。因此，我们需要前进结果集并去重。
- en: The overhead caused by the data duplication in the second method is usually
    less than that from the two round trips to the database. Of course, all this optimization
    is unnecessary for our small application, and often even for big applications.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法中由于数据重复而产生的开销通常小于两次往返数据库的开销。当然，对于我们的小型应用程序来说，所有这些优化都是不必要的，甚至对于大型应用程序来说也是如此。
- en: In our repository, we use `ResultSetExtractor<Author>` to create author instances.
    In contrast to what happens in `RowMapper<T>`, the `extractData(ResultSet rs)` method
    has the result set as its only parameter and can process it in whatever way it
    wishes. This is closer to handwritten JDBC code; in particular, this time we need
    to call `next()` on the `ResultSet` to advance the cursor.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的仓库中，我们使用`ResultSetExtractor<Author>`来创建作者实例。与`RowMapper<T>`中的情况不同，`extractData(ResultSet
    rs)`方法只有一个参数，即结果集，并且可以按其希望的任何方式处理它。这更接近于手写的JDBC代码；特别是这次我们需要在`ResultSet`上调用`next()`来移动游标。
- en: Note that both in `RowMapper<T>` and in `ResultSetExtractor<T>`, we do not have
    to worry about exceptions, since the `JdbcTemplate` will take over the exception
    translation.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`RowMapper<T>`和`ResultSetExtractor<T>`中，我们不必担心异常，因为`JdbcTemplate`将接管异常转换。
- en: CRUD Operations
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CRUD操作
- en: The acronym **CRUD** reminds us of the types of database operations that we
    usually perform. The four letters stand for **Create**, **Read**, **Update**,
    and **Delete**. They more or less correspond to the SQL keywords `INSERT`, `SELECT`,
    `UPDATE`, and `DELETE`. Up to now, we have only covered reading, so we now turn
    to the other three.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 缩写**CRUD**让我们想起了我们通常执行的数据库操作类型。这四个字母代表**创建**（Create）、**读取**（Read）、**更新**（Update）和**删除**（Delete）。它们或多或少对应于SQL关键字`INSERT`、`SELECT`、`UPDATE`和`DELETE`。到目前为止，我们只覆盖了读取，所以我们现在转向其他三个。
- en: 'Reading is different than the others in that it returns data, while the other
    three return an update count at most. In a wider sense, creating rows and deleting
    them is also an update to the database, and so there is only one call in `JdbcTemplate`
    to cater for all these needs— `update()`. Its use is very straightforward:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 读取与其他操作不同，因为它返回数据，而其他三个操作最多返回一个更新计数。从更广泛的角度来看，创建行和删除行也是对数据库的更新，因此`JdbcTemplate`中只有一个`update()`方法来满足所有这些需求——`update()`的使用非常直接：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This statement will add a role the user cate by inserting a row with that value
    into the database. The call returns the number of updated rows, which is one,
    as expected.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句将通过在数据库中插入具有该值的行来添加一个用户角色。调用返回更新的行数，正如预期的那样，是1行。
- en: '`UPDATE` and `DELETE` work just the same.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`UPDATE`和`DELETE`的工作方式相同。'
- en: Schema Updates
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式更新
- en: Only a short-lived application has no need to change. If you have a long-lived
    application, the requirements will change over time. And as your requirements
    change, so does your application. Finally, you will find that your data model
    needs to evolve as well.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 只有短期运行的应用程序不需要更改。如果您有一个长期运行的应用程序，需求会随着时间的推移而变化。随着您需求的变化，您的应用程序也会变化。最终，您会发现您的数据模型也需要进化。
- en: In this latter example, adding the new table is not enough; we also need to
    migrate the existing data from the old column to the new table and subsequently
    drop the old, now useless, column.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个后者的例子中，添加新表是不够的；我们还需要将现有数据从旧列迁移到新表，然后删除现在无用的旧列。
- en: You need to make sure that your code and your database stay compatible. Doing
    this with the methods we have seen so far is difficult and error-prone. We want
    to keep the schema and the code close, within the same code base, and not tell
    the operations department to perform certain steps during deployment. For very
    simple cases only, we can use the `execute()` method on `JdbcTemplate` to perform
    schema changes.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要确保您的代码和数据库保持兼容。使用我们迄今为止看到的方法来做这件事是困难的，并且容易出错。我们希望将模式（schema）和代码保持紧密，在同一个代码库中，并且不要告诉运维部门在部署期间执行某些步骤。对于非常简单的情况，我们只能使用`JdbcTemplate`上的`execute()`方法来执行模式更改。
- en: There are tools and libraries to support us in this endeavor. There is **Flyway**,
    which we will look at in a minute, and **Liquibase**. Both are available both
    as a Java library and as a command-line tool. Liquibase has a lot more features,
    but, as is so often the case, it is also quite a lot more complicated. Many users
    find that they have no need for all the advanced features. The general advice
    is to stick to Flyway, and to keep Liquibase at the back of your mind in case
    you ever find that you actually need more.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 有工具和库支持我们在这个任务中。有**Flyway**，我们稍后会看到，还有**Liquibase**。两者都可作为Java库和命令行工具使用。Liquibase有很多功能，但正如经常发生的那样，它也相当复杂。许多用户发现他们不需要所有高级功能。一般的建议是坚持使用Flyway，并将Liquibase放在心中，以防万一您发现您实际上需要更多。
- en: Database Migrations with Flyway
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Flyway进行数据库迁移
- en: Flyway helps to keep your code and your database schema in sync by keeping both
    of them in the same place, your source code repository. Our introductory app sported
    something similar, yet quite trivial—the `schema.sql` file that contains the SQL
    to create the database schema, is part of the source code. This, however, assumes
    an empty database. For an in-memory database which is started alongside the application,
    that is good enough.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Flyway通过将两者都保存在同一个地方，即您的源代码库，来帮助保持您的代码和数据库模式同步。我们的入门级应用程序有一种类似的东西，但相当简单——包含创建数据库模式的SQL的`schema.sql`文件是源代码的一部分。然而，这假设数据库是空的。对于与应用程序一起启动的内存数据库，这已经足够好了。
- en: In most applications, the data in the database will far outlive the runtime
    of the application; this is, in fact, the whole point of using a DBMS in the first
    place assuming an empty database will not cut it. When we release a new version
    of our software, we have to change the database accordingly to match this. One
    very effective way to do that is to run this change upon the first start of the
    new application before it actually reads any data. This change in the schema and
    data is called a **migration**.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数应用中，数据库中的数据将远远超出应用的运行时间；这实际上就是最初使用数据库管理系统（DBMS）的整个目的，假设一个空的数据库是不够的。当我们发布软件的新版本时，我们必须相应地更改数据库以匹配这个版本。实现这一点的非常有效的方法是在新应用实际读取任何数据之前，在第一次启动时运行这个更改。这种模式和数据的更改称为**迁移**。
- en: 'Take a look at how Java and SQL evolved side by side:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 看看Java和SQL是如何并肩发展的：
- en: '![](img/3bdcb03e-e531-4f98-9d25-4c66c5ca209d.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3bdcb03e-e531-4f98-9d25-4c66c5ca209d.png)'
- en: Of course, we need to keep track of which changes are already in the database.
    This is where Flyway comes into the game. Each migration necessary for keeping
    the database in sync with the application is stored alongside the application,
    and Flyway remembers that a migration has already run, and will run it only once.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要跟踪哪些更改已经存在于数据库中。这就是Flyway介入的地方。每个必要的迁移，以保持数据库与应用同步，都与应用存储在一起，Flyway会记住已经运行过的迁移，并且只会运行一次。
- en: Utilizing Flyway
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用Flyway
- en: The aim is to utilize Flyway for schema migrations. You want to add migrate
    your schema alongside your application. You want that
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是利用Flyway进行模式迁移。你希望在应用中添加迁移你的模式。你想要这样做
- en: to happen automatically on startup, so you decide to use Flyway and Spring Boot's
    excellent support for it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在启动时自动执行，所以你决定使用Flyway和Spring Boot对它的出色支持。
- en: 'Before beginning, locate the database-intro app at [https://bit.ly/2zeKkl7](https://bit.ly/2zeKkl7). The
    steps for completion are as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，定位到数据库简介应用[https://bit.ly/2zeKkl7](https://bit.ly/2zeKkl7)。完成步骤如下：
- en: 'In the POM, in a convenient spot within the `<dependencies>` element (right
    after the other two database dependencies would be just splendid), add the following
    dependency:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在POM中，在`<dependencies>`元素内的一个方便位置（在其他两个数据库依赖项之后会很好），添加以下依赖项：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the `src/main/resources` folder, create a new folder, `db`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/main/resources`文件夹中，创建一个新的文件夹，`db`。
- en: 'This is most easily done right from within IntelliJ IDEA: Right-click on `resources`
    in the tree and choose New Directory.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这最简单的方法就是在IntelliJ IDEA中直接操作：在树中右键点击`resources`，然后选择新建目录。
- en: In this newly created `db` folder, create a new folder, `migration`. This is
    the place where Flyway expects its database migrations by default.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新创建的`db`文件夹中，创建一个新的文件夹，`migration`。这是Flyway默认期望数据库迁移的地方。
- en: Move the `schema.sql` and `data.sql` files from the `resources` folder into
    the new `db/migration` folder.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`schema.sql`和`data.sql`文件从`resources`文件夹移动到新的`db/migration`文件夹。
- en: Rename `schema.sql` to `V01__initial.sql` and `rename data.sql` to `V02__data.sql`.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`schema.sql`重命名为`V01__initial.sql`，将`data.sql`重命名为`V02__data.sql`。
- en: 'Take a look at the following screenshot:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的截图：
- en: '![](img/ac7a20be-26ea-4186-941e-27f43926d675.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac7a20be-26ea-4186-941e-27f43926d675.png)'
- en: Renaming can be done in IntelliJ IDEA by pressing *Shift + F6*. In both cases,
    the important thing is the prefix before the two underscores (and the `.sql` suffix),
    while the rest of the name is informational.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过按*Shift + F6*在IntelliJ IDEA中重命名。在两种情况下，重要的是两个下划线之前的前缀（以及`.sql`后缀），而名称的其余部分是信息性的。
- en: Start the application. It behaves just as before.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动应用。它的行为和以前一样。
- en: 'In the log you will find these lines:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志中，你会找到以下行：
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Go to [https://bit.ly/2NEFqG9](https://bit.ly/2NEFqG9) to access the code for
    the `DatabaseIntroApplication.java` file.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[https://bit.ly/2NEFqG9](https://bit.ly/2NEFqG9)访问`DatabaseIntroApplication.java`文件的代码。
- en: Flyway – Behind the Scenes
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flyway – 背后场景
- en: The log lines on the application's startup tell the whole story. Flyway records
    all migrations in a database table called `flyway_schema_history`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 应用启动时的日志行讲述了整个故事。Flyway将所有迁移记录在一个名为`flyway_schema_history`的数据库表中。
- en: 'You can have a look at the schema history table in the H2 console, if you want.
    Note, however, that the table really is called `flyway_schema_history`, in lowercase.
    To view everything in it, you can use SQL as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看模式历史表，可以在H2控制台中查看。请注意，实际上表的名字是`flyway_schema_history`，全部小写。要查看表中的所有内容，可以使用以下SQL语句：
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The same is true for all the columns:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有列也是同样的道理：
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The result will be the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是以下内容：
- en: '![](img/d40029c1-8fae-415a-991c-b21a2bcf83e1.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d40029c1-8fae-415a-991c-b21a2bcf83e1.png)'
- en: If the table does not exist yet, Flyway will create it on the fly, and that
    is what will happen on each start with our in-memory-only database. In such a
    case, the current version of the schema will be empty as well.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表尚不存在，Flyway将动态创建它，这就是我们使用仅内存数据库的每次启动会发生的情况。在这种情况下，当前模式的版本也将为空。
- en: Flyway finds all migrations on the classpath under `db.migration;` in our case,
    there are two files. All migration filenames start with the version number — an
    uppercase V followed by a number, which may be subdivided by single underscores
    or dots. Double underscores delimit the version number from an arbitrary name;
    this is the human-readable part. Flyway orders the migrations by the numerical
    value of their version. The leading zero in the previous names is only for proper
    lexical ordering in file views.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Flyway在我们的类路径下找到所有位于`db.migration;`的迁移，在我们的例子中，有两个文件。所有迁移文件名都以版本号开头——一个大写字母V后跟一个数字，该数字可能被单个下划线或点分隔。双下划线将版本号与任意名称分隔开；这是可读的部分。Flyway根据版本号的数值顺序排列迁移。前导零在之前的名称中仅用于在文件视图中进行正确的词法排序。
- en: Then, Flyway executes all migrations that have not already run (all of them
    in the initial case). Flyway will also compute a checksum of all of the files.
    Remember that once applied, a migration will not be executed again. Changing it
    would have no effect and is likely to be an error, so Flyway will refuse to continue
    if any checksum does not match anymore.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，Flyway将执行所有尚未运行的迁移（在初始情况下是所有迁移）。Flyway还会计算所有文件的总校验和。请记住，一旦应用了迁移，它将不会再次执行。更改它不会有任何效果，很可能是错误，因此如果任何校验和不匹配，Flyway将拒绝继续。
- en: Non-Trivial Migrations
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非平凡迁移
- en: The migrations seen so far allow you to evolve the database schema alongside
    the Java source code throughout the lifetime of the application. Flyway has two
    extensions that allow us to handle exceptional cases.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止看到的迁移允许您在应用程序的生命周期内与Java源代码一起演变数据库模式。Flyway有两个扩展允许我们处理异常情况。
- en: 'Sometimes, we may want to support different database systems with our codebase,
    for instance, an H2 database for testing and an Oracle database for production.
    Mostly we can use the same SQL, but not always. In this case, we can use vendor-specific
    SQL. To use that, we need to configure the path to the migrations to contain the
    vendor. One possible setting in our `application.properties` could be this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能希望支持我们的代码库中的不同数据库系统，例如，用于测试的H2数据库和用于生产的Oracle数据库。大多数情况下我们可以使用相同的SQL，但并不总是这样。在这种情况下，我们可以使用特定于供应商的SQL。要使用它，我们需要配置迁移路径以包含供应商。在`application.properties`中的可能设置之一可以是这个：
- en: '`spring.flyway.locations=db/migration/{vendor},db/migration`'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`spring.flyway.locations=db/migration/{vendor},db/migration`'
- en: The placeholder `{vendor}` will be replaced by the real database driver. For
    instance, when using MySQL, Flyway will search in `db/migration/mysql` first and
    then in `db/migration`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 占位符`{vendor}`将被实际的数据库驱动程序替换。例如，当使用MySQL时，Flyway将首先在`db/migration/mysql`中搜索，然后是`db/migration`。
- en: Another case may be when a migration includes complicated computations that
    cannot be done in SQL alone, or that are much easier to do in Java. For these
    cases, Flyway also supports Java migrations. Spring Boot makes using these a breeze.
    All we have to do is create beans that extend `BaseFlywayCallback`; the order
    can be specified with the `@Order` annotation. Within the bean, we can have the
    `Datasource` injected and use `JdbcTemplate` as we have already seen.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种情况可能是迁移包括复杂的计算，这些计算仅使用SQL无法完成，或者使用Java更容易完成。对于这些情况，Flyway也支持Java迁移。Spring
    Boot使得使用这些迁移变得非常简单。我们只需创建扩展`BaseFlywayCallback`的bean；可以使用`@Order`注解指定顺序。在bean内部，我们可以注入`Datasource`并使用`JdbcTemplate`，正如我们之前所看到的。
- en: Outlook – Advanced Database Support
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Outlook – 高级数据库支持
- en: To round things up, let's have one final look into some advanced sections that
    are otherwise outside the scope of this book.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结，让我们最后看一下一些高级章节，这些章节在其他方面超出了本书的范围。
- en: External Databases
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部数据库
- en: Up to now, we have made use of an in-memory database. Spring Boot did a lot
    of work for us behind the scenes. The database management system was auto-detected,
    started, and the connection to the database automatically established.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用了内存数据库。Spring Boot在幕后为我们做了很多工作。数据库管理系统被自动检测、启动，并且数据库连接自动建立。
- en: This setup is perfect for exploring database technology. It can also be used
    in production. H2 is lightweight and fast. It can also be configured to actually
    save all data to disk. Then it will be persistent, as long as that file survives.
    If you only have this one client (your application), and the data fits into your
    memory, H2 is an option to consider.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置非常适合探索数据库技术。它也可以用于生产环境。H2 是轻量级且快速的。它还可以配置为将所有数据实际保存到磁盘上。然后它将是持久的，只要那个文件存在。如果你只有一个客户端（你的应用程序），并且数据适合你的内存，H2
    是一个可以考虑的选项。
- en: 'Production-ready databases offer a plethora of other features. They can store
    more data, they can be distributed, have fail-over and backup strategies, security,
    multitenancy, and much more. These generally run on a host of their own. That
    brings us to the question of how to access them from Spring Boot. The solution
    is extremely simple. All we have to do is set three properties: the URL, the user,
    and the password. Here is an example:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 生产就绪的数据库提供了大量其他功能。它们可以存储更多数据，它们可以分布式部署，具有故障转移和备份策略，安全性，多租户，等等。这些通常运行在自己的主机上。这让我们想到了如何从
    Spring Boot 访问它们的问题。解决方案非常简单。我们只需要设置三个属性：URL、用户名和密码。以下是一个示例：
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Connection Pooling
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接池
- en: Getting a JDBC connection is quite a slow operation for most databases. It can
    take longer than the query itself. It is not efficient to get a new connection
    for each JDBC statement. However, using a connection for many statements requires
    very careful resource management.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数数据库来说，获取 JDBC 连接是一个相当慢的操作。它可能比查询本身还要长。为每个 JDBC 语句获取一个新的连接并不高效。然而，为许多语句使用一个连接需要非常仔细的资源管理。
- en: The standard technique to solve this challenge is to use a connection pool,
    where connections are held in a store for later reuse. A number of such pool implementations
    exist. To use one, we have to do nothing at all!
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个挑战的标准技术是使用连接池，其中连接被存储在存储中以便稍后重用。存在许多这样的池实现。要使用一个，我们实际上什么都不用做！
- en: Spring Boot will automatically use HikariCP as its connection pool when it is
    on the classpath. Since spring-boot-starter-jdbc depends on HikariCP, it is already
    found and configured with sensible defaults.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Spring Boot 在类路径上时，它会自动使用 HikariCP 作为其连接池。由于 spring-boot-starter-jdbc 依赖于
    HikariCP，它已经找到并使用合理的默认值进行了配置。
- en: If HikariCP is not on the classpath for some reason, the first fallback will
    be the Tomcat pooling `Datasource`, which you will also have available on a web
    project. It is actually hard not to get connection pooling with Spring Boot.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因 HikariCP 不在类路径上，第一个回退将是 Tomcat 池的 `Datasource`，你也会在 Web 项目中找到它。实际上，在
    Spring Boot 中不使用连接池是很困难的。
- en: Other Database Technologies – JPA and Spring Data
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他数据库技术 – JPA 和 Spring Data
- en: JPA is a Java standard to access a database that given a level of abstraction.
    It maps Java classes to database tables automatically or with the help of annotations,
    and is therefore also called an object-relational mapper, or ORM. The most widely
    known implementation of JPA is Hibernate, and the two terms are sometimes used
    interchangeably (even though falsely).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: JPA 是一个 Java 标准，用于访问数据库，它提供了一定程度的抽象。它自动或通过注解将 Java 类映射到数据库表，因此也被称为对象关系映射器，或
    ORM。JPA 最著名的实现是 Hibernate，这两个术语有时可以互换使用（即使是不正确的）。
- en: 'Spring Boot supports this with the spring-boot-starter-data-jpa POM. In addition
    to the normal JPA capabilities, this also includes Spring Data, a Spring sub-project
    that allows us to write DAOs (or repositories) by just creating the interface.
    Such a repository may just look like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 通过 spring-boot-starter-data-jpa POM 支持这一点。除了正常的 JPA 功能外，这还包括 Spring
    Data，这是一个 Spring 子项目，允许我们通过仅创建接口来编写 DAO（或存储库）。这样的存储库可能看起来就像这样：
- en: '[PRE23]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The **implementation** of this interface will be created on the fly upon startup.
    JPA may not be the best choice in every project.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口的**实现**将在启动时动态创建。JPA 并不是每个项目的最佳选择。
- en: Other Database Technologies – jOOQ
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他数据库技术 – jOOQ
- en: Accessing the database with JDBC has one serious drawback — by using SQL, we
    embed another language into our Java programs. The statements are hidden in strings.
    They will not be checked at compilation time, and they are not type-safe.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JDBC 访问数据库有一个严重的缺点——通过使用 SQL，我们将另一种语言嵌入到我们的 Java 程序中。这些语句在编译时不会被检查，并且它们不是类型安全的。
- en: There are a number of approaches to tackle this problem. IntelliJ IDEA offers
    great support for embedded languages in the ultimate edition, but relying solely
    on the IDE is not a good approach. The alternative is to have a tool that queries
    the database and generates Java classes from it that reflect the tables in the
    database.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题有几种方法。IntelliJ IDEA在终极版中为嵌入式语言提供了很好的支持，但仅依赖IDE并不是一个好的方法。另一种选择是拥有一个查询数据库并从中生成反映数据库中表的Java类的工具。
- en: 'jOOQ is one such product and it is supported directly by Spring Boot. It offers
    a fluent API that always starts with an object of the `DSLContext` class. If jOOQ
    is on the classpath, Spring Boot will automatically create such a DSLContext,
    connected to your global `Datasource`, as a Spring Bean. All we have to do is
    to wire it into a bean of ours and we can use it like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ就是这样一种产品，它直接由Spring Boot支持。它提供了一个始终以`DSLContext`类的对象开始的流畅API。如果jOOQ在类路径上，Spring
    Boot将自动创建这样的DSLContext，并将其连接到您的全局`Datasource`作为Spring Bean。我们只需将其连接到我们的一个Bean，就可以这样使用：
- en: '[PRE24]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Activity: Creating an SMS Application to Display Multiple Authors'
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：创建一个显示多个作者的短信应用程序
- en: '**Aim**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: To create a short message list that can show multiple authors for a single article.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个简短的消息列表，可以显示单篇文章的多个作者。
- en: '**Prerequisites**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**先决条件**'
- en: We build this activity upon the simple message app used in the last two chapters;
    for simplicity, it is stripped of the login. It already has a human-facing web
    frontend. You find the source code at [https://bit.ly/2BcfVW1](https://bit.ly/2BcfVW1).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个活动上建立了一个简单的消息应用程序，该应用程序在上一章中使用；为了简单起见，它去掉了登录功能。它已经有一个面向人类的前端。您可以在[https://bit.ly/2BcfVW1](https://bit.ly/2BcfVW1)找到源代码。
- en: '**Scenario**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: You have a working application that needs to evolve; messages can have more
    than one author now. We need changes to the schema, the existing data, the database
    access, and the view — we will cover a lot in one go!
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您有一个需要发展的工作应用程序；现在消息可以有多位作者。我们需要对模式、现有数据、数据库访问和视图进行更改——我们将一次性涵盖很多内容！
- en: '**Steps for Completion**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: To start, in the `ShortMessage` class, change the author field and change the
    repository when creating a message.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`ShortMessage`类中更改作者字段，并在创建消息时更改存储库。
- en: Change the Thymeleaf `index.html` view to accept multiple authors.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Thymeleaf的`index.html`视图更改为接受多个作者。
- en: Start the app now to verify that everything is displayed as it was before.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在启动应用程序以验证一切是否如之前一样显示。
- en: Add a new Flyway migration and you need a new table, so copy data from the message
    and finally drop the column ID.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的Flyway迁移，您需要一个新表，因此从消息中复制数据，最后删除ID列。
- en: Add the required code at the start of the `retrieveAll` method to make the repository
    compatible with the database.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`retrieveAll`方法的开头添加所需的代码，以使存储库与数据库兼容。
- en: Using this map from article IDs to authors, change the query and the implementation
    for the second `jdbcTemplate` execution.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用从文章ID到作者的映射，更改第二个`jdbcTemplate`执行的查询和实现。
- en: Start the app now to verify that everything is displayed as it was before.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在启动应用程序以验证一切是否如之前一样显示。
- en: Use the H2 console in another browser tab to add some co-authors and immediately
    see the results after reloading in the original tab.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个浏览器标签中使用H2控制台添加一些合著者，并在原始标签中重新加载后立即看到结果。
- en: 'Create a new migration, `V04__coauthors.sql`, with message–author links. When
    you start the application again, these are visible, as shown in this screenshot:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的迁移，`V04__coauthors.sql`，包含消息-作者链接。当您再次启动应用程序时，这些链接将可见，如本截图所示：
- en: '![](img/ffbb8d41-9848-4120-9c9f-4ab5381fec2b.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ffbb8d41-9848-4120-9c9f-4ab5381fec2b.png)'
- en: The short message list can show multiple authors for a single article.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的消息列表可以显示单篇文章的多个作者。
- en: Go to [https://bit.ly/2Mnhjaw](https://bit.ly/2Mnhjaw) to access the code for
    the `DatabaseIntroApplicationTests.java` file.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[https://bit.ly/2Mnhjaw](https://bit.ly/2Mnhjaw)访问`DatabaseIntroApplicationTests.java`文件的代码。
- en: Go to [https://bit.ly/2OiSCh4](https://bit.ly/2OiSCh4) to access the complete
    code for the `DatabaseIntroApplication.java` file for the solution.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[https://bit.ly/2OiSCh4](https://bit.ly/2OiSCh4)访问`DatabaseIntroApplication.java`文件的完整代码解决方案。
- en: To refer to the detailed steps, go to the *Solutions* section at the end of this
    book on page 263.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要参考详细步骤，请前往本书末尾的*解决方案*部分，第263页。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this final chapter of the Spring Boot book, our focus was on the data that
    applications process, and in particular on the data that they persist. Storing
    data in a database is paramount for many types of applications. We had a brief
    introduction into relational databases, the workhorses of the industry. Spring
    makes it easy to access those databases. You connected a lightweight in-memory
    database and saw how to connect to a production database. You then queried data
    from that database using SQL and Spring's support class, `JdbcTemplate`. To evolve
    the database alongside the application code, you then used Flyway migrations.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spring Boot 书的最后一章中，我们的重点是应用程序处理的数据，特别是它们持久化的数据。对于许多类型的应用程序来说，将数据存储在数据库中至关重要。我们简要介绍了关系数据库，这是行业的动力源泉。Spring
    使得访问这些数据库变得容易。你连接了一个轻量级的内存数据库，并看到了如何连接到生产数据库。然后，你使用 SQL 和 Spring 的支持类 `JdbcTemplate`
    从该数据库查询数据。为了与应用程序代码一起演进数据库，你随后使用了 Flyway 迁移。
- en: This rounds off the book. You have learned how to develop Spring Boot applications,
    how to develop web pages backed by Spring applications or offer REST APIs to customers,
    and how to interface with databases. Spring Boot and the Spring project have much
    more to offer, and that world is now at your fingertips.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书到此结束。你已经学会了如何开发 Spring Boot 应用程序，如何开发由 Spring 应用程序支持的网页或向客户提供 REST API，以及如何与数据库交互。Spring
    Boot 和 Spring 项目还有更多可以提供的内容，而这个世界现在就在你的指尖。
- en: Book Summary
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 书籍摘要
- en: In this book, you learnt about the basic building blocks of a Spring application,
    Spring application creation, and testing Spring applications. Then, we analyzed
    the MVC pattern, displaying and editing data using Thymeleaf, and RESTful APIs.
    Lastly, we implemented the basics of web application security and persisting data
    using a database.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，你了解了 Spring 应用程序的基本构建块，Spring 应用程序的创建，以及测试 Spring 应用程序。然后，我们分析了 MVC 模式，使用
    Thymeleaf 显示和编辑数据，以及 RESTful API。最后，我们实现了基于数据库的 Web 应用程序安全性和数据持久化的基本原理。
- en: Thank you!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢！
- en: 'Here are some closing words of wisdom:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些智慧的结束语：
- en: If in doubt, check [StackOverflow.com](https://stackoverflow.com/)!
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有疑问，请检查 [StackOverflow.com](https://stackoverflow.com/)！
- en: Read the Javadoc or even source code of the frameworks or libraries you use,
    it really helps!
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读你所使用的框架或库的 Javadoc 或甚至源代码，这真的很有帮助！
- en: Use open source frameworks and contribute patches and bug reports, or just report
    documentation errors.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用开源框架，贡献补丁和错误报告，或者只是报告文档错误。
