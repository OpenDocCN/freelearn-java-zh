- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Exploring Architectural Strategies and Cloud Usage
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索架构策略和云使用
- en: In this chapter, we will delve into the topic of architecture from the perspective
    of services. Specifically, we will explore the relationship between monolithic
    and microservices architectures and consider the benefits and drawbacks of each
    approach. We will also examine the use of event-driven architecture as a means
    of integrating these services. In addition to providing technical foundations,
    we will aim to provide strategic and contextual insights into how these concepts
    fit together and why they drive the adoption of various cloud service offerings.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从服务的角度深入探讨架构的话题。具体来说，我们将探讨单体架构和微服务架构之间的关系，并考虑每种方法的优缺点。我们还将检查使用事件驱动架构作为整合这些服务的方法。除了提供技术基础外，我们还将旨在提供战略性和情境性的见解，了解这些概念是如何相互结合的，以及为什么它们推动了各种云服务提供的采用。
- en: In this book, we will aim to not only provide a solid foundation in technical
    Java persistence concepts but also offer strategic and contextual insights into
    how these ideas are interconnected and why they contribute to the growing adoption
    of various cloud service offerings.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们的目标不仅是提供技术Java持久化概念的坚实基础，还要提供战略性和情境性的见解，了解这些想法是如何相互关联的，以及为什么它们有助于各种云服务提供的日益普及。
- en: 'This chapter covers the aforementioned topics throughout the following sections:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将在以下部分涵盖上述主题：
- en: The cloud’s influence on software architecture design
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云对软件架构设计的影响
- en: Design patterns – the essential building blocks for software architects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计模式 – 软件架构师的基本构建块
- en: Monolithic architecture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单体架构
- en: Microservices architecture
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构
- en: By the end of this chapter, you will have a deeper understanding of how the
    overall solution architecture affects data integration design and the pros and
    cons of using a combination of on-premises and cloud solutions, resulting in hybrid
    and/or multi-cloud models.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将更深入地理解整体解决方案架构如何影响数据集成设计，以及使用本地和云解决方案组合的优缺点，从而产生混合和/或多云模型。
- en: The cloud’s influence on software architecture design
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云对软件架构设计的影响
- en: While we could start by delving into the specific details of multiple architectural
    topics – including monolithic, microservices, SOA, event-driven, and event sourcing
    – we’re going to take a different approach. We’ll start by providing you with
    a deeper understanding of these patterns and their importance in software design.
    Having this background will help to broaden your horizons. Let’s explore a few
    design patterns in more detail.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以从深入研究多个架构主题的具体细节开始——包括单体、微服务、SOA、事件驱动和事件溯源——但我们将采取不同的方法。我们将首先为您提供对这些模式及其在软件设计中的重要性有更深入的理解。有了这个背景，将有助于拓宽您的视野。让我们更详细地探讨一些设计模式。
- en: Design patterns – the essential building blocks for software architects
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计模式 – 软件架构师的基本构建块
- en: 'Over the past few decades, we’ve identified and shared “*ideas that have been
    useful in one practical context and will probably be useful in others*,” as wisely
    said by Martin Fowler:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几十年里，正如Martin Fowler明智地所说：“*在一种实际情境中有用的想法，可能会在其他情境中也有用*”，我们已经识别并分享了“*在一种实际情境中有用的想法，可能会在其他情境中也有用*”：
- en: The constant flow of ideas, experiences, and solutions shared by tech enthusiasts
    worldwide converge into a rich knowledge base that drives and accelerates technological
    evolution.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 全世界技术爱好者分享的想法、经验和解决方案的持续流动，汇聚成一个丰富的知识库，推动和加速技术进化。
- en: Patterns describe solutions at different levels, from code-level practices to
    application-level practices. Among the hundreds of patterns out there, we will
    highlight the practices of design patterns, enterprise application patterns, and
    software architecture patterns to help us build a solid persistence layer.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 模式描述了不同级别的解决方案，从代码级别的实践到应用级别的实践。在数百种模式中，我们将突出设计模式、企业应用模式和软件架构模式的实践，以帮助我们构建一个坚实的持久化层。
- en: The **Gang of Four** (**GoF**) design patterns and the **Service-Oriented Architecture**
    (**SOA**) pattern were important foundations for the more recent Microservices
    Architecture and Event-Driven Architecture patterns.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**四人帮**（**GoF**）设计模式和**面向服务的架构**（**SOA**）模式是最近出现的微服务架构和事件驱动架构模式的重要基础。'
- en: Microservices architecture, which has gained popularity in recent years, is
    an approach to designing and building software systems as a collection of small,
    independently deployable services. This architecture pattern builds on the ideas
    of modularity and separation of concerns that were central to SOA but takes them
    to a deeper level.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来广受欢迎的微服务架构是一种将软件系统设计为一系列小型、独立可部署服务的架构方法。这种架构模式基于SOA的核心思想——模块化和关注点分离，但将其推向了更深的层次。
- en: People often adopt solutions that they don’t actually need because they lack
    the ability to analyze trends and navigate tech hype. It’s important to remember
    that the goal should be to identify the best solution to a specific problem using
    available technologies, rather than simply targeting the delivery of cloud-native
    microservices or other trendy solutions. The key is to understand how to solve
    a set of business problems using the right technology.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 人们常常采用他们实际上并不需要的解决方案，因为他们缺乏分析趋势和应对技术炒作的能力。重要的是要记住，目标应该是使用可用的技术来识别解决特定问题的最佳方案，而不是简单地针对云原生微服务或其他流行解决方案的交付。关键在于理解如何使用适当的技术来解决一系列商业问题。
- en: Thinking about tech trends – a few things to keep in mind
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑技术趋势——一些需要注意的事项
- en: A common way to decide whether a specific trend is appropriate for your scenario
    is to refer to its *technology adoption life cycle*. It brings market adoption
    insights that help you understand the topic’s current maturity; in other words,
    the more people adopting a specific solution, the more success cases will show
    up. Not only that but also horror stories, adoption challenges, pros and cons,
    recommendations, and so on will appear. Looking at the bigger picture, the different
    maturity groups provide more understanding about the market segments that are
    embracing the technology.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 判断特定趋势是否适合您场景的常见方法是参考其*技术采用生命周期*。它提供了市场采用洞察，有助于您了解该主题当前的成熟度；换句话说，采用特定解决方案的人越多，出现的成功案例就越多。不仅如此，还有恐怖故事、采用挑战、优缺点、推荐等等也会出现。从更广阔的角度来看，不同的成熟度群体提供了更多关于接受该技术的市场细分领域的理解。
- en: We now understand that patterns are a set of building blocks that can be used
    to achieve specific business goals. There are hundreds of patterns covering multiple
    levels and aspects of application solutions, and new patterns can be derived from
    the concepts of previous ones. It’s important to keep in mind that patterns can
    be combined and used in different ways to address different goals. For example,
    a Java service could adopt the repository pattern for its persistence layer, be
    built on best practices for a microservices architecture, use enterprise integration
    patterns to communicate with other services, follow the recommendations of 12-factor
    applications for cloud-native applications, and adopt design patterns for automated
    pipeline delivery.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在明白，模式是一组构建块，可以用来实现特定的商业目标。有数百种模式覆盖了应用解决方案的多个层次和方面，并且可以从先前模式的概念中派生出新的模式。重要的是要记住，模式可以组合并用于不同的方式来应对不同的目标。例如，一个Java服务可以为它的持久层采用存储库模式，基于微服务架构的最佳实践进行构建，使用企业集成模式与其他服务通信，遵循12因子应用的推荐进行云原生应用的构建，并采用设计模式以实现自动化管道交付。
- en: With this in mind, let’s delve into the pros and cons of different architectural
    options such as microservices and monolithic apps, taking into consideration fundamental
    needs and features.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们深入探讨不同架构选项（如微服务和单体应用）的优缺点，同时考虑基本需求和特性。
- en: Monolithic architecture
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单体架构
- en: 'A traditional way to build a solution is using **monolithic** applications,
    which are large, standalone software systems that are built as single, cohesive
    units, with all components being contained within a single package and compiled,
    managed, and deployed together:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 建立解决方案的传统方式是使用**单体**应用，这些是大型、独立的软件系统，作为单一、统一的单元构建，所有组件都包含在单个包中，并一起编译、管理和部署：
- en: '![Figure 3.1 – Monolithic application characteristics](img/Figure_3.01_B19375.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 单体应用特性](img/Figure_3.01_B19375.jpg)'
- en: Figure 3.1 – Monolithic application characteristics
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 单体应用特性
- en: This means that both the frontend and backend are included in the same artifact
    and must be compiled, managed, and deployed together. While this method can make
    it easier to initially develop and maintain the application, as the team grows,
    the maintenance of the code becomes more complex, and deploying updates becomes
    more challenging and time-consuming.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着前端和后端都包含在同一个工件中，必须一起编译、管理和部署。虽然这种方法可以使得最初开发和维护应用程序变得更容易，但随着团队的扩大，代码的维护变得更加复杂，部署更新变得更加具有挑战性和耗时。
- en: Performance-wise, scalability is impacted since it is very difficult to upscale
    or downscale specific features or components.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能方面，可扩展性受到影响，因为很难升级或降级特定的功能或组件。
- en: Defining the relationship between a database and a monolith is not a complex
    task. Instead of huge databases, some opt to develop monoliths that store and
    consume data from multiple databases – further increasing maintenance complexity.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 定义数据库和单体之间的关系并不复杂。有些人选择开发存储和消费来自多个数据库的数据的单体，这进一步增加了维护的复杂性。
- en: Surprisingly, it is possible to create modular applications using a monolithic
    architecture. Such applications can be designed in a modular fashion, with each
    module responsible for a specific set of functions and developed independently
    of the other modules.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 惊讶的是，使用单体架构可以创建模块化应用程序。这些应用程序可以以模块化的方式设计，每个模块负责一组特定的功能，并且独立于其他模块开发。
- en: Next, to verify its maturity, let’s refer to the broad market adoption and feedback.
    According to trend reports [2] from 2022, the modular monolithic architectural
    approach has already crossed the chasm and gained widespread adoption among the
    early majority group.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了验证其成熟度，让我们参考广泛的市场采用和反馈。根据2022年的趋势报告[2]，模块化单体架构方法已经跨越了鸿沟，在早期多数群体中得到了广泛采用。
- en: 'As with every architectural design, this approach has its advantages and disadvantages.
    We can analyze the benefits from multiple angles, including (but not restricted
    to) characteristics such as maintainability, deployment processes and frequency,
    validation processes, automation pipelines, and others. *Figure 3**.2* displays
    key topics to analyze when designing an app that can result in requiring different
    levels of effort and cost during each phase of the application life cycle. Some
    prioritize long-term benefits such as ease of maintenance. Others will prefer
    to adopt strategies with an easier and faster start:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与每个架构设计一样，这种方法有其优点和缺点。我们可以从多个角度分析其好处，包括但不限于可维护性、部署流程和频率、验证流程、自动化管道等。*图3.2* 显示了在设计应用程序时需要分析的关键主题，这些主题可能导致在应用程序生命周期的每个阶段都需要不同水平和成本的努力。有些人优先考虑长期利益，如易于维护。其他人可能更喜欢采用更容易、更快的启动策略：
- en: "![Fi\uFEFFgure 3.2 – Decision points during application design](img/Figure_3.02_B19375.jpg)"
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – 应用设计过程中的决策点](img/Figure_3.02_B19375.jpg)'
- en: Figure 3.2 – Decision points during application design
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 应用设计过程中的决策点
- en: The best choice will depend on each business need being addressed. In regard
    to the monolithic architectural style, it is established that its characteristics
    can represent a significant roadblock for the organization, particularly as the
    application grows in complexity with multiple development teams and numerous features.
    Changes and additions to the application in this environment become costly and
    scaling becomes difficult.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳选择将取决于每个业务需求。就单体架构风格而言，其特性已被证明可能成为组织的一个重大障碍，尤其是在应用程序随着多个开发团队和众多功能的增长而变得更加复杂时。在这种环境下，对应用程序的更改和添加变得成本高昂，扩展变得困难。
- en: In the face of the downsides of a monolith design inspired by the SOA approach,
    the concept of microservices comes into play. Microservices propose the decoupling
    of the components/modules into smaller services, each of which having their own
    unique responsibility.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 面对由SOA方法启发的单体设计的缺点，微服务概念应运而生。微服务提出将组件/模块解耦成更小的服务，每个服务都有其独特的职责。
- en: Even though microservices involve managing more failure points, a successful
    implementation allows for benefits such as independent teams, changes, deployments,
    and scaling of each service within the ecosystem, without affecting the other
    microservices. This is achieved when maintaining the principle of integrity of
    each individual service. Let’s delve further into the topic and examine the details
    more closely.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管微服务涉及管理更多的故障点，但成功的实施允许获得以下好处：独立团队、变更、部署以及生态系统中每个服务的扩展，而不会影响其他微服务。这是在维护每个个体服务完整性的原则下实现的。让我们进一步探讨这个主题，并更仔细地检查细节。
- en: Microservices architecture
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务架构
- en: Microservice-oriented architecture brings the idea of creating applications
    decoupled from each other and modeled according to their business domain. These
    applications are integrated through different protocols, and various communication
    patterns (REST, GRPC, and asynchronous events, among others) and integration patterns
    can be adopted. Using a microservice-oriented architecture facilitates quicker
    and more regular deliveries, as well as introducing a language-agnostic ecosystem.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务导向架构引入了创建彼此解耦且根据其业务领域建模的应用程序的想法。这些应用程序通过不同的协议和多种通信模式（如REST、GRPC和异步事件等）以及集成模式进行集成。使用微服务导向架构可以促进更快、更频繁的交付，并引入一种语言无关的生态系统。
- en: 'A microservices architecture has services that are decoupled and independent
    of other microservices that compose the broader solution. As Sam Newman states
    in his book *Building Microservices*, there are implicit concepts and behaviors
    expected from a microservice, as described in *Figure 3**.3*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构具有解耦且独立于构成更广泛解决方案的其他微服务的服务。正如Sam Newman在他的书《Building Microservices》中所言，从*图3.3*中可以隐含地了解微服务的概念和行为：
- en: '![Figure 3.3 – Microservices characteristics](img/Figure_3.03_B19375.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 微服务特征](img/Figure_3.03_B19375.jpg)'
- en: Figure 3.3 – Microservices characteristics
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 微服务特征
- en: 'Architects and developers should have in mind not only a core set of characteristics
    of a microservices architecture but also the critical elements that can result
    in immense risk to the project, such as the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 架构师和开发者不仅应该考虑微服务架构的核心特征，还应该考虑可能导致项目风险极大的关键要素，如下所述：
- en: '**Integration latency**: In a monolithic application, the components communicate
    directly in memory rather than over a network. The result is faster communication
    compared to the microservices scenario. However, as the number of services and
    architectural complexity increases, the risk of performance issues and latency
    increases – potentially becoming a catastrophic problem. To mitigate this risk,
    take it as a good practice to have proper monitoring and management of thresholds
    for a service’s invocation response time, including the capability of a client
    service to handle such issues by itself. A recommendation and good practice is
    to have fault tolerance capabilities in client microservices. For instance, clients
    should be able to retry previously failed invocations, have proper fallbacks (instead
    of shutting down due to errors), and be able to reestablish themselves once the
    requested service comes back to normal functioning.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成延迟**：在单体应用中，组件通过内存直接通信，而不是通过网络。与微服务场景相比，结果是通信更快。然而，随着服务数量和架构复杂性的增加，性能问题和延迟的风险也会增加——可能成为一个灾难性的问题。为了减轻这种风险，将适当的监控和管理服务调用响应时间的阈值作为良好实践，包括客户端服务自行处理此类问题的能力。一个建议和良好实践是在客户端微服务中具备容错能力。例如，客户端应该能够重试之前失败的调用，有适当的回退机制（而不是因为错误而关闭），并且一旦请求的服务恢复正常运行，能够重新建立自身。'
- en: '**Separation of duties**: Pay attention to the separation of duties of the
    backend and frontend components. One frontend may depend on multiple backend services.
    Frontend solutions must be implemented so that, in the event of failure of one
    of the requested backend services, only the specific associated features have
    their normal functioning interrupted – all other frontend components should still
    work properly, guaranteeing the best possible experience possible for the end
    user.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**职责分离**：注意后端和前端组件的职责分离。一个前端可能依赖于多个后端服务。前端解决方案必须实施，以便在请求的后端服务之一失败的情况下，只有特定的相关功能会中断其正常功能——所有其他前端组件应继续正常工作，确保为最终用户提供最佳可能体验。'
- en: '**Polyglot environment trap**: The microservice architecture is agnostic to
    languages and frameworks. Consequently, your environment can become a polyglot.
    From an architectural and technical leadership perspective, be thrifty in evaluating
    the technologies to be used so that you don’t end up with services implemented
    with technologies for whose maintenance you lack the required staff. The scope
    definition and the microservice size should be taken as measures for such definitions.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多语言环境陷阱**: 微服务架构对语言和框架是中立的。因此，您的环境可能成为多语言的。从架构和技术领导的角度来看，在评估要使用的科技时要节俭，以免最终使用缺乏所需人员维护技术的服务。范围定义和微服务大小应被视为此类定义的措施。'
- en: '**Service size and responsibility**: Determining an appropriate size and scope
    of a microservice may require the investment of time and effort upfront, at the
    beginning of the journey to decoupling. Remember to carefully consider the principle
    of single responsibility (**SOLID**) when measuring a service’s scope and size.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务大小和责任**: 确定一个微服务的大小和范围可能需要在解耦之旅开始时投入时间和精力。记住，在衡量服务范围和大小时要仔细考虑单一责任（**SOLID**）原则。'
- en: '**Forgotten services**: One of the governance challenges is to avoid the existence
    of orphaned applications in a productive environment. Try to avoid services without
    owners by establishing a team for each service, including during productive phases.
    With that, in the face of an unexpected problem or a new change request, it will
    be simpler to map and define who should be responsible for the tasks.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遗忘的服务**: 管理挑战之一是避免在生产环境中存在孤儿应用程序。通过为每个服务建立一支团队，包括在生产阶段，尽量减少没有所有者的服务。这样，面对意外问题或新的变更请求时，将更容易确定和定义谁应该负责这些任务。'
- en: '**Granular repositories**: Avoid breaking up projects into too many repositories,
    as this over-granulation can become an unmanageable scenario with more repositories
    than collaborators in the company.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**细粒度仓库**: 避免将项目拆分成过多的仓库，因为这种过度粒度化可能会在仓库数量超过公司合作者数量时变得难以管理。'
- en: Common pitfalls of microservices adoption
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务采用常见陷阱
- en: 'Microservices architecture adoption brings multiple implications and challenges,
    and as we should know by now, and as stated in the book *Fundamentals of Software
    Architecture: An Engineering Approach* ([https://www.amazon.com/dp/B08X8H15BW](https://www.amazon.com/dp/B08X8H15BW)),
    everything has trade-offs – and *microservices are* *no exception.*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构的采用带来了多重影响和挑战，正如我们现在所知道的，正如在《软件架构基础：工程方法》一书中所述（[https://www.amazon.com/dp/B08X8H15BW](https://www.amazon.com/dp/B08X8H15BW)），一切都有权衡——而且**微服务**也不例外。
- en: While initially thought to be a promising approach, the microservices journey
    has proven to be more complex than estimated by the broader tech industry, especially
    for small teams. As its adoption increased, we also observed more reports about
    a range of design issues and missteps. To avoid common pitfalls, it is important
    to watch out for the following mistakes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然最初被认为是一种有希望的方法，但微服务之旅已被证明比更广泛的科技行业估计的要复杂，尤其是对于小型团队。随着其采用的增加，我们也观察到更多关于各种设计问题和失误的报告。为了避免常见陷阱，重要的是要注意以下错误。
- en: Improperly breaking down domains into microservices
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不当地将领域拆分成微服务
- en: It is very easy to make mistakes when mapping the business problems down to
    domains, and domains to microservices, especially when starting the move to a
    microservices approach. This domain leads to solutions that require requests to
    multiple services to be able to retrieve a relevant set of business data, instead
    of providing it efficiently through a single request. In other words, regarding
    data retrieval and querying, an incorrect scope definition can lead to complex
    code implementation and poorly performing solutions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 将业务问题映射到领域，以及将领域映射到微服务时，很容易出错，尤其是在开始采用微服务方法时。这种领域导致需要向多个服务发出请求才能检索到相关的一组业务数据，而不是通过单个请求有效地提供。换句话说，在数据检索和查询方面，不正确的范围定义可能导致复杂的代码实现和性能不佳的解决方案。
- en: 'Here are some pointers to help guide you find the right path:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些有助于您找到正确路径的指南：
- en: Stakeholders and business experts are involved in the process of domain definition
    as they can give helpful inputs concerning domain boundaries
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利益相关者和业务专家参与领域定义的过程，因为他们可以就领域边界提供有价值的输入
- en: Microservices should have well-defined scope; be responsible for one “thing”
    and be able to do it well; have functionalities that easily fit together (in other
    words, that are cohesive); be independently deployable and scalable; and keep
    in mind that a monolith has higher chances of being more performant since processing
    happens all in memory, without extra network latency added during microservices
    integration
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务应该有明确的范围；负责一个“事物”并能做好；具有易于组合的功能（换句话说，就是具有内聚性）；能够独立部署和扩展；并且记住，单体架构由于所有处理都在内存中进行，没有在微服务集成期间增加额外的网络延迟，因此更有可能表现出更高的性能。
- en: 'Generally speaking, cross-domain services integration can rely on multiple
    strategies, such as the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，跨域服务集成可以依赖于多种策略，例如以下几种：
- en: Usage of an API gateway to route requests back and forth and filter, transform,
    and aggregate requested data from multiple sources in one client request
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用API网关来回路由请求，并从多个源中过滤、转换和聚合一个客户端请求中的请求数据
- en: Data denormalization across services which may result in data duplication in
    exchange of more efficient data retrieval and querying, relying on techniques
    such as event-driven architecture to reduce the number of requests needed to retrieve
    data, or, having event-driven services that can asynchronously filter, aggregate,
    enrich and provide access to relevant data
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务之间进行数据去规范化，这可能导致数据重复，但以更高效的数据检索和查询为代价，依赖于事件驱动架构等技术来减少检索数据所需的请求数量，或者拥有能够异步过滤、聚合、丰富并提供访问相关数据的基于事件驱动的服务
- en: Automation gap
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动化差距
- en: As development teams are broken down into smaller and more numerous groups,
    they start delivering more services, more frequently. The operations of these
    services’ life cycle shouldn’t obstruct their potential fast-paced evolution.
    **Continuous Integration and Continuous Deployment** (**CI/CD**) is a best practice
    for microservices and is essential for managing multiple services deployed across
    multiple deployment environments, ranging from on-premises machines to cloud services.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 随着开发团队被拆分成更小、数量更多的组，它们开始更频繁地交付更多服务。这些服务的生命周期操作不应阻碍它们的快速演变潜力。“持续集成和持续部署”（**CI/CD**）是微服务领域的最佳实践，对于管理跨多个部署环境部署的多个服务至关重要，这些环境从本地机器到云服务不等。
- en: Adopting as many languages and technologies as teams desire
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 采用团队希望尽可能多的语言和技术
- en: Deciding on programming languages is certainly one of the most intriguing topics.
    Even though programmers love to brag about programming languages that allow them
    to write ultra-short “Hello World” examples and base their decisions on this type
    of argument, to this day, we have not come across a single project that had a
    core business goal to output text into some sort of console, terminal, or even
    write HTML.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 决定编程语言无疑是众多引人入胜的话题之一。尽管程序员喜欢炫耀那些能让他们写出超短“Hello World”示例的编程语言，并以此为基础做出决定，但时至今日，我们还没有遇到过任何一个项目是以将文本输出到某种控制台、终端或甚至编写HTML作为核心业务目标的。
- en: A critical decision such as the programming language of a service should not
    be solely based on the number of lines or the line simplicity of a sample.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 像服务编程语言这样的关键决策不应仅基于示例代码的行数或行简单性。
- en: An application must become a microservice because it is big
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个应用程序必须成为微服务，因为它很大
- en: 'Kindly realize that not every large application *needs* to be a microservice.
    Here’s an interesting metric we’d like you to be familiar with: *cost per line*
    *of code.*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请认识到，并非每个大型应用程序*都需要*成为微服务。这里有一个我们希望您熟悉的有趣指标：*每行代码的成本*。
- en: ([https://medium.com/swlh/stop-you-dont-need-microservices-dc732d70b3e0](https://medium.com/swlh/stop-you-dont-need-microservices-dc732d70b3e0)).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ([https://medium.com/swlh/stop-you-dont-need-microservices-dc732d70b3e0](https://medium.com/swlh/stop-you-dont-need-microservices-dc732d70b3e0)).
- en: The cost mentioned in the link includes computational resources and manpower,
    including potential changes the organization processes will go through, and potential
    new software solutions such as containers and container orchestrators.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 链接中提到的成本包括计算资源和人力，包括组织流程可能经历的潜在变化，以及潜在的新的软件解决方案，如容器和容器编排器。
- en: Different from its counterpart, the monolith, in a microservices architecture,
    the smaller its code size, the higher the *cost per line of code*, as everything
    and everyone involved in the service’s existence is still required. Sadly, a successfully
    delivered microservice is only one part of what’s needed to solve the actual business
    problem.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 与单体架构（monolith）的对应物不同，在微服务架构（microservices architecture）中，代码规模越小，每行代码的成本就越高，因为服务存在所涉及的一切和每个人仍然都是必需的。遗憾的是，一个成功交付的微服务只是解决实际业务问题所需的一部分。
- en: Not taking the best out of independent microservices scaling
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 没有充分利用独立微服务的扩展性
- en: 'Scalability is one of the key advantages of microservices. However, it’s important
    to consider whether it makes sense to scale a component individually. In some
    cases, it may be more effective to scale the entire system together. Think about
    it: would it make sense to exclusively scale up unique, smaller parts of the broader
    solution?'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性是微服务的一个关键优势。然而，考虑是否单独扩展组件是有意义的很重要。在某些情况下，一起扩展整个系统可能更有效。想想看：是否只扩展更广泛解决方案中独特的、较小的部分是有意义的？
- en: Inconsistent data
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据不一致
- en: Microservices rely on data, and just as with any other distributed database,
    they’re subject to the CAP theorem. This means that whenever you have to update
    multiple services, you will end up with an added layer of complexity in your application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务依赖于数据，就像任何其他分布式数据库一样，它们都受到CAP定理的影响。这意味着每次你必须更新多个服务时，你将在应用程序中增加一层复杂性。
- en: One way to work through this is to adopt the SAGA pattern. However, this additional
    layer of complexity can often have a negative impact on the overall consistency
    of your data as well.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一种处理这个问题的方法是通过采用SAGA模式。然而，这个额外的复杂性层可能会对你的数据整体一致性产生负面影响。
- en: Beginning with microservices
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从微服务开始
- en: It’s generally a bad idea to assume your project will be based on microservices.
    This can lead to big problems down the road, especially when it comes to domain
    definition. Small mistakes can result in several incorrect interdependencies between
    services and tight coupling. This is why many experts recommend using joins when
    handling relational data or subdocuments when working with a NoSQL database such
    as MongoDB.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，假设你的项目将基于微服务是不明智的。这可能导致未来出现大问题，尤其是在领域定义方面。小错误可能导致服务之间出现多个错误的相互依赖和紧密耦合。这就是为什么许多专家建议在处理关系型数据时使用连接，在处理如MongoDB这样的NoSQL数据库时使用子文档。
- en: While joins are a powerful feature in relational databases that allow us to
    combine data from different tables using foreign keys, they can be inefficient
    and time-consuming in NoSQL databases, especially for large datasets. This is
    because joins require multiple queries to be executed and can result in significant
    network traffic and resource consumption.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然连接（joins）是关系型数据库中一个强大的功能，它允许我们通过外键（foreign keys）将不同表中的数据结合起来，但在NoSQL数据库中，尤其是在处理大数据集时，连接可能会变得低效且耗时。这是因为连接需要执行多个查询，可能会导致大量的网络流量和资源消耗。
- en: In addition, NoSQL databases are optimized for query performance based on the
    access patterns and usage of the application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，NoSQL数据库根据应用程序的访问模式和用法进行了查询性能优化。
- en: Therefore, it is generally recommended to model the data to minimize the need
    for joins and use denormalization and embedding techniques to combine related
    data into a single document.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通常建议对数据进行建模，以最小化连接的需求，并使用反规范化（denormalization）和嵌入（embedding）技术将相关数据组合成单个文档。
- en: However, there may be some cases where joins are necessary for NoSQL databases.
    In those cases, NoSQL databases offer different ways to perform joins, such as
    using `$lookup` in MongoDB or MapReduce, designed to work more efficiently with
    the NoSQL data model.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，对于NoSQL数据库来说，连接可能是必要的。在这些情况下，NoSQL数据库提供了不同的方法来执行连接，例如在MongoDB中使用`$lookup`或MapReduce，这些方法旨在更有效地与NoSQL数据模型协同工作。
- en: Tip – references for common mistakes when adopting microservices
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 - 采用微服务时常见的错误参考
- en: There’s no need to feel discouraged by the challenges presented here; when the
    architecture is used correctly and in favorable scenarios, it fits perfectly.
    The point is, *there is no Holy Grail or* *silver bullet*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要因为这里提出的挑战而感到气馁；当架构被正确使用并在有利的情况下使用时，它非常适合。关键是，*没有圣杯或银弹*。
- en: 'If you want to keep on learning about common mistakes when adopting microservices,
    refer to the following reading recommendations: Ebin John’s *Stop, you don’t need
    microservices* ([https://medium.com/swlh/stop-you-dont-need-microservices-dc732d70b3e0](https://medium.com/swlh/stop-you-dont-need-microservices-dc732d70b3e0))
    and *Should I use Microservices? by Sam* *Newman* ([https://www.oreilly.com/content/should-i-use-microservices/](https://www.oreilly.com/content/should-i-use-microservices/)).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想继续了解采用微服务时的常见错误，请参考以下阅读推荐：Ebin John的《停止，你不需要微服务》([https://medium.com/swlh/stop-you-dont-need-microservices-dc732d70b3e0](https://medium.com/swlh/stop-you-dont-need-microservices-dc732d70b3e0))和Sam
    Newman的《我应该使用微服务吗？》([https://www.oreilly.com/content/should-i-use-microservices/](https://www.oreilly.com/content/should-i-use-microservices/))。
- en: We have so far outlined the concepts of monolithic and microservices architecture,
    explored the three main cloud delivery models, IaaS, PaaS, and SaaS, and learned
    that they can be combined to best fit an organization’s needs.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止概述了单体和微服务架构的概念，探讨了三种主要的云交付模型：IaaS、PaaS和SaaS，并了解到它们可以组合起来以最佳满足组织的需要。
- en: Next, let’s expand on cloud deployment models and how having multiple cloud
    deployment options can help teams to shorten development cycles, fill knowledge
    gaps, and allow teams to apply their knowledge and effort more productively.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们进一步探讨云部署模型，以及拥有多个云部署选项如何帮助团队缩短开发周期、填补知识空白，并使团队能够更有效地应用他们的知识和努力。
- en: Cloud deployment strategies that favor modern stateful solutions
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 倾向于现代有状态解决方案的云部署策略
- en: A cloud deployment model allows applications to rely on an infrastructure that
    has on-demand usage, elasticity, resiliency, measured access, and other fundamental
    aspects. Let’s have a look at deployment model strategies, such as public and
    private clouds, how to derive two combinations of them through the hybrid and
    multi-cloud models, and how best to leverage the available cloud deployment strategies
    to deliver stateful applications efficiently.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 云部署模型允许应用程序依赖于具有按需使用、弹性、容错性、可测量访问和其他基本方面的基础设施。让我们来看看部署模型策略，例如公有云和私有云，如何通过混合和多云模型推导出两种组合，以及如何最佳地利用可用的云部署策略来高效地交付有状态应用程序。
- en: Why the hybrid and multi-cloud models matter
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么混合和多云模型很重要
- en: In the search for better flexibility, access to vendor-specific capabilities,
    integration options, and cost reduction, combinations of cloud deployment models
    have started to be used more frequently. Organizations have started to combine
    public and private deployment models and benefit from both private cloud with
    public cloud services, with a **hybrid cloud** model. Another strategy used is
    the **multi-cloud** model, which isused when there’s a need to run or consume
    the same service type from different vendors.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在寻求更好的灵活性、访问供应商特定功能、集成选项和降低成本的过程中，云部署模型的组合已经开始被更频繁地使用。组织开始结合公有和私有部署模型，并从私有云和公有云服务中受益，采用**混合云**模型。另一种策略是**多云**模型，当需要从不同供应商运行或消费相同类型的服务时使用。
- en: When you combine both public and private clouds and leverage similar cloud services
    from multiple vendors, you are then working with a **hybrid multi-cloud** **deployment
    model**.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当你结合公有云和私有云，并利用多个供应商提供的类似云服务时，你正在使用一个**混合多云****部署模型**。
- en: Note
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the best deployment model isn’t the one with the highest number of
    words in its name – the best model is the one that solves your organization’s
    existing problems.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，最佳的部署模型并不是名字中单词数量最多的那个——最佳的模型是解决你组织现有问题的那个。
- en: 'What with the amount of different technologies and solutions out there, it
    is natural that teams won’t be able to build expertise in every single technology.
    The fact that it is hard to build a suitably diverse team – in terms of expertise
    – results in one of two possibilities: a poorly managed and maintained underlying
    persistence infrastructure or a restricted set of options to be used by developers.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现有技术和解决方案的种类繁多，团队不可能在每种技术上都具备专业知识。难以组建一个在专业知识方面足够多元化的团队，这导致两种可能性：一个管理不善和维护不佳的基础持久化基础设施，或者开发者可用的选项受限。
- en: 'Since data management is such a business-critical component, it shouldn’t be
    overlooked. That is where we can relate to our cloud story: *would it be possible
    for our business to delegate the management of data storage responsibility to
    someone else?* At this point, we understand that hybrid and multi-cloud models
    can provide the easy scaling up and down of several types of cloud computing resources.
    *If only we had a database with* *such capabilities…*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据管理是如此关键的业务组件，因此不应被忽视。这就是我们可以与我们云故事联系起来之处：*我们的业务是否可以将数据存储管理的责任委托给他人？* 在这一点上，我们理解混合和多云模型可以提供几种类型云计算资源的轻松扩展和缩减。*如果我们有一个具有*
    *这样能力的数据库…*
- en: It turns out we do have one – it is called **Database as a** **Service** (**DBaaS**).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 结果我们发现确实有一个——它被称为**数据库即服务**（**DBaaS**）。
- en: Besides being able to get everything up and running quickly, using DBaaS, it
    is possible to delegate complex tasks such as monitoring, version maintenance,
    security patches maintenance, disaster recovery, and backup. Beyond that, it makes
    it possible to adopt data storage technologies for which there are no specialized
    professionals in the team yet, facilitating the freedom of choice to pick the
    best solution for each scenario. However, if there’s a need to directly access
    the servers that are running the databases or have full control over sensitive
    data being transferred and stored, DBaaS is not a viable solution. Examples of
    DBaaS offerings available in the market today are Amazon RDS, AWS Aurora MySQL,
    Microsoft Azure SQL Database, ScyllaDB, and MongoDB Atlas.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够快速启动和运行一切之外，使用DBaaS，还可能将复杂的任务如监控、版本维护、安全补丁维护、灾难恢复和备份委托出去。除此之外，它还使得采用团队中尚无专业人员的存储技术成为可能，从而便于为每种场景选择最佳解决方案。然而，如果需要直接访问运行数据库的服务器或对传输和存储的敏感数据进行完全控制，DBaaS则不是一个可行的解决方案。目前市场上可用的DBaaS提供示例包括Amazon
    RDS、AWS Aurora MySQL、Microsoft Azure SQL Database、ScyllaDB和MongoDB Atlas。
- en: 'And this is where you get the best of both worlds when architecting solutions:
    by using decoupled and independent services, you can rely on public cloud services
    such as DBaaS offerings where they fit, exclusively for the particular services
    in need, and rely on on-premises data storage solutions for the services that
    can’t deal with the disadvantages of a public cloud offering.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在架构解决方案时，这正是你得到两者之最佳之处：通过使用解耦和独立的服务，你可以在适合的地方依赖公共云服务，如DBaaS提供的服务，专门用于特定需要的服务，而对于无法处理公共云提供服务的服务的，则依赖本地数据存储解决方案。
- en: With distributed services across these different deployment models, services
    integration is a critical architectural aspect to consider.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些不同的部署模型中，分布式服务，服务集成是一个需要考虑的关键架构方面。
- en: Distributed systems and their impact on data systems
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式系统及其对数据系统的影响
- en: 'Microservices are small pieces of a big puzzle: each piece can only serve its
    true value once the whole puzzle is put together. The qualities of reliability,
    resiliency, and scalability should not be catered to at each individual service
    level, but actually, for the proposed integration solution; after all, we agree
    with Martin Fowler’s idea that integration should be treated as strategic to businesses.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是大拼图中的一小部分：每个组件只有在整个拼图拼好之后才能发挥其真正的价值。可靠性、弹性和可伸缩性这些品质不应在每个单独的服务级别上被考虑，而实际上，对于所提出的集成解决方案；毕竟，我们同意马丁·福勒的观点，即集成应被视为对业务具有战略意义。
- en: '*“A microservice-based solution’s performance is only as good as the ability
    of its individual components to* *communicate efficiently.”*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*“基于微服务的解决方案的性能仅与其各个组件高效沟通的能力相当。”*'
- en: Example – architecting a food delivery solution
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 - 架构食品配送解决方案
- en: 'In distributed architectures, handling data integration across services can
    be difficult. Therefore, we are about to explore architectural concepts and mistakes
    around integration through a simple example – a microservice-based solution for
    a food delivery website. Narrowing down the scope, the discussion takes into consideration
    the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式架构中，处理跨服务的数据集成可能会很困难。因此，我们将通过一个简单的例子来探讨围绕集成的架构概念和错误——一个基于微服务的食品配送网站解决方案。缩小范围，讨论考虑以下内容：
- en: The microservices backend layer
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务后端层
- en: The microservices data storage
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务数据存储
- en: The cross-services integration
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨服务集成
- en: Next, let’s look at how the solution is initially drafted as a microservice
    architecture, and how the integration of these services can highly affect data
    management and consistency across services.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看这个解决方案最初是如何作为一个微服务架构起草的，以及这些服务的集成如何极大地影响数据管理和一致性。
- en: The basic scenario
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本场景
- en: 'In the early development phases, it may look like a non-problematic scenario.
    For the food delivery example, picture a solution, represented in *Figure 3**.4*,
    composed of four microservices, each backed by its persistence and data storage
    strategy: **Order Service**, **Payment Service**, **Kitchen Service**, and **Delivery
    Service**. The figure represents the microservices, each with its own persistent
    storage.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期开发阶段，它可能看起来像是一个非问题场景。对于食品配送的例子，想象一个解决方案，如图*图3**.4*所示，由四个微服务组成，每个微服务都有自己的持久性和数据存储策略：**订单服务**、**支付服务**、**厨房服务**和**配送服务**。该图表示了微服务，每个微服务都有自己的持久存储。
- en: '![Figure 3.4 – Food delivery service’s representation](img/Figure_3.04_B19375.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – 食品配送服务的表示](img/Figure_3.04_B19375.jpg)'
- en: Figure 3.4 – Food delivery service’s representation
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 食品配送服务的表示
- en: 'The happy path of this sample is this: whenever a customer creates and pays
    for a new *order*, the kitchen cooks it and sends it over to the delivery team,
    which in turn delivers the order to the customer. *Figure 3**.5* demonstrates
    the new-order process from creation to delivery, where the business flow is processed
    across the four independent microservices.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的“快乐路径”是这样的：每当客户创建并支付新的*订单*时，厨房就会烹饪并把它送到配送团队，配送团队随后将订单送到客户手中。*图3**.5*展示了从创建到配送的新订单流程，其中业务流程在四个独立的微服务之间处理。
- en: "![Figure 3.5 – Food delivery business’s requirement\uFEFFs](img/Figure_3.05_B19375.jpg)"
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 – 食品配送业务的需求](img/Figure_3.05_B19375.jpg)'
- en: Figure 3.5 – Food delivery business’s requirements
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 食品配送业务的需求
- en: 'From a technical standpoint, this business requirement can be described as
    follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术角度来看，这个业务需求可以这样描述：
- en: '**Order Service**: Registers a new order 0001'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**订单服务**：记录新的订单0001'
- en: '**Payment Service**:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**支付服务**：'
- en: Registers the required payment for order 0001
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录订单0001所需的付款
- en: Registers a successful payment of order 0001
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录订单0001的成功付款
- en: '**Kitchen Service**:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**厨房服务**：'
- en: Notifies incoming order 0001
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通知订单0001的到来
- en: Registers that order 0001 is being prepared
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录订单0001正在准备中
- en: Registers that order 0001 is ready for delivery
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录订单0001已准备好配送
- en: '**Delivery Service**:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**配送服务**：'
- en: Notifies that order 0001 is ready to go to its customer
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通知订单0001已准备好发送给客户
- en: Registers delivery of 0001 as completed
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录0001的配送已完成
- en: To grasp the nuances of this seemingly straightforward business requirement,
    we must go into the technicalities and explore the various obstacles and potential
    solutions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要掌握这个看似简单的业务需求的细微差别，我们必须深入了解技术细节，并探索各种障碍和潜在解决方案。
- en: Could this solution be a monolith? Yes, it could. However, delivery services,
    especially those that are spread across multiple customers/order providers/delivery
    providers, are built on an extensive list of business needs not covered in a simple
    example used for learning purposes. The architectural solutions for and business
    needs of real-world delivery services such as Uber Eats and DoorDash are good
    examples of complex, real-world scenarios.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案是否可以是单体架构？是的，可以。然而，配送服务，尤其是那些跨越多个客户/订单提供者/配送提供者的服务，是基于一个广泛的业务需求列表构建的，这些需求在用于学习目的的简单示例中没有涵盖。现实世界中的配送服务，如Uber
    Eats和DoorDash的架构解决方案和业务需求，是复杂、现实场景的好例子。
- en: This solution’s microservice has an independent database, which not only aligns
    with the microservice’s ideas but also brings a good level of encapsulation and
    reduces the number of errors caused by changes (e.g., schema changes).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案的微服务有一个独立的数据库，这不仅符合微服务的理念，而且也带来了良好的封装水平，减少了因变更（例如，模式变更）引起的错误数量。
- en: The challenges of integrating services around a central piece of data
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 围绕中心数据集成的挑战
- en: 'Even though all four services are designed to be *independent*, they all function
    around one key feature: the *order*. And a problem regarding this data appears:
    *how do you manage and handle order data across the* *four services*?'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管所有四个服务都被设计成**独立**的，但它们都围绕一个关键功能运作：**订单**。并且出现了关于这个数据的问题：*如何在四个服务之间管理和处理订单数据*？
- en: Microservices’ shared database
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微服务的共享数据库
- en: 'Some could leverage data storage as the integration layer for these services,
    having a single schema holding not only the order details but also the payment,
    kitchen, and delivery information as well. Unfortunately, this is an inadvisable
    solution known as shared databases (a.k.a. integration databases). *Figure 3**.6*.
    shows that in this case, all services rely on a single schema to maintain an order’s
    information:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一些服务可以利用数据存储作为这些服务的集成层，拥有一个单一的模式，不仅包含订单详情，还包括支付、厨房和配送信息。不幸的是，这是一个不可取的解决方案，被称为共享数据库（也称为集成数据库）。*图3.6*显示，在这种情况下，所有服务都依赖于一个单一的模式来维护订单信息：
- en: "![Figure 3.6 – Shared database ant\uFEFFi-pattern](img/Figure_3.06_B19375.jpg)"
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6 – 共享数据库反模式](img/Figure_3.06_B19375.jpg)'
- en: Figure 3.6 – Shared database anti-pattern
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – 共享数据库反模式
- en: 'In the preceding example, a service implementation may look simple since it
    doesn’t have to handle integration aspects. However, multiple problems were added
    to the solution, and design principles were broken:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的例子中，服务实现可能看起来很简单，因为它不需要处理集成方面。然而，解决方案中增加了多个问题，并破坏了设计原则：
- en: Microservices should be decoupled and independent.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务应该是解耦和独立的。
- en: Bottlenecks and performance impacts, as well as unexpected exceptions such as
    lock exceptions.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 瓶颈和性能影响，以及意外的异常，如锁异常。
- en: Involvement of multiple business areas since bounded contexts are not respected.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于边界上下文不受尊重，涉及多个业务领域。
- en: Changes to the database may require changes to all services.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库的更改可能需要更改所有服务。
- en: Multiple services acting on the same data might lead to inconsistency.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对同一数据进行操作的多项服务可能会导致不一致。
- en: Higher risk of bugs and errors. For instance, a change made to one service that
    is not expected by all other services.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更高的错误和故障风险。例如，对某个服务所做的更改，其他所有服务都没有预料到。
- en: Considering the aforementioned problems and many more, it becomes easy to see
    that this is not a good route.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到上述问题以及更多问题，很容易看出这不是一个好的选择。
- en: Dual-write anti-pattern
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 双写反模式
- en: Trying to avoid the aforementioned problems, we might consider having independent
    services, each with its respective database. However, in this solution, services
    do not maintain a copy of the order on their databases, but they should also update
    the order status both in their databases and in the order service’s database.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免上述问题，我们可能会考虑拥有独立的服务，每个服务都有自己的数据库。然而，在这个解决方案中，服务在其数据库中不保留订单的副本，但它们也应该在它们的数据库和订单服务数据库中更新订单状态。
- en: 'In *Figure 3**.6*, observe that the order service is independent and maintains
    order data in its data storage. However, other services rely on replicating order
    data in their own databases and maintaining an order’s status in both databases
    – their own and the order service’s:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图3.6*中，观察订单服务是独立的，并在其数据存储中维护订单数据。然而，其他服务依赖于在其自己的数据库中复制订单数据，并在两个数据库中维护订单状态——它们自己的和订单服务的：
- en: "![Figure 3.7 – Dual-write anti-pattern\uFEFF](img/Figure_3.07_B19375.jpg)"
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图3.7 – 双写反模式](img/Figure_3.07_B19375.jpg)'
- en: Figure 3.7 – Dual-write anti-pattern
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – 双写反模式
- en: 'And this, dear reader, is yet another anti-pattern: the *dual-write* anti-pattern.
    It brings high chances of ending up with inconsistent data and integrity issues,
    as it is not possible to ensure that both writes will complete successfully or
    none at all, as in a single transaction. It’s a common mistake in scenarios such
    as handling distributed data systems, using exclusive data storage for analytics,
    implementing dedicated search index tools, and designing event-driven solutions
    (e.g., writing the same data to a database and Kafka).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 亲爱的读者，这又是一个反模式：*双写*反模式。它带来了很高的可能性导致数据不一致和完整性问题，因为它无法确保两次写入都能成功完成，或者都不完成，就像在单一事务中一样。这在处理分布式数据系统、使用专用于分析的独占数据存储、实施专用的搜索索引工具和设计事件驱动解决方案（例如，将相同的数据写入数据库和Kafka）等场景中是一个常见的错误。
- en: 'Right upfront, we’ve highlighted two red flags for distributed architecture
    regarding data access and management:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先明确，我们在分布式架构的数据访问和管理方面指出了两个红旗：
- en: The first is that a service should not directly change any data owned and consumed
    by another service, as represented by the arrows in *Figure 3**.7*, where all
    services are modifying data in the order service’s database
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一，一个服务不应直接更改任何由其他服务拥有和消费的数据，如图3.7中的箭头所示，其中所有服务都在修改订单服务的数据库中的数据
- en: The second is that one service should *not* be responsible for, or act upon,
    the manipulation and maintenance of data persistence and consistency across multiple
    data storage solutions, including not only cross-services as shown in *Figure
    3**.5* but also between different data storage types as exemplified in *Figure
    3**.6*
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二点是，一个服务**不应**负责或对多个数据存储解决方案（包括但不限于*图3.5*中所示的服务间，以及*图3.6*中所示的不同数据存储类型）的数据持久性和一致性进行操作和维护。
- en: Both anti-patterns, as well as use cases and potential solutions and strategies
    for data integration, are explored in great depth in [*Chapter 10*](B19375_10.xhtml#_idTextAnchor175)
    and [*Chapter 11*](B19375_11.xhtml#_idTextAnchor184). For now, it is enough to
    have the awareness that *there are anti-patterns in distributed data service integration*
    that can result in performance bottlenecks, data inconsistency, and reliability
    loss.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第10章*](B19375_10.xhtml#_idTextAnchor175)和[*第11章*](B19375_11.xhtml#_idTextAnchor184)中，深入探讨了反模式、用例以及数据集成的潜在解决方案和策略。目前，只需意识到在分布式数据服务集成中存在可能导致性能瓶颈、数据不一致和可靠性损失的反模式就足够了。
- en: At this point, we can better comprehend why integration shows itself as a crucial
    architectural aspect for delivering modern microservices-based solutions. Next,
    let’s take a look at another way to integrate distributed services by relying
    on event-driven architecture for asynchronous data integration.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们更好地理解了为什么集成是提供基于现代微服务解决方案的关键架构方面。接下来，让我们看看另一种通过依赖事件驱动架构进行异步数据集成的方式来整合分布式服务。
- en: Unveiling change data capture for data integration
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 揭示数据集成中的变更数据捕获
- en: Services integration can be synchronous or asynchronous and can use different
    mechanisms and take different forms, such as file-based, shared database, message-based,
    API-based (e.g., REST, SOAP), event-driven, and many more. For the purposes of
    this book, we will consider aspects of **Event-Driven Architecture** (**EDA**),
    as it enables the usage of data integration patterns such as **change** **data
    capture**.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 服务集成可以是同步的或异步的，可以使用不同的机制和形式，例如基于文件、共享数据库、基于消息、基于API（例如REST、SOAP）、事件驱动等。为了本书的目的，我们将考虑**事件驱动架构**（**EDA**）的方面，因为它使得使用如**变更数据捕获**这样的数据集成模式成为可能。
- en: 'Technologies around event-driven patterns were created to allow databases –
    even traditional ones – to have a new capability: emit events. You read that correctly;
    it is possible for traditional relational databases (and other databases as well)
    to go beyond the basics and allow developers to rely on Change Data Capture.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动模式相关的技术被创建出来，以便数据库——即使是传统的数据库——能够拥有新的能力：发出事件。您读对了；传统的关系型数据库（以及其他数据库）可以超越基础功能，并允许开发者依赖变更数据捕获。
- en: With Change Data Capture, database operations can be captured and emitted as
    events by a component external to the database and microservices of the solution.
    With this, developers are able to create event-driven services that can then react
    and respond to the aforementioned data events, or “notifications.”
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用变更数据捕获，数据库操作可以被捕获并由解决方案的数据库和微服务之外的组件作为事件发出。有了这个，开发者可以创建能够对上述数据事件或“通知”做出反应和响应的事件驱动服务。
- en: As you might have expected, EDA is not all sunshine and roses. Understanding
    what’s happening throughout a single business flow can be quite overwhelming in
    this architectural style when multiple services and a high number of events are
    involved. Troubleshooting can also be extremely complex since the tracking process
    isn’t linear and does not happen in unique transactions. When working with EDA,
    forget about automatic rollbacks.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所预期的那样，EDA并非全是阳光和玫瑰。当涉及多个服务和大量事件时，在这种架构风格中理解整个业务流程中发生的事情可能会相当令人不知所措。故障排除也可能极其复杂，因为跟踪过程不是线性的，并且不会在唯一的交易中发生。当与EDA一起工作时，请忘记自动回滚。
- en: Even though each of the mentioned challenges can be addressed or mitigated,
    notice these are only some of the items in a list of potential drawbacks for EDA;
    therefore, don’t forget to do your evaluations for the scenario in question, and
    validate whether EDA is the best solution for it or not.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管每个提到的挑战都可以被解决或减轻，但请注意，这些只是EDA潜在缺点列表中的一部分；因此，不要忘记对特定场景进行评估，并验证EDA是否是最佳解决方案。
- en: Knowing the integration benefits offered by EDA is crucial to integrating your
    services without breaking patterns, best practices, and recommendations, and is
    critical to ensuring that you reap the benefits of asynchronous, highly scalable
    integration.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 了解EDA提供的集成优势对于在不破坏模式、最佳实践和推荐的情况下集成您的服务至关重要，并且对于确保您能够获得异步、高度可扩展集成的益处至关重要。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: At this point, we have examined the influence of cloud technology on software
    architecture design and the importance of design patterns as building blocks for
    software architects. We compared monolithic and microservices architectures, shedding
    light on their advantages and disadvantages.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经探讨了云计算技术对软件架构设计的影响以及设计模式作为软件架构师构建块的重要性。我们比较了单体架构和微服务架构，揭示了它们的优缺点。
- en: We also explored cloud deployment strategies such as hybrid and multi-cloud
    models, and how these strategies, combined with managed services such as DbaaS,
    can speed up the development and delivery of stateful solutions. On the other
    hand, we also discovered that how we integrate data in distributed systems can
    impact data management and usage directly. When integrating distributed stateful
    service, we now know we must be cautious about using anti-patterns such as shared
    databases and “dual-writes”.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了云部署策略，如混合云和多云模型，以及这些策略如何与如DbaaS之类的托管服务相结合，以加快有状态解决方案的开发和交付。另一方面，我们也发现了我们在分布式系统中如何集成数据可以直接影响数据管理和使用。当集成分布式有状态服务时，我们现在知道我们必须谨慎使用如共享数据库和“双重写入”之类的反模式。
- en: At the end of the chapter, we unveiled the potential of Change Data Capture
    for data integration in EDA, which increases architectural complexity (more components
    and technologies) in exchange for a completely decoupled and asynchronous integration.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章末尾，我们揭示了Change Data Capture在EDA中用于数据集成的潜力，这通过增加架构复杂性（更多组件和技术）来换取完全解耦和异步的集成。
- en: After discussing architectural and deployment model choices, we will next dive
    deeper into leveraging design patterns for data management in cloud-native applications,
    building upon the foundations laid in this chapter.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了架构和部署模型选择之后，我们将进一步深入探讨利用设计模式进行云原生应用数据管理的策略，基于本章奠定的基础。
