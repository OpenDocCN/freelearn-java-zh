- en: Chapter 5. Defining a REST Service Using Akka HTTP DSL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章。使用 Akka HTTP DSL 定义 REST 服务
- en: 'In this chapter, we''ll look at the successor to one of the most popular REST
    frameworks available in the Scala space, called **Spray**. Spray has been around
    for a couple of years, and provides a very extensive **domain-specific language**
    (**DSL**), which you can use to define your REST services. Spray itself isn''t
    being actively developed and has merged into the Akka HTTP initiative provided
    by Typesafe. The DSL structure and way you create REST services, however, hasn''t
    changed that much. So in this chapter, we''ll explore the following features provided
    by Akka HTTP''s DSL:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 Scala 空间中最受欢迎的 REST 框架之一的后续者，称为 **Spray**。Spray 已经存在了几年，并提供了一个非常广泛的
    **领域特定语言**（**DSL**），你可以使用它来定义你的 REST 服务。Spray 本身不再积极开发，并已合并到 Typesafe 提供的 Akka
    HTTP 创举中。然而，DSL 结构和创建 REST 服务的方式并没有发生太大的变化。因此，在本章中，我们将探讨 Akka HTTP DSL 提供的以下功能：
- en: The first DSL-based service
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个基于 DSL 的服务
- en: Verb and path handling through directives
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过指令处理动词和路径
- en: Exception handling
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理
- en: Validations and JSON support
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证和 JSON 支持
- en: In the next section, we'll first look a bit deeper at what this DSL entails
    and the history of the Akka HTTP project.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将首先深入探讨这个领域特定语言（DSL）包含的内容以及 Akka HTTP 项目的背景历史。
- en: What is Akka HTTP?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 Akka HTTP？
- en: Akka HTTP is part of the Akka set of libraries and framework. Akka itself is
    a very well-known actor framework, which is used to create highly scalable, distributed,
    and resilient applications. Akka HTTP is built on top of the Akka framework, and
    the 1.0 version was released in the summer of 2015\. You can work with Akka HTTP
    in two different manners. You can use the low-level API and directly work with
    reactive flows to process the raw HTTP information, or you can use the high-level
    API and use an advanced DSL to process your requests. In this chapter, we'll use
    the latter approach.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Akka HTTP 是 Akka 库和框架集的一部分。Akka 本身是一个非常著名的演员框架，用于创建高度可扩展、分布式和健壮的应用程序。Akka HTTP
    是建立在 Akka 框架之上的，1.0 版本于 2015 年夏季发布。你可以以两种不同的方式使用 Akka HTTP。你可以使用低级 API 并直接与反应式流一起工作来处理原始
    HTTP 信息，或者你可以使用高级 API 并使用高级 DSL 来处理你的请求。在本章中，我们将使用后一种方法。
- en: You might think that Akka HTTP isn't a very mature framework since the 1.0 version
    was only recently released. This isn't the case. The Akka HTTP DSL is based on
    the well-known Spray framework, which has been around for a couple of years. Development
    of Spray has stopped, and has continued in the Akka HTTP DSL project. So, for
    those of you who have experience with Spray, the DSL will look pretty much the
    same, and you'll recognize all the standard constructs from Spray.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为 Akka HTTP 不是一个非常成熟的框架，因为 1.0 版本最近才发布。但这并不是事实。Akka HTTP DSL 是基于广为人知的 Spray
    框架，这个框架已经存在了几年。Spray 的发展已经停止，并继续在 Akka HTTP DSL 项目中发展。因此，对于那些有 Spray 经验的人来说，DSL
    将看起来几乎一样，你将能够识别出所有来自 Spray 的标准结构。
- en: Creating a simple DSL-based service
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个基于 DSL 的简单服务
- en: 'For each framework in this book, we create a simple getting started service.
    So for Akka HTTP, we did the same thing. Before we look at the code, let''s begin
    by starting the service and firing a request using Postman. To start the service,
    from the command line, run the `sbt runCH05-HelloAkka-DSL` command:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中的每个框架中，我们都会创建一个简单的入门级服务。因此，对于 Akka HTTP，我们也做了同样的事情。在我们查看代码之前，让我们先启动服务并使用
    Postman 发送一个请求。要启动服务，请在命令行中运行 `sbt runCH05-HelloAkka-DSL` 命令：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Open up Postman, and from the **Chapter 05** collection, run the `Hello Akka-DSL`
    command. The server will respond with a simple message:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Postman，从 **第 05 章** 集合中运行 `Hello Akka-DSL` 命令。服务器将响应一条简单的消息：
- en: '![Creating a simple DSL-based service](img/00036.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个简单的 DSL 服务](img/00036.jpeg)'
- en: 'To create this example, we of course need to import the external dependencies.
    For this sample, the following `sbt` dependencies are used:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这个示例，我们当然需要导入外部依赖项。对于这个示例，使用了以下 `sbt` 依赖项：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note that the dependencies still have the experimental tag in their name. This
    means that the implementation might change and, at this point, there isn''t any
    official support from Typesafe yet. So there might be some changes in the future,
    which aren''t binary-compatible. Typesafe itself defines it as:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，依赖项的名称中仍然带有实验性的标签。这意味着实现可能会改变，并且在此阶段，还没有来自 Typesafe 的官方支持。因此，未来可能会有一些变化，这些变化可能不是二进制兼容的。Typesafe
    本身将其定义为：
- en: '*"This module of Akka is marked as experimental, which means that it is in
    early access mode, which also means that it is not covered by commercial support.
    An experimental module doesn''t have to obey the rule of staying binary compatible
    between minor releases. Breaking API changes may be introduced in minor releases
    without notice as we refine and simplify based on your feedback. An experimental
    module may be dropped in major releases without prior deprecation."*'
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"这个Akka模块被标记为实验性，这意味着它处于早期访问模式，这也意味着它不受商业支持。实验性模块不必遵守小版本之间保持二进制兼容性的规则。在不通知的情况下，可能会在次要版本中引入破坏API的变化，因为我们根据您的反馈进行精简和简化。实验性模块可能在主要版本中删除，而无需提前弃用。"*'
- en: So at this point, it might be wise to not yet convert all your existing Spray
    code to this codebase, but wait until they move out of the experimental phase.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个阶段，可能明智的做法是不要立即将所有现有的Spray代码转换为这个代码库，而是等待它们走出实验阶段。
- en: 'With these dependencies in place, we can create our simple service:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些依赖项就绪后，我们可以创建我们的简单服务：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first thing we do in this service is define two implicit values. The implicit
    `ActorSystem` is needed to define the actor system that will be used to run the
    various processing steps of a request asynchronously. Akka HTTP will convert the
    DSL we create into a flow definition (which is a construct of Akka Streams). This
    flow can be seen as a blueprint of the steps that a request takes from the beginning
    to the end. The implicit `ActorMaterializer` will convert this flow into a set
    of Akka actors so that multiple requests can be executed concurrently without
    interfering with each other, which runs on the implicitly defined `ActorSystem`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个服务中，我们首先定义两个隐式值。隐式的`ActorSystem`是必需的，用于定义将要用于异步运行请求各种处理步骤的actor系统。Akka HTTP会将我们创建的DSL转换为流定义（这是Akka
    Streams的一个构造），这个流可以看作是一个请求从开始到结束所采取步骤的蓝图。隐式的`ActorMaterializer`会将这个流转换为一组Akka
    actors，以便多个请求可以并发执行而不会相互干扰，这些actors运行在隐式定义的`ActorSystem`上。
- en: 'With the implicits defined, we can define the route:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了隐式值之后，我们可以定义路由：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Each request is passed through this route and, when one matches, its inner
    route is executed. So in this case, the following steps are executed:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每个请求都会通过这个路由，当匹配时，其内层路由会被执行。所以在这种情况下，以下步骤被执行：
- en: First, the provided URL path is checked. In this case, if the path matches `hello`,
    the inner route of the path function (this is called a **directive**) is executed.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，检查提供的URL路径。在这种情况下，如果路径匹配`hello`，则执行路径函数的内层路由（这被称为**指令**）。
- en: The next check Akka HTTP makes is to see whether the verb matches. In this example,
    we check for a `GET` verb.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Akka HTTP接下来检查的是动词是否匹配。在这个例子中，我们检查`GET`动词。
- en: The final inner route completes the request by calling complete. When complete
    is called, the result of the provided block is returned as response. In this example,
    we just return a string.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终的内层路由通过调用complete来完成请求。当调用complete时，提供的块的结果作为响应返回。在这个例子中，我们只返回一个字符串。
- en: 'The last piece of code in this hello world example shuts down the server when
    a key is pressed. Shutting down the server is done through the following code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个hello world示例的最后一段代码中，当按下键时，会关闭服务器。关闭服务器是通过以下代码完成的：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This might seem a complex way to shut down the server, but when you look at
    the types, it is actually really simple. We call `flatMap` on the `bindingFuture`
    instance (of the type `Future[ServerBinding]`), so when the `Future` is ready
    (the server is started successfully), we call unbind on the `ServerBinding` instance.
    This, in itself, also returns a `Future`, which is flattened since we called `flatMap`.
    When this last `Future` resolves, we close the Akka system to cleanly shut down
    everything.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关闭服务器的方式可能看起来很复杂，但当你查看类型时，实际上它非常简单。我们在`bindingFuture`实例（类型为`Future[ServerBinding]`）上调用`flatMap`，所以当`Future`准备好（服务器成功启动）时，我们在`ServerBinding`实例上调用unbind。由于我们调用了`flatMap`，这本身也返回一个`Future`，它被扁平化。当这个最后的`Future`解决时，我们关闭Akka系统以干净地关闭一切。
- en: We will use the same way to start and stop the service in other examples.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在其他示例中使用相同的方式来启动和停止服务。
- en: Working with paths and directives
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用路径和指令进行工作
- en: 'The first example we''ll look at is the first simple implementation of our
    API. We won''t be returning real objects or JSON yet, but a couple of strings.
    The code for this step looks like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一个例子是我们API的第一个简单实现。我们目前不会返回真实对象或JSON，而是一对字符串。这一步的代码如下：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This code doesn''t look that different from the previous example we saw. We
    define a route by using directives such as `path`, `get`, `post`, and `put` and
    return values by using the `complete` function. We do, however, use a couple of
    new concepts. Before we explain the code and the concepts provided by Akka HTTP,
    first let''s fire some requests. For this, start up the example for this section:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与我们在前面的例子中看到的代码看起来并没有太大的不同。我们通过使用`path`、`get`、`post`和`put`等指令来定义路由，并通过使用`complete`函数来返回值。然而，我们确实使用了一些新的概念。在我们解释代码和Akka
    HTTP提供的概念之前，首先让我们发起一些请求。为此，启动本节示例：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Open up Postman in your browser and firstly execute the **Step 01 - Update
    task with id** request:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开Postman，首先执行**步骤01 - 更新具有id的任务**请求：
- en: '![Working with paths and directives](img/00037.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![处理路径和指令](img/00037.jpeg)'
- en: 'As you can see, we return a simple response, which shows what data was sent
    to the server. Another interesting example is where we send an invalid request—**Step
    01 - Invalid request**:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们返回一个简单的响应，显示了发送到服务器的数据。另一个有趣的例子是当我们发送一个无效请求时——**步骤01 - 无效请求**：
- en: '![Working with paths and directives](img/00038.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![处理路径和指令](img/00038.jpeg)'
- en: Here, you can see that we can easily provide the user with additional information
    on how to use our service.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到我们可以轻松地向用户提供有关如何使用我们服务的额外信息。
- en: 'Let''s look a bit closer at the second part of the code we saw at the beginning
    of this section:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看本节开头我们看到的代码的第二部分：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we once again see the familiar `path`, `get`, and `put` directives, and
    we also use additional directives to get extra information from the request. We
    use the `IntNumber` path matcher to convert part of the path to an integer and
    use the `entity(as[String])` extractor to extract the body of the request as a
    string (we'll see more of this directive at the end of this chapter when we use
    the same approach to handle JSON input). Let's start though by looking a bit closer
    at the `path` directive.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次看到了熟悉的`path`、`get`和`put`指令，我们还使用了额外的指令来从请求中获取更多信息。我们使用`IntNumber`路径匹配器将路径的一部分转换为整数，并使用`entity(as[String])`提取器将请求体作为字符串提取出来（我们将在本章末尾使用相同的方法处理JSON输入时看到更多关于这个指令的内容）。不过，让我们先更仔细地看看`path`指令。
- en: 'In this example, we already used three different path matchers. We used a string
    value to match a part of the URL, the `/` matcher to indicate that we expected
    a forward slash, and the `IntNumber` path matcher to match and extract a number.
    Besides these, you can also use the matchers explained in the following table:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们已经使用了三个不同的路径匹配器。我们使用字符串值来匹配URL的一部分，使用`/`匹配器来表示我们期望一个正斜杠，以及使用`IntNumber`路径匹配器来匹配和提取一个数字。除了这些之外，您还可以使用以下表格中解释的匹配器：
- en: '| Path matchers | Description |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 路径匹配器 | 描述 |'
- en: '| --- | --- |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `"/hello"` | This matcher matches part of the URL and also consumes it. Nothing
    is extracted here. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `"/hello"` | 这个匹配器匹配URL的一部分，并且消耗它。这里没有提取任何内容。|'
- en: '| `"[a-b]"r` | You can also specify a regular expression with a maximum of
    one capture group with this matcher. The capture group is extracted. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `"[a-b]"r` | 您也可以使用这个匹配器指定一个最多有一个捕获组的正则表达式。捕获组将被提取。|'
- en: '| `Map[String, T]` | Using this matcher, you can extract a value, based on
    the path that matches `Map("path1" -> 1, "path2" -> 2, "path3" -> 3)`. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `Map[String, T]` | 使用这个匹配器，您可以根据匹配`Map("path1" -> 1, "path2" -> 2, "path3"
    -> 3)`的路径提取一个值。|'
- en: '| `Slash (or /)` | This matcher matches a single forward slash. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `Slash (or /)` | 这个匹配器匹配单个正斜杠。|'
- en: '| `Segment` | This matches if the path starts with a path segment (not a forward
    slash). The current path segment is extracted as a string. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `Segment` | 如果路径以路径段（而不是正斜杠）开头，则匹配。当前路径段作为字符串被提取。|'
- en: '| `PathEnd` | This matches the end of the path and extracts nothing. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `PathEnd` | 这个匹配器匹配路径的末尾，不提取任何内容。|'
- en: '| `Rest` | This matches the rest of the path and returns it as a string. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `Rest` | 这个匹配器匹配路径的其余部分，并将其作为字符串返回。|'
- en: '| `RestPath` | This matches the rest of the path and returns it as a path.
    |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `RestPath` | 这个匹配器匹配路径的其余部分，并将其作为路径返回。|'
- en: '| `IntNumber` | This matches a number of digits that can be converted to an
    integer. The matched integer is extracted. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `IntNumber` | 这个匹配器匹配可以转换为整数的数字。匹配到的整数将被提取。|'
- en: '| `LongNumber` | This matches a number of digits that can be converted to a
    long number and extracts the matched long number. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `LongNumber` | 这个匹配器匹配可以转换为长整数的数字，并提取匹配到的长整数。|'
- en: '| `HexIntNumber` | This matches a number of hex-digits that can be converted
    to an integer and extracts the matched integer. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `HexIntNumber` | 这个操作符匹配可以转换为整数的十六进制数字，并提取匹配的整数。 |'
- en: '| `HexLongNumber` | This matches a number of hex-digits that can be converted
    to a long number and extracts the matched long number. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `HexLongNumber` | 这个操作符匹配可以转换为长整数的十六进制数字，并提取匹配的长整数。 |'
- en: '| `DoubleNumber` | This matches a number of digits that can be converted to
    a double number and extracts the matched double number. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `DoubleNumber` | 这个操作符匹配可以转换为双精度数的数字，并提取匹配的双精度数。 |'
- en: '| `JavaUUID` | This matches and extracts the string representation of a `java.util.JavaUUID`
    object. The result is a `.java.util.JavaUUID` instance. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `JavaUUID` | 这个操作符匹配并提取`java.util.JavaUUID`对象的字符串表示形式。结果是`.java.util.JavaUUID`实例。
    |'
- en: '| `Neutral` | This matches everything and doesn''t consume anything. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `Neutral` | 这个操作符匹配一切，不消耗任何内容。 |'
- en: '| `Segments` | This is the same as the `Segment` matcher but, this time, matches
    all the remaining segments and returns these as a `List[String]` object. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `Segments` | 这个操作符与`Segment`匹配器相同，但这次匹配所有剩余的段，并返回这些段作为一个`List[String]`对象。
    |'
- en: '| `separateOnSlashes` | This creates a matcher that interprets slashes as path
    segment separators. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `separateOnSlashes` | 这个操作符创建一个匹配器，将斜杠解释为路径段分隔符。 |'
- en: '| `provide` | This matcher always matches and extracts the provided tuple value.
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `provide` | 这个匹配器总是匹配并提取提供的元组值。 |'
- en: '| `~` | This operator allows you to concatenate two matchers, for example `"hello"
    ~ "world"` is the same as `"helloworld"`. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `~` | 这个操作符允许你连接两个匹配器，例如 `"hello" ~ "world"` 等同于 `"helloworld"`。 |'
- en: '| `&#124;` | This combines two matchers together. The right-hand side one will
    only be evaluated when the left-hand side one fails to match. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;` | 这个操作符将两个匹配器组合在一起。当左侧的匹配器无法匹配时，才会评估右侧的匹配器。 |'
- en: '| Postfix: `?` | The `?` postfix makes the matcher optional, and it will always
    match. The result of the extracted value will be an `Option[T]` object. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 后缀: `?` | `?`后缀使匹配器可选，并且总是匹配。提取值的结果是`Option[T]`对象。 |'
- en: '| Prefix: `!` | This prefix inverses the matcher. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 前缀: `!` | 这个前缀反转了匹配器。 |'
- en: '| Postfix: `.repeat` | With `repeat`, you can make a matcher that repeats itself
    the specified amount of time. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 后缀: `.repeat` | 使用`repeat`，你可以创建一个匹配器，使其重复指定的次数。 |'
- en: '| `transform, flatMap, map` | This allows you to customize the matcher and
    create your own custom logic. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `transform, flatMap, map` | 这些操作符允许你自定义匹配器并创建自己的自定义逻辑。 |'
- en: 'So even in the `path` directive, you can already extract a lot of information
    and apply multiple matchers. Besides the `path` directive, there are a lot of
    other directives. We''ve already seen the entity extracted in this example used
    like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 所以即使在`path`指令中，你也能提取出很多信息并应用多个匹配器。除了`path`指令之外，还有很多其他的指令。我们已经看到在这个例子中提取的实体是这样使用的：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When you use an extractor, the extracted value is passed as an argument to
    the inner route (`body` in this code fragment). Akka HTTP comes with a large number
    of extractors you can use to get values out of the request. The following table
    shows the most useful ones:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用提取器时，提取的值会被作为参数传递给内部路由（在这个代码片段中是`body`）。Akka HTTP附带了许多你可以用来从请求中获取值的提取器。下表显示了最有用的几个：
- en: '| Directive | Description |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `cookie("name")` | This extracts a cookie with the specified name and returns
    an `HttpCookiePair` instance. There is also an `Option` variant—`optionalCookie`.
    |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `cookie("name")` | 这个操作符提取指定名称的cookie，并返回一个`HttpCookiePair`实例。还有一个`Option`变体——`optionalCookie`。
    |'
- en: '| `entity(as[T])` | This unmarshals the request entity to the specified type
    (for more information, see the section on JSON). |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `entity(as[T])` | 这个操作符将请求实体反序列化为指定的类型（更多信息，请参阅关于JSON的部分）。 |'
- en: '| `extractClientIp` | This extracts the client''s IP from either the X-Forwarded-
    or Remote-Addressor X-Real-IP header as a `RemoteAddress`. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `extractClientIp` | 这个操作符从X-Forwarded-或Remote-Addressor X-Real-IP头中提取客户端的IP，作为一个`RemoteAddress`。
    |'
- en: '| `extractCredentials` | This gets an `Option[HttpCredentials]` from the authorization
    header. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `extractCredentials` | 这个操作符从授权头中获取`Option[HttpCredentials]`。 |'
- en: '| `extractExecutionContext` | This provides access to the Akka `ExecutionContext`
    instance. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `extractExecutionContext` | 这个操作符提供了对Akka `ExecutionContext`实例的访问。 |'
- en: '| `extractMaterializer` | This provides access to the Akka `Materializer`.
    |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `extractMaterializer` | 这个操作符提供了对Akka `Materializer`的访问。 |'
- en: '| `extractHost` | This gets the `hostname` part of the host request header
    value as a string. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `extractHost` | 这获取主机请求头部值的`hostname`部分作为字符串。|'
- en: '| `extractMethod` | This extracts the request method as an `HttpMethod`. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `extractMethod` | 这提取请求方法作为`HttpMethod`。|'
- en: '| `extractRequest` | This provides access to the current `HttpRequest`. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `extractRequest` | 这提供了对当前`HttpRequest`的访问。|'
- en: '| `extractScheme` | This returns the URI scheme (`http`, `https`, and others)
    from the request as a string. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `extractScheme` | 这从请求中返回URI方案（如`http`、`https`等）作为字符串。|'
- en: '| `extractUnmatchedPath` | This extracts the part of the path that is unmatched
    at this point as a `Uri.Path`. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `extractUnmatchedPath` | 这提取当前点未匹配的路径部分作为`Uri.Path`。|'
- en: '| `extractUri` | This accesses the full URI of the request as a `Uri`. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `extractUri` | 这通过`Uri`访问请求的完整URI。|'
- en: '| `formFields` | This extracts fields from a POST made in an HTML form. For
    more information, see the section on path matchers. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `formFields` | 这从HTML表单中提取字段。有关更多信息，请参阅路径匹配器部分。|'
- en: '| `headerValueByName` | This extracts the value of the first HTTP request header
    with a given name and returns it as a string. You can also get an `Option[String]`
    by using `OptionalHeaderValueByName`. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `headerValueByName` | 这提取具有给定名称的第一个HTTP请求头部的值，并将其作为字符串返回。您也可以通过使用`OptionalHeaderValueByName`来获取`Option[String]`。|'
- en: '| `headerValueByType [T]` | You can also extract a header and automatically
    convert it to a specific type with this directive. For this one, there is also
    an `Option` variant—`OptionalHeaderValueByType`. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `headerValueByType [T]` | 您也可以使用此指令提取头并将其自动转换为特定类型。对于这个，还有一个`Option`变体——`OptionalHeaderValueByType`。|'
- en: '| `parameterMap` | This gets all the parameters from the request as a `Map[String,
    String]`. If multiple parameters with the same name exist, only the last one will
    be returned. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `parameterMap` | 这从请求中获取所有参数作为`Map[String, String]`。如果存在具有相同名称的多个参数，则仅返回最后一个。|'
- en: '| `parameterMultiMap` | This gets all the parameters from the request as a
    `Map[String, List[String]]`. If multiple parameters with the same name exist,
    all will be returned. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `parameterMultiMap` | 这从请求中获取所有参数作为`Map[String, List[String]]`。如果存在具有相同名称的多个参数，则所有参数都将返回。|'
- en: '| `parameterSeq` | This extracts all the parameters in order as a `Seq[(String,
    String)]` of tuples. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `parameterSeq` | 这按顺序提取所有参数作为元组的`Seq[(String, String)]`。|'
- en: '| `provide("value")` | This injects the provided value into the inner route.
    There is also a `tprovide` function, which injects a tuple. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `provide("value")` | 这将提供的值注入到内部路由中。还有一个`tprovide`函数，它可以注入一个元组。|'
- en: 'Most of these extractors are pretty much self-explanatory. For instance, when
    you want to extract a specific HTTP header, you can write a route like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些提取器相当直观。例如，当您想要提取特定的HTTP头时，您可以编写如下路由：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, let''s get back to our example and look again at a very simple part of
    our route:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的示例，再次看看我们路由的一个非常简单的部分：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'So far, we''ve only seen a small number of Akka directives. We looked at the
    possible extractors in the previous table, and the simple directives to match
    parts of the path and the specific-HTTP verbs. Besides these, Akka HTTP provides
    a very large number of directives, much more than we can explain in this single
    chapter. In the following table, we''ll list the directives we feel are the most
    important and flexible for you to use in the routes:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到了少量Akka指令。我们查看了上表中可能的提取器，以及匹配路径部分和特定HTTP动词的简单指令。除此之外，Akka HTTP提供了大量指令，远远超过我们在这单章中可以解释的数量。在下面的表中，我们将列出我们认为最重要的、最灵活的指令，供您在路由中使用：
- en: '| Directive | Description |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `conditional` | This provides support for conditional requests as specified
    in [http://tools.ietf.org/html/draft-ietf-httpbis-p4-conditional-26](http://tools.ietf.org/html/draft-ietf-httpbis-p4-conditional-26).
    |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `conditional` | 这提供了对按[http://tools.ietf.org/html/draft-ietf-httpbis-p4-conditional-26](http://tools.ietf.org/html/draft-ietf-httpbis-p4-conditional-26)指定的条件请求的支持。|'
- en: '| `decodeRequest / encodeRequest` | This compresses and decompresses a request
    that is sent using gzip or deflate compression. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `decodeRequest / encodeRequest` | 这压缩和解压缩使用gzip或deflate压缩发送的请求。|'
- en: '| `decodeRequestWith / encodeRequestWith` | This compresses and decompresses
    a request with the specified encoder and decoder. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `decodeRequestWith / encodeRequestWith` | 这使用指定的编码器和解码器压缩和解压缩请求。|'
- en: '| `get / delete / post / put / head / options / patch` | The inner route of
    this directive will be executed when the specified HTTP verb matches. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `get / delete / post / put / head / options / patch` | 当指定的 HTTP 动词匹配时，将执行此指令的内部路由。|'
- en: '| `host` | This only runs the inner route if the host specified in this directive
    matches. You can use strings or a regex. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `host` | 只有当在此指令中指定的主机与提供的匹配时，才会运行内部路由。您可以使用字符串或正则表达式。|'
- en: '| `method(httpMethod)` | This checks whether the request matches the specified
    `HttpMethod`. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `method(httpMethod)` | 检查请求是否与指定的 `HttpMethod` 匹配。|'
- en: '| `onComplete(future)` | This runs the inner route when the provided `Future`
    completes. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `onComplete(future)` | 当提供的 `Future` 完成时，将运行内部路由。|'
- en: '| `onSuccess` | This runs the inner route when the provided `Future` completes
    successfully. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `onSuccess` | 当提供的 `Future` 成功完成时，将运行内部路由。|'
- en: '| `overrideMethodWithParameter` | This changes the method (HTTP verb) of the
    incoming request to the provided `HttpMethod`. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `overrideMethodWithParameter` | 这将传入请求的 `HttpMethod` 改变传入请求的方法（HTTP动词）。|'
- en: '| `pass` | This always passes the request to the inner route. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `pass` | 总是将请求传递到内部路由。|'
- en: '| `path` | If the provided path matches, this passes the request to the inner
    route (you will get to know more about it in the next example). |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `path` | 如果提供的路径匹配，则将请求传递到内部路由（您将在下一个示例中了解更多关于它的信息）。|'
- en: '| `pathEnd` | This only passes the request on if its complete path is matched.
    |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `pathEnd` | 只有当其完整路径匹配时，才会传递请求。|'
- en: '| `pathEndOrSingleSlash` | This only passes the request on if it''s complete
    path is matched or only a single slash remains. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `pathEndOrSingleSlash` | 如果其完整路径匹配或仅剩单个斜杠，则仅传递请求。|'
- en: '| `pathPrefix` | This matches first part of a path. A leading slash is automatically
    added. If you just want to test and not consume the path, use `pathPrefixTest`.
    If you don''t want a leading slash, you can use `rawPrefix` and `rawPrefixTest`.
    |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `pathPrefix` | 这匹配路径的第一部分。自动添加前导斜杠。如果您只想测试而不消耗路径，请使用 `pathPrefixTest`。如果您不想使用前导斜杠，可以使用
    `rawPrefix` 和 `rawPrefixTest`。|'
- en: '| `pathSingleSlash` | This only runs the inner route if the path contains a
    single slash. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `pathSingleSlash` | 只有当路径包含单个斜杠时，才会运行内部路由。|'
- en: '| `pathSuffix` | This checks the end of the current path and, if it matches,
    runs the inner route. If you just want to test and not consume the path, use the
    `pathSuffixTest` directive. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `pathSuffix` | 这检查当前路径的末尾，如果匹配，则运行内部路由。如果您只想测试而不消耗路径，请使用 `pathSuffixTest`
    指令。|'
- en: '| `requestEncodedWith` | This checks whether the request encoding matches the
    specified `HttpEncoding`. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `requestEncodedWith` | 检查请求编码是否与指定的 `HttpEncoding` 匹配。|'
- en: '| `requestEntityEmpty` | This matches if the request doesn''t contain a body.
    |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `requestEntityEmpty` | 如果请求不包含正文，则匹配此条件。|'
- en: '| `requestEntityPresent` | This matches if the request contains a body. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `requestEntityPresent` | 如果请求包含正文，则匹配此条件。|'
- en: '| `scheme("http")` | This checks the scheme of the request. If the scheme matches,
    the request is passed on to the inner route. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `scheme("http")` | 这检查请求的方案。如果方案匹配，请求将被传递到内部路由。|'
- en: '| `validate` | This allows you to test against an arbitrary condition. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `validate` | 这允许您测试任意条件。|'
- en: 'Before we move on to the next example, we''ll quickly look at one last inner
    route that we saw at the beginning of this section:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续下一个示例之前，我们将快速查看本节开头看到的最后一个内部路由：
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With this inner route, we inform Akka HTTP that the inner route rejects the
    request. In this case, we reject the request because the `HttpMethod` (the verb)
    didn't match anything we can process. When you reject a request, Akka HTTP will
    check whether there are any routes that might match and, if not, will convert
    the rejection in to an HTTP error message. Further, in this chapter, we'll look
    a bit closer at how Akka HTTP works with rejections and handles exceptions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此内部路由，我们通知 Akka HTTP 内部路由拒绝请求。在这种情况下，我们拒绝请求是因为 `HttpMethod`（动词）与我们能够处理的任何内容都不匹配。当您拒绝请求时，Akka
    HTTP 将检查是否有任何可能匹配的路由，如果没有，将拒绝转换为 HTTP 错误消息。此外，在本章中，我们还将更详细地了解 Akka HTTP 如何与拒绝和异常处理交互。
- en: Processing request parameters and customizing the response
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理请求参数和自定义响应
- en: 'In this section, we''ll dive a bit deeper into how we can extract query parameters
    from requests and how to customize the response you send back to the client. In
    this section, we''ll look a bit closer at how to implement the following requests:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更深入地探讨如何从请求中提取查询参数以及如何自定义发送给客户端的响应。在本节中，我们将更详细地了解以下请求的实现方式：
- en: '**Create a task**: We''ll use a set of query parameters to create a new task'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建任务**：我们将使用一组查询参数创建一个新任务'
- en: '**Get all tasks**: We will return all the tasks that have been created'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取所有任务**：我们将返回所有已创建的任务'
- en: '**Get a task**: We will return a specific task based on the provided ID'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取任务**：我们将根据提供的ID返回一个特定的任务'
- en: 'For each of these requests, we''ll first show the call from Postman and then
    how it is implemented with Akka HTTP. First, start up the correct server with
    the `sbt runCH05-runCH05Step2` command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些请求中的每一个，我们首先将展示从Postman的调用，然后展示如何使用Akka HTTP实现。首先，使用`sbt runCH05-runCH05Step2`命令启动正确的服务器：
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now open Postman and execute the **Step 02 - Create Task** request:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开Postman并执行**步骤 02 - 创建任务**请求：
- en: '![Processing request parameters and customizing the response](img/00039.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![处理请求参数和自定义响应](img/00039.jpeg)'
- en: 'In the response, you can see that we return a string representation of the
    task that was added, and that the content of the task is based on the query parameters
    in the URL. To accomplish this, we implement the following route:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应中，您可以看到我们返回了添加的任务的字符串表示形式，并且任务的内容基于URL中的查询参数。为了实现这一点，我们实现了以下路由：
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this route, we first combine two directives, the `post` directive and the
    `parameters` directive by using the `&` symbol. This means that both directives
    should match before the inner route is executed. There is also a `|` symbol you
    can use, which means either the left or the right directive should match (`put`
    `|` `post`). The parameters, together with the body, are used to create a `Task`
    instance using the `TaskService` object. The resulting `Future[Task]` is then
    converted to a `Future[String]` and returned. We need to convert the `Task` to
    a string here manually since we haven''t told Akka HTTP how to deal with the `Task`
    class (you will get to know more about it later). If you look at the parameters
    directive, you''ll not only recognize the query parameters from the original request,
    but also see a number of modifiers. The following bullets explain how the parameters
    directive works:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在此路由中，我们首先通过使用`&`符号组合两个指令，即`post`指令和`parameters`指令。这意味着在执行内部路由之前，这两个指令都应该匹配。您还可以使用`|`符号，这意味着左边的指令或右边的指令应该匹配（`put`
    `|` `post`）。参数与正文一起使用，通过`TaskService`对象创建`Task`实例。然后，将生成的`Future[Task]`转换为`Future[String]`并返回。由于我们尚未告诉Akka
    HTTP如何处理`Task`类，因此我们需要手动将`Task`转换为字符串（您将在稍后了解更多关于它的信息）。如果您查看参数指令，您不仅会认出原始请求中的查询参数，还会看到许多修饰符。以下项目符号解释了参数指令的工作原理：
- en: '`"title"`: This extracts the value of the parameter as a string. This marks
    this query parameter as required.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"title"`：这提取参数的值作为字符串。这表示此查询参数是必需的。'
- en: '`"person".?`: By using the `.?` postfix, you make a value optional. This result
    is an `Option[String]`.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"person".?`：通过使用`.?`后缀，您使值可选。此结果为`Option[String]`。'
- en: '`"status" ? "new"`: This retrieves the parameter and, if it can''t be found,
    uses the default value (`"new"` in this case). The result is a string.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"status" ? "new"`：这检索参数，如果找不到，则使用默认值（在这种情况下为`"new"`）。结果是字符串。'
- en: '`"status" ! "new"`: This requires the query parameter with the name `"status"`
    to be `"new"`.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"status" ! "new"`：这要求查询参数的名称为`"status"`的值为`"new"`。'
- en: '`"number".as[Int]`: This tries to convert the parameter to the specified type.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"number".as[Int]`：这尝试将参数转换为指定的类型。'
- en: '`"title.*"`: This extracts multiple instances of the title parameter to an
    `Iterable[String]`.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"title.*"`：这从标题参数中提取多个实例到`Iterable[String]`。'
- en: '`"number".as[Int].*`: This is same as the previous function, but works on types.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"number".as[Int].*`：这与前面的函数相同，但适用于类型。'
- en: So for our sample, we require a `title` parameter, an optional `person` parameter,
    and an optional `status` parameter, which has a default value of `"new"`. With
    these constructs, it is very easy to extract the correct values from a request's
    query parameters.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于我们的示例，我们需要一个`title`参数，一个可选的`person`参数，以及一个可选的`status`参数，其默认值为`"new"`。使用这些结构，从请求的查询参数中提取正确的值变得非常容易。
- en: 'Now let''s look a bit closer at the response we send back from this example.
    We use the complete directive which we''ve seen earlier, and just return a `Future[String]`
    instance. Since it is a string, Akka HTTP knows how to marshal it to an HTTP response.
    We use the same approach for the get all tasks request. From Postman, after you''ve
    created a couple of tasks, make the **Step 02 - Get All** request:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更仔细地看看我们从这个示例中发送的响应。我们使用之前看到的 `complete` 指令，并仅返回一个 `Future[String]` 实例。由于它是一个字符串，Akka
    HTTP 知道如何将其序列化为 HTTP 响应。我们使用相同的方法来处理获取所有任务请求。从 Postman 开始，在你创建了一些任务之后，执行 **步骤
    02 - 获取所有** 请求：
- en: '![Processing request parameters and customizing the response](img/00040.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![处理请求参数和自定义响应](img/00040.jpeg)'
- en: 'You''ll see that you get back the list of tasks you''ve created. Once again,
    it''s very simple:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到返回了你创建的任务列表。再次强调，这非常简单：
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We make a call to the `TaskService` object, which returns a `Future[List[Task]]`
    instance. Since we haven't told Akka HTTP yet how to handle this type, we manually
    convert it to the correct type and use `complete` to send back the response. So
    far, we've only seen the use of complete. In most cases, the default behavior
    provided by Akka HTTP is good enough, however, there are also different ways you
    can customize the response that is sent by Akka HTTP.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用 `TaskService` 对象，它返回一个 `Future[List[Task]]` 实例。由于我们尚未告诉 Akka HTTP 如何处理此类型，我们手动将其转换为正确的类型，并使用
    `complete` 发送响应。到目前为止，我们只看到了 `complete` 的使用。在大多数情况下，Akka HTTP 提供的默认行为已经足够好，然而，你还可以以不同的方式自定义
    Akka HTTP 发送的响应。
- en: 'Open Postman again, use the **Step 02 - Create Task** option to create a number
    of tasks and this time execute the **Step 02 – Get Task Invalid** request to get
    a single request. This request will try to get the request with ID 100, which
    is invalid (unless you added 100 tasks). The result looks similar to this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 再次打开 Postman，使用 **步骤 02 - 创建任务** 选项创建多个任务，这次执行 **步骤 02 – 获取任务无效** 请求以获取单个请求。此请求将尝试获取
    ID 为 100 的请求，该请求无效（除非你添加了 100 个任务）。结果看起来类似于以下内容：
- en: '![Processing request parameters and customizing the response](img/00041.jpeg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![处理请求参数和自定义响应](img/00041.jpeg)'
- en: 'As you can see, this time we get a **404** message, with a custom error message.
    If you make a request for a task which is available (use the Step **02 – Get Task**
    request), you''ll see the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这次我们得到了一个 **404** 消息，带有自定义错误消息。如果你请求一个可用的任务（使用步骤 **02 – 获取任务** 请求），你会看到以下内容：
- en: '![Processing request parameters and customizing the response](img/00042.jpeg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![处理请求参数和自定义响应](img/00042.jpeg)'
- en: For the rest, there isn't too much special in these two requests. However, if
    you look at the **Cookies** and **Headers** tabs, you might notice that we get
    additional results there. If you open these tabs, you'll notice a custom hello
    cookie with `world` as the value, and in the **Headers** tab, we added a custom
    header called **helloheader**.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其余部分，这两个请求并没有太多特别之处。然而，如果你查看 **Cookies** 和 **Headers** 选项卡，你可能会注意到我们在那里得到了额外的结果。如果你打开这些选项卡，你会注意到一个带有
    `world` 值的自定义 hello cookie，在 **Headers** 选项卡中，我们添加了一个名为 **helloheader** 的自定义头。
- en: 'To accomplish this, we used a couple of standard Akka HTTP features. The following
    code fragment shows how this is done:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个任务，我们使用了几个标准的 Akka HTTP 功能。以下代码片段显示了如何实现这一点：
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this code fragment, we use a couple of directives provided by Akka HTTP that
    can be used to customize the response to a request. With the `setCookie` and `respndWithHeader`
    directives, we add the custom cookie and header. In the inner route of this directive,
    we use the `onComplete` directive to determine what to do with the response from
    the `TaskService.select` function. If the `Future` succeeds with `Some[Task]`,
    we respond with this `Task`. If no `Task` is found, we return with a `404` (the
    `NotFound` status code). Finally, if the `Future` fails to complete successfully,
    we respond with an `InternalServerError`. You might notice that this time, we
    didn't convert the `Task` to a string, but just returned it. This works in this
    case because we've also defined an implicit, `ToEntityMarshaller[Task]`. This
    marshaller allows Akka HTTP to convert the `Task` case class to an `HTTPEntity`
    instance, which Akka HTTP knows how to marshal to an `HttpResponse`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们使用了 Akka HTTP 提供的一些指令，可以用来自定义对请求的响应。使用 `setCookie` 和 `respndWithHeader`
    指令，我们添加了自定义的 cookie 和头信息。在这个指令的内部路由中，我们使用 `onComplete` 指令来确定如何处理 `TaskService.select`
    函数的响应。如果 `Future` 成功返回 `Some[Task]`，我们以这个 `Task` 作为响应。如果没有找到 `Task`，我们返回 `404`（`NotFound`
    状态码）。最后，如果 `Future` 无法成功完成，我们以 `InternalServerError` 作为响应。您可能会注意到，这次我们没有将 `Task`
    转换为字符串，而是直接返回它。这是因为我们同时也定义了一个隐式的，`ToEntityMarshaller[Task]`。这个marshaller 允许 Akka
    HTTP 将 `Task` case 类转换为 `HTTPEntity` 实例，Akka HTTP 知道如何将其序列化为 `HttpResponse`。
- en: 'Besides the directives shown here, Akka HTTP provides a number of other directives
    and functions you can use to customize the responses. The following table shows
    the directives related to customizing the response:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这里显示的指令之外，Akka HTTP 还提供了一些其他指令和函数，您可以使用它们来自定义响应。以下表格显示了与自定义响应相关的指令：
- en: '| Directive | Description |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `complete` | This completes the request with the provided arguments. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `complete` | 这使用提供的参数完成请求。|'
- en: '| `completeOrRecoverWith` | This returns the result of the provided `Future`
    object. If the `Future` fails the exception is extracted and the inner route is
    run. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `completeOrRecoverWith` | 这返回提供的 `Future` 对象的结果。如果 `Future` 失败，则提取异常并运行内部路由。|'
- en: '| `completeWith` | This extracts a function that can be called to complete
    the request. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `completeWith` | 这提取一个可以调用来完成请求的函数。|'
- en: '| `getFromBrowseableDirectories` | This serves the content of the given directories
    as a file-system browser. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `getFromBrowseableDirectories` | 这将给定目录的内容作为文件系统浏览器提供服务。|'
- en: '| `getFromBrowseableDirectory` | This serves the content of the given directory
    as a file-system browser. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `getFromBrowseableDirectory` | 这将给定目录的内容作为文件系统浏览器提供服务。|'
- en: '| `getFromDirectory` | This matches a `GET` request and returns with the content
    of a file in a specific directory. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `getFromDirectory` | 这与一个 `GET` 请求匹配并返回特定目录中文件的內容。|'
- en: '| `getFromFile` | This matches a `GET` request and returns with the content
    of a file. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `getFromFile` | 这与一个 `GET` 请求匹配并返回文件的內容。|'
- en: '| `getFromResource` | This matches a `GET` request and returns with the content
    of a classpath resource. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `getFromResource` | 这与一个 `GET` 请求匹配并返回类路径资源的內容。|'
- en: '| `getFromResourceDirectory` | This matches a `GET` request and returns with
    the content of a classpath resource in a specified classpath directory. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `getFromResourceDirectory` | 这与一个 `GET` 请求匹配并返回指定类路径目录中类路径资源的內容。|'
- en: '| `listDirectoryContents` | This matches a `GET` request and returns with the
    content of a specific directory. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `listDirectoryContents` | 这与一个 `GET` 请求匹配并返回特定目录的內容。|'
- en: '| `redirect` | This sends a redirection response. There are also more specific
    directives:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '| `redirect` | 这发送一个重定向响应。还有更具体的指令：'
- en: '`redirectToNoTrailingSlashIfPresent`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redirectToNoTrailingSlashIfPresent`'
- en: '`redirectToTrailingSlashIfMissing`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redirectToTrailingSlashIfMissing`'
- en: '|'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `respondWithHeader` | This sets a specific header on the response object.
    You can also add multiple headers at once using the `responseWithHeaders` directive.
    This directive overwrites the already set headers. If you don''t want to override
    the existing headers, use the following directives:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '| `respondWithHeader` | 这在响应对象上设置一个特定的头。您也可以使用 `responseWithHeaders` 指令一次性添加多个头。这个指令会覆盖已设置的头。如果您不想覆盖现有的头，请使用以下指令：'
- en: '`respondWithDefaultHeaders`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`respondWithDefaultHeaders`'
- en: '`respondWithDefaultHeader`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`respondWithDefaultHeader`'
- en: '|'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `setCookie, deleteCookie` | This adds or deletes a cookie. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `setCookie, deleteCookie` | 这添加或删除一个cookie。|'
- en: '| `overrideStatusCode` | This sets the HTTP status code of the response. Akka
    HTTP provides a `StatusCode` object, which you can use to access all the available
    response codes. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `overrideStatusCode` | 这设置了响应的HTTP状态码。Akka HTTP提供了一个`StatusCode`对象，你可以使用它来访问所有可用的响应码。|'
- en: 'If these directives aren''t enough, there is also the option to simply return
    an `HttpResponse` object. Akka HTTP provides an `HttpResponse` case class for
    that, which you can use like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些指令还不够，你也可以选择简单地返回一个`HttpResponse`对象。Akka HTTP提供了一个用于此目的的`HttpResponse`案例类，你可以这样使用：
- en: '[PRE16]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So far in this chapter, we saw how to access and extract information from the
    request and ways to set and customize the response. In the last couple of pages
    from this chapter, we'll look at the different ways you can handle errors and
    exception situations from Akka HTTP.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们看到了如何访问和提取请求信息以及设置和自定义响应的方式。在本章的最后几页，我们将探讨从Akka HTTP处理错误和异常情况的不同方法。
- en: Exception handling and rejections
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理和拒绝
- en: 'In this section, we''ll look at how Akka HTTP handles exceptions and rejections.
    Before we look at the code, we''ll once again use Postman to show what we want
    to accomplish. Let''s start with how rejections are handled. Rejections are functional
    errors that are either thrown by directives or which you can throw yourself. In
    this example, we add some validations to the create task request. So run `sbt
    runCH05-runCH05Step3`, open up Postman, and execute the request, **Step 03 - Rejection
    handling**:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨Akka HTTP如何处理异常和拒绝。在我们查看代码之前，我们再次使用Postman来展示我们想要实现的目标。让我们从如何处理拒绝开始。拒绝是功能错误，它们要么由指令抛出，要么你可以自己抛出。在这个例子中，我们在创建任务请求中添加了一些验证。所以运行`sbt
    runCH05-runCH05Step3`，打开Postman，并执行请求，**步骤03 - 拒绝处理**：
- en: '![Exception handling and rejections](img/00043.jpeg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![异常处理和拒绝](img/00043.jpeg)'
- en: 'As you can see from the response, the title of the task we want to create must
    be at least 10 characters. The code where we add this validation and also configure
    the rejection handler is shown here:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从响应中可以看到，我们想要创建的任务标题至少需要10个字符。展示如何添加此验证并配置拒绝处理器的代码如下：
- en: '[PRE17]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this code we use the `validate` directive to check the incoming parameters.
    If one of the validations fails, the request will be rejected with a `ValidationRejection`
    result. We''ve wrapped this route with the `handleRejections` directive, so all
    the rejections from this route will be caught by this handler. The following code
    fragment shows what this handler looks like:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们使用`validate`指令来检查传入的参数。如果其中一个验证失败，请求将因`ValidationRejection`结果而被拒绝。我们已经用`handleRejections`指令包装了这个路由，所以这个路由的所有拒绝都将被这个处理器捕获。以下代码片段展示了这个处理器的外观：
- en: '[PRE18]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When you want to create a rejection handler, it's easiest to use the `RejectionHandler.newBuilder`
    object. This object provides you with a couple of functions you can call to define
    this handler's behavior. The `handle` function we used here allows us to handle
    single rejections, and we used this to respond with a 400 bad request, when a
    `ValidationRejection` occurs. Any other rejections bubble up the route. Besides
    `handle`, you can also use `handleAll` to handle multiple instances of the same
    rejection at the same time. Finally, there is a specific `handleNotFound` function
    you can use to define behavior for when a resource isn't found.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想创建一个拒绝处理器时，最简单的方法是使用`RejectionHandler.newBuilder`对象。此对象为你提供了一些可以调用的函数来定义此处理器的行为。我们这里使用的`handle`函数允许我们处理单个拒绝，我们使用它来在发生`ValidationRejection`时响应400错误请求。任何其他拒绝都会沿着路由向上冒泡。除了`handle`之外，你也可以使用`handleAll`来同时处理同一拒绝的多个实例。最后，还有一个特定的`handleNotFound`函数，你可以用它来定义当资源未找到时的行为。
- en: 'Handling exceptions works in pretty much the same way. Open up Postman again
    and use the **Step 03 - Exception handling** request to trigger an exception:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理的工作方式几乎相同。再次打开Postman并使用**步骤03 - 异常处理**请求来触发异常：
- en: '![Exception handling and rejections](img/00044.jpeg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![异常处理和拒绝](img/00044.jpeg)'
- en: 'In this case, we return an internal server error. The following code fragment
    shows how to do this with Akka HTTP:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们返回一个内部服务器错误。以下代码片段展示了如何使用Akka HTTP来完成这个操作：
- en: '[PRE19]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, using an exception handler is not that different from the rejection
    handler we discussed previously. This time, we define an `ExceptionHandler` and
    use the `handleExceptions` directive to connect it to a specific part of the route.
    For the `ExceptionHandler`, we only provide a partial function where we specify
    the exceptions to catch.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用异常处理程序与之前讨论的拒绝处理程序没有太大区别。这次，我们定义了一个`ExceptionHandler`，并使用`handleExceptions`指令将其连接到路由的特定部分。对于`ExceptionHandler`，我们只提供了一个部分函数，其中我们指定要捕获的异常。
- en: Tip
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In this section, we explicitly used the `handleExceptions` and `handleRejections`
    functions to define which handler to use for part of the route. If you want to
    create a custom handler that matches the complete request, you can also define
    the handlers as implicits. This way, they will be used for all the rejections
    and exceptions produced by the route. Also, good to note is that you don't necessarily
    have to match all the rejections and exceptions. If you don't match a specific
    exception or rejection, it will bubble up to one higher in the route and, eventually,
    it will reach the Akka HTTP provided default handlers.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们明确使用了`handleExceptions`和`handleRejections`函数来定义用于部分路由的处理程序。如果您想创建一个匹配完整请求的自定义处理程序，您也可以将处理程序定义为隐式。这样，它们将用于路由产生的所有拒绝和异常。值得注意的是，您不一定必须匹配所有拒绝和异常。如果您没有匹配特定的异常或拒绝，它将冒泡到路由中的更高一级，最终将到达Akka
    HTTP提供的默认处理程序。
- en: 'In this sample, we''ve so far seen the `handleRejections` and `handleExceptions`
    directives; there are a couple of other directives and functions available that
    are related to rejections and exceptions. The following table lists all of these:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们迄今为止已经看到了`handleRejections`和`handleExceptions`指令；还有一些其他与拒绝和异常相关的指令和函数可用。以下表格列出了所有这些：
- en: '| Directive | Description |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `handleRejection` | This handles the current set of rejections using the
    provided `RejectionHandler`. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `handleRejection` | 这个指令使用提供的`RejectionHandler`处理当前集合的拒绝。 |'
- en: '| `handleException` | This handles exceptions thrown from the inner route using
    the provided `ExceptionHandler`. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `handleException` | 这个指令使用提供的`ExceptionHandler`处理从内部路由抛出的异常。 |'
- en: '| `cancelRejection` | This allows you to cancel a rejection coming from the
    inner route. You can also use the `cancelRejections` directive to cancel multiple
    ones. |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `cancelRejection` | 这允许您取消来自内部路由的拒绝。您也可以使用`cancelRejections`指令取消多个拒绝。 |'
- en: '| `failWith` | This directive raises the specified exception; this should be
    used instead of throwing exceptions. |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `failWith` | 这个指令引发指定的异常；这应该代替抛出异常使用。 |'
- en: '| `recoverRejections` | This directive and `RecoverRejectionsWith` allow you
    to handle rejections and transform them in to a normal result. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `recoverRejections` | 这个指令和`RecoverRejectionsWith`允许您处理拒绝并将它们转换为正常的结果。 |'
- en: '| `reject` | This rejects the request with the specified rejections. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `reject` | 这个指令使用指定的拒绝拒绝请求。 |'
- en: With these directives, and the use of global rejection and exception handlers,
    you should be able to cleanly handle the fault situations in your REST service.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些指令以及全局拒绝和异常处理程序，您应该能够干净地处理REST服务中的故障情况。
- en: For the last subject in the discussion on Akka HTTP we'll quickly show you how
    to add JSON support to your service.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于Akka HTTP的讨论的最后主题中，我们将快速向您展示如何向您的服务添加JSON支持。
- en: Adding JSON support
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加JSON支持
- en: 'As a final step, we''ll add JSON support to our Akka HTTP REST service. With
    this added, we''ll be able to send JSON to our service, and Akka HTTP will automatically
    convert it to the case classes we use. The first thing we need to do is add an
    additional SBT dependency:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们将向我们的Akka HTTP REST服务添加JSON支持。添加后，我们将能够向我们的服务发送JSON，Akka HTTP将自动将其转换为我们所使用的案例类。我们需要做的第一件事是添加一个额外的SBT依赖项：
- en: '[PRE20]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once added, we need to inform Akka HTTP which of our case classes should be
    marshaled to and from JSON. The common way to do this is by defining a specific
    trait, which contains the implicits needed by Akka HTTP. For our example, we define
    that trait like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加，我们需要通知Akka HTTP我们的哪些案例类应该被序列化和反序列化为JSON。通常的做法是定义一个特定的特质，其中包含Akka HTTP需要的隐式。对于我们的示例，我们定义这个特质如下：
- en: '[PRE21]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This code is pretty self-explanatory. What we do here is define which case
    classes should be marshaled to and from JSON. Next, we need to make sure we import
    Akka HTTP''s JSON library:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码相当直观。我们在这里定义了哪些案例类应该被序列化和反序列化为JSON。接下来，我们需要确保我们导入了Akka HTTP的JSON库：
- en: '[PRE22]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And finally, make sure we extend this trait in our application:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，确保我们在应用程序中扩展这个特质：
- en: '[PRE23]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'At this point, we can remove the custom marshallers we defined earlier in this
    chapter, and make all our methods just return the `Task` instances instead of
    converting the `Task` instances into strings. For instance, to retrieve all the
    current stored tasks, we just do this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们可以移除本章前面定义的自定义序列化器，并让所有的方法直接返回`Task`实例，而不是将`Task`实例转换为字符串。例如，要检索所有当前存储的任务，我们只需这样做：
- en: '[PRE24]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To also convert incoming JSON to a `Task` object, we need to use the `entity`
    directive. The code to add a `Task` object now becomes this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要将传入的JSON转换为`Task`对象，我们需要使用`entity`指令。添加`Task`对象的代码现在变为这样：
- en: '[PRE25]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With these steps taken, we can open up Postman and see whether it works. In
    Postman, open request, **04 - Create Task**, and run it:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这些步骤后，我们可以在Postman中查看它是否工作。在Postman中打开请求，**04 - 创建任务**，并运行它：
- en: '![Adding JSON support](img/00045.jpeg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![添加JSON支持](img/00045.jpeg)'
- en: 'Here, we can see that the JSON sent is being processed by the server and is
    successfully added. Now repeat this a couple of times and then use the **04 -
    Get all Tasks** request to see whether we can retrieve the list of all the tasks
    we''ve added:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到发送的JSON正在被服务器处理，并且成功添加。现在重复几次这个操作，然后使用**04 - 获取所有任务**请求来查看我们是否可以检索已添加的所有任务的列表：
- en: '![Adding JSON support](img/00046.jpeg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![添加JSON支持](img/00046.jpeg)'
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored most of the features provided by Akka HTTP. You
    learned to use the available directives to match specific request properties and
    extract information from the headers, parameters, and body of the request. Besides
    directives to process incoming requests, Akka HTTP also provides directives to
    create and customize the response that is sent back to the client. If errors occur
    while processing the request, Akka HTTP provides standard exception and rejection
    handlers. You also learned how you can override the default behavior by adding
    custom handlers. Finally, this chapter also showed you how easy it is to add JSON
    support and automatically marshal your classes to and from JSON.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Akka HTTP提供的几乎所有功能。你学习了如何使用可用的指令来匹配特定的请求属性并从请求的头部、参数和体中提取信息。除了处理传入请求的指令外，Akka
    HTTP还提供了创建和自定义发送回客户端的响应的指令。如果在处理请求时发生错误，Akka HTTP提供了标准的异常和拒绝处理器。你还学习了如何通过添加自定义处理器来覆盖默认行为。最后，本章还展示了添加JSON支持以及自动将你的类序列化和反序列化到JSON是多么容易。
- en: In the next chapter, we'll look at the final REST framework that we'll discuss
    in this book, **Play 2**.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨本书中将要讨论的最终REST框架，**Play 2**。
