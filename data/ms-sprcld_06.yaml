- en: Communication Between Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务间的通信
- en: In the last two chapters, we discussed details related to very important elements
    in microservice architecture—service discovery and the configuration server. However,
    it is worth remembering that the main reason for their existence in the system
    is just to help in the management of the whole set of independent, standalone
    applications. One aspect of this management is communication between microservices.
    Here, a particularly important role is played by service discovery, which is responsible
    for storing and serving the network locations of all available applications. Of
    course, we may imagine our system architecture without a service discovery server.
    Such an example will also be presented in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的两章中，我们讨论了与微服务架构中非常重要的元素相关的细节——服务发现和配置服务器。然而，值得记住的是，它们存在于系统中的主要原因只是为了帮助管理整个独立、独立的应用程序集合。这种管理的一个方面是微服务间的通信。在这里，服务发现扮演着特别重要的角色，它负责存储和提供所有可用应用程序的网络位置。当然，我们可以想象我们的系统架构没有服务发现服务器。本章也将呈现这样一个示例。
- en: However, the most important components taking part in an inter-service communication
    are HTTP clients and client-side load balancers. In this chapter, we are going
    to focus just on them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，参与服务间通信最重要的组件是HTTP客户端和客户端负载均衡器。在本章中，我们将只关注它们。
- en: 'The topics we will cover in this chapter include:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将覆盖的主题包括：
- en: Using Spring `RestTemplate` for inter-service communication with and without
    service discovery
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring `RestTemplate`进行带服务发现和不带服务发现的微服务间通信
- en: Customizing the Ribbon client
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义Ribbon客户端
- en: Description of the main features provided by the Feign client, such as integration
    with the Ribbon client, service discovery, inheritance, and zoning support
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述Feign客户端提供的main特性，如与Ribbon客户端的集成、服务发现、继承和区域支持
- en: Different styles of communication
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的通信风格
- en: We can identify different styles of communication between microservices. It
    is possible to classify them into two dimensions. The first of them is a division
    into synchronous and asynchronous communication protocols. The key point of asynchronous
    communication is that the client should not have blocked a thread while waiting
    for a response. The most popular protocol for that type of communication is AMQP,
    and we already had the opportunity to run an example of that protocol usage at
    the end of the previous chapter. However, the main way of communication between
    services is still synchronous HTTP protocol. We will be only talking about it
    in this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以识别出微服务间通信的不同风格。可以将它们分为两个维度进行分类。第一个维度是同步通信和异步通信协议的区分。异步通信的关键点是，客户端在等待响应时不应该阻塞线程。对于这种类型的通信，最流行的协议是AMQP，我们在上一章的末尾已经有了使用该协议的示例。然而，服务间通信的主要方式仍然是同步HTTP协议。我们本章只讨论这个。
- en: The second division is into different communication types based on whether there
    is a single message receiver or multiple receivers. In one-to-one communication,
    each request is processed by exactly one service instance. In one-to-many communication,
    each request may be processed by many different services. This will be discussed
    in [Chapter 11](554c4049-1dc9-430d-8fe7-19f3b9ac99a3.xhtml), *Message Driven Microservices*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个维度是基于是否有单一的消息接收者或多个接收者来进行不同的通信类型区分。在一对一的通信中，每个请求都由一个确切的服务实例处理。在一对多的通信中，每个请求可能被多个不同的服务处理。这将在[第11章](554c4049-1dc9-430d-8fe7-19f3b9ac99a3.xhtml)
    *消息驱动的微服务* 中讨论。
- en: Synchronous communication with Spring Cloud
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Cloud进行同步通信
- en: Spring Cloud provides a set of components to help you in implementing communication
    between microservices. The first of them is `RestTemplate`, which is always used
    for consuming RESTful web services by a client. It is included in a Spring Web
    project. To use it effectively in a microservices environment, it should be annotated
    with the `@LoadBalanced` qualifier. Thanks to that, it will be automatically configured
    to use Netflix Ribbon and it will be able to take an advantage of service discovery
    by using service names instead of IP addresses. Ribbon is a client-side load balancer,
    which provides a simple interface allowing control over the behavior of HTTP and
    TCP clients. It can be easily integrated with other Spring Cloud components, such
    as service discovery or circuit breaker, and, furthermore, it is fully transparent
    to a developer. The next available component is Feign, a declarative REST client
    also from the Netflix OSS stack. Feign already uses Ribbon for load balancing
    and fetching data from service discovery. It may be easily declared on the interface
    by annotating a method with `@FeignClient`. In this chapter, we will take a closer
    look at all the components listed here.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud 提供了一系列组件，帮助你实现微服务之间的通信。第一个组件是 `RestTemplate`，它总是用于客户端消费RESTful
    web服务。它包含在Spring Web项目中。为了在一个微服务环境中有效地使用它，它应该用 `@LoadBalanced` 注解标记。得益于这一点，它会自动配置为使用Netflix
    Ribbon，并能够利用服务发现，通过使用服务名称而不是IP地址。Ribbon 是客户端负载均衡器，它提供了一个简单的接口，允许控制HTTP和TCP客户端的行为。它可以轻松地与其他Spring
    Cloud组件集成，如服务发现或断路器，而且对开发者完全透明。下一个可用的组件是Feign，来自Netflix OSS堆栈的声明式REST客户端。Feign
    已经使用Ribbon进行负载均衡和从服务发现获取数据。它可以通过在接口方法上使用 `@FeignClient` 注解轻松声明。在本章中，我们将详细查看这里列出的所有组件。
- en: Load balancing with Ribbon
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ribbon进行负载均衡
- en: The main concept around Ribbon is a named **client**. That's why we may call
    other services using their names instead of the full address with hostname and
    port, without connecting to a service discovery. In that case, the list of addresses
    should be provided in the Ribbon configuration settings inside the `application.yml`
    file.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕Ribbon的主要概念是一个命名的 **客户端**。这就是为什么我们可以使用服务名称而不是带有主机名和端口的全地址来调用其他服务，而无需连接到服务发现。在这种情况下，地址列表应该在
    `application.yml` 文件内的Ribbon配置设置中提供。
- en: Enabling communication between microservices using the Ribbon client
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ribbon客户端启用微服务之间的通信
- en: 'Let''s proceed with the example. It consists of four independent microservices.
    Some of them may call endpoints exposed by the others. The application source
    code is available here:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。这个例子包含四个独立的微服务。其中一些可能会调用其他微服务暴露的端点。应用程序源代码可以在以下链接找到：
- en: '[https://github.com/piomin/sample-spring-cloud-comm.git](https://github.com/piomin/sample-spring-cloud-comm.git).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 链接：[https://github.com/piomin/sample-spring-cloud-comm.git](https://github.com/piomin/sample-spring-cloud-comm.git)。
- en: 'In this example, we will try to develop a simple order system where customers
    may buy products. If a customer decides to confirm a selected list of products
    to buy, the `POST` request is sent to the `order-service`. It is processed by
    the `Order prepare(@RequestBody Order order) {...}` method inside REST controller.
    This method is responsible for order preparation. First, it calculates the final
    price, considering the price of each product from the list, customer order history,
    and their category in the system by calling the proper API method from the `customer-service`.
    Then, it verifies the customer''s account balance is high enough to execute the
    order by calling the account service, and, finally, it returns the calculated
    price. If the customer confirms the action, the `PUT /{id}` method is called.
    The request is processed by the method `Order accept(@PathVariable Long id) {...}`
    inside REST controller. It changes the order status and withdraws money from the
    customer''s account. The system architecture is broken down into the individual
    microservices as shown here:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将尝试开发一个简单的订单系统，顾客可以购买产品。如果顾客决定确认购买的选定产品列表，`POST`请求将被发送到`order-service`。它由REST控制器内的`Order
    prepare(@RequestBody Order order) {...}`方法处理，该方法负责订单准备。首先，它通过调用`customer-service`中的适当API方法计算最终价格，考虑列表中每个产品的价格、顾客订单历史以及他们在系统中的类别。然后，它通过调用账户服务验证顾客的账户余额是否足够执行订单，并最终返回计算出的价格。如果顾客确认该操作，将调用`PUT
    /{id}`方法。请求由REST控制器内的`Order accept(@PathVariable Long id) {...}`方法处理。它更改订单状态并从顾客账户中提取资金。系统架构如以下所示分解为单独的微服务：
- en: '![](img/5c7304e2-7612-4327-94a6-eaaaec6c0fd5.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c7304e2-7612-4327-94a6-eaaaec6c0fd5.png)'
- en: Static load balancing configuration
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态负载均衡配置
- en: 'Our `order-service` has to communicate with all other microservices from the
    example to perform the required operations. So, we need to define three different
    Ribbon clients with network addresses set using the `ribbon.listOfServers` property.
    The second important thing in the example is to disable discovery services in
    Eureka, which are enabled by default. Here are all the defined properties for
    `order-service` inside its `application.yml` file:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`order-service`必须与示例中的所有其他微服务通信以执行所需操作。因此，我们需要定义三个不同的Ribbon客户端，并使用`ribbon.listOfServers`属性设置网络地址。示例中的第二件重要的事情是禁用默认启用的Eureka发现服务。以下是`order-service`在其`application.yml`文件中定义的所有属性：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We should include the following dependencies in the project to use `RestTemplate`
    in conjunction with the Ribbon client:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与Ribbon客户端一起使用`RestTemplate`，我们应该在项目中包含以下依赖关系：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we should enable the Ribbon client by declaring a list of the names configured
    in `application.yml`. To achieve this, you may annotate the main class or any
    other Spring configuration class with `@RibbonClients`. You should also register
    the `RestTemplate` bean and annotate it with `@LoadBalanced` to enable interaction
    with Spring Cloud components:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们应该通过声明在`application.yml`中配置的名称列表来启用Ribbon客户端。为了实现这一点，您可以注解主类或任何其他Spring配置类为`@RibbonClients`。您还应该注册`RestTemplate`bean，并将其注解为`@LoadBalanced`，以启用与Spring
    Cloud组件的交互：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Calling other services
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用其他服务
- en: Finally, we may begin to implement the `OrderController` responsible for serving
    HTTP methods exposed outside a microservice. It has the `RestTemplate` bean injected
    to be able to call other HTTP endpoints. You may see in the following source code
    fragment that uses the Ribbon client name configured in `application.yml` instead
    of IP address or hostname. Using the same `RestTemplate` bean, we can communicate
    with three different microservices. Let's just take a second here to discuss the
    methods available inside the controller. In the first of the implemented methods,
    we call the `GET` endpoint from `product-service`, which returns a list with details
    of selected products. Then, we invoke the `GET /withAccounts/{id}` method exposed
    by `customer-service`. It returns the customer details with the list of their
    accounts.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以开始实现负责提供微服务外暴露的HTTP方法的`OrderController`。它注入了`RestTemplate`bean，以便能够调用其他HTTP端点。您可以在以下代码片段中看到使用了在`application.yml`中配置的Ribbon客户端名称，而不是IP地址或主机名。使用相同的`RestTemplate`bean，我们可以与三个不同的微服务进行通信。让我们在这里讨论一下控制器中可用的方法。在实现的方法中，我们调用`product-service`的`GET`端点，它返回所选产品的详细信息列表。然后，我们调用`customer-service`暴露的`GET
    /withAccounts/{id}`方法。它返回带有其账户列表的客户详细信息。
- en: 'Now, we have all the information needed to calculate the final order price
    and validate the customer has sufficient funds in their main account. The `PUT`
    method calls the endpoint from `account-service` to withdraw money from the customer
    account. I have spent quite a bit of time discussing methods available in `OrderController`.
    However, I think that it was needed because the same example will be used to show
    the main features of Spring Cloud components that provide mechanisms for synchronous
    communication between microservices:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有了计算最终订单价格和验证客户在他们主账户中是否有足够资金所需的所有信息。`PUT`方法调用`account-service`的端点从客户账户中提取资金。我花了很多时间讨论了`OrderController`中可用的方法。然而，我认为这是必要的，因为同一个示例将用于展示提供微服务间同步通信机制的Spring
    Cloud组件的主要特性：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It is interesting to note that the `GET /withAccounts/{id}` method from `customer-service`,
    which is called by `order-service`, also uses the Ribbon client to communicate
    with another microservice, `account-service`. Here''s the fragment from `CustomerController`
    with the implementation of the preceding method:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，`customer-service`中的`GET /withAccounts/{id}`方法，它被`order-service`调用，也使用Ribbon客户端与另一个微服务`account-service`进行通信。以下是`CustomerController`中实现上述方法的片段：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'First, build the whole project with the Maven command `mvn clean install`.
    Then, you may launch all the microservices in any order using the `java -jar`
    command without any additional parameters. Optionally, you can run the application
    from your IDE. The test data is prepared for every microservice on startup. There
    is no persistence storage, so all objects will be removed after a restart. We
    can test the whole system by calling the `POST` method exposed by `order-service`.
    The example request is shown here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用Maven命令`mvn clean install`构建整个项目。然后，您可以使用没有任何额外参数的`java -jar`命令以任何顺序启动所有微服务。可选地，您还可以从您的IDE中运行应用程序。每个微服务在启动时都会准备测试数据。没有持久化存储，所以重启后所有对象都会被清除。我们可以通过调用`order-service`暴露的`POST`方法来测试整个系统。以下是一个示例请求：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you try to send this request, you will able to see the following logs printed
    by the Ribbon client:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试发送这个请求，您将能够看到Ribbon客户端打印出以下日志：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The approach described in this section has one big disadvantage, which makes
    it not very usable in a system composed of several microservices. The problem
    is more severe if you have auto-scaling. It is easy to see that all the network
    addresses of services have be managed manually. Of course, we may move the configuration
    settings from the `application.yml` file inside every fat JAR to the configuration
    server. However, it does not change the fact that management of a large number
    of interactions will still be troublesome. Such a problem would be easily solved
    by the ability for the client-side load balancer and service discovery to interact.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述的方法有一个很大的缺点，这使得它在由几个微服务组成的系统中不太可用。如果您有自动扩展，问题会更严重。很容易看出，所有服务的网络地址都必须手动管理。当然，我们可以将配置设置从每个胖JAR内的`application.yml`文件移动到配置服务器。然而，这并没有改变管理大量交互仍然会麻烦的事实。这种问题可以通过客户端负载均衡和服务发现之间的互动轻易解决。
- en: Using RestTemplate together with service discovery
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用与服务发现一起的RestTemplate
- en: In fact, an integration with service discovery is the default behavior of the
    Ribbon client. As you probably remember, we disabled Eureka for the client-side
    balancer by setting the `ribbon.eureka.enabled` property to `false`. The existence
    of service discovery simplifies a configuration of Spring Cloud components during
    inter-service communication, examples in this section.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，与服务发现集成是Ribbon客户端的默认行为。正如您可能记得的，我们通过将`ribbon.eureka.enabled`属性设置为`false`来禁用客户端负载均衡的Eureka。服务发现的存在简化了Spring
    Cloud组件在服务间通信时的配置，本节的示例就是如此。
- en: Building example application
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建示例应用程序
- en: The system architecture is the same as for the previous example. To view the
    source code for the current exercise, you have to switch to the `ribbon_with_discovery`
    branch ([https://github.com/piomin/shown here-spring-cloud-comm/tree/ribbon_with_discovery](https://github.com/piomin/sample-spring-cloud-comm/tree/ribbon_with_discovery)). The
    first thing you will see there is a new module, `discovery-service`. We have discussed
    in detail almost all aspects related to Eureka in [Chapter 4](b016b615-1eed-457a-9b9c-66ba07c9ce9e.xhtml),
    *Service Discovery*, so you should not have any problems with launching it. We
    run a single standalone Eureka server with really basic settings. It is available
    on the default port, `8761`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 系统架构与之前的示例相同。要查看当前练习的源代码，你必须切换到`ribbon_with_discovery`分支 ([https://github.com/piomin/shown
    here-spring-cloud-comm/tree/ribbon_with_discovery](https://github.com/piomin/sample-spring-cloud-comm/tree/ribbon_with_discovery)).在那里，你首先看到的是一个新模块，`discovery-service`。我们在[第4章](b016b615-1eed-457a-9b9c-66ba07c9ce9e.xhtml)，*服务发现*中详细讨论了与Eureka几乎所有相关方面，所以你应该不会有任何问题启动它。我们运行一个带有非常基本设置的单一独立Eureka服务器。它可在默认端口`8761`上访问。
- en: 'In comparison with the previous example, we should remove all the configuration
    and annotations strictly related to the Ribbon client. In their place, the Eureka
    discovery client has to be enabled with `@EnableDiscoveryClient` and the Eureka
    server address is provided in the `application.yml` file. Now, the main class
    of `order-service` looks like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前示例相比，我们应该删除所有严格与Ribbon客户端相关的配置和注解。取而代之的是，必须使用`@EnableDiscoveryClient`启用Eureka发现客户端，并在`application.yml`文件中提供Eureka服务器地址。现在，`order-service`的主类看起来像这样：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here''s the current configuration file. I set the name of the service with
    the `spring.application.name` property:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当前的配置文件。我用`spring.application.name`属性设置了服务的名称：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is the same as earlier; we also launch all microservices. But, this time
    `account-service` and `product-service` will be multiplied by two instances. When
    starting a second instance of each service, the default server port may be overridden
    with the `-DPORT` or `-Dserver.port` parameter, for example, `java -jar -DPORT=9093
    product-service-1.0-SNAPSHOT.jar`. All the instances have been registered in the
    Eureka server. This can be easily checked out using its UI dashboard:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是之前的内容；我们同样启动所有的微服务。但是，这次`account-service`和`product-service`将各增加两个实例。启动每个服务的第二个实例时，默认的服务器端口可以通过`-DPORT`或`-Dserver.port`参数来覆盖，例如，`java
    -jar -DPORT=9093 product-service-1.0-SNAPSHOT.jar`。所有实例都已注册到Eureka服务器中。这可以通过其UI仪表板轻松查看：
- en: '![](img/deb2c9a7-afca-421d-993c-84c3189fed0c.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/deb2c9a7-afca-421d-993c-84c3189fed0c.png)'
- en: 'This is the first time in this book we have seen a practical example of load
    balancing. By default, the Ribbon client distributes traffic equally among all
    the registered instances of the microservice. That algorithm is called **round
    robin**. In practice, it means that the client remembers where it forwarded the
    last request and then sends the current request to the service next in the row.
    This approach may be overridden by the other rule I''m going to show you in detail
    in the next chapter. Load balancing may also be configured for the previous example
    without service discovery, by setting a comma-separated list of service addresses
    in `ribbon.listOfServers`, for example, `ribbon.listOfServers=localhost:8093,localhost:9093`.
    Getting back to the example application, the requests sent by `order-service`
    will be load balanced between two instances of `account-service` and `product-service`.
    This looks similar to `customer-service`, which distributes traffic between two
    instances of `account-service`. If you launch all the instances of the service
    visible on the Eureka dashboard in the previous screenshot and send some test
    requests to `order-service`, you will certainly see the following log which I
    have posted. I have highlighted the fragment where the Ribbon client displays
    a list of addresses found for the target service:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书中第一次看到负载均衡的实际例子。默认情况下，Ribbon客户端将流量平均分配到微服务的所有注册实例。这种算法叫做**轮询**。实际上，这意味着客户端记得它上一次将请求转发到哪里，然后将当前请求发送到队列中的下一个服务。这种方法可以被我接下来详细介绍的其他规则覆盖。负载均衡也可以为前面没有服务发现的例子进行配置，通过在`ribbon.listOfServers`中设置一个以逗号分隔的服务地址列表，例如，`ribbon.listOfServers=localhost:8093,localhost:9093`。回到例子应用程序，`order-service`发送的请求将在`account-service`和`product-service`的两个实例之间进行负载均衡。这与上面截图中显示的`customer-service`类似，后者将在两个`account-service`实例之间分配流量。如果你启动了上一截图中Eureka仪表板上可见的所有服务实例，并向`order-service`发送一些测试请求，你肯定会看到我贴出的以下日志。我突出了Ribbon客户端显示目标服务找到的地址列表的片段：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Using Feign client
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Feign客户端
- en: '`RestTemplate` is a Spring component specially adapted to interact with Spring
    Cloud and microservices. However, Netflix has developed their own tool that acts
    as a web service client for providing out-of-the-box communication between independent
    REST services. Feign client, which is in it, generally does the same as `RestTemplate`
    with the `@LoadBalanced` annotation, but in a more elegant way. It is a Java to
    HTTP client binder that works by processing annotations into a templatized request.
    When using Open Feign client, you only have to create an interface and annotate
    it. It integrates with Ribbon and Eureka to provide a load balanced HTTP client,
    fetching all the necessary network addresses from service discovery. Spring Cloud
    adds support for Spring MVC annotations and for using the same HTTP message converters
    as in Spring Web.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`RestTemplate`是Spring的一个组件，特别适用于与Spring Cloud和微服务进行交互。然而，Netflix开发了自己的工具，作为web服务客户端，提供给独立的REST服务之间开箱即用的通信。Feign客户端，在其中，通常与`RestTemplate`的`@LoadBalanced`注解做相同的事情，但以更优雅的方式。它是一个通过处理注解将其转换为模板化请求的Java到HTTP客户端绑定器。当使用Open
    Feign客户端时，你只需要创建一个接口并注解它。它与Ribbon和Eureka集成，提供一个负载均衡的HTTP客户端，从服务发现中获取所有必要的网络地址。Spring
    Cloud为Spring MVC注解添加支持，并使用与Spring Web相同的HTTP消息转换器。'
- en: Support for different zones
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持不同区域
- en: 'Let me back up for a moment to the last example. I''m going to propose some
    changes to complicate our system architecture a little. The current architecture
    is visualized in the following diagram. The communication model between microservices
    is still the same, but now we launch two instances of every microservice and divide
    them into two different zones. A zoning mechanism has been already discussed in
    [Chapter 4](b016b615-1eed-457a-9b9c-66ba07c9ce9e.xhtml), *Service Discovery*,
    when talking about service discovery with Eureka, so I assume it is well known
    to you. The main purpose of this exercise is not only to show how to use Feign
    client, but also how a zoning mechanism works in communication between instances
    of microservices. Let''s start with the basics then:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我回退一下，回到上一个例子。我打算对我们的系统架构做些改动以使其稍微复杂一些。当前的架构在下面的图表中有可视化展示。微服务之间的通信模型仍然是相同的，但现在我们启动每个微服务的两个实例并将它们分为两个不同的区域。关于区域划分机制已经在[第4章](b016b615-1eed-457a-9b9c-66ba07c9ce9e.xhtml)、*服务发现*中讨论过，在讨论使用Eureka进行服务发现时，所以我想你们已经很熟悉了。这次练习的主要目的不仅是展示如何使用Feign客户端，还有微服务实例间通信中区域划分机制是如何工作的。那么我们从基础知识开始：
- en: '![](img/0afef3be-1670-4898-98c6-3c8c6f421485.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0afef3be-1670-4898-98c6-3c8c6f421485.png)'
- en: Enabling Feign for an application
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用Feign应用程序
- en: 'To include Feign in the project, we have to add to the dependencies the `spring-cloud-starter-feign` artifact or
    `spring-cloud-starter-openfeign` for Spring Cloud Netflix in minimal version 1.4.0:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在项目中包含Feign，我们必须添加依赖`spring-cloud-starter-feign`artifact或`spring-cloud-starter-openfeign`对于Spring
    Cloud Netflix的最小版本1.4.0：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The next step is to enable Feign for the application by annotating a main or
    a configuration class with `@EnableFeignClients`. This annotation will result
    in a search for all clients implemented in the application. We may also reduce
    the number of client used by setting the `clients` or `basePackages` annotation
    properties, for example, `@EnableFeignClients(clients = {AccountClient.class,
    Product.class})`. Here''s the main class of the `order-service` application:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是启用应用程序中的Feign，通过用`@EnableFeignClients`注解主类或配置类来实现。这个注解会导致搜索应用程序中所有实现的客户端。我们也可以通过设置`clients`或`basePackages`注解属性来减少使用的客户端数量，例如，`@EnableFeignClients(clients
    = {AccountClient.class, Product.class})`。这是`order-service`应用程序的主类：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Building Feign interfaces
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Feign接口
- en: 'An approach where only an interface with some annotations has to be created
    to provide a component is standard for Spring Framework. For Feign, an interface
    must be annotated with `@FeignClient(name = "...")`. It has one required property
    name, which corresponds to the invoked microservice name if service discovery
    is enabled. Otherwise, it is used together with the `url` property, where we can
    set a concrete network address. `@FeignClient` is not the only annotation that
    needs to be used here. Every method in our client interface is associated with
    a specific HTTP API endpoint by marking it with `@RequestMapping` or more concrete
    annotations, such as `@GetMapping`, `@PostMapping`, or `@PutMapping`, as in this
    example source code fragment:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一种只需要创建带有某些注解的接口来提供组件的方法是Spring Framework的标准做法。对于Feign，必须用`@FeignClient(name
    = "...")`注解接口。它有一个必需的属性名，如果启用了服务发现，则对应于被调用的微服务名称。否则，它与`url`属性一起使用，我们可以设置一个具体的网络地址。`@FeignClient`并不是这里需要使用的唯一注解。我们客户端接口中的每个方法都通过用`@RequestMapping`或更具体的注解如`@GetMapping`、`@PostMapping`或`@PutMapping`来标记，与特定的HTTP
    API端点相关联，正如这个例子源代码片段中所示：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Such components may be injected into the controller bean as they are also Spring
    Beans. Then, we just have to invoke their methods. Here''s the current implementation
    of the REST controller in `order-service`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的组件可以被注入到控制器bean中，因为它们也是Spring Beans。然后，我们只需调用它们的方法。以下是`order-service`中当前REST控制器的实现：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Launching microservices
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动微服务
- en: 'I have changed a configuration for all the microservices in `application.yml`.
    Now, there are two different profiles, the first used for assigning an application
    to `zone1` and the second for `zone2`. You may check out the version from the
    `feign_with_discovery` branch ([https://github.com/piomin/shown here-spring-cloud-comm/tree/feign_with_discovery](https://github.com/piomin/sample-spring-cloud-comm/tree/feign_with_discovery)).
    Then, build the whole project using the `mvn clean install` command. The application
    should be launched with the `java -jar --spring.profiles.active=zone[n]` command,
    where `[n]` is the number of the zone. Because you have to start many instances
    to perform that test, it is worth considering a limit on heap size by setting
    the `-Xmx` parameter, for example, `-Xmx128m`. Here are the current configuration
    settings for one of the microservices:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在`application.yml`中更改了所有微服务的配置。现在，有两个不同的配置文件，第一个用于将应用程序分配给`zone1`，第二个用于`zone2`。你可以从`feign_with_discovery`分支查看版本（[https://github.com/piomin/shown
    here-spring-cloud-comm/tree/feign_with_discovery](https://github.com/piomin/sample-spring-cloud-comm/tree/feign_with_discovery)）。然后，使用`mvn
    clean install`命令构建整个项目。应用应该使用`java -jar --spring.profiles.active=zone[n]`命令启动，其中`[n]`是区域编号。因为你要启动很多实例来执行那个测试，考虑通过设置`-Xmx`参数限制堆大小是有价值的，例如，`-Xmx128m`。以下是其中一个微服务当前的配置设置：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will launch one instance of every microservice per single zone. So, there
    are nine running Spring Boot applications, including the service discovery server,
    as shown in this screenshot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将每个区域启动每一个微服务的一个实例。所以，有九个正在运行的Spring Boot应用程序，包括服务发现服务器，如图所示：
- en: '![](img/0333d3f0-6041-4b5e-98cc-a474b4c5a072.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0333d3f0-6041-4b5e-98cc-a474b4c5a072.png)'
- en: 'If you send the test request to the instance of `order-service` running in
    `zone1` (`http://localhost:8090`), all the traffic will be forwarded to the other
    services in that zone, and the same for `zone2` (`http://localhost:9090`). I have
    highlighted the fragment where the Ribbon client prints a list of found addresses
    of the target service registered in the current zone:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向在`zone1`运行的`order-service`实例（`http://localhost:8090`）发送测试请求，所有流量都将转发到该区域的其他服务，`zone2`（`http://localhost:9090`）也是如此。我突出了Ribbon客户端在该区域注册的目标服务找到的地址列表的片段：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Inheritance support
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承支持
- en: 'You have probably noticed that the annotations inside a controller implementation
    and the Feign client implementation for a REST service served by that controller
    are identical. We may create an interface that contains abstract REST method definitions.
    That interface can be implemented by a controller class or extended by a Feign
    client interface:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，控制器实现内部的注解和为该控制器服务的REST服务的Feign客户端实现是相同的。我们可以创建一个包含抽象REST方法定义的接口。这个接口可以被控制器类实现或者被Feign客户端接口扩展：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, the controller class provides an implementation for all methods from the
    base interface, but does not contain any annotations for REST mappings instead
    of `@RestController`. Here''s a fragment of the `account-service` controller:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，控制器类为基本接口提供了所有方法的实现，但并未包含任何REST映射注解，而只用了`@RestController`。以下是`account-service`控制器的片段：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The Feign client interface for calling `account-service` does not provide any
    methods. It just extends the base interface, `AccountService`. To see the full
    implementation based on interfaces and Feign inheritance, switch to the `feign_with_inheritance` branch:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`account-service`的Feign客户端接口不提供任何方法。它只是扩展了基础接口，`AccountService`。要查看基于接口和Feign继承的全实现，切换到`feign_with_inheritance`分支：
- en: '[https://github.com/piomin/shown here-spring-cloud-comm/tree/feign_with_inheritance](https://github.com/piomin/sample-spring-cloud-comm/tree/feign_with_inheritance)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/piomin/shown here-spring-cloud-comm/tree/feign_with_inheritance](https://github.com/piomin/sample-spring-cloud-comm/tree/feign_with_inheritance)'
- en: 'Here''s an example Feign client declaration with inheritance support. It extends
    the `AccountService` interface, and hence handles all the methods exposed by `@RestController`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个带有继承支持的Feign客户端声明示例。它扩展了`AccountService`接口，因此处理了所有由`@RestController`暴露的方法：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Creating a client manually
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动创建客户端
- en: 'If you are not convinced by the annotation-like style, you may always create
    a Feign client manually using the Feign Builder API. Feign has several features
    that can be customized, such as encoders and decoders for messages or HTTP client
    implementation:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不喜欢注解式的风格，你总是可以手动创建一个Feign客户端，使用Feign Builder API。Feign有多个可以自定义的功能，比如消息的编码器和解码器或HTTP客户端实现：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Client customization
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端定制
- en: 'Client customization can be performed not only with the Feign Builder API,
    but also by using the annotation-like style. We may provide a configuration class
    by setting it with the `configuration` property of `@FeignClient`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端定制不仅可以使用Feign Builder API完成，还可以通过使用注解风格来进行。我们可以通过设置`@FeignClient`的`configuration`属性来提供一个配置类：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'An example configuration bean is shown here:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个配置bean的示例：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Spring Cloud supports the following properties to override by declaring Spring
    Beans:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud支持以下属性通过声明Spring Beans来覆盖：
- en: '`Decoder`: By default, `ResponseEntityDecoder`.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Decoder`：默认是`ResponseEntityDecoder`。'
- en: '`Encoder`: By default, `SpringEncoder`.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Encoder`：默认是`SpringEncoder`。'
- en: '`Logger`: By default, `Slf4jLogger`.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Logger`：默认是`Slf4jLogger`。'
- en: '`Contract`: By default, `SpringMvcContract`.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Contract`：默认是`SpringMvcContract`。'
- en: '`Feign.Builder`: By default, `HystrixFeign.Builder`.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Feign.Builder`：默认是`HystrixFeign.Builder`。'
- en: '`Client`: If Ribbon is enabled, it is `LoadBalancerFeignClient`; otherwise,
    the default Feign client is used.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Client`：如果启用了Ribbon，则是`LoadBalancerFeignClient`；否则，使用默认的Feign客户端。'
- en: '`Logger.Level`: It sets a default log level for Feign. You can choose between
    `NONE`, `BASIC`, `HEADERS` and `FULL`.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Logger.Level`：它为Feign设置了默认日志级别。你可以选择`NONE`、`BASIC`、`HEADERS`和`FULL`之间的一种。'
- en: '`Retryer`: It allows the implementing of the retry algorithm in case of communication
    failure.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Retryer`：它允许在通信失败时实现重试算法。'
- en: '`ErrorDecoder`: It allows the mapping of the HTTP status code into application-specific
    exception.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ErrorDecoder`：它允许将HTTP状态码映射为特定于应用程序的异常。'
- en: '`Request.Options`: It allows setting read and connects timeout for the request.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Request.Options`：它允许为请求设置读取和连接超时。'
- en: '`Collection<RequestInterceptor>`: Collection of registered `RequestInterceptor`
    implementations that perform some actions basing on data taken from request.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collection<RequestInterceptor>`：已注册的`RequestInterceptor`实现集合，根据从请求中获取的数据执行某些操作。'
- en: 'Feign client can also be customized using configuration properties. It is possible
    to override settings for all available clients or only for a single selected client
    by providing its name after the `feign.client.config` property prefix. If we set
    the name `default` instead of a specific client name, it will apply it to all Feign
    clients. Default configurations can also be specified when using the `@EnableFeignClients` annotation and
    its `defaultConfiguration` attribute in a similar way to what was described previously.
    The settings provided in the `appplication.yml` file always have a higher priority
    than the `@Configuration` bean. To change that approach and prefer `@Configuration`
    instead of the YAML file, you should set the `feign.client.default-to-properties` property to
    `false`. Here''s an example Feign client configuration for `account-service` that
    sets connect timeout, read timeout of HTTP connection, and log level:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Feign客户端也可以通过配置属性进行定制。通过在`feign.client.config`属性前缀后提供其名称，可以覆盖所有可用客户端的设置，或仅覆盖单个选定客户端的设置。如果我们设置名为`default`而不是特定客户端名称，它将应用于所有Feign客户端。当使用`@EnableFeignClients`注解及其`defaultConfiguration`属性时，也可以在`appplication.yml`文件中指定默认配置。提供的设置始终优先于`@Configuration`
    bean。如果想要改变这种方法，优先使用`@Configuration`而不是YAML文件，你应该将`feign.client.default-to-properties`属性设置为`false`。以下是一个为`account-service`设置连接超时、HTTP连接的读取超时和日志级别的Feign客户端配置示例：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have launched a couple of microservices that communicate
    with one another. We discussed such topics as different implementations of REST
    clients, load balancing between multiple instances, and integration with service
    discovery. In my opinion, these aspects are so important that I decided to describe
    them in two chapters. This chapter should be treated as an introduction to the subject
    of inter-service communication and a discussion of integration with other important
    components of microservice architecture. The next chapter will show more advanced
    use of load balancers and REST clients, with particular attention on network and
    communication problems. After reading this chapter, you should be able to use
    Ribbon, Feign, and even `RestTemplate` properly in your applications and connect
    them to other Spring Cloud components.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经启动了几个相互通信的微服务。我们讨论了诸如REST客户端的不同实现、多个实例之间的负载均衡以及与服务发现集成等主题。在我看来，这些方面是如此重要，以至于我决定用两章的篇幅来描述它们。本章应被视为微服务间通信主题的介绍，以及对微服务架构中其他重要组件集成的讨论。下一章将展示负载均衡器和REST客户端的高级使用，特别关注网络和通信问题。阅读完本章后，您应该能够在自己的应用程序中正确使用Ribbon、Feign，甚至`RestTemplate`，并将它们连接到Spring
    Cloud的其他组件。
- en: In most cases, this knowledge is enough. However, sometimes you will need to
    customize client-side load balancer configuration or enable more advanced communication
    mechanisms like a circuit breaker or fallback. It is important to understand these
    solutions and their impact on the inter-service communication in your system.
    We will discuss them in the next chapter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，这些知识已经足够。然而，有时您可能需要自定义客户端负载均衡器配置，或者启用像断路器或回退这样的更高级的通信机制。理解这些解决方案及其对您系统中微服务间通信的影响是很重要的。我们将在下一章中讨论它们。
