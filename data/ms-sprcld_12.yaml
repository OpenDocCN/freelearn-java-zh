- en: Securing an API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护API
- en: Security is one of the most commonly discussed problems related to microservices-based
    architecture. There is always one main problem for all security concerns—a network.
    With microservices, where typically there is much more communication over the
    network than there is for monolithic applications, the approach to authentication
    and authorization should be reconsidered. Traditional systems are usually secured
    at the border and then allow the frontend service full access to the backend components.
    The migration to microservices forces us to change this approach to delegated-access
    management.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是关于微服务架构的最常讨论的问题之一。对于所有安全关注，总是有一个主要问题——网络。在微服务中，通常网络通信比单体应用程序多，因此应该重新考虑认证和授权的方法。传统的系统通常在边界处进行安全保护，然后允许前端服务完全访问后端组件。微服务的迁移迫使我们改变这种委托访问管理的方法。
- en: How does Spring Framework address the security concerns of microservices-based
    architecture? It provides several projects that implement different patterns regarding
    authentication and authorization. The first of these is Spring Security, which
    is a de facto standard for secure Spring-based Java applications. It consists
    of a few submodules that help you get started with SAML, OAuth2, or Kerberos.
    There is also the Spring Cloud Security project. It provides several components
    that allow you to integrate basic Spring Security features with the main elements
    of microservices architecture, such as gateways, load balancers, and REST HTTP
    clients.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Framework是如何解决基于微服务的架构的安全问题的？它提供了几个项目，实现了关于认证和授权的不同模式。这些项目中的第一个是Spring
    Security，它是基于Spring的Java应用程序的安全事实标准。它包括几个子模块，可以帮助你开始使用SAML、OAuth2或Kerberos。还有Spring
    Cloud Security项目。它提供了几个组件，允许你将Spring Security的基本功能与微服务架构的主要元素（如网关、负载均衡器和REST HTTP客户端）集成。
- en: In this chapter, I'm going to show you how to secure all the main components
    of your microservices-based system. I will describe the particular elements relevant
    to the topic in the order of the chapters that compose the second part of this
    book. So, we would begin from service discovery with Eureka, then move on to the
    Spring Cloud Config Server and inter-service communication, and then finally discuss
    API gateway security.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将向您展示如何保护您基于微服务的系统中的所有主要组件。我将描述与主题相关的特定元素，按照构成本书第二部分的章节的顺序。所以，我们将从使用Eureka的服务发现开始，然后转移到Spring
    Cloud Config Server和跨服务通信，最后讨论API网关安全。
- en: 'Here''s what we will look at in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下内容：
- en: Configuring a secure connection for a single Spring Boot application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为单个Spring Boot应用程序配置安全连接
- en: Enabling HTTPS communication for the most important elements of microservice-based
    architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为微服务架构的最重要元素启用HTTPS通信
- en: Encrypting and decrypting property values in configuration files stored on Config
    Server
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Config Server上存储的配置文件中加密和解密属性值
- en: Simple in-memory based authentication with OAuth2 for microservices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为微服务使用基于OAuth2的简单内存身份验证
- en: More advanced OAuth2 configuration with JDBC backend store and JWT tokens
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JDBC后端存储和JWT令牌进行更高级的OAuth2配置
- en: Using OAuth2 authorization in inter-service communication with Feign client
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Feign客户端中使用OAuth2授权进行服务间通信
- en: But first, let's begin with the basics. I'll show you how to create your first
    secure microservice that exposes an API over HTTPS.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 但是首先，让我们从基础知识开始。我将向您展示如何创建第一个安全微服务，该微服务通过HTTPS暴露API。
- en: Enabling HTTPS for Spring Boot
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Spring Boot启用HTTPS
- en: 'If you want to use SSL and serve your RESTful APIs over HTTPS, you will need
    to generate a certificate. The fastest way to achieve this is through a self-signed
    certificate, which is enough for development mode. JRE provides a simple tool
    for certificate management—`keytool`. It is available under your `JRE_HOME\bin`
    directory. The command in the following code generates a self-signed certificate
    and puts it into the PKCS12 KeyStore. Besides KeyStore''s type, you will also
    have to set its validity, alias, and the name of the file. Before starting the
    generation process, `keytool` will ask you for your password and some additional
    information, as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要使用SSL并为您提供RESTful API的HTTPS服务，您需要生成一个证书。实现这一目标最快的途径是通过自签名证书，这对于开发模式来说已经足够了。JRE提供了一个简单的证书管理工具——`keytool`。它位于您的`JRE_HOME\bin`目录下。以下代码中的命令生成一个自签名证书并将其放入PKCS12
    KeyStore中。除了KeyStore的类型之外，您还需要设置其有效期、别名以及文件名。在开始生成过程之前，`keytool`会要求您输入密码和一些其他信息，如下所示：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'I have copied the generated certificate into the `src/main/resources` directory
    inside the Spring Boot application. After building and running the application,
    it will be available on the classpath. To enable SSL, we have to provide some
    configuration settings in the `application.yml` file. SSL can be customized for
    Spring by setting the various `server.ssl.*` properties:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将生成的证书复制到了Spring Boot应用程序内的`src/main/resources`目录中。在构建并运行应用程序后，它将出现在类路径上。为了启用SSL，我们必须在`application.yml`文件中提供一些配置设置。通过设置各种`server.ssl.*`属性，可以为Spring自定义SSL：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Secure discovery
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全发现
- en: As you can see, the configuration of SSL for a microservice application is not
    a very hard task. However, it is time to increase the difficulty level. We have
    already launched a single microservice that serves a RESTful API over HTTPS. Now
    we want that microservice to integrate with the discovery server. There are two
    problems that arise from this. The first of these is the need to publish information
    about the secure microservice's instance in Eureka. The second of these concerns
    exposing Eureka over HTTPS and forcing the discovery client to authenticate against
    a discovery server using a private key. Let's discuss these issues in detail.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，为微服务应用程序配置SSL并不是一个非常困难的任务。然而，现在是提高难度级别的时候了。我们已经启动了一个单一的微服务，它通过HTTPS提供RESTful
    API。现在我们想要这个微服务与发现服务器集成。由此产生的两个问题，首先是需要在Eureka中发布关于安全微服务实例的信息。第二个问题是如何通过HTTPS暴露Eureka，并强制发现客户端使用私钥对发现服务器进行身份验证。让我们详细讨论这些问题。
- en: Registering a secure application
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册安全应用程序
- en: 'If your application is exposed over a secure SSL port, you should change two
    flags from the `EurekaInstanceConfig`—`nonSecurePortEnabled` to `false` and `securePortEnabled`
    to `true`. This forces Eureka to publish instance information that shows an explicit
    preference for secure communication. The Spring Cloud `DiscoveryClient` will always
    return a URL starting with HTTPS for a service that is configured this way, and
    the Eureka instance information will have a secure health check URL:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序通过安全的SSL端口暴露，您应该将`EurekaInstanceConfig`中的两个标志更改为`nonSecurePortEnabled`为`false`和`securePortEnabled`为`true`。这使得Eureka发布显式偏好安全通信的实例信息。对于这样配置的服务，Spring
    Cloud `DiscoveryClient`总是会返回一个以HTTPS开头的URL，并且Eureka实例信息将有一个安全的健康检查URL：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Serving Eureka over HTTPS
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过HTTPS提供Eureka
- en: When the Eureka server starts with Spring Boot, it is deployed on an embedded
    Tomcat container, so the SSL configuration is the same as for the standard microservice.
    The difference is that we must take account of the client-side application, which
    establishes a secure connection with a discovery server over HTTPS. The discovery
    client should authenticate itself against the Eureka server and it should also
    verify the server's certificate. That communication process between client and
    server is called **two-way SSL** or **mutual authentication**. There is also one-way
    authentication, which is in fact the default option, where only the client validates
    the server's public key. Java applications use KeyStore and trustStore for storing
    private keys and certificates corresponding to public keys. The only difference
    between trustStore and KeyStore is what they store and for what purpose. When
    an SSL handshake between client and server is performed, a trustStore is used
    to verify the credentials, while a KeyStore is used to provide credentials. So
    in other words, a KeyStore keeps a private key and certificate for a given application,
    while a trustStore keeps the certificates that are used to identify it from the
    third party. Developers often do not pay much attention to those terms when configuring
    a secure connection, but a proper understanding of them helps you to easily understand
    what will happen next.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Spring Boot启动Eureka服务器时，它部署在嵌入式Tomcat容器中，因此SSL配置与标准微服务相同。区别在于我们必须考虑客户端应用程序，它通过HTTPS与发现服务器建立安全连接。发现客户端应该对自己进行身份验证，以对抗Eureka服务器，并且还应该验证服务器的证书。客户端和服务器之间的这种通信过程称为**双向SSL**或**相互认证**。还有一种单向认证，实际上是默认选项，其中只有客户端验证服务器的公钥。Java应用程序使用KeyStore和trustStore来存储与公钥对应的私钥和证书。trustStore和KeyStore之间的唯一区别在于它们存储的内容和目的。当客户端和服务器之间执行SSL握手时，trustStore用于验证凭据，而KeyStore用于提供凭据。换句话说，KeyStore为给定应用程序保存私钥和证书，而trustStore保存用于从第三方识别它的证书。开发者在配置安全连接时通常不会过多关注这些术语，但正确理解它们可以帮助您轻松了解接下来会发生什么。
- en: 'In a typical microservices-based architecture, there are plenty of independent
    applications and a single discovery server. Every application has its own private
    key stored in a KeyStore and a certificate corresponding to a discovery server''s
    public key in a trustStore. On the other hand, the server keeps all the certificates
    generated for the client-side applications. That''s enough theory for now. Let''s
    take a look at the following figure. It illustrates the current situation of our
    system that was used as an example in the previous chapters:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的基于微服务的架构中，有大量的独立应用程序和一个发现服务器。每个应用程序都有自己的私钥存储在KeyStore中，以及对应于发现服务器公钥的证书存储在trustStore中。另一方面，服务器保留了为客户端应用程序生成的所有证书。现在我们已经有了足够多的理论。让我们看看下面的图表。它说明了我们在前几章中用作示例的系统的当前情况：
- en: '![](img/4bdd8fff-ba4d-4694-82b7-5cd6658b7582.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4bdd8fff-ba4d-4694-82b7-5cd6658b7582.png)'
- en: Keystore generation
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Keystore生成
- en: 'After discussing the basics regarding security in Java, we may proceed to the
    generation of private and public keys for our microservices. Just like before,
    we will use the command-line tool provided under JRE—`keytool`. Let''s begin with
    a well-known command for generating a `keystore` file with a key pair. One KeyStore
    is generated for a discovery server, and a second for the one selected microservice,
    in this particular case, for `account-service`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了Java安全性的基础知识之后，我们可以继续生成微服务的私钥和公钥。像以前一样，我们将使用JRE下的命令行工具——`keytool`。让我们从一个生成`keystore`文件的键对的知名命令开始。一个KeyStore为发现服务器生成，另一个为选定的微服务生成，在本例中，为`account-service`生成：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, the self-signed certificate has to be exported from a KeyStore to a file—for
    example, with a `.cer` or `.crt` extension. You will then be prompted for the
    password you provided during the KeyStore''s generation:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，必须将自签名证书从KeyStore导出到文件中——例如，具有`.cer`或`.crt`扩展名。然后系统会提示您输入在生成KeyStore时提供的密码：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The certificate corresponding to the public key has been extracted from the
    KeyStore, so now it can be distributed to all interested parties. The public certificate
    from `account-service` should be included in the discovery server''s trustStore
    and vice-versa:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从KeyStore中提取了与公钥对应的证书，因此现在它可以分发给所有感兴趣的各方。`account-service`的公共证书应该包含在发现服务器的trustStore中，反之亦然：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The same steps that were performed for `account-service `have to be repeated
    for each subsequent microservice that registers itself in the Eureka server. Here
    are the keytool''s commands used for generating SSL keys and certificates for
    `order-service`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对`account-service`执行的相同步骤也必须重复应用于每个随后注册自己的Eureka服务器的微服务。以下是`order-service`生成SSL密钥和证书时使用的`keytool`命令：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Configurating SSL for microservices and Eureka server
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为微服务和Eureka服务器配置SSL
- en: 'Each `keystore` file has been placed in the `src/main/resources` directory
    of every secure microservice and service discovery. The SSL configuration settings
    of every microservice are very similar to those from the example in the section
    titled *Enabling HTTPS for Spring Boot*. The only difference is the type of currently
    used KeyStore, which is now JKS instead of PKCS12\. However, there are more differences
    between the earlier sample and the service discovery configuration. First, I have
    enabled client certificate authentication by setting the `server.ssl.client-auth` property to
    `need`. This in turn requires us to provide a trustStore with the `server.ssl.trust-store`
    property. Here are the current SSL configuration settings in `application.yml`
    for `discovery-service`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`keystore`文件都被放置在每个安全微服务和服务发现`src/main/resources`目录中。每个微服务的SSL配置设置与*启用Spring
    Boot HTTPS*节中的示例非常相似。唯一的区别是当前使用的KeyStore类型，现在是JKS而不是PKCS12。然而，早期示例与服务发现配置之间还有更多区别。首先，我通过将`server.ssl.client-auth`属性设置为`need`来启用了客户端证书认证。这反过来要求我们提供一个`server.ssl.trust-store`属性的trustStore。以下是`discovery-service`的`application.yml`中的当前SSL配置设置：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you run the Eureka application with the preceding configuration and then
    try to visit its web dashboard available under `https://localhost:8761/`, you
    will probably get an error code like `SSL_ERROR_BAD_CERT_ALERT`. This error occurs
    because there is no trusted certificate imported to your web browser. For this
    purpose, we may import one of the client''s application KeyStores, from `account-service`,
    for example. But first, we need to convert it from JKS format to another format
    supported by a web browser, such as PKCS12\. Here''s the `keytool` command for
    the conversion of KeyStore from JKS to PKCS12 format:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用前面的配置运行Eureka应用程序，然后尝试访问其可通过`https://localhost:8761/`访问的网络仪表板，您可能会得到一个错误代码，如`SSL_ERROR_BAD_CERT_ALERT`。出现这个错误是因为您的网络浏览器中没有导入可信证书。为此，我们可以导入一个客户端应用程序的KeyStore，例如`account-service`的。但首先，我们需要将其从JKS格式转换为受网络浏览器支持的另一种格式，例如PKCS12。以下是`keytool`命令，用于将KeyStore从JKS格式转换为PKCS12格式：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'PKCS12 is supported by all the most popular web browsers, such as Google Chrome
    and Mozilla Firefox. You can import a PKCS12 KeyStore to Google Chrome by navigating
    to the section Settings *|* Show advanced settings... | HTTPS/SSL *|* Manage certificates.
    If you try to visit the Eureka web dashboard one more time, you should be authenticated
    successfully, and you will be able to see the list of registered services. However,
    there will be no application registered there. In order to provide secure communication
    between the discovery clients and the server, we need to create a `@Bean` of a `DiscoveryClientOptionalArgs` type for
    every microservice, which overwrites the discovery client''s implementation. What
    is interesting is that Eureka uses Jersey as a REST client. With `EurekaJerseyClientBuilder`,
    we may easily build a new client implementation and pass the `keystore` and `truststore`
    file''s location. The following is the code fragment from `account-service`, where
    we create a new `EurekaJerseyClient` object and set it as an argument of `DiscoveryClientOptionalArgs`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: PKCS12格式被所有主流的网络浏览器支持，比如Google Chrome和Mozilla Firefox。您可以通过导航到设置*|*显示高级设置...|HTTPS/SSL*|*管理证书部分，在Google
    Chrome中导入PKCS12 KeyStore。如果您再次尝试访问Eureka网络仪表板，您应该能够成功认证，并能够看到已注册服务列表。然而，在那里注册的应用程序将不存在。为了在发现客户端和服务器之间提供安全的通信，我们需要为每个微服务创建一个`@Bean`类型的`DiscoveryClientOptionalArgs`，覆盖发现客户端的实现。有趣的是，Eureka使用Jersey作为REST客户端。使用`EurekaJerseyClientBuilder`，我们可以轻松地构建一个新的客户端实现，并传递`keystore`和`truststore`文件的路径。以下是从`account-service`中获取的代码片段，我们创建了一个新的`EurekaJerseyClient`对象，并将其设置为`DiscoveryClientOptionalArgs`的参数：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A similar implementation should be provided for every microservice in our sample
    system. A sample application source code is available on GitHub ([https://github.com/piomin/sample-spring-cloud-security.git](https://github.com/piomin/sample-spring-cloud-security.git)).
    You may clone it and run all the Spring Boot applications with your IDE. If everything
    works, you should see the same list of registered services in the Eureka dashboard
    as you can see in the following screenshot. In case of any problem with the SSL
    connection, try and set the `-Djava.net.debug=ssl` VM argument during the boot
    of the application to be able to check out the full logs from the SSL handshake
    process:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例系统中的每个微服务都应该提供类似的实现。一个示例应用程序的源代码可以在GitHub上找到([https://github.com/piomin/sample-spring-cloud-security.git](https://github.com/piomin/sample-spring-cloud-security.git))。你可以克隆它，并用你的IDE运行所有的Spring
    Boot应用程序。如果一切正常，你应该在Eureka仪表板上看到与以下屏幕截图相同的注册服务列表。如果SSL连接有任何问题，尝试在应用程序启动时设置`-Djava.net.debug=ssl`
    VM参数，以能够查看SSL握手过程的完整日志：
- en: '![](img/450b5cda-04ec-455d-acc3-8fc21cf2d768.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/450b5cda-04ec-455d-acc3-8fc21cf2d768.png)'
- en: Secure configuration server
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全配置服务器
- en: There is one other key element in our architecture that should be considered
    during our discussion about security—the Spring Cloud Config Server. I would say
    that it is even more important to protect the config server than the discovery
    service. Why? Because we usually store their authentication credentials to the
    external systems, along with other data that should be hidden from unauthorized
    access and usage. There are several ways to properly secure your config server.
    You may configure an HTTP basic authentication, a secure SSL connection, encrypt/decrypt
    sensitive data, or use third-party tools such as those already described in [Chapter
    5](37142825-02d0-48a0-99df-1a1a88a1bbd4.xhtml), Distributed Configuration with
    Spring Cloud Config. Let's take a closer look at some of them.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们架构中还有一个关键要素需要在讨论安全时考虑——Spring Cloud Config 配置服务器。我觉得保护配置服务器甚至比保护发现服务更为重要。为什么？因为我们通常将它们的认证凭据存储在外部系统上，还有其他一些不应该被未授权访问和使用的数据。有几种方法可以妥善保护你的配置服务器。你可以配置HTTP基本认证，安全的SSL连接，加密/解密敏感数据，或者使用第三方工具，如在[第5章](37142825-02d0-48a0-99df-1a1a88a1bbd4.xhtml)中介绍的，使用Spring
    Cloud Config进行分布式配置。让我们 closer 看看其中的一些。
- en: Encryption and decryption
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密和解密
- en: Before we begin, we have to download and install the **Java Cryptography Extension**
    (**JCE**) provided by Oracle. It consists of two JAR files (`local_policy.jar`
    and `US_export_policy.jar`), which need to override the existing policy files
    in the JRE lib/security directory.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们必须下载并安装由Oracle提供的**Java Cryptography Extension**（**JCE**）。它包括两个JAR文件（`local_policy.jar`和`US_export_policy.jar`），需要覆盖JRE
    lib/security目录中现有的策略文件。
- en: If the remote property sources stored on the config server contain encrypted
    data, their values should be prefixed with `{cipher}` and wrapped in quotes to
    designate it as a YAML file. Wrapping in quotes is not necessary for `.properties`
    files. If such a value cannot be decrypted, it is replaced by an additional value
    (usually `<n/a>`) under the same key prefixed with `invalid`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果配置服务器上存储的远程属性源包含加密数据，它们的值应该以`{cipher}`为前缀，并用引号括起来，以表示它是一个YAML文件。对于`.properties`文件，不需要用引号括起来。如果无法解密这样的值，它将被替换为同样的键前缀`invalid`的附加值（通常是`<n/a>`）。
- en: In our last sample, we stored the passphrase used for protecting the `keystore`
    file in the application configuration settings. Keeping it there as a plain text
    file may not be the best idea, so it is the first candidate for encryption. The
    question is, how do we encrypt it? Fortunately, Spring Boot provides two RESTful
    endpoints that can help with that.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们上一个示例中，我们在应用程序配置设置中存储了用于保护`keystore`文件的密码短语。将其保存在纯文本文件中可能不是最好的主意，所以它是加密的第一候选。问题是，我们如何加密它？幸运的是，Spring
    Boot提供了两个RESTful端点可以帮助实现。
- en: 'Let''s see how it works. First, we need to start a config server instance.
    The simplest way for this is to activate the `--spring.profiles.active=native` profile,
    which launches the server with the property sources from the local classpath or
    filesystem. Now we may call two POST endpoints `/encrypt` and `/decrypt`. The
    `/encrypt` method takes our plain-text password as an argument. The result can
    be checked out using an inverse operation, `/decrypt`, which takes an encrypted
    password as a parameter:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的。首先，我们需要启动一个配置服务器实例。最简单的方法是激活`--spring.profiles.active=native`配置文件，该配置文件会使用来自本地类路径或文件系统的属性源来启动服务器。现在我们可以调用两个POST端点`/encrypt`和`/decrypt`。`/encrypt`方法接受我们的明文密码作为参数。我们可以通过使用逆操作`/decrypt`，它接受一个加密密码作为参数，来检查结果：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The encryption is done with the public key, while the decryption is done with
    the private key. Therefore, you need to provide only the public key in the server
    if you perform just the encryption. For testing purposes, we can create the KeyStore
    using `keytool`. We have already created some KeyStores before, so you will not
    have any problems with that. The generated file should be placed in the classpath
    and then in the `config-service` configuration settings using `encrypt.keyStore.*`
    properties:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 加密使用公钥，而解密使用私钥。因此，如果你只进行加密，那么在服务器上只需提供公钥即可。出于测试目的，我们可以使用`keytool`创建KeyStore。我们之前已经创建了一些KeyStores，所以在这方面你不会有任何问题。生成的文件应该放在类路径中，然后在`config-service`配置设置中使用`encrypt.keyStore.*`属性：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, if you move the configuration settings of each microservice to the config
    server, you can encrypt every password, as shown in the following sample fragment:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你将每个微服务的配置设置移动到配置服务器，你可以像下面示例片段中那样加密每个密码：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Configuring authentication for a client and a server
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为客户端和服务器配置认证
- en: The implementation of authentication for Spring Cloud Config Server looks exactly
    the same as for the Eureka server. We can use an HTTP basic authentication basing
    on standard Spring security mechanisms. First, we need to make sure that the `spring-security`
    artifact is on the classpath. Then we should enable security with `security.basic.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Config服务器的认证实现与Eureka服务器的认证实现完全一样。我们可以使用基于标准Spring安全机制的HTTP基本认证。首先，我们需要确保`spring-security`工件在类路径上。然后我们应该使用`security.basic.
- en: 'enabled` set to `true` and define a username and password. The sample configuration
    settings are visible in the following code fragment:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将`enabled`设置为`true`并定义用户名和密码。示例配置设置如下代码片段所示：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The basic authentication must also be enabled on the client side. It can be
    realized in two different ways. The first of these is via the config server URL:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 基本认证必须在客户端也启用。这可以通过两种不同的方式实现。第一种是通过配置服务器的URL：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The second approach is based on separate `username` and `password` properties:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法基于独立的`username`和`password`属性：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you would like to set up SSL authentication, you need to follow the steps
    described in the section titled *Secure discovery*. After generating the KeyStores
    with private keys and certificates and setting the proper configuration, we may
    run the config server. Now, it is exposing its RESTful API over HTTPS. The only
    difference is in the implementation on the client side. This is because Spring
    Cloud Config uses a different HTTP client than Spring Cloud Netflix Eureka. As
    you may probably guess, it leverages `RestTemplate`, as it is entirely created
    within the Spring Cloud project.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想设置SSL认证，你需要遵循*安全发现*部分描述的步骤。在生成带有私钥和证书的KeyStores并设置正确的配置之后，我们可以运行配置服务器。现在，它通过HTTPS暴露其RESTful
    API。唯一的区别在于客户端的实现。这是因为Spring Cloud Config使用的是与Spring Cloud Netflix Eureka不同的HTTP客户端。正如你可能猜到的，它利用了`RestTemplate`，因为它是完全在Spring
    Cloud项目中创建的。
- en: 'To force the client-side application to use two-way SSL authentication instead
    of a standard, nonsecure HTTP connection, first we should create a `@Configuration`
    bean implementing the `PropertySourceLocator` interface. There, we may build a
    custom `RestTemplate` that uses a secure HTTP connection factory:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强制客户端应用程序使用双向SSL认证而不是标准的、不安全的HTTP连接，我们首先应该创建一个实现`PropertySourceLocator`接口的`@Configuration`bean。在那里，我们可以构建一个自定义的`RestTemplate`，它使用一个安全的HTTP连接工厂：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'However, by default, this bean would not be created before the application
    tries to establish a connection with the config server. To change this behavior,
    we should also create the `spring.factories` file in `/src/main/resources/META-INF`
    and specify the custom bootstrap configuration class:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，默认情况下，这个bean在应用程序尝试与配置服务器建立连接之前不会被创建。要改变这种行为，我们还应该在`/src/main/resources/META-INF`中创建`spring.factories`文件，并指定自定义的引导配置类：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Authorization with OAuth2
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OAuth2进行授权
- en: We have already discussed some concepts and solutions related to authentication
    in a microservices environment. I have shown you the examples of basic and SSL
    authentication between microservices and a service discovery, and also between
    microservices and a config server. In inter-service communication, authorization
    seems to be more important then authentication, which is instead implemented on
    the edge of the system. It's worth understanding the difference between authentication
    and authorization. Simply put, authentication verifies who you are, while authorization
    verifies what you are authorized to do.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了一些与微服务环境中的认证相关的概念和解决方案。我向您展示了微服务之间以及微服务与服务发现和配置服务器之间的基本和SSL认证的例子。在服务间通信中，授权似乎比认证更重要，而认证则实现在系统的边缘。理解认证和授权之间的区别是值得的。简单地说，认证验证你是谁，而授权验证你被授权做什么。
- en: Currently the most popular authorization methods for RESTful HTTP APIs are OAuth2
    and **Java Web Tokens** (**JWT**). They may be mixed together as they are rather
    more complementary than other solutions. Spring provides support for OAuth providers
    and consumers. With Spring Boot and Spring Security OAuth2, we may quickly implement
    common security patterns, such as single sign-on, token relay, or token exchange.
    But before we dive into the details regarding those projects, as well as other
    development details, we need to acquire a basic knowledge of the preceding solution.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 目前最流行的RESTful HTTP API授权方法是OAuth2和**Java Web Tokens**（**JWT**）。它们可以混合使用，因为它们互补性比其他解决方案要强。Spring为OAuth提供商和消费者提供了支持。借助Spring
    Boot和Spring Security OAuth2，我们可以快速实现常见的 security patterns，如单点登录、令牌传递或令牌交换。但在我们深入了解这些项目以及其他开发细节之前，我们需要先掌握前面解决方案的基本知识。
- en: Introduction to OAuth2
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth2简介
- en: 'OAuth2 is the standard currently used by almost all major websites that allow
    you to access their resources through a shared API. It delegates user authentication
    to an independent service that stores user credentials and authorizes third-party
    applications to access shared information about users'' accounts. OAuth2 is used
    for giving your users access to data while protecting their account credentials.
    It provides flows for web, desktop, and mobile applications. The following are
    some basic terms and roles related to OAuth2:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth2是目前几乎所有主要网站所使用的标准，它允许您通过共享API访问他们的资源。它将用户认证委托给一个独立的服务，该服务存储用户凭据并授权第三方应用程序访问关于用户账户的共享信息。OAuth2用于在保护用户账户凭据的同时给予您的用户访问数据的能力。它为web、桌面和移动应用程序提供了流程。以下是与OAuth2相关的一些基本术语和角色：
- en: '**Resource owner**: This role governs access to the resource. This access is
    limited by the scope of the granted authorization.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源所有者**：这个角色管理对资源的访问。这种访问受授予授权的范围限制。'
- en: '**Authorization grant**: This grants permission for access. There are various
    ways you may choose to confirm access—authorization code, implicit, resource-owner
    password credentials, and client credentials.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权许可**：它授予访问权限。您可以选择以各种方式确认访问——授权代码、隐式、资源所有者密码凭据和客户端凭据。'
- en: '**Resource server**: This is a server that stores the owner’s resources that
    can be shared using a special token.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源服务器**：这是一个存储可以使用特殊令牌共享所有者资源的服务器。'
- en: '**Authorization server**: This manages the allocation of keys, tokens, and
    other temporary resource access codes. It also has to ensure that access is granted
    to the relevant user.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权服务器**：它管理密钥、令牌和其他临时资源访问代码的分配。它还需要确保授予相关用户的访问权限。'
- en: '**Access token**: This is a key that allows access to a resource.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问令牌**：这是一个允许访问资源的钥匙。'
- en: 'In order to better understand what these terms and roles are in practice, take
    a look at the following diagram. It visualizes a typical flow of the authorization
    process using the OAuth protocol:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这些术语和实践中的角色，请看下面的图表。它通过OAuth协议可视化了一个典型的授权过程流程：
- en: '![](img/fb8ff8a6-c870-4ff5-a776-a7f0aedcc84a.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb8ff8a6-c870-4ff5-a776-a7f0aedcc84a.png)'
- en: Let's run through the further steps of interaction between the individual components
    listed previously. The application requests authorization from the resource owner
    in order to be able to access the requested service. The resource sends an authorization
    grant as the response, which is then sent by the application, together with its
    own identity, to the authorization server. The authorization server verifies the
    application identity's credentials and authorization grant, and then sends an
    access token back. The application requests the resource from the resource server
    using a received access token. Finally, if the access token is valid, the application
    is able to invoke the request service.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下前面列出个别组件之间交互的进一步步骤。应用程序请求资源所有者的授权，以便能够访问所请求的服务。资源以授权授予作为响应发送，应用程序将其与自身的身份一起发送到授权服务器。授权服务器验证应用程序身份凭据和授权授予，然后发送访问令牌。应用程序使用收到的访问令牌从资源服务器请求资源。最后，如果访问令牌有效，应用程序能够调用请求服务。
- en: Building an authorization server
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建授权服务器
- en: 'After moving from monolithic applications to microservices, the obvious solution
    seems to be the centralization of the authorization effort by creating an authorization
    service. With Spring Boot and Spring Security, you may easily create, configure,
    and launch an authorization server. First, we need to include the following `starters`
    to the project dependencies:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从单体应用程序移动到微服务后，明显的解决方案似乎是通过创建一个授权服务来集中授权努力。使用Spring Boot和Spring Security，你可以轻松地创建、配置和启动一个授权服务器。首先，我们需要将以下`starters`包括到项目依赖中：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The implementation of an authorization server pattern with Spring Boot is very
    easy. We just have to annotate the main class or the configuration class with
    `@EnableAuthorizationServer` and then provide `security.oauth2.client.client-id`
    and `security.oauth2.client.client-secret` properties in the `application.yml`
    file. Of course, this variant is as simple as possible, since it defines an in-memory
    implementation of the client details service.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring Boot实现授权服务器模式非常简单。我们只需要将主类或配置类注解为`@EnableAuthorizationServer`，然后提供`security.oauth2.client.client-id`和`security.oauth2.client.client-secret`属性在`application.yml`文件中。当然，这个变体尽可能简单，因为它定义了客户端详情服务的内存实现。
- en: 'A sample application is available in the same repository as the previous samples
    in this chapter ([https://github.com/piomin/sample-spring-cloud-security.git](https://github.com/piomin/sample-spring-cloud-security.git)),
    but in a different branch, `oauth2` ([https://github.com/piomin/sample-spring-cloud-security/tree/oauth2](https://github.com/piomin/sample-spring-cloud-security/tree/oauth2)).
    The authorization server is available under the `auth-service` module. Here''s
    the main class of `auth-service`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例应用程序在同一存储库中，本章之前的示例中([https://github.com/piomin/sample-spring-cloud-security.git](https://github.com/piomin/sample-spring-cloud-security.git))，但在不同的分支，`oauth2`
    ([https://github.com/piomin/sample-spring-cloud-security/tree/oauth2](https://github.com/piomin/sample-spring-cloud-security/tree/oauth2))。授权服务器在`auth-service`模块下可用。以下是`auth-service`的主类：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here is the fragment of the application''s configuration settings. In addition
    to the client''s ID and secret, I have also set its default scope and enabled
    basic security for the whole project:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是应用程序配置设置的片段。除了客户端的ID和密钥外，我还设置了它的默认范围并在整个项目中启用了基本安全：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After running our authorization service, we may perform some tests. For example,
    we may call the `POST /oauth/token` method in order to create an access token
    using resource owner password credentials, just like in the following command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行授权服务之后，我们可以进行一些测试。例如，我们可以调用`POST /oauth/token`方法，使用资源所有者密码凭证来创建访问令牌，就像以下命令一样：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We may also use an authorization code grant type by calling the `GET /oauth/authorize`
    endpoint from your web browser:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过从你的网络浏览器调用`GET /oauth/authorize`端点来使用授权码授权类型：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After that, you will be redirected to the approval page. You may confirm the
    action and finally get your access token. It will be sent to the callback URL
    passed in the `redirect_uri` parameter of the initial request. Here''s the sample
    response that I received after my test:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将被重定向到批准页面。你可能确认这个动作，最后得到你的访问令牌。它将被发送到初始请求中`redirect_uri`参数传递的回调URL。以下是我测试后收到的示例响应：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![](img/7e5e41f0-0bd3-4691-aea9-a93b0ecf709a.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7e5e41f0-0bd3-4691-aea9-a93b0ecf709a.png)'
- en: 'The same OAuth2 configuration that was provided within the `application.yml`
    file can be also implemented programatically. In order to achieve this, we should
    declare any `@Beans` that implements `AuthorizationServerConfigurer`. One of these
    is the `AuthorizationServerConfigurerAdapter` adapter, which provides empty methods,
    allowing you to create custom definitions of the following separated configurers:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`application.yml`文件内提供的相同的OAuth2配置也可以以编程方式实现。为了实现这一点，我们应该声明任何实现`AuthorizationServerConfigurer`的`@Beans`。其中的一个是`AuthorizationServerConfigurerAdapter`适配器，它提供空方法，允许您创建以下分离配置器的自定义定义：
- en: '`ClientDetailsServiceConfigurer`: This defines the client details service.
    Client details can be initialized, or you can just refer to an existing store.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClientDetailsServiceConfigurer`：这定义了客户端详情服务。客户端详情可以初始化，或者你可以简单地引用一个现有的存储。'
- en: '`AuthorizationServerSecurityConfigurer`: This defines the security constraints
    on the token endpoints `/oauth/token_key` and `/oauth/check_token`.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AuthorizationServerSecurityConfigurer`：这定义了在`/oauth/token_key`和`/oauth/check_token`令牌端点上的安全约束。'
- en: '`AuthorizationServerEndpointsConfigurer`: This defines the authorization and
    token endpoints and the token services.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AuthorizationServerEndpointsConfigurer`：这定义了授权和令牌端点以及令牌服务。'
- en: 'This approach to the authorization server implementation gives us many more
    opportunities. For example, we may define more than one client with an ID and
    a secret, as shown in the following code fragment. I''ll show you some more advanced
    samples in the next part of this chapter:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对授权服务器实现的方法为我们提供了更多的机会。例如，我们可以定义一个带有ID和密钥的多个客户端，如下面的代码片段所示。我将在本章的下一部分展示一些更高级的示例：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The last thing that has to be configured for our authorization server is web
    security. In the class extending `WebSecurityConfigurerAdapter`, we have defined
    an in-memory user credentials store and permissions to access specific resources,
    such as a login page:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须为我们的授权服务器配置的最后一件事情是网络安全。在扩展了`WebSecurityConfigurerAdapter`的类中，我们定义了一个内存中的用户凭据存储和访问特定资源的权限，例如登录页面：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Client configuration
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端配置
- en: Your application can use the OAuth2 client that is configured in two different
    ways. The first of these ways is through the `@EnableOAuth2Client` annotation,
    which creates a filter bean with an ID of `oauth2ClientContextFilter` that is
    responsible for storing the request and context. It also manages communication
    between your application and an authorization server. However, we will be looking
    at the second approach to OAuth2's client-side implementation, through `@EnableOAuth2Sso`.
    **Single sign-on** (**SSO**) is a well-known security pattern that allows a user
    to use one set of login credentials to access multiple applications. There are
    two features provided by this annotation—the OAuth2 client and the authentication.
    The authentication piece aligns your application with the typical Spring Security
    mechanisms, such as a form login. The client piece has the same functionality
    as that provided by `@EnableOAuth2Client`. So, we may think of `@EnableOAuth2Sso`
    as just a higher level annotation than `@EnableOAuth2Client`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序可以使用配置的OAuth2客户端以两种不同的方式。这两种方式中的第一种是通过`@EnableOAuth2Client`注解，它创建了一个ID为`oauth2ClientContextFilter`的过滤器bean，负责存储请求和上下文。它还负责管理您应用程序与授权服务器之间的通信。然而，我们将查看OAuth2客户端端实现的第二种方法，通过`@EnableOAuth2Sso`。**单点登录**（**SSO**）是一个众所周知的安全模式，允许用户使用一组登录凭据访问多个应用程序。这个注解提供了两个特性——OAuth2客户端和认证。认证部分使您的应用程序与典型的Spring
    Security机制（如表单登录）对齐。客户端部分具有与`@EnableOAuth2Client`提供的功能相同的功能。因此，我们可以将`@EnableOAuth2Sso`视为比`@EnableOAuth2Client`更高层次的注解。
- en: 'In the following sample code fragment, I have annotated the class that extends
    `WebSecurityConfigurerAdapter` with `@EnableOAuth2Sso`. Thanks to this extension,
    Spring Boot configures the security filter chain that carries the OAuth2 authentication
    processor. In this case, requests to the `/login` page are permitted, while all
    other requests require authentication. The form login page path may be overridden
    with the `security.oauth2.sso.login-path` property. After overriding it there,
    we should also remember to change the path pattern inside `WebSecurityConfig`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例代码片段中，我用`@EnableOAuth2Sso`注解了扩展了`WebSecurityConfigurerAdapter`的类。得益于这个扩展，Spring
    Boot配置了携带OAuth2身份处理器的网络安全过滤链。在这种情况下，允许访问`/login`页面，而所有其他请求都需要认证。表单登录页面路径可以通过`security.oauth2.sso.login-path`属性进行覆盖。在覆盖它之后，我们还应该记得在`WebSecurityConfig`内部更改路径模式：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'There are also some configuration settings that need to be set. First, we should
    disable basic authentication, because we use the form login method enabled together
    with the `@EnableOAuth2Sso` annotation. Then, we have to provide some basic OAuth2
    client properties, such as client credentials and the addresses of the HTTP API
    endpoints exposed by the authorization server:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些需要设置的配置设置。首先，我们应该禁用基本认证，因为我们使用了与`@EnableOAuth2Sso`注解一起启用的表单登录方法。然后，我们必须提供一些基本的OAuth2客户端属性，例如客户端凭据和授权服务器公开的HTTP
    API端点的地址：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The last property from the fragment of the `application.yml` file is `security.oauth2.resource.userInfoUri`,
    which requires an additional endpoint on the server side. The endpoint implemented
    by `UserController` returns the `java.security.Principal` object, indicating the
    currently authenticated user:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`application.yml`文件片段中的最后一个属性是`security.oauth2.resource.userInfoUri`，这需要在服务器端实现一个额外的端点。`UserController`实现的端点返回`java.security.Principal`对象，表示当前认证的用户：'
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, if you invoke any endpoint exposed by one of our microservices, you will
    be automatically redirected to the login page. Since we set an `autoApprove` option for
    our in-memory clients' details store, the authorization grant and access token
    are generated automatically without any interaction from the user. After providing
    your credentials in the login page, you should get the response from the requested
    resource.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您调用我们微服务中公开的任何端点，您将自动重定向到登录页面。由于我们为内存中的客户端详细信息存储设置了`autoApprove`选项，因此授权授予和访问令牌无需用户任何交互即可自动生成。在登录页面提供您的凭据后，您应该能够获得请求资源的响应。
- en: Using the JDBC backend store
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JDBC后端存储
- en: In the previous sections, we configured an authentication server and client
    application, which grants access to the resources protected by the resource server.
    However, the whole authorization server configuration has been provided inside
    in-memory storage. Such a solution meets our needs during development, but it
    is not the most desirable approach in production mode. The target solution should
    store all the authentication credentials and tokens in the database. We may choose
    between many relational databases supported by Spring. In this case, I have decided
    to use MySQL.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几节中，我们配置了一个认证服务器和客户端应用程序，它授予访问受资源服务器保护的资源的权限。然而，整个授权服务器配置都提供在内存存储中。这种解决方案在开发过程中满足我们的需求，但在生产模式下并不是最理想的方法。目标解决方案应该将所有的认证凭据和令牌存储在数据库中。我们可以选择Spring支持的关系数据库之一。在此案例中，我决定使用MySQL。
- en: 'So, the first step is to start the MySQL database locally. The most comfortable
    way to achieve this is through a Docker container. In addition to starting the
    database, the following command also creates a schema and a user called `oauth2`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，第一步是在本地启动MySQL数据库。最舒适的方法是使用Docker容器。除了启动数据库，下面的命令还将创建一个名为`oauth2`的架构和用户：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once we have started MySQL, we now have to provide the connection settings
    on the client side. MySQL is available under the host address `192.168.99.100`
    if you run Docker on a Windows machine and on port `33306`. Data source properties
    should be set in the `application.yml` of `auth-service`. Spring Boot is also
    able to run some SQL scripts on the selected data source on the application''s
    startup. It''s good news for us because we have to create some tables on the schema
    dedicated for our OAuth2 process:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们启动了MySQL，现在必须在客户端提供连接设置。如果您在Windows机器上运行Docker，则MySQL可在主机地址`192.168.99.100`上访问，端口为`33306`。数据源属性应在`auth-service`的`application.yml`中设置。Spring
    Boot还能够在应用程序启动时在选定的数据源上运行一些SQL脚本。这对我们来说是个好消息，因为我们必须在为我们的OAuth2过程专用的架构上创建一些表：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The created schema contains some tables used for storing OAuth2 credentials
    and tokens—`oauth_client_details`, `oauth_client_token`, `oauth_access_token`,
    `oauth_refresh_token`, `oauth_code`, and `oauth_approvals`. The full script with
    SQL -creation commands is available inside `/src/main/resources/script/schema.sql`.
    There is also a second SQL script, `/src/main/resources/script/data.sql`, with
    some `insert` commands for test purposes. The most important thing is to add some
    client ID/client secret pairs:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的架构包含一些用于存储OAuth2凭据和令牌的表——`oauth_client_details`、`oauth_client_token`、`oauth_access_token`、`oauth_refresh_token`、`oauth_code`和`oauth_approvals`。包含SQL创建命令的完整脚本可在`/src/main/resources/script/schema.sql`中找到。还有一个第二个SQL脚本，`/src/main/resources/script/data.sql`，其中有一些用于测试目的的`insert`命令。最重要的是要添加一些客户端ID/客户端密钥对：
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'There are some differences in implementation between the current version of
    the authentication server and the version described in the basic example. The
    first important thing here is to set the default token storage to a database by
    providing a `JdbcTokenStore` bean with the default data source as a parameter.
    Although all tokens are now stored in a database, we still want to generate them
    in JWT format. That''s why the second bean, `JwtAccessTokenConverter`, has to
    be provided in that class. By overriding different `configure` methods inherited
    from the base class, we can set a default storage for OAuth2 client details and
    configure the authorization server to always verify the API key submitted in HTTP
    headers:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当前认证服务器版本与基本示例中描述的版本在实现上有一些不同。这里的第一件重要事情是设置默认令牌存储到数据库，通过提供 `JdbcTokenStore`
    bean 作为默认数据源的参数。尽管现在所有令牌都存储在数据库中，但我们仍然希望以 JWT 格式生成它们。这就是为什么在类中必须提供第二个 bean，`JwtAccessTokenConverter`。通过重写从基类继承的不同
    `configure` 方法，我们可以为 OAuth2 客户端详情设置默认存储，并配置授权服务器始终验证在 HTTP 头中提交的 API 密钥：
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The Spring application provides a custom authentication mechanism. To use it
    in the application, we must implement the `UserDetailsService` interface and override
    its `loadUserByUsername` method. In our example application, user credentials
    and authorities are also stored in the database, so we inject the `UserRepository`
    bean to the custom `UserDetailsService` class:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 应用程序提供了一个自定义的认证机制。要在应用程序中使用它，我们必须实现 `UserDetailsService` 接口并重写其 `loadUserByUsername`
    方法。在我们示例应用程序中，用户凭据和权限也存储在数据库中，因此我们向自定义 `UserDetailsService` 类注入 `UserRepository`
    bean：
- en: '[PRE33]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Inter-service authorization
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务间授权
- en: 'Inter-service communication in our sample is realized using Feign clients.
    Here''s one of the chosen implementations—in this case, from `order-service`—which
    calls the endpoint from `customer-service`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例中的服务间通信是使用 Feign 客户端实现的。以下是所选实现之一——在这种情况下，来自 `order-service` ——它调用 `customer-service`
    的端点：
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the same way as with the other services, all the available methods from
    `customer-service` are protected by the preauthorization mechanism based on the
    OAuth token scope. It allows us to annotate every method with `@PreAuthorize`,
    defining the required scope:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与其它服务一样，`customer-service` 中所有可用方法都基于 OAuth 令牌作用域的保护预授权机制。它允许我们用 `@PreAuthorize`
    注解标记每个方法，定义所需的作用域：
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Preauthorization is disabled by default. To enable it for API methods, we should
    use the `@EnableGlobalMethodSecurity` annotation. We should also indicate that
    such a preauthorization will be based on the OAuth2 token scope:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 预授权默认是禁用的。要为 API 方法启用它，我们应该使用 `@EnableGlobalMethodSecurity` 注解。我们还应指示这种预授权将基于
    OAuth2 令牌作用域：
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If you call the account service endpoint via the Feign client, you get the
    following exception:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您通过 Feign 客户端调用账户服务端点，将会得到以下异常：
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Why does such an exception occur? Of course, `customer-service` is protected
    with a OAuth2 token authorization, but the Feign client does not send an authorization
    token in the request header. That approach may be customized by defining a custom
    configuration class for the Feign client. It allows us to declare a request interceptor.
    In that case, we can use an implementation for OAuth2 provided by `OAuth2FeignRequestInterceptor`
    from the Spring Cloud OAuth2 library. For test purposes, I decided to use a resource
    owner password grant type:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会出现这样的异常呢？当然，`customer-service` 是通过 OAuth2 令牌授权进行保护的，但是 Feign 客户端在请求头中没有发送授权令牌。解决这个问题的一种方法是为
    Feign 客户端定义一个自定义配置类。它允许我们声明一个请求拦截器。在这种情况下，我们可以使用 Spring Cloud OAuth2 库中提供的 `OAuth2FeignRequestInterceptor`
    实现的 OAuth2。出于测试目的，我决定使用资源所有者密码授权类型：
- en: '[PRE38]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, we may test the implemented solution. This time, we will create a
    JUnit automated test instead of clicking it in a web browser or sending requests
    using other tools. The test method is shown in the following code snippet. We
    use `OAuth2RestTemplate` with `ResourceOwnerPasswordResourceDetails` to perform
    a resource owner credentials grant operation and call the `POST /` API method
    from `order-service` with an OAuth2 token sent in the request header. Of course,
    before running that test, you have to start all the microservices, as well as
    the discovery and authorization server:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以测试所实现的解决方案。这次，我们将创建一个JUnit自动化测试，而不是在网页浏览器中点击它或使用其他工具发送请求。以下代码片段显示了测试方法。我们使用`OAuth2RestTemplate`和`ResourceOwnerPasswordResourceDetails`执行资源所有者凭据授予操作，并调用来自`order-service`的`POST
    /` API方法，请求头中发送了OAuth2令牌。当然，在运行那个测试之前，您必须启动所有微服务以及发现和授权服务器：
- en: '[PRE39]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Enabling SSO on the API gateway
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在API网关上启用单点登录
- en: 'You may enable the single sign-on feature on the API gateway just by annotating
    the main class with `@EnableOAuth2Sso`. Indeed, that is the best choice for your
    microservices architecture to force Zuul to generate or get the access token for
    the currently authenticated user:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在主类上添加`@EnableOAuth2Sso`注解来仅通过注解在API网关上启用单点登录功能。确实，这是强制Zuul生成或获取当前认证用户的访问令牌的最佳选择，对于您的微服务架构来说：
- en: '[PRE40]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: By including `@EnableOAuth2Sso`, you trigger an auto-configuration available
    for a ZuulFilter. The filter is responsible for extracting an access token from
    the currently authenticated user, and then putting it into the request header
    forwarded to the microservices hidden behind the gateway. If `@EnableResourceServer`
    is activated for those services, they will receive the expected token in the `Authorization`
    HTTP header. The authorization behavior downstream of an `@EnableZuulProxy` may
    be controlled by declaring `proxy.auth.*` properties.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过包含`@EnableOAuth2Sso`，你可以触发一个对ZuulFilter可用的自动配置。这个过滤器负责从当前已认证的用户中提取访问令牌，然后将其放入转发到微服务网关后面的请求头中。如果对这些服务启用了`@EnableResourceServer`，它们将会在`Authorization`
    HTTP头中收到预期的令牌。`@EnableZuulProxy`下游的授权行为可以通过声明`proxy.auth.*`属性来控制。
- en: 'When using a gateway in your architecture, you may hide an authorization server
    behind it. In this case, you should provide the additional route in Zuul''s configuration
    settings—for example, `uaa`. Then, all the messages exchanged between OAuth2 clients
    and the server go through the gateway. Here''s the proper configuration in the
    gateway''s `application.yml` file:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当在您的架构中使用网关时，您可能在其后面隐藏一个授权服务器。在这种情况下，您应该在Zuul的配置设置中提供额外的路由—例如，`uaa`。然后，OAuth2客户端与服务器之间交换的所有消息都通过网关。这是在网关的`application.yml`文件中的正确配置：
- en: '[PRE41]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: There wouldn't have been anything wrong if I had included a security section
    in every single chapter from part two of this book. But I have decided to create
    a dedicated chapter on this subject in order to show you a step-by-step process
    of how to secure the key elements of a microservices-based architecture. The topics
    related to security are usually more advanced than other topics, so I took a bit
    more time to explain some of the basic concepts around the field. I have shown
    you samples illustrating a two-way SSL authentication, encryption/decryption of
    sensitive data, Spring Security authentication, and OAuth2 authorization with
    JWT tokens. I will leave it to you to decide which of them should be used in your
    system architecture to provide your desired level of security.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在本书的第二部分每个章节中都包含一个安全部分，那也不会有什么问题。但我决定专门用一章来介绍这个主题，以便向您展示如何逐步为基于微服务架构的关键元素提供安全保护的步骤。与安全相关的主题通常比其他主题更高级，所以我花了一些时间来解释该领域的一些基本概念。我向您展示了示例，说明了双向SSL认证、敏感数据的加密/解密、Spring
    Security认证以及使用JWT令牌的OAuth2授权。您需要决定在您的系统架构中使用哪个来提供您所需的安全级别。
- en: After reading this chapter, you should be able to set up both the basic and
    the more advanced security configurations for your application. You should also be
    able to secure every component of your system's architecture. Of course, we have
    discussed only some of the possible solutions and frameworks. For example, you
    don't have to only rely on Spring as an authorization server provider. We may
    use third-party tools, such as Keycloak, which can act as an authorization and
    authentication server in a microservices-based system. It can also easily be integrated
    with Spring Boot applications. It provides support for all the most popular protocols,
    such as OAuth2, OpenId Connect, and SAML. So, in fact, Keycloak is a very powerful
    tool, and should be treated as an alternative to the Spring Authorization Server,
    especially for large, corporate systems and other more advanced use cases.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，你应该能够为你的应用程序设置基本和更高级的安全配置。你还应该能够保护你系统架构中的每一个组件。当然，我们只讨论了一些可能的解决方案和框架。例如，你不必仅依赖于Spring作为授权服务器提供者。我们可以使用第三方工具，如Keycloak，它可以在基于微服务的系统中作为授权和认证服务器。它还可以轻松地与Spring
    Boot应用程序集成。它支持所有最流行的协议，如OAuth2、OpenId Connect和SAML。因此，实际上，Keycloak是一个非常强大的工具，应该被视为Spring授权服务器的替代品，特别是在大型企业系统和其他更高级的使用场景中。
- en: In the next chapter we will discuss the different strategies of microservices
    testing.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论微服务测试的不同策略。
