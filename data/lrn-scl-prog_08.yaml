- en: Dealing with Effects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理效果
- en: In the previous two chapters, we had quite a shift in perspective. In [Chapter
    6](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml), *Exploring Built-In Effects*,
    we looked at a handful of implementations of the concrete effects available in
    the standard library. In [Chapter 7](c1798142-6829-479c-bb7b-d50ccd16e629.xhtml),
    *Understanding Algebraic Structures* we jumped from the real to the theoretical
    and played with abstract algebraic structures.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，我们的视角发生了相当大的转变。在第6章[探索内置效果](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml)中，我们查看了一些标准库中可用的具体效果的实现。在第7章[理解代数结构](c1798142-6829-479c-bb7b-d50ccd16e629.xhtml)中，我们从实际跳到了理论，并玩转了抽象代数结构。
- en: Now that we are familiar with the process of working with abstractions defined
    by laws, we can finally deliver on the promise we gave in [Chapter 6](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml), *Exploring
    Built-In Effects*, and identify abstractions lying beneath the standard implementations
    we touched on there.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了使用由法律定义的抽象的过程，我们最终可以履行我们在第6章[探索内置效果](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml)中给出的承诺，并识别出隐藏在我们在那里接触到的标准实现背后的抽象。
- en: We'll define and implement a functor, an abstract concept that's useful in relation
    to any effect. Moreover, we’ll have three different flavors of them, so stay tuned!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义和实现一个函子，这是一个在处理任何效果时都很有用的抽象概念。此外，我们还将有三种不同的风味，所以请保持关注！
- en: 'By the end of this chapter, you''ll be able to identify and implement or use
    the existing implementation of one of the following structures:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够识别并实现或使用以下结构之一：
- en: Functor
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函子
- en: Applicative functor
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用函子
- en: Traversable functor
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可遍历函子
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: JDK 1.8+
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK 1.8+
- en: SBT 1.2+
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SBT 1.2+
- en: The source code for this chapter is available in our GitHub repository at [https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter08](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter08).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在我们的GitHub仓库中找到，网址为[https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter08](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter08)。
- en: Functor
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函子
- en: In the previous chapter, we discussed the situation in which we wanted to combine
    elements inside of a container. We found out that abstractions such as `Reducible`
    and `Foldable` can help with that by taking a function of two arguments and bringing
    it *into* the container so that it can be applied on pairs of elements inside
    of it. As an example, we showed you how this approach makes it possible to implement
    different survival strategies for a bucket of fish.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们讨论了想要在容器内部组合元素的情况。我们发现，例如`Reducible`和`Foldable`这样的抽象可以帮助我们通过接受一个两个参数的函数并将其*带入*容器，以便可以在其中内部的元素对上应用它。作为一个例子，我们展示了这种方法如何使实现一桶鱼的不同的生存策略成为可能。
- en: What we haven't covered is a case where we don't want to *combine* elements
    in the container but *do* something with all of them, a single element at a time.
    This is the bread and butter of functional programming—applying pure functions
    to arguments and getting the results back, then repeating this process with the
    result. Usually, the functions applied to the argument in succession can be combined
    into a single function, which in a sense is *fusing* all of the intermediate steps
    into one step.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有涵盖的情况是我们不想在容器中*组合*元素，而是*逐个*对它们进行操作。这是函数式编程的精髓——将纯函数应用于参数并获取结果，然后重复这个过程，使用结果。通常，连续应用于参数的函数可以组合成一个单一函数，这在某种程度上是将所有中间步骤融合为一个步骤。
- en: 'Back to our fish example. Let''s imagine that we have a fish and that we''d
    like to eat it. We''d first check that the fish is healthy and still fresh, then
    we would cook it somehow, and finally, we''d consume it. We might represent this
    sequence with the following model, extending the original `Fish` definition from
    the previous chapter:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的鱼示例。让我们想象我们有一条鱼，我们想吃它。我们首先检查鱼是否健康且仍然新鲜，然后我们会以某种方式烹饪它，最后我们会消费它。我们可能会用以下模型来表示这个序列，扩展前一章中原始的`Fish`定义：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And our possible actions would naturally be represented as functions:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能采取的行动将自然地表示为函数：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we might want to combine our actions so that they represent the whole
    process from fresh to eaten fish:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可能想要组合我们的操作，使它们代表从新鲜到被吃掉的鱼的全过程：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we can act on the fish as desired by applying the combined function to
    the fish:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过将组合函数应用于鱼来按需对鱼进行操作：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, we're using the `Gen[Fish]` function we defined in the previous
    chapter. Please consult the GitHub repository if you need to refresh your understanding
    on how this was done.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了我们在前一章中定义的 `Gen[Fish]` 函数。如果您需要刷新对这个是如何完成的了解，请查阅 GitHub 仓库。
- en: So far so good—we're satisfied and happy. But the situation will change if we
    have a bucket of fish. Suddenly, all of the functions we've defined are useless
    because we don't know how to apply them to the fish inside of the bucket! What
    do we do now?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利——我们满意且高兴。但如果我们有一个鱼桶，情况就会改变。突然之间，我们定义的所有函数都变得毫无用处，因为我们不知道如何将这些函数应用于桶内的鱼！我们现在该怎么办？
- en: The requirement to work "inside" of the bucket might sound strange, but it is
    only because our example is disconnected from the implementation. In programming,
    most of the time, working with collections implies that we have the same collection
    (though with changed elements) after applying the operation. Moreover, if the
    *structure* of the collection is preserved, then the category theory we mentioned
    previously can provide some guarantees in regard to combining the operations as
    long as these obey a required set of laws. We've seen how this works with abstract
    algebraic structures, and the principle is the same for all abstractions derived
    from category theory. In practice, the requirement to preserve the structure of
    the collection means that the operation cannot change the type of the collection
    or the number of elements in it or throw an exception.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在桶内“工作”的要求可能听起来很奇怪，但这仅仅是因为我们的例子与实现脱节。在编程中，大多数时候，与集合一起工作意味着我们在应用操作后拥有相同的集合（尽管元素已更改）。此外，如果集合的
    *结构* 被保留，那么我们之前提到的范畴论可以提供一些关于组合操作保证的保证，只要这些操作遵守所需的一组定律。我们已经看到了这是如何与抽象代数结构一起工作的，并且这个原则适用于从范畴论派生出的所有抽象。在实践中，保留集合结构的要求意味着操作不能改变集合的类型或其中的元素数量，也不能抛出异常。
- en: It turns out that there is an abstraction that can help us in this situation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，有一个抽象可以帮助我们在这个情况下。
- en: 'The `Functor` has a `map` method which takes a container and a function and
    applies this function to all of the elements in the container, and finally returning
    the container with the same structure but filled with new elements. This is how
    we can specify this in Scala:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`Functor` 有一个 `map` 方法，它接收一个容器和一个函数，并将此函数应用于容器中的所有元素，最后返回具有相同结构但填充了新元素的容器。这就是我们如何在
    Scala 中指定它的方式：'
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`F[_]` is a type constructor for the container. The `map` itself takes a container
    and a function to apply and returns a container with new elements. We could also
    define the `map` slightly differently, in a curried form:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`F[_]` 是容器的类型构造函数。`map` 本身接收一个容器和一个要应用的函数，并返回一个包含新元素的容器。我们也可以将 `map` 定义得稍微不同，以柯里化的形式：'
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, `mapC` takes a function called `A => B` and returns a function called `F[A]
    => F[B]`, which can then be applied to the container.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`mapC` 接收一个名为 `A => B` 的函数，并返回一个名为 `F[A] => F[B]` 的函数，然后可以将其应用于容器。
- en: 'As this is an abstract definition, we would naturally expect some laws to be
    defined and satisfied—exactly like in the previous chapter. For functors, there
    are two of them:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个抽象定义，我们自然会期望定义并满足一些定律——就像前一章一样。对于函子，有两个定律：
- en: The *identity* law states that mapping over an  identity function should not
    change the original collection
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恒等律指出，对恒等函数进行映射不应改变原始集合
- en: The *distributive* law requires that successive mapping over two functions should
    always produce the same result as mapping over the combination of these functions
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配律要求对两个函数的连续映射应始终产生与对这两个函数组合进行映射相同的结果
- en: We will capture these requirements as properties in the same that way we did
    in the previous chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像前一章那样，将这些要求作为属性来捕捉。
- en: 'First, let''s take a look at the identity law:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看恒等律：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this property, we're using the `identity` function from [Chapter 3](9f67be8e-4fee-4050-ab96-8444bb795138.xhtml), *Deep
    Dive into Functions*, which just returns its argument.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个属性中，我们使用了来自 [第 3 章](9f67be8e-4fee-4050-ab96-8444bb795138.xhtml) 的 `identity`
    函数，*深入函数的探讨*，它只是返回其参数。
- en: 'The associativity law is a bit more involved because we need to test it with
    random functions. This requires that a lot of implicits are available:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 结合律稍微复杂一些，因为我们需要用随机函数来测试它。这需要大量的隐式函数可用：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we''re creating the arbitrary functions `f: A => B` and `g: B => C` 
    and checking that the combined function has the same effect as applying both functions
    in succession.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们正在创建任意的函数`f: A => B`和`g: B => C`，并检查组合函数的效果是否与连续应用这两个函数相同。'
- en: 'Now, we need some functors to apply our checks. We can implement a `Functor[Option]`
    by delegating to the map function defined on `Option`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一些函子来应用我们的检查。我们可以通过委托到定义在`Option`上的`map`函数来实现`Functor[Option]`：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The instance is defined as `implicit`, the same way as in the previous chapter,
    so that represents a type class.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 实例定义为`implicit`，就像上一章一样，因此它代表一个类型类。
- en: 'Does this implementation obeys the necessary laws? Let''s see. The properties
    in this chapter are defined in the test scope and can be run in SBT using the `test`
    command. They cannot be pasted into the REPL standalone, but only as a part of
    the `Properties` definition:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现遵守必要的法则吗？让我们看看。本章中的属性在测试范围内定义，可以使用SBT中的`test`命令运行。它们不能作为REPL的独立部分粘贴，但只能作为`Properties`定义的一部分：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can see that we need to specify types of the functor and functions to check
    the laws that make it impossible—in our case—to formulate the functor properties
    *in general*. The functional programming library, cats, solves this problem by also defining
    type classes for the types of arguments. We'll stick to the explicit definition—this
    is sufficient for our learning purposes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要指定函子和函数的类型，以检查使其不可能——在我们的情况下——在一般情况下制定函子属性的法则。函数式编程库cats通过也为参数类型定义类型类来解决此问题。我们将坚持显式定义——这对我们的学习目的来说足够了。
- en: We can also implement functors for the other effects we saw in [Chapter 6](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml), *Exploring
    Built-In Effects* in the same way we did for `Option`. The functor for `Try` is
    identical with respect to the type of effect. We'll leave this implementation
    as an exercise for the reader.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以以相同的方式实现我们在[第6章](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml)中看到的其他效果的函子，*探索内置效果*。`Try`的函子与效果类型相同。我们将把这个实现留给读者作为练习。
- en: 'The case of `Either` is a bit more complicated, because we need to convert
    the two type arguments it takes to one type argument that''s expected by a `Functor`
    type constructor. We do this by fixing a type of the left side to `L` and using
    the type lambda in the definition of the functor:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Either`的情况要复杂一些，因为我们需要将它接受的两个类型参数转换为一个`Functor`类型构造函数期望的单个类型参数。我们通过将左侧的类型固定为`L`并在函子的定义中使用类型lambda来实现这一点：'
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Interestingly, the implementation itself is the same again. It turns out that
    this is the abstraction we were looking for at the end of [Chapter 6](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml),
    *Exploring Built-In Effects*. All of the standard effects we discussed in [Chapter
    6](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml), *Exploring Built-In Effects* are
    functors! The visible difference in the definition of the `map` method comes from
    the fact that, for the standard effects, it is defined using object-oriented polymorphism,
    and in our functor code, we're doing this by using ad-hoc polymorphism with type
    classes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，实现本身再次相同。结果证明，这正是我们在[第6章](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml)的*探索内置效果*结束时寻找的抽象。我们在[第6章](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml)中讨论的所有标准效果都是函子！`map`方法定义中的可见差异来自于，对于标准效果，它是使用面向对象的多态定义的，而在我们的函子代码中，我们通过使用类型类的自定义多态来实现这一点。
- en: 'Let''s get back to our fish. As we have a bucket of them, which is represented
    by the `List` type, we''ll need a `Functor[Bucket]` as well:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的鱼。因为我们有一个桶，它由`List`类型表示，所以我们需要一个`Functor[Bucket]`：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The definition is once again the same as before. However, we can perform actions
    on the fish in the bucket as desired now, reusing the `bucketOfFishGen`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 定义再次与之前相同。然而，我们现在可以按照需要对桶中的鱼执行操作，重用`bucketOfFishGen`：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, we''re using our freshly defined functor to check and prepare the fish
    inside of the bucket. The nice thing about our implementation is that the bucket
    can be any type that has a functor. To demonstrate this, we need a helper function
    that will allow us to pass a functor as a third parameter, along with the two
    we have in the definition of the `Functor.map`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在使用我们刚刚定义的函子来检查和准备桶内的鱼。我们实现的一个优点是桶可以是任何具有函子的类型。为了演示这一点，我们需要一个辅助函数，它将允许我们将函子作为第三个参数传递，连同我们在`Functor.map`定义中的两个参数一起：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This function takes an effect and a function and implicitly resolves the appropriate
    functor. The calling code does not make this distinction any more since we''re
    mapping over three different types of effects in the same way by using different
    functions:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个效果和一个函数，并隐式解析适当的函子。调用代码不再进行这种区分，因为我们通过使用不同的函数以相同的方式映射三种不同类型的效果：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, it is starting to look like a useful abstraction—well, as long as our desires
    are limited to the functions of one argument. We'll see why in the next section.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它开始看起来像是一个有用的抽象——好吧，只要我们的愿望仅限于单参数函数。我们将在下一节中看到原因。
- en: Applicative
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用
- en: With functor, we now have a convenient way to apply functions to the contents
    of an effect, regardless of the type of the effect itself. We were able to check
    the fish and cook it by applying the same logic we had for an effect-free fish.
    To get even more comfortable with functors, we will now make a fish pie with our
    new tool.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过函子，我们现在有了一种方便的方式来将函数应用到效果的内容中，无论效果本身的类型如何。我们能够通过应用与无效果鱼相同的逻辑来检查鱼并烹饪它。为了更熟悉函子，我们现在将使用新工具制作鱼馅饼。
- en: 'First, we''ll define a function to make a pie from a single fish:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义一个从单个鱼制作馅饼的函数：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'That was easy—one fish, one pie, with the size of the fish. Now, we are ready
    to bake every fish in the bucket:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单——一条鱼，一个馅饼，鱼的大小。现在，我们准备好在桶中烘焙每条鱼：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Oops! This won't compile because the functor only accepts the function of one
    argument, and we have three.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！这不能编译，因为函子只接受单参数的函数，而我们有三个。
- en: 'What can we do? One of the possibilities would be to refactor and partially
    apply our function. We could also create a function that uses `mapC` to convert
    the bucket of fish in to a fresh fish bucket so that we can simplify further actions:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能做什么？一个可能性是对我们的函数进行重构和部分应用。我们还可以创建一个使用 `mapC` 将鱼桶转换为新鲜鱼桶的函数，以便我们可以进一步简化操作：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And then we can implement the rest of the logic with the partially applied
    function:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用部分应用函数来实现其余的逻辑：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is a valid approach and would work, but this will use the same amount of
    ingredients for each and every fish. Some of the pies won't taste very good if
    this strategy. Can we do better?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有效的方法，并且会起作用，但这种方法将为每条鱼使用相同数量的原料。如果采用这种策略，一些馅饼可能味道不太好。我们能做得更好吗？
- en: 'Well, we can make our original function curried. This will give us a function
    that accepts a single fish and then other arguments on top:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们可以将我们的原始函数转换为柯里化形式。这将给我们一个接受单个鱼然后是其他参数的函数：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we would like to use the ingredients from another bucket so that we can
    add to the `pieInProgress`. Unfortunately, this is something that a functor can''t
    help us with. If we try and nest, the map calls for a bucket of potatoes and a
    bucket of milk, so we would come up with something like the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望使用另一个桶中的原料，以便我们可以添加到 `pieInProgress` 中。不幸的是，这是函子无法帮助我们的事情。如果我们尝试嵌套，对土豆桶和牛奶桶的映射调用，我们就会得到以下类似的结果：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Unfortunately, each nested call will leave the result in the nested bucked so
    that even if this were able to compile at the end, we'd have three nested buckets.
    Our functors do not know how to extract nested buckets from each other.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，每个嵌套调用都会将结果留在嵌套的桶中，以至于即使最终能够编译，我们也会有三个嵌套的桶。我们的函子不知道如何从彼此中提取嵌套的桶。
- en: 'What can help us is the *Applicative Functor*. Sometimes just known as *Applicative*,
    this structure extends the original functor with two more methods:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 能帮助我们的是 *应用函子*。有时也称为 *应用函子*，这个结构通过两个额外的函数扩展了原始函子：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The apply method takes an effect, `a`, and a function, `f`, defined in the context
    of the same effect and applies `f` to `a`, thus returning the result that's wrapped
    in the very same effect.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 应用方法接受一个效果 `a` 和一个函数 `f`，该函数在相同的效果上下文中定义，并将 `f` 应用到 `a` 上，从而返回被相同效果包装的结果。
- en: The `unit` method allows us to wrap a plain value, `a`, into the effect. This
    is often called *lifting*, especially if `a` is a function, as it "lifts" the
    original value (or function) into the context of the effect, `F`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`unit` 方法允许我们将一个普通值 `a` 包装成效果。这通常被称为 *提升*，尤其是当 `a` 是一个函数时，因为它“提升”了原始值（或函数）到效果
    `F` 的上下文中。'
- en: 'An astute reader will expect some laws to pop up for the aforementioned functions.
    And you would be absolutely right! There are a few of them:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一个敏锐的读者会期待上述函数出现一些定律。你绝对是对的！有几个定律：
- en: Identity law states that an application of an identity function should return
    the argument unchanged, the same way the identity function does. This is similar
    to the identity law for the functor, but this time defined for the `apply` function.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同一律指出，应用一个恒等函数应该返回未改变的参数，就像恒等函数所做的那样。这与函子恒等律类似，但这次是为`apply`函数定义的。
- en: Homomorphism law states that applying a function to a value and then lifting
    the result is the same as first lifting this function and value and then applying
    them in the context of the applicative.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同态律指出，将函数应用于值然后提升结果与首先提升这个函数和值然后在应用上下文中应用它们是相同的。
- en: Interchange law states that changing the order of the parameters for the apply
    method should not change the result.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 交换律指出，改变`apply`方法参数的顺序不应该改变结果。
- en: Composition law states that function composition should be preserved.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组合律指出，函数组合应该得到保留。
- en: Now, this might start to sound abstract. Let's make these points clear by capturing
    them as properties.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这可能会开始听起来很抽象。让我们通过将它们作为属性来明确这些观点。
- en: 'The identity property is the simplest one. The only caveat is that we can''t
    use the `identity` function—we have to be explicit about the type of the argument
    for the `unit` method because there is no possibility for the compiler to infer
    it for us:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 同一律是最简单的一个。唯一的注意事项是我们不能使用`identity`函数——我们必须明确指定`unit`方法的参数类型，因为没有编译器能为我们推断它：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Homomorphism is also not very spectacular—it literally encodes the rules we
    stated in prose. Similar to the case of `identityProp`, we''re taking advantage
    of the `apply` syntax:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 同态也不是非常引人注目——它实际上编码了我们用散文形式陈述的规则。类似于`identityProp`的情况，我们正在利用`apply`语法：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The interchange law is where it starts to become interesting. We''ll define
    left and right sides separately to simplify the definition:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 交换律是开始变得有趣的地方。我们将分别定义左右两侧以简化定义：
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The left side is identical to the homomorphism definition—we're lifting some
    random function and a value into the applicative. Now, we need to change the order
    of `f` and `a`. The `f` is a first-class value, so we're fine on this side, but
    `a` is not a function. Therefore, we're defining a helper `func` which takes something
    with the same type as `f` and returns type `B`. Given `a`, we have only one way
    to implement this. With this helper, the types will align. Finally, we are defining
    the `rightSide` with the changed order of arguments and finish with the property
    comparing them.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧与同态定义相同——我们将某个随机函数和值提升到应用中。现在，我们需要改变`f`和`a`的顺序。`f`是一个一等值，所以我们在这方面没问题，但`a`不是一个函数。因此，我们定义了一个辅助函数`func`，它接受与`f`相同类型的参数并返回类型`B`。给定`a`，我们只有一种方式来实现这一点。有了这个辅助函数，类型就会对齐。最后，我们定义了`rightSide`，其中参数顺序已改变，并以比较它们的属性结束。
- en: 'The composition property is the most lengthy one because we have to define
    the functions that we are about to compose. First, let''s define function composition
    as a function:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 组合属性是最长的，因为我们必须定义我们即将组合的函数。首先，让我们将函数组合定义为函数：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Given two functions with matching types, `composeF` will return a function composition
    by delegating to the `compose` method of the first argument.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个类型匹配的函数，`composeF`将通过委托给第一个参数的`compose`方法返回一个函数组合。
- en: 'We''ll again define left and right sides of the property separately:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次分别定义属性的左右两侧：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The right side is straightforward—we''re applying lifted functions `f` and
    `g` in succession on some effect, `as`. As the composition law states, this must
    be preserved if we apply composition inside of an applicative. This is what the
    left side does. It is better to read it from right to left: we''re lifting our
    function which composes functions into the applicative and than applying lifted
    `f` and `g` in succession, but this time inside of the `A`. This gives us a `compose`
    function that''s built inside of the applicative, which we finally apply to `as`.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧很简单——我们连续将提升的函数`f`和`g`应用于某个效果`as`。根据组合律，如果我们在一个应用中应用组合，这必须得到保留。这正是左侧所做的。最好是从右到左阅读它：我们将组合函数的函数提升到应用中，然后连续应用提升的`f`和`g`，但这次是在`A`内部。这给我们一个构建在应用内部的`compose`函数，我们最终将其应用于`as`。
- en: 'For a valid applicative, all of these properties must hold, as well as the
    functor properties we defined earlier, as shown in the following snippet (not
    showing the implicit parameters):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个有效的适用性，所有这些属性都必须成立，以及我们之前定义的函子属性，如下面的代码片段所示（未显示隐含参数）：
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Secured with properties, we can define a few instances of applicative for the
    standard effects, just like we did for functor. The `Option` is arguably the easiest
    one to implement. Unfortunately, we can''t just delegate to the instance method
    as we did with `map`, so we have to get our hands dirty:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过属性保护，我们可以为标准效果定义几个适用性的实例，就像我们为函子（functor）所做的那样。`Option` 可能是最容易实现的一个。不幸的是，我们无法像
    `map` 那样委托给实例方法，所以我们不得不亲自动手：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The type signatures dictate the implementation. We can't return `Option[B]`
    in any other way but by applying `f` to `a`. Similarly, we can't return `Option[A]`
    from the `unit` method. Please pay attention, though, to how we're using the `Some`
    constructor in both cases instead of the `Option` constructor. This is done in
    order to preserve structure in the case of `null` parameters or returned values.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 类型签名决定了实现。我们不能通过应用 `f` 到 `a` 来返回任何其他 `Option[B]`。同样，我们也不能从 `unit` 方法返回 `Option[A]`。请注意，我们在这两种情况下都使用
    `Some` 构造函数而不是 `Option` 构造函数，这是为了在 `null` 参数或返回值的情况下保持结构。
- en: 'The implementation for `Either` and `Try` is very similar with respect to the
    effect type. Remarkably, our `Bucket` type, which is represented by `List`, is
    quite different:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`Either` 和 `Try` 的实现与效果类型非常相似。值得注意的是，我们的 `Bucket` 类型，它由 `List` 表示，相当不同：'
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Because we need to apply all functions to all arguments, we're doing this in
    a recursive way in our example (notice that it is not tail-recursive!) by splitting
    the process into four parts—dealing with both first elements, the first element
    and all of its functions, all of the elements and the first function, and the
    recursive call for all but the first elements from both lists.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们需要将所有函数应用到所有参数上，所以在我们的例子中以递归方式执行，将过程分为四个部分——处理两个第一个元素，第一个元素及其所有函数，所有元素和第一个函数，以及从两个列表中除了第一个元素之外的所有元素的递归调用。（注意：这并不是尾递归！）
- en: 'With `bucketApplicative` at hand, we can finally finish our curried `pieInProgress`
    function by first applying it to `potato` and then to `milk`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `bucketApplicative`，我们最终可以通过首先将其应用到 `potato`，然后应用到 `milk` 来完成我们的柯里 `pieInProgress`
    函数：
- en: '[PRE30]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This definition works and produces the expected result—nice. But the implementation
    does not show the intent to mix three ingredients, which is not so nice. Let's
    improve this.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义是有效的，并产生了预期的结果——很好。但实现并没有显示出混合三种成分的意图，这并不那么好。让我们改进它。
- en: 'In fact, there are three different valid ways to define an applicative in terms
    of its basic functions:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有三种不同的有效方式可以用基本函数来定义一个适用性（applicative）：
- en: The one we just implemented, with `apply` and `unit`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们刚刚实现的，使用 `apply` 和 `unit`。
- en: 'To define it with the `unit` and `map2` methods so that `map2[A, B, C](fa:
    F[A], fb: F[B])(f: (A, B) => C): F[C]`.'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '使用 `unit` 和 `map2` 方法来定义它，使得 `map2[A, B, C](fa: F[A], fb: F[B])(f: (A, B) =>
    C): F[C]`。'
- en: 'To define it with the `unit`, `map`, and `product` functions so that `product[A,
    B](fa: F[A], fb: F[B]): F[(A, B)]`.'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '使用 `unit`、`map` 和 `product` 函数来定义它，使得 `product[A, B](fa: F[A], fb: F[B]): F[(A,
    B)]`。'
- en: The `apply` and `map2` methods are equally powerful in the sense that it is
    possible to implement one in terms of another. The same applies to `product`,
    though it is weaker as it needs a `map` function to be defined.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply` 和 `map2` 方法在功能上同样强大，因为我们可以用其中一个来实现另一个。同样的，对于 `product` 方法也适用，尽管它较弱，因为它需要一个已定义的
    `map` 函数。'
- en: 'As these functions are equally powerful, we can implement them directly in
    the type class definition so that they are available on all type class instances.
    The `map2` method looks good to start with:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些函数功能相同，我们可以在类型类定义中直接实现它们，这样它们就可在所有类型类实例上使用。`map2` 方法看起来是一个好的开始：
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The implementation almost looks disappointing in its simplicity—we just apply
    `fa` and `fb` in succession to the given `f` we converted to the curried form
    so that we are able to apply them in two steps.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 实现看起来很简单，有些令人失望——我们只是将转换成柯里形式的给定 `f` 依次应用到 `fa` 和 `fb` 上，这样我们就可以分两步应用它们。
- en: 'It is interesting how the `map2` method is implemented in terms of `map`, which
    in a sense is a map of *lower power*. The curious readers out there could be asking
    if it is possible to implement a `map` with yet another function of *lower power*.
    It turns out we can do this! Here is the implementation:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 很有趣的是，`map2`方法是如何用`map`实现的，这在某种程度上是一个*低级*的映射。好奇的读者可能会问，是否可能用另一个*低级*的函数实现`map`。结果是我们能这样做！以下是实现方式：
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: All we need to do is lift the given function `f` into the context of applicative
    and use the `apply` function we already have.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的就是将给定的函数`f`提升到应用式的上下文中，并使用我们已有的`apply`函数。
- en: 'This way of defining functions in terms of other functions is common in functional
    programming. All the way down in the abstraction, there are methods that provide
    the basis for all other definitions and cannot be defined as a combination of
    other methods. These are called *primitive*. The tree flavors of applicative we
    are talking about are different by their choice of primitive functions. As it
    turns out, our initial choice was the first of them, that is, the `unit` and `apply`
    methods. Using these primitive functions, we were able to define the `Functor`
    in terms of `Applicative`! It makes sense to do the same and define a `Functor.mapC`
    in terms of `map`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以其他函数定义函数的方式在函数式编程中很常见。在抽象的底层，有一些提供所有其他定义基础的方法，不能定义为其他方法的组合。这些被称为*原始的*。我们正在讨论的应用式的三种风味通过它们选择的原始函数而不同。结果，我们的最初选择是它们中的第一个，即`unit`和`apply`方法。使用这些原始函数，我们能够用`Applicative`来定义`Functor`！在`map`的基础上定义一个`Functor.mapC`也是有意义的：
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The nice side-effect of deriving implementations this way is that as soon as
    primitive functions are implemented properly and obey the applicative (or functor)
    laws, the derived implementations should be lawful as well.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式推导实现的好处是，一旦原始函数被正确实现并遵守应用式（或函子）定律，推导出的实现也应该是有法的。
- en: 'Back to the flavors of applicative—we still need to implement the `product`
    method which creates an applicative of a product from two applicatives:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 回到应用式的风味——我们仍然需要实现`product`方法，它从两个应用式中创建一个产品应用式：
- en: '[PRE34]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This time, we had to use a type lambda again to represent a product of two types, `F`
    and `G`, as a single type. We also needed to store the reference to the current
    instance of the applicative as `F` so that we're able to call its methods later.
    The implementation itself is naturally expressed in terms of the `unit` and `apply` primitives.
    For the resulting applicative, the `unit` is defined as a product of units for
    `F` and `G`, and the `apply` is just a product of using an `apply` method on the
    given arguments.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们不得不再次使用类型lambda来表示两个类型`F`和`G`的乘积作为一个单一的类型。我们还需要将应用式的当前实例引用存储为`F`，这样我们才能稍后调用其方法。实现本身自然地用`unit`和`apply`原始函数表达。对于结果应用式，`unit`定义为`F`和`G`的单位乘积，而`apply`只是对给定参数使用`apply`方法的乘积。
- en: 'Unfortunately, we still can''t define our `pie` function in a very readable
    way. If only we had `map3`, we could implement it as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们仍然无法以一种非常可读的方式定义我们的`pie`函数。如果我们有`map3`，我们可以这样实现它：
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Obviously, this implementation expresses a very clear intent: take three containers
    full of ingredients, apply a function on these ingredients, and get a container
    with pies back. This works for any container for which an instance of an `Applicative`
    type class is available.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这种实现表达了一个非常清晰的意图：取三个装满成分的容器，对这些成分应用一个函数，然后得到一个装有派饼的容器。这对于任何有`Applicative`类型类实例的容器都适用。
- en: 'Well, we already know how to derive functions from primitives defined for an
    abstraction. Why don''t we do this again? Here goes:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们已经知道如何从为抽象定义的原始函数推导函数。为什么我们不再次这样做呢？让我们开始吧：
- en: '[PRE36]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Hmm, it turned out to be a definition for the `map2` function, just extended
    with one more call for an `apply` for a third parameter! Needless to say, it is
    possible to implement the `mapN` method for any arity like this. We can also define
    it in an inductive way by calling a `map` of smaller arity:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这实际上是对`map2`函数的定义，只是增加了一个对第三个参数的`apply`调用！不用说，可以以这种方式为任何这种类型的任意数量实现`mapN`方法。我们也可以通过调用较小数量级的`map`以归纳方式定义它：
- en: '[PRE37]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We just needed to convert the provided function to the form where we can feed
    it with all but the last parameters and the last parameter separately.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要将提供的函数转换为可以提供所有但最后一个参数和最后一个参数单独的形式。
- en: 'Now, as we have our `pie3` implementation, we must stop for a moment. We need
    to tell you something. Yes, we need to admit that we cheated a bit as we defined
    the `check` function. Surely, we can''t just return `FreshFish` every time we
    have `Fish` as we did before:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，既然我们有 `pie3` 的实现，我们必须停下来一会儿。我们需要告诉你一些事情。是的，我们必须承认我们在定义 `check` 函数时有点作弊。当然，我们不能每次有
    `Fish` 就返回 `FreshFish`，就像我们之前做的那样：
- en: '[PRE38]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We did this on purpose so that we''re able to focus on `Applicative`. Now,
    we are ready to improve on this. We are already familiar with the notion of optionality,
    so we could change this function to return an `Option`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意这样做，以便我们能够专注于 `Applicative`。现在，我们准备改进这一点。我们已经熟悉了可选性的概念，因此我们可以将这个函数改为返回 `Option`：
- en: '[PRE39]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'But let''s decide which kind of effect it should be later. Let''s call it `F`
    for now. We need two possibilities:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们稍后决定它应该是哪种类型的效果。现在我们先叫它 `F`。我们需要两种可能性：
- en: To return an empty `F` in the case that the fish is not fresh
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果鱼不新鲜，则返回一个空的 `F`
- en: To return an `F` with a fresh fish otherwise
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其他情况下返回一个包含新鲜鱼的 `F`
- en: In terms of abstractions, we have a way to lift a fish into `F` as soon as we
    have an applicative for it—the applicative gives this as a `unit`. All we need
    is an empty `F[FreshFish]`, which we'll provide as an argument to the function.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在抽象方面，我们有一种方法可以将鱼提升到 `F` 中，一旦我们有了它的 `applicative`——`applicative` 会提供这个 `unit`。我们需要的只是一个空的
    `F[FreshFish]`，我们将将其作为函数的参数提供。
- en: 'Hence, our new definition for the check will look as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们新的检查定义将如下所示：
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Having empty `F` as a separate argument list will allow us to partially apply
    this function later. The preceding implementation returns an empty `F` in approximately
    30% of cases. We're asking the compiler to check that the implicit `Applicative`
    is available for `F`, as discussed. If this is the case, our implementation will
    delegate to it to create a proper result.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 将空的 `F` 作为单独的参数列表，将允许我们稍后部分应用此函数。前面的实现在大约30%的情况下返回一个空的 `F`。我们要求编译器检查隐式的 `Applicative`
    是否对 `F` 可用，正如所讨论的。如果是这种情况，我们的实现将委托给它来创建一个适当的结果。
- en: 'OK, we now have a way to separate fresh fish from the rest, but there is another
    problem. Our `pie3` function expects all of the ingredients to be wrapped in the
    same type of applicative. This is common in functional programming, and we''ll
    deal with this impediment by lifting other parameters into the same container.
    We could introduce checks for freshness for potatoes and milk in the same way
    that we did for fish, but for simplicity, we''ll assume they are always fresh
    (sorry, critical reader):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们现在有了一种方法来区分新鲜鱼和其他鱼，但还有一个问题。我们的 `pie3` 函数期望所有原料都被包裹在相同类型的 `applicative`
    中。这在函数式编程中很常见，我们将通过将其他参数提升到相同的容器中来克服这个障碍。我们可以像对鱼那样对土豆和牛奶进行新鲜度检查，但为了简单起见，我们假设它们总是新鲜的（抱歉，挑剔的读者）：
- en: '[PRE41]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'With all of the ingredients checked for freshness, we can use our existing
    `pie3` function, almost like we did before:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查了所有原料的新鲜度后，我们可以使用我们现有的 `pie3` 函数，几乎就像我们之前做的那样：
- en: '[PRE42]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The difference is that we need to help the compiler to recognize the proper
    type parameter. We do this by using the type lambda to define the type of the
    container explicitly. There is one missing piece of the puzzle, though. If we
    try to compile the preceding code, it will fail because we don't have an instance
    of `Applicative[Bucket[Option]]` yet.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 差别在于我们需要帮助编译器识别正确的类型参数。我们通过使用类型lambda显式地定义容器的类型来实现这一点。然而，还有一个缺失的拼图。如果我们尝试编译前面的代码，它将失败，因为我们还没有
    `Applicative[Bucket[Option]]` 的实例。
- en: 'Ready to roll up your sleeves and implement it? Well, although there is nothing
    wrong with getting our hands dirty, we don''t want to implement a new applicative
    each time we''d like to have a composition of them. What we''ll do instead is
    define a generic combination of applicatives, which is itself an applicative.
    The fact that applicatives *compose* is their most admirable property. Let''s
    see how this works. This is how we can implement it for our `Applicative[F]`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 准备卷起袖子来实现它吗？好吧，尽管弄脏手没有什么不对，但我们不希望在每次想要组合它们时都实现一个新的 `applicative`。我们将要做的是定义一个通用的
    `applicative` 组合，它本身也是一个 `applicative`。`applicative` 能够 *组合* 是它们最值得称赞的特性。让我们看看它是如何工作的。这是我们可以为我们的
    `Applicative[F]` 实现它的方法：
- en: '[PRE43]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Again, we had to use the type lambda to tell the compiler that this is actually
    just a single type parameter and not two. The implementation of the `unit` method
    is just wrapping one applicative into another. The `apply` method is more complex
    and we implemented it as a local function to make it clearer what is happening.
    The first thing we're doing is converting the internal function of type `G[A =>
    B]` to the type `G[A] => G[B]`. We're doing this by applying the applicative `G`
    on the "internal" function wrapped inside of `f`. Now that we have this function,
    we can call the `map` function of the outer applicative to wrap the result into `F`. The
    last thing we're doing is applying this wrapped composed function on the original
    function and the resulting function, that is, to the original argument of the
    `apply` method.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们不得不使用类型lambda来告诉编译器这实际上只是一个类型参数，而不是两个。`unit`方法的实现只是将一个应用包裹进另一个应用中。`apply`方法更复杂，我们将其实现为一个局部函数，以便更清楚地了解发生了什么。我们首先做的事情是将类型为`G[A
    => B]`的内部函数转换为类型`G[A] => G[B]`。我们通过在`f`包裹的“内部”函数上应用应用`G`来实现这一点。现在我们有了这个函数，我们可以调用外部应用的`map`函数，将结果包裹进`F`。最后，我们应用这个包裹好的组合函数到原始函数和结果函数上，即`apply`方法的原始参数。
- en: 'Now, we can compose these applicatives as we wish:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以按我们的意愿组合这些应用：
- en: '[PRE44]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'And use this combination to call our original pie-making logic:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用这种组合来调用我们原始的馅饼制作逻辑：
- en: '[PRE45]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The beauty of this approach is that it allows us to reuse existing logic with
    arbitrarily nested applicatives, just like in the following artificial example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点在于，它允许我们像以下人工示例一样，以任意嵌套的方式重用现有的逻辑：
- en: '[PRE46]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'All that we need in the case that the structure of containers changes is to
    define a new composite applicative (and a few syntactic helpers like the type
    alias as a constructor, but these aren''t essential). Then, we are able to use
    the existing logic as we did previously. This is what the result looks like in
    REPL:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器结构改变的情况下，我们只需要定义一个新的组合应用（以及一些语法辅助，如构造函数的类型别名，但这些不是必需的）。然后，我们就可以像之前一样使用现有的逻辑。这是在REPL中的结果：
- en: '[PRE47]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can easily change the structure of the result by rewiring the composite
    applicative:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过重新布线组合应用来轻松地改变结果的结构：
- en: '[PRE48]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We changed the composition order and now the result looks different:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们改变了组合的顺序，现在结果看起来不同了：
- en: '[PRE49]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Does it feel like combining applicatives leaves no desires unfulfilled? Well,
    in a sense, it is, except for the case that we want to change the structure of
    the result at hand. To give you an example, let's recall the result of our baking
    endeavor for the fresh fish: `List(Some(FishPie(45)), Some(FishPie(66)), None)`.
    It is a bucket containing either a pie, if the fish was fresh, or nothing if it
    was not. But what if we hired a new cook and now every single fish in the bucket
    has to be fresh or the whole bucket is discarded? Our return type would be `Option[Bucket[FishPie]]`
    in this case—the bucket is full of pies if we have a bucket of fresh fish, or
    nothing. We want to keep our kitchen processes, though! This is the time for the
    `Traversable` functor to enter the scene.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 是否感觉结合应用（applicatives）能满足所有需求？嗯，从某种意义上说，确实如此，除非我们想要改变当前结果的结构。为了举例说明，让我们回顾一下我们为新鲜鱼制作的烘焙成果：`List(Some(FishPie(45)),
    Some(FishPie(66)), None)`。这是一个桶，里面要么有馅饼（如果鱼是新鲜的），要么如果没有，就是空的。但如果我们雇佣了一个新厨师，现在桶里的每条鱼都必须是新鲜的，否则整个桶就会被丢弃呢？在这种情况下，我们的返回类型将是`Option[Bucket[FishPie]]`——如果我们有一个装满新鲜鱼的桶，桶里就会装满馅饼，否则什么也没有。尽管如此，我们还想保留我们的厨房流程！这时，`Traversable`函子就登场了。
- en: Traversable
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Traversable
- en: 'The `Traversable` functor is similar to `Reducible` and `Foldable`, which we
    talked about in the previous chapter. The difference is that methods defined on
    `Traversable` preserve the underlying structure while going over it, as opposed
    to the other abstractions which collapse it into the single result. The `Traversable`
    defines two methods:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`Traversable`函子与我们在上一章中讨论的`Reducible`和`Foldable`类似。区别在于，在`Traversable`上定义的方法在遍历过程中保留了底层结构，而其他抽象则将其折叠成单个结果。`Traversable`定义了两个方法：'
- en: '[PRE50]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Unfortunately, Scala has a deprecated `Traversable` definition left over from
    previous versions, so we are getting rid of it by using import renaming. Our `Traversable`
    defines the `sequence` and `traverse` methods, which loosely correspond to the
    `reduce` and `fold` methods defined on monoids. Starting with the `sequence` method,
    we can see that it turns its argument *inside out*. This is exactly what we needed
    to make our new cook happy. Let''s skip the implementation part for a moment and
    see how it works in practice:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Scala保留了一个过时的`Traversable`定义，这是从之前的版本遗留下来的，所以我们通过使用导入重命名来消除它。我们的`Traversable`定义了`sequence`和`traverse`方法，这些方法与在单例上定义的`reduce`和`fold`方法松散对应。从`sequence`方法开始，我们可以看到它将其参数“翻转”。这正是我们让新厨师高兴所需要的。让我们暂时跳过实现部分，看看它在实际中是如何工作的：
- en: '[PRE51]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As soon as we have `None` in the list, we''re getting `None` back as the result.
    Let''s give it another try:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在列表中遇到`None`，我们就会得到作为结果的`None`。让我们再试一次：
- en: '[PRE52]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If all of the fish are fresh, we get `Some` bucket of pies, as expected. But
    we''re still not 100% satisfied with this approach. The reason for this is that
    we first bake all of the fresh pies we possibly can and then discard them in the
    case that not all of the fish was fresh. Instead, we would like to stop as soon
    as we encounter the first rotten fish. This is what the `traverse` method is for.
    Using it, we can implement our baking process like so:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有的鱼都是新鲜的，我们会得到一些预期的派，但我们对这种方法仍然不满意。原因是我们首先尽可能多地烤制所有新鲜派，然后在不是所有鱼都新鲜的情况下将它们丢弃。相反，我们希望在遇到第一只腐烂的鱼时立即停止。这正是`traverse`方法的作用。使用它，我们可以这样实现我们的烤制过程：
- en: '[PRE53]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here, we're traversing over the `bucketOfFish`. We're using `bucketTraversable`
    for this. It expects a function called `Fish => G[?]` so that `G` is applicative.
    We can satisfy this requirement by providing a function called `Fish => Option[FishPie]`.
    We're using `checkHonestly` to lift a `Fish` into the `Option[FreshFish]`, and
    then we need to `map` over it with our original `bakePie` method.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在遍历`bucketOfFish`。我们为此使用`bucketTraversable`。它期望一个名为`Fish => G[?]`的函数，这样`G`就是可应用的。我们可以通过提供一个名为`Fish
    => Option[FishPie]`的函数来满足这个要求。我们使用`checkHonestly`将一个`Fish`提升到`Option[FreshFish]`，然后我们需要使用我们的原始`bakePie`方法来`map`它。
- en: How is `traverse` implemented? Unfortunately, the implementation for this requires
    knowing the structure of the effect so that it can be preserved. Because of this,
    it needs to be implemented for each instance of the type class or delegated to
    another abstraction where this knowledge is preserved, like `Foldable`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`traverse`是如何实现的？不幸的是，这个实现需要知道效果的结构，以便可以保留它。因此，它需要为类型类的每个实例实现，或者委托给另一个抽象，在这个抽象中保留这种知识，比如`Foldable`。'
- en: 'This is how the `traverse` method can be implemented for `Traversable[List]`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何为`Traversable[List]`实现`traverse`方法的：
- en: '[PRE54]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: To preserve the structure of the list, we `foldRight` over it, starting by lifting
    an empty list into the context of `G`. We're using `map2` in each fold iteration
    to call the provided function on the next element of the original list, lift it
    into `G`, and append it to the result.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保留列表的结构，我们从空列表开始`foldRight`，在每次折叠迭代中使用`map2`来调用提供的函数，将原始列表的下一个元素提升到`G`，并将其附加到结果中。
- en: 'For the `Option`, we could use an approach similar to what we used for `fold`,
    but as we only need to handle two cases, a pattern matching implementation reveals
    the intent much better:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Option`，我们可以使用与`fold`类似的方法，但由于我们只需要处理两种情况，模式匹配实现可以更好地揭示意图：
- en: '[PRE55]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We're just lifting the `Option` into the context of `G` by using the appropriate
    methods for different states of an `Option`. It is worth noting that we're using
    `Some.apply` directly in the case of the non-empty `Option` to preserve the structure
    as required.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是通过使用`Option`的不同状态的方法将`Option`提升到`G`的上下文中。值得注意的是，在非空`Option`的情况下，我们直接使用`Some.apply`来保留所需的结构。
- en: 'The good news is that the second method, `sequence`, is less powerful than
    traverse. Because of this, it can be defined directly on `Traversable` in terms
    of `traverse`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是第二种方法`sequence`比`traverse`弱。正因为如此，它可以直接在`Traversable`上根据`traverse`定义：
- en: '[PRE56]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: It just uses the `identity` function to return a proper value of `G[A]`, as
    expected by `traverse`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是使用`identity`函数返回`G[A]`的正确值，正如`traverse`所期望的。
- en: 'Being a functor, `Traversable`s also compose. The `compose` function will have
    the following signature:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种函子，`Traversable`s也可以组合。`compose`函数将具有以下签名：
- en: '[PRE57]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We'll leave the task of implementing this to the reader.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个实现的任务留给读者。
- en: 'This is how composing `Traversable`s can make life easier. Remember our controversial
    `deeplyPackaged` example? This is, once again, what the type of the container
    looks like:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是组合`Traversable`可以使生活变得更轻松的方式。还记得我们有争议的`deeplyPackaged`示例吗？这又是容器类型的模样：
- en: '[PRE58]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Can you imagine iterating over it and applying some logic to the elements of
    it? With a composed `Traversable`, this is absolutely straightforward:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想象遍历它并对它的元素应用一些逻辑吗？使用组合的`Traversable`，这绝对简单直接：
- en: '[PRE59]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We first compose the `Traversable` to match our nested types. Then, we traverse
    over it, as we did previously. Please note how we omitted the bottom `Option`
    type and have it as a wrapper type for the function parameter for traverse. This
    is the output of the preceding snippet:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将`Traversable`组合起来以匹配我们的嵌套类型。然后，我们遍历它，就像我们之前做的那样。请注意，我们省略了底层的`Option`类型，并将其作为遍历函数参数的包装类型。这是前面代码片段的输出：
- en: '[PRE60]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Does it feel like you have superpowers yet? If you're still not feeling it,
    we have something more to offer in the next chapter!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你感觉像拥有了超能力吗？如果你仍然没有这种感觉，我们将在下一章提供更多内容！
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This was an intense chapter. We learned about the concept of working with effects
    in a way that the knowledge of the effects' structure is *outsourced* to another
    abstraction. We looked at three such abstractions.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一章内容密集的章节。我们学习了以某种方式处理效果的概念，即效果的结构知识被外包给另一个抽象。我们研究了三种这样的抽象。
- en: The `Functor` allows us to apply a function of one argument to each element
    stored in the container.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`Functor`允许我们将一个参数的函数应用到容器中存储的每个元素上。'
- en: The `Applicative` (or applicative functor) extends the `Functor` in a way that
    it is possible to apply a function of two arguments (and by induction, functions
    of any number of arguments). We’ve seen that it is possible to choose one of three
    equally valid sets of primitives that define applicative and derive all of the
    other methods from these primitives.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`Applicative`（或应用函子）以扩展`Functor`的方式，使得应用一个有两个参数的函数（以及通过归纳，任何数量的参数的函数）成为可能。我们已经看到，可以选择三个同样有效的原始函数集来定义应用函子，并从这些原始函数中推导出所有其他方法。'
- en: We said that this approach of defining a minimal set of primitive functions
    and the rest of functionality in terms of these primitives is a common approach
    in functional programming.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说，定义一组最小原始函数以及将这些原始函数作为其他功能定义的方法是函数式编程中的一种常见方法。
- en: The last abstraction we saw was the `Traversable` (or traversable functor),
    which allows us to iterate over effects, thus changing their content, but preserving
    the underlying structure.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后看到的抽象是`Traversable`（或可遍历函子），它允许我们遍历效果，从而改变其内容，但保留底层结构。
- en: We paid special attention to combining applications and later to combining traversable.
    Having implemented the general methods that allow us to build stacks of arbitrary
    functors and use these stacks to go straight to the *heart*, we were able to reuse
    existing functions that were defined in terms of plain effect-free types.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们特别关注了应用和遍历的组合。在实现了允许我们构建任意函子堆栈并使用这些堆栈直接到达*核心*的通用方法之后，我们能够重用那些以纯无效果类型定义的现有函数。
- en: What we haven't demonstrated, though, is the way that data from one applicative
    can influence functions that are called deeper in the stack—we just used constant
    parameters in our examples. The reason we did this is that applications do not
    support sequencing computations.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们没有展示的是，一个应用函子的数据如何影响堆栈中更深层次的函数调用——我们只是在使用示例中使用了常量参数。我们这样做的原因是应用不支持计算序列化。
- en: In the next chapter, we'll learn about another abstraction that is capable of
    truly chaining computations—a monad.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习另一种能够真正链式计算抽象——单子。
- en: Questions
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Implement `Functor[Try]`. Check that your implementation passes the property
    check, just like it did in this chapter.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Functor[Try]`。检查你的实现是否通过属性检查，就像在本章中做的那样。
- en: Implement `Applicative[Try]`. Check that your implementation passes the property
    check, just like it did in this chapter.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Applicative[Try]`。检查你的实现是否通过属性检查，就像在本章中做的那样。
- en: Implement `Applicative[Either]`. Check that your implementation passes the property
    check, just like it did in this chapter.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Applicative[Either]`。检查你的实现是否通过属性检查，就像在本章中做的那样。
- en: Implement `Traversable[Try]`.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Traversable[Try]`。
- en: Implement `Traversable[Either]`.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Traversable[Either]`。
- en: Implement `Traversable.compose`, in the same way, that we discussed at the end
    of this chapter.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `Traversable.compose`，就像我们在本章末尾讨论的那样。
- en: Further reading
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Atul S. Khot, *Scala Functional Programming Patterns*: Grok and performing effective
    functional programming in Scala
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Atul S. Khot，《Scala 函数式编程模式》：掌握和执行有效的 Scala 函数式编程
- en: Ivan Nikolov, *Scala Design Patterns* - Second Edition: Learn how to write efficient,
    clean, and reusable code with Scala
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ivan Nikolov，《Scala 设计模式》第二版：学习如何使用 Scala 编写高效、简洁且可重用的代码
