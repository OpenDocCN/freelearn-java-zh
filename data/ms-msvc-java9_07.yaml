- en: Securing Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护微服务
- en: As you know, microservices are the components that we deploy in on-premises
    or cloud infrastructures. Microservices may offer APIs or web applications. Our
    sample application, OTRS, offers APIs. This chapter will focus on how to secure
    these APIs using Spring Security and Spring OAuth2\. We'll also focus on OAuth
    2.0 fundamentals, using OAuth 2.0 to secure the OTRS APIs. For more understanding
    on securing REST APIs, you can refer to the *RESTful Java Web Services Security,*
    *Packt Publishing* book. You can also refer to the *Spring Security*, *Packt Publishing*
    video for more information on Spring Security. We'll also learn about cross-origin
    request site filters and cross-site scripting blockers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所知，微服务是我们部署在本地或云基础设施上的组件。微服务可能提供API或网络应用程序。我们的示例应用程序OTRS提供API。本章将重点介绍如何使用Spring
    Security和Spring OAuth2保护这些API。我们还将重点介绍OAuth 2.0基本原理，使用OAuth 2.0保护OTRS API。要了解更多关于保护REST
    API的信息，您可以参考*RESTful Java Web Services Security,* *Packt Publishing* 书籍。您还可以参考*Spring
    Security*, *Packt Publishing*视频以获取有关Spring Security的更多信息。我们还将学习跨源请求站点过滤器和跨站脚本阻止器。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Enabling Secure Socket Layer (SSL)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用安全套接层（SSL）
- en: Authentication and authorization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份验证和授权
- en: OAuth 2.0
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth 2.0
- en: Enabling Secure Socket Layer
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用安全套接层
- en: So far, we have used the **Hyper Text Transfer Protocol** (**HTTP**). HTTP transfers
    data in plain text, but data transfer over the internet in plain text is not a
    good idea at all. It makes hacker's jobs easy and allows them to get your private
    information, such as your user ID, passwords, and credit card details easily using
    a packet sniffer.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直使用**超文本传输协议**（**HTTP**）。HTTP以明文形式传输数据，但在互联网上以明文形式传输数据是一个非常糟糕的主意。这使得黑客的工作变得容易，允许他们使用数据包嗅探器轻松获取您的私人信息，例如您的用户ID、密码和信用卡详细信息。
- en: We definitely don't want to compromise user data, so we will provide the most
    secure way to access our web application. Therefore, we need to encrypt the information
    that is exchanged between the end user and our application. We'll use **Secure
    Socket Layer** (**SSL**) or **Transport Security Layer** (**TSL**) to encrypt
    the data.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绝对不希望妥协用户数据，因此我们将提供访问我们网络应用的最安全方式。因此，我们需要加密终端用户与应用之间交换的信息。我们将使用**安全套接层**（**SSL**）或**传输安全层**（**TSL**）来加密数据。
- en: 'SSL is a protocol designed to provide security (encryption) for network communications.
    HTTP associates with SSL to provide the secure implementation of HTTP, known as
    **Hyper Text Transfer Protocol Secure**, or **Hyper Text Transfer Protocol over
    SSL** (**HTTPS**). HTTPS makes sure that the privacy and integrity of the exchanged
    data is protected. It also ensures the authenticity of websites visited. This
    security centers around the distribution of signed digital certificates between
    the server hosting the application, the end user''s machine, and a third-party
    trust store server. Let''s see how this process takes place:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 安全套接层（SSL）是一种旨在为网络通信提供安全（加密）的协议。HTTP与SSL关联，以提供安全实现HTTP，称为**安全超文本传输协议**，或**通过SSL的HTTP**（**HTTPS**）。HTTPS确保交换数据的隐私和完整性得到保护。它还确保访问的网站的真实性。这种安全性围绕在托管应用程序的服务器、终端用户的机器和第三方信任存储服务器之间分发签名的数字证书。让我们看看这个过程是如何进行的：
- en: The end user sends the request to the web application, for example [http://twitter.com](http://twitter.com),
    using a web browser
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 终端用户使用网络浏览器向网络应用发送请求，例如[http://twitter.com](http://twitter.com)
- en: On receiving the request, the server redirects the browser to [https://twitter.com](https://twitter.com)
    using the HTTP code 302
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接收到请求后，服务器使用HTTP代码302将浏览器重定向到[https://twitter.com](https://twitter.com)
- en: The end user's browser connects to [https://twitter.com](https://twitter.com)
    and, in response, the server provides the certificate containing the digital signature
    to the end user's browser
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 终端用户的浏览器连接到[https://twitter.com](https://twitter.com)，作为回应，服务器向终端用户的浏览器提供包含数字签名的证书
- en: The end user's browser receives this certificate and checks it against a list
    of trusted **certificate authority** (**CA**) for verification
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 终端用户的浏览器接收到这个证书，并将其与可信的**证书授权机构**（**CA**）列表进行比对以进行验证
- en: 'Once the certificate gets verified all the way to the root CA, an encrypted
    communication is established between the end user''s browser and the application
    hosting server:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦证书验证到根CA，终端用户的浏览器与应用托管服务器之间就建立了加密通信：
- en: '![](img/a03a2790-bdc3-48ec-8ce6-d59edc13a93a.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a03a2790-bdc3-48ec-8ce6-d59edc13a93a.jpg)'
- en: Secure HTTP communication
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 安全的HTTP通信
- en: Although SSL ensures security in terms of encryption and web application authenticity,
    it does not safeguard against phishing and other attacks. Professional hackers
    can decrypt information sent using HTTPS.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管SSL在加密和Web应用真实性方面确保了安全，但它并不能防止钓鱼和其他攻击。专业的黑客可以解密通过HTTPS发送的信息。
- en: Now, after going over the basics of SSL, let's implement it for our sample OTRS
    project. We don't need to implement SSL for all microservices. All microservices
    will be accessed using our proxy or Edge server; Zuul-Server by the external environment,
    except our new microservice, security-service, which we will introduce in this
    chapter for authentication and authorization.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在了解了SSL的基本知识之后，让我们为我们的示例OTRS项目实现它。我们不需要为所有微服务实现SSL。所有微服务都将通过我们的代理或Edge服务器访问；Zuul-Server由外部环境访问，除了我们将在本章中介绍的新微服务security-service，用于认证和授权。
- en: 'First, we''ll set up SSL in an Edge server. We need to have the keystore that
    is required for enabling SSL in embedded Tomcat. We''ll use the self-signed certificate
    for demonstration. We''ll use Java keytool to generate the keystore using the
    following command. You can use any other tool also:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在一个Edge服务器上设置SSL。我们需要一个用于在嵌入式Tomcat中启用SSL的keystore。我们将使用自签名证书进行演示。我们将使用Java
    keytool生成keystore，使用以下命令。您也可以使用其他任何工具：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It asks for information such as name, address details, organization, and so
    on (see the following screenshot):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 它要求提供诸如姓名、地址详情、组织等信息（见下面的屏幕截图）：
- en: '![](img/bcd90065-6c21-4b90-b5e8-baa0af4d1e09.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bcd90065-6c21-4b90-b5e8-baa0af4d1e09.png)'
- en: The keytool generates keys
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: keytool生成密钥
- en: 'Be aware of the following points to ensure the proper functioning of self-signed
    certificates:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为确保自签名证书的正常工作，请注意以下几点：
- en: Use `-ext` to define **Subject Alternative Names** (**SANs**). You can also
    use an IP (for example, `san=ip:190.19.0.11`). Earlier, use of the hostname of
    the machine, where application deployment takes place, was being used as most
    **common name** (**CN**). It prevents the `java.security.cert.CertificateException`
    from returning `No name matching localhost found`.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`-ext`定义**主题备用名称**（**SANs**）。您还可以使用IP（例如，`san=ip:190.19.0.11`）。以前，通常使用应用程序部署机器的主机名作为最常见的名称（**CN**）。它防止了`java.security.cert.CertificateException`返回`No
    name matching localhost found`。
- en: 'You can use a browser or OpenSSL to download the certificate. Add the newly
    generated certificate to the `cacerts` keystore, located at `jre/lib/security/cacerts`
    inside the active `JDK/JRE` home directory, by using the `keytool -importcert`
    command. Note that `changeit` is the default password for the `cacerts` keystore.
    Run the following command:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用浏览器或OpenSSL下载证书。使用`keytool -importcert`命令，将新生成的证书添加到位于活动`JDK/JRE`主目录内的`jre/lib/security/cacerts`的`cacerts`
    keystore中。注意`changeit`是`cacerts` keystore的默认密码。运行以下命令：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Self-signed certificates can be used only for development and testing purposes.
    The use of these certificates in a production environment does not provide the
    required security. Always use the certificates provided and signed by trusted
    signing authorities in production environments. Store your private keys safely.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 自签名证书只能用于开发和测试目的。在生产环境中使用这些证书并不能提供所需的安全性。在生产环境中总是使用由可信签名机构提供和签名的证书。妥善保管您的私钥。
- en: 'Now, after putting the generated `keystore.jks` in the `src/main/resources`
    directory of the OTRS project, along with `application.yml`, we can update this
    information in the Edge server `application.yml`, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在将生成的`keystore.jks`放入OTRS项目的`src/main/resources`目录中，与`application.yml`一起，我们可以像以下这样更新Edge服务器的`application.yml`信息：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Rebuild the Zuul-Server JAR to use the HTTPS.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 重建Zuul-Server JAR以使用HTTPS。
- en: The keystore file can be stored in the preceding class path in Tomcat version
    7.0.66+ and 8.0.28+. For older versions, you can use the path of the keystore
    file for the `server:ssl:key-store` value.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在Tomcat 7.0.66+和8.0.28+版本中，可以将keystore文件存储在之前的类路径中。对于旧版本，您可以使用keystore文件的路径作为`server:ssl:key-store`的值。
- en: Similarly, you can configure SSL for other microservices.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以为其他微服务配置SSL。
- en: Authentication and authorization
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证和授权
- en: Providing authentication and authorization is de facto for web applications.
    We'll discuss authentication and authorization in this section. The new paradigm
    that has evolved over the past few years is OAuth. We'll learn and use OAuth 2.0
    for implementation. OAuth is an open authorization mechanism, implemented in every
    major web application. Web applications can access each other's data by implementing
    the OAuth standard. It has become the most popular way to authenticate oneself
    for various web applications. For example, on [https://www.quora.com/](https://www.quora.com/),
    you can register and log in using your Google or Twitter login IDs. It is also
    more user friendly, as client applications (for example, [https://www.quora.com/](https://www.quora.com/))
    don't need to store the user's passwords. The end user does not need to remember
    one more user ID and password.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 提供认证和授权是网络应用程序的默认行为。我们将在本节讨论认证和授权。过去几年发展起来的新范例是OAuth。我们将学习和使用OAuth 2.0进行实现。OAuth是一个开放授权机制，在每一个主要网络应用程序中都有实现。通过实现OAuth标准，网络应用程序可以访问彼此的数据。它已经成为各种网络应用程序认证自己的最流行方式。例如，在[https://www.quora.com/](https://www.quora.com/)上，你可以使用你的Google或Twitter登录ID进行注册和登录。这也更用户友好，因为客户端应用程序（例如[https://www.quora.com/](https://www.quora.com/)）不需要存储用户的密码。最终用户不需要记住另一个用户ID和密码。
- en: '![](img/9ba38134-b0a2-45eb-93b0-1908e43f3234.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9ba38134-b0a2-45eb-93b0-1908e43f3234.jpg)'
- en: OAuth 2.0 example usage
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0示例使用
- en: OAuth 2.0
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth 2.0
- en: The **Internet** **Engineering Task Force** (**IETF**) governs the standards
    and specifications of OAuth. OAuth 1.0a was the most recent version before OAuth
    2.0 that was having a fix for the session-fixation security flaw in OAuth 1.0\.
    OAuth 1.0 and 1.0a are very different from OAuth 2.0\. OAuth 1.0 relies on security
    certificates and channel binding, whereas OAuth 2.0 does not support security
    certification and channel binding. It works completely on **Transport Layer Security**
    (**TLS**). Therefore, OAuth 2.0 does not provide backward compatibility.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**互联网工程任务组**（**IETF**）管理OAuth的标准和规格。OAuth 1.0a是在OAuth 2.0之前的最新版本，它解决了OAuth
    1.0中的会话固定安全漏洞。OAuth 1.0和1.0a与OAuth 2.0非常不同。OAuth 1.0依赖于安全证书和通道绑定，而OAuth 2.0不支持安全证书和通道绑定。它完全基于**传输层安全**（**TLS**）。因此，OAuth
    2.0不提供向后兼容性。'
- en: Usage of OAuth
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OAuth
- en: 'The various uses of OAuth are as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth的各种用途如下：
- en: As discussed, it can be used for authentication. You might have seen it in various
    applications, displaying messages such as sign in using Facebook or a sign in
    using Twitter.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如讨论的那样，它可以用于身份验证。你可能在各种应用程序中看到过它，比如显示“使用Facebook登录”或“使用Twitter登录”的消息。
- en: Applications can use it to read data from other applications, such as by integrating
    a Facebook widget into the application, or having a Twitter feed on your blog.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序可以利用它来读取其他应用程序的数据，例如通过在应用程序中集成Facebook小部件，或者在博客上拥有Twitter源。
- en: 'Or, the opposite of the previous point can be true: you enable other applications
    to access the end user''s data.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，与前面一点相反的情况也是正确的：你允许其他应用程序访问最终用户的数据。
- en: OAuth 2.0 specification - concise details
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth 2.0规格说明 - 简洁的细节
- en: We'll try to discuss and understand the OAuth 2.0 specifications in a concise
    manner. Let's first see how signing in using Twitter works.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试以简洁的方式讨论和理解OAuth 2.0规格说明。首先让我们看看使用Twitter登录是如何工作的。
- en: 'Please note that the process mentioned here was used at the time of writing,
    and may change in the future. However, this process describes one of the OAuth
    2.0 processes properly:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里提到的过程是在写作时使用的，未来可能会有所变化。然而，这个过程正确地描述了OAuth 2.0的其中一个过程：
- en: The user visits the Quora home page, which shows various login options. We'll
    explore the process of the Continue with Twitter link.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户访问Quora主页，上面显示各种登录选项。我们将探讨点击“继续使用Twitter”链接的过程。
- en: When the user clicks on the Continue with Twitter link, Quora opens a new window
    (in Chrome) that redirects the user to the [www.twitter.com](http://www.twitter.com)
    application. During this process, few web applications redirect the user to the
    same opened tab/window.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户点击“继续使用Twitter”链接时，Quora在一个新窗口（在Chrome中）中打开，该窗口将用户重定向到[www.twitter.com](http://www.twitter.com)应用程序。在这个过程中，一些网络应用程序将用户重定向到同一个已打开的标签/窗口。
- en: In this new window/tab, the user signs in to [www.twitter.com](http://www.twitter.com)
    with their credentials.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个新窗口/标签中，用户使用他们的凭据登录[www.twitter.com](http://www.twitter.com)。
- en: If the user has not already authorized the Quora application to use their data,
    Twitter asks for the user's permission to authorize Quora to access the user's
    information. If the user has already authorized Quora, then this step is skipped.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户尚未授权Quora应用使用他们的数据，Twitter会请求用户授权Quora访问用户的信息。如果用户已经授权Quora，则跳过此步骤。
- en: After proper authentication, Twitter redirects the user to Quora's redirect
    URI with an authentication code.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 经过适当的认证后，Twitter会将用户重定向到Quora的重定向URI，并附带一个认证码。
- en: Quora sends the client ID, client secret token, and authentication code (sent
    by Twitter in step five) to Twitter when the Quora redirect URI is entered in
    the browser.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当在浏览器中输入Quora的重定向URI时，Quora发送客户端ID、客户端密钥令牌和认证码（由Twitter在第五步发送）。
- en: After validating these parameters, Twitter sends the access token to Quora.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在验证这些参数后，Twitter将访问令牌发送给Quora。
- en: The user is logged in to Quora on successful retrieval of the access token.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户在成功获取访问令牌后登录到Quora。
- en: Quora may use this access token to retrieve user information from Twitter.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Quora可能使用此访问令牌从Twitter检索用户信息。
- en: You must be wondering how Twitter got Quora's redirect URI, client ID, and secret
    token. Quora works as a client application and Twitter as an authorization server.
    Quora, as a client, is registered on Twitter by using Twitter's OAuth implementation
    to use resource owner (end user) information. Quora provides a redirect URI at
    the time of registration. Twitter provides the client ID and secret token to Quora.
    In OAuth 2.0, user information is known as user resources. Twitter provides a
    resource server and an authorization server. We'll discuss more of these OAuth
    terms in the following sections.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道Twitter是如何获得Quora的重定向URI、客户端ID和密钥令牌的。Quora作为客户端应用程序，Twitter作为授权服务器。Quora作为客户端，在注册时使用Twitter的OAuth实现来使用资源所有者（最终用户）的信息。Quora在注册时提供一个重定向URI。Twitter向Quora提供客户端ID和密钥令牌。在OAuth
    2.0中，用户信息被称为用户资源。Twitter提供一个资源服务器和一个授权服务器。我们将在接下来的章节中讨论更多关于这些OAuth术语的内容。
- en: '![](img/b0c76112-52d8-4051-9e33-442567eee985.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b0c76112-52d8-4051-9e33-442567eee985.jpg)'
- en: OAuth 2.0 example process for signing in with Twitter
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Twitter登录的OAuth 2.0示例过程
- en: OAuth 2.0 roles
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth 2.0角色
- en: 'There are four roles defined in the OAuth 2.0 specifications:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0规范中定义了四个角色：
- en: Resource owner
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源所有者
- en: Resource server
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源服务器
- en: Client
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端
- en: Authorization server
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权服务器
- en: '![](img/7b76513b-0a74-4b4f-bbf6-b09037f4983e.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b76513b-0a74-4b4f-bbf6-b09037f4983e.jpg)'
- en: OAuth 2.0 roles
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0角色
- en: Resource owner
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源所有者
- en: For the example of a Quora sign in using Twitter, the Twitter user was the resource
    owner. The resource owner is an entity that owns the protected resources (for
    example, user handle, tweets, and so on) that are to be shared. This entity can
    be an application or a person. We call this entity the resource owner because
    it can only grant access to its resources. The specifications also define that
    when the resource owner is a person, they are referred to as an end user.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以Quora使用Twitter登录为例，Twitter用户是资源所有者。资源所有者是拥有要共享的受保护资源（例如，用户处理、推文等）的实体。这个实体可以是应用程序或个人。我们称这个实体为资源所有者，因为它只能授予对其资源的访问权限。规范还定义，当资源所有者是个人时，它们被称为最终用户。
- en: Resource server
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源服务器
- en: The resource server hosts the protected resources. It should be capable of serving
    the access requests to these resources using access tokens. For the example of
    a Quora sign in using Twitter, Twitter is the resource server.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 资源服务器托管受保护的资源。它应该能够使用访问令牌服务于这些资源。以Quora使用Twitter登录为例，Twitter是资源服务器。
- en: Client
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端
- en: For the example of the Quora sign in using Twitter, Quora is the client. The
    client is the application that makes access requests for protected resources to
    the resource server on behalf of the resource owner.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以Quora使用Twitter登录为例，Quora是客户端。客户端是代表资源所有者向资源服务器请求受保护资源的应用程序。
- en: Authorization server
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权服务器
- en: The authorization server provides different tokens to the client application,
    such as access tokens or refresh tokens, only after the resource owner authenticates
    themselves.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 授权服务器在资源所有者身份验证后，才向客户端应用程序提供不同的令牌，例如访问令牌或刷新令牌。
- en: OAuth 2.0 does not provide any specifications for interactions between the resource
    server and the authorization server. Therefore, the authorization server and resource
    server can be on the same server, or can be on a separate one.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0没有为资源服务器与授权服务器之间的交互提供任何规范。因此，授权服务器和资源服务器可以在同一服务器上，也可以在不同的服务器上。
- en: A single authorization server can also be used to issue access tokens for multiple
    resource servers.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一个授权服务器也可以用于为多个资源服务器颁发访问令牌。
- en: OAuth 2.0 client registration
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth 2.0客户端注册
- en: 'The client that communicates with the authorization server to obtain the access
    key for a resource should first be registered with the authorization server. The
    OAuth 2.0 specification does not specify the way a client registers with the authorization
    server. Registration does not require direct communication between the client
    and the authorization server. Registration can be done using self-issued or third-party-issued
    assertions. The authorization server obtains the required client properties using
    one of these assertions. Let''s see what the client properties are:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端与授权服务器通信以获取资源访问密钥时，应首先向授权服务器注册。OAuth 2.0规范没有指定客户端如何向授权服务器注册的方式。注册不需要客户端与授权服务器之间直接通信。注册可以使用自发行或第三方发行的断言完成。授权服务器使用其中一个断言获取所需的客户端属性。让我们看看客户端属性是什么：
- en: Client type (discussed in the next section).
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端类型（在下一节中讨论）。
- en: Client redirect URI, as we discussed in the example of a Quora sign in using
    Twitter. This is one of the endpoints used for OAuth 2.0\. We will discuss other
    endpoints in the *Endpoints* section.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端重定向URI，正如我们在使用Twitter登录Quora的示例中讨论的那样。这是用于OAuth 2.0的端点之一。我们将在*端点*部分讨论其他端点。
- en: Any other information required by the authorization server, for example, client
    name, description, logo image, contact details, acceptance of legal terms and
    conditions, and so on.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权服务器可能需要的任何其他信息，例如客户端名称、描述、标志图像、联系详情、接受法律条款和条件等。
- en: Client types
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端类型
- en: 'There are two types of client described by the specification, based on their
    ability to maintain the confidentiality of client credentials: confidential and
    public. Client credentials are secret tokens issued by the authorization server
    to clients in order to communicate with them. The client types are described as
    follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 规范中描述了两种客户端类型，根据它们保持客户端凭据保密的能力：保密和公共。客户端凭据是由授权服务器颁发给客户端的秘密令牌，以便与它们通信。客户端类型如下所述：
- en: '**Confidential client type:** This is a client application that keeps passwords
    and other credentials securely or maintains them confidentially. In the example
    of a Quora sign in using Twitter, the Quora application server is secure and has
    restricted access implementation. Therefore, it is of the confidential client
    type. Only the Quora application administrator has access to client credentials.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保密客户端类型：** 这是一个保持密码和其他凭据安全或保密的客户端应用程序。在使用Twitter登录Quora的示例中，Quora应用服务器是安全的，并且实现了受限的访问。因此，它属于保密客户端类型。只有Quora应用管理员才能访问客户端凭据。'
- en: '**Public client type:** These are client applications that do *not* keep passwords
    and other credentials securely or maintain them confidentially. Any native app
    on mobile or desktop, or an app that runs on a browser, are perfect examples of
    the public client type, as these keep client credentials embedded inside them.
    Hackers can crack these apps and the client credentials can be revealed.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共客户端类型：** 这些客户端应用程序不*保持*密码和其他凭据的安全或保密。任何移动或桌面上的本地应用，或者在浏览器上运行的应用，都是公共客户端类型的完美示例，因为这些应用中嵌入了客户端凭据。黑客可以破解这些应用，从而暴露客户端凭据。'
- en: A client can be a distributed component-based application, for example, it could
    have both a web browser component and a server-side component. In this case, both
    components will have different client types and security contexts. Such a client
    should register each component as a separate client if the authorization server
    does not support such clients.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以是分布式组件基础应用程序，例如，它可能同时具有网络浏览器组件和服务器端组件。在这种情况下，两个组件将具有不同的客户端类型和安全上下文。如果授权服务器不支持此类客户端，则此类客户端应将每个组件注册为单独的客户端。
- en: Client profiles
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端配置文件
- en: 'Based on the OAuth 2.0 client types, a client can have the following profiles:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 根据OAuth 2.0客户端类型，客户端可以有以下配置文件：
- en: '**Web application:** The Quora web application used in the example of a Quora
    sign-in using Twitter is a perfect example of an OAuth 2.0 web application client
    profile. Quora is a confidential client running on a web server. The resource
    owner (end user) accesses the Quora application (OAuth 2.0 client) on the browser
    (user agent) using a HTML user interface on their device (desktop/tablet/cell
    phone). The resource owner cannot access the client (Quora OAuth 2.0 client) credentials
    and access tokens, as these are stored on the web server. You can see this behavior
    in the diagram of the OAuth 2.0 sample flow. See steps six to eight in the following
    figure:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络应用：** 在Quora使用Twitter登录的示例中使用的Quora网络应用是OAuth 2.0网络应用客户端配置文件的完美示例。Quora是一个运行在网络服务器上的机密客户端。资源所有者（最终用户）通过他们设备上的HTML用户界面在浏览器（用户代理）上访问Quora应用（OAuth
    2.0客户端）。资源所有者无法访问客户端（Quora OAuth 2.0客户端）凭据和访问令牌，因为这些是存储在网络服务器上的。您可以在OAuth 2.0示例流程图中看到此行为，具体在以下步骤六到八中：'
- en: '![](img/c9133c30-f9be-4f91-a386-04f8f57aa134.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c9133c30-f9be-4f91-a386-04f8f57aa134.jpg)'
- en: OAuth 2.0 client web application profile
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0 客户端网络应用配置文件
- en: '**User agent-based application:** User agent-based applications are of the
    public client type. Here though, the application resides in the web server, but
    the resource owner downloads it on the user agent (for example, a web browser)
    and then executes the application. Here, the downloaded application that resides
    in the user agent on the resource owner''s device communicates with the authorization
    server. The resource owner can access the client credentials and access tokens.
    A gaming application is a good example of such an application profile. The user
    agent application flow is shown as follows:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于用户代理的应用：** 基于用户代理的应用是公共客户端类型。在这种情况下，应用位于网络服务器上，但资源所有者将其下载到用户代理（例如，网络浏览器）上，然后在该设备上执行。在这里，下载并驻留在资源所有者设备上的用户代理中的应用与授权服务器通信。资源所有者可以访问客户端凭据和访问令牌。游戏应用是此类应用配置的一个很好的例子。用户代理应用流程如下所示：'
- en: '![](img/4d954ef4-70f8-468d-8564-c67d37a3bb74.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d954ef4-70f8-468d-8564-c67d37a3bb74.jpg)'
- en: OAuth 2.0 client user agent application profile
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0 客户端基于用户代理的应用配置文件
- en: '**Native application:** Native applications are similar to user agent-based
    applications, except these are installed on the resource owner''s device and executed
    natively, instead of being downloaded from the web server and then executed inside
    the user agent. Many native clients (mobile applications) you download on your
    mobile are of the native application type. Here, the platform makes sure that
    other applications on the device do not access the credentials and access tokens
    of other applications. In addition, native applications should not share client
    credentials and OAuth tokens with servers that communicate with native applications,
    as shown in the following figure:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原生应用：** 原生应用与基于用户代理的应用类似，不同之处在于这些应用是安装在资源所有者的设备上并原生执行的，而不是从网络服务器下载并在用户代理中执行。您在手机上下载的许多原生应用都属于原生应用类型。在这里，平台确保设备上的其他应用不能访问其他应用的凭据和访问令牌。此外，原生应用不应与与原生应用通信的服务器共享客户端凭据和OAuth令牌，如下面的图所示：'
- en: '![](img/5ee3ee45-fea2-4a0a-b0f6-e3455073aa14.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ee3ee45-fea2-4a0a-b0f6-e3455073aa14.jpg)'
- en: OAuth 2.0 client native application profile
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0 客户端原生应用配置文件
- en: Client identifier
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端标识符
- en: It is the authorization server's responsibility to provide a unique identifier
    to the registered client. This client identifier is a string representation of
    the information provided by the registered client. The authorization server needs
    to make sure that this identifier is unique. The authorization server should not
    use it on its own for authentication.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 授权服务器的责任是向注册客户端提供一个唯一标识符。此客户端标识符是注册客户端提供的信息的字符串表示。授权服务器需要确保此标识符是唯一的，并且授权服务器本身不应使用它进行身份验证。
- en: The OAuth 2.0 specification does not specify the size of the client identifier.
    The authorization server can set the size, and it should document the size of
    the client identifier it issues.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0 规范没有指定客户端标识符的大小。授权服务器可以设置客户端标识符的大小，并且应该文档化其发行的大小。
- en: Client authentication
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端认证
- en: The authorization server should authenticate the client based on their client
    type. The authorization server should determine the authentication method that
    suits and meets security requirements. It should only use one authentication method
    in each request.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 授权服务器应根据客户端类型验证客户端。授权服务器应确定适合并满足安全要求的认证方法。它应在每个请求中只使用一种认证方法。
- en: Typically, the authorization server uses a set of client credentials, such as
    the client password and some key tokens, to authenticate confidential clients.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，授权服务器使用一组客户端凭据，例如客户端密码和一些密钥令牌，来认证保密客户端。
- en: The authorization server may establish a client authentication method with public
    clients. However, it must not rely on this authentication method to identify the
    client, for security reasons.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 授权服务器可能与公共客户端建立客户端认证方法。然而，出于安全原因，它不能依赖这种认证方法来识别客户端。
- en: A client possessing a client password can use basic HTTP authentication. OAuth
    2.0 does not recommend sending client credentials in the request body, but recommends
    using TLS and brute force attack protection on endpoints required for authentication.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有客户端密码的客户端可以使用基本HTTP认证。OAuth 2.0建议不要在请求体中发送客户端凭据，但建议在需要身份验证的端点上使用TLS和暴力攻击保护。
- en: OAuth 2.0 protocol endpoints
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth 2.0协议端点
- en: 'An endpoint is nothing but a URI we use for REST or web components, such as
    Servlet or JSP. OAuth 2.0 defines three types of endpoints. Two are authorization
    server endpoints and one is a client endpoint:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 端点不过是我们在REST或网络组件中使用的URI，例如Servlet或JSP。OAuth 2.0定义了三种端点类型。其中两个是授权服务器端点，一个是客户端端点：
- en: Authorization endpoint (authorization server endpoint)
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权端点（授权服务器端点）
- en: Token endpoint (authorization server endpoint)
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 令牌端点（授权服务器端点）
- en: Redirection endpoint (client endpoint)
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重定向端点（客户端端点）
- en: Authorization endpoint
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权端点
- en: This endpoint is responsible for verifying the identity of the resource owner
    and, once verified, obtaining the authorization grant. We'll discuss the authorization
    grant in the next section.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个端点负责验证资源所有者的身份，并在验证后获取授权许可。我们在下一节讨论授权许可。
- en: The authorization server requires TLS for the authorization endpoint. The endpoint
    URI must not include the fragment component. The authorization endpoint must support
    the HTTP `GET` method.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 授权服务器要求对授权端点使用TLS。端点URI必须不包含片段组件。授权端点必须支持HTTP `GET`方法。
- en: 'The specification does not specify the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 规范没有指定以下内容：
- en: The way the authorization server authenticates the client.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权服务器认证客户端的方式。
- en: How the client will receive the authorization endpoint URI. Normally, documentation
    contains the authorization endpoint URI, or the client obtains it at the time
    of registration.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端如何接收授权端点的URI。通常，文档包含授权端点的URI，或者在注册时客户端获取它。
- en: Token endpoint
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 令牌端点
- en: The client calls the token endpoint to receive the access token by sending the
    authorization grant or refresh token. The token endpoint is used by all authorization
    grants except the implicit grant.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端调用令牌端点，通过发送授权许可或刷新令牌来接收访问令牌。除了隐式授权外，所有授权许可都使用令牌端点。
- en: Like the authorization endpoint, the token endpoint also requires TLS. The client
    must use the HTTP `POST` method to make the request to the token endpoint.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 像授权端点一样，令牌端点也需要TLS。客户端必须使用HTTP `POST`方法对令牌端点提出请求。
- en: Like the authorization endpoint, the specification does not specify how the
    client will receive the token endpoint URI.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 像授权端点一样，规范没有指定客户端如何接收令牌端点的URI。
- en: Redirection endpoint
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重定向端点
- en: 'The authorization server redirects the resource owner''s user agent (for example,
    a web browser) back to the client using the redirection endpoint, once the authorization
    endpoint''s interactions are completed between the resource owner and the authorization
    server. The client provides the redirection endpoint at the time of registration.
    The redirection endpoint must be an absolute URI and not contain a fragment component.
    The OAuth 2.0 endpoints are as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 授权服务器使用重定向端点将资源所有者的用户代理（例如，网络浏览器）回退到客户端，一旦资源所有者和授权服务器之间的授权端点的交互完成。客户端在注册时提供重定向端点。重定向端点必须是绝对URI，并且不包含片段组件。OAuth
    2.0端点如下：
- en: '![](img/91a2c588-bc2c-4ce5-8168-df96b8956dbf.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91a2c588-bc2c-4ce5-8168-df96b8956dbf.jpg)'
- en: OAuth 2.0 endpoints
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0端点
- en: OAuth 2.0 grant types
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth 2.0授权类型
- en: 'The client requests an access token from the authorization server, based on
    the obtained authorization from the resource owner. The resource owner gives authorization
    in the form of an authorization grant. OAuth 2.0 defines four types of authorization
    grant:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端基于从资源所有者获得的授权，请求授权服务器授予访问令牌。资源所有者以授权授予的形式给予授权。OAuth 2.0定义了四种授权授予类型：
- en: Authorization code grant
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权码授予
- en: Implicit grant
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式授予
- en: Resource owner password credentials grant
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源所有者密码凭证授予
- en: Client credentials grant
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端凭据授予
- en: OAuth 2.0 also provides an extension mechanism to define additional grant types.
    You can explore this in the official OAuth 2.0 specifications.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0还提供了一种扩展机制来定义其他授予类型。你可以在官方OAuth 2.0规范中探索这一点。
- en: Authorization code grant
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权码授予
- en: 'The first sample flow that we discussed in the OAuth 2.0 example flow for signing
    in with Twitter depicts an authorization code grant. We''ll add a few more steps
    for the complete flow. As you know, after the eighth step, the end user logs in
    to the Quora application. Let''s assume the user is logging in to Quora for the
    first time and requests their Quora profile page:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在OAuth 2.0登录Twitter的示例流程中讨论的第一个样本流程显示了一个授权码授予。我们会在完整的流程中添加一些更多步骤。正如你所知，在第8步之后，最终用户登录到Quora应用。假设用户第一次登录到Quora并请求他们的Quora资料页面：
- en: After logging in, the Quora user clicks on their Quora profile page.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录后，Quora用户点击他们的Quora资料页面。
- en: The OAuth client Quora requests the Quora user's (resource owner) resources
    (for example, Twitter profile photo, and so on) from the Twitter resource server
    and sends the access token received in the previous step.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OAuth客户端Quora请求Twitter资源服务器中Quora用户（资源所有者）的资源（例如，Twitter资料照片等），并发送在上一步中收到的访问令牌。
- en: The Twitter resource server verifies the access token using the Twitter authorization
    server.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Twitter资源服务器使用Twitter授权服务器来验证访问令牌。
- en: After successful validation of the access token, the Twitter resource server
    provides the requested resources to Quora (OAuth client).
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在成功验证访问令牌后，Twitter资源服务器向Quora（OAuth客户端）提供所请求的资源。
- en: Quora uses these resources and displays the Quora profile page of the end user.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Quora使用这些资源并显示最终用户的Quora资料页面。
- en: '**Authorization code requests and responses**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**授权码请求和响应**'
- en: 'If you look at all of the steps (a total of 13) of the authorization code flow,
    as shown in the following figure, you can see that there are a total of two requests
    made by the client to the authorization server, and the authorization server provides
    two responses: one request-response for the authentication token and one request-response
    for the access token.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看全部的13个步骤（如下图中所示）的授权码授予流程，你可以看到客户端总共向授权服务器发起了两请求，授权服务器提供两个响应：一个用于认证令牌的请求-响应和一个用于访问令牌的请求-响应。
- en: 'Let''s discuss the parameters used for each of these requests and responses:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下这些请求和响应中使用的参数：
- en: '![](img/1f9ef543-affa-4dc3-b2d0-a753398f89bc.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1f9ef543-affa-4dc3-b2d0-a753398f89bc.jpg)'
- en: OAuth 2.0 authorization code grant flow
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0授权码授予流程
- en: 'The authorization request (step four) to the authorization endpoint URI:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 授权请求（第四步）到授权端点URI：
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **必需**/**可选** | **描述** |'
- en: '| `response_type` | Required | Code (this value must be used). |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `response_type` | 必需 | 代码（必须使用此值）。 |'
- en: '| `client_id` | Required | It represents the ID issued by the authorization
    server to the client at the time of registration. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `client_id` | 必需 | 它代表授权服务器在注册时颁发的客户端ID。 |'
- en: '| `redirect_uri` | Optional | It represents the redirect URI given by the client
    at the time of registration. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `redirect_uri` | 可选 | 它代表客户端在注册时提供的重定向URI。 |'
- en: '| `scope` | Optional | The scope of the request. If not provided, then the
    authorization server provides the scope based on the defined policy. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `scope` | 可选 | 请求的范围。如果没有提供，则授权服务器根据定义的策略提供范围。 |'
- en: '| `state` | Recommended | The client uses this parameter to maintain the client
    state between the requests and callback (from the authorization server). The specification
    recommends it to protect against cross-site request forgery attacks. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `state` | 推荐 | 客户端使用此参数在请求和回调（从授权服务器）之间保持客户端状态。规范推荐此参数以防止跨站请求伪造攻击。 |'
- en: 'Authorization response (step five):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 授权响应（第五步）：
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '`Parameter` | 必填/可选 | 描述 |'
- en: '| `code` | Required | Code (authorization code) generated by the authorization
    server.Code should be expired after it is generated; the maximum recommended lifetime
    is 10 minutes.The client must not use the code more than once.If the client uses
    it more than once, then the request must be denied and all previous tokens issued
    based on the code should be revoked.Code is bound to the client ID and redirect
    URI. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '`code` | 必填 | 授权服务器生成的授权码。授权码应在生成后过期；最大推荐生存期为 10 分钟。客户端不得使用代码超过一次。如果客户端使用它超过一次，则必须拒绝请求，并撤销基于代码发行的所有先前令牌。代码与客户端
    ID 和重定向 URI 绑定。 |'
- en: '| `state` | Required | It represents the ID issued by the authorization server
    to the client at the time of registration. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '`state` | 必填 | 代表授权服务器在注册时颁发给客户端的 ID。 |'
- en: 'Token request (step seven) to token endpoint URI:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌请求（第七步）至令牌端点URI： |
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '`Parameter` | 必填/可选 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '`---` | --- | --- |'
- en: '| `grant_type` | Required | `authorization_code` (this value must be used).
    |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '`grant_type` | 必填 | 授权码（此值必须使用）。 |'
- en: '| `code` | Required | Code (authorization code) received from the authorization
    server. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '`code` | 必填 | 从授权服务器接收的授权码。 |'
- en: '| `redirect_uri` | Required | Required if it was included in the authorization
    code request and the values should match. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '`redirect_uri` | 必填 | 如果包含在授权码请求中，则必须匹配。 |'
- en: '| `client_id` | Required | It represents the ID issued by the authorization
    server to the client at the time of registration. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '`client_id` | 必填 | 代表授权服务器在注册时颁发给客户端的 ID。 |'
- en: 'Token response (step 8):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌响应（第八步）： |
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '`Parameter` | 必填/可选 | 描述 |'
- en: '| `access_token` | Required | The access token issued by the authorization
    server. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '`access_token` | 必填 | 授权服务器颁发的访问令牌。 |'
- en: '| `token_type` | Required | The token type defined by the authorization server.
    Based on this, the client can utilize the access token. For example, Bearer or
    Mac. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '`token_type` | 必填 | 授权服务器定义的令牌类型。根据此，客户端可以使用访问令牌。例如，Bearer 或 Mac。 |'
- en: '| `refresh_token` | Optional | This token can be used by the client to get
    a new access token using the same authorization grant. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '`refresh_token` | 可选 | 客户端可以使用此令牌使用相同的授权授予获取新的访问令牌。 |'
- en: '| `expires_in` | Recommended | Denotes the lifetime of the access token in
    seconds. A value of 600 denotes 10 minutes of lifetime for the access token. If
    this parameter is not provided in the response, then the document should highlight
    the lifetime of the access token. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '`expires_in` | 推荐 | 表示访问令牌的生存期，以秒为单位。600 的值表示访问令牌的 10 分钟生存期。如果此参数未包含在响应中，则文档应突出显示访问令牌的生存期。
    |'
- en: '| `scope` | Optional/Required | Optional if identical to the scope requested
    by the client.Required if the access token scope is different from the one the
    client provided in their request to inform the client about the actual scope of
    the access token granted.If the client does not provide the scope while requesting
    the access token, then the authorization server should provide the default scope,
    or deny the request, indicating the invalid scope. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '`scope` | 可选/必填 | 如果与客户端请求的 scope 相同，则为可选。如果访问令牌的 scope 与客户端在其请求中提供的 scope
    不同，则为必填，以通知客户端实际授予的访问令牌的 scope。如果客户端在请求访问令牌时未提供 scope，则授权服务器应提供默认 scope，或拒绝请求，指示无效
    scope。 |'
- en: 'Error response:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 错误响应： |
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '`Parameter` | 必填/可选 | 描述 |'
- en: '| `error` | Required | One of the error codes defined in the specification,
    for example, `unauthorized_client` or `invalid_scope`. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '`error` | 必填 | 指定中的错误代码之一，例如 `unauthorized_client` 或 `invalid_scope`。 |'
- en: '| `error_description` | Optional | Short description of the error. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '`error_description` | 可选 | 错误简短描述。 |'
- en: '| `error_uri` | Optional | The URI of the error page describing the error.
    |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '`error_uri` | 可选 | 描述错误的页面 URI。 |'
- en: An additional error parameter state is also sent in the error response if the
    state was passed in the client authorization request.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端授权请求中传递了状态，则在错误响应中也发送一个附加的错误参数状态。 |
- en: Implicit grant
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式授权 |
- en: 'There are no authorization code steps involved in the implicit grant flow.
    It provides the implicit grant for authorization code. Except the authorization
    code step, everything is the same if you compare the implicit grant flow against the
    authorization code grant flow. Therefore, it is called implicit grant. Let''s
    find out its flow:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式许可流中不涉及授权码步骤。它提供隐式授权码。如果你比较隐式许可流与授权码许可流，除了授权码步骤，一切都是一样的。因此，它被称为隐式许可。让我们找出它的流程：
- en: The client application (for example, Quora) sends the access token request to
    the resource server (for example, Facebook, Twitter, and so on) with the client
    ID, redirect URI, and so on.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端应用程序（例如，Quora）将访问令牌请求发送给资源服务器（例如，Facebook、Twitter等），附带客户端ID、重定向URI等。
- en: The user may need to authenticate if not already authenticated. On successful
    authentication and other input validation, the resource server sends the access
    token.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户尚未认证，可能需要进行认证。在成功认证和其他输入验证后，资源服务器发送访问令牌。
- en: The OAuth client requests the user's (resource owner) resources (for example,
    Twitter profile photo, and so on) from the resource server and sends the access
    token received in the previous step.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OAuth客户端请求用户（资源所有者）的资源（例如，Twitter个人资料照片等）从资源服务器，并发送在上一步收到的访问令牌。
- en: The resource server verifies the access token using the authorization server.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资源服务器使用授权服务器来验证访问令牌。
- en: After successful validation of the access token, the resource server provides
    the requested resources to the client application (OAuth client).
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在成功验证访问令牌后，资源服务器将请求的资源提供给客户端应用程序（OAuth客户端）。
- en: The client application uses these resources.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端应用程序使用这些资源。
- en: '**Implicit grant requests and responses**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**隐式许可请求和响应**'
- en: 'If you looked at all of the steps (a total of six) of the implicit grant flow,
    you can see that there are a total of two requests made by the client to the authorization
    server, and the authorization server provides two responses: one request-response
    for the access token and one request-response for the access token validation.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看了隐式许可流的所有步骤（总共六个），你可以看到客户端向授权服务器发出了总共两个请求，授权服务器提供两个响应：一个用于访问令牌的请求-响应和一个用于访问令牌验证的请求-响应。
- en: Let's discuss the parameters used for each of these requests and responses.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论这些请求和响应中使用的参数。
- en: 'Authorization request to the authorization endpoint URI:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 向授权端点URI的授权请求：
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '`**参数**` | `**必需**/**可选**` | `**描述**` |'
- en: '| `response_type` | Required | Token (this value must be used). |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '`response_type` | 必需 | 令牌（必须使用此值）。 |'
- en: '| `client_id` | Required | It represents the ID issued by the authorization
    server to the client at the time of registration. |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '`client_id` | 必需 | 它代表授权服务器在注册时发给客户端的ID。 |'
- en: '| `redirect_uri` | Optional | It represents the redirect URI given by the client
    at the time of registration. |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '`redirect_uri` | 可选 | 它代表客户端在注册时提供的重定向URI。 |'
- en: '| `scope` | Optional | The scope of the request. If not provided, then the
    authorization server provides the scope based on the defined policy. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '`scope` | 可选 | 请求的范围。如果没有提供，则授权服务器根据定义的策略提供范围。 |'
- en: '| `state` | Recommended | The client uses this parameter to maintain the client
    state between the requests and the callback (from the authorization server). The
    specification recommends it to protect against cross-site request forgery attacks.
    |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '`state` | 推荐 | 客户端使用此参数在请求和回调（从授权服务器）之间维护客户端状态。规范建议使用它以防止跨站请求伪造攻击。 |'
- en: 'Access token response:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 访问令牌响应：
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '`**参数**` | `**必需**/**可选**` | `**描述**` |'
- en: '| --- | --- | --- |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '`---` | `---` | `---` |'
- en: '| `access_token` | Required | The access token issued by the authorization
    server. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '`access_token` | 必需 | 授权服务器发行的访问令牌。 |'
- en: '| `token_type` | Required | The token type defined by the authorization server.
    Based on this, the client can utilize the access token. For example, Bearer or
    Mac. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '`token_type` | 必需 | 授权服务器定义的令牌类型。根据此类型，客户端可以利用访问令牌。例如，Bearer或Mac。 |'
- en: '| `refresh_token` | Optional | This token can be used by the client to get
    a new access token using the same authorization grant. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '`refresh_token` | 可选 | 客户端可以使用该令牌来使用相同的授权许可获取新的访问令牌。 |'
- en: '| `expires_in` | Recommended | Denotes the lifetime of the access token in
    seconds. A value of 600 denotes 10 minutes of lifetime for the access token. If
    this parameter is not provided in the response, then the document should highlight
    the lifetime of the access token. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `expires_in` | 推荐 | 表示访问令牌的生存期，以秒为单位。600 的值表示访问令牌的 10 分钟生存期。如果这个参数在响应中没有提供，那么文档应该强调访问令牌的生存期。
    |'
- en: '| `scope` | Optional/Required | Optional if identical to the scope requested
    by the client.Required if the access token scope is different from the one the
    client provided in the request to inform the client about the actual scope of
    the access token granted.If the client does not provide the scope while requesting
    the access token, then the authorization server should provide the default scope,
    or deny the request, indicating the invalid scope. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `scope` | 可选/必填 | 如果与客户端请求的 scope 相同，则为可选。如果授予的访问令牌 scope 与客户端在请求中提供的 scope
    不同，则为必填，以通知客户端授予的访问令牌的实际 scope。如果客户端在请求访问令牌时没有提供 scope，则授权服务器应提供默认 scope，或拒绝请求，指示无效
    scope。 |'
- en: '| `state` | Optional/Requried | Required if the state was passed in the client
    authorization request. |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `state` | 可选/必填 | 如果客户端授权请求中传递了状态，则为必填。 |'
- en: 'Error response:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 错误响应：
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **必填**/**可选** | **描述** |'
- en: '| `error` | Required | One of the error codes defined in the specification,
    for example, `unauthorized_client` or `invalid_scope`. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `error` | 必填 | 定义在规范中的错误代码之一，例如 `unauthorized_client` 或 `invalid_scope`。
    |'
- en: '| `error_description` | Optional | Short description of the error. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `error_description` | 可选 | 错误的精简描述。 |'
- en: '| `error_uri` | Optional | The URI of the error page describing the error.
    |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `error_uri` | 可选 | 描述错误的错误页面的 URI。 |'
- en: An additional error parameter state is also sent in the error response if the
    state was passed in the client authorization request.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在错误响应中还发送了一个额外的状态参数，如果客户端授权请求中传递了状态。
- en: Resource owner password credentials grant
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源所有者密码凭证授权
- en: 'This flow is normally used on mobile or desktops applications. In this grant
    flow, only two requests are made: one for requesting an access token and another
    for access token verification, similar to implicit grant flow. The only difference
    is the resource owner''s username and password are sent along with the access
    token request. (In implicit grant, which is normally on a browser, redirects the
    user to authenticate itself.) Let''s find out its flow:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这种流程通常用于移动或桌面应用程序。在这个授权流程中，只发起两个请求：一个用于请求访问令牌，另一个用于访问令牌验证，类似于隐式授权流程。唯一的区别是访问令牌请求中附带了资源所有者的用户名和密码。（在隐式授权中，通常在浏览器中，将用户重定向到认证页面。）让我们来看看它的流程：
- en: The client application (for example, Quora) sends the access token request to
    the resource server (for example, Facebook, Twitter, and so on) with client ID,
    resource owner's username and password, and so on. On successful parameter validation,
    the resource server sends the access token.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端应用程序（例如，Quora）将访问令牌请求发送到资源服务器（例如，Facebook、Twitter等），其中包括客户端ID、资源所有者的用户名和密码等。在成功验证参数后，资源服务器发送访问令牌。
- en: The OAuth client requests the user's (resource owner) resources (for example,
    Twitter profile photo, and so on) from the resource server and sends the access
    token received in the previous step.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OAuth 客户端请求资源服务器上的用户（资源所有者）的资源（例如，Twitter 个人资料照片等），并发送在上一步收到的访问令牌。
- en: The resource server verifies the access token using the authorization server.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资源服务器使用授权服务器验证访问令牌。
- en: After successful validation of the access token, the resource server provides
    the requested resources to the client application (OAuth client).
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在成功验证访问令牌后，资源服务器向客户端应用程序（OAuth 客户端）提供所请求的资源。
- en: The client application uses these resources.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端应用程序使用这些资源。
- en: The resource owner's password credentials grant requests and responses.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 资源所有者的密码凭证用于授权请求和响应。
- en: 'As seen in the previous section, in all of the steps (a total of five) of the
    resource owner password credential grant flow, you can see that there are a total
    of two requests made by the client to the authorization server, and the authorization
    server provides two responses: one request-response for the access token and one
    request-response for resource owner resources.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在资源所有者密码凭据授予流程的所有步骤（共五个步骤）中，您可以看到客户端向授权服务器发出了两个请求，并且授权服务器提供了两个响应：一个用于访问令牌的请求-响应，一个用于资源所有者资源的请求-响应。
- en: Let's discuss the parameters used for each of these requests and responses.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论每个请求和响应中使用的参数。
- en: 'Access token request to the token endpoint URI:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 访问令牌请求到令牌端点URI：
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **必需**/**可选** | **描述** |'
- en: '| `grant_type` | Required | Password (this value must be used). |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `grant_type` | 必需 | 密码（必须使用此值）。 |'
- en: '| `username` | Required | Username of the resource owner. |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `username` | 必需 | 资源所有者的用户名。 |'
- en: '| `password` | Required | Password of the resource owner. |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `password` | 必需 | 资源所有者的密码。 |'
- en: '| `scope` | Optional | The scope of the request. If not provided, then the
    authorization server provides the scope based on the defined policy. |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `scope` | 可选 | 请求的范围。如果未提供，则授权服务器根据定义的策略提供范围。 |'
- en: 'Access token response (step one):'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 访问令牌响应（第一步）：
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **必需**/**可选** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `access_token` | Required | The access token issued by the authorization
    server. |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `access_token` | 必需 | 授权服务器颁发的访问令牌。 |'
- en: '| `token_type` | Required | The token type defined by the authorization server.
    Based on this, the client can utilize the access token. For example, Bearer or
    Mac. |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `token_type` | 必需 | 授权服务器定义的令牌类型。基于此，客户端可以利用访问令牌。例如，Bearer或Mac。 |'
- en: '| `refresh_token` | Optional | This token can be used by the client to get
    a new access token using the same authorization grant. |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `refresh_token` | 可选 | 客户端可以使用此令牌使用相同的授权授予获取新的访问令牌。 |'
- en: '| `expires_in` | Recommended | Denotes the lifetime of the access token in
    seconds. A value of 600 denotes 10 minutes of lifetime for the access token. If
    this parameter is not provided in the response, then the document should highlight
    the lifetime of the access token. |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `expires_in` | 建议 | 以秒为单位表示访问令牌的生命周期。600的值表示访问令牌的生命周期为10分钟。如果响应中未提供此参数，则文档应突出显示访问令牌的生命周期。
    |'
- en: '| Optional parameter | Optional | Additional parameter. |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| 可选参数 | 可选 | 额外参数。 |'
- en: Client credentials grant
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端凭据授予
- en: 'As the name suggests, here, the client''s credentials are used instead of the
    user''s (resource owner''s). Except client credentials, it is very similar to
    the resource owner password credentials grant flow:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，在这里，使用客户端凭据而不是用户（资源所有者）的凭据。除了客户端凭据，它与资源所有者密码凭据授予流程非常相似：
- en: The client application (for example, Quora) sends the access token request to
    the resource server (for example, Facebook, Twitter, and so one) with the grant
    type and scope. The client ID and secrets are added to the authorization header.
    On successful validation, the resource server sends the access token.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端应用程序（例如Quora）使用授予类型和范围将访问令牌请求发送到资源服务器（例如Facebook、Twitter等）。客户端ID和密码添加到授权标头。验证成功后，资源服务器发送访问令牌。
- en: The OAuth client requests the user's (resource owner) resources (for example,
    Twitter profile photo, and so on) from the resource server and sends the access
    token received in the previous step.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OAuth客户端从资源服务器请求用户（资源所有者）的资源（例如Twitter个人资料照片等），并发送上一步收到的访问令牌。
- en: The resource server verifies the access token using the authorization server.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资源服务器使用授权服务器验证访问令牌。
- en: After successful validation of the access token, the resource server provides
    the requested resources to the client application (OAuth client).
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证访问令牌成功后，资源服务器将所请求的资源提供给客户端应用程序（OAuth客户端）。
- en: The client application uses these resources.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端应用程序使用这些资源。
- en: Client credentials grant requests and responses.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端凭据授予请求和响应。
- en: If you looked at all of the steps (a total of five) of the client credentials
    grant flow, you can
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看了客户端凭据授予流程的所有步骤（共五个步骤），您可以
- en: 'see that there are a total of two requests made by the client to the authorization
    server, and the authorization server provides two responses: one request-response
    for the access token and one request-response for the resource that involves access
    token verification.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到客户端总共向授权服务器发出了两个请求，授权服务器提供了两个响应：一个请求-响应用于访问令牌和一个请求-响应用于涉及访问令牌验证的资源。
- en: Let's discuss the parameters used for each of these requests and responses.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下每个这些请求和响应中使用的参数。
- en: 'Access token request to the token endpoint URI:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 访问令牌请求到令牌端点的URI：
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '`Parameter` | `Required`/**optional** | `Description` |'
- en: '| `grant_type` | Required | `client_credentials` (this value must be used).
    |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '`grant_type` | 必需 | `client_credentials`（必须使用此值）。 |'
- en: '| `scope` | Optional | The scope of the request. If not provided, then the
    authorization server provides the scope based on the defined policy. |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '`scope` | 可选 | 请求的范围。如果没有提供，则授权服务器根据定义的策略提供范围。 |'
- en: 'Access token response:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 访问令牌响应：
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '`Parameter` | `Required`/**optional** | `Description` |'
- en: '| `access_token` | Required | The access token issued by the authorization
    server. |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '`access_token` | 必需 | 授权服务器颁发的访问令牌。 |'
- en: '| `token_type` | Required | The token type defined by the authorization server.
    Based on this, the client can utilize the access token. For example, Bearer or
    Mac. |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '`token_type` | 必需 | 授权服务器定义的令牌类型。根据此，客户端可以利用访问令牌。例如，Bearer或Mac。 |'
- en: '| `expires_in` | Recommended | Denotes the lifetime of the access token in
    seconds. A value of 600 denotes 10 minutes of lifetime for the access token. If
    this parameter is not provided in the response, then the document should highlight
    the lifetime of the access token. |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '`expires_in` | 推荐 | 表示访问令牌的生存期，以秒为单位。600的值表示访问令牌的10分钟生存期。如果没有在响应中提供此参数，则文档应突出显示访问令牌的生存期。
    |'
- en: OAuth implementation using Spring Security
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth使用Spring Security实现
- en: OAuth 2.0 is a way of securing APIs. Spring Security provides Spring Cloud Security
    and Spring Cloud OAuth2 components for implementing the grant flows we discussed
    earlier.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0是一种保护API的方法。Spring Security提供了Spring Cloud Security和Spring Cloud OAuth2组件来实现我们之前讨论的授权流。
- en: We'll create one more service, a security-service, which will control authentication
    and authorization.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再创建一个服务，一个安全服务，它将控制认证和授权。
- en: 'Create a new Maven project and follow these steps:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的Maven项目，并按照以下步骤操作：
- en: 'Add the Spring Security and Spring Security OAuth 2 dependencies in `pom.xml`:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`pom.xml`中添加Spring Security和Spring Security OAuth 2依赖项：
- en: '[PRE3]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Use the `@EnableResourceServer` annotation in your application class. This
    will allow this application to work as a resource server. The `@EnableAuthorizationServer`
    annotation is another annotation we will use to enable the authorization server
    as per OAuth 2.0 specifications:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的应用程序类中使用`@EnableResourceServer`注解。这将允许此应用程序作为资源服务器运行。`@EnableAuthorizationServer`注解是我们将使用以根据OAuth
    2.0规范启用授权服务器的另一个注解：
- en: '[PRE4]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Update the security-service configuration in `application.yml`, as shown in
    the following code:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`application.yml`中的安全服务配置，如下代码所示：
- en: '`server.contextPath`: This denotes the context path'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`server.contextPath`：这表示上下文路径'
- en: '`security.user.password`: We''ll use the hardcoded password for this demonstration.
    You can reconfigure it for real use:'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`security.user.password`: 本示例将使用硬编码的密码。您可以为其真实应用重新配置：'
- en: '[PRE5]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we have our security server in place, we'll expose our APIs using the
    new `api-service` microservice, which will be used for communicating with external
    applications and UIs.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了我们的安全服务器，我们将使用新的`api-service`微服务暴露我们的API，该服务将用于与外部应用程序和UI通信。
- en: 'We''ll modify the Zuul-Server module to make it a resource server also. This
    can be done by following these steps:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改Zuul-Server模块，使其也成为资源服务器。这可以通过以下步骤完成：
- en: Add the Spring Security and Spring Security OAuth 2 dependencies
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加Spring Security和Spring Security OAuth 2依赖项：
- en: 'to `pom.xml`. Here, the last two dependencies are required for enabling the
    Zuul-Server as a resource server:'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到`pom.xml`。在此，最后两个依赖项是启用Zuul-Server作为资源服务器所需的：
- en: '[PRE6]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Use the `@EnableResourceServer` annotation in your application class. This
    will allow this application to work as a resource server:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的应用程序类中使用`@EnableResourceServer`注解。这将允许此应用程序作为资源服务器运行：
- en: '[PRE7]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Update the Zuul-Server configuration in `application.yml`, as shown in the
    following code. The `application.yml` file will look something like this:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`Zuul-Server`配置文件中的`application.yml`，如下所示的代码。`application.yml`文件看起来可能会像这样：
- en: '[PRE8]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, the `security.oauth2.resource.userInfoUri` property denotes the security
    service user URI. APIs are exposed to the external world using route configuration
    that points to API services.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`security.oauth2.resource.userInfoUri`属性表示安全服务用户URI。API通过指向API服务的路由配置暴露给外部世界。
- en: Now that we have our security server in place, we are exposing our APIs using
    the `api-service` microservice, which will be used for communicating with external
    applications and UIs.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了安全服务器，我们通过`api-service`微服务暴露我们的API，该服务将用于与外部应用程序和UI通信。
- en: Now, let's test and explore how it works for different OAuth 2.0 grant types.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试并探索不同OAuth 2.0授予类型的运作方式。
- en: We'll make use of the Postman extension to the Chrome browser to test the different
    flows.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Postman浏览器扩展来测试不同的流程。
- en: Authorization code grant
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权码授予
- en: 'We will enter the following URL in our browser. A request for an authorization
    code is as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在浏览器中输入以下URL。请求授权码如下：
- en: '[PRE9]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we provide the client ID (by default, we have the hardcoded client registered
    in our security service), redirect URI, scope (hardcoded `apiAccess` value in
    security service), and state. You must be wondering about the `state` parameter.
    It contains the random number that we revalidate in response to prevent cross-site
    request forgery.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们提供客户端ID（默认情况下，我们在安全服务中注册了硬编码的客户端）、重定向URI、范围（在安全服务中硬编码的`apiAccess`值）和状态。您可能会想知道`state`参数。它包含了一个我们在响应中重新验证的随机数，以防止跨站请求伪造。
- en: If the resource owner (user) is not already authenticated, it will ask for the
    username and password. Provide the username as `username` and the password as
    `password`; we have hardcoded these values in the security service.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果资源所有者（用户）尚未经过身份验证，它会要求输入用户名和密码。输入用户名`username`和密码`password`；我们在安全服务中硬编码了这些值。
- en: 'Once the login is successful, it will ask you to provide your (resource owner)
    approval:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 登录成功后，它会要求您提供您的（资源所有者）批准：
- en: '![](img/c1420332-d7fe-4fdb-8283-dda0ddcce291.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1420332-d7fe-4fdb-8283-dda0ddcce291.png)'
- en: OAuth 2.0 authorization code grant - resource grant approval
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0授权码授予 - 资源授予批准
- en: Select Approve and click on Authorize. This action will redirect the application
    to `http://localhost:7771/1?code=o8t4fi&state=1234`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 选择批准并点击授权。这个操作会将应用程序重定向到`http://localhost:7771/1?code=o8t4fi&state=1234`。
- en: As you can see, it has returned the authorization code and state.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，它返回了授权代码和状态。
- en: 'Now, we''ll use this code to retrieve the access code, using the Postman Chrome
    extension. First, we''ll add the authorization header using Username as client
    and Password as `clientsecret`, as shown in the following screenshot:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用这个代码来检索访问代码，使用Postman Chrome扩展。首先，我们将使用用户名作为客户端，密码作为`clientsecret`来添加授权头，如下所示的屏幕截图：
- en: '![](img/78666832-c5a5-4bc3-add2-f7288380f37c.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](img/78666832-c5a5-4bc3-add2-f7288380f37c.png)'
- en: OAuth 2.0 authorization code grant - access token request - adding the authentication
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0授权码授予 - 访问令牌请求 - 添加身份验证
- en: This will add the Authorization header to the request with the value `Basic
    Y2xpZW50OmNsaWVudHNlY3JldA==`, which is a base-64 encoding of the 'client client-secret'.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将`Authorization`头添加到请求中，值为`Basic Y2xpZW50OmNsaWVudHNlY3JldA==`，这是'client client-secret'的base-64编码。
- en: 'Now, we''ll add a few other parameters to the request, as shown in the following
    screenshot, and then submit the request:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将向请求中添加几个其他参数，如下的屏幕截图，然后提交请求：
- en: '![](img/f80b3537-1b8e-4e59-8993-ca06c5b9197a.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f80b3537-1b8e-4e59-8993-ca06c5b9197a.png)'
- en: OAuth 2.0 authorization code grant - access token request and response
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0授权码授予 - 访问令牌请求和响应
- en: 'This returns the following response, as per the OAuth 2.0 specification:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 根据OAuth 2.0规范，这会返回以下响应：
- en: '[PRE10]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, we can use this information to access the resources owned by the resource
    owner. For example, if `https://localhost:8765/api/restaurant/1` represents the
    restaurant with the ID of `1`, then it should return the respective restaurant
    details.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用这些信息来访问资源拥有者的资源。例如，如果`https://localhost:8765/api/restaurant/1`代表ID为`1`的餐厅，那么它应该返回相应的餐厅详情。
- en: Without the access token, if we enter the URL, it returns the error `Unauthorized`
    with the message `Full authentication is required to access this resource`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 没有访问令牌，如果我们输入URL，它会返回错误`Unauthorized`，消息为`Full authentication is required to
    access this resource`。
- en: 'Now, let''s access this URL with the access token, as shown in the following
    screenshot:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用访问令牌访问这个网址，如下面的截图所示：
- en: '![](img/7ad7dda0-294b-4576-a9b4-832beb4312e8.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7ad7dda0-294b-4576-a9b4-832beb4312e8.png)'
- en: OAuth 2.0 authorization code grant - using the access token for API access
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0 授权码授权 - 使用访问令牌访问 API
- en: As you can see, we have added the Authorization header with the access token.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们添加了带有访问令牌的授权头。
- en: Now, we will explore implicit grant implementation.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探讨隐式授权实现的实现。
- en: Implicit grant
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式授权
- en: Implicit grants are very similar to authorization code grants, except for the
    code grant step. If you remove the first step—the code grant step (where the client
    application receives the authorization token from the authorization server)—from
    the authorization code grant, the rest of the steps are the same. Let's check
    it out.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式授权与授权码授权非常相似，除了授权码步骤之外。如果您移除授权码授权的第一个步骤（客户端应用程序从授权服务器接收授权令牌的步骤），其余步骤都相同。让我们来查看一下。
- en: 'Enter the following URL and parameters in the browser and press Enter. Also,
    make sure to add basic authentication, with the client as `username` and the password
    as `password` if asked:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中输入以下URL和参数并按Enter。同时，请确保如果需要，添加基本认证，将客户端作为`username`，将密码作为`password`：
- en: '[PRE11]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we are calling the authorization endpoint with the following request
    parameters: response type, client ID, redirect URI, scope, and state.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用以下请求参数调用授权端点：响应类型、客户端 ID、重定向 URI、范围和状态。
- en: 'When the request is successful, the browser will be redirected to the following
    URL with new request parameters and values:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求成功时，浏览器将被重定向到以下URL，带有新的请求参数和值：
- en: '[PRE12]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we receive the `access_token`, `token_type`, state, and expiry duration
    for the token. Now, we can make use of this access token to access the APIs, as
    used in the authorization code grant.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们接收到`access_token`、`token_type`、状态和令牌的过期持续时间。现在，我们可以利用这个访问令牌来访问API，就像在授权码授权中使用一样。
- en: Resource owner password credential grant
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源所有者密码凭据授权
- en: In this grant, we provide `username` and `password` as parameters when requesting
    the access token, along with the `grant_type`, `client`, and `scope` parameters.
    We also need to use the client ID and secret to authenticate the request. These
    grant flows use client applications in place of browsers, and are normally used
    in mobile and desktop applications.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个授权中，我们请求访问令牌时提供`username`和`password`作为参数，以及`grant_type`、`client`和`scope`参数。我们还需要使用客户端ID和密钥来验证请求。这些授权流程使用客户端应用程序代替浏览器，通常用于移动和桌面应用程序。
- en: 'In the following Postman tool screenshot, the authorization header has already
    been added using basic authentication with `client_id` and `password`:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的Postman工具截图中，已使用`client_id`和`password`进行基本认证，并添加了授权头：
- en: '![](img/72fb8839-d705-47f9-84ea-8890276bfc61.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72fb8839-d705-47f9-84ea-8890276bfc61.png)'
- en: OAuth 2.0 resource owner password credentials grant - access token request and
    response
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0 资源所有者密码凭据授权 - 访问令牌请求和响应
- en: Once the access token is received by the client, it can be used in a similar
    way to how it is used in the authorization code grant.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦客户端接收到访问令牌，它可以用类似的方式使用，就像在授权码授权中使用一样。
- en: Client credentials grant
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端凭据授权
- en: In this flow, the client provides their own credentials and retrieves the access
    token. It does not use the resource owner's credentials and permissions.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个流程中，客户端提供自己的凭据以获取访问令牌。它不使用资源所有者的凭据和权限。
- en: 'As you can see in the following screenshot, we directly enter the token endpoint
    with only two parameters: `grant_type` and `scope`. The authorization header is
    added using `client_id` and `client secret`:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在下面的截图中看到的，我们直接输入只有两个参数的令牌端点：`grant_type`和`scope`。授权头使用`client_id`和`client
    secret`添加：
- en: '![](img/972a2e60-28b1-423a-adde-38c2fa61afc2.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![](img/972a2e60-28b1-423a-adde-38c2fa61afc2.png)'
- en: OAuth 2.0 client credentials grant - access token request and response
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0 客户端凭据授权 - 访问令牌请求和响应
- en: You can use the access token similarly as it is explained for the authorization
    code grant.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像授权码授权中解释的那样使用访问令牌。
- en: References
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'For more information, you can refer to these links:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，您可以参考以下链接：
- en: '*RESTful Java Web Services Security*, *René Enríquez, Andrés Salazar C*, *Packt
    Publishing*: [https://www.packtpub.com/application-development/restful-java-web-services-security](https://www.packtpub.com/application-development/restful-java-web-services-security)'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '《RESTful Java Web Services Security》，*René Enríquez, Andrés Salazar C*，*Packt
    Publishing*: [https://www.packtpub.com/application-development/restful-java-web-services-security](https://www.packtpub.com/application-development/restful-java-web-services-security)'
- en: '*Spring Security [Video]*, *Packt Publishing*: [https://www.packtpub.com/application-development/spring-security-video](https://www.packtpub.com/application-development/spring-security-video)'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '《Spring Security [Video]》，*Packt Publishing*: [https://www.packtpub.com/application-development/spring-security-video](https://www.packtpub.com/application-development/spring-security-video)'
- en: 'The OAuth 2.0 Authorization Framework: [https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749)'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth 2.0授权框架：[https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749)
- en: 'Spring Security: [http://projects.spring.io/spring-security](http://projects.spring.io/spring-security)'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '春安全: [http://projects.spring.io/spring-security](http://projects.spring.io/spring-security)'
- en: 'Spring OAuth2: [http://projects.spring.io/spring-security-oauth/](http://projects.spring.io/spring-security-oauth/)'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '春auth2: [http://projects.spring.io/spring-security-oauth/](http://projects.spring.io/spring-security-oauth/)'
- en: Summary
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how important it is to have the TLS layer or
    HTTPS in place for all web traffic. We have added a self-signed certificate to
    our sample application. I would like to reiterate that, for a production application,
    you must use the certificates offered by certificate-signing authorities. We have
    also explored the fundamentals of OAuth 2.0 and various OAuth 2.0 grant flows.
    Different OAuth 2.0 grant flows are implemented using Spring Security and OAuth
    2.0\. In the next chapter, we'll implement the UI for the sample OTRS project
    and explore how all of the components work together.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到拥有TLS层或HTTPS对所有网络流量的重要性。我们已经向示例应用程序添加了自签名的证书。我想再次强调，对于生产应用程序，您必须使用证书授权机构提供的证书。我们还探讨了OAuth
    2.0的基本原理和各种OAuth 2.0授权流。不同的OAuth 2.0授权流是使用Spring Security和OAuth 2.0实现的。在下一章中，我们将实现示例OTRS项目的UI，并探讨所有组件是如何一起工作的。
