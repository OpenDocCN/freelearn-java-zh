- en: Reactive Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式模式
- en: In this chapter, we are going to explore the concepts and implementations of
    reactive patterns, looking at how we can use them to implement a better application.
    We will also cover reactive programming concepts, focusing on how they can aid
    application development. After reading this chapter, we will be able to use reactive
    patterns using the best practices of Java EE 8.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章中，我们将探讨响应式模式的概念和实现，探讨我们如何使用它们来实现更好的应用程序。我们还将涵盖响应式编程概念，重点关注它们如何有助于应用程序开发。阅读本章后，我们将能够使用响应式模式，并采用Java
    EE 8的最佳实践。 '
- en: 'The following topics will be explored in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨以下主题：
- en: Explaining the concept of reactive programming
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释响应式编程的概念
- en: Explaining the concept of an event in CDI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释CDI中事件的概念
- en: Implementing an event in CDI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CDI中实现事件
- en: Explaining the concept of an asynchronous EJB method
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释异步EJB方法的概念
- en: Implementing an asynchronous EJB method
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现异步EJB方法
- en: Explaining the concept of an asynchronous REST service
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释异步REST服务的概念
- en: Implementing an asynchronous REST service
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现异步REST服务
- en: For a long time, applications processed all requests in a synchronous manner.
    In a synchronous process, the users request a resource and wait for its response.
    When this type of process begins, each step is executed right after the previous
    one.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 很长时间以来，应用程序都以同步方式处理所有请求。在同步过程中，用户请求资源并等待其响应。当此类过程开始时，每个步骤都紧随前一个步骤之后执行。
- en: 'In the following diagram, we can see the process of the workflow when it is
    executed in a synchronous manner:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，我们可以看到在同步方式下执行的工作流程过程：
- en: '![](img/a6530aad-ab8b-4374-8128-de18020ab36d.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a6530aad-ab8b-4374-8128-de18020ab36d.png)'
- en: In a synchronous process, each call to a function or resource works in a step-by-step,
    sequential manner. However, some tasks take longer to execute, thus blocking this
    process for a long time. An example of a task that can take a long time to execute
    is an I/O request when the application reads data from a disk or data source.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在同步过程中，对函数或资源的每次调用都以逐步、顺序的方式进行。然而，一些任务执行时间较长，从而长时间阻塞此过程。一个可能需要长时间执行的示例任务是当应用程序从磁盘或数据源读取数据时的I/O请求。
- en: With the growth of web application access, several web applications needed to
    become able to receive and process a large number of requests in order to respond
    to these requests. With this, synchronous processing began to encounter problems
    with responding to large volumes of requests and building a response to the requests
    quickly. To solve this, web applications began working through asynchronous processes,
    making it possible for the applications to build a response quickly.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Web应用程序访问量的增长，许多Web应用程序需要能够接收和处理大量请求，以响应这些请求。因此，同步处理开始遇到响应大量请求和快速构建响应的问题。为了解决这个问题，Web应用程序开始通过异步过程工作，使得应用程序能够快速构建响应。
- en: In an asynchronous process, calls to functions or resources can be carried out
    in a parallel manner without having to wait for a task to end in order to execute
    the next one. Because of this, executing an I/O request will not delay the next
    task's execution—they can proceed at the same time.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步过程中，对函数或资源的调用可以并行进行，无需等待一个任务结束即可执行下一个任务。正因为如此，执行I/O请求不会延迟下一个任务的执行——它们可以同时进行。
- en: Reactive programming is a style of programming that develops applications in
    a functional form. Here, the development occurs in an asynchronous data stream
    that is sent by a requester. Furthermore, we can have a resource that reacts with
    this data stream as the data flow is received. Each task then works as a function
    and does not handle variables outside of its scope, making it possible for this
    function to execute several times in a parallel manner without having any collateral
    effects.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程是一种以函数形式开发应用程序的编程风格。在这里，开发发生在请求者发送的异步数据流中。此外，我们可以有一个资源与数据流反应，因为数据流被接收。每个任务然后作为一个函数工作，并且不处理其作用域之外的变量，这使得该函数能够在并行方式下执行多次而不产生任何副作用。
- en: 'In reactive programming, we have elements that react to events, then when a
    user requests a resource, it starts an event that operates a data stream. When
    this event begins, an element or task reacts to the data stream and processes
    its algorithm. This makes it possible for the web application to process a large
    amount of data and scale it without difficulty. This paradigm works with the following
    four concepts:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应式编程中，我们有对事件做出反应的元素，然后当用户请求资源时，它启动一个事件来操作数据流。当这个事件开始时，一个元素或任务对数据流做出反应并处理其算法。这使得Web应用程序能够处理大量数据并轻松扩展。这个范例与以下四个概念一起工作：
- en: '**Elastic**: This reacts to demands. Applications can use multicore and multiple
    servers to process the requests.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Elastic**: 这是对需求做出反应。应用程序可以使用多核和多台服务器来处理请求。'
- en: '**Resilient**: This reacts to faults. Applications can react to and recover
    from faults and errors in software, hardware, and networks.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**: 这是对故障做出反应。应用程序可以响应并从软件、硬件和网络中的故障和错误中恢复。'
- en: '**Message-driven**: This reacts to events. Applications are composed of event
    managers that are asynchronous and nonblocking, as opposed to being composed of
    multiple synchronous threads.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息驱动**: 这是对事件做出反应。应用程序由异步和非阻塞的事件管理器组成，而不是由多个同步线程组成。'
- en: '**Responsive**: This reacts to users. Applications offer rich iterations in
    real time.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应式**: 这是对用户做出反应。应用程序提供实时丰富的迭代。'
- en: Java EE 8 has tools that permit developers to use reactive programming in their
    applications. Some of these tools are events in CDI, asynchronous EJB methods,
    and asynchronous rest services.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 8提供了工具，允许开发者在其应用程序中使用响应式编程。其中一些工具是CDI中的事件、异步EJB方法和异步REST服务。
- en: Explaining the concept of an event in CDI
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释CDI中事件的概念
- en: As reactive programming grew in the development environment, the Java language
    and Java EE needed to create tools to permit developers to develop systems using
    reactive programming. On Java EE, some solutions were introduced that made it
    possible to use the style function and to create processes asynchronously. One
    of these solutions is Event in CDI; this solution could launch a synchronous and
    blocking event, or an asynchronous and nonblocking event using CDI.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 随着响应式编程在开发环境中的增长，Java语言和Java EE需要创建工具，以允许开发者使用响应式编程来开发系统。在Java EE上，引入了一些解决方案，使得可以使用函数式风格并创建异步过程。其中之一是CDI中的事件；这个解决方案可以使用CDI启动同步和阻塞事件，或异步和非阻塞事件。
- en: In CDI, Event is a solution that Java EE built using the observer pattern, making
    it possible to develop and launch an event to separate components doing the processing,
    working as a synchronous and blocking or asynchronous and nonblocking process.
    This separate task is an observer that reacts to an event launched with its data.
    In this chapter, we will focus on asynchronous CDI, using Event in CDI to launch
    asynchronous events.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在CDI中，事件是Java EE使用观察者模式构建的解决方案，使得开发并启动一个事件成为可能，以便将处理事件的组件分离，作为一个同步和阻塞或异步和非阻塞的过程。这个分离的任务是一个观察者，它对其使用数据启动的事件做出反应。在本章中，我们将重点关注异步CDI，使用CDI中的事件来启动异步事件。
- en: Implementing an event in CDI
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现CDI中的事件
- en: 'As an example of implementing an event in CDI, we think about asynchronous
    CDI and imagine a scene in which we want to create an application that makes it
    possible to upload three types (or extensions) of file—this includes ZIP, JPG,
    and PDF extensions. Depending on the extension received at the request, it is
    intended that one event is launched and one observer will save its file on a disk
    using an asynchronous process. Each extension will have an observer, which will
    have an algorithm making it possible to save the file on a disk. To develop this
    example, we have the following classes:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 作为在CDI中实现事件的示例，我们考虑异步CDI并想象一个场景，在这个场景中我们想要创建一个应用程序，使其能够上传三种类型（或扩展名）的文件——这包括ZIP、JPG和PDF扩展名。根据接收到的请求扩展名，目的是启动一个事件，一个观察者将使用异步过程将其文件保存到磁盘上。每个扩展名都将有一个观察者，它将有一个算法使得文件能够保存到磁盘上。为了开发这个示例，我们有以下类：
- en: '`FileUploadResource`: This is a class that represents the resource that receives
    all the requests in order to upload and launches respective events according to
    the file extension.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileUploadResource`: 这是一个表示接收所有请求以上传并根据文件扩展名启动相应事件的类的资源。'
- en: '`FileEvent`: This is a bean that contains the file data and is sent to an event.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileEvent`: 这是一个包含文件数据的Bean，并将其发送到事件中。'
- en: '`FileHandler`: This is an interface of all the observers. In this example,
    all classes that react to `FileEvent` need to implement `FileHandler`.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileHandler`：这是所有观察者的接口。在这个例子中，所有对`FileEvent`做出响应的类都需要实现`FileHandler`。'
- en: '`JpgHandler`: This is an implementation of FileHandler that saves a JPG file
    on a disk. This class is an observer that reacts with `FileEvent` launched to
    a JPG file.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JpgHandler`：这是一个将JPG文件保存到磁盘上的`FileHandler`实现。这个类是一个观察者，它对启动到JPG文件的`FileEvent`做出响应。'
- en: '`PdfHandler`: This is an implementation of `FileHandler` that saves a PDF file
    on a disk. This class is an observer that reacts with `FileEvent` launched to
    a PDF file.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PdfHandler`：这是一个`FileHandler`的实现，它将PDF文件保存到磁盘上。这个类是一个观察者，它对启动到PDF文件的`FileEvent`做出响应。'
- en: '`ZipHandler`: This is an implementation of `FileHandler` that saves a ZIP file
    on a disk. This class is an observer that reacts with `FileEvent` launched to
    a ZIP file.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZipHandler`：这是一个将ZIP文件保存到磁盘上的`FileHandler`实现。这个类是一个观察者，它对启动到ZIP文件的`FileEvent`做出响应。'
- en: '`Jpg`: This is a qualifier used to establish that the `JpgHandler` observers
    need to react to an event.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Jpg`：这是一个用于建立`JpgHandler`观察者需要响应事件的限定符。'
- en: '`Pdf`: This is a qualifier used to establish that the `PdfHandler` observer
    needs to react to an event.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pdf`：这是一个用于建立`PdfHandler`观察者需要响应事件的限定符。'
- en: '`Zip`: This is a qualifier used to establish that the `ZipHandler` observer
    needs to react to an event.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Zip`：这是一个用于建立`ZipHandler`观察者需要响应事件的限定符。'
- en: '`FileSystemUtils`: This is a utility class to treat issues on a filesystem.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileSystemUtils`：这是一个用于处理文件系统问题的实用类。'
- en: Implementing the FileUploadResource class
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现FileUploadResource类
- en: '`FileUploadResource` is a resource class that uses JAX-RS to create a RESTful
    service to upload a file with JPG, PDF, and ZIP extensions. In the following code,
    we have the code of qualifiers that are used to select the correct observer to
    react to an event as well as the code for `FileUploadResource`.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileUploadResource`是一个资源类，它使用JAX-RS创建一个RESTful服务，用于上传具有JPG、PDF和ZIP扩展名的文件。在以下代码中，我们有用于选择正确观察者以响应事件的限定符代码以及`FileUploadResource`的代码：'
- en: Bean sent on the event
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件上发送的bean
- en: '`FileEvent` is a bean that is sent to the event—the observers will receive
    this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileEvent`是一个发送到事件的bean——观察者将接收这个：'
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Qualifier to select the JpgHandler observer to react to an event
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择用于响应事件的`JpgHandler`观察者的限定符
- en: 'In the following code, we have the `Jpg` qualifier, used to define the correct
    handler:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们有`Jpg`限定符，用于定义正确的事件处理器：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Qualifier to select the PdfHandler observer to react to an event
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择用于响应事件的`PdfHandler`观察者的限定符
- en: 'In the following code, we have the `Pdf` qualifier, used to define the correct
    handler:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们有`Pdf`限定符，用于定义正确的事件处理器：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Qualifier to select the ZipHandler observer to react to an event
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择用于响应事件的`ZipHandler`观察者的限定符
- en: 'In the following code, we have the `Zip` qualifier, used to define the correct
    handler:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们有`Zip`限定符，用于定义正确的事件处理器：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The FIleUploadResource class
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FileUploadResource类
- en: 'In the following code block, we have the `JFileUploadResource` class, which
    uses JAX-RS and is a REST service:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码块中，我们有`JFileUploadResource`类，它使用JAX-RS并且是一个REST服务：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Another way to establish the correct event to launch is to use the qualifier
    at the point where the object is injected using `@Inject`, but this way, the event
    becomes static and all events launched by the `Event` object are of the same type.
    Using the `select (Annotation... var)` method, we can launch a dynamic event as
    well as other event types. The following is an example of `Event` with a static event
    type:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 建立正确事件启动的另一种方法是使用在对象注入点使用`@Inject`时的限定符，但这种方式下，事件变为静态的，并且由`Event`对象启动的所有事件都是同一类型。使用`select
    (Annotation... var)`方法，我们可以启动动态事件以及其他事件类型。以下是一个具有静态事件类型的`Event`示例：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding example, `pdfEvent` will always launch an event to an observer
    that processes an event marked by the `@Pdf` qualifier.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`pdfEvent`将始终向由`@Pdf`限定符标记的事件处理观察者启动事件。
- en: 'To launch an asynchronous event, we need to call the `fireAsync(U var)` method, which
    returns `CompletionStage`. In the following code block, we have a snippet that
    calls this method and prepares a callback function to execute when the process
    is complete:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动异步事件，我们需要调用`fireAsync(U var)`方法，该方法返回`CompletionStage`。在以下代码块中，我们有一个调用此方法并准备在过程完成后执行回调函数的代码片段：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Implementing observers
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现观察者
- en: When an event is launched by a launcher, some elements will react to this event
    and process a task with the data given on an event. These elements are called
    **observers** and work as observer patterns, which create a one-to-many relationship
    between objects.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个启动器启动事件时，一些元素将对此事件做出反应，并使用事件上提供的数据处理一个任务。这些元素被称为 **观察者**，它们作为观察者模式工作，在对象之间创建一对一的关系。
- en: This occurs when one object is the subject and the other objects are the observers.
    Then, when the subject object is updated, all observer objects that are related
    to this subject-object are updated too.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这发生在其中一个对象是主题，而其他对象是观察者的情况下。然后，当主题对象更新时，所有与该主题对象相关的观察者对象也会更新。
- en: 'CDI has a mechanism for creating observers that will react with its events.
    In our example, we will launch an event, create observers to react to these events,
    and process a task. To do this, we will create handlers that represent our observer
    and process tasks. These handlers will be classes that implement the `FileHandler`
    interface as well as methods, called `handle(FileEvent file)`. Note that the parameter
    of the `handler(FileEvent file)` method is a `FileEvent` type. This is the same
    type of data as sent to the event in the preceding example. In the following example,
    we have the code for the `FileHandler` interface and its implementations:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: CDI 有一个创建将对其事件做出反应的观察者的机制。在我们的示例中，我们将启动一个事件，创建观察者以对这些事件做出反应，并处理一个任务。为此，我们将创建代表我们的观察者和处理任务的处理器。这些处理器将是实现
    `FileHandler` 接口以及名为 `handle(FileEvent file)` 的方法的类。请注意，`handler(FileEvent file)`
    方法的参数是 `FileEvent` 类型。这与前面示例中发送到事件的类型相同。在以下示例中，我们有 `FileHandler` 接口及其实现的代码：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the following code, we have the `JpgHandler` class, which is an implementation
    of `FileHandler`. This is responsible for saving the JPG files on a filesystem.
    This observer is called when an event is launched to the `@Jpg` qualifier:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们有一个名为 `JpgHandler` 的类，它是 `FileHandler` 的一个实现。这负责在文件系统上保存 JPG 文件。当向
    `@Jpg` 标识符启动事件时，将调用此观察者：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code block, we have the method handler, which has an `@ObservesAsync` annotation as
    well as `@Jpg`. This is a CDI annotation that configures this method to observe
    the `FileEvent` file, as well as the Qualifier, to configure the observer to react
    only to the event launched to the `@Jpg` qualifier.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们有一个方法处理程序，它带有 `@ObservesAsync` 注解以及 `@Jpg`。这是一个 CDI 注解，用于配置此方法以观察
    `FileEvent` 文件，以及 Qualifier 以配置观察者仅对启动到 `@Jpg` 标识符的事件做出反应。
- en: 'In the following code block, we have the `PdfHandler` class, which is an implementation
    of `FileHandler` responsible for persisting PDF files on a filesystem. This observer
    is called when an event is launched to a `@Pdf` qualifier:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码块中，我们有一个名为 `PdfHandler` 的类，它是 `FileHandler` 的一个实现，负责在文件系统上持久化 PDF 文件。当向
    `@Pdf` 标识符启动事件时，将调用此观察者：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, we have a handler method with an `@ObservesAsync` annotation as
    well as a `@Pdf.` This is a CDI annotation that configures the `handle(FileEvent
    file)` method to observe the `FileEvent` file, and the `Qualifier` to configure
    the observer to react only to an event launched to the `@Pdf` qualifier.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有一个带有 `@ObservesAsync` 注解以及 `@Pdf.` 的处理方法。这是一个 CDI 注解，用于配置 `handle(FileEvent
    file)` 方法以观察 `FileEvent` 文件，以及 `Qualifier` 以配置观察者仅对启动到 `@Pdf` 标识符的事件做出反应。
- en: 'In the following code, we have the `ZipHandler` class, which is an implementation
    of `FileHandler` responsible for saving ZIP files on a filesystem. This observer
    is called when an event is launched to a `@Zip` qualifier:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们有一个名为 `ZipHandler` 的类，它是 `FileHandler` 的一个实现，负责在文件系统上保存 ZIP 文件。当向 `@Zip`
    标识符启动事件时，将调用此观察者：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, we have the handler method, which has an `@ObservesAsync` and
    a `@Zip` annotation. This is a CDI annotation that configures this method to observe
    the `FileEvent` file, and the Qualifier to configure this observer to react only
    to events launched to the `@Zip` qualifier.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有一个处理方法，它带有 `@ObservesAsync` 和 `@Zip` 注解。这是一个 CDI 注解，用于配置此方法以观察 `FileEvent`
    文件，以及 Qualifier 以配置此观察者仅对启动到 `@Zip` 标识符的事件做出反应。
- en: Explaining the concept of an asynchronous EJB method
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释异步 EJB 方法的概念
- en: Launching events to elements that react to these events is a good mechanism
    for solving many kinds of problems during development. However, sometimes it is
    necessary to call a class method without blocking the process until this method
    completes the execution.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 向响应这些事件的元素启动事件是一种在开发过程中解决许多类型问题的良好机制。然而，有时有必要在不阻塞进程直到该方法完成执行的情况下调用类方法。
- en: An asynchronous EJB method is a mechanism of EJB that allows the client to call
    a method and receive its return as soon as the method is invoked. The return of
    a method is in control of the asynchronous call represented by the `Future<T>`
    object. The client can control the execution of the asynchronous method. These
    actions can cancel the invocation method, check whether the invocation is completed,
    check whether the invocation has launched an exception, and check whether the
    invocation was cancelled.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 异步 EJB 方法是 EJB 的一种机制，允许客户端调用一个方法，并在方法被调用时立即接收其返回值。方法的返回值由代表异步调用的 `Future<T>`
    对象控制。客户端可以控制异步方法的执行。这些操作可以取消调用方法，检查调用是否完成，检查调用是否抛出异常，以及检查调用是否已取消。
- en: Difference between an asynchronous EJB method and an event in CDI
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步 EJB 方法与 CDI 事件之间的区别
- en: An event in CDI and an asynchronous EJB method have the similar characteristic
    of making a nonblocking call to a task. Furthermore, the client can cancel and
    monitor the invocation of an asynchronous process. However, an asynchronous EJB
    method and an event in CDI don't share all the same characteristics. The principal
    difference between them is that the asynchronous EJB method works on a one-to-one
    basis between the caller and the called. This is because when this method is invoked,
    it will only process the task and the client knows what the method is that will
    be processed. On the event in CDI, the relationship between the caller and the
    called is one-to-many. This is because the caller launches an event, and one or
    more observers can react to this. Another difference between the asynchronous
    EJB method and an event in CDI is that, in CDI, the event works with the observer
    pattern and makes it possible to apply a callback method to be executed at another
    time. The asynchronous EJB method doesn't work with the observer pattern and doesn't
    have the ability to apply a callback method.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: CDI 中的事件和异步 EJB 方法具有使任务非阻塞调用的相似特性。此外，客户端可以取消并监控异步过程的调用。然而，异步 EJB 方法与 CDI 事件并不共享所有相同的特性。它们之间的主要区别在于异步
    EJB 方法在调用者和被调用者之间是一对一的关系。这是因为当该方法被调用时，它只会处理任务，客户端知道将要处理的方法是什么。而在 CDI 事件中，调用者和被调用者之间的关系是一对多的。这是因为调用者启动了一个事件，一个或多个观察者可以对此做出反应。异步
    EJB 方法与 CDI 事件之间的另一个区别是，在 CDI 中，事件与观察者模式一起工作，使得在另一个时间执行回调方法成为可能。异步 EJB 方法不与观察者模式一起工作，并且没有应用回调方法的能力。
- en: Implementing an asynchronous EJB method
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现异步 EJB 方法
- en: 'In our implementation example, we will use the same scenario as in the example
    of an Event in CDI. Here, we will create an application that makes it possible
    to upload three types (or extensions) of files—ZIP, JPG, and PDF extensions. Depending
    on the type of extension received, the file received will be saved on the filesystem
    at its respective directory. To develop this example, we will use the following
    classes:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的实现示例中，我们将使用与 CDI 事件示例相同的场景。在这里，我们将创建一个应用程序，使其能够上传三种类型（或扩展名）的文件——ZIP、JPG
    和 PDF 扩展名。根据接收到的扩展名类型，接收到的文件将保存在文件系统中的相应目录下。为了开发此示例，我们将使用以下类：
- en: '`FileUploadResource`: This is a class that represents the resource to receive
    all request to upload, and calls the respective EJB according to the file extension.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileUploadResource`: 这是一个表示接收所有上传请求的资源类，并根据文件扩展名调用相应的 EJB。'
- en: '`JpgHandler`: This is an EJB with an asynchronous method to treat the process
    save of a JPG file on disk.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JpgHandler`: 这是一个具有异步方法的 EJB，用于处理磁盘上 JPG 文件的保存过程。'
- en: '`PdfHandler`: This is an EJB with an asynchronous method to treat the process
    save of a PDF file on disk.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PdfHandler`: 这是一个具有异步方法的 EJB，用于处理磁盘上 PDF 文件的保存过程。'
- en: '`ZipHandler`: This is an EJB with an asynchronous method to treat the process
    save of a ZIP file on disk.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZipHandler`: 这是一个具有异步方法的 EJB，用于处理磁盘上 ZIP 文件的保存过程。'
- en: '`FileSystemUtils`: This is a utility class intended to handle issues with the
    filesystem.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileSystemUtils`: 这是一个旨在处理文件系统问题的实用工具类。'
- en: Implementing EJBs
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 EJB
- en: 'To use an asynchronous EJB method, we need to create a session bean and configure
    it to have asynchronous methods. In the following code, we have an example of
    the implementation of a session bean called `PdfHandler`, which is responsible
    for saving PDF files on a filesystem:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用异步EJB方法，我们需要创建一个会话bean并将其配置为具有异步方法。在下面的代码中，我们有一个名为`PdfHandler`的会话bean实现的示例，该bean负责在文件系统上保存PDF文件：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code block, we have the `PdfHandler` class, which contains
    a `handler(FileBean file)` method. This method is annotated with `@Asynchronous`
    to configure it as an asynchronous method.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们有一个`PdfHandler`类，它包含一个`handler(FileBean file)`方法。此方法使用`@Asynchronous`注解来配置它为一个异步方法。
- en: 'The following code demonstrates the configuration of the `handle(FileBean file)` method:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了`handle(FileBean file)`方法的配置：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This method needs to return `Future<T>`. In our example, we return `AsyncResult`,
    which is an implementation of the `Future` interface. In our example, the data
    returned with the `Future` object contains the information of the path to the
    file on the filesystem. In the following code, we have an example of a `Future`
    return:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法需要返回`Future<T>`。在我们的示例中，我们返回`AsyncResult`，它是`Future`接口的一个实现。在我们的示例中，与`Future`对象一起返回的数据包含文件系统上文件路径的信息。在下面的代码中，我们有一个`Future`返回的示例：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the following code block, we have an example of the implementation of a
    session bean called `JpgHandler`, which is responsible for saving JPG files on
    the filesystem:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们有一个名为`JpgHandler`的会话bean实现的示例，该bean负责在文件系统上保存JPG文件：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This method works as the `PdfHandler` method, but saves the file at another
    directory and with another filename pattern. In our example, the data returned
    with the `Future` object is the path to the file on the filesystem.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法与`PdfHandler`方法类似，但将文件保存在另一个目录，并使用另一个文件名模式。在我们的示例中，与`Future`对象一起返回的数据是文件系统上文件的路径。
- en: 'In the following code, we have an example of an implementation of the session
    bean called `JpgHandler`, which is responsible for saving JPG files on the filesystem:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们有一个名为`JpgHandler`的会话bean实现的示例，该bean负责在文件系统上保存JPG文件：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This method works as the `PdfHandler` and `JpgHandler` methods, but saves the
    file at another directory and with another filename pattern. In our example, the
    data returned with the `Future` object is the path to the file on the filesystem.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法与`PdfHandler`和`JpgHandler`方法类似，但将文件保存在另一个目录，并使用另一个文件名模式。在我们的示例中，与`Future`对象一起返回的数据是文件系统上文件的路径。
- en: Implementing the FileUploadResource class
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现FileUploadResource类
- en: '`FileUploadResource` is a resource class that uses JAX-RS to create a RESTful
    service to upload a file with JPG, PDF, and ZIP extensions. The following code
    contains the `FileUploadResource` resource class:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileUploadResource`是一个资源类，它使用JAX-RS创建一个RESTful服务来上传具有JPG、PDF和ZIP扩展名的文件。下面的代码包含`FileUploadResource`资源类：'
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the following code block, the EJB''s `PdfHandler`, `JpgHandler`, and `ZipHandler`
    are injected with the `@Inject` annotation from CDI. In the following example,
    we have the injection code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，EJB的`PdfHandler`、`JpgHandler`和`ZipHandler`使用CDI的`@Inject`注解进行注入。在下面的示例中，我们有注入代码：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When a request is sent to an application, the method responsible for processing
    a request gets the file and builds a `FileBean`. This method calls an asynchronous
    EJB method to process this task. In the following code blocks, we have examples
    of calling the asynchronous EJB method.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当向应用程序发送请求时，负责处理请求的方法获取文件并构建一个`FileBean`。此方法调用异步EJB方法来处理此任务。在下面的代码块中，我们有调用异步EJB方法的示例。
- en: Calling an asynchronous EJB method to save a PDF
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用一个异步EJB方法来保存PDF文件
- en: 'We use the following ways to call the asynchronous EJB method. The following
    code block demonstrates the saving of a PDF file by calling the EJB method:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下方式调用异步EJB方法。以下代码块通过调用EJB方法演示了保存PDF文件：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Calling an asynchronous EJB method to save a JPG
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用一个异步EJB方法来保存JPG文件
- en: 'The following code block demonstrates the saving of a JPG file by calling the
    asynchronous EJB method:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块通过调用异步EJB方法演示了保存JPG文件：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Calling an asynchronous EJB method to save a ZIP
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用一个异步EJB方法来保存ZIP文件
- en: 'The following code block demonstrates the saving of a ZIP file by calling the
    asynchronous EJB method:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块演示了通过调用异步EJB方法保存ZIP文件：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Explaining the concept of an asynchronous REST service
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释异步REST服务的概念
- en: Over time, the number of REST applications has grown and many APIs have been
    created to serve various kinds of services in many environments. In the same way
    as other applications, some REST applications need asynchronous processes and
    work with nonblocking processes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，REST应用程序的数量不断增加，许多API已经创建出来，以在各种环境中提供各种类型的服务。与其他应用程序一样，一些REST应用程序需要异步过程，并与非阻塞过程一起工作。
- en: An asynchronous REST service is an asynchronous process that makes it easier
    to process threads. In contrast, in a request sent to a server, a new thread can
    be called to process a nonblocking task, such as operations on a filesystem. JAX-RS
    supports asynchronous processing in a client API and server API, but the asynchronous
    rest service is implemented at the server API. This is because it is the server
    API that provides services. The client API consumes the services and, as a result,
    we refer to the asynchronous processing in a client API as the asynchronous REST
    consume.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 异步REST服务是一个异步过程，使处理线程更容易。相比之下，在发送到服务器的请求中，可以调用一个新线程来处理非阻塞任务，例如文件系统上的操作。JAX-RS在客户端API和服务器API中支持异步处理，但异步REST服务是在服务器API中实现的。这是因为服务器API提供服务。客户端API消费服务，因此我们将客户端API中的异步处理称为异步REST消费。
- en: The client API can be completed through asynchronous invocation, which returns
    a `Future<T>` object as soon as the request is done, allowing the client to control
    this invocation and apply actions to it. This can be done through reactive programming
    and it can return a `CompletionState<T>` object as soon as the request is done.
    This means that it is possible to control the invocation and choose a callback
    method, executed depending on the stage. In the implementation example covered
    in the next topic, we will use the invocation with reactive programming.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端API可以通过异步调用完成，一旦请求完成，就返回一个`Future<T>`对象，允许客户端控制这个调用并对它执行操作。这可以通过响应式编程来实现，并且可以在请求完成后立即返回一个`CompletionState<T>`对象。这意味着可以控制调用并选择一个回调方法，根据阶段执行。在下一主题中涵盖的实现示例中，我们将使用响应式编程的调用。
- en: Implementing an asynchronous REST service
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现异步REST服务
- en: 'As an example of implementing an asynchronous REST service, we will use the
    same scenario used in the example of the event in the CDI and the asynchronous
    EJB method. Here, we will create an application that makes it possible to upload
    three types (or extensions) of files—ZIP, JPG, and PDF extensions. Depending on
    the extension received, we want the file received to be kept in its respective
    directory on the filesystem. To develop this example, we have the following classes:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 作为实现异步REST服务的示例，我们将使用CDI事件示例中使用的相同场景和异步EJB方法示例。在这里，我们将创建一个应用程序，使其能够上传三种类型（或扩展名）的文件——ZIP、JPG和PDF扩展名。根据接收到的扩展名，我们希望接收到的文件被保存在文件系统上的相应目录中。为了开发这个示例，我们有以下类：
- en: '`FileUploadResource`: This is a class that represents the resource that works
    with asynchronous processes to receive all requests to upload, and calls the respective
    EJB according to the file extension.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileUploadResource`：这是一个表示与异步过程一起工作的资源，用于接收所有上传请求，并根据文件扩展名调用相应的EJB。'
- en: '`JpgHandler`: This is an EJB with an available method for saving a JPG file
    on a disk.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JpgHandler`：这是一个EJB，提供了一个在磁盘上保存JPG文件的方法。'
- en: '`PdfHandler`: This is an EJB with an available method for saving a PDF file
    on a disk.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PdfHandler`：这是一个EJB，提供了一个在磁盘上保存PDF文件的方法。'
- en: '`ZipHandler`: This is an EJB with an available method for saving a ZIP file
    on a disk.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZipHandler`：这是一个EJB，提供了一个在磁盘上保存ZIP文件的方法。'
- en: '`FileSystemUtils`: This is a utility class that deals with issues within the
    filesystem.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileSystemUtils`：这是一个处理文件系统问题的实用类。'
- en: '`FileUploadClient`: This is a client API implemented through JAX-RS that makes
    asynchronous calls to the REST service.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileUploadClient`：这是一个通过JAX-RS实现的客户端API，它对REST服务进行异步调用。'
- en: Implementing the EJBs
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现EJBs
- en: At this point, we will implement `PdfHandler`, `JpgHandler`, and `ZipHandler`,
    which are the EJBs responsible for dealing with the logic to save its files.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们将实现`PdfHandler`、`JpgHandler`和`ZipHandler`，这些EJB负责处理保存文件逻辑。
- en: 'In the following code, we have `PdfHandler`, which is responsible for saving
    PDF files:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们有`PdfHandler`，它负责保存PDF文件：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the following code block, we have `JpgHandler`, which is responsible for
    saving JPG files:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码块中，我们有`JpgHandler`，它负责保存JPG文件：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the following code block, we have `ZipHandler`, which is responsible for
    saving ZIP files:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们有`ZipHandler`，它负责保存ZIP文件：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Implementing the FileUploadResource class
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现FileUploadResource类
- en: '`FileUploadResource` is a resource designed to allow clients to upload files
    to a server through an asynchronous request using REST. This class uses the JAX-RS
    to create a REST resource and, depending on the file extension, this resource
    delegates the task of saving a file to its respective EJB. In the following code
    block, we have the `FileUploadResource` class:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileUploadResource`是一个资源，旨在允许客户端通过异步请求使用REST将文件上传到服务器。这个类使用JAX-RS创建REST资源，并根据文件扩展名，此资源将保存文件的任务委托给相应的EJB。在下面的代码块中，我们有`FileUploadResource`类：'
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In addition, this class consists of three methods that receive a request, prepare
    the `FileBean`, and send it to an EJB to process a task that saves the files.
    In the following code block, we have the `uploadPdf(File file)` method, which
    is responsible for processing all the requests to upload PDF files:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这个类包含三个方法，它们接收请求，准备`FileBean`，并将其发送到EJB以处理保存文件的任务。在下面的代码块中，我们有`uploadPdf(File
    file)`方法，它负责处理所有上传PDF文件的请求：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Implementing the client API
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现客户端API
- en: 'Now, in order to send an asynchronous request using the reactive programming,
    we create an example of the JAX-RS client API. In the following code, we can see
    an example of the client API:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使用反应式编程发送异步请求，我们创建了一个JAX-RS客户端API的示例。在下面的代码中，我们可以看到一个客户端API的示例：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In [Chapter 7](9e35e298-1a91-43b8-ace1-805997b2b89e.xhtml), *Microservice Patterns*,
    we explored the reactive programming paradigm and how it is implemented using
    Java EE 8 mechanisms. We also demonstrated how we can make asynchronous calls
    using Java EE 8 mechanisms, and how to control these calls and apply actions to
    them via asynchronous processing.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](9e35e298-1a91-43b8-ace1-805997b2b89e.xhtml)《微服务模式》中，我们探讨了反应式编程范式以及它是如何通过Java
    EE 8机制实现的。我们还展示了如何使用Java EE 8机制进行异步调用，以及如何通过异步处理来控制这些调用并对它们应用操作。
- en: Event in CDI is a mechanism of the CDI specification that can be used in all
    tiers of an application. However, using this mechanism is recommended when working
    with a presentation tier. This is because CDI has a major focus on the presentation
    tier and its scopes are directly related to the HTTP interaction and HTTP session.
    Furthermore, we could launch an event with various elements that react to this
    event.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: CDI中的事件是CDI规范中的一种机制，可以在应用程序的所有层中使用。然而，当与表示层一起工作时，推荐使用此机制。这是因为CDI主要关注表示层，其作用域与HTTP交互和HTTP会话直接相关。此外，我们可以启动一个包含各种响应此事件的元素的事件。
- en: The asynchronous EJB method doesn't use the reactive programming paradigm but
    is an asynchronous process that makes it possible to decrease the time it takes
    to respond to the client. This is an EJB mechanism and it is recommended to use
    it at the business tier. The benefit of using this mechanism is that we can also
    use other EJB mechanisms, such as the transactions control.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 异步EJB方法不使用反应式编程范式，而是一个异步过程，这使得减少对客户端响应时间成为可能。这是一个EJB机制，建议在业务层使用它。使用此机制的好处是，我们还可以使用其他EJB机制，例如事务控制。
- en: The asynchronous REST service is a mechanism of the JAX-RS specification that
    is able to create a REST service that can do asynchronous processing. With this
    mechanism, the control of the process is returned as soon as a request is sent,
    and the client, therefore, doesn't need to wait a long time to process other tasks.
    This mechanism is always implemented in the presentation tier.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 异步REST服务是JAX-RS规范中的一种机制，能够创建一个可以进行异步处理的REST服务。使用此机制，一旦发送请求，过程控制就返回，因此客户端不需要长时间等待来处理其他任务。此机制始终在表示层实现。
- en: In the next chapter, we will cover microservice patterns and how to implement
    them. We will also look at the aggregator pattern, proxy pattern, chained pattern,
    branch pattern, and asynchronous messaging pattern.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍微服务模式及其实现方法。我们还将探讨聚合器模式、代理模式、链式模式、分支模式和异步消息模式。
