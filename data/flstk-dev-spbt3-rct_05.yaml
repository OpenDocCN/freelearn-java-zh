- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Creating a RESTful Web Service with Spring Boot
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring Boot 创建 RESTful Web 服务
- en: 'Web services are applications that communicate over the internet using the
    HTTP protocol. There are many different types of web service architectures, but
    the principal idea across all designs is the same. In this book, we will create
    a RESTful web service: nowadays, a really popular design.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上使用 HTTP 协议进行通信的应用程序称为 Web 服务。存在许多不同类型的 Web 服务架构，但所有设计中的主要思想是相同的。在这本书中，我们将创建一个
    RESTful Web 服务：如今，这是一种非常流行的设计。
- en: In this chapter, we will first create a **RESTful web service** using a controller
    class. Then, we will use **Spring Data REST** to create a RESTful web service
    that also provides all CRUD functionalities automatically, and document it with
    **OpenAPI 3**. After you have created a RESTful API for your application, you
    can implement the frontend using a JavaScript library such as React. We will be
    using the database application that we created in the previous chapter as a starting
    point.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先使用控制器类创建一个 **RESTful Web 服务**。然后，我们将使用 **Spring Data REST** 创建一个提供所有
    CRUD 功能的 RESTful Web 服务，并使用 **OpenAPI 3** 进行文档记录。在为您的应用程序创建 RESTful API 之后，您可以使用
    JavaScript 库（如 React）实现前端。我们将使用前一章中创建的数据库应用程序作为起点。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Basics of REST
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST 基础
- en: Creating a RESTful web service with Spring Boot
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring Boot 创建 RESTful Web 服务
- en: Using Spring Data REST
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring Data REST
- en: Documenting a RESTful API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录 RESTful API
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The Spring Boot application created in the previous chapters is required.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 需要前几章中创建的 Spring Boot 应用程序。
- en: You will also need Postman, cURL, or another suitable tool for transferring
    data using various HTTP methods.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要 Postman、cURL 或其他合适的工具，用于使用各种 HTTP 方法传输数据。
- en: 'The following GitHub link will be required: [https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter04).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 GitHub 链接将需要：[https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter04)。
- en: Basics of REST
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST 基础
- en: '**Representational State Transfer** (**REST**) is an architectural style for
    creating web services. REST is neither language- nor platform-dependent; different
    clients like mobile apps, browsers, and other services can communicate with each
    other. RESTful services can be scaled easily to fulfill increased demand.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**表征状态转移**（**REST**）是创建 Web 服务的架构风格。REST 既不依赖于语言也不依赖于平台；不同的客户端，如移动应用、浏览器和其他服务，可以相互通信。RESTful
    服务可以轻松扩展以满足增加的需求。'
- en: 'REST is not a standard but a set of constraints, defined by Roy Fielding. The
    constraints are as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: REST 不是一个标准，而是一组由 Roy Fielding 定义的约束。约束如下：
- en: '**Stateless**: The server shouldn’t hold any information about the client state.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态**：服务器不应保留任何有关客户端状态的信息。'
- en: '**Client-server independence**: The client and server should act independently.
    The server should not send any information without a request from the client.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端-服务器独立性**：客户端和服务器应独立行动。服务器不应在没有客户端请求的情况下发送任何信息。'
- en: '**Cacheable**: Many clients often request the same resources; therefore, caching
    should be applied to resources in order to improve performance.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可缓存**：许多客户端经常请求相同的资源；因此，为了提高性能，应该对资源进行缓存。'
- en: '**Uniform interface**: Requests from different clients should look the same.
    Clients may include, for example, a browser, a Java application, and a mobile
    application.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统一接口**：来自不同客户端的请求应该看起来相同。客户端可能包括，例如，浏览器、Java 应用程序和移动应用程序。'
- en: '**Layered system**: Components can be added or modified without affecting the
    entire service. This constraint affects scalability.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分层系统**：组件可以添加或修改，而不会影响整个服务。这个限制影响了可扩展性。'
- en: '**Code on demand**: This is an optional constraint. Most of the time, the server
    sends static content in the form of JSON or XML. This constraint allows the server
    to send executable code if needed.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码按需**：这是一个可选约束。大多数情况下，服务器以 JSON 或 XML 的形式发送静态内容。这个约束允许服务器在需要时发送可执行代码。'
- en: 'The uniform interface constraint is important, and it means that every REST
    architecture should have the following elements:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 统一接口约束非常重要，这意味着每个 REST 架构都应该具有以下元素：
- en: '**Identification of resources**: Resources should be identified by unique identifiers,
    for example, URIs in web-based REST services. REST resources should expose easily
    understood directory structure URIs. Therefore, a good resource-naming strategy
    is very important.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源的标识**：资源应由唯一的标识符进行标识，例如，基于 Web 的 REST 服务中的 URI。REST 资源应公开易于理解的目录结构 URI。因此，一个良好的资源命名策略非常重要。'
- en: '**Resource manipulation through representation**: When making a request to
    a resource, the server should respond with a representation of the resource. Typically,
    the format of the representation is JSON or XML.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过表示进行资源操作**：在向资源发出请求时，服务器应以资源的表示形式进行响应。通常，表示的格式是 JSON 或 XML。'
- en: '**Self-descriptive messages**: Messages should contain enough information that
    the server knows how to process them.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自描述的消息**：消息应包含足够的信息，以便服务器知道如何处理它们。'
- en: '**Hypermedia as the Engine of Application State** (**HATEOAS**): Responses
    should contain links to other areas of the service.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超媒体作为应用程序状态引擎**（**HATEOAS**）：响应应包含指向服务其他区域的链接。'
- en: The RESTful web service that we are going to develop in the next sections follows
    the REST architectural principles above.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中开发的 RESTful 网络服务遵循上述 REST 架构原则。
- en: Creating a RESTful web service with Spring Boot
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring Boot 创建 RESTful 网络服务
- en: 'In Spring Boot, all HTTP requests are handled by **controller classes**. To
    be able to create a RESTful web service, first, we have to create a controller
    class. We will create our own Java package for the controller:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spring Boot 中，所有 HTTP 请求都由 **控制器类** 处理。为了能够创建 RESTful 网络服务，首先，我们必须创建一个控制器类。我们将为控制器创建自己的
    Java 包：
- en: 'Activate the root package in the Eclipse **Project Explorer** and right-click.
    Select **New | Package** from the menu. We will name our new package `com.packt.cardatabase.web`:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Eclipse **项目资源管理器**中激活根包，然后右键单击。从菜单中选择 **新建 | 包**。我们将命名我们的新包为 `com.packt.cardatabase.web`：
- en: '![](img/B19818_04_01.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_04_01.png)'
- en: 'Figure 4.1: New Java package'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：新的 Java 包
- en: 'Next, we will create a new `controller` class in a new web package. Activate
    the `com.packt.cardatabase.web` package in the Eclipse **Project Explorer**. Right-click
    and select **New | Class** from the menu; we will name our class `CarController`:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在新的 Web 包中创建一个新的 `controller` 类。在 Eclipse **项目资源管理器**中激活 `com.packt.cardatabase.web`
    包。右键单击并从菜单中选择 **新建 | 类**；我们将命名我们的类为 `CarController`：
- en: '![](img/B19818_04_02.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_04_02.png)'
- en: 'Figure 4.2: New Java class'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：新的 Java 类
- en: Now, your project structure should look like the following screenshot:![](img/B19818_04_03.png)
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你的项目结构应该看起来像以下截图所示：![](img/B19818_04_03.png)
- en: 'Figure 4.3: Project structure'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.3：项目结构
- en: If you create classes in the wrong package accidentally, you can drag and drop
    the files between packages in the Project Explorer. Sometimes, the Project Explorer
    view might not be rendered correctly when you make some changes. Refreshing the
    Project Explorer helps (activate the Project Explorer and press *F5*).
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你意外地创建了错误包中的类，你可以在项目资源管理器中拖放文件在包之间。有时，当你进行一些更改时，项目资源管理器视图可能无法正确渲染。刷新项目资源管理器有助于（激活项目资源管理器并按
    *F5*）。
- en: 'Open your controller class in the editor window and add the `@RestController`
    annotation before the class definition. Refer to the following source code. The
    `@RestController` annotation identifies that this class will be the controller
    for the RESTful web service:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器窗口中打开你的控制器类，并在类定义之前添加 `@RestController` 注解。参考以下源代码。`@RestController` 注解标识了该类将是
    RESTful 网络服务的控制器：
- en: '[PRE0]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we add a new method inside our controller class. The method is annotated
    with the `@GetMapping` annotation, which defines the endpoint that the method
    is mapped to. In the following code snippet, you can see the sample source code.
    In this example, when a user makes a `GET` request to the `/cars` endpoint, the
    `getCars()` method is executed:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在控制器类内部添加一个新的方法。该方法使用 `@GetMapping` 注解进行标注，该注解定义了方法映射到的端点。在下面的代码片段中，你可以看到示例源代码。在这个例子中，当用户向
    `/cars` 端点发送 `GET` 请求时，`getCars()` 方法将被执行：
- en: '[PRE1]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `getCars()` method returns all the car objects, which are then marshaled
    to JSON objects automatically by the **Jackson** library (https://github.com/FasterXML/jackson).
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`getCars()` 方法返回所有汽车对象，然后由 **Jackson** 库（https://github.com/FasterXML/jackson）自动将它们序列化为
    JSON 对象。'
- en: Now, the `getCars()` method handles only `GET` requests from the `/cars` endpoint
    because we are using the `@GetMapping` annotation. There are other annotations
    for the different HTTP methods, such as `@GetMapping`, `@PostMapping`, `@DeleteMapping`,
    and so on.
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，`getCars()`方法仅处理来自`/cars`端点的`GET`请求，因为我们使用了`@GetMapping`注解。还有其他注解用于不同的HTTP方法，例如`@GetMapping`、`@PostMapping`、`@DeleteMapping`等等。
- en: 'To be able to return cars from the database, we have to inject `CarRepository`
    into the controller. Then, we can use the `findAll()` method that the repository
    provides to fetch all cars. Due to the `@RestController` annotation, the data
    is now serialized to JSON format in the response. The following source code shows
    the controller code:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要能够从数据库中返回汽车，我们必须将`CarRepository`注入到控制器中。然后，我们可以使用仓库提供的`findAll()`方法来获取所有汽车。由于`@RestController`注解，数据现在在响应中序列化为JSON格式。以下源代码显示了控制器代码：
- en: '[PRE2]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we are ready to run our application and navigate to `localhost:8080/cars`.
    We can see that there is something wrong, and the application seems to be in an
    infinite loop. This happens on account of our one-to-many relationship between
    the car and owner tables. So, what happens in practice? First, the car is serialized,
    and it contains an owner who is then serialized, and that, in turn, contains cars
    that are then serialized, and so on. There are different solutions for avoiding
    this. One way is to use the `@JsonIgnore` annotation on the `cars` field in the
    `Owner` class, which ignores the `cars` field in the serialization process. You
    can also solve this by avoiding bidirectional mapping if it is not needed. We
    will also use the `@JsonIgnoreProperties` annotation to ignore fields that are
    generated by Hibernate:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已准备好运行我们的应用程序并导航到`localhost:8080/cars`。我们可以看到有些不对劲，应用程序似乎陷入了一个无限循环。这是由于我们的汽车和车主表之间的多对一关系。那么，实际情况是怎样的呢？首先，汽车被序列化，它包含一个车主，然后车主被序列化，反过来，车主又包含汽车，然后这些汽车被序列化，以此类推。有几种不同的解决方案可以避免这种情况。一种方法是在`Owner`类的`cars`字段上使用`@JsonIgnore`注解，在序列化过程中忽略`cars`字段。如果您不需要双向映射，也可以通过避免双向映射来解决这个问题。我们还将使用`@JsonIgnoreProperties`注解来忽略由Hibernate生成的字段：
- en: '[PRE3]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, when you run the application and navigate to `localhost:8080/cars`, everything
    should go as expected and you will get all the cars from the database in JSON
    format, as shown in the following screenshot:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当您运行应用程序并导航到`localhost:8080/cars`时，一切应该如预期进行，并且您将以JSON格式从数据库中获取所有汽车，如下面的截图所示：
- en: '![](img/B19818_04_04.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_04_04.png)'
- en: 'Figure 4.4: GET request to http://localhost:8080/cars'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：对http://localhost:8080/cars的GET请求
- en: Your output might differ from the screenshot due to browser differences. In
    this book, we are using the Chrome browser and the **JSON Viewer** extension,
    which makes JSON output more readable. JSON Viewer can be downloaded from the
    Chrome Web Store for free.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您的输出可能与截图不同，因为浏览器之间的差异。在这本书中，我们使用的是Chrome浏览器和**JSON Viewer**扩展程序，这使得JSON输出更加易于阅读。JSON
    Viewer可以从Chrome Web Store免费下载。
- en: We have written our first RESTful web service. By leveraging the capabilities
    of Spring Boot, we were able to quickly implement a service that returns all the
    cars in our database. However, this is just the beginning of what Spring Boot
    has to offer for creating robust and efficient RESTful web services, and we will
    continue to explore its capabilities in the next section.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了我们的第一个RESTful Web服务。通过利用Spring Boot的能力，我们能够快速实现一个返回我们数据库中所有汽车的服务。然而，这仅仅是Spring
    Boot为创建健壮和高效的RESTful Web服务所能提供的功能的一部分，我们将在下一节继续探索其功能。
- en: Using Spring Data REST
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Data REST
- en: '**Spring Data REST** (https://spring.io/projects/spring-data-rest) is part
    of the Spring Data project. It offers an easy and fast way to implement RESTful
    web services with Spring. Spring Data REST provides **HATEOAS** (**Hypermedia
    as the Engine of Application State**) support, an architectural principle that
    allows clients to navigate the REST API dynamically using hypermedia links. Spring
    Data REST also provides events that you can use to customize the business logic
    of your REST API endpoints.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring Data REST**（https://spring.io/projects/spring-data-rest）是Spring Data项目的一部分。它提供了一种简单快捷的方式来实现使用Spring的RESTful
    Web服务。Spring Data REST提供了**HATEOAS**（**Hypermedia as the Engine of Application
    State**）支持，这是一种架构原则，允许客户端使用超媒体链接动态地导航REST API。Spring Data REST还提供了事件，您可以使用这些事件来自定义REST
    API端点的业务逻辑。'
- en: 'You can read more about events in the Spring Data REST documentation: https://docs.spring.io/spring-data/rest/docs/current/reference/html/#events.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Spring Data REST文档中了解更多关于事件的信息：https://docs.spring.io/spring-data/rest/docs/current/reference/html/#events。
- en: 'To start using Spring Data REST, you have to add the following dependency to
    the `build.gradle` file:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Spring Data REST，您必须将以下依赖项添加到`build.gradle`文件中：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Refresh your Gradle project from Eclipse after you have modified the `build.gradle`
    file. Select the project in Eclipse’s Project Explorer and right-click to open
    the context menu. Then, select **Gradle | Refresh Gradle Project**.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改了`build.gradle`文件后，从Eclipse中刷新您的Gradle项目。在Eclipse的项目资源管理器中选择项目，然后右键单击以打开上下文菜单。然后，选择**Gradle
    | 刷新Gradle项目**。
- en: 'By default, Spring Data REST finds all public repositories from the application
    and creates RESTful web services for your entities automatically. In our case,
    we have two repositories: `CarRepository` and `OwnerRepository`; therefore, Spring
    Data REST creates RESTful web services automatically for those repositories.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Spring Data REST从应用程序中查找所有公共仓库，并自动为您的实体创建RESTful Web服务。在我们的例子中，我们有两个仓库：`CarRepository`和`OwnerRepository`；因此，Spring
    Data REST自动为这些仓库创建RESTful Web服务。
- en: 'You can define the endpoint of the service in your `application.properties`
    file as follows. You might need to restart your application for the changes to
    take effect:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`application.properties`文件中定义服务的端点，如下所示。您可能需要重新启动应用程序以使更改生效：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, you can access the RESTful web service from the `localhost:8080/api` endpoint.
    By calling the root endpoint of the service, it returns the resources that are
    available. Spring Data REST returns JSON data in the **Hypertext Application Language**
    (**HAL**) format. The HAL format provides a set of conventions for expressing
    hyperlinks in JSON and it makes your RESTful web service easier to use for frontend
    developers:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以从`localhost:8080/api`端点访问RESTful Web服务。通过调用服务的根端点，它返回可用的资源。Spring Data
    REST以**超文本应用语言**（**HAL**）格式返回JSON数据。HAL格式提供了一套在JSON中表示超链接的约定，这使得您的RESTful Web服务对前端开发者来说更容易使用：
- en: '![](img/B19818_04_05.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_04_05.png)'
- en: 'Figure 4.5: Spring Boot Data REST resources'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：Spring Boot Data REST资源
- en: 'We can see that there are links to the car and owner entity services. The Spring
    Data REST service path name is derived from the entity class name. The name will
    then be pluralized and uncapitalized. For example, the entity `Car` service path
    name will become `cars`. The `profile` link is generated by Spring Data REST and
    contains application-specific metadata. If you want to use different path naming,
    you can use the `@RepositoryRestResource` annotation in your repository class,
    as shown in the next example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到有链接到汽车和所有者实体服务。Spring Data REST服务路径名称是从实体类名称派生出来的。名称将被复数化并转换为小写。例如，实体`Car`服务路径名称将变为`cars`。`profile`链接是由Spring
    Data REST生成的，并包含特定于应用程序的元数据。如果您想使用不同的路径命名，您可以在您的仓库类中使用`@RepositoryRestResource`注解，如下一个示例所示：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, if you call the endpoint `localhost:8080/api`, you can see that the endpoint
    has been changed from `/cars` to `/vehicles`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您调用端点`localhost:8080/api`，您可以看到端点已从`/cars`更改为`/vehicles`。
- en: '![](img/B19818_04_06.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_04_06.png)'
- en: 'Figure 4.6: Spring Boot Data REST resources'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：Spring Boot Data REST资源
- en: You can remove the different naming, and we will continue with the default endpoint
    name, `/cars`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以删除不同的命名，我们将继续使用默认的端点名称，`/cars`。
- en: Now, we’ll start to examine different services more carefully. There are multiple
    tools available for testing and consuming RESTful web services. In this book,
    we are using the **Postman** (https://www.postman.com/downloads/) desktop app,
    but you can use tools that you are familiar with, such as **cURL**. Postman can
    be acquired as a desktop application or as a browser plugin. cURL is also available
    for Windows by using Windows Ubuntu Bash (**Windows Subsystem for Linux**, **WSL**).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将开始更仔细地检查不同的服务。有多种工具可用于测试和消费RESTful Web服务。在这本书中，我们使用的是**Postman**（https://www.postman.com/downloads/）桌面应用程序，但您可以使用您熟悉的工具，例如**cURL**。Postman可以作为桌面应用程序或浏览器插件获取。cURL也可以通过使用Windows
    Ubuntu Bash（**Windows子系统（WSL**））在Windows上获得。
- en: 'If you make a request to the `/cars` endpoint (`http://localhost:8080/api/cars`)
    using the `GET` method (note: you can use a web browser for `GET` requests), you
    will get a list of all the cars, as shown in the following screenshot:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`GET`方法（注意：您可以使用网络浏览器进行`GET`请求）向`/cars`端点（`http://localhost:8080/api/cars`）发出请求，您将获得所有汽车列表，如下面的截图所示：
- en: '![](img/B19818_04_07.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19818_04_07.png)'
- en: 'Figure 4.7: Fetch cars'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：获取汽车
- en: In the JSON response, you can see that there is an array of cars, and each car
    contains car-specific data. All the cars also have the `_links` attribute, which
    is a collection of links, and with these links, you can access the car itself
    or get the owner of the car. To access one specific car, the path will be `http://localhost:8080/api/cars/{id}`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSON响应中，你可以看到有一个汽车数组，并且每辆汽车都包含特定的汽车数据。所有的汽车都有`_links`属性，这是一个链接集合，通过这些链接，你可以访问汽车本身或获取汽车的所有者。要访问特定的汽车，路径将是`http://localhost:8080/api/cars/{id}`。
- en: The `GET` request to `http://localhost:8080/api/cars/3/owner` returns the owner
    of the car with `id` 3\. The response now contains owner data, a link to the owner,
    and links to the owner’s other cars.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 向`http://localhost:8080/api/cars/3/owner`发出的`GET`请求返回了ID为3的汽车的所有者。响应现在包含所有者数据、所有者的链接以及所有者其他汽车的链接。
- en: 'The Spring Data REST service provides all CRUD operations. The following table
    shows which HTTP methods you can use for different CRUD operations:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data REST服务提供了所有CRUD操作。以下表格显示了你可以用于不同CRUD操作的不同HTTP方法：
- en: '| **HTTP method** | **CRUD** |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP方法** | **CRUD** |'
- en: '| `GET` | Read |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 读取 |'
- en: '| `POST` | Create |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 创建 |'
- en: '| `PUT/PATCH` | Update |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `PUT/PATCH` | 更新 |'
- en: '| `DELETE` | Delete |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 删除 |'
- en: 'Table 4.1: Spring Data REST operations'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.1：Spring Data REST操作
- en: Next, we will look at how to delete a car from the database by using our RESTful
    web service. In a delete operation, you have to use the `DELETE` method and the
    link to the car that will be deleted (`http://localhost:8080/api/cars/{id}`).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何通过我们的RESTful网络服务从数据库中删除一辆汽车。在删除操作中，你必须使用`DELETE`方法和将要删除的汽车的链接（`http://localhost:8080/api/cars/{id}`）。
- en: 'The following screenshot shows how you can delete one car with `id` 3 by using
    the Postman desktop app. In Postman, you have to select the correct HTTP method
    from the drop-down list, enter the request URL, and then click the **Send** button:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了如何使用Postman桌面应用程序通过`id`为3删除一辆汽车。在Postman中，你必须从下拉列表中选择正确的HTTP方法，输入请求URL，然后点击**Send**按钮：
- en: '![](img/B19818_04_08.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19818_04_08.png)'
- en: 'Figure 4.8: DELETE request to delete car'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8：删除汽车的DELETE请求
- en: If everything goes correctly, you will see the response status **200 OK** in
    Postman. After the successful `DELETE` request, you will also see that there are
    now two cars left in the database if you make a `GET` request to the `http://localhost:8080/api/cars/`
    endpoint. If you got the **404 Not Found** status in the `DELETE` response, check
    that you are using a car ID that exists in the database.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你将在Postman中看到响应状态**200 OK**。在成功的`DELETE`请求之后，如果你向`http://localhost:8080/api/cars/`端点发出`GET`请求，你将看到数据库中现在还剩下两辆汽车。如果你在`DELETE`响应中得到了**404
    Not Found**状态，请检查你使用的是数据库中存在的汽车ID。
- en: When we want to add a new car to the database, we have to use the `POST` method,
    and the request URL is `http://localhost:8080/api/cars`. The header must contain
    the `Content-Type` field with the value `application/json`, and the new car object
    will be embedded in the request body in JSON format.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要将一辆新车添加到数据库中时，我们必须使用`POST`方法，请求URL是`http://localhost:8080/api/cars`。头部必须包含带有值`application/json`的`Content-Type`字段，新的汽车对象将以JSON格式嵌入到请求体中。
- en: 'Here is one car example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个汽车示例：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you click the **Body** tab and select **raw** in Postman, you can type a
    new car JSON string under the **Body** tab. Also select JSON from the drop-down
    list, as shown in the following screenshot:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击**Body**标签并从Postman中选择**raw**，你可以在**Body**标签下输入一个新的汽车JSON字符串。同时，从下拉列表中选择JSON，如下面的截图所示：
- en: '![](img/B19818_04_09.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19818_04_09.png)'
- en: 'Figure 4.9: POST request to add a new car'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9：添加新汽车的POST请求
- en: 'You also have to set a header by clicking the **Headers** tab in Postman, as
    shown in the following screenshot. Postman adds some headers automatically based
    on your request selections. Check that the `Content-Type` header is in the list
    and the value is correct (`application/json`). If it doesn’t exist, you should
    add it manually. Automatically added headers might be hidden by default, but you
    can see these by clicking the **hidden** button. Finally, you can press the **Send**
    button:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你还必须在Postman中点击**Headers**标签来设置一个头部，如下面的截图所示。Postman根据你的请求选择自动添加一些头部。请确保`Content-Type`头部在列表中，并且值是正确的（`application/json`）。如果它不存在，你应该手动添加它。自动添加的头部默认可能被隐藏，但你可以通过点击**hidden**按钮来查看这些头部。最后，你可以按下**Send**按钮：
- en: '![](img/B19818_04_10.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19818_04_10.png)'
- en: 'Figure 4.10: POST request headers'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10：POST请求头部
- en: The response will send a newly created `car` object back and the status of the
    response will be **201 Created** if everything went correctly. Now, if you make
    a `GET` request again to the `http://localhost:8080/api/cars` path, you will see
    that the new car exists in the database.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，响应将发送一个新创建的`car`对象，并且响应状态将是**201 已创建**。现在，如果你再次向`http://localhost:8080/api/cars`路径发出`GET`请求，你将看到新汽车存在于数据库中。
- en: To update entities, we can use the `PATCH` method and the link to the car that
    we want to update (`http://localhost:8080/api/cars/{id}`). The header must contain
    the `Content-Type` field with the value `application/json`, and the `car` object
    with edited data will be given inside the request body.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新实体，我们可以使用`PATCH`方法和我们想要更新的汽车的链接（`http://localhost:8080/api/cars/{id}`）。头部必须包含带有值`application/json`的`Content-Type`字段，并且编辑后的`car`对象将包含在请求体中。
- en: If you are using `PATCH`, you have to send only fields that are updated. If
    you are using `PUT`, you have to include all fields in the request body.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`PATCH`，你必须只发送更新的字段。如果你使用`PUT`，你必须包含请求体中的所有字段。
- en: 'Let’s edit the car that we created in the previous example, changing the color
    to white. We are using `PATCH`, so the payload contains only the `color` property:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编辑在前一个示例中创建的汽车，将其颜色改为白色。我们使用`PATCH`，因此有效负载中只包含`color`属性：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The Postman request is shown in the following screenshot (note: we set the
    header as in the `POST` example and use the car `id` in the URL):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Postman请求如下截图所示（注意：我们设置了与`POST`示例相同的头部，并在URL中使用汽车`id`）：
- en: '![](img/B19818_04_11.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_04_11.png)'
- en: 'Figure 4.11: PATCH request to update existing car'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11：更新现有汽车的PATCH请求
- en: If the update succeeded, the response status is **200 OK**. If you now fetch
    the updated car using a `GET` request, you will see that the color has been updated.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果更新成功，响应状态是**200 OK**。现在，如果你使用`GET`请求获取更新的汽车，你会看到颜色已经更新。
- en: Next, we will add an owner to the new car that we just created. We can use the
    `PUT` method and the `http://localhost:8080/api/cars/{id}/owner` path. In this
    example, the ID of the new car is `4`, so the link is `http://localhost:8080/api/cars/4/owner`.
    The content of the body is now linked to an owner, for example, `http://localhost:8080/api/owners/1`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为新创建的汽车添加一个车主。我们可以使用`PUT`方法和`http://localhost:8080/api/cars/{id}/owner`路径。在这个例子中，新汽车的ID是`4`，所以链接是`http://localhost:8080/api/cars/4/owner`。现在请求体的内容链接到一个车主，例如，`http://localhost:8080/api/owners/1`。
- en: '![](img/B19818_04_12.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_04_12.png)'
- en: 'Figure 4.12: PUT request to update owner'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12：更新所有者的PUT请求
- en: 'The `Content-Type` value of the headers should be `text/uri-list` in this case.
    If you can’t modify the automatically added header, you can disable it by unchecking
    it. Then, add a new one, like shown in the next image, and press the **Send**
    button:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，头部的`Content-Type`值应该是`text/uri-list`。如果你不能修改自动添加的头部，你可以通过取消选中它来禁用它。然后，添加一个新的，如下一图所示，并按**发送**按钮：
- en: '![](img/B19818_04_13.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_04_13.png)'
- en: 'Figure 4.13: PUT request headers'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13：更新现有汽车的PATCH请求头部
- en: Finally, you can make a `GET` request for the car’s owner, and you should now
    see that the owner is linked to the car.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以为汽车发出`GET`请求车主，现在你应该看到车主已经与汽车链接。
- en: 'In the previous chapter, we created queries for our repository. These queries
    can also be included in our service. To include queries, you have to add the `@RepositoryRestResource`
    annotation to the repository class. Query parameters are annotated with the `@Param`
    annotation. The following source code shows `CarRepository` with these annotations:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们为我们的存储库创建了查询。这些查询也可以包含在我们的服务中。要包含查询，你必须将`@RepositoryRestResource`注解添加到存储库类中。查询参数用`@Param`注解。以下源代码显示了带有这些注解的`CarRepository`：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, when you make a `GET` request to the `http://localhost:8080/api/cars`
    path, you can see that there is a new endpoint called `/search`. Calling the `http://localhost:8080/api/cars/search`
    path returns the following response:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你向`http://localhost:8080/api/cars`路径发出`GET`请求时，你可以看到有一个新的端点叫做`/search`。调用`http://localhost:8080/api/cars/search`路径将返回以下响应：
- en: '![](img/B19818_04_14.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_04_14.png)'
- en: 'Figure 4.14: REST queries'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14：REST查询
- en: 'From the response, you can see that both queries are now available in our service.
    The following URL demonstrates how to fetch cars by brand: `http://localhost:8080/api/cars/search/findByBrand?brand=Ford`.
    The output will only contain cars with the brand Ford.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从响应中，你可以看到现在我们的服务中都有了这两个查询。以下URL演示了如何通过品牌获取汽车：`http://localhost:8080/api/cars/search/findByBrand?brand=Ford`。输出将只包含品牌为Ford的汽车。
- en: At the beginning of this chapter, we introduced the REST principles, and we
    can see that our RESTful API fulfills several aspects of the REST specification.
    It is stateless and requests from different clients look the same (uniform interface).
    The response contains links that can be used to navigate between related resources.
    Our RESTful API provides a URI structure that reflects the data model and relationship
    between resources.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们介绍了REST原则，我们可以看到我们的RESTful API满足了REST规范的一些方面。它是无状态的，来自不同客户端的请求看起来相同（统一的接口）。响应包含可以用来在相关资源之间导航的链接。我们的RESTful
    API提供了一个反映数据模型和资源之间关系的URI结构。
- en: We have now created the RESTful API for our backend, and we will consume it
    later with our React frontend.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经为我们的后端创建了RESTful API，我们将在稍后用我们的React前端来消费它。
- en: Documenting a RESTful API
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录RESTful API
- en: A RESTful API should be properly documented so that developers who are consuming
    it understand its functionality and behavior. The documentation should include
    what endpoints are available, what data formats are accepted, and how to interact
    with the API.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一个RESTful API应该得到适当的文档，以便使用它的开发者能够理解其功能和行为。文档应包括可用的端点、接受的数据格式以及如何与API交互。
- en: In this book, we will use the **OpenAPI 3** library for Spring Boot (https://springdoc.org)
    to generate documentation automatically. The **OpenAPI Specification** (formerly
    Swagger Specification) is an API description format for RESTful APIs. There are
    other alternatives, such as RAML (https://raml.org/), that can be used as well.
    You can also document your REST API using some other documentation tools, which
    provide flexibility but require more manual work. The use of the OpenAPI library
    automates this work, allowing you to focus on development.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用Spring Boot的 **OpenAPI 3** 库（https://springdoc.org）来自动生成文档。**OpenAPI规范**（以前称为Swagger规范）是RESTful
    API的API描述格式。还有其他替代方案，例如RAML（https://raml.org/），也可以使用。你还可以使用一些其他文档工具来记录你的REST API，这些工具提供了灵活性，但需要更多手动工作。使用OpenAPI库可以自动化这项工作，让你能专注于开发。
- en: 'The following steps demonstrate how you can generate documentation for your
    RESTful API:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤演示了如何为你的RESTful API生成文档：
- en: 'First, we have to add the OpenAPI library to our Spring Boot application. Add
    the following dependency to your `build.gradle` file:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须将OpenAPI库添加到我们的Spring Boot应用程序中。将以下依赖项添加到你的 `build.gradle` 文件中：
- en: '[PRE10]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we create a configuration class for our documentation. Create a new class
    called `OpenApiConfig` in the `com.packt.cardatabase` package of your application.
    Below is the code for the configuration class where we can configure, for example,
    the REST API title, description, and version. We can use the `info()` method to
    define these values:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们为我们的文档创建一个配置类。在你的应用程序的 `com.packt.cardatabase` 包中创建一个名为 `OpenApiConfig`
    的新类。以下是为配置类编写的代码，我们可以配置，例如，REST API的标题、描述和版本。我们可以使用 `info()` 方法来定义这些值：
- en: '[PRE11]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the `application.properties` file, we can define the path for our documentation.
    We can also enable **Swagger UI,** a user-friendly tool for visualizing RESTful
    APIs that are documented using the OpenAPI Specification (https://swagger.io/tools/swagger-ui/).
    Add the following settings to your `application.properties` file:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `application.properties` 文件中，我们可以定义我们文档的路径。我们还可以启用 **Swagger UI**，这是一个用于可视化使用OpenAPI规范（https://swagger.io/tools/swagger-ui/）编写的RESTful
    API的用户友好工具。将以下设置添加到你的 `application.properties` 文件中：
- en: '[PRE12]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, we are ready to run our project. When your application is running, navigate
    to `http://localhost:8080/swagger-ui.html` and you will see the documentation
    in Swagger UI, as shown in the following screenshot:![](img/B19818_04_15.png)
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好运行我们的项目。当你的应用程序正在运行时，导航到 `http://localhost:8080/swagger-ui.html`，你将看到Swagger
    UI中的文档，如下面的截图所示：![](img/B19818_04_15.png)
- en: 'Figure 4.15: Car RESTful API documentation'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.15：汽车RESTful API文档
- en: You can see all the endpoints that are available in your RESTful API. If you
    open any of the endpoints, you can even try them out by pressing the **Try it
    out** button. The documentation is also available in JSON format at `http://localhost:8080/api-docs`.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以看到你RESTful API中所有可用的端点。如果你打开任何一个端点，甚至可以通过按下**尝试它**按钮来尝试它们。文档也以JSON格式在`http://localhost:8080/api-docs`提供。
- en: Now that you have provided documentation for your RESTful API, it is much easier
    for developers to consume it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经为你的RESTful API提供了文档，开发者们使用起来就更加容易了。
- en: In the next chapter, we will secure our RESTful API, which will break access
    to Swagger UI. You can allow access again by modifying your security configuration
    (allow the `"/api-docs/**"` and `"/swagger-ui/**"` paths). You can also use Spring
    Profiles, but that is out of scope for this book.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将保护我们的RESTful API，这将中断Swagger UI的访问。你可以通过修改你的安全配置（允许`"/api-docs/**"`和`"/swagger-ui/**"`路径）来再次允许访问。你也可以使用Spring
    Profiles，但这本书的范围之外。
- en: Summary
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created a RESTful web service with Spring Boot. First, we
    created a controller and one method that returns all cars in JSON format. Next,
    we used Spring Data REST to get a fully functional web service with all CRUD functionalities.
    We covered different types of requests that are needed to use the CRUD functionalities
    of the service that we created. We also included our queries in the RESTful web
    service. Finally, we learned how to document our API properly with OpenAPI 3.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用Spring Boot创建了一个RESTful网络服务。首先，我们创建了一个控制器和一个返回所有汽车JSON格式的函数。接下来，我们使用了Spring
    Data REST来获取一个具有所有CRUD功能的完整网络服务。我们涵盖了使用我们创建的服务CRUD功能所需的不同类型的请求。我们还将在RESTful网络服务中包含我们的查询。最后，我们学习了如何使用OpenAPI
    3正确地记录我们的API。
- en: We will use this RESTful web service with our frontend later in this book, and
    now you can also easily implement a REST API for your own needs.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的后面部分使用这个RESTful网络服务与我们的前端，现在你也可以轻松地为你的需求实现REST API。
- en: In the next chapter, we will secure our backend using Spring Security. We will
    learn how to secure our data by implementing authentication. Then, only authenticated
    users will be able to access the RESTful API’s resources.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用Spring Security来保护我们的后端。我们将学习如何通过实现身份验证来保护我们的数据。然后，只有经过身份验证的用户才能访问我们创建的RESTful
    API的资源。
- en: Questions
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is REST?
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是REST？
- en: How can you create a RESTful web service with Spring Boot?
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用Spring Boot创建一个RESTful网络服务？
- en: How can you fetch items using our RESTful web service?
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用我们的RESTful网络服务获取项目？
- en: How can you delete items using our RESTful web service?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用我们的RESTful网络服务删除项目？
- en: How can you add items using our RESTful web service?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用我们的RESTful网络服务添加项目？
- en: How can you update items using our RESTful web service?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用我们的RESTful网络服务更新项目？
- en: How can you use queries with our RESTful web service?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用我们的RESTful网络服务使用查询？
- en: What is the OpenAPI Specification?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenAPI规范是什么？
- en: What is Swagger UI?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Swagger UI是什么？
- en: Further reading
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Packt has other resources available for learning about Spring Boot RESTful
    web services:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Packt提供了其他资源，用于学习Spring Boot RESTful网络服务：
- en: '*Postman Tutorial: Getting Started with API Testing [Video]* by Praveenkumar
    Bouna ([https://www.packtpub.com/product/postman-tutorial-getting-started-with-api-testing-video/9781803243351](https://www.packtpub.com/product/postman-tutorial-getting-started-with-api-testing-video/9781803243351))'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Praveenkumar Bouna的Postman教程：API测试入门[视频]* ([https://www.packtpub.com/product/postman-tutorial-getting-started-with-api-testing-video/9781803243351](https://www.packtpub.com/product/postman-tutorial-getting-started-with-api-testing-video/9781803243351))'
- en: '*Hands-On RESTful API Design Patterns and Best Practices* by Harihara Subramanian
    J and Pethuru Raj ([https://www.packtpub.com/product/hands-on-restful-api-design-patterns-and-best-practices/9781788992664](https://www.packtpub.com/product/hands-on-restful-api-design-patterns-and-best-practices/9781788992664))'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Harihara Subramanian J和Pethuru Raj的《动手实践RESTful API设计模式和最佳实践》* ([https://www.packtpub.com/product/hands-on-restful-api-design-patterns-and-best-practices/9781788992664](https://www.packtpub.com/product/hands-on-restful-api-design-patterns-and-best-practices/9781788992664))'
- en: Learn more on Discord
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask the author questions, and learn about new releases – follow the QR code below:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的Discord社区——在那里你可以分享反馈、向作者提问，并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/FullStackSpringBootReact4e](https://packt.link/FullStackSpringBootReact4e)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/FullStackSpringBootReact4e](https://packt.link/FullStackSpringBootReact4e)'
- en: '![](img/QR_Code10796108009382640.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code10796108009382640.png)'
