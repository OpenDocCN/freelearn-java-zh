- en: '*Chapter 11*: jOOQ Keys'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 11 章*：jOOQ 键'
- en: Choosing the proper type of keys for our tables has a significant benefit on
    our queries. jOOQ sustains this statement by supporting a wide range of keys,
    from the well-known unique and primary keys to the fancy embedded and synthetic/surrogate
    keys. The most commonly used synthetic identifiers (or surrogate identifiers)
    are numerical or UUIDs. In comparison with natural keys, surrogate identifiers
    don't have a meaning or a correspondent in the real world. A surrogate identifier
    can be generated by a Numerical Sequence Generator (for instance, an identity
    or sequence) or by a Pseudorandom Number Generator (for instance, a GUID or UUID).
    Moreover, let me use this context to recall that in clustered environments, most
    relational databases rely on *numerical sequences* and different offsets per node
    to avoid the risk of conflicts. Use *numerical sequences* instead of UUIDs because
    they require less memory than UUIDs (a UUID requires 16 bytes, while `BIGINT`
    requires 8 bytes and `INTEGER` 4 bytes) and the index usage is more performant.
    Moreover, since UUIDs are not sequential, they introduce performance penalties
    at a clustered indexes level. More precisely, we will discuss an issue known as
    *index fragmentation*, which is caused by the fact that UUIDs are random. Some
    databases (for instance, MySQL 8.0) come with significant improvements in mitigating
    UUID performance penalties (there are three new functions – `UUID_TO_BIN`, `BIN_TO_UUID`,
    and `IS_UUID`) while other databases are still prone to these issues. As Rick
    James highlights, *"If you cannot avoid UUIDs (which would be my first recommendation)
    then..."* It is recommended to read his article ([http://mysql.rjweb.org/doc.php/uuid](http://mysql.rjweb.org/doc.php/uuid))
    for a deeper understanding of the main issues and potential solutions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的表选择合适的键类型对我们的查询有显著的好处。jOOQ 通过支持广泛范围的键来维持这一说法，从众所周知的唯一键和主键到复杂的内嵌键和合成/代理键。最常用的合成标识符（或代理标识符）是数字或
    UUID。与自然键相比，代理标识符在现实世界中没有意义或对应物。代理标识符可以通过数值序列生成器（例如，一个身份或序列）或伪随机数生成器（例如，GUID 或
    UUID）生成。此外，让我利用这个上下文来回忆一下，在集群环境中，大多数关系型数据库依赖于 *数值序列* 和每个节点的不同偏移量来避免冲突的风险。使用 *数值序列*
    而不是 UUID，因为它们比 UUID 占用更少的内存（一个 UUID 需要 16 字节，而 `BIGINT` 需要 8 字节，`INTEGER` 需要 4
    字节），并且索引的使用性能更优。此外，由于 UUID 不是顺序的，它们在集群索引级别引入了性能惩罚。更确切地说，我们将讨论一个被称为 *索引碎片化* 的问题，这是由于
    UUID 是随机的。一些数据库（例如，MySQL 8.0）在缓解 UUID 性能惩罚方面有显著的改进（有三个新函数 – `UUID_TO_BIN`、`BIN_TO_UUID`
    和 `IS_UUID`），而其他数据库仍然容易受到这些问题的影响。正如 Rick James 所强调的，“如果你不能避免使用 UUID（这将是我首先推荐的做法），那么...”建议阅读他的文章([http://mysql.rjweb.org/doc.php/uuid](http://mysql.rjweb.org/doc.php/uuid))，以深入了解主要问题和潜在解决方案。
- en: 'For now, let''s get back to our chapter, which will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的章节，它将涵盖以下主题：
- en: Fetching a database-generated primary key
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取数据库生成的主键
- en: Suppressing a primary key return on updatable records
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可更新记录上抑制主键返回
- en: Updating a primary key of an updatable record
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新可更新记录的主键
- en: Using database sequences
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据库序列
- en: Inserting a SQL Server IDENTITY
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入 SQL Server IDENTITY
- en: Fetching the Oracle ROWID pseudo-column
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取 Oracle ROWID 伪列
- en: Comparing composite primary keys
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较复合主键
- en: Working with embedded keys
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内嵌键工作
- en: Working with jOOQ synthetic objects
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 jOOQ 合成对象
- en: Overriding primary keys
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖主键
- en: Let's get started!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter11](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter11).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在 GitHub 上找到：[https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter11](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter11)。
- en: Fetching the database-generated primary key
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取数据库生成的主键
- en: 'A typical scenario consists of fetching a database-generated (identity) primary
    key after an `INSERT` operation is executed via the `insertInto()`method or the
    updatable record''s `insert()`method. If you are using `insertInto()` (`DSL.insertInto()`
    or `DSLContext.insertInto()`), the database-generated primary key can be obtained
    via the `returningResult()`/`returning()` methods. For instance, the identity
    primary key of `SALE` is shaped in MySQL via `AUTO_INCREMENT`, in SQL Server via
    `IDENTITY`, and for historic reasons (because both now support standard SQL `IDENTITY`
    columns), in PostgreSQL and Oracle via database sequences. In all these cases,
    the generated identity primary key of `SALE` can be fetched as here (`SALE.SALE_ID`):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的场景是在通过`insertInto()`方法或可更新记录的`insert()`方法执行`INSERT`操作后获取数据库生成的（标识）主键。如果你使用`insertInto()`（`DSL.insertInto()`或`DSLContext.insertInto()`），可以通过`returningResult()`/`returning()`方法获取数据库生成的主键。例如，`SALE`的标识主键在MySQL中通过`AUTO_INCREMENT`，在SQL
    Server中通过`IDENTITY`，由于历史原因（因为现在两者都支持标准SQL `IDENTITY`列），在PostgreSQL和Oracle中通过数据库序列。在这些所有情况下，`SALE`生成的标识主键可以像这样获取（`SALE.SALE_ID`）：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Alternatively, a convenient approach relies on the `getIdentity()` method,
    as shown here:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，一种方便的方法依赖于`getIdentity()`方法，如下所示：
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'However, this approach is useful when your table has a single identity column;
    otherwise, it is better to explicitly list the identities that should be returned.
    However, don''t get me wrong here – even if some databases (for example, PostgreSQL)
    support multiple identities, that is quite an unusual approach, which personally
    I don''t like to use, but I''ll cover it in this chapter. Also, check this tweet
    to get more details: [https://twitter.com/lukaseder/status/1205046981833482240](https://twitter.com/lukaseder/status/1205046981833482240).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你的表只有一个标识列时，这种方法是有用的；否则，最好明确列出应该返回的标识。但是，请别误解我——即使某些数据库（例如，PostgreSQL）支持多个标识，这仍然是一种相当不寻常的方法，我个人不喜欢使用，但我会在本章中介绍它。此外，查看这条推文以获取更多详细信息：[https://twitter.com/lukaseder/status/1205046981833482240](https://twitter.com/lukaseder/status/1205046981833482240)。
- en: 'Now, the `insertedId` variable holds the database-generated primary key as
    a `Record1<Long>`. Getting the `long` value can be done via `fetchOne().value1()`
    or directly via `.fetchOneInto(long.class)`. The same practice is apparent for
    a bulk insert (a multi-record insert). This time, the generated primary keys are
    stored in `Result<Record1<Long>>` or `List<Long>`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`insertedId`变量持有数据库生成的标识主键作为`Record1<Long>`。可以通过`fetchOne().value1()`或直接通过`.fetchOneInto(long.class)`获取`long`值。对于批量插入（多记录插入）也是如此。这次，生成的标识主键存储在`Result<Record1<Long>>`或`List<Long>`中：
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For a special case when we cannot provide an identity, jOOQ allows us to use
    the handy `lastID()` method:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不能提供标识的特殊情况，jOOQ允许我们使用方便的`lastID()`方法：
- en: '[PRE18]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: However, the `lastID()` method has at least two shortcomings that deserve our
    attention. In a concurrent transactional environment (for instance, a web application),
    there is no guarantee that the returned value belongs to the previous `INSERT`
    statement, since a concurrent transaction can sneak another `INSERT` between our
    `INSERT` and the `lastID()` call. In such a case, the returned value belongs to
    the `INSERT` statement executed by the concurrent transaction. In addition, `lastID()`
    is not quite useful in the case of bulk inserts, since it returns only the last-generated
    primary key (but maybe this is exactly what you need).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`lastID()`方法至少有两个缺点值得我们关注。在一个并发事务环境中（例如，一个Web应用），没有保证返回的值属于之前的`INSERT`语句，因为并发事务可以在我们的`INSERT`和`lastID()`调用之间偷偷执行另一个`INSERT`。在这种情况下，返回的值属于并发事务执行的`INSERT`语句。此外，在批量插入的情况下，`lastID()`并不十分有用，因为它只返回最后一个生成的主键（但也许这正是你所需要的）。
- en: 'If you are inserting an updatable record, jOOQ will automatically return the
    generated identity primary key and populate the updatable record field, as shown
    here:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在插入一个可更新的记录，jOOQ将自动返回生成的标识主键并填充可更新记录的字段，如下所示：
- en: '[PRE25]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After insert, calling `sr.getSaleId()` returns the primary key generated by
    the database for this record. The same thing can be accomplished via jOOQ''s DAO
    while inserting a POJO:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在插入后，调用`sr.getSaleId()`将返回数据库为该记录生成的主键。同样的事情可以通过jOOQ的DAO在插入POJO时完成：
- en: '[PRE30]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This time, jOOQ set the generated primary key in the inserted POJO. You can
    find these examples in the *Keys* bundled code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，jOOQ将生成的标识主键设置在插入的POJO中。你可以在捆绑的*Keys*代码示例中找到这些示例。
- en: Suppressing a primary key return on updatable records
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在可更新记录上抑制主键返回
- en: 'In the previous section, you saw that jOOQ automatically fetches and sets the
    generated primary key for updatable records. Suppressing this action can be done
    via the `withReturnIdentityOnUpdatableRecord()` flag setting. In some dialects,
    a database round trip (the `lastID()` style) can be prevented, so this is mostly
    a performance feature. By default, this flag is `true`, but if we explicitly set
    it to `false`, then jOOQ will no longer attempt to fetch the generated primary
    key:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你看到 jOOQ 自动获取并设置可更新记录生成的主键。通过设置 `withReturnIdentityOnUpdatableRecord()`
    标志来抑制此操作。在某些方言中，可以防止数据库往返（`lastID()` 风格），所以这主要是一个性能特性。默认情况下，此标志为 `true`，但如果我们显式将其设置为
    `false`，那么 jOOQ 将不再尝试获取生成的主键：
- en: '[PRE36]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This time, calling `sr.getSaleId()` returns `null`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，调用 `sr.getSaleId()` 返回 `null`。
- en: Updating a primary key of an updatable record
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新可更新记录的主键
- en: As a good practice, a primary key should never be updated anyway. But, who am
    I to judge?!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种良好的实践，主键无论如何都不应该被更新。但是，我又能怎样评判呢？！
- en: 'By default, calling the `store()` method after changing (to a non-null value)
    the primary key of an updatable record previously loaded via jOOQ causes an `INSERT`
    statement to be executed. However, we can force jOOQ to generate and execute an
    `UPDATE` of the primary key via the `withUpdatablePrimaryKeys()` flag setting:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在通过 jOOQ 加载的可更新记录中更改（到非空值）主键后调用 `store()` 方法会导致执行 `INSERT` 语句。然而，我们可以通过设置
    `withUpdatablePrimaryKeys()` 标志来强制 jOOQ 生成并执行主键的 `UPDATE`：
- en: '[PRE43]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Of course, we can also update the primary key via an explicit `UPDATE`, and
    if you really have to do it, then go for this instead of a jOOQ flag:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以通过显式的 `UPDATE` 来更新主键，如果你真的必须这样做，那么就选择这种方法而不是 jOOQ 标志：
- en: '[PRE50]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: You can find these examples in the *Keys* bundled code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在捆绑的 *Keys* 代码中找到这些示例。
- en: Using database sequences
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据库序列
- en: To yield sequential numbers, databases such as PostgreSQL, SQL Server, and Oracle
    rely on sequences. A database sequence lives independently from tables – it can
    be associated with the primary key and non-primary key columns, it can be auto-generated
    (as in the case of PostgreSQL (`BIG`)`SERIAL`), it can be used across multiple
    tables, it can have independent permissions, it can have cycles, it can increment
    values in its own transactions to guarantee uniqueness across transactions using
    it, we can explicitly alter its values by setting minimum, maximum, increment,
    and current values, and so on.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成序列号，数据库如 PostgreSQL、SQL Server 和 Oracle 依赖于序列。数据库序列独立于表存在 – 它可以与主键和非主键列相关联，它可以自动生成（如
    PostgreSQL 的 (`BIG`)`SERIAL`），它可以在多个表中使用，它可以有独立的权限，它可以有循环，它可以在自己的事务中增加值以保证使用它的跨事务的唯一性，我们可以通过设置最小值、最大值、增量值和当前值来显式地更改其值，等等。
- en: 'For instance, let''s consider the following sequence (`employee_seq`), defined
    in our PostgreSQL schema for the `employee.employee_number` primary key:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑以下序列（`employee_seq`），它在我们的 PostgreSQL 架构中定义，用于 `employee.employee_number`
    主键：
- en: '[PRE54]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `employee_seq` sequence doesn''t produce sequence values automatically
    on your insertions, so the application must explicitly manipulate it. On the other
    hand, the `sale_seq` sequence produces sequence values automatically on your insertions,
    and it looks like the following code block (you''ll get an automatic value when
    the `SALE_ID` column is omitted from the `INSERT` statement or `DEFAULT` or `DEFAULT
    VALUES` is used; when users set `SALE_ID` to `NULL` explicitly, there''s going
    to be a constraint violation error):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`employee_seq` 序列在插入时不会自动生成序列值，因此应用程序必须显式地操作它。另一方面，`sale_seq` 序列在插入时会自动生成序列值，其代码块如下（当省略
    `INSERT` 语句中的 `SALE_ID` 列或使用 `DEFAULT` 或 `DEFAULT VALUES` 时，你会得到一个自动值；当用户显式地将
    `SALE_ID` 设置为 `NULL` 时，将会出现约束违反错误）：'
- en: '[PRE61]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'For each such sequence, the jOOQ Code Generator produces an `org.jooq.Sequence`
    instance in `Sequences` (take your time to check the `jooq.generated.Sequences`
    class). For `employee_seq`, we get this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个这样的序列，jOOQ 代码生成器在 `Sequences` 中生成一个 `org.jooq.Sequence` 实例（花点时间检查 `jooq.generated.Sequences`
    类）。对于 `employee_seq`，我们得到以下内容：
- en: '[PRE66]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The jOOQ API exposes several methods for obtaining information about a sequence.
    Among them, we have the following suggested methods (you can find out more in
    the jOOQ documentation):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ API 提供了几个用于获取序列信息的方法。其中，我们有以下建议方法（你可以在 jOOQ 文档中找到更多信息）：
- en: '[PRE70]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Besides these methods, we have three more that are very useful in daily tasks
    –`currval()`, `nextval()`, and `nextvals()`. The first one (`currval()`) attempts
    to return the *current* value in the sequence. This can be obtained in a `SELECT`
    statement:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些方法之外，我们还有三个在日常生活中非常有用的方法——`currval()`、`nextval()`和`nextvals()`。第一个方法（`currval()`）试图返回序列中的*当前*值。这可以在一个`SELECT`语句中获取：
- en: '[PRE75]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The second one, `nextval()`, attempts to return the *next* value in the sequence.
    It can be used as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个方法，`nextval()`，试图返回序列中的*下一个*值。它可以如下使用：
- en: '[PRE80]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'And here is a `SELECT` statement that fetches both, the current and the next
    value:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个同时获取当前值和下一个值的`SELECT`语句：
- en: '[PRE85]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: A potential issue of using sequences consists of selecting `currval()` from
    the sequence before *initializing* it within your session by selecting `nextval()`
    for it. Commonly, when you are in such a scenario, you'll get an explicit error
    that mentions that `currval()` is not yet defined in this session (for instance,
    in Oracle, this is ORA-08002). By executing `INSERT` or calling `nextval()` (for
    instance, in `SELECT` as the previous one), you'll initialize `currval()` as well.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用序列的一个潜在问题是，在会话中通过选择`nextval()`对其进行初始化之前，从序列中选择`currval()`。通常，当你处于这种场景时，你会得到一个明确的错误，指出在这个会话中`currval()`尚未定义（例如，在Oracle中，这是ORA-08002）。通过执行`INSERT`或调用`nextval()`（例如，在之前的`SELECT`中），你也会初始化`currval()`。
- en: 'If the sequence can produce values automatically then the best way to insert
    a new record is to simply omit the primary key field. Since `sale_seq` can produce
    values automatically, an `INSERT` can be like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果序列可以自动生成值，那么插入新记录的最佳方式是简单地省略主键字段。由于`sale_seq`可以自动生成值，一个`INSERT`可以像这样：
- en: '[PRE89]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The database will use `sale_seq` to assign a value to the `SALE_ID` field (the
    primary key of `SALE`). This is like using any other type of identity associated
    with a primary key.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库将使用`sale_seq`为`SALE_ID`字段（`SALE`的主键）分配一个值。这就像使用与主键关联的任何其他类型的标识符一样。
- en: Important Note
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: There is no need to explicitly call the `currval()` or `nextval()` method as
    long as you don't have a specific case that requires a certain sequence value
    from a sequence that is auto-generated (for example, from (`BIG`)`SERIAL`) or
    set as default (for example, as `NOT NULL DEFAULT NEXTVAL ("'sale_seq'")`). Simply
    omit the primary key field (or whatever field uses the sequence) and let the database
    generate it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你没有特定的情况需要从一个自动生成的序列（例如，从（大）`SERIAL`）或设置为默认值（例如，`NOT NULL DEFAULT NEXTVAL
    ("'sale_seq'")`）中获取特定的序列值，就没有必要显式调用`currval()`或`nextval()`方法。只需省略主键字段（或使用序列的任何字段）并让数据库生成它。
- en: 'However, if the sequence cannot automatically produce values (for instance,
    `employee_seq`), then an `INSERT` statement must rely on an explicit call of the
    `nextval()` method:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果序列不能自动生成值（例如，`employee_seq`），那么`INSERT`语句必须依赖于显式调用`nextval()`方法：
- en: '[PRE94]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Pay attention to how you interpret and use the `currval()` and `nextval()`
    methods. Once you fetch a sequence value via `nextval()` (for instance, via `SELECT`),
    you can safely use it later in subsequent queries (`INSERT`) because the database
    will not give this value to other (concurrent) transactions. So, `nextval()` is
    safe to be used by multiple concurrent transactions. On the other hand, in the
    case of `currval()`, you have to be aware of some aspects. Check this code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你如何解释和使用`currval()`和`nextval()`方法。一旦你通过`nextval()`（例如，通过`SELECT`）获取到一个序列值，你就可以在后续的查询（`INSERT`）中安全地使用它，因为数据库不会将这个值给其他（并发）事务。所以，`nextval()`可以安全地被多个并发事务使用。另一方面，在`currval()`的情况下，你必须注意一些方面。查看以下代码：
- en: '[PRE99]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: So, between the previous `INSERT` and `SELECT` of the current value, another
    transaction can execute `INSERT`, and `currval()` is modified/incremented (generally
    speaking, another transaction performs an action that updates the current value).
    This means that there is no guarantee that `cr` holds the value of `SALE_ID` of
    our `INSERT` (`SALE_ID` and `cr` can be different). If all we need is to get `SALE_ID`
    of our `INSERT`, then the best approach is to rely on `returningResult(SALE.SALE_ID)`,
    as you saw in the *Fetching a database-generated primary key* section.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在之前的`INSERT`和获取当前值的`SELECT`操作之间，另一个事务可以执行`INSERT`，并且`currval()`会被修改/增加（一般来说，另一个事务执行的操作会更新当前值）。这意味着没有保证`cr`包含我们`INSERT`的`SALE_ID`值（`SALE_ID`和`cr`可能不同）。如果我们只需要获取我们`INSERT`的`SALE_ID`，那么最好的方法就是依赖于`returningResult(SALE.SALE_ID)`，正如你在*获取数据库生成的主键*部分所看到的。
- en: 'Obviously, attempting to use the fetched `currval()` in subsequent `UPDATE`,
    `DELETE`, and so on statements falls under the same statement. For instance, there
    is no guarantee that the following `UPDATE` will update our previous `INSERT`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，尝试在随后的 `UPDATE`、`DELETE` 等语句中使用获取的 `currval()` 落在相同的语句之下。例如，不能保证下面的 `UPDATE`
    会更新我们之前的 `INSERT`：
- en: '[PRE106]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Another approach that should be avoided in a concurrent transactional environment
    is the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发事务环境中应避免的另一种方法是以下：
- en: '[PRE110]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Even if this looks like a single query statement, it is not. This is materialized
    in a `SELECT` of the current value followed by a `DELETE`. Between these two statements,
    a concurrent transaction can still perform an `INSERT` that alters the current
    value (or, generally speaking, any kind of action that modifies/advances a sequence
    and returns a new value). Also, pay attention to these kinds of queries:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这看起来像是一个单独的查询语句，它也不是。这体现在一个 `SELECT` 当前值之后的 `DELETE`。在这两个语句之间，并发事务仍然可以执行一个
    `INSERT`，该 `INSERT` 会改变当前值（或者，一般而言，任何修改/推进序列并返回新值的操作）。此外，请注意这些类型的查询：
- en: '[PRE113]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'This renders a single `DELETE`, as shown here (the PostgreSQL dialect):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得单个 `DELETE` 变得可行，如下所示（这是 PostgreSQL 语法）：
- en: '[PRE116]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: This time, you definitely refer to the latest current value, whatever it is.
    For instance, this may result in deleting the latest inserted record (not necessarily
    by us), or it may hit a current value that is not associated with any record yet.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，你肯定是指最新的当前值，无论它是什么。例如，这可能导致删除最新的插入记录（不一定是我们插入的），或者它可能遇到尚未与任何记录关联的当前值。
- en: 'Furthermore, performing multi-inserts or batch inserts can take advantage of
    inlined `nextval()` references or pre-fetch a certain number of values via `nextvals()`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，执行多行插入或批量插入可以利用内联的 `nextval()` 引用或通过 `nextvals()` 预取一定数量的值：
- en: '[PRE118]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'At this point, `ids1`, `ids2`, and `ids3` hold in memory 10 values that can
    be used in subsequent queries. Until we exhaust these values, there is no need
    to fetch others. This way, we reduce the number of database round trips. Here
    is an example of a multi-insert:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`ids1`、`ids2` 和 `ids3` 在内存中保存了 10 个可以用于后续查询的值。在我们耗尽这些值之前，没有必要去获取其他值。这样，我们减少了数据库往返的次数。以下是一个多行插入的示例：
- en: '[PRE123]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'The pre-fetched values can be used to pre-set IDs of `Record` as well:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 预取的值可以用来预先设置 `Record` 的 ID：
- en: '[PRE129]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: You can find these examples in the *Keys* bundled code.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在捆绑的 *Keys* 代码中找到这些示例。
- en: Inserting a SQL Server IDENTITY
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入 SQL Server IDENTITY
- en: 'This is not the first time in this book that we have talked about inserting
    SQL Server `IDENTITY` values, but let''s consider this section a must-have for
    this chapter. The problem consists of the fact that SQL Server doesn''t allow
    us to specify an explicit value for an `IDENTITY` field as the `PRODUCT` primary
    key:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们不是第一次讨论插入 SQL Server `IDENTITY` 值，但让我们将这一节视为本章的必备内容。问题在于 SQL Server
    不允许我们为 `PRODUCT` 主键的 `IDENTITY` 字段指定一个显式值：
- en: '[PRE132]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'In other words, the following `INSERT` statement will cause the following error
    – *Cannot insert explicit value for identity column in table ''product'' when
    IDENTITY_INSERT is set to OFF*:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，以下 `INSERT` 语句将导致以下错误 – *当 `IDENTITY_INSERT` 设置为 OFF 时，无法向表 'product' 的标识列插入显式值*：
- en: '[PRE136]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'So, the solution to this error is contained in the message. We have to set
    `IDENTITY_INSERT` to `ON`. However, this should be done in the SQL Server *current
    session context*. In other words, we have to issue the settings of `IDENTITY_INSERT`
    and the actual `INSERT` statements in the same batch, as shown here:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个错误的解决方案包含在消息中。我们必须将 `IDENTITY_INSERT` 设置为 `ON`。然而，这应该在 SQL Server *当前会话上下文*
    中完成。换句话说，我们必须在同一批中发出 `IDENTITY_INSERT` 的设置和实际的 `INSERT` 语句，如下所示：
- en: '[PRE141]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: This time, there is no issue with inserting it into the `IDENTITY` column. You
    can find these examples in the *Keys* (for SQL Server) bundled code.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，将值插入 `IDENTITY` 列没有问题。你可以在捆绑的 *Keys*（针对 SQL Server）代码中找到这些示例。
- en: Fetching the Oracle ROWID pseudo-column
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取 Oracle ROWID 伪列
- en: If you are a fan of the Oracle database, then it is impossible not to have heard
    about the ROWID pseudo-column. However, as a quick reminder, the ROWID pseudo-column
    is associated with each row by Oracle, and its main goal is to return the address
    of the row. The information contained by ROWID can be used to locate a certain
    row. In jOOQ, we can refer to ROWID via the `rowid()` method.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个Oracle数据库的粉丝，那么不可能没有听说过ROWID伪列。然而，作为一个快速提醒，ROWID伪列与Oracle中的每一行相关联，其主要目标是返回行的地址。ROWID包含的信息可以用来定位特定的行。在jOOQ中，我们可以通过`rowid()`方法引用ROWID。
- en: 'For instance, the following statement inserts a new `SALE` and fetches the
    generated primary key and the ROWID:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下语句插入一个新的`SALE`并获取生成的主键和ROWID：
- en: '[PRE148]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'The `rowid()` method returns a `String`, representing the value of ROWID (for
    instance, *AAAVO3AABAAAZzBABE*). We can use the ROWID for subsequent queries,
    such as locating a record:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`rowid()`方法返回一个`String`，表示ROWID的值（例如，*AAAVO3AABAAAZzBABE*）。我们可以使用ROWID进行后续查询，例如定位一条记录：'
- en: '[PRE154]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'However, as Lukas Eder shared: *"ROWIDs are not guaranteed to remain stable,
    so clients should never keep them around for long (for instance, outside of a
    transaction). But they can be useful to identify a row in a table without a primary
    key (for instance, a logging table)."*'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如Lukas Eder所分享的：*"ROWIDs不保证保持稳定，因此客户端永远不应该长时间保留它们（例如，在事务之外）。但它们可以用来在没有主键的表中标识一行（例如，日志表）。"*
- en: In the bundled code, *Keys* (for Oracle), you can also see an example of using
    `rowid()` in the `SELECT`, `UPDATE`, and `DELETE` statements.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，*Keys*（针对Oracle），你还可以看到在`SELECT`、`UPDATE`和`DELETE`语句中使用`rowid()`的示例。
- en: Comparing composite primary keys
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较复合主键
- en: 'By definition, a composite primary key involves two or more columns that should
    uniquely identify a record. A composite primary key is usually a natural key (even
    if it is composed of references to surrogate keys) and can often be preferable
    to surrogate keys in relationship tables: [https://blog.jooq.org/2019/03/26/the-cost-of-useless-surrogate-keys-in-relationship-tables/](https://blog.jooq.org/2019/03/26/the-cost-of-useless-surrogate-keys-in-relationship-tables/).
    This means that predicates based on composite keys must contain all the involved
    columns. For instance, the `PRODUCTLINE` table has a composite key as (`PRODUCT_LINE`,
    `CODE`), and we can write a predicate for fetching a certain record by chaining
    the fields of the composite key via `and()`, as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，复合主键涉及两个或多个列，这些列应唯一标识一条记录。复合主键通常是自然键（即使它由代理键的引用组成），在关系表中通常比代理键更可取：[https://blog.jooq.org/2019/03/26/the-cost-of-useless-surrogate-keys-in-relationship-tables/](https://blog.jooq.org/2019/03/26/the-cost-of-useless-surrogate-keys-in-relationship-tables/)。这意味着基于复合键的谓词必须包含所有涉及的列。例如，`PRODUCTLINE`表有一个复合键为（`PRODUCT_LINE`，`CODE`），我们可以通过`and()`方法链式连接复合键的字段来编写一个用于获取特定记录的谓词，如下所示：
- en: '[PRE158]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Alternatively, we can separate fields from values using `row()` (the `eq()`
    method doesn''t require an explicit `row()` constructor, so use it as you like):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`row()`（`eq()`方法不需要显式`row()`构造函数，所以可以随意使用）来将字段与值分开：
- en: '[PRE162]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Using `row()` is also useful in conjunction with `in()`, `notIn()`, and so
    on:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`row()`与`in()`、`notIn()`等一起使用也是很有用的：
- en: '[PRE166]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Practically, in all these examples (available in *Keys*), you have to ensure
    that you don't forget any column of the composite key. This may become a struggle
    for composite keys containing more than two fields and/or in cases where the predicates
    involve more related conditions, and it is difficult to visually isolate the composite
    key fields.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在这些示例（在*Keys*中可用）中，你必须确保不要忘记复合键的任何列。对于包含两个以上字段和/或谓词涉及更多相关条件的复合键，这可能会变得很困难，并且难以从视觉上隔离复合键字段。
- en: A better approach is to employ embedded keys.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的方法是使用嵌入式键。
- en: Working with embedded keys
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与嵌入式键一起工作
- en: As part of the embeddable types introduced in [*Chapter 7*](B16833_07.xhtml#_idTextAnchor110),
    *Types, Converters, and Bindings,* we have jOOQ-embedded keys. An embedded key
    is materialized by the jOOQ Code Generator into the implementation of the jOOQ
    `org.jooq.EmbeddableRecord` interface and a handy POJO class. An embedded key
    extends the default implementation of the `org.jooq.EmbeddableRecord` interface,
    which is `org.jooq.impl.EmbeddableRecordImpl`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 作为在[*第7章*](B16833_07.xhtml#_idTextAnchor110)“类型、转换器和绑定”中引入的嵌入类型的一部分，我们有jOOQ嵌入键。嵌入键由jOOQ代码生成器实现为jOOQ
    `org.jooq.EmbeddableRecord`接口的实现和一个方便的POJO类。嵌入键扩展了`org.jooq.EmbeddableRecord`接口的默认实现，即`org.jooq.impl.EmbeddableRecordImpl`。
- en: We can define embedded keys for primary and unique keys. Practically, we indicate
    to jOOQ the primary/unique keys that should become embedded keys, and jOOQ will
    generate the corresponding artifacts for each primary/unique key, as well as for
    each foreign key referencing these primary/unique keys. Roughly, embedded keys
    mirror the primary/unique keys and the corresponding foreign keys in Java classes.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为主键和唯一键定义嵌入键。实际上，我们向jOOQ指示哪些主键/唯一键应该成为嵌入键，然后jOOQ将为每个主键/唯一键以及每个引用这些主键/唯一键的外键生成相应的工件。大致上，嵌入键反映了Java类中的主键/唯一键以及对应的外键。
- en: 'However, in order to employ embedded keys, we need the following configuration:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了使用嵌入键，我们需要以下配置：
- en: '[PRE171]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: Most probably, you'll not rely on a `.*` regular expression, since you'll not
    want to transform all your primary/unique keys into embedded keys. For instance,
    you may prefer to use embedded keys for composite keys only, so you have to use
    the proper regular expression for your case. Speaking about composite keys, how
    about creating an embedded key for the composite key of `PRODUCTLINE` (introduced
    in the previous section)?
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，您不会依赖于`.*`正则表达式，因为您不会希望将所有主键/唯一键转换为嵌入键。例如，您可能只想为组合键使用嵌入键，因此您必须为您的特定情况使用正确的正则表达式。说到组合键，为什么不创建一个嵌入键用于`PRODUCTLINE`（在上一节中介绍）的组合键呢？
- en: '[PRE186]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: Indicate to jOOQ that we are interested in the (`product_line`, `code`) primary
    key via `<embeddablePrimaryKeys>productline_pk</embeddablePrimaryKeys>`, where
    `productline_pk` represents the name of the constraint that defines our composite
    primary key (if you want to list multiple constraints/primary keys, then use `|`
    as a separator).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`<embeddablePrimaryKeys>productline_pk</embeddablePrimaryKeys>`指示jOOQ我们感兴趣的（`product_line`，`code`）主键，其中`productline_pk`代表定义我们的组合主键的约束名称（如果您想列出多个约束/主键，则使用`|`作为分隔符）。
- en: Important Note
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'As a rule of thumb, it''s always a good idea to explicitly name your constraints.
    This way, you never have to bother with dealing with vendor-specific generated
    names and potential issues. If you are not convinced that you should always name
    your constraints, then I suggest you read this meaningful article: [https://blog.jooq.org/how-to-quickly-rename-all-primary-keys-in-oracle/](https://blog.jooq.org/how-to-quickly-rename-all-primary-keys-in-oracle/).'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条经验法则，始终明确命名您的约束是一个好主意。这样，您就永远不必担心处理供应商特定的生成名称和潜在问题。如果您不确定是否应该始终命名您的约束，那么我建议您阅读这篇有意义的文章：[https://blog.jooq.org/how-to-quickly-rename-all-primary-keys-in-oracle/](https://blog.jooq.org/how-to-quickly-rename-all-primary-keys-in-oracle/)。
- en: However, notice that MySQL ignores the constraint names on the primary key and
    defaults all to `PRIMARY`. In such a case, you cannot refer to a composite primary
    key via the name of its constraint but instead as `KEY_tablename_PRIMARY`. For
    instance, instead of `productline_pk`, use `KEY_productline_PRIMARY`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，MySQL忽略了主键上的约束名称，并将所有默认设置为`PRIMARY`。在这种情况下，您不能通过约束名称引用组合主键，而必须作为`KEY_tablename_PRIMARY`来引用。例如，不要使用`productline_pk`，而应使用`KEY_productline_PRIMARY`。
- en: 'At this point, jOOQ is ready to generate the classes for this embedded key,
    but let''s take another action and customize the names of these classes. At this
    point, jOOQ relies on the default matcher strategy, so the names will be `ProductlinePkRecord.java`
    and `ProductlinePk.java`. But, we prefer `EmbeddedProductlinePkRecord.java` and
    `EmbeddedProductlinePk.java` respectively. As you already know, whenever we talk
    about renaming jOOQ things, we can rely on a configurative/programmatic matcher
    strategy and regular expressions (note that the `(?i:...)` directive is a thing
    to render the expression case-insensitive). In this case, we have the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，jOOQ已经准备好为这个内嵌键生成类，但让我们再采取一个动作，并自定义这些类的名称。在这个阶段，jOOQ依赖于默认的匹配策略，所以名称将是`ProductlinePkRecord.java`和`ProductlinePk.java`。但是，我们更喜欢`EmbeddedProductlinePkRecord.java`和`EmbeddedProductlinePk.java`。正如您已经知道的，每当我们要谈论重命名jOOQ相关的内容时，我们可以依赖于配置/程序匹配策略和正则表达式（注意，`(?i:...)`指令是一个使表达式不区分大小写的指令）。在这种情况下，我们有以下内容：
- en: '[PRE193]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: Okay, so far, so good! At this point, the jOOQ Code Generator is ready to materialize
    our embedded key in `EmbeddedProductlinePkRecord.java` and `EmbeddedProductlinePk.java`.
    Also, jOOQ generates the `PRODUCTLINE_PK` field in the `Productline` class (see
    `jooq.generated.tables.Productline`), representing the embedded primary key.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，到目前为止一切顺利！在这个阶段，jOOQ代码生成器已经准备好在我们的`EmbeddedProductlinePkRecord.java`和`EmbeddedProductlinePk.java`中实现内嵌键。此外，jOOQ在`Productline`类中生成`PRODUCTLINE_PK`字段（见`jooq.generated.tables.Productline`），代表内嵌的主键。
- en: 'Moreover, the jOOQ Code Generator searches the foreign keys referencing our
    composite key, and it should find the following two:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，jOOQ代码生成器搜索引用我们的复合键的外键，并且应该找到以下两个：
- en: '[PRE210]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: For the `product_productline_fk` and `productlinedetail_productline_fk` constraints
    (of our foreign keys), jOOQ generates the `PRODUCT_PRODUCTLINE_FK` field in the
    `Product` class (see `jooq.generated.tables.Product`) and the `PRODUCTLINEDETAIL_PRODUCTLINE_FK`
    field in the `Productlinedetail` class (see `jooq.generated.tables.Productlinedetail`).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`product_productline_fk`和`productlinedetail_productline_fk`约束（我们的外键），jOOQ在`Product`类中生成`PRODUCT_PRODUCTLINE_FK`字段（见`jooq.generated.tables.Product`）和`PRODUCTLINEDETAIL_PRODUCTLINE_FK`字段在`Productlinedetail`类中（见`jooq.generated.tables.Productlinedetail`）。
- en: 'Now, let''s practice! For instance, let''s assume that we want to fetch the
    composite primary key of `PRODUCTLINE` and the creation date. Most probably, without
    using the embedded key, our `SELECT` statement will be something like this:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来练习一下！例如，假设我们想要获取`PRODUCTLINE`的复合主键和创建日期。很可能会这样，如果我们不使用内嵌键，我们的`SELECT`语句可能如下所示：
- en: '[PRE226]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: 'We know that `PRODUCT_LINE` and `CODE` form our composite key. However, for
    someone who is not very familiar with our schema, it will be more convenient and
    less risky to rely on the `PRODUCTLINE_PK` embedded key and write this:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道`PRODUCT_LINE`和`CODE`构成了我们的复合键。然而，对于不太熟悉我们模式的人来说，依赖`PRODUCTLINE_PK`内嵌键并编写如下内容会更方便、更安全：
- en: '[PRE228]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: Obviously, this is less verbose and much more expressive. There is no risk of
    forgetting a field of the composite key or mixing composite key fields with other
    fields (which just increases confusion), and we can add/remove a column from the
    composite key without modifying this code. Once we rerun the Code Generator, jOOQ
    will shape `PRODUCTLINE_PK` accordingly.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这更简洁，更具表达力。没有忘记复合键字段或混淆复合键字段与其他字段（这只会增加混淆）的风险，并且我们可以在不修改此代码的情况下添加/删除复合键的列。一旦我们重新运行代码生成器，jOOQ将相应地调整`PRODUCTLINE_PK`。
- en: 'We can access data via getters, as shown here:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过getter来访问数据，如下所示：
- en: '[PRE231]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'Moreover, since the embedded key takes advantage of a generated POJO as well,
    we can fetch the composite key directly in the POJO. Look at how cool this is:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于内嵌键还利用了生成的POJO，我们可以在POJO中直接获取复合键。看看这是多么酷：
- en: '[PRE236]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: The `EmbeddedProductlinePk` POJO exposes getters and setters to access the parts
    of the embedded composite key.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`EmbeddedProductlinePk` POJO公开getter和setter来访问内嵌复合键的各个部分。'
- en: Important Note
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Embedded keys are the embeddable types most prone to overlapping. By default,
    jOOQ tries to elegantly solve each overlapping case to our benefit, but when the
    ambiguity cannot be clarified, jOOQ will log such cases, and it's your job to
    act accordingly.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 内嵌键是易于发生重叠的内嵌类型。默认情况下，jOOQ试图优雅地解决每个重叠情况以对我们有利，但当歧义无法澄清时，jOOQ将记录这些情况，而您需要相应地采取行动。
- en: 'Let''s go further and see other examples. For instance, searching a composite
    key in a certain collection of composite keys can be done, as shown here:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更进一步，看看其他例子。例如，在某个复合键集合中搜索复合键，可以像下面这样完成：
- en: '[PRE241]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: 'Alternatively, joining `PRODUCTLINE` and `PRODUCT` can be done, as shown here
    (both the primary and foreign keys produce the primary key record):'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以像下面这样连接`PRODUCTLINE`和`PRODUCT`（主键和外键都生成主键记录）：
- en: '[PRE246]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: Again, the code is less verbose and more expressive. However, more importantly,
    there is no risk of forgetting a column of the composite key in the join predicate.
    In addition, since both primary and foreign keys produce the primary key record,
    the predicate is valid only if we rely on matching primary/foreign key columns.
    This goes beyond type checking, since there is no risk of comparing wrong fields
    (for instance, fields that don't belong to the composite key but have the same
    type as the fields of the composite key).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，代码更加简洁且更具表现力。然而，更重要的是，没有忘记在连接谓词中复合键列的风险。此外，由于主键和外键都生成主键记录，因此谓词只有在依赖于匹配的主键/外键列时才是有效的。这超出了类型检查的范围，因为没有比较错误字段的风险（例如，不属于复合键但与复合键字段类型相同的字段）。
- en: 'As Lukas Eder mentioned: *"The type checking aspect is also interesting for
    single-column key types. With embeddable types, column types become "semantic,"
    and what would otherwise be two compatible Field<Long> columns no longer are compatible.
    So, specifically in the case of JOIN predicates, it will no longer be possible
    to accidentally compare the wrong columns in on(). This could even help detect
    a forgotten foreign key constraint."* ([https://twitter.com/anghelleonard/status/1499751304532533251](https://twitter.com/anghelleonard/status/1499751304532533251))'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 正如Lukas Eder所说：“对于单列键类型，类型检查方面也很有趣。对于可嵌入的类型，列类型变得“语义化”，原本兼容的两个Field<Long>列不再兼容。所以，具体到JOIN谓词的情况，在on()中就不再可能意外比较错误的列。这甚至可以帮助检测遗忘的外键约束。”([https://twitter.com/anghelleonard/status/1499751304532533251](https://twitter.com/anghelleonard/status/1499751304532533251))
- en: 'This is a good opportunity to reflect on your favorite way to express the `JOIN`
    predicate with composite keys in jOOQ. The following figure summarizes several
    approaches, including a simple `and()`, using `row()`, an implicit join, a synthetic
    `onKey()`, and embedded keys:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个反思你最喜欢的在jOOQ中表达复合键JOIN谓词方式的好机会。以下图总结了几个方法，包括简单的`and()`，使用`row()`，隐式连接，合成的`onKey()`和嵌入键：
- en: '![Figure 11.1 – The JOIN predicate with composite keys'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.1 – 使用复合键的JOIN谓词'
- en: '](img/Figure_11.1.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_11.1.jpg](img/Figure_11.1.jpg)'
- en: Figure 11.1 – The JOIN predicate with composite keys
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 使用复合键的JOIN谓词
- en: 'How about updating/deleting/inserting an embedded key? Well, these examples
    speak for themselves:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如何更新/删除/插入一个嵌入键？嗯，这些例子已经说明了一切：
- en: '[PRE253]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: Practice these examples in *EmbeddedCompositeKeys* (for SQL Server and Oracle).
    Alternatively, if you prefer to start with embedded keys for simple primary keys,
    then you can check out the *EmbeddedSimpleKeys* application (for SQL Server and
    Oracle). Next, let's talk about jOOQ synthetic objects.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在*EmbeddedCompositeKeys*（适用于SQL Server和Oracle）中练习这些例子。或者，如果你更喜欢从嵌入键开始，用于简单的主键，那么你可以查看*EmbeddedSimpleKeys*应用程序（适用于SQL
    Server和Oracle）。接下来，让我们谈谈jOOQ合成对象。
- en: Working with jOOQ synthetic objects
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用jOOQ合成对象
- en: jOOQ *synthetic objects* is a powerful and exciting feature introduced in version
    3.14 that reveals its full usability with database (updatable) views, databases
    that you cannot but want to alter, and legacy databases that have some *missing
    parts*. By *missing parts*, we mean identities, primary keys, unique keys, and
    foreign keys that simply don't exist, or do exist but are not enabled or reported
    by the database (and are not present in the database metadata). The jOOQ Code
    Generator can tackle this aspect by producing synthetic objects that emulate these
    *missing parts*. Let's adopt the learning by example technique to see how synthetic
    objects work.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ *合成对象*是3.14版本中引入的一个强大而令人兴奋的功能，它通过数据库（可更新）视图、你不得不想要更改的数据库以及一些*缺失部分*的遗留数据库完全展示了其可用性。通过*缺失部分*，我们指的是不存在或存在但未启用或由数据库（以及不在数据库元数据中）报告的标识、主键、唯一键和外键。jOOQ代码生成器可以通过生成模拟这些*缺失部分*的合成对象来处理这一方面。让我们采用示例学习技术来看看合成对象是如何工作的。
- en: Synthetic primary/foreign keys
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合成主键/外键
- en: 'Let''s consider that we have the following two database views (in PostgreSQL):'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下两个数据库视图（在PostgreSQL中）：
- en: '[PRE266]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: Exactly as in the case of regular tables, jOOQ generates the corresponding records,
    tables, and POJOs for these views, so you'll have `CustomerMasterRecord` (a non-updatable
    record because the view is non-updatable) and `OfficeMasterRecord` (an updatable
    record because the view is updatable) in `jooq.generated.tables.records`, and
    `CustomerMaster` and `OfficeMaster` in `jooq.generated.tables` and `jooq.generated.tables.pojos`
    respectively.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 正如常规表的情况一样，jOOQ为这些视图生成相应的记录、表和POJOs，因此你将在`jooq.generated.tables.records`中拥有`CustomerMasterRecord`（一个不可更新的记录，因为视图是不可更新的）和`OfficeMasterRecord`（一个可更新的记录，因为视图是可更新的），分别在`jooq.generated.tables`和`jooq.generated.tables.pojos`中拥有`CustomerMaster`和`OfficeMaster`。
- en: 'Next, let''s indulgently assume that a triad (`country`, `state`, and `city`)
    uniquely identifies a customer and an office, and we want to find customers that
    are in the same area as an office. For this, we can write `LEFT JOIN`, as shown
    in the following:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们宽容地假设一个三元组（`country`、`state`和`city`）唯一地标识了一个客户和一个办公室，并且我们想要找到与办公室在同一地区的客户。为此，我们可以编写`LEFT
    JOIN`，如下所示：
- en: '[PRE285]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: Look at the `JOIN` statement's predicate! It is verbose and prone to mistakes.
    Moreover, if we modify (for instance, rename or remove) any of the columns involved
    in this predicate, then we have to adjust this predicate as well. However, there
    is nothing we can do, since a database view doesn't support primary/foreign keys,
    right? Actually, here is exactly where synthetic keys enter the scene. If jOOQ
    were able to give us a composite synthetic primary key for `OFFICE_MASTER` and
    a synthetic foreign key for `CUSTOMER_MASTER` referencing the `OFFICE_MASTER`
    synthetic primary key, then we could simplify and reduce the risk of mistakes
    in our `JOIN`. Practically, we could express our `JOIN` as an implicit `JOIN`
    or via `onKey()` exactly as in the case of regular tables.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 看看`JOIN`语句的谓词！它很冗长且容易出错。此外，如果我们修改（例如，重命名或删除）涉及此谓词的任何列，那么我们还得调整这个谓词。然而，我们无能为力，因为数据库视图不支持主键/外键，对吧？实际上，这正是合成键登场的地方。如果jOOQ能够为我们提供`OFFICE_MASTER`的合成复合主键和引用`OFFICE_MASTER`合成主键的合成外键，那么我们就可以简化并减少`JOIN`中的错误风险。实际上，我们可以将`JOIN`表达为隐式`JOIN`或通过`onKey()`，就像常规表的情况一样。
- en: However, remember that we said to *indulgently assume the uniqueness*. Note
    that we don't even need to make an assumption of uniqueness for the natural key
    (`country`, `state`, and `city`). Synthetic **primary keys/unique keys** (**PK/UK**)
    can even be used to enable some cool features for things that aren't actually
    candidate keys, or even unique. For example, there may be hundreds of reports
    that calculate stuff based on this "location relationship," and normalizing is
    not possible because this is a data warehouse, and so on.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请记住我们所说的**宽容地假设唯一性**。请注意，我们甚至不需要对自然键（`country`、`state`和`city`）假设唯一性。合成**主键/唯一键**（**PK/UK**）甚至可以用来为实际上不是候选键或甚至唯一的事物启用一些酷炫的功能。例如，可能有数百份基于这种“位置关系”的计算报告，而标准化是不可能的，因为这是一个数据仓库，等等。
- en: 'Going further, jOOQ synthetic keys are shaped at the configuration level. For
    Maven and standalone configuration, we need the following intuitive snippet of
    code that defines the `office_master_pk` synthetic composite primary key and the
    `office_master_fk` synthetic foreign key (you should have no problem understanding
    this code by simply following the tag''s name and its content in the context of
    previous database views):'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步来说，jOOQ的合成键在配置级别上形成。对于Maven和独立配置，我们需要以下直观的代码片段，它定义了`office_master_pk`合成复合主键和`office_master_fk`合成外键（你应该可以通过简单地跟随标签的名称及其在先前数据库视图中的内容来理解这段代码）：
- en: '[PRE298]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: You can find the guidance for Gradle and the programmatic approach (which, in
    jOOQ style, is very intuitive as well) in the jOOQ manual.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在jOOQ手册中找到关于Gradle和编程方法的指导（在jOOQ风格中，这种方法同样直观）。
- en: 'Now, after running the jOOQ Code Generator, our `JOIN` can take advantage of
    the generated synthetic keys and be simplified via the synthetic `onKey()`, introduced
    in [*Chapter 6*](B16833_06.xhtml#_idTextAnchor093), *Tackling Different Kinds
    of JOIN Statements*. So, now we can write this:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在运行jOOQ代码生成器之后，我们的`JOIN`可以利用生成的合成键，并通过在[*第6章*](B16833_06.xhtml#_idTextAnchor093)中引入的合成`onKey()`来简化，该章节是*处理不同类型的JOIN语句*。因此，现在我们可以这样写：
- en: '[PRE331]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: '[PRE333]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '[PRE335]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '[PRE338]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: In comparison to the previous approach, this is less verbose, less prone to
    mistakes, and robust against subsequent modification of the columns involved with
    the synthetic key. Of course, you can use `onKey()` to write `INNER JOIN` and
    `RIGHT JOIN` statements and so on. However, without synthetic keys, the usage
    of `onKey()` leads to `DataAccessException` – *No matching Key found between tables
    ["classicmodels"."customer_master"] and ["classicmodels"."office_master"]*.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的方法相比，这更简洁，更不容易出错，并且对合成键涉及的列的后续修改具有鲁棒性。当然，你可以使用`onKey()`来编写`INNER JOIN`和`RIGHT
    JOIN`语句等。然而，没有合成键，使用`onKey()`会导致`DataAccessException` - *在表["classicmodels"."customer_master"]和["classicmodels"."office_master"]之间没有找到匹配的键*。
- en: Even if `onKey()` works just fine, you'll most probably find synthetic `onKey()`,
    which can lead to ambiguities in complex `JOIN` graphs (or even in simple ones),
    implicit joins are always non-ambiguous.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`onKey()`工作得很好，你很可能会发现合成`onKey()`，这可能导致复杂`JOIN`图（甚至简单图）中的歧义。隐式连接总是无歧义的。
- en: 'So, sticking to `LEFT JOIN`, the previous `JOIN` can be simplified and reinforced
    even more by adopting an implicit `JOIN`:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，坚持使用`LEFT JOIN`，之前的`JOIN`可以通过采用隐式`JOIN`来简化并进一步增强：
- en: '[PRE341]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '[PRE346]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: '[PRE347]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: So cool! There are no explicit columns in the join predicate, and we can modify
    the composite key without risks! Once we run the jOOQ Code Generator to reflect
    the changes, this code will work out of the box.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 太酷了！连接谓词中没有显式列，我们可以修改复合键而没有任何风险！一旦我们运行jOOQ代码生成器来反映这些更改，这段代码就会自动工作。
- en: 'However, the implicit join example here might lead to a peculiar weirdness.
    Since this is a synthetic foreign key, and the synthetic primary key isn''t actually/truly
    unique (we''ve just indulgently assumed the uniqueness), projecting an implicit
    join path means that we might get a Cartesian Product just from the projection,
    which is very surprising in SQL. A projection should never affect the cardinality
    of the result, but here we are... Perhaps this is a good opportunity to explore
    the `UNIQUE()` predicate to check whether their "candidate" key is actually unique:
    [https://www.jooq.org/doc/latest/manual/sql-building/conditional-expressions/unique-predicate/](https://www.jooq.org/doc/latest/manual/sql-building/conditional-expressions/unique-predicate/).'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里隐式连接的示例可能会导致一些奇怪的现象。由于这是一个合成外键，而合成主键实际上并不真正唯一（我们只是宽容地假设了唯一性），投影隐式连接路径意味着我们可能仅仅从投影中就得到笛卡尔积，这在SQL中是非常令人惊讶的。投影不应该影响结果集的基数，但在这里我们就是这样...或许这是一个探索`UNIQUE()`谓词的好机会，以检查它们的“候选”键是否真正唯一：[https://www.jooq.org/doc/latest/manual/sql-building/conditional-expressions/unique-predicate/](https://www.jooq.org/doc/latest/manual/sql-building/conditional-expressions/unique-predicate/)。
- en: You can practice this example in *SyntheticPkKeysImplicitJoin*.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*SyntheticPkKeysImplicitJoin*中练习这个示例。
- en: Embedded keys for synthetic keys
  id: totrans-474
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合成键的嵌入键
- en: 'Next, let''s assume that we want to fetch some data from the `OFFICE_MASTER`
    table, based on a given set of `country`, `state`, and `city` triads. At this
    point, we can write this:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们假设我们想要根据给定的`country`、`state`和`city`三元组从`OFFICE_MASTER`表中获取一些数据。在这个阶段，我们可以这样写：
- en: '[PRE349]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '[PRE350]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[PRE351]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[PRE352]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: 'However, we know that (`country`, `state`, `city`) is actually our synthetic
    key. This means that if we define an embedded key for this synthetic key, then
    we should take advantage of embedded keys, exactly as we saw earlier in the *Working
    with embedded keys* section. Since the synthetic key name is `office_master_pk`,
    the embedded keys resume to this:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们知道（`country`、`state`、`city`）实际上是我们的合成键。这意味着如果我们为这个合成键定义一个嵌入键，那么我们应该像在*Working
    with embedded keys*部分中看到的那样利用嵌入键。由于合成键的名称是`office_master_pk`，嵌入键恢复到这个：
- en: '[PRE356]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: 'Rerun the jOOQ Code Generator to generate the jOOQ artifacts corresponding
    to this embedded key, `OfficeMasterPkRecord`, and the `OfficeMasterPk` POJO. This
    time, we can rewrite our query, as shown here:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行jOOQ代码生成器以生成与这个嵌入键`OfficeMasterPkRecord`和`OfficeMasterPk` POJO对应的jOOQ工件。这次，我们可以重写我们的查询，如下所示：
- en: '[PRE359]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '[PRE361]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: 'Alternatively, maybe we want to fetch an embedded key value in the `OfficeMasterPk`
    POJO:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，也许我们想要获取`OfficeMasterPk` POJO中嵌入的键值：
- en: '[PRE365]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: '[PRE366]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: '[PRE367]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: '[PRE368]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: How about a `JOIN`, using explicitly `OFFICE_MASTER_PK` and `OFFICE_MASTER_FK`?
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 那么使用显式`OFFICE_MASTER_PK`和`OFFICE_MASTER_FK`的`JOIN`怎么样？
- en: '[PRE370]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[PRE371]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: '[PRE373]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[PRE374]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: 'Alternatively, maybe an update that has a predicate based on the embedded key:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，也许是一个基于嵌入键的更新操作：
- en: '[PRE377]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '[PRE379]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[PRE380]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: '[PRE381]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: You can practice these examples in *EmbeddedSyntheticKeys* for PostgreSQL.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*EmbeddedSyntheticKeys* for PostgreSQL中练习这些示例。
- en: Using navigation methods
  id: totrans-515
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用导航方法
- en: 'Furthermore, if we inspect the generated `jooq.generated.Keys`, we notice the
    following generated keys for `OFFICE_MASTER` and `CUSTOMER_MASTER`:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们检查生成的 `jooq.generated.Keys`，我们会注意到为 `OFFICE_MASTER` 和 `CUSTOMER_MASTER`
    生成的以下键：
- en: '[PRE382]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: '[PRE383]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[PRE384]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: 'These keys are quite useful in conjunction with jOOQ navigation methods – `fetchParent()`,
    `fetchChildren()`, `fetchChild()`, and so on. These methods were introduced in
    [*Chapter 9*](B16833_09.xhtml#_idTextAnchor162), *CRUD, Transactions, and Locking*,
    and here are two examples of using them to navigate our views:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 这些键与 jOOQ 导航方法（`fetchParent()`、`fetchChildren()`、`fetchChild()` 等）结合使用非常有用。这些方法在
    [*第 9 章*](B16833_09.xhtml#_idTextAnchor162) 中介绍，*CRUD、事务和锁定*，以下是使用它们导航我们的视图的两个示例：
- en: '[PRE385]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: '[PRE386]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '[PRE387]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '[PRE388]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '[PRE389]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: '[PRE391]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: You can practice these examples in *SyntheticPkKeysNavigation* for PostgreSQL.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 *SyntheticPkKeysNavigation* 中练习这些示例，这是 PostgreSQL 的。
- en: Synthetic unique keys
  id: totrans-529
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合成唯一键
- en: 'In the previous section, we used a composite synthetic primary key built on
    the triad `country`, `state`, and `city`. However, if we look carefully, we notice
    that both views select `postal_code` as well. Since we don''t have two offices
    in the same city, we can consider that `postal_code` (which has `CONSTRAINT "office_postal_code_uk"
    UNIQUE ("postal_code")` in the `office` table) is a unique key for `office_master`
    (of course, in reality, you have to pay attention to such assumptions; maybe the
    best way to represent an address is via `BLOB`, but let''s continue with what
    we have). This means that we can use a synthetic unique key as well. By simply
    replacing the `<primaryKeys/>` tag with the `<uniqueKeys/>` tag, as shown here,
    we set up `postal_code` as a synthetic unique key:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用了一个基于三元组 `country`、`state` 和 `city` 的合成合成主键。然而，如果我们仔细观察，我们会注意到这两个视图都选择了
    `postal_code`。由于我们没有在同一城市中的两个办事处，我们可以考虑 `postal_code`（在 `office` 表中具有 `CONSTRAINT
    "office_postal_code_uk" UNIQUE ("postal_code")`）是 `office_master` 的唯一键（当然，在现实中，你必须注意这样的假设；也许最好的表示地址的方式是通过
    `BLOB`，但让我们继续使用我们已有的）。这意味着我们也可以使用合成唯一键。只需简单地将 `<primaryKeys/>` 标签替换为 `<uniqueKeys/>`
    标签，就像这里所示，我们就可以将 `postal_code` 设置为合成唯一键：
- en: '[PRE392]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: '[PRE393]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: '[PRE394]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: '[PRE395]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: '[PRE397]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '[PRE398]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: '[PRE399]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '[PRE400]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: '[PRE401]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '[PRE402]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: '[PRE403]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: '[PRE404]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: '[PRE405]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '[PRE406]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: '[PRE407]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: '[PRE408]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: '[PRE409]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: '[PRE410]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: '[PRE411]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '[PRE412]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: '[PRE413]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '[PRE414]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: '[PRE415]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: The good news is that our `JOIN` statements that rely on synthetic keys will
    work out of the box, even if we switched from a composite synthetic primary key
    to a simple synthetic unique key. The bundled code is *SyntheticUniqueKeysImplicitJoin*
    for PostgreSQL.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，依赖于合成键的我们的 `JOIN` 语句将直接工作，即使我们从复合合成主键切换到简单合成唯一键。为 PostgreSQL 提供的捆绑代码是 *SyntheticUniqueKeysImplicitJoin*。
- en: Synthetic identities
  id: totrans-556
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合成标识符
- en: 'As you saw earlier, jOOQ can fetch an identity primary key after executing
    an insert (via `insertInto()…returningResult(pk)` or inserting an updatable record).
    However, not all identity columns must be primary keys as well. For instance,
    our `PRODUCT` table from PostgreSQL has two identity columns – one is also the
    primary key (`PRODUCT_ID`), while the second one is just a simple identity column
    (`PRODUCT_UID`):'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 如您之前所见，jOOQ 在执行插入操作后可以检索标识符主键（通过 `insertInto()…returningResult(pk)` 或插入可更新的记录）。但是，并非所有标识符列都必须是主键。例如，我们的
    PostgreSQL 中的 `PRODUCT` 表有两个标识符列——一个是主键（`PRODUCT_ID`），而另一个只是一个简单的标识符列（`PRODUCT_UID`）：
- en: '[PRE416]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: '[PRE417]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: '[PRE418]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: '[PRE419]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: '[PRE420]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '[PRE421]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: '[PRE422]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: '[PRE423]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: '[PRE424]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: 'Fetching both identities via `insertInto() … returningResult(pk)` can be done
    quite easily:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `insertInto() … returningResult(pk)` 同时检索两个标识符非常简单：
- en: '[PRE425]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: '[PRE426]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: '[PRE427]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: '[PRE428]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: '[PRE429]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: '[PRE430]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: '[PRE431]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: '[PRE432]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: 'There is no surprise here, since `returningResult()` instructs jOOQ to return
    all columns enlisted as an argument. However, inserting a record represents a
    more interesting case:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不令人惊讶，因为 `returningResult()` 指示 jOOQ 返回所有列出的列。然而，插入记录代表了一个更有趣的情况：
- en: '[PRE433]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: '[PRE434]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: '[PRE435]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: '[PRE436]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: '[PRE437]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: '[PRE438]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: '[PRE439]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: That's cool! Besides the identity primary key, jOOQ has also populated the record
    with the database-generated `PRODUCT_UID`. So, as long as the database reports
    a column as being an identity, jOOQ can detect it and act accordingly.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 真是酷！除了标识符主键之外，jOOQ 还已将数据库生成的 `PRODUCT_UID` 填充到记录中。因此，只要数据库报告某一列是标识符，jOOQ 就可以检测到它并相应地处理。
- en: 'Okay, let''s next focus on our Oracle schema that defines the `PRODUCT` table,
    like this:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，接下来让我们关注我们的 Oracle 架构，它定义了 `PRODUCT` 表，如下所示：
- en: '[PRE440]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: '[PRE441]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: '[PRE442]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: '[PRE443]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: '[PRE444]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: '[PRE445]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: '[PRE446]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: '[PRE447]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: '[PRE448]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: '[PRE449]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: '[PRE450]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: 'In this scenario, `insertInto() … returningResult()` works as excepted, but
    after inserting a `ProductRecord`, we get back only the identity primary key (`PRODUCT_ID`),
    while calling `getProductUid()` will return `null`. In other words, jOOQ detected
    only `PRODUCT_ID` as being a primary key column, while `PRODUCT_UID` was not reported
    by the database as being an identity column. However, here is where the jOOQ synthetic
    identities come to the rescue. Synthetic identities allow us to configure jOOQ
    to treat as formal identities those columns that are not reported by the database
    as being identities. In this particular case, `PRODUCT_UID` falls under this umbrella,
    so here is the jOOQ-expected configuration for Maven (and standalone):'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，`insertInto() … returningResult()` 的工作方式符合预期，但在插入一个 `ProductRecord` 之后，我们只得到了标识主键（`PRODUCT_ID`），而调用
    `getProductUid()` 将返回 `null`。换句话说，jOOQ 只检测到 `PRODUCT_ID` 是主键列，而 `PRODUCT_UID`
    并没有被数据库报告为标识列。然而，正是在这里，jOOQ 的合成标识符发挥了救星的作用。合成标识符允许我们配置 jOOQ 将那些没有被数据库报告为标识列的列视为正式标识符。在这个特定的情况下，`PRODUCT_UID`
    就属于这一范畴，因此以下是针对 Maven（以及独立版本）的 jOOQ 预期配置：
- en: '[PRE451]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: '[PRE452]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: '[PRE453]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: '[PRE454]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: '[PRE455]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: '[PRE456]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: '[PRE457]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: '[PRE458]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE458]'
- en: If you have multiple tables/identities, then enlist them, separated by `|` as
    regular expressions. This time, after running the Code Generator and inserting
    a new `ProductRecord`, jOOQ fetches both `PRODUCT_ID` (check it via `getProductId()`)
    and `PRODUCT_UID` (check it via `getProductUid()`, which should return a valid
    integer). Moreover, this works for Oracle versions where formal identity columns
    are emulated using sequences and triggers (prior to Oracle 12c). So, another cool
    feature of jOOQ has been revealed.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有多张表/标识符，那么列出它们，用 `|` 作为正则表达式分隔。这次，在运行代码生成器并插入一个新的 `ProductRecord` 之后，jOOQ
    会获取 `PRODUCT_ID`（通过 `getProductId()` 检查）和 `PRODUCT_UID`（通过 `getProductUid()` 检查，它应该返回一个有效的整数）。此外，这对于使用序列和触发器模拟正式标识符的
    Oracle 版本也适用（在 Oracle 12c 之前）。因此，jOOQ 的另一个酷炫特性已经被揭示。
- en: The bundled code samples are *DetectIdentity* (for PostgreSQL) and *SyntheticIdentity*
    (for Oracle).
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 包含的代码示例是 *DetectIdentity*（用于 PostgreSQL）和 *SyntheticIdentity*（用于 Oracle）。
- en: Hooking computed columns
  id: totrans-608
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 钩子计算列
- en: A *computed column* is a column that cannot be written to. Its value is computed
    from a given *expression*. When a column is computed on read (for instance, in
    `SELECT` statements) it is known as a `VIRTUAL` column (in DDL, such columns appear
    roughly expressed as `… GENERATED ALWAYS AS <expression> VIRTUAL` ). Typically,
    `VIRTUAL` columns don’t exist/appear in the database schema. On the other hand,
    a column that is computed on write (for instance, in `INSERT`, `UPDATE`, `MERGE`
    statements) is known as a `STORED` column (in DDL, some common syntax is `...
    GENERATED ALWAYS AS <expression> STORED`). Such columns exist/appear in your database
    schema.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *计算列* 是一个不能写入的列。它的值是从一个给定的 *表达式* 计算得出的。当一个列在读取时进行计算（例如，在 `SELECT` 语句中）时，它被称为
    `VIRTUAL` 列（在 DDL 中，这样的列大致表示为 `… GENERATED ALWAYS AS <expression> VIRTUAL`）。通常，`VIRTUAL`
    列在数据库模式中不存在/出现。另一方面，一个在写入时进行计算的列（例如，在 `INSERT`、`UPDATE`、`MERGE` 语句中）被称为 `STORED`
    列（在 DDL 中，一些常见的语法是 `... GENERATED ALWAYS AS <expression> STORED`）。这样的列存在于/出现在你的数据库模式中。
- en: Server side computed columns
  id: totrans-610
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器端计算列
- en: In this context, jOOQ 3.16 added support for *server side computed columns*.
    jOOQ ‘s Code Generator is capable of detecting server side computed columns and
    marking them as *read-only* (https://www.jooq.org/doc/latest/manual/co[de-generation/codegen-advanced/codegen-config-database/codegen-database-readonly-columns/](http://de-generation/codegen-advanced/codegen-config-database/codegen-database-readonly-columns/)).
    In other words, for your convenience, such columns are automatically excluded
    from DML statements and occur only in `SELECT` statements. However, jOOQ allows
    us to fine tune read-only columns via a bunch of settings available at [https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/readonly-columns/](https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/readonly-columns/).
    Moreover, jOOQ supports *synthetic read-only columns*, which are recognized by
    jOOQ if we configure them via `<readonlyColumns/>`, `<readonlyColumn/>` tags (Maven).
    You can explore this very exciting topic in jOOQ documentation at [https://www.jooq.org/doc/latest/manual/code-generation/codegen-advanced/codegen-config-database/codegen-database-synthetic-objects/codegen-database-synthetic-readonly-columns/](https://www.jooq.org/doc/latest/manual/code-generation/codegen-advanced/codegen-config-database/codegen-database-synthetic-objects/codegen-database-synthetic-readonly-columns/),
    but for now, let’s get back to the computed columns topic.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，jOOQ 3.16 增加了 *服务器端计算列* 的支持。jOOQ 的代码生成器能够检测服务器端计算列并将它们标记为 *只读*（[https://www.jooq.org/doc/latest/manual/co[de-generation/codegen-advanced/codegen-config-database/codegen-database-readonly-columns/](http://de-generation/codegen-advanced/codegen-config-database/codegen-database-readonly-columns/))).换句话说，为了方便起见，这些列自动排除在
    DML 语句之外，只出现在 `SELECT` 语句中。然而，jOOQ 允许我们通过在 [https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/readonly-columns/](https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/readonly-columns/)
    可用的设置中微调只读列。此外，jOOQ 支持 *合成只读列*，如果通过 `<readonlyColumns/>`、`<readonlyColumn/>` 标签（Maven）进行配置，jOOQ
    会识别它们。你可以在 jOOQ 文档中探索这个非常有趣的主题，[https://www.jooq.org/doc/latest/manual/code-generation/codegen-advanced/codegen-config-database/codegen-database-synthetic-objects/codegen-database-synthetic-readonly-columns/](https://www.jooq.org/doc/latest/manual/code-generation/codegen-advanced/codegen-config-database/codegen-database-synthetic-objects/codegen-database-synthetic-readonly-columns/)，但现在，让我们回到计算列的主题。
- en: So, not all dialects support server side computed columns or expressions based
    on scalar subqueries (even correlated ones), or implicit joins. jOOQ 3.17 comes
    with a powerful feature that covers these limitations, and this feature is known
    as *client side computed columns*.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，并非所有方言都支持服务器端计算列或基于标量子查询（即使是关联子查询）的表达式，或者隐式连接。jOOQ 3.17 带来一个强大的功能，覆盖了这些限制，这个功能被称为
    *客户端计算列*。
- en: Client side computed columns
  id: totrans-613
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端计算列
- en: 'Check out the following configuration of a client side computed column (`VIRTUAL`
    alike):'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下客户端计算列（类似于 `VIRTUAL`）的配置：
- en: '[PRE459]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: '[PRE460]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: '[PRE461]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: '[PRE462]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: '[PRE463]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: '[PRE464]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: '[PRE465]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: '[PRE466]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: '[PRE467]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: '[PRE468]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: '[PRE469]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: '[PRE470]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: '[PRE471]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: '[PRE472]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: '[PRE473]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: '[PRE474]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: '[PRE475]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: '[PRE476]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: '[PRE477]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: '[PRE478]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: '[PRE479]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: '[PRE480]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: '[PRE481]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: '[PRE482]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: Because the forced type matches a synthetic column (`REFUND_AMOUNT`), jOOQ semantics
    stands for a `VIRTUAL` computed column. So, the column does not exist in the database
    schema, but the computation (here, an implicit join, but correlated subqueries
    is also a supported option) will be automatically present in all of your `SELECT`
    statements containing this column. In the bundled code available for SQL Server,
    *SyntheticComputedColumns*, you can see a query sample that uses the virtual column,
    `BANK_TRANSACTION.REFUND_AMOUNT`.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 因为强制类型匹配一个合成列（`REFUND_AMOUNT`），jOOQ 语义表示一个 `VIRTUAL` 计算列。因此，该列在数据库模式中不存在，但计算（这里是一个隐式连接，但关联子查询也是一个支持选项）将自动出现在包含此列的所有
    `SELECT` 语句中。在为 SQL Server 提供的捆绑代码中，`SyntheticComputedColumns`，你可以看到一个使用虚拟列 `BANK_TRANSACTION.REFUND_AMOUNT`
    的查询示例。
- en: 'Now, check this out:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看这个：
- en: '[PRE483]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: '[PRE484]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: '[PRE485]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: '[PRE486]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE486]'
- en: '[PRE487]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE487]'
- en: '[PRE488]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE488]'
- en: '[PRE489]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE489]'
- en: '[PRE490]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE490]'
- en: '[PRE491]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE491]'
- en: '[PRE492]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE492]'
- en: '[PRE493]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE493]'
- en: '[PRE494]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE494]'
- en: '[PRE495]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE495]'
- en: '[PRE496]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE496]'
- en: '[PRE497]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE497]'
- en: 'This time, the forced type matches an actual column (`OFFICE.ADDRESS_LINE_FIRST`),
    so jOOQ applies the semantics of a `STORED` computed column. In other words, the
    DML statements will be transformed to reflect the correct computation of the value,
    which will be written to your schema. You can check out an example in the bundled
    code, *StoredComputedColumns*, available for SQL Server. Moreover, if you are
    able to, take the time to read this great article: [https://blog.jooq.org/create-dynamic-views-with-jooq-3-17s-new-virtual-client-side-computed-columns/](https://blog.jooq.org/create-dynamic-views-with-jooq-3-17s-new-virtual-client-side-computed-columns/).'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，强制类型与实际列（`OFFICE.ADDRESS_LINE_FIRST`）匹配，因此 jOOQ 应用了 `STORED` 计算列的语义。换句话说，DML
    语句将被转换以反映值的正确计算，该值将被写入您的模式。您可以在捆绑的代码中查看一个示例，`StoredComputedColumns`，适用于 SQL Server。此外，如果您能抽出时间，请阅读这篇优秀的文章：[https://blog.jooq.org/create-dynamic-views-with-jooq-3-17s-new-virtual-client-side-computed-columns/](https://blog.jooq.org/create-dynamic-views-with-jooq-3-17s-new-virtual-client-side-computed-columns/)。
- en: Overriding primary keys
  id: totrans-657
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖主键
- en: 'Let''s consider the following schema fragment (from PostgreSQL):'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下模式片段（来自 PostgreSQL）：
- en: '[PRE498]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE498]'
- en: '[PRE499]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE499]'
- en: '[PRE500]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE500]'
- en: '[PRE501]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE501]'
- en: '[PRE502]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE502]'
- en: '[PRE503]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE503]'
- en: '[PRE504]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE504]'
- en: '[PRE505]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE505]'
- en: '[PRE506]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE506]'
- en: '[PRE507]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE507]'
- en: '[PRE508]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE508]'
- en: '[PRE509]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE509]'
- en: '[PRE510]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE510]'
- en: '[PRE511]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE511]'
- en: '[PRE512]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE512]'
- en: '[PRE513]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE513]'
- en: '[PRE514]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE514]'
- en: 'The following is an example of updating a `CUSTOMER`:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个更新 `CUSTOMER` 的示例：
- en: '[PRE515]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE515]'
- en: '[PRE516]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE516]'
- en: '[PRE517]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE517]'
- en: '[PRE518]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE518]'
- en: '[PRE519]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE519]'
- en: 'Here is an example of updating a `DEPARTMENT`:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是更新 `DEPARTMENT` 的一个示例：
- en: '[PRE520]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE520]'
- en: '[PRE521]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE521]'
- en: '[PRE522]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE522]'
- en: '[PRE523]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE523]'
- en: '[PRE524]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE524]'
- en: 'From [*Chapter 9*](B16833_09.xhtml#_idTextAnchor162), *CRUD, Transaction, and
    Locking*, we know how `store()` works; therefore, we know that the generated SQLs
    will rely on the `CUSTOMER` primary key and the `DEPARTMENT` primary key (the
    same behavior applies to `update()`, `merge()`, `delete()`, and `refresh()`).
    For instance, `cr.store()` executes the following `UPDATE`:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [*第 9 章*](B16833_09.xhtml#_idTextAnchor162)，*CRUD、事务和锁定*，我们知道 `store()` 的工作原理；因此，我们知道生成的
    SQL 依赖于 `CUSTOMER` 主键和 `DEPARTMENT` 主键（`update()`、`merge()`、`delete()` 和 `refresh()`
    的行为相同）。例如，`cr.store()` 执行以下 `UPDATE`：
- en: '[PRE525]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE525]'
- en: '[PRE526]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE526]'
- en: Since `CUSTOMER_NUMBER` is the primary key of `CUSTOMER`, jOOQ uses it for appending
    the predicate to this `UPDATE`.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `CUSTOMER_NUMBER` 是 `CUSTOMER` 的主键，jOOQ 使用它来为这个 `UPDATE` 添加谓词。
- en: 'On the other hand, `dr.store()` executes this `UPDATE`:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`dr.store()` 执行以下 `UPDATE`：
- en: '[PRE527]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE527]'
- en: '[PRE528]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE528]'
- en: '[PRE529]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE529]'
- en: 'Something doesn''t look right here, since our schema reveals that the primary
    key of `DEPARTMENT` is `DEPARTMENT_ID`, so why does jOOQ use here a composite
    predicate containing `DEPARTMENT_NAME` and `DEPARTMENT_PHONE`? This may look confusing,
    but the answer is quite simple. We actually defined a synthetic primary key (`department_name`
    and `department_phone`), which we reveal here:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 这里看起来有些不对劲，因为我们的模式显示 `DEPARTMENT` 的主键是 `DEPARTMENT_ID`，那么为什么 jOOQ 在这里使用包含 `DEPARTMENT_NAME`
    和 `DEPARTMENT_PHONE` 的组合谓词呢？这可能会让人困惑，但答案相当简单。我们实际上定义了一个合成主键（`department_name`
    和 `department_phone`），我们在这里揭示它：
- en: '[PRE530]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE530]'
- en: '[PRE531]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE531]'
- en: '[PRE532]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE532]'
- en: '[PRE533]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE533]'
- en: '[PRE534]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE534]'
- en: '[PRE535]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE535]'
- en: '[PRE536]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE536]'
- en: '[PRE537]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE537]'
- en: '[PRE538]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE538]'
- en: '[PRE539]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE539]'
- en: '[PRE540]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE540]'
- en: '[PRE541]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE541]'
- en: That's cool! So, jOOQ has used the synthetic key in place of the schema primary
    key. We can say that we overrode the scheme's primary key with a synthetic key.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 太酷了！所以，jOOQ 使用了合成键来代替模式主键。我们可以这样说，我们用合成键覆盖了模式的主键。
- en: 'Let''s do it again! For instance, let''s suppose that we want to instruct jOOQ
    to use the `customer_name` unique key for `cr.store()` and the `code` unique key
    for `dr.store()`. This means that we need the following configuration:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再来一次！例如，假设我们想指示 jOOQ 使用 `customer_name` 唯一键为 `cr.store()` 和 `code` 唯一键为 `dr.store()`。这意味着我们需要以下配置：
- en: '[PRE542]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE542]'
- en: '[PRE543]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE543]'
- en: '[PRE544]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE544]'
- en: '[PRE545]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE545]'
- en: '[PRE546]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE546]'
- en: '[PRE547]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE547]'
- en: '[PRE548]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE548]'
- en: '[PRE549]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE549]'
- en: '[PRE550]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE550]'
- en: '[PRE551]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE551]'
- en: '[PRE552]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE552]'
- en: '[PRE553]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE553]'
- en: '[PRE554]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE554]'
- en: '[PRE555]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE555]'
- en: '[PRE556]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE556]'
- en: '[PRE557]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE557]'
- en: '[PRE558]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE558]'
- en: '[PRE559]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE559]'
- en: 'This configuration overrides the schema defaults, and the generated SQL becomes
    the following:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置覆盖了模式默认值，生成的 SQL 变为以下内容：
- en: '[PRE560]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE560]'
- en: '[PRE561]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE561]'
- en: '[PRE562]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE562]'
- en: '[PRE563]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE563]'
- en: Cool, right?! The complete example is named *OverridePkKeys* for PostgreSQL.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，不是吗？！完整的示例命名为 *OverridePkKeys*，适用于 PostgreSQL。
- en: Summary
  id: totrans-735
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'I hope you enjoyed this short but comprehensive chapter about jOOQ keys. The
    examples from this chapter covered popular aspects of dealing with different kinds
    of keys, from unique/primary keys to jOOQ-embedded and synthetic keys. I really
    hope that you don''t stop at these examples and get curious to deep dive into
    these amazing jOOQ features – for instance, an interesting topic that deserves
    your attention is read-only columns: [https://www.jooq.org/doc/dev/manual/sql-building/column-expressions/readonly-columns/](https://www.jooq.org/doc/dev/manual/sql-building/column-expressions/readonly-columns/).'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您喜欢这个关于 jOOQ 键的简短但全面的章节。本章的示例涵盖了处理不同类型键的流行方面，从唯一/主键到 jOOQ 内嵌和合成键。我真心希望您不要止步于这些示例，而是对深入了解这些惊人的
    jOOQ 功能感到好奇——例如，一个值得您关注的有趣主题是只读列：[https://www.jooq.org/doc/dev/manual/sql-building/column-expressions/readonly-columns/](https://www.jooq.org/doc/dev/manual/sql-building/column-expressions/readonly-columns/)。
- en: In the next chapter, we will tackle pagination and dynamic queries.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将探讨分页和动态查询。
