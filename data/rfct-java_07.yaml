- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Static and Dynamic Analysis
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态和动态分析
- en: On our way to clean, robust, and maintainable code, we’ll often need to “take
    a look” at how our software works and how it’s written. After identifying the
    code smells and doing some refactoring steps (in fact, we should never stop doing
    this!), it can be useful to scan our code for design flaws, security vulnerabilities,
    and more.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们走向干净、健壮和可维护的代码的过程中，我们经常需要“看看”我们的软件是如何工作的以及它是如何编写的。在识别代码异味并执行一些重构步骤（实际上，我们永远不应该停止这样做！）之后，扫描我们的代码以查找设计缺陷、安全漏洞等可能是有用的。
- en: This analysis can be carried out directly on the code – that is, static analysis
    – or on the running program – that is, (without involving too much imagination)
    dynamic analysis.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分析可以直接在代码上执行——也就是说，静态分析——或者在对运行程序执行时进行——也就是说，（无需过多想象）动态分析。
- en: Static and dynamic analysis tools scrutinize code to identify issues and inefficiencies.
    Their insights provide the foundation for improvements, and this is where refactoring
    comes into play.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 静态和动态分析工具会仔细检查代码以识别问题和低效之处。它们的见解为改进提供了基础，这正是重构发挥作用的地方。
- en: 'In this chapter, we’re going to talk about the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: What is static analysis?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是静态分析？
- en: Why do we need static analysis?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么我们需要静态分析？
- en: Some static analysis tools
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些静态分析工具
- en: What is dynamic analysis?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是动态分析？
- en: Some dynamic analysis techniques
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些动态分析技术
- en: What is static analysis?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是静态分析？
- en: As the name may suggest, **static analysis** in the context of Java (or any
    programming language, actually) refers to the process of analyzing source code
    without running it. It is a technique that’s used to find issues, potential bugs,
    security vulnerabilities, and other issues in the code before it is run or compiled.
    Static analysis tools are used for this purpose (we’ll jump into that shortly).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，Java（或任何编程语言，实际上）中的**静态分析**指的是在不运行代码的情况下分析源代码的过程。这是一种在代码运行或编译之前用于查找问题、潜在错误、安全漏洞和其他问题的技术。静态分析工具用于此目的（我们很快就会进入这一点）。
- en: There are lots of reasons to perform static analysis; let’s see some of them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 进行静态分析有很多原因；让我们看看其中的一些。
- en: Code errors or bad practices
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码错误或不良实践
- en: 'The first one we will show you may seem trivial, but it is the main reason
    we scan our code in search of problems – that is, problems in the code! Which
    problems? We’ll put them under the generic term of coding errors – that is, mistakes
    made by programmers when writing code (yes, it turns out that even programmers
    make mistakes – no matter how much experience they have, programmers still make
    mistakes. But, as they gain more experience, they’re more likely to own up to
    their errors!). These errors can lead to a variety of problems, including crashes,
    unexpected behavior, and security vulnerabilities:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要向您展示的第一个可能看起来微不足道，但它是我们扫描代码以寻找问题的主要原因——也就是说，寻找代码中的问题！哪些问题？我们将它们归入通用术语“编码错误”——也就是说，程序员在编写代码时犯的错误（是的，结果证明即使是程序员也会犯错误——无论他们有多少经验，程序员仍然会犯错误。但是，随着他们经验的增加，他们更有可能承认自己的错误！）。这些错误可能导致各种问题，包括崩溃、意外行为和安全漏洞：
- en: 'You could have **null pointer dereferences** when a program tries to access
    a memory location that has not been initialized, as shown here. This can lead
    to crashes and other unexpected behavior:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当程序尝试访问尚未初始化的内存位置时，可能会发生**空指针解引用**，如下所示。这可能导致崩溃和其他意外行为：
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, we have a null reference (`text`) to a string, and attempting
    to access its `length()` method leads to a `NullPointerException`.
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个指向字符串的空引用（`text`），尝试访问其`length()`方法会导致`NullPointerException`。
- en: '`if` statement that is always false. Unreachable code is not harmful, but it
    can make code more difficult to read and maintain. In general, it is useless,
    and we do not like useless code (unless your pay increases with the number of
    code lines you write, but we don’t believe that’s the case). Here’s an example
    of the same:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是返回错误的`if`语句。不可达的代码并无害处，但它可以使代码更难以阅读和维护。一般来说，它是无用的，我们不喜欢无用的代码（除非你写的代码行数越多，你的薪水就越高，但我们不相信这是真的）。以下是一个相同的例子：
- en: '[PRE1]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Class cast exceptions**, on the other hand, are runtime exceptions in Java
    that occur when you try to cast an object to a type that is not compatible with
    the object’s actual type. In other words, you’re trying to convert an object into
    a type that it is not, resulting in an exception:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，**类转换异常**是Java中的运行时异常，当您尝试将对象转换为与对象实际类型不兼容的类型时发生。换句话说，您正在尝试将对象转换为它不是的类型，从而导致异常：
- en: '[PRE2]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a very simple problem that is usually detected by your IDE while you’re
    writing code, but still, that is an example of static analysis.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个非常简单的问题，通常在您编写代码时由您的IDE检测到，但仍然，这是一个静态分析的例子。
- en: 'Some static analysis tools can also detect some bad practices; one of the most
    common is a class implementing a `compareTo` method but then you’re using `equals`.
    When you implement the `compareTo()` method, it’s important to ensure that you
    also override the `equals()` method. This ensures consistency in how objects of
    the class are compared for ordering and equality:'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一些静态分析工具还可以检测一些不良做法；其中最常见的是，一个类实现了`compareTo`方法，但您却在使用`equals`。当您实现`compareTo()`方法时，确保您也重写了`equals()`方法非常重要。这确保了在比较和相等性方面，类对象的一致性：
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The result of this method is probably not what we wanted:'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个方法的结果可能不是我们想要的：
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '@Override'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@Override'
- en: public boolean equals(Object o) {
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public boolean equals(Object o) {
- en: if (this == o) return true;
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果（this == o）返回true；
- en: if (o == null || getClass() != o.getClass()) return false;
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (o == null || getClass() != o.getClass()) return false;
- en: return this.compareTo(o) == 0;
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return this.compareTo(o) == 0;
- en: '}'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE5]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Finally, a good static analysis of your code can detect **duplicated code**,
    which in my opinion is the most common smell I’ve come across; static analysis
    tools can recognize code fragments that are repeated and flag them for developers’
    attention (often, this step can be done directly by your favorite IDE).
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，对您的代码进行良好的静态分析可以检测到**重复代码**，在我看来，这是我最常见的味道；静态分析工具可以识别重复的代码片段，并将它们标记为开发者的注意（通常，这一步可以直接由您最喜欢的IDE完成）。
- en: Security
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全性
- en: 'Static analysis of code is essential for security as it plays a pivotal role
    in identifying and mitigating security vulnerabilities. By thoroughly examining
    the source code of an application or system before it is executed, static analysis
    helps to enhance the overall security posture of software. One of the significant
    benefits of static code analysis is its ability to reduce security vulnerabilities,
    such as **cross-site scripting** (**XSS**) and injection attacks, which are common
    and potentially devastating threats to the integrity and confidentiality of data
    and the smooth operation of applications. Here are some more benefits:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的静态分析对于安全性至关重要，因为它在识别和缓解安全漏洞方面发挥着关键作用。在应用程序或系统执行之前，通过彻底检查源代码，静态分析有助于提高软件的整体安全态势。静态代码分析的一个显著好处是它能够减少安全漏洞，例如**跨站脚本**（**XSS**）和注入攻击，这些是常见且可能具有破坏性的威胁，对数据和应用程序的完整性和机密性以及平稳运行构成威胁。以下是一些更多的好处：
- en: '**Detection of XSS vulnerabilities**: Static code analysis scans the source
    code for any instances where user inputs, such as form fields or URL parameters,
    are not properly validated or sanitized. This meticulous examination helps identify
    potential entry points for malicious code injection. For example, in the context
    of a web application, static analysis can pinpoint locations where user-supplied
    data might be directly included in HTML or JavaScript code. This information is
    invaluable in fixing these issues as it adds proper input validation and output
    encoding, thereby thwarting XSS attacks.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检测XSS漏洞**：静态代码分析扫描源代码，查找任何用户输入（如表单字段或URL参数）未正确验证或清理的实例。这种细致的检查有助于识别恶意代码注入的潜在入口点。例如，在Web应用程序的上下文中，静态分析可以确定用户提供的可能直接包含在HTML或JavaScript代码中的位置。这些信息对于修复这些问题非常有价值，因为它增加了适当的输入验证和输出编码，从而阻止XSS攻击。'
- en: '**Mitigation of injection attacks**: Static analysis is highly effective in
    detecting vulnerabilities that can lead to injection attacks, including SQL injection,
    which can compromise the database and sensitive data. By analyzing the code, it
    can flag any instances where user inputs are used directly in SQL queries, without
    proper parameterization or escaping. Developers can then modify the code so that
    it uses prepared statements or stored procedures, effectively preventing injection
    attacks.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓解注入攻击**：静态分析在检测可能导致注入攻击的漏洞方面非常有效，包括SQL注入，这可能会危害数据库和敏感数据。通过分析代码，它可以标记出任何直接在SQL查询中使用用户输入而没有适当参数化或转义的实例。然后，开发者可以修改代码，使其使用预定义语句或存储过程，从而有效预防注入攻击。'
- en: '**Library and component vulnerability scanning**: We can extend the analysis
    to dynamically linked libraries and third-party components. We should regularly
    scan for known vulnerabilities in libraries and dependencies used by the application.
    Automated tools can help identify outdated or susceptible components, ensuring
    that the software relies on secure and up-to-date code.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**库和组件漏洞扫描**：我们可以将分析扩展到动态链接库和第三方组件。我们应该定期扫描应用程序使用的库和依赖项中已知的安全漏洞。自动化工具可以帮助识别过时或易受攻击的组件，确保软件依赖于安全和最新的代码。'
- en: '**Early detection and prevention**: One of the key advantages of static code
    analysis is its ability to detect vulnerabilities at an early stage of the development
    process. This early detection is crucial because addressing security issues at
    later stages, such as during testing or in production, can be considerably more
    expensive and disruptive. Static analysis empowers development teams to address
    vulnerabilities as they write the code, reducing the likelihood of security issues
    making their way into the final product.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**早期检测和预防**：静态代码分析的一个关键优势是它能够在开发过程的早期阶段检测到漏洞。这种早期检测至关重要，因为在测试或生产等后期阶段解决安全问题可能会花费更多成本并造成更大的破坏。静态分析使开发团队能够在编写代码时解决漏洞，从而降低安全问题进入最终产品的可能性。'
- en: By addressing these vulnerabilities at their root, organizations can minimize
    the potential for security breaches and the associated risks and costs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在根源上解决这些漏洞，组织可以最大限度地减少安全漏洞的可能性以及相关的风险和成本。
- en: Cyclomatic complexity
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**循环复杂度**'
- en: Static analysis of code can also be used to calculate and keep the cyclomatic
    complexity of the code itself under control. Let’s try to understand what it is.
    Simply put, **cyclomatic complexity** is like counting the different ways you
    can walk through a piece of code. If there are fewer routes and they’re not too
    complicated, the cyclomatic complexity is lower, and the code becomes easier to
    read and get.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的静态分析还可以用来计算并保持代码本身的循环复杂度在可控范围内。让我们试着理解它是什么。简单来说，**循环复杂度**就像计算你通过一段代码的不同路径。如果路径较少且不太复杂，循环复杂度就较低，代码也就更容易阅读和理解。
- en: 'To reduce cyclomatic complexity, you “just” have to write clean code, but apply
    all the advice we gave in the previous chapters and remove all the code smells
    that you get. Static analysis can help you, for example, in detecting methods
    or functions that are too long, duplicated code, or dead code (that is, code that
    is never used at runtime); it can also help you reduce the number of decision
    structures (that’s a big deal: try to avoid as many `if` statements as possible
    in your code to reduce the complexity) and help you avoid flag arguments in methods.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要降低循环复杂度，你“只需”编写干净的代码，但应用我们在前几章中给出的所有建议，并移除所有你遇到的代码异味。静态分析可以帮助你，例如，检测过长的方法或函数、重复的代码或死代码（即运行时从未使用过的代码）；它还可以帮助你减少决策结构的数量（这是一个大问题：尽量在你的代码中避免尽可能多的`if`语句以降低复杂性）并帮助你避免在方法中设置标志参数。
- en: 'We’re not going to look at this in too much detail here, but we think it’s
    generally interesting to understand how to calculate cyclomatic complexity for
    a simple method. Let’s suppose you have the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会过多地探讨这个问题，但我们认为了解如何计算简单方法的循环复杂度通常很有趣。假设你拥有以下代码：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can calculate cyclomatic complexity for functions, modules, methods, or
    classes in a software program using control flow graphs. It should be easier to
    draw the control flow graph for the `calculateSum` method than to explain what
    a control flow graph is. It represents all the possible paths of execution of
    your program and it looks something like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用控制流图计算软件程序中函数、模块、方法或类的圈复杂度。绘制`calculateSum`方法的控制流图应该比解释什么是控制流图更容易。它表示了程序所有可能的执行路径，看起来像这样：
- en: '![Figure 7.1 – The control flow graph for the calculateSum method](img/B20912_07_1.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – `calculateSum`方法的控制流图](img/B20912_07_1.jpg)'
- en: Figure 7.1 – The control flow graph for the calculateSum method
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – `calculateSum`方法的控制流图
- en: The previous diagram represents the control flow graph for the `calculateSum`
    method. We can see a **START** node, from which starts an edge that goes into
    a conditional node; depending on the condition (**TRUE** or **FALSE**), the flow
    goes through one edge or another (**a+b** or **a-b**). They both end at the **END**
    node.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的图表示了`calculateSum`方法的控制流图。我们可以看到一个**起始**节点，从这个节点开始有一条边进入一个条件节点；根据条件（**TRUE**或**FALSE**），流程通过一条边或另一条边（**a+b**或**a-b**）。它们都结束在**结束**节点。
- en: 'To calculate the cyclomatic complexity, there’s a simple formula: **M = E –
    N + 2**. Here, we have the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算圈复杂度，有一个简单的公式：**M = E – N + 2**。在这里，我们有以下内容：
- en: '**M** represents the cyclomatic complexity'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**M** 代表圈复杂度'
- en: '**E** is the number of edges in the control flow graph'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**E** 是控制流图中的边数'
- en: '**N** is the number of nodes in the control flow graph'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**N** 是控制流图中节点的数量'
- en: In our case, it would be **M = 5 – 5 + 2 =** **2**.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，**M = 5 – 5 + 2 =** **2**。
- en: In general, a piece of code with a cyclomatic complexity value exceeding 11
    is considered overly complex and brings challenges for testing and maintenance.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，圈复杂度值超过11的代码被认为过于复杂，给测试和维护带来挑战。
- en: 'The following are some common cyclomatic complexity values that are used by
    static analysis tools:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些静态分析工具常用的常见圈复杂度值：
- en: '**1-4**: Low complexity – relatively easy to test'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1-4**：低复杂度 – 相对容易测试'
- en: '**5-7**: Moderate complexity – manageable'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**5-7**：中等复杂度 – 可管理'
- en: '**8-10**: High complexity – suggests the need for refactoring to improve testability'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**8-10**：高复杂度 – 建议重构以提高可测试性'
- en: '**11 and above**: Very high complexity – extremely challenging to test'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**11以上**：非常高的复杂度 – 极具挑战性'
- en: The code’s complexity level also impacts its testability. The higher the cyclomatic
    complexity, the more difficult it is to create comprehensive tests. The cyclomatic
    complexity value indicates the number of test cases required to achieve 100% branch
    coverage.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的复杂度级别也会影响其可测试性。圈复杂度越高，创建全面测试就越困难。圈复杂度值表示达到100%分支覆盖所需的测试用例数量。
- en: Exception (mis)handling
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常（处理）情况
- en: Exceptions in Java programs are not always treated as they deserve; defects
    coming from their mishandling are common and often underestimated. Handling exceptions
    correctly in Java is vital to preventing program crashes, maintaining data integrity,
    providing a better user experience, enhancing debugging, improving security, and
    maintaining code quality. Properly handled exceptions help your software recover
    gracefully from errors and meet regulatory requirements when necessary.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Java程序中的异常并不总是得到应有的处理；由于处理不当而产生的缺陷很常见，并且经常被低估。在Java中正确处理异常对于防止程序崩溃、维护数据完整性、提供更好的用户体验、增强调试、提高安全性和保持代码质量至关重要。正确处理的异常有助于软件从错误中优雅地恢复，并在必要时满足法规要求。
- en: Static analysis tools can help us detect some common exception mishandling;
    we’re going to see some of them here.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析工具可以帮助我们检测一些常见的异常处理不当；我们将在下面看到一些。
- en: 'Consider the following snippet:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下片段：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, an `IOException` is thrown in the `finally` block; in general,
    throwing exceptions in the `finally` block is considered a smell since it could
    hide some other exception being thrown in the `try` block. In this case, the expected
    output would be a `NullPointerException`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在`finally`块中抛出了`IOException`；通常，在`finally`块中抛出异常被认为是一个坏味道，因为它可能会隐藏在`try`块中抛出的其他异常。在这种情况下，预期的输出应该是`NullPointerException`。
- en: 'Also, employing the `return` statement within a `finally` block can introduce
    confusion. This rule’s significance lies in the fact that when the code throws
    an exception, the `return` statement can discard it. Let’s see how by changing
    a bit of the previous code snippet:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在 `finally` 块中使用 `return` 语句可能会引起混淆。这条规则的重要性在于，当代码抛出异常时，`return` 语句可以丢弃它。让我们通过稍微修改一下之前的代码片段来看看：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `NullPointerException` is thrown, but the `finally` block containing the
    `return` statement is just swept under the carpet. Nothing happens.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `NullPointerException` 抛出，但包含 `return` 语句的 `finally` 块只是被扫到地毯下。什么也没有发生。
- en: 'The last smell in exception handling we’re going to see is when we close a
    stream into the `finally` block and something fails. What happens if `close()`,
    when invoked on a stream, fails and there are other instructions to be executed
    after it? Those instructions are simply not executed:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要看到的异常处理中的最后一个异味是当我们把一个流关闭到 `finally` 块中，然后发生失败。如果 `close()` 在调用流时失败，并且之后还有其他指令要执行，会发生什么？那些指令将简单地不被执行：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `copyFiles` method copies one file to another (we’re omitting the internal
    copy method for conciseness), opening two streams (`inputStream` and `outputStream`).
    As you can see, in the `finally` block, the two streams are closed in the same
    `try` block: if the first one fails, the other one will stay open.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`copyFiles` 方法将一个文件复制到另一个文件（为了简洁，我们省略了内部复制方法），打开两个流（`inputStream` 和 `outputStream`）。正如您所看到的，在
    `finally` 块中，两个流在同一个 `try` 块中被关闭：如果第一个失败，另一个将保持打开状态。'
- en: Now that we’ve seen what we’re looking for when we perform static code analysis,
    let’s get to know some tools that can help us. As usual, consider the next few
    sections as suggestions to deepen your knowledge so that you can improve the quality
    of your code day by day.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了在执行静态代码分析时我们寻找的是什么，让我们了解一些可以帮助我们的工具。像往常一样，将接下来的几节视为深化知识的建议，以便您能够日复一日地提高代码质量。
- en: Automated static analysis tools
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动静态分析工具
- en: Automated static analysis tools, such as SonarQube, Checkstyle, FindBugs, and
    PMD, play a crucial role in the software development process by helping developers
    maintain code quality, identify potential issues, and adhere to coding standards.
    These tools are instrumental in ensuring that software projects are not only functionally
    correct but also maintainable and robust.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 自动静态分析工具，如 SonarQube、Checkstyle、FindBugs 和 PMD，在软件开发过程中发挥着至关重要的作用，帮助开发者保持代码质量，识别潜在问题，并遵守编码标准。这些工具对于确保软件项目不仅功能正确，而且可维护和健壮至关重要。
- en: SonarQube and SonarLint
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SonarQube 和 SonarLint
- en: '**SonarQube** is a comprehensive tool that’s designed for continuous code inspection.
    Its primary function is to analyze code bases automatically, pinpointing potential
    issues such as bugs, security vulnerabilities, and code smells. By integrating
    seamlessly into the **continuous integration and continuous deployment** (**CI/CD**)
    pipelines, SonarQube ensures that each build undergoes a deep examination for
    code quality. This process includes identifying and reporting on areas that may
    require improvement or attention.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**SonarQube** 是一款综合性的工具，旨在进行持续代码检查。其主要功能是自动分析代码库，定位潜在问题，如错误、安全漏洞和代码异味。通过无缝集成到
    **持续集成和持续部署**（**CI/CD**）流程中，SonarQube 确保每个构建都经过对代码质量的深度检查。这个过程包括识别和报告可能需要改进或关注的区域。'
- en: One of the notable features of SonarQube is its ability to perform security
    vulnerability detection, which is crucial in today’s software development landscape
    where security is a top priority. This tool offers a holistic view of the code
    base, helping development teams maintain a high standard of code quality throughout
    the entire development life cycle. Additionally, SonarQube provides historical
    analysis, allowing developers to track changes in code quality over time. This
    historical perspective proves invaluable in assessing the effectiveness of code
    improvements or identifying potential regressions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: SonarQube 的一个显著特点是它能够执行安全漏洞检测，这在当今软件开发领域中至关重要，因为安全是首要任务。该工具提供了对代码库的整体视角，帮助开发团队在整个开发生命周期中保持高标准的代码质量。此外，SonarQube
    还提供历史分析，允许开发者跟踪代码质量随时间的变化。这种历史视角对于评估代码改进的有效性或识别潜在的回归至关重要。
- en: SonarQube and **SonarLint** often go together, like *Batman* and *Robin*. SonarLint
    is a lightweight IDE extension and serves as a valuable companion to SonarQube,
    offering developers a means to address code quality issues directly within their
    IDEs. SonarLint operates in real-time, providing instant feedback as developers
    write code. By integrating with popular IDEs such as Eclipse, IntelliJ IDEA, and
    Visual Studio, SonarLint seamlessly becomes a part of the local development environment.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: SonarQube和**SonarLint**经常一起使用，就像*蝙蝠侠*和*罗宾*一样。SonarLint是一个轻量级的IDE扩展，作为SonarQube的有价值伴侣，为开发者提供了一种在IDE中直接解决代码质量问题的方法。SonarLint在实时操作，在开发者编写代码时提供即时反馈。通过集成流行的IDE，如Eclipse、IntelliJ
    IDEA和Visual Studio，SonarLint无缝地成为本地开发环境的一部分。
- en: One of SonarLint’s strengths lies in its language support, which covers a variety
    of programming languages. This versatility allows developers to apply consistent
    code quality standards across different projects and code bases. Importantly,
    SonarLint can be configured to synchronize with SonarQube, ensuring that developers
    adhere to the same rule sets locally as those enforced by the centralized analysis
    performed by SonarQube.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: SonarLint的一个优势在于其语言支持，涵盖了多种编程语言。这种多功能性允许开发者在不同项目和代码库中应用一致的代码质量标准。重要的是，SonarLint可以配置为与SonarQube同步，确保开发者遵守与SonarQube执行的集中分析相同的规则集。
- en: In essence, SonarQube and SonarLint work hand-in-hand to create a robust system
    for maintaining and enhancing code quality. SonarQube provides centralized, comprehensive
    analysis, while SonarLint brings that analysis directly into the developers’ local
    environments, enabling them to proactively address issues during the coding process.
    Together, these tools contribute significantly to the overall goal of producing
    high-quality, secure, and maintainable code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，SonarQube和SonarLint携手合作，创建了一个强大的系统，用于维护和提升代码质量。SonarQube提供集中、全面的分析，而SonarLint则将这种分析直接带入开发者的本地环境，使他们能够在编码过程中积极解决问题。这些工具共同为生产高质量、安全且易于维护的代码做出了重大贡献。
- en: Checkstyle
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Checkstyle
- en: '**Checkstyle** is an open source tool that enforces coding standards and conventions
    for Java code. It checks the source code against a set of predefined rules and
    reports violations. Checkstyle is highly configurable, allowing development teams
    to customize and enforce their own coding standards. Some of the key features
    of Checkstyle are as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**Checkstyle**是一个开源工具，用于强制执行Java代码的编码标准和约定。它将源代码与一组预定义的规则进行比较，并报告违规情况。Checkstyle高度可配置，允许开发团队自定义并强制执行他们自己的编码标准。Checkstyle的一些关键特性如下：'
- en: '**Customizable rules**: Checkstyle allows you to define your own coding rules
    or use predefined rule sets based on established coding standards such as Sun
    Code Conventions, Google Java Style, and more. You can define rules about indentation,
    line length, variable naming, import order, and so on.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可自定义的规则**：Checkstyle允许你定义自己的编码规则或使用基于既定编码标准（如Sun代码约定、Google Java风格等）的预定义规则集。你可以定义有关缩进、行长度、变量命名、导入顺序等方面的规则。'
- en: '**Integration**: Checkstyle can be integrated into popular IDEs and build systems,
    making it seamless for developers to incorporate code checks into their development
    workflows'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成**：Checkstyle可以集成到流行的IDE和构建系统中，使开发者能够无缝地将代码检查纳入他们的开发工作流程。'
- en: '**Continuous Integration**: It is often integrated into **Continuous Integration**
    (**CI**) pipelines, ensuring that code quality checks are performed automatically
    whenever code changes are committed'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续集成**：它通常集成到**持续集成**（**CI**）管道中，确保在代码更改提交时自动执行代码质量检查。'
- en: '**Report generation**: Checkstyle generates detailed reports, making it easy
    for developers to identify and fix code violations'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**报告生成**：Checkstyle生成详细的报告，使开发者能够轻松识别和修复代码违规。'
- en: FindBugs
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FindBugs
- en: '**FindBugs** is a static analysis tool for identifying bugs and potential security
    vulnerabilities in Java code. It uses static analysis to detect issues in bytecode,
    making it particularly valuable for finding problems that might not be apparent
    from the source code alone. Here are some of the key features of FindBugs:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**FindBugs**是一个用于识别Java代码中错误和潜在安全漏洞的静态分析工具。它使用静态分析来检测字节码中的问题，因此在发现仅从源代码中不明显的问题时特别有价值。以下是FindBugs的一些关键特性：'
- en: '**Bug detection**: It is designed to find a wide range of bugs, including null
    pointer dereferences, thread synchronization problems, and performance bottlenecks'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误检测**：它旨在发现各种错误，包括空指针解引用、线程同步问题和性能瓶颈'
- en: '**Integration**: Like Checkstyle, FindBugs can be integrated into various development
    environments and CI/CD pipelines'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成**：与Checkstyle一样，FindBugs可以集成到各种开发环境和CI/CD流水线中'
- en: '**User-defined checks**: Developers can create custom bug detectors for project-specific
    issues'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户自定义检查**：开发者可以为特定项目的问题创建自定义的错误检测器'
- en: '**Community support**: FindBugs has an active community that maintains and
    updates the tool, ensuring it remains relevant and effective'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**社区支持**：FindBugs有一个活跃的社区，维护和更新这个工具，确保它保持相关性和有效性'
- en: FindBugs reviews your code by looking at its bytecode – that is, without needing
    to access the original source code. But because its analysis isn’t always perfect,
    FindBugs can sometimes raise warnings that aren’t real issues. The rate of these
    false warnings reported by FindBugs is less than 50%.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: FindBugs通过查看其字节码来审查您的代码——也就是说，无需访问原始源代码。但由于其分析并不总是完美的，FindBugs有时会发出并非真正问题的警告。FindBugs报告的这些虚假警告的比率低于50%。
- en: PMD
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PMD
- en: '**PMD** is a static source code analyzer for various programming languages,
    including Java. It focuses on code quality and identifies potential issues, redundancies,
    and complex code patterns. PMD offers the following key features:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**PMD** 是一种针对多种编程语言的静态源代码分析器，包括Java。它专注于代码质量，并识别潜在的问题、冗余和复杂的代码模式。PMD提供以下关键特性：'
- en: '**Multiple languages**: It supports multiple languages, not just Java, making
    it versatile for projects with diverse code bases'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多语言支持**：它支持多种语言，而不仅仅是Java，这使得它在具有多样化代码库的项目中更加灵活'
- en: '**Rule-based analysis**: It analyzes source code against a set of predefined
    rules that can be customized based on project requirements'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于规则的分析**：它将源代码与一组预定义的规则进行对比分析，这些规则可以根据项目需求进行自定义'
- en: '**Code duplication detection**: PMD can detect duplicate code fragments, helping
    developers maintain cleaner and more maintainable code'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码重复检测**：PMD可以检测重复的代码片段，帮助开发者维护更干净、更易于维护的代码'
- en: '**Integration**: PMD can be integrated into different IDEs and build systems
    (PMD offers an extension for Visual Studio Code, making it convenient for developers
    working in this popular IDE)'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成**：PMD可以集成到不同的IDE和构建系统中（PMD为Visual Studio Code提供了一个扩展，使得在这个流行的IDE中工作的开发者更加方便）'
- en: Using tools that check code for mistakes is important in both the place where
    we write code (IDEs) and in the system that keeps an eye on our code as we work
    (CI pipelines). These tools help us find mistakes early, which is very helpful.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写代码的地方（IDEs）以及在我们工作时监控系统代码的系统（CI流水线）中，使用检查代码错误的工具都很重要。这些工具帮助我们尽早发现错误，这非常有帮助。
- en: In our code writing environment (IDE), these tools help us spot problems as
    we write the code, making it less likely for errors to show up later.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码编写环境（IDE）中，这些工具帮助我们编写代码时发现问题，使得错误出现的可能性降低。
- en: In our code monitoring system (CI pipeline), these tools make sure the code
    we write follows the rules and standards we set. This keeps the quality of our
    code high and makes sure we don’t accidentally break things that used to work.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码监控系统（CI流水线）中，这些工具确保我们编写的代码遵循我们设定的规则和标准。这保证了我们代码的质量，并确保我们不会意外地破坏以前正常工作的东西。
- en: One of the great things about these tools is that they make sure everyone on
    the team follows the same rules. This helps our code be more organized, easier
    to understand, and generally better. These tools also save us time and money.
    They help us find and fix problems early, which is cheaper and faster than waiting
    until later when problems can be much harder to solve.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具的其中一个优点是确保团队中的每个人都遵循相同的规则。这有助于我们的代码更有组织性，更容易理解，总体上更好。这些工具还节省了我们的时间和金钱。它们帮助我们尽早发现并解决问题，这比等到问题变得难以解决时更便宜、更快。
- en: At the end of the day, using these tools makes our code better, helps us work
    together more easily, and keeps our code secure and safe from mistakes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用这些工具可以使我们的代码更好，帮助我们更容易地协作，并确保我们的代码安全，避免错误。
- en: With that, we’ve taken a quick look at static analysis, focusing on what to
    look for and how to look for it. Unfortunately, static analysis alone is not enough.
    Clean code is one thing – efficient code is another. It is strictly necessary
    to analyze the code while it is running.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们快速地浏览了静态分析，关注了要寻找的内容以及如何寻找。不幸的是，仅静态分析是不够的。干净的代码是一回事——高效的代码是另一回事。在程序运行时分析代码是绝对必要的。
- en: What is dynamic analysis?
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是动态分析？
- en: While static analysis is done on the code, its complementary version, **dynamic
    analysis**, is done on the program while it is running. This approach involves
    analyzing the code during execution, rather than just inspecting the source code,
    or performing static analysis, which examines code without executing it. Dynamic
    analysis provides insights into how a program behaves in real-world scenarios
    and helps identify issues that might not be apparent through static analysis alone.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当静态分析在代码上执行时，其互补版本，**动态分析**，是在程序运行时进行的。这种方法涉及在执行过程中分析代码，而不仅仅是检查源代码，或者执行静态分析，后者是在不执行代码的情况下检查代码。动态分析提供了关于程序在实际场景中行为的见解，并有助于识别仅通过静态分析可能不明显的问题。
- en: If you have ever done some unit testing or some debugging, well, you did some
    kind of dynamic analysis. But there is much more to this. Dynamic program analysis
    involves collecting diverse insights about a program’s behavior, which includes
    understanding variables’ value assignments, the sequence and timing of function
    calls, data structure manipulations and modifications, memory allocation and usage,
    utilization of system resources, and the detection of encountered errors. This
    information is essential for purposes such as bug and security vulnerability identification,
    program performance enhancement, verification of program adherence to its requirements,
    and gaining a deeper understanding of the program’s operational principles.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经进行过一些单元测试或调试，那么，你已经进行了一些动态分析。但这里还有更多。动态程序分析涉及收集关于程序行为的各种见解，包括理解变量的值赋值、函数调用的顺序和时机、数据结构的操作和修改、内存分配和使用、系统资源的利用以及检测到的错误。这些信息对于识别错误和安全漏洞、提高程序性能、验证程序是否符合其要求以及深入了解程序的操作原理等目的至关重要。
- en: There are many examples of dynamic program analysis; let the journey begin.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 动态程序分析的例子有很多；让我们开始这段旅程。
- en: Debugging
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试
- en: As trivial as it may seem, **debugging** is the most widely used technique for
    dynamic program analysis; maybe it’s the single activity we do the most in our
    industry – yes, certainly much more than writing the code or designing the architectures.
    And yes, we know that by implementing some good habits in respect of testing (such
    as **test-driven development** (**TDD**)) the need for debugging should be minimal,
    ideally zero, but in the real world, it isn’t always possible to do so.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这可能看似微不足道，**调试**是动态程序分析中最广泛使用的技巧；也许这是我们行业中做的最多的一件事——是的，肯定比编写代码或设计架构要多得多。是的，我们知道通过实施一些关于测试的良好习惯（例如**测试驱动开发**（**TDD**））来减少调试的需求应该是最低的，理想情况下为零，但在现实世界中，并不总是能够做到这一点。
- en: Since it’s such a popular activity, we won’t dwell too much on debugging. However,
    I would like to draw attention to some aspects that some people might underestimate,
    especially at the beginning of their professional careers.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个如此受欢迎的活动，我们不会过多地讨论调试。然而，我想提醒大家注意一些可能被低估的方面，尤其是在他们职业生涯的初期。
- en: 'For effective debugging, try to reproduce the bug first; from experience, this
    can be a difficult phase, sometimes much more difficult than the resolution itself.
    It involves having it explained to you what was done to produce that bug (in case
    you haven’t noticed it yourself) and reproducing the same input that generated
    the problem or at least an input of the same type. It is not even granted that
    you can use a debugger, actually: for example, if you can’t reproduce the problem
    in an environment where you can use the debugger (for example, your local host),
    you’ll need to use some other technique, such as logging. By logging the program’s
    state at key points, you can track down the source of the error more easily. As
    we already know – and it’s the key target of this whole book – refactoring can
    help you debug. Sometimes, it could just look like a game, but refactoring your
    code and making it cleaner will likely help you understand what’s happening.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地调试，首先尝试重现错误；根据经验，这可能是一个困难的阶段，有时甚至比解决方案本身还要困难。这涉及到有人向你解释产生该错误的原因（如果你自己没有注意到），并重现导致问题的相同输入或至少是相同类型的输入。甚至不能保证你能使用调试器：例如，如果你无法在可以使用调试器的环境中重现问题（例如，你的本地主机），你需要使用其他技术，例如日志记录。通过在关键点记录程序的状态，你可以更容易地追踪错误的来源。正如我们已知的那样——这也是整本书的关键目标——重构可以帮助你调试。有时，这看起来可能就像一场游戏，但重构你的代码并使其更简洁可能会帮助你理解正在发生的事情。
- en: Although it is widely used as a technique, I must point out that crying and
    banging your head on the keyboard does not work to fix bugs; on the other hand,
    do not hesitate to ask for help. This can also be an exceedingly difficult thing.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然性能分析作为一种技术被广泛使用，但我必须指出，哭泣和敲打键盘并不能修复错误；另一方面，不要犹豫去寻求帮助。这也可以是一个非常困难的事情。
- en: Profiling
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能分析
- en: Even the most skilled development teams may find that a few lines of code don’t
    achieve peak performance right from the start. To uncover the most efficient methods
    for improving code speed, it must undergo evaluation, debugging, and review.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是最熟练的开发团队也可能发现，一些代码行一开始并不能达到最佳性能。为了发现提高代码速度的最有效方法，必须对其进行评估、调试和审查。
- en: Software engineers (and quality assurance professionals) must take some steps
    to guarantee that their code is as swift, smooth, and flawless as possible.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工程师（以及质量保证专业人员）必须采取一些措施来确保他们的代码尽可能快速、流畅且无瑕疵。
- en: '**Profiling** is the process of measuring and analyzing the runtime behavior
    and performance characteristics of a program. The primary goal of profiling is
    to identify bottlenecks, performance issues, and areas for optimization in the
    code. This is crucial for improving the efficiency and speed of a program. Profiling
    can be applied to various types of software, including desktop applications, web
    applications, and server-side software.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**性能分析**是衡量和分析程序运行行为和性能特征的过程。性能分析的主要目标是识别代码中的瓶颈、性能问题和优化区域。这对于提高程序的效率和速度至关重要。性能分析可以应用于各种类型的软件，包括桌面应用程序、Web应用程序和服务器端软件。'
- en: 'There are many different profiling tools available, and they can be used to
    collect several types of data, as shown here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的性能分析工具可用，它们可以收集多种类型的数据，如下所示：
- en: '**CPU usage**: This data shows how much CPU time the program is using'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU使用情况**：此数据显示了程序正在使用多少CPU时间。'
- en: '**Memory usage**: This data shows how much memory the program is using'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存使用情况**：此数据显示了程序正在使用多少内存。'
- en: '**Function call frequency**: This data shows how often each function in the
    program is being called'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数调用频率**：此数据显示了程序中每个函数被调用的频率。'
- en: '**Function execution time**: This data shows how long each function in the
    program is taking to execute'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数执行时间**：此数据显示了程序中每个函数执行所需的时间。'
- en: '**Resource usage**: This data shows how many various system resources, such
    as disk I/O and network bandwidth, the program is using'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源使用情况**：此数据显示了程序正在使用多少种不同的系统资源，例如磁盘I/O和网络带宽。'
- en: Once the profiling data has been collected, it can be analyzed to identify bottlenecks.
    A bottleneck is a part of the program that is slowing it down. For example, a
    function that is called very often and takes a long time to execute may be a bottleneck.
    Once the bottlenecks have been identified, they can be fixed by optimizing the
    code. For example, the bottleneck function may be rewritten to make it more efficient.
    Profiling is a valuable tool for improving the performance of software. It can
    be used to identify and fix bottlenecks, and to make sure that the program is
    using system resources efficiently.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦收集了剖析数据，就可以进行分析以识别瓶颈。瓶颈是程序中减慢其速度的部分。例如，一个被频繁调用且执行时间较长的函数可能是一个瓶颈。一旦识别出瓶颈，可以通过优化代码来修复它们。例如，瓶颈函数可能被重写以使其更高效。剖析是提高软件性能的有价值工具。它可以用来识别和修复瓶颈，并确保程序高效地使用系统资源。
- en: Profiling has practical applications in various fields. For instance, web application
    developers can employ profilers to identify performance bottlenecks in their applications,
    allowing them to optimize the code for quicker loading. Similarly, game developers
    use profilers to improve frame rates by identifying and optimizing problematic
    sections of their games. Server administrators also make use of profilers to pinpoint
    resource-intensive processes, enabling them to reduce the server’s resource burden.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 剖析在各个领域都有实际应用。例如，网络应用程序开发者可以使用剖析器来识别他们应用程序中的性能瓶颈，从而优化代码以实现更快的加载。同样，游戏开发者使用剖析器通过识别和优化游戏中的问题部分来提高帧率。服务器管理员也利用剖析器来定位资源密集型进程，使他们能够减轻服务器的资源负担。
- en: Lots of tools are used to profile running Java applications. Sometimes, they
    are included in your IDEs in their plugin/extensions, such as NetBeans or Eclipse.
    One of the most used and common tools is VisualVM, a visual tool integrated into
    the **Java Development Kit** (**JDK**) that provides a wide range of profiling,
    monitoring, and diagnostic capabilities, including CPU profiling, memory profiling,
    and thread analysis.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 许多工具被用于分析正在运行的Java应用程序。有时，这些工具包含在你的IDE的插件/扩展中，例如NetBeans或Eclipse。最常用且常见的工具之一是VisualVM，这是一个集成到**Java开发工具包**（**JDK**）中的可视化工具，它提供了一系列的剖析、监控和诊断功能，包括CPU剖析、内存剖析和线程分析。
- en: '**VisualVM** provides a user-friendly graphical interface for monitoring and
    analyzing Java applications. It offers a wealth of visual data and performance
    metrics, making it easier to identify and address performance issues. One of VisualVM’s
    key features is its Java profiling capabilities. It allows developers to profile
    their applications to identify bottlenecks, memory leaks, and other performance-related
    problems. You can perform CPU profiling, thread analysis, and memory profiling,
    which are essential for improving the efficiency and reliability of Java applications.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**VisualVM**为监控和分析Java应用程序提供了一个用户友好的图形界面。它提供了丰富的可视化数据和性能指标，使得识别和解决性能问题变得更加容易。VisualVM的一个关键特性是其Java剖析能力。它允许开发者剖析他们的应用程序以识别瓶颈、内存泄漏和其他与性能相关的问题。你可以执行CPU剖析、线程分析和内存剖析，这对于提高Java应用程序的效率和可靠性至关重要。'
- en: When your application starts freaking out and you don’t know exactly what is
    happening (for example, everything starts slowing down), one of the best chances
    (and one of the most desperate, at the same time) is to make a so-called “heap
    dump” or “memory dump.” A **memory dump** is essentially a snapshot of the contents
    of a computer’s memory (RAM) or a specific process’s memory at a given point in
    time. This snapshot captures the state of the system or application at the moment
    it was created. Memory dumps serve various important purposes, including debugging
    software errors and crashes, analyzing security incidents and malware infections,
    investigating system crashes, and optimizing memory usage in applications. They
    come in different types, such as complete memory dumps (for hardware-related issues),
    kernel memory dumps (for operating system issues), process memory dumps (for application-specific
    debugging), and mini dumps (for smaller and more manageable data). Memory dump
    analysis is crucial for gaining insights into system and software behavior and
    is an essential tool in resolving a wide range of computing issues.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的应用程序开始出现异常并且您不知道确切发生了什么（例如，一切开始变慢），最好的机会之一（同时也是最绝望的）就是制作所谓的“堆转储”或“内存转储”。**内存转储**本质上是在某个特定时间点计算机内存（RAM）或特定进程内存的快照。这个快照捕捉了系统或应用程序在创建时的状态。内存转储在多个重要方面发挥作用，包括调试软件错误和崩溃、分析安全事件和恶意软件感染、调查系统崩溃以及优化应用程序中的内存使用。它们有不同的类型，如完整内存转储（用于与硬件相关的问题）、内核内存转储（用于操作系统问题）、进程内存转储（用于特定于应用程序的调试）和迷你转储（用于更小、更易于管理的数据）。内存转储分析对于深入了解系统和软件行为至关重要，并且是解决各种计算问题的基本工具。
- en: VisualVM (like other profiling tools) allows you to capture heap dumps and thread
    dumps, which are essential for diagnosing memory-related issues and analyzing
    thread behavior in your Java application.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: VisualVM（类似于其他分析工具）允许您捕获堆转储和线程转储，这对于诊断与内存相关的问题和分析Java应用程序中的线程行为至关重要。
- en: Fuzzing
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模糊测试
- en: '**Fuzzing**, also known as **fuzz testing**, is an automated software testing
    approach where unconventional, often random, and invalid data is provided as input
    to a computer program. The program’s responses are closely monitored for anomalies
    such as crashes, violations of built-in code rules, or potential memory issues.
    Fuzzers are typically employed to assess software programs that rely on structured
    inputs, such as file formats or protocols that distinguish between valid and invalid
    data.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**模糊测试**，也称为**模糊测试**，是一种自动化的软件测试方法，其中向计算机程序提供非传统、通常随机且无效的数据作为输入。程序的反应会密切监控异常，如崩溃、违反内置代码规则或潜在的内存问题。模糊测试器通常用于评估依赖于结构化输入的软件程序，例如区分有效和无效数据的文件格式或协议。'
- en: A good fuzzer generates partially valid inputs that are “valid enough” to avoid
    immediate rejection by the input parser but are “invalid enough” to uncover unanticipated
    program behaviors, especially in corner cases that may not have been adequately
    addressed.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的模糊测试器会生成部分有效的输入，这些输入“足够有效”以避免被输入解析器立即拒绝，但“足够无效”以揭示未预料到的程序行为，尤其是在可能没有得到充分处理的边缘情况。
- en: In a security context, the most valuable input to fuzz is often data that traverses
    a trust boundary. A **trust boundary** is a point where data or program execution
    transitions between different trust levels or where data and commands are exchanged
    between entities with varying privileges. Trust boundaries can be found at distinct
    locations in a system where all subsystems and their data have equal trust. For
    instance, an execution trust boundary occurs when an application gains elevated
    privileges, such as root access. A data trust boundary occurs when data originates
    from an untrusted source, such as user input or a network socket. For instance,
    it’s more critical to fuzz code that’s responsible for handling file uploads from
    any user, as it crosses a trust boundary, than code dealing with a configuration
    file accessible only to privileged users.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在安全环境中，模糊测试最有价值的输入通常是跨越信任边界的数据。**信任边界**是数据或程序执行在不同信任级别之间转换的点，或者是在具有不同权限的实体之间交换数据和命令的点。信任边界可以在系统的不同位置找到，其中所有子系统及其数据具有相同的信任。例如，当应用程序获得提升的权限，如root访问时，就会发生执行信任边界。当数据来自不受信任的来源，如用户输入或网络套接字时，就会发生数据信任边界。例如，对于处理来自任何用户的文件上传的代码进行模糊测试比处理仅对特权用户可访问的配置文件的代码更为关键，因为它跨越了信任边界。
- en: 'Every fuzzer can be put into one of two categories:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模糊器都可以归入两个类别之一：
- en: '**Mutation-based fuzzers**: These fuzzers start with existing data samples
    and make changes to them to create new test cases. They take an original input
    or test case and then modify it in various ways, such as changing random bits
    or values, to see if these modifications trigger unexpected behavior or vulnerabilities
    in the software being tested. Mutation-based fuzzers are good at finding certain
    types of bugs or vulnerabilities, especially when you have an initial set of valid
    inputs to work with.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于变异的模糊器**：这些模糊器从现有的数据样本开始，对它们进行修改以创建新的测试用例。它们首先获取原始输入或测试用例，然后以各种方式对其进行修改，例如更改随机位或值，以查看这些修改是否会在被测试的软件中触发意外的行为或漏洞。基于变异的模糊器擅长发现某些类型的错误或漏洞，尤其是在你有初始有效输入集可以工作的时候。'
- en: '**Generation-based fuzzers**: These fuzzers build test cases by understanding
    the structure and rules of the target protocol or file format. Instead of modifying
    existing data samples, they generate new data that follows the specific format
    and logic required for testing. These fuzzers are good at exploring different
    aspects of a program or system because they can create a wide range of test cases
    based on their knowledge of the protocol or file format.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于生成的模糊器**：这些模糊器通过理解目标协议或文件格式的结构和规则来构建测试用例。它们不是修改现有的数据样本，而是生成遵循特定格式和逻辑要求的新数据，以进行测试。这些模糊器擅长探索程序或系统的不同方面，因为它们可以根据对协议或文件格式的了解创建广泛的测试用例。'
- en: 'Now, we’ll delve into subcategories within these two groups. There’s no universally
    agreed-upon list of fuzzing categories, but I liked the approaches described in
    the book *Fuzzing: Brute Force Vulnerability Discovery* (see *Further reading*),
    so I’ll try to resume them.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，我们将深入探讨这两组内部的子类别。没有普遍认可的模糊分类列表，但我喜欢书中描述的方法 *Fuzzing: Brute Force Vulnerability
    Discovery*（见 *进一步阅读*），所以我将尝试总结它们。'
- en: Pre-generated test cases
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预生成的测试用例
- en: As mentioned earlier, the **pre-generated test cases** method, exemplified by
    the PROTOS framework, starts by studying a specific specification. It involves
    understanding supported data structures and acceptable value ranges. Test cases
    are then crafted as hard-coded packets or files, designed to test boundary conditions
    or challenge the specification itself. These test cases prove valuable for assessing
    how accurately the specification has been implemented on various systems. While
    this method requires substantial upfront effort in test case creation, its advantage
    lies in its reusability across multiple implementations of the same protocol or
    file format. A limitation, however, is that fuzz testing is finite as there’s
    no random element; once the list of test cases is exhausted, fuzzing concludes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，**预生成的测试用例**方法，以 PROTOS 框架为例，首先研究一个特定的规范。它涉及理解支持的数据结构和可接受的价值范围。然后，测试用例被精心制作成硬编码的数据包或文件，旨在测试边界条件或挑战规范本身。这些测试用例对于评估规范在各种系统上实施得有多准确非常有价值。虽然这种方法在测试用例创建方面需要大量的前期工作，但其优势在于其可重用性，可以在同一协议或文件格式的多个实现中重复使用。然而，一个限制是模糊测试是有限的，因为没有随机元素；一旦测试用例列表耗尽，模糊测试就结束了。
- en: Random
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 随机
- en: The **random approach** is the simplest yet least effective method. It involves
    hurling pseudo-random data at the target while hoping for the best (or worst,
    depending on your perspective). Surprisingly, vulnerabilities in critical software
    have been uncovered using this technique. The challenging part is identifying
    the cause of an exception or a server crash resulting from tons of random bytes.
    Capturing the traffic with a sniffer is essential to facilitate debugging, often
    requiring extensive time in a debugger and disassembler. Debugging stack smashing
    can be especially troublesome as the call stack becomes corrupted.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**随机方法**是最简单但效果最差的方法。它涉及向目标投掷伪随机数据，并寄希望于最好的（或最坏的，取决于你的观点）。令人惊讶的是，使用这种技术已经发现了关键软件中的漏洞。挑战的部分是确定由大量随机字节引起的异常或服务器崩溃的原因。使用嗅探器捕获流量对于方便调试至关重要，通常需要大量的调试器和反汇编器时间。调试堆栈溢出可能特别麻烦，因为调用栈被破坏。'
- en: Manual protocol mutation testing
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动协议变异测试
- en: '**Manual protocol mutation testing** is even less sophisticated than random
    fuzzing. It doesn’t involve an automated fuzzer; instead, the tester becomes the
    fuzzer. By entering inappropriate data into the target application, the goal is
    to crash the server or provoke undesired behavior. It’s a straightforward, cost-effective
    approach that’s often applied to web applications, allowing the analyst to rely
    on experience and intuition during the audit.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**手动协议变异测试**甚至比随机模糊测试更不复杂。它不涉及自动模糊器；相反，测试者变成了模糊器。通过向目标应用程序输入不适当的数据，目标是使服务器崩溃或引发不希望的行为。这是一种简单、成本效益高的方法，通常应用于Web应用程序，使分析师在审计过程中可以依靠经验和直觉。'
- en: We think that this approach is sometimes referred to as **hallway usability
    testing**, even though a usability test is something different than testing the
    program’s correctness. If you’re interested in what hallway usability testing
    is, take a look at the *Further* *reading* section.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为这种方法有时被称为**走廊可用性测试**，尽管可用性测试与测试程序的正确性是不同的。如果你对走廊可用性测试感兴趣，请参阅*进一步* *阅读*部分。
- en: Mutation or brute-force testing
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变异或暴力测试
- en: '**Brute-force testing** involves taking a valid sample of a protocol or data
    format and continuously modifying every byte, word, or string within that data
    packet or file. While this approach requires minimal upfront research and is relatively
    easy to implement, it’s somewhat inefficient because it may waste CPU cycles on
    data that cannot be interpreted. Nevertheless, it can be fully automated, and
    it relies on a collection of known good packets or files for testing. Examples
    of brute-force file format fuzzers include FileFuzz for Windows and notSPIKEfile
    for Linux.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**暴力测试**涉及从一个协议或数据格式的有效样本开始，并不断修改该数据包或文件中的每个字节、单词或字符串。虽然这种方法需要最少的前期研究并且相对容易实现，但它效率不高，因为它可能会浪费CPU周期在无法解释的数据上。尽管如此，它可以完全自动化，并且依赖于一组已知良好的数据包或文件进行测试。暴力文件格式模糊器示例包括Windows的FileFuzz和Linux的notSPIKEfile。'
- en: Automatic protocol generation testing
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动协议生成测试
- en: In **automatic protocol generation testing**, the tester initially studies and
    understands the protocol specification or file definition. Instead of creating
    hard-coded test cases, a grammar is developed to describe the protocol’s operation.
    Static and fuzzable variables are identified within the packet or file. The fuzzer
    works by looking at templates, creating fuzzy data, and then sending the changed
    data to the target. How well this works depends on the tester’s skills in finding
    the parts of the specification that are likely to cause problems during the parsing
    process. Notable examples are SPIKE and SPIKEfile. However, this method demands
    time to create the grammar or definition upfront.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在**自动协议生成测试**中，测试者最初研究和理解协议规范或文件定义。而不是创建硬编码的测试用例，开发了一种语法来描述协议的操作。在数据包或文件中确定了静态和模糊变量。模糊器通过查看模板、创建模糊数据，然后将更改后的数据发送到目标。这效果如何取决于测试者在解析过程中找到可能导致问题的规范部分的能力。显著的例子是SPIKE和SPIKEfile。然而，这种方法需要时间来创建语法或定义。
- en: We just wanted to give you a general smattering of concepts that we have often
    seen put in place without a real “structurization” of what was being done. As
    usual, we do not pretend to be exhaustive but simply wish to spark some curiosity
    in you regarding this subject.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是想给你一个大致的概念概述，这些概念我们经常看到被实施，但没有真正“结构化”所做的事情。像往常一样，我们并不声称是详尽的，只是希望激发你对这个主题的一些好奇心。
- en: Symbolic execution
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 符号执行
- en: '**Symbolic execution** stands as a program analysis method in which programs
    are run with symbolic inputs rather than concrete ones. Simultaneously, it preserves
    a path condition (see the *Cyclomatic complexity* section to learn what a *path*
    is) that evolves each time a branch instruction is encountered, encapsulating
    the constraints on the inputs that lead to that specific point within the program.
    In other words, it works by replacing real data with symbolic values as input
    and describing program variable values as symbolic expressions. This way, the
    program’s results are expressed as functions of these symbolic inputs.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**符号执行**是一种程序分析方法，其中程序使用符号输入而不是具体输入来运行。同时，它保留一个路径条件（参见*循环复杂度*部分了解*路径*是什么），每次遇到分支指令时都会演变，封装导致程序中特定点的输入约束。换句话说，它通过用符号值替换实际数据作为输入，并将程序变量值描述为符号表达式来工作。这样，程序的结果被表示为这些符号输入的函数。'
- en: To create tests, this method relies on solving the gathered constraints using
    a constraint solver. Symbolic execution is also handy for finding bugs since it
    inspects the program as it runs for errors or assertion violations and creates
    test inputs that can trigger these issues.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建测试，此方法依赖于使用约束求解器解决收集到的约束。符号执行对于查找错误也很有用，因为它在程序运行时检查错误或断言违规，并创建可以触发这些问题的测试输入。
- en: It is also seen as a sort of **white-box fuzzing** because you are fuzzing (see
    the previous section) but you have the knowledge of how the program works (yes,
    also of the code – it’s also something in between static and dynamic analysis).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 它也被视为一种**白盒模糊测试**，因为你在模糊测试（参见上一节）的同时，还了解程序的工作原理（是的，也包括代码——它介于静态分析和动态分析之间）。
- en: 'Consider this very trivial Java method:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个非常简单的Java方法：
- en: '[PRE10]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This method does indeed do something, so its name does not lie, but it doesn’t
    do anything meaningful. It’s just a means to explain how symbolic execution would
    work on it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法确实做了某些事情，所以它的名字并没有撒谎，但它并没有做任何有意义的事情。它只是用来解释符号执行是如何在这个方法上工作的。
- en: 'In a regular execution (often called “concrete” execution), the program operates
    as follows: it reads a specific input value (for example, `10`) and assigns this
    value to the variable, `x`. Subsequently, the program executes the addition (`z
    = x + 2`) and the conditional branch, which, in this case, results in a false
    evaluation and `OK` as the output.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在常规执行（通常称为“具体”执行）中，程序的操作如下：它读取一个特定的输入值（例如，`10`）并将此值分配给变量`x`。随后，程序执行加法操作（`z =
    x + 2`）和条件分支，在这种情况下，导致评估结果为假，输出为`OK`。
- en: During symbolic execution, the program operates differently. It reads a symbolic
    value, represented by a symbol such as λ, and assigns this symbol to the variable,
    `x`. The program then continues with the addition, setting `z` to λ + 2\. When
    it encounters the `if` statement, it evaluates the condition as λ + 2 > 20\. At
    this stage, the symbol λ can take on any value, and symbolic execution splits
    into two distinct paths by «forking.» Each path retains a copy of the program
    state at the branching point along with a path condition.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在符号执行期间，程序的操作方式不同。它读取一个符号值，由一个符号如λ表示，并将此符号分配给变量`x`。然后程序继续进行加法操作，将`z`设置为λ + 2。当它遇到`if`语句时，评估条件为λ
    + 2 > 20。在这个阶段，符号λ可以取任何值，符号执行通过“分支”分为两条不同的路径。每条路径都保留了分支点的程序状态副本以及路径条件。
- en: In this example, one path is associated with the λ + 2 > 20 path condition,
    leading to the execution of the `if` branch, while the other path is tied to the
    λ + 2 <= 20 path condition, resulting in the execution of the `else` branch. Both
    paths can be independently symbolically executed.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，一条路径与`λ + 2 > 20`路径条件相关联，导致执行`if`分支，而另一条路径与`λ + 2 <= 20`路径条件相关联，导致执行`else`分支。这两条路径都可以独立进行符号执行。
- en: As the paths reach their conclusion, which might happen due to an exception
    (for example, throwing a `RuntimeException`) or program termination, symbolic
    execution figures out a specific value for λ by solving the path constraints for
    each path it explores. These specific values can be thought of as real-world test
    cases, which can be instrumental for tasks such as bug reproduction. In this particular
    case, the constraint solver would establish that to throw the `RuntimeException`,
    λ needs to be greater than or equal to 18.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当路径达到其结论时，这可能是由于异常（例如，抛出`RuntimeException`）或程序终止，符号执行通过解决它探索的每个路径的路径约束来找出λ的具体值。这些特定值可以被视为现实世界的测试用例，对于诸如错误复现等任务非常有用。在这种情况下，约束求解器会确定要抛出`RuntimeException`，λ需要大于或等于18。
- en: We must admit that this technique is not used much and presents several downsides.
    For example, as you can easily guess, the greater the cyclomatic complexity of
    the program, the greater the complexity of the symbolic execution; this technique
    does not scale at all as the complexity of the program increases. In addition,
    the efficiency of this analysis technique depends largely on the efficiency of
    the program itself. There are other contradictions that I invite you to observe
    in the *Further* *reading* section.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须承认，这项技术使用得不多，并且存在一些缺点。例如，正如你很容易猜到的，程序的循环复杂度越大，符号执行的复杂性也越大；随着程序复杂性的增加，这项技术根本无法扩展。此外，这种分析技术的效率在很大程度上取决于程序本身的效率。还有其他一些矛盾之处，我邀请你在**进一步阅读**部分观察。
- en: Taint tracking
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 污点跟踪
- en: '**Taint tracking**, often referred to as **information flow tracking** or **data
    flow tracking**, is a technique that’s used in computer security and software
    analysis to monitor the flow of data within a program or system to identify potential
    security vulnerabilities. Taint tracking works by marking data as *tainted* if
    it comes from an untrusted source, such as user input or a file from the internet.
    The taint tracker then tracks the flow of this tainted data through the program
    to identify any operations that could potentially lead to a security vulnerability.
    Tainted data can include things such as passwords, personal information, or any
    data that should not be exposed or manipulated by unauthorized users.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**污点跟踪**，通常被称为**信息流跟踪**或**数据流跟踪**，是一种用于计算机安全和软件分析的技术，用于监控程序或系统内部的数据流动以识别潜在的安全漏洞。污点跟踪通过将数据标记为“污点”，如果它来自不受信任的来源，如用户输入或来自互联网的文件。然后污点跟踪器跟踪这种污点数据在程序中的流动，以识别可能导致安全漏洞的任何操作。污点数据可以包括密码、个人信息或任何不应被未经授权的用户暴露或操作的数据。'
- en: 'Here’s how taint tracking typically works:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是污点跟踪通常的工作方式：
- en: '**Data labeling**: Taint tracking systems label certain data as “tainted” or
    “untrusted” when it originates from external sources, such as user inputs. For
    example, if a user provides a password as input, that password data is labeled
    as tainted.'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据标记**：当数据来自外部来源，如用户输入时，污点跟踪系统会将某些数据标记为“污点”或“不可信”。例如，如果用户提供了密码作为输入，那么该密码数据就会被标记为污点。'
- en: '**Data flow monitoring**: The system then monitors how this tainted data flows
    through the program. It keeps track of which variables, functions, and components
    the tainted data interacts with.'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据流监控**：然后系统监控这种污点数据如何在程序中流动。它跟踪污点数据与哪些变量、函数和组件交互。'
- en: '**Violations detection**: Taint tracking mechanisms continuously check if tainted
    data is used in a way that could compromise security. For example, if tainted
    data is used in a database query, sent over a network, or included in a response,
    the taint tracking system can flag this as a potential security risk.'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**违规检测**：污点跟踪机制持续检查污点数据是否以可能危害安全的方式使用。例如，如果污点数据用于数据库查询、通过网络发送或包含在响应中，污点跟踪系统可以将其标记为潜在的安全风险。'
- en: '**Alerts generation**: When a potential security violation is detected, the
    system can generate alerts, log the event, or take some other predefined action
    to mitigate the risk. This helps in identifying and fixing security vulnerabilities:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**警报生成**：当检测到潜在的安全违规时，系统可以生成警报、记录事件或采取其他预定义的操作来减轻风险。这有助于识别和修复安全漏洞：'
- en: '![Figure 7.2 – One of the possible inputs is marked as tainted (because it
    comes from an untrusted source) and its flow through the program is tracked until
    its possible outputs](img/B20912_07_2.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 其中一个可能的输入被标记为受污染（因为它来自不受信任的来源），并且其通过程序的流动被跟踪，直到其可能的输出](img/B20912_07_2.jpg)'
- en: Figure 7.2 – One of the possible inputs is marked as tainted (because it comes
    from an untrusted source) and its flow through the program is tracked until its
    possible outputs
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 其中一个可能的输入被标记为受污染（因为它来自不受信任的来源），并且其通过程序的流动被跟踪，直到其可能的输出
- en: For example, a taint tracker could be used to identify SQL injection vulnerabilities
    in web applications. SQL injection vulnerabilities occur when an attacker can
    inject malicious SQL code into a web application’s database queries. This can
    allow the attacker to read or modify data in the database, or even execute arbitrary
    code on the web server. A taint tracker could be used to identify SQL injection
    vulnerabilities by marking all user input as tainted. The taint tracker would
    then track the flow of this tainted data through the web application’s code to
    identify any operations that could potentially lead to a SQL injection vulnerability.
    For example, if the tainted data is used in a database query without being properly
    sanitized, the taint tracker would flag this as a potential vulnerability.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以使用污点跟踪器来识别Web应用程序中的SQL注入漏洞。当攻击者能够将恶意SQL代码注入Web应用程序的数据库查询中时，就会发生SQL注入漏洞。这可能会允许攻击者读取或修改数据库中的数据，甚至可以在Web服务器上执行任意代码。污点跟踪器可以通过标记所有用户输入为受污染来识别SQL注入漏洞。然后，污点跟踪器会跟踪这种受污染数据在Web应用程序代码中的流动，以识别可能导致SQL注入漏洞的任何操作。例如，如果受污染的数据在未经适当清理的情况下用于数据库查询，污点跟踪器会将此标记为潜在漏洞。
- en: A small digression – what is SQL injection?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 稍作偏离——什么是SQL注入？
- en: Even if it is not strictly related to taint tracking, we think it is worth knowing
    what **SQL** **injection** is.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 即使它与污点跟踪没有严格的关系，我们认为了解什么是**SQL** **注入**也是值得的。
- en: 'SQL injection is a common and dangerous type of cyber-attack where an attacker
    can manipulate a web application’s SQL query by injecting malicious SQL code.
    This can potentially lead to unauthorized access, data theft, or even data manipulation.
    But how can this happen? Suppose you have a web application that takes user input
    to search for a specific user in a database using the following SQL query:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入是一种常见且危险的网络安全攻击，攻击者可以通过注入恶意SQL代码来操纵Web应用程序的SQL查询。这可能会导致未经授权的访问、数据盗窃，甚至数据篡改。但这是如何发生的呢？假设您有一个Web应用程序，它通过以下SQL查询使用用户输入在数据库中搜索特定用户：
- en: '`SELECT * FROM user WHERE username = ''``input'';`'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT * FROM user WHERE username = ''``input'';`'
- en: Here, the input is taken directly from `user` input, and the application does
    not properly validate or sanitize this `input`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，输入直接来自`用户`输入，并且应用程序没有正确验证或清理这个`输入`。
- en: 'An attacker can exploit this vulnerability by inputting the following as their
    username:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以通过以下方式利用这个漏洞作为他们的用户名：
- en: '`''` `OR ''1''=''1`'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`''` `OR ''1''=''1`'
- en: 'The SQL query would then look like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: SQL查询将看起来像这样：
- en: '`SELECT * FROM users WHERE username = ''''` `OR ''1''=''1'';`'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT * FROM users WHERE username = ''''` `OR ''1''=''1'';`'
- en: The `'1'='1'` condition is always true, so the query effectively selects all
    rows in the `users` table, allowing the attacker to bypass any authentication
    and access all user data.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`''1''=''1''`条件始终为真，因此查询实际上选择了`users`表中的所有行，允许攻击者绕过任何身份验证并访问所有用户数据。'
- en: 'To prevent SQL injection, you should use parameterized queries or prepared
    statements provided by Java’s **Java Database Connectivity** (**JDBC**) API or
    some other popular frameworks, such as Hibernate. Here’s how you can rewrite the
    vulnerable code so that it becomes secure:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止SQL注入，你应该使用Java的**Java数据库连接**（**JDBC**）API或一些其他流行的框架（如Hibernate）提供的参数化查询或预编译语句。以下是您如何重写有漏洞的代码以使其变得安全的方法：
- en: '`String userInput =` `getUserInput();`'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`String userInput =` `getUserInput();`'
- en: '`String sqlQuery = "SELECT * FROM users WHERE username = ?";`'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`String sqlQuery = "SELECT * FROM users WHERE username = ?";`'
- en: '`PreparedStatement preparedStatement =` `connection.prepareStatement(sqlQuery);`'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`PreparedStatement preparedStatement =` `connection.prepareStatement(sqlQuery);`'
- en: '`preparedStatement.setString(1, userInput);`'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`preparedStatement.setString(1, userInput);`'
- en: '`ResultSet resultSet =` `preparedStatement.executeQuery();`'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResultSet resultSet =` `preparedStatement.executeQuery();`'
- en: In this example, a parameterized SQL query is created using `PreparedStatement`,
    where `?` is a placeholder for the user input. The user input is then safely set
    as a parameter using the `setString` method (note that no quotes and no string
    concatenation are involved). The query is executed, and the results are processed
    securely.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，使用`PreparedStatement`创建了一个参数化SQL查询，其中`?`是用户输入的占位符。然后使用`setString`方法安全地将用户输入设置为参数（请注意，没有引号和字符串连接）。查询被执行，结果被安全地处理。
- en: By using parameterized queries like this, you can prevent SQL injection attacks
    because the JDBC driver handles the input as data rather than executable SQL code.
    This ensures the user input is treated safely and doesn’t interfere with the query’s
    structure.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这种参数化查询，你可以防止SQL注入攻击，因为JDBC驱动程序将输入作为数据而不是可执行SQL代码来处理。这确保了用户输入被安全地处理，并且不会干扰查询的结构。
- en: Taint tracking can be used to identify a variety of other security vulnerabilities,
    such as XSS, command injection, and insecure path traversal. It can also be used
    to track the flow of sensitive data, such as credit card numbers and social security
    numbers.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 污点跟踪可用于识别各种其他安全漏洞，例如跨站脚本攻击（XSS）、命令注入和不安全的路径遍历。它还可以用于跟踪敏感数据，如信用卡号和社会安全号码的流动。
- en: Using taint tracking offers various advantages, including the ability to uncover
    security vulnerabilities in software that would be difficult or even impossible
    to identify through alternative testing methods. This approach also allows you
    to monitor sensitive data flow, helping to mitigate the risk of data breaches.
    Moreover, it provides a means to establish security sandboxes, effectively isolating
    untrusted code from trusted components.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用污点跟踪提供了各种优势，包括能够揭示通过其他测试方法难以或甚至无法识别的软件安全漏洞。这种方法还允许你监控敏感数据流动，有助于减轻数据泄露的风险。此外，它提供了一种建立安全沙箱的方法，有效地将不受信任的代码与受信任组件隔离开来。
- en: Nonetheless, taint tracking presents several challenges. Its implementation
    can be intricate, requiring expertise in software security and taint tracking.
    It may introduce a performance impact on the monitored program, and it can result
    in a significant number of false positives, which can be time-consuming to investigate.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，污点跟踪也带来了一些挑战。其实现可能很复杂，需要软件安全和污点跟踪的专业知识。它可能会对被监控程序的性能产生影响，并可能导致大量误报，这可能会耗费大量时间进行调查。
- en: It is worth noticing that some programming languages, such as Perl, Ruby, or
    Ballerina, natively support *taint checking*, a feature that proceeds variable
    by variable, forming a list of variables that are potentially influenced by outside
    input. More information can be found in the *Further* *reading* section.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，一些编程语言，如Perl、Ruby或Ballerina，原生支持*污点检查*功能，该功能逐个变量进行，形成一个可能受外部输入影响的变量列表。更多信息可以在*进一步阅读*部分找到。
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we added another tool to our toolbox for writing and maintaining
    clean code and efficient software: code analysis. We learned that we can do it
    in two ways: by checking the code before it’s even run (statically) and by watching
    the code as it runs (dynamically). We tried to figure out what kind of problems
    we should look out for in each of these analyses, and we also found some tools
    and techniques that can help.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们为编写和维护干净代码以及高效软件的工具箱添加了另一个工具：代码分析。我们了解到我们可以通过两种方式来完成它：在代码运行之前（静态地）检查代码，以及在代码运行时（动态地）监视代码。我们试图弄清楚在每个分析中应该注意哪些问题，并且我们还找到了一些工具和技术可以帮助我们。
- en: Just like the other stuff we’ve covered, this chapter is meant to give you ideas
    for going deeper. Code analysis is often seen as something extra, like an optional
    step, but it’s a crucial part of making a project efficient and easy to maintain.
    So, don’t underestimate its importance!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前讨论的其他内容一样，这一章节旨在为你提供深入学习的思路。代码分析通常被视为额外的步骤，就像一个可选的过程，但它却是使项目高效且易于维护的关键部分。因此，不要低估它的重要性！
- en: Besides the times when you do analysis and improve your work, it’s crucial to
    keep a certain level of quality in your everyday tasks. You can make a significant
    difference with minimal, targeted effort by using some simple but effective methods.
    In the next chapter, we’ll explore some of these methods.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 除了进行分析和改进工作的时候，保持日常任务的一定质量水平同样至关重要。通过使用一些简单但有效的方法，你可以用最小的、有针对性的努力产生显著的效果。在下一章中，我们将探讨这些方法中的一些。
- en: Further reading
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Cyclomatic complexity: [https://www.geeksforgeeks.org/cyclomatic-complexity/](https://www.geeksforgeeks.org/cyclomatic-complexity/)'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点复杂度：[https://www.geeksforgeeks.org/cyclomatic-complexity/](https://www.geeksforgeeks.org/cyclomatic-complexity/)
- en: 'SonarQube documentation: [https://docs.sonarsource.com/sonarqube/latest/](https://docs.sonarsource.com/sonarqube/latest/)'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SonarQube文档：[https://docs.sonarsource.com/sonarqube/latest/](https://docs.sonarsource.com/sonarqube/latest/)
- en: 'PMD documentation: [https://pmd.github.io/pmd/index.html](https://pmd.github.io/pmd/index.html)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PMD文档：[https://pmd.github.io/pmd/index.html](https://pmd.github.io/pmd/index.html)
- en: 'FindBugs manual: [https://findbugs.sourceforge.net/manual/index.html](https://findbugs.sourceforge.net/manual/index.html)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FindBugs手册：[https://findbugs.sourceforge.net/manual/index.html](https://findbugs.sourceforge.net/manual/index.html)
- en: 'An introduction to CheckStyle: [https://www.baeldung.com/checkstyle-java](https://www.baeldung.com/checkstyle-java)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CheckStyle简介：[https://www.baeldung.com/checkstyle-java](https://www.baeldung.com/checkstyle-java)
- en: 'Getting started with VisualVM: [https://visualvm.github.io/gettingstarted.html](https://visualvm.github.io/gettingstarted.html)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用VisualVM：[https://visualvm.github.io/gettingstarted.html](https://visualvm.github.io/gettingstarted.html)
- en: 'M. Sutton, A. Greene, and P. Amini, *Fuzzing: Brute Force Vulnerability Discovery*,
    by Addison-Wesley Professional'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'M. Sutton, A. Greene, 和 P. Amini，*Fuzzing: Brute Force Vulnerability Discovery*，由Addison-Wesley
    Professional出版'
- en: 'Hallway usability testing: [https://www.techopedia.com/definition/30678/hallway-usability-testing](https://www.techopedia.com/definition/30678/hallway-usability-testing)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 走廊可用性测试：[https://www.techopedia.com/definition/30678/hallway-usability-testing](https://www.techopedia.com/definition/30678/hallway-usability-testing)
- en: 'Limitations of symbolic execution: [https://en.wikipedia.org/wiki/Symbolic_execution#Limitations](https://en.wikipedia.org/wiki/Symbolic_execution#Limitations)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号执行的局限性：[https://en.wikipedia.org/wiki/Symbolic_execution#Limitations](https://en.wikipedia.org/wiki/Symbolic_execution#Limitations)
- en: 'Taint checking in programming languages: [https://en.wikipedia.org/wiki/Taint_checking](https://en.wikipedia.org/wiki/Taint_checking)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程语言中的污点检查：[https://en.wikipedia.org/wiki/Taint_checking](https://en.wikipedia.org/wiki/Taint_checking)
- en: 'Part 3: Further Learning'
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：进一步学习
- en: Apart from the actual act of refactoring, it’s crucial to keep up a certain
    level of quality in your everyday work. There are small but powerful ways to achieve
    this goal, making a big impact with minimal, focused effort. We’ll discuss things
    like how you format your code, manage versions of your code, and work together
    with others through techniques like pair programming.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实际的重构行为之外，保持日常工作中一定水平的质量至关重要。有一些小而强大的方法可以实现这一目标，以最小的、集中的努力产生重大影响。我们将讨论如何格式化代码、管理代码版本以及通过结对编程等技术与他人合作。
- en: 'After we’ve covered everything about fixing up classes and packages, let’s
    zoom out and look at the big picture: architecture. Even if your code is good,
    things can go wrong if the way different parts interact is not well-managed. We’ll
    talk about signs to watch out for and what to do instead to keep everything running
    smoothly.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们涵盖了关于修复类和包的所有内容之后，让我们退后一步，看看大局：架构。即使你的代码很好，如果不同部分之间的交互没有得到妥善管理，事情也可能出错。我们将讨论需要注意的迹象以及如何采取替代措施以确保一切顺利运行。
- en: 'This part has the following chapters:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 8*](B20912_08.xhtml#_idTextAnchor183), *Crafting Quality Every Day*'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B20912_08.xhtml#_idTextAnchor183)，*每天打造质量*'
- en: '[*Chapter 9*](B20912_09.xhtml#_idTextAnchor217), *Beyond Code – Mastering Software
    Architecture*'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B20912_09.xhtml#_idTextAnchor217)，*超越代码 - 掌握软件架构*'
