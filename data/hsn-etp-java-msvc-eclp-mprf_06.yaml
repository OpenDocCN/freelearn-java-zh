- en: MicroProfile Health Check and JWT Propagation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile健康检查与JWT传播
- en: In this chapter, we will introduce the MicroProfile Health Check and **JSON
    Web Token** (**JWT**) Propagation projects. The Health Check project is concerned
    with exposing the application-defined health to the outside world, and JWT Propagation
    is concerned with defining an interoperable security token and use of that token
    in an application. In this chapter, you will learn the concerns that these specifications
    address, their constructs, and how to use them in your application. The code snippets
    throughout this chapter are for reference only. If you would like a working code
    version of this specification, please refer to [Chapter 8](5535a9c6-c887-40a5-95cd-c8b51ef75bf1.xhtml),
    *A Working Eclipse MicroProfile Code Sample*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍健康检查项目及其关注点，它们的构造方式，以及在应用程序中如何使用它们。本章中的代码片段仅供参考。如果您需要一个工作的代码版本，请参考[第8章](5535a9c6-c887-40a5-95cd-c8b51ef75bf1.xhtml)，*一个工作的Eclipse
    MicroProfile代码示例*。
- en: 'We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: What a health check is
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 健康检查是什么
- en: How MicroProfile Health Check exposes the health check endpoint and the format
    of a query to that endpoint
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MicroProfile健康检查如何暴露健康检查端点和查询该端点的格式
- en: How to write a MicroProfile Health Check for your application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为您的应用程序编写MicroProfile健康检查
- en: The required format for the tokens in MicroProfile JWT Propagation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MicroProfile JWT传播中令牌的所需格式
- en: How we can leverage MicroProfile JWT Propagation for security decisions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何利用MicroProfile JWT传播进行安全决策
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To build and run the samples in this chapter, you need Maven 3.5+ and a Java
    8 JDK. The code for this chapter can be found at [https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-healthcheck](https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-healthcheck) and
    [https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-jwtpropagation](https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-jwtpropagation)
    for the MicroProfile Health Check and MicroProfile Propagation JWT sections, respectively.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建和运行本章中的示例，您需要Maven 3.5+和Java 8 JDK。本章的代码可以在[https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-healthcheck](https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-healthcheck)和[https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-jwtpropagation](https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-jwtpropagation)找到，分别对应于MicroProfile健康检查和MicroProfile传播JWT部分。
- en: Understanding health checks and how MicroProfile handles them
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解健康检查以及MicroProfile如何处理它们
- en: In cloud-native architectures, health checks are used to determine whether a
    computing node is alive and ready to perform work. The concept of readiness describes
    the state when containers start up or roll over (that is, redeployment). During
    this time, the cloud platform needs to ensure that no network traffic is routed
    to that instance before it is ready to perform work.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在云原生架构中，健康检查用于确定计算节点是否存活并准备好执行工作。就绪状态描述了容器启动或滚动更新（即，重新部署）时的状态。在此期间，云平台需要确保没有网络流量路由到该实例，直到它准备好执行工作。
- en: Liveness, on the other hand, describes the state of a running container; that
    is, can it still respond to requests? If either the liveness or readiness states
    are seen as invalid, the computing node will be discarded (terminated or shut
    down) and eventually replaced by another, healthy, instance.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 生存性，另一方面，描述运行容器的状态；也就是说，当容器启动或滚动更新（即重新部署）时，它处于就绪状态。在此期间，云平台需要确保没有网络流量路由到该实例，直到它准备好执行工作。
- en: Health checks are an essential contract with the orchestration framework and
    scheduler of the cloud platform. The check procedures are provided by the application
    developer and the platform uses these to continuously ensure the availability
    of your application or service.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查是与云平台调度程序和应用程序编排框架之间的基本合同。检查程序由应用程序开发者提供，平台使用这些程序来持续确保应用程序或服务的可用性。
- en: MicroProfile Health Check 1.0 (MP-HC) supports a single health check endpoint
    that can be utilized for either a liveness or readiness check. MicroProfile Health
    Check 2.0 plans to add support for multiple endpoints to allow an application
    to define both liveness and readiness probes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务健康检查1.0（MP-HC）支持一个单一的健康检查端点，可以用于活动或就绪检查。微服务健康检查2.0计划添加对多个端点的支持，以允许应用程序定义活动和就绪探测器。
- en: 'The MP-HC specification details two elements: a protocol along with a response
    wire format part and a Java API for defining the response content.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务健康检查规范详细介绍了两个元素：一个协议以及响应线缆格式部分和一个用于定义响应内容的Java API。
- en: The architecture of the MP-HC feature is modeled as an application that consists
    of zero or more health check procedures that are logically linked together with
    `AND` to derive the overall health check status. A procedure represents an application-defined
    check of a required condition that has a name, state, and, optionally, data about
    the check.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务健康检查（MP-HC）特性的架构被建模为一个由零个或多个逻辑链接在一起的健康检查过程组成的应用程序，这些过程通过`AND`来推导出整体健康检查状态。一个过程代表了一个应用程序定义的检查一个必要条件的操作，它有一个名字、状态，以及可选的关于检查的数据。
- en: The Health Check protocol and wire format
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 健康检查协议和线缆格式
- en: 'The MP-HC specification defines the requirement to support the HTTP GET requests
    against a logical `/health` REST endpoint that may return any one of the following
    codes to represent the endpoint''s status:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务健康检查规范定义了支持对逻辑`/health` REST端点的HTTP GET请求的要求，该端点可能返回以下任一代码来表示端点的状态：
- en: '`200`: It is up and healthy.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`200`：它正在运行并且是健康的。'
- en: '`500`: It is unhealthy due to an unknown error.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`500`：由于未知错误而不健康。'
- en: '`503`: It is down and not ready to respond to requests.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`503`：它已经关闭，无法对请求做出响应。'
- en: Note that many cloud environments simply look at the request return code as
    either success or failure, so the differentiation between a `500` and `503` code
    may not be distinguishable.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，许多云环境只是将请求返回代码视为成功或失败，所以`500`和`503`代码之间的区别可能无法区分。
- en: The payload of a `/health` request must be a JSON object that matches the schema
    given in the following (for more information on the JSON schema syntax see [http://jsonschema.net/#/](http://jsonschema.net/#/)).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`/health`请求的负载必须是一个与下面给出的架构匹配的JSON对象（有关JSON架构语法的更多信息，请参见[http://jsonschema.net/#/](http://jsonschema.net/#/)）。'
- en: Following is ...
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是...
- en: The Health Check Java API
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 健康检查Java API
- en: Most of the plumbing is performed by the application framework that implements
    the MP-HC specification. Your part is to decide how liveness or readiness are
    determined through the health check procedures that your microservice defines
    using the MP-HC API.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分工作由实现微服务健康检查规范的应用程序框架完成。你的任务是通过使用微服务健康检查（MP-HC）API定义的健康检查过程来决定活动或就绪是如何确定的。
- en: To do this, you need to implement a health check procedure by implementing one
    or more instances of the `HealthCheck` interface using beans that are marked with
    a `Health` annotation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，你需要通过使用带有`Health`注解的beans实现一个或多个`HealthCheck`接口实例来执行健康检查过程。
- en: 'The `HealthCheck` interface is provided in the following code block:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`HealthCheck`接口如下：'
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The code for the `Health` annotation is provided in the following code block:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`Health`注解的代码如下：'
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: An example `HealthCheck` implementation that represents the status of a hypothetical
    disk space check is shown in the following example. Note that the check includes
    the current free space as part of the response data. The `HealthCheckResponse` class
    supports a builder interface to populate the response object.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的例子展示了一个表示假设磁盘空间检查状态的`HealthCheck`实现。注意检查将当前的空闲空间作为响应数据的一部分。`HealthCheckResponse`类支持一个构建器接口来填充响应对象。
- en: 'Following is a hypothetical disk space `HealthCheck` procedure implementation:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个假设的磁盘空间`HealthCheck`过程实现：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, we created a health response that is named `diskspace` with
    a status of `up` and custom data named `free` with a string value of `780mb`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为`diskspace`的健康响应，其状态为`up`，并带有名为`free`的自定义数据，其字符串值为`780mb`。
- en: Another health check example representing some service endpoint is shown in
    the following.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的例子展示了一个表示某些服务端点的健康检查示例。
- en: 'A hypothetical service `HealthCheck` procedure implementation is shown here:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下面展示了一个假设的服务`HealthCheck`过程实现：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this example, we created a health response named `service-check` with a
    status of `up` that includes the following additional data:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为`service-check`的健康响应，其状态为`up`，并包括了以下附加数据：
- en: A `port` item with an integer value of `12345`
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个整数值为`12345`的`port`项
- en: An `isSecure` item with a Boolean value of `true`
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个值为`true`的布尔`isSecure`项
- en: A `hostname` item with a string value of `service.jboss.com`
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个值为`service.jboss.com`的字符串`hostname`项
- en: 'The CDI-managed health checks are discovered and registered automatically by
    the application runtime. The runtime automatically exposes an HTTP endpoint, `/health`,
    used by the cloud platform to poke into your application to determine its state.
    You can test this by building the `Chapter04-healthcheck` application and running
    it. You will see the following output:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由CDI管理的健康检查由应用程序运行时自动发现和注册。运行时自动暴露一个HTTP端点，`/health`，供云平台用来探测您的应用程序状态。您可以通过构建`Chapter04-healthcheck`应用程序并运行它来测试这一点。您将看到以下输出：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once the server has started, test the health checks by querying the health
    endpoint:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器启动，通过查询健康端点来测试健康检查：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This shows the overall health to be `UP`. The overall status is the logical
    `OR` of all of the health check procedures found in the application. In this case,
    it is `AND` of the two health check procedures we have seen: `diskspace` and `service-check`.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了整体健康状况为`UP`。整体状态是应用程序中找到的所有健康检查程序的逻辑`OR`。在这个例子中，它是我们所看到的两个健康检查程序`diskspace`和`service-check`的`AND`。
- en: Integration with the cloud platform
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与云平台的集成
- en: Most cloud platforms support both TCP- and HTTP-based checks. To integrate health
    checks with your selected cloud platform, you need to configure your cloud deployment
    to point to the HTTP entry point, `/health`, on the node that hosts your application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数云平台都支持基于TCP和HTTP的检查。为了将健康检查与您选择的云平台集成，您需要配置云部署，使其指向托管应用程序的节点上的HTTP入口点，`/health`。
- en: The cloud platform will invoke a `GET` query on the HTTP entry point; all checks
    that are registered will be performed and the sum of individual checks determines
    the overall outcome.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 云平台将调用HTTP入口点的`GET`查询；所有注册的检查都将执行，个别检查的总和决定了整体结果。
- en: Usually, the response payload is ignored by the cloud platform and it only looks
    at the HTTP status code to determine the liveness or readiness of your application.
    A successful outcome, `UP`, will be mapped to `200` and `DOWN` to `503`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，响应载荷被云平台忽略，它只查看HTTP状态码来确定应用程序的存活或就绪状态。成功的成果，`UP`，将被映射到`200`，而`DOWN`将被映射到`503`。
- en: Human operators
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人类操作者
- en: 'The primary use case for the JSON response payload is to provide a way for
    operators to investigate the application state. To support this, health checks
    allow for additional data to be attached to a health check response as we have
    seen in the `CheckDiskspace` and `ServiceCheck` examples. Consider the following
    fragment:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: JSON响应载荷的主要用例是提供一种让操作者调查应用程序状态的方式。为了支持这一点，健康检查允许将附加数据附加到健康检查响应中，正如我们在`CheckDiskspace`和`ServiceCheck`示例中所看到的那样。考虑以下片段：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, the additional information about `free-heap` is provided and will become
    part of the response payload, as shown in this response fragment. The JSON response
    fragment showing `memory-check` procedure content is as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，提供了关于`free-heap`的附加信息，并将成为响应载荷的一部分，正如这个响应片段所示。显示`memory-check`程序内容的JSON响应片段如下：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we see the `memory-check` procedure with its `UP` state and additional
    `free-heap` data item of the string type with the value of `64mb`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到`memory-check`程序以其`UP`状态和字符串类型的附加`free-heap`数据项，值为`64mb`。
- en: '**Eclipse resources/GitHub coordinates for MP-Health**:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**Eclipse资源/GitHub中MP-Health的坐标**：'
- en: The MP-Health project source code can be found at [https://github.com/eclipse/microprofile-health](https://github.com/eclipse/microprofile-health).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: MP-Health项目源代码可以在[https://github.com/eclipse/microprofile-health](https://github.com/eclipse/microprofile-health)找到。
- en: Changes in Health Check response messages
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 健康检查响应消息的变化
- en: MicroProfile Health Check 3.0 introduced changes to the message format of health
    check JSON responses. Specifically, the field's outcome and state have been replaced
    by the field status.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile Health Check 3.0对健康检查JSON响应的消息格式进行了更改。具体来说，字段的成果和状态已经被字段状态所取代。
- en: In addition, the `@Health` qualifier was deprecated in the Health Check 3.0
    release, while the `@Liveness` and `@Readiness` qualifiers were introduced. For
    the two qualifiers, the `/health/live` and `/health/ready` endpoints were also
    introduced to call all the liveliness and readiness procedures, respectively.
    Lastly, for backward compatibility, `/health` endpoint now calls all the procedures
    that have `@Health`, `@Liveness`, or `@Readiness` qualifiers.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在健康检查3.0版本中，`@Health`限定符已被弃用，而`@Liveness`和`@Readiness`限定符已被引入。对于这两个限定符，还引入了`/health/live`和`/health/ready`端点，分别调用所有存活性和就绪性程序。最后，为了向后兼容，`/health`端点现在会调用所有具有`@Health`、`@Liveness`或`@Readiness`限定符的程序。
- en: It's time to discuss JWT Propagation now.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候讨论JWT传播了。
- en: Using JSON Web Token Propagation in MicroProfile
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在MicroProfile中使用JSON Web Token传播
- en: A **JSON Web Token** (**JWT**) is a common format for carrying security information
    that is used by many different web-based security protocols. However, there is
    a lack of standardization around exactly what the contents of the JWT are and
    what security algorithms are used with signed JWTs. The **MicroProfile JWT** (**MP-JWT**) Propagation
    project specification looked at the **OpenID Connect** (**OIDC**)-based ([http://openid.net/connect/](http://openid.net/connect/)) JWT
    ([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)) specifications
    and built upon those to define a set of requirements to promote interoperability
    of JWTs for use in MicroProfile-based microservices, along with APIs to access
    information from the JWTs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**JSON Web Token**（**JWT**）是许多不同的基于web的安全协议中用于携带安全信息的一种常见格式。然而，JWT的确切内容以及与已签名JWT一起使用的安全算法缺乏标准化。**微服务JWT**（**MP-JWT**）传播项目规范审视了基于**OpenID
    Connect**（**OIDC**）的JWT（[http://openid.net/connect/](http://openid.net/connect/)）规范，并在这些规范的基础上定义了一组需求，以促进基于MicroProfile的微服务中JWT的互操作性，同时还提供了从JWT中访问信息的API。
- en: For a description of how OIDC and JWT work, including how an application/microservice
    intercepts bearer tokens, please refer to the *Basic Client Implementer's Guide*
    at [http://openid.net/connect/](http://openid.net/connect/).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有关OIDC和JWT如何工作的描述，包括应用程序/微服务如何拦截承载令牌，请参阅[http://openid.net/connect/](http://openid.net/connect/)上的*基本客户端实现指南*。
- en: 'In this section, you will learn about the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将了解以下内容：
- en: The claims and signature algorithms from OIDC and JWT specifications that were
    required for interoperability
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了互操作性，所需的OIDC和JWT规范中的声明和签名算法
- en: Using JWTs for **Role-Based Access Control** (**RBAC**) of microservice endpoints
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JWT进行**基于角色的访问控制**（**RBAC**）的微服务端点
- en: How to use the MP-JWT APIs to access a JWT and its claim values
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用MP-JWT API来访问JWT及其声明值
- en: Recommendations for interoperability
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互操作性的建议
- en: 'The maximum utility of MP-JWT as a token format depends on the agreement between
    both identity providers and service providers. This means identity providers—responsible
    for issuing tokens—should be able to issue tokens using the MP-JWT format in a
    way that service providers can understand to inspect the token and gather information
    about a subject. The primary goals for MP-JWT are as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: MP-JWT作为令牌格式的最大效用取决于身份提供商和服务提供商之间的协议。这意味着负责发行令牌的身份提供商应该能够以服务提供商可以理解的方式发行MP-JWT格式的令牌，以便服务提供商可以检查令牌并获取有关主题的信息。MP-JWT的主要目标如下：
- en: It should be usable as an authentication token.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该可以用作认证令牌。
- en: It should be usable as an authorization token that contains application-level
    roles indirectly granted via a group's claim.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该可以用作包含通过组声明间接授予的应用级角色的授权令牌。
- en: It can support additional standard claims described in IANA JWT Assignments
    ([https://www.iana.org/assignments/jwt/jwt.xhtml](https://www.iana.org/assignments/jwt/jwt.xhtml)),
    as well as non-standard ...
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持IANA JWT分配（[https://www.iana.org/assignments/jwt/jwt.xhtml](https://www.iana.org/assignments/jwt/jwt.xhtml)）中描述的额外标准声明，以及非标准...
- en: Required MP-JWT claims
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 必需的MP-JWT声明
- en: 'The required set of MP-JWT claims for which an implementation needs to provide
    support contains the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 需要提供支持的MP-JWT声明集合包括以下内容：
- en: '`typ`: This header parameter identifies the token type and is required to be
    `JWT`.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`typ`：此头部参数标识令牌类型，必须是`JWT`。'
- en: '`alg`: This header algorithm was used to sign the JWT and must be specified
    as `RS256`.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alg`：此头部算法用于签署JWT，必须是`RS256`。'
- en: '`kid`: This header parameter provides a hint about which public key was used
    to sign the JWT.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kid`：这个头部参数提供了一个提示，关于用哪个公钥签署了JWT。'
- en: '`iss`: This is the issuer and signer of the token.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iss`：这是令牌的发行者和签名者。'
- en: '`sub`: This identifies the subject of the JWT.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sub`：这标识了JWT的主题。'
- en: '`exp`: This identifies the expiration time on, or after, which the JWT MUST
    NOT be accepted for processing.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exp`：这标识了JWT在或之后过期的时刻，此时JWT不得被处理。'
- en: '`iat`: This identifies the time at which the JWT was issued and can be used
    to determine the age of the JWT.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iat`：这标识了JWT的发行时间，可以用来确定JWT的年龄。'
- en: '`jti`: This provides a unique identifier for the JWT.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jti`：这为JWT提供了一个唯一标识符。'
- en: '`upn`: This MP-JWT custom claim is the preferred way to specify a user principal
    name.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`upn`：这是MP-JWT自定义声明，是指定用户主体名称的首选方式。'
- en: '`groups`: This MP-JWT custom claim is the list of group or role names assigned
    to the JWT principal.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groups`：这是MP-JWT自定义声明，用于分配给JWT主体的组或角色名称列表。'
- en: '`NumericDate` used by `exp`, `iat`, and other date-related claims is a JSON
    numeric value representing the number of seconds from `1970-01-01T00:00:00Z` UTC
    until the specified UTC date/time, ignoring leap seconds. Additionally, more details
    about the standard claims may be found in the MP-JWT specification ([https://github.com/eclipse/microprofile-jwt-auth/releases/tag/1.1.1](https://github.com/eclipse/microprofile-jwt-auth/releases/tag/1.1.1))
    and the JSON Web Token RFC ([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`NumericDate`用于`exp`、`iat`和其他日期相关声明是一个表示从`1970-01-01T00:00:00Z` UTC直到指定UTC日期/时间的JSON数值值，忽略闰秒。此外，有关标准声明的更多详细信息可以在MP-JWT规范([https://github.com/eclipse/microprofile-jwt-auth/releases/tag/1.1.1](https://github.com/eclipse/microprofile-jwt-auth/releases/tag/1.1.1))和JSON
    Web Token RFC([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519))中找到。'
- en: 'An example basic MP-JWT in JSON would be a sample header and payload of an
    MP-JWT compatible JWT, as shown here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基本的MP-JWT的JSON示例将是与MP-JWT兼容的JWT的示例头和载荷，如下所示：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This example shows the header with `typ=JWT`, `alg=RS256`, and `kid=abc-1234567890`.
    The body includes the `iss`, `jti`, `exp`, `iat`, `sub`, `upn`, and `groups` claims.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例显示了具有`typ=JWT`、`alg=RS256`和`kid=abc-1234567890`的头部。正文包括`iss`、`jti`、`exp`、`iat`、`sub`、`upn`和`groups`声明。
- en: The high-level description of the MP-JWT API
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MP-JWT API的高级描述
- en: 'The MP-JWT project introduces the following API interfaces and classes under
    the `org.eclipse.microprofile.jwt` package namespace:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: MP-JWT项目在`org.eclipse.microprofile.jwt`包命名空间下引入了以下API接口和类：
- en: '`JsonWebToken`: This is a `java.security.Principal` interface extension that
    makes the set of required claims available via get-style accessors, along with
    general access to any claim in the JWT.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JsonWebToken`：这是`java.security.Principal`接口的一个扩展，通过get风格的访问器提供所需声明的集合，同时提供对JWT中任何声明的通用访问。'
- en: '`Claims`: This is an enumeration utility class that encapsulates all of the
    standard JWT-related claims along with a description and the required Java type
    for the claim as returned from the `JsonWebToken#getClaim(String)` method.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Claims`：这是一个封装了所有标准JWT相关声明以及描述和返回自`JsonWebToken#getClaim(String)`方法的声明所需Java类型的枚举实用类。'
- en: '`Claim`: This is a qualifier annotation used to signify an injection point
    for `ClaimValue`.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Claim`：这是一个用于指示`ClaimValue`注入点的限定注解。'
- en: '`ClaimValue<T>`: This is a `java.security.Principal` interface extension ...'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClaimValue<T>`：这是`java.security.Principal`接口的一个扩展...'
- en: Sample code that uses MP-JWT
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MP-JWT的示例代码
- en: The basic usage of the MP-JWT API is to inject `JsonWebToken`, its `ClaimValue`,
    or both. In this section, we present snippets of typical usage. This book's code
    for this section is available at [https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-jwtpropagation](https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-jwtpropagation).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: MP-JWT API的基本用法是注入`JsonWebToken`、其`ClaimValue`或两者。在本节中，我们将展示典型用法的代码片段。本书本节代码可在[https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-jwtpropagation](https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-jwtpropagation)找到。
- en: Injection of JsonWebToken information
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注入JsonWebToken信息
- en: 'The following code sample illustrates access of the incoming MP-JWT token as `JsonWebToken`,
    the raw JWT token string, the `upn` claim, and integration with JAX-RS `SecurityContext`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例说明了如何访问传入的MP-JWT令牌作为`JsonWebToken`、原始JWT令牌字符串、`upn`声明以及与JAX-RS`SecurityContext`的集成：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Injection of JWT claim values
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向JWT断言值注入
- en: The code snippet in this section illustrates the injection of individual JWT
    claim values. There are several different formats we can use for the injected
    value. Standard claims support the object subtypes defined in the `Claim#getType`
    field and `JsonValue` subtypes. Custom claim types only support the injection
    of the `JsonValue` subtypes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的代码片段说明了JWT断言值的注入。我们可以使用几种不同的格式作为注入值。标准断言支持在`Claim#getType`字段和`JsonValue`子类型中定义的对象子类型。自定义断言类型只支持`JsonValue`子类型的注入。
- en: 'The following code example illustrates injection of the standard `groups` and
    `iss` claims, along with `customString`, `customInteger`, `customDouble`, and
    `customObject` custom claims:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例说明了标准`groups`和`iss`断言的注入，以及`customString`、`customInteger`、`customDouble`和`customObject`自定义断言的注入：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The eight commented injections are as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 八个注释注入如下：
- en: Injection of the standard `groups` claim as its default `Set<String>` type
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将标准`groups`断言作为其默认`Set<String>`类型注入
- en: Injection of the standard `iss` claim as its default String type
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将标准`iss`断言作为其默认字符串类型注入
- en: Injection of the standard `groups` claim as its default `JsonArray` type
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将标准`groups`断言作为其默认`JsonArray`类型注入
- en: Injection of the standard `iss` claim as its default `JsonString` type
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将标准`iss`断言作为其默认`JsonString`类型注入
- en: Injection of a non-standard `customString` claim as a `JsonString` type
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`JsonString`类型的`customString`断言中注入非标准自定义字符串
- en: Injection of a non-standard `customInteger` claim as a `JsonNumber` type
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`JsonNumber`类型的非标准`customInteger`断言中注入
- en: Injection of a non-standard `customDouble` claim as a `JsonNumber` type
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`JsonNumber`类型的非标准`customDouble`断言中注入
- en: Injection of a non-standard `customObject` claim as a `JsonString` type
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`JsonString`类型的`customObject`断言中注入非标准自定义对象
- en: Configuring authentication of JWTs
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置JWT的认证
- en: 'To accept a JWT as representing an identity that should be authenticated and
    therefore trusted, we need to configure the MP-JWT feature with the information
    to verify who signed and who issued the JWT. This is done via MP-Config properties:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了接受JWT作为应进行认证并因此受信任的身份，我们需要配置MP-JWT功能以验证谁签署了JWT以及谁发布了JWT。这是通过MP-Config属性完成的：
- en: '`mp.jwt.verify.publickey`: This provides the embedded key material of the public
    key for the MP-JWT signer, typically in PKCS8 PEM format.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mp.jwt.verify.publickey`：这提供了MP-JWT签名者的公钥材料，通常以PKCS8 PEM格式嵌入。'
- en: '`mp.jwt.verify.issuer`: This specifies the expected value of the `iss` claim
    found in the JWT.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mp.jwt.verify.issuer`：这指定了JWT中`iss`断言的预期值。'
- en: 'An example `microprofile-configuration.properties` file for this book is as
    follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的一个`microprofile-configuration.properties`文件示例如下：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Running the samples
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行示例
- en: The samples we looked at can be deployed to Thorntail and accessed via command-line
    queries against the endpoints to validate the expected behaviors. Since authentication
    against the endpoints marked with security constraints requires a valid JWT, we
    need a way to generate a JWT that will be accepted by the Thorntail server.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们查看的示例可以部署到Thorntail，并通过针对端点的命令行查询来验证预期行为。由于需要对带有安全约束的端点进行认证，因此我们需要一种生成将被Thorntail服务器接受的有效JWT的方法。
- en: 'This chapter''s code provides an `io.packt.jwt.test.GenerateToken` utility
    that will create a JWT signed by a key that has been configured with the Thorntail
    server. The claims included in the JWT are defined by the `src/test/resources/JwtClaims.json`
    document of this chapter''s project. You run the utility using the `mvn exec:java`
    command, as shown here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 本章代码提供了一个`io.packt.jwt.test.GenerateToken`工具，该工具将由配置在Thorntail服务器上的密钥签发的JWT。JWT中包含的断言由本章项目的`src/test/resources/JwtClaims.json`文档定义。您使用`mvn
    exec:java`命令运行该工具，如下所示：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The utility outputs the claims that were added and then prints out the base64-encoded
    JWT. You would use this JWT as the value in the `Authorization: Bearer …` header
    of the `curl` command line you used to access the server endpoints.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '该工具输出了添加的断言，然后打印出Base64编码的JWT。您将使用这个JWT作为`curl`命令行中访问服务器端点的`Authorization:
    Bearer …`头部的值。'
- en: 'To start up the Thorntail server with the example endpoints, `cd` into the `Chapter04-jwtpropagation` project
    directory and then run `mvn` to build the executable JAR:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动带有示例端点的Thorntail服务器，请进入`Chapter04-jwtpropagation`项目目录，然后运行`mvn`以构建可执行的JAR：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The resulting executable JAR is located at `target/jwt-propagation-thorntail.jar`.
    You start up the Thorntail server with this chapter''s sample deployment using
    `java -jar …`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的可执行JAR位于`target/jwt-propagation-thorntail.jar`。你使用本章的示例部署和`java -jar …`命令启动Thorntail服务器：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'At this point, we can query the server endpoints. There is one endpoint that
    we defined that does not require any authentication. This is the `jwt/openHello`
    endpoint of the `io.pckt.jwt.rest.SecureEndpoint` class. Run the following command
    to validate that your Thorntail server is running as expected:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，我们可以查询服务器端点。有一个端点是我们定义的，不需要任何认证。这是`io.pckt.jwt.rest.SecureEndpoint`类的`jwt/openHello`端点。运行以下命令来验证你的Thorntail服务器是否如预期运行：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, try the secured endpoint. It should fail with a 401 Not authorized error
    because we are not providing any authorization information:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，尝试受保护的端点。它应该会因为未提供任何授权信息而失败，返回401未授权错误：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we need to generate a fresh JWT and pass that along with the curl command
    in the `Authorization` header, so let''s try that. We will save the JWT generated
    by the mvn command in a JWT environment variable to simplify the curl command
    line:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要生成一个新的JWT，并将其与curl命令一起在`Authorization`头中传递，让我们试一试。我们将使用mvn命令生成的JWT在JWT环境变量中保存，以简化curl命令行：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the previous code snippet, for Windows users, please install a bash-compatible
    shell for Windows; otherwise, you will get an error due to the `echo` command.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，对于Windows用户，请为Windows安装一个与bash兼容的壳程序；否则，由于`echo`命令错误，你将遇到错误。
- en: This time, the query succeeds and we see that the username, `upn` claim value,
    scheme, and `isUserInRole("User")` check are as expected.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，查询成功，我们看到用户名`upn`声明值、方案和`isUserInRole("User")`检查都如预期一样。
- en: 'Now, try accessing the `/jwt/printClaims` endpoint that illustrated the injection
    of standard and non-standard claims as different types:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试访问`/jwt/printClaims`端点，该端点说明了标准和非标准声明作为不同类型的注入：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Note that, if you begin to experience `Not authorized errors` after a while,
    the problem is that the JWT has expired. You either need to generate a new token
    or generate a token with a longer expiration. You can do this by passing in the
    expiration in seconds to the `GenerateToken` utility. For example, to generate
    a token that is valid for a full hour''s use, perform the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你在使用了一段时间后开始遇到`未授权错误`，问题是因为JWT已经过期。你需要生成一个新的令牌，或者生成一个有效期更长的令牌。你可以通过向`GenerateToken`工具传入以秒为单位的过期时间来做到这一点。例如，为了生成一个可以使用一小时的令牌，执行以下操作：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: These samples should give you a feel for the interaction between the microservice
    client and how the use of JWTs to secure microservice endpoints allows for stateless
    authentication and RBAC, as well as custom authorization based on claims in the
    JWT.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例应该能让你对微服务客户端之间的交互以及使用JWT来保护微服务端点实现无状态认证和RBAC（基于角色的访问控制），以及基于JWT中声明的定制授权有一个感觉。
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about the MicroProfile Health Check and JWT Propagation
    projects. You should now understand what a health check is and how to add application-specific
    checks, known as procedures. These allow your microservice to describe its non-trivial
    health requirements in a cloud environment. You should also understand how JWTs
    can be used to provide an authentication and authorization capability on top of
    your microservices to control access to your endpoints. You should also understand
    how content from the JWT can be used to augment your microservice in user-specific
    ways.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了MicroProfile健康检查和JWT传播项目。现在你应该理解了什么是健康检查以及如何添加应用程序特定的检查，这些检查被称为程序。这允许你的微服务在云环境中描述其非琐碎的健康要求。你也应该理解如何使用JWT在微服务之上提供认证和授权能力，以控制对端点的访问。你也应该理解如何使用JWT中的内容以用户特定方式增强你的微服务。
- en: The next chapter will introduce the MicroProfile Metrics and OpenTracing features.
    These allow your microservices to provide additional information ...
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍MicroProfile Metrics和OpenTracing特性。这些特性允许你的微服务提供附加信息...
- en: Questions
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Is the MP-HC wire format useful in all environments?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 马克wp-hc协议在所有环境中都有用吗？
- en: Can an MP-HC response contain arbitrary properties?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个MP-HC响应可以包含任意属性吗？
- en: What if my application has different types of services that need to report health
    status?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我的应用程序有不同的服务类型需要报告健康状态怎么办？
- en: What is a JWT?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是JWT（JSON Web Token）？
- en: What is a claim?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是声明（claim）？
- en: Are there restrictions on what can be in a JWT?
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对JWT中可以有什么内容有限制吗？
- en: What is/are the main step(s) in authenticating a JWT?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在验证JWT时，主要需要经过哪些步骤？
- en: Beyond the security annotations, how might we perform an authorization check
    using JWTs?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了安全注解之外，我们还可以如何使用JWT来进行授权检查？
