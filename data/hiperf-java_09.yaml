- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Concurrency Strategies and Models
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发策略和模型
- en: Today’s computing world consists of distributed systems, cloud-based architectures,
    and hardware accelerated by multi-core processors. These characteristics necessitate
    concurrency strategies. This chapter provides foundational information on concurrency
    concepts and provides hands-on opportunities to implement concurrency in Java
    programs. The underlying goal is to harness the benefits and advantages of concurrency
    to improve the performance of our Java applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的计算世界由分布式系统、基于云的架构以及由多核处理器加速的硬件组成。这些特性需要并发策略。本章提供了关于并发概念的基础信息，并提供了在Java程序中实现并发的实际操作机会。其根本目标是利用并发的优势和优点来提高我们的Java应用程序的性能。
- en: The chapter starts with a review of different concurrency models and their practical
    uses. Concepts include the thread-based memory model and the message-passing model.
    Then, we will explore multithreading from both a theoretical perspective and a
    hands-on practical aspect. The thread life cycle, thread pools, and other related
    topics will be covered. Synchronization will also be covered to include how to
    ensure thread safety and strategies to avoid common pitfalls. Finally, the chapter
    introduces non-blocking algorithms, an advanced concurrency strategy, to improve
    application performance through atomic variables and specific data structures.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先回顾了不同的并发模型及其实际应用。概念包括基于线程的内存模型和消息传递模型。然后，我们将从理论角度和实际操作方面探讨多线程。将涵盖线程生命周期、线程池和其他相关主题。同步也将被涵盖，包括如何确保线程安全以及避免常见陷阱的策略。最后，本章介绍了非阻塞算法，这是一种高级并发策略，通过原子变量和特定数据结构来提高应用程序性能。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Concurrency models
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发模型
- en: Multithreading
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多线程
- en: Synchronization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步
- en: Non-blocking algorithms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非阻塞算法
- en: By the end of this chapter, you should have a thorough understanding of concurrency
    and related strategies and models. You should be prepared to implement concurrency
    in your Java applications, ensuring they perform at a high level.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您应该对并发及其相关策略和模型有深入的理解。您应该准备好在Java应用程序中实现并发，确保它们以高水平运行。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the examples and instructions in this chapter, you will need the ability
    to load, edit, and run Java code. If you have not set up your development environment,
    refer to [*Chapter 1*](B21942_01.xhtml#_idTextAnchor014).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章中的示例和说明，您需要具备加载、编辑和运行Java代码的能力。如果您尚未设置您的开发环境，请参阅[*第1章*](B21942_01.xhtml#_idTextAnchor014)。
- en: 'The finished code for this chapter can be found here: [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter09](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter09).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码可以在以下位置找到：[https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter09](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter09)。
- en: Concurrency models
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发模型
- en: One of the most exciting aspects of the Java programming language is its robustness.
    When addressing parallel execution challenges, Java supports multiple models,
    so the approach we take is up to us. Usually, there is not just one way of doing
    things, with each possible solution presenting both advantages and trade-offs.
    Our goal is to create Java applications that run efficiently and are scalable
    and maintainable. To that end, we will use the thread-based concurrency approach
    (detailed later in this chapter). Our selection is based on its straightforward
    nature.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Java编程语言最令人兴奋的方面之一是其健壮性。在解决并行执行挑战时，Java支持多种模型，因此我们采取的方法取决于我们。通常，做事情的方法不止一种，每种可能的解决方案都既有优点也有缺点。我们的目标是创建运行效率高、可扩展且易于维护的Java应用程序。为此，我们将使用基于线程的并发方法（本章后面将详细介绍）。我们的选择基于其简单性。
- en: '**Concurrency**, in the context of computer science, is the simultaneous execution
    of instructions. This is achieved through multithreading (think of multitasking).
    This programming paradigm includes the ability to access Java objects and other
    resources from multiple threads. Let’s look at three specific models (thread-based,
    message passing, and reactive) and then compare them to see which model might
    be more ideal, given a specific scenario, than others.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**并发**在计算机科学中是指指令的并行执行。这是通过多线程（想想多任务处理）实现的。这种编程范式包括从多个线程访问 Java 对象和其他资源的能力。让我们看看三种特定的模型（基于线程、消息传递和反应式），然后比较它们，以确定在特定场景下哪个模型可能比其他模型更理想。'
- en: Thread-based model
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于线程的模型
- en: The `Thread` class and `Callable` and `Runnable` interfaces.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread` 类以及 `Callable` 和 `Runnable` 接口。'
- en: 'Let’s look at a simple implementation example. We will implement the `increment`
    method and mark it with the `synchronized` keyword. This tells Java to only execute
    one thread at any given time:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的实现示例。我们将实现 `increment` 方法，并用 `synchronized` 关键字标记它。这告诉 Java 在任何给定时间只执行一个线程：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This next section of code contains our `main()` method. In this method, we
    create two threads; both will increment our counter:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码段包含我们的 `main()` 方法。在这个方法中，我们创建了两个线程；它们都将增加我们的计数器：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The next two lines of code start the threads:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行代码启动了线程：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the next two lines of code, we wait for both threads to finish:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两行代码中，我们等待两个线程完成：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Lastly, we output the final results:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们输出最终结果：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The straightforward nature of thread-based model implementation represents a
    tremendous advantage. This approach is typical for smaller applications. There
    are potential disadvantages to using this model, as **deadlocks** and **race conditions**
    can be introduced when multiple threads attempt to access shared, mutable data.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 基于线程的模型实现方式简单直接，这代表了一个巨大的优势。这种方法适用于较小的应用程序。使用此模型存在潜在的不利因素，因为当多个线程尝试访问共享的可变数据时，可能会引入**死锁**和**竞态条件**。
- en: Deadlocks and race conditions
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 死锁和竞态条件
- en: Deadlocks occur when two threads wait for the other to release a needed resource.
    Race conditions occur when the sequence of the thread execution is required.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个线程等待对方释放所需资源时发生死锁。当需要线程执行的顺序时发生竞态条件。
- en: Both deadlocks and race conditions should be avoided as much as possible in
    our applications.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，应尽可能避免死锁和竞态条件。
- en: The message passing model
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息传递模型
- en: The **message passing model** is an interesting one in that it avoids **shared
    states**. This model requires threads to intercommunicate by sending messages.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息传递模型**是一个有趣的模型，因为它避免了**共享状态**。此模型要求线程通过发送消息进行相互通信。'
- en: Shared states
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 共享状态
- en: A shared state exists when more than one thread in an application can simultaneously
    access data.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序中的多个线程可以同时访问数据时存在共享状态。
- en: The message passing model offers assurances against deadlocks and race conditions.
    A benefit of this model is that it promotes scalability.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 消息传递模型提供了防止死锁和竞态条件的保证。此模型的一个好处是它促进了可伸缩性。
- en: 'Let’s look at how we can implement the message passing model. Our example includes
    a simple sender and receiver scenario. We start with our `import` statements and
    then create a `Message` class:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何实现消息传递模型。我们的示例包括一个简单的发送者和接收者场景。我们首先编写 `import` 语句，然后创建一个 `Message` 类：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we will have our `Sender` class implement the `Runnable` interface:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将让我们的 `Sender` 类实现 `Runnable` 接口：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we will have our `Receiver` class implement the `Runnable` interface:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将让我们的 `Receiver` 类实现 `Runnable` 接口：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The last step is to create our `main()` method:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是创建我们的 `main()` 方法：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our example implemented `Sender` and `Receiver` as `Runnable` classes. They
    communicated using `BlockingQueue`. The queue is used for `Sender` to add messages
    and `Receiver` to take and process them. `Sender` sends `Done` to the queue so
    that `Receiver` knows when it can stop processing. The message passing model is
    often used in distributed systems, due to its support of highly scalable systems.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例将 `Sender` 和 `Receiver` 实现为 `Runnable` 类。它们使用 `BlockingQueue` 进行通信。队列用于
    `Sender` 添加消息，`Receiver` 用于接收和处理它们。`Sender` 向队列发送 `Done`，以便 `Receiver` 知道何时停止处理。消息传递模型通常用于分布式系统，因为它支持高度可伸缩的系统。
- en: The Reactive model
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反应式模型
- en: The **Reactive model** is newer than the last two models we covered. Its focus
    is on **non-blocking**, **event-driven programming**. This model is usually evident
    in large-scale systems that process extensive input/output operations, especially
    when high scalability is needed. There are external libraries that we can use
    to implement this model, including **Project Reactor** and **RxJava**.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应式模型** 比我们之前讨论的最后两个模型更新。它的重点是 **非阻塞**、**事件驱动编程**。此模型通常体现在处理大量输入/输出操作的大规模系统中，尤其是在需要高可伸缩性时。我们可以使用外部库来实现此模型，包括
    **Project Reactor** 和 **RxJava**。'
- en: 'Let’s look at a simple implementation example using **Project Reactor**. We
    start by adding the Project Reactor **dependency** to our project. Here is how
    that looks using **Maven** as the build tool:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个使用 **Project Reactor** 的简单实现示例。我们首先将 Project Reactor **依赖项** 添加到我们的项目中。以下是使用
    **Maven** 作为构建工具时的样子：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following example demonstrates how to create a reactive stream to process
    a sequence of events:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何创建响应式流来处理一系列事件：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The Reactive model offers efficient resource use, blocking operation avoidance,
    and a unique approach to asynchronous programming. However, it can be more difficult
    to implement compared to the other models we covered.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式模型提供了高效的资源使用、避免阻塞操作和对异步编程的独特方法。然而，与我们所讨论的其他模型相比，它可能更难实现。
- en: Comparative analysis
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 比较分析
- en: Each of the three concurrency models offers different benefits, and understanding
    their individuality and differences can help you make an informed decision regarding
    which model to adopt.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个并发模型各自提供了不同的好处，了解它们的个性和差异可以帮助您做出明智的决定，选择采用哪种模型。
- en: Multithreading
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程
- en: '**Multithreading** is simply the **synchronous execution**, or **concurrent
    execution**, of two or more parts of a program, and it is a fundamental aspect
    of Java’s concurrent programming mechanism. We execute multiple parts of our programs,
    taking advantage of multi-core **Central Processing Unit** (**CPU**) resources
    to optimize the performance of our applications.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**多线程**简单地说就是程序中两个或更多部分的**同步执行**，或**并发执行**，它是 Java 并发编程机制的基本方面。我们执行程序的多部分，利用多核**中央处理器**（**CPU**）资源来优化我们应用程序的性能。'
- en: 'Before we get too far into multithreads, let’s focus on a single `Thread` class
    to create and start threads:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨多线程之前，让我们专注于创建和启动线程的单个 `Thread` 类：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The next code snippet demonstrates how to implement the `Runnable` interface:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段演示了如何实现 `Runnable` 接口：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now that you understand how easy it is to create and start threads, let’s examine
    their life cycles.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了创建和启动线程是多么容易，让我们来检查它们的生命周期。
- en: Thread life cycles
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程生命周期
- en: Java threads have a definitive start and end state. They have additional states,
    as indicated in the following diagram.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Java 线程有一个明确的开始和结束状态。它们还有额外的状态，如下面的图中所示。
- en: '![Figure 9.1 – A Java thread life cycle](img/B21942_09_1.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – Java 线程生命周期](img/B21942_09_1.jpg)'
- en: Figure 9.1 – A Java thread life cycle
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – Java 线程生命周期
- en: 'It is important to understand each of these states so that we can effectively
    manage our threads. Let’s briefly look at each state within the Java thread life
    cycle:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些状态非常重要，这样我们才能有效地管理我们的线程。让我们简要地看看 Java 线程生命周期中的每个状态：
- en: '**New**: Threads have this state when we create them but have not started them.'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**新建**：线程处于此状态时，我们创建了它们但尚未启动它们。'
- en: '**Runnable**: This state exists when a thread is being executed. Threads that
    have started and are waiting for CPU time also have this state.'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**可运行**：当线程正在执行时，存在此状态。已启动并等待 CPU 时间的线程也有此状态。'
- en: '**Blocked**: A thread is blocked from accessing a resource.'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**阻塞**：线程被阻止访问资源。'
- en: '**Waiting/Timed Waiting**: Threads can wait on other threads. Sometimes, there
    can be a specific waiting time, while at other times, the wait might be indefinite.'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**等待/定时等待**：线程可以等待其他线程。有时，可能会有特定的等待时间，而在其他时候，等待可能是无限期的。'
- en: '**Terminated**: A thread has this state after execution completes.'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**终止**：线程在执行完成后处于此状态。'
- en: It is important to understand these states, especially with applications that
    rely on thread communication and synchronization.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于依赖于线程通信和同步的应用程序，理解这些状态非常重要。
- en: Multithreading best practices
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多线程最佳实践
- en: When working with multithreading, there are a few things we should keep in mind
    to ensure that our application performs as expected and that our threads are safe.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理多线程时，有一些事情我们应该注意，以确保我们的应用程序按预期运行，并且我们的线程是安全的。
- en: First, we want to ensure that each resource is only accessed by one thread at
    a time, using `java.util.concurrent` package, which includes concurrent data structures
    and methods we can use for synchronization. Utilizing this package can help us
    implement thread safety.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们希望确保每个资源一次只被一个线程访问，使用 `java.util.concurrent` 包，它包括我们可以用于同步的并发数据结构和方法。利用这个包可以帮助我们实现线程安全。
- en: 'Java’s `Object` class includes the `wait()`, `notify()`, and `notifyAll()`
    methods, which can be used to empower Java threads to communicate with each other.
    The following example application demonstrates how those methods can be used.
    Our example contains a `Producer` thread that creates a value for consumption
    by a `Consumer` thread. We do not want both operations to take place at the same
    time; in fact, we want `Consumer` to wait for `Producer` to create the value.
    Further, `Producer` must wait for `Consumer` to receive the last value before
    creating a new one. The first section defines our `WaitNotifyExample` class:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的 `Object` 类包括 `wait()`、`notify()` 和 `notifyAll()` 方法，这些方法可以用来使 Java 线程能够相互通信。以下示例应用程序演示了这些方法如何使用。我们的示例包含一个
    `Producer` 线程，它为 `Consumer` 线程创建一个值。我们不希望这两个操作同时进行；事实上，我们希望 `Consumer` 等待 `Producer`
    创建值。此外，`Producer` 必须等待 `Consumer` 接收到最后一个值后才能创建新的值。第一部分定义了我们的 `WaitNotifyExample`
    类：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we need to create our `Consumer` class and implement the `Runnable` interface:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建我们的 `Consumer` 类并实现 `Runnable` 接口：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The last part of our application is the `main()` class:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的最后一部分是 `main()` 类：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Our application’s output is provided here:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序输出如下所示：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When we adhere to the best practices provided in this section, we increase the
    chances of having efficient multithreading, contributing to a high-performing
    Java application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遵循本节提供的最佳实践时，我们增加了拥有高效多线程的机会，从而有助于构建高性能的 Java 应用程序。
- en: Synchronization
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步
- en: '**Synchronization** is another critical Java concept that we should grasp as
    we seek to fully understand concurrency. As we indicated earlier, we employ synchronization
    to avoid **race conditions**.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**同步** 是我们在寻求完全理解并发时应该掌握的另一个关键 Java 概念。正如我们之前指出的，我们使用同步来避免 **竞态条件**。'
- en: Race conditions
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 竞态条件
- en: The condition when multiple threads attempt to modify a shared resource at the
    same time. The results of this situation are unpredictable and should be avoided.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个线程同时尝试修改共享资源时的条件。这种情况的结果是不可预测的，应该避免。
- en: 'Let’s look at how we can implement synchronization in our Java applications
    by looking at several code snippets. First, we demonstrated adding the `synchronized`
    keyword to a method’s declaration. This is how we can ensure that only one thread
    at a time can execute the method on a specific object:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看几个代码片段来了解如何在我们的 Java 应用程序中实现同步。首先，我们展示了如何在方法声明中添加 `synchronized` 关键字。这样我们就可以确保一次只有一个线程可以执行特定对象上的方法：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can also implement **synchronized blocks**, which are a subset of a method.
    This level of granularity allows us to synchronize a block without having to lock
    out the entire method:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以实现 **synchronized 块**，它是方法的一个子集。这种粒度级别允许我们在不需要锁定整个方法的情况下同步一个块：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Java also includes a `Lock` interface that can be used for a more refined approach
    to locking resources. Here’s how we can implement it:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Java 还包括一个 `Lock` 接口，可以用于更精细的资源锁定方法。以下是实现方法：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Java also includes the `volatile` keyword, which we can use to tell Java that
    a specific variable is subject to modification by multiple threads. When we declare
    our variables with this keyword, Java places the variable’s value in a memory
    location accessible by all threads:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Java 还包括 `volatile` 关键字，我们可以用它来告诉 Java，特定的变量可能被多个线程修改。当我们用这个关键字声明变量时，Java 将变量的值放置在一个所有线程都可以访问的内存位置：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you undoubtedly will come to understand, synchronization is key for successful
    concurrency programming in Java.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如你无疑将理解的那样，同步对于 Java 中成功的并发编程至关重要。
- en: Non-blocking algorithms
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非阻塞算法
- en: As a final concept of concurrent programming, let’s look at `synchronized` methods
    and synchronized blocks. There are three types of non-blocking algorithms – **lock-free**,
    **wait-free**, and **obstruction-free**. Although their names are self-describing,
    let’s take a closer look.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 作为并发编程的最后一个概念，让我们来看看`同步`方法和同步块。非阻塞算法有三种类型——**无锁**、**无等待**和**无阻塞**。尽管它们的名称具有自我描述性，但让我们更深入地了解一下。
- en: Modern CPUs support atomic operations, and Java includes several atomic classes
    that we can use when implementing non-blocking algorithms.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现代CPU支持原子操作，Java包含了一些我们可以在实现非阻塞算法时使用的原子类。
- en: Atomic operations
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 原子操作
- en: These are operations that are executed by modern CPUs as a single, finite step
    that ensures consistency without the need for locks.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是现代CPU作为单一、有限的步骤执行的操作，确保一致性而无需锁。
- en: 'Here is a code snippet that illustrates how to use `AtomicInteger`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个代码片段，说明了如何使用`AtomicInteger`：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following example demonstrates how to implement a non-blocking stack. As
    you will see, our stack uses atomic references, which ensures thread safety:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何实现一个非阻塞栈。正如你所看到的，我们的栈使用原子引用，这确保了线程安全：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We can gain performance advantages when we use non-blocking algorithms, especially
    when our application deals with high concurrency. The advantages are counterbalanced
    by code complexity, which can result in errors and code that is more difficult
    to maintain.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用非阻塞算法时，我们可以获得性能优势，尤其是在我们的应用程序处理高并发时。这些优势被代码复杂性所抵消，这可能导致错误和更难维护的代码。
- en: Summary
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter focused on concurrency strategies and models, with the goal of
    providing insights into the concept of concurrency, the different models and strategies,
    and some implementation examples. We explored theoretical concepts and practical
    examples. The concepts covered included concurrency models, synchronization, and
    non-blocking algorithms. You should now have sufficient knowledge to start experimenting
    with code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了并发策略和模型，旨在深入探讨并发概念、不同的模型和策略，以及一些实现示例。我们探讨了理论概念和实践示例。涵盖的概念包括并发模型、同步和非阻塞算法。你现在应该具备足够的知识来开始尝试编写代码。
- en: In the next chapter, we will explore connection pooling with a specific look
    at concepts, implementation, and best practices. You will have the opportunity
    to learn how to create and maintain a cache of database connection objects to
    help increase the performance of your Java applications.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨连接池，具体包括概念、实现和最佳实践。你将有机会学习如何创建和维护数据库连接对象的缓存，以帮助提高你的Java应用程序的性能。
