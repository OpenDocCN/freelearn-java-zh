- en: Chapter 15. Using WildFly with Docker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章 使用Docker与WildFly
- en: 'In this chapter, you will learn the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下食谱：
- en: Setting up the Docker environment
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Docker环境
- en: Running WildFly in Docker
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker中运行WildFly
- en: Logging WildFly outside Docker
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker外记录WildFly
- en: Running WildFly in domain mode in Docker using different Docker containers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker中使用不同的Docker容器以域模式运行WildFly
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we will start learning the basics of Docker, and how you can
    take advantage of it by deploying your applications along with the environment.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始学习Docker的基础知识，以及您如何通过部署应用程序及其环境来利用它。
- en: Docker is an open source platform to develop, ship, and run applications. The
    basic idea of Docker is to get rid of the problems that occur when you promote
    your applications (actually the whole thing, such as the runtime environment)
    from environment to environment; that is, from development, to test, to pre-production,
    to quality, till production. There are so many variables involved that even if
    you do your best, something can go wrong in the traditional software life cycle.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是一个开源平台，用于开发、运输和运行应用程序。Docker的基本思想是消除当您将应用程序（实际上整个运行环境）从环境到环境进行推广时出现的问题；也就是说，从开发到测试，到预生产，到质量，直到生产。涉及到的变量如此之多，即使你尽力而为，在传统的软件生命周期中也可能出现问题。
- en: With Docker, you can replicate your entire environment at every stage. The word
    "replicate" probably doesn't explain the concept well enough; "resubmit" would
    be better.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker，您可以在每个阶段复制您的整个环境。单词“复制”可能不足以很好地解释这个概念；“重新提交”可能更好。
- en: 'Docker is composed of the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Docker由以下组成：
- en: '**Images**: A Docker image is just like a template. Suppose you have an image
    with Fedora, Java 8, WildFly, and your installed application. Images can be downloaded
    or built with a descriptor file called `Dockerfile`. From images you can run your
    containers.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**镜像**：Docker镜像就像一个模板。假设您有一个包含Fedora、Java 8、WildFly和已安装应用程序的镜像。镜像可以通过名为`Dockerfile`的描述文件下载或构建。从镜像中，您可以运行容器。'
- en: '**Registries**: These are the places where images are stored. There can be
    private and public registries, such as Docker Hub ([http://hub.docker.com](http://hub.docker.com)).'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仓库**：这些是存储镜像的地方。可以有私有和公共仓库，例如Docker Hub ([http://hub.docker.com](http://hub.docker.com)).'
- en: '**Containers**: They are, essentially, the running component of Docker. Basically,
    it''s a running instance of a Docker image. A container can be started, stopped,
    deleted, and so on. Each container is isolated from the host that is running it
    and from other containers as well.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器**：它们实际上是Docker的运行组件。基本上，它是一个Docker镜像的运行实例。容器可以被启动、停止、删除等。每个容器都与运行它的主机以及其他容器隔离。'
- en: By the way, how can we achieve a no bad surprises result when promoting our
    application at various stages with Docker? Think of Docker as a tool for creating
    a stack of pluggable layers. The first layer is the OS layer, then comes your
    environment layer (it might be your specific Java runtime version), then your
    application layer—you can have as many layers as you want/need.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便问一下，我们如何通过Docker在各个阶段推广我们的应用程序时避免出现任何坏惊喜的结果？将Docker视为创建可插拔层堆栈的工具。第一层是操作系统层，然后是您的环境层（可能是您的特定Java运行时版本），然后是您的应用程序层——您可以根据需要/想要拥有尽可能多的层。
- en: Once your stack is all filled in, what you get is your Docker image, which is
    ready to be committed into the registry. After that, you grab your image and install
    that exact image on the production hardware. You then get what you had before,
    when everything was working smoothly—hope you get the idea.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的堆栈全部填满，您得到的就是您的Docker镜像，它已准备好提交到仓库。之后，您抓取您的镜像并在生产硬件上安装该精确镜像。然后您得到的是当一切运行顺利时的东西——希望您能理解这个意思。
- en: 'For a better understanding of what Docker is, I strongly suggest you read the
    default documentation and user guide at the following URLs:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解Docker是什么，我强烈建议您阅读以下URLs上的默认文档和用户指南：
- en: '[http://docs.docker.com/introduction/understanding-docker](http://docs.docker.com/introduction/understanding-docker)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://docs.docker.com/introduction/understanding-docker](http://docs.docker.com/introduction/understanding-docker)'
- en: '[http://docs.docker.com/userguide](http://docs.docker.com/userguide)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://docs.docker.com/userguide](http://docs.docker.com/userguide)'
- en: Within this chapter, we will mainly use the Docker client, available for different
    operating systems, which is the tool that interfaces with the Docker daemon. There
    are so many settings and features to talk about that it would require another
    book. For this reason, I will focus on installing the client tool, and will explain
    the commands and parameters that we will use in our recipes, that is, in some
    basic WildFly scenarios.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将主要使用适用于不同操作系统的Docker客户端，这是与Docker守护进程交互的工具。有如此多的设置和功能可以讨论，以至于需要另一本书来详述。因此，我将专注于安装客户端工具，并解释我们将在我们的食谱中使用的命令和参数，即在一些基本的WildFly场景中。
- en: Setting up the Docker environment
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Docker环境
- en: In this recipe, you will learn how to install Docker and get acquainted with
    the basic commands. You will see how to create and build an image based on Fedora,
    and how you can run it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，你将学习如何安装Docker并熟悉基本命令。你将看到如何基于Fedora创建和构建镜像，以及如何运行它。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will need to have access to the Internet in order to download and install
    Docker and its dependencies.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了下载和安装Docker及其依赖项，我们需要访问互联网。
- en: How to do it…
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'To install Docker on Fedora, issue the following commands:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在Fedora上安装Docker，请执行以下命令：
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The installation should look like the following screenshot:'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 安装应该看起来像以下截图：
- en: '![How to do it…](img/3744_15_01.jpg)'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做…](img/3744_15_01.jpg)'
- en: 'Okay, now that Docker is installed, let''s run it:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在Docker已经安装好了，让我们来运行它：
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you want to start Docker at boot time, use the following command:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想在启动时启动Docker，请使用以下命令：
- en: '[PRE2]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Also, ensure that your user is in the `docker` group, by executing the following:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，确保你的用户属于`docker`组，通过执行以下命令：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In case the `docker` group is not listed, add it with the following command:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`docker`组未列出，请使用以下命令添加：
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Obviously, replace the user `luigi` with yours.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 显然，将用户`luigi`替换为你自己的用户名。
- en: 'Check Docker''s version by issuing the following command:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下命令检查Docker的版本：
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Great, we are now ready to dockerize whatever we want!
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 太好了，我们现在准备好将任何东西docker化！
- en: 'To do this, first we need to check if there are any images available, as follows:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要这样做，首先我们需要检查是否有任何可用的镜像，如下所示：
- en: '[PRE6]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As there is no image available, we need to look for it by issuing the following
    command:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于没有可用的镜像，我们需要通过以下命令查找它：
- en: '[PRE7]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The Docker image we want is the official Fedora 21\. We can download it as
    follows:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要的Docker镜像是官方的Fedora 21。我们可以按照以下方式下载它：
- en: '[PRE8]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When all the pulls are complete, we get the following output:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当所有拉取完成时，我们得到以下输出：
- en: '[PRE9]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can now use our first Fedora Docker image by executing the following command:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用我们的第一个Fedora Docker镜像，通过执行以下命令：
- en: '[PRE10]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works…
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: How long did it take to start the container with Fedora? Milliseconds? How long
    would it take to start a Fedora VM in a traditional virtualization environment?
    Tens of seconds? What about the overall installation? With Docker, everything
    gets extremely fast.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Fedora启动容器需要多长时间？毫秒？在传统的虚拟化环境中启动一个Fedora虚拟机需要多长时间？数十秒？整体安装又是如何？使用Docker，一切都会变得极其快速。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We have finally installed the Docker tool and downloaded the latest Fedora image
    (which is version 21 while writing this book). We can use this as a base for our
    next recipe, *Running WildFly into Docker*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终安装了Docker工具并下载了最新的Fedora镜像（在撰写本书时为版本21）。我们可以将其用作我们下一个食谱，即*在Docker中运行WildFly*的基础。
- en: When you first install Docker, there are no images available, and you need to
    get them from the Docker registry. The default registry is the online Docker Hub,
    where you can also sign up for free and have your own space to share your Docker
    images.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次安装Docker时，没有可用的镜像，你需要从Docker注册库中获取它们。默认注册库是线上的Docker Hub，在那里你也可以免费注册并拥有自己的空间来分享你的Docker镜像。
- en: Before you can pull (that is, download) a Docker image, you need to know at
    least its name. By issuing the command `docker search IMAGE_NAME`, you are essentially
    filtering all the images stored in the DockerHub that have the specified filter
    in the name or in the description.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在你能够拉取（即下载）Docker镜像之前，你需要至少知道它的名称。通过执行`docker search IMAGE_NAME`命令，你实际上是在过滤所有存储在DockerHub中且名称或描述中包含指定过滤器的镜像。
- en: 'Once you have pulled the image of your choice, you can use it to run a container,
    as per the following command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你拉取了所选的镜像，你可以使用它来运行容器，如下命令所示：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding command, we are using the Docker client tool to communicate
    with the Docker daemon, which is active and listening in our system.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，我们正在使用Docker客户端工具与Docker守护进程通信，该守护进程在我们的系统中是活跃并监听的。
- en: Specifically, we instruct Docker to `run` a container based on the `fedora`
    image, and finally execute the `/bin/bash` command in it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们指示Docker基于`fedora`镜像`run`一个容器，并最终在其中执行`/bin/bash`命令。
- en: 'We also specified the following flags:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还指定了以下标志：
- en: '`-i`: Which enables the STDIN'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-i`：启用STDIN'
- en: '`-t`: Which allocates a pseudo-tty, the terminal'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-t`：分配一个伪终端，即终端'
- en: Running WildFly in Docker
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker中运行WildFly
- en: In this recipe, you will learn how to run WildFly in a Docker container by creating
    a `Dockerfile`, which describes how the image should be composed. To go through
    this recipe, you need to have a working Docker installation, along with a Fedora
    21 image; if you don't have these installed, please follow the first recipe in
    this chapter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，您将学习如何通过创建一个`Dockerfile`来在Docker容器中运行WildFly，该文件描述了镜像应该如何构建。为了完成这个食谱，您需要有一个工作的Docker安装，以及一个Fedora
    21镜像；如果您还没有安装这些，请遵循本章的第一个食谱。
- en: Getting ready
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: In this recipe, you will need an internet connection to download WildFly directly
    from the container. Also, we will need a Java web application to test our WildFly
    installation. If you want, you can use one of my projects from my GitHub account,
    at [https://github.com/foogaro/wildfly-cookbook.git](https://github.com/foogaro/wildfly-cookbook.git).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，您将需要一个互联网连接来直接从容器中下载WildFly。此外，我们还需要一个Java网络应用程序来测试我们的WildFly安装。如果您愿意，可以使用我GitHub账户中的一个项目，网址为[https://github.com/foogaro/wildfly-cookbook.git](https://github.com/foogaro/wildfly-cookbook.git)。
- en: 'You can `git-clone` the repository or just download it as a ZIP archive:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以`git-clone`仓库或仅将其作为ZIP存档下载：
- en: Place the source at `~/WFC/github`.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将源放置在`~/WFC/github`。
- en: 'There you will find a project called `docker-example`. To compile the project,
    run the following commands:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那里，您将找到一个名为`docker-example`的项目。要编译该项目，请运行以下命令：
- en: '[PRE12]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the `target` folder generated by Maven, you should find the `docker-example.war`
    artifact, ready to be deployed.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Maven生成的`target`文件夹中，您应该找到准备部署的`docker-example.war`工件。
- en: 'Next, create a folder in which we will place all our Docker files that we will
    create along the way, as follows:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个文件夹，我们将放置所有将创建的Docker文件，如下所示：
- en: '[PRE13]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let's Docker now!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用Docker吧！
- en: How to do it…
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: The first thing we need to do is create the `Dockerfile` file in the `~/WFC/docker/wildfly`
    folder.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是在`~/WFC/docker/wildfly`文件夹中创建`Dockerfile`文件。
- en: 'Open a text editor and create a file named `Dockerfile`. Now copy and paste
    the following code:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个文本编辑器，创建一个名为`Dockerfile`的文件。现在复制并粘贴以下代码：
- en: '[PRE14]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Save it in the previously mentioned folder.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将其保存在之前提到的文件夹中。
- en: 'Now, with `Dockerfile`, we can build our image, specific for WildFly, and call
    it `foogaro/wildfly`, as follows:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，有了`Dockerfile`，我们可以构建一个针对WildFly的特定镜像，并将其命名为`foogaro/wildfly`，如下所示：
- en: '[PRE15]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Great! We have successfully created our first Docker image named `foogaro/wildfly`.
    Try issuing the following command now:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太好了！我们已经成功创建了第一个名为`foogaro/wildfly`的Docker镜像。现在尝试执行以下命令：
- en: '[PRE16]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, in addition to the other images, we have ours that has just
    been created.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，除了其他镜像之外，我们还有刚刚创建的镜像。
- en: 'Now, let''s run WildFly as follows:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们按照以下方式运行WildFly：
- en: '[PRE17]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You should get the following output:'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该得到以下输出：
- en: '[PRE18]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now try opening your browser, and point it to `http://127.0.0.1:9990/`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试打开您的浏览器，并将其指向`http://127.0.0.1:9990/`。
- en: 'The browser should prompt you for the username and password for the WildFly
    `ManagementRealm`; just enter the following credentials:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器应提示您输入WildFly `ManagementRealm`的用户名和密码；只需输入以下凭据：
- en: '**Username**: `wildfly`'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户名**：`wildfly`'
- en: '**Password**: `cookbook.2015`'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密码**：`cookbook.2015`'
- en: The preceding credentials are those specified in the `Dockerfile` file used
    to build the image.
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述凭据是用于构建镜像的`Dockerfile`文件中指定的凭据。
- en: There you go; you are in your dockerized WildFly instance!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 好了；您现在就在您的docker化WildFly实例中了！
- en: 'Now we have quite a few options to deploy our `docker-example` application.
    We can go to the `Deployments` page of the WildFly Admin Console, add our artifact,
    upload it, and enable it. Or we could ship our application along with Docker itself,
    which is much better, as you will soon find out:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有相当多的选项来部署我们的`docker-example`应用程序。我们可以转到WildFly管理控制台的`部署`页面，添加我们的工件，上传它，并启用它。或者，我们可以将应用程序与Docker本身一起打包，这将更好，您很快就会了解到：
- en: 'From the *Getting ready* section, you should have my GitHub `wildfly-cookbook`
    repository installed in a path, which I named `CODE_PATH`. From there, you should
    create another `Dockerfile` in the `docker-example` folder. Fill in the `Dockerfile`
    with the following code:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从*准备就绪*部分，您应该在路径中安装我的GitHub `wildfly-cookbook`仓库，我将其命名为`CODE_PATH`。从那里，您应该在`docker-example`文件夹中创建另一个`Dockerfile`。在`Dockerfile`中填写以下代码：
- en: '[PRE19]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once again, create a Docker image from it by executing the following command:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，通过执行以下命令从它创建一个Docker镜像：
- en: '[PRE20]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Great! We have successfully created the preceding Docker image, which contains
    WildFly, along with our `docker-example` application. We can also see it listed
    as a Docker image, as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太好了！我们已经成功创建了前面的Docker镜像，其中包含WildFly以及我们的`docker-example`应用程序。我们还可以看到它作为Docker镜像被列出，如下所示：
- en: '[PRE21]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we just need to run this image in a container and test our application,
    as follows:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们只需要在一个容器中运行这个镜像并测试我们的应用程序，如下所示：
- en: '[PRE22]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You should get the following output:'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该得到以下输出：
- en: '[PRE23]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Reading the last log entries, we can see that our `docker-example` application
    has been deployed. To see the application in action, open the browser and point
    it to `http://127.0.0.1:8080/docker-example`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过阅读最后几条日志条目，我们可以看到我们的`docker-example`应用程序已经被部署。要查看应用程序的实际运行情况，请打开浏览器并将它指向`http://127.0.0.1:8080/docker-example`。
- en: You should see the following page:![How to do it…](img/3744_15_02.jpg)
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到以下页面：![如何操作…](img/3744_15_02.jpg)
- en: docker-example application running from a Docker container
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: docker-example 应用程序在Docker容器中运行
- en: Excellent, we have just deployed and run our first application in a Docker container
    running WildFly!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，我们刚刚在运行WildFly容器的Docker容器中部署并运行了我们的第一个应用程序！
- en: How it works…
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Besides the Docker tool itself, and all that it comes with, there are some relevant
    things to talk about.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Docker工具本身及其附带的所有内容外，还有一些相关的事情需要讨论。
- en: 'When running the WildFly container in the `docker run` command, we used a new
    flag `-p`, followed by some suspicious numbers. The flag `-p` is used to map the
    ports exposed by the container with the local ports; that is, the host''s ports:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当在`docker run`命令中运行WildFly容器时，我们使用了一个新的标志`-p`，后面跟着一些可疑的数字。标志`-p`用于将容器暴露的端口映射到本地端口；也就是说，主机的端口：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this case, we mapped the ports `8080` and `9990` with the same ones as in
    our host. That's why we could access the WildFly Admin Console with a local address.
    The same thing happened while accessing the `docker-example` application.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将端口`8080`和`9990`映射到与主机相同的端口。这就是为什么我们可以通过本地地址访问WildFly管理控制台。在访问`docker-example`应用程序时也发生了同样的事情。
- en: 'There is also another flag used in the preceding command: `--rm`.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中还有一个用于的标志：`--rm`。
- en: 'The `--rm` flag instructs the Docker daemon to eliminate the container from
    the list of the container''s history when the container gets stopped. To view
    all containers, even the non-running ones, you can give the following command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`--rm`标志指示Docker守护进程在容器停止时将其从容器历史记录列表中删除。要查看所有容器，包括非运行中的容器，您可以给出以下命令：'
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you can see, after a while, the list can get very long. Eventually, you
    can manually remove old containers that you don''t need anymore, by issuing the
    following command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，过了一会儿，列表可能会变得非常长。最终，您可以手动删除不再需要的旧容器，通过以下命令执行：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'List all the containers again, and the container with ID `981dd5f92e24` should
    be gone, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 再次列出所有容器，ID为`981dd5f92e24`的容器应该已经消失，如下所示：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: So, if we try to run our `foogaro/wildfly` container without the `--rm` flag,
    when we stop the container it should appear in the container's history list.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们尝试在没有`--rm`标志的情况下运行我们的`foogaro/wildfly`容器，当我们停止容器时，它应该出现在容器历史记录列表中。
- en: There is still one more thing to talk about, and that's the second Dockerfile
    that we created, the one used to create the `foogaro/wildfly-docker-example` image.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一件事情需要讨论，那就是我们创建的第二个Dockerfile，它是用来创建`foogaro/wildfly-docker-example`镜像的。
- en: 'The structure and the commands used in the file are pretty straightforward:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中的结构和使用的命令相当简单：
- en: '**FROM**: It''s used to declare the base or starting image.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FROM**：它用于声明基础或起始镜像。'
- en: '**MAINTAINER**: It''s used to declare the owner of the Dockerfile; that is,
    the image.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MAINTAINER**：它用于声明Dockerfile的所有者；即镜像。'
- en: '**RUN**: It''s used to run commands in the container itself.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RUN**：它用于在容器内部运行命令。'
- en: '**EXPOSE**: It''s used to expose a set of ports from the container.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EXPOSE**：它用于从容器中公开一组端口。'
- en: '**CMD**: It''s typically used as the final instruction to run a service/command
    in the container when we start it. This instruction is basically an array of parameters,
    where even the command to execute is a parameter itself.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CMD**：通常用作启动容器时运行服务/命令的最终指令。这个指令基本上是一个参数数组，其中要执行的命令本身也是一个参数。'
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are many more instructions you can use, and they are all available and
    explained in detail at the Docker site at [https://docs.docker.com/reference/builder](https://docs.docker.com/reference/builder).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用更多指令，它们都在Docker网站上详细解释和提供，请访问[https://docs.docker.com/reference/builder](https://docs.docker.com/reference/builder)。
- en: Keep in mind that every instruction in the Dockerfile is run sequentially and
    is atomic. Each instruction starts its own temporary container, executes the task
    it has to do, when done it commits its work, and it destroys its temporary container.
    The next instruction will do the same, and so on.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Dockerfile中的每条指令都是顺序执行且是原子的。每条指令都会启动自己的临时容器，执行它必须完成的任务，完成后提交其工作，然后销毁其临时容器。下一条指令将执行同样的操作，依此类推。
- en: This is a great feature because if something goes wrong while building an image,
    you don't need to restart once the bug has been fixed; the instructions previous
    to the error are cached, so you can quickly test and run your build again.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很棒的功能，因为如果在构建镜像时出现问题，一旦错误被修复，你不需要重新启动；之前的错误指令被缓存，因此你可以快速测试并再次运行你的构建。
- en: See also
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考信息
- en: 'Keep in mind that, nowadays, there are plenty of official images in the DockerHub
    registries, such as the official WildFly docker image. To obtain and work on that
    image, you can simply search and pull it from the repository, as depicted in the
    following image:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如今，DockerHub注册表中有很多官方镜像，例如官方的WildFly Docker镜像。为了获取并在此镜像上工作，你可以简单地从存储库中搜索并拉取它，如下面的图像所示：
- en: '![See also](img/3744_15_03.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![参考信息](img/3744_15_03.jpg)'
- en: Logging WildFly outside Docker
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker外记录WildFly日志
- en: When dealing with an application server, and thus web applications, often we
    really need to look at the logs. As we have seen in the previous recipe, we have
    run WildFly in a container and we have looked at the logs automatically because
    of the terminal flag being enabled (`-t` when executing the `docker run` command).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理应用程序服务器以及因此网页应用程序时，我们通常真的需要查看日志。正如我们在前面的菜谱中看到的那样，我们已经在一个容器中运行了WildFly，并且由于终端标志被启用（在执行`docker
    run`命令时使用`-t`），我们自动查看了日志。
- en: Without the terminal flag enabled, we would have needed to access the container
    (`docker attach` `CONTAINER_ID` or `docker logs CONTAINER_ID` command). That's
    not the most comfortable way to look at logs, and we would like to store our logs
    locally, on our host, and group them.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有启用终端标志，我们就需要访问容器（使用`docker attach CONTAINER_ID`或`docker logs CONTAINER_ID`命令）。这不是查看日志最舒适的方式，我们希望将日志存储在本地，在我们的主机上，并将它们分组。
- en: In this recipe, you will learn how to store your application logs outside the
    container, and store them on the host.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何将你的应用程序日志存储在容器外部，并存储在主机上。
- en: Getting ready
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To be able to follow this recipe, you need to have followed the previous one,
    which is about running WildFly in Docker.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够跟随这个菜谱，你需要遵循前面的一个菜谱，它是关于在Docker中运行WildFly的。
- en: How to do it…
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'First of all, we need to create a directory on the host to store our logs,
    and enable the container-writable permissions to access the directory:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在主机上创建一个目录来存储我们的日志，并启用容器可写权限以访问该目录：
- en: 'Open a terminal window and execute the following commands:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个终端窗口并执行以下命令：
- en: '[PRE28]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, in a different terminal window, run a container using our `foogaro/wildfly`
    Docker image, as follows:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在另一个终端窗口中，使用我们的`foogaro/wildfly` Docker镜像运行一个容器，如下所示：
- en: '[PRE29]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the terminal where we created the `/opt/docker/wildfly/logs` folder, list
    the contents of the folder as follows:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建`/opt/docker/wildfly/logs`文件夹的终端中，按照以下方式列出文件夹的内容：
- en: '[PRE30]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Great, our `server.log` file is there!!!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，我们的`server.log`文件就在那里！！！
- en: Obviously, this is not the best way to handle logs in general; you should look
    at integrating with `syslog`, `rsyslog`, `logstash`, and other tools with more
    powerful and higher performance features.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这并不是处理日志的最佳方式；你应该考虑与`syslog`、`rsyslog`、`logstash`和其他具有更强大和更高性能特性的工具集成。
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Take this recipe as an example to deal with folders that are outside the container.
    Nonetheless, in a development environment, people might want to have the logs
    stored on their PCs.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以这个食谱为例来处理容器外的文件夹。然而，在开发环境中，人们可能希望将日志存储在他们的个人电脑上。
- en: How it works…
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'First of all, we needed to create a directory to store the WildFly logs, and
    then add the same user and group that we used in the `Dockerfile` to build the
    `foogaro/wildfly` Docker image. As a matter of fact, in the `Dockerfile` there
    was the following instruction:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个目录来存储WildFly日志，然后添加我们在构建`foogaro/wildfly`Docker镜像时使用的相同用户和组。实际上，在`Dockerfile`中有以下指令：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding code adds a group and a user in the container environment, and
    it creates them using a fixed group ID and user ID. Thus, to allow the container
    to have read-write permissions on the host, we need to use the same user and group
    for the directory.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码在容器环境中添加了一个组和用户，并使用固定的组ID和用户ID创建它们。因此，为了允许容器对主机有读写权限，我们需要使用与目录相同的用户和组。
- en: Once everything was configured, we launched the `docker run` command using the
    `-v` flag, which is about mounting volumes with the `from:to` pattern. That is,
    everything from the host `from` (at the specified path) will be present in the
    container environment in the specified path, `:to`. Furthermore, every update
    made in the specified folder would have persisted in the host folder.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一切配置完成后，我们使用带有`-v`标志的`docker run`命令启动，该标志是关于使用`from:to`模式挂载卷。也就是说，主机`from`（在指定路径上）的所有内容都将出现在容器环境中的指定路径`to`。此外，在指定文件夹中进行的每次更新都将持久保存在主机文件夹中。
- en: Running WildFly in domain mode in Docker using different Docker containers
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker中使用不同的Docker容器在域模式下运行WildFly
- en: In this recipe, you will learn how to run WildFly in the domain mode using containers.
    We will use one container to act as the domain-controller and two other containers,
    each to act as the servers of a server-group.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，您将学习如何使用容器在域模式下运行WildFly。我们将使用一个容器作为域控制器，另外两个容器，每个作为服务器组的服务器。
- en: Getting ready
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To properly follow and understand the topics treated in this recipe, we need
    to know what the WildFly domain mode is, along with its principles. You can also
    refer to [Chapter 3](ch03.html "Chapter 3. Running WildFly in Domain Mode"), *Working
    with XAML*, which is about running WildFly in the domain mode.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确地跟随和理解本食谱中讨论的主题，我们需要了解WildFly域模式是什么，以及其原则。您还可以参考[第3章](ch03.html "第3章。在域模式下运行WildFly")，*使用XAML进行操作*，该章节是关于在域模式下运行WildFly。
- en: Furthermore, you need to have followed the first two recipes of this chapter,
    of having a working Docker installation and a WildFly image available for use.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您需要遵循本章的前两个食谱，即拥有一个工作的Docker安装和一个可用的WildFly镜像。
- en: 'Nevertheless, to simplify our recipe, we will rely on the WildFly default configuration
    files: `domain.xml`, `host-master.xml` and `host-slave.xml`.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了简化我们的食谱，我们将依赖于WildFly的默认配置文件：`domain.xml`、`host-master.xml`和`host-slave.xml`。
- en: How to do it…
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First of all, we need to create a new `Dockerfile` based on the `foogaro/wildfly`
    image, which will contain the entire configuration needed to run WildFly in the
    domain mode. Following is the whole file:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要基于`foogaro/wildfly`镜像创建一个新的`Dockerfile`，它将包含运行WildFly在域模式下所需的全部配置。以下是整个文件：
- en: '[PRE32]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To build the image, use the following command:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要构建镜像，请使用以下命令：
- en: '[PRE33]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once the build process is done, we can run the `foogaro/wildfly-domain` image
    in a container. The first thing we are going to run is the domain controller without
    any operative servers, as follows:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦构建过程完成，我们就可以在容器中运行`foogaro/wildfly-domain`镜像。我们将首先运行的是没有任何操作服务器的域控制器，如下所示：
- en: '[PRE34]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now you can access the Admin Console from the host at `http://localhost:9990/`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以从主机访问管理控制台，地址为`http://localhost:9990/`。
- en: As we can see from the following image, in the **Domain** | **Topology** section,
    there is no running server:![How to do it…](img/3744_15_04.jpg)
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如以下图像所示，在**域** | **拓扑**部分，没有正在运行的服务器：![如何操作…](img/3744_15_04.jpg)
- en: WildFly in domain mode running into a Docker container
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Docker容器中运行域模式下的WildFly
- en: Let's run another container with the WildFly default configuration provided
    by the `host-slave.xml` file.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们运行另一个容器，使用由`host-slave.xml`文件提供的WildFly默认配置。
- en: 'Open a new terminal window and execute the following:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端窗口并执行以下命令：
- en: '[PRE35]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Once the container has successfully launched WildFly, refresh the topology overview
    section of the Admin Console that we loaded earlier, and you should now see two
    running servers, as depicted in the following image:![How to do it…](img/3744_15_05.jpg)
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦容器成功启动 WildFly，刷新我们之前加载的 Admin Console 中的拓扑概述部分，你现在应该会看到两个正在运行的服务器，如下面的图像所示：![如何操作…](img/3744_15_05.jpg)
- en: WildFly's domain mode topology showing two servers running on a different Docker
    container
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 显示两个在不同 Docker 容器上运行的 WildFly 域模式拓扑
- en: How it works…
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we saw some new `Dockerfile` instructions, such as `ENTRYPOINT`.
    This instruction is almost like the `CMD` one; it is used to run a service. The
    `ENTRYPOINT` instruction uses the `CMD` instruction to hold the command parameters.
    As a matter of fact, you can specify both the instructions with the option to
    override the `CMD` instruction from the command line, which is exactly what we
    have done when running the host-controller.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们看到了一些新的 `Dockerfile` 指令，例如 `ENTRYPOINT`。这个指令几乎和 `CMD` 一样；它用于运行服务。`ENTRYPOINT`
    指令使用 `CMD` 指令来持有命令参数。实际上，你可以使用选项指定这两个指令，以覆盖命令行中的 `CMD` 指令，这正是我们在运行主机控制器时所做的。
- en: We used the `sed` command to modify the `host-slave.xml` file; further information
    on this command is out of the scope of this book.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `sed` 命令修改了 `host-slave.xml` 文件；关于此命令的更多信息超出了本书的范围。
- en: As you should already know, communication between the domain controller and
    the host controller needs to be verified. Thus, I inserted the hashed password
    of the `wildfly` user of `ManagementRealm`—the first and second `sed`. The third
    `sed` basically instructs the host controller to authenticate the domain controller
    with the `wildfly` user.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你应该已经知道的，域控制器和主机控制器之间的通信需要验证。因此，我插入了 `ManagementRealm` 中 `wildfly` 用户的哈希密码——第一个和第二个
    `sed`。第三个 `sed` 基本上指示主机控制器使用 `wildfly` 用户验证域控制器。
- en: Tip
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember that if you do not specify the `username` attribute in the `remote`
    XML element, the name of the host, `<host name="slave">`, will be used instead.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果你没有在 `remote` XML 元素中指定 `username` 属性，将使用主机名 `<host name="slave">` 代替。
- en: The last two `sed` commands instruct which address and port to use to connect
    to the domain controller. As we don't know which IP the container would have,
    we can rely on Docker's environment variables, which it automatically sets when
    it starts. This particular mapping is due to the `--link` flag used when launching
    the second container.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个 `sed` 命令指示使用哪个地址和端口连接到域控制器。由于我们不知道容器会有哪个 IP 地址，我们可以依赖 Docker 的环境变量，它在启动时会自动设置。这个特定的映射是由于在启动第二个容器时使用的
    `--link` 标志。
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the first container, we used the `--name` flag to give it a significant name,
    like `DC`. Then we used that same name with the `--link` flag to bind that container
    with the second one and map it to the `DOMAIN_CONTROLLER` alias.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个容器中，我们使用 `--name` 标志给它一个有意义的名称，比如 `DC`。然后我们使用相同的名称与 `--link` 标志将这个容器与第二个容器绑定，并将其映射到
    `DOMAIN_CONTROLLER` 别名。
- en: There is more…
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: 'When running a container, you can specify the hostname that it will have. In
    our example, we could have run the slaves, as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行容器时，你可以指定它将拥有的主机名。在我们的例子中，我们可以运行从属节点，如下所示：
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And in the topology overview, we would have seen the following page:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在拓扑概述中，我们会看到以下页面：
- en: '![There is more…](img/3744_15_06.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![更多内容…](img/3744_15_06.jpg)'
- en: The slave running in a Docker container with a significant name host-1
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker 容器中运行的有意义的名称主机-1
- en: This is a nice feature that can be handy, instead of trying to remember which
    hash a host belongs to.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很实用的功能，可以避免尝试记住哪个哈希属于哪个主机。
- en: In conclusion, the same kind of mechanism used in this recipe to configure and
    run the domain mode could be used to run a WildFly cluster.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，在这个菜谱中用于配置和运行域模式的相同机制也可以用来运行 WildFly 集群。
- en: See also
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: More information about linking Docker containers can be found at [https://docs.docker.com/userguide/dockerlinks/](https://docs.docker.com/userguide/dockerlinks/)
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于链接 Docker 容器的信息可以在 [https://docs.docker.com/userguide/dockerlinks/](https://docs.docker.com/userguide/dockerlinks/)
    找到。
