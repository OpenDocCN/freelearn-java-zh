- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Introduction to Microservices
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务简介
- en: This book does not blindly praise microservices. Instead, it’s about how we
    can use their benefits while being able to handle the challenges of building scalable,
    resilient, and manageable microservices.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书并不盲目赞扬微服务。相反，它讲述了我们如何利用其优势，同时能够处理构建可扩展、弹性好且可管理的微服务的挑战。
- en: 'As an introduction to this book, the following topics will be covered in this
    chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本书的介绍，本章将涵盖以下主题：
- en: My way into microservices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我进入微服务之路
- en: What is a microservice-based architecture?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是基于微服务的架构？
- en: Challenges with microservices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务的挑战
- en: Design patterns for handling challenges
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应对挑战的设计模式
- en: Software enablers that can help us handle these challenges
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以帮助我们处理这些挑战的软件赋能者
- en: Other important considerations that aren’t covered in this book
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书未涵盖的其他重要考虑因素
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: No installations are required for this chapter. However, you may be interested
    in taking a look at the C4 model conventions, [https://c4model.com](https://c4model.com),
    since the illustrations in this chapter are inspired by the C4 model.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不需要安装。然而，你可能对查看C4模型规范感兴趣，[https://c4model.com](https://c4model.com)，因为本章的插图灵感来源于C4模型。
- en: This chapter does not contain any source code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不包含任何源代码。
- en: My way into microservices
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我进入微服务之路
- en: When I first learned about the concept of microservices back in 2014, I realized
    that I had been developing microservices (well, kind of) for a number of years
    without knowing it was microservices I was dealing with. I was involved in a project
    that started in 2009 where we developed a platform based on a set of separated
    features. The platform was delivered to a number of customers that deployed it
    on-premises. To make it easy for customers to pick and choose what features they
    wanted to use from the platform, each feature was developed as an **autonomous
    software component**; that is, it had its own persistent data and only communicated
    with other components using well-defined APIs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在2014年首次了解到微服务的概念时，我意识到我多年来一直在不知情的情况下开发微服务（好吧，有点像）。我参与了一个2009年开始的项目，我们基于一组分离的特性开发了一个平台。该平台被交付给多个客户，他们在本地部署了它。为了使客户能够轻松选择他们想要从平台中使用的功能，每个特性都被开发为一个**自主软件组件**；也就是说，它有自己的持久化数据，并且仅通过定义良好的API与其他组件进行通信。
- en: 'Since I can’t discuss specific features in this project’s platform, I have
    generalized the names of the components, which are labeled from **Component A**
    to **Component F**. The **composition** of the platform as a set of components
    is illustrated as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我无法讨论项目中具体的功能，我已经将组件的名称进行了泛化，这些组件被标记为从**组件A**到**组件F**。平台的**组成**作为一组组件的图示如下：
- en: '![Diagram  Description automatically generated](img/B19825_01.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B19825_01.png)'
- en: 'Figure 1.1: The composition of the platform'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：平台组成
- en: From the illustration, we can also see that each component has its own storage
    for persistent data, and is not sharing databases with other components.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从图中我们还可以看到，每个组件都有自己的持久化数据存储，并且不与其他组件共享数据库。
- en: 'Each component is developed using Java and the Spring Framework, packaged as
    a WAR file, and deployed as a web app in a Java EE web container, for example,
    Apache Tomcat. Depending on the customer’s specific requirements, the platform
    can be deployed on single or multiple servers. A two-node deployment may look
    as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件都是使用Java和Spring框架开发的，打包为WAR文件，并在Java EE Web容器中作为Web应用部署，例如Apache Tomcat。根据客户的具体要求，平台可以部署在单个或多个服务器上。一个双节点部署可能如下所示：
- en: '![Diagram  Description automatically generated](img/B19825_02.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B19825_02.png)'
- en: 'Figure 1.2: A two-node deployment scenario'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：双节点部署场景
- en: Benefits of autonomous software components
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自主软件组件的好处
- en: 'From this project, I learned that decomposing the platform’s functionality
    into a set of autonomous software components provides a number of benefits:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个项目中，我了解到将平台的职能分解为一系列自主软件组件提供了许多好处：
- en: A customer can deploy parts of the platform in its own system landscape, integrating
    it with its existing systems using its well-defined APIs.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户可以在自己的系统环境中部署平台的部分，通过其定义良好的API将其与其现有系统集成。
- en: 'The following is an example where one customer decided to deploy **Component
    A**, **Component B**, **Component D**, and **Component E** from the platform and
    integrate them with two existing systems in the customer’s system landscape, **System
    A** and **System B**:'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是一个示例，其中一位客户决定从平台部署**组件A**、**组件B**、**组件D**和**组件E**，并将它们与客户系统环境中的两个现有系统**系统A**和**系统B**集成：
- en: '![Diagram  Description automatically generated](img/B19825_03.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图示  自动生成的描述](img/B19825_03.png)'
- en: 'Figure 1.3: Partial deployment of the platform'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3：平台的局部部署
- en: Another customer could choose to replace parts of the platform’s functionality
    with implementations that already exist in the customer’s system landscape, potentially
    requiring some adoption of the existing functionality in the platform’s APIs.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一位客户可以选择用客户系统环境中已有的实现来替换平台功能的一部分，这可能会要求在平台API中采用一些现有功能。
- en: 'The following is an example where a customer has replaced **Component C** and
    **Component F** in the platform with their own implementation:'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是一个示例，其中客户已将平台中的**组件C**和**组件F**替换为自己的实现：
- en: '![Diagram  Description automatically generated](img/B19825_04.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图示  自动生成的描述](img/B19825_04.png)'
- en: 'Figure 1.4: Replacing parts of the platform'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4：替换平台的部分
- en: Each component in the platform can be delivered and upgraded separately. Thanks
    to the use of well-defined APIs, one component can be upgraded to a new version
    without being dependent on the life cycle of the other components.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台中的每个组件都可以单独交付和升级。得益于使用定义良好的API，一个组件可以升级到新版本，而无需依赖于其他组件的生命周期。
- en: 'The following is an example where **Component A** has been upgraded from version
    **v1.1** to **v1.2**. **Component B**, which calls **Component A**, does not need
    to be upgraded since it uses a well-defined API; that is, it’s still the same
    after the upgrade (or it’s at least backward-compatible):'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是一个示例，其中**组件A**已从版本**v1.1**升级到**v1.2**。调用**组件A**的**组件B**不需要升级，因为它使用的是定义良好的API；也就是说，升级后它仍然是相同的（或者至少是向后兼容的）：
- en: '![Graphical user interface  Description automatically generated](img/B19825_05.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面  自动生成的描述](img/B19825_05.png)'
- en: 'Figure 1.5: Upgrading a specific component'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5：升级特定组件
- en: 'Thanks to the use of well-defined APIs, each component in the platform can
    also be scaled out to multiple servers independently of the other components.
    Scaling can be done either to meet high availability requirements or to handle
    higher volumes of requests. In this specific project, it was achieved by *manually*
    setting up load balancers in front of a number of servers, each running a Java
    EE web container. An example where **Component A** has been scaled out to three
    instances looks as follows:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于使用了定义良好的API，平台中的每个组件也可以独立于其他组件扩展到多个服务器。扩展可以是满足高可用性要求或处理更高请求量的需要。在这个特定项目中，这是通过在运行Java
    EE Web容器的多个服务器前手动设置负载均衡器来实现的。**组件A**已扩展到三个实例的示例如下：
- en: '![](img/B19825_06.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19825_06.png)'
- en: 'Figure 1.6: Scaling out the platform'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6：扩展平台
- en: Challenges with autonomous software components
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自主软件组件的挑战
- en: 'My team also learned that decomposing the platform introduced a number of new
    challenges that we were not exposed to (at least not to the same degree) when
    developing more traditional, monolithic applications:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我的团队还了解到，将平台分解引入了许多新的挑战，这些挑战在我们开发更传统的、单体式应用时并未遇到（至少没有达到同样的程度）：
- en: Adding new instances to a component required manually configuring load balancers
    and manually setting up new nodes. This work was both time-consuming and error-prone.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向组件添加新实例需要手动配置负载均衡器并手动设置新节点。这项工作既耗时又容易出错。
- en: The platform was initially prone to errors caused by the other systems it was
    communicating with. If a system stopped responding to requests that were sent
    from the platform in a timely fashion, the platform quickly ran out of crucial
    resources, for example, OS threads, specifically when exposed to a large number
    of concurrent requests. This caused components in the platform to hang or even
    crash. Since most of the communication in the platform is based on synchronous
    communication, one component crashing can lead to cascading failures; that is,
    clients of the crashing components could also crash after a while. This is known
    as a **chain of failures**.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台最初容易受到它所通信的其他系统引起的错误的影响。如果一个系统未能及时响应平台发送的请求，平台很快就会耗尽关键资源，例如，操作系统线程，尤其是在面对大量并发请求时。这导致平台中的组件挂起甚至崩溃。由于平台中的大多数通信都是基于同步通信，一个组件崩溃可能导致级联故障；也就是说，崩溃组件的客户端也可能在一段时间后崩溃。这被称为**故障链**。
- en: Keeping the configuration in all the instances of the components consistent
    and up to date quickly became a problem, causing a lot of manual and repetitive
    work. This led to quality problems from time to time.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持所有组件实例的配置一致并更新迅速成为一个问题，导致大量手动和重复性的工作。这有时会导致质量问题。
- en: Monitoring the state of the platform in terms of latency issues and hardware
    usage (for example, usage of CPU, memory, disks, and the network) was more complicated
    compared to monitoring a single instance of a monolithic application.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控平台在延迟问题和硬件使用（例如，CPU、内存、磁盘和网络的使用）方面的状态，与监控单体应用的单一实例相比，要复杂得多。
- en: Collecting log files from a number of distributed components and correlating
    related log events from the components was also difficult, but feasible since
    the number of components was fixed and known in advance.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从多个分布式组件收集日志文件并关联相关日志事件也是困难的，但由于组件数量固定且事先已知，因此是可行的。
- en: Over time, we addressed most of the challenges that were mentioned in the preceding
    list with a mix of in-house-developed tools and well-documented instructions for
    handling these challenges manually. The scale of the operation was, in general,
    at a level where manual procedures for releasing new versions of the components
    and handling runtime issues were acceptable, even though they were not desirable.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，我们通过内部开发的工具和针对手动处理这些挑战的详细说明，解决了前面提到的大多数挑战。操作的规模通常在可以接受的水平上，即使它们不是理想的，手动发布组件新版本和处理运行时问题也是可行的。
- en: Enter microservices
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进入微服务时代
- en: Learning about microservice-based architectures in 2014 made me realize that
    other projects had also been struggling with similar challenges (partly for other
    reasons than the ones I described earlier, for example, the large cloud service
    providers meeting web-scale requirements). Many microservice pioneers had published
    details of lessons they’d learned. It was very interesting to learn from these
    lessons.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 2014年了解基于微服务的架构让我意识到，其他项目也一直在努力应对类似的挑战（部分原因不同于我之前描述的原因，例如，大型云服务提供商满足Web规模需求）。许多微服务先驱已经发布了他们所学到经验教训的细节。从这些经验教训中学习非常有趣。
- en: Many of the pioneers initially developed monolithic applications that made them
    very successful from a business perspective. But over time, these monolithic applications
    became more and more difficult to maintain and evolve. They also became challenging
    to scale beyond the capabilities of the largest machines available (also known
    as **vertical scaling**). Eventually, the pioneers started to find ways to split
    monolithic applications into smaller components that could be released and scaled
    independently of each other. Scaling small components can be done using **horizontal
    scaling**, that is, deploying a component on a number of smaller servers and placing
    a load balancer in front of it. If done in the cloud, the scaling capability is
    potentially endless – it is just a matter of how many virtual servers you bring
    in (given that your component can scale out on a huge number of instances, but
    more on that later on).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 许多先驱最初开发了单体应用，从商业角度来看，它们非常成功。但随着时间的推移，这些单体应用变得越来越难以维护和演进。它们也变得难以扩展到最大机器的能力之外（也称为**垂直扩展**）。最终，先驱们开始寻找将单体应用拆分成更小组件的方法，这些组件可以独立发布和扩展。可以通过**水平扩展**来实现小组件的扩展，即在多个较小的服务器上部署组件，并在其前面放置一个负载均衡器。如果在云中执行，扩展能力可能是无限的——这仅仅是一个关于你将多少虚拟服务器引入的问题（假设你的组件可以在大量实例上扩展，但关于这一点稍后还会详细说明）。
- en: In 2014, I also learned about a number of new open source projects that delivered
    tools and frameworks that simplified the development of microservices and could
    be used to handle the challenges that come with a microservice-based architecture.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在2014年，我还了解到了一些新的开源项目，它们提供了工具和框架，简化了微服务的开发，并可用于处理基于微服务架构带来的挑战。
- en: 'Some of these are as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些如下：
- en: Pivotal released **Spring Cloud**, which wraps parts of the **Netflix OSS**
    in order to provide capabilities such as dynamic service discovery, configuration
    management, distributed tracing, circuit breaking, and more.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pivotal发布了**Spring Cloud**，它封装了**Netflix OSS**的部分功能，以提供动态服务发现、配置管理、分布式跟踪、断路器等功能。
- en: I also learned about **Docker** and the container revolution, which is great
    for minimizing the gap between development and production. Being able to package
    a component not only as a deployable runtime artifact (for example, a Java `war`
    or `jar` file) but as a complete image, ready to be launched as a container on
    a server running Docker, was a great step forward for development and testing.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我还了解到了**Docker**和容器革命，这对于缩小开发和生产之间的差距非常有帮助。能够将组件打包不仅作为可部署的运行时工件（例如，Java `war`或`jar`文件），而且作为一个完整的镜像，准备好在运行Docker的服务器上启动为容器，这对于开发和测试来说是一个巨大的进步。
- en: For now, think of a container as an isolated process. We will learn more about
    containers in *Chapter 4*, *Deploying Our Microservices Using Docker*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将容器视为一个隔离的过程。我们将在*第4章*，*使用Docker部署我们的微服务*中了解更多关于容器的内容。
- en: A container engine, such as Docker, is not enough to be able to use containers
    in a production environment. Something is needed that can ensure that all the
    containers are up and running and that can scale out containers on a number of
    servers, thereby providing high availability and increased compute resources.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器引擎，例如Docker，仅靠它本身还不足以在生产环境中使用容器。需要某种东西来确保所有容器都处于运行状态，并且能够在多台服务器上扩展容器，从而提供高可用性和增加计算资源。
- en: These types of products became known as **container orchestrators**. A number
    of products have evolved over the last few years, such as Apache Mesos, Docker
    in Swarm mode, Amazon ECS, HashiCorp Nomad, and **Kubernetes**. Kubernetes was
    initially developed by Google. When Google released v1.0 in 2015, it also donated
    Kubernetes to **CNCF** ([https://www.cncf.io/](https://www.cncf.io/)). During
    2018, Kubernetes became kind of a de facto standard, available both pre-packaged
    for on-premises use and as a service from most of the major cloud providers.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些类型的产品被称为**容器编排器**。在过去几年中，许多产品已经发展起来，例如Apache Mesos、Swarm模式下的Docker、Amazon
    ECS、HashiCorp Nomad和**Kubernetes**。Kubernetes最初是由Google开发的。当Google在2015年发布v1.0版本时，它还将Kubernetes捐赠给了**CNCF**
    ([https://www.cncf.io/](https://www.cncf.io/))。在2018年，Kubernetes成为了一种事实上的标准，既可以作为本地部署的预包装版本使用，也可以作为大多数主要云服务提供商的服务。
- en: As explained in [https://kubernetes.io/blog/2015/04/borg-predecessor-to-kubernetes/](https://kubernetes.io/blog/2015/04/borg-predecessor-to-kubernetes/),
    Kubernetes is actually an open source-based rewrite of an internal container orchestrator,
    named **Borg**, used by Google for more than a decade before the Kubernetes project
    was founded.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如[https://kubernetes.io/blog/2015/04/borg-predecessor-to-kubernetes/](https://kubernetes.io/blog/2015/04/borg-predecessor-to-kubernetes/)中所述，Kubernetes实际上是一个基于开源的重写，名为**Borg**的内部容器编排器，在Kubernetes项目成立之前，Google已经使用了十多年。
- en: In 2018, I started to learn about the concept of a **service mesh** and how
    a service mesh can complement a container orchestrator to further offload microservices
    from responsibilities to make them manageable and resilient.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2018年，我开始了解**服务网格**的概念以及服务网格如何补充容器编排器，进一步减轻微服务的责任，使其可管理和有弹性。
- en: A sample microservice landscape
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个示例微服务景观
- en: Since this book can’t cover all aspects of the technologies I just mentioned,
    I will focus on the parts that have proven to be useful in customer projects I
    have been involved in since 2014\. I will describe how they can be used together
    to create cooperating microservices that are manageable, scalable, and resilient.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书无法涵盖我刚才提到的所有技术方面，我将专注于自2014年以来我在客户项目中证明有用的部分。我将描述它们如何一起使用来创建可管理、可扩展和有弹性的协作微服务。
- en: 'Each chapter in this book will address a specific concern. To demonstrate how
    things fit together, I will use a small set of cooperating microservices that
    we will evolve throughout this book. The microservice landscape will be described
    in *Chapter 3*, *Creating a Set of Cooperating Microservices*; for now, it is
    sufficient to know that it looks like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的每一章都将解决一个特定的问题。为了展示事物是如何相互关联的，我将使用一组协作的微服务，我们将在整本书中逐步发展这些微服务。微服务景观将在*第3章*，*创建一组协作微服务*中描述；目前，只需知道它看起来是这样的：
- en: '![Diagram  Description automatically generated](img/B19825_07.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B19825_07.png)'
- en: 'Figure 1.7: The microservice-based system landscape used in the book'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7：本书中使用的基于微服务的系统景观
- en: Note that this is a very small system landscape of cooperating microservices.
    The surrounding support services that we will add in the coming chapters might
    look overwhelmingly complex for these few microservices. But keep in mind that
    the solutions presented in this book aim to support a much larger system landscape.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这是一个非常小的协作微服务系统景观。我们将在接下来的章节中添加的周围支持服务对于这些微服务来说可能看起来过于复杂。但请记住，本书中提出的解决方案旨在支持一个更大的系统景观。
- en: Now that we have been introduced to the potential benefits and challenges of
    microservices, let’s start to look into how a microservice can be defined.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了微服务的潜在利益和挑战，让我们开始探讨如何定义微服务。
- en: Defining a microservice
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义微服务
- en: 'A microservice architecture is about splitting up monolithic applications into
    smaller components, which achieves two major goals:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构是将单体应用程序拆分为更小的组件，这实现了两个主要目标：
- en: Faster development, enabling continuous deployments
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更快的开发，实现持续部署
- en: Easier to scale, manually or automatically
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易扩展，手动或自动
- en: 'A microservice is essentially an autonomous software component that is independently
    upgradeable, replaceable, and scalable. To be able to act as an autonomous component,
    it must fulfill certain criteria, as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务本质上是一个独立的软件组件，它可以独立升级、替换和扩展。为了能够作为一个自主组件，它必须满足以下某些标准：
- en: It must conform to a shared-nothing architecture; that is, microservices don’t
    share data in databases with each other!
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须符合无共享架构；也就是说，微服务之间不共享数据库中的数据！
- en: It must only communicate through well-defined interfaces, either using APIs
    and synchronous services or preferably by sending messages asynchronously. The
    APIs and message formats used must be stable, well documented, and evolve by following
    a defined versioning strategy.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须仅通过定义良好的接口进行通信，无论是使用API和同步服务，还是最好通过异步发送消息。使用的API和消息格式必须是稳定的、有良好文档的，并遵循定义的版本策略。
- en: It must be deployed as separate runtime processes. Each instance of a microservice
    runs in a separate runtime process, for example, a Docker container.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须作为独立的运行时进程部署。每个微服务的实例都在一个独立的运行时进程中运行，例如，一个Docker容器。
- en: Microservice instances are stateless so that incoming requests to a microservice
    can be handled by any of its instances.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务实例是无状态的，因此进入微服务的请求可以由其任何实例处理。
- en: Using a set of cooperating microservices, we can deploy to a number of smaller
    servers instead of being forced to deploy to a single big server, like we have
    to do when deploying a monolithic application.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一组协作的微服务，我们可以部署到多个较小的服务器上，而不是被迫部署到单个大型服务器上，就像部署单体应用程序时必须做的那样。
- en: Given that the preceding criteria have been fulfilled, it is easier to scale
    up a single microservice into more instances (for example, using more virtual
    servers) compared to scaling up a big monolithic application.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于已经满足了上述标准，将单个微服务扩展到更多实例（例如，使用更多虚拟服务器）比扩展大型单体应用程序要容易得多。
- en: Utilizing autoscaling capabilities that are available in the cloud is also a
    possibility, but is not typically feasible for a big monolithic application. It’s
    also easier to upgrade or even replace a single microservice compared to upgrading
    a big monolithic application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 利用云中可用的自动扩展功能也是一种可能性，但对于大型单体应用程序来说通常不可行。与升级大型单体应用程序相比，升级或甚至替换单个微服务也更容易。
- en: 'This is illustrated by the following diagram, where a monolithic application
    has been divided into six microservices, all of which have been deployed into
    separate servers. Some of the microservices have also been scaled up independently
    of the others:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了这一点，其中单体应用程序已被分割成六个微服务，所有这些微服务都已部署到单独的服务器上。其中一些微服务也独立于其他微服务进行了扩展：
- en: '![Diagram  Description automatically generated with medium confidence](img/B19825_08.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成，置信度中等](img/B19825_08.png)'
- en: 'Figure 1.8: Dividing a monolith into microservices'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8：将单体分解为微服务
- en: 'A very frequent question I receive from customers is:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常从客户那里收到的一个非常频繁的问题是：
- en: How big should a microservice be?
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 微服务应该有多大？
- en: 'I try to use the following rules of thumb:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我尝试使用以下经验法则：
- en: Small enough to fit in the head of a developer
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 足够小，可以放入开发者的脑海中
- en: Big enough to not jeopardize performance (that is, latency) and/or data consistency
    (SQL foreign keys between data that’s stored in different microservices are no
    longer something you can take for granted)
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 足够大，不会危及性能（即延迟）和/或数据一致性（存储在不同微服务中的数据之间的SQL外键不再是你可以理所当然的事情）
- en: So, to summarize, microservice architecture is, in essence, an architectural
    style where we decompose a monolithic application into a group of cooperating
    autonomous software components. The motivation is to enable faster development
    and to make it easier to scale the application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结来说，微服务架构本质上是一种架构风格，我们将单体应用程序分解成一组协作的自主软件组件。其动机是使开发更快，并使扩展应用程序更容易。
- en: With a better understanding of how to define a microservice, we can move on
    and detail the challenges that come with a system landscape of microservices.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在更好地理解如何定义微服务之后，我们可以继续详细说明与微服务系统景观相关的挑战。
- en: Challenges with microservices
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的挑战
- en: 'In the *Challenges with autonomous software components* section, we have already
    seen some of the challenges that autonomous software components can bring (and
    they all apply to microservices as well), as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在*自主软件组件的挑战*部分，我们已经看到了自主软件组件可能带来的某些挑战（它们同样适用于微服务），如下所示：
- en: Many small components that use synchronous communication can cause *a chain
    of failure* problem, especially under high load
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多使用同步通信的小型组件可能会引起*连锁故障*问题，尤其是在高负载下
- en: Keeping the configuration up to date for many small components can be challenging
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持许多小型组件的配置更新可能具有挑战性
- en: It’s hard to track a request that’s being processed and involves many components,
    for example, when performing root cause analysis, where each component stores
    log records locally
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪一个涉及许多组件且正在处理中的请求是很困难的，例如，在进行根本原因分析时，每个组件都本地存储日志记录
- en: Analyzing the usage of hardware resources on a component level can be challenging
    as well
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件级别上分析硬件资源的使用也可能具有挑战性
- en: Manual configuration and management of many small components can become costly
    and error-prone
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动配置和管理许多小型组件可能会变得成本高昂且容易出错
- en: 'Another downside (but not always obvious initially) of decomposing an application
    into a group of autonomous components is that they form a **distributed system**.
    Distributed systems are known to be, by their nature, very hard to deal with.
    This has been known for many years (but in many cases was neglected until proven
    differently). My favorite quote to establish this fact is from Peter Deutsch who,
    back in 1994, stated the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序分解成一组自治组件的另一个缺点（但最初可能并不明显）是它们形成了一个**分布式系统**。众所周知，分布式系统由于其本质而非常难以处理。这一点已经为人所知多年（但在许多情况下直到被证明不同才被忽视）。我最喜欢的关于这一事实的引言来自彼得·德克斯特，他在1994年提出了以下观点：
- en: '**The 8 fallacies of distributed computing**: Essentially everyone, when they
    first build a distributed application, makes the following eight assumptions.
    All prove to be false in the long run and all cause big trouble and painful learning
    experiences:'
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**分布式计算的8大谬误**：基本上，每个人在第一次构建分布式应用程序时，都会做出以下八个假设。所有这些假设在长期内都被证明是错误的，并且都导致了巨大的麻烦和痛苦的学习经历：'
- en: ''
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 1\. The network is reliable
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1. 网络是可靠的
- en: ''
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 2\. Latency is zero
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2. 延迟为零
- en: ''
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 3\. Bandwidth is infinite
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3. 带宽是无限的
- en: ''
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 4\. The network is secure
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 4. 网络是安全的
- en: ''
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 5\. The topology doesn’t change
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 5. 拓扑结构不会改变
- en: ''
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 6\. There is one administrator
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6. 只有一个管理员
- en: ''
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 7\. The transport cost is zero
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 7. 传输成本为零
- en: ''
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 8\. The network is homogeneous
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 8. 网络是同质的
- en: ''
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: — Peter Deutsch, 1994
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ——彼得·德克斯特，1994年
- en: In general, building microservices based on these false assumptions leads to
    solutions that are prone to both temporary network glitches and problems that
    occur in other microservice instances. When the number of microservices in a system
    landscape increases, the likelihood of problems also goes up. A good rule of thumb
    is to design your microservice architecture based on the assumption that there
    is always something going wrong in the system landscape. The microservice architecture
    needs to be designed to handle this, in terms of detecting problems and restarting
    failed components. Also, on the client side, ensure that requests are not sent
    to failed microservice instances. When problems are corrected, requests to the
    previously failing microservice should be resumed; that is, microservice clients
    need to be resilient. All of this needs, of course, to be fully automated. With
    a large number of microservices, it is not feasible for operators to handle this
    manually!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，基于这些错误假设构建的微服务会导致容易受到暂时性网络故障和其他微服务实例中发生的问题的影响。当系统景观中微服务的数量增加时，问题的可能性也会增加。一个很好的经验法则是根据系统景观中始终存在某些问题的假设来设计您的微服务架构。微服务架构需要设计来处理这些问题，包括检测问题和重启失败的组件。此外，在客户端，确保不要向失败的微服务实例发送请求。当问题得到纠正时，应恢复对之前失败的微服务的请求；也就是说，微服务客户端需要具有弹性。当然，所有这些都需要完全自动化。对于大量微服务，操作员手动处理这是不可行的！
- en: The scope of this is large, but we will limit ourselves for now and move on
    to learn about design patterns for microservices.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本主题的范围很广，但我们将暂时限制自己，并继续学习微服务的设计模式。
- en: Design patterns for microservices
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务设计模式
- en: This topic will cover the use of design patterns to mitigate challenges with
    microservices, as described in the preceding section. Later in this book, we will
    see how we can implement these design patterns using Spring Boot, Spring Cloud,
    Kubernetes, and Istio.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 本主题将涵盖使用设计模式来缓解前述部分中描述的微服务挑战。在本书的后续部分，我们将看到如何使用Spring Boot、Spring Cloud、Kubernetes和Istio来实现这些设计模式。
- en: The concept of design patterns is actually quite old; it was invented by Christopher
    Alexander back in 1977\. In essence, a design pattern is about describing a reusable
    solution to a problem when given a specific context. Using a tried and tested
    solution from a design pattern can save a lot of time and increase the quality
    of the implementation compared to spending time inventing the solution ourselves.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式的概念实际上相当古老；它是由克里斯托弗·亚历山大在1977年发明的。本质上，设计模式是关于在特定上下文中描述一个可重用解决方案来解决问题的。使用设计模式中的经过验证和测试的解决方案可以节省大量时间，并且与自行发明解决方案相比，可以提高实现的品质。
- en: 'The design patterns we will cover are as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的设计模式如下：
- en: Service discovery
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现
- en: Edge server
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边缘服务器
- en: Reactive microservices
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式微服务
- en: Central configuration
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中央配置
- en: Centralized log analysis
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中央日志分析
- en: Distributed tracing
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式跟踪
- en: Circuit breaker
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电路断路器
- en: Control loop
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制回路
- en: Centralized monitoring and alarms
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中央监控和警报
- en: This list is not intended to be comprehensive; instead, it’s a minimal list
    of design patterns that are required to handle the challenges we described previously.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表并非旨在全面；相反，它是一个最小列表，列出了处理我们之前描述的挑战所需的设计模式。
- en: 'We will use a lightweight approach to describing design patterns, and focus
    on the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用轻量级的方法来描述设计模式，并重点关注以下内容：
- en: The problem
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题
- en: A solution
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案
- en: Requirements for the solution
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案的要求
- en: Throughout this book, we will delve more deeply into how to apply these design
    patterns. The context for these design patterns is a system landscape of cooperating
    microservices where the microservices communicate with each other using either
    synchronous requests (for example, using HTTP) or by sending asynchronous messages
    (for example, using a message broker).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将更深入地探讨如何应用这些设计模式。这些设计模式的应用背景是一个由协作微服务组成的系统景观，其中微服务通过同步请求（例如，使用HTTP）或发送异步消息（例如，使用消息代理）相互通信。
- en: Service discovery
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务发现
- en: The service discovery pattern has the following problem, solution, and solution
    requirements.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 服务发现模式存在以下问题、解决方案和解决方案要求。
- en: Problem
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: How can clients find microservices and their instances?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端如何找到微服务和它们的实例？
- en: 'Microservices instances are typically assigned dynamically allocated IP addresses
    when they start up, for example, when running in containers. This makes it difficult
    for a client to make a request to a microservice that, for example, exposes a
    REST API over HTTP. Consider the following diagram:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务实例在启动时通常会分配动态分配的IP地址，例如，在容器中运行时。这使得客户端难以向一个例如通过HTTP暴露REST API的微服务发起请求。考虑以下图表：
- en: '![Graphical user interface, diagram  Description automatically generated](img/B19825_09.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，图表  自动生成的描述](img/B19825_09.png)'
- en: 'Figure 1.9: The service discovery issue'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9：服务发现问题
- en: Solution
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: Add a new component – a **service discovery** service – to the system landscape,
    which keeps track of currently available microservices and the IP addresses of
    its instances.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 向系统景观添加一个新的组件——一个**服务发现**服务——以跟踪当前可用的微服务和其实例的IP地址。
- en: Solution requirements
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案要求
- en: 'Some solution requirements are as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一些解决方案的要求如下：
- en: Automatically register/unregister microservices and their instances as they
    come and go.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动注册/注销微服务和它们的实例，随着它们的到来和离去。
- en: The client must be able to make a request to a logical endpoint for the microservice.
    The request will be routed to one of the available microservice instances.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端必须能够向微服务的一个逻辑端点发起请求。请求将被路由到可用的微服务实例之一。
- en: Requests to a microservice must be load-balanced over the available instances.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须在可用的实例之间对微服务的请求进行负载均衡。
- en: We must be able to detect instances that currently are unhealthy so that requests
    will not be routed to them.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须能够检测当前不健康的实例，以便请求不会路由到它们。
- en: '**Implementation notes**: As we will see in *Chapter 9*, *Adding Service Discovery
    Using Netflix Eureka*, *Chapter 15*, *Introduction to Kubernetes*, and *Chapter
    16*, *Deploying Our Microservices to Kubernetes*, this design pattern can be implemented
    using two different strategies:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**实施说明**：正如我们将在第9章“使用Netflix Eureka添加服务发现”、第15章“Kubernetes简介”和第16章“将我们的微服务部署到Kubernetes”中看到的那样，此设计模式可以使用两种不同的策略实现：'
- en: '**Client-side routing**: The client uses a library that communicates with the
    service discovery service to find out the proper instances to send the requests
    to.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端路由**：客户端使用一个库与服务发现服务通信，以找出应向其发送请求的正确实例。'
- en: '**Server-side routing**: The infrastructure of the service discovery service
    also exposes a reverse proxy that all requests are sent to. The reverse proxy
    forwards the requests to a proper microservice instance on behalf of the client.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器端路由**：服务发现服务的基础设施还公开了一个反向代理，所有请求都发送到该代理。反向代理代表客户端将请求转发到适当的微服务实例。'
- en: Edge server
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 边缘服务器
- en: The edge server pattern has the following problem, solution, and solution requirements.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘服务器模式具有以下问题、解决方案和解决方案要求。
- en: Problem
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: In a system landscape of microservices, it is in many cases desirable to expose
    some of the microservices to the outside of the system landscape and hide the
    remaining microservices from external access. The exposed microservices must be
    protected against requests from malicious clients.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务系统景观中，在许多情况下，希望将一些微服务暴露给系统景观之外，并将剩余的微服务隐藏对外访问。暴露的微服务必须保护免受恶意客户端的请求。
- en: Solution
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Add a new component, an **edge server**, to the system landscape that all incoming
    requests will go through:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 向系统景观中添加一个新的组件，一个**边缘服务器**，所有进入的请求都将通过它：
- en: '![Diagram  Description automatically generated](img/B19825_10.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B19825_10.png)'
- en: 'Figure 1.10: The edge server design pattern'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.10：边缘服务器设计模式
- en: '**Implementation notes**: An edge server typically behaves like a reverse proxy
    and can be integrated with a discovery service to provide dynamic load-balancing
    capabilities.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**实施说明**：边缘服务器通常表现得像一个反向代理，可以与发现服务集成以提供动态负载均衡功能。'
- en: Solution requirements
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案要求
- en: 'Some solution requirements are as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一些解决方案要求如下：
- en: Hide internal services that should not be exposed outside their context; that
    is, only route requests to microservices that are configured to allow external
    requests
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏那些不应暴露在其上下文之外的内部服务；也就是说，只将请求路由到配置为允许外部请求的微服务
- en: Expose external services and protect them from malicious requests; that is,
    use standard protocols and best practices such as OAuth, OIDC, JWT tokens, and
    API keys to ensure that the clients are trustworthy
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暴露外部服务并保护它们免受恶意请求；也就是说，使用标准协议和最佳实践，如OAuth、OIDC、JWT令牌和API密钥，以确保客户端是可信的。
- en: Reactive microservices
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反应式微服务
- en: The reactive microservices pattern has the following problem, solution, and
    solution requirements.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式微服务模式存在以下问题、解决方案和解决方案要求。
- en: Problem
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: Traditionally, as Java developers, we are used to implementing synchronous communication
    using blocking I/O, for example, a RESTful JSON API over HTTP. Using a blocking
    I/O means that a thread is allocated from the operating system for the length
    of the request.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，作为Java开发者，我们习惯于使用阻塞I/O实现同步通信，例如，通过HTTP的RESTful JSON API。使用阻塞I/O意味着操作系统为请求的长度分配了一个线程。
- en: If the number of concurrent requests goes up, a server might run out of available
    threads in the operating system, causing problems ranging from longer response
    times to crashing servers. Using a microservice architecture typically makes this
    problem even worse, where typically a chain of cooperating microservices is used
    to serve a request. The more microservices involved in serving a request, the
    faster the available threads will be drained.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果并发请求数量增加，服务器可能会在操作系统中耗尽可用的线程，导致从响应时间变长到服务器崩溃的问题。使用微服务架构通常会使这个问题更加严重，通常使用一系列协作的微服务来处理请求。参与服务请求的微服务越多，可用的线程就会越快耗尽。
- en: Solution
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use non-blocking I/O to ensure that no threads are allocated while waiting for
    processing to occur in another service, that is, a database or another microservice.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非阻塞I/O来确保在等待另一个服务（例如数据库或另一个微服务）的处理过程中不会分配线程。
- en: Solution requirements
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案要求
- en: 'Some solution requirements are as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一些解决方案要求如下：
- en: Whenever feasible, use an asynchronous programming model, sending messages without
    waiting for the receiver to process them.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可行的情况下，使用异步编程模型，发送消息而不等待接收者处理它们。
- en: If a synchronous programming model is preferred, use reactive frameworks that
    can execute synchronous requests using non-blocking I/O, without allocating a
    thread while waiting for a response. This will make the microservices easier to
    scale in order to handle an increased workload.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果更喜欢同步编程模型，请使用可以使用非阻塞I/O执行同步请求的响应式框架，在等待响应时不分配线程。这将使微服务更容易扩展以处理增加的工作负载。
- en: Microservices must also be designed to be resilient and self-healing. Resilient
    meaning being capable of producing a response even if one of the services it depends
    on fails; self-healing meaning that once the failing service is operational again,
    the microservice must be able to resume using it.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务还必须设计成具有弹性和自我修复能力。弹性意味着即使在它依赖的服务中有一个失败的情况下也能产生响应；自我修复意味着一旦失败的服务再次运行，微服务必须能够重新使用它。
- en: In 2013, key principles for designing reactive systems were established in **The
    Reactive Manifesto** ([https://www.reactivemanifesto.org/](https://www.reactivemanifesto.org/)).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 2013年，在**《反应式宣言》**中确立了设计反应式系统的关键原则([https://www.reactivemanifesto.org/](https://www.reactivemanifesto.org/))。
- en: According to the manifesto, the foundation for reactive systems is that they
    are message-driven; they use asynchronous communication. This allows them to be
    elastic, that is, scalable, and resilient, that is, tolerant to failures. Elasticity
    and resilience together enable a reactive system to always respond in a timely
    fashion.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 根据宣言，反应式系统的基础是它们是消息驱动的；它们使用异步通信。这使得它们具有弹性，即可伸缩性，以及弹性，即对失败的容忍性。弹性和弹性共同使反应式系统能够始终及时响应。
- en: Central configuration
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中央配置
- en: The central configuration pattern has the following problem, solution, and solution
    requirements.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 中央配置模式存在以下问题、解决方案和解决方案需求。
- en: Problem
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: 'An application is, traditionally, deployed together with its configuration,
    for example, a set of environment variables and/or files containing configuration
    information. Given a system landscape based on a microservice architecture, that
    is, with a large number of deployed microservice instances, some queries arise:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，应用程序与其配置一起部署，例如，一组环境变量和/或包含配置信息的文件。给定一个基于微服务架构的系统景观，即有大量部署的微服务实例，会出现一些查询：
- en: How do I get a complete picture of the configuration that is in place for all
    the running microservice instances?
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我如何获得所有运行中的微服务实例中配置的完整视图？
- en: How do I update the configuration and make sure that all the affected microservice
    instances are updated correctly?
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我如何更新配置并确保所有受影响的微服务实例都正确更新？
- en: Solution
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Add a new component, a **configuration server**, to the system landscape to
    store the configuration of all the microservices, as illustrated by the following
    diagram:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 向系统架构中添加一个新的组件，即**配置服务器**，以存储所有微服务的配置，如下所示：
- en: '![Diagram  Description automatically generated](img/B19825_11.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B19825_11.png)'
- en: 'Figure 1.11: The central configuration design pattern'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11：中央配置设计模式
- en: Solution requirements
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案需求
- en: Make it possible to store configuration information for a group of microservices
    in one place, with different settings for different environments (for example,
    **dev**, **test**, **qa**, and **prod**).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使一组微服务的配置信息能够存储在一个地方，并为不同的环境（例如，**dev**、**test**、**qa**和**prod**）设置不同的配置。
- en: Centralized log analysis
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集中日志分析
- en: Centralized log analysis has the following problem, solution, and solution requirements.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 集中日志分析存在以下问题、解决方案和解决方案需求。
- en: Problem
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: 'Traditionally, an application writes log events to log files that are stored
    in the local filesystem of the server that the application runs on. Given a system
    landscape based on a microservice architecture, that is, with a large number of
    deployed microservice instances on a large number of smaller servers, we can ask
    the following questions:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，应用程序将日志事件写入存储在应用程序运行的服务器本地文件系统中的日志文件。给定一个基于微服务架构的系统景观，即在大量较小的服务器上部署了大量的微服务实例，我们可以提出以下问题：
- en: How do I get an overview of what is going on in the system landscape when each
    microservice instance writes to its own local log file?
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当每个微服务实例将其自己的本地日志文件写入时，我如何获得系统景观中正在发生的事情的概览？
- en: How do I find out if any of the microservice instances get into trouble and
    start writing error messages to their log files?
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我如何知道是否有任何微服务实例遇到麻烦并开始向它们的日志文件中写入错误消息？
- en: 'If end users start to report problems, how can I find related log messages;
    that is, how can I identify which microservice instance is the root cause of the
    problem? The following diagram illustrates the problem:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果最终用户开始报告问题，我如何找到相关的日志消息；也就是说，我如何确定哪个微服务实例是问题的根本原因？以下图表说明了问题：
- en: '![Diagram  Description automatically generated](img/B19825_12.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B19825_12.png)'
- en: 'Figure 1.12: Microservices write log files to their local file system'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.12：微服务将日志文件写入其本地文件系统
- en: Solution
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Add a new component that can manage **centralized logging** and is capable
    of the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个新组件，它可以管理**集中式日志记录**，并能够执行以下操作：
- en: Detecting new microservice instances and collecting log events from them
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测新的微服务实例并从它们收集日志事件
- en: Interpreting and storing log events in a structured and searchable way in a
    central database
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在中央数据库中以结构化和可搜索的方式解释和存储日志事件
- en: Providing APIs and graphical tools for querying and analyzing log events
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供查询和分析日志事件的API和图形工具
- en: Solution requirements
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案要求
- en: 'Some solution requirements are as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一些解决方案要求如下：
- en: Microservices stream log events to standard system output, `stdout`. This makes
    it easier for a log collector to find the log events compared to when log events
    are written to microservice-specific log files.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务将日志事件流式传输到标准系统输出，`stdout`。与将日志事件写入特定微服务的日志文件相比，这使得日志收集器更容易找到日志事件。
- en: Microservices tag the log events with the correlation ID described in the next
    section regarding the *Distributed tracing* design pattern.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务使用下一节中关于*分布式跟踪*设计模式描述的相关ID标记日志事件。
- en: A canonical log format is defined, so that log collectors can transform log
    events collected from the microservices to a canonical log format before log events
    are stored in the central database. Storing log events in a canonical log format
    is required to be able to query and analyze the collected log events.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义了一个规范化的日志格式，以便日志收集器可以在将日志事件存储到中央数据库之前，将来自微服务的日志事件转换为规范化日志格式。在规范化日志格式中存储日志事件是能够查询和分析收集到的日志事件所必需的。
- en: Distributed tracing
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分布式跟踪
- en: Distributed tracing has the following problem, solution, and solution requirements.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式跟踪存在以下问题、解决方案和解决方案要求。
- en: Problem
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: It must be possible to track requests and messages that flow between microservices
    while processing an external request to the system landscape.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 必须能够跟踪在处理系统景观外部请求时在微服务之间流动的请求和消息。
- en: 'Some examples of fault scenarios are as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一些故障场景的例子如下：
- en: If end users start to file support cases regarding a specific failure, how can
    we identify the microservice that caused the problem, that is, the root cause?
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果最终用户开始提交关于特定故障的支持案例，我们如何识别导致问题的微服务，即根本原因？
- en: If one support case mentions problems related to a specific entity, for example,
    a specific order number, how can we find log messages related to processing this
    specific order – for example, log messages from all microservices that were involved
    in processing it?
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果某个支持案例提到了与特定实体相关的问题，例如，特定的订单号，我们如何找到与处理此特定订单相关的日志消息——例如，所有参与处理该订单的微服务的日志消息？
- en: If end users start to file support cases regarding an unacceptably long response
    time, how can we identify which microservice in a call chain is causing the delay?
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果最终用户开始提交关于响应时间过长的问题支持案例，我们如何识别调用链中哪个微服务导致了延迟？
- en: 'The following diagram depicts this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了这一点：
- en: '![Diagram  Description automatically generated](img/B19825_13.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图示描述自动生成](img/B19825_13.png)'
- en: 'Figure 1.13: The distributed tracing issue'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.13：分布式跟踪问题
- en: Solution
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: To track the processing between cooperating microservices, we need to ensure
    that all related requests and messages are marked with a common **correlation
    ID** and that the correlation ID is part of all log events. Based on a correlation
    ID, we can use the centralized logging service to find all related log events.
    If one of the log events also includes information about a business-related identifier,
    for example, the ID of a customer, product, or order, we can find all related
    log events for that business identifier using the correlation ID.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪协作微服务之间的处理过程，我们需要确保所有相关请求和消息都带有共同的**关联ID**，并且关联ID是所有日志事件的一部分。基于关联ID，我们可以使用集中式日志服务来查找所有相关的日志事件。如果其中一个日志事件还包含有关业务标识符的信息，例如，客户的ID、产品或订单，我们可以使用关联ID找到该业务标识符的所有相关日志事件。
- en: To be able to analyze delays in a call chain of cooperating microservices, we
    must be able to collect timestamps for when requests, responses, and messages
    enter and exit each microservice.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够分析协作微服务调用链中的延迟，我们必须能够收集请求、响应和消息进入和退出每个微服务的时间戳。
- en: Solution requirements
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案要求
- en: 'The solution requirements are as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案要求如下：
- en: Assign unique correlation IDs to all incoming or new requests and events in
    a well-known place, such as a header with a standardized name
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个已知位置为所有传入或新的请求和事件分配唯一的关联ID，例如，带有标准化名称的报头
- en: When a microservice makes an outgoing request or sends a message, it must add
    the correlation ID to the request and message
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当微服务发出出站请求或发送消息时，它必须将关联ID添加到请求和消息中。
- en: All log events must include the correlation ID in a predefined format so that
    the centralized logging service can extract the correlation ID from the log event
    and make it searchable
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有日志事件都必须包含预定义格式的关联ID，以便集中日志服务可以从日志事件中提取关联ID并使其可搜索。
- en: Trace records must be created for when requests, responses, and messages both
    enter and exit a microservice instance
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当请求、响应和消息进入和退出微服务实例时，必须创建跟踪记录。
- en: Circuit breaker
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 断路器
- en: The circuit breaker pattern has the following problem, solution, and solution
    requirements.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器模式存在以下问题、解决方案和解决方案需求。
- en: Problem
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: A system landscape of microservices that uses synchronous intercommunication
    can be exposed to a **chain of failures**. If one microservice stops responding,
    its clients might get into problems as well and stop responding to requests from
    their clients. The problem can propagate recursively throughout a system landscape
    and take out major parts of it.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用同步交互的微服务系统景观可能会暴露于**连锁故障**之中。如果一个微服务停止响应，其客户端可能会遇到问题，并停止对客户端的请求做出响应。问题可能会递归地传播到整个系统景观，并使其主要部分失效。
- en: This is especially common in cases where synchronous requests are executed using
    blocking I/O, that is, blocking a thread from the underlying operating system
    while a request is being processed. Combined with a large number of concurrent
    requests and a service that starts to respond unexpectedly slowly, thread pools
    can quickly become drained, causing the caller to hang and/or crash. This failure
    can spread unpleasantly quickly to the caller’s caller, and so on.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这在同步请求使用阻塞I/O执行的情况下尤其常见，即阻塞底层操作系统的线程，在请求处理期间。结合大量并发请求和开始以意外缓慢的速度响应的服务，线程池可能会迅速耗尽，导致调用者挂起和/或崩溃。这种故障会迅速传播到调用者的调用者，依此类推。
- en: Solution
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: Add a **circuit breaker** that prevents new outgoing requests from a caller
    if it detects a problem with the service it calls.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果检测到调用服务的问题，添加一个**断路器**以阻止调用者发出新的出站请求。
- en: Solution requirements
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案需求
- en: 'The solution requirements are as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案需求如下：
- en: '**Open** the circuit and fail fast (without waiting for a timeout) if problems
    with the service are detected.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打开**电路并快速失败（不等待超时），如果检测到服务存在问题。'
- en: Probe for failure correction (also known as a **half-open** circuit); that is,
    allow a single request to go through on a regular basis to see whether the service
    is operating normally again.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于故障纠正的探测（也称为**半开**电路）；也就是说，定期允许单个请求通过，以查看服务是否已恢复正常运行。
- en: '**Close** the circuit if the probe detects that the service is operating normally
    again. This capability is very important since it makes the system landscape resilient
    to these kinds of problems; in other words, it self-heals.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关闭**电路，如果探测到服务再次正常运行。这种能力非常重要，因为它使系统景观对这些类型的问题具有弹性；换句话说，它能够自我修复。'
- en: 'The following diagram illustrates a scenario where all synchronous communication
    within the system landscape of microservices goes through circuit breakers. All
    the circuit breakers are closed; they allow traffic, except for one circuit breaker
    (for **Microservice E**) that has detected problems in the service the requests
    go to. Therefore, this circuit breaker is open and utilizes fast-fail logic; that
    is, it does not call the failing service and waits for a timeout to occur. Instead,
    **Microservice E** can immediately return a response, optionally applying some
    fallback logic before responding:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了在微服务系统景观中所有同步通信都通过断路器进行的场景。所有断路器都是关闭的；它们允许流量通过，除了检测到请求服务存在问题的一个断路器（针对**微服务E**）。因此，这个断路器是打开的，并使用快速失败逻辑；也就是说，它不调用失败的服务，并等待超时发生。相反，**微服务E**可以立即返回响应，在响应前可选地应用一些回退逻辑：
- en: '![Diagram  Description automatically generated](img/B19825_14.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B19825_14.png)'
- en: 'Figure 1.14: The circuit breaker design pattern'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.14：断路器设计模式
- en: Control loop
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制循环
- en: The control loop pattern has the following problem, solution, and solution requirements.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 控制循环模式有以下问题、解决方案和解决方案需求。
- en: Problem
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: In a system landscape with a large number of microservice instances spread out
    over a number of servers, it is very difficult to manually detect and correct
    problems such as crashed or hung microservice instances.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个拥有大量微服务实例的系统景观中，这些实例分散在多个服务器上，手动检测和纠正崩溃或挂起的微服务实例等问题非常困难。
- en: Solution
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Add a new component, a **control loop**, to the system landscape. This process
    is illustrated as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统景观中添加一个新的组件，一个**控制循环**。这个过程如下所示：
- en: '![Diagram  Description automatically generated](img/B19825_15.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B19825_15.png)'
- en: 'Figure 1.15: The control loop design pattern'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.15：控制循环设计模式
- en: Solution requirements
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案要求
- en: The control loop will constantly observe the **actual state** of the system
    landscape, comparing it with a **desired state**, as specified by the operators.
    If the two states differ, it will take action to make the actual state equal to
    the desired state.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 控制循环将不断观察系统景观的**实际状态**，将其与操作员指定的**期望状态**进行比较。如果两个状态不同，它将采取行动使实际状态等于期望状态。
- en: '**Implementation notes**: In the world of containers, a *container orchestrator*
    such as Kubernetes is typically used to implement this pattern. We will learn
    more about Kubernetes in *Chapter 15*, *Introduction to Kubernetes*.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**实施说明**：在容器世界中，通常使用*容器编排器*（如Kubernetes）来实现此模式。我们将在第15章“Kubernetes简介”中了解更多关于Kubernetes的内容。'
- en: Centralized monitoring and alarms
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集中式监控和警报
- en: For this pattern, we have the following problem, solution, and solution requirements.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个模式，我们遇到了以下问题、解决方案和解决方案要求。
- en: Problem
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: If observed response times and/or the usage of hardware resources become unacceptably
    high, it can be very hard to discover the root cause of the problem. For example,
    we need to be able to analyze hardware resource consumption per microservice.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果观察到的响应时间或/和硬件资源的使用变得无法接受地高，很难发现问题的根本原因。例如，我们需要能够分析每个微服务的硬件资源消耗。
- en: Solution
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: To curb this, we add a new component, a **monitor service**, to the system landscape,
    which is capable of collecting metrics about hardware resource usage for each
    microservice instance level.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了遏制这种情况，我们在系统景观中添加了一个新的组件，一个**监控服务**，它能够收集每个微服务实例级别的硬件资源使用指标。
- en: Solution requirements
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案要求
- en: 'The solution requirements are as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案要求如下：
- en: It must be able to collect metrics from all the servers that are used by the
    system landscape, which includes autoscaling servers
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须能够从系统景观中使用的所有服务器收集指标，这包括自动扩展服务器。
- en: It must be able to detect new microservice instances as they are launched on
    the available servers and start to collect metrics from them
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须能够检测在可用服务器上启动的新微服务实例，并从它们那里开始收集指标。
- en: It must be able to provide APIs and graphical tools for querying and analyzing
    the collected metrics
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须能够提供API和图形工具，用于查询和分析收集的指标。
- en: It must be possible to define alerts that are triggered when a specified metric
    exceeds a specified threshold value
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须能够定义当指定的指标超过指定的阈值时触发的警报。
- en: 'The following screenshot shows Grafana, which visualizes metrics from Prometheus,
    a monitoring tool that we will look at in *Chapter 20*, *Monitoring Microservices*:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了Grafana，它可视化Prometheus的指标，我们将在第20章“监控微服务”中了解这个监控工具：
- en: '![A screenshot of a computer  Description automatically generated](img/B19825_16.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图，描述自动生成](img/B19825_16.png)'
- en: 'Figure 1.16: Monitoring with Grafana'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.16：使用Grafana进行监控
- en: That was an extensive list! I am sure these design patterns helped you to understand
    the challenges with microservices better. Next, we will move on to learning about
    software enablers.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个详尽的列表！我相信这些设计模式帮助你更好地理解了微服务面临的挑战。接下来，我们将继续学习关于软件使能器的知识。
- en: Software enablers
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件使能器
- en: 'As we’ve already mentioned, we have a number of very good open source tools
    that can help us both meet our expectations of microservices and, most importantly,
    handle the new challenges that come with them:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，我们有一些非常好的开源工具可以帮助我们满足对微服务的期望，更重要的是，处理随之而来的新挑战：
- en: '**Spring Boot**, an application framework'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring Boot**，一个应用程序框架'
- en: '**Spring Cloud/Netflix OSS**, a mix of application framework and ready-to-use
    services'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring Cloud/Netflix OSS**，一个应用程序框架和现成服务的混合体'
- en: '**Docker**, a tool for running containers on a single server'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker**，一个在单个服务器上运行容器的工具'
- en: '**Kubernetes**, a container orchestrator that manages a cluster of servers
    that run containers'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes**，一个容器编排器，它管理着一群运行容器的服务器'
- en: '**Istio**, a service mesh implementation'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Istio**，一个服务网格实现'
- en: 'The following table maps the design patterns we will need to handle these challenges,
    along with the corresponding open source tool that will be used in this book to
    implement the design patterns:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格映射了我们将需要处理这些挑战的设计模式，以及本书中将用于实现这些设计模式的相应开源工具：
- en: '| **Design Pattern** | **Spring Boot** | **Spring Cloud** | **Kubernetes**
    | **Istio** |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| **设计模式** | **Spring Boot** | **Spring Cloud** | **Kubernetes** | **Istio**
    |'
- en: '| **Service discovery** |  | Netflix Eureka and Spring Cloud LoadBalancer |
    Kubernetes `kube-proxy` and service resources |  |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| **服务发现** |  | Netflix Eureka 和 Spring Cloud LoadBalancer | Kubernetes `kube-proxy`
    和服务资源 |  |'
- en: '| **Edge server** |  | Spring Cloud Gateway and Spring Security OAuth | Kubernetes
    Ingress controller | Istio ingress gateway |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| **边缘服务器** |  | Spring Cloud Gateway 和 Spring Security OAuth | Kubernetes
    入口控制器 | Istio 入口网关 |'
- en: '| **Reactive microservices** | Project Reactor and Spring WebFlux |  |  |  |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| **响应式微服务** | Project Reactor 和 Spring WebFlux |  |  |  |'
- en: '| **Central configuration** |  | Spring Config Server | Kubernetes `ConfigMaps`
    and Secrets |  |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| **中心配置** |  | Spring Config Server | Kubernetes `ConfigMaps` 和 Secrets |  |'
- en: '| **Centralized log analysis** |  |  | Elasticsearch, Fluentd, and Kibana.
    Note: Actually not part of Kubernetes, but can easily be deployed and configured
    together with Kubernetes |  |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| **集中日志分析** |  |  | Elasticsearch、Fluentd 和 Kibana。注意：实际上不是 Kubernetes 的组成部分，但可以轻松地与
    Kubernetes 一起部署和配置 |  |'
- en: '| **Distributed tracing** | Micrometer Tracing and Zipkin |  |  | Jaeger |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| **分布式追踪** | Micrometer 追踪和 Zipkin |  |  | Jaeger |'
- en: '| **Circuit breaker** |  | Resilience4j |  | Outlier detection |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| **断路器** |  | Resilience4j |  | 异常检测 |'
- en: '| **Control loop** |  |  | Kubernetes controller managers |  |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| **控制循环** |  |  | Kubernetes 控制管理器 |  |'
- en: '| **Centralized monitoring and alarms** |  |  |  | Kiali, Grafana, and Prometheus
    |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| **集中监控和警报** |  |  |  | Kiali、Grafana 和 Prometheus |'
- en: 'Figure 1.17: Mapping design patterns to open source tools'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.17：将设计模式映射到开源工具
- en: Please note that any of Spring Cloud, Kubernetes, or Istio can be used to implement
    some design patterns, such as service discovery, edge server, and central configuration.
    We will discuss the pros and cons of using these alternatives later in this book.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Spring Cloud、Kubernetes 或 Istio 中的任何一个都可以用来实现某些设计模式，例如服务发现、边缘服务器和中心配置。我们将在本书的后面讨论使用这些替代方案的优缺点。
- en: With the design patterns and tools that we will use in the book introduced,
    we will wrap up this chapter by going through some related areas that are also
    important, but not covered in this text.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了本书中将使用的模式和工具之后，我们将通过一些相关领域来结束本章，这些领域也很重要，但本书没有涉及。
- en: Other important considerations
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他重要考虑因素
- en: 'To be successful when it comes to implementing a microservice architecture,
    there are a number of related areas to consider as well. I will not cover these
    areas in this book; instead, I’ll just briefly mention them here as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施微服务架构时要想取得成功，还需要考虑许多相关领域。本书不会涵盖这些领域；相反，我将在以下内容中简要提及它们：
- en: '**Importance of DevOps**: One of the benefits of a microservice architecture
    is that it enables shorter delivery times and, in extreme cases, allows *continuous
    delivery* of new versions. To be able to deliver that fast, you need to establish
    an organization where dev and ops work together under the mantra *you built it,
    you run it*. This means that developers are no longer allowed to simply pass new
    versions of the software over to the operations team. Instead, the dev and ops
    organizations need to work much more closely together, organized into teams that
    have full responsibility for the end-to-end life cycle of one microservice (or
    a group of related microservices). Besides the organizational part of dev/ops,
    the teams also need to automate the delivery chain, that is, the steps for building,
    testing, packaging, and deploying the microservices to the various deployment
    environments. This is known as setting up a *delivery pipeline*.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DevOps的重要性**：微服务架构的一个好处是它能够缩短交付时间，在极端情况下，甚至允许**持续交付**新版本。为了能够快速交付，你需要建立一个遵循“你构建它，你就运行它”这一格言的组织。这意味着开发者不再被允许简单地传递软件的新版本给运维团队。相反，开发和运维组织需要更加紧密地合作，组建起对单个微服务（或一组相关微服务）端到端生命周期负责的团队。除了Dev/ops的组织部分，团队还需要自动化交付链，即构建、测试、打包和将微服务部署到各种部署环境中的步骤。这被称为建立**交付管道**。'
- en: '**Organizational aspects and Conway’s law**: Another interesting aspect of
    how a microservice architecture might affect the organization is *Conway’s law*,
    which states the following:'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组织方面和康威定律**：微服务架构可能对组织产生影响的另一个有趣方面是**康威定律**，该定律表述如下：'
- en: ”Any organization that designs a system (defined broadly) will produce a design
    whose structure is a copy of the organization’s communication structure.”
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “任何设计系统（广义上）的组织都会产生一个结构，其结构与组织的沟通结构相匹配。”
- en: ''
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: — Melvyn Conway, 1967
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —— Melvyn Conway，1967
- en: This means that the traditional approach of organizing IT teams for large applications
    based on their technology expertise (for example, UX, business logic, and database
    teams) will lead to a big three-tier application – typically, a big monolithic
    application with a separately deployable unit for the UI, one for processing the
    business logic, and one for the big database.
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着，基于技术专长（例如，用户体验、业务逻辑和数据库团队）的传统方法来组织大型IT团队，将导致一个庞大的三层应用——通常是一个庞大的单体应用，具有一个独立的UI部署单元、一个处理业务逻辑的单元和一个大型数据库的部署单元。
- en: To successfully deliver an application based on a microservice architecture,
    the organization needs to be changed into teams that work with one or a group
    of related microservices. The team must have the skills that are required for
    those microservices, for example, languages and frameworks for the business logic
    and database technologies for persisting its data.
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要成功交付基于微服务架构的应用程序，组织需要转变为与一个或一组相关微服务合作的团队。该团队必须具备执行这些微服务所需的技能，例如，业务逻辑的语言和框架以及用于持久化数据的数据库技术。
- en: '**Decomposing a monolithic application into microservices**: One of the most
    difficult decisions (and expensive if done wrong) is how to decompose a monolithic
    application into a set of cooperating microservices. If this is done in the wrong
    way, you will end up with problems such as the following:'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将单体应用分解为微服务**：最困难的决策之一（如果执行不当则代价高昂）是如何将单体应用分解为一系列协作的微服务。如果这样做的方式不正确，你最终会遇到以下问题：'
- en: '**Slow delivery**: Changes in the business requirements will affect too many
    of the microservices, resulting in extra work.'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓慢的交付**：业务需求的变化将影响太多的微服务，从而导致额外的工作。'
- en: '**Bad performance**: To be able to perform a specific business function, a
    lot of requests have to be passed between various microservices, resulting in
    long response times.'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不良性能**：为了执行特定的业务功能，需要在各种微服务之间传递大量请求，从而导致响应时间过长。'
- en: '**Inconsistent data**: Since related data is separated into different microservices,
    inconsistencies can appear over time in data that’s managed by different microservices.'
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据不一致**：由于相关数据被分离到不同的微服务中，随着时间的推移，由不同微服务管理的数据可能会出现不一致性。'
- en: 'A good approach to finding proper boundaries for microservices is to apply
    **domain-driven design** and its concept of **bounded contexts**. According to
    Eric Evans, a *bounded context* is:'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为微服务找到合适的边界的一个好方法是应用**领域驱动设计**及其**边界上下文**的概念。根据埃里克·埃文斯（Eric Evans）的说法，一个**边界上下文**是：
- en: ”A description of a boundary (typically a subsystem, or the work of a particular
    team) within which a particular model is defined and applicable.”
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “一个边界（通常是子系统或特定团队的作业）的描述，其中定义并适用特定的模型。”
- en: This means that a microservice defined by a bounded context will have a well-defined
    model of its own data.
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着由边界上下文定义的微服务将拥有其自身数据的明确模型。
- en: '**Importance of API design**: If a group of microservices exposes a common,
    externally available API, it is important that the API is easy to understand and
    adheres to the following guidelines:'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API设计的重要性**：如果一个微服务组公开了一个通用的、外部可用的API，那么这个API需要易于理解，并遵循以下指南：'
- en: If the same concept is used in multiple APIs, it should have the same description
    in terms of the naming and data types used.
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在多个API中使用相同的概念，那么在命名和数据类型方面应该有相同的描述。
- en: It is of great importance that APIs are allowed to evolve in an independent
    but controlled manner. This typically requires applying a proper versioning schema
    for the APIs, for example, [https://semver.org/](https://semver.org/). This implies
    supporting multiple major versions of an API over a specific period of time, allowing
    clients of the API to migrate to new major versions at their own pace.
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许API以独立但受控的方式演变非常重要。这通常需要为API应用适当的版本控制方案，例如，[https://semver.org/](https://semver.org/)。这意味着在特定时期内支持API的多个主要版本，允许API客户端以自己的节奏迁移到新的主要版本。
- en: '**Migration paths from on-premises to the cloud**: Many companies today run
    their workload on-premises, but are searching for ways to move parts of their
    workload to the cloud. Since most cloud providers today offer *Kubernetes as a
    Service*, an appealing migration approach can be to first move the workload into
    Kubernetes on-premises (as microservices or not) and then redeploy it on a Kubernetes
    as a Service offering provided by a preferred cloud provider.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从本地到云的迁移路径**：许多公司今天在本地运行他们的工作负载，但正在寻找将工作负载的部分迁移到云的方法。由于大多数云提供商今天都提供*Kubernetes
    as a Service*，一个吸引人的迁移方法可以是将工作负载首先迁移到本地的Kubernetes（无论是否作为微服务）上，然后重新部署到由首选云提供商提供的Kubernetes
    as a Service服务上。'
- en: '**Good design principles for microservices, the 12-factor app**: The 12-factor
    app ([https://12factor.net](https://12factor.net)) is a set of design principles
    for building software that can be deployed in the cloud. Most of these design
    principles are applicable to building microservices independently of where and
    how they will be deployed, that is, in the cloud or on-premises. Some of these
    principles will be covered in this book, such as config, processes, and logs,
    but not all.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务的良好设计原则，12因素应用**：12因素应用([https://12factor.net](https://12factor.net))是一套设计原则，用于构建可以在云中部署的软件。这些设计原则中的大多数都可以独立于部署位置和方式（即在云中或本地）构建微服务。本书将涵盖其中的一些原则，例如配置、进程和日志，但并非全部。'
- en: That’s it for the first chapter! I hope it gave you a good basic idea of microservices
    and the challenges that come with them, as well as an overview of what we will
    cover in this book.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 第一章节的内容就到这里！我希望这能给你一个关于微服务及其带来的挑战的良好基本概念，以及我们将在本书中涵盖的内容概述。
- en: Summary
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this introductory chapter, I described my own way into microservices and
    delved into a bit of their history. We defined what a microservice is – a kind
    of autonomous distributed component with some specific requirements. We also went
    through both the good and challenging aspects of microservice-based architecture.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的介绍中，我描述了自己进入微服务的方式，并简要探讨了它们的历史。我们定义了微服务是什么——一种具有特定要求的自主分布式组件。我们还探讨了基于微服务的架构的优缺点。
- en: To handle these challenges, we defined a set of design patterns and briefly
    mapped the capabilities of open source products such as Spring Boot, Spring Cloud,
    Kubernetes, and Istio to the design patterns.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这些挑战，我们定义了一套设计模式，并简要地将开源产品（如Spring Boot、Spring Cloud、Kubernetes和Istio）的功能映射到设计模式上。
- en: You’re eager to develop your first microservice now, right? In the next chapter,
    you will be introduced to Spring Boot and complementary open source tools that
    we will use to develop our first microservices.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在渴望开发你的第一个微服务，对吧？在下一章中，你将介绍 Spring Boot 和我们将使用的互补开源工具，以开发我们的第一个微服务。
- en: Join our community on Discord
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussion with the author and other
    readers:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/SpringBoot3e](https://packt.link/SpringBoot3e)'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SpringBoot3e](https://packt.link/SpringBoot3e)'
- en: '![](img/QR_Code1849216352344398875.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1849216352344398875.png)'
