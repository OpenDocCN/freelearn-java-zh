- en: Chapter 7. Error Handling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 错误处理
- en: In any integrated system, there are numerous reasons for errors to happen. Many
    are unforeseen, not easy to predict, and not easy to simulate. As an integrated
    framework, Camel provides extensive support for error handling, which is very
    flexible and able to deal with very different kinds of errors.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何集成系统中，都有许多可能导致错误发生的原因。许多是未预见的，不容易预测，也不容易模拟。作为一个集成框架，Camel提供了广泛的支持来处理错误，这非常灵活，能够处理非常不同类型的错误。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The kind of errors that we can deal with using Camel
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用Camel处理哪种类型的错误
- en: The different Camel error handlers available
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的不同Camel错误处理器
- en: The configuration of the error handlers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理器的配置
- en: Types of errors
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误类型
- en: We can distinguish two main types of errors—recoverable and irrecoverable. Let's
    have a look at these in detail.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以区分两种主要的错误类型——可恢复和不可恢复。让我们详细看看这些。
- en: Recoverable errors
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可恢复错误
- en: A recoverable error is a temporary error. It means that this error might be
    recovered *automatically* after a certain time.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 可恢复错误是一种暂时性错误。这意味着这个错误可能在一定时间后自动恢复。
- en: An example would be a network connection that is temporarily down, resulting
    in `IOException`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个暂时断开的网络连接会导致`IOException`。
- en: Basically, the exceptions are represented as recoverable errors in Camel.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Camel中，基本上，异常被表示为可恢复错误。
- en: 'In that case, Camel stores the exceptions (the recoverable errors) in the exchange
    using the `setException` (throwable cause) method:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在那种情况下，Camel使用`setException`（可抛出原因）方法在交换中存储异常（可恢复错误）：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As we will see later, an exchange containing an exception will be caught by
    an error handler, which will react accordingly.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们稍后将要看到的，包含异常的交换将被错误处理器捕获，并相应地做出反应。
- en: Irrecoverable errors
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可恢复的错误
- en: An irrecoverable error is an error that remains an error no matter how many
    times you try to perform the same action.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 不可恢复错误是指无论您尝试多少次执行相同操作，错误都依然存在的错误。
- en: An example would be trying to access a nonexistent table in a database, or accessing
    a JMS queue that does not exist.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，尝试访问数据库中不存在的表，或者访问不存在的JMS队列。
- en: 'An irrecoverable error is represented as a message with its `setFault` flag
    set to `true`. The fault message is the normal message body, as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 不可恢复错误表示为将`setFault`标志设置为`true`的消息。错误消息是正常消息体，如下所示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Programmers can set a fault message so Camel can react accordingly and stop
    routing the message.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员可以设置一个错误消息，以便Camel可以相应地做出反应并停止路由消息。
- en: The question could be, in which case do we use an exception in the exchange
    and in which case do we use the fault flag on the message?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的问题可能是，在哪种情况下我们在交换中使用异常，在哪种情况下我们在消息上使用错误标志？
- en: The first reason for the presence of the fault flag is that the Camel API was
    designed around JBI, which includes a `Fault` message concept.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误标志存在的第一个原因是Camel API是围绕JBI设计的，其中包括一个`Fault`消息概念。
- en: The second reason is that we might want to handle some errors in a different
    way. For instance, using exceptions in an exchange will use an `ErrorHandler`,
    meaning that for an `InOut` exchange the next endpoint of the route won't ever
    get an `out` message.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个原因是我们可能希望以不同的方式处理一些错误。例如，在交换中使用异常将使用`ErrorHandler`，这意味着对于`InOut`交换，路由的下一个端点永远不会收到`out`消息。
- en: Using the fault flag allows you to handle this kind of error in a specific way.
    For instance, with a CXF endpoint, it could make sense to create and return a
    SOAP fault. However, we will see that all kinds of errors can be handled by the
    Camel error handlers.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用错误标志允许您以特定方式处理这类错误。例如，对于CXF端点，创建并返回一个SOAP错误是有意义的。然而，我们将看到所有类型的错误都可以通过Camel的错误处理器来处理。
- en: Camel error handlers
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Camel错误处理器
- en: As we saw, Camel stores the exceptions in the exchange using the `setException(Throwable
    cause)` method.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Camel使用`setException(Throwable cause)`方法在交换中存储异常。
- en: Camel provides ready-to-use error handlers, depending of the mechanism that
    you have to implement. These error handlers will only react to the exceptions
    set in the exchange. By default, the error handlers won't react if an irrecoverable
    error has been set as the fault message. We will see, further in the chapter,
    that Camel provides an option to handle irrecoverable errors.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Camel 提供了现成的错误处理器，取决于您必须实现的机制。这些错误处理器只会对交换中设置的异常做出反应。默认情况下，如果设置了不可恢复的错误作为故障消息，错误处理器不会做出反应。我们将在本章的后面看到，Camel
    提供了一个处理不可恢复错误的选项。
- en: In order to react, the error handler *lives* on the route channels. Actually,
    an error handler is an interceptor (on the channel), that analyzes the exchange,
    and verifies that the exception attribute of the exchange is not null.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做出反应，错误处理器 *存在于* 路由通道上。实际上，错误处理器是一个拦截器（在通道上），它分析交换，并验证交换的异常属性是否不为空。
- en: If the exception is not null, the error handler *reacts*. This means that the
    error handler will *catch* any uncaught exception thrown during the routing or
    processing of messages within Camel.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果异常不为空，错误处理器 *做出反应*。这意味着错误处理器将 *捕获* 在 Camel 路由或处理消息过程中抛出的任何未捕获的异常。
- en: Camel provides different kinds of error handlers, depending on your need.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Camel 根据您的需求提供不同类型的错误处理器。
- en: Non-transacted error handlers
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非事务性错误处理器
- en: The non-transacted error handlers are mentioned in this section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中提到了非事务性错误处理器。
- en: DefaultErrorHandler
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DefaultErrorHandler
- en: The `DefaultErrorHandler` is the default error handler. It doesn't support dead
    letter queues it propagates back to the caller. The exchange ends immediately.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`DefaultErrorHandler` 是默认的错误处理器。它不支持死信队列，它将异常传播回调用者。交换立即结束。'
- en: It's very similar to the dead letter error handler, but the payload is lost
    (whereas the DLQ keeps the payload for processing).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 它与死信错误处理器非常相似，但有效载荷已丢失（而 DLQ 保留有效载荷以供处理）。
- en: This means that it supports redelivery policies. As we will see later, we can
    configure the error handler with some options.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着它支持重试策略。正如我们稍后将要看到的，我们可以使用一些选项来配置错误处理器。
- en: This error handler covers most use cases. It catches exceptions in the processors
    and propagates them back to the previous channel, where the error handler can
    catch it. This gives Camel the chance to react accordingly, for instance, to reroute
    the message to a different route path, try a redelivery, or give up and propagate
    the exception back to the caller.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误处理器涵盖了大多数用例。它捕获处理器中的异常并将它们传播回之前的通道，在那里错误处理器可以捕获它。这给了 Camel 机会相应地做出反应，例如，将消息重新路由到不同的路由路径，尝试重试，或者放弃并传播异常回调用者。
- en: Even if you don't explicitly specify an error handler, Camel will implicitly
    create a `DefaultErrorHandler`, without redelivery, no handle (see error handlers
    features for details about handle), and no dead letter queue (as it's not supported
    by the `DefaultErrorHandler`).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你没有明确指定错误处理器，Camel 也会隐式创建一个 `DefaultErrorHandler`，没有重试，没有处理（请参阅错误处理器功能以获取有关处理的详细信息），也没有死信队列（因为它不受
    `DefaultErrorHandler` 的支持）。
- en: To illustrate the `DefaultErrorHandler`, we create a simple Camel route that
    will expose a HTTP service (using Jetty).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明 `DefaultErrorHandler`，我们创建一个简单的 Camel 路由，该路由将公开一个 HTTP 服务（使用 Jetty）。
- en: 'First, we create the following Maven `pom.xml`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建以下 Maven `pom.xml`：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The route is pretty simple. It exposes an HTTP service using the Camel Jetty
    component and validates the submitted message using a bean.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 路由相当简单。它使用 Camel Jetty 组件公开一个 HTTP 服务，并使用一个 Bean 验证提交的消息。
- en: 'We write this route using the Blueprint DSL. We add the following `src/main/resources/OSGI-INF/blueprint/route.xml`
    file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Blueprint DSL 编写这个路由。我们添加以下 `src/main/resources/OSGI-INF/blueprint/route.xml`
    文件：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `checker bean` is pretty simple. It takes the message received on the Jetty
    endpoint and checks whether it's valid. The message is an HTTP parameter `key=value`.
    If the parameter has the format message=... it's valid, or else we throw an `IllegalArgumentException`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`checker bean` 非常简单。它接收 Jetty 端点接收到的消息并检查其是否有效。消息是一个 HTTP 参数 `key=value`。如果参数的格式为
    message=...，则有效，否则我们抛出 `IllegalArgumentException`。'
- en: 'Here''s the `checker` code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `checker` 代码：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can build our bundle using the following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码构建我们的包：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We now start our Apache Karaf container and install the `camel-blueprint` and
    `camel-jetty` features:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在启动 Apache Karaf 容器并安装 `camel-blueprint` 和 `camel-jetty` 功能：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can now install our bundle:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以安装我们的包：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can submit a valid message using curl:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 curl 提交一个有效的消息：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we submit an invalid message:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们提交一个无效的消息：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the Karaf `log` file (`data/karaf.log`), we can see:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Karaf 的 `log` 文件（`data/karaf.log`）中，我们可以看到：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So we can see that the `DefaultErrorHandler` reacted for the `IllegalArgumentException`.
    The delivery failed and has been logged. By default (as handled is false), the
    exception is thrown back to the caller.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到 `DefaultErrorHandler` 对 `IllegalArgumentException` 做出了反应。投递失败并已被记录。默认情况下（因为处理为
    false），异常会被抛回给调用者。
- en: DeadLetterChannel
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DeadLetterChannel
- en: The `DeadLetterChannel` error handler implements the Dead Letter Channel EIP.
    It supports the redelivery policy, and the redelivery sends the message to a dead
    letter endpoint.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeadLetterChannel` 错误处理器实现了死信通道 EIP。它支持重试策略，重试会将消息发送到死信端点。'
- en: Even then, the dead letter endpoint, the `DeadLetterChannel` behaves like the
    `DefaultErrorHandler`. To illustrate this, we update our previous example to use
    a `DeadLetterChannel` that calls an error route when an exception occurs.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 即使如此，死信端点 `DeadLetterChannel` 的行为类似于 `DefaultErrorHandler`。为了说明这一点，我们更新之前的示例，使用一个在发生异常时调用错误路由的
    `DeadLetterChannel`。
- en: So the `DeadLetterChannel` error handler will catch the exception, try to redeliver,
    and if it still fails the message will be sent to a dedicated route.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`DeadLetterChannel` 错误处理器将捕获异常，尝试重试，如果仍然失败，消息将被发送到在死信 URI 中定义的专用路由。
- en: 'The `checker` bean is exactly the same as before. The route definition (using
    the Blueprint DSL) is different as we define the `DeadLetterChannel` error handler:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`checker` 实例与之前完全相同。路由定义（使用 Blueprint DSL）不同，因为我们定义了 `DeadLetterChannel` 错误处理器：'
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can see that we use the `myDeadLetterErrorHandler` in the `main` route. The
    `myDeadLetterErrorHandler` is constructed using the `DeadLetterChannelBuilder`
    builder.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们在 `main` 路由中使用了 `myDeadLetterErrorHandler`。`myDeadLetterErrorHandler`
    是使用 `DeadLetterChannelBuilder` 构造函数构建的。
- en: 'The following attributes are set:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下属性被设置：
- en: The `deadLetterUri` containing the endpoint is set where we send the message
    if the delivery fails. Here, we define the endpoint `direct:error` to call the
    corresponding route.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含端点的 `deadLetterUri` 被设置为在投递失败时发送消息的位置。在这里，我们定义端点 `direct:error` 以调用相应的路由。
- en: The `redeliveryPolicy` is set to define the way we try to redeliver the message.
    The `myRedeliveryPolicy` defines the number of attempts (3 in the example), and
    the delay between each attempt (5 seconds here). It means that after 3 attempts
    (so, a maximum of 15 seconds), if the message still fails it will be sent to the
    endpoint defined in the dead letter URI (so `direct:error`, in our case).
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redeliveryPolicy` 被设置为定义我们尝试重试消息的方式。`myRedeliveryPolicy` 定义了尝试次数（示例中的 3 次），以及每次尝试之间的延迟（这里为
    5 秒）。这意味着在 3 次尝试（因此，最多 15 秒）之后，如果消息仍然失败，它将被发送到在死信 URI 中定义的端点（在我们的例子中是 `direct:error`）。'
- en: The `error` route just logs the failed message. It means that the `main` route
    won't fail, it will just return the `in` message to the caller.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`error` 路由仅记录失败的消息。这意味着 `main` 路由不会失败，它只会将 `in` 消息返回给调用者。'
- en: 'We build our new bundle using the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下代码构建我们的新包：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We start our Apache Karaf:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动我们的 Apache Karaf：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As previously done, we install the `camel-blueprint` and `camel-jetty` features:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如之前所做，我们安装了 `camel-blueprint` 和 `camel-jetty` 功能：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can deploy our bundle:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以部署我们的包：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'First, we send a valid message using curl:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 curl 发送一个有效的消息：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It works as before, nothing has changed.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 它与之前一样工作，没有任何变化。
- en: 'Now, we send an invalid message:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们发送一个无效的消息：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can note that curl is waiting for a response; it''s normal as we defined
    a redelivery policy in our dead letter error handler. Finally, we receive the
    original in message:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以注意到 curl 正在等待响应；这是正常的，因为我们已经在死信错误处理器中定义了重试策略。最后，我们收到了原始的 `in` 消息：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we take a look in the Karaf `log` file, we can see the following code corresponding
    to the `error` route execution:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 Karaf 的 `log` 文件，我们可以看到与 `error` 路由执行相对应的以下代码：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: LoggingErrorHandler
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LoggingErrorHandler
- en: The `LoggingErrorHandler` logs the failed message along with the exception.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoggingErrorHandler` 将失败的消息以及异常记录下来。'
- en: 'Camel will, by default, log the failed message and the exception using the
    log name `LoggingErrorHandler` at `ERROR` level. To illustrate the behavior of
    the `LoggingErrorHandler`, we update the previous route `blueprint` XML like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Camel 将默认使用 `LoggingErrorHandler` 日志名称在 `ERROR` 级别记录失败的消息和异常。为了说明 `LoggingErrorHandler`
    的行为，我们更新之前的路由 `blueprint` XML 如下：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We define a `LoggingErrorHandler` in the `main` route. This error handler will
    just intercept and log the exception in the `packt` logger, with `ERROR` as the
    log level. The exchange ends, and the exception is sent back to the caller.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`main`路由中定义了一个`LoggingErrorHandler`。这个错误处理器将只是拦截并记录异常在`packt`记录器中，日志级别为`ERROR`。交换结束，异常返回给调用者。
- en: 'After deploying our bundle in Apache Karaf, and submitting an invalid message,
    we can see that the client (curl) gets the following exception:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在Apache Karaf中部署我们的bundle后，提交一个无效的消息，我们可以看到客户端（curl）得到以下异常：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The exception is logged in the Karaf `log` file:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 异常被记录在Karaf的`log`文件中：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: NoErrorHandler
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NoErrorHandler
- en: The `NoErrorHandler` completely disables error handling; this means that any
    exception is not intercepted and is just returned to the caller.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`NoErrorHandler`完全禁用了错误处理；这意味着任何异常都不会被拦截，只是返回给调用者。'
- en: 'For instance, if we update the Blueprint XML of our sample like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们像这样更新我们的示例的Blueprint XML：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If we submit an invalid message, the exchange doesn't end, we don't have anything
    in the log, and the exception is just returned to the caller.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们提交一个无效的消息，交换不会结束，我们没有日志记录任何内容，异常只是返回给调用者。
- en: TransactedErrorHandler
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TransactedErrorHandler
- en: The `TransactedErrorHandler` is used when a route is *flagged* with transacted.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当路由被标记为事务时，使用`TransactedErrorHandler`。
- en: It's basically the same as the `DefaultErrorHandler` (it's actually inherited
    from the `DefaultErrorHandler`). The difference is that the `TransactedErrorHandler`
    will look for a transaction manager.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 它基本上与`DefaultErrorHandler`相同（它实际上是从`DefaultErrorHandler`继承的）。区别在于`TransactedErrorHandler`将寻找一个事务管理器。
- en: 'It uses the following mechanism to find it:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用以下机制来找到它：
- en: If one (and only one) bean in the registry has the `org.apache.camel.spi.TransactedPolicy`
    type, it uses it
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果注册表中的只有一个bean具有`org.apache.camel.spi.TransactedPolicy`类型，它将使用它
- en: If a bean in the registry has the `ID PROPAGATION_REQUIRED` and the `org.apache.camel.spi.TransactedPolicy`
    type, it uses it
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果注册表中的bean具有`ID PROPAGATION_REQUIRED`和`org.apache.camel.spi.TransactedPolicy`类型，它将使用它
- en: If one (and only one) bean in the registry has `org.springframework.transaction.PlatformTransactionManager`,
    it uses it
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果注册表中只有一个bean具有`org.springframework.transaction.PlatformTransactionManager`，它将使用它
- en: You can also *force* the transaction manager that you want to use, as the transacted
    notation accepts a bean ID.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以*强制*使用您想要的交易管理器，因为事务表示法接受bean ID。
- en: Error handlers scopes
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理器作用域
- en: 'An error handler can be defined:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 可以定义一个错误处理器：
- en: At the Camel Context level (Camel Context scope), which means that all routes
    in this Camel Context will use this error handler.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Camel上下文级别（Camel上下文作用域），这意味着在这个Camel上下文中的所有路由都将使用这个错误处理器。
- en: At the route level (route scope), possibly overwritten the error handler defined
    using the Camel Context scope.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在路由级别（路由作用域），可能覆盖了使用Camel上下文作用域定义的错误处理器。
- en: Thanks to the scope, it's possible to define a default error handler (Camel
    Context scope), and, possibly define an error handler specific to one particular
    route.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了作用域，可以定义一个默认错误处理器（Camel上下文作用域），并且可能定义一个特定于特定路由的错误处理器。
- en: For instance, the following Blueprint XML contains two routes with two different
    error handlers—one with the Camel Context scope and another with `route` scope.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下Blueprint XML包含两个路由和两个不同的错误处理器——一个具有Camel上下文作用域，另一个具有`route`作用域。
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Error handler features
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理器功能
- en: Basically, all error handlers extend the `DefaultErrorHandler`. The `DefaultErrorHandler`
    provides a set of interesting features allowing you to use very fine-grained management
    of the exceptions.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，所有错误处理器都扩展了`DefaultErrorHandler`。`DefaultErrorHandler`提供了一套有趣的功能，允许您使用非常细粒度的异常管理。
- en: Redelivery
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重发
- en: The `DefaultErrorHandler` (and so the `DeadLetterErrorHandler` and `TransactedErrorHandler`)
    supports a redelivery mechanism that you can configure via a redelivery policy.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`DefaultErrorHandler`（以及`DeadLetterErrorHandler`和`TransactedErrorHandler`）支持一个可以通过重发策略配置的重发机制。'
- en: For instance, the following Blueprint XML creates a Camel route that systematically
    throws an `IllegalArgumentException` (with `Booooommmmm` message). As we don't
    explicitly define an error handler, the route uses the `DefaultErrorHandler`.
    We just configure the redelivery policy of the `DefaultErrorHandler`, trying to
    redeliver the message three times, waiting two seconds between each attempt. If
    it still fails at the fourth attempt, the exchange ends and the exception is sent
    to the caller.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下Blueprint XML创建了一个Camel路由，该路由会系统地抛出`IllegalArgumentException`异常（带有`Booooommmmm`消息）。由于我们没有显式定义错误处理器，该路由使用`DefaultErrorHandler`。我们只配置了`DefaultErrorHandler`的重试策略，尝试重发消息三次，每次尝试之间等待两秒钟。如果第四次尝试仍然失败，交换结束，异常发送给调用者。
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We start our Apache Karaf container and install the `camel-blueprint` and `camel-jetty`
    features:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动Apache Karaf容器并安装`camel-blueprint`和`camel-jetty`功能：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We just drop our `route.xml` in the Karaf `deploy` folder, and we call the
    service using curl:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需将`route.xml`放入Karaf的`deploy`文件夹中，然后使用curl调用服务：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After some time, we can see the exception (`IllegalArgumentException` with
    `Booooommmmm` message) returned to the client:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一段时间后，我们可以看到异常（带有`Booooommmmm`消息的`IllegalArgumentException`）返回给客户端：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the Karaf `log` file, we can see the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在Karaf的`log`文件中，我们可以看到以下代码：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We can see that the redelivery policy has been used and the exchange fails at
    the fourth attempt (which is exhausted after delivery attempt number four).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到已经使用了重试策略，并且在第四次尝试时交换失败（在第四次尝试后耗尽）。
- en: Exception policy
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常策略
- en: The `DefaultErrorHandler` (and so `DeadLetterChannel` and `TransactedErrorHandler`)
    supports the exception policy. The exception policies are used to intercept and
    handle specific exceptions in particular ways.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`DefaultErrorHandler`（以及`DeadLetterChannel`和`TransactedErrorHandler`）支持异常策略。异常策略用于以特定方式拦截和处理特定的异常。'
- en: The exception policies are specified with the `onException` syntax. Camel will
    traverse the exception hierarchy from the bottom up to the root searching for
    an `onException` that matches the actual exception.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 异常策略使用`onException`语法指定。Camel将从底部向上遍历异常层次结构，寻找与实际异常匹配的`onException`。
- en: 'You can use `onException` with error handler defined at `CamelContext` scope
    or route scope. For instance, in the following `route.xml`, we have two different
    routes:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`CamelContext`作用域或路由作用域中定义错误处理器后使用`onException`。例如，在以下`route.xml`中，我们有两个不同的路由：
- en: The first route throws an `IllegalArgumentException` (`Boooommmm`)
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个路由抛出`IllegalArgumentException`异常（`Boooommmm`）
- en: The second route throws an `IllegalStateException` (`Kabooommmm`)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个路由抛出`IllegalStateException`异常（`Kabooommmm`）
- en: 'We want to react differently for the two exceptions:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望对这两个异常有不同的反应：
- en: For the `IllegalArgumentException`, we want to define a specific redelivery
    policy
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`IllegalArgumentException`，我们希望定义一个特定的重试策略
- en: For the `IllegalStateException`, we want to redirect the message to a specific
    endpoint
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`IllegalStateException`，我们希望将消息重定向到特定的端点
- en: For both exceptions, the exchange ends and the exception is sent back to the
    caller.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两个异常，交换结束，异常被发送回调用者。
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We start the Apache Karaf container and install the `camel-blueprint` and `camel-jetty`
    features:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动Apache Karaf容器并安装`camel-blueprint`和`camel-jetty`功能：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We drop the `route.xml` in the Karaf `deploy` folder.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`route.xml`放入Karaf的`deploy`文件夹中。
- en: 'Now, if you access the HTTP endpoint corresponding to the first route, the
    `IllegalArgumentException` is thrown:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你访问第一个路由对应的HTTP端点，会抛出`IllegalArgumentException`异常：
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the Karaf `log` file, we can see the following code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在Karaf的`log`文件中，我们可以看到以下代码：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you access the HTTP endpoint corresponding to the second route, the `IllegalStateException`
    is thrown:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你访问第二个路由对应的HTTP端点，会抛出`IllegalStateException`异常：
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the Karaf `log` file, we can see the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在Karaf的`log`文件中，我们可以看到以下代码：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We can see the `onException` used there, redirecting the exchange to the `error`
    route.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到那里使用了`onException`，将交换重定向到`error`路由。
- en: Handling and ignoring exceptions
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理和忽略异常
- en: When handling an exception, Camel breaks out of route execution.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理异常时，Camel会跳出路由执行。
- en: With a `handled` flag the exception is not sent back to the caller, and you
    can define an `error` message.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置`handled`标志时，异常不会被发送回调用者，并且你可以定义一个`error`消息。
- en: 'For instance, with the following `route.xml`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是一个`route.xml`文件：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The handled flag on the `onException` prevents to send back the exception to
    the caller. In that case, we define an error message using a constant string.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`onException` 上的处理标志防止将异常发送回调用者。在这种情况下，我们使用一个常量字符串定义一个错误消息。'
- en: 'We start Apache Karaf and install the `camel-blueprint` and `camel-jetty` features:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动 Apache Karaf 并安装 `camel-blueprint` 和 `camel-jetty` 功能：
- en: '[PRE37]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We drop the `route.xml` in the Karaf `deploy` folder. If we access the HTTP
    endpoint, we have:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `route.xml` 放在 Karaf 的 `deploy` 文件夹中。如果我们访问 HTTP 端点，我们会得到：
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'On the other hand, it''s possible to completely ignore an exception using the
    `continued` flag. For instance, with the following `route.xml`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，可以使用 `continued` 标志完全忽略异常。例如，以下 `route.xml`：
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We ignore the `IllegalArgumentException` thrown by the route. It means that
    if we access the HTTP endpoint with curl, we just have a response:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们忽略路由抛出的 `IllegalArgumentException`。这意味着如果我们使用 curl 访问 HTTP 端点，我们只会得到一个响应：
- en: '[PRE40]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This means that the `IllegalArgumentException` has been ignored, thanks to the
    `continued` flag.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着由于 `continued` 标志，`IllegalArgumentException` 被忽略了。
- en: A failover solution
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 备用解决方案
- en: The `DefaultErrorHandler` (and so the `DeadLetterChannel` and `TransactedErrorHandler`)
    supports routing of the failed exchange to a specific endpoint. Thanks to this
    mechanism we can implement a kind of failover solution, or route that could undo
    previous changes.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`DefaultErrorHandler`（以及 `DeadLetterChannel` 和 `TransactedErrorHandler`）支持将失败的交换路由到特定的端点。多亏了这个机制，我们可以实现一种备用解决方案，或者路由，可以撤销之前的变化。'
- en: 'The following `route.xml` implements such a failover:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `route.xml` 实现了这样的备用方案：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We try to upload local files to an FTP server. If in the FTP server, an `IOException`
    is thrown, we react to the `IOException` (meaning that something is wrong with
    the FTP server), trying to redeliver three times on the same FTP server. Finally,
    we redirect to a fallback (another) FTP server.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试将本地文件上传到 FTP 服务器。如果在 FTP 服务器中抛出 `IOException`，我们会响应 `IOException`（意味着 FTP
    服务器有问题），尝试在同一个 FTP 服务器上重新投递三次。最后，我们重定向到一个备用（另一个）FTP 服务器。
- en: onWhen
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: onWhen
- en: 'If `onException` allows you to filter the exceptions and react depending on
    the exception, it''s also possible to add another condition to react to one particular
    exception. It''s what you can do with the `onWhen` syntax, accepting a predicate.
    You have an even more fine-grained way to filter exceptions, as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `onException` 允许你根据异常过滤异常并做出相应反应，也可以添加另一个条件来响应特定的异常。这就是你可以使用 `onWhen` 语法，接受一个谓词来做到的。你有一个更细粒度的方法来过滤异常，如下所示：
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: onRedeliver
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: onRedeliver
- en: 'The `onRedeliver` syntax allows you to execute some code before the message
    is redelivered. For instance, you can call a processor for redelivery, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`onRedeliver` 语法允许你在消息重新投递之前执行一些代码。例如，你可以调用一个用于重新投递的处理程序，如下所示：'
- en: '[PRE43]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: retryWhile
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: retryWhile
- en: Instead of defining a static number of redeliveries, you can use the `retryWhile`
    syntax. It allows you, at runtime, to determine whether or not to continue redelivery
    or to give up.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 与定义静态的重新投递次数不同，你可以使用 `retryWhile` 语法。它允许你在运行时确定是否继续重新投递或放弃。
- en: It allows you to have fine-grained redelivery control.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许你拥有细粒度的重新投递控制。
- en: Try, Catch, and Finally
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试、捕获和最终
- en: Until now, we have used error handlers (most of the time the `DefaultErrorHandler`),
    which applies to all channels in the routes. You might want to *square* the exception
    handling to some part of a route.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用了错误处理器（大多数情况下是 `DefaultErrorHandler`），它适用于路由中的所有通道。你可能希望将异常处理“平方”到路由的某个部分。
- en: It's similar to the `try/catch/finally` Java statements.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 它类似于 Java 中的 `try/catch/finally` 语句。
- en: '[PRE44]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Camel error handling is disabled. When using `doTry` .. `doCatch` .. `doFinally`,
    the regular Camel error handler does not apply. This means any `onException` or
    the likes does not trigger. The reason is that `doTry` .. `doCatch` .. `doFinally`
    is in fact its own error handler and it aims to mimic and work like `try/catch/finally`
    works in Java.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Camel 错误处理被禁用。当使用 `doTry` .. `doCatch` .. `doFinally` 时，常规 Camel 错误处理器不适用。这意味着任何
    `onException` 或类似操作都不会触发。原因是 `doTry` .. `doCatch` .. `doFinally` 实际上是一个自己的错误处理器，它的目的是模仿并像
    Java 中的 `try/catch/finally` 一样工作。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Generally speaking, error handling is hard. That's why Camel provides a large
    panel of features around error handling. Even if you can use the `doTry/doCatch/doFinally`
    syntax, most of the time it's better to separate the routing logic from the error
    handling itself.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，错误处理是困难的。这就是为什么Camel提供了大量关于错误处理的特性。即使你可以使用`doTry/doCatch/doFinally`语法，大多数时候将路由逻辑本身与错误处理分离会更好。
- en: When possible, good practice is to try to recover. It's always a good idea to
    use strategies for recovery. It's strongly recommended to build unit tests to
    simulate errors. It's what we will see in the next chapter—testing with Camel.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当可能时，尝试恢复是良好的实践。使用恢复策略总是一个好主意。强烈建议构建单元测试来模拟错误。这就是我们在下一章将要看到的内容——使用Camel进行测试。
