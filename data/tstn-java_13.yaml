- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Desktop Graphical User Interface Coding with Swing and JavaFX
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Swing 和 JavaFX 进行桌面图形用户界面编码
- en: This chapter will introduce a simple but complete application for providing
    three common financial calculations. These are loan payments, the future value
    of money, and a savings goal. We will look at two versions of this application,
    one written using the Swing library and the second using the JavaFX library. The
    server-side coding for this application will be covered in [*Chapter 15*](B19088_15.xhtml#_idTextAnchor301),
    *Jakarta* *Faces Application*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍一个简单但完整的应用程序，用于提供三种常见的财务计算。这些是贷款还款、货币的未来价值和储蓄目标。我们将查看这个应用程序的两个版本，一个使用 Swing
    库编写，另一个使用 JavaFX 库编写。该应用程序的服务器端编码将在 [*第 15 章*](B19088_15.xhtml#_idTextAnchor301)，*Jakarta
    Faces 应用程序* 中介绍。
- en: 'We will cover the following in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下内容：
- en: A brief history of Java GUIs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java GUIs 的简要历史
- en: A financial calculator program design
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 财务计算器程序设计
- en: Using the Swing GUI framework
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Swing GUI 框架
- en: Using the JavaFX GUI framework
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JavaFX GUI 框架
- en: Which should I use?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我应该使用哪个？
- en: By the end of this chapter, you will understand the basics of GUI coding using
    the two most widely used frameworks.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解使用两个最广泛使用的框架进行 GUI 编码的基础知识。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Here are the tools required to run the examples in this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是运行本章示例所需的工具：
- en: Java 17
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 17
- en: A text editor
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本编辑器
- en: Maven 3.8.6 or a newer version installed
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Maven 3.8.6 或更高版本
- en: The sample code for this chapter is available at [https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter13](https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter13).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可在 [https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter13](https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter13)
    找到。
- en: A brief history of Java GUIs
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java GUIs 的简要历史
- en: The first user interfaces in personal computers mimicked the terminals of mainframes
    or minicomputers. Apple introduced the Mac in 1984 and Microsoft introduced Windows
    a year later. Yet, most personal computers sold in the 1980s had terminal interfaces.
    What changed everything was the general availability of the internet and the creation
    of the technology behind the World Wide Web by Tim Berners-Lee, starting in 1989\.
    By the end of the 20th century, we expected the computers we used to have a GUI.
    In [*Chapter 15*](B19088_15.xhtml#_idTextAnchor301), *Jakarta Faces Application*,
    we will look at web programming in Java, while in this chapter, we will look at
    desktop GUI programming.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最初的个人计算机用户界面模仿了大型机或小型机的终端。苹果公司在 1984 年推出了 Mac，微软公司在一年后推出了 Windows。然而，20 世纪 80
    年代销售的多数个人计算机都配备了终端界面。改变一切的是互联网的普及和蒂姆·伯纳斯-李（Tim Berners-Lee）从 1989 年开始创建的万维网技术。到
    20 世纪末，我们期望使用的计算机拥有图形用户界面。在 [*第 15 章*](B19088_15.xhtml#_idTextAnchor301)，*Jakarta
    Faces 应用程序* 中，我们将探讨 Java 的网络编程，而本章我们将探讨桌面 GUI 编程。
- en: When Java was introduced in 1995, its original purpose was the creation of applets,
    small programs that run from web pages inside a web browser. These pages delivered
    compiled applets that ran in the JVM rather than in the browser. JavaScript, also
    developed around the same time, ran inside the browser. This led to the first
    GUI library, which is still included in Java today, called the **Abstract Window
    Toolkit** (**AWT**), still usable for desktop apps. Applets are no more, having
    been deprecated.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Java 在 1995 年推出时，其原始目的是创建小程序（applets），这些小程序可以在网络浏览器内部从网页中运行。这些页面提供了在 JVM 中运行而不是在浏览器中运行的编译小程序。同时开发的
    JavaScript 在浏览器内部运行。这导致了第一个 GUI 库，今天仍然包含在 Java 中，称为 **抽象窗口工具包**（**AWT**），仍然可用于桌面应用程序。小程序不再存在，因为它们已被弃用。
- en: The AWT depends on the underlying operating system for rendering a GUI. An AWT
    program running on an Apple Mac had a look and feel like a native Mac app. If
    you ran the same code on a Windows PC, its look and feel were like a native Windows
    app. As Java became popular in the application rather than web space, an enhanced
    GUI library, Swing – first introduced in 1996 – gained traction. Unlike AWT, Swing
    could render its own controls. Now, it was possible to develop a user interface
    that looked nearly identical on Windows, Mac, and Linux. In the *Further reading*
    list is a link to a Swing look-and-feel library called **Napkin**. It is an extreme
    example of how you could style Swing applications. Swing remains in wide use today.
    It is a standard library, included with all distributions of Java. It is maintained
    with bug fixes and minor enhancements.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: AWT依赖于底层操作系统来渲染GUI。在苹果Mac上运行的AWT程序看起来和感觉就像一个原生Mac应用程序。如果你在Windows PC上运行相同的代码，它的外观和感觉就像一个原生Windows应用程序。随着Java在应用空间而不是网络空间中的普及，一个增强的GUI库Swing
    – 首次在1996年推出 – 获得了发展。与AWT不同，Swing可以渲染自己的控件。现在，可以开发出在Windows、Mac和Linux上看起来几乎相同的用户界面。在*进一步阅读*列表中有一个链接到名为**Napkin**的Swing外观和感觉库。这是一个极端的例子，说明了你可以如何设计Swing应用程序。Swing至今仍在广泛使用。它是一个标准库，包含在所有Java发行版中。它通过错误修复和微小增强进行维护。
- en: In 2008, JavaFX 1.0, an alternative to Swing, was introduced. The version we
    will be looking at began as JavaFX 2.0 in 2011\. The original purpose of JavaFX
    was to have a common platform for GUI apps on the desktop, the web, and mobile
    devices. Like Swing, it took care of its own rendering. It also introduced a declarative
    approach to defining a user interface, based on the XML language FXML. In this
    chapter, we will look at the imperative or coding approach to defining an interface.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 2008年，JavaFX 1.0，Swing的替代品，被引入。我们将要查看的版本始于2011年的JavaFX 2.0。JavaFX的原始目的是为桌面、网页和移动设备上的GUI应用程序提供一个通用平台。像Swing一样，它负责自己的渲染。它还引入了一种基于XML语言FXML的声明性方法来定义用户界面。在本章中，我们将探讨定义界面的命令式或编码方法。
- en: Now, let us look at the application we will construct.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们将要构建的应用程序。
- en: Financial calculator program design
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 财务计算器程序设计
- en: In the previous chapter, we took the loan calculation that used doubles and
    changed it to use `BigDecimal`. We will continue to use this calculation plus
    two additional ones. One is a savings goal, whereby you indicate how much you
    wish to save, what the expected interest rate will be, and the number of months
    in which you wish to reach your goal. The second is the future value, whereby
    you can determine the amount of money you will have after saving the same amount
    for a specific number of months at an expected interest rate.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们将使用双精度浮点数的贷款计算改为使用 `BigDecimal`。我们将继续使用这个计算以及另外两个。一个是储蓄目标，其中你指明你希望储蓄的金额、预期的利率以及你希望达到目标的月份数。第二个是未来价值，其中你可以确定在特定月份数和预期利率下储蓄相同金额后你将拥有的金额。
- en: We will use the same data class and business class from the previous chapter.
    To the business class, we will add the two new calculations. We will not go over
    the new calculations in this chapter, as you can see them in the chapter’s source
    code. For now, we will consider the GUI.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用上一章中的相同的数据类和业务类。我们将向业务类添加两个新的计算。我们不会在本章中详细介绍新的计算，因为你可以从章节的源代码中看到它们。现在，我们将考虑GUI。
- en: 'The application will present the user with three choices for the calculation.
    We want a single form into which we can enter the three values each calculation
    requires and where the result will appear. Finally, we want a button to signal
    that the calculation can be carried out. I usually work out the actual design
    on paper or a whiteboard, such as this figure:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将向用户提供三种计算选择。我们希望有一个单一表单，我们可以输入每个计算所需的三个值，并且结果将显示在那里。最后，我们希望有一个按钮来表示可以进行计算。我通常在纸上或白板上实际设计设计，例如这个图：
- en: "![Figure 13.1 – A \uFEFF\uFEFFhand-drawn design](img/B19088_13_01.jpg)"
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1 – 手绘设计](img/B19088_13_01.jpg)'
- en: Figure 13.1 – A hand-drawn design
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – 手绘设计
- en: 'When we finish, it will look like this when doing a calculation:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成时，进行计算时它将看起来像这样：
- en: '![Figure 13.2 – The Swing version](img/B19088_13_02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.2 – Swing 版本](img/B19088_13_02.jpg)'
- en: Figure 13.2 – The Swing version
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 – Swing 版本
- en: The choice of calculation is determined by a group of three radio buttons. These
    are controls that are either selected or not, and you can only select one. When
    the user selects a calculation, the description of the title that follows the
    radio buttons will change, all fields will become zero, the first input field
    description will change, and pressing the **Calculate** button will use the calculation
    that matches the radio button selected.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 计算的选择由一组三个单选按钮决定。这些是可选择或不可选的控件，并且只能选择一个。当用户选择一个计算时，跟随单选按钮的标题描述将会改变，所有字段都将变为零，第一个输入字段描述将改变，并且按下**计算**按钮将使用与所选单选按钮匹配的计算。
- en: '![Figure 13.3 – The future value and savings goal screens](img/B19088_13_03.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图13.3 – 未来价值和储蓄目标屏幕](img/B19088_13_03.jpg)'
- en: Figure 13.3 – The future value and savings goal screens
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 – 未来价值和储蓄目标屏幕
- en: As you already know, users cannot always be trusted to enter valid information.
    There is always a user who will enter `Bob` for a loan amount. We could throw
    up message boxes informing the user of their error. In certain situations, this
    does make sense. In this user interface, we can recognize that the only allowable
    input in the first three fields must be a number and only allow a single decimal
    point. You just cannot enter `Bob`. A field that is blank will be changed to contain
    a zero. The last field is not editable, as it displays the result.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所知，用户并不总是可以信赖输入有效信息。总会有用户会将借款金额输入为`Bob`。我们可以弹出消息框通知用户他们的错误。在某些情况下，这确实是有意义的。在这个用户界面中，我们可以识别出前三个字段中唯一允许的输入必须是数字，并且只允许一个十进制点。您不能输入`Bob`。空白字段将被更改为包含零。最后一个字段不可编辑，因为它显示结果。
- en: Internationalization – i18n
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 国际化 – i18n
- en: 'One last element of the design is internationalization, commonly referred to
    as i18n. This means that this program can present itself in multiple languages.
    I live in Canada, where we have two official languages – English and French. This
    means that anything that has written text in the interface must have a version
    in each language. Here it is in French:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 设计的最后一个元素是国际化，通常称为i18n。这意味着这个程序可以用多种语言展示。我住在加拿大，那里有两种官方语言 – 英语和法语。这意味着界面中所有带有文本的内容都必须有每种语言的版本。以下是法语版本：
- en: '![Figure 13.4 – The French version](img/B19088_13_04.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图13.4 – 法语版本](img/B19088_13_04.jpg)'
- en: Figure 13.4 – The French version
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4 – 法语版本
- en: 'We accomplish i18n by placing all text that will appear in the GUI into a properties
    file, one for each language you plan to support. Here is the English properties
    file:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将所有将出现在GUI中的文本放入一个属性文件来实现国际化，每个语言一个。以下是英文属性文件：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can see the French version in the project. These properties files are commonly
    called `ResourceBundle`, you must first load the properties file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在项目中看到法语版本。这些属性文件通常称为`ResourceBundle`，您必须首先加载属性文件。
- en: 'Use the default `Locale`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认的`Locale`：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Set `Locale` in the code, which can be quite useful for testing:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中设置`Locale`，这在测试中非常有用：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Internationalization works the same in JavaFX. Let us look at how this application
    is coded in Swing.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 国际化在JavaFX中工作方式相同。让我们看看这个应用程序是如何用Swing编写的。
- en: Using the Swing GUI framework
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Swing GUI框架
- en: 'With the GUI library chosen, we can now decide what classes this application
    will need and how they will be packaged. Here is the finished project layout:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 选择好GUI库后，我们现在可以决定这个应用程序需要哪些类以及它们如何打包。以下是完成的项目布局：
- en: '![Figure 13.5 – The Swing project layout](img/B19088_13_05.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图13.5 – Swing项目布局](img/B19088_13_05.jpg)'
- en: Figure 13.5 – The Swing project layout
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5 – Swing项目布局
- en: The source code on GitHub is extremely commented, and I encourage you to download
    it while reading this. Let us begin by looking at the basic components and controls
    of a Swing application. We begin with `JFrame`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub上的源代码注释非常详细，我鼓励您在阅读时下载它。让我们首先看看Swing应用程序的基本组件和控制。我们从`JFrame`开始。
- en: JFrame
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JFrame
- en: Every Swing application needs a main or top-level container. There are four
    classes for this purpose, but one is now deprecated for removal. They are `JFrame`,
    `JDialog`, `JWindow`, and the deprecated `JApplet`. The `JWindow` class is ideal
    for splash screens, as they have no decorations, such as a border, title bar,
    or window controls. You commonly use `JDialog` as part of an application to interact
    with a user over details you do not want in the top-level container you are using.
    It can also be used for simple applications that require minimal interaction with
    the user and so can also be used as a top-level container. `JApplet` brought Swing
    to the web browser, but it is now headed to the dustbin of history. Let us talk
    about `JFrame`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Swing应用程序都需要一个主或顶级容器。为此目的有四个类，但现在其中一个已被弃用并计划删除。它们是`JFrame`、`JDialog`、`JWindow`和已弃用的`JApplet`。`JWindow`类非常适合启动画面，因为它们没有装饰，如边框、标题栏或窗口控件。你通常将`JDialog`用作应用程序的一部分，以与用户交互，处理你不想在使用的顶级容器中的详细信息。它也可以用于需要与用户进行最少交互的简单应用程序，因此也可以用作顶级容器。`JApplet`将Swing带到了网页浏览器，但现在它正走向历史的垃圾堆。让我们来谈谈`JFrame`。
- en: The `JFrame` class is a decorated container, meaning it has a border and title
    bar. It supports `JMenuBar` should you want a menu. It can be resizable or a fixed
    size. Into `JFrame` goes all other components and controls. In my sample code,
    I have used inheritance to extend `JFrame` in the `FinanceCalculatorMain` class.
    This simplifies the coding.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`JFrame`类是一个装饰容器，这意味着它有一个边框和标题栏。如果你想要一个菜单，它支持`JMenuBar`。它可以调整大小或固定大小。所有其他组件和控制都放入`JFrame`中。在我的示例代码中，我使用了继承在`FinanceCalculatorMain`类中扩展`JFrame`，这简化了编码。'
- en: 'Here is the code that sets up the frame. You will see an additional step in
    the *JPanel* section:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是设置框架的代码。你将在*JPanel*部分看到一个额外的步骤：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: JPanel
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JPanel
- en: The `JPanel` class is a container for other components and controls. While the
    `JFrame` class already has the `JPanel` class, which is commonly referred to as
    the content pane, we rarely use it for anything more than adding a user-designed
    `JPanel`. This is exactly what my sample does. There is a second class called
    `FinanceCalculatorUI` that extends `JPanel`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`JPanel`类是其他组件和控制的容器。虽然`JFrame`类已经包含了`JPanel`类，通常被称为内容面板，但我们很少用它做任何事情，而只是添加一个用户设计的`JPanel`。这正是我的示例所做的事情。还有一个名为`FinanceCalculatorUI`的第二个类，它扩展了`JPanel`。'
- en: 'To add controls such as buttons, text fields, or other JPanels to a `JPanel`
    class, we must first decide on a `LayoutManager` class. These are objects that
    are responsible for the placement of items in `JPanel`. The main panel in the
    app is `FinancialCalculatorUI`, which extends `JPanel`. In its constructor, we
    write the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要将控件（如按钮、文本字段或其他`JPanel`）添加到`JPanel`类中，我们首先必须决定一个`LayoutManager`类。这些对象负责在`JPanel`中放置项目。应用程序中的主要面板是`FinancialCalculatorUI`，它扩展了`JPanel`。在其构造函数中，我们编写以下内容：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Later in the code, another `JPanel` is created that does not extend another
    class. We can pass the layout manager through the `JPanel` constructor:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的后面，创建了另一个不扩展其他类的`JPanel`。我们可以通过`JPanel`构造函数传递布局管理器：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It is quite common to create a user interface with multiple panels. The following
    diagram shows all the panels used:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个面板创建用户界面是非常常见的。以下图表显示了所有使用的面板：
- en: "![Figure 13.6 – The J\uFEFFPanel layout](img/B19088_13_06.jpg)"
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图13.6 – JPanel布局](img/B19088_13_06.jpg)'
- en: Figure 13.6 – The JPanel layout
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6 – JPanel布局
- en: The first `JPanel`, `FinancialCalculatorUI`, is assigned to the content pane
    of `JFrame`. It will have a `BorderLayout` that has north, south, east, west,
    and center zones. In each zone of a layout, you can add another panel or control.
    Anything you place in this layout will fill the zone. In the north, we placed
    a panel with `JRadioButtons`. In the center, we placed another `JPanel` with `BorderLayout`.
    In the north of this panel, we place a panel that contains the title. In the south,
    there is a panel with the calculate button. In the center, we place another panel
    with `GridBagLayout` that allows us to treat the panel as rows and columns, which
    is ideal for forms.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`JPanel`，`FinancialCalculatorUI`，被分配到`JFrame`的内容面板。它将有一个`BorderLayout`，包括北、南、东、西和中心区域。在每个布局区域中，你可以添加另一个面板或控件。你放置在这个布局中的任何内容都将填充该区域。在北部，我们放置了一个带有`JRadioButtons`的面板。在中心，我们放置了另一个带有`BorderLayout`的`JPanel`。在这个面板的北部，我们放置了一个包含标题的面板。在南部，有一个带有计算按钮的面板。在中心，我们放置了另一个带有`GridBagLayout`的面板，这允许我们将面板视为行和列，这对于表单来说是非常理想的。
- en: Event handlers
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件处理器
- en: 'Any component that can accept user input from either the keyboard or mouse
    can generate an event. You can choose to ignore an event, or you can register
    an event handler you have written. Here is the code that registers a method in
    the same class as the handler:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 任何可以接受用户从键盘或鼠标输入的组件都可以生成事件。你可以选择忽略事件，或者你可以注册你编写的事件处理器。以下是注册与处理器同一类中的方法的代码：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `calculateButtonHandler` method accepts an `ActionEvent` object. The object
    contains information on the event, but in this case, we do not need it. The method
    validates that the fields can be `BigDecimal`, assigns them to `FinanceBean`,
    and, if all is well, calls on the `FinanceCalculations` object to do the calculation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculateButtonHandler` 方法接受一个 `ActionEvent` 对象。该对象包含有关事件的信息，但在此情况下我们不需要它。该方法验证字段是否可以是
    `BigDecimal` 类型，并将它们分配给 `FinanceBean`，如果一切顺利，则调用 `FinanceCalculations` 对象进行计算。'
- en: Document filter
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档过滤器
- en: In our design, we decided to only allow the end user to enter a number. This
    number can only have one decimal point and without a sign, because all values
    must be positive. In Swing, `JTextField` has inside it an object of type `Document`,
    and from this, we can access and replace the `DocumentFilter` object. In the filter,
    there is a method called `replace` that is called with every keystroke. We will
    install our own filter that inherits/extends `DocumentFilter`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的设计中，我们决定只允许最终用户输入一个数字。这个数字只能有一个小数点，且不带符号，因为所有值都必须是正数。在 Swing 中，`JTextField`
    内部有一个 `Document` 类型的对象，我们可以从这个对象中访问并替换 `DocumentFilter` 对象。在过滤器中，有一个名为 `replace`
    的方法，它在每次按键时被调用。我们将安装自己的过滤器，该过滤器继承或扩展了 `DocumentFilter`。
- en: The `replace` method receives the string that you entered and the location where
    in the current text field this string is inserted. It is called before the text
    is entered in the document; we have access to the contents of the text field before
    it is changed. This means that should the user input turn out to be invalid, we
    can restore what was in the text field prior to the new string we entered.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`replace` 方法接收你输入的字符串以及当前文本字段中该字符串插入的位置。它在文本进入文档之前被调用；在文本改变之前，我们可以访问文本字段的内容。这意味着如果用户输入无效，我们可以恢复我们在输入新字符串之前文本字段中的内容。'
- en: Pattern matching with regular expressions
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正则表达式模式匹配
- en: 'A *regular expression* or *regex* is a description of what may or may not be
    allowed in a string. Pattern matching employs a regex to determine whether a string
    that a pattern is being applied to meets the requirements of the regex. These
    expressions define a pattern that will be applied to the user input string:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*正则表达式* 或 *regex* 是对字符串中允许或不允许的内容的描述。模式匹配使用正则表达式来确定应用模式的字符串是否符合正则表达式的需求。这些表达式定义了一个将应用于用户输入字符串的模式：'
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first line takes a regular expression and compiles it. Regular expressions
    are compiled every time you use them, if not compiled in advance. This is the
    role of creating a `Pattern` object.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将正则表达式编译。如果事先没有编译，每次使用正则表达式时都会进行编译。这就是创建 `Pattern` 对象的作用。
- en: 'The second line creates a `Matcher` object. Here, we create a `Matcher` object
    built from the `Pattern` object that can evaluate the string in the parenthesis
    and return `true` or `false`. In the `Matcher` declaration, it might seem strange
    to search in an empty string, but as we will see, you can change the string that
    you want to search for after you create the `Matcher` object:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行创建了一个 `Matcher` 对象。在这里，我们创建了一个由 `Pattern` 对象构建的 `Matcher` 对象，它可以评估括号内的字符串并返回
    `true` 或 `false`。在 `Matcher` 声明中，搜索空字符串可能看起来很奇怪，但正如我们将看到的，你可以在创建 `Matcher` 对象之后更改你想要搜索的字符串：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `reset` method of `Matcher` is what allows us to change a string to search
    through. The `newText` object is the string after the new characters are added
    to the original string. If the match fails, then the string already in the text
    field is unchanged. The approach taken here will work if the user is pasting strings
    into the text field.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Matcher` 类的 `reset` 方法允许我们将字符串更改为搜索内容。`newText` 对象是在将新字符添加到原始字符串之后得到的字符串。如果匹配失败，则文本字段中已有的字符串保持不变。如果用户将字符串粘贴到文本字段中，这里采取的方法将有效。'
- en: There are many developers who believe that pattern matching is costly, meaning
    it uses a lot of CPU time. Exceptions are also costly. If they are both costly,
    then the simpler exception approach will have the edge for most users. However,
    a simple test comparing the performance of pattern matching versus exception throwing,
    using the Java **Microbenchmark Harness** library, showed that pattern matching
    can be between 8 and 10 times faster than using an exception.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者认为模式匹配成本较高，这意味着它使用了大量的CPU时间。异常也是昂贵的。如果两者都很昂贵，那么对于大多数用户来说，简单的异常方法将具有优势。然而，使用Java
    **Microbenchmark Harness**库比较模式匹配与抛出异常的性能的简单测试表明，模式匹配可以比使用异常快8到10倍。
- en: Controls and panels
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制面板
- en: 'Let us look at two controls that are placed in a panel with `GridBagLayout`.
    We begin with `JLabel`. We provide the text to display in its constructor. The
    actual text is coming from the appropriate `ResourceBundle` that the `form` object
    represents. We set the font next. This font is used in more than one place, so
    it has already been defined as `labelFont`. Finally, we add `JLabel` to the panel.
    To do this, we need an object of type `GridBagConstraints`. There are five details
    about how this control is added. The number `0` represents the column and the
    number `2` represents the row. The next two numbers represent how many columns
    and rows this control will use in the grid. Finally, we indicate the alignment
    of the control in the grid:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看两个放置在带有`GridBagLayout`的面板中的控件。我们首先从`JLabel`开始。我们在其构造函数中提供要显示的文本。实际的文本来自`form`对象表示的适当`ResourceBundle`。接下来，我们设置字体。这个字体在多个地方使用，因此它已经被定义为`labelFont`。最后，我们将`JLabel`添加到面板中。为此，我们需要一个`GridBagConstraints`类型的对象。关于如何添加这个控件有五个细节。数字`0`代表列，数字`2`代表行。接下来的两个数字代表这个控件在网格中将使用多少列和行。最后，我们指示控件在网格中的对齐方式：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `JTextField` control has added settings for horizontal alignment and the
    width of the field measured in columns:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`JTextField`控件增加了水平对齐和字段宽度的设置，宽度以列为单位：'
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we extract the control’s `Document` and use this reference to install
    our filter:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们提取控制器的`Document`并使用这个引用来安装我们的过滤器：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we add `JTextField` to the grid:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`JTextField`添加到网格中：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You will find more details on this Swing version in the source code. Now, let
    us look at the JavaFX version.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在源代码中找到关于这个Swing版本的更多细节。现在，让我们看看JavaFX版本。
- en: Using the JavaFX GUI framework
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JavaFX GUI框架
- en: 'This version of the program is like the Swing version. The design of the user
    interface is identical in that it employs panes in panes. Here is the finished
    project layout:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序版本类似于Swing版本。用户界面的设计相同，因为它在面板中使用面板。以下是完成的项目布局：
- en: '![Figure 13.7 – The JavaFX program layout](img/B19088_13_07.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图13.7 – JavaFX程序布局](img/B19088_13_07.jpg)'
- en: Figure 13.7 – The JavaFX program layout
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7 – JavaFX程序布局
- en: Let us now look at the classes from the JavaFX framework that we will need for
    our program.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看JavaFX框架中我们将需要的类。
- en: Application
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序
- en: A JavaFX program must contain a class that extends `Application`. Within this
    class, we can construct the user interface or delegate this work to another class.
    A class that extends `Application` must implement a method called `start` and,
    optionally, a method called `init`. What you rarely have is a constructor. The
    JavaFX framework is not available to a constructor of a class that extends `Application`.
    This is where `init` comes in. It plays the role of the constructor but in an
    environment where JavaFX is up and running. You do not call `init`; JavaFX will.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一个JavaFX程序必须包含一个扩展`Application`的类。在这个类中，我们可以构建用户界面或将这项工作委托给另一个类。扩展`Application`的类必须实现一个名为`start`的方法，可选地实现一个名为`init`的方法。你很少有一个构造函数。JavaFX框架不对扩展`Application`的类的构造函数可用。这就是`init`发挥作用的地方。它在JavaFX运行的环境中扮演构造函数的角色。你不需要调用`init`；JavaFX会调用。
- en: The `start` method is where the creation of the GUI commences. The method is
    called by JavaFX right after `init`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`start`方法是GUI创建开始的地方。该方法在`init`之后由JavaFX调用。'
- en: PrimaryStage
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主舞台
- en: 'The `PrimaryStage` object is akin to `JFrame`. You do not create an instance
    of it. The `Application` class you are extending creates a `PrimaryStage` object
    and passes it on to `start`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrimaryStage`对象类似于`JFrame`。你不需要创建它的实例。你正在扩展的`Application`类创建了一个`PrimaryStage`对象并将其传递给`start`：'
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Pane
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面板
- en: 'Unlike Swing, where you define a panel and assign a layout manager to it, FX
    uses panes that include the layout. The first pane that we are creating is `BorderPane`,
    which has top, bottom, left, right, and center zones. We are adding to it a pane
    that contains the radio buttons at the top and another pane in the center:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与Swing不同，在Swing中您定义一个面板并将其分配给布局管理器，FX使用包含布局的面板。我们正在创建的第一个面板是`BorderPane`，它有顶部、底部、左侧、右侧和中心区域。我们在顶部添加了一个包含单选按钮的面板，并在中心添加了另一个面板：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Scene
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景
- en: The story goes that the original developer of JavaFX was a performing arts aficionado,
    and this led him to use theater names for parts of the framework. A `Stage` object
    must contain a `Scene` object that, in turn, contains a pane object. You can create
    multiple scenes and switch between them if required. For me, one of the most noteworthy
    features of JavaFX is its use of **Cascading Style Sheet** (**CSS**), and the
    second line will load it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 据说JavaFX的原开发者是一位表演艺术爱好者，这使他使用剧院名称作为框架的一部分。一个`Stage`对象必须包含一个`Scene`对象，该对象反过来又包含一个面板对象。如果需要，您可以创建多个场景并在它们之间切换。对我来说，JavaFX最引人注目的特性之一是它使用**级联样式表**（**CSS**），下一行将加载它。
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The next four lines should be self-explanatory. The last line calls the show
    method to get the program going.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 下四行应该是自解释的。最后一行调用`show`方法来启动程序。
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: CSS style sheets
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSS样式表
- en: 'You style components using CSS. This is similar but not identical to CSS used
    in web development. In the *Further reading* section, there is a link to the CSS
    reference document. Here is the style sheet used in this application. Class names
    beginning with a period are predefined. Class names beginning with an octothorpe
    are the ones that you assign:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CSS来设置组件样式。这与在Web开发中使用的CSS类似，但并不完全相同。在*进一步阅读*部分，有一个链接到CSS参考文档。以下是本应用程序使用的样式表。以点开头的类名是预定义的。以井号开头的类名是您分配的：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can assign a custom class name for a control by using the control’s `setId`
    method:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用控件的`setId`方法为控件分配一个自定义类名：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can also enter the CSS styling directly in the source code. CSS entered
    this way will override what is in the external style sheet:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以直接在源代码中输入CSS样式。以这种方式输入的CSS将覆盖外部样式表中的内容：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: JavaFX bean
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaFX Bean
- en: 'A JavaFX bean is designed to support binding a field in the bean with a control.
    Any change to the control is written to the bean, and anything written to the
    bean will update the control. This is commonly called the observer pattern. To
    accomplish this, we must wrap all the data types into a family of objects called
    properties. A JavaFX bean can be used where a JavaBean is expected. This means
    that there is no need to alter the `FinancialCalculations` class, as it will work
    with the JavaFX bean without any changes to its code. Here is our `FinanceFXBean`
    class as a JavaFX bean:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX Bean的设计是为了支持将Bean中的字段与控件绑定。对控件所做的任何更改都会写入Bean，写入Bean的内容也会更新控件。这通常被称为观察者模式。为了实现这一点，我们必须将所有数据类型包装到一个称为属性的家族对象中。JavaFX
    Bean可以在期望JavaBean的地方使用。这意味着不需要修改`FinancialCalculations`类，因为它将与JavaFX Bean一起工作，而无需对其代码进行任何更改。以下是我们的`FinanceFXBean`类作为JavaFX
    Bean的示例：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Rather than declare primitive or class types directly, they must be wrapped
    into an appropriate `Property` class. There are such classes for all the primitive
    data types, such as `DoubleProperty` or `StringProperty`. In our example, we are
    using `BigDecimal`, for which there is no property. This is where the `ObjectProperty`
    class comes in. This allows you to use any class as a property:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与直接声明原始或类类型相比，它们必须被包装到适当的`Property`类中。对于所有原始数据类型，例如`DoubleProperty`或`StringProperty`，都有这样的类。在我们的示例中，我们使用`BigDecimal`，对于它没有属性。这就是`ObjectProperty`类发挥作用的地方。这允许您将任何类用作属性：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'There are two constructors. The first is a default constructor that calls upon
    the non-default constructor:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个构造函数。第一个是默认构造函数，它调用非默认构造函数：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The non-default constructor must instantiate each of the `Property` objects
    and initialize them, with `BigDecimal` passed to it. There is a simple property
    for each of the defined properties. `SimpleObjectProperty` is used when there
    is not a named property, such as `SimpleDoubleProperty`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造函数必须实例化每个`Property`对象并对其进行初始化，传入的参数是`BigDecimal`。对于每个定义的属性都有一个简单的属性。当没有命名属性时，例如`SimpleDoubleProperty`，使用`SimpleObjectProperty`：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Unlike a JavaBean, there are three methods for each property. The first two,
    the getter and setter, retrieve the value from inside the property or change the
    value in the property. This is how a JavaFX bean can replace a Java bean, as the
    getter and setters are named the same and return or receive the same data types:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与 JavaBean 不同，每个属性有三个方法。前两个，获取器和设置器，从属性内部检索值或更改属性中的值。这就是 JavaFX bean 可以替换 Java
    bean 的方式，因为获取器和设置器的命名相同，返回或接收相同的数据类型：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The last of the three methods returns the property. This is used to implement
    binding and the observable pattern:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后三个方法之一返回属性。这用于实现绑定和观察者模式：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: BigDecimalTextField
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BigDecimalTextField
- en: This is a class that extends the JavaFX `TextField`. Unlike Swing’s `JTextField`,
    there is no `Document`. Pressing a key will invoke a method in `TextField` that
    we override to meet our needs. These methods use regular expressions for pattern
    matching. There is now a second regular expression that is used to modify the
    string by removing leading zeros.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个扩展 JavaFX `TextField` 的类。与 Swing 的 `JTextField` 不同，没有 `Document`。按下一个键将调用我们重写以满足我们需求的方法。这些方法使用正则表达式进行模式匹配。现在还有一个用于通过删除前导零来修改字符串的正则表达式。
- en: There are two methods that we override. The first is `replaceText` for handling
    keyboard input. The second is `replaceSelection` for handling changes that arise
    from selecting text and then replacing it, either from the keyboard or by pasting.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重写了两种方法。第一种是 `replaceText`，用于处理键盘输入。第二种是 `replaceSelection`，用于处理从选择文本然后替换它（无论是通过键盘还是粘贴）而产生的变化。
- en: Controls
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制
- en: 'There is a similarity in how we create controls and add them to a pane. You
    create `GridPane` to hold the form:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建控制和将它们添加到面板中的方式有相似之处。你创建 `GridPane` 来保存表单：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`inputLabel` is instantiated using `ResourceBundle`. A custom CSS-style `id`
    is assigned next. Finally, we add the label to the `financeGrid` pane, indicating
    the column and row:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ResourceBundle` 实例化 `inputLabel`。接下来分配一个自定义的 CSS-style `id`。最后，我们将标签添加到
    `financeGrid` 面板中，指示列和行：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`inputValue` is constructed from our custom `BigDecimalTextField`. We assign
    it a custom CSS `id`, change its alignment, and add it to `financeGrid`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`inputValue` 是由我们的自定义 `BigDecimalTextField` 构造的。我们给它分配一个自定义的 CSS `id`，更改其对齐方式，并将其添加到
    `financeGrid`：'
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Binding
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定
- en: 'Binding a primitive data type to a field in a JavaFX bean requires a converter.
    There are some standard converters, one of which is for `BigDecimal` to convert
    from a string to a BigDecimal. Here is the binding method:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 将原始数据类型绑定到 JavaFX bean 中的字段需要一个转换器。有一些标准转换器，其中之一是将字符串转换为 BigDecimal 的转换器。以下是绑定方法：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We are creating a `BigDecimalStringConverter` object that we can reuse in each
    of the bindings:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个 `BigDecimalStringConverter` 对象，我们可以在每个绑定中重用它：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For each binding, we pass `textProperty` of each `TextField`, the property
    for each field in the `FinanceFXBean`, and our converter:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个绑定，我们传递每个 `TextField` 的 `textProperty`，`FinanceFXBean` 中每个字段的属性，以及我们的转换器：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Which should you use? Read the following summary to decide.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用哪一个？阅读以下摘要来决定。
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Swing is a mature GUI framework that is maintained as part of the Java distribution.
    Having been around for so long, there has been much written on how to use it.
    Choosing Swing for your GUI project is a good choice.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Swing 是一个成熟的 GUI 框架，它是 Java 分发的一部分进行维护。由于存在了这么久，已经有很多关于如何使用它的文章。为您的 GUI 项目选择
    Swing 是一个好的选择。
- en: JavaFX is the new kid on the block, so to speak. The two most significant differences
    are binding and CSS style sheets. Although not covered here, JavaFX also has much
    better graphics support. In JavaFX graphics, primitives such as a line or a rectangle
    are on par with controls. JavaFX has an `Animation` class that simplifies creating
    moving graphics. There is a also chart library to create line charts, pie charts,
    and so on.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX 可以说是新来的孩子。两个最显著的区别是绑定和 CSS 样式表。虽然这里没有涉及，但 JavaFX 还提供了更好的图形支持。在 JavaFX
    图形中，如线或矩形这样的原语与控件处于同一级别。JavaFX 有一个 `Animation` 类，它简化了创建动态图形的过程。还有一个用于创建折线图、饼图等的图表库。
- en: Users today expect a GUI in the software they use. Swing projects do not need
    to be rewritten using JavaFX, and new projects using Swing continue to be written.
    So, which should you use? In my opinion, new projects should use JavaFX. Swing
    is, for the most part, in maintenance mode to ensure that it works, taking advantage
    of changes in the core language. JavaFX, on the other hand, is actively maintained
    as an open source project, with both maintenance and new features added to each
    release.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的用户期望他们使用的软件中有一个图形用户界面。不需要使用 JavaFX 重新编写 Swing 项目，并且继续有新的项目使用 Swing 编写。那么，你应该使用哪个？在我看来，新项目应该使用
    JavaFX。Swing 在很大程度上处于维护模式，以确保其正常工作，并利用核心语言的变化。另一方面，JavaFX 作为开源项目，每个版本都积极维护，并添加了维护和新功能。
- en: In our next chapter, we will look at how Java is used to write software for
    the World Wide Web that runs in a container called an application server.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们下一章中，我们将探讨如何使用 Java 编写运行在称为应用程序服务器的容器中的软件，用于万维网。
- en: Further reading
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Napkin look and feel: [https://napkinlaf.sourceforge.net/](https://napkinlaf.sourceforge.net/'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 餐巾纸外观：[https://napkinlaf.sourceforge.net/](https://napkinlaf.sourceforge.net/)
- en: )
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: 'Java Microbenchmark Harness: [https://medium.com/javarevisited/understanding-java-microbenchmark-harness-or-jmh-tool-5b9b90ccbe8d](https://medium.com/javarevisited/understanding-java-microbenchmark-harness-or-jmh-tool-5b9b90ccbe8d'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 微基准测试工具：[https://medium.com/javarevisited/understanding-java-microbenchmark-harness-or-jmh-tool-5b9b90ccbe8d](https://medium.com/javarevisited/understanding-java-microbenchmark-harness-or-jmh-tool-5b9b90ccbe8d)
- en: )
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: 'Pattern matching: [https://xperti.io/blogs/pattern-matching-java-feature-spotlight/](https://xperti.io/blogs/pattern-matching-java-feature-spotlight/'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式匹配：[https://xperti.io/blogs/pattern-matching-java-feature-spotlight/](https://xperti.io/blogs/pattern-matching-java-feature-spotlight/)
- en: )
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '*JavaFX CSS Reference* *Guide*: [https://openjfx.io/javadoc/17/javafx.graphics/javafx/scene/doc-files/cssref.html](https://openjfx.io/javadoc/17/javafx.graphics/javafx/scene/doc-files/cssref.html)'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JavaFX CSS 参考指南* *指南*：[https://openjfx.io/javadoc/17/javafx.graphics/javafx/scene/doc-files/cssref.html](https://openjfx.io/javadoc/17/javafx.graphics/javafx/scene/doc-files/cssref.html)'
