- en: 17\. Reactive Programming with Java Flow
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17. 使用 Java Flow 的响应式编程
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter covers the Java Flow API and the advantages of the Reactive Streams
    specification. It will first define, in general terms, the motivation for Flow
    and Reactive Streams, as well as the respective functions of Publishers, Subscribers,
    and Processors in Java. You will then learn to use the basic `SubmissionPublisher`
    to build a reactive application and, in the final sections, practice implementing
    a simple Subscriber and Processor using Flow.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍 Java Flow API 和响应式流规范的优势。它将首先以一般术语定义 Flow 和响应式流的动机，以及 Java 中发布者、订阅者和处理器的相应功能。然后，你将学习如何使用基本的
    `SubmissionPublisher` 来构建响应式应用程序，并在最后几节中练习使用 Flow 实现一个简单的订阅者和处理器。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'The Reactive Streams specification presents an ongoing development within software
    architecture, referred to as Reactive Systems. These systems, ideally, have the
    following advantages:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式流规范展示了软件架构中一个持续发展的方向，被称为响应式系统。这些系统理想情况下具有以下优势：
- en: A faster response
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更快的响应
- en: More controlled responses in relation to one another
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更可控的相互响应
- en: Increased reliability
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高可靠性
- en: A natively supported API for developing Reactive Systems or applications was
    introduced in Java 9, called Flow.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 中引入了一个用于开发响应式系统或应用程序的原生支持的 API，称为 Flow。
- en: The Java 9 Flow API was not intended to compete with the already developed,
    highly adopted, and appreciated reactive libraries or APIs available out there.
    The biggest reason for the advent of the Flow API was the need for a common denominator
    amongst these libraries; to ensure that the core of reactive programming would
    be the same regardless of which implementation you use. That way, you can easily
    translate from one implementation to another.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 Flow API 的目的不是与已经开发、高度采用且受到赞赏的响应式库或 API 竞争。Flow API 诞生的最大原因是需要在这些库之间找到一个共同点；确保无论使用哪种实现，响应式编程的核心都是相同的。这样，你可以轻松地从一种实现转换到另一种实现。
- en: To achieve this, the Java Flow API adheres to the Reactive Streams specification—the
    specification that most of the libraries available use as a blueprint for their
    design. The Reactive Streams initiative, which designed the specification, was
    started in 2013 by Netflix and several other large corporations with a vested
    interest in delivering content reliably.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，Java Flow API 遵循响应式流规范——大多数库在设计时都将其作为蓝图使用的规范。该规范的设计者响应式流倡议始于 2013 年，由
    Netflix 和其他几家对可靠交付内容有利益的大公司发起。
- en: Note
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While they may share a lot of the same lingo, the Flow API is not in any way
    related to the Streams API of Java 8\. They are focused on solving different kinds
    of problems.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它们可能共享很多相同的术语，但 Flow API 与 Java 8 的 Streams API 完全无关。它们专注于解决不同类型的问题。
- en: In simple terms, reactive programming is a way to write programs using components
    that communicate with each other by streaming events. These events are often asynchronous
    in nature and should never overwhelm the receiving party. Within a reactive system,
    there are two main components—publishers and subscribers. This is similar to a
    networked pub/sub system, but on a micro-scale.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，响应式编程是一种使用通过流式传输事件相互通信的组件来编写程序的方法。这些事件通常是异步的，并且永远不会使接收方感到压力。在响应式系统中，有两个主要组件——发布者和订阅者。这与网络化的
    pub/sub 系统类似，但规模更小。
- en: 'The Java Flow API (or rather Reactive Streams, which Flow adheres to) has three
    main actors:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Java Flow API（或者更确切地说，Flow 遵循的响应式流）有三个主要角色：
- en: The Publisher has the knowledge of the available data and pushes it on-demand
    to any interested subscriber.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布者了解可用的数据，并按需将其推送到任何感兴趣的订阅者。
- en: The Subscriber is the one demanding the data.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅者是需求数据的一方。
- en: The Processor may sit between a publisher and a subscriber. Processors can intercept
    and transform the published data before releasing it to a subscriber or another
    processor. Thus, the processor can act as both a subscriber and a publisher.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理器可能位于发布者和订阅者之间。处理器可以在将发布的数据释放给订阅者或另一个处理器之前拦截和转换这些数据。因此，处理器可以同时充当订阅者和发布者。
- en: Communication between these components is of both a push and pull nature. The
    subscriber first asks the publisher to send, at most, `n` messages. That's the
    pull part of the communication. Following that request, the publisher will begin
    to send messages to the subscriber, but it will never exceed `n` messages.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件之间的通信具有推送和拉取两种性质。订阅者首先请求发布者发送最多 `n` 条消息。这是通信的拉取部分。在此请求之后，发布者将开始向订阅者发送消息，但不会超过
    `n` 条消息。
- en: '![Figure 17.1: Communication between the Subscriber and the Publisher'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 17.1：订阅者和发布者之间的通信'
- en: '](img/C13927_17_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C13927_17_01.jpg)'
- en: 'Figure 17.1: Communication between the Subscriber and the Publisher'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.1：订阅者和发布者之间的通信
- en: When the publisher has sent the final message, it will provide a notification
    that the sending of messages is complete, and the subscriber may then act as needed—probably
    requesting more messages or aborting the communication entirely.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当发布者发送了最终消息后，它将提供一个通知，表明消息发送已完成，订阅者可以据此采取必要的行动——可能请求更多消息或完全终止通信。
- en: The entire Flow API, which we will look into further in this chapter, is defined
    in a single Java class. It contains one interface for each of the actors, and
    an extra interface describing the subscription object, which is the messaging
    link between the publisher and subscriber.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章进一步探讨的整个 Flow API 都定义在一个单独的 Java 类中。它为每个参与者定义了一个接口，以及一个额外的接口，描述了订阅对象，这是发布者和订阅者之间的消息链接。
- en: Publisher
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Publisher
- en: The publisher holds the data that other components are interested in getting.
    The publisher will wait until a subscriber who is interested in the data requests
    n-number of items to be sent, and will only then start sending those items to
    the subscriber.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 发布者持有其他组件感兴趣获取的数据。发布者将等待一个对数据感兴趣的订阅者请求发送 n 个项目，然后才会开始向订阅者发送这些项目。
- en: Asking for a specific number of items, rather than asking for everything, is
    called backpressure, and is very important in the Reactive Streams specification.
    This backpressure lets listeners request only as many items as they can handle
    at a time, ensuring that the application will not stall or crash.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请求特定数量的项目，而不是请求所有项目，这被称为背压，在 Reactive Streams 规范中非常重要。这种背压允许监听器一次请求他们能够处理的项目数量，确保应用程序不会停滞或崩溃。
- en: 'The interface for `Publisher` in Flow, and Reactive Streams looks like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Flow 和 Reactive Streams 中 `Publisher` 的接口如下：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You'll notice that it's a functional interface, which can be implemented as
    a lambda, should you wish.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到它是一个函数式接口，如果您愿意，可以将其实现为 lambda 表达式。
- en: SubmissionPublisher
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SubmissionPublisher
- en: Creating a fully functional Publisher can be quite a complicated endeavor. Luckily,
    Flow includes a complete implementation called `SubmissionPublisher`. We'll use
    this class in several examples in this chapter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个完全功能的发布者可能相当复杂。幸运的是，Flow 包含一个完整的实现，称为 `SubmissionPublisher`。我们将在本章的几个示例中使用这个类。
- en: 'You can use `SubmissionPublisher` either directly, as a component, or as a
    superclass for your extended `Publisher`. `SubmissionPublisher` requires an `Executor`
    and a buffer size. By default, it will use the common `ForkJoinPool` and a buffer
    size of 256:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接使用 `SubmissionPublisher` 作为组件，或者作为扩展 `Publisher` 的超类。`SubmissionPublisher`
    需要一个 `Executor` 和一个缓冲区大小。默认情况下，它将使用常见的 `ForkJoinPool` 和一个缓冲区大小为 256：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The choice of executor should be based on how your application is designed
    and the tasks it is supposed to handle. In some cases, the common `ForkJoinPool`
    is the best choice, while in other situations, a scheduled thread pool may work
    better. You may need to try different executors and buffer sizes to find the combination
    that best suits your needs:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 选择执行器应根据您的应用程序设计和预期处理的任务来决定。在某些情况下，常见的 `ForkJoinPool` 是最佳选择，而在其他情况下，一个计划中的线程池可能效果更好。您可能需要尝试不同的执行器和缓冲区大小，以找到最适合您需求的组合：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You may also use `SubmissionPublisher` as a superclass for your own implementation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将 `SubmissionPublisher` 作为您自己实现的超类使用。
- en: 'In the following example, `MyPublisher` extends `SubmissionPublisher`, but
    defines a fixed `threadpool` executor rather than the common `ForkJoinPool` executor:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`MyPublisher` 扩展了 `SubmissionPublisher`，但定义了一个固定的 `threadpool` 执行器，而不是常见的
    `ForkJoinPool` 执行器：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Subscriber
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Subscriber
- en: The subscriber represents the end-user. It receives the data at the very end
    of the stream and acts on it. The action may include updating a user interface,
    pushing it to another component, or transforming it in any way.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅者代表最终用户。它在流的末尾接收数据并对它进行操作。操作可能包括更新用户界面、推送到另一个组件或以任何方式进行转换。
- en: 'The interface of the subscribers contains four different callbacks, each of
    which represents a message of some type from the publisher or the subscriber itself:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅者的接口包含四个不同的回调，每个回调都代表来自发布者或订阅者本身的某种类型的信息：
- en: '`onSubscribe:` The `onSubscribe` method is invoked as soon as the subscriber
    has a valid subscription. Generally, this is used to kick-start the delivery of
    items from the publisher. The `Subscriber` will typically inform the `Publisher`
    here, by requesting another item.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onSubscribe:` 当订阅者拥有有效的订阅时，会调用 `onSubscribe` 方法。通常，这用于启动从发布者发送项目的交付。`Subscriber`
    通常会在这里通知 `Publisher`，通过请求另一个项目。'
- en: '`onNext:` The `onNext` method is invoked when another item is made available
    from the `Publisher`.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onNext:` 当 `Publisher` 提供另一个项目时，会调用 `onNext` 方法。'
- en: '`onError:` The `onError` method is invoked when an error occurs. This usually
    means that the subscriber will no longer receive any more messages and should
    be closed down.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onError:` 当发生错误时，会调用 `onError` 方法。这通常意味着订阅者将不再接收任何更多消息，并且应该关闭。'
- en: '`onComplete:` The `onComplete` method is invoked by the publisher when the
    final item has been sent.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onComplete:` 当发布者发送了最后一个项目时，会调用 `onComplete` 方法。'
- en: 'The following example illustrates all of these callbacks:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了所有这些回调：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Subscription
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 订阅
- en: 'A `Subscriber` may use the Subscription API to control a publisher, either
    by requesting more items, or by canceling the subscription altogether:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subscriber` 可以使用订阅 API 来控制发布者，无论是通过请求更多项目，还是完全取消订阅：'
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It is the `Publisher` who creates the subscriptions. It does this whenever a
    `Subscriber` has subscribed to that `Publisher`. If a `Subscriber` happens to
    subscribe twice to one publisher, it will fire the `onError()` callback with `IllegalStateException`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 是 `Publisher` 创建订阅。每当 `Subscriber` 订阅了该 `Publisher` 时，它会这样做。如果一个 `Subscriber`
    竟然订阅了同一个发布者两次，它将触发 `onError()` 回调并抛出 `IllegalStateException`。
- en: 'Exercise 1: A Simple Application with a Single Publisher and a Single Subscriber'
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1：具有单个发布者和单个订阅者的简单应用程序
- en: 'In this exercise, we will build an application with a single `Publisher` and
    a single `Subscriber`. The `Publisher` will send a string of messages to the `Subscriber`,
    which will then print it to the terminal. The messages are found in the `lipsum.txt`
    file, which should be placed in your `projects /res` folder. For this exercise,
    we will use the common `ForkJoinPool` to generate the executor:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将构建一个具有单个 `Publisher` 和单个 `Subscriber` 的应用程序。`Publisher` 将发送一条消息字符串到
    `Subscriber`，然后将其打印到终端。这些消息位于 `lipsum.txt` 文件中，该文件应放置在你的 `projects /res` 文件夹中。对于这个练习，我们将使用常见的
    `ForkJoinPool` 来生成执行器：
- en: If IntelliJ is already started, but no project is open, select `Create New Project`.
    If IntelliJ already has a project opened, select `File` à `New` à `Project` from
    the menu.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 IntelliJ 已经启动，但没有打开任何项目，请选择 `创建新项目`。如果 IntelliJ 已经打开了项目，请从菜单中选择 `文件` à `新建`
    à `项目`。
- en: In `New Project` dialog, select a Java project, and then click `Next`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `新建项目` 对话框中，选择 Java 项目，然后点击 `下一步`。
- en: Check the box to create the project from a template. Select `Command Line App`,
    and then click `Next`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打勾以从模板创建项目。选择 `命令行应用程序`，然后点击 `下一步`。
- en: Name the new project `Chapter17`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新项目命名为 `Chapter17`。
- en: IntelliJ will give you a default project location. If you wish to select a different
    one, you may enter it here.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IntelliJ 会为你提供一个默认的项目位置。如果你希望选择一个不同的位置，你可以在这里输入。
- en: Set the package name to `com.packt.java.chapter17`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将包名设置为 `com.packt.java.chapter17`。
- en: Click `Finish`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `完成`。
- en: IntelliJ will create your project, called `Chapter17`, with the standard folder
    structure. IntelliJ will also create a main entry point called `Main.java`.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: IntelliJ 将创建你的项目，名为 `Chapter17`，并具有标准的文件夹结构。IntelliJ 还将创建一个名为 `Main.java` 的主入口点。
- en: 'Rename this file to `Exercise1.java`. When you''re done, it should look like
    this:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此文件重命名为 `Exercise1.java`。完成时，它应该看起来像这样：
- en: '[PRE6]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will use `SubmissionPublisher` in this exercise. This is a fully functional
    implementation of the `Publisher` interface, which you can use to demonstrate
    the basic functionality of a reactive application. Declare a default `SubmissionPublisher`,
    as shown here, and then initialize it:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用`SubmissionPublisher`。这是`Publisher`接口的一个完整功能实现，您可以使用它来演示反应式应用程序的基本功能。声明一个默认的`SubmissionPublisher`，如下所示，然后初始化它：
- en: '[PRE7]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Flow doesn''t come with any already available implementations of `Subscriber`,
    so we will need to implement our own `Subscriber`. Create a new class called `LipsumSubscriber`,
    and allow it to implement the `Flow.Subscriber` interface. Your new class should
    look something like the following example:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Flow不包含任何现成的`Subscriber`实现，因此我们需要实现自己的`Subscriber`。创建一个名为`LipsumSubscriber`的新类，并允许它实现`Flow.Subscriber`接口。您的新类应类似于以下示例：
- en: '[PRE8]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The subscriber has four methods to implement. The `onSubscribe` method will
    be called by the publisher when the `Subscription` object has been created. Usually,
    you''ll store a reference to that subscription so that you can issue requests
    to the publisher, create a `Flow.Subscription` member variable in your `LipsumSubscriber`
    class, and store the reference from the `onSubscribe` method:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅者有四个方法需要实现。当`Subscription`对象被创建时，发布者将调用`onSubscribe`方法。通常，您会存储对该订阅的引用，以便可以向发布者发出请求。在您的`LipsumSubscriber`类中创建一个`Flow.Subscription`成员变量，并将`onSubscribe`方法中的引用存储起来：
- en: '[PRE9]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Usually, you''ll also request at least one item when the subscription has been
    created. Use the `request` method to ask for one item from the publisher:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，在创建订阅时，您也会请求至少一个项目。使用`request`方法从发布者请求一个项目：
- en: '[PRE10]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Looking at the next method in the class, called `onNext`, this is the callback
    executed by the `Publisher` whenever an item is issued to all subscribers. In
    this example, we will simply print the contents of the item:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看一下类中的下一个方法，称为`onNext`，这是发布者每次向所有订阅者发出项目时执行的回调。在这个例子中，我们将简单地打印项目的内容：
- en: '[PRE11]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To keep getting more items from the publisher, we need to keep requesting them;
    this is what is called backpressure. It''s the subscriber who is in control in
    terms of how many items it can handle at a time. In this exercise, we''ll handle
    one item at a time and then request another. Request another item after you''ve
    printed the current item to the console:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了从发布者那里获取更多项目，我们需要不断请求它们；这被称为背压。在处理一次可以处理多少个项目方面，控制权在订阅者手中。在这个练习中，我们将一次处理一个项目，然后请求另一个。在将当前项目打印到控制台后，请求另一个项目：
- en: '[PRE12]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The subscriber can use the methods `onError` and `onComplete` to perform a
    cleanup and make sure that no resources are kept in vain. In this example, we
    will simply print the error and a completion message:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅者可以使用`onError`和`onComplete`方法进行清理，并确保没有资源被无用地保留。在这个例子中，我们将简单地打印错误和完成消息：
- en: '[PRE13]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Back in the `main` method, create a new subscriber and allow it to subscribe
    to the publisher:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`main`方法，创建一个新的订阅者，并允许它订阅发布者：
- en: '[PRE14]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'However, this will not actually do anything. The publisher still has no data
    to send, so we need to provide the data to the publisher as well. We''ll use the
    `lipsum.txt` file as the source. Copy the file to the `res/` folder in your project.
    Create the folder if it doesn''t already exist:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，这实际上并不会做任何事情。发布者仍然没有要发送的数据，因此我们需要向发布者提供数据。我们将使用`lipsum.txt`文件作为源。将文件复制到项目中`res/`文件夹。如果该文件夹不存在，则创建它：
- en: '[PRE15]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To send the words from the `lipsum.txt` file to the `Publisher`, you need to
    load the file into some kind of container. We will use the `Stream` API to load
    the words, and then push them to the publisher immediately. Wrap the stream in
    a try-with-resources block to enable the JVM to auto-close the resource after
    loading it:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将`lipsum.txt`文件中的单词发送到`Publisher`，您需要将文件加载到某种容器中。我们将使用`Stream` API来加载单词，然后立即将它们推送到发布者。将流包装在try-with-resources块中，以便在加载后JVM自动关闭资源：
- en: '[PRE16]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we are loading the file as a stream of strings. It will load the lines
    from the file into one string each. Since every line may contain multiple words,
    we need to apply a flat mapping to each line to extract the words. We are using
    a simple regular expression to split the lines into words, looking for one or
    more whitespaces, punctuation items, or a new line.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们将文件作为字符串流加载。它将逐行将文件中的行加载到单个字符串中。由于每一行可能包含多个单词，我们需要对每一行应用平坦映射以提取单词。我们使用一个简单的正则表达式将行拆分为单词，寻找一个或多个空白字符、标点符号或换行符。
- en: Note
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You can read more about the Streams API, and the different methods used here,
    in *Chapter 15*, *Processing Data with Streams*.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在*第15章*，*使用流处理数据*中了解更多关于Streams API和这里使用的方法。
- en: 'At this point, the program will execute and print all the words available in
    the file. However, you may notice that it does not print any completion messages.
    That is because we haven''t actually notified the subscribers that the stream
    has ended. Send the completion signal, as seen here:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，程序将执行并打印文件中可用的所有单词。然而，你可能注意到它没有打印任何完成消息。这是因为我们实际上还没有通知`Subscriber`流已经结束。发送完成信号，如下所示：
- en: '[PRE17]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Running this program should yield the following output in the console:'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行此程序应在控制台产生以下输出：
- en: '[PRE18]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Having built your first reactive application, you may notice that it doesn't
    really make much sense to use this extra logic in a very simple program, as shown
    in this example. Applying the Reactive Streams concept to a simple example makes
    very little sense as it is meant to be used in asynchronous applications, where
    you may not be sure when, or if, a Subscriber can currently receive messages.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建了你的第一个响应式应用程序后，你可能注意到在非常简单的程序中使用这种额外的逻辑并没有太多意义，如本例所示。将响应式流的概念应用于简单示例几乎没有意义，因为它旨在用于异步应用程序，在这些应用程序中，你可能不确定`Subscriber`何时或是否可以接收消息。
- en: Processor
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理器
- en: The Processor is something of a chameleon in Flow; it may act as both a `Subscriber`
    and a `Publisher`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器在Flow中有点像变色龙；它可以同时充当`Subscriber`和`Publisher`。
- en: There are several different reasons for adding an interface such as the Processor.
    One reason may be that you have a stream of data that you do not fully trust.
    Imagine an asynchronous flow of data from a server, where data is delivered over
    a UDP connection that lacks promises of delivery; this data will eventually be
    corrupted and you need to handle that. A simple way would be to inject a filter
    of some kind between the publisher and subscriber. This is where a `Processor`
    excels.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 添加处理器等接口的几个不同原因之一可能是因为你有一个你不完全信任的数据流。想象一下从服务器异步流数据，数据通过缺乏交付承诺的UDP连接传递；这些数据最终会被损坏，你需要处理这种情况。一种简单的方法是在发布者和订阅者之间注入某种类型的过滤器。这就是`Processor`大显身手的地方。
- en: Another reason for using a Processor could be to separate a polymorphic data
    stream between different subscribers so that alternative actions may be taken
    based on the data type.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用处理器另一个可能的原因是将多态数据流在不同的订阅者之间分离，以便可以根据数据类型采取不同的操作。
- en: 'Exercise 2: Using a Processor to Convert a Stream of Strings to Numbers'
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2：使用处理器将字符串流转换为数字
- en: In this exercise, we will first build a Publisher that periodically publishes
    a string from a text file. Then, we will use a scheduler to control the timer.
    The Subscriber should then attempt to transform a certain string to a number.
    The `numbers.txt` file will be used to build this application. In this example,
    we will also show how to clean up the handling of the data using a Supplier implementation
    to make the data source abstract.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将首先构建一个发布者，该发布者定期从文本文件发布字符串。然后，我们将使用调度器来控制计时器。然后，`Subscriber`应该尝试将某个字符串转换为数字。`numbers.txt`文件将用于构建此应用程序。在这个例子中，我们还将展示如何使用Supplier实现来清理数据处理，以使数据源抽象化。
- en: 'The `numbers.txt` file contains intentional errors that we will handle by applying
    a processor before the subscriber:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`numbers.txt`文件包含故意引入的错误，我们将在`Subscriber`之前应用处理器来处理这些错误：'
- en: Open the `Chapter17` project in IDEA if it's not already opened.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`Chapter17`项目尚未打开，请将其在IDEA中打开。
- en: Create a new Java class, using the `File` | `New` |`Java Class` menu.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`File` | `New` | `Java Class`菜单创建一个新的Java类。
- en: In the `Create New Class` dialog, enter `Exercise2` as `Name`, and select `OK`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`创建新类`对话框中，将`Name`设置为`Exercise2`，然后选择`OK`。
- en: 'IntelliJ will create your new class. It should look something like the following
    snippet:'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: IntelliJ将创建你的新类。它应该看起来像以下代码片段：
- en: '[PRE19]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add a `main` method to this class:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向此类添加一个`main`方法：
- en: '[PRE20]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We will continue using the basic `SubmissionPublisher` supplied in the Flow
    library, but in this exercise, we''ll create our own subclass. Create a new class
    called `NumberPublisher`. This should extend `SubmissionPublisher`, as shown in
    the following code block:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将继续使用Flow库中提供的基本`SubmissionPublisher`，但在本练习中，我们将创建自己的子类。创建一个名为`NumberPublisher`的新类。它应该扩展`SubmissionPublisher`，如下面的代码块所示：
- en: '[PRE21]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Our new `NumberPublisher` should publish numbers periodically to any interested
    `Subscriber`. There are several different options in terms of how to accomplish
    this, but probably the easiest solution is to use a `Timer`. Add a `Timer`, and
    a `TimerTask` to your publisher:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的新 `NumberPublisher` 应该定期向任何感兴趣的 `Subscriber` 发布数字。在如何实现这一点方面有几个不同的选项，但可能最简单的解决方案是使用
    `Timer`。向你的发布者添加一个 `Timer` 和一个 `TimerTask`：
- en: '[PRE22]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When the publisher is shutting down, so should `Timer`. Override the publisher''s
    `close()` method, and add a call to the `cancel()` method of `Timer` just before
    the publisher is about to shut down:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当发布者关闭时，`Timer` 也应该关闭。覆盖发布者的 `close()` 方法，并在发布者即将关闭之前调用 `Timer` 的 `cancel()`
    方法：
- en: '[PRE23]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There are two different ways to let the publisher send items to the connected
    subscribers. Using either `submit()` or `offer()`. `submit()` works in a fire-and-forget
    fashion, while `offer()` lets the publisher retry sending the item once using
    a handler. In our case, `submit()` would work just fine. But, before you can submit,
    you need some data. Add a `Supplier` to the `Publisher` using dependency injection:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有两种不同的方式让发布者向连接的订阅者发送项目。使用 `submit()` 或 `offer()`。`submit()` 以“发射并遗忘”的方式工作，而
    `offer()` 允许发布者使用处理程序重试发送项目一次。在我们的情况下，`submit()` 就足够好了。但在提交之前，你需要一些数据。使用依赖注入向
    `Publisher` 添加一个 `Supplier`：
- en: '[PRE24]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: A supplier is a functional interface that is often used to deliver results –
    to anyone and anything.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 供应商是一个常用于传递结果的功能式接口——向任何人或任何事物传递。
- en: 'Now that we know how to get the data we need using `Supplier`, we can actually
    send it to the subscribers. Inside the `run()` method of `TimerTask`, add a call
    to `submit()` and get the data from the supplier:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们知道了如何使用 `Supplier` 获取所需的数据，我们实际上可以将其发送给订阅者。在 `TimerTask` 的 `run()` 方法中，添加对
    `submit()` 的调用并从供应商获取数据：
- en: '[PRE25]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'One last thing remains, because the publisher may run into trouble when attempting
    to either get items from the supplier or send items onward. We need to catch any
    exception when attempting to execute the `submit()` method. Add a try-catch clause,
    and use a `closeExceptionally()` method to inform any subscriber that we ran into
    difficulty. Executing `closeExceptionally()` will force the publisher into a state
    where it cannot send anything else out:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后还有一件事，因为发布者在尝试从供应商获取项目或继续发送项目时可能会遇到麻烦。我们需要在尝试执行 `submit()` 方法时捕获任何异常。添加一个
    try-catch 子句，并使用 `closeExceptionally()` 方法通知任何订阅者我们遇到了困难。执行 `closeExceptionally()`
    将迫使发布者进入一个无法发送任何其他内容的状态：
- en: '[PRE26]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, `TimerTask` is fully implemented. The data is injected into `Publisher`
    using `Supplier`, and shutdown handling is ready. All that remains to do is to
    actually schedule periodic publishing. Using `Timer`, schedule `TimerTask` for
    repeat execution every 1 second. Since `TimerTask` accepts only milliseconds,
    we need to remember to multiply the delay by `1000`. We''re also setting the initial
    delay to `1000` milliseconds:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`TimerTask` 已经完全实现。数据通过 `Supplier` 注入到 `Publisher` 中，并且关闭处理已经就绪。剩下要做的只是实际安排定期发布。使用
    `Timer`，每秒重复执行 `TimerTask`。由于 `TimerTask` 只接受毫秒，我们需要记住将延迟乘以 `1000`。我们还设置了初始延迟为
    `1000` 毫秒：
- en: '[PRE27]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now that our `NumberPublisher` is ready, we need to start feeding it data, but
    in order to feed it the data that should be published, we need to load the data.
    The data we're going to send is located in the `numbers.txt` file. Copy the `numbers.txt`
    file to the `/res` folder, creating the folder if it doesn't already exist.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们的 `NumberPublisher` 已经准备好了，我们需要开始向它提供数据，但为了提供应该发布的数据，我们需要加载数据。我们将发送的数据位于
    `numbers.txt` 文件中。将 `numbers.txt` 文件复制到 `/res` 文件夹，如果文件夹不存在则创建它。
- en: 'In the `Exercise2` class, create a new method called `getStrings()`, which
    will return the numbers from the `numbers.txt` file as `Strings`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Exercise2` 类中，创建一个名为 `getStrings()` 的新方法，该方法将返回 `numbers.txt` 文件中的数字作为 `Strings`：
- en: '[PRE28]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In this new method, create a variable called `filePath`. Let it point to the
    `numbers.txt` file, located in the `/res` folder. We will use this `filePath`
    variable to load the file contents in the next step:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个新方法中，创建一个名为 `filePath` 的变量。让它指向位于 `/res` 文件夹中的 `numbers.txt` 文件。我们将使用这个 `filePath`
    变量在下一步加载文件内容：
- en: '[PRE29]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Load the file contents into a `String` stream, and then wrap the load in a
    try-with-resources block so that we don''t need to care about releasing the file
    resources when we''re done:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件内容加载到 `String` 流中，然后使用 try-with-resources 块包装加载操作，这样我们就不需要在完成时关心释放文件资源：
- en: '[PRE30]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `numbers.txt` file contains lots of numbers and some other characters that
    might cause trouble later on. But, in order to actually decode the file to single
    words, we need to review the structure of the file. Let''s open it, and you should
    see something like this—multiple rows with a column-like structure:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`numbers.txt`文件包含很多数字和一些可能后来引起麻烦的其他字符。但是，为了实际上解码文件到单个单词，我们需要审查文件的结构。让我们打开它，你应该会看到类似这样的内容——多行具有类似列的结构：'
- en: '[PRE31]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The stream of strings we''ve just loaded will not be of much help. Each item
    in the stream will represent a whole line, and we need to transform the stream
    before it will be useful to us. First of all, apply a `flatMap` operator to create
    a new stream for each item in the original stream. This will let us split each
    line up into multiple items, and return them to the main stream:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们刚刚加载的字符串流不会很有帮助。流中的每个项目将代表一行，我们需要在它对我们有用之前对其进行转换。首先，应用一个`flatMap`操作符来为原始流中的每个项目创建一个新的流。这将使我们能够将每一行拆分成多个项目，并将它们返回到主流中：
- en: '[PRE32]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You can read more about processing data with Streams in *Chapter 15*, *Processing
    Data with Streams*, and regular expressions in *Chapter 12*, *Regular Expressions*.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在第15章“使用流处理数据”和第12章“正则表达式”中了解更多关于使用流处理数据的信息。
- en: 'The stream now contains items representing each column for each line. But,
    in order to use the data, we need to filter it based on length as we don''t want
    any `0` length words, and then we need to turn the stream into an array of strings.
    Filter the items of the stream, allowing only words with a length in excess of
    `0` to pass:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 流现在包含代表每一行的每一列的项目。但是，为了使用这些数据，我们需要根据长度进行过滤，因为我们不希望有任何长度为`0`的单词，然后我们需要将流转换成一个字符串数组。过滤流的项目，只允许长度超过`0`的单词通过：
- en: '[PRE33]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, turn the whole stream into an array of strings. This will return an array
    of strings to the caller of the method. However, if we do have an error in reading
    the file, we need to return something too. Return `null` at the very end of the
    `getStrings()` method. The publisher will interpret `null` as an error and throw
    `NullPointerException`, closing the connection to the subscriber:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将整个流转换成一个字符串数组。这将返回一个字符串数组给方法的调用者。然而，如果我们读取文件时出现错误，我们也需要返回一些内容。在`getStrings()`方法的最后返回`null`。发布者会将`null`解释为错误并抛出`NullPointerException`，关闭与订阅者的连接：
- en: '[PRE34]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The data for our little program is ready for pushing into the publisher so
    that it can send it to any interested subscriber. Now, we need to build a supplier
    that will take these strings and send them to the publisher, one by one, when
    the publisher requests them. Create a supplier in the `main` method of the `Exercise2`
    class:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们小程序的数据已经准备好推送到发布者，以便它可以发送给任何感兴趣的订阅者。现在，我们需要构建一个供应商，它将接受这些字符串，并在发布者请求时逐个将它们发送给发布者。在`Exercise2`类的`main`方法中创建一个供应商：
- en: '[PRE35]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let the Supplier call `getStrings()` to retrieve the full array:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让供应商调用`getStrings()`来检索完整的数组：
- en: '[PRE36]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The supplier, however, cannot return the entire dataset; it is designed to
    return one string at a time. For this to work, we need to keep an index of the
    last string sent to `Supplier`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，供应商不能返回整个数据集；它被设计为一次返回一个字符串。为了使这起作用，我们需要保留发送到`Supplier`的最后一个字符串的索引：
- en: '[PRE37]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This will constantly return the first number in the file, and that''s not what
    we want. So, we need to increment the index every time someone asks the supplier
    for a string:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将不断返回文件中的第一个数字，而这不是我们想要的。因此，我们需要在有人请求供应商字符串时每次递增索引：
- en: '[PRE38]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This, however, will throw an exception when we reach the final number in the
    file. So, we need to protect against that. In this case, we''ll return `null`
    when we reach the end. Add an `if` statement, checking that we haven''t gone too
    far:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，当我们达到文件中的最后一个数字时，这会抛出一个异常。因此，我们需要对此进行保护。在这种情况下，当我们到达末尾时，我们将返回`null`。添加一个`if`语句，检查我们是否走得太远：
- en: '[PRE39]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The supplier is now ready to be used by our `NumberPublisher`. Create an instance
    of `NumberPublisher` in the `main()` method of `Exercise2`, passing the supplier
    as an argument:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 供应商现在可以由我们的`NumberPublisher`使用了。在`Exercise2`的`main()`方法中创建一个`NumberPublisher`实例，并将供应商作为参数传递：
- en: '[PRE40]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create a Subscriber and allow it to request an item on subscription success.
    Then, request a new item every time it receives an item—backpressure. While implementing
    the subscriber, add printouts for every method so that we can easily see what''s
    happening:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个订阅者，并允许它在订阅成功时请求一个项目。然后，每次它接收到一个项目时请求一个新的项目——背压。在实现订阅者时，为每个方法添加打印输出，这样我们就可以轻松地看到发生了什么：
- en: '[PRE41]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Running this code, you should get an output to the console, and the entire
    file should print:'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行此代码，你应该在控制台得到输出，整个文件应该打印：
- en: '[PRE42]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'However, in the subscriber, we expect to get data we can easily transform into
    integers. If we apply simple integer parsing to the text, we''ll end up in trouble:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，在订阅者中，我们期望得到可以轻松转换为整数的数据。如果我们对文本应用简单的整数解析，我们最终会遇到麻烦：
- en: '[PRE43]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This will stop, with a parse exception, when reaching the second item, `2e`,
    which, of course, is not an integer:'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在到达第二个项目 `2e` 时停止，抛出一个解析异常，显然，这并不是一个整数：
- en: '[PRE44]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: To rectify the problem with the broken subscriber, you can, of course, catch
    the exception right there. But, in this exercise, we will involve a filter processor
    in the mix. `Processor` will subscribe to `Publisher`, and `Subscriber` will subscribe
    to `Processor`. In essence, `Processor` is both a Publisher and a Subscriber.
    To make this simple for us, allow `NumberProcessor` to extend `SubmissionPublisher`,
    just like `NumberPublisher` does.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了纠正有问题的订阅者的问题，你当然可以在那里捕获异常。但在这个练习中，我们将涉及一个过滤器处理器。`Processor` 将订阅 `Publisher`，而
    `Subscriber` 将订阅 `Processor`。本质上，`Processor` 既是发布者也是订阅者。为了让我们更容易理解，允许 `NumberProcessor`
    扩展 `SubmissionPublisher`，就像 `NumberPublisher` 一样。
- en: '![Figure 17.2: Communication between the Subscriber, the Processor, and the
    Publisher'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 17.2：订阅者、处理器和发布者之间的通信'
- en: '](img/C13927_17_02.jpg)'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/C13927_17_02.jpg](img/C13927_17_02.jpg)'
- en: 'Figure 17.2: Communication between the Subscriber, the Processor, and the Publisher'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 17.2：订阅者、处理器和发布者之间的通信
- en: 'Create a class called `NumberProcessor`, allow it to extend `SubmissionPublisher`,
    and implement the `Flow.Processor` interface:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `NumberProcessor` 的类，允许它扩展 `SubmissionPublisher` 并实现 `Flow.Processor`
    接口：
- en: '[PRE45]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`NumberProcessor` will subscribe to `NumberPublisher`, and, just like the subscriber,
    it needs to store a reference to the publisher so that it can control when to
    request new items. Store the reference received in `onSubscribe()` as a private
    field in the processor. Also, take this opportunity to request the first item
    from the publisher:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`NumberProcessor` 将订阅 `NumberPublisher`，就像订阅者一样，它需要存储对发布者的引用，以便它可以控制何时请求新项目。将
    `onSubscribe()` 中接收到的引用存储在处理器中的私有字段中。同时，利用这个机会从发布者那里请求第一个项目：'
- en: '[PRE46]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Whenever you receive an item from the publisher, you need to also request the
    next item, just like the subscriber would:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次从发布者接收项目时，你也需要请求下一个项目，就像订阅者一样：
- en: '[PRE47]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If the subscription to `NumberPublisher` is closed, we also need to inform
    the subscriber that there was a problem. Likewise, we need to inform the subscriber
    when the subscription ended. In the `onError()` callback, add a call to `closeExceptionally()`,
    and, in `onComplete()`, add a call to `close()`:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `NumberPublisher` 的订阅被关闭，我们还需要通知订阅者存在问题。同样，当订阅结束时，我们也需要通知订阅者。在 `onError()`
    回调中，添加对 `closeExceptionally()` 的调用，并在 `onComplete()` 中添加对 `close()` 的调用：
- en: '[PRE48]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The processor is almost done. The one thing that is missing is communicating
    the received items back to the subscriber. We will do this in the `onNext()` callback
    method. However, since we know that there may be invalid values, we want to filter
    those. We''ll use a predicate for this, declaring a predicate to the `NumberProcessor`
    class:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理器几乎完成了。唯一缺少的是将接收到的项目传达给订阅者。我们将在 `onNext()` 回调方法中这样做。然而，由于我们知道可能存在无效的值，我们想要过滤掉这些值。我们将为此使用一个谓词，在
    `NumberProcessor` 类中声明一个谓词：
- en: '[PRE49]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The predicate is a simple functional interface that is used to verify the input
    using a `test()` method. The `test()` method should always return `true` if the
    value was acceptable, or `false` if it was faulty. In our predicate, we will attempt
    to parse the string supplied. If the parsing is successful, we will return true;
    otherwise, we will return `false`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 谓词是一个简单的函数式接口，它使用 `test()` 方法来验证输入。如果值是可接受的，则 `test()` 方法应始终返回 `true`；如果值有误，则返回
    `false`。在我们的谓词中，我们将尝试解析提供的字符串。如果解析成功，我们将返回 `true`；否则，返回 `false`：
- en: '[PRE50]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Back in the `onNext()` callback, we can now use our predicate to verify the
    value supplied before we submit it to the subscribers:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onNext()` 回调中，我们现在可以使用我们的谓词来验证在提交给订阅者之前提供的值：
- en: '[PRE51]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You can read more about predicates and how to use them in *Chapter 16*, *Predicates
    and Other Functional Interfaces*.
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在*第16章*，*谓词和其他功能接口*中了解更多关于谓词及其使用方法的信息。
- en: 'Now that your `Processor` is ready, inject it between `NumberPublisher` and
    `Subscriber`:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在既然你的`Processor`已经准备好了，就在`NumberPublisher`和`Subscriber`之间注入它：
- en: '[PRE52]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'After running this example, you should see that the processor filters the faulty
    number values from the file before they reach the subscriber:'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行此示例后，你应该看到处理器在值到达订阅者之前从文件中过滤掉错误数值：
- en: '[PRE53]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This example shows how to take content from a publisher and pass it through
    a processor to ensure that the values are valid.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了如何从出版商那里获取内容，并通过处理器确保值的有效性。
- en: 'Activity 1: Let NumberProcessor Format Values as Integers'
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动1：让NumberProcessor将值格式化为整数
- en: Improve `NumberProcessor` further. Let it not only verify that the values can
    be parsed as integers, but also publish them to the subscriber as integers. The
    subscriber should only accept integer values, and no longer need to parse the
    received values.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步改进`NumberProcessor`。让它不仅验证值可以被解析为整数，而且将它们作为整数发布给订阅者。订阅者应仅接受整数值，不再需要解析接收到的值。
- en: Change the processors published item type to Integer. Make the necessary changes
    in the implementation to match the new type.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将处理器发布的项类型更改为Integer。在实现中做出必要的更改以匹配新类型。
- en: Change the subscriber for the processor, it should accept only Integer values
    in the `onNext` method.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改处理器的订阅者，它应在`onNext`方法中仅接受整数值。
- en: Note
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 568.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第568页找到。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you've learned the basics of Reactive Streams components, how
    they communicate, and their respective roles in a reactive application.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了响应式流组件的基础知识，它们如何通信，以及它们在响应式应用程序中的相应角色。
- en: In most cases, you should avoid using the Flow API to build reactive applications
    as there are much more advanced and user-friendly reactive libraries available
    out there. The Flow API provides only the basic building blocks for reactive applications,
    while implementations such as Akka or RxJava will give you a richer experience,
    providing essential functionality such as throttling, filtering, and debouncing,
    to name a few. If you're interested in delving further into reactive programming,
    there are entire books devoted to the subject.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你应该避免使用Flow API构建响应式应用程序，因为那里有更多高级且用户友好的响应式库可用。Flow API仅提供响应式应用程序的基本构建块，而像Akka或RxJava这样的实现将为你提供更丰富的体验，提供诸如节流、过滤和去抖动等基本功能。如果你对深入响应式编程感兴趣，有整本书都是关于这个主题的。
- en: As mentioned before, Flow provides the basis for building your own Reactive
    Streams library, however complex that may be. Should you wish to implement a Reactive
    Streams library of your own, you should start by reviewing the Reactive Streams
    Technology Compatibility Kit. This test-based kit will help you to ensure that
    your implementation follows the Reactive Streams rules.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Flow为构建自己的响应式流库提供了基础，尽管这可能很复杂。如果你希望实现自己的响应式流库，你应该首先审查响应式流技术兼容性套件。这个基于测试的套件将帮助你确保你的实现遵循响应式流规则。
- en: After the next chapter, which focuses on unit testing, you should be all set
    to start looking at the compatibility kit and build your own Reactive Streams
    library.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，专注于单元测试之后，你应该准备好开始查看兼容性套件并构建自己的响应式流库。
