- en: Deploying Applications on the Cloud with OpenShift
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenShift在云上部署应用程序
- en: In the previous chapters, we showed you how to develop microservices with WildFly
    Swarm. In this chapter, you will learn how to deploy those services to the cloud,
    and you will use OpenShift to achieve that. However, why should we bother? What
    are the features and benefits of cloud computing? Let's start by saying a few
    words about it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们向您展示了如何使用WildFly Swarm开发微服务。在本章中，您将学习如何将这些服务部署到云端，并且您将使用OpenShift来实现这一点。然而，为什么我们要费这个功夫呢？云计算有哪些特性和好处？让我们先简单谈谈。
- en: Before we move on to the next section, you need to be provided with some important
    information. This chapter describes a lot of theoretical concepts that explain
    the internals of OpenShift. Don't worry if some of those concepts sound too complex
    to configure because (spoiler alert!), in the end, OpenShift will do most of the
    stuff for you. The goal of this chapter is to provide you with knowledge, which
    will allow you to understand all the magic that OpenShift can do, and. In later
    chapters, modify, and reconfigure that behavior. So, let's begin.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入下一节之前，您需要了解一些重要信息。本章描述了许多理论概念，解释了OpenShift的内部机制。如果有些概念听起来太复杂而难以配置，请不要担心，因为（剧透警告！），最终OpenShift会为您做大部分工作。本章的目标是提供知识，让您能够理解OpenShift能做的所有魔法，并在后面的章节中修改和重新配置这种行为。那么，让我们开始吧。
- en: Cloud computing
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云计算
- en: OK. Let's start at the beginning. So, what actually is cloud computing?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。让我们从头开始。那么，云计算到底是什么呢？
- en: Cloud computing is an IT paradigm that advocates the use of shared pools of
    configurable resources and services provided over the internet. Those services
    are provided on demand, rapidly, and with minimal management. As a result, cloud
    computing allows for flexible architecture, optimized resource usage, and the
    possibility of decoupling the infrastructure provider from a consumer, enabling
    the separation of concerns. Let's examine those statements in greater detail.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算是一种IT范式，它提倡使用通过互联网提供的可配置资源和服务共享池。这些服务按需、快速且管理成本最小化地提供。因此，云计算允许灵活的架构、优化的资源使用，以及将基础设施提供商与消费者分离的可能性，从而实现关注点的分离。让我们更详细地检查这些声明。
- en: Resources provisioned on demand give you, as a developer or an architect, flexibility
    in configuring your technical infrastructure. Starting the project is cheap, as
    you don't have to begin with infrastructure investments. Also, when your project
    is in production, computing resources may be scaled automatically to fill your
    application's demands. In each case, you are paying only for the resources used.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 按需提供的资源使您作为开发者或架构师在配置技术基础设施方面具有灵活性。开始项目成本低，因为您不需要从基础设施投资开始。此外，当您的项目投入生产时，计算资源可以自动扩展以满足应用程序的需求。在每种情况下，您只需为使用的资源付费。
- en: Furthermore, cloud computing introduces the separation of concerns. The cloud
    provider becomes specialized in provisioning the infrastructure. The developers
    are provided with the interface of the cloud infrastructure and will use it for
    the development. As a result, they don't need to be concerned with the details
    of the infrastructure configuration as long as they comply with the interface
    provided by the cloud. Cloud providers, on the other hand, have to compete to
    provide the most convenient and robust cloud infrastructure while minimizing the
    costs.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，云计算引入了关注点的分离。云服务提供商变得专业于提供基础设施。开发者被提供了云基础设施的接口，并将用它来进行开发。因此，只要他们遵守云提供的接口，他们就不需要关心基础设施配置的细节。另一方面，云服务提供商必须竞争以提供最方便和最稳健的云基础设施，同时尽量降低成本。
- en: 'Throughout this chapter, we will describe the cloud interface provided by OpenShift.
    Before that, we will describe the following two cloud infrastructure characteristics,
    which will enable the use of a consistent set of concepts during the following
    chapters: deployment and service models. Let''s start with the first one.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将描述OpenShift提供的云接口。在此之前，我们将描述以下两个云基础设施特性，这将使在接下来的章节中使用一致的概念集成为可能：部署和服务模型。让我们从第一个开始。
- en: The cloud infrastructure deployment model
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云基础设施部署模型
- en: The cloud deployment model specifies how cloud infrastructure is organized.
    Let's look at commonly used models.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 云部署模型指定了云基础设施的组织方式。让我们看看常用的模型。
- en: The public cloud
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公共云
- en: The **public cloud** is a model in which services are provided over a network
    for public usage.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**公共云**是一种在网络上提供服务的模型，供公众使用。'
- en: 'Public cloud computing is sometimes described as an evolution of computing
    resources into utility such as electricity. Using the example of a power provider
    may give you an alternative insight into the topics described in this paragraph:
    the power distribution company is responsible, among other, for ensuring that
    the network can deal with demand peaks, or provide network redundancy in case
    of traction breakdown. However, in the end, we don''t think about it too much—we
    insert the plug into the socket when needed and get billed only for electricity
    we used.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 公共云计算有时被描述为计算资源向类似电力的公用事业演变。使用电力供应商的例子可能会给你对这个段落中描述的主题提供另一种见解：电力分配公司负责确保网络能够处理需求高峰，或者在牵引中断的情况下提供网络冗余。然而，最终，我们并不会过多地考虑这些——当我们需要时，我们会把插头插入插座，并且只为我们使用的电量付费。
- en: We shouldn't stretch that analogy too far though. Computing resources are obviously
    not a commodity like electricity, and they cannot be provided to everyone in a
    uniform manner because of different customer requirements.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应该过分夸大这个类比。计算资源显然不是像电力那样的商品，由于客户需求的不同，它们不能以统一的方式提供给每个人。
- en: First of all, not all customers are able, for various reasons, to move their
    workloads to the public cloud. One of the reasons may be the need for a higher
    level of security or greater control over the architecture. Such customers can
    take advantage of the private cloud discuss it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，由于各种原因，并非所有客户都能将他们的工作负载迁移到公共云。其中一个原因可能是需要更高层次的安全或对架构有更大的控制。这样的客户可以利用我们讨论的私有云。
- en: The private cloud
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 私有云
- en: In the **private cloud**, the computing resources used to create the cloud are
    dedicated to a single customer. The resources may be located on-site or off-site,
    owned by the customer, or managed by a third party. All of the resources are provisioned
    for a single client and are not shared by multiple clients. Such a configuration
    allows for greater control and security but requires the company to invest in
    and manage the cloud resources, removing the decoupling benefit of the public
    cloud.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在**私有云**中，用于创建云的计算机资源仅专用于单个客户。这些资源可能位于现场或异地，由客户拥有，或由第三方管理。所有资源都为单个客户配置，不会与其他客户共享。这种配置允许有更大的控制和安全，但要求公司投资并管理云资源，从而消除了公共云解耦的好处。
- en: The hybrid cloud
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合云
- en: The **hybrid cloud** is a model in which public and private clouds are connected
    together. As a result, you can take advantage of both solutions. For example,
    you can run services that deal with sensitive data on the private cloud, but use
    the public cloud to scale other services.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**混合云**是一种将公共云和私有云连接在一起的模式。因此，你可以利用这两种解决方案的优势。例如，你可以在私有云上运行处理敏感数据的业务，但使用公共云来扩展其他服务。'
- en: We would like our cloud provider to provide cloud abstraction that will enable
    users to see a homogeneous cloud view, abstracting away the infrastructure details
    of the hybrid cloud. We will return to this thought later, when we describe the
    architecture of OpenShift.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的云服务提供商提供云抽象，使用户能够看到一个统一的云视图，抽象出混合云的基础设施细节。我们将在描述OpenShift架构时回到这个想法。
- en: Let's now focus on another cloud characteristic, that is, the **service model**.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们关注另一个云特性，那就是**服务模型**。
- en: The service model
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务模型
- en: As you learned at the beginning of this chapter, the cloud provider is responsible
    for providing computing resources on demand. Computing resources can be provisioned
    in different ways, and characterized by different levels of abstraction. This
    feature of cloud computing infrastructure is called a service model. Let's describe
    the commonly used models.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本章开头所学的，云服务提供商负责按需提供计算资源。计算资源可以通过不同的方式配置，并具有不同级别的抽象。云计算基础设施的这个特性被称为服务模型。让我们描述一下常用的模型。
- en: Infrastructure as a Service
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设施即服务
- en: In **Infrastructure as a Service** (**IaaS**), a customer is able to install
    arbitrary applications (including operating systems) on the provisioned resources.
    The customer does not control the infrastructure that is provided by the cloud
    provider. For example, the customer may get access to a remote virtual machine,
    which they can fully operate.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在**基础设施即服务**（**IaaS**）中，客户能够在提供的资源上安装任意应用程序（包括操作系统）。客户不控制云提供商提供的基础设施。例如，客户可能能够访问一个远程虚拟机，他们可以完全操作。
- en: Platform as a Service
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平台即服务
- en: In **Platform as a Service** (**PaaS**), as its name suggests, the cloud provider
    is responsible for providing the customer with a ready-for-use the platform on
    which the customer can deploy and run their applications. Let's suppose that you
    want to use the database. In this case, the platform provider is responsible for
    giving you access to an up-to-date and configured database on which you can start
    working immediately. You don't have to mess with the entire configuration, and
    can start working with the database (or any other technology; WildFly Swarm, for
    example) straightaway.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在**平台即服务**（**PaaS**）中，正如其名所示，云提供商负责向客户提供现成的平台，客户可以在该平台上部署和运行他们的应用程序。假设你想使用数据库。在这种情况下，平台提供商负责为你提供一个最新且配置好的数据库，你可以在上面立即开始工作。你不必处理整个配置，可以直接与数据库（或任何其他技术；例如WildFly
    Swarm）开始工作。
- en: Software as a Service
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件即服务
- en: Finally, there is **Software as a Service** (**SaaS**). In this model, the customer
    is able to use the application provided by the cloud provider. An example of SaaS
    may be disc storage, email, or an office suite provided over the internet.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有**软件即服务**（**SaaS**）。在这个模型中，客户能够使用云提供商提供的应用程序。SaaS的一个例子可能是通过互联网提供的磁盘存储、电子邮件或办公套件。
- en: OK, now that we've clarified the nomenclature, we can finally dig into OpenShift
    architecture.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们已经明确了术语，我们最终可以深入研究OpenShift架构。
- en: The OpenShift architecture
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenShift架构
- en: So far, we have been talking in abstract terms. In this section, we will give
    you an overview of the OpenShift architecture. As a result, you will gain a practical
    understanding of the functioning cloud PaaS infrastructure.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在用抽象的术语进行讨论。在本节中，我们将为您概述OpenShift架构。结果，您将获得对功能云PaaS基础设施的实际理解。
- en: 'Let''s start with a bird''s-eye view architecture diagram:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一张俯瞰的架构图开始：
- en: '![](img/7a028067-a462-464b-b063-d3b65ab55eb6.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7a028067-a462-464b-b063-d3b65ab55eb6.png)'
- en: The preceding diagram sketches the layers of OpenShift architecture. **Docker**
    runs on top of the operating system and provides layers of containers. Containers
    are lightweight, standalone, and executable pieces of software (*Further reading*,
    link 2) that can be run anywhere on the cloud. Those containers are orchestrated
    by **Kubernetes**, which provides a unified view of heterogeneous computing resources.
    Finally, **OpenShift** builds on top of **Kubernetes**, providing developer tools
    that automate most configuration tasks. If this short description sounded cryptic
    to you, don't worry. Everything will be clear by the end of this chapter. Let's
    start with containers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表概述了OpenShift架构的层级。**Docker**运行在操作系统之上，提供容器层。容器是轻量级、独立且可执行的软件组件（*进一步阅读，链接2*），可以在云的任何地方运行。这些容器由**Kubernetes**编排，它提供了异构计算资源的统一视图。最后，**OpenShift**建立在**Kubernetes**之上，提供开发者工具，自动化大多数配置任务。如果这个简短的描述让你感到困惑，不要担心。到本章结束时，一切都会变得清晰。让我们从容器开始。
- en: Containerization
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器化
- en: As we said before, in cloud computing, the cloud provider is responsible for
    providing the server resources to users on demand. However, what does that actually
    mean? How are those resources provided? How is the server with all the necessary
    configurations created, and how it is isolated from other users? To understand
    this, we must understand how containers work.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所说，在云计算中，云提供商负责根据用户需求提供服务器资源。然而，这实际上意味着什么？这些资源是如何提供的？如何创建带有所有必要配置的服务器，以及它是如何与其他用户隔离的？为了理解这一点，我们必须了解容器是如何工作的。
- en: Containers are basically a type of **virtualization**. Let's discuss this concept.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 容器基本上是一种**虚拟化**。让我们讨论这个概念。
- en: Virtualization
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟化
- en: Virtualization is a technology that allows the running of many isolated virtual
    machines on one server. A virtual machine is an emulation of a computer system
    governed by the virtualization application running on the server's operating system.
    The user to whom the virtual machine has been provisioned has access to the fully
    operational host. The fact that the host is not physical, and that it shares the
    resources of the physical server with other virtual machines, is being abstracted
    away from the user.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟化是一种技术，它允许在一台服务器上运行多个隔离的虚拟机。虚拟机是服务器操作系统上运行的虚拟化应用程序所控制的计算机系统的模拟。虚拟机分配给用户的用户可以访问完全运行的宿主机。宿主机不是物理的，并且与其他虚拟机共享物理服务器的资源，这一点对用户来说是抽象的。
- en: Another key feature of virtualization is the ability to serialize the virtual
    machine into the image. This feature enables portability. The image can be moved
    to different servers, thus ensuring that the state of the virtual machine will
    be preserved.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟化的另一个关键特性是将虚拟机序列化为镜像的能力。这一特性使得虚拟机具有可移植性。镜像可以被移动到不同的服务器上，从而确保虚拟机的状态得以保留。
- en: Why is virtualization important to the cloud provider, then?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么虚拟化对云服务提供商来说很重要呢？
- en: Firstly, the cloud provider is able to provide access to the virtual machine
    to the user. As a result, the user will obtain access to a fraction of server
    resources. From the user's perspective, they will have access to the isolated
    server
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，云服务提供商能够向用户提供虚拟机的访问权限。因此，用户将获得服务器资源的一部分。从用户的角度来看，他们将能够访问一个隔离的服务器
- en: Secondly, the user has the ability to use a preconfigured image of the platform
    that they want to use. Do you need Fedora with WildFly AS? Here is your configured
    image. We will run it on our server, and you are ready to go.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，用户可以使用他们想要使用的平台的预配置镜像。你需要带有WildFly AS的Fedora吗？这里就是你的配置好的镜像。我们将在我们的服务器上运行它，你就可以开始了。
- en: Thirdly, the cloud provider is able to optimize the resource usage. There can
    be many virtual machines running on one server, minimizing the idle time.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，云服务提供商能够优化资源使用。一个服务器上可以运行许多虚拟机，从而最小化空闲时间。
- en: Fourthly, Virtual machines can be moved freely between different servers when
    necessary. If more resources are needed, some virtual machines can be transferred
    to another server. Again, from the user's point of view, you will have access
    to an isolated preconfigured server and won't have to worry about the details.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第四，当需要时，虚拟机可以在不同的服务器之间自由移动。如果需要更多资源，可以将一些虚拟机转移到另一个服务器。再次从用户的角度来看，您将能够访问一个隔离的预配置服务器，而无需担心细节。
- en: Then, what about the implementation?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，关于实现方面呢？
- en: Some of you may identify virtualization with hardware (of full) virtualization.
    In this architecture, the virtualization application is responsible for emulating
    the whole operating system with all the necessary processes and libraries.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你们中的一些人可能将虚拟化与硬件（全）虚拟化联系起来。在这种架构中，虚拟化应用程序负责模拟整个操作系统，包括所有必要的进程和库。
- en: This solution has some performance problems, most of them resulting from the
    fact that the operating system was initially designed to run on a physical host.
    Firstly, to start the virtual machine the whole OS has to be started and, as a
    result, the startup time may be substantial (minutes). Secondly, OS processes
    and libraries have to be duplicated in each virtual machine, which leads to non-optimal
    resources usage.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案存在一些性能问题，其中大部分是由于操作系统最初是为在物理主机上运行而设计的。首先，要启动虚拟机，整个操作系统都需要启动，因此启动时间可能会很长（几分钟）。其次，操作系统进程和库必须在每个虚拟机中重复，这导致资源使用非最优。
- en: Let's think about it from the cloud provider's perspective, taking special consideration
    of the microservices architecture that we described in [Chapter 1](77a69da4-3aff-46c3-aa00-fa4d02db5061.xhtml),
    *Java EE and Modern Architectural Methodologies*. We would like to have a solution
    that will enable us to provide a large number of ephemeral virtual machines. We
    would like to ensure that they can be started and stopped immediately, optimizing
    the use of resources, and store image data effectively. It turns out that we need
    another tool. Let's discuss containers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从云服务提供商的角度来考虑这个问题，特别考虑我们在[第1章](77a69da4-3aff-46c3-aa00-fa4d02db5061.xhtml)中描述的微服务架构，*Java
    EE和现代架构方法*。我们希望有一个解决方案，使我们能够提供大量短暂的虚拟机。我们希望确保它们可以立即启动和停止，优化资源使用，并有效地存储镜像数据。结果是我们需要另一个工具。让我们来讨论容器。
- en: Containers
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器
- en: Containers are the implementation of a system-level virtualization (or paravirtualization).
    In this kind of virtualization, the operating system is not emulated on each virtual
    machine. Instead, virtual machines share the same operating system instance, using
    the tools provided by it to achieve isolation. As a result, in this model, we
    can think of virtual machines as isolated user-space instances running on top
    of the same operating system. Such instances are called container.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是系统级虚拟化（或准虚拟化）的实现。在这种虚拟化中，操作系统不是在每个虚拟机上模拟。相反，虚拟机共享相同的操作系统实例，使用它提供的工具来实现隔离。因此，在这种模型中，我们可以将虚拟机视为在相同操作系统之上运行的隔离用户空间实例。这样的实例被称为容器。
- en: '![](img/d290ce5b-8edd-49c8-b9ce-f9e85d271b98.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d290ce5b-8edd-49c8-b9ce-f9e85d271b98.png)'
- en: The preceding diagram highlights the main differences between full virtualization
    and containers. Containers share the same operating system and, as you will learn
    in the next sections, are able to share common libraries effectively. In the preceding
    diagram, the horizontal line represents the layers that have to be created when
    the new virtual machine/container is created.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表突出了全虚拟化和容器之间的主要区别。容器共享相同的操作系统，正如您将在下一节中学习的，能够有效地共享公共库。在上述图表中，水平线代表在创建新的虚拟机/容器时必须创建的层。
- en: Before we describe the Docker implementation of containers, let's talk about
    the isolation tools that the Linux kernel provides.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们描述Docker容器的实现之前，让我们先谈谈Linux内核提供的隔离工具。
- en: Kernel isolation tools
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核隔离工具
- en: The Linux kernel provides a wide array of tools that enable the isolation of
    processes, and put a resource usage limit on those groups. The main tools that
    enable that (and are used by Docker containers) are namespaces (isolation), and
    `cgroups` (limits). Let's learn more about it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核提供了一系列工具，可以实现对进程的隔离，并对这些组设置资源使用限制。实现这一功能的主要工具（并被Docker容器使用）是命名空间（隔离）和`cgroups`（限制）。让我们更深入地了解它们。
- en: Namespaces
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间
- en: Each kernel process can be assigned to a namespace—processes with the same namespace
    share the same view some of the system resources. For example, a PID namespace
    provides the ability to isolate processes—processes in the same PID namespace
    can see each other, but cannot see processes from different namespaces.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 每个内核进程都可以分配到一个命名空间——具有相同命名空间的进程共享对一些系统资源的相同视图。例如，PID命名空间提供了隔离进程的能力——同一PID命名空间中的进程可以看到彼此，但不能看到来自不同命名空间的进程。
- en: There is a group of namespaces in Linux kernel that provides PID, network, mount
    point, and username isolation.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核中有一组命名空间，提供PID、网络、挂载点和用户名隔离。
- en: cgroups
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cgroups
- en: The `cgroups` are responsible for limiting the resource usage for the group
    of processes. `cgroups` allow you to assign processes to a number of groups and
    configure a resource quota for those groups. The resources that can be controlled
    are, among others, CPU, memory usage, network, and disk bandwidths. In the event
    of resource congestion, the `cgroups` mechanism will make sure that the group
    won't exceed its quota for that resource.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`cgroups`负责限制进程组的资源使用。`cgroups`允许您将进程分配到多个组中，并为这些组配置资源配额。可以控制的资源包括CPU、内存使用、网络和磁盘带宽。在资源拥堵的情况下，`cgroups`机制将确保该组不会超过该资源的配额。'
- en: In the case of containers, a group may be created for each container. As a result,
    we would be able to provide a quota for all of the containers. We may, for example,
    assign 1/5 of the CPU to one of the containers. This would guarantee that, in
    the case of a congestion, this container would have access to that amount of the
    CPU cycles. As a result, we are able to guarantee resource access. The `cgroups`
    limit is only enforced during the congestion. In our example, if all other containers
    are idle, the container that was assigned a fraction of CPU quota may use more
    CPU cycles.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器的情况下，可以为每个容器创建一个组。因此，我们可以为所有容器提供配额。例如，我们可以将CPU的1/5分配给其中一个容器。这将保证在拥堵的情况下，该容器可以访问相应数量的CPU周期。因此，我们能够保证资源访问。`cgroups`限制仅在拥堵期间生效。在我们的例子中，如果其他所有容器都处于空闲状态，分配了CPU配额分数的容器可能使用更多的CPU周期。
- en: The Docker implementation of containers
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker容器实现
- en: 'You have just learned that the Linux kernel provides tools that enable isolation
    of resources, laying the ground for the following the implementation of system-level
    virtualization. But we have to ask ourselves some questions: which applications
    will be run inside the container? Which libraries and files will be visible in
    individual containers?'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚了解到Linux内核提供了工具，这些工具能够实现资源的隔离，为以下系统级虚拟化的实现奠定了基础。但我们必须问自己一些问题：哪些应用将在容器内运行？哪些库和文件将在各个容器中可见？
- en: To answer these questions, we will introduce you to Docker images. As we have
    hinted at before, virtual machines in hardware virtualization can be stored as
    images, which make it possible to store the state of the virtual machine and,
    as a result, allow for the creation of reusable preconfigured virtual machines
    and portability.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这些问题，我们将向您介绍Docker镜像。正如我们之前所暗示的那样，在硬件虚拟化中，虚拟机可以存储为镜像，这使得存储虚拟机的状态成为可能，从而允许创建可重用的预配置虚拟机，并实现可移植性。
- en: 'The same feature concerns containers and the implementation that we will use:
    Docker. As you will learn in the following sections, this idea has been developed
    to a whole different level, providing us with an efficient and convenient image
    ecosystem and, as a result it, provides a base environment for our cloud infrastructure.
    However, let''s start at the beginning.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的特性也适用于容器及其实现方式：Docker。正如你将在接下来的章节中了解到的那样，这一理念已经被发展到全新的高度，为我们提供了一个高效便捷的镜像生态系统，因此它为我们的云基础设施提供了一个基础环境。然而，让我们从基础开始讲起。
- en: Images and containers
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 镜像和容器
- en: In Docker nomenclature, there is a distinction between an image and a container.
    An image is an immutable, unambiguously identifiable collection of files and metadata.
    A container, on the other hand, is a runtime instance of an image. There can be
    many container instances of the same image, each of which is mutable and has its
    own state.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker术语中，镜像和容器之间有一个区别。镜像是一个不可变、明确可识别的文件和元数据集合。另一方面，容器是镜像的运行时实例。同一个镜像可以有多个容器实例，每个实例都是可变的，并且具有自己的状态。
- en: Let's make it clear it with the help of an example. You can start a Fedora distribution
    in a container. To do so, you have to download and build a Fedora image. After
    the build, the image will be located on your machine and will contain the Fedora
    distribution. As we mentioned in the preceding paragraph, this image is an immutable
    template that can be used to start a container. When you start the container based
    on the Fedora image and log in to it, you will see that you have access to the
    bare Fedora distribution. You can, among other things, install software and create
    files there. When you do this, you modify only that specific container. If you
    run another container from the same Fedora image, you will again have access to
    the bare Fedora distribution.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来说明这一点。你可以在容器中启动Fedora发行版。为此，你必须下载并构建一个Fedora镜像。构建完成后，镜像将位于你的机器上，并包含Fedora发行版。正如我们在上一段中提到的，这个镜像是一个不可变的模板，可以用来启动容器。当你基于Fedora镜像启动容器并登录时，你会看到你能够访问裸露的Fedora发行版。你可以在那里安装软件和创建文件。当你这样做时，你只修改了那个特定的容器。如果你从同一个Fedora镜像运行另一个容器，你将再次能够访问裸露的Fedora发行版。
- en: The preceding example gives you a bird's-eye view of the behavior of containers
    and images. Let's now take a closer look at the architecture of both.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 上述例子为你提供了容器和镜像行为的鸟瞰图。现在，让我们更深入地了解两者的架构。
- en: Images are described by `Dockerfiles`. A `Dockerfile` is a text file, which
    contains a list of commands that instruct you on how to assemble an image.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像由 `Dockerfile` 描述。`Dockerfile` 是一个文本文件，其中包含一系列命令，指导您如何组装镜像。
- en: Images have a layered structure. The commands executed in a `Dockerfile` result
    in the creation of additional layers—every subsequent layer is different from
    the previous one.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像具有分层结构。在 `Dockerfile` 中执行的命令会导致创建额外的层——每个后续层都与前一个层不同。
- en: Every image must derive from another image (possibly, an explicitly empty *scratch*
    image), and it adds its layers on top of it. Image layers are built directly on
    top of the kernel code.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每个镜像都必须派生自另一个镜像（可能是显式为空的 *scratch* 镜像），并在其之上添加其层。镜像层直接建立在内核代码之上。
- en: Let's clarify all those concepts by taking a look at a practical example. We
    will create a bunch of simple images.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看一个实际示例来明确所有这些概念。我们将创建一些简单的镜像。
- en: 'Firstly, we will create a number of files in the local directory from which
    we will build the images:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从本地目录创建多个文件，然后我们将基于这些文件构建镜像：
- en: '![](img/4495867f-c8f7-4ee7-b602-fa939e73ef28.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4495867f-c8f7-4ee7-b602-fa939e73ef28.png)'
- en: 'Let''s create the first image now (note that we are aiming at architecture
    description; so, although we will briefly explain the commands used, refer to
    (Further reading, link 1) if you are interested in the details):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建第一个镜像（注意，我们旨在描述架构；因此，尽管我们将简要解释所使用的命令，但如果您对细节感兴趣，请参阅（进一步阅读，链接 1））：
- en: '[PRE0]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding `Dockerfile` represents the base image. It derives from the `centos:7`
    image, which is a bare Centos distribution, adds the `tomek` user (`#2`), and
    switches the previous user to `tomek` so that all subsequent commands will be
    run as this user (`#3`), therefore the directory from any further commands will
    be executed to `tomek`'s `homedir`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 `Dockerfile` 表示基础镜像。它派生自 `centos:7` 镜像，这是一个裸露的 Centos 发行版，添加了 `tomek` 用户（`#2`），并将之前的用户切换到
    `tomek`，以便所有后续命令都将以此用户身份运行（`#3`），因此任何后续命令的目录都将执行到 `tomek` 的 `homedir`。
- en: 'In order to build an image from `Dockerfile`, we have to execute the following
    command in the directory in which the image is located:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从 `Dockerfile` 构建镜像，我们必须在镜像所在目录中执行以下命令：
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding command, we have tagged the image as base. As a result, we
    are able to refer to it by its base name. Let''s move on to the second Dockerfile:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述命令中，我们已将镜像标记为 base。因此，我们可以通过其基础名称来引用它。让我们继续到第二个 Dockerfile：
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding image derives from the base image created before that. It copies
    directories `A` (`#2`) and `B` (`#3`) from our local filesystem to the image.
    Similarly, let''s build and tag the image:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 上述镜像派生自之前创建的基础镜像。它从我们的本地文件系统复制目录 `A`（`#2`）和 `B`（`#3`）到镜像中。同样，让我们构建并标记这个镜像：
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, take a look at the last image:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，看一下最后一个镜像：
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It derives from the middle image (`#1`) and copies the `C` directory (`#2`)
    from the local filesystem to the image.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 它从中间镜像（`#1`）派生，并将本地文件系统的 `C` 目录（`#2`）复制到镜像中。
- en: 'The following diagram presents the layers of the top image. We have included
    all the commands from the image hierarchy so that you can take a look at how the
    top image is assembled from scratch:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了顶层镜像的层。我们包括了图像层次结构中的所有命令，以便您可以查看顶层镜像是如何从头开始组装的：
- en: '![](img/34b0d337-fa20-4cf8-bf9c-b461bb638d3f.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/34b0d337-fa20-4cf8-bf9c-b461bb638d3f.png)'
- en: As you will notice in the preceding diagram, each command from all the `Dockerfiles`
    is translated into an additional layer. The base image, for example, derives from
    the `centos:7` images and, as a result, its first layer is added on top of `centos`
    layers. Similarly, the top image is based on the middle image, and as a result,
    the layer resulting from the execution of the `COPY C` command is added on top
    of layers from the middle image.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的图中将注意到的，所有 `Dockerfile` 中的每个命令都被转换为一个额外的层。例如，基础镜像派生自 `centos:7` 镜像，因此其第一层被添加到
    `centos` 层之上。同样，顶层镜像基于中间镜像，因此执行 `COPY C` 命令产生的层被添加到中间镜像的层之上。
- en: We now understand how `Dockerfiles` translate to the image layer structure.
    However, why is this structure important? It is important because it enables images
    to share the layers. Let's find out how.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在理解了 `Dockerfile` 如何转换为镜像层结构。然而，为什么这种结构很重要？它很重要，因为它使得镜像能够共享层。让我们找出如何做到这一点。
- en: When we build the image, the commands from the `Dockerfile` will be executed
    and all the layers will be created. As you saw in the preceding example, images
    are connected to each other and can share layers. A layer that is used by multiple
    images has to be created only once.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建镜像时，`Dockerfile`中的命令将被执行，并创建所有层。正如你在前面的例子中所看到的，镜像之间是相互连接的，并且可以共享层。被多个镜像使用的层只需要创建一次。
- en: In the preceding example, the middle and top images share all the layers from
    the middle image. If we decide to build the middle image, all its layers will
    also be created. If we later build the top image, none of the middle layers have
    to be created again.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，中间和顶部的镜像共享了中间镜像的所有层。如果我们决定构建中间镜像，所有这些层也将被创建。如果我们稍后构建顶部镜像，中间的层不需要再次创建。
- en: To understand why such sharing of layers is possible, we must understand how
    the layers influence filesystem behavior after the container is started.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么可以共享层，我们必须了解层如何影响容器启动后的文件系统行为。
- en: When we start the container based on an image, we are inserting another layer
    on top of an image from which the container was started. The container will write
    its changes to this layer, but the result won't change the image, which is immutable.
    To understand why this is the case, we must understand how layers influence filesystem
    behavior at runtime. Let's find out.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们基于镜像启动容器时，我们是在启动容器的镜像之上插入另一层。容器将把其更改写入这一层，但结果不会改变镜像，因为镜像是不可变的。要理解为什么是这样，我们必须了解层如何影响运行时的文件系统行为。让我们来看看。
- en: When Docker starts a container, it creates a filesystem that will be mounted
    as the root filesystem of the container. Such a filesystem overlays all the layers
    from the image and the writable layer, creating the filesystem that appears to
    combine the files and directories from all the layers that constitute the image.
    Let's return to our example to show how it works.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当Docker启动容器时，它创建一个文件系统，该文件系统将被挂载为容器的根文件系统。这样的文件系统覆盖了镜像和可写层中的所有层，创建了一个看起来结合了构成镜像的所有层的文件和目录的文件系统。让我们回到我们的例子来看看它是如何工作的。
- en: 'Let''s create three containers based on the images from our previous example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们基于我们之前的例子中的镜像创建三个容器：
- en: '![](img/9b04ba0e-cf32-43ce-8d89-99676233e13e.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b04ba0e-cf32-43ce-8d89-99676233e13e.png)'
- en: In the preceding diagram, the top rectangle represents the images that we have
    created. The middle image has added two layers corresponding to directories `A`
    and `B`. The top image has added one layer with the `C` directory. There are three
    containers. Two containers (**2** and **3**) are based on the top image, and **CONTAINER1**
    is based on the middle image. The rectangles at the bottom represent each container's
    writable layer.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，顶部的矩形代表我们创建的镜像。中间的镜像添加了两个层，对应于目录`A`和`B`。顶部的镜像添加了一个包含`C`目录的层。有三个容器。两个容器（**2**和**3**）基于顶部的镜像，而**CONTAINER1**基于中间的镜像。底部的矩形代表每个容器的可写层。
- en: 'Since all layers have been combined into one filesystem, all containers will
    see the whole operating system distribution. The content of the home directory
    will be different for **CONTAINER1**, **CONTAINER2**, and **CONTAINER3**: **CONTAINER1**
    will see only `A` and `B` directories in its `home` folder, whereas **CONTAINER2**
    and **CONTAINER3** will see `A`, `B`, and `C` directories.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有层都已合并成一个文件系统，所有容器都将看到整个操作系统分布。家目录的内容对于**CONTAINER1**、**CONTAINER2**和**CONTAINER3**将是不同的：**CONTAINER1**将只在其`home`文件夹中看到`A`和`B`目录，而**CONTAINER2**和**CONTAINER3**将看到`A`、`B`和`C`目录。
- en: Let's explain how this overlay is implemented. When a container reads a file,
    the storage driver (a component responsible for the union filesystem implementation)
    looks for that file starting from the top layer. If the file is not found, it
    moves to the layer below it. The cycle repeats till either the file is found or
    there are no more layers. If a file is not found in any of the layers, we will
    get a `File not found` error.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释这种覆盖是如何实现的。当容器读取一个文件时，存储驱动程序（负责联合文件系统实现的组件）从顶部层开始查找该文件。如果找不到文件，它将移动到下一层。这个过程会重复，直到找到文件或没有更多层。如果在任何层中都找不到文件，我们将得到一个`File
    not found`错误。
- en: Let's suppose that **CONTAINER1** wants to read a `~/C/c.txt` file. The storage
    driver starts searching in **CONTAINER3**'s writable layer. Since the file is
    not there, it moves to the `COPY C` layer from the top image. The file is found
    there and is read.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 假设**CONTAINER1**想要读取`~/C/c.txt`文件。存储驱动器从**CONTAINER3**的可写层开始搜索。由于文件不在那里，它移动到来自顶层镜像的`COPY
    C`层。文件在那里被找到并读取。
- en: What happens if **CONTAINER1** wants to read the same file?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果**CONTAINER1**想要读取相同的文件会发生什么？
- en: The storage driver starts from **CONTAINER1**'s writable layer. Again, it cannot
    find the file, but this time it moves to the `COPY B` layer, which is the top
    layer of the middle image from which the container was created. The file cannot
    be found there, nor in any layers below it. We will end up with a `File not found`
    a message.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 存储驱动器从**CONTAINER1**的可写层开始。再次，它找不到文件，但这次它移动到顶层的`COPY B`层，这是容器创建时从中创建的中间镜像的顶层。文件在那里找不到，在其下任何层中也找不到。我们最终会收到一条“文件未找到”的消息。
- en: What if **CONTAINER1** and **CONTAINER2** want to read `~/B/b.txt`?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果**CONTAINER1**和**CONTAINER2**想要读取`~/B/b.txt`会怎样？
- en: After reading the supposition in the preceding paragraph, you will know that
    both files can be read. Note, however, that both containers were reading the same
    file. The `"COPY B"` layer is reused by the middle and top images, and the `b.txt`
    file reads from the same image for both containers. Thanks to layers, containers
    are able to reuse data.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读上一段中的假设之后，你会知道两个文件都可以读取。然而，请注意，两个容器都在读取相同的文件。`"COPY B"`层被中间和顶层镜像重用，`b.txt`文件从相同的镜像读取，两个容器都是如此。多亏了层，容器能够重用数据。
- en: Now, what about writing to a file?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，写入文件会怎样呢？
- en: The storage controller uses a copy-on-write strategy when writing a file to
    a filesystem. The driver looks for a file in all the layers, again from top to
    bottom. If the file is present in the container's writable layer, it can be directly
    open for write. If it is present in one of the image's layers, it is copied to
    a writable layer and opened for write.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 存储控制器在将文件写入文件系统时使用写时复制策略。驱动器会从顶层到底层搜索所有层中的文件。如果文件存在于容器的可写层中，则可以直接打开进行写入。如果它存在于镜像的某个层中，则将其复制到可写层并打开进行写入。
- en: 'Let''s return to our example. Let''s suppose that **CONTAINER1** wants to write
    to the `~/A/a.txt` file:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的例子。假设**CONTAINER1**想要写入`~/A/a.txt`文件：
- en: '![](img/32e39a1d-0bd7-4f77-b630-ecb5c1eac610.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/32e39a1d-0bd7-4f77-b630-ecb5c1eac610.png)'
- en: The storage driver has found the `~/A/A.txt` file in **COPY A** layer and copied
    it to the writable layer of **CONTAINER1**. Subsequent reads and writes of the
    `~/A/A.txt` file from **CONTAINER1** will read/write the file from **CONTAINER1**'s
    writable layer.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 存储驱动器在**COPY A**层中找到了`~/A/A.txt`文件，并将其复制到**CONTAINER1**的可写层。从**CONTAINER1**的可写层进行的后续读取和写入操作将读取/写入文件。
- en: 'Let''s suppose that **CONTAINER3** wants to write to the `~/A/A.txt` file:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 假设**CONTAINER3**想要写入`~/A/A.txt`文件：
- en: '![](img/dd7edaf7-abb0-4548-8adb-59f579baa3b3.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dd7edaf7-abb0-4548-8adb-59f579baa3b3.png)'
- en: The situation is analogous; the file is copied to **CONTAINER3**'s writable
    layer. Let's look at the current situation. Each container has had access to the
    Fedora distribution and modified some of its parts.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 情况类似；文件被复制到**CONTAINER3**的可写层。让我们看看当前的情况。每个容器都曾访问过Fedora发行版并修改了其部分。
- en: '**CONTAINER1** and **CONTAINER3** still share most of the data, as only the
    files modified by the given container are copied to its writable layer.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**CONTAINER1**和**CONTAINER3**仍然共享大部分数据，因为只有被给定容器修改的文件才会被复制到其可写层。'
- en: As you will noticed in the preceding diagram, the implementation of Docker images
    provides an effective way of storing multiple images on the same host. Then, what
    about container startup time? The container uses the resources of the underlying
    Linux kernel and reuses the image layers (provided that they are present—if not,
    they are downloaded only once). Because of that, starting the container means
    creating a writable layer and running the container processes using Kernel isolation
    features. As you are able to see, such processes are very lightweight compared
    to the hardware virtualization. As a result, containers can be started and stopped
    immediately.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的图中注意到的，Docker镜像的实现提供了一种在相同主机上存储多个镜像的有效方法。那么，容器启动时间如何呢？容器使用底层Linux内核的资源，并重用镜像层（如果存在的话；如果不存在，则只下载一次）。正因为如此，启动容器意味着创建一个可写层，并使用内核隔离特性运行容器进程。如您所见，与硬件虚拟化相比，这些进程非常轻量级。因此，容器可以立即启动和停止。
- en: By this point, we have described the implications of Docker image architecture
    on container virtualization performance. You may have doubts regarding the performance
    of such an implementation in other circumstances. Surely, a layered filesystem
    would have a performance penalty if we decided to run a database on it. That's
    a good point that has to be clarified. A Docker-layered filesystem is used to
    work effectively with Docker containers. The layered filesystem is not meant to
    store data that requires high performance; this is the role of volumes, which
    we will learn about in the next chapter.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经描述了Docker镜像架构对容器虚拟化性能的影响。您可能对在其他情况下这种实现的性能有所怀疑。当然，如果我们决定在分层文件系统上运行数据库，分层文件系统会有性能损失。这是一个需要澄清的好点。Docker分层文件系统用于有效地与Docker容器一起工作。分层文件系统不是为了存储需要高性能的数据；这是卷的作用，我们将在下一章中学习。
- en: There may be different implementations of a storage driver. For example, copy
    on write strategy may be implemented on the file or page-cache level. Docker provides
    a number of implementations, and choosing the correct one depends on your use
    case.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 存储驱动可能有不同的实现方式。例如，写时复制策略可能实现在文件或页面缓存级别。Docker提供了一系列实现，选择正确的实现取决于您的使用场景。
- en: If you are interested in the architecture of specific storage drivers, or you
    are researching which driver is best for your use case, refer to the Docker documentation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对特定存储驱动程序的架构感兴趣，或者您正在研究哪种驱动程序最适合您的使用场景，请参考Docker文档。
- en: Docker registries
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker注册表
- en: 'Let''s return to the build process of our example container. When we were building
    the base image for the first time, the following could be seen in the build log:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们示例容器的构建过程。当我们第一次构建基本镜像时，构建日志中可以看到以下内容：
- en: '[PRE5]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As it turns out, the `fedora:26` images were downloaded from the `docker.io`
    server. Which service that enables users to download images?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，`fedora:26`镜像是从`docker.io`服务器下载的。哪个服务允许用户下载镜像？
- en: Docker images, just like Maven artifacts or operating system packages, create
    an ecosystem of interconnected reusable entities. Just like in a Maven or operating
    system scenario, we need a service that will store and distribute such images.
    Such service is called a Docker registry.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像，就像Maven工件或操作系统包一样，创建了一个相互关联的可重用实体生态系统。就像在Maven或操作系统场景中一样，我们需要一个服务来存储和分发这些镜像。这种服务被称为Docker注册表。
- en: Docker provides a default registry called DockerHub. DockerHub is a publicly
    available free registry. If not configured, Docker will use DockerHub as the default
    registry.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Docker提供了一个默认的注册表，称为DockerHub。DockerHub是一个公开可用的免费注册表。如果没有配置，Docker将使用DockerHub作为默认注册表。
- en: Docker wrap-up
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker总结
- en: 'As you can see, Docker is a tool that provides a number of capabilities that
    are essential building blocks for our cloud architecture, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Docker是一个提供许多能力的工具，这些能力是我们云架构的基本构建块，如下所示：
- en: The isolation implemented on the operating system level, combined with a layered
    filesystem implementation, makes it possible to share server resources effectively
    and allows for immediate container startup.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在操作系统级别实现的隔离，结合分层文件系统实现，使得有效地共享服务器资源成为可能，并允许容器立即启动。
- en: The image ecosystem provides a vast number of images that can be downloaded
    and used immediately.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像生态系统提供了大量的镜像，可以立即下载和使用。
- en: The containers run from the same images and operate on different Docker environments,
    providing consistency in all your environments. As you will learn in the rest
    of this chapter, this is the key feature of a dynamic cloud environment.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器使用相同的镜像运行，并在不同的Docker环境中操作，确保了所有环境的一致性。正如你将在本章的其余部分学到的那样，这是动态云环境的关键特性。
- en: All these features make Docker containers a great building block for cloud infrastructure.
    However, we need more than that. First, there will be a lot of containers in nontrivial
    environments. We are aiming for a dynamic environment, which enables, among other
    things, automatic scaling, high availability, and continuous integration as we
    expect a large number of those containers to be started and stopped within short
    periods of time. Finally, no matter how cool and efficient Docker images are,
    we would preferably like to generate them automatically during the build of our
    applications. All of those issues are resolved for you by OpenShift. Let's continue
    learning about the OpenShift stack. The next thing that you need to learn is orchestration.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些特性使Docker容器成为云基础设施的绝佳构建块。然而，我们需要的不仅仅是这些。首先，在非平凡环境中将会有大量的容器。我们追求的是一个动态环境，它能够实现自动扩展、高可用性和持续集成，因为我们预计这些容器将在短时间内被频繁启动和停止。最后，无论Docker镜像多么酷和高效，我们更愿意在构建我们的应用程序时自动生成它们。所有这些问题都由OpenShift为你解决。让我们继续学习OpenShift堆栈。接下来你需要学习的是编排。
- en: Orchestrating Docker
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编排Docker
- en: We have just learned about a tool that enables us to provide the containers—lightweight,
    virtual machines using operating system-level virtualization and providing us
    with isolation, effective resource usage, immediate creation time, and the most
    repeatable behavior across different environments. This is the first layer in
    our cloud environment, but it is not our target platform. In a more complex production
    system, we would have to manage a large number of containers and, obviously, we
    don't want to do it manually. We will need a tool that will manage our containers
    in a clever way. Let's meet Kubernetes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚了解了一个工具，它使我们能够提供容器——轻量级的虚拟机，使用操作系统级别的虚拟化，为我们提供隔离、有效资源使用、即时创建时间和在不同环境中最可重复的行为。这是我们云环境的第一层，但不是我们的目标平台。在一个更复杂的生产系统中，我们不得不管理大量的容器，显然，我们不希望手动操作。我们需要一个能够以巧妙方式管理我们的容器的工具。让我们来认识一下Kubernetes。
- en: Kubernetes
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes
- en: In order to show you the interface that Kubernetes provides, let's introduce
    its main architectural concepts.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向您展示Kubernetes提供的界面，让我们介绍其主要的架构概念。
- en: Nodes and master services
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点和主服务
- en: Kubernetes creates a cluster from a group of computers. The computers that constitute
    the cluster can be heterogeneous. A cluster may be created on your laptop, a group
    of workstations, or virtual machines. Also, all types of worker machines can be
    mixed in one cluster.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes从一组计算机中创建一个集群。构成集群的计算机可以是异构的。集群可以创建在你的笔记本电脑上、一组工作站或虚拟机上。此外，一个集群中可以混合使用所有类型的worker机器。
- en: In Kubernetes nomenclature, each worker machine is a node and the whole cluster
    is governed by the master node. Each node runs the Kubelet, which is a daemon
    that enables communication with the master and the Docker engine so that Kubernetes
    can deploy containers on it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes术语中，每台工作机器是一个节点，整个集群由主节点管理。每个节点运行Kubelet，这是一个守护进程，它使节点能够与主节点和Docker引擎通信，以便Kubernetes可以在其上部署容器。
- en: The master, on the other hand, is a group of services that coordinate the whole
    cluster. From the user's point of view, the most important part of the master
    is its REST API service, which provides an endpoint that allows users to interact
    with the whole cluster.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，主节点是一组协调整个集群的服务。从用户的角度来看，主节点最重要的部分是其REST API服务，它提供了一个端点，允许用户与整个集群交互。
- en: 'The following diagram presents a sample Kubernetes cluster, which we will use
    in the further description. The master services are represented by the blue circle
    and each node is represented by a rectangle. The cluster consists of two workstations
    (cyan), two virtual machines (green), and one laptop. Each node runs Kubelet so
    that it can connect with the master, and the Docker engine so that it can start
    containers:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图展示了我们将在后续描述中使用的示例Kubernetes集群。主服务由蓝色圆圈表示，每个节点由一个矩形表示。集群由两个工作站（青色）、两个虚拟机（绿色）和一台笔记本电脑组成。每个节点运行Kubelet，以便它可以与主节点通信，并运行Docker引擎，以便它可以启动容器：
- en: '![](img/3ebf00e0-807c-47cd-8b39-d7f8eda63e95.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3ebf00e0-807c-47cd-8b39-d7f8eda63e95.png)'
- en: Volumes
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 卷
- en: In Kubernetes, containers are ephemeral which means that they may be started
    and stopped often. If the container data is not committed, it will be erased when
    the container is stopped. As a result, we will need another tool for the storage
    of data. In Kubernetes, such a functionality is provided by volumes. Volume is
    a persistent storage implementation, which has an independent life cycle and can
    be mounted in a number of containers. We will discuss volumes in detail in the
    next chapter.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，容器是短暂的，这意味着它们可能会频繁启动和停止。如果容器数据没有提交，当容器停止时，它将被删除。因此，我们需要另一个工具来存储数据。在Kubernetes中，这种功能由卷提供。卷是一种持久存储实现，它具有独立的生命周期，并且可以挂载到多个容器中。我们将在下一章详细讨论卷。
- en: Pods
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pod
- en: In Kubernetes, a pod is a group of containers and volumes, all of which share
    the same IP address among the cluster.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，Pod是一组容器和卷，它们在集群中共享相同的IP地址。
- en: All content of the pod is guaranteed to run on the same host. As a result, a
    pod can be thought of as an atomic unit of deployment and scheduling.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Pod的所有内容都保证在同一个主机上运行。因此，Pod可以被视为部署和调度的原子单元。
- en: The pod concept is needed in order to provide us with the ability to implement
    decoupled containers. With pods, we are able to collocate a bunch of containers
    with different functionalities that have to be located together (and possibly
    share data). Those distinct functionalities can be encapsulated in each container.
    If, on the other hand, a container would have to be used as an atomic unit of
    deployment, we may be forced to collocate distinct functionalities in one container
    in order to ensure that they will be deployed and scaled together, breaking good
    design principles of low coupling and high cohesion.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Pod概念是必需的，以便为我们提供实现解耦容器的能力。有了Pod，我们能够将具有不同功能的一组容器放置在一起（并且可能共享数据）。这些不同的功能可以封装在每个容器中。另一方面，如果容器必须用作部署的原子单元，我们可能被迫将不同的功能放置在一个容器中，以确保它们将一起部署和扩展，这会破坏低耦合和高内聚的良好设计原则。
- en: In a large number of scenarios, a pod will contain only one container, and this
    will be perfectly fine. Pods don't have to comprise many containers, but you are
    provided with such a possibility so that you can use it when it is necessary for
    your application.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在大量场景中，一个Pod可能只包含一个容器，这完全没问题。Pod不需要由许多容器组成，但提供了这样的可能性，以便在应用需要时使用。
- en: Deployments
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署
- en: 'We already know about the building blocks of a Kubernetes cluster. Now it''s
    time to look at the thing that interests us the most: deploying applications to
    it.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了Kubernetes集群的构建块。现在，是时候看看我们最感兴趣的事情了：将其部署应用程序。
- en: 'When you want to deploy an application to the Kubernetes cluster, you have
    to create the deployment object that contains information about it. Among other
    things, Kubernetes must know which containers constitute the pod and how many
    replicas of the pod have to be created. Given that knowledge, Kubernetes will
    decide on which node''s application pods will be deployed, and it will deploy
    them there:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想将应用程序部署到Kubernetes集群时，你必须创建包含该应用程序信息的部署对象。其中之一是，Kubernetes必须知道哪些容器构成Pod，以及需要创建多少个Pod副本。有了这些知识，Kubernetes将决定在哪个节点的应用程序Pod上部署，并将它们部署在那里：
- en: '![](img/f856f535-ef0b-4f97-b3aa-a84dcc0bd159.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f856f535-ef0b-4f97-b3aa-a84dcc0bd159.png)'
- en: In the preceding diagram, the deployment, which requires that the pod be replicated
    on three hosts, has been created. Let's assume that Kubernetes has decided that
    the pod will be run on **WORKSTATION1** and the two virtual machines. The deployment
    object has become a part of the master model. What do we actually mean by that?
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，已经创建了一个需要Pod在三个主机上复制的部署。假设Kubernetes已经决定Pod将在**WORKSTATION1**和两个虚拟机上运行。部署对象已经成为主模型的一部分。我们实际上是什么意思呢？
- en: It has to be strongly emphasized that deployment isn't an operation that will
    finish after execution, leaving no further impact on the cluster status. Instead,
    the deployment effectively adds objects to the description of the desired state
    of the cluster. It is the role of Kubernetes to make sure that this state will
    be maintained.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 必须强调的是，部署不是一个在执行后就会完成，不会对集群状态产生进一步影响的操作。相反，部署实际上向集群期望状态描述中添加了对象。确保这种状态得以维持是Kubernetes的角色。
- en: We have hinted that Kubernetes master provides the REST API. This API allows
    for the creation of an object describing the desired state of the cluster. The
    deployment is one of those objects. As a result, deploying an application to the
    cluster is the equivalent of adding one more deployment object to the cluster
    description.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经暗示Kubernetes主节点提供了REST API。此API允许创建一个描述集群期望状态的对象。部署就是那些对象之一。因此，将应用程序部署到集群相当于向集群描述中添加一个额外的部署对象。
- en: Kubernetes monitors the state of the cluster and is responsible for making sure
    that it is equivalent to that description. To clarify it a little more, let's
    look at a few simple examples.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes监控集群的状态，并负责确保它与描述等效。为了更清楚地说明这一点，让我们看看几个简单的例子。
- en: 'Let''s suppose that one node in the cluster has gone down. As a result, the
    group of pods that were deployed on it has to be moved to different nodes so that
    the number of deployed pods matches the description of the deployment. To present
    it in our example, let''s suppose that **VIRTUAL MACHINE 1** has gone down:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 假设集群中的一个节点已经关闭。结果，部署在该节点上的Pod组必须转移到不同的节点，以便部署的Pod数量与部署描述相匹配。为了在我们的例子中展示这一点，让我们假设**虚拟机1**已经关闭：
- en: '![](img/a73437f2-7de1-4cae-93e2-50c56c5bad7e.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a73437f2-7de1-4cae-93e2-50c56c5bad7e.png)'
- en: In such a scenario, master would find out that the **VIRTUAL MACHINE 1** node
    has failed and, in order to keep the number of pod replicas aligned with the description,
    it will deploy one more pod on another machine—**LAPTOP 1**, in our example.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，主节点会发现**虚拟机1**节点已失败，为了保持Pod副本数量与描述一致，它将在另一台机器上部署一个额外的Pod——在我们的例子中是**笔记本电脑1**。
- en: 'Then, what about deploying a new version of an application? We would have to
    change the version in the deployment description. Kubernetes will find out that
    the version has changed. It will roll down the pods with the preceding version
    of an application and start pods with the new application. Let''s present this
    example in our diagram:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，部署应用程序的新版本怎么办？我们必须在部署描述中更改版本。Kubernetes会发现版本已更改。它将回滚具有先前版本应用程序的Pod，并启动具有新应用程序的Pod。让我们在我们的图中展示这个例子：
- en: '![](img/5be6545f-50ca-4703-8de4-e11bc0ee2684.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5be6545f-50ca-4703-8de4-e11bc0ee2684.png)'
- en: Kubernetes has undeployed the pods that constitute the preceding application,
    replaced the old deployment object with the new one, chosen on which nodes the
    updated pods have to be deployed, and, finally, performed deployment on those
    nodes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes已经卸载了构成前一应用程序的Pod，用新的部署对象替换了旧的部署对象，选择了更新Pod需要部署的节点，最后在这些节点上执行了部署。
- en: Because this chapter is aimed at explaining OpenShift architecture, we are using
    general theoretical examples. We will show you how scaling and deployments are
    done in practical examples in the following chapters.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因为本章旨在解释OpenShift架构，所以我们使用一般理论示例。我们将在下一章的实践示例中向您展示如何进行扩展和部署。
- en: 'The key point to understand now is the principle on which Kubernetes operates:
    it is responsible for keeping the cluster synchronized with the desired state
    described by the user.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在需要理解的关键点是Kubernetes运行的原则：它负责使集群与用户描述的期望状态保持同步。
- en: Services
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务
- en: You may already have noticed that there is a problem with the dynamic pod deployments
    described in the preceding section. How are we supposed to connect to the application
    if we have no idea where its pods are located? To solve this problem, Kubernetes
    introduced the service concept.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在前一节中描述的动态Pod部署存在问题。如果我们不知道应用程序的Pod位于何处，我们该如何连接到该应用程序？为了解决这个问题，Kubernetes引入了服务概念。
- en: A service is an object that monitors the group of pods that constitutes an application.
    It contains search criteria that define which pods are the part of an application,
    and monitors the cluster so that it knows where these pods are located. A service
    has its own IP address, which is visible from outside the cluster. As a result,
    the client only has to know the address of a service. The actual cluster status
    (number of pods and their location) is abstracted away from the client.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是一个对象，它监控构成应用程序的Pod组。它包含搜索条件，用于定义哪些Pod是应用程序的一部分，并监控集群，以便知道这些Pod的位置。服务有自己的IP地址，可以从集群外部看到。因此，客户端只需要知道服务的地址。实际的集群状态（Pod数量及其位置）被抽象化，从客户端隐藏。
- en: 'Let''s present it again in our example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的例子中再次介绍它：
- en: '![](img/952d5674-b267-4779-9183-6afe3088210e.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/952d5674-b267-4779-9183-6afe3088210e.png)'
- en: In the preceding diagram, the call to the master has created the service object
    in the master's object model, which has resulted in the creation of the service.
    The created service has an IP address, which is reachable by the external clients.
    When invoked, the service will load balance the invocation to one of the pods
    from the cluster. Note that the service constantly monitors the state of the cluster.
    If, for example, there is a failure in one of the nodes, the service will learn
    the new locations of the pods and will continue to work correctly.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，对主服务的调用在主对象模型中创建了服务对象，这导致了服务的创建。创建的服务有一个IP地址，外部客户端可以访问。当调用服务时，它将对集群中的一个pod进行负载均衡。请注意，服务持续监控集群的状态。例如，如果一个节点发生故障，服务将学习到pod的新位置，并继续正确工作。
- en: 'This example combines together all the concepts that we have introduced. Let''s
    recap them: Kubernetes creates a cluster of heterogeneous worker machines. All
    machines in a cluster have to be able to run Docker containers and communicate
    with Kubernetes master services that govern all the clusters. The unit of deployment
    is a pod, which consists of one or more containers and can have many replicas.
    A user creates the description of such deployments using the master''s API, and
    Kubernetes is responsible for ensuring that the actual cluster state matches this
    description. To do that, it has to, among other things, perform health checks
    of nodes and the application, and redeploy them as necessary. It also has to react
    to all model changes and modify the cluster accordingly. Owing to all the reasons
    mentioned in this paragraph, application pods can be located on different nodes,
    and those locations can change dynamically. As a result, Kubernetes introduces
    the service concept, which provides the proxy for the external clients to the
    pods that constitute the application to which the client wants to connect.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子结合了我们介绍的所有概念。让我们回顾一下：Kubernetes创建了一个异构工作机的集群。集群中的所有机器都必须能够运行Docker容器并与管理所有集群的Kubernetes主服务进行通信。部署的单位是pod，它由一个或多个容器组成，并且可以有多个副本。用户使用主API创建此类部署的描述，Kubernetes负责确保实际的集群状态与这个描述相匹配。为此，它必须执行节点和应用程序的健康检查，并在必要时重新部署它们。它还必须对所有模型更改做出反应，并相应地修改集群。由于本段中提到的所有原因，应用程序pod可以位于不同的节点上，并且这些位置可以动态变化。因此，Kubernetes引入了服务概念，为外部客户端提供了连接到客户端想要连接的应用程序的pod的代理。
- en: Labels
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标签
- en: Each object in a OpenShift cluster model can have any number of labels, which
    are basically key-value properties. This is a very simple, yet powerful, feature.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenShift集群模型中，每个对象都可以有任意数量的标签，这些标签基本上是键值属性。这是一个非常简单但功能强大的特性。
- en: We will need a way to be able to categorize different types of objects. We can
    build a directory structure for that, but the problem with that solution is that
    it's not flexible enough. A directory structure provides one view of objects,
    but there may be many of them, depending on the user or on the current usage scenario.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来对不同的对象类型进行分类。我们可以为这个目的构建一个目录结构，但这个解决方案的问题在于它不够灵活。目录结构提供了一个对象视图，但可能会有很多这样的视图，这取决于用户或当前的用法场景。
- en: Labels, on the other hand, provide full flexibility. Any object can have any
    number of labels applied. Those labels can be used in queries to find an OpenShift
    object based on a wide range of characteristics.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，标签提供了完全的灵活性。任何对象都可以应用任意数量的标签。这些标签可以用在查询中，根据广泛的特性来查找OpenShift对象。
- en: 'As an example, let''s take a look at a service object again. The service has
    to find all the pods that run the application represented by the service. The
    service finds those pods by querying the labels: it''s a common practice for the
    pod to have an app label set to the name of an application that runs on it. As
    a result, the service can query for pods with an appropriate app label.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们再次查看服务对象。服务必须找到所有运行由服务表示的应用程序的pod。服务通过查询标签来找到这些pod：通常的做法是pod有一个app标签设置为在其上运行的应用程序的名称。因此，服务可以查询具有适当app标签的pod。
- en: Benefits
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优点
- en: Now that we know the most important concepts regarding the architecture of Kubernetes,
    it is time to look at the big picture of the interface that it provides. Kubernetes
    takes the group of heterogeneous worker machines and provides its user with a
    view of a homogeneous container execution environment. Let's think about this
    for a moment. As a user, you tell Kubernetes, *I want to deploy my application,
    which consists of N pods.* Kubernes will place those somewhere in the cluster.
    If pods have to be scaled up or down, or if there are failures, Kubernetes will
    take care of moving those pods between the underlying machines, but the technical
    details of those machines are abstracted away from the user. With Kubernetes,
    a user sees the cluster as a pool of container execution resources. Furthermore,
    this view is the same for all the clusters that you may want to run in your environment.
    The Kubernetes development cluster on your laptop will have the same interface
    as your production environment.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了关于 Kubernetes 架构的最重要概念，是时候看看它提供的接口的全貌了。Kubernetes 将异构工作机群组抽象化，为用户提供了一个同质化的容器执行环境视图。让我们思考一下。作为用户，您告诉
    Kubernetes：“我想部署我的应用程序，它由 N 个 pod 组成。”Kubernetes 将这些 pod 放置在集群的某个位置。如果 pod 需要扩缩容，或者出现故障，Kubernetes
    将负责在底层机器之间移动这些 pod，但机器的技术细节对用户来说是抽象化的。使用 Kubernetes，用户将集群视为容器执行资源池。此外，这种视图对于您可能希望在环境中运行的任何集群都是相同的。您笔记本电脑上的
    Kubernetes 开发集群将具有与您的生产环境相同的接口。
- en: 'We must also emphasize the role that containers play—Docker guarantees that
    two containers built from the same image will behave identically. Combining that
    fact with the role that Kubernetes plays, we are able to see the cloud view provided
    by Docker and Kubernetes: a pool of container execution computing resources, which
    further guarantees repeatable behavior on all environments on which it is deployed.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须强调容器的作用——Docker 保证由同一镜像构建的两个容器将具有相同的行为。结合 Kubernetes 的作用，我们能够看到 Docker
    和 Kubernetes 提供的云视图：一个容器执行计算资源池，这进一步保证了在所有部署环境中都能重复行为。
- en: OpenShift
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenShift
- en: In the previous sections, we covered the powerful cloud abstraction that is
    provided by Kubernetes and Docker. On the other hand, we hinted in a number of
    places that in order to use Kubernetes effectively, you have to, among other things,
    deal directly with Kubernetes object configurations or Docker files. As we wrote
    before, we would preferably like to have a tool that will abstract those things
    away from us, make them either happen automatically, or be configured using easy-to-use
    tools. Here is where OpenShift steps in. OpenShift adds another layer of abstraction
    on top of Kubernetes, providing it with additional cluster model features, such
    as builds, or tools, such as web console. As you will see, the layer added by
    OpenShift makes all the cloud operations very simple and effectively allows you
    to focus on the development of your code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们介绍了 Kubernetes 和 Docker 提供的强大云抽象。另一方面，我们在多个地方暗示，为了有效地使用 Kubernetes，您必须直接处理
    Kubernetes 对象配置或 Docker 文件。正如我们之前所写的，我们更希望有一个工具可以抽象这些事情，使它们自动发生，或者使用易于使用的工具进行配置。正是在这里，OpenShift
    出现了。OpenShift 在 Kubernetes 之上添加了另一层抽象，为其提供了额外的集群模型功能，如构建，或如网页控制台等工具。正如您将看到的，OpenShift
    添加的这层使得所有云操作都非常简单，并且有效地让您能够专注于代码的开发。
- en: Returning for a moment to the cloud computing types section at the beginning
    of this chapter, we can say that Kubernetes and Docker provide you with IaaS,
    whereas OpenShift transforms it into powerful programmer-oriented PaaS.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下本章开头关于云计算类型的部分，我们可以这样说：Kubernetes 和 Docker 为您提供 IaaS，而 OpenShift 则将其转变为强大的面向程序员的
    PaaS。
- en: You will learn about the most important features provided by OpenShift in the
    following paragraphs. Now, let's quickly highlight the most important features
    of OpenShift. We will start with the build infrastructure.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的段落中，您将了解 OpenShift 提供的最重要功能。现在，让我们快速概述 OpenShift 的最重要功能。我们将从构建基础设施开始。
- en: The build infrastructure
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建基础设施
- en: In the previous paragraphs, we suggested that direct Docker images are abstracted
    away by OpenShift. Now it's time to look at it a little more closely.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的段落中，我们建议 OpenShift 将直接 Docker 镜像抽象化。现在，让我们更仔细地看看它。
- en: OpenShift provides builds and deployment abstractions. Builds are responsible
    for creating images, and deployments are responsible for deploying those images
    to the cluster, providing the abstraction above Kubernetes objects, such as replication
    controllers.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift 提供构建和部署抽象。构建负责创建镜像，部署负责将这些镜像部署到集群中，提供高于 Kubernetes 对象（如副本控制器）的抽象。
- en: One of the first questions that come to mind now is how are those images built?
    There are a bunch of options, but the most interesting one for us is source-to-image
    build. As its name suggests, this kind of build is responsible for automatically
    turning your code into a Docker image.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在脑海中浮现的第一个问题之一是这些镜像是如何构建的？有很多选项，但对我们来说最有趣的一个是源到镜像构建。正如其名所示，这种构建负责自动将您的代码转换为
    Docker 镜像。
- en: 'As a result, your interaction with OpenShift may be configured as follows:
    you write your application and push the changes into the GitHub repository. This
    triggers the source-to-image build, which creates a Docker image, and the creation
    of the Docker image may trigger automatic deployment. Also, all those steps may
    be integrated into Jenkins based on a continuous delivery pipeline. As you can
    see, OpenShift build tools allow you to concentrate only on code development.
    The interaction with cloud will be done automatically by the build infrastructure.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您与 OpenShift 的交互可能配置如下：您编写应用程序并将更改推送到 GitHub 仓库。这触发了源到镜像的构建，创建了 Docker 镜像，创建
    Docker 镜像可能还会触发自动部署。此外，所有这些步骤都可以根据持续交付管道集成到 Jenkins 中。正如您所看到的，OpenShift 构建工具允许您只专注于代码开发。与云的交互将由构建基础设施自动完成。
- en: You will learn more about deployments and about builds (including source-to-image
    and pipeline builds) in [Chapter 9](e5cfc996-0fbf-40e8-a89b-fc9ee72c8861.xhtml),
    *Configuring Continuous Integration Using Jenkins*.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在第 9 章 [配置使用 Jenkins 的持续集成](e5cfc996-0fbf-40e8-a89b-fc9ee72c8861.xhtml)中了解更多关于部署和构建（包括源到镜像和管道构建）的内容。
- en: Management of projects and users
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目和用户管理
- en: This feature is not as fresh as the preceding one, but it's still very important.
    In order to make OpenShift able to work in an enterprise environment, the concept
    of the project is necessary.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能不如前一个新鲜，但仍然非常重要。为了使 OpenShift 能够在企业环境中工作，项目的概念是必要的。
- en: Kubernetes provides the namespace concept, which enables it to separate the
    cluster into a group of virtual clusters. This concept namespace doesn't implement
    access control though. As a result, OpenShift creates the notion of a project,
    which is a Kubernetes namespace identified by specific annotation and implementing
    access control policies based on users and user groups.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了命名空间的概念，这使得它能够将集群划分为一组虚拟集群。这个命名空间的概念虽然没有实现访问控制，但 OpenShift 创建了项目的概念，这是一个由特定注释标识的
    Kubernetes 命名空间，并基于用户和用户组实现访问控制策略。
- en: You will learn more about security microservice applications in [Chapter 10](2ad0780e-aeb3-40a8-8af7-f2d26341bb35.xhtml),
    *Providing Security Using Keycloak*.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在第 10 章 [使用 Keycloak 提供安全](2ad0780e-aeb3-40a8-8af7-f2d26341bb35.xhtml)中了解更多关于安全微服务应用的内容。
- en: Minishift
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Minishift
- en: We have already said a lot of good things about OpenShift. It is high time we
    saw how it works in practice. However, how are you actually able to do that? As
    a developer, you have access to OpenShift Online. It is a publicly available OpenShift
    cloud where anyone can open an account and test OpenShift itself.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对 OpenShift 说了很多好话。现在是时候看看它在实际中是如何工作的了。然而，您实际上是如何做到这一点的呢？作为一个开发者，您有权访问 OpenShift
    Online。这是一个公开可用的 OpenShift 云，任何人都可以开设账户并测试 OpenShift 本身。
- en: 'There is also another option: Minishift. Minishiftis a tool that starts a virtual
    machine on your local computer and creates an OpenShift cluster inside it. As
    a result, it enables you to try and test a fully featured OpenShift cluster on
    your local machine. This is the option that we will use in this book. Let''s start
    by installing it.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 另外还有一个选项：Minishift。Minishift 是一个在您的本地计算机上启动虚拟机并在其中创建 OpenShift 集群的工具。因此，它使您能够在本地机器上尝试和测试一个功能齐全的
    OpenShift 集群。这是我们将在本书中使用的选项。让我们先安装它。
- en: Installation
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: You are able to download its latest version from the GitHub page. You also have
    to install the virtual machine that you will use and configure your environment
    variables accordingly. The process is very simple and takes a few minutes to complete.
    The details of the particular installation steps differ a bit between operating
    systems. They are described thoroughly in the attached installation guide.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从GitHub页面下载其最新版本。您还必须安装您将使用的虚拟机，并相应地配置环境变量。这个过程非常简单，只需几分钟即可完成。不同操作系统的特定安装步骤略有不同，它们在附带的安装指南中有详细描述。
- en: Starting the cluster
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动集群
- en: 'After you have installed the cluster, you can start it using the minishift
    start command. It is a good practice to boost the default parameters to provide
    enough memory and disk space for the services that we will develop and use:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在您安装了集群后，您可以使用minishift start命令启动它。将默认参数提升以提供足够的内存和磁盘空间供我们开发和使用的服务是一个好习惯：
- en: '[PRE6]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After you run the preceding command, you have to wait few minutes for the cluster
    to start:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在您运行上述命令后，您需要等待几分钟，以便集群启动：
- en: '![](img/4f11a892-ad0c-4edd-95aa-6511ba0fa8b1.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f11a892-ad0c-4edd-95aa-6511ba0fa8b1.png)'
- en: After minishift has started, we can access it using the provided address in
    the startup log. The first screen is a login screen. On this screen, you can use
    any credentials (as Minishift is a test tool) and click the Login button. After
    you do this, you will see the `web console`, which is one way of managing the
    OpenShift cluster. Let's learn more about it.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在minishift启动后，我们可以使用启动日志中提供的地址访问它。第一个屏幕是登录屏幕。在这个屏幕上，您可以使用任何凭证（因为Minishift是一个测试工具）并点击登录按钮。完成此操作后，您将看到`web
    console`，这是管理OpenShift集群的一种方式。让我们更深入地了解它。
- en: Web console
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web控制台
- en: A `web console` is a graphical tool that enables you to view and manage the
    content of an OpenShift project. From a technical point of view, the console is
    a graphical interface that provides convenient abstraction over the OpenShift
    REST API, which it uses to modify the cluster model according to user operations.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`web console`是一个图形工具，它允许您查看和管理OpenShift项目的内 容。从技术角度来看，控制台是一个图形界面，它提供了对OpenShift
    REST API的方便抽象，它使用该API根据用户操作修改集群模型。'
- en: 'Let''s take a look at the main console window:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看主控制台窗口：
- en: '![](img/b37e1787-e8e8-4a6f-9b1c-ae4b14f0fb06.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b37e1787-e8e8-4a6f-9b1c-ae4b14f0fb06.png)'
- en: As you can see in the preceding screenshot, the console allows you to manage
    projects, view their content, and modify it. The overview (presented in the preceding
    screenshot) contains an application deployed in the petstore namespace. The menu
    on the left allows you to view and modify different aspects of the cluster, such
    as builds, deployments, or persistent resources.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的屏幕截图中看到的，控制台允许您管理项目，查看其内容，并对其进行修改。概述（如前所述的屏幕截图所示）包含在petstore命名空间中部署的应用程序。左侧的菜单允许您查看和修改集群的不同方面，例如构建、部署或持久性资源。
- en: We will use the `web console` extensively in the following chapters, where you
    will be able to take a look at most of its features and capabilities.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将广泛使用`web console`，在那里您将能够查看其大多数功能和能力。
- en: YAML notation
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: YAML表示法
- en: 'Although the majority of configuration can be done using the graphical interface,
    sometimes it will be necessary to edit the internal representation of OpenShift
    objects: YAML.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数配置都可以使用图形界面完成，但有时将需要编辑OpenShift对象的内部表示：YAML。
- en: Each object in an OpenShift model can be represented using this kind of notation.
    If you click on Applications | Deployments, choose one of them, click on Actions
    in the top-right corner, you will be able to choose the Edit YAML option. This
    applies to all objects in the console.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift模型中的每个对象都可以使用这种类型的表示。如果您点击应用程序 | 部署，选择其中一个，点击右上角的操作，您将能够选择编辑YAML选项。这适用于控制台中的所有对象。
- en: We will be performing this from time to time when such an edit is necessary,
    informing you about the meaning of the performed operation.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在必要时进行此类编辑时，不时执行此操作，并通知您所执行操作的含义。
- en: CLI
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CLI
- en: Sometimes, it is more convenient to use a command-line tool instead of graphical
    interface. OpenShift provides it too. The OpenShift CLI implements the `oc` command-line
    tool, which allows for managing the cluster from the terminal.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，使用命令行工具而不是图形界面会更方便。OpenShift也提供了这个功能。OpenShift CLI实现了`oc`命令行工具，它允许从终端管理集群。
- en: You can install the CLI using the instruction provided in.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用提供的说明安装CLI。
- en: 'The first thing that you have to do in order to use `oc` is to log in to the
    cluster, as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 `oc`，您必须登录到集群，如下所示：
- en: '[PRE7]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You will be asked for your credentials, and will have to provide the same credentials
    that were used to create your project in the web console.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被要求提供凭证，并将必须提供在Web控制台中创建您的项目时使用的相同凭证。
- en: There are a number of operations that the `oc` tool provides. We will use it
    extensively to get and describe operations. Let's introduce them now.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`oc` 工具提供了许多操作。我们将广泛使用它来获取和描述操作。现在让我们介绍它们。'
- en: 'The `get` operation allows you to obtain available information about the availability
    of a given type of object; let''s invoke the command:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`get` 操作允许您获取有关给定类型对象可用性的信息；让我们调用该命令：'
- en: '[PRE8]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The tool will suggest a type of object that you can inspect; let''s take a
    look:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 工具将建议一种您可以检查的对象类型；让我们看看：
- en: '![](img/82c54c38-0cf9-4a6e-8f63-66f9b80e74e0.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/82c54c38-0cf9-4a6e-8f63-66f9b80e74e0.png)'
- en: 'Wow! That''s a lot, but don''t worry, you will learn a lot about most of these
    in the next chapters. Let''s use the `oc get` command to inspect the services
    available in the cluster:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这有很多，但别担心，您将在下一章中学到关于这些大多数内容的很多知识。让我们使用 `oc get` 命令检查集群中可用的服务：
- en: '![](img/ffcd64b9-21ac-44ea-b131-e980aa585215.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ffcd64b9-21ac-44ea-b131-e980aa585215.png)'
- en: 'You can also take advantage of labels. If you write:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以利用标签。如果您写下：
- en: '[PRE9]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Then you will be able to see all kinds of objects associated with the service.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将能够看到与该服务相关联的所有类型的对象。
- en: 'As you can see in the preceding code, we are able to list the objects that
    we are interested in using the `get` command. If we want to get some more information
    about them, we need to use the `oc describe` command, as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的代码中所见，我们能够使用 `get` 命令列出我们感兴趣的对象。如果我们想获取更多关于它们的信息，我们需要使用 `oc describe`
    命令，如下所示：
- en: '![](img/c7f26657-45ae-42e4-9737-f5c2f03d58de.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c7f26657-45ae-42e4-9737-f5c2f03d58de.png)'
- en: The describe command allows you to read all the information about the given
    type of object.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe` 命令允许您读取有关给定类型对象的全部信息。'
- en: You have now learned all the essential information needed to understand OpenShift.
    Now, it's finally time to try it.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经学到了理解OpenShift所需的所有基本信息。现在，是时候尝试了。
- en: Catalog-service on the OpenShift example
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenShift示例中的目录服务
- en: We have covered a lot of theory in this chapter and have introduced many concepts
    that will help you to better understand how OpenShift works under the hood. It
    is finally time to try it in practice.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了大量的理论，并介绍了许多将帮助您更好地理解OpenShift内部工作原理的概念。现在是时候在实践中尝试了。
- en: We will deploy a `catalog-service` with a `h2` database. In this example, we
    will only use the web console and deploy the applications from the book's code
    repository.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将部署一个使用 `h2` 数据库的 `catalog-service`。在这个示例中，我们只会使用Web控制台并从书籍的代码仓库部署应用程序。
- en: 'Examples reference: `chapter6/catalog-service-openshift-h2`'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 示例参考：`chapter6/catalog-service-openshift-h2`
- en: Let's start. Let's enter the host address. You will find it in the log of the
    minishift start command. After entering it into the web browser, you will be welcomed
    by the user login screen. Let's enter our Username and Password.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始。让我们输入主机地址。您可以在minishift启动命令的日志中找到它。在将其输入到网页浏览器后，您将看到用户登录屏幕。让我们输入我们的用户名和密码。
- en: 'We will be directed to the welcome screen, as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将被引导到欢迎屏幕，如下所示：
- en: '![](img/2414d182-561f-4292-b79a-9a2e2dd6f7f8.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2414d182-561f-4292-b79a-9a2e2dd6f7f8.png)'
- en: 'Enter petstore as the name of the project. In order to deploy catalog-service
    to OpenShift, we will use the source-to-image build using the CLI. To start with,
    ensure that you have logged in to the cluster, as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 将项目名称输入为petstore。为了将目录服务部署到OpenShift，我们将使用CLI的源到镜像构建。首先，确保您已登录到集群，如下所示：
- en: '[PRE10]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, you need to execute the following command:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要执行以下命令：
- en: '[PRE11]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding command creates a bunch of OpenShift objects that are necessary
    to start an OpenShift build.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令创建了一组必要的OpenShift对象，以启动OpenShift构建。
- en: 'Finally, it is time to start an application:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是时候启动应用程序了：
- en: '[PRE12]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We are fully aware that, at this point, these commands look cryptic. For some
    time, we will use them as a magical service deployment spell. Don''t worry though,
    in [Chapter 8](988f96cb-b157-41a0-8c0c-81c5ec440927.xhtml), *Scaling and Connecting
    Your Services*, they will be fully explained, and you will be able to understand
    each part of the process. To give you a quick overview now: we are making OpenShift
    create a build of our service directly from source code. In order to do that,
    we have to specify the GitHub repository. Because our book repository contains
    many subdirectories, we have to specify the subdirectory in which this example
    is located—we use `--context-dir` for that. We also provide the name, using the
    `--name` command.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完全清楚，到目前为止，这些命令看起来很晦涩。在一段时间内，我们将把它们当作一个神奇的服务部署咒语来使用。不过，不用担心，在[第8章](988f96cb-b157-41a0-8c0c-81c5ec440927.xhtml)“扩展和连接你的服务”中，它们将得到全面解释，你将能够理解整个过程的每一个部分。现在先给你一个快速概述：我们正在让OpenShift直接从源代码创建我们的服务构建。为了做到这一点，我们必须指定GitHub仓库。因为我们的书籍仓库包含许多子目录，我们必须指定包含此示例的子目录——我们使用`--context-dir`来指定。我们还提供了名称，使用`--name`命令。
- en: For now, let's use the web console to check whether the application has been
    deployed.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用Web控制台来检查应用程序是否已部署。
- en: 'Login to the web console again and navigate to Builds | Builds on the left-hand
    side. You will be able to see that the build has indeed started:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 再次登录到Web控制台，导航到左侧的构建 | 构建。你会看到构建确实已经开始：
- en: '![](img/f2df1108-d9ad-44bb-81e5-fdf606af338c.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f2df1108-d9ad-44bb-81e5-fdf606af338c.jpg)'
- en: 'Wait till the build has finished, then navigate to Applications | Services,
    and select catalog-service:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 等待构建完成，然后导航到应用程序 | 服务，并选择catalog-service：
- en: '![](img/2aaea04d-8621-43f9-b60a-92ff25c8207f.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2aaea04d-8621-43f9-b60a-92ff25c8207f.png)'
- en: As you can see in the preceding screenshot, OpenShift has deployed the application
    on one pod and made a service for it.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，OpenShift已经在一个Pod上部署了应用程序，并为它创建了一个服务。
- en: 'Before we can check the application, we have to do one more simple thing. The
    services are not visible outside of the cluster, and as a result, in order to
    use them, we have to expose them on the address visible from the external network.
    OpenShift provides a tool that enables us to use these routes. In the preceding
    view, click on the Create route link, don''t change anything, and click the Create
    button. After that, you will be able to see the external address of the service:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够检查应用程序之前，我们必须做一件简单的事情。服务在集群外部是不可见的，因此，为了使用它们，我们必须在从外部网络可见的地址上公开它们。OpenShift提供了一个工具，使我们能够使用这些路由。在上一个视图中，点击创建路由链接，不要做任何更改，然后点击创建按钮。之后，你将能够看到服务的对外地址：
- en: '![](img/ebb4abc6-5a4f-45f3-96f0-8581f9d95df9.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ebb4abc6-5a4f-45f3-96f0-8581f9d95df9.png)'
- en: 'Finally, we are ready to check the operation of our service. Copy the external
    address of the host and add the REST path to it:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们准备好检查我们服务的运行情况。复制主机的外部地址，并添加REST路径：
- en: '![](img/2f65364c-e200-4736-9f47-311f28d1fc4f.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2f65364c-e200-4736-9f47-311f28d1fc4f.png)'
- en: It works. Congratulations! You have deployed your first service in OpenShift.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 它工作了。恭喜！你已经在OpenShift中部署了你的第一个服务。
- en: Summary
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you learned a lot about OpenShift architecture. You were introduced
    to cloud computing and was provided the most essential information about it. Later,
    you learned about the architecture of OpenShift: a Kubernetes cluster using Docker
    images with an OpenShift layer, making cluster easy, to use and allowing developers
    to focus on coding.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了关于OpenShift架构的很多知识。你被介绍了云计算，并提供了关于它的最基本信息。后来，你学习了OpenShift的架构：一个使用Docker镜像的Kubernetes集群，加上OpenShift层，使得集群易于使用，并允许开发者专注于编码。
- en: Later in the chapter, you started your own local OpenShift instance using the
    Minishift tool and deployed your first service on it.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，你使用Minishift工具启动了自己的本地OpenShift实例，并在其上部署了你的第一个服务。
- en: In the next chapter, you will learn how to configure persistent storage for
    microservices deployed in the cloud.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何为在云中部署的微服务配置持久存储。
- en: Further reading
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)'
- en: '[https://www.docker.com/](https://www.docker.com/)'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[https://www.docker.com/](https://www.docker.com/)'
- en: '[https://openshift.io/](https://openshift.io/)'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[https://openshift.io/](https://openshift.io/)'
- en: '[https://github.com/minishift/minishift](https://github.com/minishift/minishift)'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[https://github.com/minishift/minishift](https://github.com/minishift/minishift)'
- en: '[https://docs.openshift.org/latest/minishift/getting-started/installing.html](https://docs.openshift.org/latest/minishift/getting-started/installing.html)'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[https://docs.openshift.org/latest/minishift/getting-started/installing.html](https://docs.openshift.org/latest/minishift/getting-started/installing.html)'
- en: '[https://docs.openshift.com/enterprise/3.1/cli_reference/get_started_cli.html](https://docs.openshift.com/enterprise/3.1/cli_reference/get_started_cli.html)'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[https://docs.openshift.com/enterprise/3.1/cli_reference/get_started_cli.html](https://docs.openshift.com/enterprise/3.1/cli_reference/get_started_cli.html)'
