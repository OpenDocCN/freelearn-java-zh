- en: Chapter 2. Working with Repositories
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 与仓库协同工作
- en: In the previous chapter, you learned how to define dependencies for your project.
    Those dependencies are mostly stored somewhere in a repository or a directory
    structure. A repository usually has a structure to support different versions
    for the same dependency. Also, some metadata, such as the other dependencies for
    a module, is saved in the repository.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何为你的项目定义依赖项。这些依赖项大多存储在某个仓库或目录结构中。仓库通常有一个结构来支持同一依赖项的不同版本。此外，一些元数据，如模块的其他依赖项，也保存在仓库中。
- en: In our build files, we must define the location of a repository for our dependencies.
    We can mix different types of repositories, such as Maven and Ivy. We can even
    use a local filesystem as a repository. We will see how we can define and configure
    repositories in our build files.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的构建文件中，我们必须定义依赖项仓库的位置。我们可以混合不同类型的仓库，例如Maven和Ivy。我们甚至可以使用本地文件系统作为仓库。我们将看到如何在构建文件中定义和配置仓库。
- en: Also, Gradle offers the option of configuring the repository layout, if the
    repository is using a custom layout. We will learn how to provide credentials
    for repositories with basic authentication.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Gradle还提供了配置仓库布局的选项，如果仓库使用自定义布局。我们将学习如何为使用基本身份验证的仓库提供凭据。
- en: Declaring repositories
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明仓库
- en: 'If we want to add dependencies from a repository in a Gradle build file, we
    must explicitly add the `repositories` configuration block. Within the configuration
    block, we define the location of the repository and maybe some extra configuration.
    In the following example of a build file, we define a Maven repository with a
    custom location:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在Gradle构建文件中添加来自仓库的依赖项，我们必须显式添加`repositories`配置块。在配置块内，我们定义仓库的位置，也许还有一些额外的配置。在以下构建文件的示例中，我们定义了一个具有自定义位置的Maven仓库：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can include several repositories in our build file. We can even mix the
    type of repositories, for example to, include both the Ivy repository and a local
    filesystem. Gradle supports the following types of repositories:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在构建文件中包含多个仓库。我们甚至可以混合仓库类型，例如，包括Ivy仓库和本地文件系统。Gradle支持以下类型的仓库：
- en: '| Type | Description |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Maven JCenter repository | This is a preconfigured repository for Bintray
    JCenter |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| Maven JCenter仓库 | 这是一个为Bintray JCenter预配置的仓库 |'
- en: '| Maven central repository | This is a preconfigured repository for Maven Central
    |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| Maven中央仓库 | 这是一个为Maven Central预配置的仓库 |'
- en: '| Maven local repository | This is a preconfigured repository for the local
    Maven repository |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| Maven本地仓库 | 这是一个为本地Maven仓库预配置的仓库 |'
- en: '| Maven repository | This is a to-be-configured Maven repository, which has
    a custom location |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| Maven仓库 | 这是一个待配置的Maven仓库，它有一个自定义位置 |'
- en: '| Ivy repository | This is a to-be-configured Ivy repository, which has a location
    and layout |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| Ivy仓库 | 这是一个待配置的Ivy仓库，它有一个位置和布局 |'
- en: '| Flat directory repository | This is a local filesystem repository |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 平坦目录仓库 | 这是一个本地文件系统仓库 |'
- en: We will see how to use these repositories in our build file later. It is good
    to realize that Gradle will try to download all artifacts from a dependency, from
    the same repository that the dependency module descriptor file is found. So, if
    we have multiple repositories defined in our build script, Gradle will still use
    the first repository that the module descriptor file is found on to download the
    artifacts.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后看到如何在构建文件中使用这些仓库。认识到Gradle将尝试从依赖项中下载所有工件，从找到依赖项模块描述符文件的同一仓库，这是很好的。因此，如果我们已经在构建脚本中定义了多个仓库，Gradle仍然会使用找到模块描述符文件的第一个仓库来下载工件。
- en: Using the Maven JCenter repository
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Maven JCenter仓库
- en: Bintray's JCenter is a relatively new public Maven repository, where a lot of
    Maven open source dependencies are stored. It is a superset of the Maven Central
    repository and also contains dependency artifacts published directly to JCenter.
    The URL to access the repository is [https://jcenter.bintray.com](https://jcenter.bintray.com).
    Gradle provides a shortcut for JCenter, so we don't have to type the URL ourselves
    in the `repositories` configuration block. The shortcut method is `jcenter()`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Bintray的JCenter是一个相对较新的公共Maven仓库，其中存储了大量的Maven开源依赖项。它是Maven Central仓库的超集，并且还包含直接发布到JCenter的依赖项工件。访问仓库的URL是[https://jcenter.bintray.com](https://jcenter.bintray.com)。Gradle为JCenter提供了一个快捷方式，因此我们不需要在`repositories`配置块中自己输入URL。快捷方式是`jcenter()`。
- en: 'In the following example build file, we define a reference to Bintray''s JCenter
    repository using the `jcenter()` shortcut:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的构建文件示例中，我们使用`jcenter()`快捷方式定义了对Bintray的JCenter仓库的引用：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Since Gradle 2.1, the default protocol is `https` for the JCenter repository
    URL. If we want to use the `http` protocol, we must set the `url` property for
    the repository. In the next example build file, we will redefine the `url` property:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 自Gradle 2.1版本以来，JCenter仓库URL的默认协议是`https`。如果我们想使用`http`协议，我们必须为仓库设置`url`属性。在下一个构建文件示例中，我们将重新定义`url`属性：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Optionally, we can assign a name to the repository definition. This can be
    done for all Maven repositories, and because JCenter is also a Maven repository,
    we can set the `name` property. In the following example build file, we define
    multiple repositories and set the `name` property. We add a new task, `repositoriesInfo`,
    which will display the `name` and `URL` properties for each repository:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，我们可以为仓库定义分配一个名称。这可以适用于所有Maven仓库，因为JCenter也是一个Maven仓库，我们可以设置`name`属性。在下面的构建文件示例中，我们定义了多个仓库并设置了`name`属性。我们添加了一个新的任务`repositoriesInfo`，它将显示每个仓库的`name`和`URL`属性：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When we run the `repositoriesInfo` task, we get the following output:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行`repositoriesInfo`任务时，我们得到以下输出：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using the Maven Central repository
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Maven中央仓库
- en: We can configure the central Maven 2 repository in the `repositories` configuration
    block. Gradle provides the shortcut method, `mavenCentral`. This configures the
    central Maven repository with the URL `https://repo1.maven.org/maven2/`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`repositories`配置块中配置中央Maven 2仓库。Gradle提供了快捷方式方法`mavenCentral`。这配置了具有URL
    `https://repo1.maven.org/maven2/`的中央Maven仓库。
- en: 'In the next example build file, we will define the central Maven 2 repository
    for our build:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个构建文件示例中，我们将定义我们的构建的中央Maven 2仓库：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Gradle 2.1 uses the `https` protocol when we use the `mavenCentral` method.
    If we want to use the `http` protocol, we can redefine the `url` property and
    use the `http://repo1.maven.org/maven2/` address. In the next example build file,
    we will redefine the `url` property:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`mavenCentral`方法时，Gradle 2.1使用`https`协议。如果我们想使用`http`协议，我们可以重新定义`url`属性并使用`http://repo1.maven.org/maven2/`地址。在下一个构建文件示例中，我们将重新定义`url`属性：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Besides changing the `url` property, we can also set an optional `name` property
    when we use the `mavenCentral` method. In the following example build script,
    we assign a value to the `name` property. We add a new task, `repositoriesInfo`,
    to display information about the configured repositories:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更改`url`属性外，我们还可以在调用`mavenCentral`方法时设置一个可选的`name`属性。在下面的构建脚本示例中，我们为`name`属性赋值。我们添加了一个新的任务`repositoriesInfo`，用于显示配置的仓库信息：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s invoke the `repositoriesInfo` task to see the output:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用`repositoriesInfo`任务来查看输出：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using the Maven local repository
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Maven本地仓库
- en: If we have used Maven on our local computer before there is a great change,
    we have a local Maven cache with downloaded artifacts. We can use this local cache
    as a repository in our Gradle build, with the `mavenLocal` shortcut method. Although
    it is possible to use our local Maven cache, it is not advisable because it makes
    the build dependent on local settings. If we work on a bigger project with more
    developers, then we cannot rely on the local Maven cache on each developer's computer
    as the only repository.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们之前在我们的本地计算机上使用过Maven，那么我们有一个包含已下载组件的本地Maven缓存。我们可以使用这个本地缓存作为Gradle构建的仓库，使用`mavenLocal`快捷方式方法。尽管可以使用我们的本地Maven缓存，但这样做并不可取，因为它使得构建依赖于本地设置。如果我们在一个由更多开发者组成的大项目上工作，那么我们不能仅依赖每个开发者的计算机上的本地Maven缓存作为唯一的仓库。
- en: 'In the following example build file, we use the `mavenLocal` shortcut method:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的构建文件示例中，我们使用`mavenLocal`快捷方式方法：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The location of the local Maven cache is determined in the same way as Maven.
    Gradle will try to find the `settings.xml` file in `USER_HOME/.m2` or `M2_HOME/conf`,
    where the former takes precedence over the latter. If the `settings.xml` file
    is found, then the location of the local Maven repository defined in the file
    is used. If `settings.xml` cannot be found, or if the local Maven repository location
    is not defined, then the default location is `USER_HOME/.` `m2/repository`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 本地Maven缓存的定位方式与Maven相同。Gradle将尝试在`USER_HOME/.m2`或`M2_HOME/conf`中找到`settings.xml`文件，其中前者优先于后者。如果找到`settings.xml`文件，则使用文件中定义的本地Maven仓库的位置。如果找不到`settings.xml`文件，或者本地Maven仓库的位置未定义，则默认位置为`USER_HOME/.`
    `m2/repository`。
- en: Using Maven repositories
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Maven仓库
- en: 'We have learned about shortcut methods to define a Maven repository. If we
    have our own Maven repository, such as Nexus or Artifactory, we can use the `maven`
    method in the `repositories` configuration block. With this method, we can define
    the `url` property to access the repository. We can see this in action in the
    following example build script:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了定义 Maven 仓库的快捷方法。如果我们有自己的 Maven 仓库，例如 Nexus 或 Artifactory，我们可以在 `repositories`
    配置块中使用 `maven` 方法。使用这种方法，我们可以定义 `url` 属性来访问仓库。我们可以在下面的示例构建脚本中看到这个方法的应用：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When Gradle finds the module dependency descriptor in the Maven repository,
    then the artifacts will be searched for in this repository. If the artifacts are
    stored in another location, we use the `artifactUrls` property to specify the
    location. This way, Gradle will look for the dependency module descriptors in
    the location specified by the `url` property, and for the artifacts in the locations
    specified by the `artifactUrls` property.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Gradle 在 Maven 仓库中找到模块依赖描述符时，将在这个仓库中搜索这些工件。如果工件存储在其他位置，我们使用 `artifactUrls`
    属性来指定位置。这样，Gradle 将在 `url` 属性指定的位置查找依赖模块描述符，并在 `artifactUrls` 属性指定的位置查找工件。
- en: 'The next example build script will define a custom Maven repository, with multiple
    locations for the artifacts:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例构建脚本将定义一个自定义的 Maven 仓库，并为工件指定多个位置：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we have configured our custom Maven repository with basic authentication,
    we must provide a username and password to access the repository. In our Gradle
    build file, we set the username and password in the `credentials` block of the
    `maven` configuration. Let''s first add the username and password to the build
    file and later see how we can externalize these properties. The next example build
    file will use the `credentials` configuration block:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经配置了带有基本身份验证的自定义 Maven 仓库，我们必须提供用户名和密码来访问该仓库。在我们的 Gradle 构建文件中，我们在 `maven`
    配置的 `credentials` 块中设置用户名和密码。让我们首先将用户名和密码添加到构建文件中，然后稍后看看我们如何将这些属性外部化。下一个示例构建文件将使用
    `credentials` 配置块：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It is not a good idea to add the username and password to the build file, because
    this file is shared with all the developers involved in our project. We fix this
    using project properties, instead of a hardcoded username and password. The values
    of the project properties can be set via the command line with the `-P` or `--project-prop`
    options. Or, we can add the `gradle.properties` file to our project with the names
    and values of the project properties. The `gradle.properties` file must not be
    put in the version control system of our project, so that the values are private
    for the developer.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将用户名和密码添加到构建文件中不是一个好主意，因为这个文件是与参与我们项目的所有开发者共享的。我们使用项目属性来解决这个问题，而不是使用硬编码的用户名和密码。项目属性的值可以通过命令行使用
    `-P` 或 `--project-prop` 选项来设置。或者，我们可以在项目目录中创建 `gradle.properties` 文件，包含项目属性的名称和值。`gradle.properties`
    文件不应放入我们项目的版本控制系统中，这样值对开发者来说是私有的。
- en: 'The following example build file uses the `mavenUsername` project properties
    and `mavenPassword` for the Maven repository credentials:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例构建文件使用 `mavenUsername` 项目属性和 `mavenPassword` 作为 Maven 仓库的凭证：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When we execute any tasks for this script, we should provide the values for
    the project properties via the command line:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为此脚本执行任何任务时，我们应该通过命令行提供项目属性的值：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Or, we can create the `gradle.properties` file in the project directory, with
    the following contents:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以在项目目录中创建 `gradle.properties` 文件，内容如下：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we have multiple projects that use the same custom Maven repository, then
    we can also create a Gradle init script with the correct credentials. A Gradle
    init script runs before the build starts. In the script, we want to set the credentials
    for a Maven repository with a specific name. There are several ways to use an
    init script:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有多个使用相同自定义 Maven 仓库的项目，我们还可以创建一个带有正确凭证的 Gradle init 脚本。Gradle init 脚本在构建开始之前运行。在脚本中，我们希望为具有特定名称的
    Maven 仓库设置凭证。使用 init 脚本有几种方法：
- en: We can use an init script directly from the command line with the `-I` or `--init-script`
    options. Here, we specify the name of the init script.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以直接从命令行使用带有 `-I` 或 `--init-script` 选项的 init 脚本。在这里，我们指定 init 脚本的名字。
- en: We put the `init.gradle` file in the `USER_HOME/.gradle` directory. This file
    is run before every Gradle build on our computer.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将 `init.gradle` 文件放在 `USER_HOME/.gradle` 目录中。这个文件在我们计算机上每次执行 Gradle 构建之前都会运行。
- en: We put a file with the`.gradle` extension in the `USER_HOME/.gradle/init.d`
    directory. All Gradle init scripts from this directory are run before every build.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在`USER_HOME/.gradle/init.d`目录中放置了一个以`.gradle`扩展名的文件。所有来自此目录的Gradle初始化脚本都会在每次构建之前运行。
- en: We put a file with the `.gradle` extension in the `GRADLE_HOME/init.d` directory.
    This way, we can package a custom Gradle distribution with init scripts that always
    need to be executed.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在`GRADLE_HOME/init.d`目录中放置了一个以`.gradle`扩展名的文件。这样，我们可以打包一个带有始终需要执行的初始化脚本的自定义Gradle发行版。
- en: 'Let''s take a look at the contents of the init script in the next example init
    script file:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一个示例初始化脚本文件中的初始化脚本内容：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We must change our project Gradle build file, because the credentials are now
    set via an init script. We will remove the credentials from the project build
    file. In the next example build file, we will remove the credentials and helper
    method, to set the credential properties. The credentials are set by the init
    script. The following code shows this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须更改我们的项目Gradle构建文件，因为凭证现在是通过初始化脚本设置的。我们将从项目构建文件中删除凭证。在下一个示例构建文件中，我们将删除凭证和辅助方法，以设置凭证属性。凭证由初始化脚本设置。以下代码显示了这一点：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Using the flat directory repository
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用平面目录仓库
- en: 'Gradle also allows directories to be used as repositories to solve dependencies.
    We can specify one or more directories using the `flatDir` method. Optionally,
    we can specify a name for the repository. In the next example build file, we specify
    the `lib` and `jars` directories to be used as repositories:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle还允许使用目录作为仓库来解决依赖项。我们可以使用`flatDir`方法指定一个或多个目录。可选地，我们可以为仓库指定一个名称。在下一个示例构建文件中，我们指定了`lib`和`jars`目录作为仓库：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When we use the flat directory repository, Gradle resolves dependency artifacts
    based on the artifact name and version. The group part of a dependency is ignored.
    If we only use flat directory repositories in our project, we can even leave out
    the group part when we configure the dependencies. Gradle uses the following rules
    to resolve a dependency:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用平面目录仓库时，Gradle根据工件名称和版本解析依赖项工件。依赖项的组部分被忽略。如果我们只在项目中使用平面目录仓库，我们甚至可以在配置依赖项时省略组部分。Gradle使用以下规则来解析依赖项：
- en: '[artifact]-[version].[ext]'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[artifact]-[version].[ext]`'
- en: '[artifact]-[version]-[classifier].[ext]'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[artifact]-[version]-[classifier].[ext]`'
- en: '[artifact].[ext]'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[artifact].[ext]`'
- en: '[artifact]-[classifier].[ext]'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[artifact]-[classifier].[ext]`'
- en: 'In the next example build file, we will define a flat directory repository
    and a single dependency:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例构建文件中，我们将定义一个平面目录仓库和一个单一依赖项：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Gradle will resolve the following files in the `lib` directory; the first matching
    file is used:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle将在`lib`目录中解析以下文件；使用第一个匹配的文件：
- en: '`pedestrian-1.0.jar`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pedestrian-1.0.jar`'
- en: '`pedestrian-1.0-jdk16.jar`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pedestrian-1.0-jdk16.jar`'
- en: '`pedestr``ian.jar`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pedestr``ian.jar`'
- en: '`pedestrian-jdk16.jar`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pedestrian-jdk16.jar`'
- en: Using Ivy repositories
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Ivy仓库
- en: Ivy repositories allow customizable and flexible repository layout patterns.
    Gradle supports Ivy repositories, and we can configure the repository layout patterns
    in our Gradle build script. To define an Ivy repository, we use the `ivy` method
    in the `repositories` configuration block.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Ivy仓库允许自定义和灵活的仓库布局模式。Gradle支持Ivy仓库，我们可以在我们的Gradle构建脚本中配置仓库布局模式。要定义一个Ivy仓库，我们在`repositories`配置块中使用`ivy`方法。
- en: 'In the following example build file, we define a standard Ivy repository, and
    we also set the optional `name` property for the repository:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例构建文件中，我们定义了一个标准的Ivy仓库，并且我们还为仓库设置了可选的`name`属性：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The layout of an Ivy repository defines the patterns used to search module
    dependency metadata and the dependency artifacts. We can use some predefined layouts
    in our build scripts. In the previous example build file, we didn''t specify a
    layout. Gradle will then use the default `gradle` layout. The next table shows
    the different layout names we can use, their patterns to find the Ivy metadata
    XML files, and the artifacts for the dependency:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Ivy仓库的布局定义了用于搜索模块依赖元数据和依赖项的模式的布局。我们可以在我们的构建脚本中使用一些预定义的布局。在先前的示例构建文件中，我们没有指定布局。然后Gradle将使用默认的`gradle`布局。下表显示了我们可以使用的不同布局名称，它们用于查找Ivy元数据XML文件和依赖项的工件：
- en: '| Name | Ivy pattern | Artifact pattern |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | Ivy模式 | 工件模式 |'
- en: '| --- | --- | --- |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| gradle | `[organisation]/[module]/[revision]/ivy-[revision].xml` | `[organisation]/[module]/[revision]/[artifact]-[revision](-[classifier])(.[ext])`
    |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| gradle | `[organisation]/[module]/[revision]/ivy-[revision].xml` | `[organisation]/[module]/[revision]/[artifact]-[revision](-[classifier])(.[ext])`
    |'
- en: '| maven | `[organisation]/[module]/[revision]/ivy-[revision].xml` | `[organisation]/[module]/[revision]/[artifact]-[revision](-[classifier])(.[ext])`
    |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| maven | `[organisation]/[module]/[revision]/ivy-[revision].xml` | `[organisation]/[module]/[revision]/[artifact]-[revision](-[classifier])(.[ext])`
    |'
- en: '| ivy | `[organisation]/[module]/[revision]/[type]s/[artifact](.[ext])` | `[organisation]/[module]/[revision]/[type]s/[artifact](.[ext])`
    |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| ivy | `[organisation]/[module]/[revision]/[type]s/[artifact](.[ext])` | `[organisation]/[module]/[revision]/[type]s/[artifact](.[ext])`
    |'
- en: The `.` in `organisation` is replaced with `/`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`organisation` 中的 `.` 被替换为 `/`。'
- en: 'To use a layout, we use the `layout` method inside the `ivy` configuration.
    For example, in the next build script, we use the `maven` and `ivy` layouts:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用布局，我们在 `ivy` 配置中使用 `layout` 方法。例如，在下一个构建脚本中，我们使用 `maven` 和 `ivy` 布局：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To define a custom pattern for the Ivy XML files and the artifacts, we use
    the `pattern` layout. With this layout, we define our own patterns using the tokens
    defined by Ivy. In the following table, we see the tokens that can be used to
    build a pattern:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 Ivy XML 文件和工件定义自定义模式，我们使用 `pattern` 布局。使用此布局，我们使用 Ivy 定义的令牌定义自己的模式。在以下表中，我们可以看到可以用来构建模式的令牌：
- en: '| Token | Description |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 令牌 | 描述 |'
- en: '| --- | --- |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [organisation] | This is the organisation name. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| [organisation] | 这是组织名称。 |'
- en: '| [orgPath] | This is the organisation name, where `.` has been replaced by
    `/`. This can be used to configure maven2-like repositories. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| [orgPath] | 这是组织名称，其中 `.` 已被替换为 `/`。这可以用来配置类似 Maven2 的仓库。 |'
- en: '| [module] | This is the module name. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| [module] | 这是模块名称。 |'
- en: '| [branch] | This is the branch name. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| [branch] | 这是分支名称。 |'
- en: '| [revision] | This is the revision name. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| [revision] | 这是修订名称。 |'
- en: '| [artifact] | This is the artifact name (or ID). |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| [artifact] | 这是工件名称（或 ID）。 |'
- en: '| [type] | This is the artifact type. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| [type] | 这是工件类型。 |'
- en: '| [ext] | This is the artifact file extension. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| [ext] | 这是工件文件扩展名。 |'
- en: '| [conf] | This is the configuration name. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| [conf] | 这是配置名称。 |'
- en: '| [originalname] | This is the original artifact name (including the extension).
    |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| [originalname] | 这是原始工件名称（包括扩展名）。 |'
- en: To specify an optional token, we enclose the token with parentheses (`(` and
    `)`). If the token defined between parentheses is null or empty, then the token
    is ignored. For example, the `[artifact](-[revision]).[ext]` pattern will accept
    `artifact.jar` if `revision` is not set and `artifact-1.1.jar` if `revision` is
    set.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 指定一个可选的令牌时，我们将令牌用括号（`(` 和 `)`）括起来。如果括号中定义的令牌为空或为空字符串，则忽略该令牌。例如，`[artifact](-[revision]).[ext]`
    模式在未设置 `revision` 时将接受 `artifact.jar`，如果设置了 `revision`，则接受 `artifact-1.1.jar`。
- en: We define a custom layout in our build script by specifying the layout with
    the `pattern` name, and adding a configuration block where we define the patterns
    for the Ivy XML files and artifacts. If we don't specify a special pattern for
    the Ivy XML files, then the artifact pattern is used. We need to define at least
    one artifact pattern. The patterns are appended to the `url` property of the repository.
    Optionally, we can set the `pattern` layout property, `m2compatible`. If the value
    is `true`, then the `.` in the `[organisation]` token is replaced with `/`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过指定 `pattern` 名称并在其中添加一个配置块来定义 Ivy XML 文件和工件的模式来在我们的构建脚本中定义自定义布局。如果我们没有为
    Ivy XML 文件指定特殊模式，则使用工件模式。我们需要定义至少一个工件模式。这些模式附加到仓库的 `url` 属性。可选地，我们可以设置 `pattern`
    布局属性 `m2compatible`。如果值为 `true`，则 `[organisation]` 令牌中的 `.` 被替换为 `/`。
- en: 'In the next example build script, we will define two new repositories with
    a custom layout:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例构建脚本中，我们将定义两个具有自定义布局的新仓库：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'An alternative syntax to define custom patterns is using `artifactPattern`
    and `ivyPattern` inside the `ivy` configuration block. We don''t have to use the
    `layout` method with this definition. If we don''t specify `ivyPattern`, then
    the pattern defined with `artifactPattern` is used to find Ivy XML files. In the
    following example build script, we rewrite the repository definitions from the
    previous example build file:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 定义自定义模式的另一种语法是在 `ivy` 配置块中使用 `artifactPattern` 和 `ivyPattern`。我们不需要使用 `layout`
    方法进行此定义。如果我们没有指定 `ivyPattern`，则使用 `artifactPattern` 定义的模式来查找 Ivy XML 文件。在以下示例构建脚本中，我们重写了上一个示例构建文件中的仓库定义：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To specify the username and password for an Ivy repository with basic authentication,
    we use the `credentials` method, just as we did with the Maven repositories. In
    the next example build file, we will set the credentials to access an Ivy repository.
    Take a look at the section about Maven repositories to see how we can externalize
    the username and password, so that they are not part of the build script code.
    The following code shows this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要为具有基本身份验证的 Ivy 仓库指定用户名和密码，我们使用 `credentials` 方法，就像我们在 Maven 仓库中所做的那样。在下一个示例构建文件中，我们将设置访问
    Ivy 仓库的凭证。查看有关 Maven 仓库的部分，了解我们如何外部化用户名和密码，以便它们不是构建脚本代码的一部分。以下代码显示了这一点：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Using different protocols
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用不同的协议
- en: The Maven and Ivy repositories can be accessed via several protocols. We already
    learned that we can use the `http` and `https` protocols. However, we can also
    use the `file` and `sftp` protocols. We must provide credentials when we use the
    `sftp` protocol. The `file` protocol doesn't support authentication.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 和 Ivy 仓库可以通过多种协议访问。我们已经了解到我们可以使用 `http` 和 `https` 协议。然而，我们也可以使用 `file`
    和 `sftp` 协议。当我们使用 `sftp` 协议时，我们必须提供凭证。`file` 协议不支持身份验证。
- en: 'The next example build file will use the `file` and `sftp` protocols to define
    the Maven and Ivy repositories:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例构建文件将使用 `file` 和 `sftp` 协议来定义 Maven 和 Ivy 仓库：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Summary
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you learned how to define repositories in your Gradle build
    scripts. You saw how to use predefined shortcut methods: `jcenter`, `mavenCentral`,
    and `mavenLocal`. To access a Maven repository at a custom location, we can use
    the `url` property and the `maven` method. When we configure an Ivy repository,
    we have the most control. We can specify a URL, and also the layout pattern of
    the repository. You learned that you can also use a flat directory repository
    in your build scripts.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在 Gradle 构建脚本中定义仓库。你看到了如何使用预定义的快捷方法：`jcenter`、`mavenCentral` 和 `mavenLocal`。要访问位于自定义位置的
    Maven 仓库，我们可以使用 `url` 属性和 `maven` 方法。当我们配置 Ivy 仓库时，我们拥有最大的控制权。我们可以指定一个 URL，也可以指定仓库的布局模式。你了解到你还可以在你的构建脚本中使用平面目录仓库。
- en: You saw how to provide credentials for repositories with basic authentication.
    You now know how to save the username and password outside your build script.
    Finally, you learned how to use different transport protocols to access repositories.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了如何为具有基本身份验证的仓库提供凭证。现在你知道了如何将用户名和密码保存在构建脚本之外。最后，你学习了如何使用不同的传输协议来访问仓库。
- en: In the next chapter, we will see how Gradle will resolve dependencies.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到 Gradle 将如何解析依赖项。
