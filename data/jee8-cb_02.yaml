- en: Server-Side Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端开发
- en: Java EE can be seen as being **made for server-side development**. Most of the
    APIs are powerful for server-side processing and managing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE可以看作是专为服务器端开发而设计的。大多数API都针对服务器端处理和管理非常强大。
- en: This chapter will provide you with some common and useful scenarios that you
    may face as a Java EE developer and will show you how you should deal with them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将为您提供一些作为Java EE开发者可能会遇到的一些常见和有用的场景，并展示您应该如何处理它们。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下菜谱：
- en: Using CDI to inject context and dependency
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CDI注入上下文和依赖
- en: Using Bean Validation for data validation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Bean Validation进行数据验证
- en: Using servlet for request and response management
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Servlet进行请求和响应管理
- en: Using Server Push to make objects available beforehand
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务器推送来预先提供对象
- en: Using EJB and JTA for transaction management
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用EJB和JTA进行事务管理
- en: Using EJB to deal with concurrency
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用EJB处理并发
- en: Using JPA for smart data persistence
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JPA进行智能数据持久化
- en: Using EJB and JPA for data caching
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用EJB和JPA进行数据缓存
- en: Using batch processing
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用批处理
- en: Using CDI to inject context and dependency
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CDI注入上下文和依赖
- en: Context and Dependency Injection for Java EE (CDI) is one of the most important
    APIs under the Java EE umbrella. Introduced in Java EE 6, it now has a big influence
    over many other APIs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE上下文和依赖注入（CDI）是Java EE范围内最重要的API之一。自Java EE 6引入以来，它现在对许多其他API产生了重大影响。
- en: In the recipe, you will learn how to use CDI in a couple of different ways and
    situations.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，您将学习如何以几种不同的方式和情况使用CDI。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'First, let''s add the required dependency needed:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们添加所需的依赖项：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We are going to build a JAX-RS based application, so we will start by preparing
    the application to perform:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将构建一个基于JAX-RS的应用程序，因此我们将首先准备应用程序以执行：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we create a `User` application as our main object:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个`User`应用程序作为我们的主要对象：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Our `User` class doesn''t have a default constructor, so CDI doesn''t know
    how to construct the class when it tries to inject it. So, we create a factory
    class and use the `@Produces` annotation over its methods:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`User`类没有默认构造函数，所以当CDI尝试注入它时不知道如何构建这个类。因此，我们创建一个工厂类，并在其方法上使用`@Produces`注解：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s create an enumeration to list our profile types:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个枚举来列出我们的配置类型：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we create a custom annotation:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个自定义注解：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add them to an interface to prototype the user profile behavior:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它们添加到接口中以原型化用户配置文件行为：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that we have defined the profile list and its behavior with respect to
    the user, we can give it a proper implementation for an admin profile:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了配置列表及其与用户的关联行为，我们可以为管理员配置文件提供一个适当的实现：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And the same can be done for an operator profile:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，也可以为操作员配置文件做同样的事情：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we create a REST endpoint by injecting all the objects that we are going
    to use into it:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过将其将要使用的所有对象注入其中来创建一个REST端点：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This method gets the user injected by CDI and sends it to the result page:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个方法通过CDI注入用户并将其发送到结果页面：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This one does the same with an admin profile:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个与管理员配置文件做的是同样的事情：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And this one does the same with an operator profile:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个与操作员配置文件做的是同样的事情：
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we send the default profile to the result page:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将默认配置发送到结果页面：
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We use the `fireUserEvents` method to fire an event and async events over a previously
    injected `User` object:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`fireUserEvents`方法触发一个事件和异步事件，针对之前注入的`User`对象：
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'So, we build a page to call each endpoint method:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们构建一个页面来调用每个端点方法：
- en: '[PRE15]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And finally, we use an expression language to print the result at the result
    page:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用表达式语言在结果页面上打印结果：
- en: '[PRE16]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Well, there''s a lot happening in the previous section! We should first have
    a look at the `@Produces` annotation. It is a CDI annotation that says to the
    server: "*Hey! This method knows how to construct a User object.*"'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，上一节中发生了很多事情！我们首先应该看看`@Produces`注解。这是一个CDI注解，它告诉服务器：“嘿！这个方法知道如何构建一个User对象。”
- en: As we didn't create a default constructor for the `User` class, the `getUser`
    method from our factory will be injected into our context as one.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有为`User`类创建默认构造函数，因此我们的工厂中的`getUser`方法将被注入到我们的上下文中作为其中一个。
- en: The second annotation is our custom annotation `@Profile` that has our enumeration
    `ProfileType` as a parameter. It is the qualifier of our `UserProfile` objects.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个注解是我们自定义的`@Profile`注解，它以我们的枚举`ProfileType`作为参数。它是`UserProfile`对象的限定符。
- en: 'Now, let''s have a look at these declarations:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这些声明：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This code will *teach* CDI how to inject a `UserProfile` object:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将*教导*CDI如何注入一个`UserProfile`对象：
- en: If the object is annotated as `@Profile(ProfileType.ADMIN)`, use `ImplAdmin`
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对象被标注为`@Profile(ProfileType.ADMIN)`，则使用`ImplAdmin`
- en: If the object is annotated as `@Profile(ProfileType.OPERATOR)`, use `ImplOperator`
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对象被标注为`@Profile(ProfileType.OPERATOR)`，则使用`ImplOperator`
- en: If the object is not annotated, use `ImplOperator`, as it has the `@Default`
    annotation
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对象没有被标注，则使用`ImplOperator`，因为它有`@Default`注解
- en: 'We can see them in action in our endpoint declaration:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的端点声明中看到它们的作用：
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: So CDI is helping us to use the context to inject the right implementation of
    our `UserProfile` interface.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，CDI正在帮助我们使用上下文来注入我们的`UserProfile`接口的正确实现。
- en: 'Looking at the endpoint methods, we see this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 看看端点方法，我们看到这个：
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that we included `HttpServletRequest` and `HttpServletResponse` as parameters
    for our method, but annotated them as `@Context`. So even though this is not a
    servlet context (when we have easy access to request and response references),
    we can ask CDI to give us a proper reference to them.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们为我们的方法包含了`HttpServletRequest`和`HttpServletResponse`作为参数，但将它们标注为`@Context`。所以即使这不是servlet上下文（当我们容易访问请求和响应引用时），我们也可以要求CDI给我们提供适当的引用。
- en: 'And finally, we have our user event engine:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有我们的用户事件引擎：
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'So, we are using the `@Observes` and `@ObserversAsync` annotations to say to
    CDI: "*Hey CDI! Watch over User object... when somebody fires an event over it,
    I want you to do something.*"'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们使用`@Observes`和`@ObserversAsync`注解告诉CDI：“*嘿CDI！监视User对象...当有人在其上触发事件时，我想让你做点什么。*”
- en: And for "something," CDI understands this as calling the `sendUserNotification`
    and `sendUserNotificationAsync` methods. Try it!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于“某物”，CDI将其理解为调用`sendUserNotification`和`sendUserNotificationAsync`方法。试试看！
- en: Obviously, `@Observers` will be executed synchronously and `@ObservesAsync`
    asynchronously.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`@Observers`将同步执行，而`@ObservesAsync`将异步执行。
- en: There's more...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We used a GlassFish 5 to run this recipe. You can do it with whatever Java EE
    8 compatible server you want, and you can even use CDI with Java SE without any
    server. Have a look at the CDI recipe from [Chapter 1](86071f26-42aa-43e2-8409-6feaed4759e0.xhtml),
    *New Features and Improvements*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用GlassFish 5来运行这个菜谱。你可以使用任何你想要的Java EE 8兼容服务器，你甚至可以在没有服务器的情况下使用CDI与Java SE。看看[第1章](86071f26-42aa-43e2-8409-6feaed4759e0.xhtml)的CDI菜谱，*新特性和改进*。
- en: See also
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: You can see the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-cdi](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-cdi)
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-cdi](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-cdi)查看这个菜谱的完整源代码
- en: Using Bean Validation for data validation
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Bean Validation进行数据验证
- en: You can use Bean Validation to constrain your data in many different ways. In
    this recipe, we are going to use it to validate a JSF form, so we can validate
    it as soon as the user tries to submit it, and avoid any invalid data right away.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用Bean Validation以许多不同的方式约束你的数据。在这个菜谱中，我们将使用它来验证JSF表单，这样我们就可以在用户尝试提交时立即进行验证，并立即避免任何无效数据。
- en: Getting ready
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: 'First, we add our dependencies:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加我们的依赖项：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How to do it...
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Let''s create a `User` object that will be attached to our JSF page:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个将被附加到我们的JSF页面的`User`对象：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then we define the method that will be fired once all data is valid:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义一个方法，当所有数据都有效时将触发：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And now our JSF page references each `User` class fields declared:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们JSF页面引用了每个`User`类声明的字段：
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, if you run this code, you will get all fields validated once you click
    the Submit button. Try it!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行这段代码，一旦你点击提交按钮，你将得到所有字段的验证。试试看！
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s check each declared constraint:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查每个声明的约束：
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `@NotBlank` annotation will deny not only null values, but also white spaces
    values, and `@Size` speaks for itself:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`@NotBlank`注解不仅拒绝null值，还拒绝空白值，而`@Size`则不言自明：'
- en: '[PRE26]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `@Email` constraint will check the email string format:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Email`约束将检查电子邮件字符串格式：'
- en: '[PRE27]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`@PastOrPresent` will constrain `LocalDate` to be in the past or until the
    present date. It can''t be in the future.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`@PastOrPresent`将`LocalDate`约束为过去或直到当前日期。它不能在未来。'
- en: 'Here we can''t use `@NotBlank`, as there is no blank date, only null, so we
    avoid it using `@NotNull`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不能使用`@NotBlank`，因为没有空白日期，只有null，所以我们使用`@NotNull`来避免它：
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is the same as the last one, but constraints for a future date.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这与上一个相同，但约束条件是未来的日期。
- en: 'In our UI, there are two places worth a careful look:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 UI 中，有两个地方值得仔细查看：
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We are using `convertDateTime` to automatically convert the data inputted into
    `inputText` according to the `dd/MM/uuuu` pattern.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `convertDateTime` 自动将输入到 `inputText` 中的数据转换为 `dd/MM/uuuu` 格式。
- en: See also
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: You can check the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-beanvalidation](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-beanvalidation)
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-beanvalidation](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-beanvalidation)
    查看这个配方的完整源代码。
- en: Using servlet for request and response management
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 servlet 进行请求和响应管理
- en: The Servlet API was created even before Java EE exists—actually before J2EE
    existed! It became part of EE in J2EE 1.2 (Servlet 2.2) in 1999.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Servlet API 是在 Java EE 存在之前创建的——实际上是在 J2EE 存在之前！它在 1999 年的 J2EE 1.2（Servlet
    2.2）中成为 EE 的一部分。
- en: This is a powerful tool to deal with a request/response context and this recipe
    will show you an example of how to do it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个处理请求/响应上下文的有力工具，这个配方将展示如何操作的示例。
- en: Getting ready
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s add our dependencies:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加我们的依赖项：
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How to do it...
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s create a `User` class for our recipe:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为我们的配方创建一个 `User` 类：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And then our servlet:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后是我们的 servlet：
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We use the `@PostConstruct` annotation over the `instantiateUser()` method.
    It says to the server that whenever this servlet is constructed (a new instance
    is up), it can run this method.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `instantiateUser()` 方法上使用 `@PostConstruct` 注解。它告诉服务器，每当这个 servlet 被构建（一个新的实例被创建）时，它可以运行这个方法。
- en: 'We also implement the `init()` and `destroy()` super methods:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还实现了 `init()` 和 `destroy()` 超类方法：
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And we also implemented `doGet()` and `doPost()`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还实现了 `doGet()` 和 `doPost()`：
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Both `doGet()` and `doPost()` will call our custom method `doRequest()`:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`doGet()` 和 `doPost()` 都将调用我们的自定义方法 `doRequest()`：'
- en: '[PRE35]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And we finally have a web page to call our servlet:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有一个网页可以调用我们的 servlet：
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Java EE server itself will call `doGet()` or `doPost()` methods, depending
    on the HTTP method used by the caller. In our recipe, we are redirecting them
    both to the same `doRequest()` method.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 服务器本身将根据调用者使用的 HTTP 方法调用 `doGet()` 或 `doPost()` 方法。在我们的配方中，我们将它们都重定向到同一个
    `doRequest()` 方法。
- en: The `init()` method belongs to the servlet life cycle managed by the server
    and is executed as a first method after the servlet instantiation.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`init()` 方法属于由服务器管理的 servlet 生命周期，并在 servlet 实例化后作为第一个方法执行。'
- en: The `destroy()` method also belongs to the servlet life cycle and it's executed
    as the last method before the instance deallocation.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`destroy()` 方法也属于 servlet 生命周期，并在实例释放前作为最后一个方法执行。'
- en: There's more...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `init()` behavior seems like `@PostConstruct`, but this last one is executed
    before `init()`, so keep it in mind when using both.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`init()` 的行为类似于 `@PostConstruct`，但最后一个是在 `init()` 之前执行的，所以使用两者时要记住这一点。'
- en: The `@PostConstruct` is executed right after the default constructor.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`@PostConstruct` 在默认构造函数之后执行。'
- en: Be careful when using the `destroy()` method and avoid holding any memory reference; otherwise,
    you can mess up with the servlet life cycle and run into memory leaks.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `destroy()` 方法时要小心，避免持有任何内存引用；否则，你可能会搞乱 servlet 生命周期并遇到内存泄漏。
- en: See also
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Check the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-servlet](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-servlet)
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-servlet](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-servlet)
    查看这个配方的完整源代码。
- en: Using Server Push to make objects available beforehand
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用服务器推送提前使对象可用
- en: One of the most important new features of Servlet 4.0 is the HTTP/2.0 support.
    It brings another cool and reliable feature—the Server Push.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Servlet 4.0 最重要的新特性之一是 HTTP/2.0 支持。它带来了另一个酷且可靠的功能——服务器推送。
- en: This recipe will show you how to use Server Push in a filter and push the resources
    needed in every request that we want.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将展示如何在过滤器中使用服务器推送并在每个请求中推送所需的资源。
- en: Getting ready
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We should first add the dependencies needed:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先应该添加所需的依赖项：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We first create `UserServlet` that calls `user.jsp`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建 `UserServlet`，它调用 `user.jsp`：
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And we do the same with `ProfileServlet`, but by calling `profile.jsp`:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还用 `ProfileServlet` 做同样的操作，但通过调用 `profile.jsp`：
- en: '[PRE39]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And then we create a filter that will be executed on every request (`urlPatterns
    = {"/*"}`):'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建一个将在每个请求上执行的过滤器（`urlPatterns = {"/*"}`）：
- en: '[PRE40]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here we create a page to call our servlets:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个页面来调用我们的servlets：
- en: '[PRE41]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And here are the pages called by the servlets. First is the `user.jsp` page:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是servlets调用的页面。首先是`user.jsp`页面：
- en: '[PRE42]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Second, the `profile.jsp` page is called:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，调用`profile.jsp`页面：
- en: '[PRE43]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works...
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A web application running under HTTP/1.0 sends a request to the server when
    it finds references for an image file, CSS file, and any other resources needed
    to render a web page.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTTP/1.0下运行的Web应用程序在找到图像文件、CSS文件和其他渲染网页所需的资源引用时向服务器发送请求。
- en: 'With HTTP/2.0 you still can do it, but now you can do better: the server can
    now push the resources beforehand, avoiding unnecessary new requests, decreasing
    the server load, and improving performance.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTTP/2.0您仍然可以这样做，但现在您可以做得更好：服务器现在可以预先推送资源，避免不必要的新的请求，减少服务器负载，并提高性能。
- en: 'In this recipe, our resources are represented by the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在此菜谱中，我们的资源由以下表示：
- en: '[PRE44]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'And the push happens at this part of our filter:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 推送发生在我们过滤器的这个部分：
- en: '[PRE45]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: So when the browser needs those resources to render the web page, they are already
    available.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当浏览器需要这些资源来渲染网页时，它们已经可用。
- en: There's more...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Note that your browser needs to support the Server Push feature; otherwise,
    your page will work as usual. So make sure you check if `PushBuilder` is null
    before using it and ensure all users will have the working application.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您的浏览器需要支持服务器推送功能；否则，您的页面将像往常一样工作。所以请确保在使用`PushBuilder`之前检查它是否为null，并确保所有用户都将拥有一个正常工作的应用程序。
- en: Note that JSF 2.3 is built over the Server Push feature, so if you just migrate
    your JSF application to a Java EE 8 compatible server, you get its performance
    boost for free!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，JSF 2.3是基于服务器推送功能构建的，所以如果您只是将您的JSF应用程序迁移到Java EE 8兼容的服务器，您将免费获得其性能提升！
- en: See also
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: View the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-serverpush](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-serverpush)
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-serverpush](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-serverpush)查看此菜谱的完整源代码
- en: Using EJB and JTA for transaction management
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用EJB和JTA进行事务管理
- en: The Java Transaction API, or JTA, is an API that enables distributed transactions
    over the Java EE environment. It is most powerful when you delegate the transaction
    management to the server.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Java事务API，或称JTA，是一个允许在Java EE环境中进行分布式事务的API。当您将事务管理委托给服务器时，它最为强大。
- en: This recipe will show you how to do it!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱将向您展示如何做到这一点！
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First, add the dependencies:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，添加依赖项：
- en: '[PRE46]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How to do it...
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, we need to create our persistence unit (at `persistence.xml`):'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建我们的持久化单元（在`persistence.xml`中）：
- en: '[PRE47]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then we create a `User` class as an entity (`@Entity`):'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个`User`类作为实体（`@Entity`）：
- en: '[PRE48]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We also need an EJB to perform the operations over the `User` entity:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个EJB来执行对`User`实体的操作：
- en: '[PRE49]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'And then we create our unit test:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建我们的单元测试：
- en: '[PRE50]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How it works...
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The key code line in this recipe for JTA is right here:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱中JTA的关键代码行就在这里：
- en: '[PRE51]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'When you use `transaction-type=''JTA''`, you are saying to the server that
    it should take care of all transactions made under this context. If you use `RESOURCE-LOCAL`
    instead, you are saying that you are taking care of the transactions:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`transaction-type='JTA'`时，您是在告诉服务器，它应该处理在此上下文中进行的所有事务。如果您使用`RESOURCE-LOCAL`，则表示您正在处理事务：
- en: '[PRE52]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Each called method of `UserBean` starts a transaction to be completed and would
    run into a rollback if there's any issue while the transaction is alive would
    commit to the end of it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserBean`的每个被调用方法都会启动一个事务以完成，如果在事务活跃期间出现任何问题，则会回滚；如果事务顺利完成，则会提交。'
- en: There's more...
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Another important piece of code is the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 另一段重要的代码如下：
- en: '[PRE53]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: So, here we are defining our `PersistenceContext` as `EXTENDED`. It means that
    this persistence context is bound to the `@Stateful` bean until it is removed
    from the container.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在这里将我们的`PersistenceContext`定义为`EXTENDED`。这意味着此持久化上下文绑定到`@Stateful`豆，直到它从容器中移除。
- en: The other option is `TRANSACTION`, which means the persistence context would
    live only by the time of transaction.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是`TRANSACTION`，这意味着持久化上下文将仅在事务期间存在。
- en: See also
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: Check the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-jta](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-jta)
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-jta](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-jta)查看此菜谱的完整源代码
- en: Using EJB to deal with concurrency
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用EJB处理并发
- en: Concurrency management is one of the biggest advantages supplied by a Java EE
    server. You can rely on a ready environment to deal with this tricky topic.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 并发管理是Java EE服务器提供的最大优势之一。你可以依赖一个现成的环境来处理这个棘手的话题。
- en: This recipe will show you how you can set up your beans to use it!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱将向您展示如何设置您的bean以使用它！
- en: Getting ready
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Just add a Java EE dependency to your project:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将Java EE依赖项添加到您的项目中：
- en: '[PRE54]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How to do it...
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The recipe will show you three scenarios.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱将展示三个场景。
- en: 'In the first scenario, `LockType` is defined at the class level:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个场景中，`LockType`在类级别定义：
- en: '[PRE55]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In the second scenario, `LockType` is defined at the method level:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个场景中，`LockType`在方法级别定义：
- en: '[PRE56]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The third scenario is a self-managed bean:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个场景是一个自管理bean：
- en: '[PRE57]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How it works...
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The first thing to have a look at the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 首先看看以下内容：
- en: '[PRE58]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This is completely redundant! Singleton beans are container-managed by default,
    so you don't need to specify them.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全是多余的！单例bean默认由容器管理，因此您不需要指定它们。
- en: Singletons are designed for concurrent access, so they are the perfect use case
    for this recipe.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 单例设计用于并发访问，因此它们是此菜谱的完美用例。
- en: 'Now let''s check the `LockType` defined at the class level:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查在类级别定义的`LockType`：
- en: '[PRE59]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: When we use the `@Lock` annotation at the class level, the informed `LockType` will
    be used for all class methods.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在类级别使用`@Lock`注解时，通知的`LockType`将用于所有类方法。
- en: In this case, `LockType.READ` means that many clients can access a resource
    at the same time. It is usual for reading data.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`LockType.READ`意味着许多客户端可以同时访问一个资源。这在读取数据时很常见。
- en: In case of some kind of locking, `LockType` will use the `@AccessTimeout` annotation
    time defined to run into a timeout or not.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在锁定的情况下，`LockType`将使用`@AccessTimeout`注解定义的时间来决定是否运行到超时。
- en: 'Now, let''s check `LockType` defined at the method level:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查在方法级别定义的`LockType`：
- en: '[PRE60]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: So, here we are basically saying that `getUserCount()` can be accessed by many
    users at once (`LockType.READ`), but `addUser()` will be accessed just by one
    user at a time (`LockType.WRITE`).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们基本上是在说`getUserCount()`可以同时被许多用户访问（`LockType.READ`），而`addUser()`则每次只能被一个用户访问（`LockType.WRITE`）。
- en: 'The last case is the self-managed bean:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个案例是自管理bean：
- en: '[PRE61]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In this case, you have to manage all the concurrency issues for your bean in
    your code. We used a synchronized qualifier as an example.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你必须在你自己的代码中管理你的bean的所有并发问题。我们以同步限定符为例。
- en: There's more...
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Unless you really *really* need to, don't use self-managed beans. The Java EE
    container is (well) designed to do it in a very efficient and elegant way.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你真的真的需要，否则不要使用自管理bean。Java EE容器（非常好）设计用来以非常高效和优雅的方式完成这项工作。
- en: See also
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Check the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-ejb-concurrency](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-ejb-concurrency)
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-ejb-concurrency](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-ejb-concurrency)查看此菜谱的完整源代码
- en: Using JPA for smart data persistence
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JPA进行智能数据持久化
- en: The Java Persistence API is a specification that describes an interface for
    managing relational databases using Java EE.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Java持久化API是一个规范，它描述了使用Java EE管理关系数据库的接口。
- en: It eases data manipulation and reduces a lot of the code written for it, especially
    if you are used to SQL ANSI.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 它简化了数据操作，并大大减少了为其编写的代码，尤其是如果您习惯于SQL ANSI。
- en: This recipe will show you how to use it to persist your data.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱将向您展示如何使用它来持久化您的数据。
- en: Getting ready
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s first add the dependencies needed:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先添加所需的依赖项：
- en: '[PRE62]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: How to do it...
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s begin by creating an entity (you can see it as a table):'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先创建一个实体（您可以将其视为一个表）：
- en: '[PRE63]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Here we declare our persistence unit (at `persistence.xml`):'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们声明我们的持久化单元（在`persistence.xml`中）：
- en: '[PRE64]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Then we create a session bean to manage our data:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建一个会话bean来管理我们的数据：
- en: '[PRE65]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'And here we use a unit test to try it out:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 而在这里，我们使用单元测试来尝试它：
- en: '[PRE66]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: How it works...
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's break down our **persistence unit** (**pu**).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解我们的**持久化单元**（**pu**）。
- en: 'This line defines the pu name and the transaction type used:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码定义了pu名称和使用的交易类型：
- en: '[PRE67]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The following line shows the provider the JPA implementation used:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了JPA使用的提供者：
- en: '[PRE68]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'It is the datasource name that will be accessed through JNDI:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 是通过JNDI访问的数据源名称：
- en: '[PRE69]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This line lets all your entities be available for this pu, so you don''t need
    to declare each one:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码使得所有你的实体都可以用于这个pu，因此你不需要为每个实体声明：
- en: '[PRE70]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This block allows the database objects to be created if they don''t exist:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这个块允许在不存在时创建数据库对象：
- en: '[PRE71]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'And now let''s have a look at `UserBean`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`UserBean`：
- en: '[PRE72]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '`EntityManager` is the object responsible for the interface between the bean
    and the datasource. It''s bound to the context by the `@PersistenceContext` annotation.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`EntityManager`是负责bean与数据源之间接口的对象。它通过`@PersistenceContext`注解绑定到上下文中。'
- en: 'And we check the `EntityManager` operations as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如下检查`EntityManager`操作：
- en: '[PRE73]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The `persist()` method is used to add new data to the datasource. At the end
    of the execution, the object is attached to the context:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`persist()`方法用于将新数据添加到数据源。执行结束时，对象被附加到上下文中：'
- en: '[PRE74]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The `merge()` method is used to update existing data on the datasource. The
    object is first found at the context, then updated at the database and attached
    to the context with the new state:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`merge()`方法用于在数据源上更新现有数据。首先在上下文中找到对象，然后在数据库中更新，并使用新状态附加到上下文中：'
- en: '[PRE75]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The `remove()` method, guess what is it?
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove()`方法，猜猜看它是做什么的？'
- en: '[PRE76]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: And finally the `find()` method uses the `id` parameter to search a database
    object with the same ID. That's why JPA demands your entities have an ID declared
    with the `@Id` annotation.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`find()`方法使用`id`参数搜索具有相同ID的数据库对象。这就是为什么JPA要求你的实体必须使用`@Id`注解声明一个ID。
- en: See also
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Check the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-jpa](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-jpa)
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-jpa](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-jpa)查看这个菜谱的完整源代码
- en: Using EJB and JPA for data caching
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用EJB和JPA进行数据缓存
- en: Knowing how to build a simple and local cache for your application is an important
    skill. It may have a big impact on some data access performance and it is quite
    easy to do.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何为你的应用程序构建一个简单且本地的缓存是一项重要的技能。它可能对某些数据访问性能有重大影响，而且做起来相当简单。
- en: This recipe will show you how.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将向你展示如何做。
- en: Getting ready
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Simply add a Java EE dependency to your project:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地为你的项目添加一个Java EE依赖项：
- en: '[PRE77]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: How to do it...
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s create a `User` class to be our cached object:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个`User`类作为我们的缓存对象：
- en: '[PRE78]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'And then create a singleton to hold our user list cache:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后创建一个单例来保存我们的用户列表缓存：
- en: '[PRE79]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: How it works...
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s first understand our bean declaration:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先了解我们的bean声明：
- en: '[PRE80]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: We are using a singleton because it has one and only one instance in the application
    context. And that's the way we want a data cache because we don't want to allow
    the possibility of different data being shared.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用单例模式，因为它在应用程序上下文中只有一个实例。这正是我们想要的数据缓存的方式，因为我们不希望允许不同数据被共享的可能性。
- en: Also note that we used the `@Startup` annotation. It says to the server that
    this bean should be *executed* once it is loaded and the method annotated with
    `@PostConstruct` is used for it.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们使用了`@Startup`注解。它告诉服务器，一旦加载了这个bean，就应该执行它，并且使用带有`@PostConstruct`注解的方法。
- en: 'So we take the startup time to load our cache:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们利用启动时间来加载我们的缓存：
- en: '[PRE81]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now let''s check the object holding our cache:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查持有我们缓存的对象：
- en: '[PRE82]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '`ConcurrentLinkedQueue` is a list built with one main purpose—being accessed
    by multiple processes in a thread-safe environment. That''s exactly what we need
    and also it offers great performance on accessing its members.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentLinkedQueue`是一个列表，它有一个主要目的——在线程安全的环境中由多个进程访问。这正是我们所需要的，而且它在其成员访问上提供了很好的性能。'
- en: 'And finally, let''s check the access to our data cache:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们检查对我们的数据缓存的访问：
- en: '[PRE83]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We annotated the `get()` method with `LockType.READ`, so it says to the concurrency
    manager that it can be accessed by multiple processes at once in a thread-safe
    way.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`LockType.READ`对`get()`方法进行了注释，这样它就告诉并发管理器，它可以以线程安全的方式同时被多个进程访问。
- en: There's more...
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you need big and complex caches in your application, you should use some
    enterprise cache solutions for better results.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在你的应用程序中使用大而复杂的缓存，你应该使用一些企业级缓存解决方案以获得更好的结果。
- en: See also
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Check the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-datacache](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-datacache)
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-datacache](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-datacache)查看此菜谱的完整源代码
- en: Using batch processing
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用批处理
- en: Batch processing is the last recipe of this chapter. Running background tasks
    is a useful and important skill in an enterprise context.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 批处理是本章的最后一个菜谱。在企业环境中运行后台任务是实用且重要的技能。
- en: You could use it to process data in bulk or just to separate it from the UI
    processes. This recipe will show you how to do it.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用它来批量处理数据，或者只是将其从UI流程中分离出来。这个菜谱将向你展示如何做到这一点。
- en: Getting ready
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s add our dependencies:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加我们的依赖项：
- en: '[PRE84]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: How to do it...
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We first define our persistence unit:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义我们的持久化单元：
- en: '[PRE85]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Then we declare a `User` entity:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们声明一个`User`实体：
- en: '[PRE86]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Here we create a job reader:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里我们创建一个工作读取器：
- en: '[PRE87]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Then we create a job processor:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建一个工作处理器：
- en: '[PRE88]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'And here we create a job writer:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建一个工作写入器：
- en: '[PRE89]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The processor, reader, and writer are referenced by the `acess-user.xml` file
    located at `META-INF.batch-jobs`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器、读取器和写入器由位于`META-INF.batch-jobs`的`acess-user.xml`文件引用：
- en: '[PRE90]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'And finally, we create a bean to interact with the batch engine:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个用于与批处理引擎交互的bean：
- en: '[PRE91]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'For the purpose of this example, we are going to use a JSF page to run the
    job and load the data:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本例的目的，我们将使用一个JSF页面来运行工作并加载数据：
- en: '[PRE92]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Run it on a Java EE server, click on the Run button and then the Reload button.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java EE服务器上运行它，点击运行按钮，然后点击重新加载按钮。
- en: How it works...
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To understand what is happening:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解正在发生的事情：
- en: '`UserReader` extends the `AbstractItemReader` class that has two key methods:
    `open()` and `readItem()`. In our case, the first one opens the `META-INF/user.txt`
    and the second one reads each line of the file.'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UserReader`扩展了具有两个关键方法的`AbstractItemReader`类：`open()`和`readItem()`。在我们的案例中，第一个打开`META-INF/user.txt`，第二个读取文件的每一行。'
- en: The `UserProcessor` class extends the `ItemProcessor` class that has a `processItem()`
    method. It gets the item read by `readItem()` (from `UserReader`) to generate
    the `User` object that we want.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UserProcessor`类扩展了具有`processItem()`方法的`ItemProcessor`类。它通过`readItem()`（从`UserReader`）获取项目，生成我们想要的`User`对象。'
- en: Once all items are processed and available in a list (in memory) we use the
    `UserWriter` class; that extends the `AbstractItemWriter` class and has the `writeItems`
    method. We use it, in our case, to persist the data read from the `user.txt` file.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦所有项目都处理完毕并可用在列表（内存）中，我们使用`UserWriter`类；它扩展了`AbstractItemWriter`类并具有`writeItems`方法。在我们的案例中，我们使用它来持久化从`user.txt`文件中读取的数据。
- en: 'All set so, we just use `UserBean` to run the job:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 一切准备就绪，我们只需使用`UserBean`来运行工作：
- en: '[PRE93]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The `job.start()` method is referencing the `acess-user.xml` file, enabling
    our reader, processor, and writer to work together.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`job.start()`方法引用了`acess-user.xml`文件，使我们的读取器、处理器和写入器能够协同工作。'
- en: See also
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: Check the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-batch](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-batch)
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-batch](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter02/ch02-batch)查看此菜谱的完整源代码
