- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Language Fundamentals – Classes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言基础 – 类
- en: An **object-oriented** (**OO**) program is based on the design of structures
    called classes that are used as the blueprint for objects. An object is the implementation
    of a class. This means that the first step in coding in **OO programming** (**OOP**)
    is to create classes. This chapter will examine how the features of OOP are implemented
    in Java. We begin by looking at how we define variables in a class followed by
    how we control access to members of a class and the class itself. From here, we
    will look at the class structure Java provides us for creating or working with
    classes and objects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象**（**OO**）程序基于称为类的结构的设计，这些结构用作对象的蓝图。对象是类的实现。这意味着在**面向对象编程**（**OOP**）中编码的第一步是创建类。本章将探讨Java中如何实现OOP的特性。我们首先看看如何在类中定义变量，然后是控制类成员及其本身的访问方式。从这里开始，我们将查看Java为我们提供的用于创建或处理类和对象的类结构。'
- en: 'In this chapter, you will learn about the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Class fields
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类字段
- en: Understanding access control
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解访问控制
- en: Understanding classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解类
- en: By the end of this chapter, you will be able to define classes, instantiate
    them into objects, and interact with other classes. Let’s begin by looking at
    access control. Before we begin, let’s look at the two categories of variables
    that you can declare in a class.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够定义类，将它们实例化为对象，并与其他类交互。让我们从查看访问控制开始。在我们开始之前，让我们看看你可以在类中声明的两种变量类别。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Here are the tools required to run the examples in this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是运行本章示例所需的工具：
- en: Java 17 installed
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装Java 17
- en: Text editor
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本编辑器
- en: Maven 3.8.6 or a newer version installed
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装Maven 3.8.6或更高版本
- en: You can find the code from this chapter in the GitHub repository at [https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter05](https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter05).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub仓库[https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter05](https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter05)中找到本章的代码。
- en: Class fields
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类字段
- en: 'Variables declared in a class and not in a method call are referred to as fields.
    They fall into two categories:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中声明而不是在方法调用中声明的变量被称为字段。它们分为两类：
- en: Instance variables
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例变量
- en: Class variables
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类变量
- en: '`double` in a class and we created 100 instances of the object, we would have
    100 doubles.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中定义`double`，如果我们创建了100个对象实例，我们就会有100个`double`。
- en: In Java, you can have a variable in a class that is shared by all objects created
    from the class. In other words, every object has a unique set of instance variables,
    but all share the **class variables**. This is accomplished by designating the
    variable as static. There is only one memory allocation for a static variable.
    In our 100 instances of an object, there is just one double if you declare the
    double as static.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，你可以在类中有一个变量，它被从该类创建的所有对象共享。换句话说，每个对象都有一个唯一的实例变量集，但所有对象都共享**类变量**。这是通过将变量指定为静态来实现的。静态变量只有一个内存分配。在我们的100个对象实例中，如果你将`double`声明为静态，就只有一个`double`。
- en: 'Another characteristic of a static or class variable is that assuming it has
    public access control, you can access it without instantiating the object. For
    example, consider the following code block:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 静态或类变量的另一个特点是，假设它具有公共访问控制，你可以不实例化对象即可访问它。例如，考虑以下代码块：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this fragment, we can access the `class` variable `bob` by simply writing
    `TestBed.bob`. We don’t have to instantiate the object. If we do instantiate it,
    we can use the reference, though this is rare.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们可以通过简单地写出`TestBed.bob`来访问`class`变量`bob`。我们不需要实例化对象。如果我们实例化了它，我们也可以使用引用，尽管这种情况很少。
- en: The fact that class variables are shared by all objects makes them an ideal
    tool for objects created from the same class to communicate with each other. If
    one object changes the value of a class variable, then even another object of
    the same class can see the updated value.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 类变量被所有对象共享的事实使它们成为同一类创建的对象之间通信的理想工具。如果一个对象改变了类变量的值，那么即使是同一类的另一个对象也可以看到更新后的值。
- en: Before we move on to the next section on access control, let’s clarify one more
    term. We refer to all variables declared in a class as **fields**. This includes
    both class and instance variables.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入下一节关于访问控制的讨论之前，让我们澄清一个术语。我们将所有在类中声明的变量称为**字段**。这包括类和实例变量。
- en: Understanding access control
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解访问控制
- en: One significant and invaluable feature of OOP is **access control**. If you
    have already worked with an OO language, then you may be familiar with this concept;
    if not, let me explain what access control means.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）的一个显著且宝贵的特性是**访问控制**。如果你已经使用过面向对象的编程语言，那么你可能已经熟悉这个概念；如果不是，让我来解释一下访问控制是什么意思。
- en: Access control in Java concerns the visibility of classes, fields, and methods
    to other classes. You must have sufficient access to create objects and access
    fields and methods in a class.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的访问控制涉及类、字段和方法对其他类的可见性。你必须有足够的访问权限来创建对象并访问类中的字段和方法。
- en: Access control, in other languages, may imply a security mechanism that can
    ensure that a request for access to a method–for example–is coming from an authenticated
    user. This is not what Java does; in Java, it is about how objects can interact
    with each other.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言中，访问控制可能意味着一种安全机制，可以确保对方法访问的请求（例如）来自经过身份验证的用户。Java并不是这样做的；在Java中，它关乎对象如何相互交互。
- en: Let’s look at the options for visibility; the first will be Java packages.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看可见性的选项；第一个将是Java包。
- en: Packages
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包
- en: The first piece of the access control puzzle is the Java package and its corresponding
    `import` statement. In [*Chapter 3*](B19088_03.xhtml#_idTextAnchor062), *The Maven
    Build Tool*, we learned about Java packages and how they are simply a folder that
    contains Java code. Code in one package cannot access code in another package
    unless you give access by including an `import` statement. The class that imports
    can access code in what it imports. Without an `import` class, the `statement`
    classes in different packages cannot interact with each other.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 访问控制难题的第一部分是Java包及其相应的`import`语句。在[*第3章*](B19088_03.xhtml#_idTextAnchor062)《Maven构建工具》中，我们学习了Java包以及它们是如何简单地包含Java代码的文件夹。除非你通过包含`import`语句来提供访问权限，否则一个包中的代码不能访问另一个包中的代码。导入类的类可以访问它导入的代码。如果没有`import`类，不同包中的`statement`类不能相互交互。
- en: Keep in mind that the interaction is one way. For example, class A has an `import`
    statement for class B. Class A can call or send messages to code in class B but
    not vice versa. You could add an `import` statement to class B for class A, and
    then they can each send a message to the other.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这种交互是单向的。例如，类A对类B有一个`import`语句。类A可以调用或向类B中的代码发送消息，但不能反过来。你可以在类B中为类A添加一个`import`语句，然后它们可以相互发送消息。
- en: Using packages for access control is simplistic; it is a simple binary setting.
    You can either see an object of a class that you are importing or you cannot see
    the class at all if you did not import it. All classes in the same package have
    an implicit import for the other classes in the same package, and, in this case,
    there is no need to import fellow package classes explicitly.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用包进行访问控制很简单；这是一个简单的二进制设置。你可以看到你导入的类的对象，或者如果你没有导入它，你根本看不到这个类。同一个包中的所有类都对同一包中的其他类有隐式导入，在这种情况下，没有必要显式导入同包中的类。
- en: Now, we are ready to look at the four access control specifiers available to
    us.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备查看我们可用的四个访问控制指定符。
- en: The public specifier
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公共指定符
- en: The `import` statement, if required, any other object can create objects of
    that public class.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，`import`语句可以创建任何其他对象的公共类的对象。
- en: You can access a public class’s fields from any object that has a reference
    to a second object. We should always keep class fields private so that we cannot
    directly assign values to the field. To interact with a private variable, you
    will need methods in the same class that will be your proxy to read or write to
    the private variable. When writing to the field, you will be able to validate
    the new value before it is assigned to the field.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从任何拥有指向第二个对象的引用的对象中访问公共类的字段。我们应该始终将类字段保持为私有，这样我们就不能直接向字段赋值。要与私有变量交互，你需要同一类中的方法，这些方法将成为你读取或写入私有变量的代理。在向字段写入时，你将能够在将其分配给字段之前验证新值。
- en: You can call class methods that are public from any other object that has a
    reference to the object containing the public method. We refer to the public methods
    of a class as its interface. We will look at interfaces in the next chapter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从任何拥有指向包含公共方法的对象的引用的其他对象中调用公共方法。我们将类中的公共方法称为其接口。我们将在下一章中探讨接口。
- en: The private specifier
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 私有指定符
- en: The **private specifier** in Java is the same as in C++ and C#–you use this
    specifier to define access control for fields and methods.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的**私有指定符**与C++和C#相同——您使用此指定符来定义字段和方法访问控制。
- en: As already mentioned, class fields should always be private. You will need to
    validate the data that you want to store in a private field. A common way to do
    this is with a mutator, commonly called a setter method. Here, you can add validation
    and reject invalid data by throwing an exception.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，类字段始终应该是私有的。您需要验证您想要存储在私有字段中的数据。一种常见的方法是使用一个修改器，通常称为setter方法。在这里，您可以添加验证并通过抛出异常拒绝无效数据。
- en: Methods designated as private can only be called upon by other methods in the
    same class. Using private methods allows us to break down complex tasks into smaller
    units. As they are private, they cannot be called upon from other objects, and
    this ensures that all the necessary steps of a complex task will be carried out
    in the correct order.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 被指定为私有的方法只能由同一类中的其他方法调用。使用私有方法允许我们将复杂任务分解成更小的单元。由于它们是私有的，因此不能从其他对象调用，这确保了复杂任务的必要步骤将按正确顺序执行。
- en: Java permits you to define a new class within another class. This is the only
    situation where a class may be private. A private non-inner class could not be
    instantiated. You cannot use a private inner class outside the class you declare
    it in. You can instantiate a private inner class in the class that declared it.
    As already mentioned, instance variables should always be private while methods
    may be any of the four access designations.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Java允许您在另一个类中定义一个新类。这是唯一一个类可能是私有的情况。一个私有的非内部类不能被实例化。您不能在声明它的类之外使用私有内部类。您可以在声明它的类中实例化私有内部类。如前所述，实例变量始终应该是私有的，而方法可以是四种访问指定中的任何一种。
- en: The protected specifier
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 受保护的指定符
- en: The `protected/package`, is only used when you are employing **inheritance**.
    In a non-inheritance situation, protected behaves the same as package access.
    In C++ and C#, the concept of package does not exist, so in a non-inheritance
    situation, these languages treat protected as private.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`protected/package`只在您使用**继承**时使用。在非继承情况下，受保护的属性表现得与包访问相同。在C++和C#中，包的概念不存在，因此在非继承情况下，这些语言将受保护的属性视为私有。'
- en: Inheritance, as we will see in the next chapter, is an arrangement between two
    classes where one class is a **superclass** and the other is a **subclass**. A
    subclass can access all the public members of its superclass, including the instance
    variable designated as protected in the superclass. Other objects with references
    to the superclass not involved with inheritance see protected members as private
    or–if these objects are defined in the same package–as package.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在下一章中将要看到的，继承是两个类之间的安排，其中一个类是**超类**，另一个类是**子类**。子类可以访问其超类的所有公共成员，包括在超类中指定的受保护实例变量。与继承无关且引用超类的其他对象将受保护的成员视为私有，或者如果这些对象定义在同一个包中，则视为包。
- en: Methods and class variables that you designate as protected also possess package
    access, as described in the next section. You cannot have a protected class.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您指定的受保护的方法和类变量也具有包访问权限，如下一节所述。您不能有受保护的类。
- en: The package specifier
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包指定符
- en: This final access specifier, package, has no equivalent in C++ or C#, although
    there is some similarity to the friend concept in these languages. It defines
    the visibility of classes, fields, and methods in other objects that are defined
    in the same package. There is no designator such as public, private, or protected.
    When not explicitly using a specifier on a class, field, or method, then the implicit
    access control is package.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最终的访问指定符包在C++或C#中没有等效项，尽管这些语言中的friend概念与之有些相似。它定义了在同一个包中定义的其他对象中类的字段、字段和方法的可视性。没有类似于public、private或protected这样的指定符。当在类、字段或方法上没有显式使用指定符时，则隐式访问控制是包。
- en: An object that has a reference to another object defined in a different package
    or folder sees protected as private. The objects of two different classes in the
    same package can access protected elements as if they were public.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同包或文件夹中定义的另一个对象的引用被视为私有。同一包中两个不同类的对象可以像访问公共元素一样访问受保护的元素。
- en: Note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: One last point before we move on–use protected and package specifiers sparingly.
    They exist for situations where the interaction between objects can be speeded
    up. The problem is that they expose fields and methods to objects that should
    not have access to them. I recommend that you only ever use public and private
    when you start designing and coding a program. Only if you can demonstrate that
    the system performance is suffering by only using public or private components
    should you consider protected and package.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，最后一点——谨慎使用`protected`和包指定符。它们存在于可以加快对象之间交互的情况。问题是它们将字段和方法暴露给不应访问它们的对象。我建议你在开始设计和编写程序时只使用公共和私有。只有在你能够证明仅使用公共或私有组件会导致系统性能下降时，才考虑使用`protected`和包。
- en: One last point to reiterate–access control does not exist inside a class. This
    means that a public method can call a `private` method in the same class. Every
    method has access to every field no matter its access control designation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点需要重申——在类内部不存在访问控制。这意味着一个公共方法可以调用同一类中的`private`方法。无论其访问控制指定如何，每个方法都可以访问每个字段。
- en: Now, we are ready to look at how classes work. We will first look at the classes
    from the last chapter’s program, and then we will create an updated version of
    the program.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备查看类是如何工作的。我们首先将查看上一章程序中的类，然后我们将创建程序的更新版本。
- en: Understanding classes
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解类
- en: Java, as with other OO languages, uses a syntax that revolves around the source
    code structure called a **class**. But first, what is a class? The theorists who
    introduced the concept of objects envisioned a class as a custom data type. Think
    of the primitive integer type–it has a range of allowable values and a pre-defined
    set of operations such as addition, subtraction, and the other usual operators.
    Imagine a class as a custom primitive in which you decide which operations, in
    the form of methods, your type will perform. One goal of OOP is to focus on problem-solving
    by developing custom data types that combine data and actions as opposed to the
    structured programming approach where data and actions are separate.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Java，与其他面向对象的语言一样，使用一种围绕源代码结构的语法，称为**类**。但首先，什么是类？引入对象概念的理论家们将类视为自定义数据类型。想象一下原始整数类型——它有一个允许的值范围和一组预定义的操作，如加法、减法和其他常用运算符。想象一下类作为一个自定义原始类型，你决定你的类型将执行哪些操作，以方法的形式。面向对象编程的一个目标是通过开发将数据和动作结合在一起的自定义数据类型来专注于问题解决，而不是结构化编程方法，其中数据和动作是分开的。
- en: This means that you develop a class by first listing all the fields of the class,
    either primitives or references to other classes. Next come the methods that conduct
    useful tasks that make use of these fields. These variables are visible to every
    method in a class regardless of the access control level.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你通过首先列出类的所有字段来开发一个类，无论是原始类型还是其他类的引用。接下来是执行有用任务的方法，这些任务利用了这些字段。这些变量对类中的每个方法都是可见的，无论其访问控制级别如何。
- en: Classes are not executable code, with one exception we will see shortly. Instead,
    a class is a blueprint that must be instantiated or created at runtime using the
    `new` keyword. When your program begins execution, the **Java virtual machine**
    (**JVM**) stores the class definition in a region of memory called the **class-method
    region**.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 类不是可执行代码，有一个例外我们很快就会看到。相反，类是一个蓝图，必须在运行时使用`new`关键字实例化或创建。当你的程序开始执行时，**Java虚拟机**（**JVM**）将类定义存储在称为**类方法区域**的内存区域中。
- en: 'The `new` operator conducts two tasks:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`new`运算符执行两个任务：'
- en: Allocates sufficient memory for all the instance variables in a class blueprint.
    We refer to this region of memory as the `Class-Method` region.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为类蓝图中的所有实例变量分配足够的内存。我们称这个内存区域为`Class-Method`区域。
- en: Assigns the address of the allocated regions of memory to the appropriate reference
    variable. A reference variable is always just 4 bytes long. Accessing objects
    through a reference variable is called indirect addressing.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将分配的内存区域的地址分配给适当的引用变量。引用变量始终只有4个字节长。通过引用变量访问对象称为间接寻址。
- en: There is a third region of memory that comes into play called the stack. The
    JVM stores all local variables–variables declared in methods–in the stack data
    structure as required. The stack is a dynamic structure that can allocate space
    for variables and then deallocate them by just moving a pointer. If you are interested
    in memory management, see the *Further reading* section at the end of this chapter
    for more information.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 存在第三个内存区域，称为栈。JVM按照需要将所有局部变量——在方法中声明的变量——存储在栈数据结构中。栈是一个动态结构，可以为变量分配空间，然后通过移动指针来释放它们。如果你对内存管理感兴趣，请参阅本章末尾的*进一步阅读*部分以获取更多信息。
- en: Before we go any further, we need to understand the two methods that the JVM
    can invoke whenever we create an object.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们需要了解JVM在创建对象时可以调用的两种方法。
- en: constructor and finalize methods
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数和finalize方法
- en: There are two special methods found in most OO languages related to memory management.
    The `constructor` method runs as the last step in the creation of an object whereas
    the `destructor` method, called `finalize` in Java, runs as the first step when
    an object goes out of scope. How this happens in Java is different than in other
    languages such as C++.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数面向对象的语言中，与内存管理相关的有两种特殊方法。`constructor`方法在对象的创建过程中的最后一步运行，而`destructor`方法，在Java中称为`finalize`，在对象超出作用域时作为第一步运行。Java中这种情况与其他语言，如C++，是不同的。
- en: finalize
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: finalize
- en: There can be only one `finalize` method in a class. You cannot overload it.
    Do not use it–Java 9 deprecated it. If you are a C++ developer, you may mistakenly
    believe that `finalize` is the Java equivalent of a C++ destructor. However, that’s
    not true–here’s why.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类中只能有一个`finalize`方法。你不能对其进行重载。不要使用它——Java 9已经弃用了它。如果你是C++开发者，你可能会错误地认为`finalize`是C++析构函数的Java等价物。然而，这并不正确——原因如下。
- en: In C++, the `delete` operator runs the `destructor` method first. Once the `destructor`
    method runs, the `delete` operator releases the memory used by the object, which
    can now be reallocated. This works because when you execute the `delete` operator
    on a valid pointer to an object, the actions in the `destructor` function execute
    immediately.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，`delete`运算符首先运行析构函数。一旦析构函数运行，`delete`运算符就会释放对象使用的内存，现在可以重新分配。这是因为当你对一个有效指针执行`delete`运算符时，析构函数中的操作会立即执行。
- en: In Java, there is no `delete` operator; instead, the JVM monitors all references
    to objects. When an object reference goes out of scope, the JVM enters it on a
    list of references that the JVM will release for you. However, for efficiency
    and performance, the JVM does not immediately release memory. Instead, it puts
    it off for as long as possible. This is due to the time necessary to release memory,
    which can impact the current programs running in the JVM. We call the release
    of memory **garbage collection**.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，没有`delete`运算符；相反，JVM监视所有对象的引用。当一个对象引用超出作用域时，JVM将其添加到JVM将为你释放的引用列表中。然而，为了效率和性能，JVM不会立即释放内存。相反，它会尽可能推迟。这是由于释放内存所需的时间，这可能会影响JVM中当前运行的程序。我们称内存释放为**垃圾回收**。
- en: The JVM runs the `finalize` method just before garbage collection. This garbage
    collection could be occurring every few minutes or less, but that’s very unlikely.
    Given a great deal of RAM (my system has 32 GB), this can mean that garbage collection
    could happen every few hours or even days. Therefore, `finalize` is non-deterministic.
    It may want to effect changes or send messages to parts of your program for reasons
    no longer valid, or that part of the program has already been garbage collected.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: JVM在垃圾回收之前运行`finalize`方法。这种垃圾回收可能每几分钟或更少发生，但这非常不可能。考虑到大量的RAM（我的系统有32 GB），这意味着垃圾回收可能每几个小时或甚至几天发生一次。因此，`finalize`是非确定性的。它可能因为不再有效的原因而想要影响程序的一部分或发送消息，或者该程序的一部分已经被垃圾回收。
- en: For this and other reasons, the Java architects made the decision to deprecate
    `finalize`. So, do not use it. If you want a method called before an object goes
    out of scope, then you will have to explicitly call a method you created.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个和其他原因，Java架构师决定弃用`finalize`。所以，不要使用它。如果你想在对象超出作用域之前调用一个方法，那么你必须显式地调用你创建的方法。
- en: With the `finalize` method discussed and then assigned to the rubbish or deprecated
    bin, let’s look at the constructor.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了`finalize`方法并将其分配给垃圾或弃用回收站之后，让我们来看看构造函数。
- en: Constructor
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数
- en: The purpose of the constructor is to conduct any actions necessary as the last
    step in object creation. Typically, you use the constructor to initialize class
    instance variables. We have seen that we can initialize these variables right
    at the point of declaration in the class. Sometimes, the initialization requires
    more steps than just assigning a value, and this is where the constructor is invaluable.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的目的是在对象创建的最后一步执行任何必要的操作。通常，您使用构造函数来初始化类实例变量。我们已经看到我们可以在类的声明点直接初始化这些变量。有时，初始化需要比仅仅赋值更多的步骤，这就是构造函数非常有价值的地方。
- en: 'You create an object by invoking the `new` operator. The `new` operator conducts
    tasks that result in the creation of an object. I am simplifying how this works,
    but it conveys what you need to know:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您通过调用`new`运算符来创建一个对象。`new`运算符执行导致创建对象的任务。我在简化这个过程，但这是您需要了解的内容：
- en: Memory is allocated in the heap region of memory for all instance variables,
    along with other required structures that the JVM requires. The address of this
    memory is what the `this` reference captures. Subsequently, every call to non-static
    methods in this class now has a first parameter, which is the invisible `this`
    parameter.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有实例变量以及其他JVM所需的所需结构都在内存的堆区域分配内存。这个内存的地址就是`this`引用捕获的地址。随后，对这个类中非静态方法的每次调用现在都有一个第一个参数，即不可见的`this`参数。
- en: 'Let’s code the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写以下代码：
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we’ll instantiate it, like so:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将实例化它，如下所示：
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The non-static methods become the following after being compiled:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，非静态方法变成了以下内容：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can never write the code this way. `MyClass this` is implied and so may
    not be written.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您永远不能这样编写代码。`MyClass this`是隐含的，因此可能不写。
- en: 'Now, we’ll call this method:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将调用这个方法：
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It then becomes the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它变成了以下内容：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once memory is allocated, along with other housekeeping chores, the JVM calls
    the appropriate `constructor` method. It does not have a return type as it does
    not have a variable to return a result to. You must name them with the same name
    as the class they belong to.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦分配了内存，以及其他的维护工作，JVM将调用适当的`constructor`方法。它没有返回类型，因为它没有变量可以返回结果。您必须用与它们所属的类相同的名字来命名它们。
- en: 'Constructors fall into two categories: default and non-default. A **default
    constructor**, of which there can only be one, has no parameters. A **non-default
    constructor** is one with parameters. It is subject to overloading, so there can
    be more than one non-default constructor if the parameter types are different.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数分为两类：默认和非默认。只有一个**默认构造函数**，它没有参数。一个**非默认构造函数**是带有参数的。它受重载的影响，因此如果参数类型不同，可以有多个非默认构造函数。
- en: Java provides the capability of having one constructor call another constructor.
    The first constructor called is determined by the rules of overloading. The called
    constructor can then call upon one other constructor. This call must be the first
    line of code. Watch out for a possible `recursive constructor invocation` error
    where constructor A calls constructor B and constructor B calls constructor A.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供了调用另一个构造函数的能力。第一个被调用的构造函数由重载的规则决定。然后，被调用的构造函数可以调用另一个构造函数。这个调用必须是代码的第一行。注意可能的`递归构造函数调用`错误，其中构造函数A调用构造函数B，而构造函数B又调用构造函数A。
- en: Revising the compound interest program
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改复利程序
- en: We are now ready to review our compound interest program and apply what we have
    just covered to the classes in this project.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好回顾我们的复利程序，并将我们刚刚学到的内容应用到这个项目中的类中。
- en: For this, let’s look in more depth at the `CompoundInterest04` program that
    we discussed in [*Chapter 2*](B19088_02.xhtml#_idTextAnchor043), *Code, Compile,*
    *and Execute*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一点，让我们更深入地看看我们在[*第2章*](B19088_02.xhtml#_idTextAnchor043)，“代码、编译和执行”中讨论的`CompoundInterest04`程序。
- en: We will begin by declaring the package in the `CompoundInterestCalculator04.java`
    file. Packages, the folders we place our source code into, allow us to manage
    our code by functionality. The only time you might not want to use a package is
    if you are creating a single-file source-code or Linux shebang application.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在`CompoundInterestCalculator04.java`文件中声明包。包，我们将源代码放入的文件夹，允许我们通过功能来管理我们的代码。您可能不想使用包的情况是如果您正在创建一个单文件源代码或Linux
    shebang应用程序。
- en: 'Here is the package declaration. The file will be in a folder named `business`,
    which is in the `com/kenfogel/compoundinterest04` folder:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是包声明。文件将位于名为`business`的文件夹中，该文件夹位于`com/kenfogel/compoundinterest04`文件夹中：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This program will be using the `NumberFormat` class. This class is part of
    Java’s standard library, and we know this because the first name in its package
    designation is `java`. To make use of this class, we must import it into our file,
    like so:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序将使用`NumberFormat`类。这个类是Java标准库的一部分，我们知道这一点是因为其包命名的第一个名字是`java`。为了使用这个类，我们必须将其导入到我们的文件中，如下所示：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The first line of the class declaration shows us the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 类声明的第一行显示了以下内容：
- en: This class is public and so can be instantiated in any other class that declares
    a reference to it.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个类是公开的，因此可以在任何声明了对其引用的其他类中实例化。
- en: The public class name, `CompoundInterestCalculator04`, must also be the name
    of the file. You can have more than one class structure in a file but only one
    of them may be public.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共类名`CompoundInterestCalculator04`也必须是文件名。你可以在一个文件中拥有多个类结构，但其中只有一个可以是公开的。
- en: 'Here is the first line of the declaration:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是声明中的第一行：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here are the fields in the class:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是类中的字段：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We are declaring four instance variables of type `double`. The access control
    designation of `private` means that you cannot access these variables from any
    other class that may have a reference to this class. The `final` modifier defines
    these variables as immutable. In a class, access control does not apply but modifiers
    do. You must initialize a `final` variable where you declared it or in the constructor.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在声明四个类型为`double`的实例变量。`private`的访问控制指定意味着你不能从任何可能引用这个类的其他类中访问这些变量。`final`修饰符将这些变量定义为不可变的。在一个类中，访问控制不适用，但修饰符适用。你必须在你声明`final`变量的地方或在构造函数中初始化它。
- en: 'Next, we are declaring references to objects that we will use in the code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们正在声明我们将要在代码中使用的对象引用：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We are declaring two instances of a `NumberFormat` class. You can see from the
    variable names that we planned each one for a different format. These are final,
    meaning we must initialize them with a value and they cannot be instantiated a
    second time. Rather than instantiate the `NumberFormat` references in their declaration,
    we can also instantiate them in a constructor, and that is what we will do.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在声明`NumberFormat`类的两个实例。你可以从变量名中看出，我们为每个不同的格式规划了一个。这些是最终的，这意味着我们必须用值初始化它们，并且不能再次实例化。我们不仅可以在声明中实例化`NumberFormat`引用，还可以在构造函数中实例化它们，这就是我们将要做的。
- en: 'The following method is the constructor:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法是构造函数：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The constructor is easy to recognize as it must have the same name as the class.
    It does not return a value as the JVM calls the constructor as part of the `new`
    operation. There is nothing to assign a result from a `return` statement to. This
    is a default constructor as there are no arguments inside the parentheses. A class
    may have only one default constructor but may overload the constructor with constructors
    that take as arguments different data types.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数很容易识别，因为它必须与类的名称相同。它不返回值，因为JVM将构造函数作为`new`操作的一部分调用。没有从`return`语句分配结果的内容。这是一个默认构造函数，因为括号中没有参数。一个类可能只有一个默认构造函数，但可以通过接受不同数据类型参数的构造函数来重载构造函数。
- en: The task that this constructor conducts is the initialization and configuration
    of the `NumberFormat` objects. Rather than just using the `new` operator, this
    class is instantiated by using a factory method. Factory methods conduct additional
    tasks before invoking `new`. Also, take note that we call the methods through
    the class name and not through an object name, very much like the `Math` library
    methods. This tells us that `getCurrencyInstance` and `getPercentInstance` are
    static methods that are available. We will discuss static methods later in this
    section.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构造函数执行的任务是初始化和配置`NumberFormat`对象。我们不是仅仅使用`new`运算符，而是通过使用工厂方法来实例化这个类。工厂方法在调用`new`之前执行额外的任务。此外，请注意，我们通过类名而不是通过对象名调用方法，这与`Math`库方法非常相似。这告诉我们`getCurrencyInstance`和`getPercentInstance`是可用的静态方法。我们将在本节稍后讨论静态方法。
- en: 'Next up is the method we want to call after the object is instantiated:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是对象实例化后我们想要调用的方法：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The name `perform` is just a name of my choosing. All that is important to remember
    is that, except for the constructor, all methods should be verbs. Keep in mind
    that class and variable identifiers should be nouns.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`perform`这个名字只是我选择的名字。重要的是要记住，除了构造函数之外，所有方法都应该使用动词。记住，类和变量标识符应该是名词。'
- en: 'The first line of the method calls upon the `calculateCompoundInterest` method
    to perform the calculation and stores the result in the `result` variable:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 方法调用的第一行调用`calculateCompoundInterest`方法进行计算，并将结果存储在`result`变量中：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This next line displays the result formatted appropriately:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行显示的结果格式正确：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The plus symbols in the code mean concatenation. As the string is quite long,
    it has been broken up into multiple strings joined by the plus operator.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的加号符号表示连接。由于字符串相当长，它已经被拆分成多个由加号运算符连接的字符串。
- en: 'Here, we see the method that carries out the calculation of the answer:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到执行答案计算的方法：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using the instance variables, calculate the result to a variable named `result`
    that the method returns to whoever called it. It is a private method, so only
    other methods in this class can see it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用实例变量，将结果计算到一个名为`result`的变量中，该方法将其返回给调用者。这是一个私有方法，因此只有本类中的其他方法可以看到它。
- en: The second class from the compound interest example holds just the `main` method.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 复利示例中的第二个类只包含`main`方法。
- en: 'Again, let’s declare the package this file is in:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们声明这个文件所在的包：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This program will be using the `CompoundInterestCalculator04` class that we
    have written. As with all imports, we are referencing a class that we wrote in
    a package/folder we created:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序将使用我们编写的`CompoundInterestCalculator04`类。与所有导入一样，我们正在引用我们创建的包/文件夹中编写的类：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is the first line that declares the class:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是声明类的第一行：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It shows us the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 它展示了以下内容：
- en: This class is public and so can be instantiated in any other class that declares
    a reference to it.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个类是公共的，因此可以在任何声明对其有引用的其他类中实例化。
- en: The class name, `CompoundInterest04`, must also be the name of the file.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类名`CompoundInterest04`也必须是文件名。
- en: You can have more than one class structure in a file but only one of them may
    be public.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个文件中可以有多个类结构，但其中只有一个可以是公共的。
- en: 'Every Java program must have a `main` method. This is where the JVM begins
    the execution of your program:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Java程序都必须有一个`main`方法。这是JVM开始执行你的程序的地方：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `main` method is a static method. What sets static methods apart from non-static
    ones is that we can call these static methods without instantiating the object,
    such as what we did with the static methods for `NumberFormat`. The `Math` library
    works the same way. To use the `pow` function, we just write `Math.pow`. We do
    not need to instantiate the `Math` object first.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`方法是一个静态方法。静态方法与非静态方法的不同之处在于，我们可以调用这些静态方法而不需要实例化对象，就像我们使用`NumberFormat`的静态方法那样。`Math`库也是这样工作的。要使用`pow`函数，我们只需写`Math.pow`。我们不需要首先实例化`Math`对象。'
- en: 'Here, we instantiate the `CompoundInterestCalculator04` class into an object
    with a reference named `banker`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用名为`banker`的引用实例化`CompoundInterestCalculator04`类：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We end `main` with a call to the perform method in `CompoundInterestCalculator04`
    class:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`main`方法中调用`CompoundInterestCalculator04`类中的`perform`方法结束：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We have now reviewed how the `CompoundInterest04` program is constructed and
    how we make use of access control and packages.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经回顾了`CompoundInterest04`程序是如何构建的，以及我们如何利用访问控制和包。
- en: Class organization based on functionality
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于功能的功能类组织
- en: The compound interest program we have been using from the start of this book
    conducts its specific task correctly. However, the problem with this approach
    is that the program is a dead end–not that being a dead end is necessarily bad.
    Sometimes, you just want a *one-off* program that can determine the answer to
    a specific problem.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从本书开始使用的复利程序正确地执行了其特定任务。然而，这种方法的问题在于程序是一个死胡同——这并不意味着死胡同一定是坏事。有时，你只是想要一个可以确定特定问题答案的*一次性*程序。
- en: But what if we were to write a complex program? In the real world, meaning coding
    in your job, you will seldom be writing programs such as our compound interest
    calculator. Imagine you wanted to create a more thorough banking system. In this
    system, it will be necessary to gather input from the user rather than hardcoding
    it in the program’s source code. Taking it further, you may want to store the
    input and the result in an external storage such as a database. You may also want
    to generate reports based on the stored data.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们编写一个复杂的程序呢？在现实世界中，意味着在工作中编码，你很少会编写像我们的复利计算器这样的程序。想象一下，你想要创建一个更完善的银行系统。在这个系统中，将需要从用户那里获取输入，而不是在程序的源代码中硬编码它。更进一步，你可能希望将输入和结果存储在外部存储中，如数据库。你可能还希望根据存储的数据生成报告。
- en: Let’s now reorganize the `CompoundInterest04` program, now renamed `CompoundInterest05`,
    based on functionality.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们根据功能重新组织`CompoundInterest04`程序，现在重命名为`CompoundInterest05`。
- en: The data class
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据类
- en: The first step is to design a class that just holds the data. There will be
    no domain methods, such as for calculating, storing in a database, or interacting
    with the end user for input and output methods. We are creating a new data type
    that we can use in classes that perform other actions. This type of class follows
    a pattern first described as a **JavaBean**. Java introduced it as a reusable
    software component.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是设计一个只持有数据的类。这个类将没有领域方法，例如计算、存储在数据库中或与最终用户进行输入输出方法交互。我们正在创建一个新的数据类型，我们可以在执行其他动作的类中使用它。这种类型的类遵循一个最初被描述为**JavaBean**的模式。Java将其引入作为一种可重用的软件组件。
- en: What we are creating is not a pure JavaBean, but a variant. I frequently refer
    to this type of class as a simple box of variables. Let’s look at one for our
    compound interest problem.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的不是一个纯JavaBean，而是一个变体。我经常将这种类型的类称为一个简单的变量盒子。让我们看看我们的复利问题中的一个例子。
- en: 'We begin with the `package` statement. We will use the package name in any
    class that needs to use this by importing the name, like so:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`package`语句开始。我们将使用包名，任何需要使用这个包的类都可以通过导入名称来使用，如下所示：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here is the standard public class declaration:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是标准的公共类声明：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here are the four variables required to perform the calculation:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是执行计算所需的四个变量：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We declare the four instance variables here. They are final so that once assigned
    a value, it becomes immutable. We expect these to come from the program’s user
    rather than hardcoding the values as we have done up until now. This means that
    every new calculation will need a new `CompoundInterestData` object.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里声明了四个实例变量。它们是final的，所以一旦赋值，就变为不可变。我们预计这些值将来自程序的用户，而不是像我们之前那样硬编码值。这意味着每次新的计算都需要一个新的`CompoundInterestData`对象。
- en: 'This last variable is where we plan to store the result of the calculation:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后这个变量是我们计划存储计算结果的地方：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As there are no actions in this class, we cannot determine when this value will
    be set, so it cannot be final.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个类中没有动作，我们无法确定这个值何时会被设置，因此它不能是final的。
- en: 'This is the constructor:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这是构造函数：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It has four required arguments when this class is instantiated. Once assigned
    to the class variables, you cannot change the value they hold. Take note of the
    `this` keyword. As we used the same name for the instance variables and the arguments
    of the method, we use `this` to designate an instance variable. Remember that
    `this` is the address of the instance variables in the class. There is not a `this`
    reference for class or static variables as there is ever only one of them per
    class. Without using `this`, you are referring to the method’s argument of the
    same name. The `result` instance variable is not one of the arguments as you will
    calculate its value later in the program.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个类被实例化时，它有四个必需的参数。一旦赋值给类变量，你不能改变它们所持有的值。注意`this`关键字。由于我们使用了与方法参数相同的实例变量名，我们使用`this`来指定实例变量。记住`this`是类中实例变量的地址。对于类或静态变量没有`this`引用，因为每个类只有一个。不使用`this`，你将引用同名的参数。`result`实例变量不是参数之一，因为你在程序中稍后计算它的值。
- en: 'The next four methods are getters for the four class instance variables:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的四个方法是为四个类实例变量提供的getter：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The JavaBean specification that this class is based on requires that all instance
    variables be private. The spec goes on to define setter and getter methods. As
    these first four are immutable by virtue of being `final`, you can only have a
    getter. You will be providing the initial value when you create an object using
    `new`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类基于的JavaBean规范要求所有实例变量必须是私有的。规范接着定义了setter和getter方法。由于这前四个变量通过`final`属性是不可变的，因此你只能有一个getter。当你使用`new`创建对象时，你将提供初始值。
- en: 'These last two methods are special because the `result` variable is not final:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后两种方法很特殊，因为`result`变量不是最终的：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We determine the value after this class is instantiated. We assign values to
    the four input values in the constructor. Frameworks such as the Java Persistence
    API or Jakarta expect this getter and setter syntax.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在实例化这个类之后确定值。我们在构造函数中为四个输入值赋值。Java持久化API或Jakarta等框架期望这种getter和setter语法。
- en: The business class
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 业务类
- en: 'Now, let’s write the `calculation` class. Its sole purpose will be to calculate
    the result and store it in the bean. We are importing the data class we just created:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写`calculation`类。它的唯一目的将是计算结果并将其存储在bean中。我们正在导入我们刚刚创建的数据类：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This class has only one method and does not have any instance variables. As
    all the values are in `CompoundInterestData05`, we retrieve the values with a
    call to the property’s `getter` method. We end by assigning the result to the
    bean’s result variable by calling the only setter:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类只有一个方法，没有实例变量。由于所有值都在`CompoundInterestData05`中，我们通过调用属性的`getter`方法来检索这些值。最后，我们通过调用唯一的setter将结果分配给bean的结果变量：
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The user interface class
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户界面类
- en: 'The last component is the user interface where we can ask the user for the
    four pieces of information required to perform the calculation. This is where
    we will create this object:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个组件是用户界面，在这里我们可以向用户请求执行计算所需的四条信息。这就是我们将创建此对象的地方：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After the `package` statement, we have imports for the classes and libraries
    we will use. We have a new import, and that is for the `Scanner` library class.
    Objects of the `Scanner` class allow us to gather end-user input, such as from
    the keyboard, in a console application:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在`package`语句之后，我们有我们将使用的类和库的导入。我们有一个新的导入，那就是`Scanner`库类。`Scanner`类的对象允许我们在控制台应用程序中收集最终用户输入，例如从键盘输入：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In Java, there are no rules covering the order of methods or the locations of
    fields, unlike in C and C++ where the order can be significant. My personal style
    is, as you see in these examples, to place the instance variables first and the
    constructors right after. My advice on this point is to have the team you work
    with all agree to the coding style. This will make reading each other’s code far
    easier.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，没有关于方法顺序或字段位置的规则，这与C和C++不同，在C和C++中，顺序可能很重要。我个人的风格，正如你在这些示例中看到的，是将实例变量放在第一位，然后将构造函数紧随其后。关于这个问题的建议是，与你的团队就编码风格达成一致。这将使阅读彼此的代码变得容易得多。
- en: 'Here is the constructor that instantiates the `NumberFormat` objects and the
    `Scanner` class. You must provide the `Scanner` class’s constructor with the source
    of input. It could be from a file on disk, but for this program, it is coming
    from the keyboard. We call the object that interacts with the keyboard’s `System.in`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是实例化`NumberFormat`对象和`Scanner`类的构造函数。你必须向`Scanner`类的构造函数提供输入源。它可以是来自磁盘上的文件，但在这个程序中，它来自键盘。我们调用与键盘交互的对象的`System.in`：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next up is the entry point for this user interface class. This will be the
    only public method in this class. I use the `do` prefix as it ensures that the
    name is a verb or action. The four values we must request from the user exist
    as local or method variables. We assign the result of user input to each one.
    We instantiate the data object with the four local variables as parameters in
    this expression. The `new` operator copies the values from the local variables
    to the instance variables of the `CompoundInterestData05` object through the constructor.
    We then call upon `calculateCompoundInterest` in our `Calculator` class to calculate
    the result. The last step is to display the result:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是这个用户界面类的入口点。这将是这个类中唯一的公共方法。我使用`do`前缀，因为它确保名称是一个动词或动作。我们必须从用户请求的四个值作为局部或方法变量存在。我们将用户输入的结果分配给每一个。在这个表达式中，我们使用四个局部变量作为参数实例化数据对象。`new`运算符通过构造函数将值从局部变量复制到`CompoundInterestData05`对象的实例变量中。然后我们调用`Calculator`类中的`calculateCompoundInterest`来计算结果。最后一步是显示结果：
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This version of the `CompoundInterest` program follows the classic pattern
    of input, process, and output. The first method we now encounter is `output`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的`CompoundInterest`程序遵循经典的输入、处理和输出模式。我们现在遇到的第一个方法是`output`：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This next method is part of the input process. It could provide additional
    instructions on the screen to the end user, but I have kept it simple here:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法是输入过程的一部分。它可以在屏幕上向最终用户提供额外的说明，但我在这里保持了简单：
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we come to the user input. Each input will display a prompt and wait for
    input. Once you enter the string, the `nextDouble` method attempts to convert
    it to the appropriate type–in this case, `double`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来到用户输入部分。每个输入都会显示一个提示并等待输入。一旦你输入字符串，`nextDouble`方法就会尝试将其转换为适当的类型——在这种情况下，是`double`：
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: But wait–there is something terribly wrong with the four input methods. They
    are identical except for the `String` prompt. As a teacher, I described repeated
    code as an invitation to failure. If we decided to make a change, such as switching
    from `double` to `float`, we must remember to make this change four times in eight
    separate places. The potential for inadvertently neglecting one of the changes
    is too high. Let’s turn this from four methods to one.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等——四个输入方法中有一个严重的问题。除了`String`提示外，它们完全相同。作为一名教师，我把重复的代码描述为失败的邀请。如果我们决定进行更改，比如从`double`切换到`float`，我们必须记住在八个不同的地方进行四次更改。不小心遗漏其中一个更改的可能性太高。让我们将这四个方法合并为一个。
- en: 'It’s simple–just make the prompt an argument to a single input method, like
    so:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单——只需将提示作为单个输入方法的参数，如下所示：
- en: '[PRE38]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we can use the `doUserInput` method for all four user inputs:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`doUserInput`方法来处理所有四个用户输入：
- en: '[PRE39]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: All user input is a `String` object; you cannot enter pure numbers, Booleans,
    or characters. The `Scanner` class is responsible for converting from a string
    to the destination type, as expressed by the next methods.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 所有用户输入都是`String`对象；你不能输入纯数字、布尔值或字符。`Scanner`类负责将字符串转换为目的地类型，如`next`方法所表达的那样。
- en: In our example, they are all doubles. What happens if we enter the `bob` string
    instead of a number? Java will throw an exception. This is an error condition.
    When we look at loops, we will learn how to create user-proof input, and when
    we look at GUI programming, we will learn about other ways we can manage user
    input. In all situations, all input arrives–as already mentioned–as strings.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，它们都是`double`类型。如果我们输入`bob`字符串而不是数字会发生什么？Java会抛出异常。这是一个错误条件。当我们研究循环时，我们将学习如何创建防用户输入错误，当我们研究GUI编程时，我们将了解其他管理用户输入的方法。在所有情况下，所有输入都作为字符串到达——如前所述。
- en: 'The last class is the `app` class. We commonly use the designation app to define
    a package that contains the class that holds the `main` method. This is a convention,
    and you can freely change this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个类是`app`类。我们通常使用`app`这个名称来定义一个包含包含`main`方法的类的包。这是一个约定，你可以自由地更改它：
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When we run this new version, this will be the output:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个新版本时，这将是我们得到的输出：
- en: '[PRE41]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The program requests from the user the four values it requires, and then using
    those values, it calculates the result and displays it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 程序会要求用户输入它所需的四个值，然后使用这些值计算结果并显示。
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have explored the basic components of a class. Once we reviewed
    how we assembled the `CompoundInterest04` example, we broke the program apart
    and created classes to hold the data, display a user interface, and calculate
    the result. We also learned about the constructor and the deprecated `finalize`
    methods. We gained insight into what `new` does and how the JVM manages a program’s
    memory.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了类的基本组成部分。一旦我们回顾了如何组装`CompoundInterest04`示例，我们就将程序拆分，创建了用于存储数据、显示用户界面和计算结果的类。我们还了解了构造函数和已弃用的`finalize`方法。我们了解了`new`的作用以及JVM如何管理程序的内存。
- en: The second version, `CompoundInterest05`, presents how a program is organized
    professionally based on functionality. It kept separate the data, the user interface,
    and the action, usually called the business. To gather user input, we had our
    first look at the Java library `Scanner` class. You should now have a good understanding
    of how a Java class is organized and how you can control access to members of
    the class.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个版本，`CompoundInterest05`，展示了如何根据功能专业地组织程序。它将数据、用户界面和操作（通常称为业务）分开。为了收集用户输入，我们首次了解了Java库中的`Scanner`类。你现在应该对Java类的组织结构以及如何控制类成员的访问有很好的理解。
- en: In the next chapter, we will look more closely at the methods that carry out
    the actions of a class and how we manage the relationships between classes.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨执行类操作的策略以及我们如何管理类之间的关系。
- en: Further reading
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Stack Memory and Heap Space in* *Java*: [https://www.baeldung.com/java-stack-heap](https://www.baeldung.com/java-stack-heap)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Java中的栈内存和堆空间*：[https://www.baeldung.com/java-stack-heap](https://www.baeldung.com/java-stack-heap)'
