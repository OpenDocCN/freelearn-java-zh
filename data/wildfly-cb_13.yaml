- en: Chapter 13. Messaging with WildFly
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 13 章。使用 WildFly 进行消息传递
- en: 'In this chapter, you will learn the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下配方：
- en: Running the messaging system using HornetQ
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 HornetQ 运行消息系统
- en: Sending and receiving messages to/from a JMS queue destination
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向/从 JMS 队列目的地发送和接收消息
- en: Clustering HornetQ using a shared store
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用共享存储进行 HornetQ 集群
- en: Clustering HornetQ using message replication
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用消息复制进行 HornetQ 集群
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, you will learn how to configure HornetQ embedded in our WildFly
    in order to provide JMS capabilities to our applications. As WildFly is a Java
    EE 7-certified application server, it implements the JMS specification version
    2.0.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何配置 WildFly 中的 HornetQ 嵌入，以便为我们的应用程序提供 JMS 功能。由于 WildFly 是 Java EE
    7 认证的应用服务器，它实现了 JMS 规范版本 2.0。
- en: HornetQ is a **Message oriented middleware** (**MOM**) used to exchange messages
    in clustered and asynchronous systems. It can run standalone (I'm not talking
    about the WildFly standalone mode) or embedded, that is inside an application
    server such as WildFly, by using the **Java EE Connector Architecture** (**JCA**).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: HornetQ 是一种 **面向消息的中间件（MOM**），用于在集群和异步系统中交换消息。它可以独立运行（我说的不是 WildFly 独立模式）或嵌入，即在
    WildFly 等应用程序服务器内部，通过使用 **Java EE 连接器架构（JCA**）。
- en: Because HornetQ uses the JCA to integrate itself with WildFly, it also provides
    out-of-the-box support for connection pooling, JTA transactions, and container
    managed security, features that simplify a developer's life. Thus, integrating
    your EJB application with the JMS system will not need additional work.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 HornetQ 使用 JCA 与 WildFly 集成，它还提供了开箱即用的连接池、JTA 事务和容器管理安全支持，这些功能简化了开发者的工作。因此，将您的
    EJB 应用程序与 JMS 系统集成不需要额外的工作。
- en: HornetQ uses two fundamental concepts, that is, acceptors and connectors. Acceptors
    determine how the HornetQ server accepts incoming connections, while connectors
    determine how to make connections with other HornetQ servers or JMS clients.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: HornetQ 使用两个基本概念，即接受者和连接器。接受者确定 HornetQ 服务器如何接受传入的连接，而连接器确定如何与其他 HornetQ 服务器或
    JMS 客户端建立连接。
- en: 'Two types of acceptors and connectors exist:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 存在两种类型的接受者和连接器：
- en: '**invm**: The connections within the same JVM (more performance, obviously)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**invm**：同一 JVM 内部的连接（显然性能更好）'
- en: '**netty**: The connections to/from remote JVMs'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**netty**: 与远程 JVM 的连接'
- en: Each configured connector is used just to reach a server if there is the same
    type of acceptor configured on the other server. In other words, if we are making
    a connection with an `invm` connector, the other server must have an `invm` acceptor
    configured. On the other hand, if we are making a connection with a `netty` connector,
    the other server must have a `netty` acceptor configured.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每个配置的连接器仅用于到达服务器，如果另一服务器上配置了相同类型的接受者。换句话说，如果我们使用 `invm` 连接器建立连接，另一服务器必须配置了 `invm`
    接受者。另一方面，如果我们使用 `netty` 连接器建立连接，另一服务器必须配置了 `netty` 接受者。
- en: HornetQ provides HA capabilities using a live server and a backup server. The
    backup server is in idle mode; it does not work until the live server fails.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: HornetQ 使用一个主服务器和一个备份服务器提供高可用性（HA）功能。备份服务器处于空闲模式；只有在主服务器失败时才会工作。
- en: 'Essentially, all messages are constantly replicated from the live server to
    the backup server. This synchronization is achieved in two ways: shared store
    and message replication. Shared store essentially means that both the live and
    backup servers share the same filesystem where messages are stored. Message replication,
    on the other hand, works via network traffic. Each server will then persist messages
    in its own local filesystem.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，所有消息都是不断从主服务器复制到备份服务器。这种同步通过两种方式实现：共享存储和消息复制。共享存储本质上意味着主服务器和备份服务器共享相同的文件系统，其中存储消息。另一方面，消息复制通过网络流量工作。然后每个服务器将在其自己的本地文件系统中持久化消息。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Only persistent messages are replicated; thus they survive a server crash.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 只有持久消息才会被复制；因此，它们在服务器崩溃后仍然存在。
- en: 'HornetQ has its own persistence, which is based on a high-performance journal
    filesystem. HornetQ uses three different journals:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: HornetQ 有自己的持久性，它基于高性能的日志文件系统。HornetQ 使用三种不同的日志：
- en: Bindings journal
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定日志
- en: JMS journal
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JMS 日志
- en: Message journal
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息日志
- en: 'HornetQ supports two different configurations for shared stores:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: HornetQ 支持两种不同的共享存储配置：
- en: GFS2 on a SAN, using the AsyncIO journal type
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 SAN 上的 GFS2，使用 AsyncIO 日志类型
- en: NFSv4, using either the AsyncIO or NIO journal type
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AsyncIO 或 NIO 日志类型的 NFSv4
- en: Note
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: NFS should only be used in a development environment, because of its performance
    issues.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于性能问题，NFS应仅用于开发环境。
- en: We can find the HornetQ configuration embedded into our WildFly configuration
    files, more precisely in the `standalone-full.xml` and `standalone-full-ha.xml`,
    if we are running in the standalone mode. However, if we are running in the domain
    mode, we can find the proper HornetQ configuration in the WildFly provided profiles
    such as `full` and `full-ha`. The `full` configuration enables the messaging systems,
    while the `full-ha` adds clustering and load-balancing capabilities.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在独立模式下运行，我们可以在WildFly配置文件中找到嵌入的HornetQ配置，更确切地说是在`standalone-full.xml`和`standalone-full-ha.xml`中。然而，如果我们运行在域模式下，我们可以在WildFly提供的配置文件中找到适当的HornetQ配置，例如`full`和`full-ha`。`full`配置启用了消息系统，而`full-ha`增加了集群和负载均衡功能。
- en: For this chapter, it's assumed that you are familiar with JMS concepts such
    as Queue, Topic, MDB, DLQ, ExpiryQueue, point-to-point, and publish/subscribe,
    because we will not go too deep into JMS specification details. If you want to
    start learning about HornetQ, I really suggest you to read the excellent book
    *HornetQ Messaging Developer's Guide*, *Piero Giacomelli*, *Packt Publishing*,
    which goes deep into the development aspects of the framework and the JMS specification.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，假设您熟悉JMS概念，如队列、主题、MDB、死信队列、过期队列、点对点和发布/订阅，因为我们不会深入探讨JMS规范细节。如果您想开始学习HornetQ，我强烈建议您阅读由Piero
    Giacomelli撰写的优秀书籍《HornetQ消息开发指南》，由Packt Publishing出版，该书深入探讨了框架的开发方面和JMS规范。
- en: There are also alternatives to HornetQ, such as ActiveMQ. For a deeper look
    into ActiveMQ, please refer to official documentation at [http://activemq.apache.org](http://activemq.apache.org).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: HornetQ也有替代品，例如ActiveMQ。要深入了解ActiveMQ，请参阅官方文档[http://activemq.apache.org](http://activemq.apache.org)。
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Architecting a messaging system is a hard and complex task; it involves a lot
    of aspects (memory, performance, network, storage, clustering, and so on) and
    there is no one-fits-all configuration. Every messaging system needs to be configured
    adhoc, tested and tuned a lot of times before going into production.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个消息系统是一项艰难且复杂的工作；它涉及许多方面（内存、性能、网络、存储、集群等），并且没有一种适合所有情况的配置。每个消息系统都需要进行专门的配置、测试和多次调整，才能投入生产。
- en: Running the messaging system using HornetQ
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HornetQ运行消息系统
- en: In this recipe, you will learn how to configure and run the WildFly messaging
    system provided by HornetQ. This is a warm-up recipe, just to get you ready.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，您将学习如何配置和运行由HornetQ提供的WildFly消息系统。这是一个热身食谱，只是为了让您做好准备。
- en: Getting ready
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To get started, let''s first create an `adhoc` folder to run our WildFly. In
    a terminal window enter the following commands:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，让我们首先创建一个`adhoc`文件夹来运行我们的WildFly。在终端窗口中输入以下命令：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now it's time to run our WildFly!!!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候运行我们的WildFly了！！！
- en: How to do it…
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Open a terminal window and execute the following:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个终端窗口并执行以下命令：
- en: '[PRE1]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now if we open the Web Console, we should find the **Messaging** subsystem as
    well, as depicted in the following screenshot:![How to do it…](img/3744_13_01.jpg)
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们打开Web控制台，我们应该也能找到**消息**子系统，如下面的截图所示：![如何做到这一点…](img/3744_13_01.jpg)
- en: Admin Console showing the Messaging subsystem
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 管理控制台显示消息子系统
- en: Well, that was quite simple! Let's try something more exciting with the following
    recipes of this chapter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这很简单！让我们尝试本章接下来的更令人兴奋的食谱。
- en: How it works…
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First of all, you should have noticed that we specified the `--server-config`
    directive, which overrides the default configuration filename, that is, `standalone.xml`
    for the standalone mode, and `host.xml` for the domain mode.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您应该已经注意到我们指定了`--server-config`指令，它覆盖了默认的配置文件名，即独立模式下的`standalone.xml`，以及域模式下的`host.xml`。
- en: 'The configuration filename specified is the one which has the messaging system
    pre-configured. If you remember from the earlier recipes of the book, in WildFly
    (as also in JBoss AS, and JBoss EAP) we have the following for different profiles:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 指定的配置文件名是预先配置了消息系统的那个。如果您还记得这本书前面的食谱，在WildFly（同样在JBoss AS和JBoss EAP）中，对于不同的配置文件，我们有以下内容：
- en: '`default`: This should be used for common web applications (including REST
    backend)'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`: 应用于通用Web应用程序（包括REST后端）'
- en: '`full`: This should be used for applications with JMS capabilities'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`full`: 应用于具有JMS功能的应用程序'
- en: '`ha`: This should be used for common web applications that require clustering
    and balancing capabilities'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ha`：此配置应用于需要集群和平衡能力的常见Web应用程序'
- en: '`full-ha`: This should be used for applications that require JMS, clustering,
    and balancing capabilities all together'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`full-ha`：此配置应用于需要JMS、集群和平衡能力的应用程序'
- en: Thus, the `standalone-full.xml` file gives us the proper configuration to run
    applications with JMS capabilities.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`standalone-full.xml`文件为我们提供了运行具有JMS功能的应用程序的正确配置。
- en: 'After we launched the start-up script, the log showed us various entries. Take
    for example the following entry:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 启动启动脚本后，日志显示各种条目。以以下条目为例：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It is complaining about the use of the native API to access the filesystem instead
    of using the Java NIO ones. This is because, as mentioned in the introduction,
    HornetQ persists JMS messages on the filesystem, so a better performant API is
    preferred.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 它在抱怨使用本地API访问文件系统而不是使用Java NIO API。这是因为，如介绍中提到的，HornetQ在文件系统上持久化JMS消息，所以更高效的API是首选。
- en: 'Other interesting log entries are the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 其他有趣的日志条目如下：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding entries are relative to the multi-protocol interoperability that
    HornetQ provides (it doesn't implement just the JMS specification). They imply
    that the server (meaning HornetQ) is now ready to produce and consume messages,
    and all that comes with it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的条目与HornetQ提供的多协议互操作性相关（它不仅仅实现了JMS规范）。这意味着服务器（即HornetQ）现在已准备好生产和消费消息，以及所有相关内容。
- en: 'Last, but not least, the following entries describe the resource that we have
    preconfigured:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，以下条目描述了预先配置的资源：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have connection factories, which are used to connect and obtain a session
    from the server to send and receive messages.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有连接工厂，用于连接服务器并从服务器获取会话，以便发送和接收消息。
- en: 'We also have two destinations: `jms.queue.DLQ` and `jms.queue.ExpiryQueue`.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有两个目的地：`jms.queue.DLQ`和`jms.queue.ExpiryQueue`。
- en: The first one is the *dead letter queue*, where all messages that couldn't be
    successfully processed (consumed) go to. When something goes wrong while consuming
    a message with a **Message Driven Bean** (**MDB**), the message gets rolled back
    and goes directly to the DLQ. Nevertheless, there are redelivery policies that
    can try to send our message again.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是一个*死信队列*，所有无法成功处理（消费）的消息都会进入其中。当使用**消息驱动Bean**（**MDB**）消费消息时出现错误，消息将被回滚并直接进入DLQ。尽管如此，还是有重传策略可以尝试再次发送我们的消息。
- en: All expired messages go to the queue called `ExpiryQueue`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 所有过期消息都会进入名为`ExpiryQueue`的队列。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are running on Mac and using the `full-ha` profile, beware of the following
    network issue you might meet:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Mac上运行并使用`full-ha`配置文件，请注意您可能会遇到以下网络问题：
- en: '`HQ224033`: Failed to broadcast connector `configs: java.io.IOException`; Can''t
    assign requested address'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`HQ224033`：广播连接器`configs`失败；无法分配请求的地址'
- en: The `full-ha` profile, because of its additional clustering and balancing capabilities,
    provides auto-discovery to its HornetQ server, and it does so by using the multicast
    address. Often, UDP traffic gets dropped, so make sure that the environment you
    are in accepts UDP traffic.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`full-ha`配置提供了额外的集群和平衡能力，它为其HornetQ服务器提供自动发现，这是通过多播地址实现的。通常，UDP流量会被丢弃，所以请确保您所在的环境接受UDP流量。
- en: For example, in our case, we are probably trying the recipe at home, and UDP
    traffic gets forwarded to the ISP that drops such traffic. What we need to do
    is create a local route to redirect the UDP traffic to our loopback interface,
    which is our localhost, `127.0.0.1` IP address.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的案例中，我们可能正在尝试在家中的食谱，并且UDP流量被转发到丢弃此类流量的ISP。我们需要做的是创建一个本地路由，将UDP流量重定向到我们的回环接口，即我们的localhost，`127.0.0.1`
    IP地址。
- en: 'You can add the multicast route to the loopback interface as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将多播路由添加到回环接口，如下所示：
- en: '`sudo route add 224.0.0.0 127.0.0.1 -netmask 240.0.0.0`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo route add 224.0.0.0 127.0.0.1 -netmask 240.0.0.0`'
- en: Beware that when running in a production environment, adding this loopback route
    will prevent any and all multicast messages from reaching other servers.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在生产环境中运行时，添加此回环路由将阻止所有多播消息到达其他服务器。
- en: See also
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For a deeper understanding of the HornetQ server principles, please refer to
    the official documentation at [http://hornetq.jboss.org](http://hornetq.jboss.org).
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 若要深入了解HornetQ服务器原理，请参阅官方文档，链接为[http://hornetq.jboss.org](http://hornetq.jboss.org)。
- en: Sending and receiving messages to/from a JMS queue destination
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向/从 JMS 队列目标发送和接收消息
- en: In this recipe, we will learn how to produce and consume a JMS queue message.
    We will use two little applications, one that produces messages, and another one
    that consumes messages.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何生产和消费 JMS 队列消息。我们将使用两个小应用程序，一个用于生成消息，另一个用于消费消息。
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To get started, let''s first create an `adhoc` folder to run our WildFly. In
    a terminal window enter the following commands:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始，让我们首先创建一个 `adhoc` 文件夹来运行我们的 WildFly。在终端窗口中输入以下命令：
- en: '[PRE5]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this recipe, we will need an application to test our configuration. For this
    recipe, we will need the applications named `jms-producer` and `jms-consumer`,
    which you can find in my GitHub repository. If you skipped the *Managing applications
    using the deployments folder* recipe of [Chapter 2](ch02.html "Chapter 2. Running
    WildFly in Standalone Mode"), *Running WildFly in Standalone Mode*, please refer
    to it to download all the source code and projects that you will need.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们需要一个应用程序来测试我们的配置。为此菜谱，我们需要名为 `jms-producer` 和 `jms-consumer` 的应用程序，您可以在我的
    GitHub 仓库中找到它们。如果您跳过了 [第 2 章](ch02.html "第 2 章。以独立模式运行 WildFly") 中关于 *使用部署文件夹管理应用程序*
    的菜谱，请参阅它以下载您将需要的所有源代码和项目。
- en: 'To build the application, enter the following commands:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要构建应用程序，请输入以下命令：
- en: '[PRE6]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now it's time to run our WildFly!!!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候运行我们的 WildFly 了！！！
- en: How to do it…
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: First of all, we need to add a user to the `ApplicationRealm` realm, which is
    the one used by the remoting subsystem and hence, the messaging subsystem.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要向 `ApplicationRealm` 域添加一个用户，这是远程子系统使用的域，因此也是消息子系统。
- en: 'Open a terminal window and execute the following:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个终端窗口并执行以下操作：
- en: '[PRE7]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now it''s time to run our WildFly as follows:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候按照以下方式运行我们的 WildFly 了：
- en: '[PRE8]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once started, let''s connect to the CLI in a new terminal and create the queue,
    as follows:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦开始，让我们在新终端中连接到 CLI 并创建队列，如下所示：
- en: '[PRE9]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In our `server.log`, we should find the following entries:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `server.log` 中，我们应该找到以下条目：
- en: '[PRE10]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Great, we've successfully created our queue destination!!!
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 太棒了，我们成功创建了我们的队列目标！！！
- en: 'Now it''s time to run our `jms-producer` and send a message to our `WildFlyCookbookQueue`
    queue. Let''s compile it and run it, as follows:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候运行我们的 `jms-producer` 并向我们的 `WildFlyCookbookQueue` 队列发送消息了。让我们编译并运行它，如下所示：
- en: '[PRE11]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The result of the preceding command is depicted in the following image:'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述命令的结果如图所示：
- en: '![How to do it…](img/3744_13_02.jpg)'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/3744_13_02.jpg)'
- en: 'Our producer sent ten text messages containing the following text: `A message
    by WildFly Cookbook`.'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的生成器发送了包含以下文本的十条文本消息：`WildFly Cookbook 的一条消息`。
- en: 'So if we now connect to the CLI, we can count the number of messages in our
    `WildFlyCookbookQueue` destination, as follows:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，如果我们现在连接到 CLI，我们可以计算我们的 `WildFlyCookbookQueue` 目标中的消息数量，如下所示：
- en: '[PRE12]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding CLI command shows, effectively, the number of messages we were
    expecting. Let''s try our consumer by executing the following commands:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述 CLI 命令实际上显示了我们所期望的消息数量。让我们通过执行以下命令来尝试我们的消费者：
- en: '[PRE13]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The result of the preceding command is depicted in the following image:'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述命令的结果如图所示：
- en: '![How to do it…](img/3744_13_03.jpg)'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/3744_13_03.jpg)'
- en: Great, we successfully consumed the messages that were stored in our queue!!!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，我们成功消费了存储在队列中的消息！！！
- en: Furthermore, when consuming a message with an MDB, if your MDB has a bug, or
    if it gets an exception for any reason, its process gets rolled back; thus, the
    message goes to the DLQ.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当使用 MDB 消费消息时，如果您的 MDB 出现错误，或者由于任何原因抛出异常，其进程将被回滚；因此，消息将进入死信队列（DLQ）。
- en: How it works…
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'To be able to understand what we have done and why, we need to look at the
    default messaging subsystem configuration. For the purpose of this recipe, we
    will analyze a specific setting such as the `security-setting`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够理解我们所做的一切以及为什么，我们需要查看默认消息子系统配置。为了本菜谱的目的，我们将分析一个特定的设置，例如 `security-setting`：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The above XML code snippet defines that any ("#" symbol is a wildcard to indicate
    any) destination needs to have a specific roles for a specific permission, such
    as sending and consuming a message. Default settings specify the "guest" role
    for sending and consuming a message from any queue.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的 XML 代码片段定义了任何（“#”符号是一个通配符，表示任何）目标都需要为特定的权限指定特定的角色，例如发送和消费消息。默认设置指定了“guest”角色，用于从任何队列发送和消费消息。
- en: That's why we need to add a user, using the `add-user` script with the role,
    `guest`. Furthermore, why did we need a user at all?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，我们需要添加一个用户，使用`add-user`脚本并指定角色`guest`。此外，为什么我们还需要用户呢？
- en: 'As we are connecting to the destination remotely using the `http-remoting://localhost:8080`
    address, WildFly uses the remoting subsystem to handle remote connections, which
    has the following configuration:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用`http-remoting://localhost:8080`地址远程连接到目的地，WildFly使用远程子系统来处理远程连接，其配置如下：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The remoting subsystem references the `ApplicationRealm` realm, that's why we
    added the `jmsuser` user to that realm.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 远程子系统引用了`ApplicationRealm`域，这就是为什么我们将`jmsuser`用户添加到该域的原因。
- en: 'On the Java code side, we added the user''s reference as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java代码方面，我们添加了用户的引用如下：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we hadn''t specified a user in the Java code (actually omitting the `SECURITY_PRINCIPAL`
    and `SECURITY_CREDENTIALS` properties), or even added to the realm, we would have
    ended up with the following error:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有在Java代码中指定用户（实际上省略了`SECURITY_PRINCIPAL`和`SECURITY_CREDENTIALS`属性），或者甚至添加到域中，我们最终会得到以下错误：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There's more…
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'The logic seen in the preceding example, also applies to Topic. Within the
    CLI, we have pretty much the same commands for adding a `topic`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中看到的逻辑也适用于主题。在CLI中，我们添加`topic`的命令几乎相同：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: See also
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Information about the JMS specification can be found at [https://jcp.org/aboutJava/communityprocess/final/jsr343/index.html](https://jcp.org/aboutJava/communityprocess/final/jsr343/index.html)
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于JMS规范的信息可以在[https://jcp.org/aboutJava/communityprocess/final/jsr343/index.html](https://jcp.org/aboutJava/communityprocess/final/jsr343/index.html)找到。
- en: For a deeper understanding of the HornetQ server principles, please refer to
    the official documentation at [http://hornetq.jboss.org](http://hornetq.jboss.org)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要深入了解HornetQ服务器原理，请参阅官方文档[http://hornetq.jboss.org](http://hornetq.jboss.org)
- en: Clustering HornetQ using a shared store
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用共享存储进行HornetQ集群
- en: In this recipe, you will learn how to configure HornetQ to provide clustering
    features by configuring to WildFly instances; one acting as a **Live** HornetQ
    server, the other one acting as a **Backup** HornetQ server.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何通过配置WildFly实例来配置HornetQ以提供集群功能；一个作为**实时**HornetQ服务器，另一个作为**备份**HornetQ服务器。
- en: 'The overall configuration can be represented as seen in the following image:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 整体配置可以表示如下图像所示：
- en: '![Clustering HornetQ using a shared store](img/3744_13_04.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![使用共享存储进行HornetQ集群](img/3744_13_04.jpg)'
- en: Shared store configuration
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 共享存储配置
- en: Within the recipe, we will use a local shared store by giving each live and
    backup server pair the same `data` directory. This kind of configuration can also
    be very useful in both development and test environments to easily simulate high
    availability and failover capabilities.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在菜谱中，我们将通过为每个实时和备份服务器对提供相同的`data`目录来使用本地共享存储。这种配置在开发和测试环境中也非常有用，可以轻松模拟高可用性和故障转移功能。
- en: 'In a production environment, you should provide high availability by having
    more pairs of live and backup servers, and use a proper filesystem as depicted
    in the following image:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，你应该通过拥有更多对实时和备份服务器，并使用以下图像中所示的正确文件系统来提供高可用性：
- en: '![Clustering HornetQ using a shared store](img/3744_13_05.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![使用共享存储进行HornetQ集群](img/3744_13_05.jpg)'
- en: Shared store configuration with high-availability
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 高可用性共享存储配置
- en: Getting ready
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started, let's first create two `adhoc` folders to run our WildFly.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，让我们首先创建两个`adhoc`文件夹来运行我们的WildFly。
- en: 'In a terminal window, run the following commands:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端窗口中，运行以下命令：
- en: '[PRE19]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For this recipe, we will need two applications named `jms-producer` and `jms-consumer`,
    which you can find in my GitHub repository. If you skipped the *Managing applications
    using the deployments folder* recipe of [Chapter 2](ch02.html "Chapter 2. Running
    WildFly in Standalone Mode"), *Running WildFly in Standalone Mode*, please refer
    to it to download all the source code and projects that you will need.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们需要两个名为`jms-producer`和`jms-consumer`的应用程序，你可以在我的GitHub仓库中找到它们。如果你跳过了[第2章](ch02.html
    "第2章。以独立模式运行WildFly")中关于*使用部署文件夹管理应用程序*的菜谱，*以独立模式运行WildFly*，请参考它以下载你需要的所有源代码和项目。
- en: 'To build the application, execute the following commands:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要构建应用程序，请执行以下命令：
- en: '[PRE20]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How to do it…
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'First of all, we need to add a user to the `ApplicationRealm` realm, which
    is the one used by the remoting subsystem and hence, the messaging subsystem:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将一个用户添加到`ApplicationRealm`域中，这是远程子系统使用的域，因此也是消息子系统使用的域：
- en: 'Open a terminal window and enter the following commands:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个终端窗口，并输入以下命令：
- en: '[PRE21]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now edit the file `standalone-full-ha.xml` of the `hq-live server`, and replace
    the `messaging` subsystem with the following:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编辑`hq-live服务器`的`standalone-full-ha.xml`文件，并将`messaging`子系统替换为以下内容：
- en: '[PRE22]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now it''s time to run our WildFly `live` instance as follows:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候运行我们的WildFly `live`实例了，如下所示：
- en: '[PRE23]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'While starting the `live` server, edit the file `standalone-full-ha.xml` of
    the `hq-backup` server, and replace the `messaging` subsystem with the following:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在启动`live`服务器时，编辑`hq-backup`服务器的`standalone-full-ha.xml`文件，并将`messaging`子系统替换为以下内容：
- en: '[PRE24]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can now start the WildFly `backup` instance as follows:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以按照以下方式启动WildFly `backup`实例：
- en: '[PRE25]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Within the live server''s log you should find the following entries:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实时服务器的日志中，你应该找到以下条目：
- en: '[PRE26]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Whilst within the backup server''s log, you should find the following entries:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你在备份服务器的日志中时，你应该找到以下条目：
- en: '[PRE27]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Both the live and backup servers'' log entries confirm our configuration: the
    live server had gained the lock of the data directory, while the backup is waiting
    to acquire the lock and it has announced itself as the backup.'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实时和备份服务器的日志条目都证实了我们的配置：实时服务器已经获得了数据目录的锁，而备份正在等待获取锁，并已宣布自己为备份。
- en: Now it's time to do some tests.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候进行一些测试了。
- en: Testing
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试
- en: 'To test our configurations, we need to first produce some messages, then check
    if the messages have been stored, and then consume them. In this case, compile
    the `jms-producer` project as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的配置，我们首先需要生成一些消息，然后检查消息是否已存储，然后消费它们。在这种情况下，按照以下方式编译`jms-producer`项目：
- en: 'Let''s produce some messages with the `jms-producer` project as follows:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用`jms-producer`项目按照以下方式生成一些消息：
- en: '[PRE28]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, if you check the message count, you will find ten messages on the live
    server. To check, execute the following:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你检查消息计数，你将在实时服务器上找到十条消息。要检查，请执行以下操作：
- en: '[PRE29]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you invoke the preceding command on the backup server, you will get the
    following error:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你将前面的命令在备份服务器上执行，你会得到以下错误：
- en: '[PRE30]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you stop the live server, the backup server should become the new live server.
    You should find the following log entries on the backup server:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你停止实时服务器，备份服务器应该成为新的实时服务器。你应该在备份服务器上找到以下日志条目：
- en: '[PRE31]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If you invoke the count message command on the old backup server again, you
    will see it has all the messages that were produced earlier:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你再次在旧备份服务器上调用计数消息命令，你会看到它包含了之前产生的所有消息：
- en: '[PRE32]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works…
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: The mechanism behind the failover is pretty simple; because HornetQ bases its
    persistence on filesystem, it makes a lock on the data storage folder. Basically,
    for the same folder, the first server to arrive owns the lock and hence, wins.
    The second server then keeps on trying to gain the lock on the same data directory
    until it gets it, which means the live server has shutdown or crashed.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 故障转移背后的机制相当简单；因为HornetQ基于文件系统进行持久化，它会在数据存储文件夹上创建一个锁。基本上，对于相同的文件夹，第一个到达的服务器拥有锁，因此获胜。第二个服务器会继续尝试获取相同数据目录的锁，直到获得它，这意味着实时服务器已关闭或崩溃。
- en: When the backup server gains the lock, it reads all the messages stored in the
    data directory; it is available to store more messages and clients consume them.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当备份服务器获得锁时，它会读取数据目录中存储的所有消息；它可用于存储更多消息，并且客户端会消费它们。
- en: What happens if the live server crashes while a client is producing or consuming
    messages?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实时服务器在客户端生成或消费消息时崩溃会发生什么？
- en: Because of the failover and high-availability configuration (`<ha>true</ha>`
    in both, `<connection-factory name="RemoteConnectionFactory">` and `<pooled-connection-factory
    name="hornetq-ra">`), the client automatically reconnects to the first available
    live server. The client has the topology on the live and backup servers.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于故障转移和高可用性配置（在`<connection-factory name="RemoteConnectionFactory">`和`<pooled-connection-factory
    name="hornetq-ra">`中的`<ha>true</ha>`），客户端会自动重新连接到第一个可用的实时服务器。客户端具有实时和备份服务器上的拓扑。
- en: 'While producing the messages, try stopping the live server. You should get
    an output similar to what is depicted in the following image:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成消息时，尝试停止实时服务器。你应该得到以下图像中所示类似的输出：
- en: '![How it works…](img/3744_13_06.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/3744_13_06.jpg)'
- en: Client reconnects to the first available live server while producing messages
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送消息时，客户端重新连接到第一个可用的活动服务器
- en: 'The same applies when consuming messages. Following is an image showing what
    you should get:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在消费消息时也适用。以下是一张显示您应该得到的内容的图片：
- en: '![How it works…](img/3744_13_07.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/3744_13_07.jpg)'
- en: Client reconnects to the first available live server while consuming messages
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在消费消息时，客户端重新连接到第一个可用的活动服务器
- en: See also
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: As mentioned in the introduction, there is a lot to talk about HornetQ, JMS,
    and MOM in general, but it's out of the scope of this book. For this reason, I
    suggest you read the book *HornetQ Messaging Developer's Guide*, *Piero Giacomelli*,
    *Packt Publishing*, which goes deep into the development aspects of the framework
    and the JMS specification.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如介绍中所述，有很多关于 HornetQ、JMS 和 MOM 的一般性话题可以讨论，但这超出了本书的范围。因此，我建议您阅读 *HornetQ 消息开发人员指南*，作者
    Piero Giacomelli，Packt Publishing，它深入探讨了框架的开发方面和 JMS 规范。
- en: Also, the jboss.org community has done a great job in providing us all with
    information about HornetQ, which is freely available at [http://hornetq.jboss.org](http://hornetq.jboss.org).
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，jboss.org 社区在为我们所有人提供关于 HornetQ 的信息方面做得非常出色，这些信息可以在 [http://hornetq.jboss.org](http://hornetq.jboss.org)
    免费获取。
- en: Last, but not least, the JMS specification is available at [https://jcp.org/aboutJava/communityprocess/final/jsr343/index.html](https://jcp.org/aboutJava/communityprocess/final/jsr343/index.html).
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，JMS 规范可在 [https://jcp.org/aboutJava/communityprocess/final/jsr343/index.html](https://jcp.org/aboutJava/communityprocess/final/jsr343/index.html)
    获取。
- en: Clustering HornetQ using message replication
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用消息复制来集群 HornetQ
- en: In this recipe, we will learn how to configure a cluster with a live and a backup
    HornetQ server.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何配置一个包含活动 HornetQ 服务器和备份 HornetQ 服务器的集群。
- en: 'HornetQ cluster environment can be achieved by using a shared store (live and
    backup servers share the same and the entire data directory) as per the previous
    recipe, or via message replication which happens at the network layer—message
    replication mode can be achieved using the following setting:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 根据之前的配方，可以通过使用共享存储（活动服务器和备份服务器共享相同的数据目录）或通过在网络层发生的消息复制来实现 HornetQ 集群环境——可以通过以下设置实现消息复制模式：
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Our final configuration should provide the following architecture:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终的配置应提供以下架构：
- en: '![Clustering HornetQ using message replication](img/3744_13_08.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![使用消息复制集群 HornetQ](img/3744_13_08.jpg)'
- en: Message replication configuration
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 消息复制配置
- en: Getting ready
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started, let's first create an `adhoc` folder to run our WildFly.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，让我们首先创建一个 `adhoc` 文件夹来运行我们的 WildFly。
- en: 'In a terminal window, enter the following commands:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端窗口中，输入以下命令：
- en: '[PRE34]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Provide the application user for both the servers to send and receive messages,
    as follows:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为发送和接收消息的服务器提供应用程序用户，如下所示：
- en: '[PRE35]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: For this recipe, we will need an application named `cluster-jms-replication`,
    which you can find in my GitHub repository. If you skipped the *Managing applications
    using the deployments folder* recipe of [Chapter 2](ch02.html "Chapter 2. Running
    WildFly in Standalone Mode"), *Running WildFly in Standalone Mode*, please refer
    to it to download all the source code and projects that you will need.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个配方，我们需要一个名为 `cluster-jms-replication` 的应用程序，您可以在我的 GitHub 仓库中找到它。如果您跳过了
    [第 2 章](ch02.html "第 2 章。以独立模式运行 WildFly") 中关于 *使用部署文件夹管理应用程序* 的配方，请参阅它以下载您将需要的所有源代码和项目。
- en: 'To build the application, run the following commands:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要构建应用程序，请运行以下命令：
- en: '[PRE36]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now it's time to configure our HornetQ servers in WildFly!!!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候配置我们的 HornetQ 服务器在 WildFly 中了！！！
- en: How to do it…
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: To configure our servers, we will rely on the configuration present in my GitHub
    repository, named `wildfly-cookbook`. There you can find a project named `cluster-jms-replication`,
    which has been provided by the reviewer Kylin Soong.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置我们的服务器，我们将依赖于我 GitHub 仓库中现有的配置，命名为 `wildfly-cookbook`。在那里您可以找到一个名为 `cluster-jms-replication`
    的项目，该项目由审稿人 Kylin Soong 提供。
- en: 'In the folder where you download the repository (`~/WFC/github/wildfly-cookbook`),
    there is a project called `cluster-jms-replication`. From within the folder of
    the project, execute the following:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您下载仓库的文件夹（`~/WFC/github/wildfly-cookbook`）中，有一个名为 `cluster-jms-replication`
    的项目。在项目文件夹内执行以下操作：
- en: '[PRE37]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now we are ready to start our servers as follows:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好以下启动我们的服务器：
- en: '[PRE38]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Once the servers are started, go to the `cluster-jms-replication` project folder
    and invoke the following command:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器启动后，转到 `cluster-jms-replication` 项目文件夹并执行以下命令：
- en: '[PRE39]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This will send ten messages to the HornetQ cluster. In the `node1` server log
    entries, you should find the following:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将向 HornetQ 集群发送十条消息。在 `node1` 服务器日志条目中，你应该找到以下内容：
- en: '[PRE40]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Within the `node2` server log entries, you should find the following:'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `node2` 服务器日志条目中，你应该找到以下内容：
- en: '[PRE41]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now we will try a failover test by sending the first couple of messages to
    `node1`, and then stop it (regular shutdown or kill is the same). Again go to
    the `cluster-jms-replication` project folder, and invoke the following command:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将通过将前几条消息发送到 `node1` 并停止它来进行故障转移测试（正常关闭或终止都一样）。再次进入 `cluster-jms-replication`
    项目文件夹，并执行以下命令：
- en: '[PRE42]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, as soon as you get the first two messages on server `node1`, stop it.
    At the end of the process, you should get the following log entries:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，一旦你在服务器 `node1` 上收到前两条消息，就停止它。在过程结束时，你应该得到以下日志条目：
- en: '`node1`'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`node1`'
- en: '[PRE43]'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`node2`'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`node2`'
- en: '[PRE44]'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How it works…
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'There are quite a few things that need to be explained. Beware that only the
    persistent messages are replicated to the backup server. Thus, non-persistent
    messages will not fail over. In the live configuration, we added the following
    directives:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多事情需要解释。请注意，只有持久消息会被复制到备份服务器。因此，非持久消息不会进行故障转移。在实时配置中，我们添加了以下指令：
- en: '[PRE45]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The first one is quite obvious; it defines that the server will be the live
    one. The `failover-on-shutdown` means that the server will fail over to the backup
    servers, even in case of normal server shutdown, as we did in our test.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条非常明显；它定义了服务器将是实时服务器。`failover-on-shutdown` 表示即使在正常服务器关闭的情况下，服务器也会切换到备份服务器，就像我们在测试中所做的那样。
- en: 'The `check-for-live-server` directive is used along with the `allow-failback`,
    present in the backup server configuration:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`check-for-live-server` 指令与备份服务器配置中的 `allow-failback` 一起使用：'
- en: '[PRE46]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Basically, when the live server comes back up, it checks if there was a failover
    by contacting the other backup servers, and issuing a shutdown on the current
    live one for it to take over.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，当实时服务器恢复运行时，它会通过联系其他备份服务器并对其当前实时服务器发出关闭指令来检查是否发生了故障转移。
- en: See also
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: As mentioned in the introduction, there is a lot to talk about HornetQ, JMS,
    and MOM in general, but it's out of the scope of this book. For this reason, I
    suggest you read the book *HornetQ Messaging Developer's Guide*, *Piero Giacomelli*,
    *Packt Publishing*, which goes deep into the development aspects of the framework
    and the JMS specification.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如介绍中所述，有很多关于 HornetQ、JMS 和 MOM 的一般性话题可以讨论，但这些都超出了本书的范围。因此，我建议你阅读《HornetQ 消息开发人员指南》一书，作者
    Piero Giacomelli，出版社 Packt Publishing，该书深入探讨了框架的开发方面和 JMS 规范。
- en: Also, the jboss.org community has done a great job in providing us all with
    information about HornetQ, which is freely available at [http://hornetq.jboss.org](http://hornetq.jboss.org).
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，jboss.org 社区为我们所有人提供了关于 HornetQ 的信息，这些信息可在 [http://hornetq.jboss.org](http://hornetq.jboss.org)
    免费获取。
- en: Last, but not least, the JMS specification is available at [https://jcp.org/aboutJava/communityprocess/final/jsr343/index.html](https://jcp.org/aboutJava/communityprocess/final/jsr343/index.html).
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，JMS 规范可在 [https://jcp.org/aboutJava/communityprocess/final/jsr343/index.html](https://jcp.org/aboutJava/communityprocess/final/jsr343/index.html)
    获取。
