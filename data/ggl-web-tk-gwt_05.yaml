- en: Chapter 5. Responsive Complex Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。响应式复杂界面
- en: In this chapter, we will create user interfaces that demonstrate some advanced
    features of GWT.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一些演示GWT高级功能的用户界面。
- en: 'The tasks that we will address are:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要解决的任务是：
- en: Pageable tables
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可分页表格
- en: Editable tree nodes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可编辑的树节点
- en: Log spy
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志监视
- en: Sticky notes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 便利贴
- en: Jigsaw puzzle
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拼图游戏
- en: Pageable Tables
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可分页表格
- en: We are going to start exploring more complex GWT user interfaces in this chapter.
    We routinely come across some cases in today's business world where we need to
    use tables to display a large amount of data. Displaying all of the available
    data in a table at once is not a viable option, either from the point of view
    of usability or from a practical perspective.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始探索更复杂的GWT用户界面。在当今的商业世界中，我们经常遇到一些情况，需要使用表格来显示大量数据。一次性在表格中显示所有可用数据既不是一个可行的选项，从可用性的角度来看，也不是一个实际的选择。
- en: We can also potentially lock up the browser that is displaying the table, if
    the dataset retrieved is of a large enough size. A much better way to display
    this data to users would be to show them a fixed number of results first, and
    then provide them with the mechanism to navigate through the results; so that
    they can page back and forward through the data at their leisure. This makes for
    a nicer user experience, and also loads the smaller dataset much faster.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以潜在地锁定显示表格的浏览器，如果检索到的数据集足够大。向用户显示这些数据的更好方法是首先显示固定数量的结果，然后提供他们浏览结果的机制；这样他们可以自由地在数据中向前或向后翻页。这样做可以提供更好的用户体验，同时也可以更快地加载较小的数据集。
- en: In this section, we are going to create an application that provides this functionality.
    As a part of this sample, we are also going to learn how to use an embedded database
    with a GWT application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个提供此功能的应用程序。作为示例的一部分，我们还将学习如何在GWT应用程序中使用嵌入式数据库。
- en: Time for Action—Interfacing a Dataset
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行动时间——接口数据集
- en: 'We will create an application that will let us retrieve data in chunks or pages,
    instead of getting everything at once. We will do this by retrieving the first
    ten items as a result of a query, and provide a way for the user to either go
    forward or backward through this set of results. The steps are as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个应用程序，让我们以分块或分页的方式检索数据，而不是一次性获取所有数据。我们将通过查询检索前十个项目作为结果，并为用户提供一种方法，让他们可以在这些结果中向前或向后翻页。具体步骤如下：
- en: 'Create a new Java file named `PageableDataService.java` in the `com.packtpub.gwtbook.samples.client`
    package. Define the `PageableDataService` interface with one method to retrieve
    the customer data, by providing a start index and the number of items to retrieve
    as parameters:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`com.packtpub.gwtbook.samples.client`包中创建一个名为`PageableDataService.java`的新的Java文件。定义`PageableDataService`接口，其中包含一个方法，通过提供起始索引和要检索的项目数量来检索客户数据：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create the asynchronous version of this service definition interface in a new
    Java file named `PageableDataServiceAsync.java` in the `com.packtpub.gwtbook.samples.client`
    package:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`com.packtpub.gwtbook.samples.client`包中创建一个名为`PageableDataServiceAsync.java`的新的Java文件，创建这个服务定义接口的异步版本：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create the implementation of our pageable data service in a new Java file named
    `PageableDataServiceImpl.java` in the `com.packtpub.gwtbook.samples.server` package.
    Create a private `ArrayList` object named `customerData` that will be the container
    for the customer data:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`com.packtpub.gwtbook.samples.server`包中创建一个名为`PageableDataServiceImpl.java`的新的Java文件，实现我们的可分页数据服务。创建一个名为`customerData`的私有`ArrayList`对象，用于存储客户数据：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It will be simpler if we use a database for storing our data instead of managing
    data structures in our service. We are going to use HSQLDB—a small embedded database
    for storing the data that we will be accessing in this service. First, load the
    data from the pre-populated database into a list:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们使用数据库来存储数据而不是在服务中管理数据结构，将会更简单。我们将使用HSQLDB——一个用于存储我们将在此服务中访问的数据的小型嵌入式数据库。首先，从预先填充的数据库中加载数据到列表中：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We call the `loadData()` function in the constructor for the service, so that
    all the required data is loaded and is available after the service is initialized:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在服务的构造函数中调用`loadData()`函数，以便在服务初始化后加载所有所需的数据并可用：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now add the service-implementation method that will send back only the requested
    subset of the data:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加一个服务实现方法，只返回请求的数据子集：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now create the user interface for interacting with the pageable data service.
    Create a new Java file named `PageableDataPanel.java` in the `com.packtpub.gwtbook.samples.client.panels`
    package. As mentioned at the beginning of the previous chapter, each of the user
    interfaces created in this book will be added to a sample application that is
    similar to the `KitchenSink` application that is available as one of the sample
    projects with the GWT download. That is why we will create each user interface
    as a panel that extends the `SamplePanel` class, and we will add the created panel
    to the list of sample panels in the sample application. The `SamplePanel` class
    and the structure of our `Samples` application are discussed at the beginning
    of the previous chapter. Add a `FlexTable` class for displaying the data, along
    with buttons for paging *forward* and *backward* through the data. Create an array
    of strings to store the column headers, and an integer variable to store the start
    index into the customer data list:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建与可分页数据服务交互的用户界面。在`com.packtpub.gwtbook.samples.client.panels`包中创建一个名为`PageableDataPanel.java`的新的Java文件。正如在上一章开头提到的，本书中创建的每个用户界面都将被添加到一个类似于GWT下载中作为示例项目之一的`KitchenSink`应用程序的示例应用程序中。这就是为什么我们将每个用户界面创建为一个扩展`SamplePanel`类的面板，并将创建的面板添加到示例应用程序的示例面板列表中。`SamplePanel`类和我们的`Samples`应用程序的结构在上一章开头进行了讨论。添加一个`FlexTable`类来显示数据，以及用于向前或向后翻页的按钮。创建一个字符串数组来存储列标题，并创建一个整数变量来存储客户数据列表的起始索引：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create the service class that we will use for invoking the service to get the
    data:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们将用于调用服务以获取数据的服务类：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add a private method for clearing out the table before we populate it with
    data:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个私有方法，在我们用数据填充表格之前清空表格：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add a private method for updating the table with data retrieved from the service:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个私有方法，用于使用从服务检索的数据更新表格：
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the constructor for `PageableDataPanel`, create a `VerticalPanel` object
    that will be the container panel for this user interface, and initialize the table
    that will hold the customer data:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PageableDataPanel`的构造函数中，创建一个`VerticalPanel`对象，它将是这个用户界面的容器面板，并初始化将保存客户数据的表格：
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create an inner navigation bar that holds the back and forward buttons:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个内部导航栏，其中包含后退和前进按钮：
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add an event handler to listen for clicks on the back button to the constructor:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中添加一个事件处理程序，以便监听后退按钮的点击：
- en: '[PRE12]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add an event handler to listen for clicks on the forward button to the constructor:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中添加一个事件处理程序，以便监听前进按钮的点击：
- en: '[PRE13]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, in the constructor, add the customer data table and the navigation
    bar to the work panel. Create a little info panel that displays descriptive text
    about this application, so that we can display the text when this sample is selected
    in the list of available samples in our `Samples` application. Add the info panel
    and the work panel to a dock panel, and initialize the widget. Call the `update()`
    method, so that we can get the first batch of customer data and display it when
    the page is initially loaded:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在构造函数中，将客户数据表和导航栏添加到工作面板中。创建一个小的信息面板，显示关于此应用程序的描述性文本，这样当我们在`Samples`应用程序的可用样本列表中选择此样本时，我们可以显示文本。将信息面板和工作面板添加到一个停靠面板，并初始化小部件。调用`update()`方法，这样当页面最初加载时，我们可以获取第一批客户数据并显示它：
- en: '[PRE14]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the service to the module file for the `Samples` application—`Samples.gwt.xml`—in
    the `com.packtpub.gwtbook.samples` package:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将服务添加到`Samples`应用程序的模块文件`Samples.gwt.xml`中，位于`com.packtpub.gwtbook.samples`包中：
- en: '[PRE15]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here is the user interface for the application:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是应用程序的用户界面：
- en: '![Time for Action—Interfacing a Dataset](img/1007_05_01.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![Time for Action—Interfacing a Dataset](img/1007_05_01.jpg)'
- en: Click on the buttons to go either forward or backward in the list.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 单击按钮以向前或向后浏览列表。
- en: What Just Happened?
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We are using an embedded database (Hypersonic SQL—HSQLDB— [http://www.hsqldb.org](http://www.hsqldb.org))
    containing the customer data that we will page through, displaying only ten results
    at a time. All the components required to use this database are contained in the
    `hsqldb.jar` file. In order to use it in a GWT project, we need to ensure that
    the `hsqldb.jar` file is added to the `buildpath` for the Eclipse project. Then
    it will be available on the `classpath`, when you either run or debug the project.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用一个嵌入式数据库（Hypersonic SQL—HSQLDB—[http://www.hsqldb.org](http://www.hsqldb.org)），其中包含我们将浏览的客户数据，每次仅显示十个结果。使用此数据库所需的所有组件都包含在`hsqldb.jar`文件中。为了在GWT项目中使用它，我们需要确保将`hsqldb.jar`文件添加到Eclipse项目的`buildpath`中。然后当您运行或调试项目时，它将在`classpath`上可用。
- en: The in-memory version of HSQLDB is being used, which means that the database
    runs in the same Java Virtual Machine as our GWT application. After initializing
    the JDBC driver for HSQLDB, we get a connection to a database named `samplesdb`,
    by specifying the database file path. If this file does not exist, it will be
    created, and if it does exist, the database will be loaded by the database engine.
    The file path provided is relative to the directory from which this JVM was started;
    so in our case, the database file will be created in the root directory of our
    project.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HSQLDB的内存版本，这意味着数据库在与我们的GWT应用程序相同的Java虚拟机中运行。在初始化HSQLDB的JDBC驱动程序之后，我们通过指定数据库文件路径获得到名为`samplesdb`的数据库的连接。如果此文件不存在，它将被创建，如果存在，则数据库将被数据库引擎加载。提供的文件路径是相对于启动此JVM的目录的；所以在我们的情况下，数据库文件将被创建在我们项目的根目录中。
- en: '[PRE16]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The data from the customer table is retrieved and stored in a local `ArrayList`.
    This list data structure contains one `ArrayList` per row in the customers table.
    It will be used as the base for retrieving sets of information. Each request to
    retrieve customer data will provide a start index and the number of items to be
    retrieved. The start index tells us the offset into the `ArrayList`, while the
    number of items limits the results returned.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从客户表中检索数据并存储在本地的`ArrayList`中。这个列表数据结构包含客户表中每一行的一个`ArrayList`。它将被用作检索信息集的基础。每个检索客户数据的请求将提供一个起始索引和要检索的项目数。起始索引告诉我们在`ArrayList`中的偏移量，而项目数限制了返回的结果。
- en: The user interface for the application displays a table along with two buttons.
    The back button pages backward through the dataset, while the forward button lets
    us move forward through the list. When the page is loaded, an asynchronous call
    is made to the `PageableDataService` interface to get the first ten items and
    display them in the table. Event handlers are registered to listen for clicks
    on the two buttons. Clicking on either of the buttons triggers a call to the remote
    service to get the next set of items. We store the start index of the currently
    displayed table items in a private variable. This variable is decremented when
    we click on the back button, and incremented when we click on the forward button.
    It is provided as a parameter to the remote method when we request the next set
    of data. The result from the request is used to populate the table on the page.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的用户界面显示了一个表格和两个按钮。后退按钮通过数据集向后翻页，而前进按钮让我们向前移动列表。页面加载时，会异步调用`PageableDataService`接口，以获取前十个项目并在表格中显示它们。注册事件处理程序以监听两个按钮的点击。单击任一按钮都会触发调用远程服务以获取下一组项目。我们将当前显示的表格项目的起始索引存储在一个私有变量中。单击后退按钮时，该变量递减；单击前进按钮时，该变量递增。在请求下一组数据时，它作为参数提供给远程方法。来自请求的结果用于填充页面上的表格。
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We clear out the data in the table and then add new data by setting the text
    for each column.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们清除表中的数据，然后通过为每一列设置文本来添加新数据。
- en: Editable Tree Nodes
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可编辑的树节点
- en: Tree controls provide a very user-friendly way to display a set of hierarchical
    data—the common examples being the directory structure on your file system or
    the nodes in an XML document. GWT provides a tree widget that can display this
    data, but does not provide any way to modify the nodes of the tree itself. One
    of the most common uses of modifying a displayed node in a tree control is the
    renaming of files and folders in your file explorer, on your favorite platform.
    We are going to create an application that shows how to edit the displayed node
    in a tree by just clicking on it and typing in the new text. This sample also
    demonstrates how easy it is to extend GWT to make it do some of the things that
    are not provided out of the box.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 树控件提供了一种非常用户友好的方式来显示一组分层数据，常见的例子包括文件系统中的目录结构或者XML文档中的节点。GWT提供了一个可以显示这些数据的树形小部件，但是没有提供任何修改树节点本身的方法。修改树控件中显示的节点最常见的用途之一是重命名文件和文件夹，比如在您喜欢的平台上的文件资源管理器中。我们将创建一个应用程序，演示如何通过单击节点并输入新文本来编辑树中显示的节点。这个示例还演示了扩展GWT以使其执行一些默认情况下不提供的功能有多么容易。
- en: Time for Action—Modifying the Node
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行动时间——修改节点
- en: 'We will create an application that contains a tree that behaves similarly to
    the Windows file explorer, by allowing us to click on a node and edit the text
    for the node. The steps are as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个应用程序，其中包含一个树，其行为类似于Windows文件资源管理器，允许我们单击节点并编辑节点的文本。步骤如下：
- en: 'Create the user interface for this application in a new Java file named `EditableTreeNodesPanel.java`
    in the `com.packtpub.gwtbook.samples.client.panels` package. This class also extends
    the `SamplePanel` class like all the other user interfaces in this book. A `SamplePanel`
    class extends the `Composite` class, and is a simple way to create several user
    interfaces, and add each of them to our `Samples` application, so that we can
    display a list of all the applications in a manner similar to the `KitchenSink`
    sample project from the GWT distribution. We have described the sample application
    structure in a section at the beginning of[Chapter 4](ch04.html "Chapter 4. Interactive
    Forms"). Create a tree, a text box, and a label. Finally, create variables for
    the work panel and the work pane:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`com.packtpub.gwtbook.samples.client.panels`包中的一个名为`EditableTreeNodesPanel.java`的新Java文件中为此应用程序创建用户界面。这个类也像本书中的所有其他用户界面一样扩展了`SamplePanel`类。`SamplePanel`类扩展了`Composite`类，是创建多个用户界面并将它们添加到我们的`Samples`应用程序的简单方法，这样我们就可以以类似于GWT发行版中的`KitchenSink`示例项目的方式显示所有应用程序的列表。我们在[第4章](ch04.html
    "第4章. 交互式表单")的开头部分描述了示例应用程序的结构。创建一个树、一个文本框和一个标签。最后，创建工作面板和工作面板的变量：
- en: '[PRE18]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a private method that populates the tree with some nodes:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个私有方法，用一些节点填充树：
- en: '[PRE19]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the constructor for `EditableTreeNodesPanel`, initialize the tree and add
    an event handler for listening to clicks on the tree node:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`EditableTreeNodesPanel`的构造函数中，初始化树并添加一个事件处理程序，用于监听树节点上的单击事件：
- en: '[PRE20]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the constructor, create a little info panel that displays descriptive text
    about this application, so that we can display the text when this sample is selected
    in the list of available samples in our `Samples` application. Add the info panel
    and the work panel to the dock panel, and initialize the widget:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，创建一个小的信息面板，显示关于这个应用程序的描述性文本，这样当我们在`Samples`应用程序的可用示例列表中选择此示例时，就可以显示文本。将信息面板和工作面板添加到停靠面板，并初始化小部件：
- en: '[PRE21]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run the application:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序：
- en: '![Time for Action—Modifying the Node](img/1007_05_02.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间——修改节点](img/1007_05_02.jpg)'
- en: You can click on a tree node and change the text in the text box that is displayed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以单击树节点并更改显示的文本框中的文本。
- en: What Just Happened?
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'Tree controls are a nice way to visualize and explore hierarchical data. In
    this sample, we create a tree with ten nodes, each node containing a string value.
    We register an event handler that listens for selection events on the tree nodes.
    When a tree node is selected, we create a text box that contains the same text
    as the tree node, and position the text box over the tree node. The text box is
    positioned by retrieving the left and top coordinates for the tree node. The currently
    selected tree node is stored in a private variable. An event handler is registered
    to listen for focus events from the newly added text box. When the text box loses
    focus, we take the current text and modify the tree item value with it:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 树控件是可视化和探索分层数据的一种好方法。在这个示例中，我们创建了一个包含十个节点的树，每个节点包含一个字符串值。我们注册了一个事件处理程序，监听树节点的选择事件。当选择一个树节点时，我们创建一个包含与树节点相同文本的文本框，并将文本框定位在树节点上方。通过检索树节点的左侧和顶部坐标来定位文本框。当前选择的树节点存储在一个私有变量中。我们注册了一个事件处理程序，监听新添加的文本框的焦点事件。当文本框失去焦点时，我们获取当前文本并用它修改树节点的值：
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `isAttached()` function enables us to check if the sender widget is actually
    attached to the root panel, or if it has already been destroyed. We avoid setting
    anything on the widget if it is no longer attached to the panel. That's all! GWT
    makes it that simple to add support for inline editing of tree nodes. The current
    GWT release does not yet support adding widgets other than strings to the tree
    as a tree item. Once that support is available, it would be simple to refactor
    this example to use text boxes as tree nodes, and make them editable or non-editable
    based on the click event.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`isAttached()`函数使我们能够检查发送者小部件是否实际附加到根面板，或者是否已经被销毁。如果小部件不再附加到面板上，我们就避免对小部件进行任何设置。就是这样！GWT使得为树节点的内联编辑添加支持变得如此简单。当前的GWT版本尚不支持向树添加除字符串以外的小部件作为树节点。一旦支持可用，就可以简单地重构此示例以使用文本框作为树节点，并根据单击事件使它们可编辑或不可编辑。'
- en: Log Spy
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志监视器
- en: In this example, we will look how a server can be polled, based on a time interval
    set by the client. This will involve using the GWT Timer object, and is very useful
    for situations where you need to perform an action on the server, based on a repeating
    time interval, and then asynchronously update a section of the web page with the
    results of the action. We will create a simple application that can monitor and
    display the contents of a log file in real time.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将看到如何基于客户端设置的时间间隔轮询服务器。这将涉及使用GWT计时器对象，对于需要根据重复的时间间隔在服务器上执行操作，然后异步更新网页部分以显示操作结果的情况非常有用。我们将创建一个简单的应用程序，可以实时监视和显示日志文件的内容。
- en: Time for Action—Updating a Log File
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行动时间-更新日志文件
- en: 'Almost every application has log files that contain debugging information.
    This information is usually read by logging in to a server, navigating to a folder
    containing the log file, and then opening the file in a text editor to actually
    view the contents. This is a tedious way of checking log files. The better and
    more user-friendly way is to use GWT to create an application that can display
    the contents of the log file in a web page. The contents are updated in real time,
    as messages are added to the log file. The following steps will give us the desired
    result:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个应用程序都有包含调试信息的日志文件。通常通过登录服务器，导航到包含日志文件的文件夹，然后在文本编辑器中打开文件来查看内容。这是检查日志文件的繁琐方式。更好、更用户友好的方式是使用GWT创建一个可以在网页中显示日志文件内容的应用程序。随着消息被添加到日志文件中，内容将实时更新。以下步骤将给我们带来期望的结果：
- en: 'Create a new Java file named `LogSpyService.java` in the `com.packtpub.gwtbook.samples.client`
    package. Define a `LogSpyService` interface with two methods—one method for retrieving
    all log entries and one method for retrieving only the new entries:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`com.packtpub.gwtbook.samples.client`包中创建一个新的Java文件`LogSpyService.java`。定义一个`LogSpyService`接口，其中包含两个方法——一个用于检索所有日志条目，一个用于仅检索新条目：
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create the asynchronous version of this service definition interface in a new
    Java file named `LogSpyServiceAsync.java` in the `com.packtpub.gwtbook.samples.client`
    package:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`com.packtpub.gwtbook.samples.client`包中的新的Java文件`LogSpyServiceAsync.java`中创建此服务定义接口的异步版本：
- en: '[PRE24]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create the implementation of the log spy service in a new Java file named `LogSpyServiceImpl.java`
    in the `com.packtpub.gwtbook.samples.server` package. First create a private method
    for reading a log file, a variable for holding the file pointer, and a variable
    with the name of the log file that you want to read:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`com.packtpub.gwtbook.samples.server`包中的新的Java文件`LogSpyServiceImpl.java`中创建日志监视服务的实现。首先创建一个用于读取日志文件的私有方法，一个用于保存文件指针的变量，以及一个包含要读取的日志文件的名称的变量：
- en: '[PRE25]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add the two methods that implement the service interface:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加实现服务接口的两个方法：
- en: '[PRE26]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now create the user interface for interacting with the log spy service. Create
    a new Java file named `LogSpyPanel.java` in the `com.packtpub.gwtbook.samples.client.panels`
    package. Create variables for the work panel, a text box for setting the monitoring
    interval, a label, and **Start** and **Stop** buttons. We will also need a Boolean
    flag to indicate the current status of monitoring.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在为与日志监视服务交互创建用户界面。在`com.packtpub.gwtbook.samples.client.panels`包中创建一个新的Java文件`LogSpyPanel.java`。创建工作面板的变量、用于设置监视间隔的文本框、一个标签和**开始**和**停止**按钮。我们还需要一个布尔标志来指示当前的监视状态。
- en: '[PRE27]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create panels that will contain the **Start** and **Stop** buttons, the text
    box and the label for the monitoring interval, and a timer:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建包含**开始**和**停止**按钮、文本框和监视间隔标签的面板，以及一个计时器：
- en: '[PRE28]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create a listbox for displaying the log messages, and the service interface
    that we will be invoking to get the log entries:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个列表框来显示日志消息，并且我们将调用的服务接口来获取日志条目：
- en: '[PRE29]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the constructor, set the initial value of the monitoring interval text box
    to 1000, and disable the **Stop** button:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，将监视间隔文本框的初始值设置为1000，并禁用**停止**按钮：
- en: '[PRE30]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Set the styles for the panels, the text box, and the label:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为面板、文本框和标签设置样式：
- en: '[PRE31]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add an event handler to listen for clicks on the **Start** button, and invoke
    the log spy service from the handler:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个事件处理程序来监听**开始**按钮的点击，并从处理程序调用日志监视服务：
- en: '[PRE32]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add an event handler to listen for clicks on the **Stop** button and stop monitoring:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个事件处理程序来监听**停止**按钮的点击，并停止监视：
- en: '[PRE33]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Limit the number of visible items in the list to eight items:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将列表中可见项的数量限制为八项：
- en: '[PRE34]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, in the constructor, create a little info panel that displays descriptive
    text about this application, so that we can display this text when this sample
    is selected in the list of available samples, in our `Samples` application. Add
    the monitoring interval panel and the start-stop buttons panel to the work panel.
    Add the info panel and the work panel to the dock panel, and initialize the widget:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在构造函数中，创建一个小的信息面板，显示有关此应用程序的描述性文本，以便在`Samples`应用程序的可用样本列表中选择此样本时显示此文本。将监视间隔面板和开始-停止按钮面板添加到工作面板。将信息面板和工作面板添加到停靠面板，并初始化小部件：
- en: '[PRE35]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add the service to the module file for the `Samples` application—`Samples.gwt.xml`
    in the `com.packtpub.gwtbook.samples` package:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将服务添加到`Samples`应用程序的模块文件`Samples.gwt.xml`中，位于`com.packtpub.gwtbook.samples`包中：
- en: '[PRE36]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here is a screenshot of the application that displays the entries in the log
    file—`test.log:`
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是显示日志文件条目的应用程序的屏幕截图-`test.log:`
- en: '![Time for Action—Updating a Log File](img/1007_05_03.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间-更新日志文件](img/1007_05_03.jpg)'
- en: As entries are added to this file, they will be added in real time to the list,
    with the first item in the list being the latest log entry. You can monitor any
    file that you want. Just change the value of the `logFile` variable in the `LogSpyServiceImpl`
    class to contain the requisite file name.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当条目被添加到此文件时，它们将实时添加到列表中，列表中的第一项将是最新的日志条目。您可以监视任何文件。只需更改`LogSpyServiceImpl`类中的`logFile`变量的值，以包含所需的文件名。
- en: What Just Happened?
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: Log files are usually just text files that have messages appended to them, as
    applications write to the log file. This sample is using a simple log file and
    can be modified to use any file that you want to monitor. We read the file using
    a `RandomAccessFile` class so that we can access only the sections of the file
    that we want, without needing to read the whole file into memory every time. A
    private variable that contains the last file pointer is stored in the class. This
    pointer is a cursor into the file. We have a method `readLogFile()` that accesses
    the file and reads only the data from the file pointer to the end of the file.
    Every time the file is read, the pointer is updated to store the last read position.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 日志文件通常只是文本文件，其中应用程序将消息附加到其中。此示例使用简单的日志文件，并可以修改为使用要监视的任何文件。我们使用`RandomAccessFile`类读取文件，以便每次只访问我们想要的文件部分，而无需每次将整个文件读入内存。类中存储了一个包含最后文件指针的私有变量。该指针是文件中的光标。我们有一个`readLogFile()`方法，用于访问文件并仅从文件指针到文件末尾读取数据。每次读取文件时，指针都会更新以存储最后读取的位置。
- en: '[PRE37]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If the file has not been modified since we last read it, we return an empty
    list without trying to read the file. Whenever the client makes a request to get
    the new log entries, we read the file and return the new entries.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果自上次读取文件以来文件未被修改，则返回一个空列表，而不尝试读取文件。每当客户端发出请求以获取新的日志条目时，我们读取文件并返回新的条目。
- en: 'The user interface consists of a list box, a text box that can be used to specify
    how often you want to monitor the log file, and buttons for starting and stopping
    the monitoring of the file. When the **Start** button is clicked, we start a timer
    that is scheduled to go off after the provided time interval. Every time the timer
    goes off, we make a request to get the log entries, and then in the `onSuccess()`
    callback method we add the returned entries to the listbox. We insert the log
    entry to the list and then set the last added entry as the selected item, so it
    visually indicates the latest item in the list:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面包括一个列表框，一个文本框，用于指定监视日志文件的频率，以及用于启动和停止文件监视的按钮。当点击**开始**按钮时，我们启动一个定时器，计划在提供的时间间隔后触发。每次定时器触发时，我们发出请求以获取日志条目，然后在`onSuccess()`回调方法中将返回的条目添加到列表框中。我们将日志条目插入列表中，然后将最后添加的条目设置为选定项，以在列表中视觉上表示最新的条目：
- en: '[PRE38]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If we click the **Stop** button, the timer is canceled, and the monitoring is
    halted. We do something very different here, compared to all the other samples.
    We call the service on a repeating time interval based on the time interval set
    by the user in the text box. So we make an asynchronous request every time the
    timer goes off. This technique can be used to do some very useful things for updating
    portions or sections of a page on a scheduled time interval by making synchronous
    calls to the server to get fresh information.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果点击**停止**按钮，则定时器被取消，监视被停止。与所有其他示例相比，我们在这里做了一些非常不同的事情。我们根据用户在文本框中设置的时间间隔，基于重复的时间间隔调用服务。因此，每次定时器触发时，我们都会进行异步请求。这种技术可用于通过定期向服务器发出同步调用来更新页面的部分或部分，以获取新的信息。
- en: Sticky Notes
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 便签
- en: The **Document Object Model** (**DOM**) describes the structure of an HTML document
    in the form of a tree structure that can be accessed using a language such as
    JavaScript. All the modern web browsers facilitate the access to a loaded web
    page through DOM scripting. GWT provides a rich set of methods that enable you
    to manipulate the DOM of a web page. We can even intercept and preview DOM events.
    We are going to learn how to use the GWT DOM methods and dialog boxes, leverage
    them to provide the ability to create sticky notes similar to the ubiquitous post-it
    notes, and drag them around to place them anywhere in the browser window.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**文档对象模型**（**DOM**）以树结构的形式描述HTML文档的结构，可以使用诸如JavaScript之类的语言进行访问。所有现代的Web浏览器都通过DOM脚本访问加载的网页。GWT提供了丰富的方法集，使您能够操作Web页面的DOM。我们甚至可以拦截和预览DOM事件。我们将学习如何使用GWT
    DOM方法和对话框，利用它们提供创建类似于无处不在的便条便签的能力，并将它们拖动到浏览器窗口的任何位置。'
- en: Time for Action—Playing with Sticky Notes
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行动时间-玩转便签
- en: 'We will create sticky notes that can be moved around in your browser window
    and placed anywhere. The steps are as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建可以在浏览器窗口中移动并放置在任何位置的便签。步骤如下：
- en: 'Create a new Java file named `StickyNotesPanel.java` in the `com.packtpub.gwtbook.samples.client.panels`
    package. Create a work panel, a button for creating the note, a text box for the
    name of the note, and variables to hold the x and y coordinates of the note. Also
    create an integer variable to hold the amount by which the coordinates of a new
    note are to be incremented:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`com.packtpub.gwtbook.samples.client.panels`包中创建一个名为`StickyNotesPanel.java`的新的Java文件。创建一个工作面板，一个用于创建便签的按钮，一个用于便签名称的文本框，以及用于保存便签的x和y坐标的变量。还创建一个整数变量，用于保存新便签坐标的增量：
- en: '[PRE39]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create a new class named `StickyNote` that extends `DialogBox`. In the constructor
    for this class, set the title for the note if provided, and add a text area that
    will be used to type in the actual note:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`StickyNote`的新类，该类扩展`DialogBox`。在这个类的构造函数中，如果提供了便签标题，则设置便签的标题，并添加一个文本区域，用于输入实际的便签内容：
- en: '[PRE40]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create a method in the `StickyNote` class that intercepts the DOM events:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`StickyNote`类中创建一个拦截DOM事件的方法：
- en: '[PRE41]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the constructor for the `StickyNotesPanel` class, create a little info panel
    that displays descriptive text about this application, so that we can display
    the text when this sample is selected in the list of available samples in our
    `Samples` application. Add this class as a listener to click events on the **Create
    Note** button. Add the button for creating the note along with the title text
    box to the work panel. Add the info panel and the work panel to the dock panel,
    and initialize the widget:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`StickyNotesPanel`类的构造函数中，创建一个小的信息面板，显示有关此应用程序的描述性文本，以便在我们的`Samples`应用程序中的可用示例列表中选择此示例时显示文本。将此类作为**Create
    Note**按钮上点击事件的监听器添加。将用于创建便利贴的按钮以及标题文本框添加到工作面板。将信息面板和工作面板添加到停靠面板，并初始化小部件：
- en: '[PRE42]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Make the `StickyNotesPanel` class implement the `ClickListener` interface,
    and add code to the `onClick()` method to create a new note when the **Create
    Note** button is clicked:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使`StickyNotesPanel`类实现`ClickListener`接口，并在`onClick()`方法中添加代码，以在单击**Create Note**按钮时创建一个新的便利贴：
- en: '[PRE43]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here is a screenshot of the application:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是应用程序的屏幕截图：
- en: '![Time for Action—Playing with Sticky Notes](img/1007_05_04.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间-玩转便利贴](img/1007_05_04.jpg)'
- en: When you create several notes, you can drag the notes around and place them
    anywhere on the browser window.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建多个便利贴时，您可以拖动便利贴并将它们放在浏览器窗口的任何位置。
- en: What Just Happened?
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: This sample demonstrates the ease with which you can generate some really cool
    interfaces and applications using GWT. The sticky notes application creates notes
    on your screen that you can drag around inside the web browser and place anywhere
    you want. The user interface contains a text box for typing in the name of the
    note, and a button for creating a new note with the provided name. If no name
    is provided, it is created with a default name **New Note**.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例演示了使用GWT可以生成一些非常酷的界面和应用程序的简易性。便利贴应用程序在屏幕上创建便利贴，您可以在Web浏览器内拖动它们并将它们放在任何位置。用户界面包含一个文本框，用于输入便利贴的名称，以及一个按钮，用于使用提供的名称创建一个新的便利贴。如果没有提供名称，则将创建一个默认名称**New
    Note**。
- en: The note itself is a subclass of `DialogBox`. It has a title and a text area
    for typing in the note. A `DialogBox` class inherits from a `PopupPanel` class,
    and implements the `EventPreview` interface. We implement the `onEventPreview()`
    method, as given in step 3, from this interface, so that we can preview all the
    browser events first, before they are sent to their targets. That essentially
    means that our sticky notes panel sits at the top of the browser event preview
    stack.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 便利贴本身是`DialogBox`的子类。它有一个标题和一个用于输入便利贴的文本区域。`DialogBox`类继承自`PopupPanel`类，并实现了`EventPreview`接口。我们实现了来自该接口的`onEventPreview()`方法，如步骤3中所述，以便我们可以首先预览所有浏览器事件，然后再将它们发送到它们的目标。这基本上意味着我们的便利贴面板位于浏览器事件预览堆栈的顶部。
- en: We preview the keyboard events and then pass them on, down to the target. This
    enables us to take a dialog box that is modal, and introduce non-modal behavior
    to it. If we do not do this, once we create the first note, the note will be modal,
    and will not allow us to create another note by clicking on the **Create** button,
    unless we close the note first.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们预览键盘事件，然后将其传递到目标。这使我们能够将模态对话框引入非模态行为。如果我们不这样做，一旦创建第一个便利贴，便利贴将是模态的，并且除非我们首先关闭便利贴，否则不允许我们通过单击**Create**按钮创建另一个便利贴。
- en: Now the note passes on the events after previewing them to the underlying panel,
    and we can create as many notes as we want. An event handler is registered to
    listen for clicks on the **Create Note** button. When the button is clicked, a
    new note is created and we set its position relative to the browser window, and
    then show it. We maintain a private variable that contains the left position of
    the last created note, so that we can stagger the position of the notes as we
    create them, as we have done in step 5\. This arranges the notes nicely on the
    screen so that the notes do not cover each other.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，便利贴在预览事件后将事件传递给底层面板，我们可以创建任意数量的便利贴。已注册事件处理程序以侦听单击**Create Note**按钮。单击按钮时，将创建一个新的便利贴，并将其位置设置为相对于浏览器窗口，然后显示它。我们保持一个包含上一个创建的便利贴的左侧位置的私有变量，以便我们可以在创建它们时交错地放置便利贴的位置，就像我们在步骤5中所做的那样。这样可以很好地在屏幕上排列便利贴，以便便利贴不会相互覆盖。
- en: As our notes inherit from `DialogBox`, they are draggable; we can drag them
    around the screen, and position them anywhere we want!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的便利贴继承自`DialogBox`，因此它们是可拖动的；我们可以将它们拖动到屏幕上的任何位置！
- en: Jigsaw Puzzle
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拼图
- en: The previous sample demonstrated some of the dragging capabilities and DOM event
    previewing in GWT. In this example, we are going to use the same DOM methods but
    a different way to intercept or preview the DOM events. We will also demonstrate
    some of the absolute positioning capabilities in GWT by using `AbsolutePanel`.
    We will be creating a simple Mona Lisa puzzle that can be solved by dragging and
    rearranging the pieces of the puzzle.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个示例演示了GWT中的一些拖动功能和DOM事件预览。在这个示例中，我们将使用相同的DOM方法，但以不同的方式拦截或预览DOM事件。我们还将通过使用`AbsolutePanel`来演示GWT中的一些绝对定位功能。我们将创建一个简单的蒙娜丽莎拼图，可以通过拖动和重新排列拼图块来解决。
- en: Time for Action—Let's Create a Puzzle!
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行动时间-让我们创建一个拼图！
- en: 'We will create a simple jigsaw puzzle, whose pieces were created by dividing
    a Mona Lisa image into nine pieces. The steps are as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的拼图，其拼图块是通过将蒙娜丽莎图像分成九个部分而创建的。步骤如下：
- en: 'Create a new Java file named `JigsawPuzzlePanel.java` in the `com.packtpub.gwtbook.samples.client.panels`
    package that implements the `MouseListener` interface. Create an `AbsolutePanel`
    class that will be the main panel to which all the widgets will be added. Also
    add two variables to store the `x` and `y` positions of the mouse cursor:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`com.packtpub.gwtbook.samples.client.panels`包中创建一个名为`JigsawPuzzlePanel.java`的新Java文件，该文件实现`MouseListener`接口。创建一个`AbsolutePanel`类，它将是将添加所有小部件的主面板。还添加两个变量来存储鼠标光标的`x`和`y`位置：
- en: '[PRE44]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the constructor for `JigsawPuzzlePanel`, add the Mona Lisa images to the
    panel, and add the panel as a listener for mouse events from the images:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`JigsawPuzzlePanel`的构造函数中，将蒙娜丽莎的图像添加到面板，并将面板添加为图像的事件监听器：
- en: '[PRE45]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Register to intercept the DOM mouse events in the constructor:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中注册拦截DOM鼠标事件：
- en: '[PRE46]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Implement the method to listen for mouse down events in the constructor:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中实现监听鼠标按下事件的方法：
- en: '[PRE47]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Implement the method to listen for mouse move events in the constructor:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中实现监听鼠标移动事件的方法：
- en: '[PRE48]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Implement the method to listen for mouse up events in the constructor:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中实现监听鼠标抬起事件的方法：
- en: '[PRE49]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally in the constructor, create a little info panel that displays descriptive
    text about this application, so that we can display the text when this sample
    is selected in the list of available samples in our `Samples` application. Add
    the info panel and the work panel to the dock panel, and initialize the widget:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在构造函数中，创建一个小的信息面板，显示关于此应用程序的描述性文本，以便在我们的`Samples`应用程序的可用示例列表中选择此示例时显示文本。将信息面板和工作面板添加到停靠面板，并初始化小部件：
- en: '[PRE50]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here is the puzzle when you first visit the page:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你第一次访问页面时的谜题：
- en: '![Time for Action—Let''s Create a Puzzle!](img/1007_05_05.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间-让我们创建一个谜题！](img/1007_05_05.jpg)'
- en: 'Here is the solved puzzle:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这是已解决的谜题：
- en: '![Time for Action—Let''s Create a Puzzle!](img/1007_05_06.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间-让我们创建一个谜题！](img/1007_05_06.jpg)'
- en: What Just Happened?
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: This sample demonstrates the absolute positioning capabilities in GWT. An image
    file of the Mona Lisa was split into nine equal-sized images. We jumble the images
    and present them on the screen in a 3x3 square, when the application is rendered.
    The user can then rearrange the image pieces by dragging them around and repositioning
    them on the screen to recreate the Mona Lisa.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例演示了GWT中的绝对定位功能。蒙娜丽莎的图像文件被分成九个大小相等的图像。我们混淆这些图像，并在应用程序呈现时在屏幕上以3x3的方形呈现它们。用户可以通过拖动它们并重新定位它们在屏幕上来重新创建蒙娜丽莎的图像。
- en: We use an `AbsolutePanel` class as our work panel in this sample. It has the
    ability to position all of its child widgets absolutely, and even allows the widgets
    to overlap. We add the nine images to the panel by positioning them absolutely,
    so they form a nice 3x3 grid.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用`AbsolutePanel`类作为我们的工作面板。它具有绝对定位其所有子部件的能力，甚至允许部件重叠。我们通过绝对定位将九个图像添加到面板中，使它们形成一个漂亮的3x3网格。
- en: 'Here is one column of the grid:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是网格的一列：
- en: '[PRE51]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the previous example, we were able to implement the `onEventpreview()` method
    to preview the browser events first before they are sent to their target. We were
    able to do this as the note was a subclass of `PopupPanel`, which provides this
    ability. But in the current sample we are not using a pop-up panel. So we use
    another method to add ourselves to the top of the event preview stack. This time
    we are using the `addEvetnpreview()` method in the DOM object, as illustrated
    in step 3.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们能够实现`onEventpreview()`方法来预览浏览器事件，然后再发送到它们的目标。我们之所以能够做到这一点，是因为该注释是`PopupPanel`的子类，它提供了这种能力。但在当前示例中，我们没有使用弹出面板。因此，我们使用另一种方法将自己添加到事件预览堆栈的顶部。这次我们使用DOM对象中的`addEvetnpreview()`方法，如步骤3所示。
- en: In step 4, we implement the `MouseListener` interface and register ourselves
    as the event handler for mouse events in the panel. When the user clicks on an
    image prior to dragging it, we get the element that was clicked and set it as
    the mouse-capture. This ensures that element will receive all of the mouse events,
    until it is released from the mouse-capture. We store the `x` and `y` coordinates
    of the element in a private variable. We also set a flag that tells us that we
    are currently in the mode of dragging an element.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步中，我们实现了`MouseListener`接口，并在面板中注册自己作为鼠标事件的事件处理程序。当用户在拖动图像之前单击图像时，我们获取被单击的元素并将其设置为鼠标捕获。这确保元素将接收所有鼠标事件，直到它从鼠标捕获中释放。我们将元素的`x`和`y`坐标存储在一个私有变量中。我们还设置了一个标志，告诉我们当前处于拖动元素的模式。
- en: Once the user starts dragging an image, we check to see if we are in drag mode,
    and we set the position of the widget, which will move the widget to the new position.
    You can only set the absolute widget position by calling the absolute panel that
    contains the widget; so we have to get the parent object of the image and then
    cast it to the right class. We have covered all this in step 5.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户开始拖动图像，我们检查是否处于拖动模式，并设置小部件的位置，这将使小部件移动到新位置。您只能通过调用包含小部件的绝对面板来设置绝对小部件位置；因此，我们必须获取图像的父对象，然后将其转换为正确的类。我们在第5步中已经涵盖了所有这些内容。
- en: When the user has finished dragging an image to a position and releasing the
    mouse, we release the element from the mouse-capture and set the drag flag to
    false, as in step 6.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户完成将图像拖动到位置并释放鼠标时，我们将元素从鼠标捕获中释放，并将拖动标志设置为false，如第6步所示。
- en: The absolute positioning support in GWT still needs some work, and can act quite
    different in Firefox and Internet Explorer, and their multiple versions.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: GWT中的绝对定位支持仍然需要一些工作，并且在Firefox和Internet Explorer以及它们的多个版本中可能表现出不同的行为。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to create tables that can page through a set
    of data in a user-friendly manner, and extended a tree widget to add simple support
    for editing the tree nodes in place. We utilized the `timer` object to create
    a log spy application that monitors a given log file for new entries, and displays
    them in a list that is updated in real time.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何创建可以友好地浏览一组数据的表格，并扩展了树部件以添加对树节点进行简单编辑的支持。我们利用`timer`对象创建了一个日志监视应用程序，用于监视给定日志文件的新条目，并实时显示在更新的列表中。
- en: We learned how to use some of the DOM methods and the DOM event preview capability
    in GWT, and leveraged it to implement a draggable sticky notes application. We
    also learned how to make dialog boxes non-modal, so that we can adapt them for
    our use. Finally, utilizing the absolute positioning functionality and an alternate
    method of previewing DOM events, we created a puzzle application.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何在GWT中使用一些DOM方法和DOM事件预览功能，并利用它来实现可拖动的便签应用程序。我们还学会了如何使对话框框非模态，以便我们可以自适应它们的使用。最后，利用绝对定位功能和另一种预览DOM事件的方法，我们创建了一个拼图应用程序。
- en: In the next chapter, we will learn how to integrate third-party JavaScript libraries
    with GWT using the JavaScript Native Interface.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用JavaScript本地接口将第三方JavaScript库与GWT集成。
