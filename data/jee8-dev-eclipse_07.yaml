- en: Creating Web Applications with Spring MVC
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring MVC创建Web应用程序
- en: In the last chapter, we learned how to create JEE applications using EJBs. In
    this chapter, we are going to divert a bit from the core JEE specifications and
    learn Spring MVC.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用EJBs创建JEE应用程序。在这一章中，我们将稍微偏离核心JEE规范，学习Spring MVC。
- en: Although this book is about JEE and Eclipse, and Spring MVC is not a part of
    JEE, it would be worthwhile to understand the Spring MVC framework. Spring MVC
    is a very popular framework for creating web applications and can be used with
    other JEE technologies, such as servlet, JSP, JPA, and EJBs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这本书是关于JEE和Eclipse的，Spring MVC不是JEE的一部分，但了解Spring MVC框架是值得的。Spring MVC是一个非常流行的用于创建Web应用的框架，并且可以与其他JEE技术（如servlet、JSP、JPA和EJBs）一起使用。
- en: JEE does support MVC out of the box, if you use JSF. Refer to *Java Server Faces*
    in [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating
    a Simple JEE Web Application*, for details. However, there is a difference in
    the design of JSF and Spring MVC. JSF is a component-based MVC framework. It is
    designed so that the user interface designer can create pages by assembling reusable
    components that are either provided by JSF or custom-developed. Spring MVC is
    a request-response-based MVC framework. If you are familiar with writing JSP or
    servlets, then Spring MVC would be an easier framework to use than JSF. You can
    find a good description of component-based MVC (as implemented by JSF) and request-response-based
    MVC (as implemented by Spring MVC) by Ed Burns at [http://www.oracle.com/technetwork/articles/java/mvc-2280472.html](http://www.oracle.com/technetwork/articles/java/mvc-2280472.html).
    JSR 371 for MVC was supposed to be part of JEE 8, but this JSR was later withdrawn
    from JEE 8 specifications. You can find more information about JSR 371 (also called
    MVC 1.0) at [https://www.mvc-spec.org/](https://www.mvc-spec.org/).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: JEE默认支持MVC，如果你使用JSF。有关详细信息，请参阅[第2章](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)中的*Java服务器端面*，*创建一个简单的JEE
    Web应用程序*。然而，JSF和Spring MVC的设计有所不同。JSF是一个基于组件的MVC框架。它被设计成用户界面设计师可以通过组装由JSF提供或自定义开发的可重用组件来创建页面。Spring
    MVC是一个基于请求-响应的MVC框架。如果你熟悉编写JSP或servlet，那么Spring MVC将比JSF更容易使用。你可以在Ed Burns的[http://www.oracle.com/technetwork/articles/java/mvc-2280472.html](http://www.oracle.com/technetwork/articles/java/mvc-2280472.html)上找到关于基于组件的MVC（由JSF实现）和基于请求-响应的MVC（由Spring
    MVC实现）的良好描述。MVC的JSR 371原本应该是JEE 8的一部分，但这个JSR后来从JEE 8规范中撤回。你可以在[https://www.mvc-spec.org/](https://www.mvc-spec.org/)上找到更多关于JSR
    371（也称为MVC 1.0）的信息。
- en: 'Before we see how Spring MVC works, we need to understand what the MVC framework
    is. **MVC** stands for **Model-View-Controller**. We are going to refer to the
    MVC framework in the context of Java web applications only, although it should
    be mentioned here that the MVC pattern is often used in desktop applications too:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们了解Spring MVC是如何工作之前，我们需要了解MVC框架是什么。**MVC**代表**模型-视图-控制器**。我们将在Java Web应用程序的上下文中引用MVC框架，尽管应该在这里提到，MVC模式也常用于桌面应用程序：
- en: '**Model**: The Model contains data that is used by the View to create the output.
    In the example that we have been following in this book, the *Course Management*
    application, if you have a `Course` class that contains information about the
    course to be displayed on a page, then the `Course` object can be called the Model.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：模型包含视图用于创建输出的数据。在我们这本书中跟随的示例中，*课程管理*应用程序，如果你有一个包含要在页面上显示的课程信息的`Course`类，那么这个`Course`对象可以被称为模型。'
- en: Some definitions of MVC also include classes that implement business logic in
    the Model layer. For example, a `CourseService` class that takes a `Course` object
    and calls `CourseDAO` to save the `Course` in the database could also be considered
    a part of the Model layer.
  id: totrans-6
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: MVC的一些定义也包括在模型层实现业务逻辑的类。例如，一个`CourseService`类，它接受一个`Course`对象并调用`CourseDAO`将`Course`保存到数据库中，也可以被认为是模型层的一部分。
- en: '**View**: The View is a page that is displayed to the user. A JSP that displays
    a list of courses could be considered a part of the View layer. The View holds
    a reference to the Model object and uses the data it contains to create the page
    that the user sees in the browser.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：视图是显示给用户的页面。一个显示课程列表的JSP可以被认为是视图层的一部分。视图持有模型对象的引用，并使用它包含的数据来创建用户在浏览器中看到的页面。'
- en: '**Controller:** The Controller is the glue between Model and View. It handles
    requests/actions from the web client (for example, the browser), calls the Model
    to handle business logic, and makes Model objects available to the View to create
    the page (user interface) to be returned to the client. The Controller could be
    a servlet, as in the case of JSF, or could be POJOs (as in the case of Spring
    MVC). When Controllers are POJOs, typically they get called by `DispatcherServlet`.
    `DispatherServlet` is a servlet that receives the request and dispatches it to
    one of the Controllers, based on the configuration. We will see example of this
    later in the chapter.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：控制器是模型和视图之间的粘合剂。它处理来自网络客户端（例如，浏览器）的请求/操作，调用模型来处理业务逻辑，并将模型对象提供给视图以创建要返回给客户端的页面（用户界面）。控制器可以是servlet，如JSF的情况，或者可以是POJO（如Spring
    MVC的情况）。当控制器是POJO时，通常由`DispatcherServlet`调用。`DispatcherServlet`是一个接收请求并将其调度到配置中的一个控制器上的servlet。我们将在本章后面看到这个示例。'
- en: MVC provides separation of concerns; that is, the code for the user interface
    and the business logic are separate. Because of this, the UI and the business
    layer can be modified independently to a great extent. Of course, since the UI
    usually displays the data generated by the business layer, it may not always be
    possible to make changes to each of the layers independent of the others. Developers
    of appropriate skills can work on each layer independently. A UI expert need not
    be too worried about how the business layer is implemented and vice versa.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: MVC提供了关注点的分离；也就是说，用户界面和业务逻辑的代码是分开的。正因为如此，UI和业务层可以很大程度上独立地进行修改。当然，由于UI通常显示由业务层生成的数据，因此可能并不总是能够独立于其他层对每一层进行修改。具备适当技能的开发者可以独立地对每一层进行工作。UI专家无需过分担心业务层的实现方式，反之亦然。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introduction to Spring dependency injection
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring依赖注入简介
- en: Configuring Spring beans and injecting them into the application
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Spring Bean并将它们注入到应用程序中
- en: Creating Spring MVC applications using the Eclipse plugin and JEE specifications
    such as JDBC, JPA, and JSP
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Eclipse插件和JEE规范（如JDBC、JPA和JSP）创建Spring MVC应用程序
- en: Dependency injection
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: Spring MVC is a part of the overall Spring Framework. The core feature of the
    Spring Framework is **dependency injection** (**DI**). Almost all other features
    of the Spring Framework use DI. Objects managed by the dependency injection framework
    are not directly instantiated in the code (using, for example, the `new` operator).
    Let's call them *managed objects*. These objects are created by a DI framework,
    such as Spring. Because these objects are created by a framework, the framework
    has a lot more flexibility in deciding how to set values in the object and from
    where to get them. For example, your **Data Access Object** (**DAO**) class might
    need an instance of a database connection factory object. However, instead of
    instantiating it in the DAO class, you just tell the DI framework that when it
    instantiates the DAO, it has to set the value of a member variable for the connection
    pool factory. Of course, the parameters for the connection pool factory will have
    to be configured somewhere and be known to the DI framework.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC是Spring框架整体的一部分。Spring框架的核心特性是**依赖注入**（**DI**）。Spring框架的几乎所有其他特性都使用了DI。由依赖注入框架管理的对象不是直接在代码中实例化的（例如，使用`new`运算符）。我们可以称它们为*管理对象*。这些对象是由DI框架（如Spring）创建的。因为这些对象是由框架创建的，所以框架在决定如何设置对象中的值以及从哪里获取它们方面具有更多的灵活性。例如，你的**数据访问对象**（**DAO**）类可能需要一个数据库连接工厂对象的实例。然而，你不需要在DAO类中实例化它，你只需告诉DI框架，当它实例化DAO时，它必须设置连接池工厂成员变量的值。当然，连接池工厂的参数必须在某处进行配置，并且为DI框架所知。
- en: When a class instantiates another class, there is tight dependency between them.
    Such design could be a problem if you want to test classes independently of others.
    For example, you may want to test a class that has business logic, but one that
    also refers to a DAO, which in turn depends on a JDBC connection object. When
    testing the first class, you will have to instantiate the DAO and configure the
    connection pool. As we saw in [Chapter 5](part0108.html#36VSO0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Unit Testing*, unit tests should be able to run without any external dependencies.
    One way to achieve this is by using DI. Instead of instantiating the DAO class,
    our class could refer to an interface that is implemented by the DAO and have
    the DI framework inject the implementation of this interface at runtime. When
    you are unit testing this class, the DI framework can be configured to inject
    a mock object that implements the required interface. Thus, DI enables loose coupling
    between objects.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类实例化另一个类时，它们之间存在紧密的依赖关系。如果你希望独立于其他类测试类，这种设计可能会成为问题。例如，你可能想测试一个具有业务逻辑的类，但它也引用了一个DAO，而DAO又依赖于一个JDBC连接对象。当你测试第一个类时，你必须实例化DAO并配置连接池。正如我们在[第5章](part0108.html#36VSO0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)“单元测试”中看到的，单元测试应该能够在没有任何外部依赖的情况下运行。实现这一目标的一种方法是通过使用DI。我们不是实例化DAO类，而是让我们的类引用由DAO实现的接口，并在运行时由DI框架注入该接口的实现。当你对这个类进行单元测试时，可以配置DI框架注入一个实现了所需接口的模拟对象。因此，DI使得对象之间能够实现松耦合。
- en: Dependency injection in Spring
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring中的依赖注入
- en: 'Because DI is at the core of the Spring Framework, let''s spend some time understanding
    how it works in Spring. We will create a standalone application for this purpose.
    Create a simple Maven project. Add the following dependency for the Spring Framework:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因为依赖注入（DI）是Spring框架的核心，让我们花些时间来了解它在Spring中的工作方式。为此，我们将创建一个独立的应用程序。创建一个简单的Maven项目。为Spring框架添加以下依赖项：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Replace the preceding version number with the latest version of Spring. Classes
    managed by the DI container of Spring are called beans or components. You can
    either declare beans in an XML file or you can annotate the class. We will use
    annotations in this chapter. However, even though we use annotations, we need
    to specify the minimum configuration in an XML file. So, create an XML file in
    the `src/main/resource` folder of your project and name it `context.xml`. The
    reason that we are creating this file in the `src/main.resource` folder is that
    the files in this folder are made available in the classpath. Next, add the following
    content to `context.xml`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的版本号替换为Spring的最新版本。由Spring的DI容器管理的类被称为bean或组件。你可以要么在XML文件中声明bean，要么在类上使用注解。在本章中，我们将使用注解。然而，尽管我们使用了注解，我们仍需要在XML文件中指定最小配置。因此，在你的项目`src/main/resource`文件夹中创建一个XML文件，并将其命名为`context.xml`。我们在`src/main.resource`文件夹中创建此文件的原因是，此文件夹中的文件将在类路径中可用。接下来，将以下内容添加到`context.xml`文件中：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By using the `<context:component-scan>` tag, we are telling the Spring Framework
    to scan the `base-package` folder and then look for the classes annotated with
    `@Component` and recognize them as managed classes so that they can be made available
    when injecting dependencies. In the preceding example, all classes in the `packt.jee.eclipse.spring`
    package (and its sub-packages) would be scanned to identify components.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`<context:component-scan>`标签，我们告诉Spring框架扫描`base-package`文件夹，然后查找带有`@Component`注解的类，并将它们识别为受管理的类，以便在注入依赖项时可以使用。在前面的例子中，`packt.jee.eclipse.spring`包（及其子包）中的所有类都将被扫描以识别组件。
- en: Information read from the configuration file must be saved in an object. In
    Spring, it is saved in an instance of the `ApplicationContext` interface. There
    are different implementations of `ApplicationContext`. We will be using the `ClassPathXmlApplicationContext`
    class, which looks for the configuration XML file in the classpath.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从配置文件中读取的信息必须保存到一个对象中。在Spring中，它被保存在`ApplicationContext`接口的一个实例中。`ApplicationContext`有不同的实现方式。我们将使用`ClassPathXmlApplicationContext`类，它在类路径中查找配置XML文件。
- en: 'We will now create two Spring components. The first one is `CourseDAO`, and
    the second is `CourseService`. Although we won''t write any business logic in
    these classes (the purpose of this example is to understand how DI works in Spring),
    assume that `CourseDAO` could have the code to access the database and `CourseService`
    calls `CourseDAO` to perform the database operations. So, `CourseService` is dependent
    on `CourseDAO`. To keep the code simple, we will not create any interface for
    `CourseDAO` but will have the direct dependency. Create the `CourseDAO` class
    as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建两个Spring组件。第一个是`CourseDAO`，第二个是`CourseService`。尽管我们不会在这些类中编写任何业务逻辑（此示例的目的是了解Spring中的DI如何工作），但假设`CourseDAO`可能有访问数据库的代码，而`CourseService`调用`CourseDAO`来执行数据库操作。因此，`CourseService`依赖于`CourseDAO`。为了使代码简单，我们不会为`CourseDAO`创建任何接口，而是将直接依赖。按照以下方式创建`CourseDAO`类：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will have no methods in `CourseDAO`, but as mentioned before, it could have
    methods to access the database. `@Component` marks this class as managed by Spring.
    Now, create the `CourseService` class. This class needs an instance of `CourseDAO`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CourseDAO`中，我们将没有方法，但如前所述，它可能有访问数据库的方法。`@Component`将此类标记为由Spring管理。现在，创建`CourseService`类。此类需要一个`CourseDAO`实例：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have declared a member variable called `courseDAO` and annotated it with
    `@Autowired`. This tells Spring to look for a component in its context (of `CourseDAO`
    type) and assign that to the `courseDAO` member.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已声明一个名为`courseDAO`的成员变量，并使用`@Autowired`进行了注解。这告诉Spring在其上下文中查找（`CourseDAO`类型的）组件并将其分配给`courseDAO`成员。
- en: 'We will now create the main class. It creates `ApplicationContext`, gets the `CourseService`
    bean, calls the `getCourseDAO` method, and then checks whether it was injected
    properly. Create the `SpringMain` class:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建主类。它创建`ApplicationContext`，获取`CourseService`豆/组件，调用`getCourseDAO`方法，然后检查它是否被正确注入。创建`SpringMain`类：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We first create an instance of `ClassPathXmlApplicationContext`. The configuration
    XML file is passed as an argument to the constructor. We then get the `courseService`
    bean/component. Note the naming convention when specifying the bean name; it is
    the class name with the first letter in lowercase. We then get and print the value
    of `CourseDAO`. The value won't show any meaningful information, but if the value
    is not null, then it would mean that the Spring DI container has injected it properly.
    Note that we have not instantiated `CourseDAO`; it is the Spring DI container
    that instantiates and injects this object.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个`ClassPathXmlApplicationContext`实例。配置XML文件作为参数传递给构造函数。然后我们获取`courseService`豆/组件。注意指定豆名称时的命名约定；它是类名，首字母小写。然后我们获取并打印`CourseDAO`的值。值不会显示任何有意义的信
- en: 'In the preceding code, we saw an example of injecting objects at the member
    declaration (this is also called property injection). We can have this object
    injected in the constructors too:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们看到了在成员声明处注入对象的一个示例（这也可以称为属性注入）。我们也可以在构造函数中注入此对象：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note that the `@Autowired` annotation is moved to the constructor, and the
    single constructor argument is auto-injected. You can also have the object injected
    in a setter:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`@Autowired`注解已移动到构造函数中，并且单个构造函数参数是自动注入的。您也可以在设置器中注入对象：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Component scopes
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件作用域
- en: 'You can specify the scope for your components in Spring MVC. The default scope
    is singleton, which means that there will be only one instance of the component
    in the context. Every request for this component will be served with the same
    instance. The other scopes are as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Spring MVC中指定组件的作用域。默认作用域是单例，这意味着在上下文中将只有一个组件实例。对每个此组件的请求都将使用相同的实例。其他作用域如下：
- en: '**Prototype**: Each request for the component is served with a new instance
    of that class.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原型**：为每个组件请求提供该类的新实例。'
- en: '**Request**: Valid for web applications. Single instance of a component class
    created for each HTTP request.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求**：适用于Web应用程序。为每个HTTP请求创建的组件类的单个实例。'
- en: '**Session**: Single instance of a component class created for each HTTP session.
    Used in web applications.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话**：为每个HTTP会话创建的组件类的单个实例。用于Web应用程序。'
- en: '**Global session**: Single instance of a component class created for the global
    HTTP session. Used in portlet applications.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局会话**：为全局HTTP会话创建的组件类的单个实例。用于portlet应用程序。'
- en: '**Application**: Single instance of a component class in the web application.
    The instance is shared by all sessions in that application.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序**：在Web应用程序中组件类的单个实例。该实例由该应用程序中的所有会话共享。'
- en: See  [https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes) for
    more information on component scopes in Spring.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Spring中组件作用域的更多信息，请访问[https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes)。
- en: If the component to be injected was not instantiated at the time it was requested,
    then Spring creates an instance of the component. In the previous example, we
    have not specified the scope of the `CourseDAO` component, so the same instance
    would be injected if there is another request for injecting `CourseDAO`. You can
    specify the scope in the `@Component` annotation. You can also specify the component
    name if you want to override the default name that Spring gives to the component.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在请求组件时该组件尚未实例化，那么Spring将创建该组件的一个实例。在先前的例子中，我们没有指定`CourseDAO`组件的作用域，因此如果有另一个请求注入`CourseDAO`，则将注入相同的实例。你可以在`@Component`注解中指定作用域。如果你想覆盖Spring给组件提供的默认名称，也可以指定组件名称。
- en: 'To see if a single instance of a component is injected when no scope is specified,
    let''s change the `main` method in the `SpringMain` class and make two calls to
    the `getBean` method:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看在没有指定作用域的情况下是否注入了组件的单个实例，让我们更改`SpringMain`类中的`main`方法并调用两次`getBean`方法：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Run the application and you should see the same instance of the `courseService`
    bean printed. Let''s change the scope of the `CourseService` component:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，你应该会看到打印出相同的`courseService` bean实例。现在让我们改变`CourseService`组件的作用域：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Run the application again; this time, you should see different instances of
    the `CourseService` component.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行应用程序；这次，你应该会看到`CourseService`组件的不同实例。
- en: 'When Spring comes across the `@Autowire` annotation, it tries to find the component
    by type. In the preceding example, `courseDAO` is annotated with `@Autowire`.
    Spring tries to find a component of `CourseDAO` type; it finds an instance of
    `CourseDAO` and injects it. But what if there are multiple instances of the class
    in the context? In such a case, we can use the `@Qualifier` annotation to uniquely
    identify components. Let''s now create the `ICourseDAO` interface, which will
    be implemented by two components, namely `CourseDAO` and `CourseDAO1`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当Spring遇到`@Autowire`注解时，它会尝试通过类型查找组件。在先前的例子中，`courseDAO`被注解为`@Autowire`。Spring会尝试找到一个`CourseDAO`类型的组件；它找到一个`CourseDAO`的实例并将其注入。但如果上下文中存在该类的多个实例呢？在这种情况下，我们可以使用`@Qualifier`注解来唯一标识组件。现在让我们创建`ICourseDAO`接口，该接口将由两个组件实现，即`CourseDAO`和`CourseDAO1`：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`CourseDAO` implements `ICourseDAO` and is uniquely qualified as `"courseDAO"`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`CourseDAO`实现了`ICourseDAO`，并且被唯一限定为`"courseDAO"`：'
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`CourseDAO1` implements `ICourseDAO` and is uniquely qualified as `"courseDAO1"`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`CourseDAO1`实现了`ICourseDAO`，并且被唯一限定为`"courseDAO1"`：'
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the `CourseService` class, we will use a qualifier to uniquely identify
    whether we want `CourseDAO` or `CourseDAO1` to be injected:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CourseService`类中，我们将使用限定符来唯一标识我们想要注入`CourseDAO`还是`CourseDAO1`：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The qualifier can also be specified at method arguments, for example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 限定符也可以在方法参数中指定，例如：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Run the application now. You should see that an instance of `CourseDAO1` is
    printed in the console.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用程序。你应该会在控制台看到打印出一个`CourseDAO1`实例。
- en: We have covered the basics of dependency injection in Spring. However, Spring
    offers a lot more options and features for dependency injection than we have covered
    here. We will see more DI features as and when required in this chapter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了Spring中依赖注入的基本知识。然而，Spring提供的依赖注入选项和功能比我们在这里介绍的要多得多。在本章中，我们将根据需要看到更多的DI功能。
- en: Visit [https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-dependencies](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-dependencies)
    for more information about dependency injection in Spring.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Spring中依赖注入的更多信息，请访问[https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-dependencies](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-dependencies)。
- en: Installing Spring Tool Suite
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Spring Tool Suite
- en: '**Spring Tool Suite** (**STS**) is a set of tools in Eclipse for creating Spring
    applications. It can be either installed as a plugin to an existing installation
    of Eclipse JEE or can be installed standalone. The standalone version of STS is
    also packaged with Eclipse EE, so all Eclipse features for Java EE development
    are available in STS too. You can download STS from [https://spring.io/tools](https://spring.io/tools).
    Since we have already installed Eclipse EE, we will install STS as a plugin. The
    easiest way to install the STS plugin is from Eclipse Marketplace. Select the
    Help | Eclipse Marketplace... menu.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring Tool Suite**（**STS**）是Eclipse中用于创建Spring应用的一组工具。它既可以作为Eclipse JEE现有安装的插件安装，也可以独立安装。STS的独立版本也包含在Eclipse
    EE中，因此STS也提供了所有Eclipse Java EE开发功能。您可以从[https://spring.io/tools](https://spring.io/tools)下载STS。由于我们已安装Eclipse
    EE，我们将以插件的形式安装STS。在Eclipse Marketplace中安装STS插件的最简单方法是选择“帮助 | Eclipse Marketplace...”菜单。'
- en: 'Type `Spring Tool Suite` in the Find box, and click the Go button:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在查找框中输入`Spring Tool Suite`，然后点击“Go”按钮：
- en: '![](img/00178.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00178.jpeg)'
- en: 'Figure 8.1: Search fir STS in Eclipse Marketplace'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：在Eclipse Marketplace中搜索STS
- en: Click Install. The next page shows the features of STS that will be installed.
    Click Confirm to install the selected features.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“安装”。下一页将显示将要安装的STS功能。点击“确认”以安装所选功能。
- en: Creating a Spring MVC application
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Spring MVC应用
- en: Spring MVC can be used for creating web applications. It provides an easy framework
    to map incoming web requests to a handler class (Controller) and create dynamic
    HTML output. It is an implementation of the MVC pattern. The Controller and Models
    are created as POJOs, and Views can be created using JSP, JSTL, XSLT, and even
    JSF. However, in this chapter, we will focus on creating Views using JSP and JSTL.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC可用于创建Web应用。它提供了一个简单的框架，将传入的Web请求映射到处理类（控制器）并创建动态HTML输出。它是MVC模式的实现。控制器和模型作为POJO创建，视图可以使用JSP、JSTL、XSLT甚至JSF创建。然而，在本章中，我们将专注于使用JSP和JSTL创建视图。
- en: You can find the Spring web documentation at [https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html)找到Spring网络文档。
- en: 'A web request is handled by four layers in Spring MVC:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC通过四层处理网络请求：
- en: '**Front controller**: This is a Spring servlet configured in `web.xml`. Based
    on the request URL pattern, it passes requests to the Controller.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前端控制器**：这是一个配置在`web.xml`中的Spring servlet。根据请求URL模式，它将请求传递到控制器。'
- en: '**Controller**: These are POJOs annotated with `@Controller`. For each Controller
    that you write, you need to specify a URL pattern that the Controller is expected
    to handle. Sub-URL patterns can be specified at the method level too. We will
    see examples of this later. Controller has access to Model and to HTTP request
    and response objects. Controller can delegate processing of a request to other
    business handler objects, get results, and populate the Model object, which is
    made available to View by Spring MVC.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：这些是带有`@Controller`注解的POJO。对于您编写的每个控制器，您需要指定控制器预期处理的URL模式。子URL模式也可以在方法级别指定。我们将在稍后看到这方面的示例。控制器可以访问模型以及HTTP请求和响应对象。控制器可以将请求的处理委托给其他业务处理对象，获取结果，并填充模型对象，该对象由Spring
    MVC提供给视图。'
- en: '**Model**: These are data objects. The Controller and View layers can set and
    get data from Model objects.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：这些是数据对象。控制器和视图层可以设置和获取模型对象中的数据。'
- en: '**View**: These are typically JSPs, but Spring MVC supports other types of
    Views too. See View technologies in the Spring documentation at [https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-view](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-view).'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：这些通常是JSP页面，但Spring MVC也支持其他类型的视图。请参阅Spring文档中的视图技术[https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-view](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-view)。'
- en: We will learn Spring MVC in this chapter through examples, as we have been learning
    in some other chapters in this book. We will create a part of the same *Course
    Management* application using Spring MVC. The application will display a list
    of courses with options to add, remove, and modify them.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过示例学习本章的Spring MVC，就像我们在本书的一些其他章节中学习的那样。我们将使用Spring MVC创建同一**课程管理**应用的一部分。该应用将显示课程列表，并提供添加、删除和修改课程的功能。
- en: Creating a Spring project
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Spring项目
- en: 'First, make sure that you have installed STS in Eclipse EE. From the Eclipse
    menu, select File | New | Other and then select the Spring | Spring Legacy Project
    option. Enter the project name and select the Spring MVC Project template:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保你在Eclipse EE中安装了STS。从Eclipse菜单中选择File | New | Other，然后选择Spring | Spring
    Legacy Project选项。输入项目名称并选择Spring MVC Project模板：
- en: '![](img/00179.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00179.jpeg)'
- en: 'Figure 8.2: Select the Spring MVC Project template'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：选择Spring MVC项目模板
- en: 'Click on Next. The page will ask you to enter the top-level package name:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 点击下一步。页面将要求你输入顶级包名：
- en: '![](img/00180.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00180.jpeg)'
- en: 'Figure 8.3: Enter top-level package name'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：输入顶级包名
- en: Whatever you enter as a top-level package, the wizard takes the third sub-package
    as the application name. When the application is deployed in a server, the application
    name becomes the context name. For example, if you enter the package name as `packt.jee.course_management`,
    then `course_management` becomes the application name, and the base URL of the
    application on the local machine would be `http://localhost:8080/course_management/`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你输入什么作为顶级包，向导都会将第三个子包作为应用程序名称。当应用程序在服务器上部署时，应用程序名称变为上下文名称。例如，如果你输入的包名为`packt.jee.course_management`，那么`course_management`将成为应用程序名称，本地机器上应用程序的基本URL将是`http://localhost:8080/course_management/`。
- en: Click Finish. This creates a Maven project with the required libraries for Spring
    MVC.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 点击完成。这将创建一个包含所需库的Maven项目，用于Spring MVC。
- en: Understanding files created by the Spring MVC project template
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Spring MVC项目模板创建的文件
- en: 'Let''s examine some of the files created by the template:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查模板创建的一些文件：
- en: '`src/main/webapp/WEB-INF/web.xml`: A front Controller servlet is declared here,
    along with other configurations:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/main/webapp/WEB-INF/web.xml`: 在这里声明了一个前端控制器servlet以及其他配置：'
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`DispatcherServlet` is the front Controller servlet. It is passed the path
    of the context (XML) file for configuring Spring DI. Recall that in the standalone
    Spring application, we created `context.xml` to configure dependency injection.
    The `DispatcherServlet` servlet is mapped to handle requests to this web application.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`DispatcherServlet`是前端控制器servlet。它传递上下文（XML）文件的路径以配置Spring DI。回想一下，在独立Spring应用程序中，我们创建了`context.xml`来配置依赖注入。`DispatcherServlet`
    servlet被映射来处理对此Web应用程序的请求。'
- en: '`src/main/webapp/WEB-INF/spring/appServlet/servlet-context.xml`: Context configuration
    for Spring DI. Some of the notable configuration parameters in this file are as
    follows:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/main/webapp/WEB-INF/spring/appServlet/servlet-context.xml`：Spring DI的上下文配置。此文件中的一些显著配置参数如下：'
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This enables annotations for configuring dependency injection at the class
    level:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这启用了在类级别配置依赖注入的注解：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Static files, such as CSS, JavaScript, and images, can be placed in the `resources`
    folder (`src/main/webapp/resources`):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 静态文件，如CSS、JavaScript和图像，可以放置在`resources`文件夹中（`src/main/webapp/resources`）：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This tells Spring to use the `InternalResourceViewResolver` class to resolve
    Views. Properties of this bean tell the `InternalResourceViewResolver` class to
    look for the View files in the `/WEB-INF/views` folder. Furthermore, Views will
    be JSP files, as indicated by the suffix property. Our Views will be the JSP files
    in the `src/main/webapp/WEB-INF/views` folder:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Spring使用`InternalResourceViewResolver`类来解析视图。此bean的属性告诉`InternalResourceViewResolver`类在`/WEB-INF/views`文件夹中查找视图文件。此外，视图将是JSP文件，如后缀属性所示。我们的视图将是`src/main/webapp/WEB-INF/views`文件夹中的JSP文件：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This tells Spring to scan the `packt.jee.course_management` package and its
    sub-packages to search for components (annotated by `@Component`).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Spring扫描`packt.jee.course_management`包及其子包以搜索组件（由`@Component`注解）。
- en: 'The default template also creates one Controller and one View. The controller
    class is `HomeController` in the package that you specified in the Spring project
    wizard (in our example, it is `packt.jee.course_management`). Controller in Spring
    MVC is called by the dispatcher servlet. Controllers are annotated by `@Controller`.
    To map the request path to a Controller, you use the `@RequestMapping` annotation.
    Let''s see the code generated by the template in the `HomeController` class:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 默认模板还创建了一个控制器和一个视图。控制器类是你在Spring项目向导中指定的包中的`HomeController`（在我们的例子中是`packt.jee.course_management`）。Spring
    MVC中的控制器由调度器servlet调用。控制器通过`@Controller`注解。要映射请求路径到控制器，你使用`@RequestMapping`注解。让我们看看模板在`HomeController`类中生成的代码：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `home` method is annotated with `@RequestMapping`. The value of mapping
    is `/`, which tells the dispatcher servlet to send all requests coming its way
    to this method. The `method` attribute tells the dispatcher to call the `home`
    method only for HTTP requests of the `GET` type. The `home` method takes two arguments,
    namely `Locale` and `Model`; both are injected at runtime by Spring. The `@RequestMapping`
    annotation also tells Spring to insert any dependencies when calling the `home`
    method, and so `locale` and `model` are auto-injected.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`home`方法被`@RequestMapping`注解。映射的值是`/`，这告诉Dispatcher Servlet将所有传入的请求发送到这个方法。`method`属性告诉Dispatcher只对HTTP请求的`GET`类型调用`home`方法。`home`方法接受两个参数，即`Locale`和`Model`；这两个都是在运行时由Spring注入的。`@RequestMapping`注解还告诉Spring在调用`home`方法时插入任何依赖项，因此`locale`和`model`会自动注入。'
- en: 'The method itself does not do much; it gets the current date-time and sets
    it as an attribute in the Model. Any attributes set in the Model are available
    to the View (JSP). The method returns a string, `"home"`. This value is used by
    Spring MVC to resolve the View to be displayed. The `InternalResourceViewResolver`
    that we saw in `servlet-context.xml` previously resolves this as `home.jsp` in
    the `/WEB-INF/views` folder. `home.jsp` has the following code in the `<body>`
    tag:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法本身并没有做什么；它获取当前的日期和时间，并将其设置为Model的属性。在Model中设置的任何属性都对View（JSP）可用。该方法返回一个字符串，“home”。这个值被Spring
    MVC用来解析要显示的View。我们在之前的`servlet-context.xml`中看到的`InternalResourceViewResolver`将这个值解析为`/WEB-INF/views`文件夹中的`home.jsp`。`home.jsp`在`<body>`标签中有以下代码：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `serverTime` variable comes from the Model object set in the `home` method
    of `HomeController`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`serverTime`变量来自`HomeController`的`home`方法中设置的Model对象。'
- en: To run this project, we need to configure a server in Eclipse and add this project
    to the server. Refer to the *Configuring Tomcat in Eclipse* and *Running JSP in
    Tomcat* sections in [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating a Simple JEE Web Application*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此项目，我们需要在Eclipse中配置一个服务器并将此项目添加到服务器中。请参考[第2章](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)中的*在Eclipse中配置Tomcat*和*在Tomcat中运行JSP*部分，*创建一个简单的JEE
    Web应用程序*。
- en: 'Once you configure Tomcat and add the project to it, start the server. Then,
    right-click on the project and select Run As | Run on Server. You should see a
    hello message with the timestamp displayed in the internal Eclipse browser. The
    URL in the browser''s address bar should be `http://localhost:8080/course_management/`,
    assuming that Tomcat is deployed on port `8080` and the context name (derived
    from the top-level package name) is `course_management`. If you want to change
    the default context name or remove the context, that is, deploy the application
    in the root context, then open the project properties (right-click on the project
    and select Properties) and go to Web Project Settings. You can change the context
    root name or remove it from this page:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你配置了Tomcat并将项目添加到其中，启动服务器。然后，在项目上右键单击并选择Run As | Run on Server。你应该在Eclipse的内部浏览器中看到一个带有时间戳的hello消息。浏览器地址栏中的URL应该是`http://localhost:8080/course_management/`，假设Tomcat部署在端口`8080`，上下文名称（从顶级包名派生）是`course_management`。如果你想更改默认的上下文名称或删除上下文，即以根上下文部署应用程序，那么打开项目属性（在项目上右键单击并选择Properties）并转到Web
    Project Settings。你可以从这个页面更改上下文根名称或删除它：
- en: '![](img/00181.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00181.jpeg)'
- en: 'Figure 8.4: Context root setting'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：上下文根设置
- en: For our *Course Management* application, we are not going to need the `HomeController`
    class or `home.jsp`, so you can go ahead and delete these files.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的*课程管理*应用程序，我们不需要`HomeController`类或`home.jsp`，所以你可以继续删除这些文件。
- en: Building the Spring MVC application using JDBC
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JDBC构建Spring MVC应用程序
- en: In this section, we will build a part of the course management application using
    Spring MVC and JDBC. The application will display a list of courses and options
    for adding, deleting, and modifying courses. We will continue using the project
    that we created in the previous section. We will learn many of the features of
    Spring for data access using JDBC as we go along.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用Spring MVC和JDBC构建课程管理应用程序的一部分。该应用程序将显示课程列表以及添加、删除和修改课程的选项。我们将继续使用上一节中创建的项目。随着我们的进行，我们将学习使用JDBC作为数据访问的许多Spring特性。
- en: First, we will configure our datasource. We will use the same MySQL database
    that we created in the *Creating database schema* section of [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Database Applications*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将配置我们的数据源。我们将使用与[第4章](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)，*创建JEE数据库应用*中*创建数据库模式*部分创建的相同MySQL数据库。
- en: Configuring a datasource
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置数据源
- en: 'In Spring, you can configure a JDBC datasource either in Java code or in the
    XML configuration (context) file. Before we see how to configure a datasource,
    we need to add some dependencies in Maven. In this chapter, we will use Apache''s
    Commons DBCP component for connection pooling (recall that in [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Database Applications*, we selected the Hikari connection pool).
    Visit [https://commons.apache.org/proper/commons-dbcp/](https://commons.apache.org/proper/commons-dbcp/)
    for details on Apache DBCP. In addition to adding a dependency for Apache DBCP,
    we need to add dependencies for Spring JDBC and the MySQL JDBC driver. Add the
    following dependencies to the `pom.xml` of the project:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在春季，您可以在Java代码或XML配置（上下文）文件中配置JDBC数据源。在我们看到如何配置数据源之前，我们需要在Maven中添加一些依赖项。在本章中，我们将使用Apache的Commons
    DBCP组件来实现连接池（回想一下，在[第4章](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)，*创建JEE数据库应用*中，我们选择了Hikari连接池）。有关Apache
    DBCP的详细信息，请访问[https://commons.apache.org/proper/commons-dbcp/](https://commons.apache.org/proper/commons-dbcp/)。除了添加Apache
    DBCP的依赖项之外，我们还需要添加Spring JDBC和MySQL JDBC驱动程序的依赖项。将以下依赖项添加到项目的`pom.xml`文件中：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you want to create a datasource in Java code, you can do so as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在Java代码中创建数据源，可以按照以下方式操作：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'However, we will configure a datasource in an XML configuration file. Open
    `servlet-context.xml` (you will find it in the `src/main/webapp/WEB-INF/spring/appServlet`
    folder) and add the following bean:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将使用XML配置文件来配置数据源。打开`servlet-context.xml`（您可以在`src/main/webapp/WEB-INF/spring/appServlet`文件夹中找到它）并添加以下bean：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you are wondering what *bean* means, it is the same as the component that
    we created in the examples earlier in the chapter. We have so far created a component
    using annotations, but the component and the bean can be declared in an XML file
    too. In fact, this is how it used to be in earlier versions, till support for
    annotations was added in Spring. In a real-world application, you may want to
    encrypt database passwords before specifying them in a configuration file. One
    way to decrypt a password before sending it to the database is to create a wrapper
    class for the datasource (in the previous example, create a wrapper for `org.apache.commons.dbcp.BasicDataSource`)
    and override the `setPassword` method, where you can decrypt the password.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道*bean*是什么意思，它与我们在本章早期示例中创建的组件相同。我们到目前为止已经使用注解创建了一个组件，但组件和bean也可以在XML文件中声明。实际上，这是在早期版本中使用的做法，直到Spring添加了对注解的支持。在现实世界的应用程序中，您可能希望在配置文件中指定数据库密码之前对其进行加密。在将密码发送到数据库之前解密密码的一种方法是为数据源创建一个包装类（在前面的示例中，为`org.apache.commons.dbcp.BasicDataSource`创建一个包装器）并重写`setPassword`方法，在那里您可以解密密码。
- en: If you want to keep the database connection parameters separate from the Spring
    configuration, then you can use a `properties` file. Spring provides a consistent
    way to access resources such as a `properties` file. Just as you can access web
    URLs using the `http` protocol prefix or the file URL using the `file` protocol
    prefix, Spring allows you to access resources in the classpath using the `classpath`
    prefix. For example, if we create a `jdbc.properties` file and save it in one
    of the folders in the classpath, then we could access it as `classpath:jdbc.properties`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想将数据库连接参数与Spring配置分开，则可以使用一个`properties`文件。Spring提供了一种一致的方式来访问资源，例如`properties`文件。就像您可以使用`http`协议前缀访问Web
    URL或使用`file`协议前缀访问文件URL一样，Spring允许您使用`classpath`前缀访问类路径中的资源。例如，如果我们创建一个`jdbc.properties`文件并将其保存在类路径中的一个文件夹中，那么我们可以将其访问为`classpath:jdbc.properties`。
- en: Visit [https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#resources](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#resources) for
    detailed information on accessing resources using Spring. The Spring resource
    URL formats can be used in configuration files or Spring APIs where the resource
    location is expected.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#resources](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#resources)
    获取有关使用 Spring 访问资源的详细信息。Spring 资源 URL 格式可用于配置文件或期望资源位置的 Spring API 中。
- en: Spring also provides a convenient tag to load property files in context config
    XML. You can access the values of properties in a `property` file in the config
    XML using the `${property_name}` syntax.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 还提供了一个方便的标签来在上下文配置 XML 中加载属性文件。您可以使用 `${property_name}` 语法在配置 XML 中访问属性文件中的属性值。
- en: 'We will move the database connection properties to a file in this example.
    Create `jdbc.properties` in the `src/main/resources` folder. Maven makes this
    folder available in the classpath, so we can access it using the Spring resource
    format in the XML configuration file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将数据库连接属性移动到一个文件中。在 `src/main/resources` 文件夹中创建 `jdbc.properties`。Maven
    使此文件夹可用于类路径，因此我们可以使用 XML 配置文件中的 Spring 资源格式来访问它：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will load this `properties` file from `servlet-context.xml` using the `property-placeholder`
    tag:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `property-placeholder` 标签从 `servlet-context.xml` 中加载此 `properties` 文件：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice that the location of the `property` file is specified using the Spring
    resource format. In this case, we ask Spring to look for the `jdbc.properties`
    file in the classpath. Further, because the `src/main/resources` folder is in
    the classpath (where we saved `jdbc.properties`), it should be loaded by Spring.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`property` 文件的存放位置是使用 Spring 资源格式指定的。在这种情况下，我们要求 Spring 在类路径中查找 `jdbc.properties`
    文件。此外，因为 `src/main/resources` 文件夹位于类路径中（我们在这里保存了 `jdbc.properties`），它应该由 Spring
    加载。
- en: 'Let''s now modify the `datasource` bean declaration in `servlet-context.xml`
    to use the property values:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们修改 `servlet-context.xml` 中的 `datasource` bean 声明，以使用属性值：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that the order of the `property-placeholder` tag and where the properties
    are used does not matter. Spring loads the entire XML configuration file before
    replacing `property` references with their values.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`property-placeholder` 标签的顺序以及属性的使用位置并不重要。Spring 在将属性引用替换为其值之前，会加载整个 XML
    配置文件。
- en: Using the Spring JDBCTemplate class
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring JDBCTemplate 类
- en: Spring provides a utility class called `JDBCTemplate` that makes it easy to
    perform many operations using JDBC. It provides convenient methods to execute
    SQL statements, map results of a query to an object (using the `RowMapper` class),
    close a database connection at the end of database operations, and many others.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 提供了一个名为 `JDBCTemplate` 的实用工具类，它使得使用 JDBC 执行许多操作变得容易。它提供了执行 SQL 语句、将查询结果映射到对象（使用
    `RowMapper` 类）、在数据库操作结束时关闭数据库连接等方便的方法。
- en: Visit [https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#jdbc](https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#jdbc) for
    more information on `JDBCTemplate`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#jdbc](https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#jdbc)
    获取有关 `JDBCTemplate` 的更多信息。
- en: 'Before we write any data access code, we will create a **Data Transfer Object**
    (**DTO**), `CourseDTO`, which will just contain members that describe one `Course`
    and setters and getters for them. Create `CourseDTO` in the `packt.jee.course_management.dto`
    package. Instances of this class will be used to transfer data between different
    tiers of our application:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写任何数据访问代码之前，我们将创建一个 **数据传输对象**（**DTO**），名为 `CourseDTO`，它将仅包含描述一个 `Course`
    的成员以及它们的设置和获取器。在 `packt.jee.course_management.dto` 包中创建 `CourseDTO`。此类实例将用于在不同层之间传输我们的应用程序中的数据：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We will now create a simple DAO that will use the `JdbcTemplate` class to execute
    a query to get all courses. Create the `CourseDAO` class in the `packt.jee.course_management.dao`
    package. Annotate the `CourseDAO` class with `@Repository`. Similar to `@Component`, the `@Repository`
    annotation marks the class as a Spring DI container-managed class.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建一个简单的 DAO，它将使用 `JdbcTemplate` 类执行查询以获取所有课程。在 `packt.jee.course_management.dao`
    包中创建 `CourseDAO` 类。使用 `@Repository` 注解 `CourseDAO` 类。类似于 `@Component`，`@Repository`
    注解将类标记为 Spring DI 容器管理的类。
- en: As per the Spring documentation ([https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-stereotype-annotations](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-stereotype-annotations)),
    `@Component` is a generic annotation to mark a class as Spring container-managed,
    and `@Repository` and `@Controller` are more specific ones. More specific annotations
    help to identify classes for specific treatments. It is recommended to use `@Repository`
    annotations for DAOs.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Spring 文档（[https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-stereotype-annotations](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-stereotype-annotations)），`@Component`
    是一个通用的注解，用于标记一个类为 Spring 容器管理，而 `@Repository` 和 `@Controller` 是更具体的注解。更具体的注解有助于识别用于特定处理的类。建议为
    DAO 使用 `@Repository` 注解。
- en: '`CourseDAO` needs to have an instance of the `JdbcTemplate` class to execute
    queries and other SQL statements. `JdbcTemplate` needs a `DataSource` object before
    it can be used. We will have `DataSource` injected in a method in `CourseDAO`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`CourseDAO` 需要一个 `JdbcTemplate` 类的实例来执行查询和其他 SQL 语句。`JdbcTemplate` 在使用之前需要一个
    `DataSource` 对象。我们将在 `CourseDAO` 的一个方法中注入 `DataSource`：'
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `datasource` that we have configured in `servlet-context.xml` will be injected
    by Spring when the `CourseDAO` object is created.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `servlet-context.xml` 中配置的 `datasource` 将在创建 `CourseDAO` 对象时由 Spring 注入。
- en: 'We will now write the method to get all courses. The `JdbcTemplate` class has
    a `query` method that allows you to specify `RowMapper`, where you can map each
    row in the query to a Java object:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将编写一个获取所有课程的方法。`JdbcTemplate` 类有一个 `query` 方法，允许你指定 `RowMapper`，其中你可以将查询中的每一行映射到一个
    Java 对象：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the `getCourses` method, we will execute a static query. Later, we will see
    how to execute parameterized queries too. The second argument to the `query` method
    of `JDBCTemplate` is an instance of the `RowMapper` interface. We have created
    the static inner class `CourseRowMapper` that implements the `RowMapper` interface.
    We override the `mapRow` method, which is called for each row in `ResultSet`,
    and then we create/map the `CourseDTO` object from the `ResultSet` passed in the
    arguments. The method returns a `CourseDTO` object. The result of `JdbcTemplate.query`
    is a list of `CourseDTO` objects. Note that the `query` method can also return
    other Java collection objects, such as `Map`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `getCourses` 方法中，我们将执行一个静态查询。稍后，我们将看到如何执行参数化查询。`JDBCTemplate.query` 方法的第二个参数是
    `RowMapper` 接口的一个实例。我们创建了一个静态内部类 `CourseRowMapper`，它实现了 `RowMapper` 接口。我们重写了 `mapRow`
    方法，该方法在 `ResultSet` 的每一行上被调用，然后我们从传入的参数中的 `ResultSet` 创建/映射 `CourseDTO` 对象。该方法返回一个
    `CourseDTO` 对象。`JdbcTemplate.query` 的结果是 `CourseDTO` 对象的列表。请注意，`query` 方法还可以返回其他
    Java 集合对象，例如 `Map`。
- en: 'Now, let''s write a method to add a course to the table:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个方法来向表中添加课程：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When we add or insert a new course, we want to get the ID of the new record,
    which is autogenerated. Furthermore, we would like to use the prepared statement
    to execute SQL. Therefore, first we create `KeyHolder` for the auto-generated
    field. The `update` method of `JdbcTemplate` has many overloaded versions. We
    use the one that takes `PreparedStatementCreator` and `KeyHolder`. We create an
    instance of `PreparedStatementCreator` and override the `createPreparedStatement`
    method. In this method, we create a JDBC `PreparedStatement` and return it. Once
    the update method is successfully executed, we retrieve the auto-generated value
    by calling the `getKey` method of `KeyHolder`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们添加或插入一个新的课程时，我们希望获取新记录的 ID，它是自动生成的。此外，我们希望使用预处理语句来执行 SQL。因此，首先我们为自动生成的字段创建
    `KeyHolder`。`JdbcTemplate` 的 `update` 方法有多个重载版本。我们使用一个接受 `PreparedStatementCreator`
    和 `KeyHolder` 的版本。我们创建一个 `PreparedStatementCreator` 的实例并重写 `createPreparedStatement`
    方法。在这个方法中，我们创建一个 JDBC `PreparedStatement` 并返回它。一旦更新方法成功执行，我们通过调用 `KeyHolder` 的
    `getKey` 方法来检索自动生成的值。
- en: 'The methods to update or delete a course are similar:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 更新或删除课程的这些方法类似：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We need to add one more method to `CourseDAO`, to get the details of a course,
    given the ID:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要向 `CourseDAO` 添加一个额外的方法，以便根据 ID 获取课程的详细信息：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`queryForObject` returns a single object for a given query. We use a parameterized
    query here, and the parameter is passed as the last argument to the `queryForObject`
    method. Further, we use `CourseRowMapper` to map the single row returned by this
    query to `CourseDTO`. Note that you can pass a variable number of parameters to the `queryForObject`
    method, although in this case, we pass a single value, that is, the ID.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`queryForObject`方法针对给定查询返回单个对象。在这里我们使用参数化查询，并将参数作为`queryForObject`方法的最后一个参数传递。此外，我们使用`CourseRowMapper`将此查询返回的单行映射到`CourseDTO`。请注意，您可以向`queryForObject`方法传递可变数量的参数，尽管在这种情况下，我们传递了一个单一值，即ID。'
- en: We now have all the methods in the `CourseDAO` class to access data for `Course`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在`CourseDAO`类中拥有了访问`Course`数据的所有方法。
- en: For a detailed discussion on data access using JDBC in Spring, refer to [https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#jdbc](https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#jdbc).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 有关在Spring中使用JDBC进行数据访问的详细讨论，请参阅[https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#jdbc](https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#jdbc)。
- en: Creating the Spring MVC Controller
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Spring MVC控制器
- en: We will now create the `Controller` class. In Spring MVC, the Controller is
    mapped to the request URL and handles requests matching the URL pattern. The request
    URL for matching an incoming request is specified at the method level in the controller.
    However, more generic request mapping can be specified at the `Controller` class
    level, and a specific URL, with respect to the URL at the class level, can be
    specified at the method level.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建`Controller`类。在Spring MVC中，控制器映射到请求URL并处理与URL模式匹配的请求。在控制器中，在方法级别指定用于匹配传入请求的请求URL。然而，可以在`Controller`类级别指定更通用的请求映射，并且可以在方法级别指定相对于类级别的特定URL。
- en: 'Create a class named `CourseController` in the `packt.jee.course_management.controller`
    package. Annotate it with `@Controller`. The `@Controller` annotation is of type
    `@Component`, and allows the Spring Framework to identify that class specifically
    as a controller. Add the method to get courses in `CourseController`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在`packt.jee.course_management.controller`包中创建一个名为`CourseController`的类。使用`@Controller`注解它。`@Controller`注解是`@Component`类型，允许Spring框架特别识别该类为控制器。在`CourseController`中添加获取课程的方法：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `CourseDAO` instance is autowired; that is, it will be injected by Spring.
    We have added the  `getCourses` method, which takes a Spring Model object. Data
    can be shared between View and Controller using this Model object. Therefore,
    we add an attribute to Model, named `courses`, and assign the list of courses
    that we get by calling `courseDAO.getCourses`. This list could be used in the
    View JSP as the `courses` variable. We have annotated this method with `@RequestMapping`.
    This annotation maps the incoming request URL to a controller method. In this
    case, we are saying that any request (relative to the root) that starts with `/courses`
    should be handled by the `getCourses` method in this controller. We will add more
    methods to `CourseController` later and discuss some of the parameters that we
    can pass to the `@RequestMapping` annotation, but first let's create a View to
    display the list of courses.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`CourseDAO`实例是自动装配的；也就是说，它将由Spring注入。我们添加了`getCourses`方法，该方法接受一个Spring Model对象。可以使用此Model对象在视图和控制器之间共享数据。因此，我们在Model中添加了一个名为`courses`的属性，并将通过调用`courseDAO.getCourses`获得的课程列表分配给该属性。这个列表可以在视图JSP中作为`courses`变量使用。我们使用`@RequestMapping`注解了这个方法。此注解将传入请求URL映射到控制器方法。在这种情况下，我们表示任何以`/courses`开头的相对根请求都应该由这个控制器中的`getCourses`方法处理。我们将在`CourseController`中添加更多方法，并讨论我们可以传递给`@RequestMapping`注解的一些参数，但首先让我们创建一个视图来显示课程列表。'
- en: Creating View
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建视图
- en: We have created data access objects for `Course` and a Controller. Let's see
    how we can call them from a View. Views in Spring are typically JSPs. Create a
    JSP (name it `courses.jsp`) in the `src/main/webapp/WEB-INF/views` folder. This
    is the folder that we configured in `servlet-context.xml` to hold the Spring View
    files.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为`Course`创建了一个数据访问对象和一个控制器。让我们看看我们如何从视图中调用它们。Spring中的视图通常是JSP。在`src/main/webapp/WEB-INF/views`文件夹中创建一个JSP（命名为`courses.jsp`）。这是我们在`servlet-context.xml`中配置的文件夹，用于存放Spring视图文件。
- en: 'Add the JSTL tag library in `courses.jsp`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在`courses.jsp`中添加JSTL标签库：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The markup code to display courses is very simple; we make use of the `courses`
    variable, which is made available in the Model from the `CourseController.getCourses`
    method and displays values using JSTL expressions:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 显示课程的标记代码非常简单；我们使用`courses`变量，该变量由`CourseController.getCourses`方法在模型中提供，并使用JSTL表达式显示值：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Recall that `courses` is a list of objects of `CourseDTO` type. Members of `CourseDTO`
    are accessed in the `forEach` tag to display the actual values.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`courses`是一个`CourseDTO`类型的对象列表。`CourseDTO`的成员在`forEach`标签中访问以显示实际值。
- en: Unfortunately, we can't run this page from Eclipse the way we have so far in
    this book, that is, by right-clicking on the project or page and selecting Run
    As | Run on Server. If you try to run the project (right-click on the project
    and select the Run menu), then Eclipse will try to open the `http://localhost:8080/course_management/`
    URL, and because we do not have any start page (`index.html` or `index.jsp`),
    we will get an HTTP 404 error. The reason that we can't run the page by right-clicking
    and selecting the run option is that Eclipse tries to open `http://localhost:8080/course_management/WEB-INF/views/courses.jsp`,
    and this fails because files in `WEB-INF` are not accessible from outside the
    server. Another reason, or rather the primary reason, that this URL will not work
    is that in `web.xml`, we have mapped all requests to be handled by `DispatcherServlet`
    of the Spring Framework and it does not find a suitable mapping for the request
    URL. To run the application, open the URL `http://localhost:8080/course_management/courses`
    in the browser.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们无法像本书中之前那样从Eclipse中运行这个页面，即通过在项目或页面上右键单击并选择“运行”|“在服务器上运行”。如果你尝试运行项目（在项目上右键单击并选择运行菜单），那么Eclipse将尝试打开`http://localhost:8080/course_management/`
    URL，因为我们没有任何起始页面（`index.html`或`index.jsp`），我们将得到HTTP 404错误。我们无法通过右键单击并选择运行选项来运行页面的原因是Eclipse试图打开`http://localhost:8080/course_management/WEB-INF/views/courses.jsp`，这失败了，因为`WEB-INF`中的文件无法从服务器外部访问。另一个原因，或者更确切地说，主要原因，是这个URL不会工作是因为在`web.xml`中，我们已经将所有请求映射到由Spring框架的`DispatcherServlet`处理的请求，并且它找不到适合请求URL的映射。要运行应用程序，请在浏览器中打开URL`http://localhost:8080/course_management/courses`。
- en: Mapping data using @ModelAttribute
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用@ModelAttribute映射数据
- en: In this section, we will implement the feature to insert a new course. In the
    process, we will learn more about mapping requests to methods and mapping request
    parameters to method arguments.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现插入新课程的功能。在这个过程中，我们将更多地了解将请求映射到方法和将请求参数映射到方法参数。
- en: 'In the previous section, we implemented `CourseController` with one method,
    `getCourses`. We will now add methods to insert new courses. To add a course,
    we first need to display a View with a form that accepts the user input. When
    the user actually submits the form, the form data should be posted to a URL that
    handles insertion of the data to the database. Therefore, there are two requests
    involved here: the first is to display the *add course* form, and the second is
    to handle the data posted from the form. We will call the first request `addCourse`
    and the second request `doAddCourse`. Let''s first create the user interface.
    Create a new JSP and name it `addCourse.jsp`. Add the following markup to the
    `body` of the page (JSTL and other header declarations are skipped to save space):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用一个方法`getCourses`实现了`CourseController`。现在我们将添加插入新课程的方法。要添加一门课程，我们首先需要显示一个包含用户输入表单的视图。当用户实际提交表单时，表单数据应该被发送到处理将数据插入数据库的URL。因此，这里涉及两个请求：第一个是显示*添加课程*表单，第二个是处理从表单发送的数据。我们将第一个请求称为`addCourse`，第二个请求称为`doAddCourse`。让我们首先创建用户界面。创建一个新的JSP页面并命名为`addCourse.jsp`。将以下标记添加到页面的`body`部分（跳过了JSTL和其他头部声明以节省空间）：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The page expects a course variable to be made available by the controller. In
    the form body, it assigns the values of the course to appropriate input fields;
    for example, the `${course.name}` value is assigned to the text input for `Course
    Name`. The form posts the data to the `"${pageContext.request.contextPath}/doAddCourse"`
    URL. Note that since our application is not deployed in the root context, we need
    to include the context name in the URL.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 页面期望控制器提供`course`变量。在表单体中，它将课程值分配到适当的输入字段；例如，`${course.name}`值分配给`课程名称`的文本输入。表单将数据发送到`"${pageContext.request.contextPath}/doAddCourse"`
    URL。请注意，由于我们的应用程序没有部署在根上下文，我们需要在URL中包含上下文名称。
- en: 'Let''s now add Controller methods to handle two requests for add: `addCourse`
    and `doAddCourse`. When the `addCourse` request is made, we want to serve the
    page that displays the input form. When the user clicks the Submit button, we
    want form data to be sent using the `doAddCourse` request. Open the `CourseController`
    class and add the following method:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加控制器方法来处理两个添加请求：`addCourse` 和 `doAddCourse`。当发起 `addCourse` 请求时，我们希望提供显示输入表单的页面。当用户点击提交按钮时，我们希望使用
    `doAddCourse` 请求发送表单数据。打开 `CourseController` 类并添加以下方法：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `addCourse` method is configured, using the `@RequestMapping` annotation,
    to handle  request URLs starting (relative to context root) with `"/addCourse"`.
    If previously the  `course` attribute was added to Model, then we want this object
    to be passed as an argument to this function. Using `@ModelAttribute`, we tell
    the Spring Framework to inject the Model attribute called `course` if it is present
    and assign it to the argument named `course`; else, `null` is passed. In the case
    of the first request, Model would not have a `course` attribute, so it would be
    `null`. In the subsequent requests, for example, when the user-entered data in
    the form (to add a course) is not valid and we want to redisplay the page, Model
    will have the `course` attribute.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`addCourse` 方法使用 `@RequestMapping` 注解配置，以处理以（相对于上下文根）以 `"/addCourse"` 开头的请求
    URL。如果之前已将 `course` 属性添加到 Model 中，那么我们希望将此对象作为参数传递给此函数。使用 `@ModelAttribute`，我们告诉
    Spring 框架如果存在，则注入名为 `course` 的 Model 属性并将其分配给名为 `course` 的参数；否则，传递 `null`。在第一次请求的情况下，Model
    不会有 `course` 属性，因此它将是 `null`。在随后的请求中，例如，当用户在表单中输入的数据（用于添加课程）无效并且我们想要重新显示页面时，Model
    将具有 `course` 属性。'
- en: 'We will now create a handler method for the `''/doAddCourse''` request. This
    is a `POST` request sent when the user submits the form in `addCourse.jsp` (refer
    to the form and its `POST` attribute discussed earlier):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将为 `'/doAddCourse'` 请求创建一个处理器方法。这是一个当用户在 `addCourse.jsp` 中提交表单时发送的 `POST`
    请求（参考之前讨论的表单及其 `POST` 属性）：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `doAddCourse` method also asks Spring to inject the Model attribute called
    `course` as the first argument. It then adds the course to the database using
    `CourseDAO`. In the case of an error, it returns the `addCourse` string, and Spring
    MVC displays `addCourse.jsp` again. If the course is successfully added, then
    the request is redirected to `courses`, which tells Spring to process and display
    `courses.jsp`. Recall that in `servlet-context.xml` (the Spring context configuration
    file in the `src/main/webapp/WEB-INF/spring/appServlet` folder), we configured
    a bean with the `org.springframework.web.servlet.view.InternalResourceViewResolver`
    class. This class is extended from `UrlBasedViewResolver`, which understands how
    to handle URLs with `redirect` and `forward` prefixes. So, in `doAddCourse` we
    save the data in the database, and if successful, we redirect the request to `courses`,
    which displays (after processing `courses.jsp`) the list of courses.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`doAddCourse` 方法还要求 Spring 将名为 `course` 的 Model 属性作为第一个参数注入。然后，它使用 `CourseDAO`
    将课程添加到数据库中。如果发生错误，它将返回 `addCourse` 字符串，Spring MVC 将再次显示 `addCourse.jsp`。如果课程成功添加，则请求将被重定向到
    `courses`，这告诉 Spring 处理并显示 `courses.jsp`。回想一下，在 `servlet-context.xml`（位于 `src/main/webapp/WEB-INF/spring/appServlet`
    文件夹中的 Spring 上下文配置文件），我们配置了一个具有 `org.springframework.web.servlet.view.InternalResourceViewResolver`
    类的 bean。这个类扩展了 `UrlBasedViewResolver`，它理解如何处理带有 `redirect` 和 `forward` 前缀的 URL。因此，在
    `doAddCourse` 中，我们将在数据库中保存数据，如果成功，我们将请求重定向到 `courses`，它将在处理 `courses.jsp` 后显示课程列表。'
- en: At this point, if you want to test the application, browse to `http://localhost:8080/course_management/addCourse`.
    Enter the course name and credits and click Submit. This should take you to the
    courses page and display the list of courses.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，如果您想测试应用程序，请浏览到 `http://localhost:8080/course_management/addCourse`。输入课程名称和学分，然后点击提交。这应该会带您到课程页面并显示课程列表。
- en: Note that Spring MVC looks at the form field names and properties of the object
    in Model (in this case, `CourseDTO`) when mapping form values to the object. For
    example, the form field `name` is mapped to the `CourseDTO.name` property. So,
    make sure that the names of the form fields and the property names in the class
    (objects of which are added to the Model) are the same.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Spring MVC 在将表单字段名称映射到 Model（在这种情况下，`CourseDTO`）中的对象属性时，会查看 Model 中的对象属性。例如，表单字段
    `name` 被映射到 `CourseDTO.name` 属性。因此，请确保表单字段的名称和类（其对象被添加到 Model 中）中的属性名称相同。
- en: Using parameters in @RequestMapping
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 @RequestMapping 参数
- en: We have seen how to use the `@RequestMapping` annotation to map the incoming
    request to a Controller method. So far, we have mapped static URL patterns in
    `@RequestMapping`. However, it is possible to map parameterized URLs (like those
    used in REST; see [https://spring.io/understanding/REST](https://spring.io/understanding/REST))
    using `@RequestMapping`. The parameters are specified inside `{}`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用`@RequestMapping`注解将传入的请求映射到Controller方法。到目前为止，我们已经在`@RequestMapping`中映射了静态URL模式。然而，使用`@RequestMapping`也可以映射参数化URL（如REST中使用的；参见[https://spring.io/understanding/REST](https://spring.io/understanding/REST)）。参数在`{}`内指定。
- en: Let's add the feature to update an existing course. Here, we will only discuss
    how to code the Controller method for this feature. The complete code is available
    when you download the samples for this chapter.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加更新现有课程的功能。在这里，我们只讨论如何为这个功能编写Controller方法。完整的代码在您下载本章的示例时可用。
- en: 'Let''s add the following method in `CourseController`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`CourseController`中添加以下方法：
- en: '[PRE39]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here, we map the `updateCourse` method to handle requests with the following
    URL pattern: `/course/update/{id}`, where `{id}` could be replaced with the ID
    (number) of any existing course, or for that matter, any integer. To access the
    value of this parameter, we used the `@PathVariable` annotation in the arguments.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`updateCourse`方法映射到以下URL模式的请求：`/course/update/{id}`，其中`{id}`可以是任何现有课程的ID（数字），或者换句话说，任何整数。为了访问此参数的值，我们在参数中使用了`@PathVariable`注解。
- en: Using Spring interceptors
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring拦截器
- en: Spring interceptors can be used to process any request before it reaches the
    controller. These could be used, for example, to implement security features (authentication
    and authorization). Like request mappers, interceptors can also be declared for
    specific URL patterns. Let's add the login page to our application, which should
    be displayed before any other page in the application if the user has not already
    logged in.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Spring拦截器可以在请求到达控制器之前处理任何请求。例如，这些可以用来实现安全功能（认证和授权）。与请求映射器一样，拦截器也可以为特定的URL模式声明。让我们将登录页面添加到我们的应用程序中，如果用户尚未登录，它应该显示在应用程序中的任何其他页面之前。
- en: 'We will first create `UserDTO` in the `packt.jee.course_management.dto` package.
    This class contains the username, password, and any message to be displayed on
    the login page, for example, authentication errors:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将在`packt.jee.course_management.dto`包中创建`UserDTO`。这个类包含用户名、密码以及要在登录页面上显示的任何消息，例如，认证错误：
- en: '[PRE40]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, let''s create the `UserController` that will process the login request.
    Once the user is logged in successfully, we would like to keep this information
    in the session.  The presence of this object in the session can be used to check
    whether the user is already logged in. Create the `UserController` class in the `packt.jee.course_management.controller`
    package:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建将处理登录请求的`UserController`。一旦用户成功登录，我们希望将此信息保留在会话中。可以通过检查会话中是否存在此对象来使用此对象的存在来检查用户是否已经登录。在`packt.jee.course_management.controller`包中创建`UserController`类：
- en: '[PRE41]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Add a handler method for the `GET` request for the login page:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为登录页面的`GET`请求添加一个处理方法：
- en: '[PRE42]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note that we have specified the method attribute in the `@RequestMapping` annotation.
    When the request URL is `/login` and the HTTP request type is `GET`, only then
    will the `login` method be called. This method would not be called if a `POST`
    request is sent from the client. In the `login` method, we create an instance
    of `UserDTO` and add it to the Model so that it is accessible to the View.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在`@RequestMapping`注解中指定了方法属性。当请求URL是`/login`且HTTP请求类型是`GET`时，才会调用`login`方法。如果客户端发送`POST`请求，则不会调用此方法。在`login`方法中，我们创建一个`UserDTO`实例并将其添加到Model中，以便它对View可访问。
- en: 'We will add a method to handle `POST` requests from the login page. We will
    keep the same URL, that is, `/login`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个方法来处理来自登录页面的`POST`请求。我们将保持相同的URL，即`/login`：
- en: '[PRE43]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We now have two methods in `UserController` handling the request URL `/login`.
    However, the login method handles `GET` requests and `doLogin` handles `POST`
    requests. If authentication is successful in the `doLogin` method, then we redirect
    to the courses (list) page. Else, we set the error message and return to the login
    page.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在`UserController`中有两种方法来处理请求URL `/login`。然而，登录方法处理`GET`请求，而`doLogin`处理`POST`请求。如果在`doLogin`方法中认证成功，那么我们将重定向到课程（列表）页面。否则，我们将设置错误信息并返回到登录页面。
- en: 'Let''s save the user object created in the login method in the HTTP session.
    This can be done with the simple `@SessionAttributes` annotation. You can specify
    the list of attributes in Model that need to be saved in the session too. Furthermore,
    we want to save the `user` attribute of Model in the session. Therefore, we will
    add the following annotation to the `UserController` class:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在登录方法中创建的用户对象保存在 HTTP 会话中。这可以通过简单的 `@SessionAttributes` 注解来完成。您可以指定需要保存在会话中的
    Model 中的属性列表。此外，我们还想将 Model 的 `user` 属性保存在会话中。因此，我们将向 `UserController` 类添加以下注解：
- en: '[PRE44]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, let''s create the login page. Create `login.jsp` in the `views` folder
    and add the following code in the HTML `<body>`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建登录页面。在 `views` 文件夹中创建 `login.jsp` 并在 HTML `<body>` 中添加以下代码：
- en: '[PRE45]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The page expects `user` (instance of `UserDTO`) to be available. It is made
    available by `UserController` through Model.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 页面期望 `user`（`UserDTO` 的实例）可用。这是通过 `UserController` 通过 Model 提供的。
- en: 'We now have the login page and `UserController` to handle the authentication,
    but how do we make sure this page is displayed for every request when the user
    is not logged in? This is where we can use Spring interceptors. We will configure
    an interceptor in the Spring context configuration file: `servlet-context.xml`.
    Add the following code to `servlet-context.xml`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了登录页面和 `UserController` 来处理认证，但如何确保当用户未登录时，此页面会显示在每个请求中？这就是我们可以使用 Spring
    拦截器的地方。我们将在 Spring 上下文配置文件 `servlet-context.xml` 中配置一个拦截器。将以下代码添加到 `servlet-context.xml`：
- en: '[PRE46]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this configuration, we are telling Spring to call `LoginInterceptor` before
    executing any request (indicated by `mapping path = "/**"`).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置中，我们正在告诉 Spring 在执行任何请求之前调用 `LoginInterceptor`（由 `mapping path = "/**"`
    表示）。
- en: Let's now implement `LoginInterceptor`. Interceptors must implement `HandlerInterceptor`.
    We will make `LoginInterceptor` extend `HandlerInterceptorAdapter`, which implements
    `HandlerInterceptor`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现 `LoginInterceptor`。拦截器必须实现 `HandlerInterceptor`。我们将使 `LoginInterceptor`
    继承 `HandlerInterceptorAdapter`，它实现了 `HandlerInterceptor`。
- en: 'Create `LoginInterceptor` in the `packt.jee.course_management.interceptor`
    package:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `packt.jee.course_management.interceptor` 包中创建 `LoginInterceptor`：
- en: '[PRE47]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `preHandle` method of the interceptor is called before Spring executes any
    request. If we return `true` from the method, then the request is handled further;
    else, it is aborted. In `preHandle`, we first check whether the `user` object
    is present in the session. The presence of the `user` object means that the user
    is already logged in. In such a case, we don't do anything more in this interceptor
    and return `true`. If the user is not logged in, then we redirect to the login
    page and return `false` so that Spring does not process this request further.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截器的 `preHandle` 方法在 Spring 执行任何请求之前被调用。如果我们从该方法返回 `true`，则请求将被进一步处理；否则，它将被终止。在
    `preHandle` 中，我们首先检查会话中是否存在 `user` 对象。`user` 对象的存在意味着用户已经登录。在这种情况下，我们在这个拦截器中不做任何更多的事情，并返回
    `true`。如果用户未登录，则我们将重定向到登录页面并返回 `false`，这样 Spring 就不会进一步处理此请求。
- en: Browse to `http://localhost:8080/course_management/courses` to test the login
    page. If you are not already logged in, the login page should be displayed.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览到 `http://localhost:8080/course_management/courses` 以测试登录页面。如果您尚未登录，登录页面应该会显示。
- en: Spring MVC application using JPA
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JPA 的 Spring MVC 应用程序
- en: In the previous section, we learned how to create a web application using Spring
    and JDBC. In this section, we will take a quick look at how to use Spring with
    **JPA** (**Java Persistence API**). We have already learned how to use JPA in
    [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating
    JEE Database Applications*, and in [Chapter 7](part0129.html#3R0OI0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Applications with EJB*, so we won't go into detail of how to set
    up the Eclipse project for JPA. However, we will discuss how to use JPA along
    with Spring in detail in this section.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何使用 Spring 和 JDBC 创建一个网络应用程序。在本节中，我们将快速查看如何使用 **JPA**（**Java Persistence
    API**）与 Spring 一起使用。我们已经在 [第 4 章](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)
    和 [第 7 章](part0129.html#3R0OI0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55) 中学习了如何使用 JPA，分别是在
    *创建 JEE 数据库应用程序* 和 *使用 EJB 创建 JEE 应用程序* 中，因此我们不会详细介绍如何为 JPA 设置 Eclipse 项目。然而，在本节中，我们将详细讨论如何与
    Spring 一起使用 JPA。
- en: We will create a separate project for this example. Create a Spring MVC project
    as described in the *Creating Spring project* section of this chapter. On the
    second page of the project wizard, where you are asked to enter a top-level package
    name, enter `packt.jee.course_management_jpa`. Recall that the last part of this
    package name is also used as the web application context.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为这个示例创建一个单独的项目。按照本章中*创建Spring项目*部分所述创建一个Spring MVC项目。在项目向导的第二页，当被要求输入顶级包名时，输入`packt.jee.course_management_jpa`。回想一下，包名的最后一部分也用作Web应用程序上下文。
- en: Configuring JPA
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置JPA
- en: 'We are going to use the EclipseLink JPA provider and the MySQL database driver
    in this project. So, add the Maven dependencies for them in the `pom.xml` file
    of the project:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本项目中使用EclipseLink JPA提供者和MySQL数据库驱动程序。因此，在项目的`pom.xml`文件中添加它们的Maven依赖项：
- en: '[PRE48]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We will now configure the project for JPA. Right-click on the project and select
    Configure | Convert to JPA Project. This opens the Project Facets page, with JPA
    selected as one of the facets:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将为JPA配置项目。在项目上右键单击并选择配置 | 转换为JPA项目。这打开项目特性页面，其中JPA被选为特性之一：
- en: '![](img/00182.jpeg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00182.jpeg)'
- en: 'Figure 8.5: Project facets'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：项目特性
- en: 'Click the Next button to configure the JPA facet:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 点击下一步按钮以配置JPA特性：
- en: '![](img/00183.jpeg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00183.jpeg)'
- en: 'Figure 8.6: JPA facet'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：JPA特性
- en: Select the EclipseLink platform in the preceding page. We will also disable
    the library configuration (select from the dropdown for the Type field). Configure
    the MySQL Connection (named CourseMgmtDBConnection), as described in the *Configuring
    JPA* section of [Chapter 7](part0129.html#3R0OI0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Applications with EJB*.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一页中选择EclipseLink平台。我们还将禁用库配置（从类型字段的下拉列表中选择）。配置MySQL连接（命名为CourseMgmtDBConnection），如第7章中*配置JPA*部分所述[第7章](part0129.html#3R0OI0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)，*使用EJB创建JEE应用程序*。
- en: 'Click Finish. `Persistence.xml` is created under the JPA Content group in Project
    Explorer (the actual location of this file is `src/main/resources/META-INF/persistence.xml`).
    We will configure properties for the MySQL JDBC connection in this. Open the file
    and click the Connection tab:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 点击完成。`Persistence.xml`文件将在项目资源管理器中的JPA内容组下创建（该文件的实际位置是`src/main/resources/META-INF/persistence.xml`）。我们将在其中配置MySQL
    JDBC连接的属性。打开文件并点击“连接”选项卡：
- en: '![](img/00184.jpeg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00184.jpeg)'
- en: 'Figure 8.7: Configure connection in persistence.xml'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：在persistence.xml中配置连接
- en: Select Transaction type as `Resource Local`. Then, enter the JDBC driver details.
    Save the file.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 选择事务类型为`资源局部`。然后输入JDBC驱动程序详细信息。保存文件。
- en: Creating the Course entity
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建课程实体
- en: 'Let''s now create the `Course` entity. Right-click on the project and select
    the JPA Tools | Generate Tables from Entities menu:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建`Course`实体。在项目上右键单击并选择JPA工具 | 从实体生成表菜单：
- en: '![](img/00185.jpeg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00185.jpeg)'
- en: 'Figure 8.8: Generate course entity'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8：生成课程实体
- en: 'Make sure that `CourseMgmtDBConnection` is selected (refer to the *Configuring
    JPA* section of [Chapter 7](part0129.html#3R0OI0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Applications with EJB*, for configuring a MySQL database connection
    in Eclipse) and that List generated classes in persistence.xml is selected. Click
    Next on this and the next page. On the Customize Defaults page, select identity as
    the Key generator and set the package name as `packt.jee.course_management_jpa.entity`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 确保已选择`CourseMgmtDBConnection`（请参阅第7章中*配置JPA*部分[第7章](part0129.html#3R0OI0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)，*使用EJB创建JEE应用程序*)，并且已选中在`persistence.xml`中列出生成的类。在此页面上点击下一步，然后在下一页上。在自定义默认值页面上，选择identity作为键生成器，并将包名设置为`packt.jee.course_management_jpa.entity`：
- en: '![](img/00186.jpeg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00186.jpeg)'
- en: 'Figure 8.9: Customize JPA entity defaults'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：自定义JPA实体默认值
- en: 'Click Next. Verify the entity class name and the other details:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 点击下一步。验证实体类名称和其他详细信息：
- en: '![](img/00187.jpeg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00187.jpeg)'
- en: 'Figure 8.10: Customize JPA entity details'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10：自定义JPA实体详细信息
- en: 'Click Finish. The `Course` entity class will be created in the package selected:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 点击完成。`Course`实体类将创建在所选的包中：
- en: '[PRE49]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note that the wizard has also created the named query to get all the courses
    from the table.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，向导还创建了一个命名查询，用于从表中获取所有课程。
- en: We now need to create `EntityManagerFactory` so that `EntityManager` can be
    created from it (refer to the *JPA concepts* section in [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Database Applications*). We will create a Spring bean/component
    to create and store `EntityManagerFactory`. Furthermore, we will inject (autowire)
    this component into the DAO class.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要创建 `EntityManagerFactory`，以便可以从它创建 `EntityManager`（参考第 4 章 *JPA 概念* 部分，*创建
    JEE 数据库应用程序*）。我们将创建一个 Spring bean/component 来创建和存储 `EntityManagerFactory`。此外，我们将将其注入（自动连接）到
    DAO 类中。
- en: 'Create the `JPAEntityFactoryBean` class in the `packt.jee.course_management_jpa.entity`
    package:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `packt.jee.course_management_jpa.entity` 包中创建 `JPAEntityFactoryBean` 类：
- en: '[PRE50]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the constructor of the class, we create `EntityManagerFactory`. The argument
    to `createEntityManagerFactory` is the name of the persistence unit, as specified
    in `persistence.xml`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的构造函数中，我们创建 `EntityManagerFactory`。`createEntityManagerFactory` 的参数是 persistence.xml
    中指定的持久化单元的名称。
- en: Creating CourseDAO and Controller
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 CourseDAO 和 Controller
- en: 'Let''s now create the `CourseDAO` class. We will have an instance of `JPAEntityFactoryBean`
    injected (auto-wired) into this class. Create the `packt.jee.course_management_jpa.dao`
    package and the `CourseDAO` class in it:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建 `CourseDAO` 类。我们将在这个类中注入（自动连接）`JPAEntityFactoryBean` 的一个实例。在 `packt.jee.course_management_jpa.dao`
    包中创建 `CourseDAO` 类：
- en: '[PRE51]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the `getCourses` method, we first create `EntityManager` (from `JPAEntityFactoryBean`)
    and execute the named query. Once we get the results, we close `EntityManager`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `getCourses` 方法中，我们首先创建 `EntityManager`（来自 `JPAEntityFactoryBean`）并执行命名查询。一旦我们得到结果，我们就关闭
    `EntityManager`。
- en: 'The `Controller` class for `Course` will have `CourseDAO` auto-injected (auto-wired).
    Create `CourseController` in the `packt.jee.course_management_jpa.controller`
    package:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`Course` 的 `Controller` 类将自动注入（自动连接）`CourseDAO`。在 `packt.jee.course_management_jpa.controller`
    包中创建 `CourseController`：'
- en: '[PRE52]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As we saw in the `CourseController` created for the JDBC application earlier,
    we get courses from the database and add the list of courses to the Model under
    the key name `courses`. This variable will be available to the View page that
    displays the list of courses.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前为 JDBC 应用程序创建的 `CourseController` 中所看到的，我们从数据库中获取课程并将课程列表添加到以 `courses`
    为键名的模型中。这个变量将可用于显示课程列表的视图页面。
- en: Creating the course list view
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建课程列表视图
- en: 'We now have all the classes to get courses. Let''s now create a JSP to display
    the list of courses. Create `courses.jsp` in the `src/main/webapp/WEB-INF/views`
    folder. Add the following content in the HTML `body` tag of the page:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了获取课程所需的所有类。现在让我们创建一个 JSP 来显示课程列表。在 `src/main/webapp/WEB-INF/views` 文件夹中创建
    `courses.jsp`。在页面的 HTML `body` 标签中添加以下内容：
- en: '[PRE53]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The View page makes use of JSTL tags to iterate over courses (using the variable
    that was made available in the Model by the Controller) and displays them.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 视图页面使用 JSTL 标签遍历课程（使用控制器通过模型提供的变量）并显示它们。
- en: We are not going to build the entire application here. The idea was to understand
    how to use JPA with Spring MVC, which we have learned in this section. Browse
    to `http://localhost:8080/course_management_jpa/courses` to run the application.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会构建整个应用程序。我们的想法是了解如何使用 JPA 与 Spring MVC，这是我们在这个部分学到的。浏览到 `http://localhost:8080/course_management_jpa/courses`
    来运行应用程序。
- en: Summary
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learned how to use Spring MVC to create web applications.
    As the name indicates, Spring MVC implements the MVC design pattern, which enables
    clear separation of the user interface code and the business logic code.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用 Spring MVC 创建 Web 应用程序。正如其名称所示，Spring MVC 实现了 MVC 设计模式，这有助于清晰地分离用户界面代码和业务逻辑代码。
- en: Using the dependency injection feature of the Spring Framework, we can easily
    manage the dependencies of different objects in the application. We also learned
    how to use JDBC and JPA along with Spring MVC to create data-driven web applications.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Spring 框架的依赖注入功能，我们可以轻松地管理应用程序中不同对象的依赖关系。我们还学习了如何使用 JDBC 和 JPA 与 Spring MVC
    一起创建数据驱动的 Web 应用程序。
- en: In the next chapter, we will see how to create and consume web services in JEE
    applications. We will look at both SOAP-based and RESTful web services.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何在 JEE 应用程序中创建和消费 Web 服务。我们将探讨基于 SOAP 和 RESTful 的 Web 服务。
