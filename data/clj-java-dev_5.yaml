- en: Chapter 5. Multimethods and Protocols
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 多态方法和协议
- en: We now have a better understanding of how Clojure works; we understand how to
    perform simple operations with immutable data structures but we are missing some
    features that could make our lives much easier.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对Clojure的工作原理有了更好的理解；我们了解了如何使用不可变数据结构执行简单操作，但我们缺少一些可以使我们的生活更加容易的功能。
- en: If you have been a Java programmer for a while, you are probably thinking about
    polymorphism and its particular flavor in Java.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经是一名Java程序员一段时间了，你可能会在思考多态及其在Java中的特定风味。
- en: Polymorphism is one of the concepts that enable us to reuse a code. It gives
    us the ability to interact with different objects with the same API.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 多态是我们能够重用代码的概念之一。它赋予我们使用相同API与不同对象交互的能力。
- en: Clojure has a powerful polymorphism paradigm that allows us to write simple
    code, create code that interacts with types that don't exist yet, and extend code
    in ways it wasn't devised for when a programmer wrote it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure有一个强大的多态范式，允许我们编写简单的代码，创建与尚未存在的类型交互的代码，并在程序员编写它时以它未设计的方式扩展代码。
- en: 'To help us with polymorphism in Clojure, we have two important concepts that
    we will cover in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们理解Clojure中的多态，我们有两个重要的概念，我们将在本章中介绍：
- en: Multimethods
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态方法
- en: Protocols
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议
- en: Each of them has its own use cases and things it is best at; we will look into
    them in the next section.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 每一个都有其自己的用例和最擅长的事情；我们将在下一节中探讨它们。
- en: We will learn each of these different concepts by reviewing what we already
    know from Java and then we will learn similar concepts from Clojure that give
    us much more power.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过回顾我们从Java中已经知道的内容来学习这些不同的概念，然后我们将从Clojure中学习类似的概念，这些概念给我们带来了更多的能力。
- en: Polymorphism in Java
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java中的多态
- en: 'Java uses polymorphism heavily, its collection API is based on it. Probably
    the best examples of polymorphism in Java are the following classes:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Java大量使用多态，其集合API基于它。Java中多态的最好例子可能是以下类：
- en: '`java.util.List`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.List`'
- en: '`java.util.Map`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.Map`'
- en: '`java.util.Set`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.Set`'
- en: We know that depending on our use case we should use a particular implementation
    of these data structures.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，根据我们的用例，我们应该使用这些数据结构的一个特定实现。
- en: If we prefer to use an ordered Set, we might use a TreeSet.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更喜欢使用有序的Set，我们可能会使用TreeSet。
- en: If we need a Map in a concurrent environment, we will use a `java.util.concurrent.ConcurrentHashMap`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要在并发环境中使用Map，我们将使用`java.util.concurrent.ConcurrentHashMap`。
- en: The beautiful thing is that you can write your code using the `java.util.Map`
    and `java.util.Set` interfaces and if you need to change to another type of Set
    or Map, because the conditions have changed or someone has created a better version
    of the collection for you, you don't need to change any code!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 美妙的是，你可以使用`java.util.Map`和`java.util.Set`接口来编写你的代码，如果你需要更改到另一种类型的Set或Map，因为条件已经改变或有人为你创建了一个更好的集合版本，你不需要更改任何代码！
- en: Lets look at a very simple example of polymorphism in Java.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Java中多态的一个非常简单的例子。
- en: 'Imagine that you have a Shapes hierarchy; it might look similar to the following
    code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你有一个形状层次结构；它可能看起来像以下代码：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You surely are aware of the power of this concept, you can now calculate the
    summation of all the areas of a collection of figures, such as this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你肯定已经意识到了这个概念的力量，你现在可以计算一组图形的所有面积的总和，如下所示：
- en: '![Polymorphism in Java](img/00014.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![Java中的多态](img/00014.jpeg)'
- en: The `totalArea` method doesn't care about the specific types of shapes that
    you pass to it and you can add new types of shapes, such as rectangles or trapezoids.
    Your same code will now work with new data types.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`totalArea`方法不关心你传递给它的具体形状类型，你可以添加新的形状类型，例如矩形或梯形。现在，你的相同代码将适用于新的数据类型。'
- en: Now, with the same Java code base, imagine that you wanted to add a new function
    to your shape interface, something simple, such as a `getPerimeter` method.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用相同的Java代码库，想象一下你想要向你的形状接口添加一个新功能，比如一个简单的`getPerimeter`方法。
- en: This seems quite simple; you will have to modify each class that implements
    the Shape interface. I'm sure you've faced this problem a lot of times when you
    don't have access to the base source. The solution is to write a wrapper around
    your Shape objects but this introduces more classes and incidental complexity.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来相当简单；你将不得不修改实现Shape接口的每个类。我确信你很多次都遇到过这个问题，当你无法访问基源代码时。解决方案是在你的Shape对象周围编写一个包装器，但这引入了更多的类和偶然的复杂性。
- en: Clojure has its own idea of polymorphism, it is much simpler but also very powerful;
    you can in fact solve the perimeter problem with it in a very simple way.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 有自己的多态概念，它更简单但也很强大；实际上，你可以用它以非常简单的方式解决周长问题。
- en: One way to solve this is with multimethods; lets have a look at how they work.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种方法是多方法；让我们看看它们是如何工作的。
- en: Multimethods in Clojure
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clojure 中的多方法
- en: Multimethods are similar to interfaces, they allow you to write a common contract
    and then a family of functions can fulfill that interface with a specific implementation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 多方法与接口类似，它们允许你编写一个公共契约，然后一组函数可以用特定的实现来满足该接口。
- en: They are extremely flexible, as you will see they grant you a very fine control
    over what function is going to get invoked for a specific data object.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 它们非常灵活，正如你将看到的，它们让你能够非常精细地控制对特定数据对象调用哪个函数。
- en: 'Multimethods consist of three parts:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 多方法由三个部分组成：
- en: A function (or method) declaration
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数（或方法）声明
- en: A dispatch function
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度函数
- en: Each possible implementation of the function
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的每个可能的实现
- en: One of the most interesting features of multimethods is that you can implement
    new functions for already existing types without having to write wrappers around
    your currently existing object.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 多方法最有趣的特点之一是，你可以在不围绕现有对象编写包装器的情况下为已存在的类型实现新的函数。
- en: 'The multimethod declaration works the same way as the interface; you define
    a common contract for the polymorphic function, as shown:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 多方法声明与接口的工作方式相同；你为多态函数定义一个公共契约，如下所示：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `defmulti` macro defines the contract for your multimethod, it consists
    of:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`defmulti` 宏定义了你的多方法的契约，它由以下部分组成：'
- en: The multimethod's name
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多方法的名称
- en: An optional `doctstring` (this is the documentation string)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的 `doctstring`（这是文档字符串）
- en: The attribute map
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性映射
- en: The `dispatch-fn` function
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dispatch-fn` 函数'
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `dispatch` function gets called for every piece of content; it generates
    a dispatch key that is later checked against its function implementation. When
    the dispatch key and the key in the function implementation match, the function
    is called.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`dispatch` 函数会对每块内容进行调用；它生成一个调度键，稍后与函数实现中的键进行比对。当调度键与函数实现中的键匹配时，函数就会被调用。'
- en: The `dispatch` function receives the same parameters that the function you are
    calling receives and returns a dispatch key that is used to determine the function
    that should dispatch the request.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`dispatch` 函数接收与你要调用的函数相同的参数，并返回一个调度键，用于确定应该调度请求的函数。'
- en: Each implementation function must define a dispatch key, if it matches with
    the `dispatch` function's result, then this function is executed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 每个实现函数都必须定义一个调度键，如果它与 `dispatch` 函数的结果匹配，则执行此函数。
- en: 'An example should clarify:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子应该可以澄清：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we are defining a multimethod called `area`; the `defmulti` statement
    has the following structure:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在定义一个名为 `area` 的多方法；`defmulti` 语句具有以下结构：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this case, the multimethod is called `area` and the `dispatch` function is
    the `:shape` keyword.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，多方法被命名为 `area`，而 `dispatch` 函数是 `:shape` 关键字。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember, keywords can be used as functions that look up themselves in maps.
    So, for example, the result of (`:shape {:shape :square}`) is `:square`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，关键字可以用作函数，在映射中查找自身。所以，例如，(`:shape {:shape :square}`) 的结果是 `:square`。
- en: 'Afterwards, we define a method, as shown:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们定义一个方法，如下所示：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that the `dispatch-key` is always the result of invoking the `dispatch-function`
    with `params` as parameters.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`dispatch-key` 总是调用 `dispatch-function` 并以 `params` 作为参数的结果。
- en: 'Finally, let''s look at the invocation, `(area {:shape :square :side 5})` which
    is calling a multimethod. The first thing that happens is that we call the dispatch
    function `:shape`, as shown:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看调用 `(area {:shape :square :side 5})`，这是在调用一个多方法。首先发生的事情是我们调用调度函数 `:shape`，如下所示：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `:square` function is now the dispatch key, we need to look for the method
    that has that dispatch key; in this case, the only method that we defined works.
    So, the function is executed and we get the result of `25`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`:square` 函数现在是调度键，我们需要寻找具有该调度键的方法；在这种情况下，我们定义的唯一方法有效。因此，函数被执行，我们得到 `25` 的结果。'
- en: 'It is pretty simple to add the area and perimeter for both square and circle,
    lets check the implementation:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 添加正方形和圆形的面积和周长非常简单，让我们检查实现：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, we have defined how to calculate the perimeter and area of circles and
    squares with very little effort and without having to define a very strict object
    hierarchy. However, we are just starting to uncover the power of multimethods.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经定义了如何用很少的努力计算圆和正方形的周长和面积，而且不需要定义一个非常严格的对象层次结构。然而，我们只是刚开始揭示多方法的力量。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keywords can be namespaced, it allows you to keep your code better organized.
    There are two ways to define a namespaced keyword, such as `:namespace/keyword`
    and `::keyword`. When using the `::` notation, the used namespace is the current
    namespace. So if you write `::test` in the REPL, you will be defining `:user/test`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字可以是命名空间的，这有助于你更好地组织代码。定义命名空间关键字有两种方式，例如 `:namespace/keyword` 和 `::keyword`。当使用
    `::` 符号时，使用的命名空间是当前命名空间。所以如果你在 REPL 中写 `::test`，你将定义 `:user/test`。
- en: 'Let''s try another example, copy the following code into your REPL:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再试一个例子，将以下代码复制到你的 REPL 中：
- en: '![Multimethods in Clojure](img/00015.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![Clojure 中的多方法](img/00015.jpeg)'
- en: As you can see, it just works as you might expect it to. However, let's see
    how you can create a keyword hierarchy to be a little bit more flexible than this.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它的工作方式正如你预期的那样。然而，让我们看看如何创建一个关键字层次结构，使其比这更灵活一些。
- en: Keyword hierarchies
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键字层次结构
- en: 'You can declare that a keyword derives from another keyword and then respond
    to other dispatch keys, for that you can use the `derive` function:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以声明一个关键字从另一个关键字派生出来，然后响应其他分发键，为此你可以使用 `derive` 函数：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When defining a keyword hierarchy, you have to use namespaced keywords.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义关键字层次结构时，你必须使用命名空间关键字。
- en: 'Here, you are declaring that the `::hominid` key is derived from the `::animal`
    key and you can now use `::hominid` as `::animal`; let''s see that now:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你声明 `::hominid` 关键字是从 `::animal` 关键字派生出来的，你现在可以使用 `::hominid` 作为 `::animal`；让我们看看现在的情况：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We do have some problems when defining hierarchies, for instance what will
    happen if the same keyword were to be derived from two conflicting keywords? Let''s
    give it a try:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在定义层次结构时确实会遇到一些问题，例如，如果相同的关键字从两个冲突的关键字派生出来会发生什么？让我们试一试：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We get an error that says, there are two methods that match the dispatch value.
    Since our hominid derives both from animal and primate, it doesn't know which
    to resolve.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到一个错误，说有两个方法匹配分发值。由于我们的 hominid 同时从动物和灵长类派生，它不知道该解决哪个。
- en: 'We can work this out explicitly with:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下方式明确地解决这个问题：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, everything works correctly. We know that we prefer to resolve to a primate
    when calling the walk multimethod with the hominid key.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一切工作正常。我们知道，在调用带有 hominid 关键字的多方法 `walk` 时，我们更喜欢解析为灵长类。
- en: 'You can also define a more specific method, just for the `hominid` key:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以定义一个更具体的方法，专门用于 `hominid` 关键字：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The derivation hierarchy can get a little complex and we might need some functions
    to introspect relationships. Clojure has the following functions to work with
    type hierarchies.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 推导层次结构可能会变得有些复杂，我们可能需要一些函数来检查关系。Clojure 有以下函数来处理类型层次结构。
- en: '`isa?`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isa?`'
- en: '`parents`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parents`'
- en: '`descendants`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`descendants`'
- en: '`underive`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`underive`'
- en: isa?
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: isa?
- en: The `isa` function checks if a type derives from some other type, it works with
    Java classes as well as Clojure keywords.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`isa` 函数检查一个类型是否派生自其他类型，它既适用于 Java 类也适用于 Clojure 关键字。'
- en: 'It is simple to explain with examples:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 用例子来说明很简单：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: parents
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 父亲
- en: 'The `parent` function returns a set of a type''s parents, they might be Java
    or Clojure keywords:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`parent` 函数返回一个类型的父集，它们可能是 Java 或 Clojure 关键字：'
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: descendants
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: descendants
- en: 'The `descendants` function, as you can imagine, returns a set of descendants
    of the `passd` keyword; it is important to keep in mind that in this case only
    Clojure keywords are allowed:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`descendants` 函数，正如你可以想象的，返回 `passd` 关键字的子集；重要的是要记住，在这种情况下只允许 Clojure 关键字：'
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: underive
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: underive
- en: 'The `underive` function breaks the relation between two types, as you can imagine
    it only works with the Clojure keywords:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`underive` 函数断开两个类型之间的关系，正如你可以想象的，它只适用于 Clojure 关键字：'
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This function will normally be used at development time and they allow you to
    play around with your type hierarchy in a very simple and dynamic way.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数通常在开发时使用，并且允许你以非常简单和动态的方式玩转你的类型层次结构。
- en: A la carte dispatch functions
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按需分发函数
- en: 'Until now, we have used a keyword as a dispatch function but you can use any
    function you like with as many arguments as you want. Let''s take a look at some
    examples:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直使用关键字作为分发函数，但你可以使用任何你喜欢的函数，并且可以传递任意数量的参数。让我们看看一些例子：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is a simple function, but it shows two important facts:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的函数，但它展示了两个重要的事实：
- en: The `dispatch` function can receive more than one argument
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dispatch` 函数可以接收多个参数'
- en: The `dispatch` key can be anything, not just a keyword
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dispatch` 键可以是任何东西，而不仅仅是关键字'
- en: 'Lets have a look at how we can use this `dispatch` function:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用这个 `dispatch` 函数：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We are getting to know the `dispatch` function a little bit better; now that
    you know that you can implement any `dispatch` function, you have a very fine
    grained control over what function gets called and when.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 `dispatch` 函数的了解更深入了；现在你知道你可以实现任何 `dispatch` 函数，你就有非常细粒度的控制权，知道哪个函数会被调用以及何时调用。
- en: 'Lets look at one more example, so we can finally grasp the complete idea:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个例子，这样我们就可以最终掌握完整的想法：
- en: '![A la carte dispatch functions](img/00016.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![点菜式 dispatch 函数](img/00016.jpeg)'
- en: Now the true power of multimethods becomes apparent. You now have an adhoc way
    of defining polymorphic functions which has the possibility to define type hierarchies
    and even execute your own logic to determine the function that is going to be
    called finally.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，多方法的力量真正显现出来。你现在有一种定义多态函数的临时方法，它有定义类型层次结构甚至执行自己的逻辑以确定最终要调用的函数的可能性。
- en: Protocols in Clojure
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clojure 中的协议
- en: Multimethods are just one of the options for polymorphism you have in Clojure,
    there are other ways to implement polymorphic functions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 多态是你在 Clojure 中有的一种选项之一，还有其他方法可以实现多态函数。
- en: Protocols are a little easier to understand and they might feel more similar
    to Java interfaces.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 协议更容易理解，它们可能感觉更类似于 Java 接口。
- en: 'Lets try to define our shape program using protocols:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用协议定义我们的形状程序：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, we have defined a protocol and it is called shaped and everything that
    implements this protocol must implement the following two functions: `perimeter`
    and `area`.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个协议，它被称为 shaped，并且实现这个协议的所有东西都必须实现以下两个函数：`perimeter` 和 `area`。
- en: There are a number of ways to implement a protocol; one interesting feature
    is that you can even extend Java classes to implement a protocol without an access
    to the Java source and without having to recompile anything.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 实现协议有多种方法；一个有趣的特点是，你甚至可以在没有访问 Java 源代码的情况下扩展 Java 类以实现协议，而且无需重新编译任何东西。
- en: Let's start by creating a record that implements the type.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个实现该类型的记录开始。
- en: Records in Clojure
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Clojure 中的记录
- en: Records work exactly like maps, but they are much faster if you stick to the
    predefined keys. Defining a record is similar to defining a class, Clojure knows
    beforehand about the fields that the record will have, so it can generate byte
    code on the fly and the code that uses the records is much faster.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 记录的工作方式与映射完全一样，但如果你坚持使用预定义的键，它们会更快。定义记录类似于定义类，Clojure 在事先就知道记录将有哪些字段，因此它可以即时生成字节码，使用记录的代码会更快。
- en: 'Lets define a `Square` record, as shown:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个 `Square` 记录，如下所示：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, we are defining the `Square` record and it has the following properties:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了 `Square` 记录，并具有以下属性：
- en: It has only one field, `size`; this is going to work as a map with only the
    side key
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只有一个字段，`size`；这将作为一个只有边键的映射来工作
- en: It implements the `Shape` protocol
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它实现了 `Shape` 协议
- en: 'Lets have a look at how a record is instantiated and how we can use it:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看记录是如何实例化的，以及我们如何使用它：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you can see it works exactly like a map, you can even associate things to
    it:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，它的工作方式与映射完全一样，你甚至可以将其与事物关联：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The downside of doing this is that we no longer have the performance guarantees
    that we had when defining just the record fields; nonetheless, it is a great way
    of giving some structure to our code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的缺点是，我们不再有定义记录字段时拥有的性能保证；尽管如此，这仍然是一种给我们的代码提供一些结构的好方法。
- en: 'We still have to check how we can use our perimeter and area functions, it
    is pretty simple. Let''s have a look:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要检查我们如何使用我们的周长和面积函数，这很简单。让我们看看：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Just to continue with the example, let''s define the `Circle` record:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了继续这个例子，让我们定义 `Circle` 记录：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: One of the promises was that we will be able to extend our existing records
    and types without having to touch the current code. Well, lets keep to that promise
    and check how to extend our records without having to touch existing code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个承诺是我们将能够扩展现有的记录和类型，而无需触及当前代码。好吧，让我们遵守这个承诺，并检查如何在不触及现有代码的情况下扩展我们的记录。
- en: 'Imagine, we need to add a predicate telling us whether a shape has an area
    or not; we might then define the next protocol, as shown:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们需要添加一个谓词来告诉我们一个形状是否有面积；然后我们可以定义下一个协议，如下所示：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s get directly to the extend type, which is going to help us define this
    `num-sides` function for our old protocols. Note that with `extend-type` we can
    even define functions for existing Java types:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接进入扩展类型，这将帮助我们为我们的旧协议定义 `num-sides` 函数。注意，使用 `extend-type`，我们甚至可以为现有的 Java
    类型定义函数：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Protocols become much more interesting when you extend them for Java types.
    Lets create a protocol that includes some functions for list like structures:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为 Java 类型扩展协议时，协议变得更有趣。让我们创建一个包括一些列表结构函数的协议：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And now you can use the positive values, negative values and `non-zero-values`
    with anything that extends from `java.util.List`, including Clojure''s vectors:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用正数、负数和 `non-zero-values` 与从 `java.util.List` 扩展的任何东西一起使用，包括 Clojure 的向量：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It might not be very exciting to extend `java.util.List`, since you can define
    these three as functions and it works the same way but you can extend any custom
    Java type with this mechanism.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 `java.util.List` 可能不会很有趣，因为你可以将这三个定义为函数，并且它们以相同的方式工作，但你可以用这种机制扩展任何自定义的 Java
    类型。
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Now we understand Clojure''s way a little bit better and we have a better grasp
    of what to look for when we need polymorphism. We understand that when needing
    a polymorphic function we have several options:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 Clojure 的方式有了更好的理解，并且我们对在需要多态时应该寻找什么有了更好的把握。我们了解到，当需要多态函数时，我们有几种选择：
- en: We can implement multimethods if we need a highly customized dispatching mechanism
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们需要一个高度定制的调度机制，我们可以实现多方法。
- en: We can implement multimethods if we need to define a complex inheritance structure
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们需要定义一个复杂的继承结构，我们可以实现多方法。
- en: We can implement a protocol and define a custom type that implements that protocol
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以实现一个协议并定义一个实现该协议的自定义类型
- en: We can define a protocol and extend existing Java or Clojure types with our
    custom functions for each type
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以定义一个协议，并使用我们为每个类型定义的自定义函数扩展现有的 Java 或 Clojure 类型。
- en: Polymorphism in Clojure is very powerful. It allows you to extend the functionality
    of Clojure or Java types that already exist; it feels like adding methods to an
    interface. The best thing about it is that you don't need to redefine or recompile
    anything.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 中的多态非常强大。它允许你扩展已经存在的 Clojure 或 Java 类型的功能；感觉就像向接口添加方法一样。最好的是，你不需要重新定义或重新编译任何东西。
- en: In the next chapter, we will talk about concurrency—one of the key features
    of Clojure. We will learn about the idea of what the identity and values are and
    how those key concepts make writing concurrent programs much easier.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论并发——Clojure 的关键特性之一。我们将了解身份和值的概念以及这些关键概念如何使编写并发程序变得更加容易。
