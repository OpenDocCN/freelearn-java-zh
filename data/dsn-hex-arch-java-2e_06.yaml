- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Building the Domain Hexagon
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建领域六边形
- en: In previous chapters, we had the opportunity to employ **Domain-Driven Design**
    (**DDD**) techniques, such as entities and value objects, to create a domain model.
    However, until now, we haven’t touched on organizing packages, classes, and modules
    to fit the hexagonal architecture purpose.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们有机会使用**领域驱动设计**（**DDD**）技术，如实体和值对象，来创建领域模型。然而，直到现在，我们还没有涉及到组织包、类和模块以适应六边形架构的目的。
- en: The **Domain hexagon** is the place to start developing a hexagonal application.
    Based on the domain, we derive all other hexagons. We can say that the Domain
    hexagon is the brain of hexagonal systems because the core fundamental business
    logic resides in such a hexagon.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**领域六边形**是开始开发六边形应用程序的地方。基于领域，我们推导出所有其他六边形。我们可以这样说，领域六边形是六边形系统的核心，因为核心的基本业务逻辑就驻留在这样的六边形中。'
- en: So, in this chapter, we will start to explore how to structure a hexagonal application
    project from the bottom using a Java module approach. This will help us ensure
    better encapsulation and unit testing to validate our code as we develop the Domain
    hexagon components.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将从底层开始探索如何使用Java模块方法来构建六边形应用程序项目。这将帮助我们确保更好的封装和单元测试，以验证我们在开发领域六边形组件时的代码。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Bootstrapping the Domain hexagon
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引导构建领域六边形
- en: Understanding the problem domain
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解问题域
- en: Defining value objects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义值对象
- en: Defining entities and specifications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义实体和规范
- en: Defining domain services
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义领域服务
- en: Testing the Domain hexagon
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试领域六边形
- en: By the end of this chapter, you will have acquired a hands-on perspective on
    the development of all the Domain hexagon components. This knowledge will enable
    you to take care of all the details regarding the structure and arrangement of
    classes and packages in the Domain hexagon.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将获得关于所有领域六边形组件开发的实际操作视角。这些知识将使你能够处理领域六边形中关于类和包的结构和排列的所有细节。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To compile and run the code examples presented in this chapter, you will need
    the latest **Java SE Development Kit** and **Maven 3.8** installed on your computer.
    They are all available for Linux, Mac, and Windows operating systems.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译和运行本章中展示的代码示例，你需要在你的计算机上安装最新的**Java SE开发工具包**和**Maven 3.8**。它们都适用于Linux、Mac和Windows操作系统。
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter06).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章的代码文件，地址为[https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter06)。
- en: Bootstrapping the Domain hexagon
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引导构建领域六边形
- en: The hexagonal application project that we will start in this chapter is actually
    a continuation of the topology and inventory system that we’ve developed in the
    last few chapters. However, the difference here is that we will augment some of
    the system’s capabilities and use the **Java Platform Module System** (**JPMS**)
    to encapsulate the Domain hexagon in a Java module.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将开始构建的六边形应用程序项目实际上是我们在上一章中开发的拓扑和库存系统的延续。然而，这里的区别在于我们将增强系统的一些功能，并使用**Java平台模块系统**（**JPMS**）来封装领域六边形为一个Java模块。
- en: 'To get started with bootstrapping the Domain hexagon, let’s create a multi-module
    Maven project, as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始引导构建领域六边形，让我们创建一个多模块Maven项目，如下所示：
- en: 'First, we will create a parent project called `topology-inventory` by executing
    the following code:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将通过执行以下代码创建一个名为`topology-inventory`的父项目：
- en: '[PRE0]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we create a module for the Domain hexagon, like this:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们为领域六边形创建一个模块，如下所示：
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After executing the `mvn` commands to create a `topology-inventory` Maven root
    project and then the `domain` module, you’ll have a directory tree similar to
    the one shown here:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行`mvn`命令创建`topology-inventory` Maven根项目和`domain`模块之后，你将拥有一个类似于以下所示的目录树：
- en: '![Figure 6.1 – The directory structure of the Domain hexagon](img/B19777_06_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 领域六边形的目录结构](img/B19777_06_01.jpg)'
- en: Figure 6.1 – The directory structure of the Domain hexagon
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 领域六边形的目录结构
- en: Since the release of `module-info.java` module descriptor file into a Java project
    root directory. When you create a Java module using this file, you close the access
    to all public packages in that module. To make public packages accessible to other
    modules, you need to export the desired packages in the module descriptor file.
    There are other interesting things to say about Java modules, but we have reserved
    them for [*Chapter 9*](B19777_09.xhtml#_idTextAnchor192), *Applying Dependency
    Inversion with* *Java Modules*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 自从将`module-info.java`模块描述符文件发布到Java项目根目录以来。当你使用此文件创建Java模块时，你将关闭对该模块中所有公共包的访问。为了使公共包对其他模块可访问，你需要在模块描述符文件中导出所需的包。关于Java模块还有其他有趣的事情要说，但我们已经将它们留给了[*第9章*](B19777_09.xhtml#_idTextAnchor192)，*使用Java模块应用依赖倒置*。
- en: 'To transform the Domain hexagon in a Java module, you need to create a module
    descriptor file at `topology-inventory/domain/src/java/module-info.java`, as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要将领域六边形转换为Java模块，你需要在`topology-inventory/domain/src/java/module-info.java`创建一个模块描述符文件，如下所示：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Because we’re not yet allowing access to any public packages, nor depending
    on other modules, we will leave the `module-info.java` file with no entries.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们尚未允许访问任何公共包，也没有依赖于其他模块，我们将`module-info.java`文件留空。
- en: 'In order to make not just the Domain but also all other hexagons with less
    verbose classes, we’ll add the `lombok` library to the `pom.xml` project root,
    as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使领域以及所有其他具有更简洁类别的六边形都更加简洁，我们将`lombok`库添加到`pom.xml`项目根目录，如下所示：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It’s also important to configure the annotation processing paths for `lombok`;
    otherwise, there will be compilation failures. You can do this by running the
    following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，配置`lombok`的注解处理路径也很重要；否则，将出现编译错误。你可以通过运行以下代码来完成此操作：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It’s inside the `maven-compile-plugin` plugin block that we add the configuration
    for `annotationProcessorPaths`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在`maven-compile-plugin`插件块内部，我们添加了`annotationProcessorPaths`的配置。
- en: 'Because we add the lombok dependency, we need to update the domain’s `module-info.java`
    file, like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们添加了lombok依赖项，我们需要更新域的`module-info.java`文件，如下所示：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We are now ready to start developing the Domain hexagon on top of our fully
    modularized structure. Let’s move on to understand the problem domain of our enhanced
    topology and inventory system.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已准备好开始在完全模块化的结构之上开发领域六边形。让我们继续了解我们增强拓扑和库存系统的问题域。
- en: Understanding the problem domain
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解问题域
- en: 'We will start modeling the problem domain by considering the fact that a core
    router can connect to both core and edge routers. Edge routers, in turn, connect
    to switches and their networks. The following diagram depicts this scenario:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过考虑以下事实来开始建模问题域：核心路由器可以连接到核心路由器和边缘路由器。反过来，边缘路由器连接到交换机和它们的网络。以下图表描述了这一场景：
- en: '![Figure 6.2 – A use case for the topology and inventory network system](img/B19777_06_02.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – 拓扑和库存网络系统的用例](img/B19777_06_02.jpg)'
- en: Figure 6.2 – A use case for the topology and inventory network system
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 拓扑和库存网络系统的用例
- en: Core routers are faster and deal with high traffic loads, and they don’t deal
    directly with the traffic generated from a switch and its networks. Conversely,
    edge routers deal directly with traffic generated by a switch and its networks.
    In our scenario, an edge router is not allowed to connect to other edge routers;
    it can only connect to core routers and switches. A switch can have multiple networks.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 核心路由器速度更快，处理高流量负载，并且它们不直接处理来自交换机和其网络的流量。相反，边缘路由器直接处理来自交换机和其网络的流量。在我们的场景中，边缘路由器不允许连接到其他边缘路由器；它只能连接到核心路由器和交换机。交换机可以有多个网络。
- en: 'Bear in mind that’s a particular arrangement established for our scenario.
    By no means does it represent a strict rule of how to organize network components.
    Here is a diagram showing the arrangement of our scenario:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这是一个为我们的场景建立的特定安排。这绝对不代表组织网络组件的严格规则。以下是我们的场景安排的图表：
- en: '![Figure 6.3 – A use case for the topology and inventory network system (continued)](img/B19777_06_03.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – 拓扑和库存网络系统的用例（续）](img/B19777_06_03.jpg)'
- en: Figure 6.3 – A use case for the topology and inventory network system (continued)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 拓扑和库存网络系统的用例（续）
- en: The topology and inventory system’s purpose is to allow users to view and manage
    network assets. By network assets, we mean routers, switches, and networks – routers
    and switches being physical assets, and networks being logical assets provided
    by switches. Those assets are spread across different locations, and the system
    should show the interconnectivity between assets and their sites. A location is
    composed of the complete address, along with its latitude and longitude.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 拓扑和库存系统的目的是允许用户查看和管理网络资产。通过网络资产，我们指的是路由器、交换机和网络——路由器和交换机是物理资产，而网络是由交换机提供的逻辑资产。这些资产分布在不同的位置，系统应显示资产及其站点之间的互连性。位置由完整的地址以及其纬度和经度组成。
- en: The management part is based on nothing more than **Create, Read, Update, Delete**
    (**CRUD**)-like operations, allowing users to exert control over the topology
    and inventory systems’ data.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 管理部分仅基于类似于**创建、读取、更新、删除**（**CRUD**）的操作，使用户能够控制拓扑和库存系统数据。
- en: Our approach to building such a system is to first create a Domain hexagon,
    using a domain model containing the operations and rules required to fulfill the
    system’s purpose at its highest level. Our intention at the highest level is to
    validate business ideas straight on the Domain hexagon without the aid of things
    present on the Application and Framework hexagons. As things move onto these hexagons,
    they tend to become more technology-specific, operating at a lower level, because
    technology-specific things are far away from the Domain hexagon. The degree to
    which we maintain the core system functionalities within the Domain hexagon heavily
    influences how loosely coupled the hexagonal system will be.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建此类系统的方法是首先创建一个领域六边形，使用包含实现系统最高层目的所需操作和规则的领域模型。在最高层，我们的意图是直接在领域六边形上验证商业想法，而不需要应用和框架六边形上现有事物的帮助。随着事物移动到这些六边形，它们往往会变得更加技术特定，处于较低层次，因为技术特定的事物离领域六边形很远。我们在领域六边形内保持核心系统功能程度的程度，极大地影响了六边形系统的松散耦合程度。
- en: To validate the methods and classes of the Domain hexagon, we’ll create unit
    tests to ensure domain operations work as expected. This will give us a degree
    of assurance to move forward and use these operations on the Application hexagon.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证领域六边形的方法和类，我们将创建单元测试以确保领域操作按预期工作。这将给我们一定的信心继续前进，并在应用六边形上使用这些操作。
- en: Next, we will start to build the hexagonal system foundation with value objects,
    the architecture components that lets us create a domain model to better express
    the problem domain.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开始使用价值对象构建六边形系统的基础，这些是架构组件，使我们能够创建领域模型以更好地表达问题域。
- en: Defining value objects
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义价值对象
- en: As we have already seen in [*Chapter 2*](B19777_02.xhtml#_idTextAnchor038),
    *Wrapping Business Rules inside Domain Hexagon*, entities are the elements we
    use to classify system components that have an identity. Conversely, the value
    objects don’t have an identity. We use value objects to describe those system
    parts where there is no need to define an identity. Then, we have aggregates that
    serve to encapsulate the objects’ related entities and values.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第二章*](B19777_02.xhtml#_idTextAnchor038)中已经看到的，“在领域六边形内封装业务规则”，实体是我们用来分类具有身份的系统组件的元素。相反，价值对象没有身份。我们使用价值对象来描述那些不需要定义身份的系统部分。然后，我们有聚合体，用于封装对象的关联实体和值。
- en: 'I recommend starting by creating value objects first because they are like
    the building blocks, the raw material we’ll use to build more elaborate value
    objects, and – most importantly – the entities. Now, we’ll add all the volume
    object classes on the Domain hexagon module, which were created in the previous
    section when we bootstrapped the Domain hexagon. We’ll use the following steps
    to define the value objects:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议首先创建价值对象，因为它们就像构建块，是我们将用来构建更复杂价值对象和——最重要的是——实体的原材料。现在，我们将添加在上一节中当我们启动领域六边形时创建的所有领域六边形模块上的体积对象类。我们将使用以下步骤来定义价值对象：
- en: 'Let’s start with the `Id` value object class, as follows:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从`Id`价值对象类开始，如下所示：
- en: '[PRE6]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code is very straightforward, with just one `UUID` attribute that
    we use to store the `id` value. We will use the `withId` static method to create
    `Id` instances with a given string. If we want to create something new, we should
    use the `withoutId` static method, which randomly generates IDs.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码非常直接，只有一个`UUID`属性，我们用它来存储`id`值。我们将使用`withId`静态方法来创建具有给定字符串的`Id`实例。如果我们想创建新的东西，我们应该使用`withoutId`静态方法，它随机生成ID。
- en: 'The `Vendor` `enum` value object class, as we’ll see in the *Defining entities
    and specifications* section, is used on both router and switch entity classes.
    You can see this class in the following code snippet:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如我们在*定义实体和规范*部分中将要看到的，`Vendor` `enum`值对象类在路由器和交换机实体类中都使用。您可以在以下代码片段中看到此类：
- en: '[PRE7]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We will model the `Vendor` class as `enum` to let us easily illustrate the system
    features.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将`Vendor`类建模为`enum`，这样我们可以轻松地展示系统功能。
- en: 'We will do the same thing with the `Model` `enum`, as follows:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将对`Model` `enum`做同样的事情，如下所示：
- en: '[PRE8]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For `Protocol`, we create an `enum` value object to represent both the **Internet
    Protocol version 4** (**IPv4**) and **IP version 6** (**IPv6**) protocols, as
    follows:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`Protocol`，我们创建一个`enum`值对象来表示**互联网协议版本4**（**IPv4**）和**IP版本6**（**IPv6**）协议，如下所示：
- en: '[PRE9]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To help us clearly define which kind of router we’re dealing with, we’ll create
    a `RouterType` `enum`, as follows:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了帮助我们清楚地定义我们正在处理哪种类型的路由器，我们将创建一个`RouterType` `enum`，如下所示：
- en: '[PRE10]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The same idea is also applied to available switch types, as we can see here:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样的想法也应用于可用的交换机类型，如下所示：
- en: '[PRE11]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As every router and switch has a location, we have to create a `Location` value
    object class, as follows:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于每个路由器和交换机都有一个位置，我们必须创建一个`Location`值对象类，如下所示：
- en: '[PRE12]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We introduce the `Location` value object with attributes that allow us to identify
    an address uniquely. That’s why we also have `latitude` and `longitude` as class
    attributes.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们引入了具有允许我们唯一识别地址的属性的`Location`值对象。这就是为什么我们也有`latitude`和`longitude`作为类属性。
- en: 'The value objects we just created are the most important ones because they
    are the basic building blocks for the other value objects and entities that comprise
    the entire system. Next, we can create more elaborate value objects based on those
    we just created, as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的值对象是最重要的，因为它们是其他值对象和实体的基本构建块，这些实体构成了整个系统。接下来，我们可以根据我们刚刚创建的创建更复杂的价值对象，如下所示：
- en: 'Let’s start with the `IP` value object, as illustrated in the following code
    snippet:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从以下代码片段中所示的`IP`值对象开始：
- en: '[PRE13]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With the `IP` value object class, we can create both IPv4 and IPv6 addresses.
    The constraint that checks which protocol to use is within the value object constructor.
    The logic we use to validate the IP address is a simple one, just for the sake
    of our example. For a more comprehensive validation, we can use the `InetAddressValidator`
    class from the `commons-validator` library.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`IP`值对象类，我们可以创建IPv4和IPv6地址。检查使用哪个协议的约束在值对象构造函数内部。我们用来验证IP地址的逻辑非常简单，只是为了我们的示例。为了更全面的验证，我们可以使用`commons-validator`库中的`InetAddressValidator`类。
- en: 'Then, we create a value object to represent networks that will be added to
    a switch, as follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个值对象来表示将被添加到交换机中的网络，如下所示：
- en: '[PRE14]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We model the `Network` value object to store the IP address, network name, and
    `10.0.0.0`) is the network base IP address. The second number (for example, `24`)
    is used to determine the network subnet mask and how many IP addresses will be
    available in this network. In the `Network` class, we refer to the second CIDR
    number.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将`Network`值对象建模为存储IP地址、网络名称和`10.0.0.0`是网络基本IP地址。第二个数字（例如，`24`）用于确定网络子网掩码以及在这个网络中可用的IP地址数量。在`Network`类中，我们引用第二个CIDR数字。
- en: Inside the `Network` constructor, we add the constraint to validate whether
    the CIDR value is valid.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`Network`构造函数内部，我们添加了约束来验证CIDR值是否有效。
- en: 'Finally, you’ll have a package and class structure similar to the one shown
    in the following screenshot:'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，你将有一个类似于以下屏幕截图所示的包和类结构：
- en: '![Figure 6.4 – The directory structure of the value objects](img/B19777_06_04.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4 – 值对象的目录结构](img/B19777_06_04.jpg)'
- en: Figure 6.4 – The directory structure of the value objects
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 值对象的目录结构
- en: Now that we have looked at value objects, which are our Domain hexagon’s building
    blocks, we can move on to creating entities and their specifications.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了值对象，它们是我们领域六边形的构建块，我们可以继续创建实体及其规范。
- en: Defining entities and specifications
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义实体和规范
- en: Once we have created all the value objects, we can start to think about how
    to represent the elements in entities that have an identity. Also, we need to
    develop specifications to define business rules that govern constraints that the
    entities should obey.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了所有值对象，我们就可以开始考虑如何在具有身份的实体中表示元素。此外，我们需要开发规范来定义规范业务规则，这些规则控制实体应遵守的约束。
- en: Remember that what characterizes an entity is its identity and the presence
    of business rules and data. In the topology and inventory system, we have as entities
    `Equipment`, `Router`, and `Switch`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，定义实体的特征是其身份、业务规则和数据的存在。在拓扑和库存系统中，我们有`Equipment`、`Router`和`Switch`作为实体。
- en: Inside the `domain` Java module we created previously, we’ll add the entity
    classes within a package called `entity`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前创建的`domain` Java模块中，我们将在名为`entity`的包内添加实体类。
- en: The Equipment and Router abstract entities
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备和路由器抽象实体
- en: 'Routers and switches are different types of network equipment, so we’ll start
    by creating an `Equipment` abstract class, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器和交换机是不同类型的网络设备，因此我们将首先创建一个`Equipment`抽象类，如下所示：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Most of the value objects created in the previous section are present here in
    the `Equipment` entity. We use the predicate provided by `getVendorTypePredicate`
    to apply the filters that only retrieve a specific vendor’s equipment.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中创建的大多数值对象都包含在`Equipment`实体中。我们使用`getVendorTypePredicate`提供的谓词来应用过滤器，只检索特定供应商的设备。
- en: 'Deriving from `Equipment`, we create a `Router` abstract class, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Equipment`派生，我们创建了一个`Router`抽象类，如下所示：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `Router` abstract class defines predicates common to either core or edge
    routers. We use the predicate provided by `getRouterTypePredicate` to apply filters
    that retrieve only routers of a specific type.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Router`抽象类定义了核心或边缘路由器共有的谓词。我们使用`getRouterTypePredicate`提供的谓词来应用过滤器，只检索特定类型的路由器。'
- en: 'Here, we have more two predicates from the `Router` abstract class:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有来自`Router`抽象类的两个更多谓词：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We use the `getModelPredicate` and `getCountryPredicate` predicates to retrieve
    routers of a specific model or particular country.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`getModelPredicate`和`getCountryPredicate`谓词来检索特定型号或特定国家的路由器。
- en: The `Router` abstract class provides the common attributes shared by core and
    edge routers. It’s in the `Router` class that we introduce the predicates to serve
    as filters when querying lists of routers.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`Router`抽象类提供了核心和边缘路由器共享的常见属性。在`Router`类中，我们引入了谓词，用作查询路由器列表时的过滤器。'
- en: The core router entity and its specifications
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心路由器实体及其规范
- en: 'Moving ahead, let’s implement the `CoreRouter` entity class, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们实现`CoreRouter`实体类，如下所示：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Core routers can be connected to other core and edge routers. To allow such
    behavior in the `CoreRouter` class, we create an `addRouter` method receiving
    the `Router` abstract type as a parameter. We also use the `SameCountrySpec` specification
    to make sure that edge routers are in the same country as the core router. This
    rule doesn’t apply when we try to connect a core router to another core router.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 核心路由器可以连接到其他核心和边缘路由器。为了在`CoreRouter`类中允许这种行为，我们创建了一个接收`Router`抽象类型作为参数的`addRouter`方法。我们还使用`SameCountrySpec`规范来确保边缘路由器与核心路由器位于同一国家。当我们尝试将核心路由器连接到另一个核心路由器时，此规则不适用。
- en: Next, we have the `SameIPSpec` specification to confirm that routers don’t have
    the same IP address. We make the business rules more explicit and the code easier
    to read and understand by using specifications. You can write this code without
    any specification and just throw `if`-`else` conditions with the necessary variables,
    but the mental load required to understand the code for anyone not acquainted
    with it would probably be higher.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`SameIPSpec`规范来确认路由器没有相同的IP地址。通过使用规范，我们使业务规则更加明确，代码更容易阅读和理解。你可以不使用任何规范，只使用必要的变量抛出`if-else`条件，但对于不熟悉它的人来说，理解代码所需的认知负荷可能会更高。
- en: 'Here, we have the `removeRouter` method:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有`removeRouter`方法：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For the `removeRouter` method, we have the `EmptyRouterSpec` specification,
    which prevents us from removing a router that has any other routers connected
    to it. The `EmptySwitchSpec` specification checks whether a router has any switch
    connected to it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`removeRouter`方法，我们有`EmptyRouterSpec`规范，它防止我们移除任何其他路由器连接到它的路由器。`EmptySwitchSpec`规范检查路由器是否连接了任何交换机。
- en: Core routers deal only with other routers. That’s why there is no reference
    to switches in the `CoreRouter` entity class.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 核心路由器只处理其他路由器。这就是为什么在 `CoreRouter` 实体类中没有交换机的引用。
- en: Note that the two methods, `addRouter` and `removeRouter`, operate directly
    on a `Router` type parameter, using domain specifications to check that there
    are no constraint violations before making any changes. Let’s closely examine
    the specifications used by the `CoreRouter` entity, starting with the `SameCountrySpec`
    specification. This specification makes sure that edge routers are always from
    the same country as their core routers.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，两个方法 `addRouter` 和 `removeRouter` 直接在 `Router` 类型参数上操作，使用域规范来检查在做出任何更改之前没有约束违规。让我们仔细检查
    `CoreRouter` 实体使用的规范，从 `SameCountrySpec` 规范开始。这个规范确保边缘路由器始终来自与其核心路由器相同的国家。
- en: 'The `package` specification is where we’ll put all the specifications, so that’s
    the package in which we’ll put the `SameCountrySpec` specification, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`package` 规范是我们将放置所有规范的地方，因此我们将 `SameCountrySpec` 规范放在这个包中，如下所示：'
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `SameCountrySpec` constructor receives an `Equipment` object, which we use
    to initialize the `equipment` private field.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`SameCountrySpec` 构造函数接收一个 `Equipment` 对象，我们使用它来初始化 `equipment` 私有字段。'
- en: 'Continuing with the `SameCountrySpec` implementation, we override the `isSatisfiedBy`
    method, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 继续实现 `SameCountrySpec`，我们重写 `isSatisfiedBy` 方法，如下所示：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `SameCountrySpec` implementation does not apply to core routers. That’s
    why we always return `true` when the object is a `CoreRouter` entity. Otherwise,
    we proceed with the validation to check that the equipment is not in a different
    country.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`SameCountrySpec` 实现不适用于核心路由器。这就是为什么当对象是 `CoreRouter` 实体时，我们总是返回 `true`。否则，我们继续进行验证，检查设备是否不在不同的国家。'
- en: 'Next, we override the `check` method, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们重写 `check` 方法，如下所示：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We use the `check` method to run the specification. Other classes can call this
    method to verify whether the specification is met or not.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `check` 方法来运行规范。其他类可以调用此方法来验证规范是否得到满足。
- en: It’s possible to connect two core routers from different countries. What’s not
    possible, as stated previously, is to connect edge and core routers that are not
    present in the same country. Note that this specification is based on the `Equipment`
    type, allowing us to reuse this specification not just with routers but also on
    switches.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 可以连接来自不同国家的两个核心路由器。然而，如前所述，不可能连接不在同一国家的边缘和核心路由器。请注意，这个规范基于 `Equipment` 类型，允许我们不仅与路由器，而且与交换机重用这个规范。
- en: 'The following `SameIpSpec` specification ensures that no equipment has the
    same IP address:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `SameIpSpec` 规范确保没有设备具有相同的 IP 地址：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `SameCountrySpec` and `SameIpSpec` specifications are used by the `addRouter`
    method to ensure that no constraints are violated before adding any router to
    a core router.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`SameCountrySpec` 和 `SameIpSpec` 规范被 `addRouter` 方法使用，以确保在向核心路由器添加任何路由器之前不会违反任何约束。'
- en: 'Moving on, we have the `EmptyRouterSpec` and `EmptySwitchSpec` specifications.
    Before a router is removed, we must make sure that no other routers or switches
    are connected to such a router. These are very simple specifications. Let’s start
    by looking at the `EmptyRouterSpec` specification, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进，我们有 `EmptyRouterSpec` 和 `EmptySwitchSpec` 规范。在删除路由器之前，我们必须确保没有其他路由器或交换机连接到这样的路由器。这些规范非常简单。让我们首先查看
    `EmptyRouterSpec` 规范，如下所示：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This specification is based on the `CoreRouter` type because only core routers
    can be connected to other core and edge routers.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规范基于 `CoreRouter` 类型，因为只有核心路由器可以连接到其他核心和边缘路由器。
- en: 'The `EmptySwitchSpec` class is given as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`EmptySwitchSpec` 类如下所示：'
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `EmptySwitchSpec` class is very similar to the `EmptyRouterSpec` class.
    The difference, though, is that only edge routers can have switches. That’s why
    this specification is based on the `EdgeRouter` type.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`EmptySwitchSpec` 类与 `EmptyRouterSpec` 类非常相似。然而，区别在于只有边缘路由器可以拥有交换机。这就是为什么这个规范基于
    `EdgeRouter` 类型。'
- en: Edge router entity and its specifications
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 边缘路由实体及其规范
- en: 'Now that we’re done with the `CoreRouter` entity and its specifications, we
    can move on to create an `EdgeRouter` entity class, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了 `CoreRouter` 实体及其规范，我们可以继续创建 `EdgeRouter` 实体类，如下所示：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `addSwitch` method’s purpose is to connect switches to edge routers. Also,
    in the `EdgeRouter` class, we reuse the same `SameCountrySpec` and `SameIpSpec`
    specifications used when implementing the `CoreRouter` class.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`addSwitch`方法的目的是将开关连接到边缘路由器。此外，在`EdgeRouter`类中，我们重用了在实现`CoreRouter`类时使用的相同的`SameCountrySpec`和`SameIpSpec`规范。'
- en: 'Next, we have the `removeSwitch` method from the `EdgeRouter` class, as illustrated
    in the following code snippet:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`removeSwitch`方法，如下面的代码片段所示：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For the `removeSwitch` method, we have the `EmptyNetworkSpec` specification
    to ensure that a switch has no networks connected to it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`removeSwitch`方法，我们有`EmptyNetworkSpec`规范来确保开关没有连接任何网络。
- en: As we did in the `CoreRouter` class, we use the `SameCountrySpec` and `SameIpSpec`
    specifications. However, the context is different because we’re adding a switch
    to a router. The only new specification used in the `EdgeRouter` class is the
    `EmptyNetworkSpec` specification, which is used to ensure all networks are removed
    from a switch before it can be removed from an edge router.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在`CoreRouter`类中所做的那样，我们使用了`SameCountrySpec`和`SameIpSpec`规范。然而，上下文是不同的，因为我们正在将一个开关添加到路由器中。在`EdgeRouter`类中使用的唯一新规范是`EmptyNetworkSpec`规范，它用于确保在从边缘路由器中删除之前，所有网络都已从开关中删除。
- en: Switch entity and its specifications
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开关实体及其规范
- en: 'What’s left now is the implementation of the `Switch` entity class and its
    related specifications. The ideas we use here are similar to what we applied in
    core and edge router entities. Let’s start by creating a `Switch` entity class,
    as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的是`Switch`实体类及其相关规范的实现。我们在这里使用的方法与我们在核心和边缘路由器实体中应用的方法类似。让我们首先创建一个`Switch`实体类，如下所示：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We start the `Switch` class implementation by creating a `getSwitchTypePredicate`
    method predicate, which we used to filter switch collections by the switch type.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建一个`getSwitchTypePredicate`方法谓词来开始`Switch`类的实现，我们使用这个谓词来根据开关类型过滤开关集合。
- en: 'Next, we create an `addNetworkToSwitch` method, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个`addNetworkToSwitch`方法，如下所示：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `addNetworkToSwitch` method receives a `Network` type parameter, which we
    use to add a network to a switch. However, before adding the network, we need
    to check some constraints expressed by the specifications. The first one is the
    `NetworkAvailabilitySpec` specification, which verifies whether the network already
    exists on the switch. Then, we use the `CIDRSpecification` specification to check
    whether the network CIDR is valid. Finally, we use the `NetworkAmountSpec` specification
    to validate whether we have surpassed the maximum networks allowed on the switch.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`addNetworkToSwitch`方法接收一个`Network`类型参数，我们使用它将网络添加到开关中。然而，在添加网络之前，我们需要检查由规范表达的一些约束。第一个是`NetworkAvailabilitySpec`规范，它验证网络是否已经存在于开关上。然后，我们使用`CIDRSpecification`规范来检查网络CIDR是否有效。最后，我们使用`NetworkAmountSpec`规范来验证我们是否已经超过了开关上允许的最大网络数量。'
- en: 'Next, we have the `removeNetworkFromSwitch` method, as illustrated in the following
    code snippet:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`removeNetworkFromSwitch`方法，如下面的代码片段所示：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As there are no constraints to remove networks from a switch, this method does
    not use any specifications.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有约束来从开关中删除网络，这个方法没有使用任何规范。
- en: To summarize, right at the beginning of the `Switch` class, we declared a predicate
    to allow us to filter switch collections based on switch types (`LAYER2` and `LAYER3`).
    The `addNetworktoSwitch` method uses the `NetworkAvailabilitySpec`, `NetworkAmountSpec`,
    and `CIDRSpecification` specifications that we already defined in [*Chapter 2*](B19777_02.xhtml#_idTextAnchor038),
    *Wrapping Business Rules inside Domain Hexagon*. If none of these specifications’
    constraints are violated, a `Network` object will be added to the switch.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，在`Switch`类的开头，我们声明了一个谓词，以便我们可以根据开关类型（`LAYER2`和`LAYER3`）过滤开关集合。`addNetworktoSwitch`方法使用了我们在[*第2章*](B19777_02.xhtml#_idTextAnchor038)，*在领域六边形内封装业务规则*中已经定义的`NetworkAvailabilitySpec`、`NetworkAmountSpec`和`CIDRSpecification`规范。如果这些规范的约束没有被违反，一个`Network`对象将被添加到开关中。
- en: Finally, we have the `removeNetworkFromSwitch` method, which doesn’t look at
    any specification to remove networks from a switch.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`removeNetworkFromSwitch`方法，它不会查看任何规范来从开关中删除网络。
- en: With the `Switch` entity implementation, we conclude the modeling of the entities
    and specifications required to fulfill the topology and inventory system’s purpose.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`Switch`实体实现，我们完成了满足拓扑和库存系统目的的实体和规范的建模。
- en: 'For all the entities, you should have a package and class structure similar
    to this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有实体，你应该有一个类似于以下的包和类结构：
- en: '![Figure 6.5 – The directory structure of entities](img/B19777_06_05.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5 – 实体的目录结构](img/B19777_06_05.jpg)'
- en: Figure 6.5 – The directory structure of entities
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – 实体的目录结构
- en: As we can see in the preceding screenshot, we put all the entities inside the
    `entity` package.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前一个屏幕截图所示，我们将所有实体放在了`entity`包中。
- en: 'And for all the specifications, the package and class structure should look
    like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有规范，包和类结构应该如下所示：
- en: '![Figure 6.6 – The directory structure of specifications](img/B19777_06_06.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图6.6 – 规范的目录结构](img/B19777_06_06.jpg)'
- en: Figure 6.6 – The directory structure of specifications
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 – 规范的目录结构
- en: Some of the specifications used by the topology and inventory system were already
    created in [*Chapter 2*](B19777_02.xhtml#_idTextAnchor038), *Wrapping Business
    Rules inside Domain Hexagon*. The remaining specifications are the ones we created
    in this section.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点和库存系统中使用的某些规范已在[*第2章*](B19777_02.xhtml#_idTextAnchor038)中创建，*将业务规则封装在领域六边形内*。其余规范是我们在本节中创建的。
- en: Based on the entities we have just created, we can now think of tasks that are
    not directly related to such entities. That is the case of services that work
    as an alternative to providing capabilities outside domain entities. Let’s now
    see how to implement services that let us find, filter, and retrieve data from
    the system.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 基于我们刚刚创建的实体，我们现在可以思考与这些实体不直接相关的任务。这就是作为提供领域实体外能力的替代方案工作的服务的情况。现在让我们看看如何实现允许我们查找、过滤和从系统中检索数据的服务。
- en: Defining domain services
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义领域服务
- en: The topology and inventory system is about the visualization and management
    of network assets, so we need to enable a user to handle collections of such network
    assets. One way to do that is through services. With services, we can define behaviors
    to deal with system entities and value objects.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 拓扑和库存系统是关于网络资产的可视化和管理，因此我们需要允许用户处理此类网络资产的集合。一种方法是通过服务来实现。通过服务，我们可以定义处理系统实体和值对象的行为。
- en: All the services that we’ll create in this section reside in the `service` package.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中创建的所有服务都位于`service`包中。
- en: Let’s start by creating a service to deal with collections of routers.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个服务来处理路由器集合。
- en: Router service
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由器服务
- en: 'In the previous section, when implementing the `Router`, `CoreRouter`, and
    `EdgeRouter` entities, we also created some methods to return predicates to aid
    us in filtering collections of routers. With a domain service, we can use these
    predicates to filter such collections, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，在实现`Router`、`CoreRouter`和`EdgeRouter`实体时，我们还创建了一些方法来返回谓词，以帮助我们过滤路由器集合。通过领域服务，我们可以使用这些谓词来过滤此类集合，如下所示：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: For the `filterAndRetrieveRouter` method, we pass a list of routers and a predicate,
    to filter the list, as parameters. Then, we define a `findById` method to retrieve
    a router, using an `Id` type parameter.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`filterAndRetrieveRouter`方法，我们传递一个路由器列表和一个谓词作为参数，以过滤列表。然后，我们定义一个`findById`方法，使用`Id`类型参数检索路由器。
- en: Now, let’s see the service operations we can use to handle switches.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们可以使用的服务操作来处理交换机。
- en: Switch service
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交换机服务
- en: 'This service follows the same idea we applied to the router service. It’s primarily
    based on the predicate provided by the `getSwitchTypePredicate` method to filter
    collections of switches based on their type. As new predicates arise, we can use
    them as new criteria to filter switch collections. Also, note that the `findById`
    method is used again to allow switch retrieval based on the `Id` type parameter.
    Here is the code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务遵循我们应用于路由器服务相同的思想。它主要基于`getSwitchTypePredicate`方法提供的谓词来根据类型过滤交换机集合。随着新谓词的出现，我们可以将它们用作新的标准来过滤交换机集合。此外，请注意，`findById`方法再次被用来允许根据`Id`类型参数检索交换机。以下是代码：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Although we don’t model the network as entities in the domain model, there is
    no issue in creating service classes to handle collections of network value objects.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们没有在领域模型中将网络建模为实体，但创建处理网络值对象集合的服务类没有问题。
- en: Let’s create a last service class for the topology and inventory system.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为拓扑和库存系统创建最后一个服务类。
- en: Network service
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络服务
- en: 'This service is based primarily on a need to filter network collections based
    on the IP protocol. We can have collections of both IPv4 and IPv6 networks. This
    service provides the capacity to filter such collections based on the network
    IP protocol. The following code is used to create a `NetworkService` class:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务主要基于根据IP协议过滤网络集合的需求。我们可以有IPv4和IPv6网络的集合。此服务提供了根据网络IP协议过滤此类集合的能力。以下代码用于创建`NetworkService`类：
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `filterAndRetrieveNetworks` method receives a list of networks and a predicate,
    to filter the list, as parameters. It returns a filtered list of networks.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`filterAndRetrieveNetworks` 方法接收一个网络列表和一个谓词，作为参数来过滤列表。它返回一个过滤后的网络列表。'
- en: With `NetworkService`, we conclude creating domain services.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`NetworkService`，我们完成了领域服务的创建。
- en: 'After creating all these services, you’ll have a package and class structure
    like the one shown here:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建所有这些服务之后，你将拥有一个类似于以下所示的包和类结构：
- en: '![Figure 6.7 – The directory structure of domain services](img/B19777_06_07.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图6.7 – 领域服务的目录结构](img/B19777_06_07.jpg)'
- en: Figure 6.7 – The directory structure of domain services
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 – 领域服务的目录结构
- en: To drive the development of value objects, entities, specifications, and services,
    you can adopt a **Test-Driven Development** (**TDD**) approach, where you can
    start creating broken tests and then implement the correct classes and methods
    to make those tests pass. We did the contrary here to provide a big picture of
    the components we needed to create to build the Domain hexagon for the topology
    and inventory system.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了推动值对象、实体、规范和服务的发展，你可以采用**测试驱动开发**（**TDD**）的方法，其中你可以开始创建失败的测试，然后实现正确的类和方法来使这些测试通过。我们在这里做了相反的事情，以提供一个我们需要创建以构建拓扑和库存系统领域六边形的组件的大图景。
- en: In this section, we created services that operate under the Domain hexagon level.
    Instead of putting more behaviors directly on entities, we created separate service
    classes to enable behaviors that we don’t consider inherently part of the entities.
    These services allow us to handle collections of routers, switches, and networks.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建了在领域六边形级别下运行的服务。我们不是直接将更多行为放在实体上，而是创建了单独的服务类，以实现我们不认为本质上是实体一部分的行为。这些服务使我们能够处理路由器、交换机和网络的集合。
- en: Before we move on to the development of the Application hexagon, we need to
    ensure the operations we created in the Domain hexagon work as expected; otherwise,
    the upstream hexagons will break when performing these operations. So, in the
    next section, we’ll see how to test the Domain hexagon.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续开发应用六边形之前，我们需要确保在领域六边形中创建的操作按预期工作；否则，当执行这些操作时，上游六边形将会崩溃。因此，在下一节中，我们将看到如何测试领域六边形。
- en: Testing the Domain hexagon
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试领域六边形
- en: To test the Domain hexagon appropriately, we should rely only on its components,
    ignoring anything coming from other hexagons. After all, these hexagons should
    depend on the Domain hexagon and not the other way around. As we have already
    seen, the Domain hexagon concentrates on the core system logic. It is from that
    logic that we derive the structure and behavior of the Application and Framework
    hexagons. By building a robust and well-tested Domain hexagon, we build a solid
    foundation for the entire system.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适当地测试领域六边形，我们应该只依赖其组件，忽略来自其他六边形的任何内容。毕竟，这些六边形应该依赖于领域六边形，而不是相反。正如我们之前看到的，领域六边形专注于核心系统逻辑。正是从这个逻辑中，我们推导出应用和框架六边形的结构和行为。通过构建一个健壮且经过良好测试的领域六边形，我们为整个系统构建了一个坚实的基础。
- en: 'Among the operations performed by the topology and inventory system, we can
    consider adding, removing, and searching network assets as the most important
    ones. We’ll use the following steps to test these operations:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在拓扑和库存系统执行的操作中，我们可以将添加、删除和搜索网络资产视为最重要的操作。我们将使用以下步骤来测试这些操作：
- en: 'Let’s start by seeing how we can test the addition of network equipment, as
    follows:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先看看如何测试网络设备的添加，如下所示：
- en: '[PRE34]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `addNetworkToSwitch` method checks the successful path when the system
    can add a network to a switch. The following test checks the unhappy path for
    this:'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`addNetworkToSwitch` 方法检查当系统可以添加网络到交换机时的成功路径。以下测试检查了该路径的不愉快情况：'
- en: '[PRE35]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `addNetworkToSwitch_failBecauseSameNetworkAddress` method checks the unsuccessful
    path when we try to add a network that already exists in the switch.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`addNetworkToSwitch_failBecauseSameNetworkAddress`方法检查当我们尝试添加一个已经存在于交换机中的网络时的失败路径。'
- en: 'Then, we have test scenarios where we want to add a switch to an edge router,
    as illustrated in the following code snippet:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们有测试场景，其中我们想要向边缘路由器添加一个交换机，如下面的代码片段所示：
- en: '[PRE36]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When we try to add a switch that is for a different country than the edge router,
    the `addSwitchToEdgeRouter` method checks the successful path while the `addSwitchToEdgeRouter_failBecauseEquipmentOfDifferentCountries`
    method checks the unsuccessful one.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们尝试添加一个针对与边缘路由器不同国家的交换机时，`addSwitchToEdgeRouter` 方法检查成功的路径，而 `addSwitchToEdgeRouter_failBecauseEquipmentOfDifferentCountries`
    方法检查不成功的路径。
- en: 'Then, we have test scenarios where we want to add an edge router to a core
    router, as illustrated in the following code snippet:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们有测试场景，其中我们想要将一个边缘路由器添加到核心路由器，如下面的代码片段所示：
- en: '[PRE38]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `addEdgeToCoreRouter_failBecauseRoutersOfDifferentCountries` method checks
    the unsuccessful path when the edge and core routers are in different countries.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`addEdgeToCoreRouter_failBecauseRoutersOfDifferentCountries` 方法检查当边缘路由器和核心路由器位于不同国家时，不成功的路径。'
- en: 'Then, we have test scenarios where we want to add a core router to another
    core router, as illustrated in the following code snippet:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们有测试场景，其中我们想要将一个核心路由器添加到另一个核心路由器，如下面的代码片段所示：
- en: '[PRE40]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `addCoreToCoreRouter` method checks the successful path when we can add
    a core router to another one. In the following code snippet, we have the unhappy
    path for this method:'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`addCoreToCoreRouter` 方法检查当我们能够将一个核心路由器添加到另一个路由器时，成功的路径。在下面的代码片段中，我们有这个方法的“不愉快”路径：'
- en: '[PRE41]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `addCoreToCoreRouter_failBecauseRoutersOfSameIp` method checks the unsuccessful
    path when we try to add core routers with the same IP address.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`addCoreToCoreRouter_failBecauseRoutersOfSameIp` 方法检查当我们尝试添加具有相同 IP 地址的核心路由器时，不成功的路径。'
- en: With these tests, we can also check whether the specifications work as expected.
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过这些测试，我们还可以检查规格是否按预期工作。
- en: 'Then, there are other scenarios where it’s necessary to remove any router from
    a core router, a switch from an edge router, and a network from a switch, as illustrated
    in the following code snippet:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，还有其他场景需要从核心路由器中移除任何路由器，从边缘路由器中移除任何交换机，以及从交换机中移除任何网络，如下面的代码片段所示：
- en: '[PRE42]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `removeRouter` test method checks whether we can remove an edge router
    from a core router. In the following code snippet, we test the removal with a
    switch:'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`removeRouter` 测试方法检查我们是否可以从核心路由器中移除一个边缘路由器。在下面的代码片段中，我们使用交换机进行移除测试：'
- en: '[PRE43]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `removeSwitch` test method checks whether we can remove a switch from an
    edge router. In the following code snippet, we test removal with a network:'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`removeSwitch` 测试方法检查我们是否可以从边缘路由器中移除一个交换机。在下面的代码片段中，我们使用网络进行移除测试：'
- en: '[PRE44]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `removeNetwork` test method checks whether we can remove a network from
    a switch.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`removeNetwork` 测试方法检查我们是否可以从交换机中移除一个网络。'
- en: After the adding and removing operations, we have to test the filter and retrieve
    operations.
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在添加和移除操作之后，我们必须测试过滤和检索操作。
- en: 'To filter routers by type, we implement the following test:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要按类型过滤路由器，我们实现以下测试：
- en: '[PRE45]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `filterRouterByType` method tests the operations available on the `RouterService`
    class. In the preceding case, we check whether the `filterAndRetrieveRouter` method
    can really filter and retrieve `CORE` or `EDGE` routers from a list containing
    different types of routers.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`filterRouterByType` 方法测试 `RouterService` 类上的可用操作。在前面的案例中，我们检查 `filterAndRetrieveRouter`
    方法是否真的可以从包含不同类型路由器的列表中过滤和检索 `CORE` 或 `EDGE` 路由器。'
- en: 'To filter routers by vendor, we have the following test:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要按供应商过滤路由器，我们有以下测试：
- en: '[PRE46]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: By using a predicate provided by the `getVendorPredicate` method, we call `filterAndRetrieveRouter`
    from the `RouterService` class. Then, we check whether the retrieved router model
    is what we are looking for.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过使用 `getVendorPredicate` 方法提供的谓词，我们从 `RouterService` 类调用 `filterAndRetrieveRouter`。然后，我们检查检索到的路由器型号是否是我们想要的。
- en: 'Next, we test the same `filterRouterByLocation` method but with a different
    predicate, as follows:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们测试相同的 `filterRouterByLocation` 方法，但使用不同的谓词，如下所示：
- en: '[PRE47]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: By calling the `getCountryPredicate` method, we receive the predicate to filter
    routers by country. The result of this method is stored in the `actualCountry`
    variable, which we use in the test assertion.
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过调用 `getCountryPredicate` 方法，我们接收用于按国家过滤路由器的谓词。此方法的结果存储在 `actualCountry` 变量中，我们在测试断言中使用它。
- en: 'Next, we test the `filterRouterByModel` method, as follows:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们测试 `filterRouterByModel` 方法，如下所示：
- en: '[PRE48]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The goal here is to confirm whether the `filterAndRetrieveRouter` method works
    as expected when we need to filter router lists based on the router model.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里的目标是确认当我们需要根据路由器模型过滤路由器列表时，`filterAndRetrieveRouter`方法是否按预期工作。
- en: 'Here, we have a test for the `filterAndRetrieveSwitch` method from the `SwitchService`
    class:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里，我们对`SwitchService`类中的`filterAndRetrieveSwitch`方法进行了测试：
- en: '[PRE49]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The goal here is to check whether it is possible to filter switch lists using
    the predicate provided by the `getSwitchTypePredicate` method. This is the predicate
    we use to filter switch lists by type. Finally, the `assertEquals` method checks
    whether the expected switch type matches what we expect.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里的目标是检查是否可以使用`getSwitchTypePredicate`方法提供的谓词来过滤开关列表。这是我们用来按类型过滤开关列表的谓词。最后，`assertEquals`方法检查预期的开关类型是否与我们期望的一致。
- en: 'Then, we test the operations to retrieve routers and switches by using their
    IDs, as follows:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过使用它们的ID来检索路由器和开关的操作进行测试，如下所示：
- en: '[PRE50]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: With `findRouterById`, we test the `findById` method from `RouterService`.
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`findRouterById`，我们测试`RouterService`中的`findById`方法。
- en: 'Finally, we implement the `findSwitchById` method, like this:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们实现了`findSwitchById`方法，如下所示：
- en: '[PRE51]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: With `findSwitchById`, we test the `findById` method from `SwitchService`.
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`findSwitchById`，我们测试`SwitchService`中的`findById`方法。
- en: 'After implementing and executing these tests, you should see the following
    output, showing that `19` tests were executed successfully:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现和执行这些测试之后，你应该看到以下输出，显示`19`个测试成功执行：
- en: '[PRE52]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The successful execution of these tests assures us that the most fundamental
    operations from the Domain hexagon work as expected.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试的成功执行确保我们最基本的功能从领域六边形按预期工作。
- en: That’s the green light we need to move ahead and start the development of the
    Application hexagon.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要继续前进并开始开发应用六边形的绿灯。
- en: Summary
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Based on the topology and inventory system we developed in previous chapters,
    this chapter provided a hands-on approach to the early steps of developing a hexagonal
    system. We started by bootstrapping the Domain hexagon as a modularized Maven
    project and using the JPMS.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 基于我们在前几章中开发的拓扑和库存系统，本章提供了一种动手方法来开发六边形系统的早期步骤。我们首先通过将领域六边形作为一个模块化的Maven项目并使用JPMS来启动它。
- en: We briefly analyzed and understood the problem domain as it relates to the management
    of network assets. Then, we translated the problem domain into a domain model
    based on value objects, entities, specifications, and services. Finally, we tested
    everything we’ve done to ensure things won’t break when we start to develop the
    Application hexagon on top of the Domain one.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要分析了并理解了与网络资产管理相关的问题域。然后，我们基于值对象、实体、规范和服务将问题域转换成领域模型。最后，我们测试了我们所做的一切，以确保当我们开始在领域六边形之上开发应用六边形时，一切都不会出错。
- en: By learning how to develop a robust Domain hexagon, we lay a solid foundation
    that the Application and Framework hexagons can rely on. In the next chapter,
    we will learn how to build the Application hexagon by assembling the useful features
    and everything else we’ve created on the Domain hexagon.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 通过学习如何开发一个健壮的领域六边形，我们为应用和框架六边形提供了一个坚实的基础。在下一章中，我们将学习如何通过组装在领域六边形上创建的有用功能和一切其他内容来构建应用六边形。
- en: Questions
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which technologies are used to bootstrap the Domain hexagon as a modularized
    application?
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于启动领域六边形作为模块化应用的哪些技术？
- en: Why did we start developing the Domain hexagon by creating value objects first?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们首先通过创建值对象来开始开发领域六边形？
- en: Once we understand the problem domain, what’s the next step?
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们理解了问题域，下一步是什么？
- en: Why is it so important to develop a robust and well-tested Domain hexagon?
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么开发一个健壮且经过良好测试的领域六边形如此重要？
- en: Answers
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Maven and the JPMS.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Maven和JPMS。
- en: Because value objects are used to compose other value objects and entities.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为值对象被用来组合其他值对象和实体。
- en: We need to translate that problem domain into a domain model.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将那个问题域转换成一个领域模型。
- en: Because a robust Domain hexagon provides a solid foundation to develop the Application
    and Framework hexagons.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为一个健壮的领域六边形为开发应用和框架六边形提供了一个坚实的基础。
