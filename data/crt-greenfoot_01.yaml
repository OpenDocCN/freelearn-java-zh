- en: Chapter 1. Let's Dive Right in…
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。让我们直接进入…
- en: '|   | *"It does not matter how slowly you go as long as you do not stop."*
    |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|    | *"无论你走得有多慢，只要你不停止。" |    |'
- en: '|   | --*Confucius* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|    | --*孔子* |'
- en: 'In this chapter, you will build a simple game where the player controls a character
    using the mouse to try to avoid oncoming enemies. As the game progresses, the
    enemies become harder to avoid. This game contains many of the basic elements
    needed to create interactive Greenfoot applications. Specifically, in this chapter,
    you will learn how to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将构建一个简单的游戏，玩家通过鼠标控制角色，尝试躲避迎面而来的敌人。随着游戏的进行，敌人变得越来越难以躲避。这个游戏包含了创建交互式Greenfoot应用程序所需的基本元素。具体来说，在本章中，你将学习如何：
- en: Create introduction and game-over screens
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建介绍和游戏结束屏幕
- en: Display a user score
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示用户得分
- en: Use the mouse to control the movement of an actor
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用鼠标控制角色的移动
- en: Play background music
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放背景音乐
- en: Dynamically spawn enemies and remove them when appropriate
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态生成敌人并在适当的时候移除它们
- en: Create game levels
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建游戏关卡
- en: Throughout this chapter, we'll learn basic programming concepts and gain familiarity
    with the Greenfoot development environment. As you proceed, think about the concepts
    presented and how you would use them in your own projects. If you are new to Java,
    or it's been a while since you've programmed in Java, be sure to take the time
    to look up things that may be confusing to you. Java is a well-established programming
    language, and there are endless online resources you can consult. Similarly, this
    book assumes a minimal understanding of Greenfoot. Be sure to look at the simple
    tutorials and documentation at [www.greenfoot.org](http://www.greenfoot.org) when
    needed. *Experiment with the code and try new things—you'll be glad you did*.
    In other words, follow the advice of Confucius, quoted in the first line of this
    chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习基本的编程概念，并熟悉Greenfoot开发环境。随着你的学习，思考所提出的概念以及你如何在你的项目中使用它们。如果你是Java的新手，或者有一段时间没有编写Java程序了，请确保花时间查阅可能让你感到困惑的内容。Java是一种成熟的编程语言，有无数的在线资源可以查阅。同样，本书假设对Greenfoot有最低限度的了解。在需要时，请务必查看[www.greenfoot.org](http://www.greenfoot.org)上的简单教程和文档。*尝试代码并尝试新事物——你会很高兴你这么做的*。换句话说，遵循本章第一行引用的孔子的建议。
- en: Many of the chapters in this book are independent; however, most are dependent
    on this chapter. This chapter provides the framework to create Greenfoot applications
    that we will continue to use, and refer to, in later chapters.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的许多章节都是独立的；然而，大多数章节都依赖于本章。本章提供了创建我们将继续使用并在后续章节中参考的Greenfoot应用程序的框架。
- en: The Avoider Game tutorial
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Avoider游戏教程
- en: This tutorial is heavily based on *AS3 Avoider Game Tutorial* by Michael James
    Williams ([http://gamedev.michaeljameswilliams.com/as3-avoider-game-tutorial-base/](http://gamedev.michaeljameswilliams.com/as3-avoider-game-tutorial-base/)).
    In that tutorial, you build a game that creates smiley-faced enemies that rain
    down from the top of the screen. The goal for the player is to avoid these enemies.
    The longer you avoid them, the higher your score. We will build the same game
    in Greenfoot, instead of Flash and ActionScript. As with Michael James Williams'
    tutorial, we will start small and slowly layer on functionality. We will pause
    frequently to consider best practices and good programming practice. Enjoy these
    learning opportunities!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程主要基于Michael James Williams的*AS3 Avoider游戏教程*。在那个教程中，你将构建一个游戏，游戏会从屏幕顶部生成笑脸敌人。玩家的目标是避开这些敌人。你避开它们的时间越长，你的得分就越高。我们将使用Greenfoot构建相同的游戏，而不是Flash和ActionScript。与Michael
    James Williams的教程一样，我们将从小处着手，逐渐添加功能。我们将经常暂停以考虑最佳实践和良好的编程实践。享受这些学习机会！
- en: We will first build the basic components of the Avoider game, including the
    initial scenario, the game environment, the enemies, and the hero. Then, we will
    layer on additional functionality, such as scoring, introduction and game-over
    screens, and the notion of levels.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先构建Avoider游戏的基本组件，包括初始场景、游戏环境、敌人和英雄。然后，我们将添加额外的功能，例如得分、介绍和游戏结束屏幕以及关卡的概念。
- en: As mentioned in the preface, we'll assume you have downloaded Greenfoot and
    have it installed. If you still haven't, do so now. Go to [www.greenfoot.org](http://www.greenfoot.org)
    for easy-to-follow instructions on downloading and installing Greenfoot. While
    you are there, make sure you are minimally familiar with all the tutorials provided
    on [http://www.greenfoot.org/doc](http://www.greenfoot.org/doc).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如前言所述，我们假设你已经下载了Greenfoot并已安装。如果你还没有，请现在就做。前往[www.greenfoot.org](http://www.greenfoot.org)获取下载和安装Greenfoot的简单说明。当你在那里时，确保你至少熟悉[http://www.greenfoot.org/doc](http://www.greenfoot.org/doc)上提供的所有教程。
- en: Basic game elements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本游戏元素
- en: All games have an environment in which the game takes place and objects interact.
    In Greenfoot, the environment is represented by the `World` class, and objects
    that interact in the environment are represented by the `Actor` class. In this
    section of the chapter, we will create a world, add enemies to the world, and
    add a hero that will be controlled by the player.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 所有游戏都有一个游戏发生的环境，其中对象进行交互。在Greenfoot中，环境由`World`类表示，而在环境中交互的对象由`Actor`类表示。在本章的这一部分，我们将创建一个世界，向世界添加敌人，并添加一个将由玩家控制的英雄。
- en: Creating a scenario
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建场景
- en: Start Greenfoot and create a new scenario by clicking on **Scenario** in Greenfoot's
    Menu bar and then clicking on **New…**. You will see the window shown in *Figure
    1*. Type `AvoiderGame` as the name of the file, and then hit the **Create** button.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Greenfoot，通过点击Greenfoot菜单栏中的**场景**然后点击**新建…**来创建一个新的场景。你会看到*图1*中显示的窗口。将文件名输入为`AvoiderGame`，然后点击**创建**按钮。
- en: '![Creating a scenario](img/image00238.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![创建场景](img/image00238.jpeg)'
- en: 'Figure 1: Here''s Greenfoot''s New Scenario window'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：这是Greenfoot的新场景窗口
- en: Creating our world
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建我们的世界
- en: Next, we need to create a world for our game. We do this by right-clicking (or
    ctrl-clicking on Mac) on the **World** class in the scenario window (see *Figure
    2*) and choosing **New subclass...** in the pop-up menu that appears.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为我们的游戏创建一个世界。我们通过在场景窗口中右键单击（或在Mac上按ctrl键单击）**世界**类，并在出现的弹出菜单中选择**新建子类...**来完成此操作（参见*图2*）。
- en: '![Creating our world](img/image00239.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![创建我们的世界](img/image00239.jpeg)'
- en: 'Figure 2: This is about right-clicking on the World class in order to subclass
    it'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：这是关于在**世界类**上右键单击以创建子类
- en: In the **New class** pop-up window, name the class `AvoiderWorld`, select the
    **backgrounds** image category, and then select the `space1.jpg` library image
    as the new class image. Once this is done, the pop-up window should resemble *Figure
    3*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在**新建类**弹出窗口中，将类命名为`AvoiderWorld`，选择**背景**图像类别，然后选择`space1.jpg`库图像作为新类的图像。完成这些操作后，弹出窗口应类似于*图3*。
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Once you associate an image with a new `World` class or `Actor` class, that
    image will be copied to the `images` directory in your Greenfoot project. We will
    count on this in later chapters.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将一个图像与新的`World`类或`Actor`类关联，该图像将被复制到Greenfoot项目的`images`目录中。我们将在后面的章节中依赖这一点。
- en: '![Creating our world](img/image00240.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![创建我们的世界](img/image00240.jpeg)'
- en: 'Figure 3: This shows the New class pop-up window'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：这显示了新建类弹出窗口
- en: Hit the **Ok** button in the **New class** pop-up window, and then, in the main
    scenario window, hit the **Compile** button. You should now have a scenario that
    looks like that shown in *Figure 4*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在**新建类**弹出窗口中点击**确定**按钮，然后在主场景窗口中点击**编译**按钮。现在你应该有一个看起来像*图4*中所示的场景。
- en: '![Creating our world](img/image00241.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![创建我们的世界](img/image00241.jpeg)'
- en: 'Figure 4: This shows our AvoiderGame scenario after compiling the AvoiderWorld
    class'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：这显示了编译了AvoiderWorld类的AvoiderGame场景
- en: We now have our own world, named `AvoiderWorld`, which we will soon populate
    with actors.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了自己的世界，名为`AvoiderWorld`，我们将很快在其中添加演员。
- en: Tip
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Later in this chapter, we will add two subclasses of `World` to our game—one
    for our introduction screen and one for our game-over screen. Those instructions
    will be abbreviated. Be sure to refer back to this section if you need detailed
    instructions on subclassing the `World` class.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将向我们的游戏添加两个`World`类的子类——一个用于我们的介绍屏幕，另一个用于我们的游戏结束屏幕。那些说明将被简略。如果你需要关于子类化`World`类的详细说明，请务必参考本节。
- en: Creating our hero
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建我们的英雄
- en: Let's create the character our players will control when they play our game.
    Greenfoot makes this really easy. We will just follow the same steps we used to
    create the `World` class earlier. Start by right-clicking on the `Actor` class
    in the scenario window (see *Figure 5*) and choose the **New subclass...** menu
    item.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建玩家在玩游戏时将控制的角色。Greenfoot使这变得非常简单。我们将遵循之前创建`World`类时使用的相同步骤。首先，在场景窗口中右键单击`Actor`类（见*图5*），然后选择**新建子类...**菜单项。
- en: '![Creating our hero](img/image00242.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![创建我们的英雄](img/image00242.jpeg)'
- en: 'Figure 5: This shows right-clicking on the Actor class in order to subclass
    it'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：此图显示了在Actor类上右键单击以继承它
- en: In the **New class** pop-up window, name the class `Avatar` and select `symbols->skull.png`
    as the new class image. In the main scenario window, hit the **Compile** button.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在**新类**弹出窗口中，将类命名为`Avatar`，并选择`symbols->skull.png`作为新的类图像。在主场景窗口中，点击**编译**按钮。
- en: Now, to create an enemy, you perform the same steps you just did for the hero,
    except choose `symbols->Smiley1.png` as the image and `Enemy` as the class name.
    Again, hit the **Compile** button when this is done.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要创建一个敌人，您只需执行与英雄相同的步骤，只是选择`symbols->Smiley1.png`作为图像，并将类名选择为`Enemy`。同样，完成此操作后，再次点击**编译**按钮。
- en: You should now have a scenario that looks like the one shown in *Figure 6*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该有一个看起来像*图6*所示的场景。
- en: '![Creating our hero](img/image00243.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![创建我们的英雄](img/image00243.jpeg)'
- en: 'Figure 6: This shows the Avoider Game scenario after creating the world and
    adding two actors'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图6：此图显示了创建世界并添加两个演员后的Avoider Game场景
- en: What have we just done?
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们刚才做了什么？
- en: Greenfoot views a scenario as `World` that contains `Actor`. The main responsibilities
    of `World` is to add and remove `each Actor` from the screen and to periodically
    call the `act()` method of each `Actor`. It is the responsibility of each `Actor`
    to implement their `act()` method to describe their actions. Greenfoot provides
    you with the code that implements general `World` and `Actor` behavior. (You right-clicked
    on those implementations previously.) As a game programmer, you must code specific
    behaviors for `World` and `Actor`. You do this by subclassing the provided `World`
    and `Actor` classes to create new classes and writing code in them. You have already
    done the subclassing, and now it is time to add the code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Greenfoot将场景视为包含`Actor`的`World`。`World`的主要职责是从屏幕上添加和删除`每个Actor`，并定期调用每个`Actor`的`act()`方法。每个`Actor`的职责是实现它们的`act()`方法来描述它们的行为。Greenfoot为您提供了实现通用`World`和`Actor`行为的代码。（您之前已经右键点击过这些实现。）作为一名游戏程序员，您必须为`World`和`Actor`编写特定的行为代码。您通过继承提供的`World`和`Actor`类来创建新类，并在其中编写代码。您已经完成了继承，现在是时候添加代码了。
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Look at [http://www.greenfoot.org/files/javadoc/](http://www.greenfoot.org/files/javadoc/)
    to learn more about the `World` and `Actor` classes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[http://www.greenfoot.org/files/javadoc/](http://www.greenfoot.org/files/javadoc/)以了解更多关于`World`和`Actor`类的信息。
- en: Oracle provides an excellent overview of object-oriented programming concepts
    at [http://docs.oracle.com/javase/tutorial/java/concepts/](http://docs.oracle.com/javase/tutorial/java/concepts/).
    If you are serious about learning Java and writing good Greenfoot scenarios, you
    should read that material.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle在[http://docs.oracle.com/javase/tutorial/java/concepts/](http://docs.oracle.com/javase/tutorial/java/concepts/)提供了关于面向对象编程概念的优秀概述。如果您认真学习Java并编写好的Greenfoot场景，您应该阅读这些材料。
- en: Adding our hero
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加我们的英雄
- en: Last, we need to add our hero to the game. To do this, right-click on the `Avatar`
    class, select `new Avatar()` from the pop-up menu, drag the picture of the skull
    that appears collocated with your mouse pointer to the center of the screen and
    then click the left mouse button. Now, right-click anywhere on the black space
    background (do not right-click on the skull) and choose **Save the world** in
    the pop-up menu that appears.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将我们的英雄添加到游戏中。为此，右键单击`Avatar`类，从弹出菜单中选择`new Avatar()`，将鼠标指针旁边出现的头骨图片拖到屏幕中央，然后点击鼠标左键。现在，在任何黑色背景上右键单击（不要在头骨上右键单击）并选择弹出菜单中的**保存世界**。
- en: Doing this will permanently add our hero to the game. If you hit the **Reset**
    button on Greenfoot's scenario window, you should still see the skull you placed
    in the middle of the screen.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此操作将永久将我们的英雄添加到游戏中。如果您在Greenfoot的场景窗口中点击**重置**按钮，您应该仍然看到您放置在屏幕中间的头骨。
- en: Using the mouse as a game controller
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用鼠标作为游戏控制器
- en: Let's add some code to the `Avatar` class that will allow us to control its
    movement using the mouse. Double-click on `Avatar` to pull up the code editor
    (You can also right-click on the class and select **Open editor**).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Avatar`类中添加一些代码，这样我们就可以使用鼠标来控制它的移动。双击`Avatar`以打开代码编辑器（你也可以右键单击类并选择**打开编辑器**）。
- en: You will see a code-editing window appear that looks as shown in *Figure 7*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到一个代码编辑窗口出现，其外观如图7所示。
- en: '![Using the mouse as a game controller](img/image00244.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![使用鼠标作为游戏控制器](img/image00244.jpeg)'
- en: 'Figure 7: This is the code for our Avatar class'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图7：这是我们Avatar类的代码
- en: You can see the `act()` method we discussed earlier. Because there is no code
    in it, `Avatar` will not move or display any other behavior when we run our scenario.
    What we would like, is to have `Avatar` follow the mouse. Wouldn't it be nice
    if there was a `followMouse()` method we could use? *Let's pretend there is!*
    Inside the `act()` method, type `followMouse();`. Your `act()` method should look
    like *Figure 8*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们之前讨论过的`act()`方法。因为里面没有代码，所以当我们运行场景时，`Avatar`不会移动或显示任何其他行为。我们希望的是让`Avatar`跟随鼠标。如果有一个我们可以使用的`followMouse()`方法会怎么样？*让我们假装有！*
    在`act()`方法中，输入`followMouse();`。你的`act()`方法应该看起来像图8。
- en: '![Using the mouse as a game controller](img/image00245.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![使用鼠标作为游戏控制器](img/image00245.jpeg)'
- en: 'Figure 8: This shows the act() method with the followMouse() function added'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图8：显示了添加了followMouse()函数的act()方法
- en: Just for fun, let's compile this and see what happens. What do you think will
    happen? Click the **Compile** button to find out. Did you see something like what
    is shown in *Figure 9*?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了好玩，让我们编译一下看看会发生什么。你认为会发生什么？点击**编译**按钮来找出答案。你看到了像图9中显示的那样的事情吗？
- en: '![Using the mouse as a game controller](img/image00246.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![使用鼠标作为游戏控制器](img/image00246.jpeg)'
- en: 'Figure 9: This is about viewing a compilation error in Greenfoot'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图9：这是关于在Greenfoot中查看编译错误
- en: If you look at the bottom of the window in *Figure 9*, you'll see that Greenfoot
    has provided us with a useful error message and has even highlighted the code
    that has the problem. As we know, we were pretending that the method `followMouse()`
    existed. Of course, it does not. We will, however, write it soon. Throughout the
    course of this manual (and during any Java coding), you are going to make errors.
    Sometimes, you'll make a "typo" and at other times, you'll use a symbol that doesn't
    exist (just as we did earlier). There are other common errors you will make as
    well.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看图9的底部，你会看到Greenfoot为我们提供了一个有用的错误信息，甚至突出显示了有问题的代码。正如我们所知，我们假装方法`followMouse()`存在。当然，它不存在。然而，我们很快就会编写它。在整个手册的编写过程中（以及任何Java编码过程中），你都会犯错误。有时，你会犯一个“打字错误”，有时，你会使用一个不存在的符号（就像我们之前做的那样）。你还会犯其他一些常见的错误。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Help! I just made a programming error!**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**帮助！我刚刚犯了一个编程错误！**'
- en: 'Don''t panic! There are a number of things you can do to remedy the situation.
    I will list some here. First and foremost, the process you use to code can greatly
    aid you in debugging code (finding errors). The process you should follow is called
    *Incremental Development*. Simply follow these steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 不要慌张！你可以做很多事情来解决这个问题。我会在这里列出一些。首先，你使用的编码过程可以大大帮助你调试代码（查找错误）。你应该遵循的过程被称为**增量开发**。只需遵循以下步骤：
- en: Code a couple of lines of code. *(Really!! Don't code any more!)*
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写几行代码。（真的！！不要编写更多代码！）
- en: Save and compile.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存并编译。
- en: Run and test your code. *(Really!! Try it out!)*
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行并测试你的代码。（真的！！试试看！）
- en: Repeat.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复。
- en: 'Now, if you get an error, *it has to be due to the last 2-5 lines of code*
    you just wrote. You know exactly where to look. Compare this to writing 30 lines
    of code and then testing them out. You will have compounding bugs that are hard
    to find. Here are some other debugging tips:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你遇到错误，*它一定是由于你刚刚编写的最后2-5行代码造成的*。你知道确切的位置在哪里。将此与编写30行代码然后测试它们进行比较。你将会有累积的难以找到的错误。以下是一些其他调试技巧：
- en: Very carefully read the error message you get. While they can be cryptic, they
    really do point you to the location of the bug (sometimes even giving line numbers).
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非常仔细地阅读你得到的错误信息。虽然它们可能很晦涩，但它们确实会指向错误的位置（有时甚至给出行号）。
- en: Sometimes, you get multiple, long error messages. Don't worry. Just go to the
    top and read and deal with only the first one. Often, by fixing the first one,
    many others will be taken care of too.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，你会得到多个、长篇的错误信息。不用担心。只需从顶部开始阅读并处理第一个。通常，通过修复第一个，许多其他问题也会得到解决。
- en: If you just can't find it, have someone else read your code. It's amazing how
    fast someone else can spot your error.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你实在找不到，让其他人帮你阅读代码。别人能多快地发现你的错误真是令人惊讶。
- en: Print some information out. You can use `System.out.println()` to print out
    variables and check that the code you are looking at is actually running.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印一些信息。你可以使用`System.out.println()`来打印变量，并检查你正在查看的代码是否实际在运行。
- en: Learn how to use a debugger. This is a very useful tool, but beyond the scope
    of this book. Learn what a debugger is and use it. *Greenfoot has a nice, built-in
    debugger you can use.*
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用调试器。这是一个非常有用的工具，但超出了本书的范围。了解调试器是什么，并使用它。\*Greenfoot有一个内置的调试器，你可以使用它\*。
- en: In the extremely rare case that there is an error in the Greenfoot program,
    report it by following the instructions found at [http://www.greenfoot.org/support](http://www.greenfoot.org/support).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在极其罕见的情况下，如果Greenfoot程序中存在错误，请按照[http://www.greenfoot.org/support](http://www.greenfoot.org/support)中找到的说明进行报告。
- en: Creating the followMouse function
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建`followMouse`函数
- en: 'Ok, let''s get back to our hero. We last left our hero (the `Avatar` class)
    with an error, because there was actually no `followMouse()` method. Let''s fix
    that. Add the method shown in the following code after the `act()` method in the
    `Avatar` class:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们回到我们的英雄。我们上一次离开我们的英雄（Avatar类）时，有一个错误，因为实际上没有`followMouse()`方法。让我们来修复它。在`Avatar`类的`act()`方法之后添加以下代码中的方法：
- en: '[PRE0]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We now have an implementation of `followMouse()`. Save the file, compile the
    Greenfoot scenario, and try the code out. The picture of the skull should follow
    your mouse. If something went wrong, look closely at the debugging window (shown
    in Figure 9) to see the clues Java is giving you about your error. Did you mistype
    something? Verify that the code in your `Avatar` class looks exactly like the
    code in Figure 10\. *Follow the debugging tips provided earlier*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了`followMouse()`方法的实现。保存文件，编译Greenfoot场景，并尝试运行代码。头骨的图片应该会跟随你的鼠标。如果出了问题，仔细查看调试窗口（如图9所示）以查看Java给你提供的关于错误的线索。你是不是打错了什么？验证一下你的`Avatar`类中的代码是否与图10中的代码完全一致。\*遵循之前提供的调试提示\*。
- en: '![Creating the followMouse function](img/image00247.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![创建`followMouse`函数](img/image00247.jpeg)'
- en: 'Figure 10: This shows the Avatar class with completed followMouse() method'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图10：此图显示了完成`followMouse()`方法的Avatar类
- en: Hey, wait! How did I come up with the code for the `followMouse()` method? Was
    I born with that information? No, I actually just looked over the Greenfoot documentation
    ([http://www.greenfoot.org/files/javadoc/](http://www.greenfoot.org/files/javadoc/))
    and saw there was a class named `MouseInfo`. I clicked on that and read about
    all of its methods.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，等等！我是怎么想出`followMouse()`方法的代码的？我是带着这些信息出生的吗？不，我实际上只是查阅了Greenfoot文档（[http://www.greenfoot.org/files/javadoc/](http://www.greenfoot.org/files/javadoc/))，并看到有一个名为`MouseInfo`的类。我点击了它，并阅读了它所有的方法。
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Go read the Greenfoot documentation now. It's actually pretty short. There are
    only seven classes and each only has around 20, or fewer, methods.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在去阅读Greenfoot文档。实际上它相当简短。只有七个类，每个类大约有20个或更少的方法。
- en: Breaking down the code
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码分解
- en: Let's break down this code. First, we get access to an object that represents
    mouse data via `Greenfoot.getMouseInfo()`. We then use that object to get the
    location of the mouse, via `getX()` and `getY()`, and then set the *x* and *y*
    locations of our hero using `setLocation(x,y)`. How did I know to use `setLocation()`?
    Again, it is in the Greenfoot documentation for the `Actor` class. It is a method
    that Greenfoot provides for all actors. Last, we had to include the `if(mi !=
    null)` part because if you accidentally move the mouse outside the Greenfoot window,
    there will be no mouse information, so trying to access it will cause an error
    (check out the comment in the code in *Figure 10*, *line 22*).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这段代码。首先，我们通过`Greenfoot.getMouseInfo()`获取一个表示鼠标数据的对象。然后，我们使用该对象通过`getX()`和`getY()`获取鼠标的位置，然后使用`setLocation(x,y)`设置我们的英雄的*x*和*y*位置。我是怎么知道要使用`setLocation()`的？再次，它是在`Actor`类的Greenfoot文档中。这是Greenfoot为所有演员提供的一个方法。最后，我们必须包含`if(mi
    != null)`部分，因为如果你不小心将鼠标移动到Greenfoot窗口之外，将没有鼠标信息，尝试访问它将导致错误（查看*图10*中的代码注释，*第22行*）。
- en: Since the `followMouse()` method is called in the `act()` method, our hero will
    continually be moved to the location of the mouse.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`followMouse()`方法在`act()`方法中被调用，我们的英雄（Avatar类）将持续移动到鼠标的位置。
- en: Tip
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When typing a method in Greenfoot, you can hit *Ctrl* + space bar and Greenfoot
    will display a list of potential methods you may have been trying to write. Select
    a method from the list and Greenfoot will autocomplete the method for you, including
    space holders for method parameters.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Greenfoot中输入方法时，你可以按*Ctrl* + 空格键，Greenfoot将显示一个可能尝试编写的潜在方法的列表。从列表中选择一个方法，Greenfoot将为你自动完成该方法，包括方法参数的占位符。
- en: Adding enemies
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加敌人
- en: We're going to add enemies to our game in two steps. First, we need to write
    the code for the `Enemy` class, and then we will add code to our world, `AvoiderWorld`,
    to create a never-ending army of enemies. Both steps are surprisingly simple.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分两步向我们的游戏添加敌人。首先，我们需要编写`Enemy`类的代码，然后我们将向我们的世界`AvoiderWorld`添加代码来创建一支永无止境的敌人军队。这两个步骤都非常简单。
- en: Enemy code
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 敌人代码
- en: 'Double-click on the `Enemy` class and change its `act()` method to look like
    the following code snippet:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 双击`Enemy`类并更改其`act()`方法，使其看起来像以下代码片段：
- en: '[PRE1]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Remember using `setLocation()` earlier in the `Avatar` class? We use it again
    here to move an enemy down one pixel every time the `act()` method is called.
    In Greenfoot, the upper-left corner of the screen is the coordinate (0,0). The
    *x* coordinate increases as you move to the right and the *y* coordinate increases
    as you move down. That is why we set the *x* location of the enemy to be its current
    *x* coordinate value (we are not moving to the left or the right) and its *y*
    location to be its current *y* coordinate plus one (we are moving down one pixel.)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在`Avatar`类中使用过`setLocation()`吗？我们在这里再次使用它，每次调用`act()`方法时将敌人向下移动一个像素。在Greenfoot中，屏幕的左上角是坐标(0,0)。*x*坐标随着向右移动而增加，*y*坐标随着向下移动而增加。这就是为什么我们将敌人的*x*位置设置为当前的*x*坐标值（我们不会向左或向右移动）以及其*y*位置设置为当前的*y*坐标加一（我们向下移动一个像素。）
- en: Save your `Enemy` class, and then compile your scenario. Run the scenario, right-click
    on the `Enemy` class, and choose `new Enemy()` in the pop-up menu. Add this enemy
    to the screen and watch it move down.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你的`Enemy`类，然后编译你的场景。运行场景，右键单击`Enemy`类，并在弹出菜单中选择`new Enemy()`。将这个敌人添加到屏幕上，并观察它向下移动。
- en: Creating an army
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建一支军队
- en: 'Now that we have completed our `Enemy` class, we can use it to create an army.
    To do this, we are going to add code to the `act()` method in our `AvoiderWorld`
    class. Open the editor for `AvoiderWorld` by double-clicking on it, or right-clicking
    on it and selecting **Open editor** in the pop-up menu. If you look around the
    code for `AvoiderWorld`, you''ll notice that Greenfoot does not automatically
    create an `act()` method for you. No problem, we''ll just add it. Put the following
    code in `AvoiderWorld`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了`Enemy`类的编写，我们可以用它来创建一支军队。为此，我们将向`AvoiderWorld`类的`act()`方法中添加代码。通过双击`AvoiderWorld`或右键单击它并在弹出菜单中选择**打开编辑器**来打开`AvoiderWorld`的编辑器。如果你查看`AvoiderWorld`的代码，你会注意到Greenfoot不会自动为你创建`act()`方法。没问题，我们只需添加它。在`AvoiderWorld`中放入以下代码：
- en: '[PRE2]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `act()` method starts by checking whether a randomly generated number between
    0 and 1000, including 0 but not 1000, was less than 20\. In the long run, this
    code will run 2 percent of the times the `act()` method is called. Is this enough?
    Well, the `act()` method is typically called 50 times per second (ranges from
    1 to 100, depending on the position of the speed slider bar), so 2 percent of
    50 is 1\. Therefore, on average one enemy will be created per second. This feels
    about right for the starting level of our game.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`act()`方法首先检查一个在0到1000之间（包括0但不包括1000）随机生成的数字是否小于20。从长远来看，这段代码将在`act()`方法被调用的2%的时间内运行。这足够了吗？嗯，`act()`方法通常每秒调用50次（范围从1到100，取决于速度滑块的位置），所以2%的50次是1。因此，平均每秒将创建一个敌人。这对于我们游戏的起始级别来说感觉是合适的。'
- en: 'Inside the `if` statement, we create an enemy and place it at a specific location
    in the world using the method `addObject()`. The `addObject()` method takes three
    parameters: the object to add, the *x* coordinate of the object, and the *y* coordinate
    of the object. The *y* coordinate is constant and chosen so that the newly created
    enemy starts off at the top of the screen and will appear as it slowly moves down.
    The *x* coordinate is trickier. It is dynamically generated so that the enemy
    could appear on any valid *x* coordinate on the screen. The following is the code
    we are talking about:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if`语句内部，我们创建一个敌人并将其放置在世界的特定位置，使用`addObject()`方法。`addObject()`方法接受三个参数：要添加的对象、对象的*x*坐标和对象的*y*坐标。*y*坐标是恒定的，选择它使得新创建的敌人从屏幕顶部开始，并随着它缓慢向下移动而出现。*x*坐标更复杂。它是动态生成的，以便敌人可以出现在屏幕上的任何有效的*x*坐标。以下是我们正在讨论的代码：
- en: '[PRE3]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Figure 11* demonstrates the range of *x* coordinate values that are generated.
    In this figure, the rectangles represent the possible set of values for the *x*
    coordinate for the given code. This method of generating ranges of values for
    screen coordinates is common in Greenfoot.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11*展示了生成的*x*坐标值的范围。在这个图中，矩形代表给定代码的*x*坐标可能值的集合。在Greenfoot中，为屏幕坐标生成值范围的这种方法是常见的。'
- en: '![Creating an army](img/image00248.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![创建一支军队](img/image00248.jpeg)'
- en: 'Figure 11: This is the range of x coordinate values generated by the code'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图11：这是代码生成的x坐标值的范围
- en: Compile and run the scenario; you should see a continuous stream of enemy hordes
    moving down the screen.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行场景；你应该会看到一个连续的敌人洪流沿着屏幕向下移动。
- en: Unbounding the world
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无界世界
- en: 'After running the scenario, you''ll notice that the enemies end up piling up
    at the bottom of the screen. In Greenfoot, you can create worlds that are bounded
    (where actors are not allowed to go past the screen borders) and unbounded (where
    actors are allow to exit the screen.) By default, Greenfoot creates bounded worlds.
    However, changing the world to unbounded is extremely easy. Double-click on `AvoiderWorld`
    to open the code editor. Take this line of code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 运行场景后，你会注意到敌人最终会堆积在屏幕底部。在Greenfoot中，你可以创建有界（演员不允许穿过屏幕边界）和无界（演员允许退出屏幕）的世界。默认情况下，Greenfoot创建的是有界世界。然而，将世界改为无界非常容易。双击`AvoiderWorld`以打开代码编辑器。找到以下代码行：
- en: '[PRE4]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Change the preceding code to the following line of code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码更改为以下代码行：
- en: '[PRE5]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Looking at the Greenfoot documentation for the `World` class, we notice there
    are two constructors (see [http://www.greenfoot.org/files/javadoc/greenfoot/World.html](http://www.greenfoot.org/files/javadoc/greenfoot/World.html)
    for detailed information on these constructors): one that takes three parameters
    and another that takes four. The constructor with four parameters has the same
    parameters as the one that takes three, plus one additional `boolean` parameter
    that indicates whether the world is bounded or not. Our code change added the
    fourth Boolean parameter and set it to `false` (no bounds in the world.)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Greenfoot文档中的`World`类，我们会注意到有两个构造函数（有关这些构造函数的详细信息，请参阅[http://www.greenfoot.org/files/javadoc/greenfoot/World.html](http://www.greenfoot.org/files/javadoc/greenfoot/World.html)）：一个接受三个参数，另一个接受四个。具有四个参数的构造函数与接受三个参数的构造函数具有相同的参数，再加上一个额外的`boolean`参数，表示世界是有界还是无界。我们的代码更改添加了第四个布尔参数并将其设置为`false`（世界中没有边界。）
- en: Now, compile and run the scenario. The enemies fall off the bottom of the screen
    as required.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编译并运行场景。敌人会按照要求从屏幕底部掉落。
- en: Where do all those enemies go? We'll deal with that next.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些敌人都去哪里了？我们将在下一节中处理这个问题。
- en: Memory management
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存管理
- en: In Greenfoot applications, you'll create hundreds and thousands of actors. When
    we are done with an actor, such as when it is killed or goes off screen, we would
    like to remove that object and not have it consume any more system resources.
    Java manages memory resources via a method called **garbage collection**. With
    this method, Java tries to automatically determine whether you no longer need
    an actor, and if you don't, it deletes that actor and frees up all resources associated
    with it. In Greenfoot, you can let Java know you are done with the actor by removing
    it from `World` using the `removeObject()` method. This is what we want to do
    to an `Enemy` actor, after we have successfully avoided it and it has moved off
    the screen.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在Greenfoot应用程序中，你会创建成百上千的演员。当我们完成一个演员，比如当它被杀死或离开屏幕时，我们希望移除该对象，并且它不再消耗任何系统资源。Java通过一个称为**垃圾回收**的方法来管理内存资源。使用此方法，Java试图自动确定你是否不再需要演员，如果你不需要，它将删除该演员并释放与其相关的所有资源。在Greenfoot中，你可以通过使用`removeObject()`方法从`World`中移除演员来让Java知道你已经完成了演员。这就是我们在成功避开它并且它已经离开屏幕后想要对`Enemy`演员做的事情。
- en: 'The most convenient place to remove an `Enemy`, after it has gone off the screen,
    is within the `Enemy` class itself. Add the following code as the last line of
    code inside the `act()` method in the `Enemy` class:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在敌人离开屏幕后，移除`Enemy`的最方便的地方是在`Enemy`类本身中。将以下代码作为`Enemy`类中`act()`方法内的最后一行代码添加：
- en: '[PRE6]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we need to add the `checkRemove()` method. Put the definition of this
    method below the `act()` method. Here is the definition:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要添加`checkRemove()`方法。将此方法的定义放在`act()`方法下方。以下是定义：
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The code for your `Enemy` class should look like that shown in *Figure 12*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`Enemy`类的代码应该看起来像*图12*中所示的那样。
- en: '![Memory management](img/image00249.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![内存管理](img/image00249.jpeg)'
- en: 'Figure 12: This shows the adding of code to remove the enemy if it goes off
    the bottom of the screen'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图12：这显示了如何添加代码以移除如果敌人从屏幕底部移出
- en: Now, compile and run the scenario. The enemies fall of the bottom of the screen,
    as before, but you can feel good knowing that they are soon removed from the world
    and the garbage is collected.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编译并运行场景。敌人像以前一样从屏幕底部落下，但你可以放心，它们很快就会从世界中移除，垃圾回收也会进行。
- en: Your assignment
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你的作业
- en: 'Learning is not passive, and you really need to engage in the process. Before
    moving on to the next section of this chapter, you should:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 学习不是被动的，你真的需要参与这个过程。在继续本章的下一部分之前，你应该：
- en: Make sure your version of our Avoider Game works, click on **Scenario** in Greenfoot's
    main application menu, and then choose **Save as…** to create an experimental
    copy of Avoider Game. Let's name this experimental copy `AvoiderGameIExperimentation`.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的Avoider Game版本可以正常工作，在Greenfoot的主应用程序菜单中点击**场景**，然后选择**另存为…**来创建Avoider
    Game的实验副本。让我们把这个实验副本命名为`AvoiderGameIExperimentation`。
- en: Play around with your experimental copy. Change the spawn rates of the enemies.
    Change how fast the enemies descend.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的实验副本上玩玩。改变敌人的出生率。改变敌人下降的速度。
- en: Add `turn(5);` to the `act()` method of the Enemy class. Compile and run. What's
    going on? Try different values instead of `5` as the input parameter to `turn()`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`turn(5);`添加到`Enemy`类的`act()`方法中。编译并运行。发生了什么？尝试用不同的值代替`5`作为`turn()`的输入参数。
- en: If things get too crazy, delete your experimental copy and make a new copy to
    play with from our original Avoider Game. There's no harm done, nor any foul.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事情变得太疯狂，删除你的实验副本，并从我们的原始Avoider Game创建一个新的副本来玩耍。没有造成伤害，也没有任何不当行为。
- en: Tip
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Throughout this book, take this approach of experimenting with the code. Much
    learning will happen during the playing. The very act of thinking about how to
    change the code provides your brain with a new way to process and understand it.
    Making mistakes in a controlled environment will better prepare you to handle
    mistakes later on. You will start to become familiar with Greenfoot's error messages.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，采取这种通过实验代码的方法。在玩耍的过程中会发生很多学习。思考如何更改代码的行为本身就会给你的大脑提供一种新的处理和理解它的方式。在受控环境中犯错误将更好地为你准备以后处理错误。你将开始熟悉Greenfoot的错误信息。
- en: Next…
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 接下来...
- en: Great work until now! We have built the basics of our game and will next add
    some things, such as an introduction screen, game-over screen, and a score, to
    make it look and feel more like a game.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止做得很好！我们已经建立了游戏的基础，接下来我们将添加一些东西，比如介绍屏幕、游戏结束屏幕和分数，使它看起来和感觉更像一个游戏。
- en: Making it a game
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使其成为一个游戏
- en: In this section, we will add a game-over screen, an introduction screen, and
    some background music. But, before we do all that, we need to know when our hero
    touches one of the enemies. This will be our cue to end the game. The act of determining
    when two actors touch is called **collision detection**. Collision detection is
    used to tell whether a bullet hit an enemy, whether the player landed on a platform
    after jumping, or to tell whether a falling leaf landed on a surface. We will
    discuss this important topic next and spend considerable time on it in the upcoming
    chapters.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将添加一个游戏结束屏幕、一个介绍屏幕和一些背景音乐。但在我们做所有这些之前，我们需要知道我们的英雄何时接触到敌人。这将是我们结束游戏的提示。确定两个角色何时接触的行为称为**碰撞检测**。碰撞检测用于判断子弹是否击中敌人，玩家在跳跃后是否落在平台上，或者判断一片落叶是否落在地面上。我们将在下一节讨论这个重要话题，并在接下来的章节中花费大量时间讨论。
- en: Detecting collisions
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测碰撞
- en: 'Greenfoot provides several `Actor` methods you can use to determine whether
    you are touching another `Actor`. These methods, in no particular order, are:
    `getIntersectingObjects()`, `getNeighbors()`, `getObjectsAtOffset()`, `getObjectsInRange()`,
    `getOneIntersectingObject()`, and `getOneObjectAtOffset()`. They all provide slightly
    different ways of determining collision. For our game, we are going to use `getOneIntersectingObject()`.
    The prototype of this method is as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Greenfoot提供了几个`Actor`方法，您可以使用它们来确定您是否接触到了另一个`Actor`。这些方法没有特定的顺序，包括：`getIntersectingObjects()`、`getNeighbors()`、`getObjectsAtOffset()`、`getObjectsInRange()`、`getOneIntersectingObject()`和`getOneObjectAtOffset()`。它们都提供了确定碰撞的不同方法。对于我们的游戏，我们将使用`getOneIntersectingObject()`。此方法的原型如下：
- en: '[PRE8]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This method takes one parameter, which is the class of the objects you want
    to check for collision. This method defines collision in terms of **bounding boxes**;
    a bounding box is the minimal rectangle that can surround all pixels in the graphic.
    This method is efficient and fast, but not the most accurate. In *Figure 12*,
    we can see a picture of a skull and a picture of a smiley face. Even though the
    pixels of the two pictures are not overlapping, we can see that their bounding
    boxes are overlapping; therefore, `getOneIntersectingObject()` would report that
    these two actors are touching. In [Chapter 3](part0024.xhtml "Chapter 3. Collision
    Detection"), *Collision Detection*, we will explore more advanced methods of collision
    detection.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受一个参数，即您想要检查碰撞的对象类别。此方法将碰撞定义为**边界框**；边界框是能够包围图形中所有像素的最小矩形。此方法既高效又快速，但不是最精确的。在*图12*中，我们可以看到一幅头骨的图片和一幅笑脸的图片。尽管这两幅图片的像素没有重叠，但我们可以看到它们的边界框是重叠的；因此，`getOneIntersectingObject()`会报告这两个角色正在接触。在[第3章](part0024.xhtml
    "第3章。碰撞检测")*碰撞检测*中，我们将探讨更高级的碰撞检测方法。
- en: '![Detecting collisions](img/image00250.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![检测碰撞](img/image00250.jpeg)'
- en: 'Figure 13: This shows the bounding boxes of two actors'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图13：此图显示了两个角色的边界框
- en: 'Armed with this new information, we are going to add collision detection to
    our `Avatar` class. We will remove our hero from the game if it touches one of
    the enemies. (Later in this chapter, we will display a game-over screen after
    removing our hero.) Double-click on the `Avatar` class to bring up its editing
    window. Change its `act()` method to this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些新信息，我们将向我们的`Avatar`类添加碰撞检测。如果我们的英雄接触到敌人之一，我们将将其从游戏中移除。（在本章的后面部分，我们将在移除我们的英雄后显示游戏结束屏幕。）双击`Avatar`类以打开其编辑窗口。将其`act()`方法更改为以下内容：
- en: '[PRE9]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, add this `checkForCollisions()` method''s definition under the `act()`
    method:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`act()`方法下添加此`checkForCollisions()`方法的定义：
- en: '[PRE10]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `Avatar` class should look like the code shown in Figure 14.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`Avatar`类应该看起来像图14中所示的那样。'
- en: '![Detecting collisions](img/image00251.jpeg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![检测碰撞](img/image00251.jpeg)'
- en: 'Figure 14: The Avatar class with collision detection added.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图14：添加了碰撞检测的`Avatar`类。
- en: Let's examine exactly what's going on in the `checkForCollisions()` method.
    The first thing we do is call `getOneIntersectionObject()` and save its return
    value in the variable `enemy`. This variable will be `null` if this object is
    not touching any enemies, in which case, the expression in the `if` statement
    will evaluate to `false`, and we will not execute the statements inside. Otherwise,
    we are touching an object of the type `Enemy` and do execute the contents of the
    `if` statement.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细检查`checkForCollisions()`方法中正在发生的事情。我们首先调用`getOneIntersectionObject()`并将它的返回值保存在变量`enemy`中。如果这个对象没有接触到任何敌人，这个变量将是`null`，在这种情况下，`if`语句中的表达式将评估为`false`，我们不会执行其内部的语句。否则，我们接触到了一个类型为`Enemy`的对象，并将执行`if`语句的内容。
- en: There are only two lines of code in the `if` statement. In the first line, we
    use the method `getWorld()`, implemented in the `Actor` class, to get a reference
    to the instance of the `World` we are in. Instead of saving the reference in a
    variable, we immediately invoke the `World` method `removeObject()` supplying
    the keyword `this` as the argument to remove our hero. Lastly, we use the `stop()`
    method in the `Greenfoot` utility class to pause our game.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句中只有两行代码。在第一行中，我们使用`getWorld()`方法，该方法在`Actor`类中实现，来获取我们所在世界的`World`实例的引用。我们不是将引用保存在一个变量中，而是立即调用`World`的`removeObject()`方法，将关键字`this`作为参数传递以移除我们的英雄。最后，我们使用`Greenfoot`实用类中的`stop()`方法暂停我们的游戏。'
- en: Now, compile and run the scenario. Enemies should stream down from the top of
    the screen and exit out at the bottom. You should be able to control the hero,
    an instance of the `Avatar` class, by moving your mouse. If our hero touches one
    of the enemies, the game should stop.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编译并运行这个场景。敌人应该从屏幕顶部流下来并在底部退出。你应该能够通过移动鼠标来控制英雄，它是`Avatar`类的一个实例。如果我们的英雄接触到任何一个敌人，游戏应该停止。
- en: Adding a game-over screen
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加游戏结束屏幕
- en: First, you need to draw an entire game-over screen in your favorite graphic
    design/drawing program, such as GIMP, CorelDRAW, Inkscape, Greenfoot's built-in
    graphic editor, or even Windows Paint. I used Adobe Illustrator to create the
    screen shown in *Figure 15*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要使用你喜欢的图形设计/绘图程序，比如GIMP、CorelDRAW、Inkscape、Greenfoot内置的图形编辑器，甚至是Windows
    Paint，绘制整个游戏结束屏幕。我使用Adobe Illustrator创建了*图15*中显示的屏幕。
- en: '![Adding a game-over screen](img/image00252.jpeg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![添加游戏结束屏幕](img/image00252.jpeg)'
- en: 'Figure 15: My AvoiderGame game-over screen; try designing your own.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图15：我的AvoiderGame游戏结束屏幕；尝试设计你自己的。
- en: Whatever you use to draw your image, make sure you can save it in either `PNG`
    or `JPG` format. Its size should be 600 x 400 (the same size as your world). Save
    this image in the `images` folder in your `AvoiderGame` scenario.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用什么来绘制你的图像，确保你可以以`PNG`或`JPG`格式保存它。其大小应该是600 x 400（与你的世界大小相同）。将此图像保存在你的`AvoiderGame`场景的`images`文件夹中。
- en: Using the same steps that you used to create `AvoiderWorld` (*The Avoider Game
    tutorial* section), create another world; call it `AvoiderGameOverWorld` and associate
    the image you created earlier with it. In the **World classes** area of your scenario,
    you should see what is shown in *Figure 16*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与创建`AvoiderWorld`相同的步骤（*避免者游戏教程*部分），创建另一个世界；命名为`AvoiderGameOverWorld`，并将你之前创建的图像与之关联。在你的场景的**世界类**区域，你应该看到*图16*中所示的内容。
- en: '![Adding a game-over screen](img/image00253.jpeg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![添加游戏结束屏幕](img/image00253.jpeg)'
- en: 'Figure 16: The World classes section after adding AvoiderGameOverWorld'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图16：添加AvoiderGameOverWorld后的世界类区域
- en: Switching scenes
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 场景切换
- en: 'Now, we want to display the game-over screen if our hero touches an enemy.
    To do this, we need to perform the following three steps:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要显示游戏结束屏幕，如果我们的英雄接触到敌人。为此，我们需要执行以下三个步骤：
- en: Detect when we collide with an enemy and then tell (by calling a method) our
    world, `AvoiderWorld`, that the game is over.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检测我们与敌人发生碰撞，然后通过调用一个方法通知我们的世界，`AvoiderWorld`，游戏已经结束。
- en: In our `AvoiderWorld` class, we need to implement the game-over method that
    the `Avatar` will use to signal the end of days.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`AvoiderWorld`类中，我们需要实现`Avatar`将用来信号世界末日结束的游戏结束方法。
- en: In our game-over method, set the world to be `AvoiderGameOverWorld`, instead
    of `AvoiderWorld`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的游戏结束方法中，将世界设置为`AvoiderGameOverWorld`，而不是`AvoiderWorld`。
- en: 'Let''s start with step 1\. Previously, in the *Detecting collisions* subsection
    of this section, you wrote code to remove the hero from the game if it touches
    one of the enemies. This code was contained in the method `checkForCollisions()`.
    To implement step 1, we need to change that method to the following method:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一步开始。之前，在本节的*检测碰撞*子节中，你编写了代码，如果英雄接触到敌人，就会从游戏中移除英雄。这段代码包含在`checkForCollisions()`方法中。为了实现第一步，我们需要将该方法更改为以下方法：
- en: '[PRE11]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The only difference is the code inside the `if` statement. I hope it makes sense
    that we are now asking the world to end the game, as opposed to removing the hero
    object. The part that could be confusing is the substitution of `AvoiderWorld`
    for `World` and the addition of the `(AvoiderWorld)` part. The problem, is that
    we are going to implement `endGame()` in `AvoiderWorld`, not `World`. So, we need
    some way of specifying that the return value of `getWorld()` will be treated as
    `AvoiderWorld` and not just plain old ordinary `World`. In Java terms, this is
    called **casting**.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是`if`语句内的代码。我希望你能理解我们现在要求世界结束游戏，而不是移除英雄对象。可能让人困惑的部分是将`AvoiderWorld`替换为`World`以及添加`(AvoiderWorld)`部分。问题是，我们将在`AvoiderWorld`中实现`endGame()`，而不是`World`。因此，我们需要一种方法来指定`getWorld()`的返回值将被视为`AvoiderWorld`，而不仅仅是普通的`World`。用Java术语来说，这被称为**类型转换**。
- en: Now, let's look at steps 2 and 3\. Here's the code you need to add to `AvoiderWorld`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看第二步和第三步。这是你需要添加到`AvoiderWorld`中的代码。
- en: '![Switching scenes](img/image00254.jpeg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![切换场景](img/image00254.jpeg)'
- en: 'Figure 17: This shows the endGame() method added to AvoiderWorld'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图17：这显示了添加到AvoiderWorld中的endGame()方法
- en: We have changed, and added, a minimal amount of code, but if you have followed
    along carefully, you should be able to save, compile, and run the code. See the
    game-over screen when our hero touches an enemy? (If not, go back and retrace
    your steps. Something you typed in is wrong.)
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经更改并添加了最小量的代码，但如果你仔细跟随着，你应该能够保存、编译并运行代码。看到我们的英雄接触到敌人时出现的游戏结束界面吗？（如果没有，请回过头来重新追踪你的步骤。你可能输入了错误的内容。）
- en: Note
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**The three Ps: Plan, Plan, and Plan**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**三个P：计划，计划，再计划**'
- en: Coding is complicated stuff. When you have a problem to solve, you don't just
    want to sit down and start hacking away at the computer until you bang out a solution.
    You want to sit down with a stylus and ePad (used to be pen and paper in my day)
    and plan. I gave you a small example when I wrote out the three steps needed to
    display the game-over screen. One of the best methods to help you design a solution
    is a **top-down design** (also know as divide and conquer).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 编程是复杂的事情。当你有一个问题要解决时，你不想只是坐下来，对着电脑开始乱敲，直到你敲出一个解决方案。你想要坐下来，用笔和ePad（在我那个时代是笔和纸）来规划。我在编写显示游戏结束界面的三个步骤时给你提供了一个小的例子。帮助你设计解决方案的最佳方法之一是**自顶向下的设计**（也称为分而治之）。
- en: In the top-down design, you start thinking of a solution to a problem at a very
    high level and then repeatedly break down this solution into subsolutions until
    the subsolutions are small and manageable
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在自顶向下的设计中，你从非常高的层面开始思考问题的解决方案，然后反复将这个解决方案分解成子解决方案，直到子解决方案变得小且易于管理。
- en: Adding a "play again" button
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加“再玩一次”按钮
- en: 'The game-over screen is great and all, but we don''t want to just stare at
    it all day. OK, so let''s make it so that you can restart the game by clicking
    on the game-over screen. `AvoiderGameOverWorld` needs to keep checking whether
    the mouse has been clicked and then set the world back to `AvoiderWorld`, so that
    we can play the game again. Looking at the Greenfoot documentation, we can see
    the `mouseClicked()` function. Let''s use that method in the `act()` method of
    `AvoiderGameOverWorld`, along with the change world code. Add the following code
    to `AvoiderGameOverWorld`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏结束界面很棒，但我们不想整天都盯着它看。好吧，那么让我们设置一下，点击游戏结束界面就可以重新开始游戏。`AvoiderGameOverWorld`需要持续检查鼠标是否被点击，然后将世界状态重置为`AvoiderWorld`，这样我们就可以再次玩游戏了。查看Greenfoot文档，我们可以看到`mouseClicked()`函数。让我们在`AvoiderGameOverWorld`的`act()`方法中使用这个方法，以及更改世界状态的代码。将以下代码添加到`AvoiderGameOverWorld`中：
- en: '[PRE12]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code should look very familiar to you. The code inside the `if` statement
    is nearly identical to the code we added to the `endGame()` method in the `AvoiderWorld`
    class, except this time we are creating and switching to `AvoiderWorld`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该对你来说非常熟悉。`if`语句内的代码几乎与我们添加到`AvoiderWorld`类中的`endGame()`方法中的代码相同，只是这次我们创建并切换到`AvoiderWorld`。
- en: The new part is to check to see whether the user clicked the mouse anywhere
    on the screen. The `Greenfoot.mouseClicked()` method returns true if the user
    just clicked on the object supplied in its parameter. We supplied the `this` variable,
    which represents the whole instance of the `AvoiderGameOverWorld` world.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 新的部分是检查用户是否点击了屏幕上的任何位置。如果用户刚刚点击了其参数中提供的对象，`Greenfoot.mouseClicked()` 方法返回 true。我们提供了
    `this` 变量，它代表 `AvoiderGameOverWorld` 实例的整体。
- en: Compile and run. Great job! Our game is coming along nicely!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行。做得好！我们的游戏进展得很顺利！
- en: Adding an introduction screen
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加一个介绍屏幕
- en: Adding an introduction screen is really easy, and we just need to perform many
    of the same steps we did in creating a game-over screen. First, we need to create
    an introduction screen image in whatever graphics editor program you want. The
    one I created is shown in *Figure 18*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个介绍屏幕非常简单，我们只需要执行我们在创建游戏结束屏幕时所做的许多相同步骤。首先，我们需要使用你想要的任何图形编辑器程序创建一个介绍屏幕图像。我创建的图像显示在*图18*中。
- en: '![Adding an introduction screen](img/image00255.jpeg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![添加介绍屏幕](img/image00255.jpeg)'
- en: 'Figure 18: The image of the introduction screen for our game.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图18：我们游戏的介绍屏幕图像。
- en: Make sure the image is either in PNG or JPG format and has a pixel size of 600
    x 400\. Save this image in the `images` folder in your `AvoiderGame` scenario.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 确保图像是 PNG 或 JPG 格式，并且像素大小为 600 x 400。将此图像保存在你的 `AvoiderGame` 场景的 `images` 文件夹中。
- en: Create a new world (by subclassing `World`), call it `AvoiderGameIntroScreen`,
    and associate the image you just created with it. When you are done with this,
    the **World classes** area of your scenario should look like the screenshot shown
    in *Figure 19*.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的世界（通过继承 `World`），命名为 `AvoiderGameIntroScreen`，并将其与刚刚创建的图像关联起来。当你完成这个步骤后，你的场景的**世界类**区域应该看起来像*图19*中所示的截图。
- en: '![Adding an introduction screen](img/image00256.jpeg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![添加介绍屏幕](img/image00256.jpeg)'
- en: 'Figure 19: These are all the worlds you created in your AvoiderGame'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图19：这些都是你在 AvoiderGame 中创建的所有世界。
- en: Setting the initial screen
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置初始屏幕
- en: We obviously want our new introduction screen to display first when the player
    first starts the game. To select `AvoiderGameIntroScreen` world as our starting
    `World`, we need to right-click on it in the **World classes** area and select
    the `new AvoiderGameIntroScreen()` menu option in the pop-up window that appears
    (see *Figure 20*).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们显然希望我们的新介绍屏幕在玩家第一次开始游戏时首先显示。要选择 `AvoiderGameIntroScreen` 世界作为我们的起始 `World`，我们需要在**世界类**区域中右键单击它，并在出现的弹出窗口中选择
    `new AvoiderGameIntroScreen()` 菜单选项（见*图20*）。
- en: '![Setting the initial screen](img/image00257.jpeg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![设置初始屏幕](img/image00257.jpeg)'
- en: 'Figure 20: This is about selecting our starting world'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图20：这是关于选择我们的起始世界
- en: Let's make sure everything is hooked up correctly. Compile and run your Greenfoot
    application. You should start with the introduction screen you just created, but
    can't do much else. We'll fix that now.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保一切连接正确。编译并运行你的 Greenfoot 应用程序。你应该从你刚刚创建的介绍屏幕开始，但无法做太多其他事情。我们现在将解决这个问题。
- en: Adding a "play" button
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加“播放”按钮
- en: We are going to repeat exactly the same steps we did in implementing the restarting
    of the game from the game-over screen.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重复我们在从游戏结束屏幕实现游戏重启时所做的完全相同的步骤。
- en: 'Add the following code to `AvoiderGameIntroScreen`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `AvoiderGameIntroScreen`：
- en: '[PRE13]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code should look very familiar to you. This is exactly the same code we
    added to the `AvoiderGameOverWorld` class.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该对你来说非常熟悉。这正是我们添加到 `AvoiderGameOverWorld` 类中的代码。
- en: Compile and run. Have some fun. See how long you can last!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行。享受乐趣。看看你能坚持多久！
- en: So far so good, but it is definitely missing some key gaming elements.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利，但确实缺少一些关键的游戏元素。
- en: Adding background music
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加背景音乐
- en: In this part of the tutorial, you need to search the Web for a song (`.mp3`)
    you would like to play during the game.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程的这一部分，你需要在网上搜索一首你希望在游戏中播放的歌曲（`.mp3`）。
- en: Note
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Acquiring music**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**获取音乐**'
- en: Whenever you are adding assets (music or graphics) to your game, make sure you
    do so legally. There are many sites on the Internet that offer free use of the
    music or pictures provided. Never use proprietary music, and always cite the sources
    from which you acquired assets. I got the music I added to the game from [newgrounds.com](http://newgrounds.com),
    and I gave credit to the author in my code.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你在游戏中添加资源（音乐或图形）时，确保你这样做是合法的。互联网上有许多网站提供免费使用提供的音乐或图片。永远不要使用专有音乐，并且始终引用你获取资源的来源。我从
    [newgrounds.com](http://newgrounds.com) 获取了添加到游戏中的音乐，并在我的代码中为作者提供了信用。
- en: We only want the music to play when we start playing the game, not during the
    introduction or game-over screens. Therefore, we'll start the music when we display
    `AvoiderWorld` and turn it off before we display `AvoiderGameOverWorld`. We only
    want to start the music once, so we don't want to add the code to play the music
    in the `act()` method—imagine the noise from doing that! What we need is a method
    that is only called once at the creation of the object. That's what the **constructors**
    of a class provide. (If you need to review what a class and an object are, see
    the information box in the *What have we just done?* section)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只希望在开始玩游戏时播放音乐，而不是在介绍或游戏结束屏幕上播放。因此，我们在显示 `AvoiderWorld` 时开始播放音乐，在显示 `AvoiderGameOverWorld`
    之前关闭它。我们只想播放一次音乐，所以不想在 `act()` 方法中添加播放音乐的代码——想象一下那样做的噪音！我们需要的是一个在对象创建时只被调用一次的方法。这正是类的**构造函数**所提供的。（如果你需要回顾类和对象是什么，请参阅
    *What have we just done?* 部分的资料框）
- en: Note
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**What is a constructor?**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**构造函数是什么？**'
- en: In programming in Java (and other object-oriented languages), we write code
    in classes. A **class** describes the methods and attributes of objects we want
    to create in our program. You can think of a class as a blueprint for building
    objects. For example, our `Enemy` class describes the behavior and attributes
    of every enemy object that appears in our Avoider Game. Each *class* has a *constructor*
    that performs all initialization needed for each object created. You can identify
    the constructor of a class easily. Constructors have exactly the same name as
    the class they are in and have no return type. As a quick test, find the constructor
    in our `AvoiderWorld` class. Found it?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java编程（以及其他面向对象的语言）中，我们在类中编写代码。一个**类**描述了我们想要在程序中创建的对象的方法和属性。你可以把类看作是构建对象的蓝图。例如，我们的
    `Enemy` 类描述了出现在我们的 Avoider 游戏中的每个敌人对象的行为和属性。每个 *类* 都有一个 *构造函数*，它执行每个创建的对象所需的全部初始化。你可以很容易地识别类的构造函数。构造函数的名称与它们所在的类完全相同，并且没有返回类型。作为一个快速测试，找到我们的
    `AvoiderWorld` 类中的构造函数。找到了吗？
- en: We call the constructor every time we create a new object. In Greenfoot, right-click
    on the Enemy class and you'll see that the top-menu choice is `new Enemy()`. The
    `Enemy()` part is the constructor. The `new` keyword creates the new object and
    the `Enemy()` initializes that new object. Got it?
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们每次创建新对象时都会调用构造函数。在Greenfoot中，右键单击 `Enemy` 类，你会看到顶部的菜单选项是 `new Enemy()`。`Enemy()`
    部分是构造函数。`new` 关键字创建新对象，而 `Enemy()` 初始化该新对象。明白了吗？
- en: 'The following are some good resources you should read to learn more about constructor
    functions:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些你应该阅读的好资源，以了解更多关于构造函数函数的信息：
- en: '[http://docs.oracle.com/javase/tutorial/java/javaOO/constructors.html](http://docs.oracle.com/javase/tutorial/java/javaOO/constructors.html)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.oracle.com/javase/tutorial/java/javaOO/constructors.html](http://docs.oracle.com/javase/tutorial/java/javaOO/constructors.html)'
- en: '[http://java.about.com/od/workingwithobjects/a/constructor.htm](http://java.about.com/od/workingwithobjects/a/constructor.htm)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://java.about.com/od/workingwithobjects/a/constructor.htm](http://java.about.com/od/workingwithobjects/a/constructor.htm)'
- en: Writing the music code
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写音乐代码
- en: Now that we know where to put the code (everyone say `constructor`), we need
    to know what code to write. Greenfoot provides a class for playing and managing
    music called `GreenfootSound`. This class makes playing music really easy. Before
    I show you the code to put in the constructor, you should take a look at the documentation
    for `GreenfootSound` and see if you can figure out what to write.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了代码应该放在哪里（大家说 `constructor`），我们需要知道要写什么代码。Greenfoot提供了一个用于播放和管理音乐的类，称为
    `GreenfootSound`。这个类使得播放音乐变得非常简单。在我向你展示要放入构造函数中的代码之前，你应该查看 `GreenfootSound` 的文档，看看你是否能弄清楚要写什么。
- en: Tip
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: No, really! Go read the documentation! Trying to do it on your own will really
    help you.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 不，真的！去阅读文档！自己尝试去做真的会对你有帮助。
- en: Here's the code you need to add to the constructor of `AvoiderWorld`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是你需要添加到 `AvoiderWorld` 构造函数中的代码。
- en: '![Writing the music code](img/image00258.jpeg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![编写音乐代码](img/image00258.jpeg)'
- en: 'Figure 21: Here''s the constructor for AvoiderWorld'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图21：这是AvoiderWorld的构造函数
- en: Analyzing the music code
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 分析音乐代码
- en: 'Let''s look at every line of code in the `AvoiderWorld` constructor. First,
    you have the call to the superclass''s constructor, which is needed, as described
    earlier, to properly initialize your game world. Next, we have this line:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`AvoiderWorld`构造函数中的每一行代码。首先，你有调用超类构造函数的调用，正如之前所述，这是为了正确初始化你的游戏世界。接下来，我们有这一行：
- en: '[PRE14]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This creates a new `GreenfootSound` object and saves a reference to it in the
    `bkgMusic` variable. You need to change the preceding code, so that instead of
    `sounds/UFO_T-Balt.mp3`, you use a string that gives the name of the music file
    you downloaded to play (you need to save the music in your `sounds` folder in
    your Greenfoot project's folder). We also need to declare the `bkgMusic` variable
    we are using in the constructor. To do that, you need to add a variable declaration
    at the top of your class, as shown in *Figure 22*. By declaring the variable at
    the top of your class, it will be accessible to all the methods in your class.
    This will be important when we add code to stop playing the music.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个新的`GreenfootSound`对象，并将对它的引用保存在`bkgMusic`变量中。你需要更改前面的代码，而不是使用`sounds/UFO_T-Balt.mp3`，你需要使用一个字符串来给出你下载以播放的音乐文件名（你需要将音乐保存在你的Greenfoot项目文件夹中的`sounds`文件夹中）。我们还需要声明在构造函数中使用的`bkgMusic`变量。为此，你需要在类的顶部添加一个变量声明，如图22所示。通过在类的顶部声明变量，它将可以访问你的类中的所有方法。这将在我们添加停止播放音乐的代码时变得很重要。
- en: '![Analyzing the music code](img/image00259.jpeg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![分析音乐代码](img/image00259.jpeg)'
- en: 'Figure 22: This shows the variable declaration for bkgMusic in the AvoiderWorld
    class'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图22：这显示了AvoiderWorld类中bkgMusic变量的声明
- en: 'The next line of code we have to discuss is this one:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要讨论的代码行是这一行：
- en: '[PRE15]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This line starts playing the music and will start it over once it finishes.
    If we would have only done `bkgMusic.play()`, then the song would have played
    through only once.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码开始播放音乐，并在结束时重新开始播放。如果我们只做了`bkgMusic.play()`，那么这首歌只会播放一次。
- en: The last line in the constructor is a very important one, and it was added automatically
    by Greenfoot. Remember when, back in the *Adding our hero* section of this chapter,
    I instructed you to place an instance of the `Avatar` class (our hero) in the
    center of the **screen**, right-click, and choose the menu option **Save the World**?
    When you did this, Greenfoot created this `prepare()` method. If you look at the
    contents of this method, you will see that it contains the code to create an `Avatar`
    object and add it to the **screen**. Then, it added the call to use `prepare()`
    in the constructor. If you choose the menu option **Save the World** again, this
    `prepare()` method will be updated.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数中的最后一行是非常重要的一行，它是Greenfoot自动添加的。记得在本书的*添加我们的英雄*部分，我指导你将`Avatar`类（我们的英雄）的实例放置在屏幕中央，右键点击，并选择**保存世界**菜单选项吗？当你这样做时，Greenfoot创建了这个`prepare()`方法。如果你查看这个方法的内容，你会看到其中包含了创建`Avatar`对象并将其添加到**屏幕**的代码。然后，它在构造函数中添加了对`prepare()`的调用。如果你再次选择**保存世界**菜单选项，这个`prepare()`方法将会更新。
- en: OK, save, compile, and run. Did it work? If not, go back and find the typo.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，保存、编译并运行。它工作了吗？如果没有，回去找到错误。
- en: Stop the music
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 停止音乐
- en: 'If you ran your code, you had music during the game, but it did not turn off
    when you died and went to the game-over screen. We have to explicitly turn off
    the music before displaying `AvoiderGameOverWorld`. This is super easy! All we
    need to do is add the following line of code at the beginning of the `endGame()`
    method you added to `AvoiderWorld` earlier:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行了你的代码，你在游戏中会有音乐，但是当你死亡并进入游戏结束屏幕时，音乐并没有关闭。我们必须在显示`AvoiderGameOverWorld`之前显式地关闭音乐。这很简单！我们只需要在之前添加到`AvoiderWorld`中的`endGame()`方法的开头添加以下代码行：
- en: '[PRE16]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, save, compile, and run. It should all work according to plan.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，保存、编译并运行。它应该按照计划工作。
- en: Note
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Private, Protected, and Public**'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**私有、受保护和公共**'
- en: 'The Java keywords `private`, `protected`, and `public` modify how a variable,
    method, or class is accessed in Java. Good programming practice dictates that
    you make all of your class instance variables `private` and require access to
    that variable to only occur through methods. For methods, you want to make ones
    you only access within the `private` class; otherwise, make it `public`. The keyword
    `protected` is used to a method available to subclasses of the class but not to
    external classes. For more information, refer to the following links:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Java关键字`private`、`protected`和`public`修改了Java中变量、方法或类的访问方式。良好的编程实践规定，你应该将所有类的实例变量设置为`private`，并且只通过方法访问该变量。对于方法，你希望只在你自己的`private`类中访问它们；否则，将其设置为`public`。关键字`protected`用于使方法对类的子类可用，但对外部类不可用。有关更多信息，请参阅以下链接：
- en: '[http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html](http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html](http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html)'
- en: '[http://www.tutorialspoint.com/java/java_access_modifiers.htm](http://www.tutorialspoint.com/java/java_access_modifiers.htm)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.tutorialspoint.com/java/java_access_modifiers.htm](http://www.tutorialspoint.com/java/java_access_modifiers.htm)'
- en: Your assignment
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你的任务
- en: 'Perform the following actions before continuing:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前执行以下操作：
- en: Once the game-over screen is displayed, play music. Are you going to make it
    peppy music to lift the spirits of your player or sad and morose to really rub
    it in? Make sure you turn it off before switching to `AvoiderWorld`.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦显示游戏结束屏幕，播放音乐。你打算播放欢快的音乐来提振玩家的精神，还是播放悲伤和忧郁的音乐来真正打击他们？确保在切换到`AvoiderWorld`之前将其关闭。
- en: Our enemy's movements are pretty vanilla. Can you spice it up? Some ideas are
    to have the enemy characters have variable speed, drift left or right, or enter
    from the top or bottom. What will you come up with?
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们敌人的动作相当平淡。你能让它变得更有趣吗？一些想法是让敌人角色具有可变速度，左右漂移，或从顶部或底部进入。你将想出什么？
- en: Remember to create a backup copy of `AvoiderGame` before trying these challenges.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试这些挑战之前，请记住创建`AvoiderGame`的备份副本。
- en: Next…
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接下来...
- en: Almost done! We have built the basics of our game and will next add some things
    to make it challenging.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎完成了！我们已经构建了游戏的基础，接下来将添加一些内容使其更具挑战性。
- en: Enhancing playability
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高可玩性
- en: In the final section of this chapter, we will add code to increase the game's
    playability. First, we will add a score. Next, we need to increase the challenge
    of the game over time. As the player gets better at the game, we want to ramp
    up the challenge; we will add a leveling system to do this.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将添加代码来提高游戏的可玩性。首先，我们将添加一个分数。接下来，我们需要随着时间的推移增加游戏的挑战性。随着玩家在游戏中的进步，我们希望提高挑战性；我们将添加一个等级系统来实现这一点。
- en: Game scoring
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏评分
- en: Our game is evolving; however, we need a way to judge how well we are doing
    in the game. There are many ways to judge game performance, for example, levels
    completed, time, progression, and so on—but the most common method is to assign
    the player a score. We are going to add a scoring system to the game that rewards
    players for the number of enemies they avoid.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏正在发展；然而，我们需要一种方法来判断我们在游戏中的表现如何。有许多方法可以判断游戏表现，例如，完成的关卡、时间、进度等——但最常见的方法是为玩家分配分数。我们将在游戏中添加一个评分系统，奖励玩家避免的敌人数量。
- en: Adding the Counter class
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加Counter类
- en: Keeping a count of things and displaying that count is so common in games that
    Greenfoot provides you with a **Counter** class. To get access to this class,
    you need to import it into your scenario. To do this, select **Edit** in Greenfoot's
    main menu, and then select the **Import Class…** submenu choice. You will see
    a window, like the one shown in *Figure 23*. Make sure the **Counter** box is
    selected on the left-hand side and then click on the **Import** button.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中计数并在屏幕上显示计数是如此常见，以至于Greenfoot为你提供了一个**Counter**类。要访问此类，你需要将其导入到你的场景中。为此，在Greenfoot的主菜单中选择**编辑**，然后选择**导入类…**子菜单选项。你将看到一个窗口，就像图23中显示的那样。确保在左侧选中**Counter**框，然后点击**导入**按钮。
- en: '![Adding the Counter class](img/image00260.jpeg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![添加Counter类](img/image00260.jpeg)'
- en: 'Figure 23: Here''s Greenfoot''s Import Class window'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图23：这是Greenfoot的导入类窗口
- en: This will add the `Counter` class to your list of **Actor classes** available
    for use in our game as shown in *Figure 24*.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把`Counter`类添加到你的**演员类**列表中，以便在我们的游戏中使用，如图24所示。
- en: '![Adding the Counter class](img/image00261.jpeg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![添加Counter类](img/image00261.jpeg)'
- en: 'Figure 24: The Actor classes section of your scenario window now includes the
    Counter class'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图24：你的场景窗口中的Actor类部分现在包括Counter类
- en: We want the score to appear immediately in the game. In tutorial 4 ([http://www.greenfoot.org/doc/tut-4](http://www.greenfoot.org/doc/tut-4))
    on the Greenfoot site, you were introduced to "Saving the World" to have the `World`
    class automatically place `Actor` in your world. I'm going to describe how to
    place `Actor` in your world manually; specifically, you are going to add an instance
    of the `Counter` class to your `AvoiderWorld` world.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望分数能立即在游戏中显示。在Greenfoot网站上的教程4 ([http://www.greenfoot.org/doc/tut-4](http://www.greenfoot.org/doc/tut-4))
    中，你被介绍了“拯救世界”，以便自动将`Actor`放置在你的世界中。我将描述如何手动将`Actor`放置在你的世界中；具体来说，你将向你的`AvoiderWorld`世界添加一个`Counter`类的实例。
- en: 'We discussed that Greenfoot already added the call to the `prepare()` method
    in your `AvoiderWorld()` constructor. Locate the definition of this method in
    the `AvoiderWorld` class. Change this method to look like the following code:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了Greenfoot已经在你的`AvoiderWorld()`构造函数中添加了对`prepare()`方法的调用。在`AvoiderWorld`类中找到这个方法的定义。将其更改为以下代码：
- en: '[PRE17]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The first two lines of this method were already present. The last two lines
    put a score display on our game screen. The `scoreBoard = new Counter("Score:
    ");` code creates a new Counter object with a label `Score:` and stores a reference
    to it in the `scoreBoard` variable (we haven''t declared this variable yet, but
    will soon.) The next line of code adds our `Counter` to the upper-left corner
    of our game screen.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '这个方法的前两行已经存在。最后两行在游戏屏幕上放置了一个分数显示。`scoreBoard = new Counter("Score: ");` 这段代码创建了一个带有标签“Score:”的新`Counter`对象，并将其引用存储在`scoreBoard`变量中（我们尚未声明这个变量，但很快就会声明。）下一行代码将我们的`Counter`添加到游戏屏幕的左上角。'
- en: Lastly, we need to declare the `scoreBoard` variable at the top of our class.
    Add `private Counter scoreBoard;` above the constructor, as shown in *Figure 25*.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在类的顶部声明`scoreBoard`变量。在构造函数上方添加`private Counter scoreBoard;`，如图*图25*所示。
- en: '![Adding the Counter class](img/image00262.jpeg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![添加Counter类](img/image00262.jpeg)'
- en: 'Figure 25: The declaration of the scoreBoard variable in the class AvoiderWorld.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图25：在AvoiderWorld类中声明scoreBoard变量。
- en: Compile, run, and test your scenario.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 编译、运行并测试你的场景。
- en: Increasing the score over time
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 随着时间的推移提高分数
- en: 'We need to do just one more thing. We need to call `setValue()` on our `scoreBoard`
    variable to increase our score over time. One place we could do this is where
    we create the enemies in `AvoiderWorld`. The thinking, is that you get some points
    for every enemy created, because you will ultimately have to avoid it. Here''s
    how you should change the `act()` method in `AvoiderWorld`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做最后一件事。我们需要在`scoreBoard`变量上调用`setValue()`来随时间增加我们的分数。一个我们可以这样做的地方是在`AvoiderWorld`中创建敌人时。思考一下，对于每个创建的敌人，你将得到一些分数，因为你最终需要避开它。以下是你在`AvoiderWorld`中的`act()`方法应该如何更改：
- en: '[PRE18]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The only thing I changed was adding the comment about points and adding the
    call to `setValue()` on `scoreBoard`. This line of code retrieves the current
    score using `getValue()`, adds 1 to it, and then sets the new value using `setValue()`.
    The typical usage of the `Counter` class is also provided in a comment at the
    top of the `Counter` class. Check it out!
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我所做的唯一改变是添加了关于分数的注释，并在`scoreBoard`上添加了对`setValue()`的调用。这段代码使用`getValue()`获取当前分数，将其加1，然后使用`setValue()`设置新值。`Counter`类的典型用法也在`Counter`类的顶部注释中提供。查看它！
- en: Compile your `AvoiderGame` scenario and try it out. Are you getting an increased
    score?
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 编译你的`AvoiderGame`场景并尝试运行。你是否得到了增加的分数？
- en: Adding levels
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加等级
- en: Our game isn't very challenging at this point. One thing we could do, is make
    the game become more challenging over time. To do this, we are going to add the
    notion of levels to Avoider Game. We are going to increase the challenge of the
    game by periodically increasing the rate at which enemies spawn and the speed
    at which they travel.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的游戏并不具有很大的挑战性。我们可以做的一件事是，让游戏随着时间的推移变得更加具有挑战性。为此，我们将在Avoider游戏中加入等级的概念。我们将通过定期增加敌人生成的速率和敌人移动的速度来增加游戏的挑战性。
- en: Increasing spawn rates and enemy speed
  id: totrans-280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 增加生成速率和敌人速度
- en: In `AvoiderWorld`, add two variables, `enemySpawnRate` and `enemySpeed`, and
    give them initial values; we will use these two variables to increase difficulty.
    The top of your `AvoiderWorld` class should look like *Figure 26*.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AvoiderWorld`中添加两个变量，`enemySpawnRate`和`enemySpeed`，并给它们设置初始值；我们将使用这两个变量来增加难度。你的`AvoiderWorld`类的顶部应该看起来像*图26*。
- en: '![Increasing spawn rates and enemy speed](img/image00263.jpeg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![增加出生率和敌人速度](img/image00263.jpeg)'
- en: 'Figure 26: This shows the variables in AvoiderWorld'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图26：这显示了AvoiderWorld中的变量
- en: Increasing difficulty based on the score
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 根据得分增加难度
- en: 'Next, we need to add a method that increases the difficulty of the game based
    on the player''s score. To do this, we need to add the following method to `AvoiderWorld`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加一个方法，根据玩家的得分增加游戏的难度。为此，我们需要将以下方法添加到`AvoiderWorld`中：
- en: '[PRE19]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We introduced a new variable, `nextLevel`, in `increaseLevel()`, and we need
    to add its declaration at the top of the `AvoiderWorld` class. Here is the declaration
    you need to add next to the variable declarations of `enemySpawnRate` and `enemySpeed`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在`increaseLevel()`中，我们引入了一个新的变量`nextLevel`，我们需要在`AvoiderWorld`类的顶部添加其声明。以下是您需要添加到`enemySpawnRate`和`enemySpeed`变量声明旁边的声明：
- en: '[PRE20]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As evident from the code in `increaseLevel()`, we increase both `enemySpawnRate`
    and `enemySpeed` as the player''s score increases. The last thing we need to do
    is use the `enemySpawnRate` and `enemySpeed` variables in the creation of enemies
    and call `increaseLevel()` from the `act()` method in `AvoiderWorld`. Here is
    the new `act()` method:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 从`increaseLevel()`函数中的代码可以看出，随着玩家得分的增加，我们同时增加了`enemySpawnRate`和`enemySpeed`。我们需要做的最后一件事是在`AvoiderWorld`的`act()`方法中使用`enemySpawnRate`和`enemySpeed`变量来创建敌人，并从`AvoiderWorld`的`act()`方法中调用`increaseLevel()`。以下是新的`act()`方法：
- en: '[PRE21]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Implementing enemy speed increases
  id: totrans-291
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现敌人速度增加
- en: I'd love to yell *compile and run!* at this point, but there is one last detail.
    In the `act()` method, we use the line `e.setSpeed(enemySpeed);` to change the
    speed of the enemy; however, we never have implemented that method in the `Enemy`
    class. In addition, we need to change the `Enemy` class a bit to use the newly
    set speed.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在很想大声喊出*编译并运行!*，但还有一个细节。在`act()`方法中，我们使用`e.setSpeed(enemySpeed);`这一行来改变敌人的速度；然而，我们从未在`Enemy`类中实现过该方法。此外，我们还需要对`Enemy`类进行一些修改，以便使用新设置的速度。
- en: '*Figure 27* gives the complete code for the `Enemy` class.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '*图27*给出了`Enemy`类的完整代码。'
- en: '![Implementing enemy speed increases](img/image00264.jpeg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![实现敌人速度增加](img/image00264.jpeg)'
- en: 'Figure 27: This shows the finished Enemy class'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图27：这显示了完成的Enemy类
- en: As you can see, we made some really simple changes to the `Enemy` class. We
    added the `setSpeed()` method, which simply accepts an integer parameter and uses
    that value to set the `speed` variable that has been declared at the top of the
    class. In the `act()` method, we use the value of the `speed` variable in the
    `setLocation()` call; we continually add `speed` to the current *y* coordinate.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们对`Enemy`类进行了一些非常简单的修改。我们添加了`setSpeed()`方法，该方法简单地接受一个整数参数，并使用该值来设置在类顶部声明的`speed`变量。在`act()`方法中，我们使用`speed`变量的值在`setLocation()`调用中；我们不断地将`speed`添加到当前的*y*坐标。
- en: '*Compile and run and enjoy your new game!*'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '*编译并运行，享受你的新游戏！*'
- en: Your assignment
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你的任务
- en: 'Since this is the end of the Avoider Game instruction. I''m going to give you
    a few challenge assignments. Good luck! Try to implement the following:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是Avoider游戏的结束说明。我将给你一些挑战性任务。祝你好运！尝试实现以下内容：
- en: Once the player's score is above 600, add a new enemy that spawns in addition
    to the enemies we have now. The new enemy should visually be very distinct from
    our existing enemies. If you are feeling up to it, have the new enemy move differently
    from the existing enemies too.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦玩家的得分超过600，除了我们现在拥有的敌人外，还需要添加一个新敌人。新敌人应该在外观上与我们的现有敌人非常不同。如果你觉得可以，让新敌人的移动方式也与现有敌人不同。
- en: Periodically, spawn a power-up that gives our hero a special ability. For example,
    the power-up could make our hero temporarily invincible, allow our hero to kill
    three enemies, or shrink the size of the avatar making it easier to avoid enemies.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期生成一个提供英雄特殊能力的道具。例如，这个道具可以使英雄暂时无敌，允许英雄杀死三个敌人，或者缩小英雄的大小，使其更容易躲避敌人。
- en: Display the player's final score on the game-over screen.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在游戏结束屏幕上显示玩家的最终得分。
- en: These challenges will definitely take some time and you should not feel compelled
    to try them. I just wanted to give those who are really interested a way to continue
    working on the Avoider Game. You will not need to have completed these challenges
    to move on to the next chapter.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这些挑战肯定需要一些时间，你不应该感到必须尝试它们。我只是想给那些真正感兴趣的人提供一个继续在Avoider游戏上工作的方法。你不需要完成这些挑战就可以进入下一章。
- en: Next…
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接下来…
- en: Congratulations! You did it! Have fun. Play your new game.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你做到了！祝你好玩。玩你的新游戏。
- en: Summary
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter demonstrated how to make a fun and engaging game. We have mouse
    control, a hero, enemies, a score, and introduction and game-over screens.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了如何制作一个有趣且引人入胜的游戏。我们包含了鼠标控制、一个英雄角色、敌人、得分以及介绍和游戏结束屏幕。
- en: As this book assumes you have some experience working in Greenfoot, this chapter
    also served the purpose of refreshing your memory of how to program in Greenfoot.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书假设您在Greenfoot中已有一些工作经验，因此本章也起到了刷新您对如何在Greenfoot中编程的记忆的作用。
- en: In the upcoming chapters, we'll look at advanced programming concepts in Greenfoot
    that will allow you to create fun, innovative, and engaging applications. These
    chapters will assume that you have mastered the material in this one.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨Greenfoot中的高级编程概念，这些概念将使您能够创建有趣、创新且引人入胜的应用程序。这些章节将假设您已经掌握了本章中的内容。
