- en: Security Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全模式
- en: 'In this chapter, we will look at security pattern concepts and how they can
    help us to implement better security applications. We will also learn about the
    single-sign-on pattern and how this can help us to provide a secure application.
    In addition, we will learn about the authentication mechanism and authentication
    interceptor, focusing on how to implement those concepts. After reading this chapter,
    we will be able to create a security application and implement it using Java EE
    8\. The topics covered in this chapter are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨安全模式的概念以及它们如何帮助我们实现更好的安全应用程序。我们还将了解单点登录模式以及它如何帮助我们提供安全的应用程序。此外，我们还将了解认证机制和认证拦截器，重点关注如何实现这些概念。阅读本章后，我们将能够创建一个安全应用程序并使用Java
    EE 8实现它。本章涵盖的主题如下：
- en: Explaining the concept of security patterns
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释安全模式的概念
- en: Explaining the concept of the single-sign-on pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释单点登录模式的概念
- en: Implementing the single-sign-on pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现单点登录模式
- en: Explaining the authentication mechanism
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释认证机制
- en: Implementing the authentication mechanism
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现认证机制
- en: Explaining the authentication interceptor
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释认证拦截器
- en: Implementing the authentication interceptor
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现认证拦截器
- en: Explaining the concept of security patterns
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释安全模式的概念
- en: 'Applications have a close relationship with data and its storage. This is because
    applications basically consist of managing data in order to make it possible to
    optimize the business using automation tasks, helping with decision-making, organizing
    tasks, and managing certain areas. Also, many companies need to store delicate
    data and validate access control. Over time, the demand for security software
    grew significantly, and many companies increasingly invested in creating safe applications.
    An integral element of security is security information, which follows these basic
    principles:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序与数据和其存储有密切关系。这是因为应用程序基本上由管理数据组成，以便通过自动化任务优化业务，帮助决策，组织任务和管理特定区域。此外，许多公司需要存储敏感数据并验证访问控制。随着时间的推移，对安全软件的需求显著增长，许多公司越来越多地投资于创建安全的应用程序。安全的一个基本要素是安全信息，它遵循以下基本原则：
- en: '**Confidentiality**: The data should not be accessible to non-authorized users
    or to any entities that request access to the data.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机密性**：数据不应被非授权用户或请求访问数据的任何实体访问。'
- en: '**Integrity**: The data cannot be updated or modified in a non-authorized manner.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完整性**：数据不能以非授权的方式更新或修改。'
- en: '**Availability**: The data should be available when it is needed.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：数据应在需要时可用。'
- en: '**Non-repudiation**: Users cannot repudiate or deny the relation using data
    or any other process.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可否认性**：用户不能使用数据或任何其他过程否认或否认关系。'
- en: For an application to be safe, it needs to provide at least these basic principles.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使应用程序安全，它需要提供至少以下基本原则。
- en: Security patterns are a set of solutions to common security problems that occur
    over and over. A large part of these security patterns works to solve problems
    about authentication, which is associated with confidentiality and integrity principles.
    With security patterns, the developer can write software with a high level of
    security for targeting known problems and issues using solutions that are tested
    and validated.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 安全模式是一组针对常见安全问题的解决方案，这些问题反复出现。这些安全模式中的很大一部分致力于解决与认证相关的问题，这与机密性和完整性原则相关。使用安全模式，开发者可以编写具有高安全性的软件，针对已知的问题和问题使用经过测试和验证的解决方案。
- en: Explaining the concept of the single-sign-on pattern
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释单点登录模式的理念
- en: In a business environment, it is very common that, when a user logs in to a
    system, they are automatically logged into various other systems within the business
    without having to input their login details more than once. One example of this
    is Google services. Here, if a user logs in to one Google application (Gmail,
    YouTube, Google Drive), they are logged in to all the available Google services. For
    example, if we log in to Gmail, we can access YouTube without having to log in
    again.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在商业环境中，当用户登录到系统时，他们通常会自动登录到业务内的各种其他系统，而无需再次输入他们的登录详细信息。一个例子是谷歌服务。在这里，如果用户登录到一个谷歌应用程序（Gmail、YouTube、Google
    Drive），他们将登录到所有可用的谷歌服务。例如，如果我们登录到Gmail，我们可以访问YouTube而无需再次登录。
- en: 'Single-sign-on is a security pattern that creates an authentication service
    that is shared with several applications of a domain to make the centered validation
    of authentication and authenticates a user only once in this domain. The user
    can then access all applications of this domain without having to authenticate
    again. All applications that depend on this type communicate with service authentication
    in order to validate the authentication of a user and log in if they are not yet logged
    in. These applications can be made in any language or technology and can stay
    in several networks or separate physical locations. In the following diagram,
    we can see the process of authentication using single-sign-on:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 单点登录是一种安全模式，它创建了一个认证服务，该服务被一个域的多个应用程序共享，以实现认证的中心验证，并在这个域中只对用户进行一次认证。用户随后可以访问该域的所有应用程序，而无需再次进行认证。所有依赖于此类型的应用程序都会与认证服务通信，以验证用户的认证并登录，如果他们尚未登录。这些应用程序可以用任何语言或技术制作，并可以位于多个网络或不同的物理位置。在下面的图中，我们可以看到使用单点登录的认证过程：
- en: '![](img/0df504d4-646b-43aa-913f-356b740f00f1.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0df504d4-646b-43aa-913f-356b740f00f1.png)'
- en: In the preceding figure, we have three applications that are accessed by a user
    as well as a single point to log in and validate authentication. This single point
    is shown in our diagram by **Authentication Service**. When a user (represented
    by **Actor** in the diagram) sends a request to an application (**Application
    1**, **Application 2**, or **Application 3**), this application waits for **Authentication
    Service** to validate whether the user is logged in. If not, they are redirected
    to the login page, and the user can log in there. After the user logs in, when
    they access **Application 1**, **Application 2**, or **Application 3**, they will
    not need to log in again.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们有三个用户可以访问的应用程序以及一个登录和验证认证的单一点。这个单一点在我们的图中通过**认证服务**表示。当用户（在图中由**参与者**表示）向一个应用程序（**应用程序
    1**、**应用程序 2**或**应用程序 3**）发送请求时，该应用程序等待**认证服务**验证用户是否已登录。如果没有，他们将被重定向到登录页面，用户可以在那里登录。用户登录后，当他们访问**应用程序
    1**、**应用程序 2**或**应用程序 3**时，他们不需要再次登录。
- en: The single-sign-off pattern is a process that occurs when a user logs out of
    something. At this point, they are then logged out from all applications that
    they were logged in to by the authentication service. This is a good pattern because
    it makes it possible to log in and out of all applications only once, and it also
    separates all authentication logic from business logic, putting it into a separate
    service. This then promotes the decoupling of authentication logic and business
    logic, making it possible to change the logic authentication without impacting
    the business logic. This pattern can be done using OAuth, SAML, or a custom process
    of authentication. In a real-world situation, it is very common to use third-party
    solutions, such as OAuth0 and **Red Hat single-sign-on** (**RH-SSO**). In our
    example, we will complete a custom authentication process.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 单点注销模式是在用户注销某个东西时发生的过程。此时，他们将从这个认证服务登录的所有应用程序中注销。这是一个很好的模式，因为它使得用户只需登录和注销一次即可，同时也将所有认证逻辑从业务逻辑中分离出来，将其放入一个独立的服务中。这促进了认证逻辑和业务逻辑的解耦，使得在不影响业务逻辑的情况下更改认证逻辑成为可能。此模式可以使用OAuth、SAML或自定义认证过程来实现。在现实世界中，使用第三方解决方案非常普遍，例如OAuth0和**红帽单点登录**（**RH-SSO**）。在我们的例子中，我们将完成一个自定义认证过程。
- en: Implementing the single-sign-on pattern
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现单点登录模式
- en: 'In our example of implementing **single-sign-on** (**SSO**), we will create
    the authentication service through a custom process to authenticate the users
    and we will also allow the user to log in using their login credentials. After
    this, one token will be generated and sent to the user. Further, we will create
    two applications (`App1` and `App2`), and when the user tries to access these
    applications when not logged in, the application will authenticate the user on
    the authentication service and the user will access `App1` and `App2` without
    having to log in again. The authentication service will be a REST application
    written using JAX-RS, and `App1` and `App2` will be applications that implement
    a JAX-RS client to validate user access. With this, the following classes will
    be created to use with our example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现 **单点登录**（**SSO**）的示例中，我们将通过自定义过程创建认证服务以认证用户，并允许用户使用其登录凭证登录。之后，将生成一个令牌并发送给用户。进一步，我们将创建两个应用程序（`App1`
    和 `App2`），当用户尝试在不登录的情况下访问这些应用程序时，应用程序将在认证服务上验证用户，用户将无需再次登录即可访问 `App1` 和 `App2`。认证服务将是一个使用
    JAX-RS 编写的 REST 应用程序，而 `App1` 和 `App2` 将是实现 JAX-RS 客户端以验证用户访问的应用程序。因此，将创建以下类以配合我们的示例使用：
- en: '`AuthenticationResource`: This is responsible for processing the login request
    and validating the authentication of a user. This class is written using JAX-RS
    and is inside the authentication service application.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AuthenticationResource`：此功能负责处理登录请求并验证用户的认证。此类使用 JAX-RS 编写，位于认证服务应用程序内部。'
- en: '`AuthSession`: This is a session that contains data and information about logins.
    This class has the application scope, that is, a Java EE scope.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AuthSession`：这是一个包含登录数据和信息的会话。此类具有应用程序范围，即 Java EE 范围。'
- en: '`Auth`: This is a bean that represents the logged-in user. This class contains
    the user''s login details, password, and date of the last login.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Auth`：这是一个表示已登录用户的 Bean。此类包含用户的登录详情、密码和上次登录日期。'
- en: '`TokenUtils`: This is a class that contains a method for generating tokens.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TokenUtils`：这是一个包含生成令牌方法的类。'
- en: '`App1`: This app sends the `Welcome to App1` text if the user is logged in.
    If the user is not logged in, this application launches an error.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`App1`：如果用户已登录，则此应用程序发送 `Welcome to App1` 文本。如果用户未登录，则此应用程序会引发错误。'
- en: '`App2`: This app sends the `Welcome to App2` text if the user is logged in.
    If the user is not logged in, this application launches an error.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`App2`：如果用户已登录，则此应用程序发送 `Welcome to App2` 文本。如果用户未登录，则此应用程序会引发错误。'
- en: '`Auth`: This is an interface with methods responsible for calling the authentication
    services.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Auth`：这是一个具有调用认证服务方法的责任的接口。'
- en: '`AuthImpl`: This is a class that implements the `Auth` interface. This class
    is an EJB.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AuthImpl`：这是一个实现 `Auth` 接口的类。此类是一个 EJB。'
- en: The `App1` and `App2` applications don't have any process or logic that is required
    in order to log a user in; this is the responsibility of the authentication service
    (the resource that validates the authentication), which has the `AuthenticationResource`
    class with this responsibility.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`App1` 和 `App2` 应用程序没有登录所需的任何流程或逻辑；这是认证服务的责任（验证认证的资源），该服务具有负责此功能的 `AuthenticationResource`
    类。'
- en: Implementing the AuthenticationResource class
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 `AuthenticationResource` 类
- en: '`AuthenticationResource` is a JAX-RS resource, which makes it possible to log
    in and validates the authentication of an application. In the following code,
    we have its implementation:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthenticationResource` 是一个 JAX-RS 资源，这使得登录和验证应用程序的认证成为可能。在下面的代码中，我们有它的实现：'
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding code block, we have `AuthenticationResource`, which contains
    the `authSession` attribute that is used to persist the information about the
    login on the data source and obtain access to data sources that contain users''
    information used to validate login credentials. Further, `AuthenticationResource`
    has two methods: `login(String login, String password)`, which is used to process
    the login request, and `checkAuthentication( String token)`, which is used to
    allow clients to check whether a user is authenticated. In the following code
    block, we have the `login` method which is used to log a user in:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们有`AuthenticationResource`，它包含用于在数据源中持久化登录信息并获取包含用于验证登录凭证的用户信息的数据源的`authSession`属性。此外，`AuthenticationResource`有两个方法：`login(String
    login, String password)`，用于处理登录请求，以及`checkAuthentication(String token)`，用于允许客户端检查用户是否已认证。在下面的代码块中，我们有`login`方法，用于登录用户：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code block, we can see that if a user is already logged in,
    the token is returned as a response. If the user is not logged in, the login and
    password details are validated and a new token is generated and returned as a
    response. Note that this method is called when the client sends a `POST` request
    to this resource.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们可以看到如果用户已经登录，则返回一个令牌作为响应。如果用户未登录，则验证登录和密码详情，并生成一个新的令牌作为响应返回。注意，当客户端向该资源发送`POST`请求时，会调用此方法。
- en: 'The other method is `checkAuthentication( String token)`, which is used to
    allow clients to check whether a user is authenticated. In the preceding code
    block, we have this method. This method returns the 200 HTTP status code to the
    client if it is logged in, or returns the 401 HTTP status code if it is not logged
    in:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个方法是`checkAuthentication(String token)`，用于允许客户端检查用户是否已认证。在先前的代码块中，我们有这个方法。如果用户已登录，则该方法向客户端返回200
    HTTP状态码，如果用户未登录，则返回401 HTTP状态码：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that the `checkAuthentication(String token)` method is called when the
    client sends a `HEAD` request.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当客户端发送`HEAD`请求时，会调用`checkAuthentication(String token)`方法。
- en: 'The `AuthSession` class is used in the `AuthenticationResource` class. The `AuthSession`
    class has an application scope and is used to persist information about users
    that are logged in and has a data source that contains all users'' login credentials:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthSession`类在`AuthenticationResource`类中使用。`AuthSession`类具有应用范围，用于持久化有关已登录用户的信息，并且有一个包含所有用户登录凭证的数据源：'
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`Auth` is a bean that contains information about users'' login details:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Auth`是一个包含用户登录详情信息的bean：'
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As demonstrated, `TokenUtils` is a class that uses the `generateToken()` method to
    generate a new token:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，`TokenUtils`是一个使用`generateToken()`方法生成新令牌的类：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Implementing the App1 and App2 classes
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现`App1`和`App2`类
- en: 'In the preceding code block, we have the code of the `App1` application. When
    this application is accessed by a `GET` request, a request is sent to the authentication
    service to validate whether the user has already logged in:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们有`App1`应用的代码。当这个应用通过一个`GET`请求被访问时，会向认证服务发送一个请求以验证用户是否已经登录：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, we have the `App1` class, which contains the `auth` parameter,
    which is an EJB used to integrate with the authentication service. Further, this
    class has two methods, called `helloWorld`, with different signatures. In `helloWorld(
    String login, String password )`, the login is completed and then the `Hello World.
    Welcome to App1!` message is sent to the user. In `helloWorld( String token )`,
    the token is validated, and if it is a valid token and the user is logged in,
    the `Hello World. Welcome to App1!` message is sent to the user.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有`App1`类，它包含`auth`参数，这是一个用于与认证服务集成的EJB。此外，这个类有两个名为`helloWorld`的方法，具有不同的签名。在`helloWorld(String
    login, String password)`中，完成登录后，将`Hello World. Welcome to App1!`消息发送给用户。在`helloWorld(String
    token)`中，验证令牌，如果它是有效的令牌并且用户已登录，则将`Hello World. Welcome to App1!`消息发送给用户。
- en: 'In the following code block, we have the `App2` class. This has the same code
    as `App1`, but prints another message to the user. This class stays in another
    application, known as `App2` to us:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们有`App2`类。这个类与`App1`具有相同的代码，但向用户打印另一条消息。这个类位于另一个应用中，对我们来说称为`App2`：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the following code block, we have the `Auth` interface. This interface contains
    the contract with the methods responsible for integrating with the authentication
    service, validating the authentication, and logging in:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们有`Auth`接口。此接口包含与负责与认证服务集成、验证认证和登录的方法的合约：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the following code block, we have the `AuthImpl` class, which is an implementation
    of the `Auth` interface as well as a stateless EJB:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们有`AuthImpl`类，它实现了`Auth`接口，并且是一个无状态的EJB：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code block, we have three methods, called `isLogged`, `login`,
    and `logout`, with the signatures `isLogged(String token)`, `login(String login,
    String password)`, and `logout(String token)`, respectively.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们有三个方法，分别称为`isLogged`、`login`和`logout`，它们的签名分别是`isLogged(String token)`、`login(String
    login, String password)`和`logout(String token)`。
- en: When a user logs in to an application (either `App1` or `App2`), and when the
    user navigates to another application using the token, this user will not need
    to log in again.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户登录到应用程序（无论是`App1`还是`App2`），并且当用户使用令牌导航到另一个应用程序时，此用户将不需要再次登录。
- en: Explaining the authentication mechanism
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释认证机制
- en: 'In an enterprise environment, every application or resource needs to validate
    the user access and guarantee that all users that access these applications or
    resources will be identified and validated to prevent non-authorized access. When
    a user requests access to a protected area, they need to be authenticated and
    then their permissions will be validated by the server. To allow a developer to
    authenticate and validate users, Java EE 8 has to have an Authentication Mechanism,
    which is a common solution in Java EE 8 that allows developers to authenticate
    and validate users in a fast and easy way. The Java EE 8 has five mechanisms to
    authenticate users:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业环境中，每个应用程序或资源都需要验证用户访问并确保所有访问这些应用程序或资源的用户都将被识别和验证，以防止未经授权的访问。当用户请求访问受保护区域时，他们需要进行认证，然后服务器将验证他们的权限。为了允许开发者进行用户认证和验证，Java
    EE 8必须有一个认证机制，这是Java EE 8中的一种常见解决方案，允许开发者以快速和简单的方式对用户进行认证和验证。Java EE 8有五种机制来认证用户：
- en: Basic authentication
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本认证
- en: Form-based authentication
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于表单的认证
- en: Digest authentication
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摘要认证
- en: Client authentication
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端认证
- en: Mutual authentication
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互惠认证
- en: The authentication mechanism works by identifying the roles that define user
    permissions. Identity is generally defined by logging in with a username and password.
    This information about a user needs to be kept in a database, generally called
    a *realm*, to allow the server to validate the information. To use the authentication
    mechanism, we configure it with the deployment descriptor file, using annotation
    or the programmatic way. Usually, we will specify an authentication mechanism
    using annotation or a deployment descriptor file.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 认证机制通过识别定义用户权限的角色来工作。身份通常通过使用用户名和密码登录来定义。关于用户的信息需要保存在一个数据库中，通常称为*域*，以便服务器验证信息。为了使用认证机制，我们使用部署描述符文件对其进行配置，使用注解或编程方式。通常，我们将使用注解或部署描述符文件指定一个认证机制。
- en: Explaining basic authentication
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释基本认证
- en: 'Basic authentication is the default mechanism if the developer uses an authentication
    mechanism without defining it. With this authentication mechanism, if the user
    is not authenticated when they send a request, then a dialog box requesting a
    username and password is returned. This mechanism is not completely safe, because
    the username and password are easily captured, making *man-in-the-middle* attacks
    possible. To use this authentication mechanism, it is recommended to use a secure
    transport mechanism, such as SSL (HTTPS) or a VPN. The following figure represents
    a Java EE tutorial showing what happens when basic authentication is used:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开发者在未定义认证机制的情况下使用认证机制，则基本认证是默认机制。使用这种认证机制时，如果用户在发送请求时未进行认证，则会返回一个请求用户名和密码的对话框。这种机制并不完全安全，因为用户名和密码容易被捕获，使得中间人攻击成为可能。为了使用这种认证机制，建议使用安全的传输机制，例如SSL（HTTPS）或VPN。以下图表示了一个Java
    EE教程，展示了使用基本认证时会发生什么：
- en: '![](img/0de03f79-aab7-42f8-9961-51b7d45f1665.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0de03f79-aab7-42f8-9961-51b7d45f1665.png)'
- en: Explaining form authentication
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释基于表单的认证
- en: Form-based authentication is an authentication mechanism that uses forms to
    request a username and password, allowing the developer to customize the login
    and error screen. When a user requests access to a protected resource, the authentication
    mechanism sends a login page to the user, who then inputs the username and password
    and sends them to the server. If the username or password is not correct, the
    server will return the error page or return the requested resource. This mechanism
    is not safe either, because the username and password are also easily captured
    in this way, making a *man-in-the-middle* attack possible. As mentioned in the
    previous section, it is recommended to use a secure transport mechanism, such
    as SSL (HTTPS) or a VPN, when using this authentication mechanism.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 基于表单的认证是一种使用表单请求用户名和密码的认证机制，允许开发者自定义登录和错误屏幕。当用户请求访问受保护资源时，认证机制会向用户发送登录页面，然后用户输入用户名和密码并发送给服务器。如果用户名或密码不正确，服务器将返回错误页面或返回请求的资源。此机制也不安全，因为用户名和密码也容易以这种方式被捕获，使得中间人攻击成为可能。如前所述，建议在使用此认证机制时使用安全的传输机制，例如SSL（HTTPS）或VPN。
- en: 'The following diagram represents a Java EE tutorial, showing what happens when
    form-based authentication is used:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表示一个Java EE教程，展示了使用基于表单的认证时会发生什么：
- en: '![](img/570365ca-b6b7-449e-bb7b-f3ea8108ee46.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![Java EE教程示例](img/570365ca-b6b7-449e-bb7b-f3ea8108ee46.png)'
- en: Explaining digest authentication
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释摘要认证
- en: Digest authentication is an authentication mechanism that uses a one-way cryptographic
    hash of the password and additional data. With this mechanism, the developer does
    not need to use a secure transport mechanism to protect login credentials. This
    is because this mechanism already provides the security. When a user sends a digest
    to a server, the digest authentication needs a clear-text password available in
    order to digest and validate the access, comparing the clear-text password sent
    with the password saved on the server.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要认证是一种使用密码和附加数据的一向加密散列的认证机制。使用此机制，开发者不需要使用安全的传输机制来保护登录凭证。这是因为此机制已经提供了安全性。当用户向服务器发送摘要时，摘要认证需要明文密码以便进行摘要和验证访问，比较发送的明文密码与服务器上保存的密码。
- en: Explaining client authentication
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释客户端认证
- en: Client authentication is a mechanism that authenticates the client by using
    its public key certificate instead of a username and password, such as in basic
    and form-based authentication. This mechanism is considered more secure because
    it uses HTTP over SSL (HTTPS) and uses the client's public key certificate.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端认证是一种通过使用其公钥证书而不是用户名和密码来认证客户端的机制，例如在基本和基于表单的认证中。此机制被认为更安全，因为它使用基于SSL的HTTP（HTTPS）并使用客户端的公钥证书。
- en: Explaining mutual authentication
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释相互认证
- en: 'Mutual authentication is an authentication mechanism where a server authenticates
    a client and a client authenticates a server. Mutual authentication works with
    *certificate-based* or *username/password-based*. With *certificate-based*, the
    client requests access to a protected resource, then the server responds, sending
    its certificate to the client. After this, the client verifies the server certificate
    and, if the server''s certificate is valid, the client sends its certificate to
    the server. The server then verifies the client''s certificate and, if the client''s
    certificate is valid, the server grants the client access to the protected resource.
    The following diagram shows what happens when mutual authentication with *certificate-**based*
    works:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 相互认证是一种服务器认证客户端，客户端也认证服务器的认证机制。相互认证与基于证书或基于用户名/密码的工作。在基于证书的情况下，客户端请求访问受保护资源，然后服务器响应，向客户端发送其证书。之后，客户端验证服务器证书，如果服务器证书有效，客户端将发送其证书给服务器。服务器随后验证客户端证书，如果客户端证书有效，服务器将授予客户端访问受保护资源的权限。以下图显示了基于证书的相互认证时会发生什么：
- en: '![](img/c6542b6a-f37d-4898-84aa-5ac99109d97c.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![相互认证示例](img/c6542b6a-f37d-4898-84aa-5ac99109d97c.png)'
- en: 'In *username/password-**bas**ed*, the client requests access to a protected
    resource, then the server responds, sending its certificate to the client. The
    client then verifies the server certificate and if it is valid, the client sends
    its username and password to the server. Following this, the server verifies the
    credentials and, if these are valid, the server grants the client access to the
    protected resource. The following diagram shows what happens when mutual authentication
    with *username/password-**based* works:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于**用户名/密码**的认证中，客户端请求访问受保护的资源，然后服务器响应，向客户端发送其证书。客户端随后验证服务器证书，如果它是有效的，客户端将发送其用户名和密码到服务器。随后，服务器验证凭证，如果这些凭证有效，服务器将授予客户端访问受保护资源的权限。以下图示显示了当使用基于**用户名/密码**的相互认证时会发生什么：
- en: '![](img/d0141b09-7f02-40e9-a963-2d9d360fcc66.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d0141b09-7f02-40e9-a963-2d9d360fcc66.png)'
- en: When to use the deployment descriptor, annotation, or programmatic configuration
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用部署描述符、注解或程序化配置
- en: To specify and configure the authentication mechanism, we can either use the deployment
    descriptor file, use annotation, or programmatically define the configuration.
    Generally, we choose annotation because it is easy to use in Java EE projects.
    However, sometimes it easier and more interesting to use deployment descriptors
    or programmatic configuration. If this is the case, what are the appropriate scenarios
    in which to use each?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定和配置认证机制，我们可以使用部署描述符文件、使用注解，或者以程序化的方式定义配置。通常，我们选择注解，因为它在Java EE项目中易于使用。然而，有时使用部署描述符或程序化配置可能更简单、更有趣。如果是这种情况，那么在什么适当的场景下使用每种方法呢？
- en: When we use a deployment descriptor, we define a file of configurations and
    create a configuration to a set of resources. This makes it possible to create
    a single location to configure our security policies and associate it with a set
    of resources. However, when we use an annotation, we define a policy on the specific
    resource and it overrides the deployment descriptor, if it exists. Using annotations,
    we create an authentication's configurations because it doesn't need to set up
    an XML file. However, when we use a programmatic configuration, we can authenticate
    other characteristics that don't exist and we can use the authentication mechanism
    in a dynamic way. Further, when we want to create configurations for a set of
    resources, we can use the deployment descriptor file. When we want to create an
    authentication using dynamic behavior, we use programmatic configuration, and
    when we need to create a configuration in an easy manner, we use annotation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用部署描述符时，我们定义一个配置文件并创建一组资源的配置。这使得我们能够在单个位置配置我们的安全策略并将其与一组资源关联。然而，当我们使用注解时，我们在特定资源上定义一个策略，如果存在部署描述符，它将覆盖部署描述符。使用注解，我们创建认证的配置，因为它不需要设置XML文件。然而，当我们使用程序化配置时，我们可以认证不存在其他特性，并且我们可以以动态的方式使用认证机制。此外，当我们想要为一系列资源创建配置时，我们可以使用部署描述符文件。当我们想要使用动态行为创建认证时，我们使用程序化配置，而当我们需要以简单的方式创建配置时，我们使用注解。
- en: Implementing the authentication mechanism
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现认证机制
- en: 'In our example of implementing an authentication mechanism, we will create
    an application with resources that receive a request and return *hello world*
    messages to the user. However, this resource is protected and the user needs to
    be authenticated in order to access this resource. Further, we will set up some
    security policies and associations through the deployment descriptor file, some
    security policies to some resources using annotation, and some security policies
    to some resources using the programmatic configuration. We will also use basic
    authentication. To configure the security policies using the deployment descriptor
    file and programmatic configuration, we will use a JAX-RS resource. To configure
    the security policies using annotation, we will use a servlet. All of the examples
    used here are secure in a web application, but Java EE 8 permits the use of authentication
    mechanisms on the enterprise application. In this example, the following classes
    are used:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现认证机制的示例中，我们将创建一个包含接收请求并返回 *hello world* 消息给用户的资源的应用程序。然而，此资源受到保护，用户需要认证才能访问此资源。此外，我们将在部署描述符文件中设置一些安全策略和关联，一些安全策略通过注解应用于某些资源，一些安全策略通过程序性配置应用于某些资源。我们还将使用基本认证。为了使用部署描述符文件和程序性配置配置安全策略，我们将使用
    JAX-RS 资源。为了使用注解配置安全策略，我们将使用 Servlet。这里使用的所有示例在 Web 应用中都是安全的，但 Java EE 8 允许在企业应用中使用认证机制。在这个例子中，使用了以下类：
- en: '`web.xml`: This is a deployment descriptor file that is used to configure the
    authentication mechanism.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web.xml`：这是一个用于配置认证机制的部署描述符文件。'
- en: '`HelloWorld`: This is a JAX-RS resource class that contains the authentication
    mechanism used by the deployment descriptor file and the programmatic configuration.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HelloWorld`：这是一个包含由部署描述符文件和程序性配置使用的认证机制的 JAX-RS 资源类。'
- en: '`HelloWorldServlet`: This is a servlet class that contains the authentication
    mechanism used by the annotation.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HelloWorldServlet`：这是一个包含由注解使用的认证机制的 Servlet 类。'
- en: Implementing the web.xml file
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 web.xml 文件
- en: '`web.xml` is a deployment descriptor of a web application and it contains many
    configurations about the web application. In the following deployment descriptor,
    we have the security configurations for our web application:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`web.xml` 是一个 Web 应用的部署描述符，它包含许多关于 Web 应用的配置。在下面的部署描述符中，我们有我们 Web 应用的安全配置：'
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Implementing the HelloWorld class
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 HelloWorld 类
- en: 'The `HelloWorld` class is a JAX-RS resource that responds to requests sent
    to the `/helloworld` path*.* This class has two methods with the respective `helloWorldWithDeploymentDescriptor()`
    and `helloWorldWithProgrammatically()` signatures. In `helloWorldWithDeploymentDescriptor()`,
    the authentication validation is oriented by the deployment descriptor configuration,
    and in `helloWorldWithProgrammatically()`, the authentication validation is oriented
    by codes written by the developer:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`HelloWorld` 类是一个响应发送到 `/helloworld` 路径的请求的 JAX-RS 资源。这个类有两个方法，分别具有 `helloWorldWithDeploymentDescriptor()`
    和 `helloWorldWithProgrammatically()` 签名。在 `helloWorldWithDeploymentDescriptor()`
    中，认证验证由部署描述符配置导向，而在 `helloWorldWithProgrammatically()` 中，认证验证由开发者编写的代码导向：'
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To show the dialog box in the browser in a programmatic manner, use the following
    code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要以程序方式在浏览器中显示对话框，请使用以下代码：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Implementing the HelloWordServlet class
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 HelloWordServlet 类
- en: 'The `HelloWorldServlet` class is a servlet class that responds to requests
    sent to the `/helloworld/annotation`path. This class has a `doGet(HttpServletRequest
    request, HttpServletResponse response)` method that responds to all `GET` requests.
    After this method is processed, a validation of authentication is done, and if
    the user is associated with the `user` role, the method is processed. If not,
    the dialog box is returned to the user:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`HelloWorldServlet` 类是一个响应发送到 `/helloworld/annotation` 路径的请求的 Servlet 类。这个类有一个
    `doGet(HttpServletRequest request, HttpServletResponse response)` 方法，它响应所有 `GET`
    请求。在此方法处理完毕后，进行认证验证，如果用户与 `user` 角色相关联，则处理该方法。如果不相关联，则将对话框返回给用户：'
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Explaining the authentication interceptor
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释认证拦截器
- en: In an enterprise application, authentication is a very important process and
    this can be done using many techniques. In Java EE 8, one of these techniques
    is the interceptor pattern.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业应用中，认证是一个非常重要的过程，这可以通过许多技术来完成。在 Java EE 8 中，这些技术之一是拦截器模式。
- en: The interceptor pattern is an advanced programming technique that makes it possible
    to intercept an object call and process algorithms before or after processing
    the call. This works as **aspect-oriented programming** (**AOP**), which makes
    it possible to include behavior in a process without altering its logic. To implement
    this using Java EE 8, we can use either the EJB interceptor or the CDI interceptor.
    We can also select which kind of interceptor to use, depending on whether we are
    intercepting an EJB class/method or a CDI class/method.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截器模式是一种高级编程技术，它使得在处理对象调用之前或之后拦截对象调用并处理算法成为可能。这就像**面向切面编程**（**AOP**）一样，使得在不改变其逻辑的情况下将行为包含在过程中成为可能。要使用Java
    EE 8实现此功能，我们可以使用EJB拦截器或CDI拦截器。我们还可以根据我们是否正在拦截EJB类/方法或CDI类/方法来选择要使用的拦截器类型。
- en: The authentication interceptor is a technique that uses an interceptor pattern
    either through an EJB interceptor or a CDI interceptor. This is done to add authentication
    logic before or after using the business logic aspect of oriented programming.
    We can then validate the authentication without having to couple the authentication
    logic with the business logic. It is better to use the EJB interceptor with business
    logic in an EJB class, and it is better to use the CDI interceptor with the CDI
    class in a web tier.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 认证拦截器是一种使用EJB拦截器或CDI拦截器通过拦截器模式的技术。这样做是为了在面向业务逻辑的方面使用业务逻辑之前或之后添加认证逻辑。然后我们可以验证认证，而无需将认证逻辑与业务逻辑耦合。在EJB类中使用业务逻辑时，最好使用EJB拦截器，而在Web层中使用CDI类时，最好使用CDI拦截器。
- en: Implementing the authentication interceptor
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现认证拦截器
- en: 'In our final example of implementing the authentication interceptor, we will
    create an application with resources that receives a user request and returns *hello
    world* messages to the user, but this resource is protected and the user needs
    to be authenticated in order to access the resource. However, this protection
    is achieved by authenticating the interceptor implemented using the CDI interceptor,
    which captures a call to a resource and validates the user access. Further, we
    will use the basic authentication mechanism to do an authentication validation;
    the source of the user data will not be managed by the application server and
    Java EE, but by a custom data source. In this example, the following classes are
    used:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现认证拦截器的最终示例中，我们将创建一个包含资源的应用程序，这些资源接收用户请求并向用户返回*hello world*消息，但此资源受到保护，用户需要认证才能访问资源。然而，这种保护是通过使用CDI拦截器实现的拦截器来实现的，它捕获对资源的调用并验证用户访问。此外，我们将使用基本认证机制进行认证验证；用户数据源将由应用程序服务器和Java
    EE管理，而不是由自定义数据源管理。在这个例子中，以下类被使用：
- en: '`DataSource`: This is the data source that contains security user information.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataSource`: 这是一个包含安全用户信息的数据库源。'
- en: '`Auth`: This is the interface used to define a method to validate authentication
    and authorization.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Auth`: 这是一个用于定义验证认证和授权方法的接口。'
- en: '`AuthImpl`: This is the class that implements the `Auth` interface.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AuthImpl`: 这是一个实现`Auth`接口的类。'
- en: '`Authentication`: This is the qualifier used to configure the method to be
    intercepted.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Authentication`: 这是一个用于配置要拦截的方法的限定符。'
- en: '`AuthenticationInterceptor`: This is the interceptor that intercepts a call
    to the `HelloWorld` methods and validates the user access.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AuthenticationInterceptor`: 这是一个拦截对`HelloWorld`方法调用的拦截器，并验证用户访问权限。'
- en: '`HelloWorld`: This is the JAX-RS resource class that contains the authentication
    mechanism used by the deployment descriptor file and programmatic configuration.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HelloWorld`: 这是一个包含部署描述符文件和程序配置中使用的认证机制的JAX-RS资源类。'
- en: '`AuthUtils`: This is the utility class for authentication.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AuthUtils`: 这是一个用于认证的实用工具类。'
- en: Implementing the CDI interceptor
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现CDI拦截器
- en: 'To implement the CDI interceptor, we need to create a qualifier to be used
    to configure a class or method to be intercepted. In the following code block,
    we have a qualifier, called `Authentication`, with a parameter, called roles,
    and these are used to declare the roles that are permitted to access a resource:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现CDI拦截器，我们需要创建一个用于配置要拦截的类或方法的限定符。在下面的代码块中，我们有一个名为`Authentication`的限定符，它有一个名为roles的参数，这些参数用于声明允许访问资源的角色：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the following code block, we have the `AuthenticationInteceptor` class,
    which is used as an interceptor. This class is annotated with the `@Authentication` annotation,
    indicating that this class will intercept all calls to methods annotated with
    `@Authentication` and will process the method annotated with `@AroundInvoke`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们有`AuthenticationInteceptor`类，它用作拦截器。这个类被`@Authentication`注解标注，表示这个类将拦截所有标注了`@Authentication`的方法调用，并将处理标注了`@AroundInvoke`的方法：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that this interceptor expects `HttpServletRequest` and `HttpServletResponse`
    as parameters of the target method. This is done in order to allow for the validation
    of authentication and authorization.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个拦截器期望目标方法的参数为`HttpServletRequest`和`HttpServletResponse`。这样做是为了允许对认证和授权进行验证。
- en: 'In the following code block, we have a snippet of the interceptor. This configures
    a method to process when a call has been intercepted:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们有一个拦截器的片段。它配置了一个在调用被拦截时处理的方法：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the preceding code block, we have the `Auth` interface:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们有`Auth`接口：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the preceding code block, we have the class that implements an `Auth` interface.
    In this class, we will consult information about the user from a data source.
    This class is an EJB:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们有实现`Auth`接口的类。在这个类中，我们将从数据源中查询用户信息。这个类是一个EJB：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding code block, we have a `DataSource` class. This class has the
    logic to read information about users, and all information in this data source
    stays as maps. However, we can save this information in a relational database,
    non-relational database, filesystem, or LDAP. This class has the application scope
    and maintains all security data in memory for all the application life cycles:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们有一个`DataSource`类。这个类包含读取用户信息逻辑，并且在这个数据源中的所有信息都保持为映射形式。然而，我们可以将这些信息保存到关系型数据库、非关系型数据库、文件系统或LDAP中。这个类具有应用范围，并在整个应用生命周期中维护所有安全数据：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the following code block, we have `AuthUtils`. This is an authentication
    utility class. This class uses the `readBasicHeader` method, which receives `HttpServletRequest`
    as a parameter and extracts a username and password if the request uses basic
    authorization:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们有`AuthUtils`。这是一个认证工具类。这个类使用`readBasicHeader`方法，该方法接收`HttpServletRequest`作为参数，并在请求使用基本认证时提取用户名和密码：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the following code block, we have `beans.xml`, which contains an `<interceptors>` tag with
    a declaration of all CDI interceptors. Its configuration is needed for the CDI
    interceptor to work:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们有`beans.xml`，它包含一个`<interceptors>`标签，声明了所有CDI拦截器。CDI拦截器要正常工作，需要这个配置：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Implementing the JAX-RS resource
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现JAX-RS资源
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Note that the `helloWorld(@Context HttpServletRequest request, @Context HttpServletResponse
    response)` method has the `@Authentication(roles={"user})` annotation, along with
    the `HttpServletRequest` and `HttpServletResponse` parameters. With `@Authentication(roles={"user})`,
    we configured the `helloWorld(@Context HttpServletRequest request, @Context HttpServletResponse
    response)` method to be intercepted by `AuthenticationInterceptor`. As previously
    mentioned, the target method must have `HttpServletRequest` and `HttpServletResponse`
    as parameters:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`helloWorld(@Context HttpServletRequest request, @Context HttpServletResponse
    response)`方法具有`@Authentication(roles={"user"})`注解，以及`HttpServletRequest`和`HttpServletResponse`参数。通过`@Authentication(roles={"user"})`，我们配置了`helloWorld(@Context
    HttpServletRequest request, @Context HttpServletResponse response)`方法被`AuthenticationInterceptor`拦截。如前所述，目标方法必须具有`HttpServletRequest`和`HttpServletResponse`作为参数：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered security patterns as well as how to implement a
    security application using Java EE and its best practices. We also looked at single-sign-on
    (SSO), authentication mechanisms, and an authentication interceptor. Further,
    we demonstrated how to implement each of these using Java EE 8.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了安全模式以及如何使用Java EE及其最佳实践实现安全应用。我们还探讨了单点登录（SSO）、认证机制和认证拦截器。此外，我们展示了如何使用Java
    EE 8实现这些功能。
- en: On the topic of a single-sign-on, we implement SSO using JAX-RS and create a
    service to deal with all authentication and authorization logic. As discussed,
    implementing a single-sign-on is generally done by a third-party application,
    such as Red Hat single-sign-on (RH-SSO) or Oracle Enterprise single-sign-on, but
    we can also create our own solution.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在单点登录这个话题上，我们使用JAX-RS实现单点登录，并创建了一个服务来处理所有的认证和授权逻辑。正如讨论的那样，实现单点登录通常由第三方应用程序完成，例如红帽单点登录（RH-SSO）或Oracle企业单点登录，但我们也可以创建自己的解决方案。
- en: We learned about authentication mechanisms and how to use this HTTP tool with
    Java EE 8\. Using Java EE 8, we implemented a basic mechanism, and saved user
    information on an application server at the realm. Further, we demonstrated how
    to implement authentication mechanisms in a servlet and REST resource.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了认证机制以及如何使用Java EE 8中的这个HTTP工具。使用Java EE 8，我们实现了一个基本机制，并在应用服务器上的领域保存了用户信息。此外，我们还演示了如何在servlet和REST资源中实现认证机制。
- en: We implemented an authentication interceptor using a CDI interceptor and configured
    it to intercept a JAX-RS resource. The JAX-RS resource authentication interceptor
    tends to be a better solution, but we can use this solution in a servlet or in
    an EJB class.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用CDI拦截器实现了一个认证拦截器，并将其配置为拦截JAX-RS资源。JAX-RS资源认证拦截器通常是一个更好的解决方案，但我们也可以在servlet或EJB类中使用这个解决方案。
- en: In the next chapter, we will explore deployment patterns, why these are important
    for the success of a project, what blue/green deployment is, why it is important
    to use blue/green deployment, what continuous deployment is, and why we should
    use continuous deployment.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨部署模式，为什么这些模式对于项目的成功至关重要，什么是蓝绿部署，为什么使用蓝绿部署很重要，什么是持续部署，以及为什么我们应该使用持续部署。
