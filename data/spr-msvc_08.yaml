- en: Chapter 8. Containerizing Microservices with Docker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。使用Docker容器化微服务
- en: In the context of microservices, containerized deployment is the icing on the
    cake. It helps microservices be more autonomous by self-containing the underlying
    infrastructure, thereby making the microservices cloud neutral.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务的上下文中，容器化部署是锦上添花。它通过自包含底层基础设施来帮助微服务更加自治，从而使微服务与云中立。
- en: This chapter will introduce the concepts and relevance of virtual machine images
    and the containerized deployment of microservices. Then, this chapter will further
    familiarize readers with building Docker images for the BrownField PSS microservices
    developed with Spring Boot and Spring Cloud. Finally, this chapter will also touch
    base on how to manage, maintain, and deploy Docker images in a production-like
    environment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍虚拟机镜像的概念和相关性，以及微服务的容器化部署。然后，本章将进一步使读者熟悉使用Spring Boot和Spring Cloud开发的BrownField
    PSS微服务构建Docker镜像。最后，本章还将介绍如何在类生产环境中管理、维护和部署Docker镜像。
- en: 'By the end of this chapter, you will learn about:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将了解以下内容：
- en: The concept of containerization and its relevance in the context of microservices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器化概念及其在微服务上下文中的相关性
- en: Building and deploying microservices as Docker images and containers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和部署微服务作为Docker镜像和容器
- en: Using AWS as an example of cloud-based Docker deployments
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以AWS作为基于云的Docker部署的示例
- en: Reviewing the microservice capability model
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查微服务能力模型
- en: 'In this chapter, we will explore the following microservice capabilities from
    the microservice capability model discussed in [Chapter 3](ch03.html "Chapter 3. Applying
    Microservices Concepts"), *Applying Microservices Concepts*:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨[第3章](ch03.html "第3章。应用微服务概念")中讨论的微服务能力模型中的以下微服务能力：
- en: Containers and virtual machines
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器和虚拟机
- en: The private/public cloud
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有/公共云
- en: The microservices repository
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务仓库
- en: 'The model is shown in the following diagram:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型如下图所示：
- en: '![Reviewing the microservice capability model](img/B05447_08_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![审查微服务能力模型](img/B05447_08_01.jpg)'
- en: Understanding the gaps in BrownField PSS microservices
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解BrownField PSS微服务中的空白
- en: In [Chapter 5](ch05.html "Chapter 5. Scaling Microservices with Spring Cloud"),
    *Scaling Microservices with Spring Cloud,* BrownField PSS microservices were developed
    using Spring Boot and Spring Cloud. These microservices are deployed as versioned
    fat JAR files on bare metals, specifically on a local development machine.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html "第5章。使用Spring Cloud扩展微服务")*使用Spring Cloud扩展微服务*中，BrownField
    PSS微服务使用Spring Boot和Spring Cloud开发。这些微服务部署为版本化的fat JAR文件，特别是在本地开发机器上的裸金属上。
- en: In [Chapter 6](ch06.html "Chapter 6. Autoscaling Microservices"), *Autoscaling
    Microservices*, the autoscaling capability was added with the help of a custom
    life cycle manager. In [Chapter 7](ch07.html "Chapter 7. Logging and Monitoring
    Microservices"), *Logging and Monitoring Microservices*, challenges around logging
    and monitoring were addressed using centralized logging and monitoring solutions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章。微服务自动扩展")*微服务自动扩展*中，通过自定义生命周期管理器添加了自动扩展能力。在[第7章](ch07.html
    "第7章。日志和监控微服务")*日志和监控微服务*中，通过集中日志和监控解决方案解决了围绕日志和监控的挑战。
- en: There are still a few gaps in our BrownField PSS implementation. So far, the
    implementation has not used any cloud infrastructure. Dedicated machines, as in
    traditional monolithic application deployments, are not the best solution for
    deploying microservices. Automation such as automatic provisioning, the ability
    to scale on demand, self-service, and payment based on usage are essential capabilities
    required to manage large-scale microservice deployments efficiently. In general,
    a cloud infrastructure provides all these essential capabilities. Therefore, a
    private or public cloud with the capabilities mentioned earlier is better suited
    to deploying Internet-scale microservices.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的BrownField PSS实施仍然存在一些空白。到目前为止，该实施尚未使用任何云基础设施。专用机器，如传统的单片应用部署，不是部署微服务的最佳解决方案。自动化，如自动配置、按需扩展、自助服务和基于使用量的付款，是管理大规模微服务部署所需的基本能力。一般来说，云基础设施提供所有这些基本能力。因此，具有前述能力的私有或公共云更适合部署互联网规模的微服务。
- en: Also, running one microservice instance per bare metal is not cost effective.
    Therefore, in most cases, enterprises end up deploying multiple microservices
    on a single bare metal server. Running multiple microservices on a single bare
    metal could lead to a "noisy neighbor" problem. There is no isolation between
    the microservice instances running on the same machine. As a result, services
    deployed on a single machine may eat up others' space, thus impacting their performance.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在裸金属上运行一个微服务实例并不划算。因此，在大多数情况下，企业最终会在单个裸金属服务器上部署多个微服务。在单个裸金属上运行多个微服务可能会导致“吵闹的邻居”问题。在同一台机器上运行的微服务实例之间没有隔离。因此，部署在单台机器上的服务可能会占用其他服务的空间，从而影响其性能。
- en: An alternate approach is to run the microservices on VMs. However, VMs are heavyweight
    in nature. Therefore, running many smaller VMs on a physical machine is not resource
    efficient. This generally results in resource wastage. In the case of sharing
    a VM to deploy multiple services, we would end up facing the same issues of sharing
    the bare metal, as explained earlier.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是在虚拟机上运行微服务。然而，虚拟机的性能较重。因此，在物理机上运行许多较小的虚拟机并不高效。这通常会导致资源浪费。在共享虚拟机以部署多个服务的情况下，我们将面临与前述共享裸金属相同的问题。
- en: In the case of Java-based microservices, sharing a VM or bare metal to deploy
    multiple microservices also results in sharing JRE among microservices. This is
    because the fat JARs created in our BrownField PSS abstract only application code
    and its dependencies but not JREs. Any update on JRE installed on the machine
    will have an impact on all the microservices deployed on this machine. Similarly,
    if there are OS-level parameters, libraries, or tunings that are required for
    specific microservices, then it will be hard to manage them on a shared environment.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于Java的微服务的情况下，共享VM或裸机来部署多个微服务也会导致在微服务之间共享JRE。这是因为在我们的BrownField PSS抽象中创建的fat
    JAR仅包含应用程序代码及其依赖项，而不包括JRE。在安装在机器上的JRE上进行任何更新都会对部署在该机器上的所有微服务产生影响。同样，如果特定微服务需要OS级参数、库或调整，则在共享环境中很难对其进行管理。
- en: One microservice principle insists that it should be self-contained and autonomous
    by fully encapsulating its end-to-end runtime environment. In order to align with
    this principle, all components, such as the OS, JRE, and microservice binaries,
    have to be self-contained and isolated. The only option to achieve this is to
    follow the approach of deploying one microservice per VM. However, this will result
    in underutilized virtual machines, and in many cases, extra cost due to this can
    nullify benefits of microservices.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个微服务原则坚持认为它应该是自包含的，并通过完全封装其端到端运行时环境来实现自主性。为了符合这一原则，所有组件，如操作系统、JRE和微服务二进制文件，都必须是自包含和隔离的。实现这一点的唯一选择是遵循每个VM部署一个微服务的方法。然而，这将导致虚拟机的利用率不足，并且在许多情况下，由于这种情况而产生的额外成本可能会抵消微服务的好处。
- en: What are containers?
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是容器？
- en: Containers are not revolutionary, ground-breaking concepts. They have been in
    action for quite a while. However, the world is witnessing the re-entry of containers,
    mainly due to the wide adoption of cloud computing. The shortcomings of traditional
    virtual machines in the cloud computing space also accelerated the use of containers.
    Container providers such as **Docker** simplified container technologies to a
    great extent, which also enabled a large adoption of container technologies in
    today's world. The recent popularity of DevOps and microservices also acted as
    a catalyst for the rebirth of container technologies.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 容器并不是革命性的、开创性的概念。它们已经实践了相当长的时间。然而，由于广泛采用云计算，世界正在见证容器的重新进入。传统虚拟机在云计算领域的缺陷也加速了容器的使用。像**Docker**这样的容器提供商大大简化了容器技术，这也使得容器技术在当今世界得到了广泛的应用。最近DevOps和微服务的流行也促成了容器技术的重生。
- en: 'So, what are containers? Containers provide private spaces on top of the operating
    system. This technique is also called operating system virtualization. In this
    approach, the kernel of the operating system provides isolated virtual spaces.
    Each of these virtual spaces is called a container or **virtual engine** (**VE**).
    Containers allow processes to run on an isolated environment on top of the host
    operating system. A representation of multiple containers running on the same
    host is shown as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是容器？容器在操作系统之上提供了私有空间。这种技术也被称为操作系统虚拟化。在这种方法中，操作系统的内核提供了隔离的虚拟空间。这些虚拟空间中的每一个被称为一个容器或**虚拟引擎**（**VE**）。容器允许进程在主机操作系统之上的隔离环境中运行。多个容器在同一主机上运行的表示如下：
- en: '![What are containers?](img/B05447_08_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![什么是容器？](img/B05447_08_02.jpg)'
- en: Containers are easy mechanisms to build, ship, and run compartmentalized software
    components. Generally, containers package all the binaries and libraries that
    are essential for running an application. Containers reserve their own filesystem,
    IP address, network interfaces, internal processes, namespaces, OS libraries,
    application binaries, dependencies, and other application configurations.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是构建、运输和运行组件化软件的简单机制。通常，容器打包了运行应用程序所必需的所有二进制文件和库。容器保留自己的文件系统、IP地址、网络接口、内部进程、命名空间、操作系统库、应用程序二进制文件、依赖项和其他应用程序配置。
- en: There are billions of containers used by organizations. Moreover, there are
    many large organizations heavily investing in container technologies. Docker is
    far ahead of the competition, supported by many large operating system vendors
    and cloud providers. **Lmctfy**, **SystemdNspawn**, **Rocket**, **Drawbridge**,
    **LXD**, **Kurma**, and **Calico** are some of the other containerization solutions.
    Open container specification is also under development.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 组织使用数十亿个容器。此外，许多大型组织都在大力投资容器技术。Docker遥遥领先于竞争对手，得到了许多大型操作系统供应商和云提供商的支持。**Lmctfy**、**SystemdNspawn**、**Rocket**、**Drawbridge**、**LXD**、**Kurma**和**Calico**是其他一些容器化解决方案。开放容器规范也正在开发中。
- en: The difference between VMs and containers
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VM和容器之间的区别
- en: VMs such as **Hyper-V**, **VMWare**, and **Zen** were popular choices for data
    center virtualization a few years ago. Enterprises experienced a cost saving by
    implementing virtualization over the traditional bare metal usage. It has also
    helped many enterprises utilize their existing infrastructure in a much more optimized
    manner. As VMs support automation, many enterprises experienced that they had
    to make lesser management effort with virtual machines. Virtual machines also
    helped organizations get isolated environments for applications to run in.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，**Hyper-V**、**VMWare**和**Zen**等VM是数据中心虚拟化的热门选择。企业通过实施虚拟化而节省了成本，而不是传统的裸机使用。它还帮助许多企业以更加优化的方式利用其现有基础设施。由于VM支持自动化，许多企业发现他们在虚拟机上的管理工作更少。虚拟机还帮助组织获得应用程序运行的隔离环境。
- en: 'Prima facie, both virtualization and containerization exhibit exactly the same
    characteristics. However, in a nutshell, containers and virtual machines are not
    the same. Therefore, it is unfair to make an apple-to-apple comparison between
    VMs and containers. Virtual machines and containers are two different techniques
    and address different problems of virtualization. This difference is evident from
    the following diagram:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，虚拟化和容器化表现出完全相同的特征。然而，总的来说，容器和虚拟机并不相同。因此，在虚拟机和容器之间进行苹果对苹果的比较是不公平的。虚拟机和容器是两种不同的技术，解决虚拟化的不同问题。这种差异可以从以下图表中看出：
- en: '![The difference between VMs and containers](img/B05447_08_03.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![虚拟机和容器之间的区别](img/B05447_08_03.jpg)'
- en: Virtual machines operate at a much lower level compared to containers. VMs provide
    hardware virtualization, such as that of CPUs, motherboards, memory, and so on.
    A VM is an isolated unit with an embedded operating system, generally called a
    **Guest OS**. VMs replicate the whole operating system and run it within the VM
    with no dependency on the host operating system environment. As VMs embed the
    full operating system environment, these are heavyweight in nature. This is an
    advantage as well as a disadvantage. The advantage is that VMs offer complete
    isolation to the processes running on VMs. The disadvantage is that it limits
    the number of VMs one can spin up in a bare metal due to the resource requirements
    of VMs.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与容器相比，虚拟机的操作级别要低得多。虚拟机提供硬件虚拟化，如CPU、主板、内存等。虚拟机是一个独立的单元，内嵌操作系统，通常称为**客户操作系统**。虚拟机复制整个操作系统，并在虚拟机内部运行，不依赖于主机操作系统环境。由于虚拟机嵌入了完整的操作系统环境，因此它们在性质上比较笨重。这既是优势也是劣势。优势在于虚拟机为在虚拟机上运行的进程提供了完全隔离。劣势在于它限制了在裸机上启动虚拟机的数量，因为虚拟机的资源需求。
- en: The size of a VM has a direct impact on the time to start and stop it. As starting
    a VM in turn boots the OS, the start time for VMs is generally high. VMs are more
    friendly with infrastructure teams as it requires a low level of infrastructure
    competency to manage VMs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机的大小直接影响其启动和停止时间。由于启动虚拟机会启动操作系统，因此虚拟机的启动时间通常较长。虚拟机更适合基础设施团队，因为管理虚拟机需要较低水平的基础设施能力。
- en: In the container world, containers do not emulate the entire hardware or operating
    system. Unlike VMs, containers share certain parts of the host kernel and operating
    system. There is no concept of guest OS in the case of containers. Containers
    provide an isolated execution environment directly on top of the host operating
    system. This is its advantage as well as disadvantage. The advantage is that it
    is lighter as well as faster. As containers on the same machine share the host
    operating system, the overall resource utilization of containers is fairly small.
    As a result, many smaller containers can be run on the same machine, as compared
    to heavyweight VMs. As containers on the same host share the host operating system,
    there are limitations as well. For example, it is not possible to set iptables
    firewall rules inside a container. Processes inside the container are completely
    independent from the processes on different containers running on the same host.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器世界中，容器不会模拟整个硬件或操作系统。与虚拟机不同，容器共享主机内核和操作系统的某些部分。在容器的情况下，没有客户操作系统的概念。容器在主机操作系统的顶部直接提供了一个隔离的执行环境。这既是它的优势也是劣势。优势在于它更轻，更快。由于同一台机器上的容器共享主机操作系统，容器的整体资源利用率相当小。因此，与笨重的虚拟机相比，可以在同一台机器上运行许多较小的容器。由于同一主机上的容器共享主机操作系统，也存在一些限制。例如，在容器内部无法设置iptables防火墙规则。容器内的进程与在同一主机上运行的不同容器的进程完全独立。
- en: Unlike VMs, container images are publically available on community portals.
    This makes developers' lives much easier as they don't have to build the images
    from scratch; instead, they can now take a base image from certified sources and
    add additional layers of software components on top of the downloaded base image.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与虚拟机不同，容器镜像在社区门户网站上是公开可用的。这使得开发人员的生活变得更加轻松，因为他们不必从头开始构建镜像；相反，他们现在可以从认证来源获取基础镜像，并在下载的基础镜像上添加额外的软件组件层。
- en: The lightweight nature of the containers is also opening up a plethora of opportunities,
    such as automated build, publishing, downloading, copying, and so on. The ability
    to download, build, ship, and run containers with a few commands or to use REST
    APIs makes containers more developer friendly. Building a new container does not
    take more than a few seconds. Containers are now part and parcel of continuous
    delivery pipelines as well.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的轻量化特性也为自动化构建、发布、下载、复制等提供了大量机会。通过几个命令下载、构建、运行容器或使用REST API使容器更加适合开发人员。构建一个新的容器不会超过几秒钟。容器现在也是持续交付流水线的一部分。
- en: In summary, containers have many advantages over VMs, but VMs have their own
    exclusive strengths. Many organizations use both containers and VMs, such as by
    running containers on top of VMs.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，容器相对于虚拟机有许多优势，但虚拟机也有其独特的优势。许多组织同时使用容器和虚拟机，例如在虚拟机上运行容器。
- en: The benefits of containers
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器的优势
- en: 'We have already considered the many benefits of containers over VMs. This section
    will explain the overall benefits of containers beyond the benefits of VMs:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经考虑了容器相对于虚拟机的许多优势。本节将解释容器的整体优势，超越虚拟机的优势：
- en: '**Self-contained**: Containers package the essential application binaries and
    their dependencies together to make sure that there is no disparity between different
    environments such as development, testing, or production. This promotes the concept
    of Twelve-Factor applications and that of immutable containers. Spring Boot microservices
    bundle all the required application dependencies. Containers stretch this boundary
    further by embedding JRE and other operating system-level libraries, configurations,
    and so on, if there are any.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自包含：容器将必要的应用程序二进制文件和它们的依赖项打包在一起，以确保在开发、测试或生产等不同环境之间没有差异。这促进了十二要素应用程序和不可变容器的概念。Spring
    Boot微服务捆绑了所有必需的应用程序依赖项。容器通过嵌入JRE和其他操作系统级别的库、配置等，进一步扩展了这一边界。
- en: '**Lightweight**: Containers, in general, are smaller in size with a lighter
    footprint. The smallest container, Alpine, has a size of less than 5 MB. The simplest
    Spring Boot microservice packaged with an Alpine container with Java 8 would only
    come to around 170 MB in size. Though the size is still on the higher side, it
    is much less than the VM image size, which is generally in GBs. The smaller footprint
    of containers not only helps spin new containers quickly but also makes building,
    shipping, and storing easier.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻量级：总的来说，容器体积小，占用空间少。最小的容器Alpine大小不到5MB。使用Alpine容器和Java 8打包的最简单的Spring Boot微服务只有大约170MB的大小。虽然大小仍然偏大，但比通常几GB的VM镜像要小得多。容器的较小占用空间不仅有助于快速启动新容器，还使构建、部署和存储更加容易。
- en: '**Scalable**: As container images are smaller in size and there is no OS booting
    at startup, containers are generally faster to spin up and shut down. This makes
    containers the popular choice for cloud-friendly elastic applications.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展：由于容器镜像体积小，在启动时没有操作系统引导，容器通常更快地启动和关闭。这使得容器成为云友好的弹性应用程序的热门选择。
- en: '**Portable**: Containers provide portability across machines and cloud providers.
    Once the containers are built with all the dependencies, they can be ported across
    multiple machines or across multiple cloud providers without relying on the underlying
    machines. Containers are portable from desktops to different cloud environments.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可移植：容器在不同机器和云提供商之间提供可移植性。一旦容器构建完成所有依赖项，它们可以在多台机器或多个云提供商之间移植，而不依赖于底层机器。容器可以从桌面移植到不同的云环境。
- en: '**Lower license cost**: Many software license terms are based on the physical
    core. As containers share the operating system and are not virtualized at the
    physical resources level, there is an advantage in terms of the license cost.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较低的许可成本：许多软件许可条款是基于物理核心的。由于容器共享操作系统，并且在物理资源级别上没有虚拟化，因此在许可成本方面具有优势。
- en: '**DevOps**: The lightweight footprint of containers makes it easy to automate
    builds and publish and download containers from remote repositories. This makes
    it easy to use in Agile and DevOps environments by integrating with automated
    delivery pipelines. Containers also support the concept of *build once* by creating
    immutable containers at build time and moving them across multiple environments.
    As containers are not deep into the infrastructure, multidisciplinary DevOps teams
    can manage containers as part of their day-to-day life.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DevOps：容器的轻量级占用空间使得容易自动化构建，并从远程存储库发布和下载容器。这使得在敏捷和DevOps环境中易于使用，通过与自动交付流水线集成。容器还支持“构建一次”的概念，通过在构建时创建不可变容器，并在多个环境之间移动它们。由于容器并不深入基础设施，多学科的DevOps团队可以将容器作为日常生活的一部分进行管理。
- en: '**Version controlled**: Containers support versions by default. This helps
    build versioned artifacts, just as with versioned archive files.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本控制：容器默认支持版本。这有助于构建有版本的工件，就像有版本的存档文件一样。
- en: '**Reusable**: Container images are reusable artifacts. If an image is built
    by assembling a number of libraries for a purpose, it can be reused in similar
    situations.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可重用：容器镜像是可重用的工件。如果一个镜像是通过组装一些库来实现某个目的，它可以在类似的情况下被重复使用。
- en: '**Immutable containers**: In this concept, containers are created and disposed
    of after usage. They are never updated or patched. Immutable containers are used
    in many environments to avoid complexities in patching deployment units. Patching
    results in a lack of traceability and an inability to recreate environments consistently.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变的容器：在这个概念中，容器在使用后被创建和销毁。它们永远不会被更新或打补丁。不可变的容器在许多环境中被使用，以避免部署单元的补丁复杂性。打补丁会导致无法追踪和无法一致地重新创建环境。
- en: Microservices and containers
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务和容器
- en: There is no direct relationship between microservices and containers. Microservices
    can run without containers, and containers can run monolithic applications. However,
    there is a sweet spot between microservices and containers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务和容器之间没有直接关系。微服务可以在没有容器的情况下运行，容器可以运行单片应用程序。然而，微服务和容器之间存在一个甜蜜点。
- en: Containers are good for monolithic applications, but the complexities and the
    size of the monolith application may kill some of the benefits of the containers.
    For example, spinning new containers quickly may not be easy with monolithic applications.
    In addition to this, monolithic applications generally have local environment
    dependencies, such as the local disk, stovepipe dependencies with other systems,
    and so on. Such applications are difficult to manage with container technologies.
    This is where microservices go hand in hand with containers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 容器适用于单片应用程序，但单片应用程序的复杂性和大小可能会削弱容器的一些优势。例如，使用单片应用程序可能不容易快速启动新容器。除此之外，单片应用程序通常具有本地环境依赖，如本地磁盘、与其他系统的独立依赖等。这些应用程序很难通过容器技术进行管理。这就是微服务与容器相辅相成的地方。
- en: 'The following diagram shows three polyglot microservices running on the same
    host machine and sharing the same operating system but abstracting the runtime
    environment:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了在同一主机上运行的三个多语言微服务，并共享相同的操作系统，但抽象了运行时环境：
- en: '![Microservices and containers](img/B05447_08_04.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![微服务和容器](img/B05447_08_04.jpg)'
- en: The real advantage of containers can be seen when managing many polyglot microservices—for
    instance, one microservice in Java and another one in Erlang or some other language.
    Containers help developers package microservices written in any language or technology
    in a platform- and technology-agnostic fashion and uniformly distribute them across
    multiple environments. Containers eliminate the need to have different deployment
    management tools to handle polyglot microservices. Containers not only abstract
    the execution environment but also how to access the services. Irrespective of
    the technologies used, containerized microservices expose REST APIs. Once the
    container is up and running, it binds to certain ports and exposes its APIs. As
    containers are self-contained and provide full stack isolation among services,
    in a single VM or bare metal, one can run multiple heterogeneous microservices
    and handle them in a uniform way.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当管理许多多语言微服务时，容器的真正优势可以看出来，例如，一个微服务用Java编写，另一个微服务用Erlang或其他语言编写。容器帮助开发人员以平台和技术无关的方式打包任何语言或技术编写的微服务，并统一分布到多个环境中。容器消除了处理多语言微服务的不同部署管理工具的需求。容器不仅抽象了执行环境，还抽象了如何访问服务。无论使用何种技术，容器化的微服务都会暴露REST
    API。一旦容器启动运行，它就会绑定到某些端口并暴露其API。由于容器是自包含的，并在服务之间提供完全的堆栈隔离，在单个VM或裸金属上，可以以统一的方式运行多个异构微服务并处理它们。
- en: Introduction to Docker
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker简介
- en: The previous sections talked about containers and their benefits. Containers
    have been in the business for years, but the popularity of Docker has given containers
    a new outlook. As a result, many container definitions and perspectives emerged
    from the Docker architecture. Docker is so popular that even containerization
    is referred to as **dockerization**.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的部分讨论了容器及其优势。容器已经在业界使用多年，但Docker的流行使容器有了新的前景。因此，许多容器定义和观点都源自Docker架构。Docker如此受欢迎，以至于容器化甚至被称为**dockerization**。
- en: Docker is a platform to build, ship, and run lightweight containers based on
    Linux kernels. Docker has default support for Linux platforms. It also has support
    for Mac and Windows using **Boot2Docker**, which runs on top of Virtual Box.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是一个基于Linux内核构建、运输和运行轻量级容器的平台。Docker默认支持Linux平台。它还支持Mac和Windows，使用**Boot2Docker**，它运行在Virtual
    Box之上。
- en: Amazon **EC2 Container Service** (**ECS**) has out-of-the-box support for Docker
    on AWS EC2 instances. Docker can be installed on bare metals and also on traditional
    virtual machines such as VMWare or Hyper-V.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊**EC2容器服务**（**ECS**）在AWS EC2实例上对Docker有开箱即用的支持。Docker可以安装在裸金属上，也可以安装在传统的虚拟机上，如VMWare或Hyper-V。
- en: The key components of Docker
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker的关键组件
- en: 'A Docker installation has two key components: a **Docker daemon** and a **Docker
    client**. Both the Docker daemon and Docker client are distributed as a single
    binary.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Docker安装有两个关键组件：**Docker守护程序**和**Docker客户端**。Docker守护程序和Docker客户端都作为单个二进制文件分发。
- en: 'The following diagram shows the key components of a Docker installation:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了Docker安装的关键组件：
- en: '![The key components of Docker](img/B05447_08_05.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![Docker的关键组件](img/B05447_08_05.jpg)'
- en: The Docker daemon
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker守护程序
- en: The Docker daemon is a server-side component that runs on the host machine responsible
    for building, running, and distributing Docker containers. The Docker daemon exposes
    APIs for the Docker client to interact with the daemon. These APIs are primarily
    REST-based endpoints. One can imagine that the Docker daemon as a controller service
    running on the host machine. Developers can programmatically use these APIs to
    build custom clients as well.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Docker守护程序是运行在主机上的服务器端组件，负责构建、运行和分发Docker容器。Docker守护程序暴露API供Docker客户端与守护程序交互。这些API主要是基于REST的端点。可以想象Docker守护程序是运行在主机上的控制器服务。开发人员可以以编程方式使用这些API来构建自定义客户端。
- en: The Docker client
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker客户端
- en: The Docker client is a remote command-line program that interacts with the Docker
    daemon through either a socket or REST APIs. The CLI can run on the same host
    as the daemon is running on or it can run on a completely different host and connect
    to the daemon remotely. Docker users use the CLI to build, ship, and run Docker
    containers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Docker客户端是一个远程命令行程序，通过套接字或REST API与Docker守护程序进行交互。CLI可以在与守护程序相同的主机上运行，也可以在完全不同的主机上运行，并远程连接到守护程序。Docker用户使用CLI构建、运输和运行Docker容器。
- en: Docker concepts
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker概念
- en: 'The Docker architecture is built around a few concepts: images, containers,
    the registry, and the Dockerfile.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Docker架构围绕着一些概念构建：镜像、容器、注册表和Dockerfile。
- en: Docker images
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker镜像
- en: One of the key concepts of Docker is the image. A Docker image is the read-only
    copy of the operating system libraries, the application, and its libraries. Once
    an image is created, it is guaranteed to run on any Docker platform without alterations.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的一个关键概念是镜像。Docker镜像是操作系统库、应用程序及其库的只读副本。一旦创建了镜像，它就保证在任何Docker平台上运行而不需要修改。
- en: 'In Spring Boot microservices, a Docker image packages operating systems such
    as Ubuntu, Alpine, JRE, and the Spring Boot fat application JAR file. It also
    includes instructions to run the application and expose the services:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Boot微服务中，Docker镜像打包了操作系统，如Ubuntu、Alpine、JRE和Spring Boot fat应用程序JAR文件。它还包括运行应用程序和暴露服务的指令：
- en: '![Docker images](img/B05447_08_06.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![Docker镜像](img/B05447_08_06.jpg)'
- en: As shown in the diagram, Docker images are based on a layered architecture in
    which the base image is one of the flavors of Linux. Each layer, as shown in the
    preceding diagram, gets added to the base image layer with the previous image
    as the parent layer. Docker uses the concept of a union filesystem to combine
    all these layers into a single image, forming a single filesystem.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，Docker镜像基于分层架构，其中基本镜像是Linux的各种版本之一。如前图所示，每个层都添加到具有前一个镜像作为父层的基本镜像层中。Docker使用联合文件系统的概念将所有这些层组合成单个镜像，形成单个文件系统。
- en: In typical cases, developers do not build Docker images from scratch. Images
    of an operating system, or other common libraries, such as Java 8 images, are
    publicly available from trusted sources. Developers can start building on top
    of these base images. The base image in Spring microservices can be JRE 8 rather
    than starting from a Linux distribution image such as Ubuntu.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型情况下，开发人员不会从头开始构建Docker镜像。操作系统的镜像，或其他常见的库，如Java 8镜像，都可以从可信任的来源公开获取。开发人员可以在这些基本镜像的基础上开始构建。在Spring微服务中，基本镜像可以是JRE
    8，而不是从Ubuntu等Linux发行版镜像开始。
- en: 'Every time we rebuild the application, only the changed layer gets rebuilt,
    and the remaining layers are kept intact. All the intermediate layers are cached,
    and hence, if there is no change, Docker uses the previously cached layer and
    builds it on top. Multiple containers running on the same machine with the same
    type of base images would reuse the base image, thus reducing the size of the
    deployment. For instance, in a host, if there are multiple containers running
    with Ubuntu as the base image, they all reuse the same base image. This is applicable
    when publishing or downloading images as well:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 每次重新构建应用程序时，只有更改的层会被重新构建，其余层保持不变。所有中间层都被缓存，因此，如果没有更改，Docker会使用先前缓存的层并在其上构建。在同一台机器上运行具有相同类型基本镜像的多个容器将重用基本镜像，从而减小部署的大小。例如，在主机上，如果有多个使用Ubuntu作为基本镜像运行的容器，它们都会重用相同的基本镜像。这也适用于发布或下载镜像时：
- en: '![Docker images](img/B05447_08_07.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: Docker镜像
- en: As shown in the diagram, the first layer in the image is a boot filesystem called
    `bootfs`, which is similar to the Linux kernel and the boot loader. The boot filesystem
    acts as a virtual filesystem for all images.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，图像中的第一层是称为`bootfs`的引导文件系统，类似于Linux内核和引导加载程序。引导文件系统充当所有图像的虚拟文件系统。
- en: On top of the boot filesystem, the operating system filesystem is placed, which
    is called `rootfs`. The root filesystem adds the typical operating system directory
    structure to the container. Unlike in the Linux systems, `rootfs`, in the case
    of Docker, is on a read-only mode.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在引导文件系统之上，放置了操作系统文件系统，称为`rootfs`。根文件系统向容器添加了典型的操作系统目录结构。与Linux系统不同，在Docker的情况下，`rootfs`处于只读模式。
- en: On top of `rootfs`, other required images are placed as per the requirements.
    In our case, these are JRE and the Spring Boot microservice JARs. When a container
    is initiated, a writable filesystem is placed on top of all the other filesystems
    for the processes to run. Any changes made by the process to the underlying filesystem
    are not reflected in the actual container. Instead, these are written to the writable
    filesystem. This writable filesystem is volatile. Hence, the data is lost once
    the container is stopped. Due to this reason, Docker containers are ephemeral
    in nature.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 根据需求，其他所需的镜像被放置在`rootfs`之上。在我们的情况下，这些是JRE和Spring Boot微服务的JAR文件。当容器被初始化时，会在所有其他文件系统之上放置一个可写文件系统以供进程运行。进程对底层文件系统所做的任何更改都不会反映在实际容器中。相反，这些更改会被写入可写文件系统。这个可写文件系统是易失性的。因此，一旦容器停止，数据就会丢失。因此，Docker容器是短暂的。
- en: The base operating system packaged inside Docker is generally a minimal copy
    of just the OS filesystem. In reality the process running on top may not use the
    entire OS services. In a Spring Boot microservice, in many cases, the container
    just initiates a CMD and JVM and then invokes the Spring Boot fat JAR.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Docker内部打包的基本操作系统通常是OS文件系统的最小副本。实际上，运行在其上的进程可能并不使用整个OS服务。在Spring Boot微服务中，很多情况下，容器只是启动一个CMD和JVM，然后调用Spring
    Boot的fat JAR。
- en: Docker containers
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker容器
- en: Docker containers are the running instances of a Docker image. Containers use
    the kernel of the host operating system when running. Hence, they share the host
    kernel with other containers running on the same host. The Docker runtime ensures
    that the container processes are allocated with their own isolated process space
    using kernel features such as **cgroups** and the kernel **namespace** of the
    operating system. In addition to the resource fencing, containers get their own
    filesystem and network configurations as well.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Docker容器是Docker镜像的运行实例。容器在运行时使用主机操作系统的内核。因此，它们与在同一主机上运行的其他容器共享主机内核。Docker运行时确保容器进程使用内核功能（如**cgroups**和操作系统的内核**namespace**）分配其自己的隔离进程空间。除了资源隔离，容器还有自己的文件系统和网络配置。
- en: The containers, when instantiated, can have specific resource allocations, such
    as the memory and CPU. Containers, when initiated from the same image, can have
    different resource allocations. The Docker container, by default, gets an isolated
    **subnet** and **gateway** to the network. The network has three modes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化的容器可以具有特定的资源分配，如内存和CPU。从相同镜像初始化的容器可以具有不同的资源分配。Docker容器默认获得独立的**子网**和**网关**。网络有三种模式。
- en: The Docker registry
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker注册表
- en: 'The Docker registry is a central place where Docker images are published and
    downloaded from. The URL [https://hub.docker.com](https://hub.docker.com) is the
    central registry provided by Docker. The Docker registry has public images that
    one can download and use as the base registry. Docker also has private images
    that are specific to the accounts created in the Docker registry. The Docker registry
    screenshot is shown as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Docker注册表是Docker镜像发布和下载的中心位置。URL [https://hub.docker.com](https://hub.docker.com)是Docker提供的中央注册表。Docker注册表有公共镜像，可以下载并用作基本注册表。Docker还有私有镜像，专门针对在Docker注册表中创建的帐户。Docker注册表的截图如下所示：
- en: '![The Docker registry](img/B05447_08_08.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![Docker注册表](img/B05447_08_08.jpg)'
- en: Docker also offers **Docker Trusted Registry**, which can be used to set up
    registries locally on premises.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Docker还提供**Docker Trusted Registry**，可用于在本地部署注册表。
- en: Dockerfile
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Dockerfile
- en: A Dockerfile is a build or scripting file that contains instructions to build
    a Docker image. There can be multiple steps documented in the Dockerfile, starting
    from getting a base image. A Dockerfile is a text file that is generally named
    Dockerfile. The `docker build` command looks up Dockerfile for instructions to
    build. One can compare a Dockerfile to a `pom.xml` file used in a Maven build.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile是一个包含构建Docker镜像的指令的构建或脚本文件。Dockerfile中可以记录多个步骤，从获取基本镜像开始。Dockerfile是一个通常命名为Dockerfile的文本文件。`docker
    build`命令查找Dockerfile以获取构建指令。可以将Dockerfile比作Maven构建中使用的`pom.xml`文件。
- en: Deploying microservices in Docker
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker中部署微服务
- en: This section will operationalize our learning by showcasing how to build containers
    for our BrownField PSS microservices.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将通过展示如何为我们的BrownField PSS微服务构建容器来实现我们的学习。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The full source code of this chapter is available under the `Chapter 8` project
    in the code files. Copy `chapter7.configserver`, `chapter7.eurekaserver`, `chapter7.search`,
    `chapter7.search-apigateway`, and `chapter7.website` into a new STS workspace
    and rename them `chapter8.*`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码可在代码文件的`第8章`项目中找到。将`chapter7.configserver`，`chapter7.eurekaserver`，`chapter7.search`，`chapter7.search-apigateway`和`chapter7.website`复制到新的STS工作区，并将它们重命名为`chapter8.*`。
- en: 'Perform the following steps to build Docker containers for BrownField PSS microservices:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来构建BrownField PSS微服务的Docker容器：
- en: Install Docker from the official Docker site at [https://www.docker.com](https://www.docker.com).
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从官方Docker网站[https://www.docker.com](https://www.docker.com)安装Docker。
- en: 'Follow the **Get Started** link for the download and installation instructions
    based on the operating system of choice. Once installed, use the following command
    to verify the installation:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 按照所选操作系统的下载和安装说明，使用**开始**链接。安装后，使用以下命令验证安装：
- en: '[PRE0]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this section, we will take a look at how to dockerize the **Search** (`chapter8.search`)
    microservice, the **Search API Gateway** (`chapter8.search-apigateway`) microservice,
    and the **Website** (`chapter8.website`) Spring Boot application.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看如何将**Search**(`chapter8.search`)微服务，**Search API Gateway**(`chapter8.search-apigateway`)微服务和**Website**(`chapter8.website`)
    Spring Boot应用程序docker化。
- en: 'Before we make any changes, we need to edit `bootstrap.properties` to change
    the config server URL from localhost to the IP address as localhost is not resolvable
    from within the Docker containers. In the real world, this will point to a DNS
    or load balancer, as follows:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进行任何更改之前，我们需要编辑`bootstrap.properties`，将配置服务器URL从localhost更改为IP地址，因为在Docker容器内无法解析localhost。在现实世界中，这将指向DNS或负载均衡器，如下所示：
- en: '[PRE1]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Replace the IP address with the IP address of your machine.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 用您的机器的IP地址替换IP地址。
- en: 'Similarly, edit `search-service.properties` on the Git repository and change
    localhost to the IP address. This is applicable for the Eureka URL as well as
    the RabbitMQ URL. Commit back to Git after updating. You can do this via the following
    code:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，在Git存储库上编辑`search-service.properties`，将localhost更改为IP地址。这适用于Eureka URL以及RabbitMQ
    URL。更新后提交回Git。您可以通过以下代码执行此操作：
- en: '[PRE2]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Change the RabbitMQ configuration file `rabbitmq.config` by uncommenting the
    following line to provide access to guest. By default, guest is restricted to
    be accessed from localhost only:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过取消注释以下行来更改RabbitMQ配置文件`rabbitmq.config`，以提供对guest的访问。默认情况下，guest只能从本地主机访问：
- en: '[PRE3]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The location of `rabbitmq.config` will be different for different operating
    systems.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`rabbitmq.config`的位置对于不同的操作系统是不同的。'
- en: 'Create a Dockerfile under the root directory of the Search microservice, as
    follows:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Search微服务的根目录下创建一个Dockerfile，如下所示：
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following is a quick examination of the contents of the Dockerfile:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对Dockerfile内容的快速检查：
- en: '`FROM frolvlad/alpine-oraclejdk8`: This tells the Docker build to use a specific
    `alpine-oraclejdk8` version as the basic image for this build. The `frolvlad`
    indicates the repository to locate the `alpine-oraclejdk8` image. In this case,
    it is an image built with Alpine Linux and Oracle JDK 8\. This will help layer
    our application on top of the base image without setting up Java libraries ourselves.
    In this case, as this image is not available on our local image store, the Docker
    build will go ahead and download this image from the remote Docker Hub registry.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM frolvlad/alpine-oraclejdk8`：这告诉Docker构建使用特定的`alpine-oraclejdk8`版本作为此构建的基本镜像。`frolvlad`表示定位`alpine-oraclejdk8`镜像的存储库。在这种情况下，它是使用Alpine
    Linux和Oracle JDK 8构建的镜像。这将帮助我们将应用程序层叠在基本镜像之上，而无需自己设置Java库。在这种情况下，由于此镜像在我们的本地镜像存储中不可用，Docker构建将继续从远程Docker
    Hub注册表下载此镜像。'
- en: '`VOLUME /tmp`: This enables access from the container to the directory specified
    in the host machine. In our case, this points to the `tmp` directory in which
    the Spring Boot application creates working directories for Tomcat. The `tmp`
    directory is a logical one for the container, which indirectly points to one of
    the local directories of the host.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VOLUME /tmp`：这允许容器访问主机机器中指定的目录。在我们的情况下，这指向Spring Boot应用程序为Tomcat创建工作目录的`tmp`目录。`tmp`目录对于容器来说是一个逻辑目录，间接指向主机的一个本地目录。'
- en: '`ADD target/search-1.0.jar search.jar`: This adds the application binary file
    to the container with the destination filename specified. In this case, the Docker
    build copies `target/search-1.0.jar` to the container as `search.jar`.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADD target/search-1.0.jar search.jar`: 这将应用程序二进制文件添加到容器中，并指定目标文件名。在这种情况下，Docker构建将`target/search-1.0.jar`复制到容器中作为`search.jar`。'
- en: '`EXPOSE 8090`: This is to tell the container how to do port mapping. This associates
    `8090` with external port binding for the internal Spring Boot service.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPOSE 8090`: 这是告诉容器如何进行端口映射。这将`8090`与内部Spring Boot服务的外部端口绑定。'
- en: '`ENTRYPOINT ["java","-jar", "/search.jar"]`: This tells the container which
    default application to run when a container is started. In this case, we are pointing
    to the Java process and the Spring Boot fat JAR file to initiate the service.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT ["java","-jar", "/search.jar"]`: 这告诉容器在启动时要运行哪个默认应用程序。在这种情况下，我们指向Java进程和Spring
    Boot fat JAR文件来启动服务。'
- en: 'The next step is to run `docker build` from the folder in which the Dockerfile
    is stored. This will download the base image and run the entries in the Dockerfile
    one after the other, as follows:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是从存储Dockerfile的文件夹运行`docker build`。这将下载基础镜像，并依次运行Dockerfile中的条目，如下所示：
- en: '[PRE5]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output of this command will be as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令的输出将如下所示：
- en: '![Deploying microservices in Docker](img/B05447_08_09.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![在Docker中部署微服务](img/B05447_08_09.jpg)'
- en: Repeat the same steps for Search API Gateway and Website.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对Search API Gateway和Website重复相同的步骤。
- en: 'Once the images are created, they can be verified by typing the following command.
    This command will list out the images and their details, including the size of
    image files:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建完镜像后，可以通过输入以下命令来验证。这个命令将列出镜像及其详细信息，包括镜像文件的大小：
- en: '[PRE6]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output will be as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Deploying microservices in Docker](img/B05447_08_11.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![在Docker中部署微服务](img/B05447_08_11.jpg)'
- en: The next thing to do is run the Docker container. This can be done with the
    `docker run` command. This command will load and run the container. On starting,
    the container calls the Spring Boot executable JAR to start the microservice.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来要做的是运行Docker容器。可以使用`docker run`命令来完成这个操作。这个命令将加载并运行容器。在启动时，容器调用Spring Boot可执行JAR来启动微服务。
- en: 'Before starting the containers, ensure that the Config and the Eureka servers
    are running:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动容器之前，请确保Config和Eureka服务器正在运行：
- en: '[PRE7]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding command starts the Search and Search API Gateway microservices
    and Website.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令启动了Search和Search API Gateway微服务以及网站。
- en: In this example, we are using the host network `(--net host`) instead of the
    bridge network to avoid Eureka registering with the Docker container name. This
    can be corrected by overriding `EurekaInstanceConfigBean`. The host option is
    less isolated compared to the bridge option from the network perspective. The
    advantage and disadvantage of host versus bridge depends on the project.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用主机网络`(--net host`)而不是桥接网络，以避免Eureka注册到Docker容器名称。这可以通过覆盖`EurekaInstanceConfigBean`来纠正。从网络角度来看，主机选项比桥接选项更少隔离。主机与桥接的优势和劣势取决于项目。
- en: Once all the services are fully started, verify with the `docker ps` command,
    as shown in the following screenshot:![Deploying microservices in Docker](img/B05447_08_10.jpg)
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦所有服务都完全启动，可以使用`docker ps`命令进行验证，如下面的屏幕截图所示：![在Docker中部署微服务](img/B05447_08_10.jpg)
- en: The next step is to point the browser to `http://192.168.99.100:8001`. This
    will open the BrownField PSS website.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是将浏览器指向`http://192.168.99.100:8001`。这将打开BrownField PSS网站。
- en: 'Note the IP address. This is the IP address of the Docker machine if you are
    running with Boot2Docker on Mac or Windows. In Mac or Windows, if the IP address
    is not known, then type the following command to find out the Docker machine''s
    IP address for the default machine:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意IP地址。这是Docker机器的IP地址，如果你在Mac或Windows上使用Boot2Docker运行。在Mac或Windows上，如果不知道IP地址，则输入以下命令来找出默认机器的Docker机器IP地址：
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If Docker is running on Linux, then this is the host IP address.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Docker在Linux上运行，那么这就是主机IP地址。
- en: Apply the same changes to **Booking**, **Fares**, **Check-in**, and their respective
    gateway microservices.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对**Booking**、**Fares**、**Check-in**和它们各自的网关微服务应用相同的更改。
- en: Running RabbitMQ on Docker
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker上运行RabbitMQ
- en: 'As our example also uses RabbitMQ, let''s explore how to set up RabbitMQ as
    a Docker container. The following command pulls the RabbitMQ image from Docker
    Hub and starts RabbitMQ:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的示例也使用了RabbitMQ，让我们探讨如何将RabbitMQ设置为Docker容器。以下命令从Docker Hub拉取RabbitMQ镜像并启动RabbitMQ：
- en: '[PRE9]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Ensure that the URL in `*-service.properties` is changed to the Docker host's
    IP address. Apply the earlier rule to find out the IP address in the case of Mac
    or Windows.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 确保`*-service.properties`中的URL已更改为Docker主机的IP地址。在Mac或Windows的情况下，应用之前的规则来找出IP地址。
- en: Using the Docker registry
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker注册表
- en: The Docker Hub provides a central location to store all the Docker images. The
    images can be stored as public as well as private. In many cases, organizations
    deploy their own private registries on premises due to security-related concerns.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub提供了一个集中存储所有Docker镜像的位置。这些镜像可以存储为公共或私有。在许多情况下，由于安全相关的问题，组织会在本地部署自己的私有注册表。
- en: 'Perform the following steps to set up and run a local registry:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来设置和运行本地注册表：
- en: 'The following command will start a registry, which will bind the registry on
    port `5000`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下命令将启动一个注册表，将注册表绑定到端口`5000`上：
- en: '[PRE10]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Tag `search:1.0` to the registry, as follows:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`search:1.0`标记到注册表，如下所示：
- en: '[PRE11]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, push the image to the registry via the following command:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过以下命令将镜像推送到注册表：
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Pull the image back from the registry, as follows:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从注册表中拉取镜像，如下所示：
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Setting up the Docker Hub
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Docker Hub
- en: In the previous chapter, we played with a local Docker registry. This section
    will show how to set up and use the Docker Hub to publish the Docker containers.
    This is a convenient mechanism to globally access Docker images. Later in this
    chapter, Docker images will be published to the Docker Hub from the local machine
    and downloaded from the EC2 instances.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用了本地Docker注册表。本节将展示如何设置和使用Docker Hub来发布Docker容器。这是一个方便的机制，可以全球访问Docker镜像。在本章的后面部分，Docker镜像将从本地机器发布到Docker
    Hub，并从EC2实例下载。
- en: 'In order to do this, create a public Docker Hub account and a repository. For
    Mac, follow the steps as per the following URL: [https://docs.docker.com/mac/step_five/](https://docs.docker.com/mac/step_five/).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，创建一个公共Docker Hub账户和一个存储库。对于Mac，按照以下URL的步骤进行：[https://docs.docker.com/mac/step_five/](https://docs.docker.com/mac/step_five/)。
- en: In this example, the Docker Hub account is created using the `brownfield` username.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，使用`brownfield`用户名创建了Docker Hub账户。
- en: The registry, in this case, acts as the microservices repository in which all
    the dockerized microservices will be stored and accessed. This is one of the capabilities
    explained in the microservices capability model.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，注册表充当微服务存储库，其中所有docker化的微服务将被存储和访问。这是微服务能力模型中解释的能力之一。
- en: Publishing microservices to the Docker Hub
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将微服务发布到Docker Hub
- en: 'In order to push dockerized services to the Docker Hub, follow these steps.
    The first command tags the Docker image, and the second one pushes the Docker
    image to the Docker Hub repository:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要将docker化的服务推送到Docker Hub，请按照以下步骤进行。第一条命令标记Docker镜像，第二条命令将Docker镜像推送到Docker
    Hub存储库：
- en: '[PRE14]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To verify whether the container images are published, go to the Docker Hub repository
    at `https://hub.docker.com/u/brownfield`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证容器镜像是否已发布，请转到Docker Hub存储库`https://hub.docker.com/u/brownfield`。
- en: Repeat this step for all the other BrownField microservices as well. At the
    end of this step, all the services will be published to the Docker Hub.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对所有其他BrownField微服务也重复此步骤。在此步骤结束时，所有服务将被发布到Docker Hub。
- en: Microservices on the cloud
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云上的微服务
- en: One of the capabilities mentioned in the microservices capability model is the
    use of the cloud infrastructure for microservices. Earlier in this chapter, we
    also explored the necessity of using the cloud for microservices deployments.
    So far, we have not deployed anything to the cloud. As we have eight microservices
    in total—`Config-server`, `Eureka-server`, Turbine, RabbitMQ, Elasticsearch, Kibana,
    and Logstash—in our overall BrownField PSS microservices ecosystem, it is hard
    to run all of them on the local machine.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务能力模型中提到的能力之一是使用云基础设施进行微服务。在本章的前面部分，我们还探讨了使用云进行微服务部署的必要性。到目前为止，我们还没有将任何东西部署到云上。由于我们总共有八个微服务——`Config-server`、`Eureka-server`、Turbine、RabbitMQ、Elasticsearch、Kibana和Logstash——在我们的整体BrownField
    PSS微服务生态系统中，很难在本地机器上运行所有这些微服务。
- en: In the rest of this book, we will operate using AWS as the cloud platform to
    deploy BrownField PSS microservices.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们将使用AWS作为云平台来部署BrownField PSS微服务。
- en: Installing Docker on AWS EC2
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在AWS EC2上安装Docker
- en: In this section, we will install Docker on the EC2 instance.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在EC2实例上安装Docker。
- en: This example assumes that readers are familiar with AWS and an account is already
    created on AWS.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 本例假设读者熟悉AWS，并且在AWS上已经创建了一个账户。
- en: 'Perform the following steps to set up Docker on EC2:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤在EC2上设置Docker：
- en: Launch a new EC2 instance. In this case, if we have to run all the instances
    together, we may need a large instance. The example uses **t2.large**.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个新的EC2实例。在这种情况下，如果我们必须同时运行所有实例，可能需要一个大实例。本例使用**t2.large**。
- en: 'In this example, the following Ubuntu AMI image is used: `ubuntu-trusty-14.04-amd64-server-20160114.5
    (ami-fce3c696)`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，使用以下Ubuntu AMI镜像：`ubuntu-trusty-14.04-amd64-server-20160114.5 (ami-fce3c696)`。
- en: 'Connect to the EC2 instance and run the following commands:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到EC2实例并运行以下命令：
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding command will install Docker on an EC2 instance. Verify the installation
    with the following command:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述命令将在EC2实例上安装Docker。使用以下命令验证安装：
- en: '[PRE16]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Running BrownField services on EC2
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在EC2上运行BrownField服务
- en: In this section, we will set up BrownField microservices on the EC2 instances
    created. In this case, the build is set up in the local desktop machine, and the
    binaries will be deployed to AWS.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在创建的EC2实例上设置BrownField微服务。在这种情况下，构建设置在本地桌面机器上，并且二进制文件将部署到AWS。
- en: 'Perform the following steps to set up services on an EC2 instance:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤在EC2实例上设置服务：
- en: 'Install Git via the following command:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下命令安装Git：
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Create a Git repository on any folder of your choice.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任意文件夹上创建一个Git存储库。
- en: Change the Config server's `bootstrap.properties` to point to the appropriate
    Git repository created for this example.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改配置服务器的`bootstrap.properties`，指向为本例创建的适当Git存储库。
- en: Change the `bootstrap.properties` of all the microservices to point to the config-server
    using the private IP address of the EC2 instance.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改所有微服务的`bootstrap.properties`，指向使用EC2实例的私有IP地址的配置服务器。
- en: Copy all `*.properties` from the local Git repository to the EC2 Git repository
    and perform a commit.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将本地Git存储库中的所有`*.properties`复制到EC2 Git存储库并执行提交。
- en: Change the Eureka server URLs and RabbitMQ URLs in the `*.properties` file to
    match the EC2 private IP address. Commit the changes to Git once they have been
    completed.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`*.properties`文件中的Eureka服务器URL和RabbitMQ URL，以匹配EC2私有IP地址。完成后将更改提交到Git。
- en: On the local machine, recompile all the projects and create Docker images for
    the `search`, `search-apigateway`, and `website` microservices. Push all of them
    to the Docker Hub registry.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地机器上重新编译所有项目，并为`search`、`search-apigateway`和`website`微服务创建Docker镜像。将它们全部推送到Docker
    Hub注册表。
- en: Copy the config-server and the Eureka-server binaries from the local machine
    to the EC2 instance.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从本地机器复制配置服务器和Eureka服务器的二进制文件到EC2实例。
- en: Set up Java 8 on the EC2 instance.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在EC2实例上设置Java 8。
- en: 'Then, execute the following commands in sequence:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按顺序执行以下命令：
- en: '[PRE18]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Check whether all the services are working by opening the URL of the website
    and executing a search. Note that we will use the public IP address in this case:
    `http://54.165.128.23:8001`.'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过打开网站的URL并执行搜索来检查所有服务是否正常工作。请注意，在这种情况下我们将使用公共IP地址：`http://54.165.128.23:8001`。
- en: Updating the life cycle manager
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新生命周期管理器
- en: In [Chapter 6](ch06.html "Chapter 6. Autoscaling Microservices"), *Autoscaling
    Microservices*, we considered a life cycle manager to automatically start and
    stop instances. We used SSH and executed a Unix script to start the Spring Boot
    microservices on the target machine. With Docker, we no longer need SSH connections
    as the Docker daemon provides REST-based APIs to start and stop instances. This
    greatly simplifies the complexities of the deployment engine component of the
    life cycle manager.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章。自动缩放微服务")中，*自动缩放微服务*，我们考虑了一个生命周期管理器来自动启动和停止实例。我们使用SSH并执行Unix脚本来在目标机器上启动Spring
    Boot微服务。使用Docker，我们不再需要SSH连接，因为Docker守护程序提供了基于REST的API来启动和停止实例。这极大地简化了生命周期管理器的部署引擎组件的复杂性。
- en: In this section, we will not rewrite the life cycle manager. By and large, we
    will replace the life cycle manager in the next chapter.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们不会重写生命周期管理器。总的来说，我们将在下一章中替换生命周期管理器。
- en: The future of containerization – unikernels and hardened security
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器化的未来 - 单内核和强化安全
- en: Containerization is still evolving, but the number of organizations adopting
    containerization techniques has gone up in recent times. While many organizations
    are aggressively adopting Docker and other container technologies, the downside
    of these techniques is still in the size of the containers and security concerns.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化仍在不断发展，但采用容器化技术的组织数量近年来有所增加。虽然许多组织正在积极采用Docker和其他容器技术，但这些技术的缺点仍在于容器的大小和安全问题。
- en: Currently, Docker images are generally heavy. In an elastic automated environment,
    where containers are created and destroyed quite frequently, size is still an
    issue. A larger size indicates more code, and more code means that it is more
    prone to security vulnerabilities.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Docker镜像通常很大。在一个弹性自动化的环境中，容器经常被创建和销毁，大小仍然是一个问题。更大的大小表示更多的代码，更多的代码意味着更容易受到安全漏洞的影响。
- en: The future is definitely in small footprint containers. Docker is working on
    unikernels, lightweight kernels that can run Docker even on low-powered IoT devices.
    Unikernels are not full-fledged operating systems, but they provide the basic
    necessary libraries to support the deployed applications.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 未来绝对在小型容器中。Docker正在研究单内核，轻量级内核可以在低功率的物联网设备上运行Docker。单内核不是完整的操作系统，但它们提供了支持部署应用程序所需的基本库。
- en: The security issues of containers are much discussed and debated. The key security
    issues are around the user namespace segregation or user ID isolation. If the
    container is on root, then it can by default gain the root privilege of the host.
    Using container images from untrusted sources is another security concern. Docker
    is bridging these gaps as quickly as possible, but there are many organizations
    that use a combination of VMs and Docker to circumvent some of the security concerns.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的安全问题被广泛讨论和辩论。关键的安全问题围绕用户命名空间隔离或用户ID隔离。如果容器在根目录上，则可以默认获取主机的根权限。使用来自不受信任来源的容器镜像是另一个安全问题。Docker正在尽快弥合这些差距，但有许多组织使用虚拟机和Docker的组合来规避一些安全顾虑。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about the need to have a cloud environment when
    dealing with Internet-scale microservices.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了在处理互联网规模的微服务时需要具有云环境的必要性。
- en: We explored the concept of containers and compared them with traditional virtual
    machines. You also learned the basics of Docker, and we explained the concepts
    of Docker images, containers, and registries. The importance and benefits of containers
    were explained in the context of microservices.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了容器的概念，并将其与传统虚拟机进行了比较。您还学习了Docker的基础知识，我们解释了Docker镜像、容器和注册表的概念。在微服务的背景下解释了容器的重要性和好处。
- en: This chapter then switched to a hands-on example by dockerizing the BrownField
    microservice. We demonstrated how to deploy the Spring Boot microservice developed
    earlier on Docker. You learned the concept of registries by exploring a local
    registry as well as the Docker Hub to push and pull dockerized microservices.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，本章转向了一个实际示例，通过将BrownField微服务docker化。我们演示了如何在Docker上部署之前开发的Spring Boot微服务。通过探索本地注册表以及Docker
    Hub来推送和拉取docker化的微服务，您学习了注册表的概念。
- en: As the last step, we explored how to deploy a dockerized BrownField microservice
    in the AWS cloud environment.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们探讨了如何在AWS云环境中部署一个dockerized的BrownField微服务。
