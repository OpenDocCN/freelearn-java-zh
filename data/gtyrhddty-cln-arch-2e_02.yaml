- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: What’s Wrong with Layers?
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 层的问题是什么？
- en: Chances are that you have developed a layered (web) application in the past.
    You might even be doing it in your current project right now.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能你过去已经开发了一个分层（网络）应用。你甚至可能正在你的当前项目中这样做。
- en: Thinking in layers has been drilled into us in computer science classes, tutorials,
    and best practices. It has even been taught in books.[1](#footnote-011)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学课程、教程和最佳实践中，我们已经习惯了层级的思维方式。甚至在书中也有教授。[1](#footnote-011)
- en: '[1](#footnote-011-backlink) Layers as a pattern are, for example, taught in
    *Software Architecture Patterns* by Mark Richards, O''Reilly, 2015.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[1](#footnote-011-backlink) 作为一种模式，层在Mark Richards的《软件架构模式》一书中被教授，O''Reilly，2015年。'
- en: '![Figure 2.1 – A conventional web application architecture consists of a web
    layer, a domain layer, and a persistence layer](img/Figure_02.1_B19916.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 传统Web应用架构由网络层、领域层和持久化层组成](img/Figure_02.1_B19916.jpg)'
- en: Figure 2.1 – A conventional web application architecture consists of a web layer,
    a domain layer, and a persistence layer
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 传统Web应用架构由网络层、领域层和持久化层组成
- en: '*Figure 2**.1* shows a high-level view of the very common three-layer architecture.
    We have a **web layer** that receives requests and routes them to a service in
    the **domain layer**.[2](#footnote-010) The service does some business logic and
    calls components from the **persistence layer** to query for or modify the current
    state of our domain entities in the database.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.1* 展示了非常常见的三层架构的高级视图。我们有一个**网络层**，它接收请求并将它们路由到**领域层**中的服务。[2](#footnote-010)
    该服务执行一些业务逻辑，并从**持久化层**调用组件以查询或修改数据库中我们的领域实体的当前状态。'
- en: '[2](#footnote-010-backlink) Domain versus business: in this book, I use the
    terms “domain” and “business” synonymously. The domain layer or business layer
    is the place in the code that solves the business problems, as opposed to code
    that solves technical problems, like persisting things in a database or processing
    web requests.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[2](#footnote-010-backlink) 领域与业务：在这本书中，我使用“领域”和“业务”这两个词同义。领域层或业务层是代码中解决业务问题的位置，与解决技术问题的代码不同，例如在数据库中持久化事物或处理Web请求。'
- en: You know what? Layers are a solid architecture pattern! If we get them right,
    we’re able to build domain logic that is independent of the web and persistence
    layers. We can switch out the web or persistence technologies without affecting
    our domain logic, if the need arises. We can also add new features without affecting
    existing features.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道吗？层是一种稳固的架构模式！如果我们做得正确，我们就能构建出独立于网络和持久化层的领域逻辑。如果需要的话，我们可以更换网络或持久化技术，而不会影响我们的领域逻辑。我们还可以在不影响现有功能的情况下添加新功能。
- en: With a good layered architecture, we’re keeping our options open and are able
    to quickly adapt to changing requirements and external factors (such as our database
    vendor doubling their prices overnight). A good layered architecture is maintainable.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 好的分层架构使我们保持选择余地，能够快速适应不断变化的需求和外部因素（例如我们的数据库供应商一夜之间将价格翻倍）。好的分层架构是可维护的。
- en: So, what’s wrong with layers?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，层有什么问题呢？
- en: In my experience, a layered architecture is very vulnerable to changes, which
    makes it hard to maintain. It allows bad dependencies to creep in and make the
    software increasingly harder to change over time. Layers don’t provide enough
    guardrails to keep the architecture on track. We need to rely too much on human
    discipline and diligence to keep it maintainable.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，分层架构非常容易受到变化的影响，这使得它难以维护。它允许不良依赖性逐渐渗透，使得软件随着时间的推移越来越难以更改。层没有提供足够的护栏来保持架构的轨迹。我们需要过度依赖人类的纪律和勤奋来保持其可维护性。
- en: In the following sections, I’ll tell you why.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我会告诉你原因。
- en: They promote database-driven design
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它们促进了数据库驱动的设计
- en: By its very definition, the foundation of a conventional layered architecture
    is the database. The web layer depends on the domain layer, which in turn depends
    on the persistence layer and thus the database. Everything builds on top of the
    persistence layer. This is problematic for several reasons.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 根据其定义，传统分层架构的基础是数据库。网络层依赖于领域层，领域层又依赖于持久化层和数据库。一切都是在持久化层之上构建的。这有几个问题。
- en: Let’s take a step back and think about what we’re trying to achieve with almost
    any application we’re building. We’re typically trying to create a model of the
    rules or “policies” that govern the business in order to make it easier for the
    users to interact with them.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们退一步，思考一下我们在构建几乎任何应用程序时试图实现的目标。我们通常试图创建一个模型，以反映管理业务的规则或“政策”，以便用户更容易与之互动。
- en: We’re primarily trying to model behavior, not the state. Yes, the state is an
    important part of any application, but the behavior is what changes the state
    and thus drives the business!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要试图模拟行为，而不是状态。是的，状态是任何应用程序的一个重要部分，但行为是改变状态并因此推动业务的东西！
- en: So, why are we making the database the foundation of our architecture and not
    the domain logic?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们要将数据库作为我们架构的基础，而不是领域逻辑？
- en: Think back to the last use cases you implemented in any application. Did you
    start by implementing the domain logic or the persistence layer? Most likely,
    you thought about what the database structure would look like and only then moved
    on to implementing the domain logic on top of it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 想想你在任何应用程序中最近实现的使用案例。你是从实现领域逻辑还是持久层开始的？很可能是你考虑了数据库结构会是什么样子，然后才继续在它之上实现领域逻辑。
- en: This makes sense in a conventional layered architecture since we’re going with
    the natural flow of dependencies. But it makes absolutely no sense from a business
    point of view! We should build the domain logic before building anything else!
    We want to find out whether we have understood the business rules correctly. And
    only once we know we’re building the right domain logic should we move on to build
    a persistence and web layer around it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的分层架构中，这是有意义的，因为我们遵循依赖关系的自然流动。但从业务角度来看，这完全没有意义！我们应该在构建其他任何东西之前先构建领域逻辑！我们想要弄清楚我们是否正确理解了业务规则。只有当我们知道我们正在构建正确的领域逻辑时，我们才应该继续构建围绕它的持久层和Web层。
- en: A driving force in such a database-centric architecture is the use of **object-relational
    mapping** (**ORM**) frameworks. Don’t get me wrong, I love those frameworks and
    work with them regularly. But if we combine an ORM framework with a layered architecture,
    we’re easily tempted to mix business rules with persistence aspects.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种以数据库为中心的架构中，一个推动力是使用**对象关系映射**（**ORM**）框架。请别误会，我非常喜欢这些框架，并且经常使用它们。但如果我们结合ORM框架和分层架构，我们很容易被诱惑将业务规则与持久性方面混合在一起。
- en: '![Figure 2.2 – Using the database entities in the domain layer leads to strong
    coupling with the persistence layer](img/Figure_02.2_B19916.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 在领域层中使用数据库实体会导致与持久层的强耦合](img/Figure_02.2_B19916.jpg)'
- en: Figure 2.2 – Using the database entities in the domain layer leads to strong
    coupling with the persistence layer
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 在领域层中使用数据库实体会导致与持久层的强耦合
- en: Usually, we have ORM-managed entities as part of the persistence layer, as shown
    in *Figure 2**.2*. Since a layer may access the layers below it, the domain layer
    is allowed to access those entities. And if it’s allowed to use them, it will
    use them at some point.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们将在持久层中作为ORM管理的实体，如图*图2.2*所示。由于一个层可能访问其下方的层，领域层被允许访问这些实体。如果允许它们使用，它们最终会使用它们。
- en: This creates a strong coupling between the domain layer and the persistence
    layer. Our business services use the persistence model as their business model
    and have to deal not only with the domain logic but also with eager versus lazy
    loading, database transactions, flushing caches, and similar housekeeping tasks.[3](#footnote-009)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这在领域层和持久层之间创建了一个强耦合。我们的业务服务使用持久性模型作为它们的业务模型，不仅要处理领域逻辑，还要处理 eager（急切）加载与lazy（延迟）加载、数据库事务、刷新缓存和类似的维护任务。[3](#footnote-009)
- en: '[3](#footnote-009-backlink) In his seminal book *Refactoring* (Pearson, 2018),
    Martin Fowler calls this symptom “divergent change”: having to change seemingly
    unrelated parts of the code to implement a single feature. This is a code smell
    that should trigger a refactoring.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[3](#footnote-009-backlink) 在他的开创性著作《重构》（Pearson，2018）中，马丁·福勒将这种症状称为“发散性变化”：为了实现一个功能而不得不更改看似无关的代码部分。这是一个应该触发重构的代码异味。'
- en: The persistence code is virtually fused into the domain code and thus it’s hard
    to change one without the other. That’s the opposite of being flexible and keeping
    options open, which should be the goal of our architecture.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 持久性代码几乎与领域代码融合在一起，因此很难在不影响另一个的情况下对其进行更改。这与灵活性和保持选项开放的目标相反，而我们的架构应该追求这样的目标。
- en: They’re prone to shortcuts
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它们容易走捷径
- en: In a conventional layered architecture, the only global rule is that from a
    certain layer, we can only access components in the same layer or a layer below.
    There may be other rules that a development team has agreed upon and some of them
    might even be enforced by tooling, but the layered architecture style itself does
    not impose those rules on us.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的分层架构中，唯一的全局规则是从某个层开始，我们只能访问同一层或其下层的组件。可能还有开发团队达成一致的其他规则，其中一些甚至可能由工具强制执行，但分层架构风格本身并不强加这些规则给我们。
- en: So, if we need access to a certain component in a layer above ours, we can just
    push the component down a layer and we’re allowed to access it. Problem solved.
    Doing this once may be OK. But doing it once opens the door for doing it a second
    time. And if someone else was allowed to do it, so am I, right?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们需要访问我们之上层的某个组件，我们只需将组件向下推一层，我们就被允许访问它。问题解决。做一次可能没问题。但做一次就打开了做第二次的门。如果其他人被允许这么做，那么我也被允许，对吧？
- en: I’m not saying that as developers, we take such shortcuts lightly. But if there
    is an option to do something, someone will do it, especially in combination with
    a looming deadline. And if something has been done before, the likelihood of someone
    doing it again will increase drastically. This is a psychological effect called
    the **Broken Windows Theory** – more on this in [*Chapter 11*](B19916_11.xhtml#_idTextAnchor096),
    *Taking* *Shortcuts Consciously*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不是说作为开发者，我们会轻易地采取这样的捷径。但如果有一个做某事的选择，有人会这么做，尤其是在面临即将到来的截止日期的情况下。而且如果某件事已经做过，有人再次做它的可能性会大大增加。这是一种称为**破窗理论**的心理效应
    – 更多内容请见[*第11章*](B19916_11.xhtml#_idTextAnchor096)，*有意识地采取* *捷径*。
- en: '![Figure 2.3 – Since any layer may access everything in the persistence layer,
    it tends to grow fat over time](img/Figure_02.3_B19916.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3 – 由于任何层都可以访问持久层中的所有内容，随着时间的推移，它往往会变得臃肿](img/Figure_02.3_B19916.jpg)'
- en: Figure 2.3 – Since any layer may access everything in the persistence layer,
    it tends to grow fat over time
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – 由于任何层都可以访问持久层中的所有内容，随着时间的推移，它往往会变得臃肿
- en: Over years of development and maintenance of a software project, the persistence
    layer may very well end up like in *Figure 2**.3*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在多年的软件开发和维护过程中，持久层可能会变得像*图2**.3*所示的那样。
- en: The persistence layer (or, in more generic terms, the bottom-most layer) will
    grow fat as we push components down through the layers. Perfect candidates for
    this are helper or utility components since they don’t seem to belong to any specific
    layer.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们通过层将组件向下推，持久层（或者更通用地，最底层的层）会变得臃肿。这种组件的完美候选者是辅助或实用组件，因为它们似乎不属于任何特定的层。
- en: So, if we want to disable *shortcut mode* for our architecture, layers are not
    the best option, at least not without enforcing some kind of additional architecture
    rules. And by *enforcing*, I don’t mean a senior developer doing code reviews,
    but automatically enforced rules that make the build fail when they’re broken.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们想为我们的架构禁用*快捷模式*，层不是最佳选择，至少在没有强制执行某些额外的架构规则的情况下不是。而当我提到*强制执行*时，我并不是指高级开发者进行代码审查，而是当规则被破坏时自动强制执行的规则，导致构建失败。
- en: They grow hard to test
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它们变得难以测试
- en: A common evolution within a layered architecture is that layers are skipped.
    We access the persistence layer directly from the web layer since we’re only manipulating
    a single field of an entity, and for that, we need not bother the domain layer,
    right?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在分层架构中，一个常见的演变是跳过层。我们直接从网络层访问持久层，因为我们只操作一个实体的单个字段，为此，我们不需要麻烦领域层，对吧？
- en: '![Figure 2.4 – Skipping the domain layer tends to scatter domain logic across
    the code base](img/Figure_02.4_B19916.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4 – 跳过领域层往往会将领域逻辑分散到代码库中](img/Figure_02.4_B19916.jpg)'
- en: Figure 2.4 – Skipping the domain layer tends to scatter domain logic across
    the code base
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 跳过领域层往往会将领域逻辑分散到代码库中
- en: '*Figure 2**.4* shows how we’re skipping the domain layer and accessing the
    persistence layer right from the web layer.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2**.4*展示了我们如何跳过领域层，直接从网络层访问持久层。'
- en: Again, this feels OK the first couple of times, but it has two drawbacks if
    it happens often (and it will, once someone has made the first step).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，前几次可能感觉没问题，但如果经常发生（一旦有人迈出了第一步，就会这样），它有两个缺点。
- en: First, we’re implementing domain logic in the web layer, even if it’s only manipulating
    a single field. What if the use case expands in the future? We’re most likely
    going to add more domain logic to the web layer, mixing responsibilities and spreading
    essential domain logic across all layers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在网络层实现领域逻辑，即使它只是操作单个字段。如果用例在未来扩展，我们很可能会在网络层添加更多领域逻辑，混合责任并使关键领域逻辑散布在所有层中。
- en: Second, in the unit tests of our web layer, we not only have to manage the dependencies
    on the domain layer but also the dependencies on the persistence layer. If we’re
    using mocks in our tests, that means we have to create mocks for both layers.
    This adds complexity to the tests. And a complex test setup is the first step
    toward no tests at all because we don’t have time for them. As the web component
    grows over time, it may accumulate a lot of dependencies on different persistence
    components, adding to the test’s complexity. At some point, it takes more time
    for us to understand the dependencies and create mocks for them than to actually
    write test code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，在我们的网络层单元测试中，我们不仅要管理对领域层的依赖，还要管理对持久化层的依赖。如果我们使用模拟进行测试，这意味着我们必须为这两个层创建模拟。这增加了测试的复杂性。而复杂的测试设置是走向完全没有测试的第一步，因为我们没有时间进行它们。随着时间的推移，网络组件可能会积累大量对不同的持久化组件的依赖，从而增加了测试的复杂性。在某个时候，我们理解依赖和为它们创建模拟所需的时间可能比实际编写测试代码的时间还要多。
- en: They hide the use cases
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它们隐藏了用例
- en: As developers, we like to create new code that implements shiny new use cases.
    But we usually spend much more time changing existing code than we do creating
    new code. This is not only true for those dreaded legacy projects in which we’re
    working on a decades-old code base but also for a hot new greenfield project after
    the initial use cases have been implemented.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们喜欢创建实现新用例的新代码。但通常我们花费在修改现有代码上的时间比创建新代码的时间要多得多。这不仅适用于那些令人讨厌的遗留项目，在这些项目中我们正在处理几十年的代码库，也适用于在初始用例实现之后的热门新绿色项目。
- en: Since we’re so often searching for the right place to add or change functionality,
    our architecture should help us to quickly navigate the code base. How does a
    layered architecture hold up in this regard?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们经常需要寻找合适的地点来添加或更改功能，我们的架构应该帮助我们快速导航代码库。分层架构在这方面表现如何？
- en: As already discussed previously, in a layered architecture, it easily happens
    that domain logic is scattered throughout the layers. It may exist in the web
    layer if we’re skipping the domain logic for an “easy” use case. And it may exist
    in the persistence layer if we have pushed a certain component down so it can
    be accessed from both the domain and persistence layers. This already makes finding
    the right spot to add new functionality hard.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在分层架构中，领域逻辑很容易散布在各个层中。如果我们跳过“简单”用例的领域逻辑，它可能存在于网络层。如果我们把某个组件推到持久化层，以便从领域层和持久化层都可以访问它，它可能存在于持久化层。这已经使得找到添加新功能正确位置变得困难。
- en: But there’s more. A layered architecture does not impose rules on the “width”
    of domain services. Over time, this often leads to very broad services that serve
    multiple use cases (see *Figure 2**.5*).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 但还有更多。分层架构并没有对领域服务的“宽度”强加规则。随着时间的推移，这往往会导致非常广泛的服务，服务于多个用例（见图*2**.5*）。
- en: '![Figure 2.5 – “Broad” services make it hard to find a certain use case within
    the code base](img/Figure_02.5_B19916.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 – “广泛”的服务使得在代码库中找到特定用例变得困难](img/Figure_02.5_B19916.jpg)'
- en: Figure 2.5 – “Broad” services make it hard to find a certain use case within
    the code base
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – “广泛”的服务使得在代码库中找到特定用例变得困难
- en: A broad service has many dependencies on the persistence layer and many components
    in the web layer depend on it. This not only makes the service hard to test but
    also makes it hard for us to find the code responsible for the use case we want
    to work on.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 广泛的服务对持久化层有众多依赖，而网络层的许多组件都依赖于它。这不仅使得服务难以测试，也使得我们难以找到我们想要工作的用例所负责的代码。
- en: How much easier would it be if we had highly specialized, narrow domain services
    that each serve a single use case? Instead of searching for the user registration
    use case in `UserService`, we would just open up `RegisterUserService` and start
    hacking away.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们拥有高度专业化的、狭窄的领域服务，每个服务都服务于单个用例，那会容易多少？我们不必在`UserService`中搜索用户注册用例，我们只需打开`RegisterUserService`并开始修改。
- en: They make parallel work difficult
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它们使得并行工作变得困难
- en: Management usually expects us to be done with building the software they sponsor
    on a certain date. Actually, they even expect us to be done within a certain budget
    as well, but let’s not complicate things here.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 管理层通常期望我们在某个日期完成他们资助的软件开发。实际上，他们甚至期望我们在一定的预算内完成，但在这里我们不要使事情复杂化。
- en: Aside from the fact that I have never seen “done” software in my career as a
    software engineer, to be “done” by a certain date usually implies that multiple
    people have to work in parallel.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我作为软件工程师的职业生涯中从未见过“完成”的软件之外，到某个日期“完成”通常意味着多个人必须并行工作。
- en: 'You probably know this famous conclusion from “*The Mythical Man-Month*,” even
    if you haven’t read the book: *Adding manpower to a late software project makes*
    *it later*.[4](#footnote-008)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能知道“*《神话般的月份》*”中的这个著名结论，即使你没有读过这本书：*向一个落后的软件项目增加人力会使它更晚*。[4](#footnote-008)
- en: '[4](#footnote-008-backlink)4 *The Mythical Man-Month: Essays on Software Engineering*
    by Frederick P. Brooks, Jr., Addison-Wesley, 1995.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[4](#footnote-008-backlink)4 《神话般的月份：软件工程论文集》由Frederick P. Brooks, Jr.著，Addison-Wesley，1995年。'
- en: This also holds true, to a degree, in software projects that are not (yet) late.
    You cannot expect a large group of 50 developers to be 5 times faster than a smaller
    team of 10 developers. If they’re working on a very large application where they
    can split up into sub-teams and work on separate parts of the software, it may
    work, but in most contexts, they will step on each other’s feet.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，这也适用于尚未落后的软件项目。你不能期望一个由50名开发者组成的大型团队比一个10人的小团队快5倍。如果他们正在开发一个非常大的应用程序，可以分成子团队并分别处理软件的不同部分，这可能行得通，但在大多数情况下，他们可能会互相干扰。
- en: But on a healthy scale, we can certainly expect to be faster with more people
    on the project. And management is right to expect that of us.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 但在健康规模上，我们当然可以期待随着项目人员的增加而加快速度。管理层有权利期望我们这样做。
- en: To meet this expectation, *our architecture must support parallel work*. This
    is not easy. And a layered architecture doesn’t really help us here.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足这一期望，*我们的架构必须支持并行工作*。这并不容易。而且分层架构在这里实际上并没有太大帮助。
- en: Imagine we’re adding a new use case to our application. We have three developers
    available. One can add the needed features to the web layer, one to the domain
    layer, and the third to the persistence layer, right?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们正在向我们的应用程序添加一个新的用例。我们有三名开发者可用。一个可以添加到网络层所需的功能，一个到领域层，第三个到持久化层，对吧？
- en: Well, it usually doesn’t work that way in a layered architecture. Since everything
    builds on top of the persistence layer, the persistence layer must be developed
    first. Then comes the domain layer and finally the web layer. So only one developer
    can work on the feature at a time!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，在分层架构中，通常不是这样工作的。由于一切都是在持久化层之上构建的，因此持久化层必须首先开发。然后是领域层，最后是网络层。所以一次只能有一个开发者工作在功能上！
- en: “Ah, but the developers can define interfaces first,” you say, “and then each
    developer can work against these interfaces without having to wait for the actual
    implementation.”
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: “啊，但开发者可以先定义接口，”你说，“然后每个开发者都可以针对这些接口工作，而无需等待实际实现。”
- en: Sure, this is possible, but only if we haven’t mixed our domain and persistence
    logic as discussed previously, blocking us from working on each aspect separately.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是可能的，但前提是我们没有像之前讨论的那样混合领域和持久化逻辑，这阻止了我们分别处理每个方面。
- en: If we have broad services in our code base, it may even be hard to work on *different*
    features in parallel. Working on different use cases will cause the same service
    to be edited in parallel, which leads to merge conflicts and potentially regressions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的代码库中服务众多，甚至可能难以并行处理*不同*的功能。在处理不同的用例时，会导致同一服务并行编辑，这会导致合并冲突和潜在的回归。
- en: How does this help me build maintainable software?
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这如何帮助我构建可维护的软件？
- en: If you have built layered architectures in the past, you can probably relate
    to some of the issues discussed in this chapter, and you could maybe even add
    some more.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前构建过分层架构，你可能能够与本章中讨论的一些问题产生共鸣，甚至可能添加一些更多的问题。
- en: If done correctly, and if some additional rules are imposed on it, a layered
    architecture can be very maintainable and can make changing or adding to the code
    base a breeze.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果做得正确，并且对它施加一些额外的规则，分层架构可以非常易于维护，并且可以使更改或添加到代码库变得轻而易举。
- en: However, the discussion shows that a layered architecture allows many things
    to go wrong. Without good self-discipline, it’s prone to degrading and becoming
    less maintainable over time. And our self-discipline usually takes a hit each
    time a team member rotates into or out of the team, or a manager draws a new deadline
    around the development team.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，讨论表明分层架构允许许多事情出错。如果没有良好的自律，它随着时间的推移容易退化，变得难以维护。而且，每当团队成员进出团队，或者经理为开发团队设定新的截止日期时，我们的自律通常都会受到打击。
- en: Keeping the traps of layered architecture in mind will help us the next time
    we argue against taking a shortcut and for building a more maintainable solution
    instead – be it in a layered architecture or a different architecture style.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 将分层架构的陷阱牢记于心，将有助于我们下次在争论反对走捷径，而支持构建更易于维护的解决方案时——无论是分层架构还是其他架构风格。
