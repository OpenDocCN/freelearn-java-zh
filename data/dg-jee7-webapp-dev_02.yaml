- en: Chapter 2. JavaServer Faces Lifecycle
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章. JavaServer Faces 生命周期
- en: '|   | *"No two people on earth are alike, and it''s got to be that way in music
    or it isn''t music"* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|    | *"世界上没有两个人是完全相同的，在音乐中也是如此，如果不是这样，那就不是音乐"* |    |'
- en: '|   | --*Billie Holiday* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|    | --*比莉·假日* |'
- en: 'Java has been a complete success in the server side for a long time: since
    the year 2000\. Businesses have trusted the JVM, Java programming language, and
    abundance of frameworks as their platform of choice for enterprise software. So,
    are we correct in continuing to put our trust in the JVM as digital web engineers?
    I think the answer to that question, and because you are reading this book, is
    yes!'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Java 在服务器端已经取得了长期的成功：自 2000 年以来。企业一直信任 JVM、Java 编程语言以及丰富的框架作为他们选择的企业软件平台。那么，我们继续信任
    JVM 作为数字 Web 工程师是否正确？我认为这个问题的答案，以及因为你正在阅读这本书，答案是肯定的！
- en: 'This chapter is an expansive overview of the **JavaServer Faces** (**JSF**)
    concepts. We will start with the history and purpose of JSF and how it relates
    to the fundamental design pattern: the **Model-View-Controller** (**MVC**). We
    will explore the life cycle concepts in JSF, which is one of the key concepts
    that separates it from the other Java web application frameworks. Moreover, we
    will examine some JSF code, including the nefarious concept of managed beans.
    We will also cover how a JSF application navigates between the POJOs and pages.
    To sweeten this, we will meander in the powerful expression language for page
    authors. By the time we finish the chapter, we will have built a solid foundation
    of knowledge.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是对 **JavaServer Faces**（**JSF**）概念的全面概述。我们将从 JSF 的历史和目的开始，以及它如何与基本设计模式：**模型-视图-控制器**（**MVC**）相关联。我们将探讨
    JSF 中的生命周期概念，这是将其与其他 Java Web 应用程序框架区分开来的关键概念之一。此外，我们将检查一些 JSF 代码，包括管理 Bean 的邪恶概念。我们还将介绍
    JSF 应用程序如何在 POJO 和页面之间导航。为了使内容更加丰富，我们将探讨页面作者强大的表达式语言。当我们完成本章时，我们将建立起坚实的知识基础。
- en: Introduction to JSF
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSF 简介
- en: JSF is a specification to build a web user interface from a component model.
    It encompasses a MVC and templating framework. JSF is a standard library of the
    Java EE platform. The **Java Community Process** (**JCP**) controls the specifications,
    and the current version is JSF 2.2, which is defined by **Java Specification Request**
    (**JSR**) 334 ([https://www.jcp.org/en/jsr/detail?id=344](https://www.jcp.org/en/jsr/detail?id=344)).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 是一个用于从组件模型构建 Web 用户界面的规范。它包含 MVC 和模板框架。JSF 是 Java EE 平台的标准库。**Java 社区进程**（**JCP**）控制规范，当前版本是
    JSF 2.2，由 **Java 规范请求**（**JSR**）334 定义（[https://www.jcp.org/en/jsr/detail?id=344](https://www.jcp.org/en/jsr/detail?id=344)）。
- en: Originally, the promise behind JSF was to bring rapid user interface development
    to server-side Java. This statement was true when JSF was first conceived; but
    of course, it is still useful if you would rather not write a lot of JavaScript
    code and hand crafted boilerplate so as to handle the transformation of an HTTP
    request to the Java invocations and back-to-page responses. Web technology and,
    in particular, digital development has leaped off the web pages since JSF 1.0
    was conceived in 2004\. Back then, JavaScript was not taken as a programming language
    so seriously as it is now; there was no responsive web design and there was certainly
    less demand for mobile web programming. Nowadays, it is common to see terms such
    as mobile first or digital by default. This means that websites consider all sorts
    of screen sizes and devices and recognize that people can view the content on
    a smartphone or tablet. Some people (your target customers) do not have access
    to a desktop PC or laptop.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，JSF 背后的承诺是将快速用户界面开发带到服务器端 Java。当 JSF 首次构想时，这个说法是正确的；但当然，如果你不想写很多 JavaScript
    代码和手工制作的样板代码来处理 HTTP 请求到 Java 调用以及返回页面的响应，这个说法仍然是有用的。自 2004 年 JSF 1.0 被构想以来，Web
    技术和，特别是数字开发已经从网页上飞跃。当时，JavaScript 并没有被当作一种编程语言那样认真对待；没有响应式 Web 设计，对移动 Web 编程的需求也肯定较少。如今，看到“移动优先”或“默认为数字”这样的术语是很常见的。这意味着网站会考虑各种屏幕尺寸和设备，并认识到人们可以在智能手机或平板电脑上查看内容。有些人（你的目标客户）无法访问台式电脑或笔记本电脑。
- en: Tip
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: See Cameron Moll's pioneering—but now slightly dated—e-book on mobile web design
    ([http://mobilewebbook.com/](http://mobilewebbook.com/)). The UK government places
    great emphasis on the term, Digital by Default ([https://www.gov.uk/service-manual/digital-by-default](https://www.gov.uk/service-manual/digital-by-default)),
    which has been followed up by the expansive Default to Open term from the United
    States Digital Service ([https://playbook.cio.gov/](https://playbook.cio.gov/)).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 Cameron Moll 的开创性——但现在已经有些过时的——关于移动网页设计的电子书（[http://mobilewebbook.com/](http://mobilewebbook.com/)）。英国政府非常重视“数字优先”（[https://www.gov.uk/service-manual/digital-by-default](https://www.gov.uk/service-manual/digital-by-default)）这一术语，而美国数字服务则提出了“默认为开放”的广泛概念（[https://playbook.cio.gov/](https://playbook.cio.gov/)）。
- en: JSF was conceived as a user interface technology that could allow even a Java
    engineer to build frontend in the same way as a JavaFX (or Swing) application.
    The idea was to allow the developers (not designers) to assemble an HTML page
    using a custom editor. The JSF applications were designed to be themed. The intention
    of the framework was to allow a render kit to produce different forms of output.
    A render kit might generate a PDF output, another type would generate an HTML
    output, and yet another would generate specific mobile content in the form of
    **Wireless Application Protocol** (**WAP**) (WAP was a technology that was afforded
    much attention before Apple produced the first iPhone in 2007). Technology has
    moved on in leaps and bounds!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 被构想为一种用户界面技术，它甚至可以让 Java 工程师以与 JavaFX（或 Swing）应用相同的方式构建前端。这个想法是让开发者（而不是设计师）使用自定义编辑器组装
    HTML 页面。JSF 应用程序被设计为可主题化的。框架的意图是允许渲染工具产生不同形式的输出。一个渲染工具可能生成 PDF 输出，另一种类型可能生成 HTML
    输出，还有一种类型会以 **无线应用协议**（**WAP**）的形式生成特定的移动内容（WAP 是在 2007 年苹果公司推出第一代 iPhone 之前受到广泛关注的技术）。技术已经取得了飞跃性的进步！
- en: Although there is much criticism of JSF as web technology to produce serious
    applications, it has the support of the Java EE platform. Facelets is a useful
    template framework to build sharable components and partial content for web pages.
    JSF has a lifecycle model that integrates into a POJO, and this means that it
    works seamlessly with the Context and Dependency Injection (CDI) beans. Moreover,
    JSF has been kept up to date with the changes taking place in the digital landscape.
    JSF 2.2 supports HTML5 friendly markup. It supports AJAX events and allows the
    events to be queued. It allows a W3C sanction ID attribute for all the elements
    for the HTML5 content. JSF 2.2 introduces Faces Flow, which adds the ability to
    take the user through the sets of screens, workflows, and wizards. Above all,
    JSF 2.2 (JSR 334) represents a commitment to continually support a standard component-based
    framework for the Java EE platform.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对 JSF 作为产生严肃应用程序的 Web 技术有很多批评，但它得到了 Java EE 平台的支持。Facelets 是一个有用的模板框架，用于构建可共享的组件和网页的部分内容。JSF
    具有生命周期模型，可以集成到 POJO 中，这意味着它与 Context 和依赖注入（CDI）豆无缝工作。此外，JSF 还与数字领域的变化保持同步。JSF
    2.2 支持 HTML5 友好的标记。它支持 AJAX 事件，并允许事件排队。它允许为 HTML5 内容的所有元素使用 W3C 授权的 ID 属性。JSF
    2.2 引入了 Faces Flow，它增加了引导用户通过一系列屏幕、工作流程和向导的能力。最重要的是，JSF 2.2（JSR 334）代表了持续支持 Java
    EE 平台标准组件化框架的承诺。
- en: Tip
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Mojarra 2.2**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mojarra 2.2**'
- en: In order for JSF to become a standard of the Java EE platform, it requires a
    JSR and reference implementation. For JSF, the reference implementation project
    is called Mojarra. The software is open source and supported by the Oracle Corporation
    ([https://javaserverfaces.java.net/](https://javaserverfaces.java.net/)). The
    reference implementation is part of the GlassFish 4 application server.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 JSF 成为 Java EE 平台的标准，它需要一个 JSR 和参考实现。对于 JSF，参考实现项目被称为 Mojarra。该软件是开源的，并由甲骨文公司（[https://javaserverfaces.java.net/](https://javaserverfaces.java.net/)）支持。参考实现是
    GlassFish 4 应用服务器的一部分。
- en: JSF 1.0 and 2.0 history
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSF 1.0 和 2.0 历史简介
- en: 'The concept of JSF was first discussed around 2001\. It was a part of the Sun
    Microsystems project called Project Rave and then announced as JSR 127\. The technology,
    although an improvement over the action-request-based framework of the era such
    as Apache Struts, was met with lukewarm fanfare in 2003 and 2004\. A maintenance
    version 1.1 was released in 2004, but only in 2006 did the JSF 1.2 specification
    become an official part of the umbrella specification: Java EE 5.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 的概念最早在 2001 年左右被讨论。它是 Sun Microsystems 项目 Project Rave 的一部分，后来宣布为 JSR 127。尽管这项技术在当时基于动作请求的框架（如
    Apache Struts）之上有所改进，但在 2003 年和 2004 年却遭到了冷淡的欢迎。2004 年发布了一个维护版本 1.1，但直到 2006 年，JSF
    1.2 规范才成为 Java EE 5 的官方规范的一部分。
- en: By this time, however, the developer mindshare had already evolved into the
    AJAX techniques, partial applications, and non-JVM software such as Ruby and Ruby
    on Rails. JSF 1.2 was encumbered by the default templating technology of the platform,
    JavaServer Pages. JSP proved unsuitable for JSF because the life cycle of the
    interception of the requests and the generation of the responses were essentially
    incompatible. The search for alternatives led to the creation of Facelets, which
    were designed to work explicitly with JSF.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，到了这个时候，开发者的市场份额已经演变成了 AJAX 技术、部分应用程序以及 Ruby 和 Ruby on Rails 等非 JVM 软件等。JSF
    1.2 被平台默认的模板技术 JavaServer Pages 所拖累。JSP 证明不适合 JSF，因为请求拦截和响应生成的生命周期本质上是不兼容的。寻找替代方案导致了
    Facelets 的创建，它被设计成与 JSF 显式协同工作。
- en: In 2009, Facelets became the default template solution in JSF 2.0 (JSR 314),
    which was also a part of Java EE 6\. JSF 2.0 added annotations for validation
    and conversion. JSF 2.0 defined a standard AJAX component life cycle and it also
    added improvements for graphical editors. JSF 2.0 introduced a resource handle
    for the web content, including images, JavaScript, and CSS files.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2009 年，Facelets 成为 JSF 2.0（JSR 314）的默认模板解决方案，JSF 2.0 也是 Java EE 6 的一部分。JSF
    2.0 添加了验证和转换的注解。JSF 2.0 定义了标准的 AJAX 组件生命周期，并增加了对图形编辑器的改进。JSF 2.0 引入了一个用于网络内容的资源处理程序，包括图像、JavaScript
    和 CSS 文件。
- en: Key JSF 2.2 features
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Key JSF 2.2 features
- en: 'The big ticket features of the JSF 2.2 specification are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 2.2 规范的主要特性如下：
- en: It provides the support for the HTML5 friendly markup, which is a boon to web
    designers and interface developers.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了对 HTML5 友好标记的支持，这对网页设计师和界面开发者来说是一个福音。
- en: The Resource Library Contracts is a new system in JSF to build reusable themes
    through bundling the Facelet views, components, style sheets, and other resources
    including internationalization.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源库合同是 JSF 中的一个新系统，通过捆绑 Facelet 视图、组件、样式表和其他资源（包括国际化）来构建可重用的主题。
- en: It provides the new URI locators that are consistent with the Java EE 7 umbrella
    specification. The Oracle Corporation purchased Sun Microsystems in 2010, and
    so, the old URIs of the form [http://java.sun.com/jsf/core](http://java.sun.com/jsf/core)
    were transformed to [http://xmlns.jcp.org/jsf/core](http://xmlns.jcp.org/jsf/core)
    reflecting the namespace of the JCP web domain.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了与 Java EE 7 规范一致的新的 URI 定位器。Oracle 公司在 2010 年收购了 Sun Microsystems，因此，旧形式的
    URI [http://java.sun.com/jsf/core](http://java.sun.com/jsf/core) 被转换为 [http://xmlns.jcp.org/jsf/core](http://xmlns.jcp.org/jsf/core)，反映了
    JCP 网络域的命名空间。
- en: Faces Flows allow an application to be modeled as a directed graph of pages
    and views. With Faces Flows, we can build the basis of a workflow application
    in terms of the user interface. As a digital engineer, we can assemble a subdivision
    of the applications in a greater whole. These types of workflows lend themselves
    to the conversational scope of the CDI beans. You will learn more about flows
    in detail in [Chapter 6](part0057.xhtml#aid-1MBG21 "Chapter 6. JSF Flows and Finesse"),
    *JSF Flows and Finesse*.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Faces Flows 允许将应用程序建模为页面和视图的定向图。使用 Faces Flows，我们可以从用户界面的角度构建工作流应用程序的基础。作为数字工程师，我们可以将应用程序的子集组装成更大的整体。这类工作流程非常适合
    CDI 容器的对话范围。你将在第 6 章 [JSF Flows and Finesse](part0057.xhtml#aid-1MBG21 "第 6 章。JSF
    流程和优雅") 中详细了解流程。
- en: Stateless Views allow the developers to build the components that have no server-side
    state. Usually, the JSF components will save the state of the user interface component
    on either the server or the client, but sometimes a view does not require this
    extra resource, and thus, having a stateless view affords the scalability of the
    web application on servers.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态视图允许开发者构建没有服务器端状态的组件。通常，JSF 组件会在服务器或客户端上保存用户界面组件的状态，但有时视图不需要这种额外的资源，因此，拥有无状态视图可以提供在服务器上扩展
    Web 应用的可伸缩性。
- en: 'It provides the ability to correctly handle the content of the browser from
    the client window: tab, browser window, pop-up dialog, or modal dialog.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了从客户端窗口（标签、浏览器窗口、弹出对话框或模态对话框）正确处理浏览器内容的能力。
- en: JSF 2.2 is backward compatible with Faces 2.1 and 2.0\. An application built
    against Faces 2.0 or 2.1 will not require changes in order to run with Faces 2.2;
    however, going the other way and using specific 2.2 features will not run in these
    older environments.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 2.2 与 Faces 2.1 和 2.0 兼容。针对 Faces 2.0 或 2.1 构建的应用程序不需要更改即可在 Faces 2.2 中运行；然而，在相反方向使用特定的
    2.2 功能在这些较旧的环境中无法运行。
- en: 'JSF is based on the following Java API specifications:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 基于以下 Java API 规范：
- en: JavaServer Pages 2.2 and JavaServer Pages Tag Library (JSTL) 1.2
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaServer Pages 2.2 和 JavaServer Pages 标签库 (JSTL) 1.2
- en: Java Servlet 3.0
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java Servlet 3.0
- en: Java SE 7
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java SE 7
- en: Java EE 7
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java EE 7
- en: Java Beans 1.01
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java Beans 1.01
- en: Why choose JSF over alternatives?
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么选择 JSF 而不是其他替代品？
- en: JSF is the only Java web application framework that is certified as a JCP standard
    so far. Of course, there are alternatives; in fact, there may be as many as 100
    different Java web frameworks, and the majority of them will be open source. However,
    they will vary according to the vision, implementation, age of the code base,
    and who actually maintains it as a repository. It is no good for a business if
    the web framework that your application works against is built with yesterday's
    technology because the web is constantly evolving. Equally, the web framework
    has to evolve with the times or it will eventually become irrelevant. Businesses
    trust that JSF is a standard that has the guarantees that the technology will
    be supported for the long term.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，JSF 是唯一一个被认证为 JCP 标准的 Java Web 应用框架。当然，有替代品；实际上，可能有 100 多种不同的 Java Web
    框架，其中大多数将是开源的。然而，它们将根据愿景、实现、代码库的年龄以及谁实际上维护它作为存储库而有所不同。如果你的应用程序所依赖的 Web 框架是用昨天的技术构建的，因为
    Web 正在不断发展，这对业务来说是没有好处的。同样，Web 框架必须与时俱进，否则最终会变得无关紧要。企业相信 JSF 是一个有保证的标准，即这项技术将得到长期支持。
- en: Tip
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In fact, MVC (JSR 371) will be the other standard web application framework
    in Java EE 8\. You will learn about MVC in [Chapter 9](part0087.xhtml#aid-2IV0U1
    "Chapter 9. Java EE MVC Framework"), *Java EE MVC Framework*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，MVC (JSR 371) 将成为 Java EE 8 的另一个标准 Web 应用框架。你将在[第 9 章](part0087.xhtml#aid-2IV0U1
    "第 9 章。Java EE MVC 框架")*Java EE MVC 框架*中学习 MVC。
- en: It is perfectly understandable that an application architect may want to choose
    a web framework other than JSF for their business requirements. Apache Struts
    2, Spring MVC, and Apache Wicket are a few that I would mention in passing. Apache
    Struts 2 and Spring MVC are generally considered to be request-oriented frameworks.
    Apache Wicket is a component-oriented framework and a direct competitor to JSF.
    Apache Struts was one of the most famous web application frameworks in the early
    2000s and certainly the first to break the mold.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个应用架构师可能希望根据业务需求选择 JSF 以外的 Web 框架，这是完全可以理解的。Apache Struts 2、Spring MVC 和
    Apache Wicket 是我顺便提到的几个。Apache Struts 2 和 Spring MVC 通常被认为是面向请求的框架。Apache Wicket
    是一个面向组件的框架，并且是 JSF 的直接竞争对手。Apache Struts 是 2000 年代初最著名的 Web 应用框架之一，并且是第一个打破传统框架的。
- en: The world of web frameworks does not stop with Java. Most developers will have
    heard of Ruby on Rails, which is an off-JVM technology. A few engineers will know
    about the Play framework for both the Java and Scala developers, and then there
    are solutions based around the Groovy language such as Grails.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Web 框架的世界并不局限于 Java。大多数开发者都会听说过 Ruby on Rails，这是一种非 JVM 技术。一些工程师会了解 Play 框架，它适用于
    Java 和 Scala 开发者，然后还有基于 Groovy 语言的解决方案，如 Grails。
- en: Whatever framework you choose for a web application essentially dictates the
    Java-based frontend architecture for your developer. Whatever you do, my strong
    recommendation is not to invent your own web application framework. The strength
    of open source is the community of developers that is diverse with from thousands
    of different companies, endeavors, and cultures.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪个框架来构建Web应用，本质上都会决定你的开发者的Java前端架构。无论你做什么，我强烈建议不要发明自己的Web应用框架。开源的优势在于拥有来自数千家不同公司、项目和文化的开发者社区。
- en: If you choose JSF, then it is more than likely that you, as a customer, want
    to maintain your investment in the Java platform. The core strength of your JSF
    enterprise application is the rich components, and you rely on the model to add
    the default benefits such as easier validation, type conversion, and mapping of
    HTTP request parameters so as to bean the properties. Many experienced Java EE
    engineers will have experience in the JSF framework, so you will be in great company.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择JSF，那么作为客户，你很可能希望维护你在Java平台上的投资。你的JSF企业应用的核心优势是丰富的组件，你依赖模型来添加默认的好处，例如更简单的验证、类型转换和HTTP请求参数到Bean属性的映射。许多经验丰富的Java
    EE工程师都将有在JSF框架中的经验，所以你将身处一群人中。
- en: The MVC design pattern
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVC设计模式
- en: The MVC design describes a set of design patterns that aim to separate the concerns
    of a user interface from the application logic that semantically binds them. The
    Model describes the business logic. The View denotes the presentation—the abstract
    surface that the user senses and also interacts with. The Controller denotes the
    component that handles the interaction between the model and view. The original
    idea of MVC stemmed from Trygve Reenskaug, who introduced the concept in the Smalltalk
    programming language during the 1970s. The pattern was subsequently implemented
    and popularized in the Smalltalk-80 before it was adopted in the wider software
    engineering community. MVC is famous for its ideas about the division of labor
    and the separation of responsibilities between the components.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: MVC设计描述了一组旨在将用户界面与应用逻辑（它们在语义上绑定）的关注点分离的设计模式。模型描述业务逻辑。视图表示展示——用户感知和与之交互的抽象表面。控制器表示处理模型和视图之间交互的组件。MVC的原始想法源于Trygve
    Reenskaug，他在20世纪70年代在Smalltalk编程语言中引入了这个概念。该模式随后在Smalltalk-80中实现并普及，之后被更广泛的软件工程社区采用。MVC因其关于组件劳动分工和责任分离的想法而闻名。
- en: We call it MVC patterns because the plural term describes a set of related derivatives
    of the classic pattern as group patterns.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称之为MVC模式，因为复数术语描述了一组与经典模式相关的相关衍生模式，作为组模式。
- en: The MVC pattern has subsequently evolved, giving rise to variants such as the
    **Hierarchical model–view–controller** (**HMVC**), **Model-view-presenter** (**MVP**),
    **Model View ViewModel** (**MVVM**), and others that adapted MVC to different
    contexts.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: MVC模式随后演变，产生了如**分层模型-视图-控制器**（**HMVC**）、**模型-视图-表示器**（**MVP**）、**模型视图ViewModel**（**MVVM**）等变体，它们将MVC适应到不同的上下文中。
- en: MVC in JSF
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSF中的MVC
- en: 'How does the MVC map to JSF? This has been answered in the following points:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: MVC如何映射到JSF？以下是一些回答：
- en: '**Model**: In JSF and Java EE, the model is the component or a set of components
    that handles the business data and logic. The model is either a CDI bean, EJB,
    or some other component that is compatible with the life cycle of the web container
    and the JSF framework.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**: 在JSF和Java EE中，模型是处理业务数据和逻辑的组件或组件集。模型可以是CDI Bean、EJB或与Web容器和JSF框架的生命周期兼容的其他组件。'
- en: '**Controller**: A lot of the responsibility of the controller logic in the
    classic design pattern is taken care of by the framework. In JSF, one can consider
    the start of the controller as FacesServlet, which is responsible for dispatching
    the incoming HTTP request to the correct managed bean.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**: 在经典设计模式中，控制器逻辑的大部分责任由框架承担。在JSF中，可以将控制器的开始视为FacesServlet，它负责将传入的HTTP请求分发到正确的管理Bean。'
- en: '**View**: In JSF, the view is the rendering group that contains the UI components
    and their respective beans. Usually, the view is described in a page description
    language, for which JSF 2.0 is Facelets. The render kit of JSF composes the UI
    components and beans in a full page.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**: 在JSF中，视图是包含UI组件及其相应Bean的渲染组。通常，视图是用页面描述语言描述的，对于JSF 2.0来说，就是Facelets。JSF的渲染套件将UI组件和Bean组合成整个页面。'
- en: 'The following diagram illustrates the MVC patterns in a perspective of the
    JSF framework:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示从JSF框架的角度说明了MVC模式：
- en: '![MVC in JSF](img/image00374.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![JSF中的MVC](img/image00374.jpeg)'
- en: The Model View Controller pattern is terms of JSF framework
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSF框架中，模型视图控制器模式被称为
- en: Facelets
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Facelets
- en: The JSF specification defines a **View Declaration Language** (**VDL**) to render
    the output of the pages. In JSF 1.0, this was JavaServer Pages; but in JSF 2.0,
    the VDL was changed to Facelets by default. Facelets are the default view handler
    for JSF 2.0 and are defined as XHTML files.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: JSF规范定义了一种**视图声明语言**（**VDL**）来渲染页面的输出。在JSF 1.0中，这是JavaServer Pages；但在JSF 2.0中，VDL默认改为Facelets。Facelets是JSF
    2.0的默认视图处理器，定义为XHTML文件。
- en: Facelets can be used in a templating situation. A Facelets file can reference
    a master template as a composition, and the view can provide the content that
    will look like a cookie cutter being supplied to the template. A Facelet that
    utilizes a reference template is known as a template client. The placeholder content
    in the template client will override the default content in the master template.
    In this way, Facelets can be reused in order to share the content. The template
    clients may become master templates and thus, a hierarchy of views can be derived.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Facelets可以在模板化场景中使用。一个Facelets文件可以作为组合引用主模板，视图可以提供看起来像模具提供给模板的内容。利用引用模板的Facelet被称为模板客户端。模板客户端中的占位符内容将覆盖主模板中的默认内容。这样，Facelets可以重用以共享内容。模板客户端可能成为主模板，从而派生出视图的层次结构。
- en: Facelets also provide reuse by the custom tags. It is possible for engineers
    to write their own custom tags through the XHTML files and metadata. The designer
    and developer will provide the content through a tag library descriptor file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Facelets还通过自定义标签提供重用。工程师可以通过XHTML文件和元数据编写自己的自定义标签。设计师和开发者将通过标签库描述文件提供内容。
- en: The final option to template that Facelets provide is the Composite Component
    Composition. This mechanism allows a composition to be reused in the other Facelet
    views so that they appear like first-class components. The template files, however,
    must be created in a special directory in order to allow the internal composition
    handler to succeed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Facelets提供的最后一个模板化选项是复合组件组合。这种机制允许组合在其他Facelet视图中重用，使它们看起来像一等组件。然而，模板文件必须创建在一个特殊目录中，以便允许内部组合处理器成功。
- en: The request processing lifecycle
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求处理生命周期
- en: JSF has a request-response processing lifecycle that is built around the HTTP
    protocol. JSF is built on top of the Java Servlet specification that takes care
    of translating the request user agent, which in the majority of the cases, is
    a web browser to a known endpoint. For JSF, the first port of call is `javax.faces.webapp.FacesServlet`.
    This servlet will simply dispatch the incoming request to the controller, and
    this component can elect to generate a response or delegate the output to the
    internal JSF controller implementation.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: JSF有一个基于HTTP协议的请求-响应处理生命周期。JSF建立在Java Servlet规范之上，负责将请求用户代理（在大多数情况下是网络浏览器）转换为已知的端点。对于JSF来说，第一个端口是`javax.faces.webapp.FacesServlet`。这个servlet将简单地转发传入的请求到控制器，并且这个组件可以选择生成响应或将输出委托给内部JSF控制器实现。
- en: There are three circumstances for JSF in the request processing lifecycle. The
    first is the invocation to the JSF controller with a Faces request, which ultimately
    generates a Faces response.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求处理生命周期中，JSF有三种情况。第一种是带有Faces请求调用JSF控制器，这最终生成一个Faces响应。
- en: The second is a request to retrieve a resource such as a CSS or JavaScript file
    or image or some other media file. However, a Faces resource request, which does
    not require the execution of logic, causes the JSF framework to furnish the output
    as a Faces resource response.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种请求是检索资源，如CSS或JavaScript文件、图片或其他媒体文件。然而，不需要执行逻辑的Faces资源请求，会导致JSF框架提供输出作为Faces资源响应。
- en: 'The last one is a page request to retrieve the content that has nothing to
    do with JSF, and this is called a Non-Faces request and subsequently derives a
    Non-Faces response. An HTTP request to a JAX-RS service endpoint is an example
    of a Non-Faces request and response. Let''s have a look at the following figure:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个是页面请求，用于检索与JSF无关的内容，这被称为非Faces请求，随后产生非Faces响应。向JAX-RS服务端点发出的HTTP请求就是一个非Faces请求和响应的例子。让我们看一下以下图示：
- en: '![The request processing lifecycle](img/image00375.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![请求处理生命周期](img/image00375.jpeg)'
- en: JSF request and response processing
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: JSF请求和响应处理
- en: The JSF framework first determines if the incoming request is for a resource.
    If it is, then the framework serves up the resource and sends the bytes, content
    type, and data to the user agent.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: JSF框架首先确定传入的请求是否为资源。如果是，则框架提供资源并发送字节、内容类型和数据到用户代理。
- en: The interesting work happens when the incoming request is treated as a Face
    request; the JSF framework handles this processing in a linear workflow. This
    process is known as the execute and render lifecycle.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当传入的请求被处理为Face请求时，有趣的工作发生了；JSF框架以线性工作流程处理此处理。这个过程被称为执行和渲染生命周期。
- en: The execute and render lifecycle
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行和渲染生命周期
- en: 'The following diagram shows the JSF lifecycle to process a Faces request:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了JSF生命周期以处理Faces请求：
- en: '![The execute and render lifecycle](img/image00376.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![执行和渲染生命周期](img/image00376.jpeg)'
- en: The execute and render lifecycle phases inside the JSF framework
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: JSF框架内部的执行和渲染生命周期阶段
- en: The standard request processing lifecycle starts with a Faces request stimulus
    to the **Restore View** stage. JSF maintains a `javax.faces.context.FacesContext`
    instance for the lifecycle. This object instance contains all of the information
    that is associated with a single Faces request. FacesContext is passed along to
    the various stages.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 标准请求处理生命周期从Faces请求刺激到**恢复视图**阶段开始。JSF维护一个`javax.faces.context.FacesContext`实例以处理生命周期。此对象实例包含与单个Faces请求相关联的所有信息。FacesContext被传递到各个阶段。
- en: Restore View
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 恢复视图
- en: Restore View is a phase of the lifecycle where the JSF framework ensures that
    the tree of the components and their states match the form when the view was originally
    generated at the response. In other words, JSF has to rebuild the view accurately
    before it can start inserting the changes and apply the form property values from
    the Faces request. The reason for this phase to exist is that the state of the
    overall input can change dynamically between requests. What follows is the technical
    depth description.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复视图是生命周期的一个阶段，其中JSF框架确保组件树及其状态与视图最初在响应中生成时匹配。换句话说，JSF必须在开始插入更改并应用从Faces请求中获取的表单属性值之前，准确重建视图。此阶段存在的原因是整体输入的状态可以在请求之间动态更改。以下是对技术深度的描述。
- en: Restore View determines if the request is a postback or an initial request according
    to the algorithm. Every view in JSF has its unique identifier, `viewId`, and this
    is usually stored in a map collection internally in the framework's implementation.
    The framework calls the `initView()` method on the `javax.faces.application.ViewHandler`
    instance, which is associated with the view. Restore View constructs or retrieves
    the view so as to display to the user agent.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复视图根据算法确定请求是回发还是初始请求。JSF中的每个视图都有一个唯一的标识符，即`viewId`，这通常在框架的实现内部存储在映射集合中。框架在关联的视图的`javax.faces.application.ViewHandler`实例上调用`initView()`方法，以便构建或检索视图以显示给用户代理。
- en: If the view already exists, then the request is a postback. JSF will then restore
    the view with `viewId` using the previously saved state. The state can be stored
    on the server or client. This behavior is configured from the Web XML deployment
    behavior for the application.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果视图已经存在，则请求是回发。JSF将使用之前保存的状态恢复带有`viewId`的视图。状态可以存储在服务器或客户端。此行为是从应用程序的Web XML部署行为中配置的。
- en: For an entirely new view, JSF creates a new instance of the type `javax.faces.component.UIViewRoot`,
    which is initially empty and sets the associated properties on it, such as the
    locale and character set. JSF then populates the view with the UI components in
    a tree data structure.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于全新的视图，JSF创建一个`javax.faces.component.UIViewRoot`类型的新实例，该实例最初为空，并设置其关联的属性，如区域设置和字符集。然后JSF以树形数据结构填充视图中的UI组件。
- en: Apply Request Values
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用请求值
- en: After the component tree is restored, JSF maps the request information parameters
    to the component properties. The framework iterates over the component objects
    in the tree. Each component retrieves the data from the request object, which
    are usually the request parameters but can be cookies, session attributes, or
    even header parameters. Hence, the new values are stored with the UI component
    locally. The values are extracted from the request information, and at this phase,
    the values are still strings. This stage is called the Apply Request Values phase.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件树恢复后，JSF将请求信息参数映射到组件属性。框架遍历树中的组件对象。每个组件从请求对象中检索数据，这些数据通常是请求参数，但也可以是cookie、会话属性，甚至是头部参数。因此，新值被存储在UI组件本地。值从请求信息中提取，在这个阶段，值仍然是字符串。这个阶段被称为应用请求值阶段。
- en: During this stage, JSF will attempt to apply conversion on the component properties
    where it is appropriate. If the conversion or validation fails, then the error
    message is queued on FacesContext.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，JSF将尝试在适当的位置对组件属性进行转换。如果转换或验证失败，则错误信息将被排队在FacesContext中。
- en: 'The Apply Request Values phase adds events to an internal JSF event queue when
    a command button or link is clicked on. JSF has certain special conditions in
    which an event handler is allowed to break the linear flow of processing and skip
    to the final stage: Render Response.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 应用请求值阶段在命令按钮或链接被点击时向内部JSF事件队列添加事件。JSF存在某些特殊条件，在这些条件下，事件处理器允许打破处理流程的线性流程并跳转到最终阶段：渲染响应。
- en: Process Validations
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理验证
- en: The Process Validation phase is the stage where the submitted string values,
    which are stored with the component, are converted to local values. These local
    values can be Java objects of any type. It is in this phase that the validators
    that are associated with the component can verify the value of the local values.
    If the validation passes and all the required validators are invoked successfully,
    then the JSF life cycle continues to the next phase. If the validation fails or
    there have been conversion errors from the previous lifecycle phase—the Apply
    Request Values phase—then the JSF framework skips directly to the Render Response
    phase. The web user then has a chance to enter the correct data in, say, an HTML
    input form.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 处理验证阶段是提交的字符串值（这些值与组件一起存储）被转换为本地值的阶段。这些本地值可以是任何类型的Java对象。在这个阶段，与组件关联的验证器可以验证本地值的值。如果验证通过并且所有必需的验证器都成功调用，则JSF生命周期继续到下一个阶段。如果验证失败或前一个生命周期阶段（应用请求值阶段）中存在转换错误，则JSF框架直接跳转到渲染响应阶段。然后，网络用户有机会在HTML输入表单中输入正确数据。
- en: As a JSF developer, it is up to you to attach validators to the UI components
    with inputs, which are important to check.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 作为JSF开发者，将验证器附加到具有输入的UI组件是你的责任，这些输入非常重要。
- en: Update Model Values
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新模型值
- en: After the conversion and validation phases, JSF enters the Update Model Values
    stage. At this point, the local values are considered as safe so as to update
    the model. Remember that in JSF versus MVC parlance, the model is likely to be
    your managed backing bean, CDI bean, or an EJB or aggregate object. JSF updates
    the beans that are referenced by the component.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在转换和验证阶段之后，JSF进入更新模型值阶段。在这个时候，本地值被认为是安全的，以便更新模型。记住，在JSF与MVC术语中，模型很可能是你的管理后端bean、CDI
    bean或EJB或聚合对象。JSF更新由组件引用的bean。
- en: Invoke Application
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用应用
- en: In the life cycle, we arrive at the phase where the model has been updated,
    and conversion and validation has been applied. JSF calls this the Invoke Application
    phase, and here, finally, business logic is invoked. JSF calls the method that
    is named by the action method of the command button or link component. The Invoke
    Application phase is a result of the user submitting an HTML form or invoking
    a navigation anchor link, so the JSF framework executes the corresponding method
    of the backing bean.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在生命周期中，我们到达了模型已更新，转换和验证已应用的阶段。JSF称这个阶段为调用应用阶段，在这里，最终调用业务逻辑。JSF调用由命令按钮或链接组件的动作方法命名的函数。调用应用阶段是用户提交HTML表单或调用导航锚链接的结果，因此JSF框架执行后端bean的相应方法。
- en: The method may elect to return a simple outcome string. Since JSF 2.0, methods
    are allowed to return a simple string that refers to the view by its name. Alternatively,
    the method may build its own response programmatically using the FacesContext
    instance or may return the navigation view ID that is passed to a navigation handler,
    which in turn looks up the next page.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法可以选择返回一个简单的结果字符串。自从 JSF 2.0 以来，方法被允许返回一个简单的字符串，该字符串通过名称引用视图。或者，方法可以使用 FacesContext
    实例程序化构建自己的响应，或者返回传递给导航处理器的导航视图 ID，该处理器随后查找下一页。
- en: Render Response
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渲染响应
- en: The last phase in the lifecycle is the Render Response phase. This stage has
    the requirement to encode the Faces response and the JSF framework sends this
    output to the requesting user agent, which is usually a web browser. As soon as
    the data is sent down the network to the client, the life cycle is complete for
    the request and response. A new lifecycle begins on the next request.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期中的最后一个阶段是渲染响应阶段。这一阶段需要编码 Faces 响应，JSF 框架将此输出发送到请求的用户代理，这通常是网络浏览器。一旦数据通过网络发送到客户端，请求和响应的生命周期就结束了。在下一个请求上，一个新的生命周期开始。
- en: Event handling
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件处理
- en: Between certain phases, you will have noticed the Process Event stages. JSF
    allows the listeners to be registered against the framework in order to observe
    events. These are called Phase Listeners. They are special because they can be
    active in behavior and cause the lifecycle to skip or they can be passive in behavior
    to just monitor some aspects of the user interface that is interesting to the
    application. These mini-extension points are quite useful and powerful for application
    builders and thus are a major differentiator between JSF and the other web frameworks.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些阶段之间，你可能已经注意到了进程事件阶段。JSF 允许监听器注册到框架中，以便观察事件。这些被称为阶段监听器。它们之所以特殊，是因为它们可以在行为中保持活跃，导致生命周期跳过，或者它们可以保持被动，仅监控对应用程序有趣的用户界面的某些方面。这些小型扩展点对于应用程序构建者非常有用且强大，因此是
    JSF 与其他 Web 框架之间的重要区别。
- en: A basic JSF example
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个基本的 JSF 示例
- en: We have covered just enough theory on the JSF framework. I think it is time
    for my readers to see some code. The first code is the XHTML file to display a
    basic web page on a site. The source code is available on the book's website in
    the author's public GitHub account at [http://github.com/peter_pilgrim/digital_javaee7](http://github.com/peter_pilgrim/digital_javaee7).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对 JSF 框架的理论进行了足够的介绍。我认为是时候让我的读者看看一些代码了。第一段代码是用于在网站上显示基本网页的 XHTML 文件。源代码可在作者公共
    GitHub 账户的书籍网站上找到，网址为 [http://github.com/peter_pilgrim/digital_javaee7](http://github.com/peter_pilgrim/digital_javaee7)。
- en: 'Here is the XHTML source code for the initial Facelets view, and the file is
    called `index.xhtml`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是初始 Facelets 视图的 XHTML 源代码，文件名为 `index.xhtml`：
- en: '[PRE0]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is worth reminding you that this file is not an HTML5 document; although
    JSF 2.2 can cope with the document grammar, we must walk before we can run. XHTML
    is a format of HTML that uses an XML schema namespace to add additional tags.
    Hence, there are JSF-specific namespaces for HTML, UI, and F. See further onward
    for a description of these namespaces.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 值得提醒的是，此文件不是 HTML5 文档；尽管 JSF 2.2 可以处理文档语法，但我们必须先学会走路，然后才能奔跑。XHTML 是一种使用 XML
    架构命名空间添加额外标签的 HTML 格式。因此，存在针对 HTML、UI 和 F 的 JSF 特定命名空间。请参阅以下内容，了解这些命名空间的描述。
- en: The `<h:head>`, `<h:body>`, and `<h:form>` custom tags resemble the standard
    HTML element tags that everyone knows about in web development. This is because
    they are designed to reflect this purpose deliberately. In fact, these are the
    JSF customs tags that add the functionalities and in the end, render the equivalent
    HTML element output.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`<h:head>`、`<h:body>` 和 `<h:form>` 自定义标签类似于大家在网上开发中都知道的标准 HTML 元素标签。这是因为它们被设计成故意反映这一目的。实际上，这些是添加功能并在最后渲染等效
    HTML 元素输出的 JSF 自定义标签。'
- en: You are probably wondering that what an earth is a `<h:link>` element. This
    is simply JSF's way of rendering an HTML anchor tag. The outcome tag attribute
    references another XHTML directly, and after JSF 2.0, developers are allowed to
    write this in code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道 `<h:link>` 元素是什么。这仅仅是 JSF 渲染 HTML 锚点标签的方式。结果标签属性直接引用另一个 XHTML，而在 JSF
    2.0 之后，开发人员被允许在代码中这样写。
- en: The `<h:commandButton>` tag is an example of a JSF form button that ultimately
    renders an HTML submit element tag. This tag accepts an action attribute that
    refers to a special string. The string is an example of the expression language;
    it references a method name of a bean.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`<h:commandButton>` 标签是 JSF 表单按钮的一个示例，它最终渲染一个 HTML 提交元素标签。此标签接受一个 action 属性，该属性引用一个特殊字符串。该字符串是表达式语言的示例；它引用了一个实例的方法名。'
- en: 'Here is the code for the JSF managed bean, `BasicFlow`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 JSF 管理实例 `BasicFlow` 的代码：
- en: '[PRE1]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`BasicFlow` is a CDI bean with the request scope life cycle as declared by
    the `@javax.enterprise.context.RequestScoped` annotation. The bean is created
    by the CDI framework at the beginning of the servlet request lifecycle and is
    finished and left for the garbage collection once the servlet response is complete.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`BasicFlow` 是一个具有请求作用域生命周期的 CDI 实例，由 `@javax.enterprise.context.RequestScoped`
    注解声明。该实例在 servlet 请求生命周期开始时由 CDI 框架创建，一旦 servlet 响应完成，则完成并留给垃圾回收。'
- en: In JSF 2.2, we will use the `@javax.inject.Named` annotation to specify the
    bean that is available to the JSF framework. We can explicitly write the annotation
    as `@Named("basicFlow")`, but the default is the camel case identifier of the
    simple class name. We recommend that a digital developer should not use the older
    `@javax.faces.bean.ManagedBean` annotation as it is now targeted for deprecation
    in a future JSF specification.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JSF 2.2 中，我们将使用 `@javax.inject.Named` 注解来指定对 JSF 框架可用的实例。我们可以明确写出注解为 `@Named("basicFlow")`，但默认情况下是简单类名的驼峰标识符。我们建议数字开发者不要使用旧的
    `@javax.faces.bean.ManagedBean` 注解，因为它现在在未来的 JSF 规范中已被标记为弃用。
- en: Tip
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Make sure that your POJOs are actually CDI beans. Confusion can abound with
    JSF if you are using the wrong import for JSF. At deployment time, you will be
    unable to inject or find the backing bean in an expression like `#{basicFlow.serveResponse}`.
    Check that you are importing `javax.enterprise.context.RequestScoped` and not
    importing the deprecated `javax.faces.bean.RequestScoped` annotation.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的 POJO 实际上是 CDI 实例。如果您为 JSF 使用了错误的导入，可能会出现混淆。在部署时，您将无法在 `#{basicFlow.serveResponse}`
    这样的表达式注入或找到后端实例。请检查您是否导入了 `javax.enterprise.context.RequestScoped` 而不是过时的 `javax.faces.bean.RequestScoped`
    注解。
- en: The `#{basicFlow.serveResponse}` string is an example of the **Expression Language**
    (**EL**), which is a mechanism for the page content to communicate with the backing
    beans while maintaining a separation of concerns. The first `BasicFlow` element
    refers to the backing bean instance and the second `serverResponse` element refers
    to the `serveResponse()` method. So, this is an EL expression that references
    the backing bean method. We will learn a lot more about expression languages later
    in this chapter.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`#{basicFlow.serveResponse}` 字符串是 **表达式语言**（**EL**）的一个示例，这是一种页面内容与后端实例通信的机制，同时保持关注点的分离。第一个
    `BasicFlow` 元素引用后端实例，第二个 `serverResponse` 元素引用 `serveResponse()` 方法。因此，这是一个引用后端实例方法的
    EL 表达式。我们将在本章后面学习更多关于表达式语言的内容。'
- en: 'You can see that the response is a simple string, which is the next VDL file:
    `endState.xhtml`. Strictly speaking, the suffix can be left off and the JSF framework
    will determine the correct view.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到响应是一个简单的字符串，这是下一个 VDL 文件：`endstate.xhtml`。严格来说，可以省略后缀，JSF 框架将确定正确的视图。
- en: 'The `endState.xhtml` Facelet view file looks as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`endState.xhtml` Facelet 视图文件如下所示：'
- en: '[PRE2]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a JSF view that allows the user to go back to the start view with an
    `<h:link>` element.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 JSF 视图，允许用户通过 `<h:link>` 元素返回起始视图。
- en: A web deployment descriptor
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络部署描述符
- en: 'In order to get the best out of the JSF framework, we recommend configuring
    a web application deployment descriptor. This file is a special XML document that
    declaratively describes the entry servlet endpoints, servlet mapping, and other
    environment resources. The code for the XML file is as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用 JSF 框架，我们建议配置网络应用程序部署描述符。此文件是一个特殊的 XML 文档，声明性地描述了入口 servlet 端点、servlet
    映射和其他环境资源。XML 文件的代码如下：
- en: '[PRE3]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding file has the `WEB-INF/web.xml` path. In order to activate the
    JSF framework, the deployment descriptor declares the servlet with a fully qualified
    class name; `javax.faces.webapp.FacesServlet`. Note that the servlet is mapped
    to serve the `*.xhtml` files.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的文件具有 `WEB-INF/web.xml` 路径。为了激活 JSF 框架，部署描述符声明了具有完全限定类名的 servlet；`javax.faces.webapp.FacesServlet`。请注意，servlet
    被映射以服务 `*.xhtml` 文件。
- en: We will define the active phase of the current project with the context parameter
    `javax.faces.PROJECT_STAGE` and an appropriate value. In the preceding example,
    the stage is set to `Development` but after the application goes live, then we
    might want to switch the value to `Production`. Switching to `Production` improves
    the performance and disables some of the debugging output.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用上下文参数 `javax.faces.PROJECT_STAGE` 和一个适当的值来定义当前项目的活动阶段。在前面的例子中，阶段设置为 `Development`，但在应用程序上线后，我们可能希望将值切换到
    `Production`。切换到 `Production` 可以提高性能并禁用一些调试输出。
- en: You will find the deployment descriptor in the book's source code as part of
    the project `ch02/jsf-compositions`. Once you add the project to an IDE—say, IntelliJ,
    Eclipse, or NetBeans—you can view the output from the application server at the
    URL `http://localhost:8080/jsf-compositions-1.0-SNAPSHOT/`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的源代码中找到部署描述符，它是项目 `ch02/jsf-compositions` 的一部分。一旦将项目添加到 IDE 中——比如说，IntelliJ、Eclipse
    或 NetBeans——你就可以在 URL `http://localhost:8080/jsf-compositions-1.0-SNAPSHOT/` 上查看应用程序服务器的输出。
- en: JSF XML namespaces
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSF XML 命名空间
- en: 'Here is a table describing the common JSF and related namespaces:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个描述常见 JSF 及相关命名空间的表格：
- en: '| Namespace | Description |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 命名空间 | 描述 |'
- en: '| --- | --- |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `h` | [http://xmlns.jcp.org/jsf/html](http://xmlns.jcp.org/jsf/html)This
    defines the standard tag JSF library for the HTML renderers and components such
    as `h:link`, `h:commandButton`, and so on. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `h` | [http://xmlns.jcp.org/jsf/html](http://xmlns.jcp.org/jsf/html) 这定义了标准的
    JSF 标签库，用于 HTML 渲染器和组件，如 `h:link`、`h:commandButton` 等。 |'
- en: '| `f` | [http://xmlns.jcp.org/jsf/core](http://xmlns.jcp.org/jsf/core)This
    defines the standard tag JSF library for the core functionality that is independent
    of any render kit. This library includes the tags to handle the validation and
    conversion. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `f` | [http://xmlns.jcp.org/jsf/core](http://xmlns.jcp.org/jsf/core) 这定义了标准的
    JSF 标签库，用于独立于任何渲染套件的核心理念。这个库包括处理验证和转换的标签。 |'
- en: '| `ui` | [http://xmlns.jcp.org/jsf/facelet](http://xmlns.jcp.org/jsf/facelet)This
    defines the standard tag JSF library to template the support including the composition
    of the views. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `ui` | [http://xmlns.jcp.org/jsf/facelet](http://xmlns.jcp.org/jsf/facelet)
    这定义了标准的 JSF 标签库，用于模板化支持，包括视图的组合。 |'
- en: '| `cc` | [http://xmlns.jcp.org/jsf/composite](http://xmlns.jcp.org/jsf/composite)This
    defines the standard `tag` library to build the composite components. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `cc` | [http://xmlns.jcp.org/jsf/composite](http://xmlns.jcp.org/jsf/composite)
    这定义了用于构建组合组件的标准 `tag` 库。 |'
- en: '| `jsf` | [http://xmlns.jcp.org/jsf](http://xmlns.jcp.org/jsf)This defines
    the tags to support HTML5 friendly output. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `jsf` | [http://xmlns.jcp.org/jsf](http://xmlns.jcp.org/jsf) 这定义了支持 HTML5
    友好输出的标签。 |'
- en: '| `p` | [http://xmlns.jcp.org/jsf/passthrough](http://xmlns.jcp.org/jsf/passthrough)This
    defines the tags to support the HTML5 friendly output with the pass-through `tag`
    attributes. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `p` | [http://xmlns.jcp.org/jsf/passthrough](http://xmlns.jcp.org/jsf/passthrough)
    这定义了支持通过 `tag` 属性输出 HTML5 友好输出的标签。 |'
- en: '| `c` | [http://xmlns.jcp.org/jsp/jstl/core](http://xmlns.jcp.org/jsp/jstl/core)This
    defines the JSTL 1.2 tag library for the JSP core behaviors. These tags include
    `<c:forEach>`, `<c:if>`, `<c:choose>`, and `<c:catch>`. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `c` | [http://xmlns.jcp.org/jsp/jstl/core](http://xmlns.jcp.org/jsp/jstl/core)
    这定义了用于 JSP 核心行为的 JSTL 1.2 标签库。这些标签包括 `<c:forEach>`, `<c:if>`, `<c:choose>`, 和
    `<c:catch>`。 |'
- en: '| `fn` | [http://xmlns.jcp.org/jsp/jstl/ficmtion](http://xmlns.jcp.org/jsp/jstl/ficmtion)This
    defines the JSTL 1.2 tag library for the JSP functions. These tags include `<fn:upperCase>`,
    `<fn:length>`, and `<fn:contains>`. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `fn` | [http://xmlns.jcp.org/jsp/jstl/ficmtion](http://xmlns.jcp.org/jsp/jstl/ficmtion)
    这定义了用于 JSP 函数的 JSTL 1.2 标签库。这些标签包括 `<fn:upperCase>`, `<fn:length>`, 和 `<fn:contains>`。
    |'
- en: An abbreviated name such as `fn` must be added to the root XML document element,
    which in the majority of cases is an HTML element.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 必须将一个缩写名称，如 `fn`，添加到根 XML 文档元素中，在大多数情况下这是一个 HTML 元素。
- en: A Composition example
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个组合示例
- en: 'Let''s delve into some code to demonstrate the JSF composition before we close
    this chapter. We will start with a simple JSF template that lies out a web page
    in two areas: a top area and the main area.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束这一章之前，让我们深入一些代码来演示 JSF 组合。我们将从一个简单的 JSF 模板开始，该模板在两个区域中布局一个网页：一个顶部区域和主要区域。
- en: 'This `template-top.xhtml` file is the JSF view that performs the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `template-top.xhtml` 文件是执行以下操作的 JSF 视图：
- en: '[PRE4]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code is the template master. So far so good. This resembles a
    standard web page with HTML elements and we can see that the page uses the nested
    DIV elements to structure the content. I will draw your attention to the `<h:outputStylesheet>`
    tag, which denotes that we should include a couple of cascading style sheets as
    resources.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是模板母版。到目前为止一切顺利。这类似于一个标准的网页，带有HTML元素，我们可以看到页面使用了嵌套的DIV元素来结构化内容。我将把你的注意力引向`<h:outputStylesheet>`标签，它表示我们应该包含几个层叠样式表作为资源。
- en: The `ui:insert` tag is the composition JSF tag that denotes an area of the template
    that will be replaced by a placeholder in a client template. An insertion placeholder
    must have a name and we have two in this example, namely top and content. Note
    that the `ui:insert` tags are inserted in the body content of the HTML `div` elements.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`ui:insert`标签是表示模板中将被客户端模板中的占位符替换的区域的组合JSF标签。插入占位符必须有一个名称，在这个例子中我们有两个，即top和content。请注意，`ui:insert`标签被插入到HTML
    `div`元素的body内容中。'
- en: 'Here is the code for the client template as `composition1.xhtml`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是客户端模板的代码，作为`composition1.xhtml`：
- en: '[PRE5]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你购买的所有Packt书籍的账户中下载示例代码文件。[http://www.packtpub.com](http://www.packtpub.com)。如果你在其他地方购买了这本书，你可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给你。
- en: The key annotation in this file is the `<ui:composition>` JSF custom tag that
    references the master template that is being used. The template attribute refers
    the path to the file.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件中的关键注释是`<ui:composition>` JSF自定义标签，它引用了正在使用的母版模板。模板属性指向文件的路径。
- en: The two `<ui:define>` tags define the name placeholders with the content that
    substitutes for the default content in the master template. In this example, the
    placeholders are top and content.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`<ui:define>`标签定义了具有替换母版模板中默认内容的名称占位符。在这个例子中，占位符是top和content。
- en: 'Here are the screenshots of this process. The first screenshot is the initial
    Facelets view, `index.xhtml`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这个过程的截图。第一张截图是初始的Facelets视图，`index.xhtml`：
- en: '![A Composition example](img/image00377.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![一个组合示例](img/image00377.jpeg)'
- en: 'The second is the second Facelets view, `endState.xhtml`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是第二个Facelets视图，`endState.xhtml`：
- en: '![A Composition example](img/image00378.jpeg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![一个组合示例](img/image00378.jpeg)'
- en: JSF serving resources
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSF服务资源
- en: 'JSF expects our web resources to be placed in the `resources` folder by default.
    A quick look at the following file directory will help you understand:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: JSF期望我们的Web资源默认放置在`resources`文件夹中。快速查看以下文件目录将有助于你理解：
- en: '`jsf-composition`'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`jsf-composition`'
- en: '`jsf-composition/src/main/webapp`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`jsf-composition/src/main/webapp`'
- en: '`jsf-composition/src/main/webapp/resources`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`jsf-composition/src/main/webapp/resources`'
- en: '`jsf-composition/src/main/webapp/resources/images`'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`jsf-composition/src/main/webapp/resources/images`'
- en: '`jsf-composition/src/main/webapp/resources/javascripts`'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`jsf-composition/src/main/webapp/resources/javascripts`'
- en: '`jsf-composition/src/main/webapp/resources/styles`'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`jsf-composition/src/main/webapp/resources/styles`'
- en: '`jsf-composition/src/main/webapp/WEB-INF`'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`jsf-composition/src/main/webapp/WEB-INF`'
- en: '`jsf-composition/src/main/webapp/WEB-INF/classes`'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`jsf-composition/src/main/webapp/WEB-INF/classes`'
- en: '`jsf-composition/src/main/webapp/WEB-INF/lib`'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`jsf-composition/src/main/webapp/WEB-INF/lib`'
- en: 'In this simplified view of the Gradle project, we can see the folders, images,
    JavaScript, and CSS files that are placed under the `resource` folder. Let''s
    remind ourselves of the JSF view code again, as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个Gradle项目的简化视图中，我们可以看到放置在`resource`文件夹下的文件夹、图像、JavaScript和CSS文件。让我们再次提醒自己JSF视图代码，如下所示：
- en: '[PRE6]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'These tags are essentially referring to two files: `resources/style/top.css`
    and `resources/style/main.css`.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标签本质上指的是两个文件：`resources/style/top.css` 和 `resources/style/main.css`。
- en: 'In order for these tags to work, the resource must be placed under the resources
    folder or it can be placed in the `META-INF/resources` folder of a web application
    JAR file that is deployed with the web application. The specification lists the
    following two options:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些标签正常工作，资源必须放置在`resources`文件夹下，或者它可以放置在随Web应用程序部署的Web应用程序JAR文件的`META-INF/resources`文件夹中。规范列出了以下两个选项：
- en: '[PRE7]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Otherwise, you can use this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，你可以使用这个：
- en: '[PRE8]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, `<ROOT>` is the project web root, `<DEPENDANT-JAR>` is a third-party dependent
    JAR, and `<RES-ID>` is the resource identifier.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`<ROOT>`是项目Web根目录，`<DEPENDANT-JAR>`是第三方依赖JAR，`<RES-ID>`是资源标识符。
- en: '`<RES-ID>` can be further broken up into formal parts, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`<RES-ID>`可以进一步细分为正式部分，如下所示：'
- en: '[PRE9]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The term parts inside `[]` are optional except for the resource name. It is
    therefore possible to have a resource identifier that is completely internationalized,
    versioned, and modularized in a library. Perhaps your project might utilize the
    following resource:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`[]`内的术语部分是可选的，除了资源名称。因此，可以有一个完全国际化、版本化和模块化的库中的资源标识符。也许你的项目可能会使用以下资源：'
- en: '[PRE10]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'What happens if you want to buck the trend and change the default location
    for the resources in JSF 2.2? It is possible to configure an alternative folder
    in the `web.xml` deployment descriptor file. You can set a context parameter variable:
    `javax.faces.WEBAPP_RESOURCES_DIRECTORY`.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想逆势而行，更改JSF 2.2中资源的默认位置，该怎么办？可以在`web.xml`部署描述符文件中配置一个替代文件夹。你可以设置一个上下文参数变量：`javax.faces.WEBAPP_RESOURCES_DIRECTORY`。
- en: 'Here is an extract of the descriptor that defines the resources folder as asset:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是定义资源文件夹为资产的描述符摘录：
- en: '[PRE11]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We will cover the full extent of the JSF custom tags and how to submit the HTML
    forms in [Chapter 3](part0035.xhtml#aid-11C3M2 "Chapter 3. Building JSF Forms"),
    *Building JSF Forms* and [Chapter 4](part0043.xhtml#aid-190861 "Chapter 4. JSF
    Validation and AJAX"), *JSF Validation and AJAX*.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖JSF自定义标签的全面内容以及如何在[第3章](part0035.xhtml#aid-11C3M2 "第3章。构建JSF表单")*构建JSF表单*和[第4章](part0043.xhtml#aid-190861
    "第4章。JSF验证和AJAX")*JSF验证和AJAX*中提交HTML表单。
- en: Expression language
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式语言
- en: '[PRE12]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This would work as a read-only value. However, it is not possible to apply the
    value to the employee bean using JSF because the expression is not evaluated in
    any life cycle state.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这将作为一个只读值工作。然而，由于表达式在任何生命周期状态都没有被评估，因此无法使用JSF将值应用到employee bean上。
- en: 'If we change the expression from an immediate to a deferred form, then we will
    see the following behavior:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将表达式从立即形式更改为延迟形式，那么我们将看到以下行为：
- en: '[PRE13]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With this change, the EL is evaluated immediately during the Render Response
    phase of the lifecycle. The JSF implementation performs the evaluation and retrieves
    the value of the `firstName` property from the bean called employee.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这一变化，在生命周期的渲染响应阶段，EL（表达式语言）立即被评估。JSF实现执行评估并从名为employee的bean中检索`firstName`属性的值。
- en: When the form is posted back to the server as a Faces request, which by the
    way is also known as a `postback` event, the JSF implementation has a chance to
    retrieve the value at a deferred time. It is at these later life cycle states—Apply
    Request Values, Process Validation, and Update Model—that the value expression
    is evaluated and the value from the Faces request is injected into the target
    bean property.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当表单作为Faces请求发送回服务器时，顺便说一下，这也被称为`postback`事件，JSF实现有机会在延迟时间检索值。在这些后续的生命周期状态——应用请求值、处理验证和更新模型中，值表达式被评估，并且从Faces请求中的值被注入到目标bean属性中。
- en: Value expressions
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值表达式
- en: A value expression is one that returns a single result. The value is retrieved
    from the object graph in the implementation that manages the collections of the
    Java instances. For Java EE, this is either JSF or JSP provider, and for application
    servers, it is a Context and Dependency Injection provider. CDI maintains a set
    of collections internally of the `@javax.inject.Named` beans. (Please wait for
    the explanation of the named beans or head straight for [Chapter 3](part0035.xhtml#aid-11C3M2
    "Chapter 3. Building JSF Forms"), *Building JSF Forms*.) In particular, JSF traditionally
    keeps a record of the managed beans annotated with `@javax.faces.bean.ManagedBean`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 值表达式是返回单个结果的表达式。值从管理Java实例集合的实现中的对象图中检索。对于Java EE，这可以是JSF或JSP提供者，对于应用程序服务器，它是一个上下文和依赖注入提供者。CDI内部维护一组`@javax.inject.Named`
    bean的集合。（请等待对命名bean的解释，或者直接查看[第3章](part0035.xhtml#aid-11C3M2 "第3章。构建JSF表单")*构建JSF表单*。）特别是，JSF传统上保留有注解了`@javax.faces.bean.ManagedBean`的托管bean的记录。
- en: JSP will search for the named object in the page scope, request scope, session
    scope, and then the application scope of the servlet container. Behind the scenes,
    there is a subclass of the abstract class `javax.el.ELResolver`, which is responsible
    for evaluation. This class has useful methods, such as `getValue()`, `setValue()`,
    `isReadOnly()`, and `invoke()` that developers can use to add evaluation to their
    own applications programmatically.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: JSP 将在页面作用域、请求作用域、会话作用域以及最后在 servlet 容器的应用程序作用域中搜索命名对象。在幕后，有一个抽象类 `javax.el.ELResolver`
    的子类，它负责评估。这个类有有用的方法，例如 `getValue()`、`setValue()`、`isReadOnly()` 和 `invoke()`，开发者可以使用这些方法以编程方式将评估添加到自己的应用程序中。
- en: In any case, the first port of call of value expressions is the object instance
    with an identified name. This is known as the initial term. Afterwards, the evaluation
    logic can traverse through the object graph through a named property using the
    dot-notation (`.`). The evaluation continues through the subsequent terms in the
    expression. Let's stick with JSF for the moment and consider that the `#{employee.firstName}`
    expression will evaluate a deferred search for the object named employee in the
    scope. The EL resolver will then look up the property in the bean named `firstName`,
    which in turn will be a call to the `getFirstName()` method. The job will be completed
    and the EL resolver returns the result value of the property.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，值表达式的首要目标是具有识别名称的对象实例。这被称为初始项。之后，评估逻辑可以通过使用点符号（`.`）通过命名属性遍历对象图。评估将继续通过表达式中的后续项。让我们暂时坚持
    JSF，并考虑 `#{employee.firstName}` 表达式将评估在作用域中延迟搜索名为 employee 的对象。然后，EL 解析器将在名为 `firstName`
    的 bean 中查找属性，这反过来将调用 `getFirstName()` 方法。任务将完成，EL 解析器返回属性的值。
- en: EL also works with Java Collections. In particular, the `java.util.Map` collections
    are treated specially. A standard EL assumes that the collection has a key of
    a String type we can think of this as `Map<String,Object>`. The entries in Map
    may be accessed using the dot notation or square bracket notation `[]`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: EL 也可以与 Java 集合一起使用。特别是，`java.util.Map` 集合被特别处理。标准的 EL 假设集合有一个字符串类型的键，我们可以将其视为
    `Map<String,Object>`。Map 中的条目可以使用点符号或方括号符号 `[]` 访问。
- en: 'The following table of value expressions will make this scheme clear for more
    complex expressions:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的值表达式表将使更复杂的表达式方案更加清晰：
- en: '| Expression | Meaning |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 表达式 | 含义 |'
- en: '| --- | --- |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Employee` | This finds the initial term associated with the name `employee`
    |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `Employee` | 这将找到与名称 `employee` 关联的初始项 |'
- en: '| `employee.firstName` | This resolves the named instance and invokes `getFirstName()`
    |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `employee.firstName` | 这解析了命名实例并调用 `getFirstName()` |'
- en: '| `employee.department.name` | This resolves the object, invokes `getFirstName()`,
    retrieves the next object, and invokes `getName()` on this object |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `employee.department.name` | 这解析了对象，调用 `getFirstName()`，检索下一个对象，并在该对象上调用
    `getName()` |'
- en: '| `employee["firstName"]` | This is equivalent to the dot notation `employee.firstName`
    |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `employee["firstName"]` | 这与点符号 `employee.firstName` 等价 |'
- en: '| `employee[''firstName'']` | This is equivalent to the dot notation `employee.firstName`
    |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `employee[''firstName'']` | 这与点符号 `employee.firstName` 等价 |'
- en: '| `capitalCities[''Brazil'']` | This finds the name instance and, assuming
    that `capitalCities` is a type of `java.util.Map`, retrieves the value with the
    key `Brazil` |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `capitalCities[''Brazil'']` | 这将找到名称实例，并且假设 `capitalCities` 是 `java.util.Map`
    类型，通过键 `Brazil` 获取值 |'
- en: '| `capitalCities["Brazil"]` | This is a map expression equivalent to the previous
    |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `capitalCities["Brazil"]` | 这与前面的映射表达式等价 |'
- en: 'The square bracket notation `[]` is very useful with the string that contains
    dashes and/or a period character. This notation helps when you want to extract
    a message from a resource bundle for internationalization purposes. You can write
    a value expression as: `appMessages["registeredTraveller.applicant.firstName.required"]`.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号符号 `[]` 在包含破折号和/或点字符的字符串中非常有用。这种符号在您想从资源包中提取消息以进行国际化时很有帮助。您可以编写一个值表达式，如下所示：`appMessages["registeredTraveller.applicant.firstName.required"]`。
- en: 'The square bracket notation allows us to write peculiar expressions. We can
    write the following value expression:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号符号允许我们编写特殊表达式。我们可以编写以下值表达式：
- en: '[PRE14]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This translates to the following equivalent Java code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这翻译成以下等效的 Java 代码：
- en: '[PRE15]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Map expressions
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射表达式
- en: 'The EL handles the Map objects seamlessly with the square bracket notation
    `[]`. If the expression evaluates to a reference that accesses or reads the value
    associated with Map key on the right-hand-side (an `rvalue`), then the EL resolver
    translates to a `Map.get("key")` call. The following are the expressions to read
    a value:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: EL 使用方括号符号 `[]` 无缝地处理 Map 对象。如果表达式评估为一个引用，该引用访问或读取右侧 Map 键（一个 `rvalue`）关联的值，那么
    EL 解析器将其转换为 `Map.get("key")` 调用。以下为读取值的表达式：
- en: '[PRE16]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If the expression is bound to the left-hand side (an `lvalue`), then the EL
    resolver translates to `Map.put("key", newValue)`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表达式绑定到左侧（一个 `lvalue`），那么 EL 解析器将其转换为 `Map.put("key", newValue)`。
- en: List expressions
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表表达式
- en: The EL can retrieve objects from an index array with the square bracket notation.
    It works exactly like a Map expression except that the key must evaluate to a
    literal integer. In EL, the array index number starts at zero, as expected.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: EL 可以使用方括号符号从索引数组中检索对象。它的工作方式与 Map 表达式完全相同，只是键必须评估为一个字面量整数。在 EL 中，数组索引数从零开始，这是预期的。
- en: 'So, these following value expressions are valid if `departmentList` is a type
    of `java.util.List` and `departmentArray` is a primitive array:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下值表达式在 `departmentList` 是 `java.util.List` 类型且 `departmentArray` 是原始数组时是有效的：
- en: '[PRE17]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'These are the equivalent pseudo Java statements:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是等效的伪 Java 语句：
- en: '[PRE18]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Resolving the initial term
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析初始项
- en: The EL relies on the ability to look up the initial term from the servlet container,
    JSF list of the managed beans, and CDI scopes with the named beans. Essentially,
    you can give a JSF bean any name that you want, except you should avoid predefined
    objects. The initial term is the first part of an expression.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: EL 依赖于从 servlet 容器、JSF 管理 Bean 列表和 CDI 作用域中查找初始项的能力。本质上，你可以给 JSF Bean 任何你想要的名字，但你应该避免预定义对象。初始项是表达式的一部分。
- en: 'In the servlet container, you can refer to several predefined objects. As an
    example, `requestScope` is a map collection of all the request scope attributes
    on a page. The request is also a predefined object in the EL that represents the
    `javax.servlet.http.HttpServletRequest` instance that is passed to the JSF view.
    We can use this to retrieve the web application context path in an `lvalue` expression,
    as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在 servlet 容器中，你可以引用几个预定义对象。例如，`requestScope` 是页面上的所有请求作用域属性的 Map 集合。请求也是 EL
    中的一个预定义对象，它代表传递给 JSF 视图的 `javax.servlet.http.HttpServletRequest` 实例。我们可以使用它在一个
    `lvalue` 表达式中检索 Web 应用程序上下文路径，如下所示：
- en: '[PRE19]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding code is extremely helpful to ensure that the resources can be
    found in a JSF application. It is used to create reliable relative URLs. We will
    explain more in [Chapter 4](part0043.xhtml#aid-190861 "Chapter 4. JSF Validation
    and AJAX"), *JSF Validation and AJAX*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码对于确保在 JSF 应用程序中找到资源非常有用。它用于创建可靠的相对 URL。我们将在 [第 4 章](part0043.xhtml#aid-190861
    "第 4 章。JSF 验证和 AJAX") 中进一步解释，*JSF 验证和 AJAX*。
- en: 'Resolution of the initial term begins by checking whether the initial term
    in the expression is a predefined object or not. If it is a predefined object,
    then the resolver continues this object. If it is not, then the JSF implementation
    searches for the object name in one of the servlet container scopes in this order:
    `requestScope`, `sessionScope`, or `applicationScope`.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 初始项的解析从检查表达式中的初始项是否为预定义对象开始。如果是预定义对象，则解析器继续此对象。如果不是，则 JSF 实现将按照以下顺序在 servlet
    容器作用域中搜索对象名称：`requestScope`、`sessionScope` 或 `applicationScope`。
- en: If the object is not found by name, the JSF 2.2 framework will delegate to `ELResolver`,
    which will search for the equivalent CDI scopes for the instance and will then
    look at the registered or annotated managed beans.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按名称找不到对象，JSF 2.2 框架将委托给 `ELResolver`，该解析器将搜索实例的等效 CDI 作用域，然后查看已注册或注解的管理 Bean。
- en: 'The following table lists the predefined object instances in the expression
    language:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了表达式语言中的预定义对象实例：
- en: '| Predefined Name | Description |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 预定义名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `applicationScope` | This is a Map collection of the application scope attributes
    (`javax.servlet.ServletContext.getAttributes()`) |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `applicationScope` | 这是一个包含应用程序作用域属性（`javax.servlet.ServletContext.getAttributes()`）的
    Map 集合 |'
- en: '| `application` | This refers to the `ServletContext` instance |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `application` | 这指的是 `ServletContext` 实例 |'
- en: '| `cookie` | This is a Map collection of the cookie names and values |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `cookie` | 这是一个包含 cookie 名称和值的 Map 集合 |'
- en: '| `facesContext` | This is the `javax.faces.context.FacesContext` instance
    of this page and life cycle |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `facesContext` | 这是页面的 `javax.faces.context.FacesContext` 实例及其生命周期 |'
- en: '| `header` | This is a Map collection of the HTTP header parameters that only
    yield the first elements of the multiple values |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `header` | 这是一个 Map 集合，包含 HTTP 标头参数，只产生多个值中的第一个元素 |'
- en: '| `headerValues` | This is a Map collection of the HTTP header parameters yielding
    a `String[]` array of values |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `headerValues` | 这是一个 Map 集合，包含 HTTP 标头参数，并产生一个 `String[]` 值数组 |'
- en: '| `initParam` | This is a Map collection of the web application initialization
    parameters |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `initParam` | 这是 Web 应用程序初始化参数的 Map 集合 |'
- en: '| `param` | This is a Map collection of the HTTP request parameters with only
    the first element in any array of values |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `param` | 这是一个 Map 集合，包含 HTTP 请求参数，只包含任何值数组中的第一个元素 |'
- en: '| `paramValue` | This is a Map collection of the HTTP request parameters yielding
    a `String[]` array of values |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `paramValue` | 这是一个 Map 集合，包含 HTTP 请求参数，并产生一个 `String[]` 值数组 |'
- en: '| `requestScope` | This is a Map collecction of the request scope attributes
    (`HttpServletRequest.getAttributes()`) |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `requestScope` | 这是一个 Map 集合，包含请求作用域属性（`HttpServletRequest.getAttributes()`）
    |'
- en: '| `request` | This refers to the `HttpServletRequest` instance |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `request` | 这指的是 `HttpServletRequest` 实例 |'
- en: '| `sessionScope` | This is a Map collection of the session scope attributes
    (`HttpSession.getAttributes()`) |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `sessionScope` | 这是一个 Map 集合，包含会话作用域属性（`HttpSession.getAttributes()`） |'
- en: '| `session` | This refers to the `HttpSession` instance |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `session` | 这指的是 `HttpSession` 实例 |'
- en: '| `View` | This is the `javax.faces.component.UIViewRoot` instance of the page
    |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `View` | 这是页面的 `javax.faces.component.UIViewRoot` 实例 |'
- en: Let's move on to method expressions.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到方法表达式。
- en: Method expressions
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法表达式
- en: EL also permits the association to a method on an object instance. This type
    of reference is called a method binding expression. The JSF framework permits
    method expressions to reference the action methods, validators, converters, and
    phase listeners. A method expression invokes a method on a named object instance
    and then returns the results, if any.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: EL 还允许将方法绑定关联到对象实例上的方法。这种类型的引用称为方法绑定表达式。JSF 框架允许方法表达式引用动作方法、验证器、转换器和阶段监听器。方法表达式在命名对象实例上调用方法，并返回结果（如果有）。
- en: A good example of a method expression is an action handler on a managed bean,
    which you already witnessed in the basic JSF example in this chapter.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一个方法表达式的良好例子是在一个托管 Bean 上的动作处理器，这在本章的基本 JSF 示例中你已经见识过了。
- en: '[PRE20]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `#{basicFlow.serverResponse}` expression is a method binding that refers
    to the controller, the CDI bean named `BasicFlow`, and the `serveResponse()` method.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`#{basicFlow.serverResponse}` 表达式是一个方法绑定，它指向控制器、名为 `BasicFlow` 的 CDI 实例以及 `serveResponse()`
    方法。'
- en: Parameterized method expressions
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数化方法表达式
- en: EL also supports method invocation with parameters. The parameters can be literal
    constants. They can also be names of the terms in the scope of the page. This
    provides a very powerful way to build applications with the list collections and
    other complicated data structures.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: EL 还支持带有参数的方法调用。参数可以是字面常量，也可以是页面作用域中术语的名称。这提供了一种非常强大的方式来构建使用列表集合和其他复杂数据结构的应用程序。
- en: 'Here is an example of the expression that uses the method parameters code:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用方法参数代码的表达式示例：
- en: '[PRE21]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `process()` method is invoked on the object instance that is resolved with
    the `complexFlow` initial term. The first parameter is a literal string. The second
    parameter is the value of the `subterm`, `productLine`, which we will assume is
    available to the EL resolver.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`process()` 方法在通过 `complexFlow` 初始术语解析的对象实例上调用。第一个参数是一个字面字符串。第二个参数是 `subterm`，`productLine`
    的值，我们假设它对 EL 解析器是可用的。'
- en: It is also possible to get the size of the collection by definition because
    this is a no-arguments call. This expression looks like `#{genericSearchResult.size()}`,
    assuming that the initial term references a type of `java.util.Collection` or
    `java.util.Map`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个无参数调用，因此也可以通过定义来获取集合的大小。此表达式看起来像 `#{genericSearchResult.size()}`，假设初始术语引用的是
    `java.util.Collection` 或 `java.util.Map` 类型。
- en: Arithmetic expressions
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术表达式
- en: We can use arithmetic operators to perform calculations in the expressions.
    The expressions may also feature the relational and logical operators.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在表达式中使用算术运算符进行计算。表达式还可以包含关系和逻辑运算符。
- en: 'In EL, the following are the reserved operators:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在 EL 中，以下是一些保留运算符：
- en: 'Arithmetic operators: `+` `-` `*` `/` `div` `%` `mod`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术操作符：`+` `-` `*` `/` `div` `%` `mod`
- en: 'Relational operators: `==` or `eq`, `!=` or `ne`, `<` or `lt`, `>` or `gt`,
    `<=` or `le`, `>=` or `ge`'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系操作符：`==` 或 `eq`，`!=` 或 `ne`，`<` 或 `lt`，`>` 或 `gt`，`<=` 或 `le`，`>=` 或 `ge`
- en: 'Logical operators: `&&` and, `||` or, `!` `not`'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑操作符：`&&` 和，`||` 或，`!` `not`
- en: 'Empty operator: empty'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空操作符：空
- en: 'Here is an example of some of these arithmetic expressions in use:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些这些算术表达式在应用中的示例：
- en: '[PRE22]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note the use of the escape character—the backslash (`\`), which prevents the
    JSF view from interpreting the expression. We can also render the expressions
    directly on the page without the need for a `<h:outputText/>` custom tag. This
    is a nice treat for the page authors.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到使用了转义字符——反斜杠（`\`），它可以防止 JSF 视图解释表达式。我们也可以在页面上直接渲染表达式，而不需要 `<h:outputText/>`
    自定义标签。这对页面作者来说是个不错的待遇。
- en: Tip
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Preserve the MVC Model**'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**保留 MVC 模型**'
- en: It is better to place business logic in a controller bean rather than populating
    the page with complicated conditions.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 将业务逻辑放在控制器 bean 中，而不是用复杂条件填充页面会更好。
- en: Page navigation
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 页面导航
- en: After JSF 2, it is very easy to provide navigation in a controller. In the `BasicFlow`
    controller from the earlier JSF example, we relied on implicit page navigation.
    The developer can specify the next page to render simply by returning a simple
    string.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JSF 2 之后，在控制器中提供导航变得非常容易。在早期的 JSF 示例中的 `BasicFlow` 控制器中，我们依赖于隐式页面导航。开发者可以通过简单地返回一个字符串来指定要渲染的下一页。
- en: 'Here is the controller class again:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这里再次展示了控制器类：
- en: '[PRE23]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In JSF 1, the page navigation was determined explicitly in a Faces Configuration
    XML file: `/WEB-INF/faces-config.xml`, which made the development harder because
    of the enforced cognitive indirection. The purpose of `faces-config.xml` is to
    define the configuration for a JSF web application. The developer can define the
    navigation rules, inject bean properties, define the properties file, and declare
    the resource bundles and locales. They can register the converters, validators,
    and renderer components.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JSF 1 中，页面导航在 Faces 配置 XML 文件中明确确定：`/WEB-INF/faces-config.xml`，这使得开发变得更难，因为强制认知间接性。`faces-config.xml`
    的目的是定义 JSF 网络应用程序的配置。开发者可以定义导航规则，注入 bean 属性，定义属性文件，并声明资源包和区域设置。他们可以注册转换器、验证器和渲染组件。
- en: Explicit page navigation is useful for the defined information architecture
    paths. Writing the page navigation is easier to share in a team. It can be incredibly
    quick to make prototypes for business stakeholders. However, explicit navigation
    is probably redundant if your controllers and rendered pages map directly in a
    one-to-one relationship.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 显式页面导航对于定义的信息架构路径很有用。编写页面导航在团队中更容易分享。为业务利益相关者制作原型可以非常快。然而，如果你的控制器和渲染页面直接映射为一对一关系，显式导航可能就是多余的。
- en: The navigation rules
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航规则
- en: JSF also supports explicit navigation rules in the Faces Configuration XML file.
    I should warn you that this is the old style in JSF 1.*x* to describe the navigation
    between the pages explicitly. In JSF 2.*x*, navigation rules are no longer required,
    and if you want to describe the page navigation better, remind yourself to learn
    about Faces Flows (See [Chapter 6](part0057.xhtml#aid-1MBG21 "Chapter 6. JSF Flows
    and Finesse"), *JSF Flows and Finesse*). However, there is a reasonable chance
    that, in your professional work, you will encounter older JSF applications, and
    therefore, you will need to learn how the JSF navigation rules are designed.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 还支持在 Faces 配置 XML 文件中显式导航规则。我应该提醒你，这是 JSF 1.*x* 中的旧式方法，用于明确描述页面之间的导航。在 JSF
    2.*x* 中，导航规则不再需要，如果你想更好地描述页面导航，记得学习关于 Faces Flows（见第 6 章 [JSF Flows and Finesse](part0057.xhtml#aid-1MBG21
    "第 6 章. JSF 流程和优雅")）。然而，在你的专业工作中，你很可能遇到旧的 JSF 应用程序，因此，你需要学习 JSF 导航规则是如何设计的。
- en: With this in mind, here is how navigation works explicitly. Suppose that we
    have a simple page where we can choose between a collection of fruits and vegetables
    in a set of pages. We can also elect to cancel the choice.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，以下是导航如何显式工作的示例。假设我们有一个简单的页面，我们可以从一组页面中选择水果和蔬菜的集合。我们还可以选择取消选择。
- en: 'Here is a representation of these rules in the standard Faces Configuration
    file, `faces-config.xml`. This file is normally found in `src/main/webapp/WEB-INF`
    in Maven and Gradle projects:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这些规则在标准 Faces 配置文件 `faces-config.xml` 中的表示。这个文件通常位于 Maven 和 Gradle 项目的 `src/main/webapp/WEB-INF`
    目录下：
- en: '[PRE24]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Explicit navigation is determined by a set of rules that the JSF framework applies.
    The developers will write a series of compound elements in the <`navigation-rule>`
    tag. The context of the rule is determined by the `<from-view-id>` element, which
    references a specific view page, `/order-start.xhtml`, or it can be a wildcard
    rule (asterisk `*`) that applies to more than one navigation case. Each navigation
    rule has a collection of the `<navigation-case>` elements. Each case requires
    a `<from-outcome>` and `<to-view-id>` element. The outcome identifies the literal
    string, which is returned by the controller method and the view ID is the destination
    view. So, in the cancellation case, the outcome string identified by cancel will
    navigate to the `/cancel.xhtml` view.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 显式导航由JSF框架应用的一组规则确定。开发者将在 `<navigation-rule>` 标签中编写一系列复合元素。规则的上下文由 `<from-view-id>`
    元素确定，它引用一个特定的视图页面，`/order-start.xhtml`，或者它可以是应用于多个导航情况的通配符规则（星号 `*`）。每个导航规则都有一个
    `<navigation-case>` 元素的集合。每个情况都需要一个 `<from-outcome>` 和 `<to-view-id>` 元素。结果标识了由控制器方法返回的文本字符串，视图ID是目标视图。因此，在取消情况下，由取消标识的结果字符串将导航到
    `/cancel.xhtml` 视图。
- en: The advantage of the indirection mapping of the outcome to the view page is
    obvious. The outcome code in the controller remains the same but the destination
    view can change.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 将结果映射到视图页面的间接映射的优势是显而易见的。控制器中的结果代码保持不变，但目标视图可以更改。
- en: 'We can write a JSF controller that handles these navigation rules. This is
    an extract of the `ProductTypeController` class:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个处理这些导航规则的JSF控制器。这是 `ProductTypeController` 类的一个摘录：
- en: '[PRE25]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `cancel()` method simply returns the cancel outcome, which JSF maps to the
    `/cancel.xhtml` page because the navigation case matches the outcome. The `navigate()`
    method sets outcome depending on the `productType` property. There can only be
    two outcomes in the `fruit` and `vegetable` methods, and the navigation case ensures
    that the `fruit.xhtml` and `vegetable.xhtml` pages are rendered respectively.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`cancel()` 方法简单地返回取消结果，JSF将其映射到 `/cancel.xhtml` 页面，因为导航情况与结果匹配。`navigate()`
    方法根据 `productType` 属性设置结果。在 `fruit` 和 `vegetable` 方法中只能有两个结果，导航情况确保 `fruit.xhtml`
    和 `vegetable.xhtml` 页面分别渲染。'
- en: Wildcards
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通配符
- en: Navigation rules may also have wildcard views. A wildcard navigation rule occurs
    where the asterisk (`*`) character prepends to the URI path in the `<from-view-id>`
    element.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 导航规则也可以有通配符视图。通配符导航规则出现在 `<from-view-id>` 元素中的URI路径前缀为星号 (`*`) 的情况下。
- en: 'Suppose we have a website with protected pages that should not be displayable
    unless the user is logged in as a registered user. We can write a navigation rule
    that is shared for all the pages under the protected area. Let''s say we want
    to secure any web pages under the URI `/secured`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个网站，其中受保护的页面除非用户以注册用户登录，否则不应显示。我们可以编写一个适用于受保护区域下所有页面的共享导航规则。让我们说我们想要保护任何位于URI
    `/secured` 下的Web页面：
- en: '[PRE26]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The wildcard `from-view-id /secured/*` identifies all the pages that start with
    the `/secured/` prefix. You are allowed to have only one wildcard in a URI path.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 通配符 `from-view-id /secured/*` 识别所有以 `/secured/` 前缀开始的页面。在URI路径中，你只能有一个通配符。
- en: 'Using wildcards in an outcome brings forth the question of precedence. When
    does a wildcard `view id` take precedence over a direct outcome? Here is a navigation
    case extract of the Faces Configuration XML where we set the source page view:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在结果中使用通配符引发优先级问题。何时通配符 `视图ID` 覆盖直接结果？以下是设置源页面视图的Faces配置XML中的导航情况摘录：
- en: '[PRE27]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A direct `view id` always has a higher precedence over an equivalent wildcard
    view. JSF chooses the navigation case of a direct view, `stocks.xhtml`, over the
    wildcard view, as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 直接 `视图ID` 总是比等效的通配符视图有更高的优先级。JSF选择直接视图的导航情况，`stocks.xhtml`，而不是通配符视图，如下所示：
- en: '[PRE28]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If there are multiple wildcard views that are in competition for a match, then
    the longest match is chosen. JSF chooses the navigation case in the longest matching
    view, which is in the illustration `/secured/portfolio/*`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在多个通配符视图在竞争匹配，那么将选择最长的匹配。JSF在最长匹配的视图中选择导航情况，如图所示 `/secured/portfolio/*`。
- en: Conditional navigation
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件导航
- en: 'A JSF explicit page navigation also supports the idea of conditional navigation
    in the Faces configuration file. This allows the developer to declaratively set
    up the navigation rules based on the dynamic state of the application. Conditional
    navigation is achieved by using the `<if>` element tag, as shown in the next example:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: JSF显式页面导航也支持在Faces配置文件中实现条件导航的概念。这允许开发者根据应用程序的动态状态声明式地设置导航规则。条件导航是通过使用`<if>`元素标签实现的，如下一个示例所示：
- en: '[PRE29]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The body content of `<if>` is a deferred value expression, which is evaluated
    in the JSF lifecycle and should return a Boolean value. In the code, the `#{user.registered}`
    expression is evaluated to the bean with the current logged-in user profile bean
    and property called registered. The `#{!user.registered}` expression evaluates
    the negation—note the use of the exclamation character for the operator.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`<if>`标签的正文内容是一个延迟值表达式，它在JSF生命周期中评估，并应返回一个布尔值。在代码中，`#{user.registered}`表达式被评估为当前登录用户配置文件bean及其名为registered的属性。`#{!user.registered}`表达式评估否定——注意运算符使用了感叹号。'
- en: Static navigation
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态导航
- en: To complete the digital developer story about page navigation, it is time to
    look at static navigation with JSF. Static navigation allows us to traverse from
    one JSF page to another without invoking a managed bean controller. It is useful
    for the page views where there is no requirement for a server-side Java code or
    where there are no HTML input elements. Static navigation is achieved from a combination
    of markups on the Facelets view and explicit navigation rules.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成关于页面导航的数字开发者故事，现在是时候看看JSF的静态导航了。静态导航允许我们从一个JSF页面导航到另一个页面，而不需要调用管理bean控制器。这对于不需要服务器端Java代码或没有HTML输入元素的页面视图非常有用。静态导航是通过Facelets视图上的标记组合和显式导航规则实现的。
- en: 'In the earlier `Basic JSF` example, we had a page view with `<h:link>`. Let''s
    change this to `<h:commandButton>`:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的`Basic JSF`示例中，我们有一个带有`<h:link>`的页面视图。让我们将其更改为`<h:commandButton>`：
- en: '[PRE30]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The action attribute specifies the name of outcome to navigate. We will replace
    the old element with the `<h:commandButton>` JSF tag. The action attribute specifies
    the value expression. JSF looks for the initial term in several contexts but it
    will also search the Faces configuration to match the navigation rule. For this
    traversal to work, we also require a navigation rule in the Faces configuration:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 动作属性指定要导航的结果名称。我们将用`<h:commandButton>` JSF标签替换旧元素。动作属性指定值表达式。JSF将在几个上下文中查找初始项，但它也会搜索Faces配置以匹配导航规则。为了使此遍历工作，我们还需要在Faces配置中有一个导航规则：
- en: '[PRE31]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The navigation rule matches the `your-next-view` outcome from the Facelets view,
    and so JSF can navigate to the destination page.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 导航规则与Facelets视图中的`your-next-view`结果匹配，因此JSF可以导航到目标页面。
- en: I think we will stop here regarding the page navigation topic. We will continue
    our developer digital journey with page navigation in [Chapter 4](part0043.xhtml#aid-190861
    "Chapter 4. JSF Validation and AJAX"), *JSF Validation and AJAX*.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为关于页面导航的话题我们就到这里吧。我们将继续我们的开发者数字之旅，在[第4章](part0043.xhtml#aid-190861 "第4章。JSF验证和AJAX")中继续页面导航，*JSF验证和AJAX*。
- en: Summary
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has been a robust adventure in the world of JSF. You should be
    able to understand the theory of how the framework has been put together. We covered
    the key features of JSF such as an HTML5 friendly markup and a templating engine.
    JSF is a part of the Java EE platform and is available on many application servers
    and servlet containers. We learned how the JSF framework relates to the Model-View-Controller
    design pattern.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 本章在JSF的世界里是一次稳健的冒险。你应该能够理解框架是如何构建的理论。我们涵盖了JSF的关键特性，如HTML5友好的标记和模板引擎。JSF是Java
    EE平台的一部分，可在许多应用程序服务器和servlet容器上使用。我们学习了JSF框架如何与模型-视图-控制器设计模式相关联。
- en: You should be able to understand the request and response processing lifecycle
    and the phase change state model in JSF under the execute and render lifecycle.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够理解JSF在执行和渲染生命周期中的请求和响应处理生命周期以及阶段变化状态模型。
- en: Towards the middle chapter, we inspected the JSF basic pages, custom tag libraries,
    Facelets views, and a simple backing bean. We also observed a composition layout
    with both the master and client templates.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在中间章节，我们检查了JSF基本页面、自定义标签库、Facelets视图和简单的后端bean。我们还观察了包含主模板和客户端模板的复合布局。
- en: We also went in detail in the powerful EL framework, which is a part of Java
    EE 7 and JSF 2.2\. EL is a very important facility for the server-side Java applications,
    especially if they are built against Faces. To finish the journey, we looked at
    both implicit and explicit page navigation.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还详细介绍了强大的EL框架，它是Java EE 7和JSF 2.2的一部分。EL是服务器端Java应用程序的一个重要设施，特别是如果它们针对Faces构建。为了完成这次旅程，我们探讨了隐式和显式页面导航。
- en: We now have enough knowledge to constitute a JSF foundation. In the next chapter,
    we will look at beefing up our JSF knowledge with the HTML forms and set the ground
    running with validation. In the subsequent chapters, we will definitely lose the
    XHTML documents and add HTML5 so that we can develop more modern websites.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有足够的知识来构成JSF基础。在下一章中，我们将通过HTML表单增强我们的JSF知识，并开始验证。在随后的章节中，我们肯定会放弃XHTML文档并添加HTML5，以便我们可以开发更现代的网站。
- en: Exercises
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Here are the questions for this chapter:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是本章的问题：
- en: Where else in computer science might one find the Model-View-Controller design
    pattern?
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在计算机科学的哪个其他领域可以找到模型-视图-控制器设计模式？
- en: Why do you think that keen computer scientists and architects wanted to separate
    business logic from the presentation view code?
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你认为为什么热衷于计算机科学的科学家和建筑师想要将业务逻辑与展示视图代码分离？
- en: Consider a situation where you have been contracted by the municipal government
    for a local territory.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑一种情况，你被市政政府委托负责一个地方区域。
- en: You have been asked to write an electoral roll web application for the voters
    to replace the traditional paper trail. Instead of sending official letters to
    the citizens and waiting to receive the filled-in forms, the citizens will be
    able to register for the electoral roll online. What constitutes the Model-View-Controller
    in this application?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你被要求编写一个用于选民注册的选举名单网络应用程序，以取代传统的纸质记录。而不是向公民发送官方信件并等待收到填写好的表格，公民将能够在线注册选举名单。在这个应用程序中，模型-视图-控制器（Model-View-Controller）由什么构成？
- en: What parts of the JSF life cycle map to the Model-View-Controller pattern?
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JSF生命周期的哪些部分映射到模型-视图-控制器模式？
- en: Describe when and where the framework will encounter the Restore View phase.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述框架何时何地会遇到恢复视图阶段。
- en: Describe the process of an HTML form submission. What happens in JSF transferring
    the contents of an HTML form to the Java POJOS?
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述HTML表单提交的过程。在JSF中，将HTML表单的内容传输到Java POJOS时会发生什么？
- en: When a customer enters an invalid value in a form, describe the phases of the
    JSF life cycle that will process the Faces request. What do you think is added
    to the Faces response? Why?
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当客户在表单中输入无效值时，描述JSF生命周期中处理Faces请求的阶段。你认为在Faces响应中添加了什么？为什么？
- en: Why have the JSF specification writers explicitly designed a special Render
    Response phase?
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JSF规范编写者为什么明确设计了特殊的渲染响应阶段？
- en: JSF has explicitly separated the valuation from the invocation of business logic
    in a backing bean (or action controller). Other web frameworks have a validation
    code in the backing beans. Outline the pros and cons of both the approaches.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JSF在后端Bean（或动作控制器）中明确地将评估与业务逻辑的调用分离。其他Web框架在后端Bean中有验证代码。概述这两种方法的优缺点。
- en: 'Download the code for chapter 2 and study how the web application is laid out.
    If you are feeling brave, modify one of the project examples. Add another string
    property to the backing bean, and then add a JSF form text field (hint: `<f:inputText>`).
    What happens? If your changes go wrong, you can always revert the changes.'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载第2章的代码，研究Web应用程序的布局。如果你感到勇敢，可以修改项目示例之一。向后端Bean添加另一个字符串属性，然后添加一个JSF表单文本字段（提示：`<f:inputText>`）。会发生什么？如果你的更改出错，你总是可以撤销更改。
