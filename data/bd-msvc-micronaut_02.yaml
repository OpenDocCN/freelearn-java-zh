- en: '*Chapter 1*: Getting Started with Microservices Using the Micronaut Framework'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*：使用Micronaut框架开始微服务之旅'
- en: In recent times, there's been a good buzz about **microservices** and how the
    **microservices architecture** has been transformational in developing rapid,
    agile, and enterprise-grade web services to address the unique challenges and
    requirements of today's world. The microservices architecture has turned the page
    toward disciplining the standards on developing these web services. In this chapter,
    we will walk through the evolution of web services to microservices. We will quickly
    dive into some useful microservices design patterns. We will zero in on the key
    pitfalls in most of the traditional Java development frameworks and how their
    surface-level adoption to the microservices architecture has elevated performance
    and optimization issues. We will then explore how the Micronaut framework has
    addressed these performance and optimization issues in the microservices with
    an overhauled and ground-up approach to microservices development. Lastly, to
    get started with the Micronaut framework, we will set up the Micronaut CLI and
    work on a small hello world project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，关于**微服务**及其如何使**微服务架构**在开发快速、敏捷和面向企业的网络服务中发挥变革性作用的话题引起了广泛关注。微服务架构推动了这些网络服务开发标准的规范化。在本章中，我们将探讨网络服务向微服务的演变。我们将快速深入了解一些有用的微服务设计模式。我们将关注大多数传统Java开发框架中的关键陷阱，以及它们对微服务架构的表面级采用如何提高了性能和优化问题。然后，我们将探讨Micronaut框架如何通过彻底的、从头开始的方法解决微服务中的性能和优化问题。最后，为了开始使用Micronaut框架，我们将设置Micronaut
    CLI并完成一个小型的hello world项目。
- en: 'In this chapter, we will focus on these topics in particular:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将特别关注以下主题：
- en: Introducing microservices and their evolution
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍微服务及其演变
- en: Understanding microservices design patterns
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解微服务设计模式
- en: Why Micronaut is the best choice for developing microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么Micronaut是开发微服务的最佳选择
- en: Getting started with the Micronaut framework
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用Micronaut框架
- en: Working on the hello world project in the Micronaut framework
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Micronaut框架中完成hello world项目
- en: By the end of this chapter, you will have an understanding of how web services
    evolved in to microservices and why traditional Java frameworks are ineffective
    for developing microservices as compared to the Micronaut framework. Furthermore,
    we will also gain the practical knowledge to start using the Micronaut framework
    by working on a small project in the Micronaut framework.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将了解网络服务如何演变为微服务，以及为什么与Micronaut框架相比，传统的Java框架在开发微服务方面效率低下。此外，我们还将通过在Micronaut框架中完成一个小项目来获得使用Micronaut框架的实际知识。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the commands and technical instructions in this chapter are run on Windows
    10 and mac OS X. Code examples covered in this chapter are available in the book's
    GitHub repository at [https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter01](https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter01).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有命令和技术说明均在Windows 10和mac OS X上运行。本章涵盖的代码示例可在本书的GitHub存储库中找到，网址为[https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter01](https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter01)。
- en: 'The following tools need to be installed and set up in the development environment:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发环境中需要安装和设置以下工具：
- en: '**Java SDK**: Version 13 or above (we used Java 14).'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java SDK**：版本13或更高（我们使用了Java 14）。'
- en: '**Maven**: This is optional and only required if you would like to use Maven
    as the build system. However, we recommend having Maven set up on any development
    machine. Instructions to download and install Maven can be found at [https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi).'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Maven**：这是可选的，仅当您想使用Maven作为构建系统时才需要。然而，我们建议在任何开发机器上设置Maven。有关下载和安装Maven的说明，请参阅[https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi)。'
- en: '**Development IDE**: Based on your preferences, any Java-based IDE can be used,
    but for the purpose of writing this chapter, IntelliJ was used.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发IDE**：根据您的偏好，可以使用任何基于Java的IDE，但为了编写本章，使用了IntelliJ。'
- en: '**Git**: Instructions to download and install Git can be found at [https://git-scm.com/downloads](https://git-scm.com/downloads).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Git**：有关下载和安装Git的说明，请参阅[https://git-scm.com/downloads](https://git-scm.com/downloads)。'
- en: Introducing microservices and their evolution
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍微服务及其演变
- en: 'Before we thoroughly jump into introducing and defining microservices, it will
    be helpful to know how microservices have evolved. In the late 1960s, Alan Kay
    coined the term **object-oriented programming**. Though it was a definitive idea,
    later it birthed the four pillars for building software solutions using object-oriented
    programming:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入介绍和定义微服务之前，了解微服务的演变过程将非常有帮助。在20世纪60年代末，艾伦·凯提出了**面向对象编程**这一术语。虽然这是一个明确的概念，但后来它孕育了使用面向对象编程构建软件解决方案的四个支柱：
- en: Encapsulation
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装
- en: Inheritance
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: Polymorphism
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态
- en: Abstraction
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象
- en: In a short mnemonic, it's known as EIPA. Since the inception of these four pillars,
    the software industry has seen the rise and fall of many programming languages,
    frameworks, design patterns, and so on. With each such adaption and idea, thinkers
    and tinkerers have tried to come closer to EIPA by keeping a modular design and
    loosely coupled yet tightly encapsulated application components. Over the last
    few decades, software teams have moved away from the art of object-oriented programming
    toward the science of object-oriented programming by systematically adopting these
    key pillars. This iterative journey is the evolution of microservices.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 用简短的助记符，它被称为EIPA。自从这四个支柱诞生以来，软件行业见证了众多编程语言、框架、设计模式等的兴衰。随着每一次这样的适应和理念，思想家和发明家们试图通过保持模块化设计和松散耦合但紧密封装的应用程序组件，来更接近EIPA。在过去的几十年里，软件团队通过系统地采用这些关键支柱，从面向对象编程的艺术转向面向对象编程的科学。这一迭代之旅是微服务的演变。
- en: In the late 1980s and early 1990s, almost every enterprise application was exposed
    as either a command line or native desktop software. Applications were tightly
    connected to databases and it was almost as if the end user was directly interacting
    with the database with the application as a thin façade in between. It was the
    era of monolithic applications or client/server architecture.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪80年代末和90年代初，几乎每个企业应用程序都以命令行或本地桌面软件的形式暴露出来。应用程序与数据库紧密相连，几乎就像最终用户直接与数据库交互，而应用程序作为一个薄薄的门面介于两者之间。这是单体应用程序或客户端/服务器架构的时代。
- en: 'In the proceeding diagram, we can see how users interacted with a monolith
    application:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的图中，我们可以看到用户如何与单体应用程序交互：
- en: '![Figure 1.1 – Monolithic client/server architecture'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.1 – 单体客户端/服务器架构'
- en: '](img/Figure_1.1_B16585.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.1_B16585.jpg)'
- en: Figure 1.1 – Monolithic client/server architecture
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – 单体客户端/服务器架构
- en: As depicted in *Figure 1.1*, in monolithic client/server architecture, the application
    is tightly coupled to the database and the user interacts through a terminal façade
    or desktop application. In this architecture, it was painful to maintain good
    **service-level agreements** (**SLAs**). Almost all the key non-functional factors
    such as scalability, high availability, fault tolerance, and flexibility underperformed
    or failed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图1.1*所示，在单体客户端/服务器架构中，应用程序与数据库紧密耦合，用户通过终端门面或桌面应用程序进行交互。在这个架构中，维护良好的**服务级别协议**（**SLA**）非常痛苦。几乎所有关键的非功能性因素，如可伸缩性、高可用性、容错性和灵活性，都表现不佳或失败。
- en: 'To address some of these aspects **service-oriented architecture** (**SOA**)
    came into existence. In the 2000s, SOA was formalized in the industry with the
    definition of some standard protocols such as **Simple Object Access Protocol
    (SOAP**). **Web Services Description Language** (**WSDL**) was also created during
    this period. Web 2.0 applications were popular with **Asynchronous JavaScript
    And XML (AJAX**). Enterprise service bus and messaging systems were highly used
    in enterprise applications. Advancements in SOA catalyzed a new paradigm of delivering
    software solutions to end users: **Software as a Service** (**SaaS**). Instead
    of desktop applications and terminal clients, software solutions were delivered
    to end users over HTTP as hosted online services. In the proceeding diagram, we
    can see how users interacted with an SOA-based application:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，**面向服务的架构**（**SOA**）应运而生。在21世纪初，SOA在行业中得到了正式化，定义了一些标准协议，如**简单对象访问协议（SOAP**）。**Web服务描述语言**（**WSDL**）也在此期间被创建。Web
    2.0应用程序因**异步JavaScript和XML（AJAX**）而流行。企业服务总线和信息传递系统在企业应用程序中得到广泛使用。SOA的进步催化了向最终用户提供软件解决方案的新范式：**软件即服务**（**SaaS**）。软件解决方案不再通过桌面应用程序和终端客户端提供，而是作为托管在线服务通过HTTP提供给最终用户。在接下来的图中，我们可以看到用户如何与基于SOA的应用程序交互：
- en: '![Figure 1.2 – SOA'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.2 – SOA'
- en: '](img/Figure_1.2_B16585.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.2_B16585.jpg)'
- en: Figure 1.2 – SOA
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 – SOA
- en: As shown, SOA brought in some decoupling by separating the concerns between
    the web application, web server, and app server. App servers or **enterprise service
    buses** (**ESBs**) usually interact with the database and the user interacts with
    the application by accessing it on web browsers (SaaS solutions). Though SOA brought
    some relief, the adoption of SaaS left scalability and flexibility as key unhashed
    puzzles.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，SOA通过在Web应用程序、Web服务器和应用程序服务器之间分离关注点引入了一些解耦。应用程序服务器或**企业服务总线（ESB**）通常与数据库交互，用户通过在Web浏览器上访问应用程序与它交互（SaaS解决方案）。尽管SOA带来了一些缓解，但SaaS的采用留下了可扩展性和灵活性作为关键未解之谜。
- en: 'Post-2010, the technology world started to move much faster than it did in
    the previous two decades. With the introduction of containers, the cloud, big
    data, and machine learning, everything started moving rapidly in architecture
    design. It is the era of Uber, Airbnb, Netflix, and freemium/premium applications.
    Applications are designed for distributed computing and scalability. With the
    microservices architecture, the application is decomposed to loosely coupled microservices
    where each microservice owns its database. In the proceeding diagram, we can see
    how users interact with a microservices-based application:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 2010年之后，技术世界开始比前二十年移动得更快。随着容器、云、大数据和机器学习的引入，架构设计开始迅速发展。这是优步、爱彼迎、Netflix和免费/付费应用的时代。应用程序是为分布式计算和可扩展性而设计的。在微服务架构中，应用程序被分解为松散耦合的微服务，每个微服务拥有自己的数据库。在下面的图中，我们可以看到用户如何与基于微服务的应用程序交互：
- en: '![Figure 1.3 – Microservices architecture'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.3 – 微服务架构'
- en: '](img/Figure_1.3_B16585.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.3_B16585.jpg)'
- en: Figure 1.3 – Microservices architecture
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – 微服务架构
- en: In the previous diagram, we can see a fully realized microservices application
    where each microservice interacts with and owns its database. The user interacts
    with a single-page application through a modern browser. Any incoming requests
    from the web server are routed to the respective microservice. The full realization
    of microservices architecture is to address key factors of scalability, fault
    tolerance, high availability, and flexibility.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到一个完全实现的微服务应用程序，其中每个微服务都与自己的数据库交互。用户通过现代浏览器与单页应用程序交互。来自网络服务器的任何传入请求都会被路由到相应的微服务。微服务架构的完全实现是为了解决可扩展性、容错性、高可用性和灵活性等关键因素。
- en: 'To put it simply, microservices or microservices architecture componentize
    an application into a collection of interacting services. Each service could be
    developed, tested, deployed, and maintained independently. Thus, each smaller
    (micro) service has its own unique life cycle. Furthermore, since each service
    is loosely coupled (interacting with other services using HTTP/HTTPS), we can
    do the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，微服务或微服务架构将应用程序分解为一系列相互交互的服务。每个服务都可以独立地进行开发、测试、部署和维护。因此，每个较小的（微）服务都有自己的独特生命周期。此外，由于每个服务都是松散耦合的（使用HTTP/HTTPS与其他服务交互），我们可以做以下事情：
- en: Scale up or scale down (based on the service traffic).
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩大或缩小（根据服务流量）。
- en: Address any runtime faults (boot up the service backup).
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决任何运行时故障（启动服务备份）。
- en: Make new changes (change impact is limited to the service).
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行新的更改（更改影响仅限于服务）。
- en: Therefore, through the complete realization of decoupled architecture in the
    microservices, we address key issues of scalability, fault tolerance, high availability,
    and flexibility.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过在微服务中完全实现解耦架构，我们解决了可扩展性、容错性、高可用性和灵活性等关键问题。
- en: So far, we have learned about microservices and their evolution and how they
    have been transformational in addressing the unique, rapid, and agile needs of
    today's world. This understanding is a good preface to realizing the potential
    of microservices. In the next section, we will dive into the microservices design
    patterns.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了微服务及其演变，以及它们是如何在解决当今世界独特、快速和敏捷需求方面产生变革性的影响的。这种理解是实现微服务潜力的良好前言。在下一节中，我们将深入探讨微服务设计模式。
- en: Understanding microservices design patterns
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解微服务设计模式
- en: To fully realize the benefits of any architecture (including the microservices
    architecture), an architectural approach is often backed with design patterns.
    Understanding these design patterns is crucial for an ideal adoption of the architecture.
    In the following sections, we will cover some practical and commonly used design
    patterns in microservices. Each pattern addresses a different aspect of the application
    development life cycle and our focus would be to see these design patterns from
    a practical usage standpoint. We will begin with decomposition design patterns.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分实现任何架构（包括微服务架构）的好处，通常需要一个架构方法来支持设计模式。理解这些设计模式对于理想地采用架构至关重要。在接下来的章节中，我们将介绍一些实用且常用的微服务设计模式。每个模式都针对应用程序开发生命周期的不同方面，我们的重点是查看这些设计模式的实际使用角度。我们将从分解设计模式开始。
- en: Decomposition design patterns
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分解设计模式
- en: Decomposition design patterns dictate how we can componentize or decompose a
    big/monolithic application into smaller (micro) services. These patterns come
    in handy in designing a transformational architecture for any legacy monolithic
    application. The following are the most commonly used design patterns in decompositions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 分解设计模式规定了我们可以如何将大型/单体应用程序组件化或分解成更小的（微）服务。这些模式在为任何遗留单体应用程序设计转型架构时非常有用。以下是在分解中常用的设计模式。
- en: Decomposing by business capability
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按业务能力分解
- en: Any business capability is an instrument to make a profit. If we can enlist
    and categorize an application into a set of business capabilities such as inventory
    management, customer orders, or operations, then the application can be decomposed
    into microservices that are based on these business capabilities. This process
    to decompose is effective and recommended for small- to medium-sized applications.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 任何业务能力都是一种盈利工具。如果我们能将应用程序列出来并分类成一系列业务能力，如库存管理、客户订单或运营，那么应用程序就可以分解成基于这些业务能力的微服务。这个过程对于中小型应用程序来说是有效且推荐的。
- en: Decomposing by domains/sub-domains
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按领域/子领域分解
- en: If the application is an enterprise-grade and heavy application, then the previous
    approach may end up decomposing the application into smaller monoliths. These
    monoliths are smaller but monoliths nonetheless. In such cases, business modeling
    can help to categorize and map application functionalities into domains and sub-domains.
    Functionalities inside a domain/sub-domain are similar but very different from
    the functionalities of other domains/sub-domains. Microservices then can be designed
    and built around domains or sub-domains (if there are many functionalities mapped
    to a domain).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序是一个企业级和重量级的应用程序，那么先前的做法可能会导致应用程序分解成更小的单体。这些单体虽然更小，但仍然是单体。在这种情况下，业务建模可以帮助将应用程序功能分类并映射到领域和子领域。领域/子领域内的功能相似，但与其他领域/子领域的功能非常不同。然后，可以围绕领域或子领域（如果有许多功能映射到领域）设计和构建微服务。
- en: Integration design patterns
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成设计模式
- en: Once the application is broken down into smaller (micro) services, we will need
    to establish cohesion among these services. Integration design patterns address
    such collaboration requirements. The following are the most commonly used design
    patterns in integrations.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序被分解成更小的（微）服务，我们就需要在这些服务之间建立内聚。集成设计模式解决了这样的协作需求。以下是在集成中常用的设计模式。
- en: The API gateway pattern
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API网关模式
- en: 'Often upstream frontend consumers need to access microservices through a façade.
    This façade is called an API gateway. The API gateway design pattern serves an
    important purpose to keep things simple for frontend clients:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通常上游前端消费者需要通过一个外观访问微服务。这个外观被称为API网关。API网关设计模式为前端客户端保持简单提供了一个重要的目的：
- en: The frontend client is not sending too many requests to microservices.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端客户端不会向微服务发送过多的请求。
- en: The frontend client is not processing/aggregating too many responses (from microservices).
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端客户端不会处理/聚合过多的响应（来自微服务）。
- en: At the server end, the gateway routes a request to multiple microservices, and
    these microservices can run in parallel.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器端，网关将请求路由到多个微服务，这些微服务可以并行运行。
- en: Before sending the final response, we can aggregate individual responses from
    different microservices.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在发送最终响应之前，我们可以聚合来自不同微服务的单个响应。
- en: The aggregator pattern
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 聚合器模式
- en: This pattern is very similar to the aforementioned API gateway pattern. However,
    composite microservice is the key differential. The mandate of a composite microservice
    is to offload an incoming request to multiple microservices and then collaborate
    to create a unified response. This pattern is used when a user request is atomic
    from business logic standpoints, but it is processed by multiple microservices.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式与上述API网关模式非常相似。然而，复合微服务是关键区别。复合微服务的使命是将传入的请求卸载到多个微服务，然后协作创建统一的响应。当用户请求从业务逻辑的角度来看是原子的，但它由多个微服务处理时，使用此模式。
- en: The chained microservices pattern
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链式微服务模式
- en: 'In some scenarios, an incoming request is executed in a series of steps wherein
    each step could be spinning off a call to a microservice. For example, ordering
    an item in an online marketplace would require the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些场景中，一个传入的请求会通过一系列步骤执行，每个步骤都可能产生对微服务的调用。例如，在在线市场中订购商品可能需要以下步骤：
- en: Searching for an item (inventory management service)
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索商品（库存管理服务）
- en: Adding an item to the cart (cart service)
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将商品添加到购物车（购物车服务）
- en: Checking out the added item (payment service, mail service, inventory management
    service)
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查添加的商品（支付服务、邮件服务、库存管理服务）
- en: All these service calls would be synchronous. Fulfilling a user request would
    be an amalgamation of all these chained microservice calls.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些服务调用将是同步的。满足用户请求将是所有这些链式微服务调用的组合。
- en: Data management patterns
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据管理模式
- en: Integrating with the persistence layer is an important aspect of any microservice-based
    application. Greenfield (net new) and brownfield (legacy transformation) applications
    may dictate their requirements in how to choose a data management pattern. The
    following are the most often used design patterns in data management in microservices.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 将持久层集成是任何基于微服务应用程序的重要方面。绿色田野（全新）和棕色田野（遗留转型）应用程序可能规定了它们在如何选择数据管理模式方面的要求。以下是在微服务中数据管理最常用的设计模式。
- en: Database per service
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 每个服务一个数据库
- en: In greenfield (net new) applications, it is ideal to have a database per service.
    Each service is the owner of an isolated database (relational or non-relational)
    and any data operation must be executed through the microservice only. Furthermore,
    even if any other microservice needs to perform a database operation, then it
    should be routed through the owner microservice.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在绿色田野（全新）应用程序中，每个服务拥有一个数据库是最理想的。每个服务是独立数据库（关系型或非关系型）的所有者，任何数据操作都必须通过微服务执行。此外，即使任何其他微服务需要执行数据库操作，也应该通过所有者微服务路由。
- en: Shared database
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享数据库
- en: In brownfield (transformational) applications, it may not be practical to decompose
    the database into one database per service. In such scenarios, the microservices
    architecture realization can be kickstarted with services sharing a common monolith
    database.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在棕色田野（转型）应用程序中，将数据库分解为每个服务一个数据库可能不切实际。在这种情况下，可以通过共享一个公共单体数据库来启动微服务架构的实现。
- en: Command query responsibility segregation (CQRS)
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令查询责任分离（CQRS）
- en: 'In greenfield or fully transformed applications where each microservice is
    an independent database owner, there might be a requirement to query data from
    multiple databases. The CQRS pattern stipulates to decompose an application into
    a command and query:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在绿色田野或完全转型的应用程序中，每个微服务都是独立的数据库所有者，可能需要从多个数据库查询数据。CQRS模式规定将应用程序分解为命令和查询：
- en: '**Command**: This part will manage any create, update, and delete requests.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令**：这部分将管理任何创建、更新和删除请求。'
- en: '**Query**: This part will manage query requests using database views where
    database views can unify data from multiple schemas or data sources.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询**：这部分将使用数据库视图来管理查询请求，其中数据库视图可以统一来自多个模式或数据源的数据。'
- en: Cross-cutting patterns
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨切面模式
- en: Some concerns cut across all the different aspects/layers of microservices.
    In the following sub-sections, we will discuss some of these concerns and patterns.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一些关注点跨越了微服务的所有不同方面/层。在以下子节中，我们将讨论一些这些关注点和模式。
- en: The service discovery pattern
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务发现模式
- en: In a microservices-based application, each microservice may have more than one
    instance at runtime. Furthermore, these service instances can be added or removed
    at runtime based on traffic. This runtime agility can be an issue for upstream
    consumers in how they connect with services.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于微服务的应用程序中，每个微服务在运行时可能拥有多个实例。此外，这些服务实例可以根据流量在运行时添加或删除。这种运行时的灵活性可能会成为上游消费者如何与服务连接的问题。
- en: The service discovery pattern addresses this by implementing a service registry
    database. The service registry is a metadata store containing information such
    as the service name, where the service is running, and the current status of the
    service. Any change to the service runtime information will be updated in the
    service registry, for example, when a service adds a new instance or a service
    is down. This eases the pain for upstream consumers to connect with different
    microservices in the application.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 服务发现模式通过实现服务注册数据库来解决此问题。服务注册是一个元数据存储库，包含诸如服务名称、服务运行位置以及服务当前状态等信息。任何对服务运行时信息的更改都将更新到服务注册中，例如，当服务添加新实例或服务出现故障时。这简化了上游消费者连接到应用程序中不同微服务的痛苦。
- en: The circuit breaker pattern
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 断路器模式
- en: In a microservices-based application, often services interact with each other
    by invoking endpoints. There could be a scenario where a service is calling a
    downstream service but the downstream service is down. Without a circuit breaker,
    the upstream service will keep calling the downstream service while it's down
    and this will keep impacting the user interaction with the application.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于微服务的应用程序中，通常服务通过调用端点相互交互。可能会出现一种情况，即一个服务正在调用下游服务，但下游服务出现故障。如果没有断路器，上游服务将在下游服务处于故障状态时持续调用它，这将持续影响用户与应用程序的交互。
- en: In the circuit breaker pattern, a downstream service call will be routed through
    a proxy. This proxy will timeout for a fixed interval if the downstream service
    is down. After the timeout expiry, the proxy will try to connect again. If successful,
    it will connect with the downstream service; otherwise, it will renew the timeout
    period. Therefore, the circuit breaker will not bombard the downstream service
    with unnecessary calls and it will not impact user interaction with the application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在断路器模式中，下游服务调用将通过代理进行路由。如果下游服务出现故障，该代理将在固定的时间间隔后超时。在超时到期后，代理将再次尝试连接。如果连接成功，它将与下游服务连接；否则，它将更新超时周期。因此，断路器不会对下游服务进行不必要的调用，也不会影响用户与应用程序的交互。
- en: The log aggregation pattern
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日志聚合模式
- en: In the microservices landscape, often an incoming request will be processed
    by multiple services. Each service may create and log its entries. To trace any
    issues, it will be counter-intuitive to access these sporadic logs. By implementing
    a log aggregation pattern, logs could be indexed in a central place, thereby enabling
    easy access to all application logs. **Elasticsearch, Logstash, Kibana** (**ELK**)
    can be used to implement log aggregation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务领域中，通常一个入站请求会被多个服务处理。每个服务都可能创建并记录其条目。为了追踪任何问题，访问这些零散的日志可能会显得反直觉。通过实现日志聚合模式，日志可以在一个中心位置进行索引，从而使得访问所有应用程序日志变得容易。可以使用**Elasticsearch、Logstash、Kibana**（**ELK**）来实现日志聚合。
- en: In this section, we covered some often-used design patterns in different stages
    of the application life cycle. Understanding these design patterns is required
    to fully reap the benefits of microservices architecture. In the next section,
    we will dive into the Micronaut framework for developing microservices.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了应用生命周期不同阶段中常用的一些设计模式。理解这些设计模式是充分利用微服务架构优势的必要条件。在下一节中，我们将深入探讨用于开发微服务的Micronaut框架。
- en: Why Micronaut is the best choice for developing microservices
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么Micronaut是开发微服务的最佳选择
- en: In the previous sections, we learned about the maturity on the architectural
    side of microservices. Unfortunately, on the implementation side, an overhaul
    shift to build/develop microservices is not as mature as microservices architecture.
    To address some of these implementation challenges, many traditional Java frameworks
    have added small, iterative changes, but much-sought-after disruptive and overhauled
    changes are missing. At the core, these traditional Java frameworks have stayed
    almost the same since the time of monolithic services. Reflections, runtime proxies,
    and bulky configuration management have plagued all traditional frameworks with
    slower boot time and bigger memory footprints, making them unsuitable for microservices
    development.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了微服务架构在架构方面的成熟度。不幸的是，在实施方面，向构建/开发微服务的全面转变并不像微服务架构那样成熟。为了解决这些实施挑战，许多传统的Java框架已经添加了小的、迭代的变更，但人们迫切需要的颠覆性和全面性的变更却缺失。从根本上讲，这些传统的Java框架自单体服务时代以来几乎保持不变。反射、运行时代理和庞大的配置管理一直困扰着所有传统框架，导致它们启动时间较慢和内存占用更大，这使得它们不适合微服务开发。
- en: 'Micronaut is developed from the bottom up, considering these important challenges,
    to organically support microservices development:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Micronaut是从底层开发的，考虑到这些重要的挑战，以有机地支持微服务开发：
- en: '`@Inject` for dependency injection. It adds the *Java inject* module to the
    compiler and all the annotations are processed at compile time. The compiler generates
    the byte code for all the classes based on the annotations that are used in their
    source code. This is all done at compile time. At runtime, Micronaut can instantiate
    the beans and read their metadata from the generated byte code and does not need
    to use the slow reflection API.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Inject`用于依赖注入。它将*Java注入*模块添加到编译器中，并且所有注解都在编译时进行处理。编译器根据源代码中使用的注解生成所有类的字节码。所有这些都是在编译时完成的。在运行时，Micronaut可以实例化bean并从生成的字节码中读取它们的元数据，而不需要使用缓慢的反射API。'
- en: '**Ahead-of-time compilation**: As discussed before, one of the key contrasts
    is that Micronaut performs dependency injection, configuration management, and
    aspect-oriented programming proxying at compile time. Micronaut relies on one
    or more annotation processors to process the annotation metadata into **ASM**-generated
    (**assembly**) byte code. Furthermore, this ahead-of-time-generated byte code
    is further optimized by Java''s **just-in-time** (**JIT**) compiler. Other frameworks
    use reflection and produce the annotation metadata at application boot-up. This
    metadata is loaded to runtime memory, therefore increasing the memory footprint.
    Instead of the Java Reflection API, Micronaut uses the Java annotation processor
    API, the Kotlin compiler plugin for annotation processors, and Groovy AST transformations
    for metaprogramming.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译时编译**：正如之前讨论的那样，一个关键的区别是Micronaut在编译时执行依赖注入、配置管理和面向方面的编程代理。Micronaut依赖于一个或多个注解处理器来将注解元数据处理成由**ASM**生成的（**汇编**）字节码。此外，这种提前生成的字节码还通过Java的**即时**（**JIT**）编译器进一步优化。其他框架使用反射，并在应用程序启动时生成注解元数据。这些元数据被加载到运行时内存中，因此增加了内存占用。Micronaut不是使用Java反射API，而是使用Java注解处理器API、Kotlin编译器插件和Groovy
    AST转换来进行元编程。'
- en: '**Faster boot-up time and lower memory consumption**: Other frameworks use
    Java reflections and at application boot-up, all classpaths are scanned to generate
    reflection metadata for each field, method, and constructor. This metadata is
    then used to determine and inject the required object into the application runtime.
    This adds significantly to boot-up time as well as runtime memory. As discussed
    previously, Micronaut uses ahead-of-time compilation and the Java annotation processor
    API to offload such work from the runtime and reduce memory requirements by not
    pushing unnecessary reflection metadata onto runtime memory.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更快的启动时间和更低的内存消耗**：其他框架使用Java反射，并在应用程序启动时扫描所有类路径以生成每个字段、方法和构造函数的反射元数据。然后，这些元数据被用来确定并注入所需的对象到应用程序运行时。这显著增加了启动时间和运行时内存。正如之前讨论的那样，Micronaut使用编译时编译和Java注解处理器API来将这项工作从运行时卸载，并通过不将不必要的反射元数据推送到运行时内存来降低内存需求。'
- en: '**Serverless applications support**: One of the key issues in serverless applications
    is boot-up time. With a huge memory footprint and slower boot-up time, traditional
    frameworks are not a prudent choice to develop serverless applications. Micronaut
    organically supports serverless application development by keeping the minimal
    runtime memory footprint and sub-second boot-up time. Furthermore, Micronaut natively
    supports commonly used cloud platforms for serverless function development.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无服务器应用程序支持**：无服务器应用程序中的一个关键问题是启动时间。由于内存占用大且启动时间慢，传统框架不是开发无服务器应用程序的明智选择。Micronaut通过保持最小的运行时内存占用和亚秒级启动时间，自然支持无服务器应用程序的开发。此外，Micronaut原生支持常用的云平台用于无服务器函数开发。'
- en: '**Language-agnostic framework**: The Micronaut framework supports the Java,
    Kotlin, and Groovy programming languages. With varied support for major programming
    languages, developers can choose their preferred language option when considering
    cloud requirements. For example, for IoT requirements, Groovy could be a good
    option. This language-agnostic enablement makes it flexible and apt for varied
    requirements of mobile/web/cloud solutions.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言无关的框架**：Micronaut框架支持Java、Kotlin和Groovy编程语言。由于对主要编程语言的广泛支持，开发者在考虑云需求时可以选择他们偏好的语言选项。例如，对于物联网需求，Groovy可能是一个不错的选择。这种语言无关的启用使其灵活且适用于移动/网络/云解决方案的多种需求。'
- en: '**Support to GraalVM**: Since Micronaut doesn''t use reflections, any Micronaut-based
    application can be ahead-of-time compiled into a GraalVM native image. GraalVM
    is a universal virtual machine offered by Oracle that can run a Java application
    down to machine code. This increases application performance significantly. Any
    Micronaut application compiled to a GraalVM native image can boot up in milliseconds.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对GraalVM的支持**：由于Micronaut不使用反射，任何基于Micronaut的应用都可以编译成GraalVM原生镜像。GraalVM是Oracle提供的一个通用虚拟机，可以运行Java应用程序到机器码。这显著提高了应用程序的性能。任何编译成GraalVM原生镜像的Micronaut应用程序都可以在毫秒内启动。'
- en: 'In light of the preceding key points, Micronaut stands out as a preferred framework
    to develop cloud-native, ultra-light, and rapid microservices. In addition, we
    performed a quick benchmark experiment to compare the application startup times
    for Micronaut versus another popular traditional framework. In the following chart,
    startup times are shown for both Micronaut and a traditional framework:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 基于前面的关键点，Micronaut作为一个首选框架，在开发云原生、超轻量级和快速微服务方面脱颖而出。此外，我们进行了一个快速基准实验，比较了Micronaut与另一个流行的传统框架的应用程序启动时间。在下面的图表中，显示了Micronaut和传统框架的启动时间：
- en: '![Figure 1.4 – Startup times for a traditional framework versus Micronaut'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.4 – 传统框架与Micronaut的启动时间'
- en: '](img/Figure_1.4_B16585.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.4 – 传统框架与Micronaut的启动时间'
- en: Figure 1.4 – Startup times for a traditional framework versus Micronaut
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – 传统框架与Micronaut的启动时间
- en: As shown in the preceding chart, the traditional framework took 6,156 milliseconds
    to boot up whereas Micronaut took only 3,750 milliseconds. This time difference
    in booting up the application is significant and sets Micronaut as a go-to framework
    for developing cloud-native and rapid microservices.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，传统框架启动需要6,156毫秒，而Micronaut只需3,750毫秒。这种启动时间的差异是显著的，使Micronaut成为开发云原生和快速微服务的首选框架。
- en: In the following section, we will get started with using the Micronaut framework
    on both Windows as well as mac OS.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将开始使用Micronaut框架在Windows和mac OS上。
- en: Getting started with the Micronaut framework
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Micronaut框架
- en: In order to get started with the Micronaut framework, we will begin by installing
    the Micronaut CLI on Mac and Windows OS.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始使用Micronaut框架，我们将从在Mac和Windows OS上安装Micronaut CLI开始。
- en: Installing the Micronaut CLI on mac OS
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在mac OS上安装Micronaut CLI
- en: On mac OS, we can install the Micronaut CLI in a couple of ways – using SDKMAN!,
    Homebrew, or MacPorts. In the following sections, we will cover step-by-step instructions
    to install the Micronaut CLI.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在mac OS上，我们可以通过几种方式安装Micronaut CLI – 使用SDKMAN!、Homebrew或MacPorts。在接下来的章节中，我们将逐步介绍安装Micronaut
    CLI的步骤。
- en: Installing Micronaut using SDKMAN!
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用SDKMAN!安装Micronaut
- en: 'Please follow these steps to install the Micronaut CLI using SDKMAN!:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 请按照以下步骤使用SDKMAN!安装Micronaut CLI：
- en: Open Terminal.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端。
- en: 'If you don''t have SDKMAN! installed, take the following steps:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您尚未安装SDKMAN!，请执行以下步骤：
- en: 'a. Type or paste the following command:'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 输入或粘贴以下命令：
- en: '[PRE0]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'b. Next, type or paste the following command:'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 接下来，输入或粘贴以下命令：
- en: '[PRE1]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To install the Micronaut CLI, type or paste the following command:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装 Micronaut CLI，请输入或粘贴以下命令：
- en: '[PRE2]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You will observe the following interactions on Terminal while installing the
    Micronaut CLI:'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在安装 Micronaut CLI 时，你将在终端观察到以下交互：
- en: '![Figure 1.5 – Installing Micronaut CLI on mac OS using SDKMAN!'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 1.5 – 使用 SDKMAN! 在 macOS 上安装 Micronaut CLI'
- en: '](img/Figure_1.5_B16585.jpg)'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Figure_1.5_B16585.jpg](img/Figure_1.5_B16585.jpg)'
- en: Figure 1.5 – Installing Micronaut CLI on mac OS using SDKMAN!
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Figure 1.5 – 使用 SDKMAN! 在 macOS 上安装 Micronaut CLI
- en: 'If all the preceding steps execute successfully, you can verify the Micronaut
    CLI installation by running the following command in Terminal:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果所有前面的步骤都执行成功，你可以通过在终端中运行以下命令来验证 Micronaut CLI 的安装：
- en: '[PRE3]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Installing Micronaut using Homebrew
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Homebrew 安装 Micronaut
- en: 'Please follow these steps to install the Micronaut CLI using MacPorts:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请按照以下步骤使用 MacPorts 安装 Micronaut CLI：
- en: Open Terminal.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端。
- en: 'If you don''t have Homebrew installed, then take the following steps:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有安装 Homebrew，请执行以下步骤：
- en: 'a. Type or paste the following command:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 输入或粘贴以下命令：
- en: '[PRE4]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'b. Next, type or paste the following command:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 接下来，输入或粘贴以下命令：
- en: '[PRE5]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Type or paste the following command:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入或粘贴以下命令：
- en: '[PRE6]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You will observe the following interactions on Terminal while installing the
    Micronaut CLI:'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在安装 Micronaut CLI 时，你将在终端观察到以下交互：
- en: '![Figure 1.6 – Installing the Micronaut CLI on mac OS using HomeBrew'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 1.6 – 使用 HomeBrew 在 macOS 上安装 Micronaut CLI'
- en: '](img/Figure_1.6_B16585.jpg)'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Figure_1.6_B16585.jpg](img/Figure_1.6_B16585.jpg)'
- en: Figure 1.6 – Installing the Micronaut CLI on mac OS using HomeBrew
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Figure 1.6 – 使用 HomeBrew 在 macOS 上安装 Micronaut CLI
- en: 'If all the preceding steps execute successfully, you can verify the Micronaut
    CLI installation by hitting the following command in Terminal:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果所有前面的步骤都执行成功，你可以通过在终端中执行以下命令来验证 Micronaut CLI 的安装：
- en: '[PRE7]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Installing Micronaut using MacPorts
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 MacPorts 安装 Micronaut
- en: 'Please follow these steps to install the Micronaut CLI using Homebrew:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请按照以下步骤使用 Homebrew 安装 Micronaut CLI：
- en: If you don't have MacPorts installed, then follow the instructions at [https://www.macports.org/install.php](https://www.macports.org/install.php).
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有安装 MacPorts，请按照 [https://www.macports.org/install.php](https://www.macports.org/install.php)
    中的说明进行操作。
- en: Open Terminal.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端。
- en: 'Type or paste the following command:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入或粘贴以下命令：
- en: '[PRE8]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Type or paste the following command:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入或粘贴以下命令：
- en: '[PRE9]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You will observe the following interactions on Terminal while installing the
    Micronaut CLI:'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在安装 Micronaut CLI 时，你将在终端观察到以下交互：
- en: '![Figure 1.7 – Installing the Micronaut CLI on macOS using MacPorts'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 1.7 – 使用 MacPorts 在 macOS 上安装 Micronaut CLI'
- en: '](img/Figure_1.7_B16585.jpg)'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Figure_1.7_B16585.jpg](img/Figure_1.7_B16585.jpg)'
- en: Figure 1.7 – Installing the Micronaut CLI on macOS using MacPorts
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Figure 1.7 – 使用 MacPorts 在 macOS 上安装 Micronaut CLI
- en: 'If all the preceding steps execute successfully, you can verify the Micronaut
    CLI installation by hitting the followed command in Terminal:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果所有前面的步骤都执行成功，你可以通过在终端中执行以下命令来验证 Micronaut CLI 的安装：
- en: '[PRE10]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Installing the Micronaut CLI on Windows
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Windows 上安装 Micronaut CLI
- en: 'Please follow these steps to install the Micronaut CLI on Windows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请按照以下步骤在 Windows 上安装 Micronaut CLI：
- en: 'Download the Micronaut CLI binary from the Micronaut download page: [https://micronaut.io/download.html](https://micronaut.io/download.html).'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Micronaut 下载页面下载 Micronaut CLI 二进制文件：[https://micronaut.io/download.html](https://micronaut.io/download.html)。
- en: Unzip the downloaded binary file into a folder on your system. It is better
    to keep this in a separate folder under a root directory such as `C:\Program Files\Micronaut`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将下载的二进制文件解压到系统上的一个文件夹中。最好将其保存在根目录下的单独文件夹中，例如 `C:\Program Files\Micronaut`。
- en: Create a new system variable called `MICRONAUT_HOME` with the preceding directory
    path. Please note to add this variable under system variables (not user variables).
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `MICRONAUT_HOME` 的新系统变量，并使用前面的目录路径。请注意，要将此变量添加到系统变量（而不是用户变量）中。
- en: Then, update your Windows `PATH` environment variable. You can add a path such
    as `%MICRONAUT_HOME%\bin`.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，更新你的 Windows `PATH` 环境变量。你可以添加一个路径，例如 `%MICRONAUT_HOME%\bin`。
- en: 'Open Command Prompt or any terminal and type the following command:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令提示符或任何终端，并输入以下命令：
- en: '[PRE11]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will boot up the CLI for the first time by resolving any dependencies.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将启动 CLI 并解决任何依赖项。
- en: 'To test that the CLI is installed properly, type the following command:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试 CLI 是否正确安装，请输入以下命令：
- en: '[PRE12]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is what the command outputs:'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是命令输出的内容：
- en: '![Figure 1.8 – Installing the Micronaut CLI on Windows OS'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 1.8 – 在 Windows OS 上安装 Micronaut CLI'
- en: '](img/Figure_1.8_B16585_Fixed.jpg)'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Figure_1.8_B16585_Fixed.jpg](img/Figure_1.8_B16585_Fixed.jpg)'
- en: Figure 1.8 – Installing the Micronaut CLI on Windows OS
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.8 – 在 Windows OS 上安装 Micronaut CLI
- en: You should see all the **CLI** options after hitting the preceding command.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行前面的命令后，您应该会看到所有 **CLI** 选项。
- en: In this section, we explored different ways to install the Micronaut CLI in
    Windows and macOS. In order to get hands-on with the Micronaut framework, we will
    get started with working on a hello world project in the next section.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了在 Windows 和 macOS 上安装 Micronaut CLI 的不同方法。为了亲身体验 Micronaut 框架，我们将在下一节中开始在一个
    hello world 项目上工作。
- en: Working on a hello world project in the Micronaut framework
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Micronaut 框架中工作于 hello world 项目
- en: To understand the practical aspects of using the Micronaut framework for developing
    a microservice, we will work with a hello world project. This will help you quickly
    get started with the Micronaut framework and also give you first-hand experience
    of how easy it is to do microservices development.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解使用 Micronaut 框架开发微服务的实际方面，我们将通过一个 hello world 项目进行操作。这将帮助您快速开始使用 Micronaut
    框架，并让您亲身体验微服务开发是多么简单。
- en: Micronaut works seamlessly with the Maven and Gradle packaging managers. We
    will cover one example for each using the Micronaut CLI as well as Micronaut Launch
    (web interface) for generating barebones projects.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Micronaut 与 Maven 和 Gradle 打包管理器无缝协作。我们将使用 Micronaut CLI 以及 Micronaut Launch（网页界面）各举一个例子来生成基础项目。
- en: Creating a hello world project using the Micronaut CLI
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Micronaut CLI 创建 hello world 项目
- en: 'Please take the following steps to create a hello world application using the
    Micronaut CLI:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 请按照以下步骤使用 Micronaut CLI 创建 hello world 应用程序：
- en: Open the terminal (or Command Prompt).
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端（或命令提示符）。
- en: Change the directory to your desired directory where you want to create the
    hello world project.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将目录更改为您想要创建 hello world 项目的目标目录。
- en: 'Type the following command:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令：
- en: '[PRE13]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Wait for the Micronaut CLI to finish and it will create a `hello-world-maven`
    project. The `create-app` command will create a boilerplate project for you with
    a Maven build and your system-installed Java version. It will create `Application.java`
    as well as a sample test class called `ApplicationTest.java`.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待 Micronaut CLI 完成，它将创建一个 `hello-world-maven` 项目。`create-app` 命令将为您创建一个带有 Maven
    构建和系统安装的 Java 版本的样板项目。它将创建 `Application.java` 以及一个名为 `ApplicationTest.java` 的示例测试类。
- en: To explore your freshly created `hello-world-maven` project, open this project
    in your preferred IDE.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要探索您刚刚创建的 `hello-world-maven` 项目，请使用您首选的 IDE 打开此项目。
- en: 'To run your project, run the following command in a Bash terminal:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行您的项目，请在 Bash 终端中运行以下命令：
- en: '[PRE14]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: mvn -N io.takari:maven:wrapper
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: mvn -N io.takari:maven:wrapper
- en: '[PRE15]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The Maven wrapper will build and run your project on `http://localhost:8080`
    by default.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Maven 包装器默认会在 `http://localhost:8080` 上构建和运行您的项目。
- en: Adding HelloWorldController
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加 HelloWorldController
- en: 'To create a simple endpoint, let''s add a simple controller to the `hello-world-maven`
    project:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个简单的端点，让我们向 `hello-world-maven` 项目添加一个简单的控制器：
- en: Add a web package to our `hello-world-maven` project.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个网络包添加到我们的 `hello-world-maven` 项目中。
- en: 'Add a `HelloWorldController` Java class. It will contain a simple `hello` endpoint:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `HelloWorldController` Java 类。它将包含一个简单的 `hello` 端点：
- en: '[PRE16]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`HelloController` is accessible on the `…/hello` path. `helloMicronaut()` will
    generate a plain text `"Hello, Micronaut!"` message.'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`HelloController` 可在 `…/hello` 路径上访问。`helloMicronaut()` 将生成一个纯文本 `"Hello, Micronaut!"`
    消息。'
- en: 'Rerun your application and hit [http://localhost:8080/hello/](http://localhost:8080/hello/)
    in a browser window. The server will return the following response:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行您的应用程序，并在浏览器窗口中点击 [http://localhost:8080/hello/](http://localhost:8080/hello/)。服务器将返回以下响应：
- en: '![Figure 1.9 – Hello, Micronaut!'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.9 – 你好，Micronaut！'
- en: '](img/Figure_1.9_B16585_Fixed.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.9_B16585_Fixed.jpg)'
- en: Figure 1.9 – Hello, Micronaut!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9 – 你好，Micronaut！
- en: By default, the application will be accessible on port `8080`, and this port
    can be changed in the application properties.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，应用程序将在端口 `8080` 上可用，并且可以在应用程序属性中更改此端口。
- en: So far, we have worked on a hello world project using the Micronaut CLI. Next,
    we will explore Micronaut Launch, which is a web interface, to generate a boilerplate
    project.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用 Micronaut CLI 创建了一个 hello world 项目。接下来，我们将探索 Micronaut Launch，这是一个网页界面，用于生成样板项目。
- en: Creating a hello world project using Micronaut Launch
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Micronaut Launch 创建 hello world 项目
- en: '**Micronaut Launch** ([https://micronaut.io/launch/](https://micronaut.io/launch/))
    is an intuitive web interface that came into existence with Micronaut 2.0.1\.
    We can use this interface to quickly generate boilerplate for different kinds
    of Micronaut applications (such as server applications, the CLI, serverless functions,
    a messaging application, and so on). Let''s quickly use this to generate a hello
    world application for us.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**Micronaut Launch** ([https://micronaut.io/launch/](https://micronaut.io/launch/))
    是一个直观的 Web 界面，随着 Micronaut 2.0.1 的发布而出现。我们可以使用此界面快速为不同类型的 Micronaut 应用程序（如服务器应用程序、CLI、无服务器函数、消息应用程序等）生成模板。让我们快速使用它为我们生成一个
    hello world 应用程序。'
- en: 'Please follow these instructions to generate the hello world project using
    the Micronaut Launch web interface:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请按照以下说明使用 Micronaut Launch Web 界面生成 hello world 项目：
- en: 'Open Micronaut Launch in a browser window: [https://micronaut.io/launch/](https://micronaut.io/launch/).'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器窗口中打开 Micronaut Launch：[https://micronaut.io/launch/](https://micronaut.io/launch/)。
- en: Under **Application Type**, choose **Application**.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **应用程序类型** 下，选择 **应用程序**。
- en: Under **Micronaut Version**, choose **2.0.1**.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Micronaut 版本** 下，选择 **2.0.1**。
- en: For the Java version, choose **Java 14**.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 Java 版本，选择 **Java 14**。
- en: For **Language**, choose **Java**.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 **语言**，选择 **Java**。
- en: Give a base package name such as `com.packtpub.micronaut`.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给一个基本包名，例如 `com.packtpub.micronaut`。
- en: Choose **Gradle** as the build option.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **Gradle** 作为构建选项。
- en: Give a name to the application, such as `hello-world-gradle`.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给应用程序命名，例如 `hello-world-gradle`。
- en: Choose **JUnit** as the testing framework
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **JUnit** 作为测试框架
- en: After you've finished choosing all the options, click on **GENERATE PROJECT**.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在完成所有选项的选择后，点击 **生成项目**。
- en: 'After choosing the preceding options and providing various inputs, the Micronaut
    Launch interface should look as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择前面的选项并输入各种输入后，Micronaut Launch 界面应如下所示：
- en: '![Figure 1.10 – Using Micronaut Launch to generate a boilerplate project'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.10 – 使用 Micronaut Launch 生成模板项目'
- en: '](img/Figure_1.10_B16585_Fixed.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.10_B16585_Fixed.jpg)'
- en: Figure 1.10 – Using Micronaut Launch to generate a boilerplate project
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10 – 使用 Micronaut Launch 生成模板项目
- en: Your project boilerplate source code will be generated into a zipped file. You
    can unarchive this zipped file into your desired directory and open it in your
    preferred IDE. Just like the previous example (`hello-world-maven`), we can add
    a basic `HelloWorldController` instance.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您的项目模板源代码将被生成到一个压缩文件中。您可以将此压缩文件解压到您想要的目录中，并在您首选的 IDE 中打开它。就像之前的例子 (`hello-world-maven`)
    一样，我们可以添加一个基本的 `HelloWorldController` 实例。
- en: 'To run your project, run the following command in a Bash terminal:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行您的项目，请在 Bash 终端中运行以下命令：
- en: '[PRE17]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When the project is running, go to `http://localhost:8080/hello` and you should
    see the **Hello, Micronaut!** message in the browser tab.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目运行时，请访问 `http://localhost:8080/hello`，你应该在浏览器标签页中看到 **Hello, Micronaut!**
    消息。
- en: In this section, we explored how to get started with the Micronaut framework
    by developing small hello world projects using the Micronaut CLI as well as the
    Micronaut Launch user interface. This small exercise will be a good preface for
    what we will cover in the next chapter.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了如何通过使用 Micronaut CLI 以及 Micronaut Launch 用户界面开发小型的 hello world 项目来开始使用
    Micronaut 框架。这个小练习将为我们下一章将要介绍的内容做一个良好的铺垫。
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we began our journey into microservices by exploring their
    evolution and some useful design patterns. We covered the Micronaut framework
    in contrast to the traditional reflection-based Java frameworks. Essentially,
    Micronaut's approach to leverage ahead-of-time compilation (and not reflections)
    sets it apart as an ideal framework for developing microservices. To get our hands
    dirty, we went through setting up the Micronaut CLI on mac OS as well as Windows
    OS. Lastly, we worked on `hello-world-maven` and `hello-world-gradle` projects.
    In both projects, we added `hello` endpoints.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过探索其演变和一些有用的设计模式，开始了我们的微服务之旅。我们对比了 Micronaut 框架与传统基于反射的 Java 框架。本质上，Micronaut
    利用编译时编译（而不是反射）的方法，使其成为开发微服务的理想框架。为了亲身体验，我们介绍了在 mac OS 和 Windows OS 上设置 Micronaut
    CLI 的方法。最后，我们在 `hello-world-maven` 和 `hello-world-gradle` 项目上进行了工作。在这两个项目中，我们添加了
    `hello` 端点。
- en: With the fundamentals of microservices as well as practical hello world projects
    covered, this chapter enhanced your knowledge of the evolution of microservices,
    their design patterns, and why Micronaut should be preferred for developing microservices.
    This foundational understanding is the bedrock for starting the adventure of microservices
    development in the Micronaut framework.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在涵盖了微服务的基本原理以及实际的“Hello World”项目之后，本章增强了你对微服务演变、设计模式以及为什么应该选择 Micronaut 来开发微服务的了解。这种基础理解是开始在
    Micronaut 框架中开发微服务冒险的基石。
- en: At the end of this chapter, we kickstarted an exciting journey into microservices
    development using the Micronaut CLI and Micronaut Launch. In the next chapter,
    we will explore how we can integrate different kinds of persistent storage and
    databases in the Micronaut framework.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章末尾，我们启动了一段使用 Micronaut CLI 和 Micronaut Launch 开发微服务的激动人心的旅程。在下一章中，我们将探讨如何在
    Micronaut 框架中集成不同类型的持久存储和数据库。
- en: Questions
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How did web services evolve into microservices?
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网络服务是如何演变成微服务的？
- en: What is a microservice?
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是微服务？
- en: What is the microservice architecture?
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是微服务架构？
- en: What are the microservices design patterns?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微服务设计模式有哪些？
- en: What is Micronaut?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 Micronaut？
- en: Why should Micronaut be preferred for developing microservices?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么应该优先选择 Micronaut 来开发微服务？
- en: Which framework should be used to develop microservices?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发微服务应该使用哪个框架？
- en: How do you install the Micronaut CLI on macOS?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在 macOS 上安装 Micronaut CLI？
- en: How do you install the Micronaut CLI on Windows OS?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在 Windows OS 上安装 Micronaut CLI？
- en: How do you create a project using the Micronaut CLI?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用 Micronaut CLI 创建一个项目？
- en: How do you create a project using Micronaut Launch?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用 Micronaut Launch 创建一个项目？
