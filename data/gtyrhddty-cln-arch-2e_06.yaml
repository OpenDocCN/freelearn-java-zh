- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Implementing a Web Adapter
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Web适配器
- en: Most applications today have some kind of web interface – either a UI that we
    can interact with via a web browser or an HTTP API that other systems can call
    to interact with our application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的大多数应用程序都有某种形式的Web界面——要么是我们可以通过Web浏览器与之交互的UI，要么是其他系统可以通过调用以与我们的应用程序交互的HTTP
    API。
- en: In our target architecture, all communication with the outside world goes through
    adapters. So, let’s discuss how we can implement an adapter that provides such
    a web interface.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的目标架构中，所有与外部世界的通信都通过适配器进行。因此，让我们讨论如何实现一个提供此类Web界面的适配器。
- en: Dependency Inversion
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖倒置
- en: '*Figure 6**.1* gives a zoomed-in view of the architecture elements that are
    relevant to our discussion of a web adapter – the adapter itself and the ports
    through which it interacts with our application core:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6.1*给出了一个放大视图，展示了与我们讨论Web适配器相关的架构元素——适配器本身以及它通过哪些端口与我们的应用程序核心交互：'
- en: '![Figure 6.1 – An incoming adapter talks to the application layer through dedicated
    incoming ports, which are interfaces implemented by the domain services](img/Figure_06.1_B19916.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 一个传入适配器通过专用传入端口与应用层通信，这些端口是由领域服务实现的接口](img/Figure_06.1_B19916.jpg)'
- en: Figure 6.1 – An incoming adapter talks to the application layer through dedicated
    incoming ports, which are interfaces implemented by the domain services
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 一个传入适配器通过专用传入端口与应用层通信，这些端口是由领域服务实现的接口
- en: The web adapter is a “driving” or “incoming” adapter. It takes requests from
    the outside and translates them into calls to our application core, telling it
    what to do. The control flow goes from the controllers in the web adapter to the
    services in the application layer.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Web适配器是一个“驱动”或“传入”适配器。它从外部接收请求并将它们转换为对应用程序核心的调用，告诉它要做什么。控制流从Web适配器中的控制器流向应用层中的服务。
- en: The application layer provides specific ports through which the web adapter
    may communicate. Each port is what I have called a “use case” in the previous
    chapter, and it is implemented by a domain service in the application layer.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层通过特定的端口提供通信，这些端口是我在上一章中所称的“用例”，并由应用层中的领域服务实现。
- en: If we look closer, we notice that this is the Dependency Inversion Principle
    in action. Since the control flow goes from left to right, we could just as well
    let the web adapter call the use cases directly, as shown in *Figure 6**.2*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细观察，会发现这是依赖倒置原则在起作用。由于控制流是从左到右的，我们同样可以让Web适配器直接调用用例，如图*6.2*所示。
- en: '![Figure 6.2 – We can remove the port interfaces and call the services directly](img/Figure_06.2_B19916.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – 我们可以移除端口接口并直接调用服务](img/Figure_06.2_B19916.jpg)'
- en: Figure 6.2 – We can remove the port interfaces and call the services directly
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 我们可以移除端口接口并直接调用服务
- en: So why do we add another layer of indirection between the adapter and the use
    cases? The reason is that the ports are a specification of the places where the
    outside world can interact with our application core. By having ports in place,
    we know exactly which communication with the outside world takes place, which
    is valuable information for any maintenance engineer working on your legacy code
    base.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么我们在适配器和用例之间添加另一层间接层呢？原因在于端口是外部世界可以与我们的应用程序核心交互的地点的规范。通过设置端口，我们确切地知道哪些与外部世界的通信发生了，这对于任何正在为您的遗留代码库工作的维护工程师来说都是宝贵的信息。
- en: Knowing the ports that drive the application also lets us build a test driver
    for the application. This test driver is an adapter that calls the input ports
    to simulate and test certain usage scenarios – more about testing in [*Chapter
    8*](B19916_08.xhtml#_idTextAnchor071), *Testing* *Architecture Elements*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 了解驱动应用程序的端口也让我们可以为应用程序构建一个测试驱动器。这个测试驱动器是一个适配器，它调用输入端口来模拟和测试某些使用场景——更多关于测试的内容请参阅[*第8章*](B19916_08.xhtml#_idTextAnchor071)，*测试*
    *架构元素*。
- en: Having talked about the importance of input ports, one of the shortcuts we’ll
    talk about in [*Chapter 11*](B19916_11.xhtml#_idTextAnchor096), *Taking Shortcuts
    Consciously*, is just leaving the incoming ports out and calling the application
    services directly.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了输入端口的重要性之后，我们将在[*第11章*](B19916_11.xhtml#_idTextAnchor096)，*有意识地走捷径*中讨论的一个捷径是直接跳过传入端口并直接调用应用程序服务。
- en: One question remains, though, which is relevant for highly interactive applications.
    Imagine a server application that sends real-time data to the user’s browser via
    WebSocket. How does the application core send this real-time data to the web adapter,
    which in turn sends it to the user’s browser?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，还有一个问题与高度交互式应用程序相关。想象一个通过WebSocket向用户浏览器发送实时数据的服务器应用程序。应用程序核心如何将实时数据发送到网络适配器，而网络适配器再将数据发送到用户浏览器？
- en: 'For this scenario, we definitely need a port because, without a port, the application
    would have to depend on an adapter implementation, breaking our efforts to keep
    the application free from dependencies on the outside. This port must be implemented
    by the web adapter and called by the application core, as depicted in *Figure
    6**.3*:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个场景，我们肯定需要一个端口，因为没有端口，应用程序将不得不依赖于适配器实现，这会破坏我们使应用程序免受外部依赖的努力。这个端口必须由网络适配器实现，并由应用程序核心调用，如图*图6**.3*所示：
- en: '![Figure 6.3 – If an application must actively notify a web adapter, we need
    to go through an outgoing port to keep the dependencies in the right direction](img/Figure_06.3_B19916.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – 如果应用程序必须主动通知网络适配器，我们需要通过输出端口来保持依赖关系的正确方向](img/Figure_06.3_B19916.jpg)'
- en: Figure 6.3 – If an application must actively notify a web adapter, we need to
    go through an outgoing port to keep the dependencies in the right direction
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 如果应用程序必须主动通知网络适配器，我们需要通过输出端口来保持依赖关系的正确方向
- en: The `WebSocketController` on the left implements the port interface in the `out`
    package, and services in the application core can call this port to send real-time
    data to the user’s browser.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的`WebSocketController`实现了`out`包中的端口接口，应用程序核心可以通过这个端口调用以将实时数据发送到用户的浏览器。
- en: Technically speaking, this would be an outgoing port and make the web adapter
    an incoming and outgoing adapter. But there is no reason that the same adapter
    cannot be both at the same time. For the rest of this chapter, we’ll assume that
    the web adapter is an incoming adapter only since this is the most common case.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上来说，这将是一个输出端口，使网络适配器成为一个输入和输出适配器。但没有任何理由说同一个适配器不能同时是两者。在本章的其余部分，我们将假设网络适配器仅作为输入适配器，因为这是最常见的情况。
- en: Responsibilities of a web adapter
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络适配器的职责
- en: What does a web adapter actually do? Let’s say we want to provide a REST API
    for our BuckPal application. Where do the responsibilities of the web adapter
    start and where do they end?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 网络适配器实际上做什么？假设我们想要为我们的BuckPal应用程序提供一个REST API。网络适配器的职责从哪里开始，又在哪里结束？
- en: 'A web adapter usually does these things:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 网络适配器通常做以下事情：
- en: Maps the incoming HTTP request to objects.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将传入的HTTP请求映射到对象。
- en: Performs authorization checks.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行授权检查。
- en: Validates the input.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证输入。
- en: Maps the request objects to the input model of the use case.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将请求对象映射到用例的输入模型。
- en: Calls the use case.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用用例。
- en: Maps the output of the use case back to HTTP.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将用例的输出映射回HTTP。
- en: Returns the HTTP response.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回HTTP响应。
- en: First of all, a web adapter must listen to HTTP requests that match certain
    criteria such as a URL path, HTTP method, and content type. The parameters and
    the content of a matching HTTP request must then be deserialized into objects
    we can work with.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，网络适配器必须监听符合某些标准（如URL路径、HTTP方法和内容类型）的HTTP请求。然后，匹配的HTTP请求的参数和内容必须反序列化为我们可以处理的对象。
- en: Commonly, a web adapter then does an authentication and authorization check
    and returns an error if it fails.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，网络适配器会进行身份验证和授权检查，如果失败则返回错误。
- en: The state of the incoming objects can then be validated. But haven’t we already
    discussed input validation as a responsibility of the input model to the use cases?
    Yes, the input model to the use cases should only allow input that is valid in
    the context of the use cases. But here, we’re talking about the input model to
    the web adapter. It might have a completely different structure and semantics
    from the input model to the use cases, so we might have to perform different validations.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以验证传入对象的状态。但我们不是已经讨论过输入验证作为输入模型对用例的职责了吗？是的，输入模型对用例应该只允许在用例上下文中有效的输入。但在这里，我们谈论的是网络适配器的输入模型。它可能具有与用例输入模型完全不同的结构和语义，因此我们可能需要进行不同的验证。
- en: I don’t advocate implementing the same validations in the web adapter as we
    have already done in the input model of the use cases. Instead, we should validate
    that we can transform the input model of the web adapter into the input model
    of the use cases. Anything that prevents us from doing this transformation is
    a validation error.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我不主张在Web适配器中实现与我们在用例输入模型中已经实现的相同验证。相反，我们应该验证我们能否将Web适配器的输入模型转换为用例的输入模型。任何阻止我们进行这种转换的因素都是验证错误。
- en: 'This brings us to the next responsibility of a web adapter: to call a certain
    use case with the transformed input model. The adapter then takes the output of
    the use case and serializes it into an HTTP response, which is sent back to the
    caller.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这将我们带到Web适配器的下一个责任：使用转换后的输入模型调用特定的用例。然后适配器获取用例的输出并将其序列化为HTTP响应，发送回调用者。
- en: If anything goes wrong on the way and an exception is thrown, the web adapter
    must translate the error into a message that is sent back to the caller.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在过程中出现任何问题并抛出异常，网络适配器必须将错误转换为发送回调用者的消息。
- en: That’s a lot of responsibilities weighing on the shoulders of our web adapter.
    But it’s also a lot of responsibilities that the application layer should not
    be concerned with. Anything that has to do with HTTP must not leak into the application
    layer. If the application core knows that we’re dealing with HTTP on the outside,
    we have lost the option to perform the same domain logic from other incoming adapters
    that do not use HTTP. In a maintainable architecture, we want to keep options
    open.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的Web适配器承担了大量的责任。但这也是应用层不应该关心的责任。任何与HTTP相关的事情都不应该泄露到应用层。如果应用核心知道我们在外部处理HTTP，我们就失去了从其他不使用HTTP的传入适配器执行相同领域逻辑的选项。在一个可维护的架构中，我们希望保持选项开放。
- en: Note that this boundary between the web adapter and application layer comes
    naturally if we start development with the domain and application layers instead
    of with the web layer. If we implement the use cases first, without thinking about
    any specific incoming adapter, we are not tempted to blur the boundary.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们从领域层和应用层开始开发，而不是从网络层开始，那么网络适配器与应用层之间的边界就会自然而然地出现。如果我们首先实现用例，而不考虑任何特定的传入适配器，我们就不会倾向于模糊边界。
- en: Slicing controllers
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切片控制器
- en: In most web frameworks – such as Spring MVC in the Java world – we create controller
    classes that perform the responsibilities we have discussed previously. So, do
    we build a single controller that answers all requests directed at our application?
    We don’t have to. A web adapter may certainly consist of more than one class.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数Web框架中——例如Java世界的Spring MVC——我们创建执行我们之前讨论过的责任的控制器类。那么，我们是否需要构建一个回答所有指向我们应用程序的请求的单个控制器？我们不必这样做。Web适配器可能由多个类组成。
- en: We should take care, however, to put these classes into the same package hierarchy
    to mark them as belonging together, as discussed in [*Chapter 4*](B19916_04.xhtml#_idTextAnchor037),
    *Organizing Code*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们应该注意将这些类放入相同的包层次结构中，以标记它们属于一起，正如在[*第4章*](B19916_04.xhtml#_idTextAnchor037)“组织代码”中讨论的那样。
- en: So, how many controllers do we build? I say we should rather build too many
    than too few. We should make sure that each controller implements a slice of the
    web adapter that is as narrow as possible and that shares as little as possible
    with other controllers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们构建多少个控制器呢？我说我们宁愿构建太多也不愿太少。我们应该确保每个控制器实现尽可能窄的Web适配器切片，并且与其他控制器共享尽可能少的内容。
- en: Let’s take the operations on an account entity within our BuckPal application.
    A popular approach is to create a single `AccountController` that accepts requests
    for all operations that relate to accounts.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以BuckPal应用程序中的账户实体操作为例。一种常见的方法是创建一个单独的`AccountController`，它接受与账户相关的所有操作的请求。
- en: 'A Spring controller providing a REST API might look like the following code
    snippet:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 提供REST API的Spring控制器可能看起来像以下代码片段：
- en: '![](img/code-6.1.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![代码-6.1](img/code-6.1.jpg)'
- en: Everything concerning the account resource is in a single class, which feels
    good. But let’s discuss the downsides of this approach.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与账户资源相关的一切都在一个类中，这感觉很好。但让我们讨论一下这种方法的缺点。
- en: First, less code per class is a good thing. I have worked on a legacy project
    where the largest class had 30,000 lines of code.[1](#footnote-022) That’s no
    fun. Even if the controller only accumulates 200 lines of code over the years,
    it’s still harder to grasp than 50 lines, even when it’s cleanly separated into
    methods.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，每个类中代码更少是好事。我在一个遗留项目中工作过，其中最大的类有30,000行代码。[1](#footnote-022) 这不是什么有趣的事情。即使控制器多年来只积累了200行代码，它也比50行代码更难理解，即使它被干净地分离成方法。
- en: '[1](#footnote-022-backlink) 30,000 lines of code: it was actually a conscious
    architecture decision (by our predecessors, mind you) that lead to those 30,000
    lines being in a single class: to change the system at runtime, without re-deployment,
    it allowed them to upload compiled Java bytecode in a `.class` file. And it only
    allowed them to upload a single file, so this file had to contain all the code.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[1](#footnote-022-backlink) 30,000行代码：这实际上是我们前辈（请注意）的一个有意识的架构决策，导致这30,000行代码位于一个类中：为了在运行时更改系统，而不需要重新部署，它允许他们上传编译后的Java字节码到`.class`文件中。而且它只允许他们上传一个文件，所以这个文件必须包含所有代码。'
- en: The same argument is valid for test code. If the controller itself has a lot
    of code, there will be a lot of test code. And often, test code is even harder
    to grasp than production code because it tends to be more abstract. We also want
    to make the tests for a certain piece of production code to be easy to find, which
    is easier in small classes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的论点也适用于测试代码。如果控制器本身有很多代码，那么就会有大量的测试代码。而且，通常测试代码比生产代码更难理解，因为它往往更抽象。我们还想让特定生产代码的测试更容易找到，这在小型类中更容易实现。
- en: Equally important, however, is that putting all operations into a single controller
    class encourages the reuse of data structures. In the preceding code example,
    many operations share the `AccountResource` model class. It serves as a bucket
    for everything that is needed in any of the operations. `AccountResource` probably
    has an `id` field. This is not needed in the `create` operation and will probably
    confuse here more than it will help. Imagine that an `Account` has a one-to-many
    relationship with `User` objects. Do we include those `User` objects when creating
    or updating an account? Will the users be returned by the list operation? This
    is an easy example, but in any above-play-size project, we’ll ask these questions
    at some point.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 同样重要的是，然而，将所有操作放入单个控制器类中鼓励了数据结构的重用。在先前的代码示例中，许多操作共享`AccountResource`模型类。它作为任何操作所需内容的容器。`AccountResource`可能有一个`id`字段。在`create`操作中不需要这个字段，而且可能会比它有帮助的地方更多造成混淆。想象一下，`Account`与`User`对象之间存在一对一的关系。在创建或更新账户时，我们会包括那些`User`对象吗？用户会被列表操作返回吗？这是一个简单的例子，但在任何大型项目中，我们迟早都会问这些问题。
- en: 'So, I advocate the approach to create a separate controller, potentially in
    a separate package, for each operation. Also, we should name the methods and classes
    as close to our use cases as possible:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我提倡为每个操作创建一个单独的控制器，可能是在一个单独的包中。我们还应该尽可能将方法和类名与我们的用例相匹配：
- en: '![](img/code-6.2.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例](img/code-6.2.jpg)'
- en: We can take primitives as input, as we did with `sourceAccountId`, `targetAccountId`,
    and `amount` in the example. But each controller can also have its own input model.
    Instead of a generic model such as `AccountResource`, we might then have a model
    specific to the use case such as `CreateAccountResource` or `UpdateAccountResource`.
    Those specialized model classes may even be private to the controller’s package
    to prevent accidental reuse. Controllers may still share models, but using shared
    classes from another package makes us think about it more and perhaps we will
    find out that we don’t need half of the fields and will create our own, after
    all.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将原始数据作为输入，就像我们在示例中处理`sourceAccountId`、`targetAccountId`和`amount`时那样。但每个控制器也可以有自己的输入模型。我们可能有一个针对特定用例的模型，如`CreateAccountResource`或`UpdateAccountResource`，而不是一个通用的模型如`AccountResource`。这些专门的模型类甚至可以是控制器包私有的，以防止意外重用。控制器仍然可以共享模型，但使用来自另一个包的共享类让我们更多地思考它，也许我们会发现我们不需要一半的字段，最终会创建自己的。
- en: Also, we should think hard about the names of the controllers and services.
    Instead of `CreateAccount`, for instance, wouldn’t `RegisterAccount` be a better
    name? In our BuckPal application, the only way to create an account is for a user
    to register it. So, we use the word “register” in class names to better convey
    their meaning. There are certainly cases where the usual suspects (`Create...`,
    `Update...`, and `Delete...`) sufficiently describe a use case, but we might want
    to think twice before actually using them.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还应该仔细思考控制器和服务的命名。例如，对于`CreateAccount`，难道`RegisterAccount`不是一个更好的名字吗？在我们的BuckPal应用中，创建账户的唯一方式是用户注册它。因此，我们在类名中使用“register”这个词来更好地传达它们的含义。当然，有些情况下，常用的命名方式（`Create...`、`Update...`和`Delete...`）足以描述一个用例，但在实际使用之前，我们可能需要三思而后行。
- en: Another benefit of this slicing style is that it makes parallel work on different
    operations a breeze. We won’t have merge conflicts if two developers work on different
    operations.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种切割风格的另一个好处是，它使得在不同操作上的并行工作变得轻而易举。如果两个开发者分别处理不同的操作，我们不会遇到合并冲突。
- en: How does this help me build maintainable software?
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这如何帮助我构建可维护的软件？
- en: When building a web adapter to an application, we should keep in mind that we’re
    building an adapter that translates the HTTP protocol to method calls on the use
    cases of our application, translates the results back to HTTP, and does not do
    any domain logic.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建一个应用到Web的适配器时，我们应该记住，我们正在构建一个适配器，它将HTTP协议转换为应用用例的方法调用，将结果转换回HTTP，并且不执行任何领域逻辑。
- en: The application layer, on the other hand, should not do HTTP, so we should make
    sure not to leak HTTP details. This makes the web adapter replaceable with another
    adapter should the need arise.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，应用层不应处理HTTP，因此我们应该确保不要泄露HTTP细节。这使得Web适配器在需要时可以替换为另一个适配器。
- en: When slicing web controllers, we should not be afraid to build many small classes
    that don’t share a model. They’re easier to grasp and test, and they support parallel
    work. It’s more work initially to set up such fine-grained controllers, but it
    will pay off during maintenance.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当切割Web控制器时，我们不应害怕构建许多不共享模型的小类。它们更容易理解和测试，并且支持并行工作。最初设置这样细粒度的控制器需要更多的工作，但在维护期间会得到回报。
- en: Having looked at the incoming side of our application, we’ll now take a look
    at the outgoing side and how to implement a persistence adapter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看我们应用的输入端之后，我们现在将来看看输出端以及如何实现持久化适配器。
