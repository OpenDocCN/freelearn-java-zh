- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Finding Bottlenecks and Optimizing Your Application
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找瓶颈并优化你的应用程序
- en: Finding what makes your application perform below your expectations can be difficult
    if you don’t follow a systematic approach. When optimizing an application, it’s
    important to focus your efforts on facts, not guesses. For that reason, in this
    chapter, we’ll leverage the tools and learnings from [*Chapter 3*](B21646_03.xhtml#_idTextAnchor103),
    and we’ll tackle some common challenges by analyzing the footprints of the changes
    applied.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不遵循系统化的方法，找到使你的应用程序表现低于预期的原因可能会很困难。在优化应用程序时，重要的是将你的努力集中在事实而不是猜测上。因此，在本章中，我们将利用第[*3章*](B21646_03.xhtml#_idTextAnchor103)中的工具和经验，通过分析应用变更的足迹来解决一些常见挑战。
- en: In this chapter, you will learn how to use observability tools to find the bottlenecks
    of your application and apply some common techniques of application optimization,
    such as caching and runtime tuning. You will also learn how to improve your application’s
    startup time and resource consumption by using native applications, which have
    been supported since Spring Boot 3’s release.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用可观察性工具来找到你应用程序的瓶颈，并应用一些常见的应用程序优化技术，如缓存和运行时调整。你还将学习如何通过使用自Spring
    Boot 3发布以来一直支持的本地应用程序来提高你的应用程序的启动时间和资源消耗。
- en: We’ll run some load tests to apply stress to our application, and we’ll learn
    how to analyze the results.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将运行一些负载测试，以对我们的应用程序施加压力，并学习如何分析结果。
- en: 'In this chapter, we will go through the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Tuning the database connection pool
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整数据库连接池
- en: Caching dependencies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存依赖项
- en: Using shared cache
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用共享缓存
- en: Using Testcontainers with Redis cache
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Testcontainers与Redis缓存一起使用
- en: Creating a native image using Spring Boot
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Boot创建原生镜像
- en: Using GraalVM Tracing Agent to configure the native application
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GraalVM跟踪代理配置本地应用程序
- en: Creating a native executable using Spring Boot
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Boot创建原生可执行文件
- en: Creating a native executable from a JAR
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从JAR文件创建原生可执行文件
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: I created an application that we’ll optimize during this chapter. This application
    provides some RESTful APIs to manage football data. The application uses PostgreSQL
    as a data repository. You can find it on https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/,
    in the `chapter7/football` folder. This application is already configured for
    observability, exposing a Prometheus endpoint with Actuator. To monitor the application,
    you can use Prometheus and Grafana.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了一个应用程序，我们将在本章中对其进行优化。这个应用程序提供了一些RESTful API来管理足球数据。该应用程序使用PostgreSQL作为数据存储库。你可以在https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/上找到它，在`chapter7/football`文件夹中。这个应用程序已经配置了可观察性，通过Actuator暴露了Prometheus端点。要监控应用程序，你可以使用Prometheus和Grafana。
- en: Prometheus configuration
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus配置
- en: You will need to configure Prometheus, as explained in the *Integrating your
    application with Prometheus and Grafana* recipe in [*Chapter 3*](B21646_03.xhtml#_idTextAnchor103).
    I have already prepared the `prometheus.yml` file. You will need to get the IP
    address of your computer and set the value in the `prometheus.yml` file.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要配置Prometheus，如[*3章*](B21646_03.xhtml#_idTextAnchor103)中“将你的应用程序与Prometheus和Grafana集成”食谱中所述。我已经准备好了`prometheus.yml`文件。你需要获取你计算机的IP地址并将其设置在`prometheus.yml`文件中。
- en: 'I created a Grafana dashboard to monitor the application’s performance. To
    make it, I used the following dashboard as a starting point and adapted it for
    our purposes: [https://grafana.com/grafana/dashboards/12900-springboot-apm-dashboard/](https://grafana.com/grafana/dashboards/12900-springboot-apm-dashboard/).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了一个Grafana仪表板来监控应用程序的性能。为了制作它，我使用了以下仪表板作为起点，并对其进行了调整以适应我们的目的：[https://grafana.com/grafana/dashboards/12900-springboot-apm-dashboard/](https://grafana.com/grafana/dashboards/12900-springboot-apm-dashboard/)。
- en: 'In addition to PostgreSQL, Prometheus, and Grafana, we’ll also use Redis for
    some recipes. As usual, the simplest way to run all these services on your computer
    is using Docker. You can get Docker from the product page: [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/).
    I will explain how to deploy each tool in its corresponding recipe.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 除了PostgreSQL、Prometheus和Grafana之外，我们还将使用Redis来处理一些食谱。像往常一样，在计算机上运行所有这些服务的最简单方法是使用Docker。你可以在产品页面：[https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/)上获取Docker。我将在相应的食谱中解释如何部署每个工具。
- en: You may need a tool to execute SQL scripts in PostgreSQL. You can use the `psql`
    command-line tool or the more user-friendly *PgAdmin* tool. You can check the
    *Connect your application to PostgreSQL* recipe in [*Chapter 5*](B21646_05.xhtml#_idTextAnchor203)
    for more details.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要一个工具来在PostgreSQL中执行SQL脚本。您可以使用`psql`命令行工具或更用户友好的*PgAdmin*工具。您可以在[*第5章*](B21646_05.xhtml#_idTextAnchor203)中查看*将应用程序连接到PostgreSQL*的菜谱以获取更多详细信息。
- en: I prepared some JMeter tests to generate some load over the application. You
    can download JMeter from the project website at [https://jmeter.apache.org](https://jmeter.apache.org).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我准备了一些JMeter测试来在应用程序上生成一些负载。您可以从项目网站[https://jmeter.apache.org](https://jmeter.apache.org)下载JMeter。
- en: For some of the recipes related to native applications, you will need the **GraalVM**
    JDK. You can follow the instructions to install it from the official website at
    [https://www.graalvm.org/downloads/](https://www.graalvm.org/downloads/).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些与原生应用程序相关的菜谱，您将需要**GraalVM** JDK。您可以根据官方网站[https://www.graalvm.org/downloads/](https://www.graalvm.org/downloads/)上的说明进行安装。
- en: 'All the recipes that will be demonstrated in this chapter can be found at:
    [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter7](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter7)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将要演示的所有菜谱都可以在以下位置找到：[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter7](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter7)
- en: Tuning the database connection pool
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整数据库连接池
- en: Database connections are an expensive resource that can take some time when
    they’re created for the first time. For that reason, Spring Boot uses a technique
    known as connection pooling. When a connection pool is used, the application doesn’t
    create a direct connection to the database; instead, it requests an available
    connection to the connection pool. When the application doesn’t need a connection,
    it returns it to the pool. The connection pool usually creates some connections
    at the start of the application. When the connections are returned to the pool,
    they are not closed but reused by other parts of the application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库连接是一种昂贵的资源，当它们第一次创建时可能需要一些时间。因此，Spring Boot使用一种称为连接池的技术。当使用连接池时，应用程序不会直接与数据库建立连接；相反，它向连接池请求一个可用的连接。当应用程序不需要连接时，它会将其返回到池中。连接池通常在应用程序启动时创建一些连接。当连接返回到池中时，它们不会被关闭，而是由应用程序的其他部分重用。
- en: A common challenge when operating applications is deciding on the connection
    pool size. If the size is too small, under a certain load, some requests will
    take longer as they wait for a connection to become available in the pool. If
    the connection pool is too large, it will waste resources in the database server,
    as open connections are expensive.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作应用程序时，一个常见的挑战是确定连接池的大小。如果大小太小，在一定的负载下，一些请求会因为等待连接池中的连接变得可用而花费更长的时间。如果连接池太大，它将在数据库服务器上浪费资源，因为打开的连接是昂贵的。
- en: In this recipe, we’ll learn how to monitor the database connection pool in a
    Spring Boot application using standard metrics and monitoring tools. We’ll use
    the techniques and tools learned in [*Chapter 3*](B21646_03.xhtml#_idTextAnchor103).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用标准指标和监控工具在Spring Boot应用程序中监控数据库连接池。我们将使用在[*第3章*](B21646_03.xhtml#_idTextAnchor103)中学到的技术和工具。
- en: Getting ready
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, you will optimize an application that I have already prepared
    for this purpose. You can find the application in the book’s GitHub repository
    at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/),
    in the `chapter7/football` folder. I recommend copying the folder’s content to
    your working directory, as we’ll apply different optimizations over the base project
    on each recipe.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，您将优化我已经为此目的准备的应用程序。您可以在书籍的GitHub仓库[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/)中找到该应用程序，在`chapter7/football`文件夹中。我建议将文件夹的内容复制到您的当前工作目录，因为我们将对每个菜谱在基础项目上应用不同的优化。
- en: 'The application uses PostgreSQL as a database engine and is configured for
    monitoring using Zipkin, Prometheus, and Grafana. You can run all these dependent
    services in Docker; for that purpose, I have prepared a `docker-compose-base.yml`
    file that you can find in the `chapter7/docker` folder. You can run this `docker-compose-base.yml`
    file by opening a terminal in the directory containing the file and executing
    the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序使用PostgreSQL作为数据库引擎，并配置了使用Zipkin、Prometheus和Grafana进行监控。你可以在Docker中运行所有这些依赖服务；为此，我在`chapter7/docker`文件夹中准备了一个`docker-compose-base.yml`文件。你可以通过在包含文件的目录中打开终端并执行以下命令来运行此`docker-compose-base.yml`文件：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Prometheus service has a configuration file named `prometheus.yml` that
    contains the application scrapping configuration. It points to my computer’s IP,
    but you will need to change it to your IP configuration. You should configure
    the Prometheus data source and the *SpringBoot APM Dashboard*. See the *Integrating
    your application with Prometheus and Grafana* recipe in [*Chapter 3*](B21646_03.xhtml#_idTextAnchor103),
    for more details.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus服务有一个名为`prometheus.yml`的配置文件，其中包含应用程序抓取配置。它指向我的电脑IP，但你需要将其更改为你的IP配置。你应该配置Prometheus数据源和*SpringBoot
    APM仪表板*。有关更多详细信息，请参阅[*第3章*](B21646_03.xhtml#_idTextAnchor103)中的*将应用程序与Prometheus和Grafana集成*配方。
- en: 'I have prepared a JMeter test to generate workload on the application. You
    can find it in `chapter7/jmeter/Football.jmx`. This test simulates a common use
    case for the sample Football Trading application. The test performs the following
    steps:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经准备了一个JMeter测试来在应用程序上生成工作负载。你可以在`chapter7/jmeter/Football.jmx`中找到它。此测试模拟了示例足球交易应用程序的常见用例。测试执行以下步骤：
- en: One user buys some cards.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个用户购买了一些卡片。
- en: Another user buys some cards.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一位用户购买了一些卡片。
- en: Both users try to use the cards in their albums.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两位用户都试图在他们自己的专辑中使用这些卡片。
- en: Then, the first user gets all available cards from the second user and vice
    versa, the second user gets all available cards from the first user.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，第一位用户从第二位用户那里获得了所有可用的卡片，反之亦然，第二位用户从第一位用户那里获得了所有可用的卡片。
- en: Both users examine the players on the cards from the other user.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两位用户检查来自另一位用户的卡片上的球员。
- en: They trade between them their available cards.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他们之间交换他们可用的卡片。
- en: The test has 10 threads running simultaneously with no think time between requests.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 测试有10个线程同时运行，请求之间没有思考时间。
- en: How to do it…
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We’ll launch the application and ensure we see the application metrics in Grafana.
    Ready to find the application bottleneck and optimize it? Let’s go for it!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将启动应用程序，并确保我们在Grafana中看到应用程序指标。准备好寻找应用程序瓶颈并优化它了吗？让我们行动起来吧！
- en: 'First, we’ll start the application, and we’ll check that we see the application
    metrics in Grafana. I’ll assume you have already started all dependent services
    as explained in the *Getting* *ready* section:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将启动应用程序，并检查我们是否在Grafana中看到应用程序指标。我将假设你已经按照*准备就绪*部分中解释的那样启动了所有依赖服务：
- en: Open Grafana at `http://localhost:3000`, then open the SpringBoot APM Dashboard.
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`http://localhost:3000`打开Grafana，然后打开SpringBoot APM仪表板。
- en: Check that you can see data in the **Basic Statics** and **HikariCP** **Statics**
    sections.
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你可以在**基本静态**和**HikariCP静态**部分看到数据。
- en: Start the JMeter application and open the `football.jmx` file, which you can
    find in the `chapter7/jmeter` folder.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动JMeter应用程序并打开`football.jmx`文件，该文件位于`chapter7/jmeter`文件夹中。
- en: 'Execute the JMeter test and wait until it finishes. The test execution can
    take some minutes to complete:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行JMeter测试，等待其完成。测试执行可能需要几分钟才能完成：
- en: During the execution of the test, check the connection metrics in the **HikariCP
    Statistics** section in Grafana.
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试执行过程中，检查Grafana中**HikariCP统计**部分的连接指标。
- en: 'You will see that there are pending connections:'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会看到存在挂起的连接：
- en: '![Figure 7.1: Hikari connection metrics](img/B21646_07_1.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1：Hikari连接指标](img/B21646_07_1.jpg)'
- en: 'Figure 7.1: Hikari connection metrics'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：Hikari连接指标
- en: You can also see that the **Connection Acquire Time** value is over 4 ms all
    the time.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以看到**连接获取时间**值始终超过4毫秒。
- en: '![Figure 7.2: Connection Acquire Time](img/B21646_07_2.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2：连接获取时间](img/B21646_07_2.jpg)'
- en: 'Figure 7.2: Connection Acquire Time'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：连接获取时间
- en: You can see the results summary by opening the **Summary** **Report** item.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过打开**摘要** **报告**项来查看结果摘要。
- en: '![Figure 7.3: Summary Report](img/B21646_07_3.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3：摘要报告](img/B21646_07_3.jpg)'
- en: 'Figure 7.3: Summary Report'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：摘要报告
- en: You can also see them while the test runs, but the baseline will be taken once
    completed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在测试运行时查看它们，但基线将在完成后确定。
- en: '![Figure 7.4: Summary Report results – baseline results](img/B21646_07_4.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4：总结报告结果 – 基线结果](img/B21646_07_4.jpg)'
- en: 'Figure 7.4: Summary Report results – baseline results'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4：总结报告结果 – 基线结果
- en: In my environment, the total throughput is 987.5 **requests per second** (**RPS**),
    and the most used request is **get-user-player**, with a total of 145,142 requests
    and a throughput of 798 RPS. Note that the average time of the **get-user-player**
    operation is 6 milliseconds. Save the results of executing this test on your computer,
    as we’ll compare them after the optimizations.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的环境中，总吞吐量为 987.5 **每秒请求**（**RPS**），最常用的请求是 **get-user-player**，总共有 145,142
    个请求，吞吐量为 798 RPS。请注意，**get-user-player** 操作的平均时间为 6 毫秒。请将您电脑上执行此测试的结果保存下来，因为我们在优化后将会比较它们。
- en: Now, we’ll change the HikariCP settings by increasing the maximum number of
    database connections. For that, open the `application.yml` file in the `resources`
    folder and modify the `spring.datasource.hikari.maximum-pool-size` setting by
    increasing it to `10`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将通过增加数据库连接的最大数量来更改 HikariCP 设置。为此，打开 `resources` 文件夹中的 `application.yml`
    文件，并将 `spring.datasource.hikari.maximum-pool-size` 设置增加至 `10`。
- en: 'Let’s repeat the same performance test and see the difference. But before that,
    let’s do a clean-up of the data to execute the test in the same conditions:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '让我们重复相同的性能测试并看看差异。但在那之前，让我们清理数据以在相同的条件下执行测试：  '
- en: I prepared a script named `cleanup.sql` that you can run to clean up the database.
    You can find it in the `chapter7/dbscripts` folder.
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我准备了一个名为 `cleanup.sql` 的脚本，您可以通过运行它来清理数据库。您可以在 `chapter7/dbscripts` 文件夹中找到它。
- en: In JMeter, use the **Clear all** button to reset the results.
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 JMeter 中，使用 **清除所有** 按钮重置结果。
- en: 'Once the test is done, compare the results with the baseline. The results on
    my computer are the following:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试完成后，将结果与基线进行比较。我的电脑上的结果如下：
- en: The total throughput is 1,315 RPS. That is approximately a 33% performance increase
    compared to the baseline 987.5 RPS.
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总吞吐量为 1,315 RPS。这比基线 987.5 RPS 大约提高了 33% 的性能。
- en: The **get-user-player** request throughput is 1,085.3 RPS. That is approximately
    a 36% performance increase compared to the baseline 798 RPS.
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**get-user-player** 请求的吞吐量为 1,085.3 RPS。这比基线 798 RPS 大约提高了 36% 的性能。'
- en: The average response time of the **get-user-player** operation is 2 milliseconds.
    In the baseline, it was 6 milliseconds. That is three times faster.
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**get-user-player** 操作的平均响应时间为 2 毫秒。在基线中，它是 6 毫秒。这快了三倍。'
- en: If you look at **HikariCP Statistics** in Grafana, you will see that there are
    no connections pending and the connection-acquire time has reduced. The connection
    acquire time metric on my computer is always below 10 microseconds.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您在 Grafana 中查看 **HikariCP 统计信息**，您将看到没有挂起的连接，并且连接获取时间已经减少。我的电脑上的连接获取时间指标始终低于
    10 微秒。
- en: How it works…
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Spring Boot uses HikariCP as a JDBC data source connection pool. If you don’t
    specify any pool size, the default is 10\. I configured the initial example with
    a maximum of four connections for learning purposes. During the initial load test,
    we observed in Grafana that the number of pending connections remained consistently
    above zero throughout the entire testing period. That means that there is always
    a request that is waiting for an available database connection.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 使用 HikariCP 作为 JDBC 数据源连接池。如果您没有指定任何池大小，默认值为 10。为了学习目的，我在初始示例中将最大连接数配置为四个。在初始负载测试期间，我们在
    Grafana 中观察到挂起的连接数在整个测试期间始终保持在零以上。这意味着始终有一个请求正在等待可用的数据库连接。
- en: As we saw with the connection acquire time metric, on average, the time waited
    to acquire a connection is 4 milliseconds. That means that for every request,
    we need to add 4 milliseconds for each database operation involved. For fast operations,
    such as **get-user-player**, that is two times the time required when there’s
    a connection available. Once we increased the size of the connection pool, this
    operation boosted its performance, and it was the most used operation in this
    scenario.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在连接获取时间指标中看到的那样，平均来说，获取连接所需的时间为 4 毫秒。这意味着对于每个请求，我们需要为每个涉及的数据库操作添加 4 毫秒。对于像
    **get-user-player** 这样的快速操作，在没有连接可用时，所需时间是两倍。一旦我们增加了连接池的大小，这个操作就提高了其性能，并且在这个场景中是最常用的操作。
- en: The rest of the operations also benefited from this new configuration, but as
    the request time with available connections is longer, the relative performance
    improvement is not that high.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的操作也受益于这种新的配置，但由于可用连接的请求时间较长，相对性能提升并不高。
- en: In this recipe, we focused on the number of database connections. But the same
    approach can be applied to other types of application metrics, for instance, the
    number of Tomcat concurrent threads. You can use the observability data exposed
    by the application and tune your settings accordingly to adjust to your workload.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们专注于数据库连接的数量。但同样的方法可以应用于其他类型的应用程序指标，例如Tomcat并发线程的数量。您可以使用应用程序暴露的可观察性数据，并相应地调整您的设置以适应您的负载。
- en: There’s more…
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this recipe, we fixed the connection availability by adding the maximum number
    of connections used simultaneously at a given moment, that is, 10 connections.
    As mentioned, database connections are an expensive resource that should be used
    wisely. Let’s consider a scenario with multiple instances of your service. Every
    additional connection for your application should be multiplied by the number
    of instances. Say you have 10 application instances; then, any additional connection
    should be multiplied by 10.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们通过增加在某一时刻同时使用的最大连接数来固定连接可用性，即10个连接。正如所述，数据库连接是一种昂贵的资源，应该明智地使用。让我们考虑一个具有多个服务实例的场景。为您的应用程序提供的每个额外连接都应该乘以实例的数量。比如说，您有10个应用程序实例；那么，任何额外的连接都应该乘以10。
- en: During the execution of the baseline test, we detected a maximum of six pending
    connections, so we added those six connections to the four initial connections.
    If the maximum number of pending connections happens only during a few spikes,
    we can adjust the number of maximum connections to 1 or 2 fewer connections than
    the maximum detected. For instance, in our scenario, we could adjust the number
    of maximum connections to 9, repeat the load test, and observe the impact.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在基准测试执行期间，我们检测到最多有六个挂起的连接，因此我们将这六个连接添加到最初的四个连接中。如果最大挂起连接数仅在少数几个峰值期间发生，我们可以将最大连接数调整为比检测到的最大值少1或2个连接。例如，在我们的场景中，我们可以将最大连接数调整为9，重复负载测试，并观察其影响。
- en: Another potential adjustment is configuring the minimum and maximum number of
    connections. Then, if there is a spike and no available connections, HikariCP
    will create a connection to the database. Remember the time required to create
    the connection to the database and the time this connection will be idle. When
    the minimum and maximum connections are defined, HikariCP can close physical connections
    when idle. If the spike is too short, you may create a connection that will take
    longer than just waiting for an available connection, and then you will have an
    idle connection consuming resources in the database server.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个潜在的调整是配置最小和最大连接数。然后，如果有峰值且没有可用连接，HikariCP将创建一个数据库连接。记住创建数据库连接所需的时间和这个连接将空闲的时间。当定义了最小和最大连接数时，HikariCP可以在空闲时关闭物理连接。如果峰值太短，您可能会创建一个连接，其创建时间将比等待可用连接更长，然后您将有一个空闲连接在数据库服务器上消耗资源。
- en: Caching dependencies
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存依赖
- en: 'The most common flow in the Football Trading application that we want to optimize
    is the following: sometimes, the users buy some cards, and after using them in
    their albums, they try to exchange the redundant cards they already have with
    other users. Before starting the exchange process, the users see which players
    are available from other users. There can be thousands and even millions of cards,
    but the total number of football players is around 700, and they are constantly
    retrieved from the Football Trading application.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要优化的足球交易应用中最常见的流程如下：有时，用户购买一些卡片，并在他们的专辑中使用后，试图与其他用户交换他们已经拥有的冗余卡片。在开始交换过程之前，用户会查看其他用户可用的球员。可能会有数千甚至数百万张卡片，但足球运动员的总数大约为700，他们不断从足球交易应用中检索。
- en: Now, you want to optimize the application’s performance. So, you are considering
    using a cache mechanism to avoid retrieving data from the database that is accessed
    frequently but changes very infrequently.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您想要优化应用程序的性能。因此，您正在考虑使用缓存机制来避免从数据库检索频繁访问但很少更改的数据。
- en: In this recipe, you will learn how to identify a database bottleneck and how
    to apply the caching mechanisms provided by Spring Boot. You will learn how to
    measure the improvement using the observability tools you learned about in [*Chapter
    3*](B21646_03.xhtml#_idTextAnchor103).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您将学习如何识别数据库瓶颈以及如何应用Spring Boot提供的缓存机制。您将学习如何使用您在[*第3章*](B21646_03.xhtml#_idTextAnchor103)中了解到的可观察性工具来衡量改进。
- en: Getting ready
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, you will continue optimizing the application that I prepared
    for this purpose. You can use the version resulting from the *Tuning the database
    connection pool* recipe. You can find the application in the book’s GitHub repository
    at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/),
    in the `chapter7/recipe7-2/start` folder.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您将继续优化我为这个目的准备的应用程序。您可以使用来自*调整数据库连接池*配方版本的版本。您可以在本书的GitHub存储库中找到该应用程序，在[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/)的`chapter7/recipe7-2/start`文件夹中。
- en: 'As we explained in the previous recipe, you can run all dependent services
    in Docker by running the `docker-compose-base.yml` Docker Compose file that you
    can find in the `chapter7/docker` folder. For that, open a terminal and execute
    the following command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在前面的配方中解释的那样，您可以通过运行位于`chapter7/docker`文件夹中的`docker-compose-base.yml` Docker
    Compose文件来在Docker中运行所有依赖服务。为此，打开一个终端并执行以下命令：
- en: '[PRE1]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We’ll use the same JMeter test we used in the previous recipe. You can find
    it in `chapter7/jmeter/football.jmx`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前配方中使用的相同的JMeter测试。您可以在`chapter7/jmeter/football.jmx`中找到它。
- en: How to do it…
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let’s start by executing the JMeter load test to determine the performance
    baseline. Then, we’ll apply caching on different parts of the application, and
    we’ll measure the improvements:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从执行JMeter负载测试以确定性能基线开始。然后，我们将对应用程序的不同部分应用缓存，并测量改进：
- en: We can use the results of the JMeter execution from the *Tuning database connection
    pool* recipe test.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用来自*调整数据库连接池*配方测试的JMeter执行结果。
- en: '![Figure 7.5: JMeter summary report – baseline requests throughput detail](img/B21646_07_5.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5：JMeter总结报告 – 基线请求吞吐量详情](img/B21646_07_5.jpg)'
- en: 'Figure 7.5: JMeter summary report – baseline requests throughput detail'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：JMeter总结报告 – 基线请求吞吐量详情
- en: In my environment, the total throughput is 1,340.3 RPS, and the most used request
    is **get-user-player**, with a total of 145,683 requests and a throughput of 1,085.3
    RPS. Save the results of executing this test on your computer, as we’ll compare
    them after the optimizations.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的环境中，总吞吐量为1,340.3 RPS，最常用的请求是**get-user-player**，总共有145,683个请求，吞吐量为1,085.3
    RPS。请将执行此测试的结果保存在您的计算机上，因为我们在优化后将会比较它们。
- en: 'Now that we have our application baseline, we’ll enable caching:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了应用程序基线，我们将启用缓存：
- en: 'First, add the *Spring Cache Abstraction* starter to the `pom.xml` file:'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将*Spring Cache Abstraction*启动器添加到`pom.xml`文件中：
- en: '[PRE2]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, in the `FootballApplication` class, add the `@``EnableCaching` annotation:'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`FootballApplication`类中，添加`@EnableCaching`注解：
- en: '[PRE3]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we’ll modify the `getPlayer` method of the `FootballService` class to
    cache the responses. This is the method called in the `@Cacheable` as follows:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将修改`FootballService`类的`getPlayer`方法以缓存响应。这是在`@Cacheable`中调用的方法如下：
- en: '[PRE4]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s execute the JMeter test again. But before that, let’s do a cleanup of
    the data to execute the test in the same conditions:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次执行JMeter测试。但在那之前，让我们清理数据以在相同条件下执行测试：
- en: I prepared a script named `cleanup.sql` that you can run to clean up the database.
    You can find it in the `chapter7/dbscripts` folder.
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我准备了一个名为`cleanup.sql`的脚本，您可以通过运行它来清理数据库。您可以在`chapter7/dbscripts`文件夹中找到它。
- en: In JMeter, use the **Clear all** button to reset the results.
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JMeter中，使用**清除所有**按钮重置结果。
- en: 'Once the test is done, check the results and compare them with the baseline.
    The results on my computer are the following:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦测试完成，检查结果并与基线进行比较。我的计算机上的结果如下：
- en: '![Figure 7.6: Summary report after applying caching on the FootballService](img/B21646_07_6.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6：在FootballService上应用缓存后的总结报告](img/B21646_07_6.jpg)'
- en: 'Figure 7.6: Summary report after applying caching on the FootballService'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：在FootballService上应用缓存后的总结报告
- en: The total throughput jumped to 1,806.7 RPS from 1,340.3 RPS, approximately a
    34% performance increase.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总吞吐量从1,340.3 RPS跃升至1,806.7 RPS，大约提高了34%的性能。
- en: '**get-user-player** requests are 1,458.5 RPS, and the baseline was 1,085.3
    RPS, which means around a 34% performance increase as well.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**get-user-player** 请求为 1,458.5 RPS，基线为 1,085.3 RPS，这意味着性能也提高了大约 34%。'
- en: The rest of the requests also increased by around 34% of the overall throughput.
    For instance, **get-user-cards** rose to 100.1 RPS from 74.5 RPS, and the other
    requests went from 37.2 RPS to 50.1 RPS.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其余的请求也增加了大约 34% 的整体吞吐量。例如，**get-user-cards** 从 74.5 RPS 上升到 100.1 RPS，其他请求从
    37.2 RPS 上升到 50.1 RPS。
- en: 'Let’s use the caching in a different place in our application. Instead of applying
    the `@Cacheable` annotation in `FootballService`, apply the annotation in the
    `PlayersController` class in the `getPlayer` method:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在应用程序的不同位置使用缓存。不是在 `FootballService` 中应用 `@Cacheable` 注解，而是在 `PlayersController`
    类的 `getPlayer` 方法中应用注解：
- en: '[PRE5]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works…
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: By adding the *Spring Cache Abstraction* starter and using the `@EnableCaching`
    annotation, Spring Boot inspects the Beans for the presence of caching annotations
    on public methods, and a proxy is created to intercept the method call and handle
    the caching behavior accordingly; in our case, the methods annotated with `@Cacheable`.
    Spring Boot registers a `CacheManager` Bean to handle the cached items, as we
    didn’t specify any specific `CacheManager`. Spring Boot uses the default implementation,
    a `ConcurrentHashMap` object, and it’s handled in the process. This approach is
    valid for elements that do not change and where the dataset is small. Otherwise,
    you may want to use an external shared cache. In the next recipe, we’ll tackle
    this scenario.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加 *Spring Cache Abstraction* 启动器并使用 `@EnableCaching` 注解，Spring Boot 会检查 Beans
    中公共方法上是否存在缓存注解，并创建一个代理来拦截方法调用并相应地处理缓存行为；在我们的例子中，是带有 `@Cacheable` 注解的方法。Spring
    Boot 注册了一个 `CacheManager` Bean 来处理缓存项，因为我们没有指定任何特定的 `CacheManager`。Spring Boot
    使用默认实现，一个 `ConcurrentHashMap` 对象，并在处理过程中进行管理。这种方法适用于不经常变化且数据集较小的元素。否则，你可能想使用外部共享缓存。在下一个菜谱中，我们将处理这种情况。
- en: In this recipe, we optimized only `get-user-player`. It’s the best candidate
    for all operations performed in this recipe. The reason is that the operations
    that modify data frequently are not candidates for caching, so `buy-cards`, `use-cards`,
    and `trade-cards` cannot be cached as they modify the data and are frequently
    used. The only operations that read just data are `get-user-cards` and `get-user-player`.
    `get-user-cards` is not a good candidate as the cards available owned by a user
    change every time they buy cards, exchange cards, or use them in an album. That
    means that the cache will be updated frequently. In addition, the number of users
    is high, around 100,000, so adding all those elements to the application memory
    can be counterproductive. On the other hand, `get-user-player` just retrieves
    the player’s information. That information changes very infrequently, and there
    are just a few hundred players. For that reason, `get-user-player` is the best
    candidate for caching.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们只优化了 `get-user-player`。它是这个菜谱中所有操作的最佳候选者。原因是修改数据频率较高的操作不适合缓存，所以 `buy-cards`、`use-cards`
    和 `trade-cards` 不能被缓存，因为它们修改数据并且经常被使用。唯一只读取数据的操作是 `get-user-cards` 和 `get-user-player`。`get-user-cards`
    不是一个好的候选者，因为用户拥有的卡片每次购买、交换或用于专辑时都会改变，这意味着缓存将频繁更新。此外，用户数量很高，大约有 100,000，所以将这些元素添加到应用程序内存中可能是适得其反的。另一方面，`get-user-player`
    只检索球员信息。这些信息变化非常不频繁，而且只有几百名球员。因此，`get-user-player` 是缓存的最佳候选者。
- en: By adding the cache in the `FootballService` class, the throughput of that operation
    improved significantly, but it also benefited the rest of the operations. The
    reason is that even though it is a quick request on the database, it is the most
    frequent operation. The number of database connections available is defined by
    the `hikaricp` connection pool; we configured 10 connections. All operations should
    acquire a connection from `hikaricp`. As the most frequent operation is reduced,
    it’s easier for the rest of the operations to acquire a connection faster.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `FootballService` 类中添加缓存，该操作的吞吐量显著提高，但它也使其他操作受益。原因是尽管这是一个快速的数据库请求，但它是最频繁的操作。可用的数据库连接数由
    `hikaricp` 连接池定义；我们配置了 10 个连接。所有操作都应该从 `hikaricp` 获取连接。由于最频繁的操作减少了，其他操作获取连接的速度更快。
- en: There’s more…
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'I recommend you check the metrics exposed by the application in Grafana while
    you run the tests. There are two main areas to observe in this scenario:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你在运行测试时检查应用在 Grafana 中暴露的指标。在这个场景中，有两个主要区域需要观察：
- en: '**Basic statistics**: Here we can find the classic metrics for every application:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本统计**：在这里，我们可以找到每个应用的经典指标：'
- en: '**CPU Usage**: This is often the limiting factor for demanding computing applications.
    During the tests on my computer, it was always under 70%.'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU 使用率**：这通常是要求高的计算应用的限制因素。在我的电脑上的测试中，它始终低于 70%。'
- en: '**Heap Used**: This is the heap memory used by our application. It could limit
    the performance of our application.'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆内存使用**：这是我们的应用使用的堆内存。它可能会限制我们应用的性能。'
- en: '**Non-heap Used**: This is all other memory used by our application. It usually
    accounts for less than 30% of the total memory used by the application, and its
    usage remains more stable than heap memory.'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非堆内存使用**：这是我们的应用使用的所有其他内存。它通常占应用总内存使用的不到 30%，并且其使用比堆内存更稳定。'
- en: '**HikariCP** **S****tatistics**: As we saw in the previous recipe, HikariCP
    is the default database connection pool in Spring Boot. Creating a database connection
    to PostgreSQL or any other database engine is expensive. You can check the following
    metrics related to HikariCP:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HikariCP 统计**：正如我们在前面的菜谱中所见，HikariCP 是 Spring Boot 中的默认数据库连接池。创建到 PostgreSQL
    或任何其他数据库引擎的连接都是昂贵的。你可以检查以下与 HikariCP 相关的指标：'
- en: '**Active**: This is the number of connections out of the pool actively used
    to perform an operation in the database.'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**活跃**：这是池外用于在数据库中执行操作的连接数量。'
- en: '**Idle**: This is the number of available connections in the pool ready to
    be used when needed.'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**闲置**：这是池中可供使用以备不时之需的可用连接数量。'
- en: '**Pending**: This is the number of operations waiting for an available connection
    to access the database. Ideally, this metric should be 0.'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**挂起**：这是等待可用连接以访问数据库的操作数量。理想情况下，这个指标应该是 0。'
- en: '**Connection creation time**: This is the time spent creating the physical
    connection to the database.'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接创建时间**：这是创建到数据库的物理连接所花费的时间。'
- en: '**Connection usage time**: This is how long a connection is used before being
    returned to the pool.'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接使用时间**：这是连接被返回到池中之前的使用时长。'
- en: '**Connection acquire time**: This is the time required to get a connection.
    When there are idle connections, the time required will be very low. When there
    are pending connections, the time required will be higher.'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接获取时间**：这是获取连接所需的时间。当有闲置连接时，所需时间会非常低。当有挂起的连接时，所需时间会更高。'
- en: '![Figure 7.7: HikariCP metrics in Grafana](img/B21646_07_7.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7：Grafana 中的 HikariCP 指标](img/B21646_07_7.jpg)'
- en: 'Figure 7.7: HikariCP metrics in Grafana'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7：Grafana 中的 HikariCP 指标
- en: You may want to cache operations, as we did in this recipe, to reduce the number
    of connections to the database.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要缓存操作，就像我们在本菜谱中所做的那样，以减少对数据库的连接次数。
- en: In the next recipe, we’ll learn how to use Redis as an external cache and how
    to update it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个菜谱中，我们将学习如何使用 Redis 作为外部缓存以及如何更新它。
- en: Using shared cache
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用共享缓存
- en: The sample Football Trading application needs to cover a new scenario. Some
    football players can play in different positions, sometimes as defenders and sometimes
    as midfielders. Players do not change their position frequently, but it may happen.
    As we learned in the previous recipe, caching the players can improve the application’s
    performance significantly. We assume it’s possible and recommended to have more
    than one application instance running simultaneously. When a player is updated,
    all the application instances should return the latest version of the player.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 样本足球交易应用需要覆盖一个新的场景。一些足球运动员可以胜任不同的位置，有时是后卫，有时是中场。球员不会频繁更换位置，但这种情况可能发生。正如我们在前面的菜谱中学到的，缓存球员可以显著提高应用性能。我们假设同时运行多个应用实例是可能的，也是推荐的。当一个球员被更新时，所有应用实例都应该返回球员的最新版本。
- en: In this recipe, we’ll learn how to use an external cache shared among all application
    instances and how to update the cache when the underlying data is modified.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用所有应用实例共享的外部缓存，以及当底层数据被修改时如何更新缓存。
- en: Getting ready
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we’ll reuse the application resulting from the previous recipe,
    as it has already been configured for caching. I have prepared a working version
    in the GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
    It is in the `chapter7/recipe7-3/start` folder.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将重用前一个菜谱生成的应用程序，因为它已经配置好了缓存。我在GitHub仓库中准备了一个工作版本，网址为[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/)。它位于`chapter7/recipe7-3/start`文件夹中。
- en: The application uses PostgreSQL as a database engine, configured for observability
    with Zipkin, Prometheus, and Grafana.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序使用PostgreSQL作为数据库引擎，配置了Zipkin、Prometheus和Grafana以进行可观察性。
- en: As we’ll add support for caching using Redis, we’ll need a Redis server. The
    easiest way to run Redis on your computer is using Docker.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将添加对Redis的缓存支持，我们需要一个Redis服务器。在您的计算机上运行Redis的最简单方法是使用Docker。
- en: 'I prepared a Docker Compose file named `docker-compose-redis.yml`, with all
    dependent services, that is, PostgreSQL, Zipkin, Prometheus, Grafana, and Redis.
    You can find that file in the `chapter7/docker` folder. To run all dependent services,
    open a terminal in the `chapter7/docker` folder and run the following command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我准备了一个名为`docker-compose-redis.yml`的Docker Compose文件，其中包含所有依赖服务，即PostgreSQL、Zipkin、Prometheus、Grafana和Redis。你可以在`chapter7/docker`文件夹中找到该文件。要运行所有依赖服务，请在`chapter7/docker`文件夹中打开一个终端并运行以下命令：
- en: '[PRE6]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: I prepared a JMeter test to generate load for this recipe. You can find it in
    `chapter7/jmeter/Football-updates.jmx`. In addition to the flow implemented in
    the previous recipe, it updates the position of a football player from time to
    time.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我为这个菜谱准备了一个JMeter测试来生成负载。你可以在`chapter7/jmeter/Football-updates.jmx`中找到它。除了前一个菜谱中实现的流程外，它还会不时更新足球运动员的位置。
- en: How to do it…
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We’ll start by preparing the application to use Redis, and later, we’ll ensure
    that the cache is updated when the players are modified:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先准备应用程序以使用Redis，然后确保当球员被修改时缓存会更新：
- en: 'First, we’ll add the *Spring Data Redis* starter dependency. For that, just
    add the following dependency in the `pom.xml` file:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将添加`Spring Data Redis`启动器依赖项。为此，只需在`pom.xml`文件中添加以下依赖项：
- en: '[PRE7]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You will need to add the following dependency to manage `LocalDate` fields:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要添加以下依赖来管理`LocalDate`字段：
- en: '[PRE8]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we need to configure Redis. For that, we will register a `RedisCacheConfiguration`
    Bean. Let’s create a new configuration class; you can name it `RedisConfig`:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要配置Redis。为此，我们将注册一个`RedisCacheConfiguration` Bean。让我们创建一个新的配置类；你可以命名为`RedisConfig`：
- en: '[PRE9]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, you must ensure that the cache is updated when the underlying data
    is updated. Let’s modify the `updatePlayerPosition` method in the `FootballService`
    class by adding the `@``CacheEvict` annotation:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你必须确保当底层数据更新时，缓存也会更新。让我们通过在`FootballService`类中添加`@CacheEvict`注解来修改`updatePlayerPosition`方法：
- en: '[PRE10]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, you can run the JMeter test to validate the application and measure the
    performance footprint. I prepared a test named `Football-updates.jmx` for that
    purpose. You can find it in the `chapter7/jmeter` folder. This test updates the
    player’s position randomly but very infrequently, then retrieves the player to
    validate that it has the position updated.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以运行JMeter测试来验证应用程序并测量性能影响。为此，我准备了一个名为`Football-updates.jmx`的测试。你可以在`chapter7/jmeter`文件夹中找到它。这个测试会随机但非常不频繁地更新球员的位置，然后检索球员以验证其位置是否已更新。
- en: '![Figure 7.8: JMeter test, showing the details of the player update](img/B21646_07_8.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图7.8：JMeter测试，显示球员更新的详细信息](img/B21646_07_8.jpg)'
- en: 'Figure 7.8: JMeter test, showing the details of the player update'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8：JMeter测试，显示球员更新的详细信息
- en: On my computer, the total throughput is 1,497.5 RPS, and `get-user-players`
    is 1,210.6 RPS. The performance of Redis caching is slightly lower than in-process
    caching. However, externalizing the cache makes it possible to scale horizontally
    by adding additional instances.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的计算机上，总吞吐量为1,497.5 RPS，`get-user-players`为1,210.6 RPS。Redis缓存的性能略低于进程内缓存。然而，将缓存外部化使得可以通过添加更多实例来实现水平扩展。
- en: How it works…
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When adding an external caching implementation, the application needs to serialize
    the objects to be cached to send them over the network and save them in Redis.
    The default Redis configuration can manage basic types such as `String` or `int`
    with no additional configuration. However, in this sample application, we need
    to cache `Player` objects. To use the default configuration, the `Player` class
    should implement the `Serializable` interface.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当添加外部缓存实现时，应用程序需要将需要缓存的对象序列化以通过网络发送并将它们保存到Redis中。默认的Redis配置可以管理基本类型，如`String`或`int`，无需额外配置。然而，在这个示例应用程序中，我们需要缓存`Player`对象。为了使用默认配置，`Player`类应该实现`Serializable`接口。
- en: To avoid modifying our domain classes, we configured a `Jackson2JsonRedisSerializer`
    serializer. This serializer represents the objects as JSON strings. The player
    has a catch with the `birthDate` field, as it is of the `LocalDate` type and cannot
    be managed with the default implementation. That is the reason we added the `com.fasterxml.jackson.datatype:jackson-datatype-jsr310`
    dependency and registered `JavaTimeModule` in `ObjectMapper` for `RedisCacheConfiguration`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免修改我们的领域类，我们配置了一个`Jackson2JsonRedisSerializer`序列化器。这个序列化器将对象表示为JSON字符串。玩家有一个关于`birthDate`字段的限制，因为它属于`LocalDate`类型，无法使用默认实现来管理。这就是我们添加`com.fasterxml.jackson.datatype:jackson-datatype-jsr310`依赖并在`ObjectMapper`中注册`JavaTimeModule`以用于`RedisCacheConfiguration`的原因。
- en: 'It’s important to consider the implications of using an external cache repository:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑使用外部缓存存储库的影响很重要：
- en: As we just learned, we must ensure the cached objects can be serialized.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们刚刚学习的，我们必须确保缓存的对象可以被序列化。
- en: You need to consider the network latency as well. I executed all load tests
    locally on my computer, so there was no network latency. In real environments,
    it can also impact the performance of the application.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还需要考虑网络延迟。我在我的电脑上本地执行了所有负载测试，所以没有网络延迟。在实际环境中，它也可能影响应用程序的性能。
- en: The caching server may become the new bottleneck. Redis is very performant,
    but it may imply adding new resources to your solution, such as new servers.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存服务器可能成为新的瓶颈。Redis非常高效，但它可能意味着需要向你的解决方案添加新资源，例如新服务器。
- en: I didn’t notice significant performance differences in my load test results
    because everything ran on the same computer; however, you may expect slight differences
    in a production environment with services distributed across different servers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的负载测试结果中，我没有注意到显著的性能差异，因为所有操作都在同一台电脑上运行；然而，你可能在具有跨不同服务器分布的服务器的生产环境中期望有轻微的差异。
- en: You must configure the server address if you run Redis on a different server.
    By default, the *Spring Data Redis* starter assumes that Redis runs on `localhost`
    and listens to port `6379`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将Redis运行在不同的服务器上，你必须配置服务器地址。默认情况下，*Spring Data Redis*启动器假定Redis运行在`localhost`并监听端口`6379`。
- en: 'In this recipe, we used the `@CacheEvict` annotation to update the cache. This
    annotation deletes the entry using a key. By default, this annotation uses all
    method parameters as the cache entry key. However, the `updatePlayerPosition`
    method has two parameters: the player `id` and the new `position`. As the key
    is just the player `id`, we specified that in the `position` field of the `@CacheEvict`
    annotation. Other options, such as clearing all entries, don’t apply to our scenario.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用了`@CacheEvict`注解来更新缓存。这个注解通过键来删除条目。默认情况下，这个注解使用所有方法参数作为缓存条目的键。然而，`updatePlayerPosition`方法有两个参数：玩家的`id`和新的`position`。因为键只是玩家的`id`，所以我们指定了`@CacheEvict`注解的`position`字段中。其他选项，如清除所有条目，不适用于我们的场景。
- en: Using Testcontainers with Redis cache
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用带有Redis缓存的Testcontainers
- en: If you have executed the automated tests available in the sample project in
    the previous recipe, you may have noticed that the tests using methods that require
    Redis are failing. The reason is that Redis is not available during the execution
    of the tests.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在前一个菜谱中执行了示例项目中可用的自动化测试，你可能已经注意到使用需要Redis的方法的测试失败。原因是测试执行期间Redis不可用。
- en: In this recipe, we’ll learn how to set up a Redis server hosted as a Docker
    container using Testcontainers.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用Testcontainers设置作为Docker容器托管的Redis服务器。
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we’ll create the tests for the project created in the *Using
    shared cache* recipe. If you haven’t completed it yet, use the version I prepared
    as a starting point for this recipe. You can find it in the book’s GitHub repository
    at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in the `chapter7/recipe7-4/start` folder.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将为在*使用共享缓存*菜谱中创建的项目创建测试。如果你还没有完成，请使用我为这个菜谱准备的版本作为起点。你可以在书的GitHub仓库[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook)中的`chapter7/recipe7-4/start`文件夹中找到它。
- en: As we use Testcontainers, you will need Docker installed on your computer.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们使用Testcontainers，你需要在电脑上安装Docker。
- en: How to do it…
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: We like reliable applications. Let’s make our tests work!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们喜欢可靠的应用程序。让我们让我们的测试工作起来！
- en: 'We’ll make all changes in the `FootballServiceTest` class. So, open it and
    add a new static field of type `GenericContainer`. We’ll expose the default Redis
    port at `6379`, and we’ll use the latest `redis` image:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在`FootballServiceTest`类中做出所有更改。所以，打开它并添加一个新的静态字段，类型为`GenericContainer`。我们将暴露默认的Redis端口`6379`，并使用最新的`redis`镜像：
- en: '[PRE11]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: static class Initializer
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: static class Initializer
- en: implements ApplicationContextInitializer<ConfigurableApplicationContext> {
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: implements ApplicationContextInitializer<ConfigurableApplicationContext> {
- en: public void initialize(ConfigurableApplicationContext configurableApplicationContext)
    {
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public void initialize(ConfigurableApplicationContext configurableApplicationContext)
    {
- en: TestPropertyValues.of(
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: TestPropertyValues.of(
- en: '"spring.datasource.url=" + postgreSQLContainer.getJdbcUrl(),'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"spring.datasource.url=" + postgreSQLContainer.getJdbcUrl(),'
- en: '"spring.datasource.username=" + postgreSQLContainer.getUsername(),'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"spring.datasource.username=" + postgreSQLContainer.getUsername(),'
- en: '"spring.datasource.password=" + postgreSQLContainer.getPassword(),'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"spring.datasource.password=" + postgreSQLContainer.getPassword(),'
- en: '"spring.data.redis.host=" + redisContainer.getHost(),'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"spring.data.redis.host=" + redisContainer.getHost(),'
- en: '"spring.data.redis.port=" + redisContainer.getMappedPort(6379))'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"spring.data.redis.port=" + redisContainer.getMappedPort(6379))'
- en: .applyTo(configurableApplicationContext.getEnvironment());
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .applyTo(configurableApplicationContext.getEnvironment());
- en: '}'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE12]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, start the container before executing the tests:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在执行测试之前启动容器：
- en: '[PRE13]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can run the tests now. They should work fine!
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以运行测试了。它们应该能正常工作！
- en: How it works…
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: To integrate Redis into our tests, we only need an available Redis server. There
    is a specialized Redis module in Testcontainers. You can find it at [https://testcontainers.com/modules/redis/](https://testcontainers.com/modules/redis/).
    As the integration is pretty simple, we can use just `GenericContainer` instead
    of the specialized `RedisContainer`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将Redis集成到我们的测试中，我们只需要一个可用的Redis服务器。Testcontainers中有一个专门的Redis模块。你可以在[https://testcontainers.com/modules/redis/](https://testcontainers.com/modules/redis/)找到它。由于集成相当简单，我们可以使用`GenericContainer`而不是专门的`RedisContainer`。
- en: 'As we learned in previous recipes, by adding the `@Testcontainers` annotation
    in our test class, it automatically scans all container fields and integrates
    them into the test. `FootballServiceTest` was already annotated with `@Testcontainers`
    as it integrated PostgreSQL. We only needed to add a new container, in this case
    just `GenericContainer`, and perform the basic configuration to set it up. That
    is as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在之前的菜谱中学习到的，通过在我们的测试类中添加`@Testcontainers`注解，它将自动扫描所有容器字段并将它们集成到测试中。`FootballServiceTest`已经通过集成PostgreSQL而注解了`@Testcontainers`。我们只需要添加一个新的容器，在这种情况下就是`GenericContainer`，并执行基本的配置来设置它。具体如下：
- en: 'Configure the container with the minimum configuration: image and exposed port.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用最少的配置：镜像和暴露的端口来配置容器。
- en: Set the Redis configuration connection data in the application context. We did
    this in the `FootballServiceTest.Initializer` class. The Redis starter expects
    the configuration under `spring.data.redis`. We added the host and port, but only
    the port is required. By default, it expects the host on `localhost`.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序上下文中设置Redis配置连接数据。我们在`FootballServiceTest.Initializer`类中做了这件事。Redis启动器期望在`spring.data.redis`下配置。我们添加了主机和端口，但只需要端口。默认情况下，它期望主机在`localhost`。
- en: Start the container before the test execution. We did it in the method annotated
    with `@BeforeAll`.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试执行之前启动容器。我们在带有`@BeforeAll`注解的方法中做了这件事。
- en: Creating a native image using Spring Boot
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Boot创建原生镜像
- en: Usually, when we design solutions using a microservice-oriented approach, we
    imagine that we can easily scale our applications by adding and removing new instances
    of our application, and we also imagine that this process happens immediately.
    However, starting new instances of our application can take longer than we initially
    expected. Spring Boot orchestrates Bean initialization, dependency injection,
    and event handling during application startup, and most of these steps happen
    dynamically. This is not a major issue for small applications, but for complex
    applications, this process can take up to minutes to complete.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们使用面向微服务的方法设计解决方案时，我们想象我们可以通过添加和删除我们应用程序的新实例来轻松扩展我们的应用程序，我们也想象这个过程是立即发生的。然而，启动我们应用程序的新实例可能需要比我们最初预期的更长的时间。Spring
    Boot 在应用程序启动期间协调 Bean 初始化、依赖注入和事件处理，并且这些步骤中的大多数都是动态发生的。这对小型应用程序来说不是一个大问题，但对于复杂的应用程序，这个过程可能需要几分钟才能完成。
- en: Another important factor when designing applications is the efficient use of
    computing resources. We want the applications to consume as little memory as possible
    and process the workload efficiently.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计应用程序时，另一个重要因素是高效使用计算资源。我们希望应用程序尽可能少地消耗内存并高效处理工作负载。
- en: For this kind of scenario, we can consider creating native applications, that
    is, applications that are built as final binaries for a specific processor family
    and operating system. A normal Java application generates intermediate code that
    is processed by the **Java Virtual Machine** (**JVM**) and converted into binary
    code during the application runtime. In a native application, this process happens
    during build time.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种场景，我们可以考虑创建原生应用程序，即作为特定处理器家族和操作系统的最终二进制文件构建的应用程序。一个普通的 Java 应用程序生成中间代码，该代码在应用程序运行时由
    **Java 虚拟机** (**JVM**) 处理并转换为二进制代码。在原生应用程序中，这个过程发生在构建时。
- en: In this recipe, we’ll learn how to create a new Spring Boot native application.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何创建一个新的 Spring Boot 原生应用程序。
- en: Getting ready
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we’ll need Docker. You can check the *Technical requirements*
    section of this chapter for more information.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们需要 Docker。你可以查看本章的 *技术要求* 部分以获取更多信息。
- en: How to do it…
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: Let’s create a native application using Spring Boot!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Spring Boot 创建一个原生应用程序！
- en: 'Open the *Spring Boot Initializr* tool at [https://start.spring.io](https://start.spring.io)
    and use the same options as you did in the *Create a RESTful API* recipe in [*Chapter
    1*](B21646_01.xhtml#_idTextAnchor020), and use the same parameters, except the
    following options:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 *Spring Boot Initializr* 工具，访问 [https://start.spring.io](https://start.spring.io)，并使用与你在
    [*第 1 章*](B21646_01.xhtml#_idTextAnchor020) 中 *创建一个 RESTful API* 菜单中使用的相同选项，并使用相同的参数，除了以下选项：
- en: For `footballnative`
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `footballnative`
- en: For **Dependencies**, select **Spring Web** and **GraalVM** **Native Support**
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 **依赖项**，选择 **Spring Web** 和 **GraalVM** **原生支持**
- en: 'Next, create a sample RESTful controller; for instance, create a `TeamController`
    controller and a method that returns a list of teams:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个示例 RESTful 控制器；例如，创建一个 `TeamController` 控制器和一个返回团队列表的方法：
- en: '[PRE14]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can run the application on the JVM as usual, but what we’ll do now is create
    a native Docker image. For that, open your terminal and execute the following
    Maven command:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以像往常一样在 JVM 上运行应用程序，但我们现在要创建一个原生 Docker 镜像。为此，打开你的终端并执行以下 Maven 命令：
- en: '[PRE15]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Be patient, as this step can take up to a few minutes to complete depending
    on the resources of your computer.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请耐心等待，因为这个步骤可能需要几分钟才能完成，具体取决于你电脑的资源。
- en: 'Once the build completes, you can run the Docker image with our native application
    by executing the following command in your terminal:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建完成后，你可以在终端中执行以下命令来运行我们的原生应用程序的 Docker 镜像：
- en: '[PRE16]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, you can perform a request to the RESTful application normally; for instance,
    you can use the following `curl` command:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以像通常一样对 RESTful 应用程序进行请求；例如，你可以使用以下 `curl` 命令：
- en: '[PRE17]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works…
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The GraalVM Native Support dependency adds a new `native` profile that can be
    used with the standard Spring Boot `build-image` goal to generate an image that
    targets **GraalVM**. GraalVM is a Java runtime that can compile your applications
    **Ahead of Time** (**AOT**) into native executables with low resource usage, fast
    startup, and improved security. To create the native image, the Maven plugin builds
    the native GraalVM executable in a Docker container using **Paketo Buildpacks**.
    Paketo Buildpacks are a set of community-driven tools that simplify the process
    of building and deploying applications as container images. That is the reason
    you don’t need to download GraalVM tools on your computer.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM 本地支持依赖添加了一个新的 `native` 配置文件，可以与标准的 Spring Boot `build-image` 目标一起使用，以生成针对
    **GraalVM** 的镜像。GraalVM 是一个 Java 运行时环境，可以将您的应用程序 **即时编译**（**AOT**）成原生可执行文件，具有低资源消耗、快速启动和增强的安全性。为了创建原生镜像，Maven
    插件在 Docker 容器中使用 **Paketo Buildpacks** 构建本地的 GraalVM 可执行文件。Paketo Buildpacks 是一套由社区驱动的工具，简化了将应用程序作为容器镜像构建和部署的过程。这就是为什么您不需要在您的计算机上下载
    GraalVM 工具的原因。
- en: The result is a Docker image that contains our application as a native executable.
    Just as a reference for performance improvements, the application takes around
    1.5 seconds to start on my computer running on the JVM, while the native image
    takes 0.07 seconds to do the same. That is around 21 times faster. However, when
    running 10,000 requests, the total throughput of both versions is pretty similar,
    with the JVM version being a bit better performant. That could be because the
    native version runs on Docker, while the JVM runs directly on my computer. I prepared
    a JMeter test that you can use to compare the results on your computer. You can
    find a test named `teams-native.jmx` in the book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in the `chapter7/jmeter` folder.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个包含我们的应用程序作为原生可执行文件的 Docker 镜像。仅作为性能改进的参考，该应用程序在我的运行 JVM 的计算机上启动需要大约 1.5
    秒，而原生镜像完成同样的操作只需要 0.07 秒。这大约是 21 倍的快。然而，当运行 10,000 个请求时，两个版本的总体吞吐量相当接近，JVM 版本的性能略好。这可能是因为原生版本运行在
    Docker 上，而 JVM 直接运行在我的计算机上。我准备了一个 JMeter 测试，您可以使用它来比较您计算机上的结果。您可以在书籍的 GitHub 仓库
    [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook)
    中的 `chapter7/jmeter` 文件夹找到一个名为 `teams-native.jmx` 的测试。
- en: A native application is not a silver bullet that fits all scenarios. You need
    to consider that some features require dynamic processing during runtime, and
    they are difficult to handle with native applications. If your application doesn’t
    have a quick boot-time requirement, native applications do not add many benefits
    and there can be many inconveniences. In terms of performance, a JVM application
    performs as well as a native application in the long term. That is, after warming
    up, it works as well as a native one; there can be some gains in terms of memory
    management, but in terms of performance, they are quite similar.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 原生应用程序并不是适用于所有场景的万能药。您需要考虑，某些功能在运行时需要动态处理，并且它们难以用原生应用程序处理。如果您的应用程序没有快速启动时间的要求，原生应用程序不会带来很多好处，并且可能会有很多不便。从性能的角度来看，JVM
    应用程序在长期内与原生应用程序表现相当。也就是说，在预热后，它的工作效果与原生应用程序一样；在内存管理方面可能会有一些改进，但在性能方面它们相当相似。
- en: Using GraalVM Tracing Agent to configure the native application
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GraalVM 跟踪代理配置原生应用程序
- en: The small native application we created in the previous recipe looks so promising
    that we’ve decided to build a bigger football application as a native app.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个菜谱中创建的小型本地应用程序看起来非常有前景，因此我们决定构建一个更大的足球应用程序作为原生应用程序。
- en: The application we created in the *Creating a native image using Spring Boot*
    recipe didn’t require any special configuration. But native applications are built
    AOT. That means the compiler needs to analyze all code statically and detect the
    code reached during runtime. There are some Java technologies, such as the **Java
    Native Interface** (**JNI**), **Reflection**, **dynamic proxy** objects, and class-path
    resources, that are very difficult to detect just by using static code analysis.
    The native compiler can use configuration files to include the required components
    in the final binary. As you may have figured out, the difficult part is configuring
    those files by detecting the components to be included in the final binary. For
    that purpose, GraalVM provides an agent that traces all usages to those types
    of technologies during the execution of an application on a regular JVM application.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *使用 Spring Boot 创建本地镜像* 菜谱中创建的应用程序不需要任何特殊配置。但是，本地应用程序是 AOT 构建的。这意味着编译器需要静态分析所有代码并检测运行时到达的代码。有一些
    Java 技术，如 **Java 本地接口**（**JNI**）、**反射**、**动态代理**对象和类路径资源，仅通过静态代码分析很难检测到。本地编译器可以使用配置文件将所需的组件包含在最终的二进制文件中。正如你可能已经想到的，困难的部分是通过检测要包含在最终二进制文件中的组件来配置这些文件。为此，GraalVM
    提供了一个代理，在常规 JVM 应用程序上执行应用程序时追踪对这些类型技术的所有使用。
- en: In this recipe, we will build as a native image the sample application provided
    in this chapter. If you try to build the application as a native image as is,
    you will find some errors during runtime. In this recipe, we’ll learn how to use
    GraalVM Tracing Agent to find all the required components and build a native image
    for an existing application. Then, you will be able to run your application in
    Docker.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将构建本章提供的示例应用程序的本地图像。如果你尝试直接以本地图像构建应用程序，你将在运行时遇到一些错误。在这个菜谱中，我们将学习如何使用
    GraalVM 追踪代理来查找所有必需的组件，并为现有应用程序构建本地图像。然后，你将能够在 Docker 中运行你的应用程序。
- en: Getting ready
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we’ll adapt the application you created in the *Using Testcontainers
    with Redis cache* recipe. If you haven’t finished it yet, you can use a functional
    project I’ve provided as a starting point for this recipe. You can find it in
    the book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook)
    in the `chapter7/recipe7-6/start` folder.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将适应你在 *使用 Testcontainers 与 Redis 缓存一起使用* 菜谱中创建的应用程序。如果你还没有完成，你可以使用我提供的功能项目作为这个菜谱的起点。你可以在本书的
    GitHub 仓库中找到它：[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook)
    中的 `chapter7/recipe7-6/start` 文件夹。
- en: You will need the GraalVM JDK installed on your computer. You can install it
    following the instructions from the official website at [https://www.graalvm.org/downloads/](https://www.graalvm.org/downloads/).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在你的计算机上安装 GraalVM JDK。你可以按照官方网站上的说明进行安装：[https://www.graalvm.org/downloads/](https://www.graalvm.org/downloads/)。
- en: The application depends on PostgreSQL, Redis, and other services. As we’ll see
    in the *How to do it…* section, we’ll run the application as a Docker container.
    To facilitate the execution in your development computer, I prepared a Docker
    Compose file named `docker-compose-all.yml` with the application and all dependent
    services.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序依赖于 PostgreSQL、Redis 和其他服务。正如我们将在 *如何操作...* 部分中看到的，我们将以 Docker 容器的形式运行应用程序。为了方便在开发计算机上执行，我准备了一个名为
    `docker-compose-all.yml` 的 Docker Compose 文件，其中包含应用程序和所有依赖服务。
- en: How to do it…
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let’s build a native executable image of our Spring Boot application. We’ll
    see how fast it runs now! Remember that we initially created this application
    as a regular JVM application:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个本地的可执行镜像文件，用于我们的 Spring Boot 应用程序。我们将看到它现在运行得多快！记住，我们最初创建这个应用程序时是一个常规的
    JVM 应用程序：
- en: 'First, we’ll add the *GraalVM Native Support* plugin to our `pom.xml` application.
    You should include the following configuration in the `build/plugins` element:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将向我们的 `pom.xml` 应用程序添加 *GraalVM 本地支持* 插件。你应该在 `build/plugins` 元素中包含以下配置：
- en: '[PRE18]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we’ll need to add the Hibernate Enhance plugin as well. You should include
    the following configuration in the `build/plugins` element:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们还需要添加 Hibernate Enhance 插件。你应该在 `build/plugins` 元素中包含以下配置：
- en: '[PRE19]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this step, we’ll run the application using the GraalVM JVM with a special
    setting to trace the components that our application uses at runtime. The native
    compiler will use these traces to include those components in the final binary
    executable:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此步骤中，我们将使用 GraalVM JVM 并带有特殊设置来运行应用程序，以跟踪应用程序在运行时使用的组件。原生编译器将使用这些跟踪将那些组件包含在最终的二进制可执行文件中：
- en: 'This step requires that you use the GraalVM JVM. Depending on which installation
    method you used, switching Java versions may differ. I used the *SDKMAN!* tool,
    which just executes the following command in your terminal:'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此步骤需要你使用 GraalVM JVM。根据你使用的安装方法不同，切换 Java 版本的方式可能不同。我使用了 *SDKMAN!* 工具，它只需在你的终端中执行以下命令：
- en: '[PRE20]'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To ensure you use the right JVM version, execute the following command in your
    terminal:'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了确保你使用正确的 JVM 版本，请在你的终端中执行以下命令：
- en: '[PRE21]'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Check that the response includes GraalVM. As a reference, this is the output
    when I execute this command on my computer:'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认响应中包含 GraalVM。作为一个参考，这是我在我的电脑上执行此命令时的输出：
- en: '![Figure 7.9: Sample java -version output for GraalVM JVM](img/B21646_07_9.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.9：GraalVM JVM 的示例 java -version 输出](img/B21646_07_9.jpg)'
- en: 'Figure 7.9: Sample java -version output for GraalVM JVM'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9：GraalVM JVM 的示例 java -version 输出
- en: 'Build the application normally, that is, by executing the `package` goal in
    Maven. Execute this command on a terminal in the application root folder:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正常构建应用程序，即通过在 Maven 中执行 `package` 目标。在应用程序根目录的终端中执行此命令：
- en: '[PRE22]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This command creates the JAR file for your application. By default, the filename
    will be `football-0.0.1-SNAPSHOT.jar`, and it will be created in the `target`
    directory.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此命令为你的应用程序创建 JAR 文件。默认情况下，文件名将是 `football-0.0.1-SNAPSHOT.jar`，它将在 `target` 目录中创建。
- en: 'Now, run the GraalVM tracing tool. That is achieved by executing the application
    specifying an agent for the JVM, that is, specifying the `-agentlib:native-image-agent`
    parameter and passing the folder to save the configuration output. We’ll set the
    folder where the native compiler expects the special configuration, that is, in
    `src/main/resources/META-INF/native-image`. This is how to execute your application
    specifying the GraalVM tracing tool:'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，运行 GraalVM 跟踪工具。这是通过执行指定 JVM 代理的应用程序来实现的，即指定 `-agentlib:native-image-agent`
    参数并传递保存配置输出的文件夹。我们将设置原生编译器期望的特殊配置文件夹，即 `src/main/resources/META-INF/native-image`。这是如何执行指定
    GraalVM 跟踪工具的应用程序的方法：
- en: '[PRE23]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now that our application is up and running, let’s make sure that we cover all
    our bases. It’s important that we execute every path of the application so that
    we can trace all the dynamic components and ensure everything is ready to build
    the native application. You’ll see that the `src/main/resources/META-INF/native-image`
    folder contains several JSON files.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们应用程序已经启动并运行，让我们确保我们覆盖了所有基础。执行应用程序的每个路径非常重要，这样我们就可以跟踪所有动态组件，并确保一切准备就绪以构建原生应用程序。你会发现
    `src/main/resources/META-INF/native-image` 文件夹包含几个 JSON 文件。
- en: When you complete the execution of all application paths, you can stop the application.
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你完成所有应用程序路径的执行后，你可以停止应用程序。
- en: 'It’s time to build the native application! You can do it by executing the following
    Maven command:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候构建原生应用程序了！你可以通过执行以下 Maven 命令来完成：
- en: '[PRE24]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works…
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: As explained in the *Creating a native image using Spring Boot* recipe, adding
    *GraalVM Native Support* to our application creates a new Spring Boot profile
    that we can use to build a Docker image with a native version of our application.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *使用 Spring Boot 创建原生映像* 菜单中所述，将 *GraalVM Native Support* 添加到我们的应用程序将创建一个新的
    Spring Boot 配置文件，我们可以使用它来构建具有我们应用程序原生版本的新 Docker 映像。
- en: Some Hibernate operations generate Hibernate Proxy instances at runtime. If
    we don’t include the Hibernate Enhance plugin, the native compiler doesn’t have
    the required references at build time. For that reason, we need to include this
    plugin in our application.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Hibernate 操作在运行时生成 Hibernate 代理实例。如果我们不包括 Hibernate Enhance 插件，原生编译器在构建时没有所需的引用。因此，我们需要在我们的应用程序中包含此插件。
- en: 'In a simple application like the one created in the *Creating a native image
    using Spring Boot* recipe, we could skip *steps 3* and *4* and build the native
    application directly. However, we would realize that many operations do not work.
    That happens because the static build analysis doesn’t detect some dynamic loading
    components, mostly related to Hibernate. To tackle this issue, GraalVM provides
    the Tracing Agent tool. This tool traces all usages of JNI, Java Reflection, dynamic
    proxy objects (`java.lang.reflect.Proxy`), or class-path resources and saves them
    in the specified folder. The files generated are the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在像在*使用共享缓存*菜谱中创建的简单应用程序中，我们可以跳过*步骤3*和*步骤4*，直接构建本地应用程序。然而，我们会意识到许多操作不起作用。这是因为静态构建分析没有检测到一些动态加载的组件，这些组件大多与Hibernate相关。为了解决这个问题，GraalVM提供了跟踪代理工具。这个工具跟踪JNI、Java反射、动态代理对象（`java.lang.reflect.Proxy`）或类路径资源的所有使用情况，并将它们保存在指定的文件夹中。生成的文件如下：
- en: '`jni-config.json`: This contains JNI-related information'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jni-config.json`: 这包含JNI相关信息'
- en: '`reflect-config.json`: This contains reflection-related details'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reflect-config.json`: 这包含反射相关细节'
- en: '`proxy-config.json`: This contains dynamic proxy object details'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy-config.json`: 这包含动态代理对象详情'
- en: '`resource-config.json`: This contains class-path resource information'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource-config.json`: 这包含类路径资源信息'
- en: '`predefined-classes-config.json`: This contains metadata for predefined classes'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`predefined-classes-config.json`: 这包含预定义类的元数据'
- en: '`serialization-config.json`: This contains serialization-related data'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serialization-config.json`: 这包含序列化相关数据'
- en: Then, the native compiler can use this configuration to include the referenced
    components in the final native executable. With this approach, we may find most
    of the components used at runtime, but some components may not be detected. In
    that case, we will need to include them manually.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，本地编译器可以使用此配置将引用的组件包含在最终的本地可执行文件中。采用这种方法，我们可能会找到大多数在运行时使用的组件，但某些组件可能无法检测到。在这种情况下，我们需要手动包含它们。
- en: As we run the application as a container, it’s executed in the context of Docker.
    This means that to locate the dependent services, such as PostgreSQL, it’s necessary
    to specify the internal Docker DNS name. In the previous recipes, all dependent
    services were accessible using `localhost`. For that reason, it’s necessary to
    specify the address of all dependent components, for instance, by setting the
    environment variables, and the easiest way to set these environment variables
    is by creating a Docker Compose file.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将应用程序作为容器运行，它是在Docker的上下文中执行的。这意味着为了定位依赖的服务，例如PostgreSQL，需要指定内部Docker DNS名称。在先前的菜谱中，所有依赖服务都可以使用`localhost`访问。因此，需要指定所有依赖组件的地址，例如，通过设置环境变量，而设置这些环境变量的最简单方法是通过创建Docker
    Compose文件。
- en: There’s more…
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'I executed the same JMeter tests we used in the *Using shared cache* recipe
    to compare the results of executing the same application running on a JVM and
    as a native application. In the following figure, you can see the results of running
    as a native application:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我执行了我们在*使用共享缓存*菜谱中使用的相同的JMeter测试，以比较在JVM上运行和作为本地应用程序运行的同一种应用程序的结果。在下面的图中，你可以看到作为本地应用程序运行的结果：
- en: '![Figure 7.10: JMeter throughput for native image running on Docker](img/B21646_07_10.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图7.10：在Docker上运行的本地图像的JMeter吞吐量](img/B21646_07_10.jpg)'
- en: 'Figure 7.10: JMeter throughput for native image running on Docker'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10：在Docker上运行的本地图像的JMeter吞吐量
- en: The results may seem surprising, as the application running as a native application
    performs significantly worse than the JVM version.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可能看起来令人惊讶，因为作为本地应用程序运行的应用程序的性能明显低于JVM版本。
- en: 'There are two factors to keep in mind:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个因素需要考虑：
- en: The application now runs on Docker, while the application running on a JVM was
    executed directly on my computer
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序现在运行在Docker上，而运行在JVM上的应用程序是直接在我的计算机上执行的
- en: Once the application running on a JVM did the **Just-in-Time** (**JIT**) compilation,
    there were no significant gains in performance compared to running
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦在JVM上运行的应用程序完成了**即时编译**（**JIT**），与运行相比，性能没有显著提升。
- en: In the next recipe, we’ll build the application natively instead of running
    on a container. Then, we’ll be able to compare the applications running with similar
    conditions.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个菜谱中，我们将以本地方式构建应用程序，而不是在容器上运行。然后，我们将能够比较在类似条件下运行的应用程序。
- en: Creating a native executable using Spring Boot
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Boot创建本地可执行文件
- en: In the previous recipes, we built the native application to run as a container.
    Even if that is a convenient solution for most modern cloud-native scenarios,
    we may need to build a native executable to be executed directly without a container
    engine.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们构建了原生应用程序以作为容器运行。尽管这对于大多数现代云原生场景来说是一个方便的解决方案，但我们可能需要构建一个原生可执行文件，以便在没有容器引擎的情况下直接执行。
- en: In this recipe, we’ll learn how to configure our computer to build native applications
    using the GraalVM JDK.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何配置我们的计算机以使用 GraalVM JDK 构建原生应用程序。
- en: Getting ready
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In this recipe, we’ll reuse the result of the *Using GraalVM Tracing Agent to
    configure the native application* recipe. I prepared a version of the application
    that you can use as a starting point for this recipe. You can find it in the book’s
    GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/),
    in the `chapter7/recipe7-6/start` folder.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将重用 *使用 GraalVM 追踪代理配置原生应用程序* 菜谱的结果。我准备了一个应用程序版本，您可以用作此菜谱的起点。您可以在本书的
    GitHub 仓库中找到它，网址为 [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/)，在
    `chapter7/recipe7-6/start` 文件夹中。
- en: You will need the GraalVM JDK version 21 installed on your computer. You can
    follow the instructions from the official website at [https://www.graalvm.org/downloads/](https://www.graalvm.org/downloads/).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在您的计算机上安装 GraalVM JDK 版本 21。您可以通过访问官方网站上的说明进行操作，网址为 [https://www.graalvm.org/downloads/](https://www.graalvm.org/downloads/).
- en: The application depends on some services, such as PostgreSQL and Redis. To facilitate
    the execution of these services on your computer, you can reuse the `docker-compose-redis.yml`
    file prepared in the *Using shared* *cache* recipe.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序依赖于一些服务，如 PostgreSQL 和 Redis。为了方便在您的计算机上执行这些服务，您可以使用在 *使用共享* *缓存* 菜谱中准备的
    `docker-compose-redis.yml` 文件。
- en: How to do it…
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Now, we’ll build our application as a native image that can be executed directly
    on our computer:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将构建我们的应用程序作为一个原生镜像，可以直接在我们的计算机上执行：
- en: 'Ensure that you are using the GraalVM JVM for this process. For that, execute
    the following command:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您在此过程中使用 GraalVM JVM。为此，执行以下命令：
- en: '[PRE25]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Verify that the message contains GraalVM, as shown in *Figure 7**.5*.
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确认消息中包含 GraalVM，如图 *图 7**.5* 所示。
- en: 'Next, we’ll build the native executable. For that, open a terminal, change
    the directory to the root application folder, and execute the following command:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将构建原生可执行文件。为此，打开一个终端，将目录更改为根应用程序文件夹，并执行以下命令：
- en: '[PRE26]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The native build takes longer than a regular JVM build, even up to a few minutes.
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 原生构建所需的时间比常规 JVM 构建长，甚至可能长达几分钟。
- en: 'Now, we have our binary executable in the `target` folder. Its name is the
    same as the project, this time without a version suffix. If you use Windows, it
    will be `football.exe`; in Unix-like systems, it will be just `football`. It’s
    time to run the application. As I’m using Linux, I’ll execute the following commands
    in my terminal:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们的二进制可执行文件位于 `target` 文件夹中。它的名称与项目相同，这次没有版本后缀。如果您使用 Windows，它将是 `football.exe`；在类
    Unix 系统中，它将只是 `football`。现在是运行应用程序的时候了。由于我使用的是 Linux，我将在我的终端中执行以下命令：
- en: '[PRE27]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Be sure that the dependent services, such as PostgreSQL and Redis, are up and
    running. As explained in the *Getting ready* section, you can use the `docker-compose-redis.yml`
    Docker Compose file to run all dependent services.
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保依赖的服务，如 PostgreSQL 和 Redis，正在运行。正如在 *准备就绪* 部分中解释的那样，您可以使用 `docker-compose-redis.yml`
    Docker Compose 文件来运行所有依赖的服务。
- en: How it works…
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作……
- en: As we did in the *Using GraalVM Tracing Agent to configure the native application*
    recipe, we must prepare our application for the native build. In this recipe,
    we reused the application, and we already had the hints for the dynamic components
    that GraalVM needs to generate the native application. However, if you start from
    scratch, you will need to prepare the configuration as we did in the *Using GraalVM
    Tracing Agent to configure the native* *application* recipe.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 *使用 GraalVM 追踪代理配置原生应用程序* 菜谱中所做的那样，我们必须为原生构建准备我们的应用程序。在这个菜谱中，我们重用了应用程序，并且我们已经有了
    GraalVM 需要生成原生应用程序的动态组件的提示。然而，如果您从头开始，您将需要像在 *使用 GraalVM 追踪代理配置原生* *应用程序* 菜谱中所做的那样准备配置。
- en: The Spring Boot *GraalVM Native Support* starter includes the native profile
    and the `native:compile` goal. This starter was already included in the application
    we reused in this recipe. This time, the compilation process runs on your computer
    instead of being executed in a container.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot *GraalVM Native Support* 启动器包括原生配置文件和`native:compile`目标。这个启动器已经包含在我们在这个菜谱中重用的应用程序中。这次，编译过程是在您的计算机上运行，而不是在容器中执行。
- en: There’s more…
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We can execute the load test using JMeter. This scenario is comparable to the
    one tested in the *Using Testcontainers with Redis cache* recipe, as both applications
    run directly on the computer and the dependent services run on Docker. These are
    the results of executing the same JMeter test on my computer:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用JMeter执行负载测试。这个场景与*使用Testcontainers与Redis缓存*菜谱中测试的场景相似，因为两个应用程序都是直接在计算机上运行的，而依赖的服务运行在Docker上。以下是我计算机上执行相同JMeter测试的结果：
- en: '![Figure 7.11: JMeter summary for a native application](img/B21646_07_11.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图7.11：原生应用程序的JMeter摘要](img/B21646_07_11.jpg)'
- en: 'Figure 7.11: JMeter summary for a native application'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11：原生应用程序的JMeter摘要
- en: The throughput for `get-user-player` is 622.1 RPS, compared to the 566.3 RPS
    achieved using a JVM version. That is approximately a 9.86% increase. For the
    total requests, it is 773.5 RPS compared to 699.2 RPS, which is approximately
    a 10.6% increase.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`get-user-player`的吞吐量是622.1 RPS，与使用JVM版本实现的566.3 RPS相比，这大约提高了9.86%。对于总请求量，它是773.5
    RPS，与699.2 RPS相比，大约提高了10.6%。
- en: You must consider the benefits and trade-offs of using a native image. The main
    benefits are quick start-up time and better memory management and performance.
    The main trade-offs are the complexities of preparing the build image with all
    hints required to avoid runtime errors due to dynamic components. This configuration
    can be very painful and difficult to detect. You also need to consider the time
    required to build your application, which can be significantly longer than the
    JVM counterpart.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须考虑使用原生镜像的利弊。主要好处是快速启动时间和更好的内存管理和性能。主要的权衡是准备构建镜像的复杂性，需要所有必要的提示以避免由于动态组件导致的运行时错误。这种配置可能非常痛苦且难以检测。您还需要考虑构建应用程序所需的时间，这可能会比JVM对应版本长得多。
- en: Creating a native executable from a JAR
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从JAR创建原生可执行文件
- en: As we realized during the completion of the previous recipes, building a native
    image takes way more time than building a regular JVM application. Another important
    consideration in certain environments is that GraalVM currently doesn’t support
    cross-platform builds. That means if we need to build an application for Linux,
    as it’s the most popular platform for server environments, but our development
    computer is a Windows or macOS computer, we cannot build the application directly.
    For these reasons, it could be a good choice to keep working with a regular JVM
    development process and create the native executable in a **Continuous Integration**
    (**CI**) platform. For instance, you can create a GitHub action for the native
    executable creation. In that way, we maintain the productivity for our development
    processes, we don’t need to change our development platform, and we can target
    platforms for our application.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在完成前一个菜谱的过程中所意识到的，构建原生镜像所需的时间远比构建常规JVM应用程序所需的时间多。在特定环境中，另一个重要的考虑因素是GraalVM目前不支持跨平台构建。这意味着如果我们需要为Linux构建应用程序，因为它是服务器环境中最受欢迎的平台，但我们的开发计算机是Windows或macOS计算机，我们无法直接构建该应用程序。出于这些原因，继续使用常规JVM开发流程并在**持续集成**（**CI**）平台上创建原生可执行文件可能是一个不错的选择。例如，您可以创建一个用于创建原生可执行文件的GitHub操作。这样，我们可以在开发过程中保持生产力，我们不需要更改我们的开发平台，并且我们可以针对我们的应用程序的平台。
- en: In this recipe, we’ll generate a native executable for our football application
    using the *native-image* tool from the GraalVM JDK.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用GraalVM JDK中的*native-image*工具为我们足球应用程序生成原生可执行文件。
- en: Getting ready
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: For this recipe, we’ll use the outcome from the *Creating a native executable
    using Spring Boot* recipe. Creating a native executable using a *native-image*
    tool requires an AOT-processed JAR. If you plan to convert another application
    into a native executable, follow the instructions from the previous recipe to
    generate the AOT-processed JAR file. If you haven’t completed the previous recipe
    yet, I prepared a working version that you can use as the starting point for this
    recipe. You can find it in the book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/),
    in the `chapter7/recipe7-8/start` folder.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将使用来自*使用Spring Boot创建原生可执行文件*配方的结果。使用`native-image`工具创建原生可执行文件需要一个AOT处理的JAR。如果您计划将另一个应用程序转换为原生可执行文件，请按照上一个配方中的说明生成AOT处理的JAR文件。如果您还没有完成上一个配方，我准备了一个可用的版本，您可以用它作为本配方的起点。您可以在本书的GitHub仓库中找到它，网址为[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/)，在`chapter7/recipe7-8/start`文件夹中。
- en: You will need the *native-image* tool. This tool is part of the GraalVM JDK.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要`native-image`工具。此工具是GraalVM JDK的一部分。
- en: How to do it…
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: You can work normally with a JVM and keep the native build for CI. Let’s see
    what you will need to do then!
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用JVM正常工作，并将原生构建用于CI。让我们看看那时您需要做什么！
- en: 'The first step is ensuring that you generate a JAR with AOT processed. For
    that, open your terminal at the root of your project and package the JAR file
    using the `native` profile with Maven. To do so, execute the following command:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是确保您生成一个经过AOT处理的JAR。为此，在项目的根目录中打开您的终端，并使用Maven的`native`配置文件打包JAR文件。为此，请执行以下命令：
- en: '[PRE28]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we’ll create a new directory for our native executable. Let’s name it
    `native`. We’ll create this directory inside the `target` directory:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为我们的原生可执行文件创建一个新的目录。让我们称它为`native`。我们将在`target`目录内创建此目录：
- en: '[PRE29]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Change your current directory to the new directory created:'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将您的当前目录更改为新创建的目录：
- en: '[PRE30]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we’ll extract the classes from the JAR file created in *step 1*. We’ll
    use the JAR tool, which is part of the JDK:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将从在*步骤1*中创建的JAR文件中提取类。我们将使用JDK的一部分，即JAR工具：
- en: '[PRE31]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can build the native application. For that, we’ll use the `native-image`
    tool. We need to set the following arguments:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以构建原生应用程序。为此，我们将使用`native-image`工具。我们需要设置以下参数：
- en: '`-H:name=football`: This is the executable filename; in our case, it will be
    `football`.'
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-H:name=football`: 这是指定的可执行文件名；在我们的例子中，它将是`football`。'
- en: '`@META-INF/native-image/argfile`: The `@` symbol indicates that the argument
    is read from a file. The specified file (`argfile`) likely contains additional
    configuration options or arguments for the native image generation process.'
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@META-INF/native-image/argfile`: `@`符号表示该参数是从文件中读取的。指定的文件（`argfile`）可能包含用于原生图像生成过程的附加配置选项或参数。'
- en: '`-cp`: This argument sets the class path for the native image. We must pass
    the current directory, the `BOOT-INF/classes` directory, and all files contained
    in `BOOT-INF/lib`. This argument will look like this: ``-cp .:BOOT-INF/classes:`find
    BOOT-INF/lib | tr ''\[PRE32]'
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-cp`: 此参数设置原生图像的类路径。我们必须传递当前目录、`BOOT-INF/classes`目录以及`BOOT-INF/lib`中包含的所有文件。此参数将如下所示：``-cp
    .:BOOT-INF/classes:`find BOOT-INF/lib | tr ''\[PRE32]'
- en: native-image -H:Name=football @META-INF/native-image/argfile \
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: native-image -H:Name=football @META-INF/native-image/argfile \
- en: -cp .:BOOT-INF/classes:`find BOOT-INF/lib | tr '\n' ':'`
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: -cp .:BOOT-INF/classes:`find BOOT-INF/lib | tr '\n' ':'`
- en: '[PRE33]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ./football
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ./football
- en: '```'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '```'
- en: How it works…
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: As we reused the application from the previous recipes, we have already defined
    the hints. See the *Using GraalVM Tracing Agent to configure the native application*
    recipe for more details. To make them available for the native build, we must
    package our application using the `native` profile.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们重用了上一个配方中的应用程序，我们已定义了提示。有关更多详细信息，请参阅*使用GraalVM跟踪代理配置原生应用程序*配方。为了使它们可用于原生构建，我们必须使用`native`配置文件打包我们的应用程序。
- en: A JAR file contains the classes and resources of our application in a ZIP file.
    We could use a standard ZIP tool, but the JAR tool is more convenient for our
    purposes. We passed the `-xvf` arguments with the JAR file to be processed. The
    `x` argument instructs the tool to extract the content. `f` means that it will
    get the content from a file that is passed as an argument as well. Finally, `v`
    is just to generate a verbose output; we could get rid of this parameter.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 JAR 文件包含我们应用程序的类和资源在一个 ZIP 文件中。我们可以使用标准的 ZIP 工具，但 JAR 工具对我们的目的来说更加方便。我们使用
    `-xvf` 参数与要处理的 JAR 文件一起传递。`x` 参数指示工具提取内容。`f` 表示它将从作为参数传递的文件中获取内容。最后，`v` 只是用来生成详细输出；我们可以去掉这个参数。
- en: For the `native-image` tool, we need to pass all files contained in the `BOOT-INF/lib`
    directory. Unfortunately, the `cp` argument doesn’t admit wildcards. In Unix-like
    systems, you can use the `find` and `tr` tools. `find` lists the files in the
    directory, and `tr` removes `\n` and`:` characters. `\n` is the new line character.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `native-image` 工具，我们需要传递 `BOOT-INF/lib` 目录中包含的所有文件。不幸的是，`cp` 参数不承认通配符。在类
    Unix 系统中，你可以使用 `find` 和 `tr` 工具。`find` 列出目录中的文件，而 `tr` 移除 `\n` 和 `:` 字符。`\n` 是换行符。
