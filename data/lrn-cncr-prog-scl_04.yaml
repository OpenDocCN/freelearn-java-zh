- en: Chapter 4.  Asynchronous Programming with Futures and Promises
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。使用Futures和Promises进行异步编程
- en: '|   | *Programming in a functional style makes the state presented to your
    code explicit, which makes it much easier to reason about, and, in a completely
    pure system, makes thread race conditions impossible.* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *以函数式风格编程使代码呈现的状态明确，这使得推理更容易，并且在完全纯系统中，使得线程竞争条件成为不可能。* |   |'
- en: '|   | --*John Carmack* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*约翰·卡马克* |'
- en: 'In the examples of the previous chapters, we often dealt with blocking computations.
    We have seen that blocking synchronization can have negative effects: it can cause
    deadlocks, starve thread pools, or break lazy value initialization. While, in
    some cases, blocking is the right tool for the job, in many cases we can avoid
    it. Asynchronous programming refers to the programming style in which executions
    occur independently of the main program flow. Asynchronous programming helps you
    to eliminate blocking instead of suspending the thread whenever a resource is
    not available; a separate computation is scheduled to proceed once the resource
    becomes available.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章的示例中，我们经常处理阻塞计算。我们了解到阻塞同步可能产生负面影响：它可能导致死锁、耗尽线程池或破坏懒值初始化。虽然在某些情况下，阻塞是完成工作的正确工具，但在许多情况下我们可以避免它。异步编程指的是执行独立于主程序流程的编程风格。异步编程帮助您在资源不可用时消除阻塞，而不是挂起线程；一旦资源可用，就会安排一个单独的计算继续进行。
- en: 'In a way, many of the concurrency patterns seen so far support asynchronous
    programming; thread creation and scheduling execution context tasks can be used
    to start executing a computation concurrent to the main program flow. Still, using these
    facilities directly when avoiding blocking or composing asynchronous computations
    is not straightforward. In this chapter, we will focus on two abstractions in
    Scala that are specifically tailored for this task: futures and promises.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，到目前为止看到的许多并发模式都支持异步编程；线程创建和调度执行上下文任务可以用来在主程序流程并发执行计算。尽管如此，在避免阻塞或组合异步计算时直接使用这些设施并不简单。在本章中，我们将关注Scala中专门针对此任务的两个抽象：futures和promises。
- en: 'More specifically, we will study the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，我们将研究以下主题：
- en: Starting asynchronous computations, and using `Future` objects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动异步计算，并使用`Future`对象
- en: Installing callbacks that handle the results of asynchronous computations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装处理异步计算结果的回调
- en: Exception semantics of `Future` objects, and using the type `Try`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Future`对象的异常语义，以及使用类型`Try`'
- en: Functional composition of `Future` objects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Future`对象的函数式组合'
- en: Using `Promise` objects to interface with callback-based APIs, implement future
    combinators, and support cancellation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Promise`对象与基于回调的API接口，实现future组合子，并支持取消
- en: Blocking threads inside asynchronous computations
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在异步计算中阻塞线程
- en: Using the Scala `Async` library
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Scala的`Async`库
- en: In the next section, we will start by introducing the try `Future` , and show
    why it is useful.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将首先介绍`Future`，并展示为什么它是有用的。
- en: Futures
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Futures
- en: 'In earlier chapters, we learned that parallel executions in a concurrent program
    proceed on entities called **threads**. At any point, the execution of a thread
    can be temporarily suspended, until a specific condition is fulfilled. When this
    happens, we say that the thread is blocked. Why do we block threads in the first
    place in concurrent programming? One of the reasons is that we have a finite amount
    of resources; multiple computations that share these resources sometimes need
    to wait. In other situations, a computation needs specific data to proceed, and
    if that data is not yet available, threads responsible for producing the data
    could be slow or the source of the data could be external to the program. A classic
    example is waiting for the data to arrive over the network. Let''s assume that
    we have a `getWebpage` method, that given a `url` string with the location of
    the webpage, returns that webpage''s contents:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们了解到并发程序中的并行执行是在称为**线程**的实体上进行的。在任何时刻，线程的执行可以被暂时挂起，直到满足特定条件。当这种情况发生时，我们说线程被阻塞了。为什么在并发编程中我们最初要阻塞线程呢？其中一个原因是资源有限；共享这些资源的多个计算有时需要等待。在其他情况下，一个计算需要特定的数据才能继续进行，如果这些数据尚未可用，负责生成数据的线程可能运行缓慢或数据源可能位于程序外部。一个经典的例子是等待通过网络到达的数据。假设我们有一个`getWebpage`方法，给定一个包含网页位置的`url`字符串，返回该网页的内容：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The return type of the `getWebpage` method is `String`; the method must return
    a string with the webpage's contents. Upon sending an HTTP request, though, the
    webpage's contents are not available immediately. It takes some time for the request
    to travel over the network to the server and back before the program can access
    the document. The only way for the method to return the contents of the webpage
    as a string value is to wait for the HTTP response to arrive. However, this can
    take a relatively long time from the program's point of view; even with a high-speed
    Internet connection, the `getWebpage` method needs to wait. Since the thread that
    called the `getWebpage` method cannot proceed without the contents of the webpage,
    it needs to pause its execution; therefore, the only way to correctly implement
    the `getWebpage` method is to block.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`getWebpage`方法的返回类型是`String`；该方法必须返回包含网页内容的字符串。然而，在发送HTTP请求后，网页的内容并不立即可用。请求需要一些时间在网络中从服务器传回，程序才能访问文档。唯一的方法是等待HTTP响应到达，但这可能需要相对较长的时间；即使有高速的互联网连接，`getWebpage`方法也需要等待。由于调用`getWebpage`方法的线程在没有网页内容的情况下无法继续执行，它需要暂停其执行；因此，正确实现`getWebpage`方法的唯一方式是阻塞。'
- en: 'We already know that blocking can have negative side-effects, so can we change
    the return value of the `getWebpage` method to some special value that can be
    returned immediately? The answer is yes. In Scala, this special value is called
    a **future**. A future is a placeholder, that is, a memory location for the value.
    This placeholder does not need to contain a value when the future is created;
    the value can be placed into the future eventually by the `getWebpage` method.
    We can change the signature of the `getWebpage` method to return a future as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道阻塞可能会产生负面影响，那么我们能否将`getWebpage`方法的返回值更改为一个可以立即返回的特殊值呢？答案是肯定的。在Scala中，这个特殊值被称为**future**。future是一个占位符，即值的内存位置。这个占位符在future创建时不需要包含值；值最终可以通过`getWebpage`方法放入future中。我们可以将`getWebpage`方法的签名更改为返回一个future，如下所示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, the `Future[String]` type means that the future object can eventually
    contain a `String` value. We can now implement the `getWebpage` method without
    blocking-we can start the HTTP request asynchronously and place the webpage's
    contents into the future when they become available. When this happens, we say
    that the `getWebpage` method completes the future. Importantly, after the future
    is completed with some value, that value can no longer change.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`Future[String]`类型意味着future对象最终可以包含一个`String`值。现在我们可以实现不阻塞的`getWebpage`方法——我们可以异步启动HTTP请求，并在内容可用时将其放入future中。当这种情况发生时，我们说`getWebpage`方法完成了future。重要的是，在future完成并带有某个值之后，该值将无法再改变。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `Future[T]` type encodes latency in the program; use it to encode values
    that will become available later during execution.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`Future[T]`类型在程序中编码了延迟；使用它来编码在执行过程中稍后可用的值。'
- en: This removes blocking from the `getWebpage` method, but it is not clear how
    the calling thread can extract the content of the future. Polling is one non-blocking
    way of extracting the content. In the polling approach, the calling thread calls
    a special method to block until the value becomes available. While this approach
    does not eliminate blocking, it transfers the responsibility of blocking from
    the `getWebpage` method to the caller thread. Java defines its own `Future` type
    to encode values that will become available later. However, as a Scala developer,
    you should use Scala's futures instead; they allow additional ways of handling
    future values and avoid blocking, as we will soon see.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这消除了`getWebpage`方法中的阻塞，但调用线程如何提取future的内容并不明确。轮询是一种非阻塞提取内容的方法。在轮询方法中，调用线程调用一个特殊方法来阻塞，直到值变得可用。虽然这种方法并没有消除阻塞，但它将阻塞的责任从`getWebpage`方法转移到了调用线程。Java定义了自己的`Future`类型来编码稍后可用的值。然而，作为一个Scala开发者，你应该使用Scala的futures；它们允许处理future值的方式更多，并且避免了阻塞，正如我们很快就会看到的。
- en: 'When programming with futures in Scala, we need to distinguish between **future
    values** and **future computations**. A future value of the type `Future[T]` 
    denotes some value of type `T`  in the program that might not be currently available,
    but could become available later. Usually, when we say a future, we really mean
    a future value. In the `scala.concurrent` package, futures are represented with
    the `Future[T]` trait:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Scala中使用未来编程时，我们需要区分**未来值**和**未来计算**。类型为`Future[T]`的未来值表示程序中可能当前不可用，但以后可能可用的某种类型的`T`值。通常，当我们说未来时，我们实际上是指未来值。在`scala.concurrent`包中，未来是通过`Future[T]`特质来表示的：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'By contrast, a future computation is an asynchronous computation that produces
    a future value. A future computation can be started by calling the `apply` method
    on the `Future` companion object. This method has the following signature in the
    `scala.concurrent` package:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，未来的计算是一种异步计算，它产生一个未来的值。可以通过在`Future`伴生对象上调用`apply`方法来启动未来的计算。在`scala.concurrent`包中，此方法具有以下签名：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This method takes a by-name parameter of the type `T` . This is the body of
    the asynchronous computation that results in some value of type `T`. It also takes
    an implicit `ExecutionContext` parameter, which abstracts over where and when
    the thread gets executed, as we learned in [Chapter 3](ch03.html "Chapter 3. Traditional
    Building Blocks of Concurrency"), *Traditional Building Blocks of Concurrency*.
    Recall that Scala's implicit parameters can either be specified when calling a
    method, in the same way as normal parameters, or they can be left out-in this
    case, the Scala compiler searches for a value of the `ExecutionContext` type in
    the surrounding scope. Most `Future` methods take an implicit execution context.
    Finally, the `Future.apply` method returns a future of the type `T`. This future
    is completed with the value resulting from the asynchronous computation, `b`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受一个类型为`T`的按名参数。这是异步计算的主体，该计算产生某种类型的`T`值。它还接受一个隐式`ExecutionContext`参数，该参数抽象化了线程在哪里以及何时执行，正如我们在[第3章](ch03.html
    "第3章。并发传统构建块")中学习的，*并发的传统构建块*。回想一下，Scala的隐式参数可以在调用方法时指定，就像正常参数一样，或者它们可以被省略——在这种情况下，Scala编译器会在周围作用域中搜索`ExecutionContext`类型的值。大多数`Future`方法都接受一个隐式执行上下文。最后，`Future.apply`方法返回一个类型为`T`的未来。这个未来通过异步计算的结果值`b`来完成。
- en: Starting future computations
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动未来计算
- en: 'Let''s see how to start a future computation in an example. We first import
    the contents of the `scala.concurrent` package. We then import the `global` execution
    context from the `Implicits` object. This makes sure that future computations
    execute on `global`, the default execution context you can use in most cases:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来看看如何启动未来的计算。我们首先导入`scala.concurrent`包的内容。然后从`Implicits`对象中导入`global`执行上下文。这确保了未来的计算将在`global`上执行，这是大多数情况下你可以使用的默认执行上下文：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The order in which the `log` method calls (in the future computation and the
    main thread) execute is nondeterministic. The `Future` singleton object followed
    by a block is syntactic sugar for calling the `Future.apply` method. The `Future.apply`
    method acts similarly to the `execute` statement from [Chapter 3](ch03.html "Chapter 3. Traditional
    Building Blocks of Concurrency"), *Traditional Building Blocks of Concurrency*.
    The difference is that the `Future.apply` method returns a future value. We can
    poll this future value until it is completed. In the following example, we can
    use the `scala.io.Source` object to read the contents of our `build.sbt` file
    in a future computation. The main thread calls the `isCompleted` method on the
    `buildFile` future value, returned from the future computation. Chances are that
    the build file was not read so rapid, so `isCompleted` returns `false`. After
    250 milliseconds, the main thread calls `isCompleted` again, and this time `isCompleted`
    returns `true`. Finally, the main thread calls the `value` method, which returns
    the contents of the build file:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`log` 方法调用（在未来的计算和主线程中）执行的顺序是非确定的。跟随一个块的 `Future` 单例对象是调用 `Future.apply` 方法的语法糖。`Future.apply`
    方法的作用类似于 [第 3 章](ch03.html "第 3 章。并发传统的构建块") 中的 `execute` 语句，*并发的传统构建块*。不同之处在于
    `Future.apply` 方法返回一个未来值。我们可以轮询这个未来值，直到它完成。在以下示例中，我们可以使用 `scala.io.Source` 对象在未来的计算中读取
    `build.sbt` 文件的全部内容。主线程在未来的计算返回的 `buildFile` 未来值上调用 `isCompleted` 方法。很可能会发生的是，构建文件没有快速读取，所以
    `isCompleted` 返回 `false`。250 毫秒后，主线程再次调用 `isCompleted`，这次 `isCompleted` 返回 `true`。最后，主线程调用
    `value` 方法，它返回构建文件的内容：'
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, we used polling to obtain the value of the future. The `Future`
    singleton object's polling methods are non-blocking, but they are also nondeterministic;
    `isCompleted` will repeatedly return `false` until the future is completed. Importantly,
    completion of the future is in a happens-before relationship with the polling
    calls. If the future completes before the invocation of the polling method, then
    its effects are visible to the thread after polling completes.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了轮询来获取未来的值。`Future` 单例对象的轮询方法是非阻塞的，但它们也是非确定的；`isCompleted` 将会反复返回
    `false` 直到未来完成。重要的是，未来的完成与轮询调用之间存在发生之前的关系。如果未来在轮询方法调用之前完成，那么其效果将在轮询完成后对线程可见。
- en: 'Shown graphically, polling looks like the following figure:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以图形方式展示，轮询看起来像以下图：
- en: '![Starting future computations](img/image_04_001.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![启动未来计算](img/image_04_001.jpg)'
- en: Polling diagram
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 轮询图
- en: Polling is like calling your potential employer every five minutes to ask if
    you're hired. What you really want to do is hand in a job application and then
    apply for other jobs, instead of busy-waiting for the employer's response. Once
    your employer decides to hire you, they will give you a call on the phone number
    you left them. We want futures to do the same; when they are completed, they should
    call a specific function we left for them. This is the topic of the next section.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 轮询就像每隔五分钟给你的潜在雇主打电话询问你是否被雇佣一样。你真正想做的应该是提交一份工作申请，然后申请其他工作，而不是忙等雇主的回复。一旦你的雇主决定雇佣你，他们会在你留给他们的电话号码上给你打电话。我们希望未来能做同样的事情；当它们完成时，它们应该调用我们留给它们的特定函数。这是下一节的主题。
- en: Future callbacks
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未来回调
- en: A callback is a function that is called once its arguments become available.
    When a Scala future takes a callback, it eventually calls that callback. However,
    the future does not call the callback before this future is completed with some
    value.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 回调是一个在其参数可用时被调用的函数。当 Scala 未来接受一个回调时，它最终会调用那个回调。然而，未来不会在完成并带有某个值之前调用回调。
- en: 'Let''s assume that we need to look up details of the URL specification from
    the W3 consortium. We are interested in all the occurrences of the `telnet` keyword.
    The URL specification is available as a text document at [https://www.w3.org/](https://www.w3.org/).
    We can use the `scala.io.Source` object to fetch the contents of the specification,
    and use futures in the `getUrlSpec` method to asynchronously execute the HTTP
    request. The `getUrlSpec` method first calls the `fromURL` method to obtain a
    `Source` object with the text document. It then calls `getLines` to get a list
    of separate lines in the document:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要查找W3联盟的URL规范细节。我们对`telnet`关键字的全部实例感兴趣。URL规范作为文本文档可在[https://www.w3.org/](https://www.w3.org/)找到。我们可以使用`scala.io.Source`对象获取规范的正文内容，并在`getUrlSpec`方法中使用未来异步执行HTTP请求。`getUrlSpec`方法首先调用`fromURL`方法以获取包含文本文档的`Source`对象。然后它调用`getLines`以获取文档中的单独行列表：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To find the lines in the `urlSpec` future that contains the `telnet` keyword,
    we use the `find` method which takes a list of lines and a keyword and returns
    a string containing the matches:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到`urlSpec`未来中包含`telnet`关键字的行，我们使用`find`方法，该方法接受一个行列表和一个关键字，并返回包含匹配项的字符串：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `find` method takes a `List[String]` parameter, but `urlSpec` is of the
    `Future[List[String]]` type. We cannot pass the `urlSpec` future directly to the
    `find` method; and for a good reason, the value might not be available at the
    time when we call the `find` method.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`方法接受一个`List[String]`参数，但`urlSpec`是`Future[List[String]]`类型。我们不能直接将`urlSpec`未来传递给`find`方法；而且有很好的理由，该值可能在调用`find`方法时不可用。'
- en: 'Instead, we install a callback to the future using the `foreach` method. Note
    that the equivalent of the `foreach` method is the `onSuccess` method, but it
    might be deprecated after Scala 2.11\. This method takes a partial function that,
    given a value of the future, performs some action, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们使用`foreach`方法安装到未来的回调。请注意，`foreach`方法的等效方法是`onSuccess`方法，但它可能在Scala 2.11之后被弃用。此方法接受一个部分函数，给定未来的值，执行某些操作，如下所示：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Importantly, installing a callback is a non-blocking operation. The `log` statement
    in the main thread immediately executes after the callback is registered, but
    the `log` statement in the callback can be called much later. This is illustrated
    in the following figure:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，安装回调是一个非阻塞操作。在主线程中，回调注册后立即执行`log`语句，但回调中的`log`语句可以在很久以后被调用。这在下图中得到了说明：
- en: '![Future callbacks](img/image_04_002.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![Future回调](img/image_04_002.jpg)'
- en: Callback diagram
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 回调图
- en: Note that the callback is not necessarily invoked immediately after the future
    is completed. Most execution contexts schedule a task to asynchronously process
    the callbacks. The same is true if the future is already completed when we try
    to install a callback.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，回调不一定在未来完成后立即被调用。大多数执行上下文都会安排一个任务以异步处理回调。如果我们在尝试安装回调时未来已经完成，也是如此。
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: After the future is completed, the callback is called *eventually* and independently
    from other callbacks on the same future. The specified execution context decides
    when and on which thread the callback gets executed.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 未来的完成之后，回调最终被调用，并且独立于同一未来的其他回调。指定的执行上下文决定了回调何时以及在哪条线程上执行。
- en: There is a happens-before relationship between completing the future and starting
    the callback.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 完成未来和开始回调之间存在发生之前的关系。
- en: 'We are not limited to installing a single callback to the future. If we additionally
    want to find all the occurrences of the `password` keyword, we can install another
    callback:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅限于安装一个回调到未来。如果我们还想找到所有`password`关键字的实例，我们可以安装另一个回调：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As an experienced Scala programmer, you might have heard about referential transparency.
    Roughly speaking, a function is referentially transparent if it does not execute
    any side effects such as variable assignment, modifying mutable collections, or
    writing to the standard output. Callbacks on futures have one very useful property.
    Programs using only the `Future.apply` and `foreach` calls with referentially
    transparent callbacks are deterministic. For the same inputs, such programs will
    always compute the same results.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名经验丰富的Scala程序员，你可能听说过引用透明性。大致来说，一个函数是引用透明的，如果它不执行任何副作用，例如变量赋值、修改可变集合或写入标准输出。未来的回调有一个非常有用的特性。仅使用`Future.apply`和`foreach`调用具有引用透明回调的程序是确定性的。对于相同的输入，这些程序将始终计算相同的结果。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Programs composed from referentially transparent future computations and callbacks
    are deterministic.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由引用透明未来计算和回调组成的程序是确定性的。
- en: In the examples so far, we assumed that an asynchronous computation yielding
    a future always succeeds. However, computations occasionally fail and throw exceptions.
    We will study how to handle failures in asynchronous computations next.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们假设异步计算产生未来总是成功的。然而，计算有时会失败并抛出异常。我们将研究如何处理异步计算中的失败情况。
- en: Futures and exceptions
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未来和异常
- en: If a future computation throws an exception, then its corresponding future object
    cannot be completed with a value. Ideally, we would like to be notified when this
    happens. If you apply for a job and the employer decides to hire someone else,
    you would still like to receive a phone call. Otherwise, you might spend days
    sitting idly in front of your phone, waiting for the call from the recruiter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未来计算抛出异常，那么相应的未来对象就不能用值完成。理想情况下，我们希望在发生这种情况时得到通知。如果你申请一份工作，而雇主决定雇佣其他人，你仍然希望接到电话。否则，你可能会在电话前无所事事地坐上几天，等待招聘人员的电话。
- en: When a Scala future is completed, it can either be completed *successfully*
    or with a failure. When a future is completed with a failure, we also say that
    a future has *failed*. To summarize all the different states of a future, we show
    the following state diagram. A future is created without any associated callbacks.
    Then, any number of callbacks `f1`, `f2`, ..., `fn` can be assigned to it. When
    the future is completed, it has either completed successfully or has failed. After
    that, the future's state no longer changes, and registering a callback immediately
    schedules it for execution.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Scala 未来完成时，它可以是成功完成或失败。当一个未来以失败完成时，我们还说未来已经失败。为了总结未来的所有不同状态，我们展示了以下状态图。未来创建时没有任何关联的回调。然后，可以为它分配任意数量的回调
    `f1`、`f2`、...、`fn`。当未来完成时，它要么成功完成，要么失败。之后，未来的状态不再改变，并立即注册回调以安排其执行。
- en: '![Futures and exceptions](img/image_04_003.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![未来和异常](img/image_04_003.jpg)'
- en: 'We now take a closer look at handling the failure case. The `foreach` method
    only accepts callbacks that handle values from a successfully completed future,
    so we need another method to install failure callbacks. This method is called
    `failed`. It returns a `Future[Throwable]` object that contains the exception
    that the current object has failed with, and can be used with the `foreach` statement
    to access the exception:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们更详细地看看如何处理失败情况。`foreach` 方法只接受处理成功完成的未来的回调，因此我们需要另一个方法来安装失败回调。这个方法被称为 `failed`。它返回一个包含当前对象失败时异常的
    `Future[Throwable]` 对象，并且可以与 `foreach` 语句一起使用来访问异常：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, our asynchronous computation sends an HTTP request to an invalid
    URL. As a result, the `fromURL` method throws an exception, and the `urlSpec`
    future fails. The program then prints the exception name and message with the
    `log` statement.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的异步计算向一个无效的 URL 发送 HTTP 请求。结果，`fromURL` 方法抛出异常，`urlSpec` 未来失败。然后程序使用
    `log` 语句打印异常名称和消息。
- en: Using the Try type
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Try 类型
- en: For conciseness, sometimes we want to subscribe to both successes and failures
    in the same callback. To do this, we need to use the type `Try[T]`. The type `Try[T]` is
    very similar to the type `Option[T]` . Recall from your experience with sequential
    Scala programming that the type `Option[T]`  is used to encode a value of the
    type `T` or its absence. A value of `Option[T]` type can either be an object of
    a type `Some[T]` , which holds some value, or `None`, which does not hold anything.
    We use pattern matching to determine whether an `Option[T]` type is `Some[T]`
    or `None`. Optional types are an alternative to using `null` values, which is
    what one typically does in Java. However, the `Option[T]` type does not allow
    encoding failures in its `None` subtype. The `None` subtype tells us nothing about
    the exception in the computation. For this, we use the `Try[T]` type.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁，有时我们想在同一个回调中订阅成功和失败。为此，我们需要使用类型 `Try[T]`。类型 `Try[T]` 与类型 `Option[T]` 非常相似。回想一下你在顺序
    Scala 编程中的经验，类型 `Option[T]` 用于编码类型 `T` 的值或其不存在。`Option[T]` 类型的值可以是 `Some[T]` 类型的对象，它包含一些值，或者
    `None`，它不包含任何东西。我们使用模式匹配来确定 `Option[T]` 类型是 `Some[T]` 还是 `None`。可选类型是使用 `null`
    值的替代方案，这在 Java 中通常是这样做。然而，`Option[T]` 类型不允许在它的 `None` 子类型中编码失败。`None` 子类型告诉我们关于计算中异常的什么信息。为此，我们使用
    `Try[T]` 类型。
- en: 'The type `Try[T]` has two implementations--the type `Success[T]`, which encodes
    the results of the successful computations, and the `Failure[T]` type, which encodes
    the `Throwable` objects that failed the computation. We use pattern matching to
    determine which of the two a `Try[T]` object is:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 类型`Try[T]`有两个实现--类型`Success[T]`，它编码了成功计算的成果，以及`Failure[T]`类型，它编码了导致计算失败的`Throwable`对象。我们使用模式匹配来确定`Try[T]`对象是哪一个：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `Try[T]` objects are immutable objects used synchronously; unlike futures,
    they contain a value or an exception from the moment they are created. They are
    more akin to collections than to futures. We can even compose `Try[T]` values
    in for-comprehensions. In the following code snippet, we will compose the name
    of the current thread with some custom text:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Try[T]`对象是用于同步的不可变对象；与未来不同，它们从创建的那一刻起就包含一个值或异常。它们更类似于集合而不是未来。我们甚至可以在for推导式中组合`Try[T]`值。在下面的代码片段中，我们将组合当前线程的名称和一些自定义文本：'
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will first create two `Try[String]` values, `threadName` and `someText`,
    using the `Try.apply` factory method. The `for` comprehension extracts the thread
    name, `tn`, from the `threadName` value, and then the `st` text from the `someText`
    value. These values are then used to yield another string. If any of the `Try`
    values in the `for` comprehension fail, then the resulting `Try` value fails with
    the `Throwable` object from the first failed `Try` value. However, if all the
    `Try` values are `Success`, then the resulting `Try` value is `Success` with the
    value of the expression after the `yield` keyword. If this expression throws an
    exception, the resulting `Try` value fails with that exception.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将使用`Try.apply`工厂方法创建两个`Try[String]`值，分别是`threadName`和`someText`。`for`推导式从`threadName`值中提取线程名`tn`，然后从`someText`值中提取`st`文本。这些值随后被用来生成另一个字符串。如果在`for`推导式中任何一个`Try`值失败，那么结果`Try`值将使用第一个失败的`Try`值中的`Throwable`对象失败。然而，如果所有的`Try`值都是`Success`，那么结果`Try`值将是带有`yield`关键字之后表达式值的`Success`。如果这个表达式抛出异常，结果`Try`值将使用那个异常失败。
- en: Note that the preceding example always prints the name of the main thread. Creating
    `Try` objects and using them in `for` comprehensions always occurs on the caller
    thread.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的例子总是打印主线程的名称。创建`Try`对象并在`for`推导式中使用它们总是在调用者线程上发生的。
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike `Future[T]` values, `Try[T]` values are manipulated synchronously.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Future[T]`值不同，`Try[T]`值是同步操作的。
- en: 'In most cases, we use the `Try` values in pattern matching. When calling the
    `onComplete` callback, we will provide a partial function that matches the `Success`
    and `Failure` values. Our example for fetching the URL specification is as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们使用`Try`值进行模式匹配。在调用`onComplete`回调时，我们将提供一个部分函数来匹配`Success`和`Failure`值。我们获取URL规范的示例如下：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Fatal exceptions
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 致命异常
- en: 'We have seen futures storing exceptions that caused them to fail. However,
    there are some `Throwable` objects that a future computation does not catch. In
    the following short program, the callback on the `f` future is never invoked.
    Instead, the stack trace of `InterruptedException` exception is printed on the
    standard error output:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到未来存储了导致它们失败的异常。然而，有一些`Throwable`对象是未来计算无法捕获的。在以下简短的程序中，`f`未来的回调永远不会被调用。相反，`InterruptedException`异常的堆栈跟踪被打印到标准错误输出：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `InterruptedException` exception and some severe program errors such as
    `LinkageError`, `VirtualMachineError`, `ThreadDeath`, and Scala''s `ControlThrowable`
    error are forwarded to the execution context''s `reportFailure` method introduced
    in [Chapter 3](ch03.html "Chapter 3. Traditional Building Blocks of Concurrency"),
    *Traditional Building Blocks of Concurrency*. These types of `Throwable` object
    are called **fatal errors**. To find out if a `Throwable` object will be stored
    in a `Future` instance, you can pattern match the `Throwable` object with the
    `NonFatal` extractor:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`InterruptedException`异常和一些严重的程序错误，如`LinkageError`、`VirtualMachineError`、`ThreadDeath`和Scala的`ControlThrowable`错误，会被转发到执行上下文的`reportFailure`方法，该方法在[第3章](ch03.html
    "第3章。并发传统构建块")中介绍，*并发传统构建块*。这些类型的`Throwable`对象被称为**致命错误**。要找出一个`Throwable`对象是否会被存储在`Future`实例中，你可以使用`NonFatal`提取器与`Throwable`对象进行模式匹配：'
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that you never need to manually match in order to see whether errors in
    your futures are nonfatal. Fatal errors are automatically forwarded to the execution
    context.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你永远不需要手动匹配来查看你的未来中的错误是否是非致命的。致命错误会自动转发到执行上下文。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Future computations do not catch fatal errors. Use the `NonFatal` extractor
    to pattern match against nonfatal errors.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Future计算不会捕获致命错误。使用`NonFatal`提取器来对非致命错误进行模式匹配。
- en: Functional composition on futures
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: futures上的函数式组合
- en: Callbacks are useful, but they can make reasoning about control flow difficult
    when programs become larger. They also disallow certain patterns in asynchronous
    programming in particular, it is cumbersome to use a callback to subscribe to
    multiple futures at once. Luckily, Scala futures have an answer to these problems
    called **functional composition**. Functional composition on futures allows using
    futures inside `for` comprehensions, and is often more intuitive to use than callbacks.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 回调很有用，但当程序变得更大时，它们可能会使关于控制流的推理变得困难。它们还禁止异步编程中的一些特定模式，特别是同时订阅多个未来的回调使用起来很繁琐。幸运的是，Scala的futures有针对这些问题的解决方案，称为**函数式组合**。在futures上的函数式组合允许在`for`循环中使用futures，并且通常比回调更直观易用。
- en: Introducing futures transfers the responsibility for blocking from the API to
    the caller. The `foreach` method helps you to avoid blocking altogether. It also
    eliminates non-determinism inherent to polling methods such as `isCompleted` and
    `value`. Still, there are some situations when the `foreach` statement is not
    the best solution.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 引入futures将阻塞的责任从API转移到调用者。`foreach`方法帮助你完全避免阻塞。它还消除了`isCompleted`和`value`等轮询方法固有的非确定性。尽管如此，在某些情况下，`foreach`语句并不是最佳解决方案。
- en: Let's say that we want to implement some of the functionality from the Git version
    control system; we want to use the `.gitignore` file to find files in our project
    tree that should not be versioned. We simplify our task by assuming that the `.gitignore`
    file only contains a list of prefixes for blacklisted file paths, and no regular
    expressions.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要实现Git版本控制系统中的一些功能；我们想要使用`.gitignore`文件来找到我们的项目树中不应进行版本控制的文件。我们通过假设`.gitignore`文件只包含黑名单文件路径的前缀列表，而不包含正则表达式来简化我们的任务。
- en: 'We perform two asynchronous actions. First, we fetch the contents of our `.gitignore`
    file in a future computation. Then, using its contents, we will asynchronously
    scan all the files in our project directory and match them. We will start by importing
    the packages necessary for file handling. In addition to the `scala.io.Source`
    object, we use the `java.io` package and the `apache.commons.io.FileUtils` class,
    and import them as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行两个异步操作。首先，我们在future计算中获取`.gitignore`文件的内容。然后，使用其内容，我们将异步扫描我们的项目目录中的所有文件并进行匹配。我们将首先导入必要的文件处理包。除了`scala.io.Source`对象外，我们还使用`java.io`包和`apache.commons.io.FileUtils`类，并按如下方式导入它们：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you haven''t already added the dependency on Commons IO to your `build.sbt`
    file in the previous chapters, now is a good time to introduce the following line:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有在前面章节的`build.sbt`文件中添加对Commons IO的依赖项，现在是引入以下行的好时机：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will first create a future using the `blacklistFile` method, which reads
    the contents of the `.gitignore` file. Given the pace at which technology is evolving
    these days, we never know when a different version control system will become
    more popular; so we add the `name` parameter for the name of the blacklist file.
    We filter out the empty lines and all the comment lines starting with a `#` sign.
    We then convert them to a list, as shown in the following code snippet:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`blacklistFile`方法创建一个future，该方法读取`.gitignore`文件的内容。鉴于技术目前的发展速度，我们永远不知道何时不同的版本控制系统会变得更加流行；因此，我们添加了`name`参数来指定黑名单文件的名称。我们过滤掉空行和所有以`#`符号开始的注释行。然后我们将它们转换为列表，如下面的代码片段所示：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In our case, the future returned by the `blacklistFile` method eventually contains
    a list with a single string, the `target` directory is where SBT stores files
    created by the Scala compiler. Then, we implement another method named `findFiles`
    that, given a list of patterns, finds all the files in the current directory containing
    these patterns. The `iterateFiles` method from the Commons IO library returns
    a Java iterator over the project files, so we can convert it to a Scala iterator
    by calling `asScala`. We then yield all the matching file paths:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，`blacklistFile`方法返回的future最终包含一个包含单个字符串的列表，目标目录是SBT存储由Scala编译器创建的文件的地方。然后，我们实现另一个名为`findFiles`的方法，该方法接受一个模式列表，并找到当前目录中包含这些模式的所有文件。Commons
    IO库的`iterateFiles`方法返回一个Java迭代器，遍历项目文件，因此我们可以通过调用`asScala`将其转换为Scala迭代器。然后我们产生所有匹配的文件路径：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we now want to list blacklisted files, we first need to call `foreach` on
    the `blacklistFile` future, and call `findPatterns` from inside the callback,
    as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在想要列出黑名单文件，我们首先需要在`blacklistFile`未来上调用`foreach`，然后在回调内部调用`findPatterns`，如下所示：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Assume your fellow developer now asks you to implement another `blacklisted`
    method that takes the name of the blacklist file and returns a future with a list
    of blacklisted files. This allows us to specify the callback independently in
    the program; instead of printing the files to the standard output, another part
    of the program can, for example, create a safety backup of the blacklisted files
    using the following method:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的同事现在要求你实现另一个接受黑名单文件名称并返回包含黑名单文件列表的未来的`blacklisted`方法。这允许我们在程序中独立指定回调；而不是将文件打印到标准输出，程序的另一部分可以，例如，使用以下方法创建黑名单文件的安全备份：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Being an experienced object-oriented developer, you'd like to reuse the `blacklistFile`
    future and the `findFiles` method. After all, the functionality is already there.
    We challenge you to reuse the existing methods to implement the new `blacklisted`
    method. Try to use the `foreach` statement. You will find this task extremely
    difficult.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名经验丰富的面向对象开发者，你希望重用`blacklistFile`未来和`findFiles`方法。毕竟，功能已经存在了。我们挑战你使用现有方法来实现新的`blacklisted`方法。尝试使用`foreach`语句。你会发现这项任务极其困难。
- en: 'So far, we haven''t seen methods that produce new futures using the values
    in existing futures. The `Future` trait has a `map` method that maps the value
    in one future to a value in another future:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有看到使用现有未来的值生成新未来的方法。`Future`特质有一个`map`方法，它将一个未来的值映射到另一个未来的值：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This method is non blocking--it returns the `Future[S]` object immediately.
    After the original future completes with some value `x`, the returned `Future[S]`
    object is eventually completed with `f(x)`. With the `map` method, our task is
    trivial: we transform the patterns into a list of matching files by calling the
    `findFiles` method:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法是非阻塞的--它立即返回`Future[S]`对象。在原始未来完成并带有某些值`x`之后，返回的`Future[S]`对象最终会完成并带有`f(x)`。使用`map`方法，我们的任务很简单：通过调用`findFiles`方法将模式转换成匹配文件列表：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As a Scala developer, you know that a `map` operation on a collection transforms
    many elements into a new collection. To more easily comprehend operations such
    as the `map` operation on futures, you can consider a future as a specific form
    of collection that contains at most one element.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Scala开发者，你知道在集合上执行`map`操作会将多个元素转换成一个新的集合。为了更容易理解像`map`操作这样的操作，你可以将未来视为一种特定的集合形式，该集合最多包含一个元素。
- en: '**Functional composition** is a programming pattern in which simpler values
    are composed into more complex ones by means of higher-order functions called
    **combinators**. Functional composition on Scala collections should be familiar
    to you from sequential Scala programming. For example, the `map` method on a collection
    produces a new collection containing elements from the original collection, mapped
    with a specified function.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数组合**是一种编程模式，通过称为**组合子**的高阶函数将更简单的值组合成更复杂的值。Scala集合上的函数组合应该对你来说很熟悉，来自顺序Scala编程。例如，集合上的`map`方法会产生一个新的集合，包含来自原始集合的元素，这些元素通过指定的函数进行映射。'
- en: Functional composition on futures is similar; we can produce new futures by
    transforming or merging existing futures, as in the preceding example. Callbacks
    are useful, but they do not directly allow functional composition in the way combinators
    such as `map` do. Just as with callbacks, a function passed to a combinator is
    never invoked before the corresponding future completes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 未来的函数组合与之前类似；我们可以通过转换或合并现有未来来生成新未来，就像前面的例子一样。回调很有用，但它们并不直接允许像`map`这样的组合子进行函数组合。就像回调一样，传递给组合子的函数在相应的未来完成之前永远不会被调用。
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is a happens-before relationship between completing the future and invoking
    the function in any of its combinators.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 完成未来和调用其组合子中的任何函数之间存在一种“先发生”的关系。
- en: Choosing between alternative ways to handle futures can be confusing. When should
    we use functional composition in place of callbacks? A good rule of thumb is to
    use callbacks for side-effecting actions that depend on a single future. In all
    other situations, we can use functional composition.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理未来的不同方法之间进行选择可能会令人困惑。我们应该在什么情况下使用函数组合而不是回调？一个好的经验法则是，对于依赖于单个未来的副作用操作，应使用回调。在所有其他情况下，我们可以使用函数组合。
- en: Tip
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When an action in the program depends on the value of a single future, use callbacks
    on futures. When subsequent actions in the program depend on values of multiple
    futures or produce new futures, use functional composition on futures.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序中的某个操作依赖于单个未来的值时，使用未来的回调。当程序中的后续操作依赖于多个未来的值或产生新的未来时，使用未来的函数组合。
- en: Let us consider several crucial combinators for functional composition. The
    `map` method on a `Future[T]` takes an `f` function and returns a new `Future[S]`
    future. After the `Future[T]` is completed, the `Future[S]` is completed by applying
    `f` to the value in `Future[T]`. If `Future[T]` fails with an exception `e`, or
    the mapping function `f` throws an exception `e`, then `Future[S]` also fails
    with that exception `e`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑几个关键的组合器，用于函数组合。`Future[T]` 上的 `map` 方法接受一个 `f` 函数并返回一个新的 `Future[S]` 未来。在
    `Future[T]` 完成之后，通过将 `f` 应用到 `Future[T]` 中的值来完成 `Future[S]`。如果 `Future[T]` 因异常
    `e` 失败，或者映射函数 `f` 抛出异常 `e`，那么 `Future[S]` 也会因该异常 `e` 失败。
- en: 'Recall that Scala allows using for-comprehensions on objects that have a `map`
    method, so we can use futures in for-comprehensions. Let''s assume that we want
    to get the future with the longest line from our `build.sbt` file. The computation
    proceeds in two steps. First, we read in the lines from the disk, and then we
    call the `maxBy` method to get the longest line:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，Scala 允许在具有 `map` 方法的对象上使用 `for` 表达式，因此我们可以在 `for` 表达式中使用未来。假设我们想要从我们的
    `build.sbt` 文件中获取具有最长行的未来。计算分为两个步骤进行。首先，我们从磁盘读取行，然后调用 `maxBy` 方法来获取最长行：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `longest` declaration is desugared by the Scala compiler into the following
    line:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`longest` 声明被 Scala 编译器转换为以下行：'
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The real advantage of `for` comprehensions becomes apparent when we use the
    `flatMap` combinator, which has the following signature:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `flatMap` 组合器时，`for` 表达式的真正优势才会显现出来，该组合器的签名如下：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `flatMap` combinator uses the current future with the `Future[T]` type to
    produce another future with the type `Future[S]` . The resulting `Future[S]` is
    completed by taking the value `x` of the type `T` from the current future, and
    mapping that value to another future `f(x)`. While the future resulting from a
    `map` method completes when the mapping function `f` completes, the future resulting
    from a `flatMap` method completes when both `f` and the future returned by `f`
    complete.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap` 组合器使用当前具有 `Future[T]` 类型的未来来产生另一个具有类型 `Future[S]` 的未来。结果 `Future[S]`
    通过从当前未来中获取类型 `T` 的值 `x` 并将该值映射到另一个未来 `f(x)` 来完成。当 `map` 方法的结果未来完成时，映射函数 `f` 也完成了，而
    `flatMap` 方法的结果未来在 `f` 和 `f` 返回的未来都完成时才完成。'
- en: 'To understand how this combinator is useful, let''s consider the following
    example. Assume that your job application went well and you got that new job you
    were hoping for. On the first day of work, you receive a chain e-mail from your
    secretary. The chain e-mail claims that you should never open URLs starting with
    `ftp://`, because all of them contain viruses. As a skillful techie with a lot
    of experience, you quickly recognize the chain letter for what it is--a scam.
    You, therefore, decide to enlighten your secretary by sending her instructions
    on how to communicate using e-mails, and an explanation of what FTP links are.
    You write a short program that replies asynchronously. You''ve got better things
    to do than to spend your day writing e-mails:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这个组合器的有用性，让我们考虑以下示例。假设你的求职申请进展顺利，你得到了你一直希望得到的新工作。在工作的第一天，你从你的秘书那里收到了一封连锁电子邮件。这封连锁电子邮件声称你永远不应该打开以
    `ftp://` 开头的 URL，因为它们都包含病毒。作为一个经验丰富的技术高手，你很快就能识别出这封连锁信是骗局。因此，你决定通过发送给她如何使用电子邮件进行通信的说明以及
    FTP 链接的解释来启发你的秘书。你编写了一个简短的异步回复程序。你有很多比整天写电子邮件更重要的事情要做：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This program asynchronously fetches the good old **RFC 1855**--the guidelines
    for e-mail communication or netiquette. It then asynchronously fetches the URL
    specification with information on the `ftp` schema. The program attempts to concatenate
    the two texts. It calls `flatMap` on the `netiquette` future. Based on the `nettext`
    value in the `netiquette` future, the `flatMap` future needs to return another
    future. It could return the `urlSpec` future directly, but the resulting future,
    `answer`, would then be completed with just the URL specification. Instead, we
    can call the `map` combinator on the `urlSpec` future; we map its value, `urltext`,
    into the concatenation of the `nettext` and `urltext` values. This results in
    another intermediate future holding the concatenation; once this future is completed,
    the `answer` future is completed as well. Graphically, this looks as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序异步地获取了古老的**RFC 1855**——电子邮件通信或网络礼仪的指南。然后它异步地获取了包含`ftp`方案信息的URL规范。程序尝试连接这两个文本。它在`netiquette`期货上调用`flatMap`。根据`netiquette`期货中的`nettext`值，`flatMap`期货需要返回另一个期货。它可以直接返回`urlSpec`期货，但结果期货`answer`将只包含URL规范。相反，我们可以在`urlSpec`期货上调用`map`组合器；我们将它的值`urltext`映射到`nettext`和`urltext`值的连接中。这导致另一个中间期货持有连接；一旦这个期货完成，`answer`期货也完成了。从图形上看，这看起来如下：
- en: '![Functional composition on futures](img/image_04_004.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![功能组合在期货上](img/image_04_004.jpg)'
- en: 'If you look at this execution diagram from a distance, you will notice that
    there is an inherent ordering between asynchronous computations. We can capture
    these relationships in a graph, as shown in the following figure:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从远处看这个执行图，你会注意到异步计算之间存在固有的顺序。我们可以在以下图中捕获这些关系：
- en: '![Functional composition on futures](img/image_04_005.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![功能组合在期货上](img/image_04_005.jpg)'
- en: This graph is called the **dataflow graph**, because it describes how the data
    flows from one future to another. Futures are represented with vertices and asynchronous
    computations are directed edges between them. An edge points from one vertex to
    another if the value of future in the first vertex is used to compute the value
    of future in the second vertex. In this graph, futures produced by `Future.apply`
    are source vertices-they have only outward edges. Various future combinators such
    as `map` and `flatMap` connect different vertices. Callback functions such as
    `foreach` lead to sink vertices-they have no outward edges. Some combinators,
    such as `flatMap`, can use values from multiple vertices.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图被称为**数据流图**，因为它描述了数据如何从一个期货流向另一个期货。期货用顶点表示，异步计算用它们之间的有向边表示。如果第一个顶点中期货的值用于计算第二个顶点中期货的值，则边从第一个顶点指向第二个顶点。在这个图中，由`Future.apply`产生的期货是源顶点——它们只有向外边。各种期货组合器，如`map`和`flatMap`，连接不同的顶点。回调函数，如`foreach`，导致汇点——它们没有向外边。一些组合器，如`flatMap`，可以使用多个顶点的值。
- en: Tip
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'The `flatMap` combinator combines two futures into one: the one on which the
    `flatMap` combinator is invoked and the one that is returned by the argument function.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap`组合器将两个期货合并为一个：调用`flatMap`组合器的那个期货和由参数函数返回的那个期货。'
- en: 'There are two issues with our e-mail example. First, we should be nicer to
    our new secretary; she''s not a techie like we are. Second, using `flatMap` directly
    makes the program hard to understand. There are not many developers in the Scala
    community that use `flatMap` like this. Instead, `flatMap` should be used implicitly
    in `for` comprehensions:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的电子邮件示例中存在两个问题。首先，我们应该对我们新来的秘书更加友好；她不像我们那样是技术人士。其次，直接使用`flatMap`使得程序难以理解。在Scala社区中，使用`flatMap`像这样使用的人并不多。相反，`flatMap`应该在`for`循环理解中隐式使用：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After desugaring, this `for` comprehension is identical to what we had before.
    This is much simpler; the program now almost reads itself. For the `nettext` value
    of the `netiquette` future and the `urltext` value of the `urlSpec` future, the
    `answer` future is a new future with the concatenation of `nettext` and `urltext`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在去糖化之后，这个`for`循环理解与之前我们所拥有的相同。这要简单得多；现在程序几乎可以自读。对于`netiquette`期货的`nettext`值和`urlSpec`期货的`urltext`值，`answer`期货是一个新的期货，它是`nettext`和`urltext`的连接。
- en: Tip
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You should prefer for-comprehensions to using `flatMap` directly to make programs
    more concise and understandable.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该优先使用`for`循环理解而不是直接使用`flatMap`，以使程序更加简洁和易于理解。
- en: 'Note that the following for-comprehension looks very similar to what we had
    before, but it is not equivalent:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，以下for-comprehension看起来与我们之前看到的一样，但它并不等价：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding code, the `nettext` value is extracted from the first future.
    Only after the first future is completed, the second future computation start.
    This is useful when the second asynchronous computation uses `nettext`, but in
    our case fetching the `netiquette` document and the URL specification can proceed
    concurrently.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，从第一个未来中提取了`nettext`值。只有当第一个未来完成之后，第二个未来的计算才开始。这在第二个异步计算使用`nettext`时很有用，但在我们的情况下，获取`netiquette`文档和URL规范可以并行进行。
- en: 'So far, we have only considered future combinators that work with successful
    futures. When any of the input futures fail or the computation in the combinator
    throws an exception, the resulting future fails with the same exception. In some
    situations, we want to handle the exception in the future in the same way as we
    handle exceptions with a `try-catch` block in sequential programming. A combinator
    that is helpful in these situations is called `recover`. Its simplified signature
    is as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只考虑了与成功未来一起工作的未来组合器。当任何输入未来失败或组合器中的计算抛出异常时，结果未来会以相同的异常失败。在某些情况下，我们希望像在顺序编程中使用`try-catch`块处理异常一样处理未来的异常。在这些情况下有帮助的组合器称为`recover`。它的简化签名如下：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When this combinator is called on a future, which is successfully completed
    with some value `x` of the type `T`, the resulting future is completed with the
    same value `x`. On the other hand, if a future fails, then the `pf` partial function
    is applied to the `Throwable` object that failed it. If the `pf` partial function
    is not defined for the `Throwable` object, then the resulting future is failed
    with the same `Throwable` object. Otherwise, the resulting future is completed
    with the result of applying `pf` to the `Throwable` object. If the `pf` partial
    function itself throws an exception, the resulting future is completed with that
    exception.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个组合器在一个成功完成某个类型`T`的值`x`的未来上被调用时，结果未来会以相同的值`x`完成。另一方面，如果一个未来失败，那么`pf`部分函数会被应用到导致它失败的那个`Throwable`对象上。如果`pf`部分函数没有为`Throwable`对象定义，那么结果未来会以相同的`Throwable`对象失败。否则，结果未来会以将`pf`应用到`Throwable`对象上的结果完成。如果`pf`部分函数本身抛出异常，那么结果未来会以那个异常完成。
- en: 'Let''s assume you''re worried about misspelling the URL for the `netiquette`
    document. You can use the `recover` combinator on the `netiquette` future to provide
    a reasonable default message if anything fails, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你担心拼写`netiquette`文档的URL出错。你可以在`netiquette`未来上使用`recover`组合器来提供一个合理的默认消息，如果发生任何错误，如下所示：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Futures come with other combinators such as `filter`, `fallbackTo`, or `zip`,
    but we will not cover all of them here; an understanding of the basic combinators
    should be sufficient. You might wish to study the remaining combinators in the
    API documentation.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 未来还有其他组合器，如`filter`、`fallbackTo`或`zip`，但在这里我们不会涵盖所有这些；对基本组合器的理解应该足够了。你可能希望研究API文档中剩余的组合器。
- en: Promises
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 承诺
- en: 'In [Chapter 2](ch02.html "Chapter 2. Concurrency on the JVM and the Java Memory
    Model"), *Concurrency on the JVM and the Java Memory Model*, we implemented an
    `asynchronous` method that used a worker thread and a task queue to receive and
    execute asynchronous computations. That example should have left you with a basic
    intuition about how the `execute` method is implemented in execution contexts.
    You might be wondering how the `Future.apply` method can return and complete a
    `Future` object. We will study promises in this section to answer this question.
    **Promises** are objects that can be assigned a value or an exception only once.
    This is why promises are sometimes also called single-assignment variables. A
    promise is represented with the `Promise[T]` type in Scala. To create a promise
    instance, we use the `Promise.apply` method on the `Promise` companion object:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。JVM和Java内存模型上的并发")中，*JVM和Java内存模型上的并发*，我们实现了一个使用工作线程和任务队列接收和执行异步计算的`异步`方法。这个例子应该让你对`execute`方法在执行上下文中的实现有了基本的直觉。你可能想知道`Future.apply`方法如何返回并完成一个`Future`对象。我们将在本节中研究承诺来回答这个问题。**承诺**是只能赋予一个值或一个异常一次的对象。这就是为什么承诺有时也被称为单赋值变量。在Scala中，承诺用`Promise[T]`类型表示。要创建承诺实例，我们使用`Promise`伴生对象的`Promise.apply`方法：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This method returns a new promise instance. Like the `Future.apply` method,
    the `Promise.apply` method returns immediately; it is non-blocking. However, the
    `Promise.apply` method does not start an asynchronous computation; it just creates
    a fresh promise object. When the promise object is created, it does not contain
    a value or an exception. To assign a value or an exception to a promise, we use
    the `success` or `failure` method, respectively.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回一个新的承诺实例。与`Future.apply`方法一样，`Promise.apply`方法立即返回；它是非阻塞的。然而，`Promise.apply`方法并不启动异步计算；它只是创建一个新的承诺对象。当承诺对象被创建时，它不包含值或异常。要分配值或异常给承诺，我们分别使用`success`或`failure`方法。
- en: Perhaps you have noticed that promises are very similar to futures. Both futures
    and promises are initially empty and can be completed with either a value or an
    exception. This is intentional; every promise object corresponds to exactly one
    future object. To obtain the future associated with a promise, we can call the
    `future` method on the promise. Calling this method multiple times always returns
    the same future object.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你已经注意到承诺与未来非常相似。未来和承诺最初都是空的，可以用值或异常来完成。这是故意的；每个承诺对象都对应于一个确切的未来对象。要获取与承诺关联的未来，我们可以在承诺上调用`future`方法。调用此方法多次始终返回相同的未来对象。
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A promise and a future represent two aspects of a single--assignment variable--the
    promise allows you to assign a value to the future object, whereas the future
    allows you to read that value.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺和未来代表单个赋值变量的两个方面——承诺允许你将值分配给未来对象，而未来允许你读取那个值。
- en: 'In the following code snippet, we create two promises, `p` and `q`, that can
    hold string values. We then install a `foreach` callback on the future associated
    with the `p` promise and wait for one second. The callback is not invoked until
    the `p` promise is completed by calling the `success` method. We then fail the
    `q` promise in the same way and install a `failed.foreach` callback:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们创建了两个可以包含字符串值的承诺，`p`和`q`。然后我们在与`p`承诺关联的未来上安装了一个`foreach`回调并等待一秒钟。回调只有在调用`success`方法完成`p`承诺时才会被调用。然后我们以相同的方式失败`q`承诺并安装一个`failed.foreach`回调：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Alternatively, we can use the `complete` method and specify a `Try[T]` object
    to complete the promise. Depending on whether the `Try[T]` object is a success
    or a failure, the promise is successfully completed or failed. Importantly, after
    a promise is either successfully completed or failed, it cannot be assigned an
    exception or a value again in any way. Trying to do so results in an exception.
    Note that this is true even when there are multiple threads simultaneously calling
    `success` or `complete`. Only one thread completes the promise, and the rest throw
    an exception.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`complete`方法并指定一个`Try[T]`对象来完成承诺。根据`Try[T]`对象是成功还是失败，承诺将成功完成或失败。重要的是，一旦承诺成功完成或失败，就不能以任何方式再次分配异常或值。尝试这样做会导致异常。注意，即使在有多个线程同时调用`success`或`complete`时，这也是正确的。只有一个线程完成承诺，其余的抛出异常。
- en: Note
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Assigning a value or an exception to an already completed promise is not allowed
    and throws an exception.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 将值或异常分配给已完成的承诺是不允许的，并且会抛出异常。
- en: We can also use the `trySuccess`, `tryFailure`, and `tryComplete` methods that
    correspond to `success`, `failure`, and `complete`, respectively, but return a
    Boolean value to indicate whether the assignment was successful. Recall that using
    `Future.apply` and callback methods with referentially transparent functions results
    in deterministic concurrent programs. As long as we do not use the `trySuccess`,
    `tryFailure`, and `tryComplete` methods, and none of the `success`, `failure`,
    and `complete` methods ever throw an exception, we can use promises and retain
    determinism in our programs.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用与`success`、`failure`和`complete`相对应的`trySuccess`、`tryFailure`和`tryComplete`方法，但返回一个布尔值以指示分配是否成功。回想一下，使用`Future.apply`和具有引用透明函数的回调方法会产生确定性的并发程序。只要我们不使用`trySuccess`、`tryFailure`和`tryComplete`方法，并且`success`、`failure`和`complete`方法中没有任何一个抛出异常，我们就可以使用承诺并在我们的程序中保持确定性。
- en: 'We now have everything we need to implement our custom `Future.apply` method.
    We call it `myFuture` in the following example. The `myFuture` method takes a
    `b` by-name parameter that is the asynchronous computation. First, it creates
    a `p` promise. Then, it starts an asynchronous computation on the `global` execution
    context. This computation tries to evaluate `b` and complete the promise. However,
    if the `b` body throws a nonfatal exception, the asynchronous computation fails
    the promise with that exception. In the meanwhile, the `myFuture` method returns
    the future immediately after starting the asynchronous computation:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有了实现自定义`Future.apply`方法所需的一切。在下面的例子中，我们将其称为`myFuture`。`myFuture`方法接受一个名为`b`的按名参数，它是异步计算。首先，它创建一个`p`承诺。然后，它在`global`执行上下文中启动异步计算。这个计算尝试评估`b`并完成承诺。然而，如果`b`的主体抛出一个非致命异常，异步计算将使用该异常失败承诺。同时，`myFuture`方法在启动异步计算后立即返回未来：
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is a common pattern when producing futures. We create a promise, let some
    other computation complete that promise, and return the corresponding future.
    However, promises were not invented just for our custom future computation method,
    `myFuture`. In the following sections, we will study use cases in which promises
    are useful.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在生成未来时的一个常见模式。我们创建一个承诺，让其他计算完成该承诺，并返回相应的未来。然而，承诺并非仅仅是为了我们的自定义未来计算方法`myFuture`而发明的。在接下来的章节中，我们将研究承诺有用的用例。
- en: Converting callback-based APIs
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换基于回调的API
- en: Scala futures are great. We already saw how they can be used to avoid blocking.
    We have learned that callbacks help us to avoid polling and busy-waiting. We witnessed
    that futures compose well with functional combinators and `for` comprehensions.
    In some cases, futures and promises even guarantee deterministic programs. But,
    we have to face the truth-not all legacy APIs were created using Scala futures.
    Although futures are now the right way to do asynchronous computing, various third-party
    libraries have different approaches to encoding latency.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Scala的未来非常出色。我们已经看到它们如何被用来避免阻塞。我们已经了解到回调帮助我们避免轮询和忙等待。我们见证了未来与函数组合子和`for`循环很好地结合。在某些情况下，未来和承诺甚至可以保证确定性程序。但是，我们必须面对现实——并非所有遗留API都是使用Scala未来创建的。尽管现在异步计算的正确方式是使用未来，但各种第三方库对编码延迟的方法各不相同。
- en: Legacy frameworks deal with latency in the program with raw callbacks. Methods
    that take an unbounded amount of time to complete do not return the result; instead,
    they take a callback argument, which is invoked with the result later. JavaScript
    libraries and frameworks are a good example for this--there is a single thread
    executing a JavaScript program and it is unacceptable to block that thread every
    time we call a blocking method.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 遗留框架通过原始回调处理程序中的延迟。那些需要无限时间才能完成的方法不会返回结果；相反，它们接受一个回调参数，稍后用结果调用该参数。JavaScript库和框架是这方面的好例子——有一个线程在执行JavaScript程序，每次调用阻塞方法时阻塞该线程都是不可接受的。
- en: Such legacy systems have issues in large-scale development. First, they do not
    nicely compose, as we already saw. Second, they are hard to understand and reason
    about; a bunch of unstructured callbacks feels almost like spaghetti code. The
    control flow of the program is not apparent from the code, but is dictated by
    the internals of the library. This is called **inversion of control**. We would
    like to somehow create a bridge between legacy callback-based APIs and futures,
    and avoid this inversion of control. This is where promises come in handy.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的遗留系统在大规模开发中存在问题。首先，它们没有很好地组合，正如我们之前看到的。其次，它们难以理解和推理；一大堆无结构的回调几乎就像意大利面代码。程序的流程控制从代码中不明显，而是由库的内部机制决定。这被称为**控制反转**。我们希望
    somehow 在遗留基于回调的API和未来之间建立桥梁，并避免这种控制反转。这正是承诺派上用场的地方。
- en: Tip
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Use promises to bridge the gap between callback-based APIs and futures.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用承诺来弥合基于回调的API和未来之间的差距。
- en: 'Let''s consider the `org.apache.commons.io.monitor` package from the **Commons
    IO** library. This package allows subscribing to filesystem events such as file
    and directory creation and deletion. Having become well versed in the use of futures,
    we do not want to deal with this API directly anymore. We, therefore, implement
    a `fileCreated` method that takes a directory name and returns a future with the
    name of the first file in that freshly created directory:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑来自 **Commons IO** 库的 `org.apache.commons.io.monitor` 包。这个包允许订阅文件系统事件，如文件和目录的创建和删除。由于我们已经熟练掌握了未来的使用，我们不想再直接处理这个
    API。因此，我们实现了一个 `fileCreated` 方法，它接受一个目录名并返回一个包含该新创建目录中第一个文件名称的未来：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To subscribe to a filesystem event using this package, we first need to instantiate
    a `FileAlterationMonitor` object. This object periodically scans the filesystem
    for changes. After that, we need to create a `FileAlterationObserver` object,
    which observes a specific directory for changes. Finally, we create a `FileAlterationListenerAdaptor`
    object, which represents the callback. Its `onFileCreate` method is called when
    a file is created in the filesystem; we use it to complete the promise with the
    name of the file that was changed:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个包订阅文件系统事件，我们首先需要实例化一个 `FileAlterationMonitor` 对象。这个对象定期扫描文件系统以查找更改。之后，我们需要创建一个
    `FileAlterationObserver` 对象，它观察特定目录的更改。最后，我们创建一个 `FileAlterationListenerAdaptor`
    对象，它代表回调。当文件系统中有文件被创建时，会调用它的 `onFileCreate` 方法；我们使用它来完成包含已更改文件名称的承诺：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Notice that the structure of this method is the same as the structure of the
    `myFuture` method. We first create a promise and defer the completion of the promise
    to some other computation. Then, we return the future associated with the promise.
    This recurring pattern is called the future-callback bridge.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个方法的结构与 `myFuture` 方法结构相同。我们首先创建一个承诺，并将承诺的完成推迟到其他一些计算。然后，我们返回与承诺关联的未来。这种重复出现的模式被称为未来-回调桥接。
- en: 'We can now use the future to subscribe to the first file change in the filesystem.
    We add a `foreach` call to the future returned by the `fileCreated` method, create
    a new file in the editor, and witness how the program detects a new file:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用这个未来来订阅文件系统的第一个文件更改。我们在 `fileCreated` 方法返回的未来上添加一个 `foreach` 调用，在编辑器中创建一个新文件，并观察程序如何检测到新文件：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'A useful utility that is not available on futures is the `timeout` method.
    We want to call a `timeout` method that takes some number of `t` milliseconds and
    returns a future that is completed after at least `t` milliseconds. We apply the
    callback-future bridge to the `Timer` class from the `java.util` package. We use
    a single timer object for all the `timeout` calls:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一个在未来的 API 中不可用的有用实用工具是 `timeout` 方法。我们想要调用一个 `timeout` 方法，它接受一些 `t` 毫秒数并返回一个至少
    `t` 毫秒后完成的未来。我们将回调-未来桥接应用于 `java.util` 包中的 `Timer` 类。我们使用单个计时器对象来处理所有的 `timeout`
    调用：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Again, we first create a promise `p`. This promise holds no useful information
    other than the fact that it is completed, so we give it the type `Promise[Unit]` .
    We then call the `Timer` class''s `schedule` method with a `TimerTask` object
    that completes the `p` promise after `t` milliseconds:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们首先创建一个承诺 `p`。这个承诺除了表明它已完成之外，不包含任何有用的信息，所以我们给它赋予类型 `Promise[Unit]`。然后，我们使用一个在
    `t` 毫秒后完成 `p` 承诺的 `TimerTask` 对象调用 `Timer` 类的 `schedule` 方法：
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The future returned by the `timeout` method can be used to install a callback,
    or it can be combined with other futures using combinators. In the next section,
    we will introduce new combinators for this purpose.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeout` 方法返回的未来可以用来安装一个回调，或者它可以与其他未来使用组合器进行组合。在下一节中，我们将介绍为此目的而创建的新组合器。'
- en: Extending the future API
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展未来 API
- en: 'Usually, the existing future combinators are sufficient for most tasks, but
    occasionally we want to define new ones. This is another use case for promises.
    Assume that we want to add a combinator to futures, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，现有的未来组合器足够用于大多数任务，但偶尔我们想要定义新的组合器。这是承诺的另一个用例。假设我们想要为未来添加一个组合器，如下所示：
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This method returns a new future of the same type that is assigned the value
    of the `this` future or the `that` future, whichever is completed first. We cannot
    add this method directly to the `Future` trait because futures are defined in
    the Scala standard library, but we can create an implicit conversion that adds
    this method. Recall that, if you call a nonexistent `xyz` method on an object
    of some type `A`, the Scala compiler will search for all implicit conversions
    from type `A`  to some other type that has the `xyz` method. One way to define
    such an implicit conversion is to use Scala''s implicit classes:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回一个与同一类型的新`Future`，该`Future`被分配了`this` `Future`或`that` `Future`的值，取决于哪个先完成。我们无法直接将此方法添加到`Future`特质中，因为`Future`是在Scala标准库中定义的，但我们可以创建一个隐式转换来添加此方法。回想一下，如果你在某种类型`A`的对象上调用一个不存在的`xyz`方法，Scala编译器将搜索从类型`A`到具有`xyz`方法的某些其他类型的所有隐式转换。定义此类隐式转换的一种方法是用Scala的隐式类：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The implicit `FutureOps` class converts a future of type `Future[T]`  to an
    object with an additional `or` method. Inside the `FutureOps` object, we refer
    to the original future with the name `self`; we cannot use `this` word, because
    `this` is a reserved keyword that refers to the `FutureOps` object. The `or` method
    installs callbacks on `self` and `that` future. Each of these callbacks calls
    the `tryComplete` method on the `p` promise; the callback that executes first
    successfully completes the promise. The `tryComplete` method in the other callback
    returns `false` and does not change the state of the promise.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式`FutureOps`类将类型`Future[T]`的`Future`转换为具有额外`or`方法的对象。在`FutureOps`对象内部，我们用`self`这个名字来引用原始`Future`；我们不能使用`this`这个词，因为`this`是一个保留关键字，它指向`FutureOps`对象。`or`方法在`self`和`that`
    `Future`上安装回调。这些回调中的每一个都会在`p` `Promise`上调用`tryComplete`方法；首先执行的回调会成功完成`Promise`。另一个回调中的`tryComplete`方法返回`false`，并且不会改变`Promise`的状态。
- en: Tip
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Use promises to extend futures with additional functional combinators.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Promise`来扩展`Future`，添加额外的功能性组合器。
- en: Note that we used the `tryComplete` method in this example, and the `or` combinator
    is nondeterministic as a result. The resulting future is completed with the value
    of one of the input futures depending on the execution schedule. In this particular
    case, this is exactly what we want.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这个例子中使用了`tryComplete`方法，因此`or`组合器是非确定性的。结果`Future`会根据执行计划完成，其值取决于输入`Future`中的一个。在这个特定情况下，这正是我们想要的。
- en: Cancellation of asynchronous computations
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步计算的取消
- en: In some cases, we want to cancel a future computation. This might be because
    a future computation takes more than the allotted amount of time, or because the
    user clicks on the **Cancel** button in the UI. In either case, we need to provide
    some alternative value for the canceled future.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们想要取消一个`Future`计算。这可能是因为异步计算花费的时间超过了分配的时间，或者因为用户在UI中点击了**取消**按钮。在任一情况下，我们需要为取消的`Future`提供一个替代值。
- en: Futures come without built-in support for cancellation. Once a future computation
    starts, it is not possible to cancel it directly. Recall from [Chapter 2](ch02.html
    "Chapter 2. Concurrency on the JVM and the Java Memory Model"), *Concurrency on
    the JVM and the Java Memory Model*, that violently stopping concurrent computations
    can be harmful, and this is why the `Thread` methods such as `stop` were deprecated
    in the early JDK releases.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`Futures` 没有内置的取消支持。一旦异步计算开始，就无法直接取消它。回想一下[第2章](ch02.html "第2章。JVM和Java内存模型上的并发")，*JVM和Java内存模型上的并发*，猛烈地停止并发计算可能会造成损害，这也是为什么在早期JDK版本中`Thread`方法如`stop`被弃用的原因。'
- en: 'One approach to cancel a future is to compose it with another future called
    the **cancellation future**. The `cancellation` future provides a default value
    when a future is canceled. We can use the `or` combinator, discussed in the previous
    section, along with the `timeout` method, to compose a future with its `cancellation`
    future:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 取消`Future`的一种方法是将它与另一个称为**取消`Future`**的`Future`组合。`cancellation` `Future`在`Future`被取消时提供一个默认值。我们可以使用上一节中讨论的`or`组合器以及`timeout`方法来组合一个`Future`与其`cancellation`
    `Future`：
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The nondeterminism of the `or` combinator is apparent when running this program.
    The `timeout` and `sleep` statements are precisely tuned to occur approximately
    at the same time. Another thing worth noting is that the computation started by
    the `Future.apply` method does not actually stop if a timeout occurs. The `f`
    future is completed with the value `"timeout!"`, but the future computation proceeds
    concurrently. Eventually, it fails to set the value of the promise when calling
    `tryComplete` in the `or` combinator. In many cases, this is not a problem. An
    HTTP request that needs to complete a future does not occupy any computational
    resources, and will eventually timeout anyway. A keyboard event that completes
    a future only consumes a small amount of CPU time when it triggers. Callback-based
    futures can usually be canceled, as in the preceding example. On the other hand,
    a future that performs an asynchronous computation can use a lot of CPU power
    or other resources. We might want to ensure that actions such as scanning the
    filesystem or downloading a huge file really terminate.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此程序时，`or` 组合子的非确定性是显而易见的。`timeout` 和 `sleep` 语句被精确调整，以大约相同的时间发生。另一个值得注意的事情是，由
    `Future.apply` 方法启动的计算在超时发生时实际上并不会停止。`f` 期约以值 `"timeout!"` 完成，但未来计算是并发进行的。最终，它在
    `or` 组合子中调用 `tryComplete` 时未能设置期约的值。在许多情况下，这并不是一个问题。需要完成未来的 HTTP 请求不会占用任何计算资源，并且最终会超时。当触发时，完成未来的键盘事件只会消耗一小部分
    CPU 时间。基于回调的期约通常可以取消，就像前面的例子一样。另一方面，执行异步计算的未来可能会使用大量的 CPU 功率或其他资源。我们可能想确保像扫描文件系统或下载大文件这样的操作真正终止。
- en: A future computation cannot be forcefully stopped. Instead, there should exist
    some form of cooperation between the future computation and the client of the
    future. In the examples seen so far, asynchronous computations always use futures
    to communicate a value to the client. In this case, the client also communicates
    in the opposite direction to let the asynchronous computation know that it should
    stop. Naturally, we use futures and promises to accomplish this two-way communication.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 未来计算不能被强制停止。相反，未来计算和未来客户端之间应该存在某种形式的合作。在迄今为止看到的例子中，异步计算始终使用未来与客户端通信一个值。在这种情况下，客户端也以相反方向通信，让异步计算知道它应该停止。自然地，我们使用未来和期约来完成这种双向通信。
- en: 'First, we define a type `Cancellable[T]`  as a pair of `Promise[Unit]` and
    `Future[T]` objects. The client will use the `Promise[Unit]` part to request a
    cancellation, and the `Future[T]` part to subscribe to the result of the computation:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个类型 `Cancellable[T]` 作为 `Promise[Unit]` 和 `Future[T]` 对象的配对。客户端将使用 `Promise[Unit]`
    部分来请求取消，并使用 `Future[T]` 部分来订阅计算的输出：
- en: '[PRE43]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `cancellable` method takes the `b` body of the asynchronous computation.
    This time, the `b` body takes a single parameter, `Future[Unit]`, to check if
    the cancellation was requested. The `cancellable` method creates a `cancel` promise
    of the type `Promise[Unit]`  and forwards its corresponding future to the asynchronous
    computation. We call this promise the **cancellation promise**. The `cancel` promise
    will be used to signal that the asynchronous computation `b` should end. After
    the asynchronous computation `b` returns some value `r`, the `cancel` promise
    needs to fail. This ensures that, if the type `Future[T]`  is completed, then
    the client cannot successfully cancel the computation using the `cancel` promise:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`cancellable` 方法获取异步计算的 `b` 主体。这次，`b` 主体接受一个单一参数，`Future[Unit]`，以检查是否请求了取消。`cancellable`
    方法创建一个类型为 `Promise[Unit]` 的 `cancel` 期约，并将其对应的前端传递给异步计算。我们称这个期约为 **取消期约**。`cancel`
    期约将用于指示异步计算 `b` 应该结束。在异步计算 `b` 返回某个值 `r` 后，`cancel` 期约需要失败。这确保了，如果类型 `Future[T]`
    完成，那么客户端不能通过 `cancel` 期约成功取消计算：'
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If calling `tryFailure` on the `cancel` promise returns `false`, then the client
    must have already completed the `cancel` promise. In this case, we cannot fail
    the client's attempt to cancel the computation, so we throw a `CancellationException`.
    Note that we cannot omit this check, as it exists to avoid the race in which the
    client successfully requests the cancellation, and the future computation simultaneously
    completes the future.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 `cancel` 期约上调用 `tryFailure` 返回 `false`，则客户端可能已经完成了 `cancel` 期约。在这种情况下，我们无法失败客户端尝试取消计算，因此我们抛出
    `CancellationException`。请注意，我们不能省略这个检查，因为它存在是为了避免客户端成功请求取消，而同时未来计算完成未来的竞争。
- en: 'The asynchronous computation must occasionally check if the future was canceled
    using the `isCompleted` method on the `cancel` future. If it detects that it was
    canceled, it must cease execution by throwing a `CancellationException` value:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 异步计算必须偶尔检查未来是否被取消，这可以通过在`cancel`未来的`isCompleted`方法上执行来实现。如果检测到它已被取消，它必须通过抛出`CancellationException`值来停止执行：
- en: '[PRE45]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'After the `cancellable` computation starts, the main thread waits for 1,500
    milliseconds and then calls `trySuccess` to complete the cancellation promise.
    By this time, the cancellation promise could have already failed; in this case,
    calling `success` instead of the `trySuccess` method would result in an exception:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cancellable`计算开始后，主线程等待1,500毫秒，然后调用`trySuccess`来完成取消承诺。到那时，取消承诺可能已经失败了；在这种情况下，调用`success`而不是`trySuccess`方法会导致异常：
- en: '[PRE46]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We expect to see the final `working` message printed after the `"computation
    cancelled!"` message from the main thread. This is because the asynchronous computation
    uses polling and does not immediately detect that it was cancelled.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望在主线程的`"computation cancelled!"`消息之后打印出最终的`working`消息。这是因为异步计算使用轮询，并不能立即检测到它已被取消。
- en: Tip
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Use promises to implement cancellation or any other form of two-way communication
    between the client and the asynchronous computation.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用承诺来实现客户端和异步计算之间的取消或其他任何形式的双向通信。
- en: Note that calling the `trySuccess` method on the `cancel` promise does not guarantee
    that the computation will really be canceled. It is entirely possible that the
    asynchronous computation fails the `cancel` promise before the client has a chance
    to cancel it. Thus, the client, such as the main thread in our example, should
    in general use the return value from the `trySuccess` method to check if the cancellation
    succeeded.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`cancel`承诺上调用`trySuccess`方法并不能保证计算真的会被取消。完全有可能异步计算在客户端有机会取消它之前就失败了`cancel`承诺。因此，客户端，例如我们例子中的主线程，通常应该使用`trySuccess`方法的返回值来检查取消是否成功。
- en: Futures and blocking
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未来和阻塞
- en: Examples in this book should have shed the light into why blocking is sometimes
    considered an anti-pattern. Futures and asynchronous computations mainly exist
    to avoid blocking, but in some cases, we cannot live without it. It is, therefore,
    valid to ask how blocking interacts with futures.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的示例应该已经阐明了为什么阻塞有时被认为是一种反模式。未来和异步计算主要存在是为了避免阻塞，但在某些情况下，我们无法没有它。因此，询问阻塞如何与未来交互是合理的。
- en: There are two ways to block with futures. The first is waiting until a future
    is completed. The second is blocking from within an asynchronous computation.
    We will study both the topics in this section.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用未来有两种阻塞方式。第一种是等待未来完成。第二种是在异步计算内部进行阻塞。我们将在本节中研究这两个主题。
- en: Awaiting futures
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等待未来
- en: In rare situations, we cannot use callbacks or future combinators to avoid blocking.
    For example, the main thread that starts multiple asynchronous computations has
    to wait for these computations to finish. If an execution context uses daemon
    threads, as is the case with the `global` execution context, the main thread needs
    to block to prevent the JVM process from terminating.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在罕见的情况下，我们无法使用回调或未来组合器来避免阻塞。例如，启动多个异步计算的主线程必须等待这些计算完成。如果一个执行上下文使用守护线程，就像`global`执行上下文那样，主线程需要阻塞以防止JVM进程终止。
- en: In these exceptional circumstances, we use the `ready` and `result` methods
    on the `Await` object from the `scala.concurrent` package. The `ready` method
    blocks the caller thread until the specified future is completed. The `result`
    method also blocks the caller thread, but returns the value of the future if it
    was completed successfully, or throws the exception in the future if the future
    was failed.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些异常情况下，我们使用来自`scala.concurrent`包的`Await`对象的`ready`和`result`方法。`ready`方法阻塞调用者线程，直到指定的未来完成。`result`方法也会阻塞调用者线程，但如果未来成功完成，则返回未来的值，如果未来失败，则抛出未来的异常。
- en: 'Both the methods require specifying a timeout parameter-the longest duration
    that the caller should wait for the completion of the future before a `TimeoutException`
    is thrown. To specify a timeout, we import the `scala.concurrent.duration` package.
    This allows us to write expressions such as `10.seconds`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都需要指定一个超时参数——调用者在抛出`TimeoutException`之前应该等待未来完成的最高持续时间。要指定超时，我们需要导入`scala.concurrent.duration`包。这允许我们编写如`10.seconds`这样的表达式：
- en: '[PRE47]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this example, the main thread starts a computation that retrieves the URL
    specification and then awaits. By this time, the World Wide Web Consortium is
    worried that a DOS attack is under way, so this is the last time we download the
    URL specification.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，主线程启动了一个获取URL规范的计算，然后等待。此时，万维网联盟担心正在进行DOS攻击，因此这是我们最后一次下载URL规范。
- en: Blocking in asynchronous computations
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步计算中的阻塞
- en: Waiting for the completion of a future is not the only way to block. Some legacy
    APIs do not use callbacks to asynchronously return results. Instead, such APIs
    expose the blocking methods. After we call a blocking method, we lose control
    over the thread; it is up to the blocking method to unblock the thread and return
    the control back.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 等待未来的完成并不是唯一阻塞的方式。一些遗留API不使用回调来异步返回结果。相反，这些API公开了阻塞方法。在调用阻塞方法后，我们失去了对线程的控制；它取决于阻塞方法来解除线程的阻塞并返回控制权。
- en: 'Execution contexts are often implemented using thread pools. As we saw in [Chapter
    3](ch03.html "Chapter 3. Traditional Building Blocks of Concurrency"), *Traditional
    Building Blocks of Concurrency*, blocking worker threads can lead to thread starvation.
    Thus, by starting future computations that block, it is possible to reduce parallelism
    and even cause deadlocks. This is illustrated in the following example, in which
    16 separate future computations call the `sleep` method, and the main thread waits
    until they complete for an unbounded amount of time:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上下文通常使用线程池实现。正如我们在[第3章](ch03.html "第3章。并发传统的构建块")中看到的，“并发的传统构建块”，阻塞工作线程可能导致线程饥饿。因此，通过启动阻塞的计算，可以减少并行性，甚至可能导致死锁。以下是一个示例，其中16个独立的前期计算调用`sleep`方法，主线程等待它们完成，时间是不确定的：
- en: '[PRE48]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Assume that you have eight cores in your processor. This program does not end
    in one second. Instead, the first batch of eight futures started by the `Future.apply`
    method will block all the worker threads for one second, and then another batch
    of eight futures will block for another second. As a result, none of our eight
    processor cores can do any useful work for one second.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的处理器有八个核心。这个程序不会在一秒内结束。相反，`Future.apply`方法启动的第一个批次的八个未来将阻塞所有工作线程一秒，然后另一批次的八个未来将再阻塞一秒。结果，我们的八个处理器核心在一秒内都无法进行任何有用的工作。
- en: Tip
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Avoid blocking in asynchronous computations, as it can cause thread starvation.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在异步计算中阻塞，因为它可能导致线程饥饿。
- en: 'If you absolutely must block, then the part of the code that blocks should
    be enclosed within the `blocking` call. This signals to the execution context
    that the worker thread is blocked and allows it to temporarily spawn additional
    worker threads if necessary:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你绝对必须阻塞，那么应该将阻塞的代码部分放在`blocking`调用中。这会向执行上下文发出信号，表明工作线程被阻塞，并在必要时临时启动额外的工人线程：
- en: '[PRE49]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: With the `blocking` call around the `sleep` call, the `global` execution context
    spawns additional threads when it detects that there is more work than the worker
    threads. All 16 future computations can execute concurrently, and the program
    terminates after one second.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在`sleep`调用周围使用`blocking`调用，当检测到工作线程的工作量超过时，全局执行上下文会额外启动线程。所有16个未来计算可以同时执行，程序在一秒后终止。
- en: Note
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `Await.ready` and `Await.result` statements block the caller thread until
    the future is completed, and are in most cases used outside the asynchronous computations.
    They are blocking operations. The `blocking` statement is used inside asynchronous
    code to designate that the enclosed block of code contains a blocking call. It
    is not a blocking operation by itself.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`Await.ready`和`Await.result`语句会阻塞调用线程，直到未来完成，在大多数情况下，它们在异步计算外部使用。它们是阻塞操作。`blocking`语句在异步代码中使用，以指定包含阻塞调用的代码块。它本身不是阻塞操作。'
- en: The Scala Async library
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala异步库
- en: In the final section of this chapter, we turn to the Scala **Async** library.
    You should understand that the Scala Async library does not add anything conceptually
    new to futures and promises. If you got this far in this chapter, you already
    know everything that you need to know about asynchronous programming, callbacks,
    future composition, promises, and blocking. You can start building asynchronous
    applications right away.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将转向 Scala **Async** 库。你应该明白 Scala Async 库并没有为未来和承诺添加任何概念上的新内容。如果你已经读到本章的这一部分，你已经知道你需要知道的一切关于异步编程、回调、未来组合、承诺和阻塞的知识。你现在就可以开始构建异步应用程序了。
- en: Having said that, the Scala Async library is a convenient library for futures
    and promises that allow expressing chains of asynchronous computations more conveniently.
    Every program that you express using the Scala Async library can also be expressed
    using futures and promises. Often, the Scala Async library allows writing shorter,
    more concise, and understandable programs.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，Scala Async 库是一个方便的库，用于未来和承诺，允许更方便地表达异步计算的链。你使用 Scala Async 库表达的所有程序也可以使用未来和承诺来表达。通常，Scala
    Async 库允许编写更短、更简洁、更易于理解的程序。
- en: The Scala Async library introduces two new method calls--the `async` and `await`
    methods. The `async` method is conceptually equivalent to the `Future.apply` method;
    it starts an asynchronous computation and returns a future object. The `await`
    method should not be confused with the `Await` object used to block on futures.
    The `await` method takes a future and returns that future's value. However, unlike
    the methods on the `Await` object, the `await` method does not block the underlying
    thread; we will soon see how this is possible.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Scala Async 库引入了两种新的方法调用——`async` 和 `await` 方法。`async` 方法在概念上等同于 `Future.apply`
    方法；它启动一个异步计算并返回一个未来对象。`await` 方法不应与用于在未来的阻塞上使用的 `Await` 对象混淆。`await` 方法接受一个未来并返回该未来的值。然而，与
    `Await` 对象上的方法不同，`await` 方法不会阻塞底层线程；我们很快就会看到这是如何可能的。
- en: 'The Scala Async library is currently not part of the Scala standard library.
    To use it, we need to add the following line to our build definition file:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 目前 Scala Async 库不是 Scala 标准库的一部分。要使用它，我们需要在我们的构建定义文件中添加以下行：
- en: '[PRE50]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As a simple example, consider the `delay` method, which returns a future that
    is completed after `n` seconds. We use the `async` method to start an asynchronous
    computation that calls the `sleep` method. When the `sleep` call returns, the
    future is completed:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 作为简单的示例，考虑 `delay` 方法，它返回一个在 `n` 秒后完成的未来。我们使用 `async` 方法启动一个异步计算，调用 `sleep`
    方法。当 `sleep` 调用返回时，未来就完成了：
- en: '[PRE51]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `await` method must be statically enclosed within an `async` block in the
    same method; it is a compile-time error to invoke `await` outside of the `async`
    block. Whenever the execution inside the `async` block reaches an `await` statement,
    it stops until the value from the future in the `await` statement becomes available.
    Consider the following example:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`await` 方法必须在同一方法中的 `async` 块内静态封装；在 `async` 块之外调用 `await` 是编译时错误。每当 `async`
    块内的执行达到 `await` 语句时，它就会停止，直到 `await` 语句中的未来值可用。考虑以下示例：'
- en: '[PRE52]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, the asynchronous computation in the `async` block prints `"T-minus 1 second"`.
    It then calls `delay` to obtain a future that is completed after one second. The
    `await` call designates that the computation can proceed only after the future
    returned by `delay` completes. After that happens, the `async` block prints the
    text `done`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`async` 块中的异步计算打印出 `"T-minus 1 second"`。然后调用 `delay` 以获取一个在一秒后完成的未来。`await`
    调用指定只有在 `delay` 返回的未来完成之后，计算才能继续进行。在那之后，`async` 块打印出文本 `done`。
- en: 'The natural question is: How can the Scala Async library execute the preceding
    example without blocking? The answer is that the Scala Async library uses Scala
    Macros to transform the code inside the `async` statement. The code is transformed
    in such a way that the code after every `await` statement becomes a callback registered
    to the future inside `await`. Immensely simplifying how this transformation works
    under the hood, the preceding code is equivalent to the following computation:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 自然会问：Scala Async 库是如何在不阻塞的情况下执行前面的示例的？答案是 Scala Async 库使用 Scala 宏来转换 `async`
    语句内部的代码。代码被转换成这样的方式，即每个 `await` 语句之后的代码都变成了注册到 `await` 中的未来的回调。极大地简化了这种转换在底层的工作方式，前面的代码等同于以下计算：
- en: '[PRE53]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As you can see, the equivalent code produced by the Scala Async library is
    completely non-blocking. The advantage of the `async`/`await` style code is that
    it is much more understandable. For example, it allows defining a custom `countdown`
    method that takes a number of seconds and an `n` and a `f` function to execute
    every second. We use a `while` loop for the `countdown` method inside the `async`
    block: each time an `await` instance is invoked, the execution is postponed for
    one second. The implementation using the Scala Async library feels like regular
    procedural code, but it does not incur the cost of blocking:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，由Scala Async库产生的等效代码是完全非阻塞的。`async`/`await`风格代码的优势在于它更容易理解。例如，它允许定义一个自定义的`countdown`方法，该方法接受秒数以及每秒执行一次的`n`和`f`函数。我们在`async`块内部使用`while`循环实现`countdown`方法：每次调用`await`实例时，执行将推迟一秒。使用Scala
    Async库的实现感觉像常规的过程代码，但它不会产生阻塞的成本：
- en: '[PRE54]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `countdown` method can be used from the main thread to print to the standard
    output every second. Since the `countdown` method returns a future, we can additionally
    install a `foreach` callback to execute after the `countdown` method is over:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`countdown`方法可以从主线程使用，每秒打印到标准输出。由于`countdown`方法返回一个future，我们还可以安装一个`foreach`回调，在`countdown`方法完成后执行：'
- en: '[PRE55]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Having seen how expressive the Async library is in practice, the question is:
    When to use it in place of callbacks, future combinators, and for-comprehensions?
    In most cases, whenever you can express a chain of asynchronous computations inside
    a single method, you are free to use Async. You should use your best judgment
    when applying it; always choose the programming style that results in concise,
    more understandable, and more maintainable programs.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中看到Async库的表达能力后，问题是：何时使用它来替代回调、未来组合器和for-comprehensions？在大多数情况下，只要您可以在单个方法内部表达一系列异步计算，您就可以自由地使用Async。在应用它时，您应该运用最佳判断；始终选择产生简洁、更易于理解和更易于维护的程序的开发风格。
- en: Tip
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Use the Scala Async library when a chain of asynchronous computations can be
    expressed more intuitively as procedural code using the `async` and `await` statements.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当一系列异步计算可以用`async`和`await`语句以更直观的过程代码形式表达时，请使用Scala Async库。
- en: Alternative future frameworks
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替代未来框架
- en: Scala futures and promises API resulted from an attempt to consolidate several
    different APIs for asynchronous programming, among them, legacy Scala futures,
    Akka futures, Scalaz futures, and Twitter's Finagle futures. Legacy Scala futures
    and Akka futures have already converged to the futures and promises APIs that
    you've learned about so far in this chapter. Finagle's `com.twitter.util.Future`
    type is planned to eventually implement the same interface as `scala.concurrent.Future`,
    while the Scalaz `scalaz.concurrent.Future` type implements a slightly different
    interface. In this section, we give a brief description of Scalaz futures.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Scala futures和promises API源于尝试整合几个不同的异步编程API，其中包括遗留的Scala futures、Akka futures、Scalaz
    futures和Twitter的Finagle futures。遗留的Scala futures和Akka futures已经收敛到您在本章中已经了解到的futures和promises
    APIs。Finagle的`com.twitter.util.Future`类型计划最终实现与`scala.concurrent.Future`相同的接口，而Scalaz的`scalaz.concurrent.Future`类型实现了一个略有不同的接口。在本节中，我们简要描述Scalaz
    futures。
- en: 'To use Scalaz, we add the following dependency to the `build.sbt` file:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Scalaz，我们将在`build.sbt`文件中添加以下依赖项：
- en: '[PRE56]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We now encode an asynchronous tombola program using Scalaz. The `Future` type
    in Scalaz does not have the `foreach` method. Instead, we use its `runAsync` method,
    which asynchronously runs the future computation to obtain its value, and then
    calls the specified callback:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在使用Scalaz来编码一个异步的彩票程序。Scalaz中的`Future`类型没有`foreach`方法。相反，我们使用它的`runAsync`方法，该方法异步运行未来计算以获取其值，然后调用指定的回调：
- en: '[PRE57]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Unless you are terribly lucky and draw the same permutation twice, running this
    program reveals that the two `runAsync` calls print different numbers. Each `runAsync`
    call separately computes the permutation of the random numbers. This is not surprising,
    as Scalaz futures have the pull semantics, in which the value is computed each
    time some callback requests it, in contrast to the push semantics of Finagle and
    Scala futures, in which the callback is stored, and applied if and when the asynchronously
    computed value becomes available.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你非常幸运，两次都抽到了相同的排列，否则运行这个程序会揭示两个`runAsync`调用打印了不同的数字。每个`runAsync`调用单独计算随机数的排列。这并不奇怪，因为Scalaz
    `Future`具有拉语义，即每次某个回调请求值时都会计算值，这与Finagle和Scala `Future`的推语义形成对比，后者将回调存储起来，并在异步计算值可用时应用它。
- en: 'To achieve the same semantics as we would have with Scala futures, we need
    to use the `start` combinator that runs the asynchronous computation once, and
    caches its result:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到与Scala `Future`相同的语义，我们需要使用`start`组合子来运行异步计算一次，并缓存其结果：
- en: '[PRE58]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: With this change, the two `runAsync` calls use the same permutation of random
    numbers `tombola`, and print the same values.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个变化，两个`runAsync`调用使用了相同的随机数排列`tombola`，并打印了相同的值。
- en: We will not delve further into the internals of alternate frameworks. The fundamentals
    of futures and promises that you learned about in this chapter should be sufficient
    to easily familiarize yourself with other asynchronous programming libraries,
    should the need arise.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会进一步深入探讨其他框架的内部结构。本章中你学到的`Future`和`Promise`的基本原理应该足以让你在需要时轻松熟悉其他异步编程库。
- en: Summary
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter presented some powerful abstractions for asynchronous programming.
    We have seen how to encode latency with the `Future` type, how to avoid blocking
    with callbacks on futures, and how to compose values from multiple futures. We
    have learned that futures and promises are closely tied together and that promises
    allow interfacing with legacy callback-based systems. In cases where blocking
    was unavoidable, we learned how to use the `Await` object and the `blocking` statement.
    Finally, we learned that the Scala Async library is a powerful alternative for
    expressing future computations more concisely.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了异步编程的一些强大抽象。我们看到了如何使用`Future`类型来编码延迟，如何通过在`Future`上使用回调来避免阻塞，以及如何从多个`Future`中组合值。我们了解到`Future`和`Promise`紧密相连，并且`Promise`允许与基于回调的旧系统进行接口。在阻塞不可避免的情况下，我们学习了如何使用`Await`对象和`blocking`语句。最后，我们了解到Scala
    Async库是表达未来计算的一种更简洁的强大替代方案。
- en: Futures and promises only allow dealing with a single value at a time. What
    if an asynchronous computation produces more than a single value before completing?
    Similarly, how do we efficiently execute thousands of asynchronous operations
    on different elements of large datasets? Should we use futures in such cases?
    In the next chapter, we will explore Scala's support for data-parallelism, a form
    of concurrency where similar asynchronous computations execute in parallel on
    different collection elements. We will see that using data-parallel collections
    is preferable to using futures when collections are large, as it results in a
    better performance.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`Future`和`Promise`仅允许一次处理一个值。如果一个异步计算在完成之前产生了多个值，该怎么办？同样，我们如何高效地在大型数据集的不同元素上执行数千个异步操作？在这种情况下，我们应该使用`Future`吗？在下一章中，我们将探索Scala对数据并行性的支持，这是一种在集合的不同元素上并行执行类似异步计算的并发形式。我们将看到，当集合很大时，使用数据并行集合比使用`Future`更可取，因为它会产生更好的性能。'
- en: Exercises
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'The following exercises summarize what we have learned about futures and promises
    in this chapter, and require implementing custom future factory methods and combinators.
    Several exercises also deal with several deterministic programming abstractions
    that were not covered in this chapter, such as single-assignment variables and
    maps:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 以下练习总结了本章关于`Future`和`Promise`的学习内容，并需要实现自定义的`Future`工厂方法和组合子。几个练习还涉及本章未涵盖的几个确定性编程抽象，例如单赋值变量和映射：
- en: Implement a command-line program that asks the user to input a URL of some website,
    and displays the HTML of that website. Between the time that the user hits **ENTER**
    and the time that the HTML is retrieved, the program should repetitively print
    a `.` to the standard output every 50 milliseconds, with a 2 second timeout. Use
    only futures and promises, and avoid synchronization primitives from the previous
    chapters. You may reuse the `timeout` method defined in this chapter.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个命令行程序，要求用户输入某个网站的 URL，并显示该网站的 HTML。在用户按下 **ENTER** 和检索到 HTML 之间，程序应每隔 50
    毫秒重复打印一个 `.` 到标准输出，并设置 2 秒的超时。仅使用未来和承诺，并避免使用上一章中的同步原语。你可以重用本章中定义的 `timeout` 方法。
- en: 'Implement an abstraction called a single-assignment variable, represented by
    the `IVar` class:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为单赋值变量的抽象，表示为 `IVar` 类：
- en: '[PRE59]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: When created, the `IVar` class does not contain a value, and calling `apply`
    results in an exception. After a value is assigned using the `:=` method, subsequent
    calls to `:=` throw an exception, and the `apply` method returns the previously
    assigned value. Use only futures and promises, and avoid the synchronization primitives
    from the previous chapters.
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当创建时，`IVar` 类不包含任何值，调用 `apply` 会引发异常。使用 `:=` 方法分配一个值后，后续对 `:=` 的调用会引发异常，而 `apply`
    方法返回之前分配的值。仅使用未来和承诺，并避免使用上一章中的同步原语。
- en: 'Extend the `Future[T]` type with the `exists` method, which takes a predicate
    and returns a `Future[Boolean]` object:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展类型 `Future[T]`，添加 `exists` 方法，该方法接受一个谓词并返回一个 `Future[Boolean]` 对象：
- en: '[PRE60]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The resulting future is completed with `true` if and only if the original future
    is completed and the predicate returns `true`, and `false` otherwise. You can
    use future combinators, but you are not allowed to create any `Promise` objects
    in the implementation.
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果未来只有在原始未来完成且谓词返回 `true` 时才完成 `true`，否则为 `false`。你可以使用未来组合子，但在实现中不允许创建任何 `Promise`
    对象。
- en: Repeat the previous exercise, but use `Promise` objects instead of future combinators.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复之前的练习，但使用 `Promise` 对象代替未来组合子。
- en: Repeat the previous exercise, but use the Scala Async framework.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复之前的练习，但使用 Scala Async 框架。
- en: 'Implement the `spawn` method, which takes a command-line string, asynchronously
    executes it as a child process, and returns a future with the exit code of the
    child process:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为 `spawn` 的方法，它接受一个命令行字符串，异步执行它作为子进程，并返回一个包含子进程退出码的未来：
- en: '[PRE61]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Make sure that your implementation does not cause thread starvation.
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保你的实现不会导致线程饥饿。
- en: 'Implement the `IMap` class, which represents a single-assignment map:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现名为 `IMap` 的类，它表示单赋值映射：
- en: '[PRE62]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Pairs of keys and values can be added to the `IMap` object, but they can never
    be removed or modified. A specific key can be assigned only once, and subsequent
    calls to `update` with that key result in an exception. Calling `apply` with a
    specific key returns a future, which is completed after that key is inserted into
    the map. In addition to futures and promises, you may use the `scala.collection.concurrent.Map`
    class.
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以向 `IMap` 对象添加键值对，但它们不能被删除或修改。特定的键只能分配一次，后续使用该键的 `update` 调用会导致异常。使用特定键调用 `apply`
    会返回一个未来，该未来在将该键插入映射后完成。除了未来和承诺外，你还可以使用 `scala.collection.concurrent.Map` 类。
- en: 'Extend the type `Promise[T]`  with the `compose` method, which takes a function
    of the type `S => T` , and returns a `Promise[S]` object:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展类型 `Promise[T]`，添加 `compose` 方法，该方法接受类型 `S => T` 的函数，并返回一个 `Promise[S]` 对象：
- en: '[PRE63]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Whenever the resulting promise is completed with some value `x` of the type
    `S` (or failed), the original promise must be completed with the value `f(x)`
    asynchronously (or failed), unless the original promise is already completed.
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当结果承诺完成并带有某种类型 `S` 的值 `x`（或失败）时，原始承诺必须异步完成带有值 `f(x)`（或失败），除非原始承诺已经完成。
- en: 'Implement the `scatterGather` method, which given a sequence of tasks, runs
    those tasks as parallel asynchronous computations, then combines the results,
    and returns a future that contains the sequence of results from different tasks.
    The `scatterGather` method has the following interface:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现名为 `scatterGather` 的方法，该方法接受一系列任务，并行异步运行这些任务，然后合并结果，并返回一个包含来自不同任务的结果序列的未来。`scatterGather`
    方法具有以下接口：
- en: '[PRE64]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Implement another version of the `timeout` method shown in this chapter, but
    without using the `blocking` construct or `Thread.sleep`. Instead use the `java.util.Timer`
    class from the JDK. What are the advantages of this new implementation?
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现本章中展示的`timeout`方法的另一个版本，但不使用`blocking`构造或`Thread.sleep`。相反，使用JDK中的`java.util.Timer`类。这种新实现有什么优点？
- en: A directed graph is a data structure composed from a finite set of nodes, where
    each node has a finite number of directed edges that connect it with other nodes
    in the graph. A directed acyclic graph, or shorter, DAG, is a directed graph data
    structure in which, starting from any node N and following any path along the
    directed edges, we cannot arrive back at N. In other words, directed edges of
    a DAG never form a cycle.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有向图是由有限节点集合组成的数据结构，其中每个节点都有有限数量的有向边，这些边将其与其他图中的节点连接起来。有向无环图，或简称DAG，是一种有向图数据结构，其中从任何节点N开始，沿着有向边跟随任何路径，我们无法回到N。换句话说，DAG的有向边永远不会形成一个循环。
- en: 'One way to represent the nodes of the DAG data structure is as follows:'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表示DAG数据结构节点的一种方式如下：
- en: '[PRE65]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Here is an example of a DAG declaration:'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是一个DAG声明的示例：
- en: '[PRE66]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The preceding DAG declaration is shown graphically in the following figure:'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之前DAG的声明在以下图中以图形方式展示：
- en: '![Exercises](img/image_04_006.jpg)'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![练习](img/image_04_006.jpg)'
- en: 'DAGs are often used to declare dependencies between different items, for example,
    build tasks in a project build tool or an IDE. Your task is to implement the `fold`
    method that takes a DAG node and a function that maps each item and its inputs
    into some value, and then returns the future with the resulting value of the input
    node:'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: DAGs通常用于声明不同项目之间的依赖关系，例如，在项目构建工具或IDE中的构建任务。你的任务是实现一个`fold`方法，该方法接受一个DAG节点和一个函数，该函数将每个项目和其输入映射到某个值，然后返回包含输入节点结果的future：
- en: '[PRE67]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `fold` method runs an asynchronous task for each item in the DAG to map
    the item and its inputs to a new value. Dependencies between DAG items must be
    respected: an item can only run after all of its dependencies have been computed.
    For example, in the previous figure, task `b` can only run after both `c` and
    `d` have produced a result.'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`fold`方法为DAG中的每个项目运行一个异步任务，将项目及其输入映射到一个新值。DAG项目之间的依赖关系必须得到尊重：一个项目只能在所有依赖项都已计算之后才能运行。例如，在之前的图中，任务`b`只能在`c`和`d`都生成结果之后才能运行。'
