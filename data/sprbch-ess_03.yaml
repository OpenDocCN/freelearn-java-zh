- en: Chapter 3. Working with Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。与数据一起工作
- en: In the previous chapter, we learned about batch configurations, components,
    and execution modes to match with diverse business needs. Handling the data, which
    includes reading, processing, and writing, is an essential part of any kind of
    application, and batch applications are no exception. Spring Batch provides the
    ability to read different forms of data, process the data in the way business
    expects, and write it back to different systems, which can be easily integrated
    with different frameworks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了关于批配置、组件和执行模式的知识，以适应不同的业务需求。处理数据，包括读取、处理和写入，是任何类型应用程序的一个基本部分，批处理应用程序也不例外。Spring
    Batch提供了读取不同形式数据的能力，按照业务预期的方式处理数据，并将其写回到不同的系统中，这些系统可以轻松地与不同的框架集成。
- en: 'In this chapter, we will cover three major operations involved in data handling:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍数据处理中涉及到的三个主要操作：
- en: Data reading
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据读取
- en: Data processing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据处理
- en: Data writing![Working with Data](img/3372OS_03_01.jpg)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据写入![与数据一起工作](img/3372OS_03_01.jpg)
- en: The preceding figure shows the three stages of handling data in a batch application.
    The input (source) can be a database, a filesystem (flat file or XML), or data
    from a web service as well. Applications need to read the data from an input (source),
    process it, and write to the output (destination) system. The output (destination)
    can be a database or a filesystem (a flat file or an XML file). In the processing
    stage, data read in format can be verified and transformed into the desired format
    before writing to the output. Let's examine each of these stages now.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图显示了批处理应用程序中处理数据的三个阶段。输入（源）可以是数据库、文件系统（平面文件或XML）或来自Web服务的数据。应用程序需要从输入（源）读取数据，处理它，并将其写入输出（目标）系统。输出（目标）可以是数据库或文件系统（平面文件或XML文件）。在处理阶段，读取的数据格式可以验证并转换为所需的格式，然后再写入输出。现在让我们逐一检查这些阶段。
- en: Data reading
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据读取
- en: Spring Batch provides the configuration to read different forms of data from
    different sources, including flat files, XML, and relational databases. It also
    supports the custom reader configurations for the formats that are not available
    with the specification.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Batch提供了从不同来源读取不同形式数据的配置，包括平面文件、XML和关系数据库。它还支持为未提供规格的格式提供自定义读取器配置。
- en: ItemReader
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ItemReader
- en: 'Spring Batch provides an interface in the form of `ItemReader` to read bulk
    data from different forms, which include the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Batch提供了一个名为`ItemReader`的接口，用于从不同形式读取大量数据，包括以下内容：
- en: '**Flat files**: These are typically of two types: fixed width and delimited
    character-based files'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平面文件**：这些通常有两种类型：固定宽度和基于分隔符的字符文件'
- en: '**XML**: This format is used for different forms of application data'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XML**：这种格式用于不同形式的应用数据'
- en: '**Database**: This maintains a set of records of similar or different groups
    of information'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库**：这维护了一组类似或不同信息组的记录'
- en: 'The following is the definition of the `ItemReader` interface:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对`ItemReader`接口的定义：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's examine how `ItemReader` can help us with reading different formats.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来探讨一下`ItemReader`如何帮助我们读取不同格式的数据。
- en: Reading data from flat files
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从平面文件读取数据
- en: Flat files are configured in two formats, namely, **fixed width** and **delimited**.
    Fixed width files have each field detail configured with a predefined fixed width,
    whereas the delimited files have fields with a specific character (or tab in general)
    used to delimit them from the other fields.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 平面文件配置有两种格式，即**固定宽度**和**分隔符**。固定宽度文件中的每个字段细节都配置了预定义的固定宽度，而分隔符文件中的字段使用特定的字符（通常为制表符）来分隔它们与其他字段。
- en: Fixed width file
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 固定宽度文件
- en: A fixed width file generally has a predefined specification of its fields, how
    much length each field should occupy on the file, and from which position to which
    position on a line.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 固定宽度文件通常具有其字段的预定义规格，包括每个字段在文件中应占用的长度，以及从哪一位置到哪一位置在一行上。
- en: 'The following is one such specification of the fixed width file we want to
    read:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们想要读取的固定宽度文件的这样一个规格：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Using the preceding specification, let''s fill a sample file with employee
    information in a fixed width file, as follows (`employees.txt`):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的规格，让我们填充一个包含员工信息的样本文件，该文件是一个固定宽度文件，如下所示（`employees.txt`）：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If a Java object is to be generated corresponding to this specification, we
    can create a **Plain Old Java Object** (**POJO**) with the following representation:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要生成与该规格相对应的Java对象，我们可以创建以下表示的**普通Java对象**（**POJO**）：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: FlatFileItemReader
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FlatFileItemReader
- en: '`FlatFileItemReader` provides a means of reading different types of flat files
    and parsing them by the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`FlatFileItemReader`提供了一种读取不同类型的平面文件并通过以下方式解析它们的方法：'
- en: '`resource`: This represents the file from which the data has to be read.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource`：这表示需要从中读取数据的文件。'
- en: '`lineMapper`: This represents the mapper that converts the String that is read
    by `ItemReader` to the Java object.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lineMapper`：这表示将`ItemReader`读取的字符串转换为Java对象的映射器。'
- en: '`linesToSkip`: This is used with files having header content before records.
    It is the number of lines we want to ignore at the top of the file.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`linesToSkip`：当文件在记录之前有标题内容时使用。这是我们想要忽略文件顶部的行数。'
- en: LineMapper
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LineMapper
- en: 'The `LineMapper` interface lets us read each line from the file with the line
    number passed in every iteration. It is the Spring Batch standard implementation
    of `LineMapper`. The following is the `LineMapper` interface:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`LineMapper`接口允许我们在每次迭代中传递行号来读取文件中的每一行。它是Spring Batch的`LineMapper`标准实现。以下为`LineMapper`接口：'
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `LineTokenizer` interface converts the line read from `LineMapper` to the
    set of fields (`FieldSet`). `DelimitedLineTokenizer`, `FixedLengthTokenizer`,
    and `PatternMatchingCompositeLineTokenizer` are Spring Batch''s supporting implementations
    of `LineTokenizer`. The following is the `LineTokenizer` interface:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`LineTokenizer`接口将`LineMapper`读取的行转换为字段集（`FieldSet`）。`DelimitedLineTokenizer`、`FixedLengthTokenizer`和`PatternMatchingCompositeLineTokenizer`是Spring
    Batch对`LineTokenizer`的支持实现。以下为`LineTokenizer`接口：'
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `FieldSetMapper` interface lets us map each field from the String read
    to the `Employee` object. The following is the `FieldSetMapper` interface:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`FieldSetMapper`接口允许我们将从读取的字符串映射到`Employee`对象中的每个字段。以下为`FieldSetMapper`接口：'
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can implement `FieldSetMapper` for our `Employee` data, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为我们的`Employee`数据实现`FieldSetMapper`，如下所示：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The data can be read from the file as part of the batch job, as shown in the
    following code snippet:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以作为批处理作业的一部分从文件中读取，如下面的代码片段所示：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `setResource()` method sends the flat file resource to `FlatFileItemReader`.
    The `LineTokenizer` interface can be used with field names and ranges with the
    start and end positions on the file set as an array using the `setNames()` and
    `setColumns()` methods respectively. Every time the `read()` method is invoked
    on `itemReader`, it reads a line and moves on to the next.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`setResource()`方法将平面文件资源发送到`FlatFileItemReader`。`LineTokenizer`接口可以与字段名称和范围一起使用，使用`setNames()`和`setColumns()`方法分别设置文件上的起始和结束位置作为数组。每次在`itemReader`上调用`read()`方法时，它都会读取一行并移动到下一行。'
- en: 'The following is the output of the batch program after reading data from a
    fixed width flat file and capturing them into Java objects:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从固定宽度平面文件读取数据并将其捕获到Java对象后的批处理程序输出：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `reader`, `linetokenizer`, and `fieldsetmapper` are used in the batch as
    beans, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`reader`、`linetokenizer`和`fieldsetmapper`在批处理中作为bean使用，如下所示：'
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Delimited file
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定界文件
- en: A delimited flat file contains fields separated by a specific character in each
    line. The following is an example of a delimited file, with each field delimited
    by the character comma. Let's take an example of reading employee details from
    a delimited flat file.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 定界符平面文件包含每行中由特定字符分隔的字段。以下是一个定界符文件的示例，每个字段由逗号分隔。让我们以从定界符平面文件中读取员工详细信息为例。
- en: 'The following are the specifications of the file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为文件的规格说明：
- en: ID
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ID
- en: Last name
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 姓氏
- en: First name
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名字
- en: Designation
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 职称
- en: Department
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部门
- en: Year of joining
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 入职年份
- en: 'Each field should be separated from the other with a comma. The following is
    the sample file content (`employees.csv`):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 每个字段都应该用逗号与其他字段分隔。以下是一个示例文件内容（`employees.csv`）：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Delimited files need to be handled the same way as the fixed width flat files,
    except that `LineTokenizer` used in this case should be `DelimitedLineTokenizer`.
    The following is the Java code realized to read a delimited flat file to be handled
    as part of the batch job:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 定界文件需要像固定宽度平面文件一样处理，除了在这种情况下使用的`LineTokenizer`应该是`DelimitedLineTokenizer`。以下是为了读取作为批处理作业一部分处理的定界符平面文件而实现的Java代码：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With the delimited files, we don''t have to set the column''s property. The
    delimiter used has to be set unless the delimiter is a comma. Executing this program
    should read the delimited flat files into the Java objects and the output is as
    follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用定界符文件，我们不需要设置列的属性。除非定界符是逗号，否则必须设置使用的定界符。执行此程序应将定界符平面文件读入Java对象，输出如下：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `ItemReader`, `LineTokenizer`, and `FieldSetMapper` in the case of delimited
    files can be configured in the batch as beans and used in the program as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在分隔符文件的情况下，`ItemReader`、`LineTokenizer`和`FieldSetMapper`可以作为bean配置在批处理中，并在程序中如下使用：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If the lines of file are defined in a different format specific to a business,
    `LineTokenizer` is open for custom implementation and configuration. The `PatternMatchingCompositeLineMapper`
    can be used to read files with complex patterns. For example, if we have multiple
    record types within a single flat file, we can use `PatternMatchingCompositeLineMapper`
    to have tokenizers for each record type, as follows.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件的行以特定于业务的格式定义，`LineTokenizer`允许自定义实现和配置。`PatternMatchingCompositeLineMapper`可用于读取具有复杂模式的文件。例如，如果我们有一个平面文件中的多个记录类型，我们可以使用`PatternMatchingCompositeLineMapper`为每个记录类型提供分词器，如下所示。
- en: 'A sample flat file with multiple record types:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包含多个记录类型的示例平面文件：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following is the bean configuration for this multiple record type:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为这种多记录类型进行的bean配置：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `PatternMatchingCompositeLineMapper` identifies each line by its pattern,
    with matching keys to let the corresponding `Tokenizer` and `FieldSetMapper` read
    and match the records.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`PatternMatchingCompositeLineMapper`通过模式识别每个行，使用匹配的键让相应的`Tokenizer`和`FieldSetMapper`读取和匹配记录。'
- en: Exceptions from flat file reading
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 平面文件读取的异常
- en: 'The following are the possible exceptions from flat files, for example when
    in case the file has an incorrect format, a problem in reading the data from file,
    or inconsistent data in the flat file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从平面文件中可能出现的异常，例如当文件格式不正确、从文件读取数据时出现问题或平面文件中的数据不一致时：
- en: '`FlatFileParseException`: This is the exception thrown by `FlatFileItemReader`
    for the errors that occur during file reading'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FlatFileParseException`: 这是`FlatFileItemReader`在文件读取过程中抛出的异常。'
- en: '`FlatFileFormatException`: This is the exception thrown by `LineTokenizer`
    for the errors that occur during data tokenizing'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FlatFileFormatException`: 这是`LineTokenizer`在数据分词过程中抛出的异常。'
- en: '`IncorrectTokenCountException`: This is thrown if the number of columns specified
    do not match with the number of columns tokenized'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IncorrectTokenCountException`: 如果指定的列数与分词的列数不匹配，则会抛出此异常。'
- en: '`IncorrectLineLengthException`: This is thrown during the fixed width flat
    file reading if the line/field lengths do not match with the ones specified'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IncorrectLineLengthException`: 在固定宽度平面文件读取过程中，如果行/字段长度与指定的长度不匹配，则会抛出此异常。'
- en: Reading data from XML
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从XML读取数据
- en: '**Extensible** **Markup Language** (**XML**) is a markup language to define
    documents with data that can be readable by both humans and machines. XML is mainly
    used when multiple systems interact with each other.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**可扩展** **标记语言** (**XML**) 是一种标记语言，用于定义文档，其中包含人类和机器都能读取的数据。XML主要用于多个系统相互交互时。'
- en: 'Spring Batch uses the **Streaming API for XML** (**StAX**) parser. In the StAX
    metaphor, the programmatic entry point is a cursor that represents a point within
    the document. The application moves the cursor forward, ''pulling'' the information
    from the parser as required. Hence, the reading happens in fragments of XML content
    from a file that is represented in the following figure:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Batch 使用 **XML的流式API** (**StAX**) 解析器。在 StAX 比喻中，程序入口点是一个表示文档中某一点的游标。应用程序将游标向前移动，'拉取'解析器所需的信息。因此，读取发生在以下图示的文件中XML内容的片段：
- en: '![Reading data from XML](img/3372OS_03_02.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![从XML读取数据](img/3372OS_03_02.jpg)'
- en: The `StaxItemReader` lets us parse the XML file, considering that the root element
    of each fragment is common (`employee` in the above example). `unmarshaller` converts
    the data into Java objects.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`StaxItemReader`让我们解析XML文件，考虑到每个片段的根元素是通用的（如上述示例中的`employee`）。`unmarshaller`将数据转换为Java对象。'
- en: 'The following are the `employeeFile` and `employeeFileReader` configuration
    as beans:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对`employeeFile`和`employeeFileReader`的bean配置：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can use different unmarshalling technologies, including JAXB, XStream binding,
    JiBX, and XML Beans. We used StAX as an engine for marshalling. Let''s consider
    the XStream binding and the following configuration with it:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用不同的反序列化技术，包括JAXB、XStream绑定、JiBX和XML Beans。我们使用StAX作为序列化的引擎。让我们考虑XStream绑定及其以下配置：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If more than one file has the XML details to be read, we can use `MuliResourceItemReader`
    to configure multiple resources to be read in a read operation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个文件包含要读取的XML细节，我们可以使用`MuliResourceItemReader`在读取操作中配置多个资源。
- en: Reading data from a database
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从数据库读取数据
- en: 'A database contains information in the form of tables with multiple columns
    to hold each field in it. If a batch job has to read the data from a database,
    it can be performed using the following two types of item reading concepts:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库以表格的形式包含信息，具有多个列来存储每个字段。如果批处理作业需要从数据库读取数据，可以使用以下两种类型的项读取概念：
- en: '**Cursor-based** **item reading**: This reads each fragment having a cursor
    pointing to one after the other'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于游标的** **项目读取**：这种读取方式读取每个片段，其中游标依次指向下一个'
- en: '**Page-based** **item reading**: This reads multiple records together, considering
    them as a page'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于页面的** **项目读取**：这种读取方式将多个记录一起读取，将其视为一个页面'
- en: In comparison, cursor-based item reading works well as it reads little data
    and processes unless their memory leaks with the system.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相比，基于游标的项读取工作得很好，因为它读取少量数据并处理，除非它们的内存泄漏与系统相关。
- en: JdbcCursorItemReader
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JdbcCursorItemReader
- en: To read the data in a cursor-based technique, we can use `JdbcCursorItemReader`.
    It configures with `RowMapper` (of Spring framework) to match each attribute in
    the database to the Java object attributes.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用基于游标的技巧读取数据，我们可以使用`JdbcCursorItemReader`。它通过`RowMapper`（Spring框架）配置，将数据库中的每个属性匹配到Java对象的属性。
- en: 'The `RowMapper` for the employee example can be implemented as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 员工示例的`RowMapper`可以按以下方式实现：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The Java program to read the data from the database with `EmployeeRowMapper`
    can be realized as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`EmployeeRowMapper`从数据库读取数据的Java程序可以实现如下：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `JdbcCursorItemReader` and `EmployeeRowMapper` can be configured in the
    batch XML as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`JdbcCursorItemReader`和`EmployeeRowMapper`可以在批处理XML中按以下方式配置：'
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`JdbcCursorItemReader` can be customized by setting ignore warnings, fetch
    size, max rows, query timeout, verify cursor position, and such properties with
    the corresponding options for respective items.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过设置忽略警告、获取大小、最大行数、查询超时、验证游标位置等属性以及相应的选项来自定义`JdbcCursorItemReader`。
- en: If we want to configure the database read activity using the Hibernate framework,
    we can use `HibernateCursorItemReader`. The stored procedure-based read operation
    can be performed using the `StoredProcedureItemReader`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用Hibernate框架配置数据库读取活动，可以使用`HibernateCursorItemReader`。基于存储过程的读取操作可以使用`StoredProcedureItemReader`执行。
- en: JdbcPagingItemReader
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JdbcPagingItemReader
- en: 'The paging mode read operation on a database can be performed using the `JdbcPagingItemReader`.
    The configuration with the `JdbcPagingItemReader` with the properties of `dataSource`,
    `queryProvider`, and query with different clauses can be done as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库上执行分页模式读取操作可以使用`JdbcPagingItemReader`。使用`JdbcPagingItemReader`并配置`dataSource`、`queryProvider`和具有不同子句的查询属性，可以按照以下方式进行：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Using the `SqlPagingQueryProviderFactoryBean`, we can set the `select`, `from`,
    and `where` clauses separately, along with a sortkey and parameter to be passed.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`SqlPagingQueryProviderFactoryBean`，我们可以分别设置`select`、`from`、`where`子句，以及要传递的排序键和参数。
- en: Spring Batch supports different object relational frameworks as well the corresponding
    item readers such as `JpaPagingItemReader` for JPA and `IbatisPagingItemReader`
    for IBatis.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Batch支持不同的对象关系框架以及相应的项读取器，例如为JPA提供的`JpaPagingItemReader`和为IBatis提供的`IbatisPagingItemReader`。
- en: Data processing
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据处理
- en: Spring Batch provides the means to read input data in one form, process it,
    and return it in a desired form of output data. The `ItemProcessor` interface
    is the interface that supports the processing activity.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Batch提供了读取输入数据的一种形式，处理它，并以所需形式的输出数据返回的手段。`ItemProcessor`接口是支持处理活动的接口。
- en: ItemProcessor
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ItemProcessor
- en: Spring Batch provides the simple interface `ItemProcessor` to take the object,
    process it, and transform it to the desired form and return as another object.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Batch提供了简单的`ItemProcessor`接口来接收对象，对其进行处理，并将其转换为所需的格式，然后作为另一个对象返回。
- en: 'The following is the definition of the `ItemProcessor` interface:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对`ItemProcessor`接口的定义：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`ValidatingItemProcessor` is an implementation of the `ItemProcessor` that
    lets us validate the input data before processing. If the data fails to pass the
    validation, it gives `org.springframework.batch.item.validator.ValidationException`.
    Frameworks such as Hibernate have the validation framework (`hibernate-validator`)
    that lets us configure annotation-based validators for the beans.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValidatingItemProcessor`是`ItemProcessor`的一个实现，它允许我们在处理之前验证输入数据。如果数据未通过验证，则抛出`org.springframework.batch.item.validator.ValidationException`。例如，Hibernate这样的框架具有验证框架（`hibernate-validator`），允许我们为bean配置基于注解的验证器。'
- en: 'The `ItemProcessor` can be implemented for the `Employee` example as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`ItemProcessor`可以为`Employee`示例实现如下：'
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding program takes the `employee` data object, transforms the object,
    and returns an `Associate` data object.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序接收`employee`数据对象，转换对象，并返回一个`Associate`数据对象。
- en: 'The `itemProcessor` can be configured as a job chunk in the following format:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`itemProcessor`可以配置为以下格式的作业块：'
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Chaining the process
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接过程
- en: 'The processing activity can be chained by defining more than one item processor
    and calling from one another to make `compositeItemProcessor` as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义多个项处理器并将它们相互调用，可以链式处理活动，如下所示创建`compositeItemProcessor`：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Data writing
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据写入
- en: Spring Batch provides the configuration to write the read and processed data
    to a different output (destination). The writer can integrate easily with different
    relational frameworks. It can also be customized for the different formats.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Batch提供了将读取和处理的写入不同输出的配置。写入器可以轻松地与不同的关系型框架集成。它也可以针对不同的格式进行自定义。
- en: ItemWriter
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ItemWriter
- en: 'Spring Batch provides an interface in the form of `ItemWriter` to write bulk
    data. The following is the definition of the `ItemWriter` interface:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Batch提供了一个名为`ItemWriter`的接口来写入大量数据。以下是对`ItemWriter`接口的定义：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Based on the destination platform onto which we have to write the data, we
    have the following item writers:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们必须写入数据的目标平台，我们有以下项写入器：
- en: '**Flat file item writers**: These write the content onto a flat file (fixed
    width and delimited)'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平面文件项写入器**：这些将内容写入平面文件（固定宽度和分隔符）'
- en: '**XML item writers**: These write the data onto an XML file'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XML项写入器**：这些将数据写入XML文件'
- en: '**Database item writers**: These write the data onto a database'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库项写入器**：这些将数据写入数据库'
- en: Flat file item writers
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 平面文件项写入器
- en: The data read from any of the existing formats can be processed to the desired
    format and then be written onto multiple formats, including flat files. The following
    are the APIs that help in flat file item writing.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 从任何现有格式读取的数据可以处理成所需格式，然后写入到多种格式，包括平面文件。以下是一些帮助进行平面文件项写入的API。
- en: LineAggregator
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: LineAggregator
- en: The `LineAggregator` API concatenates multiple fields into a String to write
    onto the flat file. This works exactly the opposite way of `LineTokenizer` in
    the read operation.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`LineAggregator` API将多个字段连接成一个字符串以写入平面文件。这与读取操作中的`LineTokenizer`正好相反。'
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: PassThroughLineAggregator
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: PassThroughLineAggregator
- en: '`PassThroughLineAggregator` is an implementation of `LineAggreagator` that
    considers the object in use is already aggregated and simply returns the String
    from the object using the `toString()` method.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`PassThroughLineAggregator`是`LineAggreagator`的一个实现，它认为正在使用的对象已经聚合，并简单地使用`toString()`方法从对象返回字符串。'
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `FlatFileItemWriter` can be configured with the `PassThroughLineAggregator`
    , as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`FlatFileItemWriter`可以配置为`PassThroughLineAggregator`，如下所示：'
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: FieldExtractor
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FieldExtractor
- en: If the object writing is more than just writing its String form onto the file,
    `FieldExtractor` needs to be used, wherein each object gets converted to the array
    of fields, aggregated together to form a String to write onto the file.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象写入不仅仅是将其字符串形式写入文件，则需要使用`FieldExtractor`，其中每个对象都转换为字段数组，聚合在一起形成要写入文件的字符串。
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Field extractors are primarily of two types:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 字段提取器主要有两种类型：
- en: '`PassThroughFieldExtractor`: For the scenario where the object collection has
    to just be converted to the array and passed to write'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PassThroughFieldExtractor`：对于需要将对象集合仅转换为数组并传递以写入的场景'
- en: '`BeanWrapperFieldExtractor`: With a field-level configuration of how each field
    of the object gets placed in the String to write onto the file, this works exactly
    the opposite way of `BeanWrapperFieldSetMapper`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BeanWrapperFieldExtractor`：通过为对象的每个字段在写入文件时的字符串位置进行字段级配置，这与`BeanWrapperFieldSetMapper`正好相反。'
- en: 'The `BeanWrapperFieldSetExtractor` works as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`BeanWrapperFieldSetExtractor`的工作方式如下：'
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Writing delimited files
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 写入分隔符文件
- en: If the Java object can be written onto the flat files in delimited file format,
    we can perform it as shown in the following example. Let's consider the `Employee`
    object defined already.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Java对象可以以分隔符文件格式写入平面文件，我们可以像以下示例中那样执行。让我们考虑已经定义的`Employee`对象。
- en: 'This object can be configured with the `FlatFileItemWriter`, the `DelimitedLineAggregator`,
    and the `BeanWrapperFieldExtractor` to perform the delimited flat file, as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象可以使用 `FlatFileItemWriter`、`DelimitedLineAggregator` 和 `BeanWrapperFieldExtractor`
    进行配置，以执行分隔符平面文件，如下所示：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Writing a fixed width file
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 写入固定宽度文件
- en: 'Spring Batch supports fixed width file writing with the help of `FormatterLineAggregator`.
    Considering the same example data as delimited flat file writing, we can perform
    the fixed width file writing using the following configuration:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Batch 在 `FormatterLineAggregator` 的帮助下支持固定宽度文件写入。考虑到与分隔符平面文件写入相同的示例数据，我们可以使用以下配置执行固定宽度文件写入：
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The format value is formed based on the following listed formatter conversions,
    where `arg` represents the argument for conversion:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 格式值基于以下列出的格式化转换形成，其中 `arg` 代表转换的参数：
- en: '| Conversion | Category | Description |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 转换 | 类别 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `b`, `B` | general | This converts Boolean to the String format. The value
    is `false` for `null` |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `b`, `B` | 通用 | 这将布尔值转换为字符串格式。对于 `null`，值为 `false` |'
- en: '| `h`, `H` | general | This is the `Integer.toHexString(arg.hashCode())` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `h`, `H` | 通用 | 这是 `Integer.toHexString(arg.hashCode())` |'
- en: '| `s`, `S` | general | If `arg` implements `Formattable`, then `arg.formatTo()`
    Otherwise, `arg.toString()` |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `s`, `S` | 通用 | 如果 `arg` 实现 `Formattable`，则 `arg.formatTo()` 否则，`arg.toString()`
    |'
- en: '| `c`, `C` | character | This is a Unicode character |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `c`, `C` | 字符 | 这是一个 Unicode 字符 |'
- en: '| `d` | integral | This is a decimal integer |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `d` | 整数 | 这是一个十进制整数 |'
- en: '| `o` | integral | This is an octal integer |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `o` | 整数 | 这是一个八进制整数 |'
- en: '| `x`, `X` | integral | This is a hexadecimal integer |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `x`, `X` | 整数 | 这是一个十六进制整数 |'
- en: '| `e`, `E` | floating point | This is a decimal number in computerized scientific
    notation |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `e`, `E` | 浮点数 | 这是一个计算机化的科学记数法中的十进制数 |'
- en: '| `f` | floating point | This is a decimal number |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `f` | 浮点数 | 这是一个十进制数 |'
- en: '| `g`, `G` | floating point | This is a computerized scientific notation or
    decimal format, depending on the precision and value after rounding |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `g`, `G` | 浮点数 | 这是一种计算机化的科学记数法或十进制格式，具体取决于精度和四舍五入后的值 |'
- en: '| `a`, `A` | floating point | This is a hexadecimal floating point number with
    a significand and an exponent |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `a`, `A` | 浮点数 | 这是一个带有尾数和指数的十六进制浮点数 |'
- en: '| `t`, `T` | date/time | This is the prefix for date and time conversion characters
    |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `t`, `T` | 日期/时间 | 这是日期和时间转换字符的前缀 |'
- en: '| `%` | percent | This is a literal `%` (`\u0025`) |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `%` | 百分比 | 这是一个字面量 `%` (`\u0025`) |'
- en: '| `n` | line separator | This is the platform-specific line separator |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `n` | 行分隔符 | 这是特定平台的行分隔符 |'
- en: '`FlatFileItemWriter` can be configured with the `shouldDeleteIfExists` option,
    to delete a file if it already exists in the specified location. The header and
    footer can be added to the flat file by implementing `FlatFileHeaderCallBack`
    and `FlatFileFooterCallBack` and including these beans with the `headerCallback`
    and `footerCallback` properties respectively.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`FlatFileItemWriter` 可以配置 `shouldDeleteIfExists` 选项，如果指定位置已存在文件，则删除该文件。可以通过实现
    `FlatFileHeaderCallBack` 和 `FlatFileFooterCallBack` 并使用 `headerCallback` 和 `footerCallback`
    属性分别包含这些豆来向平面文件添加标题和页脚。'
- en: XML item writers
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XML 项目写入器
- en: 'The data can be written to the **Extensible Markup Language** (**XML**) format
    using `StaxEventItemWriter`. The Spring Batch configuration for this activity,
    for the employee example can be the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以使用 `StaxEventItemWriter` 写入到 **可扩展标记语言** (**XML**) 格式。对于员工示例，此活动的 Spring
    Batch 配置可以是以下内容：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Using the XStream to do the marshalling activity, the following is the configuration:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 XStream 进行序列化活动，以下是其配置：
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The Java code for the preceding configuration can be realized as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 前述配置的 Java 代码可以如下实现：
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Database item writers
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库项目写入器
- en: 'Spring Batch supports database item writing with two possible access types:
    JDBC and ORM.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Batch 支持两种可能的数据库项目写入访问类型：JDBC 和 ORM。
- en: JDBC-based database writing
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于JDBC的数据库写入
- en: 'Spring Batch supports JDBC-based database writing with the help of `JdbcBatchItemWriter`,
    which is an implementation of `ItemWriter`, which executes multiple SQL statements
    in the batch mode. The following is the sample configuration for the employee
    example with the JDBC-based database writing:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Batch 在 `JdbcBatchItemWriter` 的帮助下支持基于 JDBC 的数据库写入，`JdbcBatchItemWriter`
    是 `ItemWriter` 的一个实现，它以批处理模式执行多个 SQL 语句。以下是基于 JDBC 的数据库写入的员工示例的样本配置：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `ItemPreparedStatementSetter` can be implemented for our example of `Employee`
    data as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 可以按照以下方式为我们的`Employee`数据示例实现`ItemPreparedStatementSetter`：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ORM-based database writing
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于ORM的数据库写入
- en: '**Object** **relational mapping** (**ORM**) is defined as a programming technique
    to convert data between incompatible type systems in object-oriented programming
    languages. ORM takes care of the data persistence from the object oriented program
    to the database. Spring Batch supports multiple ORMs including Hibernate, JPA,
    and iBatis.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象关系映射**（**ORM**）被定义为一种编程技术，用于在面向对象编程语言中将数据在不可兼容的类型系统之间进行转换。ORM负责从面向对象程序到数据库的数据持久化。Spring
    Batch支持多个ORM，包括Hibernate、JPA和iBatis。'
- en: '![ORM-based database writing](img/3372OS_03_03.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![基于ORM的数据库写入](img/3372OS_03_03.jpg)'
- en: 'In our example, the `Employee` class should be annotated to be used with ORM
    (Hibernate/JPA) for persistence as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，`Employee`类应该被注释为与ORM（Hibernate/JPA）一起使用，以便进行持久化，如下所示：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The annotations specify that the class `Employee` is representing a corresponding
    table in the database with a name as shown with `@Entity`, and each field corresponds
    to a column in the database as shown with the `@ID` and `@Column` annotations.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注释指定类`Employee`代表数据库中相应的表，其名称由`@Entity`所示，并且每个字段对应数据库中的一个列，如`@ID`和`@Column`注释所示。
- en: 'The following is the configuration to be made with Hibernate for the employee
    example:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的配置是针对员工示例使用Hibernate进行的：
- en: '[PRE42]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Similarly, for JPA and iBatis, the configurations can be made with `JpaItemWriter`
    and `IbatisBatchItemWriter` respectively.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对于JPA和iBatis，可以通过`JpaItemWriter`和`IbatisBatchItemWriter`分别进行配置。
- en: Custom item readers and writers
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义项目读取器和写入器
- en: Spring Batch supports custom item readers' and writers' configurations. This
    can be done easily by implementing the `ItemReader` and `ItemWriter` interfaces
    for the respective read and write operations with the business logic we want,
    and configuring the `ItemReader` and `ItemWriter` in the XML batch configuration.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Batch支持自定义项目读取器和写入器的配置。这可以通过实现`ItemReader`和`ItemWriter`接口来完成，这些接口分别用于执行所需的读取和写入操作，并带有我们想要的企业逻辑，然后在XML批配置中配置`ItemReader`和`ItemWriter`。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Through this chapter we learned the essential data handling mechanisms, including
    reading the data from different sources (such as flat files, XML, and databases),
    processing the data, and writing the data to different destinations including
    flat files, XML, and databases. We also learned about transforming and validating
    the data in the processing data section. We finished this chapter with an understanding
    of the Spring Batch support to custom formats by implementing the interface to
    match the business needs that are different from the default formats. In the next
    chapter, we will learn about managing the transactions with diverse configurations
    and patterns in detail.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，我们学习了基本的数据处理机制，包括从不同的来源（如平面文件、XML和数据库）读取数据，处理数据，并将数据写入不同的目的地，包括平面文件、XML和数据库。我们还学习了在数据处理部分转换和验证数据。我们通过理解Spring
    Batch通过实现接口来支持自定义格式，以匹配与默认格式不同的业务需求来完成本章。在下一章中，我们将详细了解使用不同配置和模式管理事务。
