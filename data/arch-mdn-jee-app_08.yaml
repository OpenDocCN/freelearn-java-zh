- en: Microservices and System Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务和系统架构
- en: The previous chapters covered how to develop a single enterprise application
    with Java EE. Modern applications contain infrastructure and configuration definitions
    as code, making it possible to create environments in automated ways, either on
    premises or in cloud platforms. Continuous Delivery pipelines together with sufficient,
    automated test cases make it possible to deliver enterprise applications with
    high quality and productivity. Modern zero-dependency Java EE approaches support
    these efforts.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 前几章介绍了如何使用Java EE开发单一的企业应用程序。现代应用程序包含基础设施和配置定义作为代码，使得能够在自动化的方式下创建环境，无论是在本地还是在云平台上。持续交付管道与足够的自动化测试案例一起，使得能够以高质量和高效能交付企业应用程序。现代零依赖Java
    EE方法支持这些努力。
- en: Enterprise systems rarely come with single responsibilities that could be reasonably
    mapped into single enterprise applications. Traditionally, enterprise applications
    combined multiple aspects of the business into monolithic applications. The question
    is, whether this approach to crafting distributed systems is advisable.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 企业系统很少具有单一责任，这些责任可以合理地映射到单一的企业应用程序中。传统上，企业应用程序将商业的多个方面结合到单体应用程序中。问题是，这种构建分布式系统的方法是否可取。
- en: 'This chapter will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖：
- en: The motivations behind distribution
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布背后的动机
- en: Possibilities and challenges of distributed systems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式系统的可能性和挑战
- en: How to design interdependent applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设计相互依赖的应用程序
- en: Application boundaries, APIs, and documentation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序边界、API和文档
- en: Consistency, scalability, challenges, and solutions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一致性、可扩展性、挑战和解决方案
- en: Event sourcing, event-driven architectures, and CQRS
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件溯源、事件驱动架构和CQRS
- en: Microservice architectures
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构
- en: How Java EE fits the microservice world
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java EE如何适应微服务世界
- en: How to realize resilient communication
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现弹性通信
- en: Motivations behind distributed systems
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式系统背后的动机
- en: One of the first questions should ask for the need for distribution. There are
    several technical motivations behind designing distributed systems.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 应该首先询问的第一个问题是分布的需求。设计分布式系统背后有几个技术动机。
- en: Typical enterprise scenarios are in essence distributed. Users or other systems
    that are spread across locations need to communicate with a service. This needs
    to happen over the network.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的企业场景本质上都是分布式的。分布在不同地点的用户或其他系统需要与一个服务进行通信。这需要在网络上发生。
- en: Another reason is scalability. If a single application reaches the point where
    it cannot reliably serve the overall load of clients, the business logic needs
    to be distributed to multiple hosts.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因是可扩展性。如果一个单一的应用程序达到无法可靠地服务整体客户负载的程度，业务逻辑就需要分布到多个主机上。
- en: A similar reasoning aims toward a system's fault tolerance. Single applications
    represent single points of failure; if the single application is unavailable,
    the service won't be usable by the clients. Distributing services to multiple
    locations increases availability and resilience.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的推理旨在提高系统的容错性。单一应用程序代表单一故障点；如果单一应用程序不可用，服务将无法被客户端使用。将服务分布到多个位置可以增加可用性和弹性。
- en: There are also other less technology-driven motivations. An application represents
    certain business responsibilities. In Domain-Driven Design language they are contained
    in the application's **bounded context**. Bounded contexts include the business
    concerns, logic, and data of the application and differentiate it from external
    concerns.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，也有其他一些不那么技术驱动的动机。一个应用程序代表某些业务责任。在领域驱动设计语言中，它们包含在应用程序的**边界上下文**中。边界上下文包括应用程序的业务关注点、逻辑和数据，并将其与外部关注点区分开来。
- en: In the same way as engineers cluster code responsibilities into packages and
    modules, it certainly makes sense to craft contexts on a system scale as well.
    Coherent business logic and functionality is grouped into separate services as
    part of separate applications. The data and schema is also part of a bounded context.
    It can therefore be encapsulated into several database instances, which are owned
    by the corresponding distributed applications.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与工程师将代码责任聚类到包和模块中一样，在系统规模上构建上下文也肯定是有意义的。一致的业务逻辑和功能作为单独应用程序的一部分被分组到单独的服务中。数据和模式也是边界上下文的一部分。因此，它可以封装到几个数据库实例中，这些实例由相应的分布式应用程序拥有。
- en: Challenges of distribution
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布的挑战
- en: With all these motivations, especially technical ones such as scalability, why
    shouldn't engineers distribute everything then? Distribution comes with certain
    overheads.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些动机中，尤其是像可扩展性这样的技术动机，为什么工程师不应该将一切分散呢？分散伴随着一定的开销。
- en: In general, the overall overhead that comes on top of the system's distilled
    business logic will be multiplied by the number of applications involved. For
    example, a single, monolithic application requires a monitoring solution. Distributing
    this application will cause all resulting applications to be monitored as well.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，系统提炼出的业务逻辑之上的整体开销将乘以涉及的应用程序数量。例如，一个单一、单体应用程序需要一个监控解决方案。分散这个应用程序将导致所有结果应用程序也需要被监控。
- en: Communication overhead
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通信开销
- en: In distribution, first of all, there is an overhead cost in communicating between
    systems.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式中，首先，系统之间通信存在一定的开销成本。
- en: Technology is very effective in communicating within a single process. There
    is effectively no overhead in calling functionality that is part of the application.
    As soon as inter-process or remote communication is required, engineers have to
    define interface abstractions. Communication protocols such as HTTP have to be
    defined and used in order to exchange information.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 技术在单个进程内的通信非常有效。调用应用程序部分的功能几乎没有开销。一旦需要进程间或远程通信，工程师必须定义接口抽象。需要定义和使用HTTP等通信协议来交换信息。
- en: This requires certain time and effort. Communication between applications has
    to be defined, implemented, and maintained. Within a single application, the communication
    is reflected in method invocations.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要一定的时间和努力。应用程序之间的通信需要定义、实现和维护。在单个应用程序中，通信体现在方法调用上。
- en: The required communication also becomes a concern of the business use case.
    It can no longer be assumed that certain functionality or data can be just used
    without any overhead. Communicating with the distributed system becomes a responsibility
    of the application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的通信也成为业务用例的担忧。不能再假设某些功能或数据可以无开销地使用。与分布式系统的通信成为应用程序的责任。
- en: Performance overhead
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能开销
- en: Distributing applications at first decreases performance of the overall systems.
    Computer networks are slower than communication within a single host. Therefore
    networking will always come with a certain performance overhead.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在一开始分散应用程序会降低整体系统的性能。计算机网络比单个主机内的通信要慢。因此，网络总是伴随着一定的性能开销。
- en: The overhead in performance is not only caused by the communication itself,
    but also the need to synchronize. Synchronization within a single process already
    consumes certain processing time, and this impact is much bigger when distribution
    is involved.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 性能开销不仅由通信本身引起，还包括同步的需要。在单个进程内的同步已经消耗了一定的处理时间，当涉及到分布式时，这种影响更大。
- en: However, despite this overhead in performance, distribution eventually increases
    the overall performance of the system as its applications scale out. Scaling horizontally
    always comes with a certain performance overhead compared to a single instance.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管性能开销存在，但随着应用的扩展，分布式最终会增加系统的整体性能。与单个实例相比，水平扩展总是伴随着一定的性能开销。
- en: Organizational overhead
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织开销
- en: Distributed systems containing several applications certainly need more organizational
    effort than a single one.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 包含多个应用程序的分布式系统当然需要比单个应用程序更多的组织努力。
- en: Multiple applications imply multiple deployments that need to be managed. Deploying
    new versions may have an impact on dependent applications. Teams need to ensure
    that versions of deployed applications work together well. Single, monolithic
    applications are not affected by this since they are consistent within themselves.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 多个应用程序意味着需要管理的多个部署。部署新版本可能会影响依赖的应用程序。团队需要确保部署的应用程序版本能够良好地协同工作。单一、单体应用程序不受此影响，因为它们在自身内部是一致的。
- en: Besides that, multiple applications are developed in several projects and repositories,
    usually by multiple development teams. In particular, having multiple teams requires
    communication, not necessarily technically, but human-related communication. In
    the same way as for deploying applications, responsibilities, system boundaries,
    and dependencies need to be agreed upon.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，多个应用在多个项目和存储库中开发，通常由多个开发团队完成。特别是，拥有多个团队需要沟通，不一定是技术上的，而是与人类相关的沟通。与部署应用一样，需要就职责、系统边界和依赖达成一致。
- en: How to design systems landscapes
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何设计系统景观
- en: With all of these challenges and overheads involved, a lot of scenarios still
    require distribution. It's important to mention, that there must be enough motivation
    behind distributing systems. Distribution comes with costs and risks. If it's
    not necessary to distribute, building monolithic applications is always to be
    preferred.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在涉及所有这些挑战和开销的情况下，许多场景仍然需要分布式处理。重要的是要提到，分布式系统必须有足够的动机。分布式处理伴随着成本和风险。如果不是必须分布式处理，构建单体应用始终是首选。
- en: Now, let's look into how to design reasonable system landscapes, tailored for
    business requirements.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看如何设计合理的系统景观，以满足业务需求。
- en: Context maps and bounded contexts
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文映射和边界上下文
- en: '**Bounded contexts** define the application''s responsibilities in business
    logic, behavior, and data ownership. So-called **context maps**, as described
    in Domain-Driven Design, represent the entire system landscape. It shows the individual
    responsibilities, contexts, and belongings of its applications. Bounded contexts
    therefore fit within a context map to show how they exchange information among
    each other.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**边界上下文**定义了应用在业务逻辑、行为和数据所有权方面的职责。所谓的**上下文映射**，如领域驱动设计中所描述的，代表了整个系统景观。它显示了应用的个别职责、上下文和所属关系。因此，边界上下文适合在上下文映射中展示它们之间如何交换信息。'
- en: 'The following shows the context map of the *cars* domain, including two bounded
    contexts:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了*汽车*领域的上下文映射，包括两个边界上下文：
- en: '![](img/cab69c57-671a-4028-b544-a1a602df0f2b.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cab69c57-671a-4028-b544-a1a602df0f2b.png)'
- en: It's advisable to consider the different responsibilities of the system before
    designing and carving out applications. Lack of clarity on an application's responsibilities
    usually emerges quickly as soon as the system's context map is recorded.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计和划分应用之前，考虑系统的不同职责是明智的。一旦记录了系统的上下文映射，通常很快就会出现对应用职责的缺乏清晰性。
- en: Context maps are not only helpful during the initial project definition, but
    also during revisiting and refining responsibilities once business functionality
    changes. In order to prevent the boundaries and belongings of distribution applications
    from drifting apart, it's advisable to reflect on them from time to time.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文映射不仅在项目定义的初期有帮助，而且在业务功能发生变化后重新审视和细化职责时也有帮助。为了防止分布式应用的边界和所属关系分离，建议不时地反思它们。
- en: Separation of concerns
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关注点的分离
- en: The application's responsibilities should be clearly defined and differentiated
    from other applications.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 应该清楚地定义应用程序的职责，并与其他应用程序区分开来。
- en: In the same way as with code level, the concerns of several applications should
    be separated. The single responsibility principle holds true here as well.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在代码级别一样，几个应用的关注点应该被分离。单一职责原则在这里同样适用。
- en: The application's concerns include all business concerns, application boundaries,
    and owned data. As the business logic evolves and changes over time, these concerns
    should be revisited from time to time. This may result in applications that split
    up or get merged into single ones. The responsibilities and concerns that emerge
    from the context map should be reflected in the system's applications.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的关注点包括所有业务关注点、应用边界和拥有的数据。随着业务逻辑随时间发展和变化，这些关注点应该不时地重新审视。这可能导致应用被分割或合并成单个应用。上下文映射中出现的职责和关注点应在系统的应用中得到反映。
- en: Data and data ownership is an important aspect of distributed applications.
    The business processes, being part of the bounded context defines the data involved
    in the use cases. Owned data are a concern of the specific applications and are
    only shared via the defined boundaries. Use cases that require data that is under
    the responsibility of another, remote application need to retrieve the information
    by remotely invoking the corresponding use cases.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 数据和数据所有权是分布式应用的一个重要方面。业务流程，作为边界上下文的一部分，定义了用例中涉及的数据。所有数据是特定应用的关注点，并且仅通过定义的边界进行共享。需要从其他，远程应用负责的数据的用例需要通过远程调用相应的用例来检索信息。
- en: Teams
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 团队
- en: Teams and organizational structure are other important aspects to consider when
    designing distributed systems, since, as of writing this book, software is developed
    by humans. Considering Conway's law, that the organization's communication structure
    will eventually leak into the constructed system, teams should be defined similarly
    to the applications in the system.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计分布式系统时，团队和组织结构是其他需要考虑的重要方面，因为截至撰写本书时，软件是由人类开发的。考虑到康威定律，即组织的沟通结构最终会渗透到构建的系统之中，团队应该与系统中的应用类似地进行定义。
- en: Or, in other words, it makes sense for a single application to be developed
    by only a single team. Depending on the responsibilities and sizes, a single team
    can potentially craft multiple applications.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 或者换句话说，一个应用只由一个团队开发是有意义的。根据责任和规模，一个团队可以潜在地创建多个应用。
- en: Again, comparing to the project code structure, this is a similar approach as
    horizontal versus vertical module layering. Similar to business motivated module
    structures, teams are therefore organized vertically, representing the structure
    of the context map. For example, rather than having several expert teams on software
    architecture, development, or operations, there will be teams for *car manufacture*,
    *assembly line*, and *order management*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，与项目代码结构相比，这是水平与垂直模块层叠的类似方法。与业务驱动的模块结构类似，因此团队是垂直组织的，代表着上下文地图的结构。例如，而不是在软件架构、开发或运维上有几个专家团队，将会有汽车制造、装配线和订单管理团队。
- en: Project life cycles
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目生命周期
- en: With individual teams being involved in developing distributed systems, applications
    will have independent project life cycles. This includes the way teams operate,
    for example, how they organize their sprint cycles.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于个人团队参与开发分布式系统，应用将拥有独立的工程生命周期。这包括团队运作的方式，例如，他们如何组织他们的冲刺周期。
- en: The deployment cycles and schedules also emerge from the project life cycle.
    For the overall system to stay consistent and functional, potential dependencies
    on deployments of other applications need to be defined. This does not only target
    the application's availability.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 部署周期和计划也来自项目生命周期。为了使整个系统保持一致和功能，需要定义对其他应用部署的潜在依赖。这不仅仅针对应用的可用性。
- en: Deployed application versions need to be compatible. In order to ensure this,
    applications that are dependent need to be clearly represented in the context
    map. Teams will have to communicate when dependent services introduce changes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 部署的应用版本需要兼容。为了确保这一点，依赖的应用需要在上下文地图中明确表示。当依赖的服务引入更改时，团队将不得不进行沟通。
- en: Again, painting a clear context map containing the bounded contexts helps define
    the interdependent applications and their responsibilities.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，绘制一个清晰的上下文地图，包含边界上下文，有助于定义相互依赖的应用及其责任。
- en: How to design system interfaces
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何设计系统接口
- en: After the responsibilities of the system landscape have been defined, the boundaries
    of dependent systems need to be specified.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了系统景观的责任之后，需要指定依赖系统的边界。
- en: 'In previous chapters, we have seen various communication protocols and how
    to implement them. Besides the actual implementation, the question is now: how
    to design the interfaces of applications? Which aspects need to be considered,
    especially in distributed systems?'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了各种通信协议及其实现方法。除了实际实现之外，现在的问题是：如何设计应用的接口？在分布式系统中，哪些方面需要考虑？
- en: API considerations
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API 考虑因素
- en: The applications within a system are carved out based on their business responsibilities.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 系统中的应用是基于它们的业务责任划分的。
- en: Similarly, the application's API should represent that business logic as well.
    The exposed API represents the business use cases a certain application comprises.
    This implies that a business domain expert can, without any further technical
    knowledge, identify the exposed business use cases from an API.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，应用程序的API也应代表业务逻辑。公开的API代表了某个应用程序包含的业务用例。这意味着业务领域专家可以在没有任何进一步的技术知识的情况下，从API中识别出公开的业务用例。
- en: The business use cases are ideally offered in clear, lean interfaces. Invoking
    a use case should not require more technically-motivated communication steps or
    details than being part of the business logic. For example, if the *create a car*
    use case could be invoked as a single operation, the API of the *car manufacture*
    application should not require multiple invocations providing technical details.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 商业用例理想情况下应提供清晰、简洁的接口。调用用例不应需要比作为业务逻辑的一部分更多的技术动机的通信步骤或细节。例如，如果“创建汽车”用例可以作为单一操作调用，那么“汽车制造”应用程序的API就不应需要多次调用提供技术细节。
- en: An API should abstract the business logic in a clear, lean interface.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一个API应该通过清晰、简洁的接口抽象业务逻辑。
- en: The API should therefore be decoupled from the application's implementation.
    The interface implementation should be independent from the chosen technology.
    This also implies that a communication format is chosen that doesn't set many
    constraints on the used technology.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，API 应该与应用程序的实现解耦。接口实现应独立于所选技术。这也意味着选择了一种不设置太多约束于所用技术的通信格式。
- en: It therefore makes sense to prefer technology that sets on standard protocols
    such as HTTP. It's more likely that engineer have knowledge in commonly used protocols,
    as that are supported by various technologies and tools. Creating application
    interfaces in HTTP web services allows clients to be developed in every technology
    that supports HTTP.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，优先选择基于标准协议（如HTTP）的技术是有意义的。工程师更有可能了解常用协议，因为它们被各种技术和工具所支持。在HTTP网络服务中创建应用程序接口允许在支持HTTP的任何技术中开发客户端。
- en: Abstracting the business logic in clear, lean interfaces that use standard protocols
    also enables change in used implementations, technologies, and platforms. Java
    Enterprise applications that only expose HTTP services could replace their technology
    with other implementations, without requiring dependent clients to change.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准协议的清晰、简洁接口抽象业务逻辑，也使得在使用的实现、技术和平台上进行更改成为可能。仅公开HTTP服务的Java企业应用程序可以用其他实现替换其技术，而无需要求依赖的客户端进行更改。
- en: Interface management
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口管理
- en: Application interfaces are often subject to change during the development process.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序接口在开发过程中经常发生变化。
- en: New business use cases are included and existing one refined. The question is,
    how are these changes reflected in the API?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 新的商业用例被包含进来，现有的用例被细化。问题是，这些更改如何在API中反映出来？
- en: It depends on the nature and environment of the enterprise application how stable
    the API needs to be. If the project team is both in charge of the service, all
    clients and their life cycles, the API can introduce arbitrary changes that are
    reflected in the clients at the same time. The case is the same if for some reason
    the life cycles of involved applications are identical.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 企业应用程序的性质和环境决定了API需要有多稳定。如果项目团队负责服务、所有客户端及其生命周期，API可以引入任意更改，这些更改同时反映在客户端上。如果涉及的应用程序的生命周期由于某种原因相同，情况也是如此。
- en: Usually, life cycles of distributed systems aren't that tightly coupled. For
    any other client/server model, or applications that have different life cycles,
    the APIs must not break existing clients. This means that the APIs are fully backwards-compatible,
    not introducing breaking changes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，分布式系统的生命周期并不那么紧密耦合。对于任何其他客户端/服务器模型，或者具有不同生命周期的应用程序，API不得破坏现有客户端。这意味着API是完全向后兼容的，不引入破坏性更改。
- en: Change-resilient APIs
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抗变API
- en: There are certain principles in designing interfaces that prevent unnecessary
    breaks. For example, introducing new, optional payload data should not break the
    contract. Technology should be resilient as far as it can continue to work if
    all necessary data is provided. This matches the idea of *being conservative in
    what you do and liberal in what you accept*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计接口时有一些原则可以防止不必要的中断。例如，引入新的、可选的有效负载数据不应破坏合同。技术应该具有弹性，只要提供所有必要的数据，它就可以继续工作。这与“在所做的事情上保守，在所接受的事情上自由”的想法相符。
- en: Therefore adding new, optional functionality or data should be possible without
    breaking clients. But what if existing logic changes?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在不破坏客户端的情况下，应该能够添加新的、可选的功能或数据。但如果是现有逻辑发生变化呢？
- en: Breaking the business logic
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 破坏业务逻辑
- en: The question to be asked here is what a breaking change in the API means for
    the business use case. Is the application's past behavior not valid anymore? Should
    the client have to stop working from now on?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要问的问题是API中的破坏性变更对业务用例意味着什么。应用程序的过去行为是否不再有效？客户端是否必须从现在开始停止工作？
- en: This is equivalent to, for example, a vendor of a widely-used smartphone app
    that decides to break existing versions and to force the users to update the installations
    to its latest version. There is arguably no need in doing so for existing functionality
    to continue.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于，例如，一个广泛使用的智能手机应用的供应商决定破坏现有版本，并强迫用户更新到其最新版本。在继续使用现有功能方面，这样做可能没有必要性。
- en: If for some reason the existing use cases can't be used *as is* anymore, some
    additional, compensating business logic should be considered.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因，现有的用例不能再“原样”使用，应考虑一些额外的、补偿性的业务逻辑。
- en: Hypermedia REST and versioning
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超媒体REST和版本控制
- en: Hypermedia REST APIs can bring some relief with this issue. In particular, Hypermedia
    controls provide the ability to evolve the API by dynamically defining resource
    links and actions. The clients of the REST service will adapt to the changes in
    accessing the services and considerately ignore unknown functionality.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 超媒体REST API可以在这方面提供一些缓解。特别是，超媒体控制提供了通过动态定义资源链接和操作来演进API的能力。REST服务的客户端将适应访问服务的变更，并考虑性地忽略未知的功能。
- en: A quite often suggested possibility is to version the API. This means introducing
    different operations or resources, such as `/car-manufacture/v1/cars`, with the
    version as the identifying part of the API. Versioning APIs, however, contradicts
    the idea of clean interfaces. In particular, since REST APIs resources represent
    domain entities, introducing several *versions* of a car doesn't make sense in
    business terms. The car entity is identified by its URI. Changing the URI to reflect
    changes in the business functionality would imply a change to the car's identity.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经常建议的可能性是对API进行版本控制。这意味着引入不同的操作或资源，例如`/car-manufacture/v1/cars`，其中版本是API的标识部分。然而，对API进行版本控制与干净接口的理念相矛盾。特别是，由于REST
    API资源代表领域实体，引入多个“版本”的汽车在商业术语上没有意义。汽车实体由其URI标识。将URI更改以反映业务功能的变化意味着对汽车身份的更改。
- en: Sometimes several, different representations, or versions, of the same domain
    entities are required, for example, JSON mappings containing different sets of
    properties. Via HTTP interface this is achievable via **content negotiation**,
    by defining content type parameters. For example, different JSON representations
    for the same car can be requested via content types such as `application/json;vnd.example.car+v2`,
    if supported by the corresponding service.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要同一领域实体的几个不同表示或版本，例如包含不同属性集的JSON映射。通过HTTP接口，这可以通过**内容协商**实现，通过定义内容类型参数。例如，可以通过内容类型如`application/json;vnd.example.car+v2`请求同一辆车的不同JSON表示，如果相应的服务支持的话。
- en: Managing interfaces is a relevant topic for distributed systems. It's advisable
    to carefully design APIs upfront, with backwards-compatibility in mind. Extra
    efforts, such as additional operations that prevent an API from breaking existing
    functionality, should be preferred over clean interfaces that disrupt clients.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 管理接口是分布式系统的一个相关主题。建议在考虑向后兼容性的情况下提前仔细设计API。应优先考虑额外的操作，以防止API破坏现有功能，而不是破坏客户端的干净接口。
- en: Documenting boundaries
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录边界
- en: Application boundaries that define APIs to invoke the application's business
    logic need to be made public to its clients, for example, other applications within
    the system. The question is, what information needs to be documented?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 定义API以调用应用程序业务逻辑的应用程序边界需要对其客户端公开，例如系统内的其他应用程序。问题是，需要记录哪些信息？
- en: The application's bounded context is part of the context map. Therefore, the
    domain responsibilities should be clear. The application fulfills certain business
    use cases within its context.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的边界上下文是上下文图的一部分。因此，领域责任应该是清晰的。应用程序在其上下文中完成某些业务用例。
- en: This domain information needs to be documented first. Clients should be aware
    of what the application offers. This includes the use cases as well as the exchanged
    information and data ownership.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这种领域信息需要首先记录。客户端应该了解应用程序提供的内容。这包括用例以及交换的信息和数据所有权。
- en: The responsibility of the *car manufacture* application is to assemble cars
    due to provided, exact specifications. The status information of manufactured
    cars is owned by the application for the whole process of assembling, until the
    car reaches the end of the production line and is ready for delivery. The application
    can be polled to provide status updates about the creation process of a car.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**汽车制造**应用程序的责任是根据提供的精确规格组装汽车。制造汽车的状态信息由应用程序在整个组装过程中拥有，直到汽车到达生产线末端并准备交付。应用程序可以被轮询以提供有关汽车创建过程的更新状态。'
- en: The application's domain description should contain the information the clients
    require, be precise in responsibilities, but not too verbose, only exposing what
    clients *need to know*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的领域描述应包含客户端所需的信息，职责明确，但不要过于冗长，仅暴露客户端*需要知道*的内容。
- en: Besides the business domain, there are technical aspects that need to be documented.
    Client applications need to be programmed against a system's API. They require
    information about the communication protocols, as well as data formats.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 除了业务领域，还需要记录技术方面的内容。客户端应用程序需要针对系统的API进行编程。它们需要有关通信协议以及数据格式的信息。
- en: We covered several communication protocols and how to implement them in the
    second chapter of this book. At the time of writing, one of the most used protocols
    is HTTP, together with JSON or XML content types. With the example of HTTP, what
    needs to be documented?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书的第二章中介绍了几个通信协议及其实现方法。在撰写本文时，最常用的协议之一是HTTP，以及JSON或XML内容类型。以HTTP为例，需要记录什么内容？
- en: HTTP endpoints, especially those following the REST constraints, represent the
    domain entities as resources, locatable by URLs. The available URLs need to be
    documented first. Clients will connect against these URLs in order to perform
    some business use cases. For example, the `/car-manufacture/cars/<car-id>` URL
    will refer to a particular car specified by its identifier.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP端点，尤其是遵循REST约束的端点，将领域实体作为资源表示，可以通过URL进行定位。首先需要记录可用的URL。客户端将连接到这些URL以执行某些业务用例。例如，`/car-manufacture/cars/<car-id>`
    URL将引用由其标识符指定的特定汽车。
- en: The content type with detailed mapping information needs to be documented as
    well. Clients need to be aware of the structure and properties within the used
    content type.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记录具有详细映射信息的内容类型。客户端需要了解所使用内容类型中的结构和属性。
- en: 'For example, a car specification that is provided in order to create a car
    contains an *identifier*, an *engine type,* and a *chassis color*. The JSON format
    will look as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了创建汽车而提供的汽车规格包含一个*标识符*、一个*引擎类型*和一个*底盘颜色*。JSON格式如下所示：
- en: '[PRE0]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The types and available values need to be documented as well. They will point
    to the business domain knowledge, the semantics behind an engine type. This is
    important, that both the content types as well as the semantics of the information
    are documented.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记录类型和可用的值。这将指向业务领域知识，以及引擎类型背后的语义。这一点很重要，即内容类型以及信息的语义都需要进行记录。
- en: In the case of HTTP there will be more aspects to be documented such as potentially
    required header information, status codes provided by the web service, and so
    on.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTTP的情况下，需要记录的方面将更多，例如可能需要的头部信息、由网络服务提供的状态码等。
- en: All this documentation certainly depends on the used technology and communication
    protocol. The business domain, however, should also be part of the documentation,
    providing as much context as required.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些文档当然取决于所使用的技术和通信协议。然而，业务领域也应该包含在文档中，提供所需的所有上下文。
- en: The application's API documentation is part of the software project. It needs
    to be shipped together with the application in a particular version.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的API文档是软件项目的一部分。它需要与应用程序一起以特定版本发布。
- en: In order to ensure that the documentation matches the application's version,
    it should be part of the project repository, residing under version control as
    well. Therefore, it's highly advisable to use text-based documentation formats
    instead of binary formats such as Word documents. Lightweight markup languages
    such as **AsciiDoc** or **Markdown** have proven themselves well in the past.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保文档与应用程序的版本一致，它应该是项目存储库的一部分，位于版本控制之下。因此，强烈建议使用基于文本的文档格式，而不是像Word文档这样的二进制格式。轻量级标记语言如**AsciiDoc**或**Markdown**在过去已经证明了自己非常有效。
- en: The benefit of maintaining the documentation directly in the project, next to
    the application's sources, is to ensure the creation of documentation versions
    that are consistent with the developed service. Engineers are able to perform
    both changes in one step. Doing so prevents the documentation and service version
    from diverging.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目内直接维护文档，紧邻应用程序的源代码，可以确保创建与开发的服务一致的文档版本。工程师能够一步完成更改。这样做可以防止文档和服务版本出现分歧。
- en: There is a lot of tool support in documenting application boundaries depending
    on the communication technology. For HTTP web services for example, the **OpenAPI
    Specification** together with **Swagger** as a documentation framework are widely
    used. Swagger outputs the API definition as browsable HTML, making it easy for
    developers to identify the offered resources together with their usages.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 根据通信技术，在记录应用程序边界方面有很多工具支持。例如，对于HTTP Web服务，**OpenAPI规范**与**Swagger**作为文档框架被广泛使用。Swagger将API定义输出为可浏览的HTML，这使得开发者能够轻松地识别提供的资源及其用法。
- en: Using Hypermedia REST services, however, gets rids of the biggest necessity
    of service documentation. Providing the information of which resources are available
    in links removes the need for documenting URLs. In fact, the server gets back
    the control of how URLs are constructed. Clients only enter an entry point, for
    example `/car-manufacture/`, and follow the provided Hypermedia links based on
    their relations. The knowledge what a car URL consists of solely resides on the
    server side and is explicitly not documented.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用超媒体REST服务消除了服务文档的最大必要性。通过在链接中提供有关哪些资源可用，消除了记录URL的需求。实际上，服务器重新获得了如何构造URL的控制权。客户端只需输入一个入口点，例如`/car-manufacture/`，然后根据它们的关系遵循提供的超媒体链接。关于汽车URL由哪些部分组成的知识仅存在于服务器端，并且明确没有进行文档记录。
- en: 'This is especially true for Hypermedia controls, not only directing the client
    to resources, but providing information on how to consume it. The *car manufacture*
    service that tells a client how to perform the `create-car` action: A POST request
    to `/car-manufacture/cars` is needed, including a request body in JSON content
    type with properties `identifier`, `engine-type`, and `color`.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于超媒体控制尤其如此，它不仅指导客户端访问资源，还提供有关如何消费这些资源的信息。例如，*汽车制造*服务告诉客户端如何执行`create-car`动作：需要向`/car-manufacture/cars`发送POST请求，包括一个JSON内容类型的请求体，其中包含`identifier`、`engine-type`和`color`属性。
- en: The client needs to know the semantics of all relations and action names as
    well as the properties and where they originate. This is certainly client logic.
    All information on how to consume the API becomes part of the API. Designing REST
    services then eliminates the need for a lot of documentation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 客户需要了解所有关系和动作名称的语义，以及它们的属性和来源。这当然属于客户端逻辑。有关如何消费API的所有信息都成为API的一部分。因此，设计REST服务消除了大量文档的需求。
- en: Consistency versus scalability
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一致性与可扩展性
- en: Certainly it's necessary for distributed system to communicate. Since computer
    networks cannot be considered as reliable, even not in company-internal networks,
    reliable communication is a necessity. Business use cases are required to communicate
    in a reliable way, in order to ensure correct behavior.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，分布式系统进行通信是必要的。由于计算机网络不能被认为是可靠的，甚至在公司内部网络中也是如此，可靠的通信是必需的。为了确保正确的行为，业务用例需要以可靠的方式进行通信。
- en: Earlier in this book, we introduced the so-called CAP theorem that claims that
    it's impossible for distributed data stores to guarantee at most two of the three
    specified constraints. Systems can effectively choose whether they want to guarantee
    consistency or horizontal scalability. This highly affects the communication in
    a distributed world.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的早期，我们介绍了所谓的CAP定理，该定理声称分布式数据存储无法保证最多两个指定的约束。系统可以有效地选择它们是否想要保证一致性或水平可扩展性。这极大地影响了分布式世界中的通信。
- en: In general, enterprise systems should be consistent in their use cases. Business
    logic should transform the overall system from one consistent state to another,
    different consistent state.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，企业系统在其用例中应该是一致的。业务逻辑应该将整体系统从一个一致状态转换到另一个不同的一致状态。
- en: In distributed systems, an overall consistent state would imply that use cases
    that communicate to external concerns would have to ensure that the invoked external
    logic also adheres to consistency. This approach leads to distributed transactions.
    Use cases that are invoked on a system would execute in an *all-or-nothing* fashion,
    including all external systems. This implies a need for a lock on all involved,
    distributed functionality until every single distributed application successfully
    performed its responsibilities.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中，一个整体一致的状态意味着与外部关注点通信的用例必须确保被调用的外部逻辑也遵守一致性。这种方法导致分布式事务。在系统上被调用的用例将以“全有或全无”的方式执行，包括所有外部系统。这意味着需要对所有涉及的分布式功能进行锁定，直到每个分布式应用程序都成功完成其职责。
- en: Naturally, this approach doesn't scale. The fact that the system is distributed
    requires this transaction orchestration to be performed over the potentially slow
    network. This introduces a bottleneck, which results in a locking situation, since
    involved applications have to block and wait a relatively large amount of time.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，这种方法无法扩展。系统是分布式的这一事实要求这种事务编排需要在可能缓慢的网络上进行。这引入了一个瓶颈，导致锁定情况，因为涉及的应用程序必须阻塞并等待相对较长的时间。
- en: Generally speaking, synchronous, consistent communication is only advisable
    for applications that don't involve more than two applications at a time. Performance
    tests as well as production experience indicate whether a chosen communication
    scenario scales well enough for the given use case and environment.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，同步、一致性的通信仅适用于一次不涉及超过两个应用程序的应用程序。性能测试以及生产经验表明，所选的通信场景是否足够好地扩展以适应给定的用例和环境。
- en: Using asynchronous communication is motivated by scalability. Distributed systems
    that communicate asynchronously won't, by definition, be consistent at all times.
    Asynchronous communication can happen on a logical level, where synchronous calls
    only initiate business logic without awaiting a consistent result.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异步通信的动机是可扩展性。异步通信的分布式系统在定义上不会始终一致。异步通信可以在逻辑层面上发生，其中同步调用仅启动业务逻辑，而不等待一致的结果。
- en: Let's have a look into the motivations and design behind asynchronous, eventually
    consistent communication in distributed applications.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看分布式应用程序中异步、最终一致通信背后的动机和设计。
- en: Event sourcing, event-driven architectures, and CQRS
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件溯源、事件驱动架构和CQRS
- en: Traditionally, enterprise applications are built using a model approach that
    is based on the atomic **Create Read Update Delete** (**CRUD**).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，企业应用程序是使用基于原子的**创建、读取、更新、删除**（**CRUD**）的模型方法构建的。
- en: The current state of the system, including the state of the domain entities,
    is reflected in a relational database. If a domain entity is updated, the new
    state of the entity including all of its properties is put into the database and
    the old state is gone.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的当前状态，包括领域实体的状态，反映在关系数据库中。如果一个领域实体被更新，该实体的新状态（包括所有属性）将被放入数据库，而旧状态则消失。
- en: The CRUD approach requires applications to maintain consistency. In order to
    ensure the state of the domain entity is reflected correctly, all use case invocations
    have to be executed in a consistent manner, synchronizing modifications to the
    entities.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: CRUD方法要求应用程序保持一致性。为了确保领域实体的状态正确反映，所有用例调用都必须以一致的方式进行执行，同步对实体的修改。
- en: Shortcomings of CRUD-based systems
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于CRUD的系统缺点
- en: This synchronization is also one of the shortcomings of CRUD-based systems,
    the way that we typically build applications.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这种同步也是我们通常构建应用程序的CRUD系统的一个缺点。
- en: Scalability
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可扩展性
- en: The required synchronization prevents the system from scaling infinitely. All
    transactions are executed on the relational database instance, which eventually
    introduces a bottleneck if the system needs to scale out.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的同步防止了系统无限扩展。所有事务都在关系数据库实例上执行，如果系统需要扩展，最终会引入瓶颈。
- en: This ultimately becomes a challenge for situations with huge amounts of workloads
    or huge numbers of users. For the vast majority of enterprise applications, however,
    the scalability of relational databases is sufficient.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这最终成为处理大量工作负载或大量用户的情况的挑战。然而，对于绝大多数企业应用程序来说，关系数据库的可扩展性是足够的。
- en: Competing transactions
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 竞争事务
- en: Another challenge that comes with CRUD-based models is to handle competing transactions.
    Business use cases that include the same domain entities and operate simultaneously
    need to ensure that the resulting state of the entities is consistent.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 基于CRUD模型的另一个挑战是处理竞争事务。包括相同领域实体并同时操作的业务用例需要确保实体的最终状态是一致的。
- en: Editing a user's name and at the same time updating its account credit limit
    should not result in lost updates. The implementation has to ensure that the overall
    result of both transactions is still consistent.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 同时编辑用户姓名和更新其账户信用额度不应导致更新丢失。实现必须确保这两个事务的整体结果是仍然一致的。
- en: Competing transactions that rely on optimistic locking usually result in failing
    transactions. This is definitely not ideal from a user's perspective, but at least
    maintains consistency, rather than suppressing that a transaction has been lost
    in space.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于乐观锁定的竞争事务通常会导致事务失败。这绝对不是从用户的角度来看的理想情况，但至少保持了一致性，而不是压制一个事务在空间中丢失的情况。
- en: Following this approach, however, potentially leads to unnecessary locking.
    From a business theory perspective it should be possible to simultaneously edit
    the user's name and account credit limit.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，遵循这种方法可能会引起不必要的锁定。从业务理论的角度来看，应该可以同时编辑用户的姓名和账户信用额度。
- en: Reproducibility
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可重现性
- en: Since the application only stores its current state, all historical information
    about previous states is gone. The state is always overwritten by the new updates.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用程序只存储其当前状态，所有关于先前状态的历史信息都消失了。状态总是被新的更新覆盖。
- en: This makes it hard to reproduce how an application got into its current state.
    If a current state was miscalculated from its originating use case invocations,
    there is no possibility of fixing the situation later on.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得很难重现应用程序如何进入当前状态。如果当前状态是从其原始用例调用中错误计算出来的，那么后来就没有可能修复这种情况。
- en: Some scenarios explicitly require reproducibility for legal terms. Some applications
    therefore include audit logs that permanently write certain information as soon
    as they happen to the system.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一些场景明确要求可重现性以符合法律条款。因此，一些应用程序包括审计日志，这些日志在信息发生时立即永久写入系统。
- en: Event sourcing
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件源
- en: Event sourcing is an approach that tackles reproducibility as a shortcoming
    of CRUD-based systems.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 事件源是一种解决基于CRUD（创建、读取、更新、删除）系统可重现性不足的方法。
- en: Event sourced systems calculate the current state of the systems from atomic
    events that happened in the past. The events represent the individual business
    use case invocations, including the information provided in the invocations.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 事件源系统通过过去发生的原子事件来计算系统的当前状态。这些事件代表了单个业务用例的调用，包括调用中提供的信息。
- en: The current state is not permanently persisted, but emerges by applying all
    events one after another. The events themselves happened in the past and are immutable.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当前状态不是永久持久化的，而是通过依次应用所有事件而产生的。这些事件本身发生在过去，是不可变的。
- en: 'To give an example, a user with its characteristics is calculated from all
    events related to it. Applying `UserCreated`, `UserApproved`, and `UserNameChanged`
    one after another creates the current representation of the user up to its recent
    event:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个具有其特征的用户是从与其相关的所有事件中计算出来的。依次应用`UserCreated`、`UserApproved`和`UserNameChanged`创建用户当前的表示，直到最近的那个事件：
- en: '![](img/998e273c-5a6c-4907-9708-2acb5c58a123.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/998e273c-5a6c-4907-9708-2acb5c58a123.png)'
- en: The events contain self-sufficient information mostly concerning the corresponding
    use case. For example, a `UserNameChanged` event contains the time stamp and the
    name the user was changed to, not other, unrelated information about the user.
    The event's information is therefore atomic.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 事件包含自给自足的信息，主要与相应的用例相关。例如，一个`UserNameChanged`事件包含时间戳和用户更改后的名称，而不是其他与用户无关的信息。因此，事件的信息是原子的。
- en: Events are never changed nor deleted. If a domain entity is removed from the
    application, there will be a corresponding deletion event such as `UserDeleted`.
    The current state of the system then won't contain this user anymore after applying
    all events.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 事件永远不会被更改或删除。如果从应用程序中删除了一个领域实体，将会有一个相应的删除事件，例如`UserDeleted`。在应用所有事件后，系统的当前状态将不再包含此用户。
- en: Benefits
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优势
- en: An event-sourced application contains all of its information in atomic events.
    Therefore, the full history and context, how it got into its current state, is
    available. In order to reproduce the current state for debugging purposes, all
    events and their individual modifications to the system can be regarded.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 事件溯源的应用程序包含所有其信息在原子事件中。因此，完整的记录和上下文，即它是如何进入当前状态的，都是可用的。为了调试目的重现当前状态，所有事件及其对系统的个别修改都可以被视为。
- en: The fact that everything that happened to the system is stored atomically has
    a couple of benefits, not only for debugging purposes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 系统发生的一切都被原子存储的事实有几个好处，不仅限于调试目的。
- en: Tests can make use of this information to replay everything that happened to
    a production system in system tests. Tests are then able to re-execute the exact
    business use case invocations that happened in productions. This is an advantage
    especially for system and performance tests.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以利用这些信息在系统测试中重放生产系统中发生的一切。然后测试能够重新执行生产中发生的确切业务用例调用。这对于系统和性能测试来说是一个优势。
- en: The same is true for statistics that use the atomic information to gather insights
    about the usage of the application. This enables use cases and insights that are
    designed after an application has been deployed.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用原子信息来收集关于应用程序使用情况的洞察的统计也是如此。这使人们能够在应用程序部署后设计用例和洞察。
- en: Assuming a manager wants to know how many users were created on a Monday, after
    the application has been running for two years. With CRUD-based systems that information
    would have had to explicitly been persisted by the time the use case was invoked.
    Use cases that were not explicitly requested in the past can only be added as
    new features, and will add value in the future.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一位经理想知道在应用程序运行两年后的周一创建了多少用户。在基于CRUD的系统上，在用例被调用时，该信息必须被显式地持久化。过去未明确请求的用例只能作为新功能添加，并将在未来增加价值。
- en: With event sourcing these functionalities are possible. Since information about
    whatever happened to the system is stored, use cases that are developed in the
    future are able to operate on data that happened in the past.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用事件溯源，这些功能是可能的。由于系统发生的一切信息都被存储，因此未来开发的使用案例能够操作过去发生的数据。
- en: These benefits, however, are certainly possible without the need for distributed
    systems. A monolithic, independent application can base its model on event sourcing,
    gaining the same benefits from it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些优势当然可以在不需要分布式系统的情况下实现。一个单体、独立的应用程序可以基于事件溯源构建其模型，从中获得相同的优势。
- en: Eventually consistent real world
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终一致的现实世界
- en: Before we go further into distributed systems in regard to consistency and scalability,
    let's look at an example of how consistent the real world is. Enterprise applications
    are typically built with the aspiration to provide full consistency. The real
    world, however, is highly distributed and not consistent at all.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步探讨分布式系统的一致性和可伸缩性之前，让我们看看现实世界的一致性是如何的。企业应用程序通常旨在提供完全的一致性。然而，现实世界却是高度分布的，根本不一致。
- en: Imagine you're hungry and you want to eat a burger. So you go to a restaurant,
    sit at a table, and tell the waiter that you would like to have a burger. The
    waiter will accept your order. Now, although your order has been accepted this
    doesn't necessarily mean that you will receive your meal. The process of ordering
    a meal is not fully consistent.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你饿了，想吃一个汉堡。所以你去了餐馆，坐在桌子旁，告诉服务员你想要一个汉堡。服务员会接受你的订单。现在，尽管你的订单已被接受，但这并不一定意味着你将收到你的餐点。点餐的过程并不完全一致。
- en: A lot of things can go wrong at this point. For example, the chef may tell the
    waiter that unfortunately the last burger patty was just used and there won't
    be more burgers for the day. So although your order has transactionally been accepted,
    the waiter will come back and tell you that the order won't be possible.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上可能会出很多问题。例如，厨师可能会告诉服务员，不幸的是，最后一个汉堡肉饼已经被使用，当天不会再有汉堡了。所以尽管你的订单在事务上已被接受，服务员会回来告诉你订单无法实现。
- en: Now, instead of asking you to leave, the waiter might suggest to you an alternative
    dish. And if you're hungry and fine with the substitute you might eventually receive
    a meal.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，服务员可能不会要求你离开，而是会向你推荐一道替代菜品。如果你饿了，并且对替代品满意，你最终可能会得到一份餐点。
- en: This is how the highly distributed real world handles business use case transactions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是高度分布式现实世界处理业务用例事务的方式。
- en: If the restaurant would be modeled in a fully consistent way the scenario would
    look different. In order to guarantee that an order is only accepted if it will
    be possible to provide the prepared meal, the whole restaurant would need to be
    locked down. The customers would have to wait and hold the conversation while
    the waiter goes into the kitchen and orders the meal from the chef. Since many
    other things can go wrong after ordering, the whole order transaction would actually
    have to block until the meal is fully prepared.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果餐厅以完全一致的方式建模，场景将有所不同。为了确保只有在能够提供准备好的餐点的情况下才接受订单，整个餐厅都需要被锁定。顾客必须等待并保持对话，直到服务员进入厨房并从厨师那里订购餐点。由于在订购后可能会发生许多其他问题，整个订单事务实际上必须阻塞，直到餐点完全准备好。
- en: Obviously, this approach would not work. Instead, the real world is all about
    collaboration, intentions, and eventually dealing with issues if the intentions
    can't be fulfilled.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这种方法是不可行的。相反，现实世界完全是关于协作、意图，并在意图无法实现时最终处理问题。
- en: This means that the real world operates in an eventually consistent way. Eventually,
    the restaurant system will be in a consistent state, but not necessarily at all
    times, which leads to initially accepting orders that are actually not possible.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着实际世界以最终一致的方式运行。最终，餐厅系统将达到一致状态，但并不一定是所有时候，这导致最初接受实际上不可能的订单。
- en: Real-world processes are represented as intentions or **commands**, such as
    ordering a burger, and atomic outcomes or **events**, such as that the order has
    been accepted. Events will then cause new commands that result in new outcomes
    or failures.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 实际世界的过程被表示为意图或**命令**，例如点一份汉堡，以及原子结果或**事件**，例如订单已被接受。随后，事件将导致新的命令，从而产生新的结果或失败。
- en: Event-driven architectures
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件驱动架构
- en: Now back to the topic of distributed systems. In the same way as for a restaurant,
    distributed systems that communicate in a consistent way, via distributed transactions,
    won't be able to scale.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到分布式系统的话题。与餐厅一样，通过分布式事务以一致方式通信的分布式系统将无法扩展。
- en: Event-driven architectures solve this issue. The communication in these architectures
    happens via asynchronous events that are published and consumed reliably.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动架构解决了这个问题。在这些架构中，通信通过可靠发布和消费的异步事件进行。
- en: By doing so, consistent use case transactions get split up into multiple, smaller-scaled
    transactions that are consistent in themselves. This leads the overall use case
    eventually being consistent.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，一致的业务用例事务被分割成多个、规模更小的、自身一致的事务。这导致整体业务用例最终达到一致。
- en: 'Let''s see an example of how the use case of ordering a burger is represented
    in an event-driven architecture. The restaurant system consists of at least two
    distributed applications, the *waiter* and the *chef*. The restaurant applications
    communicate by listening to each other''s events. The client application will
    communicate with the waiter in order to initiate the use case:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在事件驱动架构中如何表示点汉堡用例的例子。餐厅系统至少由两个分布式应用程序组成，即*服务员*和*厨师*。餐厅应用程序通过监听彼此的事件进行通信。客户端应用程序将与服务员通信，以启动用例：
- en: '![](img/0479e749-f675-490e-875d-cd1964440029.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0479e749-f675-490e-875d-cd1964440029.png)'
- en: The client orders a meal at the waiter application, which results in the `OrderPlaced`
    event. Once the event has been published reliably, the `orderMeal()` method's
    invocation returns. The client therefore is able to perform other work in parallel.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 客户在服务员应用程序中下单，这会触发`OrderPlaced`事件。一旦事件可靠地发布，`orderMeal()`方法的调用就会返回。因此，客户端能够并行执行其他工作。
- en: The chef system receives the `OrderPlaced` event and validates whether the order
    is possible with the currently available ingredients. If the order wouldn't be
    possible, the chef would emit a different event, such as `OrderFailedInsufficientIngredients`.
    In that case, the waiter would update the order status to failed.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 厨师系统接收到`OrderPlaced`事件并验证订单是否可以使用当前可用的原料。如果订单无法实现，厨师会发出不同的事件，例如`OrderFailedInsufficientIngredients`。在这种情况下，服务员会将订单状态更新为失败。
- en: When initiating the meal preparation was successful, the waiter receives the
    `MealPreparationStarted` event and updates the status of the order, what results
    in `OrderStarted`. If the client would ask the waiter about the status of their
    order, it could respond appropriately.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当餐点准备成功时，服务员会接收到`MealPreparationStarted`事件并更新订单状态，这会导致`OrderStarted`。如果客户询问服务员他们的订单状态，服务员可以相应地回答。
- en: At some point the meal preparation would have been finished, resulting in a
    `MealPrepared` event, which notifies the waiter to deliver the order.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时刻，餐点准备过程将会完成，从而触发一个`MealPrepared`事件，通知服务员送餐。
- en: Eventual consistency in event-driven architectures
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件驱动架构中的最终一致性
- en: The use case of ordering a meal is eventually consistent. Publishing the events
    reliably still ensures that all clients *eventually* know about the status of
    their order.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 订单用例最终是一致的。可靠地发布事件仍然确保所有客户端最终都会知道他们订单的状态。
- en: It is somewhat fine if processing the order doesn't happen immediately or if
    the order will fail for some reason. However, it must not happen that an order
    gets lost in the system due to unavailable applications. This needs to be ensured
    when publishing the events.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果处理订单不是立即发生，或者由于某些原因订单会失败，这可能是可以接受的。然而，绝不能发生订单因应用程序不可用而丢失在系统中的情况。在发布事件时需要确保这一点。
- en: There are still transactions involved here, but on a much smaller scale and
    not involving external systems. Doing so enables distributed systems to cover
    transactional use cases while still enabling horizontal scalability.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这里仍然涉及交易，但规模较小，且不涉及外部系统。这样做使得分布式系统能够覆盖事务性用例，同时仍然能够实现水平扩展。
- en: The fact that some reliability is required for approaches like event-driven
    architectures is an important aspect in distributed systems, and should be considered
    when designing solutions and choosing technology.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像事件驱动架构这样的方法，需要一定的可靠性是一个重要的方面，在设计解决方案和选择技术时应该予以考虑。
- en: Enter CQRS
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入CQRS
- en: Now let's combine the motivations behind event-driven architectures and event
    sourcing.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们结合事件驱动架构和事件溯源背后的动机。
- en: Event-driven architectures communicate by atomic events. It makes sense to piggyback
    on this approach and build the system using event sourcing, by using the events
    as the system's source of truth. Doing so combines the benefits of both approaches,
    enabling horizontally scalable, event-sourced systems.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动架构通过原子事件进行通信。利用这种方法，并通过事件作为系统真相的来源来构建系统（即事件溯源），是有意义的。这样做结合了两种方法的好处，使得系统能够实现水平扩展和事件溯源。
- en: The question is how to model event-driven applications that base their domain
    model on events? And how to efficiently calculate and return the current state
    of domain entities?
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是如何对基于事件的域模型的事件驱动应用程序进行建模？以及如何高效地计算并返回域实体的当前状态？
- en: The **Command Query Responsibility Segregation** (**CQRS**) principle describes
    how to model these applications. It is a consequence of event-driven architectures
    and is based on event sourcing.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令查询责任分离**（**CQRS**）原则描述了如何对这些应用程序进行建模。它是事件驱动架构的结果，并基于事件溯源。'
- en: Principles
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原则
- en: As the name suggests, CQRS separates the responsibilities for commands and queries,
    namely writes and reads.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，CQRS将命令和查询的责任分开，即写入和读取。
- en: A command changes the state of the system by ultimately producing events. It
    is not allowed to return any data. Either the command succeeds, which results
    in zero or more events, or it fails with an error. The events are produced reliably.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 命令通过最终产生事件来改变系统的状态。它不允许返回任何数据。命令要么成功，产生零个或多个事件，要么失败并返回错误。事件产生是可靠的。
- en: A query retrieves and returns data, without side effects on the system. It is
    not allowed to modify state.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 查询检索并返回数据，不会对系统产生副作用。它不允许修改状态。
- en: To give an example in Java code, a command acts like a `void doSomething()`
    method, which changes state. A query acts like a getter `String getSomething()`,
    which has no impact on the system's state. These principles sound simple, but
    have some implications on the system's architecture.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以Java代码为例，命令就像一个`void doSomething()`方法，它改变状态。查询就像一个getter `String getSomething()`，它不会影响系统的状态。这些原则听起来很简单，但它们对系统的架构有一些影响。
- en: The responsibilities of the commands and queries are separated into several
    concerns, allowing CQRS applications to emerge in fully independent applications
    that either write or read. Now, how to design and implement this approach?
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 命令和查询的责任被分割成几个关注点，使得CQRS应用程序可以成为完全独立的、要么写入要么读取的应用程序。那么，如何设计和实现这种方法呢？
- en: Design
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计
- en: Following event-driven architectures, the write and read systems communicate
    solely via events. The events are distributed via an event store or event hub.
    There is no other coupling than the write systems that produce events and both
    write and read systems that consume for events to update their internal state.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循事件驱动架构，写入和读取系统仅通过事件进行通信。事件通过事件存储或事件中心进行分发。除了产生事件的写入系统和消费事件以更新其内部状态的读取系统之外，没有其他耦合。
- en: 'The following snippet shows the architecture of a CQRS system:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段显示了CQRS系统的架构：
- en: '![](img/32876ade-c2d7-4a57-b69f-40b88a6f40be.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/32876ade-c2d7-4a57-b69f-40b88a6f40be.png)'
- en: The command and query services consume events from the event store. This is
    the only way for communication between them.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 命令和查询服务从事件存储中消费事件。这是它们之间通信的唯一方式。
- en: All services maintain a current-state representation that reflects the state
    of the domain entities. Entities are, for example, *meal orders* or *cars*, including
    the latest state of their properties. This state is kept in memory or persisted
    in databases.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 所有服务维护一个当前状态表示，该表示反映了领域实体的状态。实体例如是*餐点订单*或*汽车*，包括它们属性的最新状态。这种状态保存在内存中或在数据库中持久化。
- en: These representations just enable the systems to contain a current state. The
    golden source of truth is the atomic events contained in the event store.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这些表示只是使系统能够包含当前状态。黄金真相来源是事件存储中包含的原子事件。
- en: All application instances individually update their state representations by
    consuming and applying the events from the event store.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 所有应用程序实例通过消费和应用事件存储中的事件来单独更新它们的状态表示。
- en: The command services contain the business logic that initiates changes to the
    systems. They produce events via the event store after potential command verification
    using their state representations.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 命令服务包含启动系统更改的业务逻辑。它们在通过其状态表示进行可能的命令验证后，通过事件存储产生事件。
- en: 'In order to make the flow of information clear, let''s go through an example
    meal order:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使信息流清晰，让我们通过一个示例餐点订单来分析：
- en: '![](img/fb0fbe4e-8d2c-4763-972a-bba3f416d84d.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fb0fbe4e-8d2c-4763-972a-bba3f416d84d.png)'
- en: The client orders the meal at a command service instance. After a potential
    verification against its representation, the command service produces the `OrderPlaced`
    event to the event store. If publishing the event was successful, the `orderMeal()`
    method returns. The client can proceed with its execution.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 客户在命令服务实例中下单。在对其表示进行可能的验证后，命令服务将`OrderPlaced`事件发送到事件存储。如果事件发布成功，`orderMeal()`方法返回。客户可以继续其执行。
- en: 'The command service can create a meal identifier for later retrieval, for example,
    as a universally unique identifier:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 命令服务可以为后续检索创建一个餐点标识符，例如，作为一个通用唯一标识符：
- en: '![](img/93abf0cf-c901-4837-a8da-fd5b74122dcc.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/93abf0cf-c901-4837-a8da-fd5b74122dcc.png)'
- en: The event store publishes the event to all consumers, which updates their internal
    representation accordingly. The client can access the status of the meal at the
    query service using its identifier. The query service will respond with its latest
    representation of the order.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 事件存储会将事件发布给所有消费者，并相应地更新他们的内部表示。客户端可以使用其标识符在查询服务中访问餐点的状态。查询服务将响应其最新的订单表示。
- en: 'In order to proceed with the order processing, an authority that invokes potential
    subsequent commands will handle the event as well:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续订单处理，一个调用潜在后续命令的权威机构也会处理该事件：
- en: '![](img/ba948444-0114-4543-8feb-8236d7179c48.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ba948444-0114-4543-8feb-8236d7179c48.png)'
- en: An event handler will listen to the `OrderPlaced` event and invoke the `prepareMeal()`
    use case of the chef system. This subsequent command will then potentially result
    in new events.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理器将监听`OrderPlaced`事件并调用厨师系统的`prepareMeal()`用例。此后续命令可能产生新事件。
- en: The section *Implementing microservices with Java EE*, covers how to implement
    CQRS among other things.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: “使用Java EE实现微服务”这一章节涵盖了如何实现CQRS等内容。
- en: Benefits
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优点
- en: CQRS enables distributed applications to not only scale horizontally, but independently
    in their write and read concerns. The replicas of query service, for example,
    can be different from the number of command services.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS使分布式应用程序不仅能够水平扩展，而且可以在其读写关注点上独立扩展。例如，查询服务的副本可以与命令服务的数量不同。
- en: The read and write load in enterprise applications is usually not evenly distributed.
    Typically the read operations highly outperform the number of writes. For these
    cases the number of read instances can be scaled out independently. This would
    not be possible in a CRUD-based system.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 企业应用程序的读写负载通常分布不均。通常，读操作远高于写操作的数量。在这些情况下，可以独立扩展读实例的数量。在基于CRUD的系统，这是不可能的。
- en: Another benefit is that each service can optimize their state representations
    accordingly. For example, persistently storing the domain entities in a relational
    database might not be the best approach for every situation. It's also possible
    to just store the representation in memory and to recalculate all events at application
    startup. The point is that both the write and read instances are free to choose
    and optimize their representations according to the circumstances.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优点是，每个服务都可以相应地优化其状态表示。例如，将领域实体持久化存储在关系型数据库中可能不是每个情况的最佳方法。也可以仅在内存中存储表示，并在应用程序启动时重新计算所有事件。关键是写实例和读实例都可以自由选择并优化其表示以适应环境。
- en: A side effect of this approach is also that CQRS provides read-side failover
    availability. In case of the event store being unavailable no new events can be
    published, therefore no use cases that modify state can be invoked on the system.
    In CRUD-based systems this would correspond to the database being down. In CQRS
    systems, however, at least the query services can still provide the latest state
    from their representations.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的副作用是，CQRS还提供了读侧故障转移可用性。如果事件存储不可用，则无法发布新事件，因此无法在系统上调用修改状态的用例。在基于CRUD的系统，这相当于数据库宕机。然而，在CQRS系统中，至少查询服务仍然可以从其表示中提供最新的状态。
- en: The state representations of CQRS systems also solve the scalability issue of
    event-sourced systems. Event-sourced systems calculate the current application
    state from the atomic events. Executing this each and every time an operation
    is invoked will over time become slower and slower as more events arrive. The
    representations of the command and query services eliminate this need by continuously
    applying the recent events.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS系统的状态表示也解决了事件源系统的可伸缩性问题。事件源系统从原子事件计算当前应用程序状态。每次操作调用时执行此操作将随着时间的推移变得越来越慢，因为事件越来越多。命令和查询服务的表示通过持续应用最近的事件消除了这种需求。
- en: Shortcomings
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺点
- en: Building CQRS systems not only has benefits, it also has shortcomings.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 构建CQRS系统不仅有益，也有缺点。
- en: Probably one of the biggest shortcoming of constructing these systems is that
    the majority of developers are not familiar with the concept, design and implementations.
    This will introduce difficulties when this approach is chosen in enterprise projects.
    Unlike CRUD-based systems, CQRS would require additional training and know-how.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 构建这些系统可能的最大缺点之一是，大多数开发者不熟悉其概念、设计和实现。当这种方法在企业项目中选择时，这将会引入困难。与基于CRUD的系统不同，CQRS将需要额外的培训和专业知识。
- en: Like any distributed system, there are naturally more applications involved
    in a CQRS system compared to the CRUD approach. As previously described for distributed
    systems in general, this requires some extra effort. Additionally, an event store
    is required.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何分布式系统一样，与CRUD方法相比，CQRS系统中涉及的应用程序自然更多。正如之前在一般分布式系统中所述，这需要一些额外的工作。此外，还需要一个事件存储。
- en: Unlike the figures demonstrated, it is not mandatory to have the command and
    query sides in two or more independent applications. As long as the functionalities
    only communicate via events published by the event store, both can reside within
    the same application. This would, for example, result in a single waiter and chef
    application that still scales out horizontally. This is a reasonable trade-off,
    if individually scaling the write and read sides is not required.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 与所展示的示例不同，命令和查询两侧必须在两个或更多独立的应用程序中是强制性的。只要功能仅通过事件存储发布的事件进行通信，两者都可以位于同一应用程序中。例如，这会导致一个服务员和厨师应用程序仍然可以水平扩展。如果不需要单独扩展写入和读取两侧，这是一个合理的权衡。
- en: Communication
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通信
- en: Building CQRS systems is one approach to realizing asynchronous, eventually
    consistent communication. As we have seen previously in this book, there are many
    forms of communication, synchronous as well as asynchronous.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 构建CQRS系统是实现异步、最终一致通信的一种方法。正如我们在本书中之前所看到的，有许多通信形式，包括同步和异步。
- en: In order to enable scalable applications, distributed systems should not rely
    on synchronous communication that involves several systems. This leads to distributed
    transactions.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使应用程序可伸缩，分布式系统不应依赖于涉及多个系统的同步通信。这会导致分布式事务。
- en: One approach to realize scalability with technology-agnostic, synchronous communication
    protocols is to model logically asynchronous processes. For example, communication
    protocols such as HTTP can be used to trigger processing that happens asynchronously
    while the caller immediately returns. This introduces eventual consistency, but
    enables the system to scale.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 实现具有技术无关、同步通信协议的可伸缩性的一种方法是对逻辑上异步过程进行建模。例如，可以使用HTTP等通信协议来触发异步发生的处理，同时调用者立即返回。这引入了最终一致性，但使系统能够扩展。
- en: This also involves the consideration of whether the applications that made the
    distributed system make a difference in system-internal, and external communication.
    CQRS uses this approach by offering external interfaces, for example, using HTTP,
    to the clients, whereas the services themselves communicate via the event store.
    Modeling asynchronous processes that are accessed via uniform protocol doesn't
    distinguish here.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这还涉及到考虑使分布式系统的应用程序在系统内部和外部通信中是否有所区别。CQRS通过提供外部接口来实现这一点，例如使用HTTP，而服务本身通过事件存储进行通信。通过统一协议访问的异步过程建模在这里没有区别。
- en: In general, it's advisable to prefer availability, that is, scalability, over
    consistency when designing distributed systems. There are many approaches possible,
    CQRS is one of them, combining asynchronous communication with event sourcing.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在设计分布式系统时，建议优先考虑可用性，即可伸缩性，而不是一致性。有许多可能的方法，CQRS就是其中之一，它结合了异步通信和事件溯源。
- en: The following section covers the necessity of self-sufficient applications.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分涵盖了自给自足应用程序的必要性。
- en: Microservice architectures
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务架构
- en: We saw the motivations, challenges, and benefits of distributed systems, as
    well as some approaches to handle communication and consistency. Now we will focus
    on the architecture of distributed applications.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了分布式系统的动机、挑战和好处，以及一些处理通信和一致性的方法。现在我们将关注分布式应用程序的架构。
- en: Sharing data and technology in enterprises
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 企业中的数据和技术共享
- en: A common idea in enterprises is to share and reuse technology as well as commonly
    used data. Earlier we looked at sharing Java modules and the shortcomings with
    that. What about sharing common technology or data models in distributed systems?
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 企业中一个常见的想法是共享和重用技术以及常用的数据。我们之前讨论了共享Java模块及其不足。那么，在分布式系统中共享通用技术或数据模型又如何呢？
- en: Multiple applications that form an enterprise system are often implemented using
    similar technology. This comes naturally with applications that are built by a
    single team or teams that work closely together. Doing so very often raises the
    idea of sharing technology that is being reused in the applications.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 构成企业系统的多个应用通常使用类似的技术来实现。这对于由单个团队或紧密合作的团队构建的应用来说是很自然的。这样做往往会产生共享在应用中重用的技术的想法。
- en: Projects could use commonly used modules that remove duplication in the overall
    system. A typical approach for this is shared models. There could be only one
    module within the organization that is being reused in all projects.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 项目可以使用常用的模块来消除整个系统中的重复。一个典型的做法是共享模型。组织内部可能只有一个模块在所有项目中都被重用。
- en: Sharing models leads to the question whether potentially persisted domain entities
    or transfer objects are being reused. Domain entities that are persisted in a
    database could then even be directly retrieved from the database system, right?
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 共享模型引发了一个问题，即是否正在重用潜在的持久化领域实体或传输对象。领域实体在数据库中持久化后甚至可以直接从数据库系统中检索，对吧？
- en: Commonly used databases stand in total contradiction to distributed systems.
    They tightly couple the involved applications. Changes in schemas or technology
    welds the application and project life cycles together. Commonly used database
    instances prevent applications from being able to scale. This eliminates the motivations
    behind distributed systems.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 常用的数据库与分布式系统完全矛盾。它们紧密耦合了涉及的应用。模式或技术的变更将应用和项目生命周期焊接在一起。常用的数据库实例阻止了应用的可扩展性。这消除了分布式系统背后的动机。
- en: The same is true for sharing technology in general. As shown in previous chapters,
    commonly used modules and dependencies introduce technical constraints in the
    implementations. They couple the applications and limit their independence in
    changes and life cycles. Teams will have to communicate and discuss modifications,
    even if they would not affect the application's boundaries.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样适用于一般的技术共享。如前几章所示，常用的模块和依赖关系在实现中引入了技术约束。它们将应用耦合起来，限制了它们在变更和生命周期中的独立性。即使这些变更不会影响应用的边界，团队也必须进行沟通和讨论。
- en: Looking at the domain knowledge and the responsibilities in the context map
    of the system, sharing data and technology makes little sense. There are indeed
    points of contact between the systems that are subject to be shared in technology.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 从系统上下文图中的领域知识和职责来看，共享数据和技术的意义不大。确实存在一些系统间需要共享技术接触点。
- en: However, the point is to implement applications, which only depend on their
    business responsibilities on the one side and documented communication protocols
    on the other side. It's therefore advisable to choose potential duplication and
    independence rather than coupling in technology.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，关键在于实现应用，这些应用一方面依赖于其业务职责，另一方面依赖于记录的通信协议。因此，建议选择潜在的重复和独立性，而不是在技术上的耦合。
- en: Sharing other concerns rather than points of contact in the system's context
    map should alert engineers. The application's different responsibilities should
    make it clear that commonly used models or data reside in different contexts.
    The individual applications are exclusively responsible for their concerns.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统上下文图中共享其他关注点而不是接触点应该会提醒工程师。应用的不同职责应该清楚地表明常用的模型或数据位于不同的上下文中。各个应用只对其关注点负责。
- en: Shared-nothing architectures
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无共享架构
- en: With these thoughts in mind it's advisable to craft applications that share
    no common technology or data. They fulfill the application boundary contract in
    communication and business responsibilities.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些想法，建议构建不共享任何公共技术或数据的程序。它们在通信和业务职责上履行了应用边界合同。
- en: '**Shared-nothing architectures** are independent in technology, potentially
    used libraries, their data and schemas thereof. They are free to choose implementations
    and potential persistence technology.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**无共享架构**在技术、潜在使用的库、它们的数据及其模式方面是独立的。它们可以自由选择实现和潜在的持久化技术。'
- en: Changing the implementation of an application within a distributed system from
    Python to Java should have no impact on the other applications, if the contract
    of its HTTP interface is still met.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果分布式系统中应用程序的实现从Python更改为Java，只要其HTTP接口的合同仍然满足，就不应该对其他应用程序产生影响。
- en: If data is required within other applications, this needs to be defined explicitly
    in the context map, requiring the application to expose data via its business
    logic interfaces. Databases are not shared.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其他应用程序需要数据，这需要在上下文映射中明确定义，要求应用程序通过其业务逻辑接口公开数据。数据库不共享。
- en: Shared-nothing architectures enable applications with independent life cycles
    that depend on nothing more than the explicitly defined contracts. Teams are free
    to choose technology and the project life cycles. The technology, as well as the
    data including databases, is owned by the application.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 无共享架构允许具有独立生命周期的应用程序，这些应用程序除了明确定义的合同外，不依赖任何其他东西。团队可以自由选择技术和项目生命周期。技术和包括数据库在内的数据都属于应用程序。
- en: Interdependent systems
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相互依赖的系统
- en: Shared-nothing architectures eventually have to collaborate with other applications.
    The defined contracts have to be met, documented, and communicated.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 无共享架构最终必须与其他应用程序协作。定义的合同必须满足、记录并传达。
- en: This is the point, that shared-nothing architectures are only dependent on the
    defined contracts and responsibilities. In case of changes in the business logic
    the contracts are redefined and communicated. Solely the application's team is
    responsible for how to implement the contracts.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点是，无共享架构仅依赖于定义的合同和责任。在业务逻辑发生变化时，合同被重新定义并传达。仅应用程序团队负责如何实现合同。
- en: Interdependent systems are made up of several shared-nothing applications with
    well-defined interfaces. The used interfaces should be technology-agnostic to
    not set constraints on the used implementation.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 相互依赖的系统由几个具有良好定义接口的无共享应用程序组成。使用的接口应该是技术无关的，以避免对使用的实现设置约束。
- en: This is the idea behind microservice architectures. Microservices consist of
    several interdependent applications that realize their individual business responsibilities
    and, combined together, solve a problem.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这是微服务架构背后的理念。微服务由几个相互依赖的应用程序组成，这些应用程序实现它们各自的企业责任，并结合起来解决问题。
- en: The name microservice doesn't necessarily say anything about the size of the
    application. An application should be built by a single team of developers. For
    organizational reasons team sizes should not grow too big. There is an often-cited
    notion by Amazon that the whole team should be able to survive on two pizzas.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的名称并不一定说明应用程序的大小。应用程序应由单个开发团队构建。出于组织原因，团队规模不应过大。亚马逊经常引用的一个观点是，整个团队应该能够靠两块披萨生存。
- en: The motivations behind distributed systems should be considered before crafting
    microservices. If there is no actual need to distribute a system, it should be
    avoided. Sticking to monolithic applications with reasonable responsibilities
    is to be preferred.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建微服务之前，应该考虑分布式系统背后的动机。如果没有实际需要分布式系统，应避免使用。坚持使用具有合理责任的单体应用程序是首选。
- en: Usually the approach to craft microservice architectures is to slice up monolithic
    applications that grow too large in responsibilities, or diverged in teams and
    life cycles. This is comparable with refactoring approaches. Refactoring a class
    that grew too big into multiple delegates works well more often than trying to
    introduce a perfect scenario from the beginning.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，构建微服务架构的方法是将责任过大或团队和生命周期分歧的单体应用程序分割成多个部分。这与重构方法类似。将变得过大的类重构为多个代理通常比一开始就尝试引入一个完美的场景更有效。
- en: In general, it's always advisable to consider the business requirements, context
    map of the system with their development teams and life cycles.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在考虑业务需求、系统的上下文映射以及他们的开发团队和生命周期时，总是建议这样做。
- en: 12-factor and cloud native applications
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12因子和云原生应用程序
- en: '[Chapter 5](a24f88d4-1af2-4746-91c9-9717d077dd27.xhtml), *Container and Cloud
    Environments with Java EE*, introduced the approaches of 12-factor and cloud native
    applications. They heavily support microservice architectures.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[第5章](a24f88d4-1af2-4746-91c9-9717d077dd27.xhtml)，*使用Java EE的容器和云环境*，介绍了12要素和云原生应用程序的方法。它们强烈支持微服务架构。'
- en: In particular, the shared-nothing approach of having interdependent, distributed
    applications is well realizable with the principles of containerized, stateless,
    and scalable enterprise applications.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，通过容器化、无状态和可扩展的企业应用程序原则，可以实现具有相互依赖、分布式应用程序的无共享方法。
- en: The 12-factor principles and the effective nature of cloud and container environments
    support teams in developing microservices with manageable overhead and high productivity.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 12要素原则和云和容器环境的有效性支持团队以可管理的开销和高生产力开发微服务。
- en: However, an enterprise system doesn't not have to be distributed in order to
    comply with the 12-factor or cloud native principles. The approaches are certainly
    advisable for building monolithic applications as well.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，企业系统并不一定需要分布式才能符合12要素或云原生原则。这些方法当然也适用于构建单体应用程序。
- en: When to use and when not to use microservices
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用微服务，何时不使用微服务
- en: In the recent years microservice architectures have seen some hype in the software
    industry.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，微服务架构在软件行业中受到了一些炒作。
- en: As always with hypes, engineers should ask themselves what is behind certain
    buzzwords and whether implementing them makes sense. It's always advisable to
    look into new technology and methodologies. It's not necessarily advisable to
    apply them immediately.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 总是随着炒作，工程师应该问自己某些热门词汇背后的东西，以及实施它们是否有意义。总是建议研究新技术和方法。不一定建议立即应用它们。
- en: The reasons for using microservices are the same as for using distributed systems
    in general. There are technical reasons, such as applications that need independent
    deployment life cycles.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务的理由与使用分布式系统的一般理由相同。有技术原因，例如需要独立部署生命周期的应用程序。
- en: There are also reasons that are driven by the business requirements and situations
    in teams and project working modes.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，也有一些原因是受业务需求以及团队和项目工作模式中的情况驱动的。
- en: Scalability is an often-cited motivation behind microservice architectures.
    As we have seen in event-driven architectures, monolithic applications aren't
    able so scale infinitely. The question is whether scalability is effectively an
    issue.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性是微服务架构经常引用的动机。正如我们在事件驱动架构中看到的，单体应用程序无法无限扩展。问题是可扩展性是否真正是一个问题。
- en: There are big companies that handle business logic for huge amounts of users
    using monolithic applications. Before considering distribution as a relief for
    scaling issues, performance insights and statistics should be gathered.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 有大公司使用单体应用程序处理大量用户的业务逻辑。在考虑将分布式作为缓解扩展问题的手段之前，应该收集性能洞察和统计数据。
- en: Engineers should avoid to use microservice architectures solely because of believing
    in a *silver bullet* approach. It can easily happen as a result of *buzzword-driven*
    meetings and conversations, that solutions are chosen based on limited or no evidence
    supporting the requirement. Microservices certainly provide benefits, but also
    come with a price in time and effort. In any way, the requirements and motivations
    whether to split up responsibilities into multiple applications should be clear.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 工程师应避免仅仅因为相信“银弹”方法而使用微服务架构。这很容易发生在“热门词汇驱动”的会议和对话中，解决方案的选择基于有限的或没有证据支持的要求。微服务当然提供了好处，但也带来了时间和努力上的代价。无论如何，将责任分割到多个应用程序的要求和动机应该是清晰的。
- en: Implementing microservices with Java EE
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Java EE实现微服务
- en: Now on to the question of how to build microservices with Enterprise Java.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来谈谈如何使用企业Java构建微服务。
- en: In various discussions and meetings, Java EE has been considered as *too heavyweight*
    and cumbersome for microservices. Whereas this is certainly the case for J2EE
    technology and approaches, Java EE offers modern, lean ways of developing enterprise
    applications. [Chapter 4](f0a49441-e411-49c4-a4b6-c6193ba36094.xhtml), *Lightweight
    Java EE* and [Chapter 5](a24f88d4-1af2-4746-91c9-9717d077dd27.xhtml), *Container
    and Cloud Environments with Java EE* covered these aspects, especially in regard
    to modern environments.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在各种讨论和会议中，Java EE 被认为对于微服务来说过于**重量级**且笨重。虽然这对于 J2EE 技术和方法确实如此，但 Java EE 提供了现代、精简的企业应用程序开发方式。[第
    4 章](f0a49441-e411-49c4-a4b6-c6193ba36094.xhtml)，*轻量级 Java EE* 和 [第 5 章](a24f88d4-1af2-4746-91c9-9717d077dd27.xhtml)，*Java
    EE 与容器和云环境*涵盖了这些方面，特别是在现代环境方面。
- en: Java EE is indeed well suited for writing microservice applications. Container
    technologies and orchestration support the platform, particularly since Java EE
    separates the business logic from the implementation.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 确实非常适合编写微服务应用程序。容器技术和编排支持该平台，尤其是由于 Java EE 将业务逻辑与实现分离。
- en: Zero-dependency applications
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 零依赖应用程序
- en: Microservices with Java EE are ideally built as zero-dependency applications.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Java EE 的微服务理想地构建为零依赖应用程序。
- en: Thin WAR applications are deployed on modern enterprise containers that can
    be shipped in containers. This minimizes deployment time. Java EE deployment artifacts
    should only contain provided dependencies, if there is a reasonable need for adding
    third-party dependencies, they should be installed in the application server.
    Container technologies simplify this approach.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 薄型 WAR 应用程序部署在现代企业容器中，这些容器可以用于运输。这最小化了部署时间。Java EE 部署工件应仅包含提供的依赖项；如果有合理的需要添加第三方依赖项，它们应安装在应用程序服务器中。容器技术简化了这种方法。
- en: This also matches the idea of shared-nothing architectures. The team is responsible
    for the application-specific technology, in this case the application server installation
    including libraries. Infrastructure as code definitions such as Dockerfiles, enable
    the development team to accomplish this in effective ways.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这也符合无共享架构的理念。团队负责特定于应用程序的技术，在这种情况下是包括库在内的应用程序服务器安装。例如 Dockerfile 这样的基础设施代码定义，使开发团队能够以有效的方式完成这项工作。
- en: Application servers
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用服务器
- en: Following this approach, the application server is shipped in a container, containing
    only a single application. The *one application per application server* approach
    also matches the idea of shared-nothing architectures.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法，应用程序服务器以容器形式交付，其中只包含单个应用程序。"一个应用程序对应一个应用程序服务器" 的方法也符合无共享架构的理念。
- en: The question is whether application servers introduce too much overhead if a
    single server instance only contains a single application. In the past, the storage
    and memory footprint certainly was significant.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，如果单个服务器实例只包含一个应用程序，应用服务器是否会引入过多的开销。在过去，存储和内存占用确实很大。
- en: Modern application servers considerably improved in this area. There are container
    base images of servers such as **TomEE** that consume 150 MB and less, for the
    server including the Java runtime and operating system, mind you. The memory consumption
    also significantly improved due to dynamically loading functionality.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现代应用服务器在这方面有了显著提升。例如，**TomEE** 这样的服务器基于容器，其占用内存仅为150 MB及以下，请注意，这包括了服务器、Java
    运行时和操作系统。由于动态加载功能，内存消耗也得到了显著改善。
- en: In enterprise projects installation sizes are usually not an issue to be concerned
    with, especially if they're not exceeding all bounds. What's much more important
    is the size of the built and shipped artifacts. The application artifact, which
    in some technologies contains megabytes of dependencies, is built and transmitted
    many times. The runtime is only installed once per environment.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业项目中，安装大小通常不是需要关注的问题，尤其是如果它们没有超过所有界限的话。更重要的是构建和交付的工件的大小。应用程序工件，在某些技术中包含数兆字节的依赖项，被构建和传输多次。运行时只在每个环境中安装一次。
- en: Container technologies such as Docker make use of layered file systems that
    encourage the moving parts to be small. Zero-dependency applications support this
    approach.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如 Docker 这样的容器技术利用分层文件系统，鼓励将组件保持小型化。零依赖应用程序支持这种方法。
- en: Making each and every Continuous Delivery build only shipping kilobytes of data
    is far more advisable than saving a few megabytes in the base installation.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让每个持续交付的构建只传输几KB的数据，比在基础安装中节省几个MB的数据要明智得多。
- en: If the installation size still needs to be shrunk down, some application vendors
    offer possibilities to tailor the container to the required standards, especially
    the MicroProfile initiative, which includes several application server vendors,
    and defines slimmed profiles.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果还需要缩小安装大小，一些应用供应商提供定制容器以满足所需标准的方法，特别是MicroProfile倡议，它包括多个应用服务器供应商，并定义了精简配置文件。
- en: Java EE microservices don't need to be shipped as standalone JAR files. On the
    contrast, applications shipped in containers should leverage the use of layered
    file systems and be deployed on enterprise containers residing in the base image.
    Standalone JAR files oppose this principle.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE微服务不需要作为独立JAR文件分发。相反，在容器中分发的应用程序应利用分层文件系统的使用，并在基础镜像中运行的企业的容器上部署。独立JAR文件与此原则相悖。
- en: There are possibilities to combine standalone JAR files with thin deployments,
    by so-called hollow JAR. This approach, however, is not required when using containers.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能通过所谓的空JAR将独立JAR文件与轻量级部署相结合。然而，在使用容器时，这种方法并不是必需的。
- en: Implementing application boundaries
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现应用边界
- en: Let's move on to the implementation of the application boundaries with Java
    EE. This is, in fact, a more system-architectural question than an implementational
    one.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探讨使用Java EE实现应用边界的实现。这实际上是一个比实现问题更系统架构的问题。
- en: Communication between microservices should use technology-agnostic protocols.
    As seen previously, Java EE heavily supports HTTP, for both HTTP and REST services
    use Hypermedia.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务之间的通信应使用技术无关的协议。如前所述，Java EE在HTTP和REST服务方面都大力支持HTTP，并使用超媒体。
- en: The next sub-chapter will cover asynchronous communication in CQRS systems,
    using publish/subscribe messaging implemented with Apache Kafka.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍CQRS系统中使用Apache Kafka实现的发布/订阅消息的异步通信。
- en: Implementing CQRS
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现CQRS
- en: Earlier in this chapter we have seen the motivations and concepts behind event
    sourcing, event-driven architectures, and CQRS. CQRS offers an interesting approach
    to creating distributed applications that implement scalable, eventually consistent
    business use cases.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我们看到了事件源、事件驱动架构和CQRS背后的动机和概念。CQRS为创建实现可扩展、最终一致业务用例的分布式应用提供了一种有趣的方法。
- en: At the time of writing, there is a lot of interest in CQRS, yet little knowledge
    within companies of how to use it. Some frameworks and technologies have emerged
    that aim to implement this approach. Yet CQRS is an architectural style, and specific
    frameworks are not necessary to develop CQRS systems.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，对CQRS（Command Query Responsibility Segregation）的兴趣很大，但公司内部对如何使用它的了解却很少。已经出现了一些框架和技术，旨在实现这种方法。然而，CQRS是一种架构风格，开发CQRS系统并不需要特定的框架。
- en: Let's have a close look at an approach that uses Java EE.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看一种使用Java EE的方法。
- en: System interfaces
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统接口
- en: The CQRS system interfaces are used from outside the system to initiate business
    use cases. For example, a client accesses the waiter system to order a burger.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS系统接口用于系统外部来启动业务用例。例如，客户端访问服务员系统来订购汉堡。
- en: These interfaces are used externally and ideally implemented using a technology-agnostic
    protocol.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这些接口用于外部，理想情况下使用一种技术无关的协议实现。
- en: For REST-like HTTP services, this implies that the command services implement
    HTTP methods that modify resources, such as POST, DELETE, PATCH, or PUT. The query
    services usually only implement resources queried by GET.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类似REST的HTTP服务，这意味着命令服务实现修改资源的HTTP方法，例如POST、DELETE、PATCH或PUT。查询服务通常只实现通过GET查询的资源。
- en: In our example, this means that the client POSTs a new meal order to a command
    service resource. Similarly, meal orders are retrieved via GET resources from
    query services.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，这意味着客户端通过命令服务资源POST一个新的餐点订单。同样，餐点订单通过查询服务的GET资源检索。
- en: These HTTP interfaces concern the external communication. Internally the application
    communicates via events that are published using an event hub.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这些HTTP接口涉及外部通信。内部应用通过使用事件中心发布的事件进行通信。
- en: Example scenario using Apache Kafka
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Apache Kafka的示例场景
- en: In this example, I will use Apache Kafka as a distributed message broker, offering
    high performance and throughput. It's one example of a messaging technology, supporting
    a publish/subscribe approach, among others.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我将使用 Apache Kafka 作为分布式消息代理，提供高性能和高吞吐量。它是支持发布/订阅方法等多种消息技术的一个例子。
- en: At the time of writing, Apache Kafka doesn't implement all JMS semantics. The
    following examples will use the Kafka's vendor-specific Client API.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Apache Kafka 没有实现所有 JMS 语义。以下示例将使用 Kafka 的供应商特定客户端 API。
- en: Apache Kafka's publish/subscribe approach organizes messages in topics. It can
    be configured to enable transactional event producers and in-order event consumption,
    which is what event-driven architectures need to ensure in order to create reliable
    use cases.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Kafka 的发布/订阅方法将消息组织在主题中。它可以配置为启用事务性事件生产者和有序事件消费，这是事件驱动架构需要确保的，以便创建可靠的使用案例。
- en: Kafka brokers are distributed and use so-called consumer groups to manage message
    topics and partitions. Examining Kafka's architecture is beyond the scope of this
    book and it's advised to go further into its documentation when choosing this
    technology.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Kafka 代理是分布式的，并使用所谓的消费者组来管理消息主题和分区。检查 Kafka 的架构超出了本书的范围，建议在选择此技术时进一步查阅其文档。
- en: In short, a message is published to a topic and consumed once per consumer group.
    Consumer groups contain one or more consumers and guarantee that exactly one consumer
    will process the messages that have been published using transactional producers.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，消息被发布到主题中，每个消费者组只消费一次。消费者组包含一个或多个消费者，并保证恰好有一个消费者将处理使用事务性生产者发布的消息。
- en: A CQRS system needs to consume messages in multiple locations. The applications
    that are interested in a specific topic will consume the message and update their
    internal representations. Therefore, all these updating consumers will receive
    an event. There are also event handlers who use the event to process the business
    logic further. Exactly one event handler needs to process the event per topic,
    otherwise processes would run multiple times or not at all.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS 系统需要在多个位置消费消息。对特定主题感兴趣的应用程序将消费消息并更新它们的内部表示。因此，所有这些更新消费者都将收到一个事件。还有使用事件进一步处理业务逻辑的事件处理器。每个主题恰好需要一个事件处理器来处理事件，否则进程可能会多次运行或根本不运行。
- en: 'The concept of Kafka consumer groups is therefore used in such a way, where
    there is one update consumer group per application and one event handler group
    per topic. This enables all instances to receive the events, but reliably one
    command service to process the business logic. By doing so, the instances are
    able to scale without affecting the overall system''s outcome:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Kafka 消费者组的概念被这样使用，即每个应用程序有一个更新消费者组，每个主题有一个事件处理器组。这使所有实例都能接收事件，但可靠地只有一个命令服务来处理业务逻辑。通过这样做，实例能够扩展而不会影响整体系统的结果：
- en: '![](img/d8c5b4a8-2c08-49e1-b66b-52bc48f16cb4.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d8c5b4a8-2c08-49e1-b66b-52bc48f16cb4.png)'
- en: Integrating Java EE
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成 Java EE
- en: In order to integrate the Apache Kafka cluster into the application this example
    will use Kafka's Java API.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 Apache Kafka 集群集成到应用程序中，本示例将使用 Kafka 的 Java API。
- en: The applications connect to Kafka to consume messages in their updating consumers
    and event handlers. The same is true for publishing events.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序连接到 Kafka，在它们的更新消费者和事件处理器中消费消息。发布事件也是如此。
- en: 'The used technology should be encapsulated from the rest of the application.
    In order to integrate the events, developers can use a functionality that naturally
    fits this scenario: CDI events.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 应用的技术应该从应用程序的其他部分封装起来。为了集成事件，开发者可以使用适合此场景的功能：CDI 事件。
- en: CDI events
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CDI 事件
- en: The domain events contain the event specific data, a timestamp, and identifiers
    that reference the domain entity.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 领域事件包含特定事件的 数据、时间戳以及引用领域实体的标识符。
- en: 'The following snippet shows an example of an abstract `MealEvent` and the `OrderPlaced`
    event:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段展示了抽象的 `MealEvent` 和 `OrderPlaced` 事件的示例：
- en: '[PRE1]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Domain events like these are the core of the application. The domain entity
    representations are calculated from these events.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的领域事件是应用程序的核心。领域实体表示是从这些事件计算出来的。
- en: The integration into Kafka ensures that these events are fired via CDI. They
    are observed in the corresponding functionality that updates the state representations,
    or invokes subsequent commands, respectively.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 将其集成到Kafka中确保这些事件通过CDI触发。它们被观察在相应的功能中，分别更新状态表示或调用后续命令。
- en: Event handlers
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件处理器
- en: 'The following snippet shows an event handler of the chef system, invoking functionality
    of a command service:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了厨师系统的事件处理器，调用命令服务的功能：
- en: '[PRE2]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The event handler consumes the event and will invoke the boundary of the subsequent
    meal preparation use case. The `prepareMeal()` method itself will result in zero
    or more events, in this case either `MealPreparationStarted` or `OrderFailedInsufficientIngredients`:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理器消费事件并将调用后续餐准备用例的边界。`prepareMeal()`方法本身将导致零个或多个事件，在这种情况下，要么是`MealPreparationStarted`，要么是`OrderFailedInsufficientIngredients`：
- en: '[PRE3]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The event producer will reliably publish the events to the Kafka cluster. If
    the publication fails, the whole event processing has to fail, and will be retried
    later.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 事件生产者将可靠地将事件发布到Kafka集群。如果发布失败，整个事件处理必须失败，稍后重试。
- en: State representation
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态表示
- en: 'The consumers that update the state representation consume the CDI events as
    well. The following snippet shows the bean that contains the meal order state
    representations:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 更新状态表示的消费者也消费CDI事件。以下代码片段显示了包含餐订单状态表示的bean：
- en: '[PRE4]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This simple example represents the state of the meal orders in a relational
    database. As soon as a new CDI event arrives, the state of the orders is updated.
    The current state can be retrieved by the `get()` method.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子代表了关系型数据库中餐订单的状态。一旦新的CDI事件到达，订单的状态就会更新。当前状态可以通过`get()`方法检索。
- en: 'The meal order domain entity is persisted via JPA. It contains the status of
    the order that is updated via observed CDI events:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 餐订单领域实体通过JPA持久化。它包含通过观察CDI事件更新的订单状态：
- en: '[PRE5]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Consuming Kafka messages
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消费Kafka消息
- en: The part that consumes the messages encapsulates the message hub from the rest
    of the application. It is integrated by firing CDI events on arriving messages.
    This certainly is specific to the Kafka API and should be considered as an example
    solution.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 消息消费的部分封装了消息中心与整个应用程序的其他部分。它是通过在到达的消息上触发CDI事件来集成的。这当然特定于Kafka API，应被视为一个示例解决方案。
- en: 'The updating consumer connects to a specific topic via its consumer group.
    The startup singleton bean ensures the consumer will be initiated at application
    startup. A container-managed executor service runs the event consumer in its own
    thread:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 更新消费者通过其消费者组连接到特定的主题。启动单例bean确保消费者将在应用程序启动时启动。一个容器管理的执行器服务在其自己的线程中运行事件消费者：
- en: '[PRE6]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The application-specific Kafka properties are exposed via a CDI producer. They
    contain the corresponding consumer groups.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 应用特定的Kafka属性通过CDI生产者公开。它们包含相应的消费者组。
- en: 'The event consumer performs the actual consumption:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 事件消费者执行实际的消费：
- en: '[PRE7]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Kafka records that are consumed result in new CDI events. The configured properties
    use JSON serializers and deserializers, respectively, to map the domain event
    classes.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 消费的Kafka记录会导致新的CDI事件。配置的属性分别使用JSON序列化和反序列化器来映射领域事件类。
- en: Events that are fired via CDI and consumed successfully are committed to Kafka.
    The CDI events are fired synchronously, to ensure that all processes are finish
    reliably before committing.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 通过CDI触发并成功消费的事件被提交到Kafka。CDI事件是同步触发的，以确保在提交之前所有进程都可靠地完成。
- en: Producing Kafka messages
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成Kafka消息
- en: 'The event producer publishes the domain events to the message hub. This happens
    synchronously to rely on the messages being in the system. Once the transmission
    is acknowledged, the `EventProducer#publish` method invocation returns:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 事件生产者将领域事件发布到消息中心。这是同步发生的，以确保消息在系统中。一旦传输被确认，`EventProducer#publish`方法的调用返回：
- en: '[PRE8]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Going into the details of the Kafka producer API is beyond the scope of this
    book. However, it needs to be ensured that the events are sent reliably. The event
    producer bean encapsulates this logic.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 详细介绍Kafka生产者API超出了本书的范围。然而，需要确保事件可靠地发送。事件生产者bean封装了这个逻辑。
- en: These examples demonstrate one possibility for integrating Kafka.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例演示了集成Kafka的一种可能性。
- en: As mentioned earlier, the **Java EE Connector Architecture** (**JCA**) is another
    possibility for integrating external concerns into the application container.
    At the time of writing, there are vendor-specific container solutions that integrate
    messaging via JCA. Existing solutions for integrating message hubs such as Kafka
    are an interesting alternative. However, application developers are advised to
    encapsulate technology specifics into single points of responsibilities and use
    standard Java EE functionality within the application.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，**Java EE 连接器架构**（**JCA**）是将外部关注点集成到应用程序容器的另一种可能性。在撰写本文时，存在一些供应商特定的容器解决方案，它们通过
    JCA 集成消息。对于集成 Kafka 等消息中心现有解决方案是一个有趣的替代方案。然而，建议应用程序开发者将技术特定细节封装到单一责任点，并在应用程序中使用标准的
    Java EE 功能。
- en: Application boundaries
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序边界
- en: The applications of a CQRS system communicate via events internally. Externally,
    other protocols such as HTTP can be provided.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS 系统的应用程序通过事件进行内部通信。外部，可以提供其他协议，如 HTTP。
- en: 'The query and command functionality of, for example, the waiter system, is
    exposed via JAX-RS. The command service offers functionality to place meal orders.
    It uses the event producer to publish the resulting events:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，服务员系统的查询和命令功能通过 JAX-RS 公开。命令服务提供放置餐点订单的功能。它使用事件生产者发布结果事件：
- en: '[PRE9]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `orderMeal()` method is called by the HTTP endpoint. The other methods are
    called by the waiter system's event handler. They will result in new events that
    are delivered by the event hub.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`orderMeal()` 方法由 HTTP 端点调用。其他方法由服务员系统的事件处理器调用。它们将导致由事件中心传递的新事件。'
- en: The reason for not directly firing events or calling functionality internally
    here is that this application resides in a distributed environment. There might
    be other instances of the waiter system consuming the event hub and updating their
    representation accordingly.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里不直接触发事件或调用内部功能的原因是，此应用程序位于分布式环境中。可能会有其他服务员系统实例消费事件中心并相应地更新它们的表示。
- en: 'The command service contains a JAX-RS resource that is used to order meals:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 命令服务包含一个 JAX-RS 资源，用于订购餐点：
- en: '[PRE10]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The query service exposes the meal order representations. It loads the current
    state of the domain entities from the database as seen in the `MealOrders`. The
    JAX-RS resources of the query service use this functionality.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 查询服务公开了餐点订单表示。它从数据库中加载域实体的当前状态，如 `MealOrders` 中所示。查询服务的 JAX-RS 资源使用此功能。
- en: 'If the waiter system is shipped as a single instance, containing both the command
    and query services, these resources can be combined. It needs to be ensured though
    that the services don''t cross-communicate, except via the eventing mechanism.
    The following code snippet shows the query service endpoint:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务员系统作为一个单一实例发布，包含命令和查询服务，则可以将这些资源合并。不过，需要确保服务之间不通过事件机制以外的任何方式进行交叉通信。以下代码片段显示了查询服务端点：
- en: '[PRE11]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: These examples are not exhaustive, but are meant to give the reader an idea
    of integrating CQRS concepts and message hubs into Java EE applications.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例并不全面，但旨在让读者了解将 CQRS 概念和消息中心集成到 Java EE 应用程序中。
- en: Integrating further CQRS concepts
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步集成 CQRS 概念
- en: One of the benefits of event-sourced systems is that it's possible to take the
    full set of atomic events and replay them, for example, in test scenarios. System
    tests verify against the actual use cases that happened in production. Audit logging
    comes for free as well, being part of the core of the application.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 事件源系统的一个好处是，可以重新播放完整的原子事件集，例如，在测试场景中。系统测试针对生产中实际发生的使用案例进行验证。审计日志也是免费的，因为它是应用程序核心的一部分。
- en: This approach also enables us to change business functionality and replay some
    events, either to fix bugs and to correct behavior, or to apply the event information
    to new functionality. This makes it possible to apply new features on events as
    if they were part of the application since day one.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法还使我们能够更改业务功能并重放某些事件，无论是为了修复错误和纠正行为，还是将事件信息应用于新功能。这使得将新功能应用于事件，仿佛它们从应用程序第一天起就是一部分成为可能。
- en: If the chef system adds functionality to continuously calculate the average
    time of meal preparation, the events can be redelivered to re-calculate the representations.
    Therefore the database contents will be reset and the events redelivered, only
    to the updating consumer, which results in new representation being calculated
    and persisted. Kafka can explicitly redeliver events.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果厨师系统添加了持续计算餐食准备平均时间的功能，事件可以被重新投递以重新计算表示。因此，数据库内容将被重置，事件仅重新投递给更新消费者，这导致新的表示被计算并持久化。Kafka可以显式地重新投递事件。
- en: The events, however, are solely used to update the status representations, not
    triggering new commands during replays. Otherwise, the system would end up in
    an inconsistent state. The demonstrated example realizes this by defining a dedicated
    Kafka consumer group for event handlers, which is not reset to redistribute events
    to the event handlers. Only the updating consumers re-consume the events, to recalculate
    the internal state representations.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，事件仅用于更新状态表示，在重放期间不会触发新的命令。否则，系统最终会陷入不一致的状态。所展示的示例通过为事件处理器定义一个专用的Kafka消费者组来实现这一点，该组不会被重置以重新分配事件给事件处理器。只有更新消费者重新消费事件，以重新计算内部状态表示。
- en: The point is, that CQRS systems enable many more use cases, due to event sourcing
    being used. The possibilities of capturing and replaying events, as well as the
    contained context and history information, enable extensive scenarios.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 重点是，由于使用了事件溯源，CQRS系统可以启用更多的用例。捕获和重放事件的可能性，以及包含的上下文和历史信息，使得广泛的应用场景成为可能。
- en: Java EE in the age of distribution
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式时代的Java EE
- en: Microservice architectures and distributed systems naturally require communication
    that involves more than a single, monolithic application. There are many ways
    how to implement communication with Java EE, depending on the chosen protocols
    and communication technologies.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构和分布式系统自然需要涉及多个单一、单体应用程序的通信。根据选择的协议和通信技术，有许多实现Java EE通信的方法。
- en: There are some aspects to be considered when realizing communication. External
    applications that take part of the microservice system, for example, require discovering
    the service instances. In order to not tightly couple applications and configuration,
    looking up services should be dynamic, rather than configuring static hosts or
    IP addresses.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现通信时有一些方面需要考虑。例如，参与微服务系统的外部应用程序需要发现服务实例。为了不紧密耦合应用程序和配置，查找服务应该是动态的，而不是配置静态的主机或IP地址。
- en: The cloud native principle of being resilient also concerns communication. Since
    networks can potentially fail anytime, application health should not be impacted
    when connectivity decelerates or goes down. The application should guard itself
    from potential errors propagating into the application.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生原则的弹性也关系到通信。由于网络可能随时失败，当连接速度减慢或断开时，应用程序的健康状况不应受到影响。应用程序应该保护自己免受潜在错误传播到应用程序中的影响。
- en: Discovering services
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现服务
- en: Service discovery can happen in various ways, from DNS lookup to more sophisticated
    scenarios where the lookup is part of business logic, providing different endpoints
    depending on the situation. It generally encapsulates addressing external systems
    from the application's concerns. Ideally, the application logic only names the
    logical service it needs to communicate with, and the actual lookup is performed
    externally.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 服务发现可以通过多种方式发生，从DNS查找到更复杂的场景，其中查找是业务逻辑的一部分，根据情况提供不同的端点。它通常封装了从应用程序关注点中对外部系统的寻址。理想情况下，应用程序逻辑仅命名它需要与之通信的逻辑服务，而实际的查找由外部执行。
- en: It depends on the used environments and runtime which possibilities enterprise
    developers have. Container technologies offer functionality to link services by
    names, taking away work and responsibility from the application. The clients connect
    against the link or service names as hostnames, which are resolved by the container
    technology.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于所使用的环境和运行时，企业开发者有哪些可能性。容器技术提供了通过名称链接服务的功能，从而从应用程序中移除了工作和责任。客户端通过链接或服务名称作为主机名进行连接，这些名称由容器技术解析。
- en: This approach works both for Docker containers and container orchestration such
    as Docker Compose, Kubernetes, or OpenShift. All communication concerns solely
    use logical service names and ports to establish connections. This matches the
    12-factor principles as well.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法适用于Docker容器和容器编排，如Docker Compose、Kubernetes或OpenShift。所有通信问题仅使用逻辑服务名称和端口来建立连接。这也符合12因素原则。
- en: Since the lookup work is performed in the environment, the applications will
    only specify the desired service names. This is true for all outward communication,
    such as HTTP connections, databases, or message hubs. [Chapter 5](a24f88d4-1af2-4746-91c9-9717d077dd27.xhtml),
    *Container and Cloud Environments with Java EE* demonstrated examples for this.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 由于查找工作是在环境中执行的，因此应用程序只需指定所需的服务名称。这对于所有外部通信都适用，例如HTTP连接、数据库或消息中心。[第5章](a24f88d4-1af2-4746-91c9-9717d077dd27.xhtml)，*Java
    EE的容器和云环境*展示了这一点的示例。
- en: Communicating resiliently
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性通信
- en: Network communication is not reliable and can potentially break in all sorts
    of ways. Connections may timeout, services may be unavailable, respond slowly,
    or deliver unexpected answers.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 网络通信不可靠，可能以各种方式中断。连接可能会超时，服务可能不可用，响应缓慢，或者提供意外的答案。
- en: In order to not let errors propagate into the application, the communications
    need to be resilient.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 为了不让错误传播到应用程序中，通信需要具有弹性。
- en: Validating responses
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证响应
- en: First of all, this implies client-side validation and handling errors. Irrelevant
    to the communication technology in use, applications can't rely on external systems
    to provide responses that are not malformed or not simply wrong.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这意味着客户端验证和错误处理。与使用的通信技术无关，应用程序不能依赖于外部系统提供未损坏或未简单错误的响应。
- en: This doesn't mean that clients immediately have to reject all responses that
    are not perfect in the application's understanding. Responses that contain more
    information or slightly different formats than expected, but are still understandable,
    should not lead to immediate errors. Following the principle to *be conservative
    in what you do and liberal in what you accept*, messages that contain just enough
    for the application to do its job should be accepted. For example, additional,
    unknown properties in JSON responses should not lead to refusing to map the object.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着客户端必须立即拒绝所有不符合应用程序理解的完美响应。包含比预期更多信息或格式略有不同但仍然可理解的响应，不应导致立即错误。遵循“在行动上保守，在接受上宽容”的原则，包含足够信息以供应用程序执行其工作的消息应被接受。例如，JSON响应中的额外、未知属性不应导致拒绝映射对象。
- en: Breaking timeouts and circuits
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打破超时和断路
- en: Clients that perform synchronous calls to external systems block the subsequent
    execution until the external system responds. Invocations may fail, slow down
    the execution, or in the worst case effectively bring the whole application down.
    It's crucial to keep this fact in mind when implementing clients.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 执行同步调用外部系统的客户端会阻塞后续执行，直到外部系统响应。调用可能会失败，减慢执行速度，或者在最坏的情况下，实际上会导致整个应用程序崩溃。在实现客户端时，牢记这一事实至关重要。
- en: First of all client connections should always set reasonable timeouts, as shown
    similarly in Chapter 3, *Implementing Modern Java Enterprise Applications*. Timeouts
    prevent the application from deadlock situations.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，客户端连接应始终设置合理的超时时间，正如第3章中类似地展示在*实现现代Java企业应用程序*中。超时可以防止应用程序陷入死锁状态。
- en: As seen before, Java EE interceptors can be used to prevent potential runtime
    exceptions from propagating into the business logic.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Java EE拦截器可以用来防止潜在的运行时异常传播到业务逻辑。
- en: So-called **circuit breakers** take this approach of preventing cascading failure
    further. They secure client invocations by defining error or timeout thresholds
    and prevent further invocations in case of failure. The circuit breaker approach
    comes from the model of electrical engineering, circuit breakers built into buildings,
    that intercept the connection by opening their circuits to prevent further damage.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 所说的**断路器**进一步采取了防止级联失败的方法。它们通过定义错误或超时阈值来确保客户端调用安全，并在失败的情况下防止进一步的调用。断路器方法源于电气工程模型，即建筑物中内置的断路器，通过打开电路来截断连接，以防止进一步的损害。
- en: A client circuit breaker similarly opens its circuit, that is, preventing further
    invocations, to not *damage* the application or the external system. Circuit breakers
    usually allow errors and timeouts to happen up to a certain degree and then cutting
    the connections for a certain time, or until the circuit is manually closed again.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端断路器类似地打开其电路，即阻止进一步的调用，以避免*损害*应用程序或外部系统。断路器通常允许错误和超时在一定范围内发生，然后切断连接一段时间，或者直到电路被手动关闭。
- en: Java EE applications can implement circuit breakers via interceptors. They can
    add sophisticated logic on when and how to open and close their circuits, for
    example, measuring the number of failures and timeouts.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE应用程序可以通过拦截器实现断路器。它们可以添加复杂的逻辑来决定何时以及如何打开和关闭电路，例如，测量失败次数和超时时间。
- en: 'The following demonstrates one possible circuit breaker approach in pseudo
    code. The interceptor behavior is annotated to a client method, similarly to client
    interceptor examples demonstrated earlier in this book:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了伪代码中一种可能的断路器方法。拦截器行为被注释到客户端方法中，类似于本书前面展示的客户端拦截器示例：
- en: '[PRE12]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Similarly, the circuit breaker could measure the service time and open its circuit
    if the service becomes too slow, additionally to HTTP client timeouts.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，断路器可以测量服务时间，如果服务变得过于缓慢，则打开其电路，除了HTTP客户端超时之外。
- en: There are some open source Java EE libraries available for this purpose, for
    example **Breakr** by Java EE expert Adam Bien. It depends on the technical requirements
    and the complexity of the logic, when to open and close the circuit, and whether
    third-party dependencies are required.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些开源Java EE库可用于此目的，例如Java EE专家Adam Bien的**Breakr**。它取决于技术要求、逻辑的复杂性、何时打开和关闭电路，以及是否需要第三方依赖项。
- en: In order to build zero-dependency applications, potential libraries should be
    installed into the container and not shipped with the application artifacts.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建零依赖的应用程序，潜在的库应该安装到容器中，而不是与应用程序工件一起分发。
- en: Bulkheads
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隔离舱
- en: Ships contain bulkheads that divide the vessel into several areas. If the ship
    hull gets a leak in some locations, only a single area is filled with water and
    the whole ship is likely still able to float.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 船只包含隔离舱，将船体分成几个区域。如果船体在某些位置出现泄漏，只有单个区域被水填满，整个船只可能仍然能够浮起。
- en: The **bulkhead** pattern takes this idea to enterprise applications. If some
    component of the application fails or is working to capacity due to workload,
    then the rest of the application should still be able to fulfill its purpose.
    This, of course, highly depends on the business use case.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '**隔离舱**模式将这个想法应用到企业应用程序中。如果应用程序的某些组件失败或由于工作负载而达到容量极限，则其余的应用程序仍然应该能够实现其目的。当然，这高度依赖于业务用例。'
- en: One example is to separate the thread execution of business processes from HTTP
    endpoints. Application servers manage a single pool of request threads. If, for
    example, a single business component fails and blocks all incoming requests, all
    available request threads will eventually be occupied. The result is in no other
    business uses cases is being able to be invoked, due to unavailable request threads.
    This could be the case if used clients don't implement proper timeouts, connect
    against a system that is down, and block the execution.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是将业务流程的线程执行与HTTP端点分离。应用程序服务器管理一个请求线程池。例如，如果单个业务组件失败并阻止所有传入请求，所有可用的请求线程最终都将被占用。结果是，在其他业务用例中无法调用，因为请求线程不可用。这可能发生在客户端没有实现适当的超时、连接到已关闭的系统并阻止执行的情况下。
- en: Using asynchronous JAX-RS resources together with dedicated managed executor
    services can relieve this issue. As seen earlier in this book, JAX-RS resources
    can invoke the business functionality in separate, container-managed threads to
    prevent the overall execution utilizing a request thread. Multiple components
    can use independent thread pools, which prevent failures from spreading.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异步JAX-RS资源与专用管理执行器服务可以缓解这个问题。如本书前面所见，JAX-RS资源可以在单独的、容器管理的线程中调用业务功能，以防止整体执行使用请求线程。多个组件可以使用独立的线程池，这可以防止故障扩散。
- en: Since the application server is responsible for managing threads, this approach
    should be implemented following Java EE standards. The idea is to define dedicated
    executor services that are injectable at the required positions.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用程序服务器负责管理线程，因此应按照 Java EE 标准实现此方法。其理念是定义可注入到所需位置的专用执行器服务。
- en: The open source library **Porcupine** by Adam Bien uses this approach to create
    dedicated executor services that use `ManagedThreadFactory` to define thread pools
    with container-managed threads. The dedicated executor services can be configured
    and instrumented appropriately.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: Adam Bien 开发的开源库 **Porcupine** 使用这种方法创建专用执行器服务，这些服务使用 `ManagedThreadFactory`
    定义具有容器管理的线程的线程池。这些专用执行器服务可以适当配置和监控。
- en: 'The following snippet shows one example of the bulkheads pattern, combining
    asynchronous JAX-RS resources with dedicated executor services:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了批量头模式的一个示例，结合了异步 JAX-RS 资源和专用执行器服务：
- en: '[PRE13]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The business use case is executed in a managed thread provided by the executor
    service, in order to allow the request thread to return and to handle other requests.
    This enables other functionality of the application to still function, even if
    this part is overloaded, and utilizes all threads of the `custom-name` executer.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 业务用例在执行器服务提供的托管线程中执行，以便请求线程返回并处理其他请求。这使得即使这部分过载，其他应用程序功能仍能继续运行，并利用 `custom-name`
    执行器的所有线程。
- en: The following examines how the custom executor service is configured.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将检查如何配置自定义执行器服务。
- en: Shaking hands and pushing back
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 握手和推回
- en: Another approach of communicating in a resilient way is **handshaking** and
    **backpressure**. The idea is that the communication partner being under load
    notifies the other side, which then backs off and eases the load. Handshaking
    here means that the calling side has a way of asking the service whether it can
    handle more requests. Backpressure reduces the load on a system by notifying clients
    when the limit is reached or pushing back requests.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种以弹性方式通信的方法是 **握手** 和 **背压**。其理念是，负载中的通信伙伴通知另一方，然后另一方退后并减轻负载。在这里，握手意味着调用方有方法询问服务是否可以处理更多请求。背压通过在达到限制时通知客户端或推回请求来减少系统负载。
- en: The two approaches combined form a resilient and effective form of communication.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法的结合形成了一种弹性且有效的通信形式。
- en: Information about the current load state of the application can be provided
    in HTTP resources or via header fields. The clients then take this information
    into account.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序当前负载状态的信息可以通过HTTP资源或通过头部字段提供。客户端随后会考虑这些信息。
- en: A more direct way is to simply reject a client request when the server's resources
    are fully utilized. Developers are advised to pay attention to the behavior of
    pooling such as in executor services, and how they handle situations with full
    queues. Exceptionally, it's advisable to abort the client request to not unnecessarily
    run into timeouts.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更直接的方法是在服务器资源完全利用时简单地拒绝客户端请求。建议开发者注意池化行为，例如在执行器服务中，以及它们如何处理队列满的情况。异常情况下，建议终止客户端请求，以避免不必要的超时。
- en: The following example shows a scenario using the Porcupine library. A business
    functionality is executed using a dedicated executor service, which will be configured
    to abort rejected executions. The clients will immediately receive a `503 Service
    Unavailable` response, indicating that currently the service is not able to serve
    requests.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了使用 Porcupine 库的场景。一个业务功能通过专用执行器服务执行，该服务将被配置为终止被拒绝的执行。客户端将立即收到 `503 服务不可用`
    的响应，表示当前服务无法处理请求。
- en: 'The JAX-RS resource is similar to the previous example. The `custom-name` executor
    is configured to abort rejected executions via a specialized configurator. The
    `ExecutorConfigurator` is part of the Porcupine library. The following shows the
    custom configuration:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS 资源与上一个示例类似。`custom-name` 执行器通过专用配置器配置为终止被拒绝的执行。`ExecutorConfigurator`
    是 Porcupine 库的一部分。以下展示了自定义配置：
- en: '[PRE14]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Executions that are rejected due to full queues will then result in a `RejectedExecutionException`.
    This exception is mapped via JAX-RS functionality:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 由于队列满而被拒绝的执行将导致 `RejectedExecutionException`。此异常通过 JAX-RS 功能映射：
- en: '[PRE15]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Client requests that would exceed the server limits immediately result in an
    error response. The client invocation can take this into account and act appropriately.
    For example, a circuit breaker pattern-like functionality can prevent the client
    from immediate subsequent invocations.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端请求如果超出服务器限制，将立即导致错误响应。客户端调用可以考虑到这一点并采取适当的行动。例如，类似断路器模式的功能可以防止客户端立即进行后续调用。
- en: Backpressure is helpful when crafting scenarios with multiple services that
    need to meet **service level agreements** (**SLA**). Chapter 9, *Monitoring, Performance,
    and Logging* will cover this topic.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建需要满足**服务级别协议**（**SLA**）的多个服务场景时，背压（Backpressure）是有帮助的。第9章 *监控、性能和日志* 将会涵盖这个主题。
- en: More on being resilient
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于弹性的内容
- en: Besides resilience in communication, microservices also aim to improve service
    quality and availability. Applications should be able to scale and self-heal in
    cases of failures.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通信的弹性之外，微服务还旨在提高服务质量和服务可用性。应用程序应在出现故障的情况下能够扩展和自我修复。
- en: The use of container orchestration technology such as Kubernetes supports this
    approach. Pods that back logical services can be scaled up to handle more workload.
    The services balance the load between the containers. There are possibilities
    to auto-scale instances up or down based on the current workload on the cluster.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 使用如Kubernetes之类的容器编排技术支持这种方法。支持逻辑服务的Pod可以扩展以处理更多的负载。服务在容器之间平衡负载。根据集群当前的工作负载，有自动扩展实例上下文的可能性。
- en: Kubernetes aims to maximize service uptime. It manages liveness and readiness
    probes to detect failures and potentially start new containers. In case of errors
    during deployments, it will leave currently running services untouched, until
    the new versions are able to serve traffic.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes旨在最大化服务正常运行时间。它管理存活性和就绪性探测以检测故障并可能启动新的容器。在部署过程中出现错误时，它将保持当前运行的服务不变，直到新版本能够处理流量。
- en: These approaches are managed by the runtime environment, not part of the application.
    It's advisable to minimize the non-functional, cross-cutting concerns within the
    enterprise application.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法由运行时环境管理，不是应用程序的一部分。建议在企业应用程序中尽量减少非功能性、横切关注点。
- en: Summary
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: There a multiple motivations behind distributing systems. Despite certain introduced
    challenges and overheads in communication, performance, and organization, distribution
    is often necessary.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统背后有多种动机。尽管在通信、性能和组织方面引入了某些挑战和开销，但分布式往往是必要的。
- en: 'In order to design the system landscape, the system''s context map that represents
    the individual responsibilities needs to be taken into consideration. It''s advisable
    to design application APIs in clear, lean interfaces, ideally implemented with
    standard communication protocols. Before introducing breaking changes, engineers
    as well as business experts need to ask themselves whether it is necessary to
    force client functionality to stop working. In the same way, APIs should be designed
    in a resilient way, preventing unnecessary breaks, in other words: *be conservative
    in what you do and liberal in what you accept*.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设计系统景观，需要考虑表示个别责任的系统上下文图。建议设计清晰、简洁的应用程序API，理想情况下使用标准通信协议实现。在引入破坏性变更之前，工程师以及业务专家需要问自己是否有必要强制客户端功能停止工作。同样，API应该设计得具有弹性，防止不必要的中断，换句话说：*在行动上保守，在接受上宽容*。
- en: Engineers that build distributed applications need to be aware of the trade-off
    between consistency and scalability. The majority of applications that use synchronous
    communication involving an external system will likely scale well enough. Distributed
    transactions should be avoided.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 构建分布式应用程序的工程师需要意识到一致性和可伸缩性之间的权衡。使用涉及外部系统的同步通信的大多数应用程序可能会足够好地扩展。应避免分布式事务。
- en: In order to communicate asynchronously, application can be based on event-driven
    architectures. The CQRS principle combines the motivations behind event-driven
    architectures and event sourcing. Whereas CQRS certainly offers interesting solutions,
    it only makes sense if there is a need for distributing application.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 为了异步通信，应用程序可以基于事件驱动架构。CQRS原则结合了事件驱动架构和事件源背后的动机。虽然CQRS确实提供了有趣的解决方案，但它只有在需要分布式应用程序的情况下才有意义。
- en: Microservice architectures don't share common technology or data with each other.
    Shared-nothing architectures are free to choose implementations and persistence
    technology. Zero-dependency Java EE applications shipped in containers are a reasonable
    fit for microservices. The *one application per application server* approach matches
    the idea of shared-nothing architectures. There are many aspects in which Java
    EE applications running in container orchestration frameworks support developing
    microservice architectures, such as service discovery, resilient communication
    via timeout, circuit breakers or bulkheads.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构之间不共享通用的技术或数据。无共享架构可以自由选择实现和持久化技术。以容器形式打包的零依赖Java EE应用非常适合微服务。每个应用服务器一个应用的方案与无共享架构的理念相匹配。Java
    EE应用在容器编排框架中运行时，支持开发微服务架构的许多方面，例如服务发现、通过超时进行弹性通信、断路器或防波堤。
- en: The following chapter covers the topics of performance, monitoring and logging.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将涵盖性能、监控和日志记录的主题。
