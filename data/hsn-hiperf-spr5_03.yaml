- en: Tuning Aspect-Oriented Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整面向切面编程
- en: 'In the previous chapter, we took a deep dive into one of Spring''s key features:
    dependency injection (IoC container). DI is an enterprise design pattern, that
    makes an object loosely-coupled from its required dependencies. We learned about
    Spring''s bean wiring configuration and best practices to follow to achieve optimal
    results.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们深入研究了Spring的一个关键特性：依赖注入（IoC容器）。DI是一种企业设计模式，使对象与其所需的依赖关系解耦。我们了解了Spring的bean装配配置和实现最佳实践以实现最佳结果。
- en: 'Moving further in line with Spring''s core features, in this chapter, we will
    discuss **Aspect-Oriented Programming** (**AOP**). We''ve already learned that
    DI promotes programming to the interface and the decoupling of the application''s
    objects, whereas AOP helps to achieve the decoupling of business logic and crosscutting
    concerns. A** crosscutting concern** is a concern applicable to part of the application
    or the entire application, for example, security, logging, and caching, which
    are required in almost every module of the application. AOP and AspectJ help to
    achieve these crosscutting concerns. In this chapter, we will go through the following
    topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续了解Spring的核心特性的同时，在本章中，我们将讨论**面向切面编程**（**AOP**）。我们已经了解到DI促进了编程到接口和应用对象的解耦，而AOP有助于实现业务逻辑和横切关注点的解耦。**横切关注点**是应用程序部分或整个应用程序适用的关注点，例如安全、日志记录和缓存，在几乎每个模块中都需要。AOP和AspectJ有助于实现这些横切关注点。在本章中，我们将讨论以下主题：
- en: AOP concepts
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AOP概念
- en: AOP proxies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AOP代理
- en: Spring AOP method for profiling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring AOP方法进行性能分析
- en: AOP versus AspectJ comparison
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AOP与AspectJ比较
- en: AOP best programming practices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AOP最佳编程实践
- en: AOP concepts
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AOP概念
- en: In this section, we will look at what problems we have to face if we use only
    the **object-oriented programming** (**OOP**) paradigm. Then we will understand
    how AOP solves those problems. We will walk through the concepts of AOP and ways
    to implement AOP concepts.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看如果只使用**面向对象编程**（**OOP**）范例，我们将面临哪些问题。然后我们将了解AOP如何解决这些问题。我们将深入了解AOP的概念和实现AOP概念的方法。
- en: Limitations of OOP
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OOP的局限性
- en: With the help of OOP fundamentals and design patterns, application development
    was divided into groups of functionalities. OOP protocols made many things easy
    and useful, such as introducing an interface with which we can implement loosely-coupled
    designs, encapsulation with which we can hide object data, and inheritance-extending
    functionalities, by classes, with which we can reuse work.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 借助OOP的基本原理和设计模式，应用程序开发被划分为功能组。OOP协议使许多事情变得简单和有用，例如引入接口，我们可以实现松耦合设计，封装，我们可以隐藏对象数据，继承-通过类扩展功能，我们可以重用工作。
- en: These advantages of OOP also add complexity as the system grows. With added
    complexities, the cost to maintain it and the chances of failure increase. To
    solve this, modularizing functionalities into simpler and more manageable modules
    helps reduce complexity.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 随着系统的增长，OOP的这些优势也增加了复杂性。随着复杂性的增加，维护成本和失败的机会也增加。为了解决这个问题，将功能模块化为更简单和更易管理的模块有助于减少复杂性。
- en: To modularize a system, we started following a practice of dividing applications
    into different logical layers, for example, presentation layer, service layer,
    and data layer. However, even after dividing the functionalities into different
    layers, there are certain functionalities that are required in all layers, for
    example, security, logging, caching, and performance monitoring. These functionalities
    are called crosscutting concerns**.**
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模块化系统，我们开始遵循将应用程序划分为不同逻辑层的做法，例如表示层、服务层和数据层。然而，即使将功能划分为不同层，仍然有一些功能在所有层中都是必需的，例如安全、日志记录、缓存和性能监控。这些功能被称为**横切关注点**。
- en: 'If we implement these crosscutting concerns using inheritance, it will violate
    the single responsibility of the SOLID principle and increase the object hierarchy.
    And if we implement them using composition, it will be more complicated. So the
    implementation of crosscutting concerns using OOP leads to two problems:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用继承来实现这些横切关注点，将违反SOLID原则的单一责任，并增加对象层次结构。如果我们使用组合来实现它们，将会更加复杂。因此，使用OOP实现横切关注点会导致两个问题：
- en: Code tangling
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码交织
- en: Code scattering
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码分散
- en: Let's discuss these problems more.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地讨论这些问题。
- en: Code tangling
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码交织
- en: '**Code tangling** means mixing crosscutting concerns and business logic, which
    in turn leads to tight coupling. Let''s look at the following diagram to understand
    code tangling:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码交织**意味着混合横切关注点和业务逻辑，从而导致紧耦合。让我们看下面的图表来理解代码交织：'
- en: '![](img/67377d05-09ec-425d-840a-a338a3cd835e.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67377d05-09ec-425d-840a-a338a3cd835e.jpg)'
- en: Code tangling
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 代码交织
- en: The preceding diagram illustrates how we mix transactions and security code
    along with our business logic in our service implementation. With such implementation,
    code reusability is reduced, maintenance is degraded, and the single responsibility
    principle is violated.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表说明了我们在服务实现中将事务和安全代码与业务逻辑混合在一起。通过这样的实现，代码的可重用性降低，维护性下降，并且违反了单一责任原则。
- en: Code scattering
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码分散
- en: 'Code scattering means crosscutting concerns are duplicated across all modules
    of an application. Let''s look at the following example to understand code scattering:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 代码分散意味着横切关注点在应用程序的所有模块中都是重复的。让我们看下面的例子来理解代码分散：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As we saw in preceding code sample, the permission check (security) is our crosscutting
    concern that is duplicated in all services.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码示例中看到的，权限检查（安全性）是我们的横切关注点，在所有服务中都是重复的。
- en: These code tangling and code scattering problems are solved by AOP, but how?
    We will see shortly.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码交织和代码分散的问题通过AOP得到解决，但是如何呢？我们很快就会看到。
- en: AOP – problem solver
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AOP-问题解决者
- en: 'We have seen in the preceding section that with OOP, code tangling and scattering occurs.
    With AOP, we can achieve the following objectives/benefits:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在前面的部分中看到，使用OOP会导致代码交织和分散。使用AOP，我们可以实现以下目标/好处：
- en: Modularizing crosscutting concerns
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化横切关注
- en: Decoupling of modules
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块解耦
- en: Removing crosscutting concerns regarding module dependency
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消除模块依赖的横切关注
- en: Spring AOP allows us to keep our crosscutting concerns logic separate from our
    business logic so we can focus on our application's main logic. To help us perform
    this separation, Spring provides `Aspects`, a normal class where we would implement
    our crosscutting concerns logic. Spring provides ways to inject these `Aspects`
    into the right place in our application without mixing them with business logic.
    We will see more about `Aspects`, how to implement it, and how to apply it in
    the following sections.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Spring AOP允许我们将横切关注逻辑与业务逻辑分开，这样我们就可以专注于应用的主要逻辑。为了帮助我们进行这种分离，Spring提供了`Aspects`，这是一个普通的类，我们可以在其中实现我们的横切关注逻辑。Spring提供了将这些`Aspects`注入到我们应用的正确位置的方法，而不会将它们与业务逻辑混合在一起。我们将在接下来的部分中更多地了解`Aspects`，如何实现它以及如何应用它。
- en: 'This diagram illustrates Spring AOP:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表说明了Spring AOP：
- en: '![](img/8ea23ba5-9b75-4ba8-9313-bf441b95b1da.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ea23ba5-9b75-4ba8-9313-bf441b95b1da.jpg)'
- en: How AOP solves code tangling
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: AOP如何解决代码交织
- en: Spring AOP terminology and concepts
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring AOP术语和概念
- en: 'AOP, like every technology, has its own terminologies. It has its own vocabulary.
    Spring uses the AOP paradigm in its Spring AOP module. However, Spring AOP has
    its own terminologies that are Spring-specific. To understand Spring AOP terms,
    let''s look at the following diagram:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: AOP，就像每种技术一样，有自己的术语。它有自己的词汇。Spring在其Spring AOP模块中使用AOP范式。但是，Spring AOP有其自己的术语，这些术语是特定于Spring的。为了理解Spring
    AOP术语，让我们看一下以下图表：
- en: '![](img/0fd2ee17-3144-487c-b6e7-a54fbb852387.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0fd2ee17-3144-487c-b6e7-a54fbb852387.jpg)'
- en: Spring AOP terminologies and concepts
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Spring AOP术语和概念
- en: 'Let''s understand each concept of Spring AOP mentioned in the preceding diagram:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解前面图表中提到的Spring AOP的每个概念：
- en: '**Join Point:** A point defined in the execution of our program. This execution
    could be method invocation, exception handling, class initialization, or object
    instantiation. Spring AOP supports method invocation only. In case we want a join
    point for anything other than method invocation, we can use Spring and AspectJ
    together. We will walk through AspectJ later in this chapter.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接点**：程序执行中定义的点。这个执行可以是方法调用、异常处理、类初始化或对象实例化。Spring AOP仅支持方法调用。如果我们想要除了方法调用之外的连接点，我们可以同时使用Spring和AspectJ。我们将在本章后面介绍AspectJ。'
- en: '**Advice**: A definition of what exactly needs to be done at the join point.
    Different types of advice are `@Before`, `@After`, `@Around`, `@AfterThrowing`,
    and `@AfterReturning`. We will see them in action in the *Types of advice* section.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**建议**：在连接点上需要做什么的定义。不同类型的建议包括`@Before`、`@After`、`@Around`、`@AfterThrowing`和`@AfterReturning`。我们将在*建议类型*部分看到它们的实际应用。'
- en: '**Pointcut**: A collection of join point used to define an advice that has
    to be executed. An advice is not necessarily applied to all join points, so pointcut
    gives fine-grained control over an advice that is to be executed on components
    in our application. Pointcuts are defined using an expression and Spring uses
    the AspectJ pointcut expression language. We will shortly see how this is done.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**切入点**：用于定义必须执行的建议的连接点集合。建议不一定适用于所有连接点，因此切入点可以对我们应用中要执行的建议进行精细控制。切入点使用表达式定义，Spring使用AspectJ切入点表达式语言。我们很快就会看到如何做到这一点。'
- en: '**Aspect**: The combination of advice and pointcuts that defines logic in an
    application and where it should execute. Aspect is implemented using the regular
    class annotated with the `@Aspect` annotation. This annotation is from Spring
    AspectJ support.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**切面**：建议和切入点的组合，定义了应用中的逻辑以及应该在哪里执行。切面是使用带有`@Aspect`注解的常规类来实现的。这个注解来自Spring
    AspectJ支持。'
- en: That's too much theory, isn't it? Now, let's dive into how to apply these Spring
    AOP concepts in real programming. You might have implemented these AOP concepts
    in your projects; however, did you know the background of why it was needed? No,
    so now you know why we need Spring AOP.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这太多理论了，不是吗？现在，让我们深入了解如何在实际编程中应用这些Spring AOP概念。您可能已经在项目中实现了这些AOP概念；但是，您知道为什么需要它吗？不知道，所以现在您知道为什么我们需要Spring
    AOP了。
- en: Since Spring 2.0, AOP implementation is made simpler using the AspectJ pointcut
    language defined either in the schema-based approach (XML) or annotations. We
    will discuss Spring 2.0 AspectJ support with annotations further in this chapter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Spring 2.0以来，AOP的实现变得更简单，使用了AspectJ切入点语言，可以在基于模式的方法（XML）或注解中定义。我们将在本章的后续部分讨论Spring
    2.0的AspectJ支持和注解。
- en: Defining pointcuts
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义切入点
- en: 'As we learned before, pointcuts define a point where advice should be applied.
    Spring AOP uses AspectJ''s expression language to define a point where advice
    should be applied. The following are the set of pointcut designators supported
    in Spring AOP:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前学到的，切入点定义了建议应该应用的位置。Spring AOP使用AspectJ的表达式语言来定义建议应该应用的位置。以下是Spring AOP支持的一组切入点设计器：
- en: '| **Designator** | **Description** |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| **设计器** | **描述** |'
- en: '| `execution` | It restricts matching to join points by a method execution. 
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `execution` | 它限制匹配只在方法执行时的连接点中进行。 |'
- en: '| `within` | It restricts matching to join points within certain types only.Example:
    `within(com.packt.springhighperformance.ch3.TransferService)`. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `within` | 它限制匹配只在特定类型的连接点中进行。例如：`within(com.packt.springhighperformance.ch3.TransferService)`。
    |'
- en: '| `args` | It restricts matching to join points where arguments are of the
    given type.Example: `args(account,..)`. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `args` | 它限制匹配只在参数为给定类型的连接点中进行。例如：`args(account,..)`。 |'
- en: '| `this` | It restricts matching to join points where the bean reference or
    Spring proxy object is an instance of the given type.Example: `this(com.packt.springhighperformance.ch3.TransferService)`.
    |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `this` | 它将匹配限制在bean引用或Spring代理对象是给定类型的实例的连接点。例如：`this(com.packt.springhighperformance.ch3.TransferService)`。
    |'
- en: '| `target` | It restricts matching to join points where the target object is
    an instance of the given type.Example: `target(com.packt.springhighperformance.ch3.TransferService)`.
    |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `target` | 它将匹配限制在目标对象是给定类型实例的连接点。例如：`target(com.packt.springhighperformance.ch3.TransferService)`。
    |'
- en: '| `@within` | It restrict matching to join points where the declared type has
    the given type of annotation.Example: `@within(org.springframework.transaction.annotation.Transactional)`.
    |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `@within` | 它将匹配限制在声明类型具有给定类型注解的连接点。例如：`@within(org.springframework.transaction.annotation.Transactional)`。
    |'
- en: '| `@target` | It restricts matching to join points where the target object
    has the given type of annotation.Example: `@target(org.springframework.transaction.annotation.Transactional)`.
    |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `@target` | 它将匹配限制在目标对象具有给定类型注解的连接点。例如：`@target(org.springframework.transaction.annotation.Transactional)`。
    |'
- en: '| `@args` | It restricts matching to join points where the type of the actual
    arguments passed have annotations of the given type.Example: `@args(com.packt.springhighperformance.ch3.Lockable)`.
    |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `@args` | 它将匹配限制在传递的实际参数类型具有给定类型注解的连接点。例如：`@args(com.packt.springhighperformance.ch3.Lockable)`。
    |'
- en: '| `@annotation` | It restricts matching to join points where the executing
    method has the given annotation.Example: `@annotation(org.springframework.transaction.annotation.Transactional)`.
    |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `@annotation` | 它将匹配限制在执行方法具有给定注解的连接点。例如：`@annotation(org.springframework.transaction.annotation.Transactional)`。
    |'
- en: 'Let''s see how to write the point expression using the `execution` designator:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`execution`指示符编写切入点表达式：
- en: 'Using `execution(<method-pattern>)`: Method matching to the pattern would be
    advised. The following is the method pattern:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`execution(<method-pattern>)`：匹配模式的方法将被advised。以下是方法模式：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To create composite pointcuts by joining other pointcuts, we can use the `&&`,
    `||`, and `!` operators (these mean AND, OR, and NOT, respectively).
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要通过连接其他切入点来创建复合切入点，我们可以使用`&&`、`||`和`!`运算符（分别表示AND、OR和NOT）。
- en: In the preceding method pattern, anything defined in `[ ]` is optional. Values
    without `[ ]` are mandatory to define.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法模式中，方括号`[ ]`中定义的内容是可选的。没有`[ ]`的值是必须定义的。
- en: 'The following diagram will illustrate point expression using the `execution`
    designator to apply advice whenever the `findAccountById()` method is executed:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表将说明使用`execution`指示符的切入点表达式，以便在执行`findAccountById()`方法时应用advice：
- en: '![](img/1f9aa8b5-8a9b-4ee7-b5b9-e7e8ab78d487.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1f9aa8b5-8a9b-4ee7-b5b9-e7e8ab78d487.jpg)'
- en: Execution join point pattern
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 执行连接点模式
- en: Types of advice
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: advice的类型
- en: 'In the preceding section, we learned different terminologies of AOP and how
    to define the pointcut expression. In this section, we will learn about the different
    types of advice in Spring AOP:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分，我们学习了AOP的不同术语以及如何定义切入点表达式。在本节中，我们将学习Spring AOP中不同类型的advice：
- en: '`@Before`: This advice is executed before the join point and it is defined
    in `aspect` using the `@Before` annotation. The declaration is shown in the following
    code:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Before`：这个advice在连接点之前执行，并且在`aspect`中使用`@Before`注解进行定义。声明如下代码所示：'
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If the `@Before` method throws an exception, the `transfer` target method would
    not get called. This is a valid use of `@Before` advice.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`@Before`方法抛出异常，`transfer`目标方法将不会被调用。这是`@Before` advice的有效用法。
- en: '`@After`: This advice is executed after the join point (method) exits/returns
    either normally or with any exception. To declare this advice, use the `@After`
    annotation. The declaration is shown in the following code:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@After`：这个advice在连接点（方法）退出/返回时执行，无论是正常返回还是有异常。要声明这个advice，使用`@After`注解。声明如下代码所示：'
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`@AfterReturning`: As we know in `@After` advice, the advice is executed in
    any case where the join point exits normally or with an exception. Now, if we
    want to run an advice only after a matched method returns normally, then what?
    Then we need `@AfterReturning`. Sometimes we need to perform some operation based
    on the value returned by the method. In those cases, we can use the `@AfterReturning`
    annotation. The declaration is shown in the following code:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@AfterReturning`：正如我们在`@After` advice中所知，无论连接点正常退出还是有异常，advice都会执行。现在，如果我们只想在匹配的方法正常返回后运行advice，怎么办？那么我们需要`@AfterReturning`。有时我们需要根据方法返回的值执行一些操作。在这些情况下，我们可以使用`@AfterReturning`注解。声明如下代码所示：'
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`@AfterThrowing`**:** This advice is called when an exception is thrown by
    a matched method in an expression. This is useful when we want to take some action
    when any particular type of exception is thrown or we want to track method execution
    to correct errors. It is declared using the `@AfterThrowing` annotation, as shown
    in the following code:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@AfterThrowing`：当表达式中的匹配方法抛出异常时，将调用这个advice。当我们想要在抛出特定类型的异常时采取某些操作，或者我们想要跟踪方法执行以纠正错误时，这是很有用的。它使用`@AfterThrowing`注解声明，如下代码所示：'
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Similar to `@AfterThrowing` `returning` attribute, the `throwing` attribute
    in the `@AfterThrowing` advice must match the name of the parameter in the advice
    method. The `throwing` attribute restricts matching to those method executions
    that throws an exception of the specified type.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`@AfterThrowing` `returning`属性，`@AfterThrowing` advice中的`throwing`属性必须与advice方法中的参数名称匹配。`throwing`属性将匹配那些抛出指定类型异常的方法执行。
- en: '`@Around`**:** The last and final advice that is applied around the matched
    method. This means that it is a combination of the `@Before` and `@After` advice
    we saw earlier. However, the `@Around` advice is more powerful than `@Before`
    and `@After` combined. It is powerful because it can decide whether to proceed
    to the join point method or return its own value or throw an exception. The `@Around`
    advice can be used with the `@Around` annotation. The first parameter of the advice
    method in `@Around` advice should be `ProceedingJoinPoint`. The following is the
    code sample of how to use the `@Around` advice:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Around`**：**应用于匹配方法周围的最后一个建议。这意味着它是我们之前看到的 `@Before` 和 `@After` 建议的组合。但是，`@Around`
    建议比 `@Before` 和 `@After` 更强大。它更强大，因为它可以决定是否继续到连接点方法或返回自己的值或抛出异常。`@Around` 建议可以与
    `@Around` 注解一起使用。`@Around` 建议中建议方法的第一个参数应该是 `ProceedingJoinPoint`。以下是如何使用 `@Around`
    建议的代码示例：'
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can invoke `proceed` once, many times, or not at all within the body of the
    `@Around` advice.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `@Around` 建议的主体内部一次、多次或根本不调用 `proceed`。
- en: Aspect instantiation models
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Aspect 实例化模型
- en: By default, the declared `aspect` is `singleton`, so there will be only one
    instance of our `aspect` per class loader (and not per JVM). The instance of our
    `aspect` will be destroyed only when the class loader is garbage.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，声明的 `aspect` 是 `singleton`，因此每个类加载器（而不是每个 JVM）只会有一个 `aspect` 实例。我们的 `aspect`
    实例只有在类加载器被垃圾回收时才会被销毁。
- en: If we need to have our `aspect` with private attributes hold data relative to
    class instances, the `aspect` needs to be stateful. To do so, Spring with its
    AspectJ support provides a way using `perthis` and `pertarget` instantiation models.
    AspectJ is an independent library, and has other instantiation models in addition
    to `perthis` and `pertarget`, such as `percflow`, `percflowbelow`, and `pertypewithin`,
    which are not supported in Spring's AspectJ support.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要让我们的 `aspect` 具有私有属性来保存与类实例相关的数据，那么 `aspect` 需要是有状态的。为此，Spring 与其 AspectJ
    支持提供了使用 `perthis` 和 `pertarget` 实例化模型的方法。AspectJ 是一个独立的库，除了 `perthis` 和 `pertarget`
    之外，还有其他实例化模型，如 `percflow`、`percflowbelow` 和 `pertypewithin`，这些在 Spring 的 AspectJ
    支持中不受支持。
- en: 'To create a stateful `aspect` using `perthis`, we need to declare `perthis`
    as follows in our `@Aspect` declaration:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `perthis` 创建一个有状态的 `aspect`，我们需要在我们的 `@Aspect` 声明中声明 `perthis` 如下：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once we declare our `@Aspect` with the `perthis` clause, one `aspect` instance
    will be created for each unique `TransferService` object executing the `transfer`
    method (each unique object that is bound to `this` at join points matched by the
    pointcut expression). The instance of aspect goes out of scope when the `TransferService`
    object goes out of scope.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们用 `perthis` 子句声明了我们的 `@Aspect`，将为每个执行 `transfer` 方法的唯一 `TransferService`
    对象创建一个 `aspect` 实例（通过切入点表达式匹配的 `this` 绑定到的每个唯一对象）。当 `TransferService` 对象超出范围时，`aspect`
    实例也会超出范围。
- en: '`pertarget` works the same as `perthis`; however, in `pertarget`, it creates
    one `aspect` instance per unique target object at join points matched by the pointcut
    expression.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`pertarget` 与 `perthis` 的工作方式相同；但是，在 `pertarget` 中，它会在切入点表达式匹配的连接点上为每个唯一的目标对象创建一个
    `aspect` 实例。'
- en: Now you might be wondering how Spring would have applied advice without making
    calls from the business logic classes to the crosscutting concern class (`Aspects`).
    So the answer is, Spring does this using the proxy pattern. It weaves your `Aspects`
    to the target objects by creating proxied objects. Let's look at the Spring AOP
    proxy in detail in the next section.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能想知道 Spring 是如何应用建议而不是从业务逻辑类到横切关注类（`Aspects`）进行调用的。答案是，Spring 使用代理模式来实现这一点。它通过创建代理对象将你的
    `Aspects` 编织到目标对象中。让我们在下一节详细看一下 Spring AOP 代理。
- en: AOP proxies
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AOP 代理
- en: It is the proxy pattern that made Spring AOP able to decouple crosscutting concerns
    from the core application's business logic or functionalities. The proxy pattern
    is a structural design pattern included in a book by the **Gang of Four** (**GoF**).
    In practice, the proxy pattern creates different object wrapping out of an original
    object without changing the behavior of the original object to allow intercepting
    its method call, and the outside world would feel they are interacting with the
    original object and not a proxy.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正是代理模式使得 Spring AOP 能够将横切关注从核心应用程序的业务逻辑或功能中解耦出来。代理模式是一种结构设计模式，包含在《四人组》（**GoF**）的一本书中。在实践中，代理模式通过创建不同的对象包装原始对象，而不改变原始对象的行为，以允许拦截其方法调用，外部世界会感觉他们正在与原始对象交互，而不是代理。
- en: JDK dynamic proxies and CGLIB proxies
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JDK 动态代理和 CGLIB 代理
- en: 'The proxy in Spring AOP can be created in two ways:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Spring AOP 中的代理可以通过两种方式创建：
- en: 'JDK proxy (dynamic proxy): The JDK proxy creates a new proxy object by implementing
    interfaces of the target object and delegating method calls'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK 代理（动态代理）：JDK 代理通过实现目标对象的接口并委托方法调用来创建新的代理对象
- en: 'CGLIB proxy: The CGLIB proxy creates a new proxy object by extending the target
    object and delegating method calls'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CGLIB 代理：CGLIB 代理通过扩展目标对象并委托方法调用来创建新的代理对象
- en: 'Let''s look at these proxy mechanisms and how they differ in the following
    table:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些代理机制以及它们在下表中的区别：
- en: '| **JDK proxy** | **CGLIB proxy** |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| **JDK 代理** | **CGLIB 代理** |'
- en: '| It is built in JDK. | It is a custom-developed library. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 它内置在 JDK 中。 | 它是一个自定义开发的库。 |'
- en: '| JDK proxy works on the interface. | CGLIB proxy works on subclassing. This
    is used when the interface is not present. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| JDK 代理在接口上工作。 | CGLIB 代理在子类上工作。当接口不存在时使用。'
- en: '| It will proxy all interfaces. | It cannot work when the method and class
    are final. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 它将代理所有接口。 | 当方法和类都是 final 时无法工作。 |'
- en: From Spring 3.2, the CGLIB library is packaged with Spring Core, so there's
    no need to include this library separately in our application.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Spring 3.2 开始，CGLIB 库已经打包到 Spring Core 中，因此在我们的应用程序中不需要单独包含这个库。
- en: From Spring 4.0, the constructor of the proxied object will not be called twice,
    as the CGLIB proxy instance will be created via Objenesis.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Spring 4.0 开始，代理对象的构造函数将不会被调用两次，因为 CGLIB 代理实例将通过 Objenesis 创建。
- en: By default, Spring will try to use the JDK dynamic proxy if the class of the
    target object implements the interface; if the class of the target object does
    not implement any interface then Spring will create a proxy using the CGLIB library.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果目标对象的类实现了接口，则Spring将尝试使用JDK动态代理；如果目标对象的类没有实现任何接口，则Spring将使用CGLIB库创建代理。
- en: 'If the class of the target object implements an interface and it is injected
    as a concrete class in another bean, then Spring will throw an exception: `NoSuchBeanDefinitionException`.
    The solution to this problem is either to inject through the interface (which
    is a best practice) or to annotate the injection with `Scope(proxyMode=ScopedProxyMode.TARGET_CLASS)`.
    Then Spring will create a proxy object using the CGLIB proxy. This configuration
    disables Spring''s use of JDK proxies. Spring will then always extend concrete
    classes, even if an interface is injected. The CGLIB proxy uses the decorator
    pattern to weave advice to the target object by creating a proxy:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标对象的类实现了一个接口，并且作为一个具体类注入到另一个bean中，那么Spring将抛出异常：`NoSuchBeanDefinitionException`。解决这个问题的方法要么通过接口注入（这是最佳实践），要么用`Scope(proxyMode=ScopedProxyMode.TARGET_CLASS)`注解注入。然后Spring将使用CGLIB代理创建代理对象。这个配置禁用了Spring使用JDK代理。Spring将始终扩展具体类，即使注入了一个接口。CGLIB代理使用装饰器模式通过创建代理来将建议编织到目标对象中：
- en: '![](img/39e2351e-1d2b-4566-aa34-d6d2266ad700.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39e2351e-1d2b-4566-aa34-d6d2266ad700.jpg)'
- en: JDK dynamic proxy and CGLIB proxy
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: JDK动态代理和CGLIB代理
- en: Creating a proxy would be able to delegate all calls to a method to interceptors
    (advice). However, once a method call reaches the target object, any internal
    method call made within that target object is not going to be intercepted. So,
    any method call within the object reference would not result in any advice execution.
    In order to solve this, either refactor the code so that direct self-invocation
    doesn't happen or use AspectJ weaving. To solve this in Spring, we need to set
    the expose a proxy property to true and use `AopContext.currentProxy()` to make
    self-invocation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 创建代理将能够将所有调用委托给拦截器（建议）。但是，一旦方法调用到达目标对象，目标对象内部的任何方法调用都不会被拦截。因此，对象引用内的任何方法调用都不会导致任何建议执行。为了解决这个问题，要么重构代码，使直接自我调用不会发生，要么使用AspectJ编织。为了在Spring中解决这个问题，我们需要将`expose
    a proxy`属性设置为true，并使用`AopContext.currentProxy()`进行自我调用。
- en: Spring recommends using the JDK proxy wherever possible. Hence, try to implement
    the abstraction layer almost everywhere in your application so that the JDK proxy
    will be applied when the interface is available and we have not explicitly set
    it to use the CGLIB proxy only.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Spring建议尽可能使用JDK代理。因此，尽量在应用程序的几乎所有地方实现抽象层，这样当接口可用且我们没有明确设置为仅使用CGLIB代理时，将应用JDK代理。
- en: ProxyFactoryBean
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ProxyFactoryBean
- en: 'Spring provides a classic way of creating proxies of objects manually using
    `ProxyFactoryBean`, which will create an AOP proxy wrapping the target object.
    `ProxyFactoryBean` provides a way to set advice and advisors that are eventually
    merged into an AOP proxy. The key properties inherited from the `org.springframework.aop.framework.ProxyConfig`
    superclass for all AOP proxy factories in Spring are as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了一种经典的方式来手动创建对象的代理，使用`ProxyFactoryBean`，它将创建一个AOP代理包装目标对象。`ProxyFactoryBean`提供了一种设置建议和建议者的方法，最终合并到AOP代理中。从Spring中所有AOP代理工厂继承的`org.springframework.aop.framework.ProxyConfig`超类的关键属性如下：
- en: '`proxyTargetClass`: If it''s true, then the proxy is created using CGLIB only.
    If it''s not set, the proxy will be created using the JDK proxy if the target
    class implements the interface; otherwise, the proxy will be created using CGLIB.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxyTargetClass`：如果为true，则仅使用CGLIB创建代理。如果未设置，则如果目标类实现了接口，则使用JDK代理创建代理；否则，将使用CGLIB创建代理。'
- en: '`optimize`: For the CGLIB proxy, this instructs the proxy to apply some aggressive
    optimizations. Currently, it is not supported by the JDK proxy. This needs to
    be used wisely.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`optimize`：对于CGLIB代理，这指示代理应用一些激进的优化。目前，JDK代理不支持这一点。这需要明智地使用。'
- en: '`frozen`: If a proxy is set as `frozen`, then changes to the configuration
    are not allowed. This is useful when we don''t want callers to modify the proxy
    after the proxy has been created. This is used for optimization. The default value
    of this property is `false`.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`冻结`：如果代理设置为`冻结`，则不允许对配置进行更改。当我们不希望调用者在代理创建后修改代理时，这是很有用的。这用于优化。此属性的默认值为`false`。'
- en: '`exposeProxy`: Setting this property to true determines whether the current
    proxy should be exposed to `ThreadLocal` or not. If it''s exposed to `ThreadLocal`,
    then the target can use the `AopContext.currentProxy()` method for self-invocation
    of the method.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exposeProxy`：将此属性设置为true确定当前代理是否应该暴露给`ThreadLocal`。如果暴露给`ThreadLocal`，则目标可以使用`AopContext.currentProxy()`方法进行方法的自我调用。'
- en: ProxyFactoryBean in action
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ProxyFactoryBean的作用
- en: We will define a regular Spring bean as target bean, say `TransferService`,
    and then, using `ProxyFactoryBean`, we will create a proxy that will be accessed
    by our application. To advice the `transfer` method of `TransferService`, we will
    set the point expression using `AspectJExpressionPointcut` and we will create
    the interceptor, which we will set into `DefaultPointcutAdvisor` to create the
    advisor.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个常规的Spring bean作为目标bean，比如`TransferService`，然后，使用`ProxyFactoryBean`，我们将创建一个代理，该代理将被我们的应用程序访问。为了对`TransferService`的`transfer`方法进行建议，我们将使用`AspectJExpressionPointcut`设置切点表达式，并创建拦截器，然后将其设置到`DefaultPointcutAdvisor`中创建建议者。
- en: 'The target object or bean is as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 目标对象或bean如下：
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following code is for the method interceptor or advice:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是方法拦截器或建议：
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The Spring configuration is as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Spring配置如下：
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code samples, we have not separately defined `TransferService`
    as Spring bean. We have created an anonymous bean of `TransferService` and then
    created its proxy using `ProxyFactoryBean`. This has an advantage that there will
    be only one object of the `TransferService` type and no one can obtain an unadvised
    object. This also reduces ambiguity if we want to wire this bean to any other
    bean using the Spring IoC.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们没有单独定义`TransferService`作为Spring bean。我们创建了`TransferService`的匿名bean，然后使用`ProxyFactoryBean`创建了它的代理。这样做的好处是`TransferService`类型只有一个对象，没有人可以获得未经建议的对象。这也减少了如果我们想要使用Spring
    IoC将此bean连接到任何其他bean时的歧义。
- en: With `ProxyFactoryBean`, we can configure AOP proxies that provide all flexibility
    of the programmatic method without needing our application to do AOP configurations.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ProxyFactoryBean`，我们可以配置AOP代理，提供了编程方法的所有灵活性，而不需要我们的应用进行AOP配置。
- en: It is best to use the declarative method of proxy configuration over the programmatic
    method unless we need to perform a manipulative action at runtime or we want to
    gain fine-grained control.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最好使用声明性的代理配置方法，而不是编程方法，除非我们需要在运行时执行操作或者想要获得细粒度的控制。
- en: Performance JDK dynamic proxy versus CGLIB proxy
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能JDK动态代理与CGLIB代理
- en: 'We learned what proxies are used for. According to the GoF book, *Design Patterns:
    Elements of Reusable Object-Oriented Software*, a proxy is a placeholder for another
    object to control access to it. As the proxy lies in between the caller of an
    object and the real object, it can decide whether to prevent the invocation of
    the real (or target) object or perform some action before the target object is
    invoked.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了代理的用途。根据GoF书籍《设计模式：可复用面向对象软件的元素》，代理是另一个对象的占位符，用于控制对它的访问。由于代理位于调用对象和真实对象之间，它可以决定是否阻止对真实（或目标）对象的调用，或者在调用目标对象之前执行一些操作。
- en: Many object-relational mappers use proxy patterns to implement a behavior that
    prevents data from being loaded until it is actually needed. Sometimes this is
    called **lazy loading**. Spring also uses proxies to develop some of its functionality,
    such as its transaction management, security, caching, and the AOP framework.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 许多对象关系映射器使用代理模式来实现一种行为，该行为可以防止数据在实际需要之前被加载。有时这被称为**延迟加载**。Spring也使用代理来开发一些功能，比如事务管理、安全性、缓存和AOP框架。
- en: As proxies objects are an additional object created at runtime, either by JDK
    proxy or CGLIB library, and sit between the caller object and the target object,
    it is going to add some overhead to a plain method invocation.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代理对象是在运行时由JDK代理或CGLIB库创建的额外对象，并位于调用对象和目标对象之间，它将增加对普通方法调用的一些开销。
- en: Let's find out how much overhead proxies add to a plain method invocation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找出代理对普通方法调用增加了多少开销。
- en: 'The following snippet shows the Spring Java-based configuration class for the
    CGLIB proxy:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段显示了CGLIB代理的Spring基于Java的配置类：
- en: '[PRE11]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The Spring Java-based configuration class for the JDK proxy is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: JDK代理的Spring基于Java的配置类如下：
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The JUnit class is as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit类如下：
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The overhead time varies based on hardware tools, such as CPU and memory. The
    following is the kind of output we would get:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 开销时间根据硬件工具（如CPU和内存）而异。以下是我们将获得的输出类型：
- en: '[PRE14]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can do benchmarking using tools such as Google's Caliper, found at [https://github.com/google/caliper](https://github.com/google/caliper),
    or **Java Microbenchmark Harness** (**JMH**), found at [http://openjdk.java.net/projects/code-tools/jmh/](http://openjdk.java.net/projects/code-tools/jmh/).
    Many performance tests, using different tools and scenarios, delivered different
    results. A few tests showed CGLIB is faster than the JDK proxy, and a few got
    other results. If we test AspectJ, which we'll discuss later in this chapter,
    performance is still better than the JDK proxy and CGLIB proxy, due to its bytecode-weaving
    mechanism instead of a proxy object.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用诸如Google的Caliper（[https://github.com/google/caliper](https://github.com/google/caliper)）或**Java微基准测试工具**（**JMH**）（[http://openjdk.java.net/projects/code-tools/jmh/](http://openjdk.java.net/projects/code-tools/jmh/)）等工具进行基准测试。使用不同的工具和场景进行了许多性能测试，得到了不同的结果。一些测试显示CGLIB比JDK代理更快，而另一些测试得到了其他结果。如果我们测试AspectJ，这是本章稍后将讨论的内容，性能仍然优于JDK代理和CGLIB代理，因为它使用了字节码编织机制而不是代理对象。
- en: The question here is do we really need to worry about the overhead we saw? The
    answer is both yes and no. We will discuss both these answers.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是我们是否真的需要担心我们看到的开销？答案既是肯定的，也是否定的。我们将讨论这两个答案。
- en: We don't have to really worry about the overhead because that amount of time
    the proxy added is negligible and the amount of benefits provided by AOP or the
    proxy pattern is high. We already saw the benefits of AOP in the preceding sections
    of this chapter, such as transaction management, security, lazy loading, or anything
    that is crosscutting but with code simplification, centralized management, or
    maintenance of code.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必真正担心开销，因为代理增加的时间微不足道，而AOP或代理模式提供的好处很大。我们已经在本章的前几节中看到了AOP的好处，比如事务管理、安全性、延迟加载或任何横切的东西，但通过代码简化、集中管理或代码维护。
- en: Also, we need to worry about the overhead when our application has **Service
    Level Agreement** (**SLA**) to deliver in milliseconds or our application has
    a very high volume of concurrent requests or loads. In this case, each millisecond
    spent is important for our application. However, we still need to use AOP in our
    application in order to implement crosscutting concerns. So, what we need to take
    care of here is the right AOP configuration, avoiding the unnecessary scanning
    of objects for advice, configuring the exact join point to which we want advice,
    and avoiding the implementation of fine-grained requirements through AOP. For
    fine-grained requirements user AspectJ (the byte-code-weaving approach).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当我们的应用程序有**服务级别协议**（**SLA**）以毫秒交付，或者我们的应用程序有非常高的并发请求或负载时，我们还需要担心开销。在这种情况下，每花费一毫秒对我们的应用程序都很重要。但是，我们仍然需要在我们的应用程序中使用AOP来实现横切关注点。因此，我们需要在这里注意正确的AOP配置，避免不必要的扫描对象以获取建议，配置我们想要建议的确切连接点，并避免通过AOP实现细粒度要求。对于细粒度要求，用户可以使用AspectJ（字节码编织方法）。
- en: So the rule of thumb is, use AOP to implement crosscutting concerns and leverage
    its benefits. However, implement it cautiously, and with the right configurations
    that do not degrade system performance, by applying advice or proxies to each
    and every operation.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，经验法则是，使用AOP来实现横切关注点并利用其优势。但是，要谨慎实施，并使用正确的配置，不会通过对每个操作应用建议或代理来降低系统性能。
- en: Caching
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存
- en: In order to improve the performance of an application, caching heavy operations
    is inevitable. Spring 3.1 added a great abstraction layer called **caching** that
    helped to abandon all custom-implemented `aspects`, decorators, and code injected
    into the business logic related to caching.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高应用程序的性能，缓存重操作是不可避免的。Spring 3.1添加了一个名为**caching**的优秀抽象层，帮助放弃所有自定义实现的`aspects`，装饰器和注入到与缓存相关的业务逻辑中的代码。
- en: Spring applies caching to the methods of Spring beans using AOP concepts; we
    learned about it in the *AOP concepts* section of this chapter. Spring creates
    proxies of the Spring beans where the methods are annotated to be cached.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Spring使用AOP概念将缓存应用于Spring bean的方法；我们在本章的*AOP概念*部分学习了它。Spring会创建Spring bean的代理，其中方法被注释为缓存。
- en: 'In order to leverage the benefits of Spring''s caching abstraction layer, just
    annotate heavy methods with `@Cacheable`. Also, we need to notify our application
    that methods are cached by annotating our configuration class with `@EnableCaching`.
    The following is the example of caching a method:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用Spring的缓存抽象层的好处，只需使用`@Cacheable`注释重的重方法。此外，我们需要通过在配置类上注释`@EnableCaching`来通知我们的应用程序方法已被缓存。以下是缓存方法的示例：
- en: '[PRE15]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `@Cacheable` annotation has the following attributes:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Cacheable`注释具有以下属性：'
- en: '`value`: Name of cache'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`：缓存的名称'
- en: '`key`: Caching key for each cached item'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key`：每个缓存项的缓存键'
- en: '`condition`: Defines whether to apply caching or not based on the evaluation
    of the **Spring Expression Language** (**SpEL**) expression'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`condition`：根据**Spring表达式语言**（**SpEL**）表达式的评估来定义是否应用缓存'
- en: '`unless`: This is another condition written in SpEL, and if it is true, it
    prevents the return value from being cached'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unless`：这是另一个用SpEL编写的条件，如果为真，则阻止返回值被缓存'
- en: 'The following are additional annotations provided by Spring related to caching:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Spring提供的与缓存相关的其他注释：
- en: '`@CachePut`: It will let the method execute and update the cache'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@CachePut`：它将允许方法执行并更新缓存'
- en: '`@CacheEvict`: It will remove stale data from the cache'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@CacheEvict`：它将从缓存中删除陈旧的数据'
- en: '`@Caching`: It allows you to group multiple annotations `@Cacheable`, `@CachePut`,
    and `@CacheEvict` on the same method'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Caching`：它允许您在同一方法上组合多个注释`@Cacheable`，`@CachePut`和`@CacheEvict`'
- en: '`@CacheConfig`: It will allow us to annotate our entire class instead of repeating
    on each method'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@CacheConfig`：它允许我们在整个类上注释，而不是在每个方法上重复'
- en: 'We can use `@Cacheable` on methods that are retrieving data and use `@CachePut`
    on a method that performs insertion to update the cache. The code sample is as
    follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在检索数据的方法上使用`@Cacheable`，并在执行插入以更新缓存的方法上使用`@CachePut`。代码示例如下：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Annotating methods to cache the data would not store the data; for that, we
    need to implement or provide `CacheManager`. Spring, by default, provides some
    cache managers in the `org.springframework.cache` package and one of them is `SimpleCacheManager`.
    The `CacheManager` code sample is as shown:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对方法进行注释以缓存数据不会存储数据；为此，我们需要实现或提供`CacheManager`。Spring默认情况下在`org.springframework.cache`包中提供了一些缓存管理器，其中之一是`SimpleCacheManager`。`CacheManager`代码示例如下：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Spring also provides support to integrate the following third-party cache managers:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Spring还提供支持，以集成以下第三方缓存管理器：
- en: EhCache
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EhCache
- en: Guava
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Guava
- en: Caffeine
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Caffeine
- en: Redis
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redis
- en: Hazelcast
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hazelcast
- en: Your custom cache
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的自定义缓存
- en: AOP method profiling
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AOP方法分析
- en: Applications can have many business methods. Due to some implementation issues,
    some methods take time and we want to measure how much time is taken by those
    methods and we may want to analyze method arguments, as well. Spring AOP provides
    a way to perform method profiling without touching business methods. Let's see
    how.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以有许多业务方法。由于一些实现问题，一些方法需要时间，我们希望测量这些方法花费了多少时间，我们可能还想分析方法参数。Spring AOP提供了一种执行方法分析的方法，而不触及业务方法。让我们看看如何做到这一点。
- en: PerformanceMonitorInterceptor
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PerformanceMonitorInterceptor
- en: Let's see how to perform profiling or monitoring on our method execution. This
    is done with the help of a simple option provided by Spring AOP using the `PerformanceMonitorInterceptor`
    class.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何对我们的方法执行进行分析或监视。这是通过Spring AOP提供的`PerformanceMonitorInterceptor`类的简单选项来完成的。
- en: As we have learned, Spring AOP allows the defining of crosscutting concerns
    in applications by intercepting the execution of one or more methods to add extra
    functionality without touching the core business classes.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所了解的，Spring AOP允许在应用程序中通过拦截一个或多个方法的执行来定义横切关注点，以添加额外功能，而不触及核心业务类。
- en: The `PerformanceMonitorInterceptor` class from Spring AOP is an interceptor
    that can be tied to any custom method to be executed at the same time. This class
    uses a `StopWatch` instance to log the beginning and ending time of the method
    execution.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Spring AOP中的`PerformanceMonitorInterceptor`类是一个拦截器，可以绑定到任何自定义方法以在同一时间执行。该类使用`StopWatch`实例来记录方法执行的开始和结束时间。
- en: 'Let''s monitor the `transfer` method of `TransferService`. The following is
    the `TransferService` code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们监视`TransferService`的`transfer`方法。以下是`TransferService`的代码：
- en: '[PRE18]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following code is `@Pointcut` to monitor the advice method using Spring
    interceptor:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是`@Pointcut`，用于使用Spring拦截器监视建议方法：
- en: '[PRE19]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following code is the advisor class:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是advisor类：
- en: '[PRE20]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following code is the Spring Java configuration class:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是Spring Java配置类：
- en: '[PRE21]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The expression in pointcut identifies the methods that we want to intercept.
    We have defined `PerformanceMonitorInterceptor` as a bean and then created `PerformanceMonitorAdvisor`
    to associate pointcut with the interceptor.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Pointcut表达式标识我们想要拦截的方法。我们已经将`PerformanceMonitorInterceptor`定义为一个bean，然后创建了`PerformanceMonitorAdvisor`来将切入点与拦截器关联起来。
- en: In our `Appconfig`, we have annotated with the `@EnableAspectJAutoProxy` annotation
    to enable AspectJ support for our beans to create a proxy automatically.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Appconfig`中，我们使用`@EnableAspectJAutoProxy`注解来为我们的bean启用AspectJ支持，以自动创建代理。
- en: To have `PerformanceMonitorInterceptor` work, we need to set the log level of
    the target object, `TransferServiceImpl`, to the `TRACE` level as this is the
    level at which it logs messages.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要使`PerformanceMonitorInterceptor`起作用，我们需要将目标对象`TransferServiceImpl`的日志级别设置为`TRACE`级别，因为这是它记录消息的级别。
- en: 'For every execution of the `transfer` method, we will see the `TRACE` message
    in the console log:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每次执行`transfer`方法，我们将在控制台日志中看到`TRACE`消息：
- en: '[PRE22]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Custom monitoring interceptor
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义监视拦截器
- en: '`PerformanceMonitorInterceptor` is a very basic and simple way to monitor the
    execution of our method time. However, most of the time we would need more a controlled
    way to monitor the method and its parameters. For that, we can implement our custom
    interceptor, either by extending `AbstractMonitoringInterceptor` or writing around
    advice or a custom annotation. Here we will write a custom interceptor extending
    `AbstractMonitoringInterceptor`.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`PerformanceMonitorInterceptor`是监视我们方法执行时间的一种非常基本和简单的方式。然而，大多数情况下，我们需要更加受控的方式来监视方法及其参数。为此，我们可以通过扩展`AbstractMonitoringInterceptor`或编写环绕建议或自定义注解来实现我们的自定义拦截器。在这里，我们将编写一个扩展`AbstractMonitoringInterceptor`的自定义拦截器。'
- en: 'Let''s extend the `AbstractMonitoringInterceptor` class and override the `invokeUnderTrace`
    method to log the `start`, `end`, and duration of a method. We can also log a
    warning if the method execution lasts more than `5` milliseconds. The following
    is the code sample for the custom monitoring interceptor:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展`AbstractMonitoringInterceptor`类，并重写`invokeUnderTrace`方法来记录方法的`start`、`end`和持续时间。如果方法执行时间超过`5`毫秒，我们还可以记录警告。以下是自定义监视拦截器的代码示例：
- en: '[PRE23]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Every other step we saw in the basic `PerformanceMonitorInterceptor` would be
    same, just replace `PerformanceMonitorInterceptor` with `CustomPerformanceMonitorInterceptor`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本的`PerformanceMonitorInterceptor`中看到的每一步都是相同的，只是用`CustomPerformanceMonitorInterceptor`替换`PerformanceMonitorInterceptor`。
- en: 'The following output is generated:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 生成以下输出：
- en: '[PRE24]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Spring AOP versus AspectJ
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring AOP与AspectJ
- en: So far, we have seen AOP using proxy patterns and runtime weaving. Now let's
    look at AOP at compile time and load time weaving.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了使用代理模式和运行时织入的AOP。现在让我们看看编译时和加载时织入的AOP。
- en: What is AspectJ?
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是AspectJ？
- en: As we know from the start of this chapter, AOP is a programming paradigm that
    helps to decouple our code by separating the implementation of crosscutting concerns. AspectJ
    is the original implementation of AOP, which implements both concerns and the
    weaving of crosscutting concerns using extensions of Java programming language.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从本章的开头所知，AOP是一种编程范式，通过将横切关注点的实现分离来帮助解耦我们的代码。AspectJ是AOP的原始实现，它使用Java编程语言的扩展来实现关注点和横切关注点的编织。
- en: To enable AspectJ in our project, we need AspectJ libraries and AspectJ provides
    different libraries based on its usage. One can find all its libraries, at [https://mvnrepository.com/artifact/org.aspectj](https://mvnrepository.com/artifact/org.aspectj).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的项目中启用AspectJ，我们需要AspectJ库，AspectJ根据其用途提供了不同的库。可以在[https://mvnrepository.com/artifact/org.aspectj](https://mvnrepository.com/artifact/org.aspectj)找到所有的库。
- en: 'In AspectJ, `Aspects` will be created in a file with the extension `.aj`*.* The
    following is the sample `TransferAspect.aj` file:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在AspectJ中，`Aspects`将在扩展名为`.aj`的文件中创建。以下是`TransferAspect.aj`文件的示例：
- en: '[PRE25]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To enable compile-time weaving, when we have both `aspect` code and code to
    which we want to weave `aspects`, use the Maven plugin as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用编译时织入，当我们既有`aspect`代码又有我们想要织入`aspects`的代码时，使用Maven插件如下：
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To perform post-compile time weaving, when we want to weave existing class
    files and JAR files, use Mojo''s AspectJ Maven plugin as follows. The artifact
    or JAR files we reference to weave must be listed as `<dependencies/>` in the
    Maven project and listed as `<weaveDependencies/>` in the `<configuration>` of
    the AspectJ Maven plugin. The following is the Maven sample for how to define
    weaving dependencies:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行编译后织入，当我们想要织入现有的类文件和JAR文件时，使用Mojo的AspectJ Maven插件如下。我们引用的artifact或JAR文件必须在Maven项目的`<dependencies/>`中列出，并在AspectJ
    Maven插件的`<configuration>`中列出为`<weaveDependencies/>`。以下是如何定义织入依赖项的Maven示例：
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To perform **Load-time weaving** (**LTW**), when we want to defer our weaving
    until the class loader loads a class file, we would need a weaving agent; use
    the Maven plugin as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行**加载时织入**（**LTW**），当我们想要推迟我们的织入直到类加载器加载类文件时，我们需要一个织入代理；使用Maven插件如下：
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For LTW, it looks for `aop.xml` in the classpath under the `META-INF` folder.
    The file contains the `aspect` and `weaver` tags as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于LTW，它在`META-INF`文件夹下的类路径中查找`aop.xml`。文件包含如下的`aspect`和`weaver`标签：
- en: '[PRE29]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: So this was just an introduction for how to enable AspectJ in our project.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个关于如何在项目中启用AspectJ的介绍。
- en: Differences between Spring AOP and AspectJ
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring AOP和AspectJ之间的区别
- en: Let's look at the differences between Spring AOP (runtime weaving) and AspectJ
    (compile-time and LTW).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看Spring AOP（运行时织入）和AspectJ（编译时和LTW）之间的区别。
- en: Capabilities and goals
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 能力和目标
- en: Spring AOP provides a simple AOP implementation to implement crosscutting concerns
    using the proxy pattern and decorator pattern. It is not considered a complete
    AOP solution, Spring can be applied to the beans that are managed by a Spring
    container.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Spring AOP提供了一个简单的AOP实现，使用代理模式和装饰器模式来实现横切关注点。它不被认为是一个完整的AOP解决方案，Spring可以应用于由Spring容器管理的bean。
- en: AspectJ is the original AOP technology, aiming to provide a complete AOP solution.
    It is more robust, however, and more complicated than Spring AOP. The benefit
    of AspectJ is that it can be applied across all domain objects.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: AspectJ是最初的AOP技术，旨在提供完整的AOP解决方案。它比Spring AOP更健壮，但也更复杂。AspectJ的好处是可以应用于所有领域对象。
- en: Weaving
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 织入
- en: Both Spring AOP and AspectJ use the different types of weaving and, based on
    their weaving mechanism, their behavior regarding performance and ease of use
    are different.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Spring AOP和AspectJ都使用不同类型的织入，根据它们的织入机制，它们在性能和易用性方面的行为是不同的。
- en: To perform runtime weaving of our `aspects` during the execution of the application,
    Spring creates proxies of the targeted object using either the JDK dynamic proxy
    or CGLIB proxy, which we discussed earlier.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在应用程序执行期间执行我们的“aspects”的运行时织入，Spring使用JDK动态代理或CGLIB代理创建目标对象的代理，这是我们之前讨论过的。
- en: As opposed to Spring AOP's runtime weaving, AspectJ performs weaving at compile-time
    or classload-time. We already saw different types of AspectJ weaving in the preceding
    section.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 与Spring AOP的运行时织入相反，AspectJ在编译时或类加载时执行织入。我们已经在前面的部分看到了不同类型的AspectJ织入。
- en: Join points
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接点
- en: As Spring AOP creates proxies of target classes or objects to apply crosscutting
    concerns (`Aspects`), it needs to perform subclassing of the targeted class or
    object. As we already know, with subclassing, Spring AOP cannot apply crosscutting
    concerns on classes or methods that are final or static.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Spring AOP创建目标类或对象的代理来应用横切关注点（“Aspects”），它需要对目标类或对象进行子类化。正如我们已经知道的，通过子类化，Spring
    AOP无法在最终或静态的类或方法上应用横切关注点。
- en: On the other hand, AspectJ weaves crosscutting concerns into the actual code
    using byte-code weaving and hence it doesn't need to subclass the targeted class
    or object.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，AspectJ通过字节码织入将横切关注点编织到实际代码中，因此它不需要对目标类或对象进行子类化。
- en: Simplicity
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单性
- en: In Spring AOP, the runtime weaving of `Aspects` will be performed by the container
    at startup and hence it integrates seamlessly with our building process.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring AOP中，“Aspects”的运行时织入将由容器在启动时执行，因此它与我们的构建过程无缝集成。
- en: On the other hand, in AspectJ, we have to perform this using an extra compiler
    (`ajc`) unless we are doing this post-compilation or in LTW. For this reason,
    Spring is simpler and more manageable than AspectJ.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在AspectJ中，除非我们在后期编译或在LTW中执行此操作，否则我们必须使用额外的编译器（`ajc`）。因此，Spring比AspectJ更简单、更易管理。
- en: With Spring AOP, we cannot use or apply the full power of AOP because Spring
    AOP is proxy-based and can only be applied to Spring-managed beans.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring AOP，我们无法使用或应用AOP的全部功能，因为Spring AOP是基于代理的，只能应用于Spring管理的bean。
- en: AspectJ is based on byte-code weaving, meaning it modifies our code and hence
    it enables us to use the full power of AOP on any bean of our application.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: AspectJ基于字节码织入，这意味着它修改了我们的代码，因此它使我们能够在应用程序的任何bean上使用AOP的全部功能。
- en: Performance
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能
- en: From a performance point of view, compile-time weaving would be faster than
    run-time weaving. Spring AOP is a proxy-based framework, so it creates additional
    objects for proxies at runtime and there are more method invocations per `aspect`,
    which affects performance negatively.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 从性能的角度来看，编译时织入比运行时织入更快。Spring AOP是基于代理的框架，因此它在运行时为代理创建额外的对象，并且每个“aspect”有更多的方法调用，这对性能产生负面影响。
- en: On the other hand, AspectJ weaves `aspects` into the main code before the application
    starts and hence there's no additional runtime overhead. There are benchmarks
    available on the internet that say AspectJ is much faster than Spring AOP.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，AspectJ在应用程序启动之前将“aspects”编织到主代码中，因此没有额外的运行时开销。互联网上有可用的基准测试表明，AspectJ比Spring
    AOP快得多。
- en: It is not like one framework is better than another. A choice would be made
    based on the requirements and many different factors, such as overhead, simplicity,
    manageability/maintainability, complexity, and learning curve. If we are using
    fewer `aspects` and there is no need to apply `aspect` apart from a Spring bean
    or method executions, then the performance difference between Spring AOP and AspectJ
    is trivial. We can use AspectJ and Spring AOP together to achieve our requirements
    as well.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是说一个框架比另一个更好。选择将基于需求和许多不同因素，例如开销、简单性、可管理性/可维护性、复杂性和学习曲线。如果我们使用较少的“aspects”，并且除了Spring
    bean或方法执行之外没有应用“aspect”的需求，那么Spring AOP和AspectJ之间的性能差异是微不足道的。我们也可以同时使用AspectJ和Spring
    AOP来实现我们的需求。
- en: AspectJ with Spring
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring中的AspectJ
- en: Spring provides small libraries to enable AspectJ `aspects` into Spring projects.
    This library is named `spring-aspects.jar`. As we know from our earlier discussion,
    Spring allows dependency injection or AOP advice only on Spring bean. With Spring's
    AspectJ support using this small library, we can enable any object created outside
    the container for Spring-driven configuration. Just annotate the outside object
    with `@Configurable`. Annotating a non-Spring bean with `@Configurable` would
    require `AnnotationBeanConfigurerAspect` in `spring-aspects.jar`. The `AnnotationBeanConfigurerAspect`
    configuration needed by Spring can be done by annotating our configuration Java configuration
    class with `@EnableSpringConfigured`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了小型库，以将AspectJ `aspects`集成到Spring项目中。这个库被命名为`spring-aspects.jar`。正如我们从之前的讨论中了解到的，Spring只允许在Spring
    bean上进行依赖注入或AOP建议。使用这个小库的Spring的AspectJ支持，我们可以为Spring驱动的配置启用在容器外创建的任何对象。只需用`@Configurable`注释外部对象。用`@Configurable`注释非Spring
    bean将需要`spring-aspects.jar`中的`AnnotationBeanConfigurerAspect`。Spring需要的`AnnotationBeanConfigurerAspect`配置可以通过用`@EnableSpringConfigured`注释我们的配置Java配置类来完成。
- en: Spring provides a finer way to enable **Load-time weaving** (**LTW**) by enabling
    a per-class loader basis. This gives much more fine-grained control, especially
    when we are deploying large or multiple applications into a single JVM environment.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了一种更精细的方式来启用**加载时织入**（**LTW**），通过启用每个类加载器基础。这在将大型或多个应用程序部署到单个JVM环境时提供了更精细的控制。
- en: 'To use LTW with Spring, we need to implement our `aspect` or advice as we had
    implemented earlier in the *AOP concepts* sections and, as per the AspectJ concepts,
    we need to create `aop.xml` in the `META-INF` folder, as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Spring中使用LTW，我们需要像在*AOP概念*部分中实现的那样实现我们的`aspect`或建议，并且根据AspectJ概念，我们需要在`META-INF`文件夹中创建`aop.xml`，如下所示：
- en: '[PRE30]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The last thing we need to do is annotate our Java-based Spring configuration
    with `@EnableLoadTimeWeaving`. We need to add `-javaagent:path/to/org.springframework.instrument-{version}.jar`
    in our server launch script.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是用`@EnableLoadTimeWeaving`注释我们基于Java的Spring配置。我们需要在服务器启动脚本中添加`-javaagent:path/to/org.springframework.instrument-{version}.jar`。
- en: AOP best programming practices
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AOP最佳编程实践
- en: We have learned about why AOP is needed in our application. We learned about
    its concepts and how to use it in detail. Let's see what best practices should
    be followed when using AOP in our application.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了为什么需要在我们的应用程序中使用AOP。我们详细了解了它的概念以及如何使用它。让我们看看在我们的应用程序中使用AOP时应该遵循哪些最佳实践。
- en: Pointcut expressions
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切入点表达式
- en: 'We learned about pointcut in terms of AOP. Now let''s see what we should take
    care of when using pointcut:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在AOP方面学习了切入点。现在让我们看看在使用切入点时应该注意什么：
- en: Spring with AspectJ processes the pointcuts during compilation and tries to
    match and optimize matching performance. However, examining code and matching
    (statically or dynamically) would be a costly process. So, for optimal performance,
    think twice about what we want to achieve and narrow down our search or matching
    criteria as much as possible.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring与AspectJ在编译期间处理切入点，并尝试匹配和优化匹配性能。然而，检查代码和匹配（静态或动态）将是一个昂贵的过程。因此，为了实现最佳性能，要三思而后行，尽量缩小我们想要实现的搜索或匹配标准。
- en: 'All the designators we learned earlier in this chapter are divided into three
    categories:'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在本章中早些时候学习的所有指示符分为三类：
- en: 'Method signature pattern: `execution`, `get`, `set`, `call`, `handler`'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法签名模式：`execution`，`get`，`set`，`call`，`handler`
- en: 'Type signature pattern: `within`, `withincode`'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型签名模式：`within`，`withincode`
- en: 'Contextual signature pattern: `this`, `target`, `@annotation`'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文签名模式：`this`，`target`，`@annotation`
- en: In order to achieve good performance, write pointcut that includes the method
    at least and type signature pattern. It is not like matching would not work if
    we use only the method or type pattern; however, it is always recommended to join
    the method and type signature together. The type signature is very fast as it
    narrows down the search space by quickly opting out join points that could not
    be further processed.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了实现良好的性能，编写切入点应至少包括方法和类型签名模式。如果只使用方法或类型模式进行匹配，可能不会起作用；然而，始终建议将方法和类型签名结合在一起。类型签名非常快速，通过快速排除无法进一步处理的连接点，缩小了搜索空间。
- en: Declare pointcuts on empty methods and refer to those pointcuts by their empty
    method name (named pointcut), so in case of any change to an expression, we have
    to change only at one place.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在空方法上声明切入点，并通过其空方法名称引用这些切入点（命名切入点），这样在表达式发生任何更改时，我们只需要在一个地方进行更改。
- en: 'It is also recommended to declare small-named pointcuts and combine them by
    name to build complex pointcuts. Referring to pointcuts by name would follow the
    default Java method visibility rules. The following is the code sample of defining
    small pointcuts and joining them:'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建议声明小命名的切入点，并通过名称组合它们来构建复杂的切入点。按名称引用切入点将遵循默认的Java方法可见性规则。以下是定义小切入点并将它们连接的代码示例：
- en: '[PRE31]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Try to create anonymous beans for pointcuts when they are not shared to avoid
    direct access by an application.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量在切入点不共享时为其创建匿名bean，以避免应用程序直接访问。
- en: Try to use static pointcuts where arguments need not be matched. These are faster
    and cached by Spring when the method is invoked first. Dynamic pointcuts are costly
    because they are evaluated on every method invocation because caching cannot be
    done as the argument would differ.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量使用静态切入点，其中不需要匹配参数。这些更快，并且在首次调用方法时由Spring缓存。动态切入点成本高，因为它们在每次方法调用时进行评估，因为无法进行缓存，参数会有所不同。
- en: Advice ordering
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建议顺序
- en: 'Now we know how to write advice and how to create `Aspect`. Let''s see how
    advice ordering can help us to prioritize our advice when we have multiple advice
    on the same join point:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何编写建议以及如何创建`Aspect`。让我们看看建议顺序如何帮助我们在同一连接点上有多个建议时优先考虑我们的建议：
- en: Let's say we wrote two before or after advice in different aspects and both
    want to run at the same join point. In this case, the order of execution of the
    advice would be based on the which aspect comes first in the execution of classes.
    To avoid this and apply our advice one after the other, Spring provides a way
    to specify the order of execution by either implementing the `Ordered` interface
    by an aspect or applying the `@Order` annotation. The lower the value of the order,
    the higher the precedence.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我们在不同的aspects中编写了两个before或after advice，并且两者都希望在相同的连接点运行。在这种情况下，advice的执行顺序将基于在类执行中哪个aspect先出现。为了避免这种情况并依次应用我们的advice，Spring提供了一种方法来指定执行顺序，即通过一个aspect实现`Ordered`接口或应用`@Order`注解。顺序的值越低，优先级越高。
- en: While declaring an advice, always use the least powerful form of advice; for
    example, if a simple before advice would achieve our requirement, we should not
    use the around advice.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在声明advice时，始终使用最不强大的advice形式；例如，如果一个简单的before advice可以实现我们的要求，我们就不应该使用around
    advice。
- en: Best practices of AOP proxies
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AOP代理的最佳实践
- en: 'We learned about AOP proxies and how AOP proxies work. We learned about different
    types of proxies in Spring AOP. The following are best practices to be followed
    while implementing AOP proxies in Spring:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了AOP代理以及AOP代理的工作原理。我们了解了Spring AOP中不同类型的代理。在实现Spring中的AOP代理时，应遵循以下最佳实践：
- en: Unless we need to perform a manipulative action at runtime or we want to gain
    fine-grained control of our proxies, use the declarative method of proxy configuration
    over the programmatic method.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非我们需要在运行时执行操作或者想要对代理进行细粒度控制，否则使用声明式代理配置而不是编程方法。
- en: Spring recommends JDK dynamic proxy over the CGLIB proxy wherever possible.
    If we are building our application from scratch and there is no requirement to
    create proxies of third-party APIs, implement the abstraction layer to loosely-couple
    the implementation using the interface and let Spring use the JDK dynamic proxy
    mechanism to create proxies.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring在可能的情况下建议使用JDK动态代理而不是CGLIB代理。如果我们从头开始构建我们的应用程序，并且没有要创建第三方API的代理的要求，实现抽象层以松散耦合实现，使用接口并让Spring使用JDK动态代理机制来创建代理。
- en: In case of CGLIB proxies, make sure the methods are not `final`, as `final`
    methods cannot be overridden and hence they cannot be advised.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CGLIB代理的情况下，确保方法不是`final`，因为`final`方法无法被覆盖，因此也无法被advised。
- en: 'According to Spring, it is not possible to have `aspects` themselves be the
    target of advice from other `aspects`. There are workarounds for this situation;
    move the `aspect` method to a  new Spring bean annotated with `@Component`, `@Autowire`
    this new Spring bean to `aspect`, and just call the advised method. `MethodProfilingAspect`
    is `aspect` defining a pointcut on all join points under `com.packt.springhighperformance.ch3.bankingapp`:'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据Spring的说法，`aspects`本身不可能成为其他`aspects`的advice目标。对于这种情况有解决方法；将`aspect`方法移动到一个新的Spring
    bean上，并用`@Component`进行注释，将这个新的Spring bean自动装配到`aspect`，然后调用被advised的方法。`MethodProfilingAspect`是在`com.packt.springhighperformance.ch3.bankingapp`下定义一个切入点的`aspect`：
- en: '[PRE32]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following `ValidatingAspect` is `aspect` defined under the `com.packt.springhighperformance.ch3.bankapp`
    package, however a call to the `validate` method would not be advised by `MethodProfilingAspect`:'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下的`ValidatingAspect`是在`com.packt.springhighperformance.ch3.bankapp`包下定义的`aspect`，但是`MethodProfilingAspect`不建议调用`validate`方法：
- en: '[PRE33]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following is the solution by creating a separate class with the `@Component`
    annotation and implementing the `validate` method. This class will be a Spring-managed
    bean and it will be advised:'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过创建一个带有`@Component`注解的单独类并实现`validate`方法来解决这个问题。这个类将是一个Spring管理的bean，并且会被advised：
- en: '[PRE34]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following code of `ValidatingAspect` injects the `ValidateDefault` Spring
    bean and calls the `validate` method:'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下的`ValidatingAspect`代码注入了`ValidateDefault` Spring bean并调用了`validate`方法：
- en: '[PRE35]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Never implement fine-grained requirements through AOP or use AspectJ for such
    requirements. Do not use `@Configurable` on Spring-managed bean classes, otherwise
    it would do double initialization, once through the container and once through
    the aspect.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要通过AOP实现细粒度的要求，也不要对Spring管理的bean类使用`@Configurable`，否则会导致双重初始化，一次是通过容器，一次是通过aspect。
- en: Caching
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存
- en: 'We have seen how to improve our application''s performance with the use of
    caching. The following are the best practices to be followed when implementing
    caching in Spring:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何通过缓存来提高应用程序的性能。在Spring中实现缓存时应遵循以下最佳实践：
- en: Spring cache annotations should be used on concrete classes and not on interfaces.
    If we choose to use `proxy-target-class="true"`, caching will not work because
    the Java annotation from the interfaces cannot be inherited.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring缓存注解应该用在具体类上，而不是接口上。如果选择使用`proxy-target-class="true"`，缓存将不起作用，因为接口的Java注解无法继承。
- en: Try not use `@Cacheable` and `@CachePut` together on the same method.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量不要在同一个方法上同时使用`@Cacheable`和`@CachePut`。
- en: Do not cache very low-level methods close, such as CPU-intensive and in-memory
    computations. Spring's caching might be overkill in those scenarios.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要缓存非常低级的方法，比如CPU密集型和内存计算。在这些情况下，Spring的缓存可能过度。
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at the Spring AOP module. AOP is a powerful programming
    paradigm that complements object-oriented programming. AOP helps to decouple crosscutting
    concerns from business logic and helps us to focus only on business logic when
    working on business requirements. Decoupled crosscutting concerns help to implement
    the reusable code.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了Spring AOP模块。AOP是一种强大的编程范式，它补充了面向对象编程。AOP帮助我们将横切关注点与业务逻辑解耦，并在处理业务需求时只关注业务逻辑。解耦的横切关注点有助于实现可重用的代码。
- en: We learned about AOP concepts, its terminologies, and how to implement advice.
    We learned about proxies and how Spring AOP is implemented using the proxy pattern.
    We learned best practices to be followed while working on Spring AOP to achieve
    better quality and performance.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了AOP的概念、术语以及如何实现建议。我们了解了代理和Spring AOP如何使用代理模式实现。我们学习了在使用Spring AOP时应遵循的最佳实践，以实现更好的质量和性能。
- en: In the next chapter, we will learn about Spring MVC. Spring Web MVC provides
    a web framework that is based on MVC. Using Spring Web MVC as a web framework
    enables us to develop loosely-coupled web applications with the benefit of writing
    test cases without using request and response objects. We will see how can we
    optimize the Spring MVC implementation to achieve better results using async method
    features, multithreading, and authentication caching.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于Spring MVC。Spring Web MVC提供了一个基于MVC的Web框架。使用Spring Web MVC作为Web框架使我们能够开发松耦合的Web应用程序，并且可以编写测试用例而不使用请求和响应对象。我们将看到如何优化Spring
    MVC实现，以利用异步方法特性、多线程和身份验证缓存来实现更好的结果。
