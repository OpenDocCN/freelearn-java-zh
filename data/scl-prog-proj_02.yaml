- en: Developing a Retirement Calculator
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发退休计算器
- en: In this chapter, we will put into practice the features of the Scala language
    seen in the first chapter. We will also introduce other elements of the Scala
    language and SDK to develop the model and logic for a retirement calculator. This
    calculator will help people work out how long and how much to save to have a comfortable
    retirement.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将将第一章节中看到的 Scala 语言特性付诸实践。我们还将介绍 Scala 语言和 SDK 的其他元素，以开发退休计算器的模型和逻辑。这个计算器将帮助人们计算出需要存多少钱以及存多久才能有一个舒适的退休生活。
- en: We will use the **test-driven development** (**TDD**) technique to develop the
    different functions. I encourage you to try writing the body of the functions
    yourself before looking at the solution. Also, it would be better to retype the
    code rather than copy/pasting it. You will remember it more and will have a sense
    of what it feels like to use IntelliJ's completion and editor. Do abuse the autocompletion
    with *Ctrl* + spacebar. You will not only type faster, but you will also discover
    what functions are available in a given class.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**测试驱动开发**（**TDD**）技术来开发不同的功能。我鼓励你在查看解决方案之前先尝试自己编写函数的主体。此外，最好是重新输入代码而不是复制粘贴。这样你会记得更牢，并且会有一种使用
    IntelliJ 的自动完成和编辑器的感受。不要过度使用*Ctrl* + 空格键的自动完成功能。你不仅会打字更快，还会发现给定类中可用的函数。
- en: You are going to get a strong foundation for building more complex applications
    using the Scala language.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你将获得使用 Scala 语言构建更复杂应用程序的坚实基础。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Calculating the future capital
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算未来资本
- en: Calculating when you can retire
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算何时可以退休
- en: Using market rates
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用市场汇率
- en: Packaging the application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包应用程序
- en: Project overview
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: 'Using some parameters such as your net income, your expenses, your initial
    capital, and so on, we will create functions to calculate the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一些参数，例如你的净收入、你的开支、你的初始资本等，我们将创建函数来计算以下内容：
- en: Your future capital at retirement
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退休时的未来资本
- en: Your capital after a number of years in retirement
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退休多年后的资本
- en: How long you need to save to be able to retire
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要存多少钱才能退休
- en: We will first use a fixed interest rate for these calculations. After that,
    we will load market data from `.tsv` files, then refactor the previous functions
    to simulate what could happen during the investment period.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用固定利率进行这些计算。之后，我们将从 `.tsv` 文件中加载市场数据，然后重构之前的函数以模拟投资期间可能发生的情况。
- en: Calculating the future capital
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算未来资本
- en: The first thing you need to know when planning for retirement is how much capital
    you can get at your chosen retirement date. For now, we will assume that you invest
    your savings every month at a constant rate. To simplify things, we will ignore
    the effects of inflation, hence the capital calculated will be in today's money
    and the interest rate will be calculated as* real rate* = *nominal interest rate*
    - *inflation rate*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在规划退休时，你需要知道的第一件事是在你选择的退休日期可以获得的资本量。现在，我们将假设你以恒定的速率每月投资你的储蓄。为了简化问题，我们将忽略通货膨胀的影响，因此计算出的资本将是今天的货币，利率将计算为*实际利率*
    = *名义利率* - *通货膨胀率*。
- en: We intentionally do not mention any currency in the rest of this chapter. You
    can consider that the amounts are in USD, EUR, or any other currency. It will
    not change the results as long as all the amounts are expressed in the same currency.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意在本章的其余部分不提及任何货币。你可以认为金额是以美元（USD）、欧元（EUR）或任何其他货币计算的。只要所有金额都使用相同的货币表示，结果就不会改变。
- en: Writing a unit test for the accumulation phase
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写积累阶段的单元测试
- en: 'We want a function that behaves similarly to the `FV` function in Excel: it
    calculates the future value of an investment based on a constant interest rate.
    As we follow a TDD approach, the first thing to do is create a failing test:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个与 Excel 中的 `FV` 函数行为相似的函数：它根据恒定的利率计算投资的未来价值。由于我们遵循 TDD 方法，首先要做的事情是创建一个失败的测试：
- en: Create a new Scala project called `retirement_calculator`. Follow the same instructions
    as in [Chapter 1](db4d7854-92ff-43c8-a87b-2d605bf88d1b.xhtml), *Writing Your First
    Program*.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `retirement_calculator` 的新 Scala 项目。遵循[第 1 章](db4d7854-92ff-43c8-a87b-2d605bf88d1b.xhtml)中“编写你的第一个程序”的相同说明。
- en: Right-click on the directory `src/main/scala` and select New | Package. Name
    it `retcalc`.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 `src/main/scala` 目录并选择 New | Package。将其命名为 `retcalc`。
- en: Right-click on the new package and select New | Scala class. Name it `RetCalcSpec`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击新包，选择New | Scala class。将其命名为`RetCalcSpec`。
- en: 'Enter the following code:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下代码：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As seen in [Chapter 1](db4d7854-92ff-43c8-a87b-2d605bf88d1b.xhtml), *Writing
    Your First Program*, in the section *Creating my first project*, we used the `WordSpec`
    ScalaTest style. We also used a handy feature called `TypeCheckedTripleEquals`.
    It provides a powerful assertion, `should ===`, that ensures at compile time that
    both sides of the equality have the same type. The default ScalaTest assertion
    `should` verifies the type equality at runtime. We encourage you to always use
    `should ===`, as it will save a lot of time when refactoring code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第1章](db4d7854-92ff-43c8-a87b-2d605bf88d1b.xhtml)中所述，在*创建我的第一个项目*部分，我们使用了`WordSpec`
    ScalaTest风格。我们还使用了一个方便的功能，称为`TypeCheckedTripleEquals`。它提供了一个强大的断言`should ===`，确保在编译时等式的两边具有相同的类型。默认的ScalaTest断言`should`在运行时验证类型相等性。我们鼓励您始终使用`should
    ===`，因为它在重构代码时可以节省大量时间。
- en: 'Besides, it lets us use a certain amount of tolerance when comparing double
    values. Consider the following declaration:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它让我们在比较双精度值时可以使用一定程度的容差。考虑以下声明：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It will let a `double1 should === (double2)` assertion pass if the absolute
    difference between `double1` and `double2` is lower than `0.0001`. This allows
    us to specify expected values to only the fourth digit after the decimal point.
    It also avoids hitting floating point calculation issues. For instance, enter
    the following code in the Scala Console:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`double1`和`double2`之间的绝对差异小于`0.0001`，它将允许`double1 should === (double2)`断言通过。这允许我们只指定小数点后第四位的预期值。它还避免了遇到浮点计算问题。例如，在Scala控制台中输入以下代码：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It can be a bit surprising, but this is a well-known problem in any language
    that encodes floating point numbers in binary. We could have used `BigDecimal`
    instead of `Double` to avoid this kind of issue, but for our purposes, we do not
    need the additional precision offered by `BigDecimal`, and `BigDecimal` computations
    are much slower.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能有点令人惊讶，但这在任何将浮点数编码为二进制的语言中都是一个众所周知的问题。我们本可以使用`BigDecimal`而不是`Double`来避免这类问题，但就我们的目的而言，我们不需要`BigDecimal`提供的额外精度，而且`BigDecimal`的计算速度要慢得多。
- en: The body of the test is quite straightforward; we call a function and expect
    a value. As we wrote the test first, we had to work out what would be the expected
    result before writing the production code. For non-trivial calculations, I generally
    use Excel or LibreOffice. For this function, the expected value can be obtained
    by using the formula `=-FV(0.04/12,25*12,1000,10000,0)`. We assume that the user
    saves the full difference between his or her income and his/her expenses every
    month. Hence, the PMT parameter in the `FV` function is `1,000 = netIncome - currentExpenses`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的主体相当直接；我们调用一个函数并期望得到一个值。由于我们首先编写了测试，我们必须在编写生产代码之前确定预期的结果。对于非平凡的计算，我通常使用Excel或LibreOffice。对于这个函数，预期的值可以通过使用公式`=-FV(0.04/12,25*12,1000,10000,0)`获得。我们假设用户每月将其收入与支出的全部差额存入。因此，`FV`函数中的PMT参数是`1,000
    = netIncome - currentExpenses`。
- en: 'We now have a failing test, but it does not compile, as the `RetCalc` object
    and its `futureCapital` function do not exist yet. Create a `RetCalc` object in
    a new package `retcalc` in `src/main/scala`, then select the red `futureCapital`
    call in the unit test and hit *Alt* + *Enter* to generate the function body. Fill
    in the names and types of the parameters. You should end up with the following
    code in `RetCalc.scala`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个失败的测试，但它无法编译，因为`RetCalc`对象及其`futureCapital`函数尚不存在。在`src/main/scala`中的新包`retcalc`中创建一个`RetCalc`对象，然后在单元测试中选择红色的`futureCapital`调用，按*Alt*
    + *Enter*生成函数体。填写参数的名称和类型。你应该在`RetCalc.scala`中得到以下代码：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Open `RetCalcSpec`, and type *Ctrl* + *Shift* + *R* to compile and run it. Everything
    should compile and the test should fail.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`RetCalcSpec`，按*Ctrl* + *Shift* + *R*来编译和运行它。一切都应该编译，测试应该失败。
- en: Implementing futureCapital
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现未来资本
- en: 'We now have a failing test, so it is time to make it pass by writing the production
    code. If we use `initialCapital = 10,000` and `monthlySavings = 1,000`, the computation
    we need to perform can be decomposed as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个失败的测试，所以是时候通过编写生产代码让它通过了。如果我们使用`initialCapital = 10,000`和`monthlySavings
    = 1,000`，我们需要执行的计算可以分解如下：
- en: For month `0`, before any savings, we have `capital0 = initialCapital = 10,000`.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第`0`个月，在没有任何储蓄之前，我们有`capital0 = initialCapital = 10,000`。
- en: For month `1`, our initial capital generated some interest. We also saved 1,000
    more. We therefore have `capital1 = capital0 *(1 + monthlyInterestRate) + 1,000`
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第一个月，我们的初始资本产生了一些利息。我们还额外存入了1,000元。因此，我们有 `capital1 = capital0 *(1 + monthlyInterestRate)
    + 1,000`
- en: For month `2`, we have `capital2 = capital1 *(1 + monthlyInterestRate) + 1,000`
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第二个月，我们有 `capital2 = capital1 *(1 + monthlyInterestRate) + 1,000`
- en: There is a mathematical formula to compute `capitalN` from the parameters, but
    we will not use it here. This formula works well for fixed interest rates, but
    we will use variable interest rates later in this chapter.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一种数学公式可以从参数计算 `capitalN`，但在这里我们不会使用它。这个公式在固定利率下工作得很好，但我们在本章后面将使用可变利率。
- en: 'Here is the body of the function:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是函数的主体：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We first generate a collection of integers using `0 to nbOfMonths`, and we then
    iterate through it using `foldLeft`. `foldLeft` is one of the most powerful functions
    in the Scala collection library. Many other functions in the `collections` library
    could be implemented just by using `foldLeft`, such as `reverse`, `last`, `contains`,
    `sum`, and so on.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用 `0 to nbOfMonths` 生成一个整数集合，然后使用 `foldLeft` 遍历它。`foldLeft` 是 Scala 集合库中最强大的函数之一。`collections`
    库中的许多其他函数可以通过使用 `foldLeft` 来实现，例如 `reverse`、`last`、`contains`、`sum` 等。
- en: 'In the Scala SDK, the signature of `foldLeft` is as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala SDK 中，`foldLeft` 的签名如下：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can see its definition in IntelliJ by pointing at it with the mouse and
    using cmd + left-click. This introduces some new syntax:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将鼠标悬停在 IntelliJ 中的定义上并使用 cmd + left-click 来查看其定义。这引入了一些新的语法：
- en: '`[B]` means that the function has a **type parameter** named `B`. When we call
    the function, the compiler automatically infers what `B` is, depending on the
    type of the `z: B` argument. In our code, the `z` argument is `initialCapital`,
    of type `Double`. Therefore, our call to `foldLeft` in `futureCapital` will behave
    as if the function was defined with `B = Double`:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[B]` 表示该函数有一个名为 `B` 的 **类型参数**。当我们调用函数时，编译器会根据 `z: B` 参数的类型自动推断 `B` 是什么。在我们的代码中，`z`
    参数是 `initialCapital`，类型为 `Double`。因此，我们在 `futureCapital` 中对 `foldLeft` 的调用将表现得好像函数是用
    `B = Double` 定义的：'
- en: '`def foldLeft(z: Double)(op: (Double, A) => Double): Double`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`def foldLeft(z: Double)(op: (Double, A) => Double): Double`.'
- en: The function has two parameter lists. Scala allows you to have many parameter
    lists. Each list can have one or many parameters. This does not change the behavior
    of the function; it is just a way of separating the concerns of each parameter
    list.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该函数有两个参数列表。Scala 允许你拥有多个参数列表。每个列表可以有一个或多个参数。这不会改变函数的行为；这只是分离每个参数列表关注点的一种方式。
- en: '`op: (B, A) => B` means that `op` must be a function that has two parameters
    of type `B` and `A` and returns a value of type `B`. Since `foldLeft` is a function
    that takes another function as an argument, we say that `foldLeft` is a **higher
    order function**.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`op: (B, A) => B` 表示 `op` 必须是一个有两个参数类型为 `B` 和 `A` 并返回类型为 `B` 的函数。由于 `foldLeft`
    是一个接受另一个函数作为参数的函数，我们说 `foldLeft` 是一个 **高阶函数**。'
- en: 'If we consider a `coll` collection, `foldLeft` works as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑一个 `coll` 集合，`foldLeft` 的工作方式如下：
- en: 'It creates a `var acc = z` accumulator then calls the `op` function:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它创建一个 `var acc = z` 累加器，然后调用 `op` 函数：
- en: '`acc = op(acc, coll(0))`'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`acc = op(acc, coll(0))`'
- en: 'It carries on calling `op` with each element of the collection:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它继续对集合的每个元素调用 `op`。
- en: '`acc = op(acc, coll(i))`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`acc = op(acc, coll(i))`'
- en: It returns `acc` once it has iterated through all elements of the collection
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它在遍历完集合的所有元素后返回 `acc`。
- en: In our `futureCapital` function, we pass `op = nextCapital`. The `foldLeft`
    will iterate through all `Int` between `1` and `nbOfMonths`, each time computing
    the capital using the previous capital. Note that, for now, we do not use the
    `month` parameter in `nextCapital`. We must declare it, though, because the `op` function
    in `foldLeft` must have two parameters.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `futureCapital` 函数中，我们传递 `op = nextCapital`。`foldLeft` 将遍历从 `1` 到 `nbOfMonths`
    的所有 `Int`，每次使用前一个资本计算资本。注意，目前我们不在 `nextCapital` 中使用 `month` 参数。尽管如此，我们必须声明它，因为
    `foldLeft` 中的 `op` 函数必须有两个参数。
- en: You can now run the `RetCalcSpec` unit test again. It should pass.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以再次运行 `RetCalcSpec` 单元测试。它应该通过。
- en: Refactoring the production code
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构生产代码
- en: In the TDD approach, it is common to refactor the code once we have passing
    tests. If our test coverage is good, we should not have any fear of changing the
    code, because any mishap should be flagged by a failing test. This is known as
    a **Red-Green-Refactor** cycle.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在TDD方法中，一旦我们有了通过测试的代码，重构代码是很常见的。如果我们的测试覆盖率良好，我们不应该害怕更改代码，因为任何错误都应该由失败的测试标记出来。这被称为**红-绿-重构**循环。
- en: 'Change the body of `futureCapital` with the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码更改`futureCapital`的主体：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we have inlined the `nextCapital` function in the `foldLeft` call. In
    Scala, we can define an **anonymous function** using the syntax:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在`foldLeft`调用中内联了`nextCapital`函数。在Scala中，我们可以使用以下语法定义一个**匿名函数**：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We saw earlier that the `month` parameter in `nextCapital` was not used. In
    an anonymous function, it is a good practice to name any unused parameter with
    `_`. A parameter named `_` cannot be used in the function body. If you try to
    replace the `_` character with a name, IntelliJ will underline it. If you hover
    the mouse over it, you will see a popup stating `Declaration is never used`. You
    can then hit *Alt* + *Enter* and choose to remove the unused element to automatically
    change it back to `_`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到，`nextCapital`中的`month`参数没有被使用。在匿名函数中，将任何未使用的参数命名为`_`是一个好的实践。名为`_`的参数不能在函数体中使用。如果你尝试将`_`字符替换为其他名称，IntelliJ会将其下划线。如果你将鼠标悬停在其上，你会看到一个弹出窗口，显示“声明从未使用”。然后你可以按*Alt*
    + *Enter*键并选择删除未使用的元素，以自动将其更改回`_`。
- en: Writing a test for the decumulation phase
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写减值阶段的测试
- en: Now you know how much capital you can expect at your retirement date. It turns
    out you can reuse the same `futureCapital` function, to work out how much capital
    will be left for your heirs.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道你退休时可以期待多少资本。结果是你可以重用相同的`futureCapital`函数，来计算为你继承人留下的资本。
- en: 'Add the following test in `RetCalcSpec`, underneath the previous unit test,
    and run it. It should pass:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RetCalcSpec`中添加以下测试，在之前的单元测试下方，并运行它。它应该通过：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So, if you live for 40 years after your retirement date, spend the same amount
    every month, and don't have any other income, you will still have a significant
    capital left for your heirs. If the remaining capital was negative, that would
    have meant that you would have run out of money at some point during your retirement
    and it is an outcome we want to avoid.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你在退休后活40年，每个月支出相同的金额，并且没有其他收入，你仍然会为你的继承人留下相当可观的资本。如果剩余的资本为负，这意味着你在退休期间某个时候可能会用完钱，这是我们想要避免的结果。
- en: Feel free to call the function from the Scala Console and try different values
    that would match more closely to your personal situation. Try different values
    for the interest rate and observe how you can end up with a negative capital if
    the rate is low.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随意从Scala控制台调用该函数并尝试更接近你个人情况的值。尝试不同的利率值，观察如果利率低，你最终可能会得到负资本。
- en: Note that, in a production system, you would certainly add more unit tests to
    cover some other edge cases and make sure that the function will not crash. As
    we will cover error handling in [Chapter 3](f7fa24eb-8f31-4201-ba7c-c1e32518df8b.xhtml), *Handling
    Errors*, we can assume that the test coverage of `futureCapital` is good enough
    for now.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在生产系统中，你肯定会添加更多的单元测试来覆盖一些其他边缘情况，并确保函数不会崩溃。由于我们将在[第3章](f7fa24eb-8f31-4201-ba7c-c1e32518df8b.xhtml)“处理错误”中介绍错误处理，我们可以假设`futureCapital`的测试覆盖率现在已经足够好了。
- en: Simulating a retirement plan
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟退休计划
- en: Now that we know how to calculate the capital at retirement and after death,
    it would be useful to combine the two calls in a single function. This function
    will simulate a retirement plan in one go.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何计算退休和死亡时的资本，将这两个调用合并到一个函数中会很有用。这个函数将一次性模拟退休计划。
- en: Writing a failing unit test
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写失败的单元测试
- en: 'Here is the unit test you need to add to `RetCalcSpec`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是你需要添加到`RetCalcSpec`中的单元测试：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Select the call to `simulatePlan`, and hit *Alt* + *Enter* to let IntelliJ
    create the function for you in `RetCalc`. It should have the following signature:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 选择调用`simulatePlan`，然后按*Alt* + *Enter*键让IntelliJ在`RetCalc`中为你创建函数。它应该具有以下签名：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now compile the project with cmd + *F9*, and run `RetCalcSpec`. It should fail
    since the `simulatePlan` function must return two values. The simplest way of
    modeling the return type is to use `Tuple2`. In Scala, a tuple is an immutable
    data structure which holds several objects of different types. The number of objects
    contained in a tuple is fixed. It is akin to a case class, which does not have
    specific names for its attributes. In type theory, we say that a tuple or a case
    class is a **product type**.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用 cmd + *F9* 编译项目，并运行 `RetCalcSpec`。它应该会失败，因为 `simulatePlan` 函数必须返回两个值。最简单的建模返回类型的方法是使用
    `Tuple2`。在 Scala 中，元组是一个不可变的数据结构，可以包含不同类型的多个对象。元组中包含的对象数量是固定的。它与没有特定属性名称的案例类类似。在类型理论中，我们说元组或案例类是
    **积类型**。
- en: Working with tuples
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作元组
- en: 'Type the following in the Scala Console to get more familiar with tuples. Feel
    free to experiment with different types and sizes of tuples:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 控制台中输入以下内容，以熟悉元组。你可以自由地尝试不同类型和大小的元组：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can create tuples of any length up to 22, and access their elements using
    `_1`, `_2`, and so on. You can also declare several variables in one go for each
    element of the tuple.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建长度最多为 22 的元组，并使用 `_1`、`_2` 等来访问它们的元素。你还可以一次性为元组的每个元素声明多个变量。
- en: Implementing simulatePlan
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 `simulatePlan`
- en: 'The implementation for `simulatePlan` is straightforward; we call `futureCapital`
    twice with different arguments:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`simulatePlan` 的实现方法很简单；我们用不同的参数两次调用 `futureCapital`：'
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Run `RetCalcSpec` again, and it should pass now. Feel free to experiment calling
    `simulatePlan` from the Scala Console with different values.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行 `RetCalcSpec`，这次应该能通过了。你可以随意在 Scala 控制台中用不同的值调用 `simulatePlan` 进行实验。
- en: Calculating when you can retire
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算何时可以退休
- en: If you have tried to call `simulatePlan` from the Scala Console, you probably
    tried different values for `nbOfMonths` and observed the resulting capital at
    retirement and after death. It would be useful to have a function that finds the
    optimal `nbOfMonths` so that you have enough capital to never run out of money
    during your retirement.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试从 Scala 控制台调用 `simulatePlan`，你可能尝试了不同的 `nbOfMonths` 值，并观察了退休和去世后的资本结果。有一个函数可以找到最佳的
    `nbOfMonths`，这样你就有足够的资本在退休期间永远不会耗尽。
- en: Writing a failing test for nbOfMonthsSaving
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写针对 `nbOfMonthsSaving` 的失败测试
- en: 'As usual, let''s start with a new unit test to clarify what we expect from
    this function:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，让我们从一个新的单元测试开始，以明确我们从这个函数期望什么：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this test, the expected value can be a bit difficult to figure out. One way
    would be to use the `NPM` function in Excel. Alternatively, you could call `simulatePlan`
    many times in the Scala Console, and increase `nbOfMonthsSaving` to gradually
    find out what the optimal value is.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，预期的值可能有点难以确定。一种方法是在 Excel 中使用 `NPM` 函数。或者，你可以在 Scala 控制台中多次调用 `simulatePlan`，并逐渐增加
    `nbOfMonthsSaving` 以找到最佳值。
- en: Writing the function body
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写函数体
- en: 'In functional programming, we avoid mutating variables. In an imperative language,
    you would typically implement `nbOfMonthsSaving` by using a `while` loop. It is
    also possible to do so in Scala, but it is a better practice to only use immutable
    variables. One way of solving this problem is to use recursion:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，我们避免修改变量。在命令式语言中，你通常会通过使用 `while` 循环来实现 `nbOfMonthsSaving`。在 Scala 中也可以这样做，但更好的做法是只使用不可变变量。解决这个问题的方法之一是使用递归：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We declare the recursive function inside the body of the function, as it is
    not meant to be used anywhere else. The `loop` function increments `months` by
    `1` until the calculated `capitalAfterDeath` is positive. The `loop` function
    is initiated in the body of `nbMonthsSaving` with `months = 0`. Note that IntelliJ
    highlights the fact that the `loop` function is recursive with a kind of `@` sign.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在函数体内声明递归函数，因为它不打算在其他任何地方使用。`loop` 函数通过将 `months` 增加 `1` 直到计算出的 `capitalAfterDeath`
    为正来递增 `months`。`loop` 函数在 `nbMonthsSaving` 的函数体内以 `months = 0` 初始化。请注意，IntelliJ
    使用一种 `@` 符号突出显示 `loop` 函数是递归的。
- en: Now, we can run our unit test again, and it should pass. However, we are not
    quite done yet. What happens if you can never reach a month that would satisfy
    the condition `capitalAfterDeath > 0.0`? Let's find out by writing another test.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以再次运行我们的单元测试，它应该会通过。然而，我们还没有完成。如果你永远无法达到满足条件 `capitalAfterDeath > 0.0`
    的月份，会发生什么？让我们通过编写另一个测试来找出答案。
- en: Understanding tail-recursion
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解尾递归
- en: 'Add the following tests underneath the previous one:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个测试下面添加以下测试：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We will implement the `not loop forever` later on. It is a good practice to
    write pending tests as soon as you think about new edge cases or other use cases
    for your function. It helps to keep a direction toward the end goal, and gives
    some momentum—as soon as you have made the previous test pass, you know exactly
    what test you need to write next.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后实现`not loop forever`。编写悬而未决的测试是一个好习惯，当你想到你函数的新边缘情况或其他用例时立即编写。这有助于保持对最终目标的指向，并提供一些动力——一旦你通过了之前的测试，你就知道接下来需要编写什么测试。
- en: Run the test, and it will fail with `StackOverflowError`. This is because each
    time `loop` is called recursively, local variables are saved onto the JVM stack.
    The size of the stack is quite small, and as we can see, it is quite easy to fill
    it up. Fortunately, there is a mechanism in the Scala compiler to automatically
    transform tail-recursive calls into a `while` loop. We say that a recursive call
    (the call to the `loop` function inside the `loop` function) is tail-recursive
    when it is the last instruction of the function.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试，它将因`StackOverflowError`而失败。这是因为每次`loop`递归调用时，局部变量都会保存到JVM堆栈上。堆栈的大小相当小，正如我们所看到的，它很容易被填满。幸运的是，Scala编译器中有一个机制可以自动将尾递归调用转换为`while`循环。我们说递归调用（`loop`函数内部的`loop`函数调用）是尾递归的，当它是函数的最后一个指令时。
- en: 'We can easily change our previous code to make it tail-recursive. Select `returnValue`,
    and hit cmd + *O* to inline the variable. The body of the `loop` function should
    look like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地将之前的代码更改为使其成为尾递归。选择`returnValue`，然后按cmd + *O*将变量内联。`loop`函数的主体应该看起来像这样：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: IntelliJ changed the small symbol in the editor's margin to highlight the fact
    that our function is now tail-recursive. Run the test again and it should pass.
    It is a good practice to also put an annotation `@tailrec` before the function
    definition. This tells the compiler that it must verify that the function is indeed
    tail-recursive. If you annotate a `@tailrec` function that is not tail-recursive,
    the compiler will raise an error.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliJ将编辑器边缘的小符号更改为突出显示我们的函数现在是尾递归。再次运行测试，它应该通过。在函数定义之前也放置一个注释`@tailrec`是一个好习惯。这告诉编译器它必须验证函数确实是尾递归。如果你注释了一个不是尾递归的`@tailrec`函数，编译器将引发错误。
- en: When you know that the depth of a recursive call can be high (more than 100),
    always make sure it is tail-recursive.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当你知道递归调用的深度可以很高（超过100）时，始终确保它是尾递归。
- en: When you write a tail-recursive function, always annotate it with `@tailrec`
    to let the compiler verify it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写尾递归函数时，始终使用`@tailrec`进行注释，以便让编译器验证它。
- en: Ensuring termination
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保终止
- en: 'We are not quite done yet because our function might loop indefinitely. Imagine
    that you always spend more than what you earn. You will never be able to save
    enough to retire, even if you live a million years! Here is a unit test highlighting
    this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成，因为我们的函数可能会无限循环。想象一下，你总是花费比你赚的更多的钱。即使你活上一百万年，你也永远无法存足够的钱来退休！以下是一个突出显示这一点的单元测试：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We decided to use a special value `Int.MaxValue` to indicate that `nbOfMonths`
    is infinite. This is not very pretty, but we will see in the next chapter how
    we can model this better with `Option` or `Either`. This is good enough for now.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定使用一个特殊的值`Int.MaxValue`来表示`nbOfMonths`是无限的。这看起来并不美观，但我们在下一章中将会看到如何使用`Option`或`Either`来更好地建模这一点。现在这已经足够好了。
- en: 'To make the test pass, we just need to add an `if` statement:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使测试通过，我们只需要添加一个`if`语句：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Using market rates
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用市场利率
- en: In our calculations, we have always assumed that the interest rate of return
    was constant, but the reality is more complex. It would be more accurate to use
    real rates from market data to gain more confidence with our retirement plan.
    For this, we first need to change our code to be able to perform the same calculations
    using variable interest rates. Then, we will load real market data to simulate
    regular investments in a fund by tracking the S & P 500 index.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的计算中，我们一直假设回报利率是恒定的，但现实情况更为复杂。使用市场数据中的实际利率来获得对我们退休计划的更多信心会更准确。为此，我们首先需要更改我们的代码，以便能够使用可变利率执行相同的计算。然后，我们将加载真实的市场数据，通过跟踪标准普尔500指数来模拟基金的定期投资。
- en: Defining an algebraic data type
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义代数数据类型
- en: 'In order to support variable rates, we need to change the signature of all
    functions that accept `interestRate: Double`. Instead of a double, we need a type
    that can represent either a constant rate or a sequence of rates.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '为了支持可变利率，我们需要更改接受`interestRate: Double`的所有函数的签名。我们需要一个可以表示恒定利率或一系列利率的类型，而不是一个双精度浮点数。'
- en: 'Considering two types `A` and `B`, we previously saw how to define a type that
    can hold a value of type `A` and a value of type `B`. This is a product type,
    and we can define it using a tuple, such as `ab: (A, B)`, or a case class, such
    as `case class MyProduct(a: A, b: B)`.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '考虑两种类型`A`和`B`，我们之前看到了如何定义一个可以持有类型`A`和类型`B`的值的类型。这是一个产品类型，我们可以使用元组，例如`ab: (A,
    B)`，或者使用案例类，例如`case class MyProduct(a: A, b: B)`。'
- en: 'On the other hand, a type that can hold either `A` **or** `B` is a sum type,
    and in Scala, we declare it using a `sealed` trait inheritance:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，可以持有`A`或`B`的类型是和类型，在Scala中，我们使用`sealed`特质继承来声明它：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: An **Algebraic Data Type** (**ADT**) is a type that composes sum types and product
    types to define a data structure. In the preceding code, we defined a `Shape`
    ADT, which composes a sum type (a `Shape` can be a `Circle` or a `Rectangle`),
    with a product type `Rectangle` (a `Rectangle` holds a width and a height).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**代数数据类型**（**ADT**）是一种由和类型和积类型组成以定义数据结构的类型。在上面的代码中，我们定义了一个`Shape` ADT，它由一个和类型（`Shape`可以是`Circle`或`Rectangle`）和一个积类型`Rectangle`（`Rectangle`包含宽度和高度）组成。'
- en: The `sealed` keyword indicates that all subclasses of the trait must be declared
    in the same `.scala` file. If you attempt to declare a class that extends a `sealed`
    trait in another file, the compiler will reject it. This is used to guarantee
    that our inheritance tree is complete, and as we will see later on, it has interesting
    benefits when it comes to using pattern matching.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`sealed`关键字表示特质的所有子类必须在同一个`.scala`文件中声明。如果你尝试在另一个文件中声明一个扩展`sealed`特质的类，编译器将拒绝它。这用于确保我们的继承树是完整的，并且正如我们稍后将会看到的，它在使用模式匹配时具有有趣的优点。'
- en: 'Going back to our problem, we can define a `Returns` ADT as follows. Create
    a new Scala class in the `retcalc` package in `src/main/scala`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的问题，我们可以定义一个`Returns` ADT如下。在`src/main/scala`中的`retcalc`包中创建一个新的Scala类：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For `VariableReturn`, we keep the monthly interest rate and an identifier `monthId`
    that will have the form *2017.02*, for February 2017\. I recommend that you use
    `Vector` whenever you need to model a sequence of elements. `Vector` is faster
    than `List` for appending/inserting elements or accessing an element by index.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`VariableReturn`，我们保留月利率和一个标识符`monthId`，其形式为`*2017.02*`，代表2017年2月。我建议你在需要建模元素序列时使用`Vector`。`Vector`在追加/插入元素或通过索引访问元素时比`List`更快。
- en: Filtering returns for a specific period
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤特定期间的回报
- en: When we have `VariableReturns` over a long period, for instance, 1900 to 2017,
    it can be interesting to use a smaller period to simulate what would happen if
    the historical returns in a smaller period, say 50 years, would be repeated.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个跨越长期期的`VariableReturns`，例如，从1900年到2017年，使用较短的时间段来模拟如果较短时间段的历史回报，比如50年，被重复会发生什么，这可能是有趣的。
- en: 'We are going to create a method in the `VariableReturns` class that will keep
    only the returns contained in a specific period. Here is the unit test in `ReturnsSpec.scala`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`VariableReturns`类中创建一个方法，该方法将仅保留特定期间内的回报。以下是`ReturnsSpec.scala`中的单元测试：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: First, we generate a sequence of returns and assign them to `variableReturns` using
    the function `Vector.tabulate`. It generates 12 elements, and each element is
    produced by an anonymous function, taking a parameter `i` that will go from `0`
    to `11`. In the call to the `VariableReturn` constructor, for the `monthId` argument,
    we use the `f` interpolator to generate a string in the form `2017.01` when `d
    = 1`, `2017.02` when `d = 2`, and so on.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`Vector.tabulate`函数生成一系列回报，并将它们分配给`variableReturns`。它生成12个元素，每个元素由一个匿名函数生成，该函数接受一个参数`i`，其值将从`0`到`11`。在调用`VariableReturn`构造函数时，对于`monthId`参数，我们使用`f`插值器生成形式为`2017.01`的字符串，当`d
    = 1`时，`2017.02`当`d = 2`时，依此类推。
- en: The function `fromUntil` that we are specifying will return a `VariableReturns`
    type that contains a specific window inside the original returns. For now, we
    assume that the arguments passed to `fromUntil` are valid months that are present
    in `variableReturns`. Ideally, we should add unit tests to specify what should
    happen if they are not.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定的`fromUntil`函数将返回一个包含原始回报中特定窗口的`VariableReturns`类型。目前，我们假设传递给`fromUntil`的参数是有效的月份，它们存在于`variableReturns`中。理想情况下，我们应该添加单元测试来指定如果它们不存在会发生什么。
- en: 'Here is the implementation in `Returns.scala`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Returns.scala`中的实现：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We use the higher order function `dropWhile` to drop elements until we reach
    the condition `monthId == monthIdFrom`. Then, we call `takeWhile` on the resulting
    collection to keep all elements until `monthId == monthIdUntil`. This will return
    a collection that keeps only the elements in a window that starts at `monthIdFrom`
    and ends just before `monthIdUntil`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用高阶函数`dropWhile`来丢弃元素，直到我们达到条件`monthId == monthIdFrom`。然后，我们在得到的集合上调用`takeWhile`来保留所有元素，直到`monthId
    == monthIdUntil`。这将返回一个只包含从`monthIdFrom`开始到`monthIdUntil`之前的元素的集合。
- en: Run `ReturnsSpec`, and it should pass.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`ReturnsSpec`，它应该通过。
- en: Pattern matching
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式匹配
- en: 'Now that we have a way of expressing variable returns, we need to change our `futureCapital` function
    to accept a `Returns` type instead of a monthly interest rate of type `Double`.
    Change the tests first:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了表达变量回报的方法，我们需要将我们的`futureCapital`函数更改为接受`Returns`类型，而不是每月的利率类型`Double`。首先更改测试：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, change the `futureCapital` function in `RetCalc` as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按照以下方式更改`RetCalc`中的`futureCapital`函数：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, instead of just using the `interestRate` in the formula, we introduced
    a new function called `Returns.monthlyRate` which we must now create. As we follow
    a rather strict TDD approach, we will only create its signature first, then write
    the unit test, and finally implement it.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不是只在公式中使用`interestRate`，而是引入了一个新的函数`Returns.monthlyRate`，我们现在必须创建它。由于我们遵循相当严格的TDD方法，我们首先创建其签名，然后编写单元测试，最后实现它。
- en: 'Write the function signature in `Returns.scala`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Returns.scala`中编写函数签名：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create a new unit test `ReturnsSpec` in the `retcalc` package in `src/test/scala`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/test/scala`中的`retcalc`包中创建一个新的单元测试`ReturnsSpec`：
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: These tests act as a specification for our `monthlyRate` function. For `VariableRate`,
    the `monthlyRate` must return the *n^(th)* rate stored in the returned `Vector`.
    If *n* is greater than the number of rates, we decide that `monthlyRate` should
    go back to the beginning of `Vector`, as if the history of our variable returns
    would repeat itself infinitely. We could have made a different choice here, for
    instance, we could have taken a mirror of the returns, or we could have just returned
    some error if we reached the end. To implement this rotation, we are taking the
    month value and applying the modulo ( `*%*` in Scala ) of the length of the vector.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试充当我们`monthlyRate`函数的规范。对于`VariableRate`，`monthlyRate`必须返回返回的`Vector`中存储的第*n*个利率。如果*n*大于利率的数量，我们决定`monthlyRate`应该回到`Vector`的开始，就像我们的变量回报的历史会无限期地重复一样。我们在这里可以做出不同的选择，例如，我们可以取回报的镜像，或者如果我们到达了末尾，我们可以简单地返回一些错误。为了实现这种旋转，我们正在将月份值和向量的长度应用模运算（`*%*`在Scala中）。
- en: 'The implementation introduces a new element of syntax, called **pattern matching**:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 实现引入了一个新的语法元素，称为**模式匹配**：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can now run `ReturnsSpec`, and all tests should pass. Pattern matching allows
    you to deconstruct an ADT and evaluate some expression when it matches one of
    the patterns. You can also assign variables along the way and use them in the
    expression. In the preceding example, `case FixedReturns(r) => r/12` can be interpreted
    as "if the variable `returns` is of type `FixedReturns`, assign `r = returns.annualRate`,
    and return the result of the expression `r/12`".
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以运行`ReturnsSpec`，所有测试都应该通过。模式匹配允许你解构一个ADT，并在匹配到某个模式时评估一些表达式。你还可以在过程中分配变量并在表达式中使用它们。在上面的例子中，`case
    FixedReturns(r) => r/12`可以解释为“如果变量`returns`是`FixedReturns`类型，将`r = returns.annualRate`赋值，并返回表达式`r/12`的结果”。
- en: 'This is a simple example, but you can use much more complicated patterns. This
    feature is very powerful, and can often replace lots of `if`/`else` expressions.
    You can try some more complex patterns in the Scala Console:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，但你可以使用更复杂的模式。这个特性非常强大，通常可以替代很多`if`/`else`表达式。你可以在Scala控制台中尝试一些更复杂的模式：
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It is a good practice to exhaustively match all possible patterns for your value.
    Otherwise, if no pattern matches the value, Scala will raise a runtime exception,
    and it might crash your program. However, when you use `sealed` traits, the compiler
    is aware of all the possible classes for a trait and will issue a warning if you
    do not match all cases.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的值，全面匹配所有可能的模式是一种良好的实践。否则，如果没有模式与值匹配，Scala将抛出一个运行时异常，这可能会导致你的程序崩溃。然而，当你使用`sealed`特质时，编译器会知道特质的所有可能类，如果你没有匹配所有情况，编译器将发出警告。
- en: 'In `Returns.scala`, try to comment out this line with cmd + */*:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Returns.scala`中，尝试使用cmd + */*注释掉这一行：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Recompile the project with cmd + *F9*. The compiler will warn you that you
    are doing something wrong:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用cmd + *F9*重新编译项目。编译器将警告你正在做错事：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If you then try to remove the `sealed` keyword and recompile, the compiler will
    not issue any warning.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试移除`sealed`关键字并重新编译，编译器将不会发出任何警告。
- en: We now have a good grasp of how to use pattern matching. Keep the `sealed` keyword,
    revert the comment in `monthlyRate`, and run `ReturnsSpec` to make sure everything
    is green again.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对如何使用模式匹配有了很好的掌握。保留`sealed`关键字，撤销`monthlyRate`中的注释，并运行`ReturnsSpec`以确保一切恢复正常。
- en: If you are coming from an object-oriented language, you might wonder why we
    did not implement `monthlyRate` using an abstract method with implementations
    in `FixedRate` and `VariableRate`. This is perfectly feasible in Scala, and some
    people might prefer this design choice.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自面向对象的语言，你可能会想知道为什么我们没有使用在`FixedRate`和`VariableRate`中实现的具体方法的抽象方法来实现`monthlyRate`。这在Scala中是完全可行的，有些人可能更喜欢这种设计选择。
- en: 'However, as I am an advocate of a functional programming style, I prefer using
    pure functions in objects:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，作为功能编程风格的倡导者，我更喜欢在对象中使用纯函数：
- en: They are easier to reason about, as the whole dispatching logic is in one place.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们更容易推理，因为整个调度逻辑都在一个地方。
- en: They can be moved to other objects easily, which facilitates refactoring.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以轻松地移动到其他对象中，这有助于重构。
- en: They have a more limited scope. In class methods, you always have all the attributes
    of the class in scope. In a function, you only have the parameters of the function.
    This helps unit testing and readability, as you know that the function cannot
    use anything else but its parameters. Also, it can avoid side effects when the
    class has mutable attributes.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们的范围更有限。在类方法中，你总是有类的所有属性在作用域内。在函数中，你只有函数的参数。这有助于单元测试和可读性，因为你知道函数只能使用其参数，而不能使用其他任何东西。此外，当类有可变属性时，它还可以避免副作用。
- en: Sometimes in object-oriented design, when a method manipulates two objects,
    `A` and `B`, it is not clear if the method should be in class `A` or class `B`.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时在面向对象的设计中，当一个方法操作两个对象`A`和`B`时，并不清楚该方法应该放在类`A`还是类`B`中。
- en: Refactoring simulatePlan
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构simulatePlan
- en: 'As we changed the signature of `futureCapital`, we also need to change the
    callers of that function. The only caller is `simulatePlan`. Before introducing
    variable rates, the implementation was straightforward: we just had to call `futureCapital`
    for the accumulation and decumulation phases with the same fixed rate argument.
    However, with variable rate, we must make sure that the decumulation phase uses
    the rates that follow the rates of the accumulation phase.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们更改了`futureCapital`的签名，我们也需要更改该函数的调用者。唯一的调用者是`simulatePlan`。在引入变量利率之前，实现很简单：我们只需要用相同的固定利率参数调用`futureCapital`进行积累和提款阶段。然而，随着变量利率的出现，我们必须确保提款阶段使用的利率是积累阶段利率之后的利率。
- en: 'For instance, consider that you started saving in 1950, and retired in 1975\.
    For the accumulation phase, you need to use the returns from 1950 to 1975, and
    for the decumulation, you must use the returns from 1975\. We created a new unit
    test to make sure that we are using different returns for the two phases:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你在1950年开始储蓄，并在1975年退休。在积累阶段，你需要使用1950年到1975年的回报，而在提款阶段，你必须使用1975年的回报。我们创建了一个新的单元测试来确保我们为这两个阶段使用了不同的回报：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Since `simulatePlan` has quite a lot of parameters apart from the `returns` parameter,
    we decided to put them in a case class called `RetCalcParams`. This way, we are
    able to reuse the same parameters for different unit tests. We will also be able
    to reuse it in `nbMonthsSaving`. As seen previously, we use the function `tabulate`
    to generate values for our variable returns.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `simulatePlan` 除了 `returns` 参数外还有相当多的参数，我们决定将它们放入一个名为 `RetCalcParams` 的案例类中。这样，我们能够为不同的单元测试重用相同的参数。我们还将能够在
    `nbMonthsSaving` 中重用它。如前所述，我们使用 `tabulate` 函数生成变量回报的值。
- en: The expected value for `capitalAtRetirement` can be obtained with Excel by using
    `-FV(0.04/12, 25*12, 1000, 10000)`. The expected value for `capitalAfterDeath`
    can be obtained by using `-FV(0.03/12, 40*12, -2000, 541267.20)`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 Excel 通过 `-FV(0.04/12, 25*12, 1000, 10000)` 获取 `capitalAtRetirement` 的预期值。使用
    `-FV(0.03/12, 40*12, -2000, 541267.20)` 可以获取 `capitalAfterDeath` 的预期值。
- en: 'Here is the implementation in `RetCalc`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `RetCalc` 中的实现：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The first line, `import params._`, brings all the parameters of `RetCalcParams`
    into scope. This way, you can directly use, for instance, `netIncome` without
    having to prefix it with `params.netIncome` . In Scala, you can not only import
    classes from a package, but also functions or values from an object.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行，`import params._`，将 `RetCalcParams` 的所有参数引入作用域。这样，你可以直接使用，例如，`netIncome`，而无需在前面加上
    `params.netIncome`。在 Scala 中，你不仅可以从包中导入类，还可以从对象中导入函数或值。
- en: 'In the second call to `futureCapital`, we introduce a new subclass called `OffsetReturns`,
    which will shift the starting month. We need to write a new unit test for it in
    `ReturnsSpec`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在对 `futureCapital` 的第二次调用中，我们引入了一个新的子类 `OffsetReturns`，它将改变起始月份。我们需要在 `ReturnsSpec`
    中为它编写一个新的单元测试：
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And the corresponding implementation in `Returns.scala` is as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在 `Returns.scala` 中的相应实现如下：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: For an offset return, we call `monthlyRate` recursively and add the offset to
    the requested month.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对于偏移回报，我们递归地调用 `monthlyRate` 并将偏移量加到请求的月份。
- en: Now, you can compile everything with cmd + *F9* and rerun the unit tests. They
    should all pass.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用 cmd + *F9* 编译所有内容，并重新运行单元测试。它们都应该通过。
- en: Loading market data
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载市场数据
- en: In order to calculate the real monthly returns of our investments in a fund
    tracking the S & P 500, we are going to load a tab-separated file containing the
    S & P 500 prices and dividends, and another file containing the consumer price
    index. This will let us calculate a real rate of return, stripped out of inflation.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算跟踪 S & P 500 的基金中我们投资的实际月回报率，我们将加载一个包含 S & P 500 价格和股息的制表符分隔文件，以及另一个包含消费者价格指数的文件。这将使我们能够计算一个扣除通货膨胀的实际回报率。
- en: Writing the unit test using the column selection mode
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用列选择模式编写单元测试
- en: 'First, copy `sp500_2017.tsv` from [https://github.com/PacktPublishing/Scala-Programming-Projects/blob/master/Chapter02/retirement-calculator/src/main/resources/sp500.tsv](https://github.com/PacktPublishing/Scala-Programming-Projects/blob/master/Chapter02/retirement-calculator/src/main/resources/sp500.tsv)
    to `src/test/resources`. Then, create a new unit test called `EquityDataSpec` in
    the `retcalc` package. If you retype this example, try the column selection mode
    (*Alt* + *Shift* + *Insert*). Copy the content of the `.tsv` file in the test,
    then select the first column with *Shift* + *Down* 13 times, and then type `EquityData("`.
    Finally, edit the rest of the lines using the arrow keys, delete, comma, and so
    on:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将 `sp500_2017.tsv` 从 [https://github.com/PacktPublishing/Scala-Programming-Projects/blob/master/Chapter02/retirement-calculator/src/main/resources/sp500.tsv](https://github.com/PacktPublishing/Scala-Programming-Projects/blob/master/Chapter02/retirement-calculator/src/main/resources/sp500.tsv)
    复制到 `src/test/resources`。然后，在 `retcalc` 包中创建一个新的单元测试 `EquityDataSpec`。如果你重新输入这个例子，尝试使用列选择模式
    (*Alt* + *Shift* + *Insert*)。将 `.tsv` 文件的内容复制到测试中，然后使用 *Shift* + *Down* 13 次选择第一列，并输入
    `EquityData("`。最后，使用箭头键、删除、逗号等编辑其余的行：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The first lines of `sp500_2017.tsv` look like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`sp500_2017.tsv` 的前几行看起来像这样：'
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Loading the file with Source
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Source 加载文件
- en: 'Our implementation must drop the first line which contains the headers, then
    for each line, split and create a new instance of `EquityData`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现必须删除包含标题的第一行，然后对于每一行，分割并创建一个新的 `EquityData` 实例：
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This code is quite compact, and you might lose a sense of what types are returned
    by intermediate calls. In IntelliJ, you can select a portion of code and hit *Alt*
    + *=* to show the inferred type of the expression.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码相当紧凑，你可能会失去对中间调用返回的类型的感觉。在 IntelliJ 中，你可以选择代码的一部分并按 *Alt* + *=* 来显示表达式的推断类型。
- en: We first load the `.tsv` file using `scala.io.Source.fromResource`. This takes
    the name of a file located in a `resource` folder and returns a `Source` object.
    It can be in `src/test/resources` or `src/main/resources`. When you run a test,
    both folders will be searched. If you run the production code, only the files
    in `src/main/resources` will be accessible.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用 `scala.io.Source.fromResource` 加载 `.tsv` 文件。它接受位于 `resource` 文件夹中的文件名，并返回一个
    `Source` 对象。它可以在 `src/test/resources` 或 `src/main/resources` 中。当你运行测试时，这两个文件夹都会被搜索。如果你运行生产代码，只有
    `src/main/resources` 中的文件可访问。
- en: '`getLines` returns `Iterator[String]`. An **iterator** is a **mutable** data
    structure that allows you to iterate over a sequence of elements. It provides
    many functions that are common to other collections. Here, we drop the first line,
    which contains the header, and transforms each line using an anonymous function
    passed to `map`.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`getLines` 返回 `Iterator[String]`。**迭代器**是一个允许你遍历一系列元素的**可变**数据结构。它提供了许多与其他集合共有的函数。在这里，我们丢弃包含标题的第一行，并使用传递给
    `map` 的匿名函数转换每一行。'
- en: The anonymous function takes `line` of type string, transforms it into `Array[String]`
    using `split`, and instantiates a new `EquityData` object.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数接受 `line` 类型的字符串，使用 `split` 将其转换为 `Array[String]`，并实例化一个新的 `EquityData`
    对象。
- en: 'Finally, we convert the resulting `Iterator[EquityData]` into `Vector[EquityData]` using
    `.toVector`. This step is very important: we convert the mutable, unsafe, iterator
    into an immutable, safe `Vector`. Public functions should, in general, not accept
    or return mutable data structures:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `.toVector` 将结果 `Iterator[EquityData]` 转换为 `Vector[EquityData]`。这一步非常重要：我们将可变、不安全的迭代器转换为不可变、安全的
    `Vector`。公共函数通常不应接受或返回可变数据结构：
- en: It makes the code harder to reason about, as you have to remember the state
    the mutable structure is in.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这使得代码更难推理，因为你必须记住可变结构的状态。
- en: 'The program will behave differently depending on the order/repetition of the
    function calls. In the case of an iterator, it can be iterated only once. If you
    need to iterate again, you won''t get any data:'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序的行为将根据函数调用的顺序/重复次数而有所不同。在迭代器的情况下，它只能迭代一次。如果你需要再次迭代，你将不会得到任何数据：
- en: '[PRE38]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Loading inflation data
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载通货膨胀数据
- en: Now that we can load some equity data, we need to load inflation data so that
    we're able to compute inflation-adjusted returns. It is very similar to the loading
    of equity data.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够加载一些股权数据，我们需要加载通货膨胀数据，以便能够计算通货膨胀调整后的回报。这与加载股权数据非常相似。
- en: 'First, copy `cpi_2017.tsv` from [https://github.com/PacktPublishing/Scala-Programming-Projects/blob/master/Chapter02/retirement-calculator/src/main/resources/cpi.tsv](https://github.com/PacktPublishing/Scala-Programming-Projects/blob/master/Chapter02/retirement-calculator/src/main/resources/cpi.tsv)
    to `src/test/resources`. Then, create a new unit test called `InflationDataSpec`
    in the `retcalc` package:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将 `cpi_2017.tsv` 从 [https://github.com/PacktPublishing/Scala-Programming-Projects/blob/master/Chapter02/retirement-calculator/src/main/resources/cpi.tsv](https://github.com/PacktPublishing/Scala-Programming-Projects/blob/master/Chapter02/retirement-calculator/src/main/resources/cpi.tsv)
    复制到 `src/test/resources`。然后，在 `retcalc` 包中创建一个新的单元测试，名为 `InflationDataSpec`：
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, create the corresponding `InflationData` class and companion object:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建相应的 `InflationData` 类和伴生对象：
- en: '[PRE40]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Computing real returns
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算实际回报
- en: 'For a given month, *n*, the real return is *return*[n] *- inflationRate*[n],
    hence the following formula:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的月份，*n*，实际回报是 *return*[n] 减去 *inflationRate*[n]，因此以下公式：
- en: '![](img/e0504af4-084c-4252-b1b8-74ab19365329.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e0504af4-084c-4252-b1b8-74ab19365329.png)'
- en: 'We are going to create a new function in `Returns` that creates `VariableReturns`
    using `Vector[EquityData]` and `Vector[InflationData]`. Add the following unit
    test to `ReturnsSpec`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `Returns` 中创建一个新的函数，使用 `Vector[EquityData]` 和 `Vector[InflationData]` 创建
    `VariableReturns`。将以下单元测试添加到 `ReturnsSpec`：
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We create two small `Vector` instances of `EquityData` and `InflationData`,
    and calculate the expected value using the preceding formula.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个小的 `Vector` 实例 `EquityData` 和 `InflationData`，并使用前面的公式计算期望值。
- en: 'Here is the implementation of `fromEquityAndInflationData` in `Returns.scala`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Returns.scala` 中 `fromEquityAndInflationData` 的实现：
- en: '[PRE42]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Firstly, we `zip` the two `Vectors` to create a collection of tuples, `(EquityData,
    InflationData)`. This operation brings our two collections together as if we were
    zipping a jacket. It is a good habit to play around with the Scala Console to
    get a sense of what it does:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 `zip` 将两个 `Vectors` 合并，创建一个元组集合，`(EquityData, InflationData)`。这个操作就像我们正在拉链一件夹克一样将我们的两个集合结合在一起。在
    Scala 控制台中玩弄是一个好习惯，以了解它的工作方式：
- en: '[PRE43]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note that the resulting `Vector` has a size that is the minimum size of the
    two arguments. The last element, `"c"`, is lost, because there is nothing to zip
    it with!
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，结果 `Vector` 的大小是两个参数中的最小值。最后一个元素 `"c"` 被丢失，因为没有东西可以与它进行压缩！
- en: 'This is a good start, as we could now iterate through a collection that can
    give us *price^n*, *dividends^n*, and *inflation^n*. But in order to calculate
    our formula, we also need the previous data on *n-1*. For this, we use `sliding(2)`.
    I encourage you to read the documentation on sliding. Let''s try it in the console:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个良好的开始，因为我们现在可以迭代一个可以给我们 *price^n*、*dividends^n* 和 *inflation^n* 的集合。但为了计算我们的公式，我们还需要
    *n-1* 的先前数据。为此，我们使用 `sliding(2)`。我鼓励你阅读有关滑动的文档。让我们在控制台上试一试：
- en: '[PRE44]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`sliding(p)` creates an `Iterator` which will produce collections of size `p`.
    Each collection will have a new iterated element plus all the previous `p-1` elements.
    Notice that if the collection size *n* is lower than `p`, the produced collection
    will have a size of *n*.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`sliding(p)` 创建一个 `Iterator`，它将产生大小为 `p` 的集合。每个集合将包含一个新的迭代元素和所有之前的 `p-1` 个元素。请注意，如果集合的大小
    *n* 低于 `p`，则产生的集合大小将为 *n*。'
- en: 'Next, we iterate through the sliding collections using `collect`. `collect`
    is similar to `map`: it allows you to transform the elements of a collection,
    but with the added capability of filtering them. Basically, whenever you want
    to `filter` and `map` a collection, you can use `collect` instead. The filtering
    is performed using pattern matching. Anything that does not match any pattern
    is filtered out:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `collect` 迭代滑动集合。`collect` 与 `map` 类似：它允许你转换集合的元素，但增加了过滤的能力。基本上，每次你想对集合进行
    `filter` 和 `map` 操作时，你都可以使用 `collect`。过滤是通过模式匹配来执行的。任何不匹配任何模式的东西都会被过滤掉：
- en: '[PRE45]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Notice that, in the preceding code, we used `map(_ + 1)` instead of `map(i =>
    i + 1)`. This is a shorthand notation for an anonymous function. Whenever you
    use a parameter once in your anonymous function, you can replace it with `_`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的代码中，我们使用了 `map(_ + 1)` 而不是 `map(i => i + 1)`。这是一个匿名函数的简写表示。每次你在匿名函数中使用参数一次时，你可以用
    `_` 替换它。
- en: 'Finally, we pattern match on our zipped and sliding elements using the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用以下方法对压缩和滑动元素进行模式匹配：
- en: '[PRE46]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This has the benefit of filtering out sliding elements of size `0` or `1`, if
    we were passing equities or inflation arguments of size `0` or `1`. We will not
    write a unit test for this edge case in this book, but I encourage you to do so
    as an excercise.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们传递大小为 `0` 或 `1` 的股票或通货膨胀参数，这将有助于过滤掉大小为 `0` 或 `1` 的滑动元素。在这本书中，我们不会为这种边缘情况编写单元测试，但我鼓励你作为练习这样做。
- en: 'The rest of the function is straightforward: we use the matched variables to
    compute the formula and create a new `VariableReturn` instance. The resulting
    iterator is converted to `Vector`, and we instantiate a `VariableReturns` case
    class using it.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的其余部分很简单：我们使用匹配的变量来计算公式并创建一个新的 `VariableReturn` 实例。结果迭代器被转换为 `Vector`，然后我们使用它实例化一个
    `VariableReturns` 案例类。
- en: Packaging the application
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包应用程序
- en: We have now implemented some useful building blocks, and it is time to create
    an executable so that end users can use our calculator with their own parameters.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经实现了一些有用的构建块，现在是时候创建一个可执行文件，以便最终用户可以使用他们自己的参数使用我们的计算器。
- en: Creating the App object
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 App 对象
- en: We are going to build a simple executable around `RetCalc.simulatePlan`. It
    will take a list of parameters separated by spaces, and print the results on the
    console.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将围绕 `RetCalc.simulatePlan` 构建一个简单的可执行文件。它将接受由空格分隔的参数列表，并在控制台上打印结果。
- en: The test we are going to write integrates several components together and will
    use a full market data set. As such, it is not really a unit test anymore; it
    is an integration test. For this reason, we suffixed it with IT instead of Spec.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要编写的测试将集成多个组件，并使用完整的市场数据集。因此，它不再是一个单元测试；它是一个集成测试。出于这个原因，我们在其后面加上 IT 而不是 Spec。
- en: 'First, copy `sp500.tsv` and `cpi.tsv` from [https://github.com/PacktPublishing/Scala-Programming-Projects/blob/master/Chapter02/retirement-calculator/src/main/resources/sp500.tsv](https://github.com/PacktPublishing/Scala-Programming-Projects/blob/master/Chapter02/retirement-calculator/src/main/resources/sp500.tsv)
    and [https://github.com/PacktPublishing/Scala-Programming-Projects/blob/master/Chapter02/retirement-calculator/src/main/resources/cpi.tsv](https://github.com/PacktPublishing/Scala-Programming-Projects/blob/master/Chapter02/retirement-calculator/src/main/resources/cpi.tsv)
    to `src/main/resources`, then create a new unit test called `SimulatePlanIT` in
    `src/test/scala`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将 `sp500.tsv` 和 `cpi.tsv` 从 [https://github.com/PacktPublishing/Scala-Programming-Projects/blob/master/Chapter02/retirement-calculator/src/main/resources/sp500.tsv](https://github.com/PacktPublishing/Scala-Programming-Projects/blob/master/Chapter02/retirement-calculator/src/main/resources/sp500.tsv)
    和 [https://github.com/PacktPublishing/Scala-Programming-Projects/blob/master/Chapter02/retirement-calculator/src/main/resources/cpi.tsv](https://github.com/PacktPublishing/Scala-Programming-Projects/blob/master/Chapter02/retirement-calculator/src/main/resources/cpi.tsv)
    复制到 `src/main/resources`，然后在 `src/test/scala` 中创建一个新的单元测试，名为 `SimulatePlanIT`：
- en: '[PRE47]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We call a function called `strMain` which will return a string instead of printing
    it to the console. This way, we can assert on the content printed to the console.
    To keep things simple, we assume that the arguments are passed in a specific order.
    We will develop a more user-friendly interface in the next chapter. The arguments
    are as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用一个名为 `strMain` 的函数，它将返回一个字符串而不是将其打印到控制台。这样，我们可以断言打印到控制台的内容。为了保持简单，我们假设参数以特定的顺序传递。我们将在下一章开发一个更用户友好的界面。参数如下：
- en: A period that we will use in the variables returns, separated by a comma
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在变量返回值中使用的时期，以逗号分隔
- en: The number of years of savings
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 储蓄的年数
- en: The number of years in retirement
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退休的年数
- en: Income
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收入
- en: Expenses
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 支出
- en: Initial capital
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始资本
- en: The expected value is a string that we define using triple quotes. In Scala,
    a string enclosed in triple quotes lets you enter special characters such as a
    quote or newline. It is very convenient to enter multiline strings while keeping
    a good indentation. The `|` characters allow you to mark the beginning of each
    line, and the `.stripMargin` function removes the white spaces before the `|`,
    as well as the `|` itself in order. In IntelliJ, when you type `"""` and then
    hit *Enter*, it automatically adds the `|` and `.stripMargin` after the closing
    triple quote.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 预期值是我们使用三引号定义的字符串。在 Scala 中，三引号包围的字符串允许你输入特殊字符，如引号或换行符。在保持良好缩进的同时输入多行字符串非常方便。`|`
    字符允许你标记每行的开始，而 `.stripMargin` 函数则移除了 `|` 前面的空白以及 `|` 本身。在 IntelliJ 中，当你输入 `"""`
    并按 *Enter* 键时，它会自动在关闭三引号后添加 `|` 和 `.stripMargin`。
- en: 'The implementation calls the different functions we implemented earlier. Notice
    that IntelliJ can autocomplete the name of the files using *Ctrl* + spacebar,
    for instance, after `EquityData.fromResource("Create a new object SimulatePlanApp
    in the package retcalc`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 实现调用我们之前实现的不同函数。注意，IntelliJ 可以使用 *Ctrl* + 空格键自动补全文件名，例如，在 `EquityData.fromResource("Create
    a new object SimulatePlanApp in the package retcalc` 之后：
- en: '[PRE48]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The only code executed when we run our executable will be `println(strMain(args))`.
    It is a good practice to keep this code as short as possible because it is not
    covered by any test. Our function `strMain` is covered, so we are fairly sure
    there won't be any unexpected behavior from a single `println`. `args` is an `Array[String]`
    containing all the arguments passed to the executable.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行可执行文件时，唯一执行的代码将是 `println(strMain(args))`。将此代码保持尽可能短是一个好习惯，因为它不受任何测试的覆盖。我们的
    `strMain` 函数是受覆盖的，所以我们相当确信不会有任何意外的行为来自单个 `println`。`args` 是一个包含传递给可执行文件的所有参数的
    `Array[String]`。
- en: The first line of `strMain` uses a pattern matching on `List` to assign `from`
    and `until`. The variables will be assigned only if the split first argument,
    in our test `"1997.09,2017.09"`, is a `List` of two elements.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`strMain` 的第一行使用 `List` 的模式匹配来分配 `from` 和 `until`。只有当拆分的第一个参数，在我们的测试中为 `"1997.09,2017.09"`，是一个包含两个元素的
    `List` 时，变量才会被分配。'
- en: Then, we load the equity and inflation data from our `.tsv` files. They contain
    data from 1900.01 until 2017.09\. We then call `Returns.fromEquityAndInflationData`
    to compute the real returns.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从 `.tsv` 文件中加载股票和通货膨胀数据。它们包含从 1900.01 到 2017.09 的数据。然后我们调用 `Returns.fromEquityAndInflationData`
    来计算实际回报。
- en: After having assigned the returns to `allReturns`, we call `simulatePlan` with
    the right arguments. The returns are filtered for a specific period using `from`
    and `until`. Finally, we return `String` using a string interpolation and triple
    quotes.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在将收益分配给`allReturns`之后，我们用正确的参数调用`simulatePlan`。使用`from`和`until`对收益进行特定时期的过滤。最后，我们使用字符串插值和三引号返回`String`。
- en: This implementation is the first draft and is quite brittle. It will indeed
    crash with a horrible `ArrayIndexOutOfBoundsException` if we do not pass enough
    parameters to our executable, or with a `NumberFormatException` if some strings
    cannot be converted to `Int` or `Double`. We will see in the next chapter how
    we can handle these error cases gracefully, but for now, our calculator does the
    job as long as we feed it with the right arguments.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现是第一个草稿，相当脆弱。如果我们没有给我们的可执行文件传递足够的参数，它确实会因`ArrayIndexOutOfBoundsException`而崩溃，或者如果某些字符串无法转换为`Int`或`Double`，则会因`NumberFormatException`而崩溃。我们将在下一章中看到我们如何优雅地处理这些错误情况，但到目前为止，只要我们给它提供正确的参数，我们的计算器就能完成工作。
- en: You can now run `SimulatePlanIT`, and it should pass.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以运行`SimulatePlanIT`，它应该通过。
- en: 'Since we built an application, we can also run it as such. Move your cursor
    to `SimulatePlanApp`, and hit *Ctrl* + *Shift* + *R*. The app should run and crash
    with an exception because we did not pass any arguments. Click on the launcher
    for `SimulatePlanApp` (underneath the Build menu), then click Edit Configurations.
    Put the following in program arguments:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们构建了一个应用程序，我们也可以这样运行它。将光标移至`SimulatePlanApp`，然后按*Ctrl* + *Shift* + *R*。应用程序应该运行并崩溃，因为我们在可执行文件中没有传递任何参数。点击`SimulatePlanApp`的启动器（位于构建菜单下方），然后点击编辑配置。在程序参数中输入以下内容：
- en: '[PRE49]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Then, click OK, and run `SimulatePlanApp` again. It should print the same content
    as what we had in our unit test. You can try calling the application with different
    parameters and observe the resulting calculated capitals.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，点击确定，再次运行`SimulatePlanApp`。它应该打印出我们在单元测试中拥有的相同内容。您可以尝试用不同的参数调用应用程序，并观察产生的计算资本。
- en: Packaging the application
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包应用程序
- en: So far so good, but what if we want to send this application to uncle Bob so
    that he can plan for his retirement too? It would not be very convenient to ask
    him to download IntelliJ or SBT. We are going to package our application in a
    `.jar` file so that we can run it with a single command.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利，但如果我们想将这个应用程序发送给鲍勃叔叔，以便他也能为退休做准备呢？要求他下载IntelliJ或SBT并不方便。我们将把我们的应用程序打包成一个`.jar`文件，这样我们就可以通过单个命令来运行它。
- en: 'SBT provides a package task that can create a `.jar` file, but this file will
    not contain the dependencies. In order to package our own classes as well as the
    classes coming from the dependent libraries, we are going to use the `sbt-assembly`
    plugin. Create a new file called `project/assembly.sbt` containing the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: SBT提供了一个打包任务，可以创建一个`.jar`文件，但这个文件不会包含依赖项。为了打包我们自己的类以及来自依赖库的类，我们将使用`sbt-assembly`插件。创建一个名为`project/assembly.sbt`的新文件，包含以下内容：
- en: '[PRE50]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, edit `build.sbt` to define the name of our main class:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，编辑`build.sbt`以定义我们的主类名称：
- en: '[PRE51]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Click on the SBT tab on the top-right and then on the Refresh button. Then,
    expand the project and double-click on the assembly task:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 点击右上角的SBT标签，然后点击刷新按钮。然后，展开项目并双击assembly任务：
- en: '![](img/536aabaa-077d-46d6-af9c-bbd39c9d0cc1.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/536aabaa-077d-46d6-af9c-bbd39c9d0cc1.png)'
- en: 'The assembly task will compile all the classes, run all the tests, and if they
    all pass, package a fat JAR. You should see an output similar to this at the bottom
    of the SBT console:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 打包任务将编译所有类，运行所有测试，如果它们都通过，则打包一个胖JAR。您应该在SBT控制台底部看到类似的输出：
- en: '[PRE52]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Copy the location of the `.jar` file in your clipboard. Now, you can use a
    Unix terminal or a Windows command prompt and run the application as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 将`.jar`文件的路径复制到您的剪贴板。现在，您可以使用Unix终端或Windows命令提示符来运行应用程序，如下所示：
- en: '[PRE53]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'It is now easier to try different parameters. It is interesting to see that
    some periods are much more lucrative than others:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试不同的参数更容易了。有趣的是，有些时期比其他时期更有利可图：
- en: '[PRE54]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We have covered how to create a small project in Scala from scratch to packaging.
    We used TDD along the way so that it is guaranteed that our code was well-designed
    and robust. It gives us confidence when we refactor code: as long as all tests
    pass, we know that our code stills works. We modeled our domain with immutable
    data structures and processed them using pure functions that have no side effects.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了如何从头到尾创建一个Scala小项目，包括打包。我们在整个过程中使用了TDD，以确保我们的代码设计良好且健壮。当我们重构代码时，这给了我们信心：只要所有测试都通过，我们就知道我们的代码仍然有效。我们使用不可变数据结构来模拟我们的领域，并使用没有副作用的功能函数来处理它们。
- en: We used some basic features of the language that are used in most projects,
    and you should now be familiar with enough building blocks to implement a wide
    variety of projects.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了大多数项目中都会用到的语言的基本特性，你现在应该熟悉了足够的构建块来实现各种各样的项目。
- en: 'As a further exercise, you could enhance this calculator with one or many of
    these features:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 作为进一步的练习，你可以通过添加一个或多个这些特性来增强这个计算器：
- en: Create an app for the function `RetCalc.nbOfMonthsSaving`, which calculates
    how long you need to save before you can retire.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为函数 `RetCalc.nbOfMonthsSaving` 创建一个应用程序，该函数计算你退休前需要存多久。
- en: Create a function called `RetCalc.annualizedTotalReturn`, which calculates the
    geometric average of a sequence of returns. See [https://www.investopedia.com/terms/a/annualized-total-return.asp](https://www.investopedia.com/terms/a/annualized-total-return.asp)[ ](https://www.investopedia.com/terms/a/annualized-total-return.asp)for
    more details.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为 `RetCalc.annualizedTotalReturn` 的函数，该函数计算一系列回报的几何平均值。有关更多详细信息，请参阅[https://www.investopedia.com/terms/a/annualized-total-return.asp](https://www.investopedia.com/terms/a/annualized-total-return.asp)[ ](https://www.investopedia.com/terms/a/annualized-total-return.asp)。
- en: Create a function called `monthlyPension`, which calculates how much you will
    get in retirement if you save a given amount every month for a given number of
    months.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为 `monthlyPension` 的函数，该函数计算如果你每个月存入一定金额，在给定月份后你将获得多少退休金。
- en: Incorporate other streams of income. Maybe you will get a state pension after
    a number of years, or you might get an inheritance.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合其他收入来源。也许在几年后，你将获得国家养老金，或者你可能得到遗产。
- en: Load a different index, such as STOXX Europe 600, MSCI World Index, and so on.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载不同的指数，例如STOXX欧洲600、MSCI世界指数等。
- en: Most people do not invest all their savings in the stock market, but wisely
    diversify with bonds, that is, typically 60% stocks, 40% bonds. You could add
    a new function in `Returns.scala` to calculate the returns of a mixed portfolio.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数人不会将所有储蓄投资于股市，而是明智地通过债券进行多元化，即通常60%的股票，40%的债券。你可以在 `Returns.scala` 中添加一个新函数来计算混合投资组合的回报。
- en: We observed that some periods have much higher returns than others. As it is
    difficult to predict the future, you could run multiple simulations using different
    periods, and calculate a probability of success.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们观察到有些时期的回报率远高于其他时期。由于预测未来很困难，你可以使用不同的时期运行多个模拟，并计算成功的概率。
- en: In the next chapter, we will improve our calculator further by handling errors
    in a functional way.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过以功能方式处理错误来进一步改进我们的计算器。
