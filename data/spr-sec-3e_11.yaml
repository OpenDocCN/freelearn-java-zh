- en: Single Sign-On with the Central Authentication Service
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用中央认证服务的单点登录
- en: In this chapter, we'll examine the use of the **Central Authentication Service**
    (**CAS**) as a single sign-on portal for Spring Security-based applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何使用**中央认证服务**（**CAS**）作为Spring Security基础应用程序的单点登录门户。
- en: 'During the course of this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Learning about CAS, its architecture, and how it benefits system administrators
    and organizations of any size
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习关于CAS，其架构以及它如何使系统管理员和任何大小的组织受益
- en: Understanding how Spring Security can be reconfigured to handle the interception
    of authentication requests and redirecting it to CAS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何重新配置Spring Security以处理认证请求的拦截并重定向到CAS
- en: Configuring the JBCP calendar application to utilize CAS single sign-on
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置JBCP日历应用程序以使用CAS单点登录
- en: Gaining an understanding of how a single logout can be performed, and configuring
    our application to support it
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何执行单一登出，并配置我们的应用程序以支持它
- en: Discussing how to use CAS proxy ticket authentication for services, and configuring
    our application to utilize proxy ticket authentication
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论如何使用CAS代理票证认证服务，并配置我们的应用程序以利用代理票证认证
- en: Discussing how to customize the out-of-the-box **JA-SIG CAS** server using the
    recommended war overlay approach
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论如何使用推荐的war覆盖方法定制**JA-SIG CAS**服务器
- en: Integrating the CAS server with LDAP, and passing data from LDAP to Spring Security
    via CAS
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将CAS服务器与LDAP集成，并通过CAS将数据从LDAP传递到Spring Security
- en: Introducing the Central Authentication Service
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍中央认证服务
- en: 'CAS is an open source, single sign-on server, providing centralized access
    control, and authentication to web-based resources within an organization. The
    benefits of CAS are numerous to administrators, and it supports many applications
    and diverse user communities. The benefits are as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: CAS是一个开源的单点登录服务器，为组织内的基于web的资源提供集中访问控制和认证。对于管理员来说，CAS的好处是显而易见的，它支持许多应用程序和多样化的用户社区。好处如下：
- en: Individual or group access to resources (applications) can be configured in
    one location
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源（应用程序）的个人或组访问可以在一个位置进行配置
- en: Broad support for a wide variety of authentication stores (to centralize user
    management) provides a single point of authentication and control to a widespread,
    cross-machine environment
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对各种认证存储（用于集中用户管理）的广泛支持，为广泛的跨机器环境提供单一的认证和控制点
- en: Wide authentication support is provided for web-based and non-web-based Java
    applications through CAS client libraries
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过CAS客户端库为基于web和非基于web的Java应用程序提供广泛的认证支持
- en: A single point of reference for user credentials (via CAS) is provided so that
    CAS client applications are not required to have any knowledge of the user's credentials,
    or knowledge of how to verify them
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过CAS提供单一引用点用户凭据（ via CAS），因此CAS客户端应用程序无需了解用户的凭据，或知道如何验证它们
- en: In this chapter, we'll not focus much on the management of CAS, but on authentication
    and how CAS can act as an authentication point for the users of our site. Although
    CAS is commonly seen in intranet environments for enterprises or educational institutions,
    it can also be found in use at high profile locations such as Sony Online Entertainment's
    public-facing site.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将不太多关注CAS的管理，而是关注认证以及CAS如何为我们的网站用户充当认证点。尽管CAS通常在企业或教育机构的内部网络环境中看到，但它也可以在诸如Sony
    Online Entertainment公共面向网站等高知名度位置找到使用。
- en: High-level CAS authentication flow
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级CAS认证流程
- en: 'At a high level, CAS is composed of a CAS server, which is the central web
    application for determining authentication, and one or more CAS services, which
    are distinct web applications that use the CAS server to get authenticated. The
    basic authentication flow of CAS proceeds via the following actions:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在较高层次上，CAS由CAS服务器组成，这是确定认证的中心web应用程序，还有CAS服务，这是使用CAS服务器进行认证的不同的web应用程序。CAS的基本认证流程通过以下动作进行：
- en: The user attempts to access a protected resource on the website.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户尝试访问网站上的受保护资源。
- en: The user is redirected through the browser from the CAS service to the CAS server
    to request a login.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户通过浏览器从CAS服务请求登录到CAS服务器。
- en: The CAS server is responsible for user authentication. If the user is not already
    authenticated to the CAS server, it requests credentials from the user. In the
    following diagram, the user is presented with a login page.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CAS服务器负责用户认证。如果用户尚未认证到CAS服务器，它会请求用户提供凭证。在下面的图中，用户被呈现一个登录页面。
- en: The user submits the credentials (that is, the username and password).
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户提交凭证（即用户名和密码）。
- en: If the user's credentials are valid, the CAS server responds with a redirect
    through the browser with a service ticket. A service ticket is a one-time use
    token used to identify a user.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户的凭证有效，CAS服务器将通过浏览器重定向一个服务票证。服务票证是一次性使用的令牌，用于标识用户。
- en: The CAS service calls the CAS server back to verify that the ticket is valid,
    has not expired, and so on. Note that this step does not occur through the browser.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CAS服务调用CAS服务器来验证票证是否有效，是否已过期等。注意这一步不是通过浏览器进行的。
- en: The CAS server responds with an assertion indicating that trust has been established.
    If the ticket is acceptable, trust has been established and the user may proceed
    via normal authorization checking.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CAS服务器回应一个断言，表示信任已经建立。如果票证可以接受，信任已经建立，用户可以通过正常的授权检查继续操作。
- en: 'Visually, this behaves as illustrated in the following diagram:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '视觉上，它表现为以下 diagram:'
- en: '![](img/93089ee8-4fe7-41ea-8a0c-1bbda83dbb11.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/93089ee8-4fe7-41ea-8a0c-1bbda83dbb11.png)'
- en: We can see that there is a high level of interaction between the CAS server
    and the secured application, with several data exchange handshakes required before
    the trust of the user can be established. The result of this complexity is a single
    sign-on protocol that is quite hard to spoof through common techniques (assuming
    other network security precautions, such as the use of SSL and network monitoring,
    are in place).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，CAS服务器与安全应用程序之间有很高的交互性，在建立用户的信任之前需要进行几次数据交换握手。这种复杂性的结果是一个相当难以通过常见技术进行欺骗的单点登录协议（假设已经实施了其他网络安全措施，如使用SSL和网络监控）。
- en: Now that we understand how CAS authentication works in general, let's see how
    it applies to Spring Security.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了一般情况下CAS认证是如何工作的，现在让我们看看它如何应用于Spring Security。
- en: Spring Security and CAS
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security和CAS
- en: Spring Security has a strong integration capability with CAS, although it's
    not as tightly integrated into the security namespace style of configuration like
    the OAuth2 and LDAP integrations that we've explored thus far in the latter part
    of this book. Instead, much of the configuration relies on bean wiring and configuration
    by reference, from the security namespace elements to bean declarations.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security与CAS有很强的集成能力，尽管它不像我们在这本书的后半部分所探讨的OAuth2和LDAP集成那样紧密地集成在安全命名空间配置风格中。相反，大部分配置依赖于从安全命名空间元素到bean声明的bean导线和引用配置。
- en: 'The two basic pieces of CAS authentication when using Spring Security involve
    the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring Security进行CAS认证的两个基本部分包括以下内容：
- en: Replacement of the standard `AuthenticationEntryPoint` implementation, which
    typically handles redirection of unauthenticated users to the login page with
    an implementation that redirects the user to the CAS server instead
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换标准的`AuthenticationEntryPoint`实现，该实现通常处理将未认证的用户重定向到登录页面的操作，改为将用户重定向到CAS服务器。
- en: Processing the service ticket when the user is redirected back from the CAS
    server to the protected resource, through the use of a custom servlet filter
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理服务票证，当用户从CAS服务器重定向回受保护的资源时，通过使用自定义servlet过滤器
- en: An important thing to understand about CAS is that in typical deployments, CAS
    is intended to replace all of the alternative login mechanisms of your application.
    As such, once we configure CAS for Spring Security, our users must use CAS exclusively
    as an authentication mechanism to our application. In most cases, this is not
    a problem; as we discussed in the previous section, CAS is designed to proxy authentication
    requests to one or more authentication stores (similar to what Spring Security
    does when delegating to a database or LDAP for authentication). From the previous
    diagram, we can see that our application is no longer checking its own authentication
    store to validate users. Instead, it determines the user through the use of the
    service ticket. However, as we will discuss later, initially, Spring Security
    still needs a data store to determine the user's authorization. We will discuss
    how to remove this restriction later on in the chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 关于CAS的一个重要理解是，在典型的部署中，CAS旨在替代您应用程序的所有其他登录机制。因此，一旦我们为Spring Security配置了CAS，我们的用户必须将CAS作为唯一身份验证机制来使用。在大多数情况下，这并不是问题；如我们在上一节中讨论的，CAS旨在代理身份验证请求到一个或多个身份验证存储（类似于Spring
    Security委托数据库或LDAP进行身份验证时）。从之前的图表中，我们可以看到，我们的应用程序不再检查其自己的身份验证存储来验证用户。相反，它通过使用服务票证来确定用户。然而，如我们稍后讨论的，最初，Spring
    Security仍然需要一个数据存储来确定用户的授权。我们将在本章后面讨论如何移除这个限制。
- en: After completing the basic CAS integration with Spring Security, we can remove
    the login link from the home page and enjoy automatic redirection to CAS's login
    screen, where we attempt to access a protected resource. Of course, depending
    on the application, it can also be beneficial to still allow the user to explicitly
    log in (so that they can see customized content, and so on).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成与Spring Security的基本CAS集成后，我们可以从主页上删除登录链接，并享受自动重定向到CAS登录界面的便利，在此界面中我们尝试访问受保护的资源。当然，根据应用程序的不同，允许用户明确登录（以便他们可以看到自定义内容等）也可能很有好处。
- en: Required dependencies
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 必需的依赖项
- en: 'Before we got too far, we should ensure that our dependencies are updated.
    A list of the dependencies that we have added with comments about when they are
    needed can be seen, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进展太远之前，我们应该确保我们的依赖项已经更新。我们可以看到，以下是我们添加的依赖项列表，以及关于何时需要它们的注释：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Installing and configuring CAS
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和配置CAS
- en: CAS has the benefit of having an extremely dedicated team behind it that has
    done an excellent job of developing both quality software and accurate, straightforward
    documentation on how to use it. Should you choose to follow along with the examples
    in this chapter, you are encouraged to read the appropriate getting started manual
    for your CAS platform. You can find this manual at [https://apereo.github.io/cas/5.1.x/index.html](https://apereo.github.io/cas/5.1.x/index.html).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: CAS的好处之一是有一个非常 dedicated的团队，他们为开发高质量的软件和准确、简洁的文档做出了出色的job。如果您选择跟随本章中的示例，建议您阅读适合您CAS平台的入门手册。您可以在[https://apereo.github.io/cas/5.1.x/index.html](https://apereo.github.io/cas/5.1.x/index.html)找到此手册。
- en: In order to make integration as simple as possible, we have included a CAS server
    application for this chapter, which can be deployed in the Spring Tool Suite or
    in IntelliJ, along with the calendar application. For the examples in this chapter,
    we will assume that CAS is deployed at `https://localhost:9443/cas/` and the calendar
    application is deployed at `https://localhost:8443/`. In order to work, CAS requires
    the use of HTTPS. For detailed instructions on setting up HTTPS, refer to the
    Appendix, *Additional Reference Material*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使集成尽可能简单，我们为本章 included了一个CAS服务器应用程序，可以在Spring Tool Suite或IntelliJ中部署，还可以附带日历应用程序。本章中的示例将假设CAS部署在`https://localhost:9443/cas/`，日历应用程序部署在`https://localhost:8443/`。为了使CAS正常工作，必须使用HTTPS。关于设置HTTPS的详细说明，请参阅附录*附加参考资料*。
- en: The examples in this chapter were written using the most recent, available version
    of the CAS server, 5.1.2 at the time of writing. Be aware that some significant
    changes to some of the backend classes were made to CAS in the 5.x time frame.
    So, if you are on an earlier version of the server, these instructions may be
    slightly or significantly different for your environment.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例是使用最新的CAS服务器版本（写作时为5.1.2）编写的。请注意，在5.x版本中，对CAS的某些后端类进行了重大更改。因此，如果您使用的是服务器的前一个版本，这些说明可能会有所不同或显著不同。
- en: Let's go ahead and configure the components required for CAS authentication.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们配置用于CAS认证的组件。
- en: You should start the chapter off with the source from `chapter10.00-calendar`
    and `chapter10.00-cas-server`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该从`chapter10.00-calendar`和`chapter10.00-cas-server`开始章节，引入源代码。
- en: Configuring basic CAS integration
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置基本的CAS集成
- en: Since the Spring Security namespace does not support CAS configuration, there
    are quite a few more steps that we need to implement in order to get a basic setup
    working. In order to get a high-level understanding of what is happening, you
    can refer to the following diagram.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Spring Security命名空间不支持CAS配置，我们需要实现很多步骤才能让基本设置工作。为了了解发生了什么，你可以参考以下图表。
- en: 'Don''t worry about understanding the entire diagram right now, as we will break
    it into small chunks in order to make it easy to digest:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心现在就理解整个图表，因为我们将其分解成小块，以便更容易消化：
- en: '![](img/414892bb-05b4-4d94-9cf5-79ef506f42ac.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/414892bb-05b4-4d94-9cf5-79ef506f42ac.png)'
- en: Creating the CAS ServiceProperties object
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建CAS ServiceProperties对象
- en: 'The Spring Security setup relies on an `o.s.s.cas.ServiceProperties` bean in
    order to store common information about the CAS service. The `ServiceProperties`
    object plays a role in coordinating the data exchange between the various CAS
    components-it is used as a data object to store CAS configuration settings that
    are shared (and are expected to match) by the varying participants in the Spring
    CAS stack. You can view the configuration included in the following code snippet:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security设置依赖于一个`o.s.s.cas.ServiceProperties`bean来存储关于CAS服务的常见信息。`ServiceProperties`对象在协调各种CAS组件之间的数据交换中扮演角色-它被用作一个数据对象来存储共享的（并且预期是匹配的）Spring
    CAS堆栈中的各个参与者的CAS配置设置。你可以查看以下代码段中包含的配置：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You probably noticed that we leveraged system properties to use variables named
    `${cas.service}` and `${cas.server}`. Both of these values can be included in
    your application, and Spring will automatically replace them with the values provided
    in the `PropertySources` configuration. This is a common strategy when deploying
    a CAS service, since the CAS server will likely change as we progress from development
    to production. In this instance, we use `localhost:9443` by default for the CAS
    server and `localhost:8443` for the calendar application. This configuration can
    be overridden using a system argument when the application is taken to production.
    Alternatively, the configuration can be externalized into a Java properties files.
    Either mechanism allows us to externalize our configuration properly.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到了，我们利用系统属性使用了名为`${cas.service}`和`${cas.server}`的变量。这两个值都可以包含在你的应用程序中，Spring会自动将它们替换为在`PropertySources`配置中提供的值。这是一种常见的策略，当部署CAS服务时，由于CAS服务器很可能从开发环境过渡到生产环境，所以CAS服务器可能会发生变化。在这个实例中，我们默认使用`localhost:9443`作为CAS服务器，`localhost:8443`作为日历应用程序。当应用程序部署到生产环境时，可以通过系统参数来覆盖这个配置。另外，配置可以外部化到一个Java属性文件中。任一机制都允许我们适当外部化配置。
- en: Adding the CasAuthenticationEntryPoint object
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加CasAuthenticationEntryPoint对象
- en: 'As we briefly mentioned earlier in this chapter, Spring Security uses an `o.s.s.web.AuthenticationEntryPoint`
    interface to request credentials from the user. Typically, this involves redirecting
    the user to the login page. With CAS, we will need to redirect the CAS server
    to request a login. When we redirect to the CAS server, Spring Security must include
    a `service` parameter that indicates where the CAS server should send the service
    ticket. Fortunately, Spring Security provides the `o.s.s.cas.web.CasAuthenticationEntryPoint`
    object, which is specifically designed for this purpose. The configuration that
    is included in the sample application is as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章开头简要提到的，Spring Security使用一个`o.s.s.web.AuthenticationEntryPoint`接口来请求用户的凭据。通常，这涉及到将用户重定向到登录页面。对于CAS，我们需要将用户重定向到CAS服务器以请求登录。当我们重定向到CAS服务器时，Spring
    Security必须包含一个`service`参数，指示CAS服务器应该发送服务票证的位置。幸运的是，Spring Security提供了`o.s.s.cas.web.CasAuthenticationEntryPoint`对象，专门为此目的设计。示例应用程序中的配置如下：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `CasAuthenticationEntryPoint` object uses the `ServiceProperties` class
    to specify where to send the service ticket once the user is authenticated. CAS
    allows for the selective granting of access per user, per application, based on
    configuration. We''ll examine the particulars of this URL in a moment when we
    configure the servlet filter that is expected to process it. Next, we will need
    to update Spring Security to utilize the bean with the `casAuthenticationEntryPoint`
    ID. Make the following update to our `SecurityConfig.java` file:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`CasAuthenticationEntryPoint`对象使用`ServiceProperties`类来指定用户认证后要发送服务票据的位置。CAS允许根据配置对每个用户、每个应用程序进行选择性授权。我们将在配置处理该URL的servlet过滤器时立即检查这个URL的详细信息。接下来，我们需要更新Spring
    Security以使用具有`casAuthenticationEntryPoint` ID的bean。将以下内容更新到我们的`SecurityConfig.java`文件中：'
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Lastly, we need to ensure that the `CasConfig.java` file is loaded by Spring.
    Update the `SecurityConfig.java` file, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要确保`CasConfig.java`文件被Spring加载。更新`SecurityConfig.java`文件，如下所示：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The last thing you need to do is to remove the existing `UserDetailsService`
    object as the `userDetailsService` implementation of the `AuthenticationManager`,
    as it is no longer required as the `CasAuthenticationEntryPoint` replaces it in
    the SecurityConfig.java file:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的最后一件事是删除现有的`UserDetailsService`对象作为`AuthenticationManager`的`userDetailsService`实现，因为它不再需要，因为`CasAuthenticationEntryPoint`在`SecurityConfig.java`文件中取代了它：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you start the application at this point and attempt to access the My Events
    page, you will immediately be redirected to the CAS server for authentication.
    The default configuration of CAS allows authentication for any user whose username
    is equal to the password. So, you should be able to log in with the username `admin1@example.com`
    and the password `admin1@example.com` (or `user1@example.com`/`user1@example.com`).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个时候启动应用程序并尝试访问“我的事件”页面，你将会立即被重定向到CAS服务器进行认证。CAS的默认配置允许任何用户名与密码相等的用户进行认证。所以，你应该能够使用用户名`admin1@example.com`和密码`admin1@example.com`（或`user1@example.com`/`user1@example.com`）登录。
- en: You'll notice, however, that even after the login, you will immediately be redirected
    back to the CAS server. This is because although the destination application was
    able to receive the ticket, it wasn't able to be validated, and as such the `AccessDeniedException`
    object is handled by CAS as a rejection of the ticket.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你会注意到，即使在登录之后，你也会立即被重定向回CAS服务器。这是因为尽管目标应用程序能够接收到票据，但它无法进行验证，因此CAS将`AccessDeniedException`对象处理为对票据的拒绝。
- en: Proving authenticity with the CasAuthenticationProvider object
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CasAuthenticationProvider对象证明真实性
- en: If you have been following the logical flow of Spring Security throughout the
    rest of this book, hopefully, you already know what comes next-the `Authentication`
    token must be inspected by an appropriate `AuthenticationProvider` object. CAS
    is no different, and as such, the final piece of the puzzle is the configuration
    of an `o.s.s.cas.authentication.CasAuthenticationProvider` object within `AuthenticationManager`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直跟随本书中Spring Security的逻辑流程，那么你应该已经知道接下来会发生什么——`Authentication`令牌必须由一个适当的`AuthenticationProvider`对象进行检查。CAS也不例外，因此，这个谜题的最后一片拼图就是在`AuthenticationManager`内部配置一个`o.s.s.cas.authentication.CasAuthenticationProvider`对象。
- en: 'Let''s take a look at the following steps:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看以下步骤：
- en: 'First, we''ll declare the Spring bean in the `CasConfig.java` file, as follows:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将在`CasConfig.java`文件中声明Spring bean，如下所示：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we''ll configure a reference to this new `AuthenticationProvider` object
    in `SecurityConfig.java`, where our `AuthenticationManager` declaration resides:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在`SecurityConfig.java`文件中配置对新`AuthenticationProvider`对象的引用，该文件包含我们的`AuthenticationManager`声明：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you have any other `AuthenticationProvider` references remaining from prior
    exercises, please remember to remove them from work with CAS. All of these changes
    are illustrated in the preceding code. Now, we''ll need to take care of the other
    attributes and bean references within the `CasAuthenticationProvider` class. The
    `ticketValidator` attribute refers to an implementation of the `org.jasig.cas.client.validation.TicketValidator`
    interface; as we are using the CAS 3.0 authentication, we''ll declare an `org.jasig.cas.client.validation.Cas30ServiceTicketValidator`
    instance, as follows:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你之前练习中有任何其他`AuthenticationProvider`引用，请记得将它们与CAS一起移除。所有这些更改都在前面的代码中有所展示。现在，我们需要处理`CasAuthenticationProvider`类中的其他属性和bean引用。`ticketValidator`属性指的是`org.jasig.cas.client.validation.TicketValidator`接口的实现；由于我们使用的是CAS
    3.0认证，我们将声明一个`org.jasig.cas.client.validation.Cas30ServiceTicketValidator`实例，如下所示：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The constructor argument supplied to this class should refer (once again) to
    the URL used to access the CAS server. You'll note that at this point, we have
    moved out of the `org.springframework.security` package into `org.jasig`, which
    is part of the CAS client's JAR files. Later in this chapter, we'll see that the
    `TicketValidator` interface also has implementations (still within the CAS client's
    JAR files) that support other methods of authentication with CAS, such as the
    proxy ticket and SAML authentications.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类提供的构造参数应该（再次）指的是访问CAS服务器的URL。你会注意到，在这个阶段，我们已经从`org.springframework.security`包中移出，进入到`org.jasig`，这是CAS客户端JAR文件的一部分。在本章后面，我们将看到`TicketValidator`接口也有实现（仍在CAS客户端的JAR文件中），支持使用CAS的其他认证方法，例如代理票和SAML认证。
- en: Next, we can see the `key` attribute; this is simply used to validate the integrity
    of `UsernamePasswordAuthenticationToken` and can be arbitrarily defined.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以看到`key`属性；这个属性仅用于验证`UsernamePasswordAuthenticationToken`的完整性，可以任意定义。
- en: 'Just as we saw in [Chapter 8](09.html), *Client Certificate Authentication
    with TLS*, the `authenticationUserDetailsService` attribute refers to an `o.s.s.core.userdetails.AuthenticationUserDetailsService`
    object that is used to translate the username information from the `Authentication`
    token to a fully-populated `UserDetails` object. The current implementation does
    this translation by looking up the username returned by the CAS server and looking
    up `UserDetails` using the `UserDetailsService` object. Obviously, this technique
    would only ever be used when we have confirmed that the integrity of the `Authentication`
    token has not been compromised. We configure this object with a reference to our
    `CalendarUserDetailsService` implementation of the `UserDetailsService` interface:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第8章[《使用TLS的客户端证书认证》](09.html)中所看到的，`authenticationUserDetailsService`属性指的是一个`o.s.s.core.userdetails.AuthenticationUserDetailsService`对象，该对象用于将`Authentication`令牌中的用户名信息转换为完全填充的`UserDetails`对象。当前实现通过查找CAS服务器返回的用户名并使用`UserDetailsService`对象查找`UserDetails`来实现这一转换。显然，这种技术只有在确认`Authentication`令牌的完整性未被破坏时才会使用。我们将此对象配置为对我们`CalendarUserDetailsService`实现的`UserDetailsService`接口的引用：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You may wonder why a `UserDetailsService` interface isn't directly referenced;
    it's because, just as with OAuth2, there will be additional advanced configuration
    options later, which will allow details from the CAS server to be used to populate
    the `UserDetails` object.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会好奇为什么没有直接引用`UserDetailsService`接口；原因在于，正如OAuth2一样，之后将会有额外的先进配置选项，这将允许使用CAS服务器的信息来填充`UserDetails`对象。
- en: Your code should look like `chapter10.01-calendar` and `chapter10.01-cas-server`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码应该看起来像`chapter10.01-calendar`和`chapter10.01-cas-server`。
- en: At this point, we should be able to start both the CAS server and JBCP calendar
    application. You can then visit `https://localhost:8443/` and select All Events,
    which will redirect you to the CAS server. You can then log in using the username
    `admin1@example.com` and the password `admin1@example.com`. Upon successful authentication,
    you will be redirected back to the JBCP calendar application. Excellent job!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们应该能够启动CAS服务器和JBCP日历应用程序。然后你可以访问`https://localhost:8443/`，并选择所有事件，这将引导你到CAS服务器。之后你可以使用用户名`admin1@example.com`和密码`admin1@example.com`登录。验证成功后，你将被重定向回JBCP日历应用程序。干得好！
- en: If you are experiencing issues, it is most likely due to an improper SSL configuration.
    Ensure that you have set up the trust store file as `tomcat.keystore`, as described
    in the Appendix, *Additional reference Material*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到问题，很可能是由于不正确的SSL配置。请确保您已经按照附录中的*附加参考材料*所述设置了信任库文件为`tomcat.keystore`。
- en: Single logout
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单点登出
- en: You may notice that if you log out of the application, you get the logout confirmation
    page. However, if you click on a protected page, such as the My Events page, you
    are still authenticated. The problem is that the logout is only occurring locally.
    So, when you request another protected resource in the JBCP calendar application,
    a login is requested from the CAS server. Since the user is still logged in to
    the CAS server, it immediately returns a service ticket and logs the user back
    into the JBCP calendar application.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，如果您从应用程序中登出，会得到登出确认页面。然而，如果您点击受保护的页面，比如我的事件页面，您仍然会被认证。问题在于，登出仅在本地发生。所以，当您请求JBCP日历应用程序中的另一个受保护资源时，会从CAS服务器请求登录。由于用户仍然登录到CAS服务器，它会立即返回一个服务票据，并将用户重新登录到JBCP日历应用程序。
- en: 'This also means that if the user had signed in to other applications using
    the CAS server, they would still be authenticated to those applications, since
    our calendar application does not know anything about the other applications.
    Fortunately, CAS and Spring Security offer a solution to this problem. Just as
    we can request a login from the CAS server, we can also request a logout. You
    can see a high-level diagram of how a logout works within CAS, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这也就意味着，如果用户已经通过CAS服务器登录了其他应用程序，由于我们的日历应用程序不知道其他应用程序的情况，他们仍然会对那些应用程序进行身份验证。幸运的是，CAS和Spring
    Security为这个问题提供了一个解决方案。正如我们可以从CAS服务器请求登录一样，我们也可以请求登出。您可以看到以下关于在CAS中登出工作方式的的高级示意图：
- en: '![](img/987b97c6-e600-405e-a800-648ca3f400c4.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/987b97c6-e600-405e-a800-648ca3f400c4.png)'
- en: 'The following steps explain how a single logout takes place:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤解释了单点登出是如何进行的：
- en: The user requests to log out of the web application.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户请求从Web应用程序登出。
- en: The web application then requests to log out of CAS by sending a redirect through
    the browser to the CAS server.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后Web应用程序通过浏览器重定向到CAS服务器，请求登出CAS。
- en: The CAS server recognizes the user and then sends a logout request to each CAS
    service that was authenticated. Note that these logout requests do not occur through
    the browser.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CAS服务器识别用户，然后向每个已认证的CAS服务发送登出请求。请注意，这些登出请求不是通过浏览器发生的。
- en: The CAS server indicates which user should log out by providing the original
    service ticket that was used to log the user in. The application is then responsible
    for ensuring that the user is logged out.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CAS服务器通过提供原始的服务票据来指示哪个用户应该登出，该票据用于登录用户。然后应用程序负责确保用户登出。
- en: The CAS server displays the logout success page to the user.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CAS服务器向用户显示登出成功页面。
- en: Configuring single logout
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置单点登出
- en: 'The configuration for a single logout is relatively simple:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 单点登出的配置相对简单：
- en: 'The first step is to specify a `logout-success-url` attribute to be the logout
    URL of the CAS server in our `SecurityConfig.java` file. This means that after
    we log out locally, we will automatically redirect the user to the CAS server''s
    logout page:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是在我们的`SecurityConfig.java`文件中指定一个`logout-success-url`属性，该属性是CAS服务器的登出URL。这意味着在本地登出后，我们将自动将用户重定向到CAS服务器的登出页面：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Since we only have one application, this is all we need to make it appear as
    though a single logout is occurring. This is because we log out of our calendar
    application before redirecting to the CAS server logout page. This means that
    by the time the CAS server sends the logout request to the calendar application,
    the user has already been logged out.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只有一个应用程序，所以这是我们需要的，以使看起来像是在发生单点登出。这是因为我们在重定向到CAS服务器登出页面之前已经从我们的日历应用程序中登出。这意味着当CAS服务器将登出请求发送给日历应用程序时，用户已经登出了。
- en: 'If there were multiple applications and the user logged out of another application,
    the CAS server would send a logout request to our calendar application and not
    process the logout event. This is because our application is not listening to
    these logout events. The solution is simple; we must create the `SingleSignoutFilter`
    object, as follows:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有多个应用程序，用户从另一个应用程序登出，CAS服务器会将登出请求发送给我们的日历应用程序，而不会处理登出事件。这是因为我们的应用程序没有监听这些登出事件。解决方案很简单；我们必须创建一个`SingleSignoutFilter`对象，如下所示：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we need to make Spring Security aware of the `singleLogoutFilter` object
    in our `SecurityCOnfig.java` file by including it as a `<custom-filter>` element.
    Place the single logout filter before the regular logout to ensure that it receives
    the logout events, as follows:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要让Spring Security意识到我们`SecurityCOnfig.java`文件中的`singleLogoutFilter`对象，通过将其作为`<custom-filter>`元素包括在内。将单次登出过滤器放在常规登出之前，以确保它接收到登出事件，如下所示：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Under normal circumstances, we would need to make a few updates to the `web.xml`
    or `ApplicationInitializer` file. However, for our calendar application, we have
    already made the updates to our `CasConfig.java` file, as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在正常情况下，我们需要对`web.xml`或`ApplicationInitializer`文件进行一些更新。然而，对于我们的日历应用程序，我们已经对我们的`CasConfig.java`文件进行了更新，如下所示：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: First, we added the `SingleSignoutHttpSessionListener` object to ensure that
    the mapping of the service ticket to `HttpSession` was removed. We have also added
    `CharacterEncodingFilter`, as recommended by the JA-SIG documentation, to ensure
    that character encoding is correct when using `SingleSignOutFilter`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加了`SingleSignoutHttpSessionListener`对象，以确保删除服务票证与`HttpSession`的映射。我们还添加了`CharacterEncodingFilter`，正如JA-SIG文档所推荐的那样，以确保在使用`SingleSignOutFilter`时字符编码正确。
- en: Go ahead and start up the application and try logging out now. You will observe
    that you are actually logged out.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续启动应用程序并尝试登出。你会观察到你实际上已经登出了。
- en: Now, try logging back in and visiting the CAS server's logout URL directly.
    For our setup, the URL is `https://localhost:9443/cas/logout`.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试重新登录并直接访问CAS服务器的登出URL。对于我们设置，URL是`https://localhost:9443/cas/logout`。
- en: Now, try to visit the JBCP calendar application. You will observe that you are
    unable to access the application without authenticating again. This demonstrates
    that a single logout works.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试访问JBCP日历应用程序。你会观察到，在没有重新认证的情况下，你无法访问该应用程序。这证明了单次登出是有效的。
- en: Your code should look like `chapter10.02-calendar` and `chapter10.02-cas-server`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码应该看起来像`chapter10.02-calendar`和`chapter10.02-cas-server`。
- en: Clustered environments
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集群环境
- en: 'One of the things that we failed to mention in our initial diagram of a single
    logout was how the logout is performed. Unfortunately, it is implemented by storing
    a mapping of the service ticket to `HttpSession` as an in-memory map. This means
    that a single logout will not work properly within a clustered environment:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有在单次登出初始图中提到的一件事是如何执行登出。不幸的是，它是通过将服务票证与`HttpSession`的映射作为内存映射存储来实现的。这意味着在集群环境中，单次登出将无法正确工作：
- en: '![](img/20770234-2dc4-410c-9237-c5481f56a004.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/20770234-2dc4-410c-9237-c5481f56a004.png)'
- en: 'Consider the following situation:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下情况：
- en: The user logs in to **Cluster Member A**
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户登录到**集群成员A**
- en: '**Cluster Member A** validates the service ticket'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集群成员A**验证服务票证'
- en: It then remembers, in memory, the mapping of the service ticket to the user's
    session
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，在内存中记住服务票证与用户会话的映射
- en: The user requests to log out from the **CAS Server**
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户请求从**CAS服务器**登出
- en: The **CAS Server** sends a logout request to the CAS service, but the **Cluster
    Member B** receives the logout request. It looks in its memory but does not find
    a session for **Service Ticket A**, because it only exists in **Cluster Member
    A**. This means, the user has not been logged out successfully.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**CAS服务器**向CAS服务发送登出请求，但**集群成员B**接到了登出请求。它在它的内存中查找，但没有找到**服务票证A**的会话，因为它只存在于**集群成员A**中。这意味着，用户没有成功登出。'
- en: Users looking for this functionality might consider looking in the JA-SIG JIRA
    queue and forums for solutions to this problem. In fact, a working patch has been
    submitted on [https://issues.jasig.org/browse/CASC-114](https://issues.jasig.org/browse/CASC-114).
    Keep in mind that there are a number of ongoing discussions and proposals on the
    forums and in the JA-SIG JIRA queue, so you may want to look around before deciding
    which solution to use. For more information about clustering with CAS, refer to
    JA-SIG's clustering documentation at [https://wiki.jasig.org/display/CASUM/Clustering+CAS](https://wiki.jasig.org/display/CASUM/Clustering+CAS).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 寻求此功能的用户可能需要查看JA-SIG JIRA队列和论坛中解决此问题的方案。实际上，一个工作补丁已经提交到了[https://issues.jasig.org/browse/CASC-114](https://issues.jasig.org/browse/CASC-114)。记住，论坛和JA-SIG
    JIRA队列中有许多正在进行讨论和提案，所以在决定使用哪个解决方案之前，你可能想要四处看看。关于与CAS的集群，请参考JA-SIG在[https://wiki.jasig.org/display/CASUM/Clustering+CAS](https://wiki.jasig.org/display/CASUM/Clustering+CAS)的集群文档。
- en: Proxy ticket authentication for stateless services
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无状态服务的代理票证认证
- en: 'Centralizing our authentication using CAS seems to work rather well for web
    applications, but what if we want to call a web service using CAS? In order to
    support this, CAS has a notion of **proxy tickets** (**PT**). The following is
    a diagram of how it works:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CAS集中我们的认证似乎很适合web应用程序，但如果我们想使用CAS调用web服务呢？为了支持这一点，CAS有一个代理票证（**PT**）的概念。以下是它如何工作的图表：
- en: '![](img/21b96476-c1df-42b1-8cc2-01f250b3fe4a.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21b96476-c1df-42b1-8cc2-01f250b3fe4a.png)'
- en: 'The flow is the same as standard CAS authentication until the following things
    take place:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 流程与标准的CAS认证流程相同，直到以下事情发生：
- en: The **Service Ticket** is validated when an additional parameter is included
    called the proxy ticket callback URL (**PGT URL**).
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当包含一个额外参数时，**服务票证**被验证，这个参数叫做代理票证回调URL（**PGT URL**）。
- en: The **CAS Server** calls the **PGT URL** over **HTTPS** to validate that the
    **PGT URL** is what it claims to be. Like most of CAS, this is done by performing
    an SSL handshake to the appropriate URL.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**CAS服务器**通过**HTTPS**调用**PGT URL**来验证**PGT URL**是否如它所声称的那样。像大多数CAS一样，这是通过与适当URL执行SSL握手来完成的。'
- en: The **CAS Server** submits the **Proxy Granting Ticket** (**PGT**) and the **Proxy
    Granting Ticket I Owe You** (**PGTIOU**) to the **PGT URL** over **HTTPS** to
    ensure that the tickets are submitted to the source they claim to be.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**CAS服务器**提交**代理授权票**（**PGT**）和**代理授权票我欠你**（**PGTIOU**）到**PGT URL**，通过**HTTPS**确保票证提交到它们声称的来源。'
- en: The **PGT URL** receives the two tickets and must store an association of the
    **PGTIOU** to the **PGT**.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**PGT URL**接收到两个票证，并必须存储**PGTIOU**与**PGT**的关联。'
- en: The **CAS Server** finally returns a response to the request in *step 1* that
    includes the username and the **PGTIOU**.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**CAS服务器**最终在*步骤1*中返回一个响应，其中包括用户名和**PGTIOU**。'
- en: The CAS service can look up the **PGT** using the **PGTIOU**.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CAS服务可以使用**PGTIOU**查找**PGT**。
- en: Configuring proxy ticket authentication
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置代理票证认证
- en: 'Now that we know how PT authentication works, we will update our current configuration
    to obtain a PGT by performing the following steps:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道PT认证是如何工作的，我们将更新我们当前的配置，通过执行以下步骤来获取PGT：
- en: 'The first step is to add a reference to a `ProxyGrantingTicketStorage` implementation.
    Go ahead and add the following code to our `CasConfig.java` file:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是添加一个对`ProxyGrantingTicketStorage`实现的引用。接着，在我们的`CasConfig.java`文件中添加以下代码：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `ProxyGrantingTicketStorageImpl` implementation is an in-memory mapping
    of the PGTIOU to a PGT. Just as with logging out, this means we would have problems
    in a clustered environment using this implementation. Refer to the JA-SIG documentation
    to determine how to set this up in a clustered environment: [https://wiki.jasig.org/display/CASUM/Clustering+CAS.](https://wiki.jasig.org/display/CASUM/Clustering+CAS)'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ProxyGrantingTicketStorageImpl`实现是一个内存中映射，将PGTIOU映射到PGT。正如登出时一样，这意味着在集群环境中使用此实现会有问题。参考JA-SIG文档，确定如何在集群环境中设置：`[https://wiki.jasig.org/display/CASUM/Clustering+CAS](https://wiki.jasig.org/display/CASUM/Clustering+CAS)`'
- en: We also need to periodically clean `ProxyGrantingTicketStorage` by invoking
    its `cleanUp()` method. As you can see, Spring's task abstraction makes this very
    simple. You may consider tweaking the configuration to clear the `Ticket`'s, in
    a separate a thread pool that makes sense for your environment. For more information,
    refer to the *Task Execution* and *Scheduling* section of the Spring Framework
    Reference documentation at [http://static.springsource.org/spring/docs/current/spring-framework-reference/html/scheduling.html](http://static.springsource.org/spring/docs/current/spring-framework-reference/html/scheduling.html).
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要定期通过调用其`cleanUp()`方法来清理`ProxyGrantingTicketStorage`。正如你所看到的，Spring的任务抽象使这非常简单。你可以考虑调整配置，清除`Ticket`在一个适合你环境的单独线程池中。更多信息，请参考Spring框架参考文档中*任务执行*和*调度*部分：[http://static.springsource.org/spring/docs/current/spring-framework-reference/html/scheduling.html](http://static.springsource.org/spring/docs/current/spring-framework-reference/html/scheduling.html)。
- en: 'Now we need to use `ProxyGrantingTicketStorage`, which we have just created.
    We just need to update the `ticketValidator` method to refer to our storage and
    to know the PGT URL. Make the following updates to `CasConfig.java`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要使用我们刚刚创建的`ProxyGrantingTicketStorage`。我们只需要更新`ticketValidator`方法，使其引用我们的存储并知道PGT
    URL。对`CasConfig.java`进行以下更新：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The last update we need to make is to our `CasAuthenticationFilter` object,
    to store the PGTIOU to the PGT mapping in our `ProxyGrantingTicketStorage` implementation
    when the PGT URL is called. It is critical to ensure that the `proxyReceptorUrl`
    attribute matches the `proxyCallbackUrl` attribute of the `Cas20ProxyTicketValidator`
    object, to ensure that the CAS server sends the ticket to the URL that our application
    is listing to. Make the following changes to `security-cas.xml`:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的最后更新是我们的`CasAuthenticationFilter`对象，当PGT URL被调用时，将PGTIOU存储到PGT映射中我们的`ProxyGrantingTicketStorage`实现。确保`proxyReceptorUrl`属性与`Cas20ProxyTicketValidator`对象的`proxyCallbackUrl`属性相匹配，以确保CAS服务器将票证发送到我们的应用程序正在监听的URL。在`security-cas.xml`中进行以下更改：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now that we have a PGT, what do we do with it? A service ticket is a one-time
    use token. However, a PGT can be used to produce PT. Let's see how we can create
    a PT using a PGT.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了一个PGT，我们该怎么办呢？服务票证是一次性使用的令牌。然而，PGT可以用来生成PT。让我们看看我们可以如何使用PGT创建一个PT。
- en: You will observe that the `proxyCallBackUrl` attribute matches the absolute
    path of our context-relative `proxyReceptorUrl` attribute path. Since we are deploying
    our base application to `https://${cas.service }/`, the full path of our `proxyReceptor`
    URL will be `https://${cas.service }/pgtUrl`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到`proxyCallBackUrl`属性与我们的上下文相关`proxyReceptorUrl`属性的绝对路径相匹配。由于我们将我们的基本应用程序部署到`https://${cas.service
    }/`，我们`proxyReceptor` URL的完整路径将是`https://${cas.service }/pgtUrl`。
- en: Using proxy tickets
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用代理票证
- en: 'We can now use our PGT to create a PT to authenticate it to a service. The
    code to do this is quite trivially demonstrated in the `EchoController` class
    that we have included with this chapter. You can see the relevant portions of
    it in the following code snippet. For additional details, refer to the sample''s
    source code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用我们的PGT创建一个PT来验证它对一个服务。这个操作在本书中包含的`EchoController`类中非常简单地演示了。您可以在以下代码片段中看到相关的部分。有关更多详细信息，请参阅示例的源代码：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This controller is a contrived example that will obtain a PT that will be used
    to authenticate a RESTful call to obtain all of the events for the currently logged-in
    user. It then writes the JSON response to the page. The thing that may confuse
    some users is that the `EchoController` object is actually making a RESTful call
    to the `MessagesController` object that is in the same application. This means
    that the calendar application makes a RESTful call to itself[.](https://localhost:8443/calendar/rest-client)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个控制器是一个构造的例子，它将获取一个PT，用于验证对当前登录用户的所有事件进行RESTful调用的请求。然后它将JSON响应写入页面。让一些用户感到困惑的是，`EchoController`对象实际上正在对同一应用程序中的`MessagesController`对象进行RESTful调用。这意味着日历应用程序对自己进行RESTful调用[。](https://localhost:8443/calendar/rest-client)
- en: Go ahead and visit `https://localhost:8443/echo` to see it in action. The page
    looks a lot like the CAS login page (minus the CSS). This is because the controller
    attempts to echo our My Events page, and our application does not yet know how
    to authenticate a PT. This means it is redirected to the CAS login page. Let's
    see how we can authenticate proxy tickets.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 大胆地访问`https://localhost:8443/echo`来看它的实际效果。这个页面看起来很像CAS登录页面（除了CSS）。这是因为控制器试图回显我们的“我的事件”页面，而我们的应用程序还不知道如何验证PT。这意味着它被重定向到CAS登录页面。让我们看看我们如何可以验证代理票证。
- en: Your code should look like `chapter10.03-calendar` and `chapter10.03-cas-server`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码应该看起来像`chapter10.03-calendar`和`chapter10.03-cas-server`。
- en: Authenticating proxy tickets
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证代理票证
- en: 'Let''s take a look at the following steps to learn about authenticating proxy
    tickets:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看以下步骤，了解验证代理票证的方法：
- en: 'We first need to tell the `ServiceProperties` object that we want to authenticate
    all of the tickets and not just those submitted to the `filterProcessesUrl` attribute.
    Make the following updates to `CasConfig.java`:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先需要告诉`ServiceProperties`对象我们希望验证所有票证，而不仅仅是那些提交到`filterProcessesUrl`属性的票证。对`CasConfig.java`进行以下更新：
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We then need to update our `CasAuthenticationFilter` object for it to know
    that we want to authenticate all artifacts (that is, tickets) instead of only
    listening to a specific URL. We also need to use an `AuthenticationDetailsSource`
    interface that can dynamically provide the CAS service URL when validating proxy
    tickets on arbitrary URLs. This is important because when a CAS service asks whether
    a ticket is valid or not, it must also provide the CAS service URL that was used
    to create the ticket. Since proxy tickets can occur at any URL, we must be able
    to dynamically discover this URL. This is done by leveraging the `ServiceAuthenticationDetailsSource`
    object, which will provide the current URL from the HTTP request:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们需要更新我们的`CasAuthenticationFilter`对象，使其知道我们希望认证所有工件（即，票证）而不是只监听特定的URL。我们还需要使用一个`AuthenticationDetailsSource`接口，当在任意URL上验证代理票证时，可以动态提供CAS服务URL。这是因为当一个CAS服务询问票证是否有效时，它也必须提供创建票证所用的CAS服务URL。由于代理票证可以发生在任何URL上，我们必须能够动态发现这个URL。这是通过利用`ServiceAuthenticationDetailsSource`对象来完成的，它将提供HTTP请求中的当前URL：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We will also need to ensure that we are using the `Cas30ProxyTicketValidator`
    object and not the `Cas30ServiceTicketValidator` implementation, and indicate
    which proxy tickets we will want to accept. We will configure ours to accept a
    proxy ticket from any CAS service. In a production environment, you will want
    to consider restricting yourself to only those CAS services that are trusted:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要确保我们使用的是`Cas30ProxyTicketValidator`对象，而不是`Cas30ServiceTicketValidator`实现，并指出我们想要接受哪些代理票证。我们将配置我们的接受来自任何CAS服务的代理票证。在生产环境中，您可能希望考虑只限制那些可信的CAS服务：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Lastly, we will want to provide a cache for our `CasAuthenticationProvider`
    object so that we do not need to hit the CAS service for every call to our service:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们希望能够为我们的`CasAuthenticationProvider`对象提供一个缓存，这样我们就不需要为每个服务调用而访问CAS服务：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you might have suspected, the cache requires the `ehcache` dependency that
    we mentioned at the beginning of the chapter. Go ahead and start the application
    back up and visit `https://localhost:8443/echo` again. This time, you should see
    a JSON response to calling our My Events page.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如您可能已经猜到的那样，缓存需要我们章节开头提到的`ehcache`依赖。接着重新启动应用程序，并再次访问`https://localhost:8443/echo`。这次，您应该看到一个JSON响应，响应我们的事件页面调用。
- en: Your code should look like `chapter10.04-calendar` and `chapter10.04-cas-server`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码应该看起来像`chapter10.04-calendar`和`chapter10.04-cas-server`。
- en: Customizing the CAS server
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定制CAS服务器
- en: All of the changes in this section will be to the CAS server and not the calendar
    application. This section is only meant to be an introduction to configuring the
    CAS server, as a detailed setup is certainly beyond the scope of this book. Just
    as with the changes for the calendar application, we encourage you to follow along
    with the changes in this chapter. For more information, you can refer to the JA-SIG
    CAS Wikipedia page at [https://wiki.jasig.org/display/CAS/Home](https://wiki.jasig.org/display/CAS/Home).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的所有更改都将是针对CAS服务器，而不是日历应用程序。本节仅旨在介绍配置CAS服务器的入门，因为详细的设置确实超出了本书的范围。正如日历应用程序的更改一样，我们鼓励您跟随本章中的更改。更多信息，您可以参考JA-SIG
    CAS维基百科页面在[https://wiki.jasig.org/display/CAS/Home](https://wiki.jasig.org/display/CAS/Home)。
- en: CAS WAR overlay
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CAS WAR覆盖
- en: The preferred way to customize CAS is to use a Maven or Gradle War overlay.
    With this mechanism, you can change everything from the UI to the method in which
    you authenticate to the CAS server. The concept of a WAR overlay is simple. You
    add a WAR overlay, `cas-server-webapp`, as a dependency, and then provide additional
    files that will be merged with the existing WAR overlay. For more information
    about the CAS WAR overlay, refer to the JA-SIG documentation at [https://wiki.jasig.org/display/CASUM/Best+Practice+-+Setting+Up+CAS+Locally+using+the+Maven2+WAR+Overlay+Method](https://wiki.jasig.org/display/CASUM/Best+Practice+-+Setting+Up+CAS+Locally+using+the+Maven2+WAR+Overlay+Method).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 定制CAS的首选方式是使用Maven或Gradle War覆盖。通过这种机制，您可以从UI到认证CAS服务的方法改变一切。WAR覆盖的概念很简单。您添加一个WAR覆盖`cas-server-webapp`作为一个依赖，然后提供额外的文件，这些文件将与现有的WAR覆盖合并。有关关于CAS
    WAR覆盖的更多信息，请参考JA-SIG文档在[https://wiki.jasig.org/display/CASUM/Best+Practice+-+Setting+Up+CAS+Locally+using+the+Maven2+WAR+Overlay+Method](https://wiki.jasig.org/display/CASUM/Best+Practice+-+Setting+Up+CAS+Locally+using+the+Maven2+WAR+Overlay+Method)。
- en: How does the CAS internal authentication work?
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CAS内部认证是如何工作的？
- en: 'Before we jump into CAS configuration, we''ll briefly illustrate the standard
    behavior of CAS authentication processing. The following diagram should help you
    follow the configuration steps required to allow CAS to talk to our embedded LDAP
    server:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论CAS配置之前，我们将简要说明CAS认证处理的标准行为。以下图表应帮助你理解允许CAS与我们的内置LDAP服务器通信所需的配置步骤：
- en: '![](img/90ac09bd-55dd-43ed-bc1d-5d6ce644b782.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90ac09bd-55dd-43ed-bc1d-5d6ce644b782.png)'
- en: While the previous diagram describes the internal flow of authentication within
    the CAS server itself, it is likely that if you are implementing integration between
    Spring Security and CAS, you will need to adjust the configuration of the CAS
    server as well. It's important, therefore, that you understand how CAS authentication
    works at a high level.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然之前的图表描述了CAS服务器本身内部认证的流程，但如果你正在实现Spring Security和CAS之间的集成，你可能需要调整CAS服务器的配置。因此，理解CAS认证的高级工作原理是很重要的。
- en: The CAS server's `org.jasig.cas.authentication.AuthenticationManager` interface
    (not to be confused with the Spring Security interface of the same name) is responsible
    for authenticating the user based on the provided credentials. Much as with Spring
    Security, the actual processing of the credentials is delegated to one (or more)
    processing class implementing the `org.jasig.cas.authentication.handler.AuthenticationHandler`
    interface (we recognize that the analogous interface in Spring Security would
    be `AuthenticationProvider`).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: CAS服务器的`org.jasig.cas.authentication.AuthenticationManager`接口（不要与Spring Security中同名的接口混淆）负责根据提供的凭据对用户进行认证。与Spring
    Security类似，凭据的实际处理委托给一个（或多个）实现`org.jasig.cas.authentication.handler.AuthenticationHandler`接口的处理类（我们认识到Spring
    Security中相应的接口是`AuthenticationProvider`）。
- en: Finally, a `org.jasig.cas.authentication.principal.CredentialsToPrincipalResolver`
    interface is used to translate the credentials passed into a full `org.jasig.cas.authentication.principal.Principal`
    object (similar behavior in Spring Security occurs during the implementation of
    `UserDetailsService`).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`org.jasig.cas.authentication.principal.CredentialsToPrincipalResolver`接口用于将传入的凭据转换为完整的`org.jasig.cas.authentication.principal.Principal`对象（在Spring
    Security中实现`UserDetailsService`时，会有类似的行为）。
- en: While not a full review of the behind-the-scenes functionality of the CAS server,
    this should help you understand the configuration steps in the next several exercises.
    We encourage you to read the source code for CAS and consult the web-based documentation
    available at the JA-SIG CAS Wikipedia page at [http://www.ja-sig.org/wiki/display/CAS](http://www.ja-sig.org/wiki/display/CAS).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是对CAS服务器后台功能的全面回顾，但这应该能帮助你理解接下来的几个练习中的配置步骤。我们鼓励你阅读CAS的源代码，并参考在JA-SIG CAS维基百科页面上的网络文档，网址为[http://www.ja-sig.org/wiki/display/CAS](http://www.ja-sig.org/wiki/display/CAS)。
- en: Configuring CAS to connect to our embedded LDAP server
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置CAS以连接到我们的内置LDAP服务器。
- en: The `org.jasig.cas.authentication.principal.UsernamePasswordCredentialsToPrincipalResolver`
    object that comes configured, by default, with CAS doesn't allow us to pass back
    attribute information and demonstrate this feature of Spring Security CAS integration,
    so we'd suggest using an implementation that does allow this.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 默认配置的`org.jasig.cas.authentication.principal.UsernamePasswordCredentialsToPrincipalResolver`对象不允许我们返回属性信息并展示Spring
    Security CAS集成的这一特性，因此我们建议使用一个允许这样做的实现。
- en: An easy authentication handler to configure and use (especially if you have
    gone through the previous chapter's LDAP exercises) is `org.jasig.cas.adaptors.ldap.BindLdapAuthenticationHandler`,
    which communicates with the embedded LDAP server that we used in the previous
    chapter. We'll lead you through the configuration of CAS that returns user LDAP
    attributes in the following guide.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经完成了上一章的LDAP练习，那么配置和使用一个简单的认证处理程序（尤其是`org.jasig.cas.adaptors.ldap.BindLdapAuthenticationHandler`）会很容易，它与我们在上一章中使用的内置LDAP服务器通信。我们将引导你通过配置CAS，使其在以下指南中返回用户LDAP属性。
- en: All of the CAS configuration will take place in the `WEB-INF/deployerConfigContext.xml`
    file of the CAS installation, and will typically involve inserting class declarations
    into configuration file segments that already exist. We have already extracted
    the default `WEB-INF/deployerConfigContext.xml` file from `cas-server-webapp`
    and placed it in `cas-server/src/main/webapp/WEB-INF`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的CAS配置都将在CAS安装的`WEB-INF/deployerConfigContext.xml`文件中进行，通常涉及将类声明插入到已经存在的配置文件段中。我们已经从`cas-server-webapp`中提取了默认的`WEB-INF/deployerConfigContext.xml`文件，并将其放在了`cas-server/src/main/webapp/WEB-INF`中。
- en: If the contents of this file look familiar to you, it's because CAS uses the
    Spring Framework for its configuration just like the JBCP calendar! We'd recommend
    using a good IDE with a handy reference to the CAS source code if you want to
    dig into what these configuration settings do. Remember that in this section,
    and all sections where we refer to `WEB-INF/deployerConfigContext.xml`, we are
    referring to the CAS installation and not JBCP calendar.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这份文件的内容对你来说很熟悉，那是因为CAS像JBCP日历一样，也是使用Spring框架来进行配置的。我们建议如果你想要深入理解这些配置设置是如何工作的，最好使用一个好的IDE并且有一个方便的CAS源代码参考。记住，在本节以及所有引用到`WEB-INF/deployerConfigContext.xml`的部分，我们指的是CAS安装，而不是JBCP日历。
- en: 'Let''s take a look at the following steps:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看以下步骤：
- en: First, we'll add a new `BindLdapAuthenticationHandler` object in place of the
    `SimpleTestUsernamePasswordAuthenticationHandler` object, which will attempt to
    bind the user to LDAP (just as we did in [Chapter 6](07.html), *LDAP Directory
    Services*).
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将在`SimpleTestUsernamePasswordAuthenticationHandler`对象的位置添加一个新的`BindLdapAuthenticationHandler`对象，该对象将尝试将用户绑定到LDAP（正如我们在[第6章](07.html)，*LDAP目录服务*中所做的那样）。
- en: 'The `AuthenticationHandler` interface will be placed in the `authenticationHandlers`
    property of the `authenticationManager` bean:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AuthenticationHandler`接口将被放置在`authenticationManager`bean的`authenticationHandlers`属性中：'
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Don't forget to remove the reference to the `SimpleTestUsernamePasswordAuthenticationHandler`
    object, or at least move its definition to after that of the `BindLdapAuthenticationHandler`
    object, otherwise, your CAS authentication will not use LDAP and use the stub
    handler instead!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了删除对`SimpleTestUsernamePasswordAuthenticationHandler`对象的引用，或者至少将其定义移到`BindLdapAuthenticationHandler`对象之后，否则，你的CAS认证将不会使用LDAP，而是使用代理处理器！
- en: 'You''ll notice the bean reference to a `contextSource` bean; this defines the
    `org.springframework.ldap.core.ContextSource` implementation, which CAS will use
    to interact with LDAP (yes, CAS uses Spring LDAP as well). We''ll define this
    at the end of the file using the Spring Security namespace to simplify its definition,
    as follows:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会注意到对一个`contextSource`bean的引用；这定义了`org.springframework.ldap.core.ContextSource`实现，CAS将使用它来与LDAP进行交互（是的，CAS也使用Spring
    LDAP）。我们将在文件的末尾使用Spring Security命名空间来简化其定义，如下所示：
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This creates an embedded LDAP instance that uses the `calendar.ldif` file included
    with this chapter. Of course, in a production environment, you would want to point
    to a real LDAP server.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个使用随本章提供的`calendar.ldif`文件的嵌入式LDAP实例。当然，在生产环境中，你希望指向一个真实的LDAP服务器。
- en: Finally, we'll need to configure a new `org.jasig.cas.authentication.principal.CredentialsToPrincipalResolver`
    object. This is responsible for translating the credentials that the user has
    provided (that CAS has already authenticated using the `BindLdapAuthenticationHandler`
    object) into a full `org.jasig.cas.authentication.principal.Principal` authenticated
    principal. You'll notice many configuration options in this class, which we'll
    skim over. You are welcome to dive into them as you explore CAS further.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要配置一个新的`org.jasig.cas.authentication.principal.CredentialsToPrincipalResolver`对象。这个对象负责将用户提供的凭据（CAS已经使用`BindLdapAuthenticationHandler`对象进行认证的）翻译成一个完整的`org.jasig.cas.authentication.principal.Principal`认证主体。你会注意到这个类中有许多配置选项，我们将略过它们。当你深入探索CAS时，你可以自由地研究它们。
- en: 'Remove `UsernamePasswordCredentialsToPrincipalResolver` and add the following
    bean definition inline to the `credentialsToPrincipalResolvers` property of the
    CAS `authenticationManager` bean:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`UsernamePasswordCredentialsToPrincipalResolver`，并向CAS`authenticationManager`bean的`credentialsToPrincipalResolvers`属性中添加以下内联bean定义：
- en: '[PRE25]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You'll notice that, as with the Spring Security LDAP configuration, much of
    the same behavior exists in CAS with principals being searched on property matches
    below a subtree of the directory, based on a DN.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，与Spring Security LDAP配置一样，CAS中有很多同样的行为，原则是基于DN在目录的子树下基于属性匹配进行搜索。
- en: Note that we haven't yet configured the bean with the ID `attributeRepository`
    ourselves, which should refer to an implementation of `org.jasig.services.persondir.IPersonAttributeDao`.
    CAS ships with a default configuration that includes a simple implementation of
    this interface, `org.jasig.services.persondir.support.StubPersonAttributeDao`,
    which will be sufficient until we configure LDAP-based attributes in a later exercise.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们尚未亲自为ID为`attributeRepository`的bean配置，这应该指的是`org.jasig.services.persondir.IPersonAttributeDao`的一个实现。CAS随带有一个默认配置，其中包括这个接口的一个简单实现`org.jasig.services.persondir.support.StubPersonAttributeDao`，这将足以直到我们在后面的练习中配置基于LDAP的属性。
- en: Your code should look like `chapter10.05-calendar` and `chapter10.05-cas-server`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码应该看起来像`chapter10.05-calendar`和`chapter10.05-cas-server`。
- en: So, now we've configured basic LDAP authentication in CAS. At this point, you
    should be able to restart CAS, start JBCP calendar (if it's not already running),
    and authenticate it using `admin1@example.com`/`admin` or `user1@example.com/user1`.
    Go ahead and try it to see that it works. If it does not work, try checking the
    logs and comparing your configuration with the sample configuration.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们已经在大CAS中配置了基本的LDAP身份验证。在这个阶段，您应该能够重新启动CAS，启动JBCP日历（如果它还没有运行），并使用`admin1@example.com`/`admin`或`user1@example.com/user1`对它进行身份验证。去尝试看看它是否有效。如果它不起作用，尝试检查日志并将您的配置与示例配置进行比较。
- en: As discussed in [Chapter 5](05.html), *Authentication with Spring Data*, you
    may encounter issues starting the application, whether or not the temporary directory
    named `apacheds-spring-security` still exists. If the application appears to not
    exist, check the logs and see if the `apacheds-spring-security` directory needs
    to be removed.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第5章](05.html)中所讨论的，*使用Spring Data进行身份验证*，您可能会遇到启动应用程序时出现问题，无论临时目录`apacheds-spring-security`是否仍然存在。如果应用程序似乎不存在，检查日志并查看是否需要删除`apacheds-spring-security`目录。
- en: Getting the UserDetails object from a CAS assertion
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从CAS断言获取UserDetails对象
- en: Up until this point, we have been authenticating with CAS by obtaining the roles
    from our `InMemoryUserDetailsManager` object. However, we can create the `UserDetails`
    object from the CAS assertion just as we did with OAuth2\. The first step is to
    configure the CAS server to return the additional attributes.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 直到这一点，我们一直通过从我们的`InMemoryUserDetailsManager`对象获取角色来使用CAS进行身份验证。然而，我们可以像对待OAuth2一样，从CAS断言中创建`UserDetails`对象。第一步是配置CAS服务器以返回附加属性。
- en: Returning LDAP attributes in the CAS response
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在CAS响应中返回LDAP属性
- en: We know that CAS can return the username in the CAS response, but it can also
    return arbitrary attributes in the CAS response. Let's see how we can update the
    CAS server to return additional attributes. Again, all of the changes in this
    section are in the CAS server and not in the calendar application.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道CAS可以在CAS响应中返回用户名，但它也可以在CAS响应中返回任意属性。让我们看看我们如何更新CAS服务器以返回附加属性。再次强调，本节中的所有更改都在CAS服务器中，而不是在日历应用程序中。
- en: Mapping LDAP attributes to CAS attributes
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将LDAP属性映射到CAS属性
- en: The first step requires us to map LDAP attributes to attributes in the CAS assertion
    (including the `role` attribute, which we're expecting to contain the user's `GrantedAuthority`).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步需要我们将LDAP属性映射到CAS断言中的属性（包括我们期望包含用户`GrantedAuthority`的`role`属性）。
- en: 'We''ll add another bit of configuration to the CAS `deployerConfigContext.xml`
    file. This new bit of configuration is required to instruct CAS as to how to map
    attributes from the CAS `Principal` object to the CAS `IPersonAttributes` object,
    which will ultimately be serialized as part of ticket validation. This bean configuration
    should replace the bean of the same name-which is `attributeRepository`-as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在CAS的`deployerConfigContext.xml`文件中添加另一段配置。这一新的配置是必需的，以指导CAS如何将来自CAS`Principal`对象的属性映射到CAS`IPersonAttributes`对象，这最终将作为票证验证的一部分序列化。这个bean配置应该替换相同名称的bean-即`attributeRepository`-如下所示：
- en: '[PRE26]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The functionality behind the scenes here is definitely confusing-essentially,
    the purpose of this class is to map `Principal` back to the LDAP directory. (This
    is the `queryAttributeMapping` property mapping the `username` field of `Principal`
    to the `uid` attribute in the LDAP query.) The provided `baseDN` Java Bean property
    is searched using the LDAP query (`uid=user1@example.com`), and attributes are
    read from the matching entry. The attributes are mapped back to `Principal` using
    the key/value pairs in the `resultAttributeMapping` property. We recognize that
    LDAP's `cn` and `sn` attributes are being mapped to meaningful names, and the
    `description` attribute is being mapped to the role that will be used for determining
    the authorization of our user.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的幕后功能确实令人困惑——本质上，这个类的目的是将`Principal`映射回LDAP目录。（这是`queryAttributeMapping`属性，它将`Principal`的`username`字段映射到LDAP查询中的`uid`属性。）提供的`baseDN`Java
    Bean属性使用LDAP查询（`uid=user1@example.com`）进行搜索，并从匹配的条目中读取属性。这些属性使用`resultAttributeMapping`属性中的键/值对映射回`Principal`。我们认识到，LDAP的`cn`和`sn`属性被映射到有意义的名称，并且`description`属性被映射到用于确定我们用户角色的属性。
- en: Part of the complexity comes from the fact that a portion of this functionality
    is wrapped up in a separate project called `Person Directory` ([http://www.ja-sig.org/wiki/display/PD/Home](http://www.ja-sig.org/wiki/display/PD/Home)),
    which is intended to aggregate multiple sources of information about a person
    into a single view. The design of `Person Directory` is such that it is not directly
    tied to the CAS server and can be reused as part of other applications. The downside
    of this design choice is that it makes some aspects of CAS configuration more
    complex than it initially seems should be required.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂性的一部分源于这样一个事实：这部分功能被包装在一个名为`Person Directory`的单独项目中（[http://www.ja-sig.org/wiki/display/PD/Home](http://www.ja-sig.org/wiki/display/PD/Home)），该项目旨在将关于一个人的多个信息源聚合到一个单一的视图中。`Person
    Directory`的设计如此，它并不直接与CAS服务器绑定，并且可以作为其他应用程序的一部分被复用。这种设计选择的一个缺点是，它使得CAS配置的一些方面比最初看起来要复杂。
- en: Troubleshooting LDAP attribute mapping in CAS
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 排查CAS中的LDAP属性映射问题
- en: We would love to set up the same type of query in LDAP as we used with Spring
    Security LDAP in [Chapter 6](07.html), *LDAP Directory Services*, to be able to
    map `Principal` to a full LDAP-distinguished name, and then to use that DN to
    look up group membership by matching on the basis of the `uniqueMember` attribute
    of a `groupOfUniqueNames` entry. Unfortunately, the CAS LDAP code doesn't have
    this flexibility yet, leading to the conclusion that more advanced LDAP mapping
    will require extensions to base classes in CAS.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很想设置与第6章中使用的Spring Security LDAP相同的查询类型（*LDAP目录服务*），以便能够将`Principal`映射到完整的LDAP别名，然后使用该DN通过匹配`groupOfUniqueNames`条目的`uniqueMember`属性来查找组成员。不幸的是，CAS
    LDAP代码目前还没有这种灵活性，导致结论，更高级的LDAP映射将需要对CAS的基本类进行扩展。
- en: Authorizing CAS services to access custom attributes
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权CAS服务访问自定义属性
- en: 'Next, we will need to authorize any CAS service over HTTPS to access these
    attributes. To do this, we can update `RegisteredServiceImpl`, which has the description
    `Only Allows HTTPS URLs` in `InMemoryServiceRegistryDaoImpl`, as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将需要授权任何通过HTTPS访问这些属性的CAS服务。为此，我们可以更新`RegisteredServiceImpl`，其描述为`仅允许HTTPS
    URL`（在`InMemoryServiceRegistryDaoImpl`中），如下所示：
- en: '[PRE27]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Acquiring a UserDetails from CAS
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从CAS获取UserDetails
- en: When we first set up CAS integration with Spring Security, we configured `UserDetailsByNameServiceWrapper`,
    which simply translated the username presented to CAS into a `UserDetails` object
    from `UserDetailsService`, which we had referenced (in our case, it was `InMemoryUserDetailsManager`).
    Now that CAS is referencing the LDAP server, we can set up `LdapUserDetailsService`,
    as we discussed at the tail end of [Chapter 6](07.html), *LDAP Directory Services*,
    and things will work just fine. Note that we have switched back to modifying the
    calendar application and not the CAS server.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们第一次将CAS与Spring Security集成时，我们配置了`UserDetailsByNameServiceWrapper`，它简单地将呈现给CAS的用户名转换为从`UserDetailsService`获取的`UserDetails`对象，我们所引用的（在我们的案例中，它是`InMemoryUserDetailsManager`）。现在既然CAS正在引用LDAP服务器，我们可以设置`LdapUserDetailsService`，正如我们在第6章末尾讨论的那样（*LDAP目录服务*），并且一切都会正常工作。请注意，我们已经回到修改日历应用程序，而不是CAS服务器。
- en: The GrantedAuthorityFromAssertionAttributesUser object
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`GrantedAuthorityFromAssertionAttributesUser`对象'
- en: 'Now that we have modified the CAS server to return custom attributes, we''ll
    experiment with another capability of the Spring Security CAS integration-the
    ability to populate `UserDetails` from the CAS assertion itself! This is actually
    as simple as switching the `AuthenticationUserDetailsService` implementation to
    the `o.s.s.cas.userdetails.GrantedAuthorityFromAssertionAttributesUserDetailsService`
    object, whose job it is to read the CAS assertion, look for a certain attribute,
    and map the value of that attribute directly to the `GrantedAuthority` object
    for the user. Let''s assume that there is an attribute entitled role that will
    be returned with the assertion. We''ll simply configure a new `authenticationUserDetailsService`
    bean (be sure to replace the previously defined `authenticationUserDetailsService`
    bean) in the `CaseConfig.xml` file:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经修改了CAS服务器以返回自定义属性，接下来我们将尝试Spring Security CAS集成的另一个功能-从CAS断言本身填充`UserDetails`的能力！实际上，这就像将`AuthenticationUserDetailsService`实现更改为`o.s.s.cas.userdetails.GrantedAuthorityFromAssertionAttributesUserDetailsService`对象一样简单，该对象的任务是读取CAS断言，查找某个属性，并将该属性的值直接映射到用户的`GrantedAuthority`对象。假设有一个名为role的属性将随断言返回。我们只需在`CaseConfig.xml`文件中配置一个新的`authenticationUserDetailsService`
    bean（确保替换之前定义的`authenticationUserDetailsService` bean）：
- en: '[PRE28]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You will also want to remove the `userDetailsService` bean from our `SecurityConfig.java`
    file, since it is no longer needed.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要将从`SecurityConfig.java`文件中的`userDetailsService` bean删除，因为现在它不再需要了。
- en: Alternative ticket authentication using SAML 1.1
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SAML 1.1的替代票证认证。
- en: '**Security Assertion Markup Language** (**SAML**) is a standard, cross-platform
    protocol for identify verification using structured XML assertions. SAML is supported
    by a wide variety of products, including CAS (in fact, we will look at support
    for SAML within Spring Security itself in a later chapter).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全断言标记语言**（**SAML**）是一个使用结构化XML断言的标准、跨平台身份验证协议。SAML被许多产品支持，包括CAS（实际上，我们将在后面的章节中查看Spring
    Security本身对SAML的支持）。'
- en: 'While the standard CAS protocol can be extended to return attributes, the SAML
    security assertion XML dialect solves some of the issues with attribute passing,
    using the CAS response protocol that we previously described. Happily, switching
    between CAS ticket validation and SAML ticket validation is as simple as changing
    the `TicketValidator` implementation configured in `CasSecurity.java`. Modify
    `ticketValidator`, as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然标准的CAS协议可以扩展以返回属性，但SAML安全断言XML方言解决了属性传递的一些问题，使用了我们之前描述的CAS响应协议。幸运的是，在`CasSecurity.java`中配置的`TicketValidator`实现从CAS票证验证切换到SAML票证验证就像改变以下`ticketValidator`一样简单：
- en: '[PRE29]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You will notice that there is no longer a reference to the PGT URL. This is
    because the `Saml11TicketValidator` object does not support PGT. While both could
    exist, we opt to remove any references to the proxy ticket authentication, since
    we will no longer be using proxy ticket authentication. If you do not want to
    remove it from this exercise, don't worry; it won't prevent our application from
    running so long as your `ticketValidator` bean ID looks similar to the previous
    code snippet.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到再也没有对PGT URL的引用。这是因为`Saml11TicketValidator`对象不支持PGT。虽然两者都可以存在，但我们选择删除任何对代理票证认证的引用，因为我们不再使用代理票证认证。如果你不想在本练习中删除它，不用担心；只要你的`ticketValidator`
    bean ID与之前的代码片段相似，它就不会阻止我们的应用程序运行。
- en: In general, it's recommended that SAML ticket validation be used over CAS 2.0
    ticket validation, as it adds more non-repudiation features, including `timestamp`
    validation, and solves the attribute problem in a standard way.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，建议使用SAML票证验证而不是CAS 2.0票证验证，因为它增加了更多的非否认功能，包括`timestamp`验证，并以标准方式解决了属性问题。
- en: Restart the CAS server and JBCP calendar application. You can then visit `https://localhost:8443`
    and see that our calendar application can obtain `UserDetails` from the CAS response.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动CAS服务器和JBCP日历应用程序。然后你可以访问`https://localhost:8443`，并看到我们的日历应用程序可以从CAS响应中获取`UserDetails`。
- en: Your code should now look like `chapter10.06-calendar` and `chapter10.06-cas-server`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码现在应该看起来像`chapter10.06-calendar`和`chapter10.06-cas-server`。
- en: How is attribute retrieval useful?
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性检索有什么用？
- en: Remember that CAS provides a layer of abstraction for our application, removing
    the ability for our application to directly access the user repository, and instead
    forcing all such access to be performed through CAS as a proxy.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，CAS为我们的应用程序提供了一层抽象，消除了我们应用程序直接访问用户存储库的能力，而是强制所有此类访问通过CAS作为代理进行。
- en: This is extremely powerful! It means that our application no longer cares what
    kind of repository the users are stored in, nor does it have to worry about the
    details of how to access them-this simply confirms that authentication with CAS
    is sufficient to prove that a user should be able to access our application. For
    system administrators, this means that should an LDAP server be renamed, moved,
    or otherwise adjusted, they only need to reconfigure it in a single location-CAS.
    Centralizing access through CAS allows for a high level of flexibility and adaptability
    in the overall security architecture of the organization.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常强大！这意味着我们的应用程序不再关心用户存储在什么类型的存储库中，也不必担心如何访问它们——这进一步证实了通过CAS进行身份验证足以证明用户应该能够访问我们的应用程序。对于系统管理员来说，这意味着如果LDAP服务器被重新命名、移动或进行其他调整，他们只需要在单一位置——CAS中重新配置它。通过CAS集中访问允许在组织的整体安全架构中具有高度的灵活性和适应性。
- en: This story to the usefulness of attribute retrieval from CAS; now all applications
    authenticated through CAS have the same view of a user and can consistently display
    information across any CAS-enabled environment.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事讲述了从CAS获取属性的有用性；现在所有通过CAS验证的应用程序对用户有相同的视图，并且可以在任何CAS启用的环境中一致地显示信息。
- en: Be aware that, once authenticated, Spring Security CAS does not require the
    CAS server, unless the user is required to reauthenticate. This means that attributes
    and other user information stored locally in the application in the user's `Authentication`
    object may become stale over time, and possibly out of sync with the source CAS
    server. Take care to set session timeouts appropriately to avoid this potential
    issue!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一旦验证通过，Spring Security CAS不再需要CAS服务器，除非用户需要重新验证。这意味着存储在应用程序中用户`Authentication`对象中的属性和其他用户信息可能会随时间变得过时，并且可能与源CAS服务器不同步。请注意适当地设置会话超时，以避免这个潜在的问题！
- en: Additional CAS capabilities
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外的CAS功能
- en: 'CAS offers additional advanced configuration capabilities outside of those
    that are exposed through the Spring Security CAS wrappers. Some of these include
    the following capabilities:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: CAS提供了通过Spring Security CAS包装器暴露之外的高级配置功能。其中一些包括以下功能：
- en: Providing transparent single sign-on for users who are accessing multiple CAS-secured
    applications within a configurable time window on the CAS server. Applications
    can force users to authenticate to CAS by setting the `renew` property to `true`
    on `TicketValidator`; you may want to conditionally set this property in custom
    code in the event where the user is attempting to access a highly secured area
    of the application.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为在CAS服务器上配置的时间窗口内访问多个CAS安全应用程序的用户提供透明的单点登录。应用程序可以通过在`TicketValidator`上设置`renew`属性为`true`来强制用户向CAS进行身份验证；在用户试图访问应用程序的受保护区域时，您可能希望在自定义代码中有条件地设置此属性。
- en: The RESTful API for obtaining service tickets.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取服务票证的RESTful API。
- en: JA-SIG's CAS server can also act as an OAuth2 server. If you think about it,
    this makes sense, since CAS is very similar to OAuth2.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JA-SIG的CAS服务器也可以作为OAuth2服务器。如果你想想，这是有道理的，因为CAS与OAuth2非常相似。
- en: Providing OAuth support for the CAS server so that it can obtain access tokens
    to a delegate OAuth provider (that is, Google), or so that the CAS server can
    be the OAuth server itself.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为CAS服务器提供OAuth支持，以便它可以获取委派OAuth提供者（即Google）的访问令牌，或者使CAS服务器本身成为OAuth服务器。
- en: We'd encourage you to explore the full capabilities of the CAS client and server
    as well as ask questions to the helpful folks in the JA-SIG community forums!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励您探索CAS客户端和服务器的全部功能，并向JA-SIG社区论坛中的热心人士提问！
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about the CAS single sign-on portal and how it can
    be integrated with Spring Security, and we also covered the CAS architecture and
    communication paths between actors in a CAS-enabled environment. We also saw the
    benefits of CAS-enabled applications for application developers and system administrators.
    We also learned about configuring JBCP calendar to interact with a basic CAS installation.
    We also covered the use of CAS's single logout support.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了关于CAS单点登录门户的知识，以及它是如何与Spring Security集成的，我们还涵盖了CAS架构以及在CAS启用环境中参与者之间的通信路径。我们还看到了CAS启用应用程序对应用开发人员和系统管理员的益处。我们还学习了如何配置JBCP日历与基本CAS安装进行交互。我们还涵盖了CAS的单一登出支持的用途。
- en: We also saw how proxy ticket authentication works and how to leverage it to
    authenticate stateless services.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们同样了解了代理票证认证是如何工作的，以及如何利用它来认证无状态服务。
- en: We also covered tasks of updating CAS to interact with LDAP, and sharing LDAP
    data with our CAS-enabled application. We even learned about implementing attribute
    exchange with the industry standard SAML protocol.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还涵盖了更新CAS以与LDAP交互，以及将LDAP数据与我们的CAS启用应用程序共享的任务。我们还学习了如何使用行业标准的SAML协议实现属性交换。
- en: We hope this chapter was an interesting introduction to the world of single
    sign-on. There are many other single sign-on systems in the marketplace, mostly
    commercial, but CAS is definitely one of the leaders of the open source SSO world,
    and an excellent platform to build out SSO capability in any organization.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这一章是对单点登录世界的一个有趣的介绍。市场上还有许多其他单点登录系统，大部分是商业的，但CAS无疑是开源SSO世界中的领导者之一，是任何组织构建SSO能力的一个优秀平台。
- en: In the next chapter, we'll learn more about Spring Security authorization.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习更多关于Spring Security授权的内容。
