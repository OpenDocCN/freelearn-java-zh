- en: Remember-Me Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记住我服务
- en: 'In this chapter, we''ll add the ability for an application to remember a user
    even after their session has expired and the browser is closed. The following
    topics will be covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将添加一个应用程序即使在会话过期且浏览器关闭后也能记住用户的功能。本章将涵盖以下主题：
- en: Discussing what remember-me is
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论什么是记住我
- en: Learning how to use the **token-based remember-me** feature
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用基于**令牌的记住我**功能
- en: Discussing how secure remember-me is, and various ways of making it more secure
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论记住我有多安全，以及使其更安全的各种方法
- en: Enabling the persistent-based remember-me feature, and how to handle additional
    considerations for using it
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用基于持久性的记住我功能，以及使用它时要考虑的额外问题
- en: Presenting the overall remember-me architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍整体的记住我架构
- en: Learning how to create a custom remember-me implementation that is restricted
    to the user's IP address
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何创建一个限制在用户IP地址上的自定义记住我实现
- en: What is remember-me?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是记住我？
- en: A convenient feature to offer frequent users of a website is the remember-me
    feature. This feature allows a user to elect to be remembered even after their
    browser is closed. In Spring Security, this is implemented through the use of
    a remember-me cookie that is stored in the user's browser. If Spring Security
    recognizes that the user is presenting a remember-me cookie, then the user will
    automatically be logged into the application, and will not need to enter a username
    or password.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为网站的常客提供的一个便利功能是记住我功能。此功能允许用户在浏览器关闭后选择被记住。在Spring Security中，这是通过在用户浏览器中存储一个记住我cookie来实现的。如果Spring
    Security识别到用户正在出示一个记住我cookie，那么用户将自动登录应用程序，无需输入用户名或密码。
- en: What is a cookie?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是cookie？
- en: A cookie is a way for a client (that is, a web browser) to persist the state.
    For more information about cookies, refer to additional online resources, such
    as Wikipedia ([http://en.wikipedia.org/wiki/HTTP_cookie](http://en.wikipedia.org/wiki/HTTP_cookie)).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Cookie是客户端（即Web浏览器）保持状态的一种方式。有关cookie的更多信息，请参考其他在线资源，例如维基百科（[http://en.wikipedia.org/wiki/HTTP_cookie](http://en.wikipedia.org/wiki/HTTP_cookie)）。
- en: 'Spring Security provides the following two different strategies that we will
    discuss in this chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security在本章提供了以下两种不同的策略，我们将在此讨论：
- en: The first is the token-based remember-me feature, which relies on a cryptographic
    signature
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是基于令牌的记住我功能，它依赖于加密签名
- en: The second method, the **persistent-based remember-me** feature, requires a
    datastore (a database)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个方法，基于**持久性的记住我**功能，需要一个数据存储（数据库）
- en: As we previously mentioned, we will discuss these strategies in much greater
    detail throughout this chapter. The remember-me feature must be explicitly configured
    in order to enable it. Let's start off by trying the token-based remember-me feature
    and see how it affects the flow of the login experience.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，我们将在本章中详细讨论这些策略。为了启用记住我功能，必须显式配置记住我功能。让我们先尝试基于令牌的记住我功能，看看它如何影响登录体验的流程。
- en: Dependencies
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖项
- en: 'The token-based remember-me section does not need any additional dependencies
    other than the basic setup from [Chapter 2](02.html), *Getting Started with Spring
    Security*. However, you will want to ensure you include the following additional
    dependencies in your `pom.xml` file if you are leveraging the persistent-based
    remember-me feature. We have already included these dependencies in the chapter''s
    sample, so there is no need to update the sample application:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 基于令牌的记住我部分除了第[第二章](02.html) *Spring Security入门*中的基本设置外，不需要其他依赖项。然而，如果你正在使用基于持久性的记住我功能，你需要在你的`pom.xml`文件中包含以下额外的依赖项。我们已经在章节的示例中包含了这些依赖项，所以不需要更新示例应用程序：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The token-based remember-me feature
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于令牌的记住我功能
- en: Spring Security provides two different implementations of the remember-me feature.
    We will start off by exploring how to set up token-based remember-me services.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security提供了记住我功能的两种不同实现。我们将首先探索如何设置基于令牌的记住我服务。
- en: Configuring the token-based remember-me feature
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置基于令牌的记住我功能
- en: 'Completing this exercise will allow us to provide a simple and secure method
    to keep users logged in for extended periods of time. To start, perform the following
    steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此练习将允许我们提供一种简单且安全的方法，使用户在较长时间内保持登录。开始时，请执行以下步骤：
- en: Modify the `SecurityConfig.java` configuration file and add the `rememberMe`
    method.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`SecurityConfig.java`配置文件，添加`rememberMe`方法。
- en: 'Take a look at the following code snippet:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下代码片段：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You should start with `chapter07.00-calendar`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该从`chapter07.00-calendar`开始。
- en: 'If we try running the application now, we''ll see nothing different in the
    flow. This is because we also need to add a field to the login form that allows
    the user to opt for this functionality. Edit the `login.html` file and add a checkbox,
    as shown in the following code snippet:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在尝试运行应用程序，我们会发现流程中没有不同。这是因为我们还需要在登录表单中添加一个字段，允许用户选择此功能。编辑`login.html`文件，并添加一个复选框，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Your code should look like `chapter07.01-calendar`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码应该看起来像`chapter07.01-calendar`。
- en: When we next log in, if the remember-me box is selected, a remember-me cookie
    is set in the user's browser.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们下次登录时，如果选择了记住我框，则在用户的浏览器中设置了记住我cookie。
- en: Spring Security understands that it should remember the user by inspecting the
    HTTP parameter `remember_me`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security理解它应该通过检查HTTP参数`remember_me`来记住用户。
- en: In Spring Security 3.1 and earlier versions, the default parameter for the remember-me
    form field was `spring_security_remember_me`. Now, in Spring Security 4.x, the
    default remember-me form field is `remember-me`. This can be overridden with the
    `rememberMeParameter` method.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Security 3.1及更早版本中，记住我表单字段的默认参数是`spring_security_remember_me`。现在，在Spring
    Security 4.x中，默认的记住我表单字段是`remember-me`。这可以通过`rememberMeParameter`方法来覆盖。
- en: If the user then closes his/her browser and reopens it to an authenticated page
    on the JBCP calendar website, he/she won't be presented with the login page a
    second time. Try it yourself now-log in with the remember-me option selected,
    bookmark the home page, then restart the browser and access the home page. You'll
    see that you're immediately logged in successfully without needing to supply your
    login credentials again. If this appears to be happening to you, it means that
    your browser or a browser plugin is restoring the session.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户然后关闭他的浏览器，重新打开它以登录JBCP日历网站的认证页面，他/她不会第二次看到登录页面。现在试试自己-选择记住我选项登录，将主页添加到书签中，然后重新启动浏览器并访问主页。您会看到，您会立即成功登录，而无需再次提供登录凭据。如果这种情况出现在您身上，这意味着您的浏览器或浏览器插件正在恢复会话。
- en: Try closing the tab first and then close the browser.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 先尝试关闭标签页，然后再关闭浏览器。
- en: One more effective solution is to use a browser plugin, such as **Firebug**
    ([https://addons.mozilla.org/en-US/firefox/addon/firebug/](https://addons.mozilla.org/en-US/firefox/addon/firebug/)),
    to remove the `JSESSIONID` cookie. This can often save time and annoyance during
    the development and verification of this type of feature on your site.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有效的方法是使用浏览器插件，如**Firebug**（[https://addons.mozilla.org/en-US/firefox/addon/firebug/](https://addons.mozilla.org/en-US/firefox/addon/firebug/)），以删除`JSESSIONID`cookie。这通常可以在开发和验证您网站上此类功能时节省时间和烦恼。
- en: 'After logging in and selecting remember-me, you should see two cookies have
    been set, `JSESSIONID` and `remember-me`, as shown in the following screenshot:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后选择记住我，你应该会看到已经设置了两个cookie，`JSESSIONID`和`remember-me`，如下面的截图所示：
- en: '![](img/486134eb-1413-42f7-b94d-70070a43966b.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/486134eb-1413-42f7-b94d-70070a43966b.png)'
- en: How the token-based remember-me feature works
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于令牌的记住我功能是如何工作的
- en: 'The remember-me feature sets a cookie in the user''s browser containing a Base64-encoded
    string with the following pieces:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我功能在用户的浏览器中设置一个cookie，包含一个Base64编码的字符串，包含以下内容：
- en: The username
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名
- en: An expiration date/time
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过期日期/时间
- en: An MD5 hash value of the `expiration` date/time, `username`, `password`, and
    the `key` attribute of the `rememberMe` method
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expiration`日期/时间的MD5散列值、`username`、`password`以及`rememberMe`方法的`key`属性。'
- en: These are combined into a single cookie value that is stored in the browser
    for later use.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些被组合成一个单一的cookie值，存储在浏览器中供以后使用。
- en: MD5
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MD5
- en: MD5 is one of the several well-known cryptographic hash algorithms. Cryptographic
    hash algorithms compute a compact and unique text representation of input data
    with arbitrary length, called a **digest**. This digest can be used to determine
    if an untrusted input should be trusted by comparing the digest of the untrusted
    input to a known valid digest of the expected input.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: MD5是几种著名的加密散列算法之一。加密散列算法计算具有任意长度的输入数据的最紧凑且唯一的文本表示，称为**摘要**。这个摘要可以用来确定是否应该信任一个不可信的输入，通过将不可信输入的摘要与预期输入的有效摘要进行比较。
- en: 'The following diagram illustrates how this works:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了它是如何工作的：
- en: '![](img/a2fb3cec-4da4-4033-ba05-b83fac2bfa16.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a2fb3cec-4da4-4033-ba05-b83fac2bfa16.png)'
- en: For example, many open source software sites allow mirrors to distribute their
    software to help increase download speeds. However, as a user of the software,
    we would want to be sure that the software is authentic and doesn't include any
    viruses. The software distributor will calculate and publish the expected MD5
    checksum on their website with their known, good version of the software. Then,
    we can download the file from any location. Before we install the software, we
    calculate the untrusted MD5 checksum on the file we downloaded. We then compare
    the untrusted MD5 checksum to the expected MD5 checksum. If the two values match,
    we know that we can safely install the file we downloaded. If the two values do
    not match, we should not trust the downloaded file and delete it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，许多开源软件网站允许镜像站点分发它们的软件，以帮助提高下载速度。然而，作为软件的用户，我们希望确保软件是真实的，并且不包含任何病毒。软件分发商将计算并在其网站上发布与他们已知的好版本软件对应的预期MD5校验和。然后，我们可以从任何位置下载文件。在安装软件之前，我们对下载的文件计算不信任的MD5校验和。然后，我们将不信任的MD5校验和与预期的MD5校验和进行比较。如果这两个值匹配，我们就知道可以安全地安装我们下载的文件。如果这两个值不匹配，我们不应该信任下载的文件并删除它。
- en: Although it is impossible to obtain the original data from the hash value, MD5
    is vulnerable to several types of attack, including the exploitation of weaknesses
    in the algorithm itself and rainbow table attacks. Rainbow tables typically contain
    the pre-computed hash values of millions of input values. This allows attackers
    to look for the hash value in the rainbow table and determine the actual (unhashed)
    value. Spring Security combats this by including the expiration date, the user's
    password, and the remember-me key in the hashed value.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管无法从哈希值中获取原始数据，但MD5算法存在多种攻击风险，包括利用算法本身的弱点以及彩虹表攻击。彩虹表通常包含数百万输入值预先计算的哈希值。这使得攻击者可以在彩虹表中查找哈希值，并确定实际的（未哈希）值。Spring
    Security通过在哈希值中包括过期日期、用户的密码和记住我键来对抗这种风险。
- en: Remember-me signature
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记住我签名
- en: 'We can see how MD5 can ensure that we have downloaded the correct file, but
    how does this apply to Spring Security''s remember-me service? Much like the file
    we downloaded, the cookie is untrusted, but we can trust it if we can validate
    the signature that originated from our application. When a request comes in with
    the remember-me cookie, its contents are extracted and the expected signature
    is compared to the signature found in the cookie. The steps in calculating the
    expected signature are illustrated in the following diagram:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到MD5如何确保我们下载了正确的文件，但这与Spring Security的记住我服务有何关联呢？与下载的文件类似，cookie是不信任的，但如果我们能验证来自我们应用程序的签名，我们就可以信任它。当带有记住我cookie的请求到来时，其内容被提取，期望的签名与cookie中找到的签名进行比较。计算期望签名的步骤在下图中说明：
- en: '![](img/6014f753-534c-4041-84e4-f55339e3c5a8.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6014f753-534c-4041-84e4-f55339e3c5a8.png)'
- en: The remember-me cookie contains the **username**, **expiration**, and a **signature**.
    Spring Security will extract the **username** and **expiration** from the cookie.
    It will then utilize the `username` from the cookie to look up the **password**
    using `UserDetailsService`. The **key** is already known because it was provided
    using the `rememberMe` method. Now that all of the arguments are known, Spring
    Security can calculate the expected signature using the **username**, **expiration**,
    **password**, and **key**. It then compares the **expected signature** against
    the cookie's **signature**.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我cookie包含**用户名**、**过期时间**和一个**签名**。Spring Security将从中提取**用户名**和**过期时间**。然后使用来自cookie的`username`通过`UserDetailsService`查找**密码**。**密钥**已知，因为它是通过`rememberMe`方法提供的。现在所有参数都知道了，Spring
    Security可以使用**用户名**、**过期时间**、**密码**和**密钥**计算期望的签名。然后，它将期望签名与cookie中的**签名**进行比较。
- en: If the two signatures match, we can trust that the **username** and **expiration**
    date are valid. Forging a **signature** is next to impossible without knowing
    the remember-me key (which only the application knows) and the user's password
    (which only this user knows). This means if the signatures match and if the token
    is not expired, the user can be logged in.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个签名匹配，我们可以确信**用户名**和**过期日期**是有效的。不知道记住我密钥（只有应用程序知道）和用户密码（只有这个用户知道）的情况下伪造签名几乎是不可能的。这意味着如果签名匹配且令牌没有过期，用户可以登录。
- en: You have anticipated that if the user changes their username or password, any
    remember-me token set will no longer be valid. Make sure that you provide appropriate
    messaging to users if you allow them to change these bits of their account. Later
    in this chapter, we will look at an alternative remember-me implementation that
    is reliant only on the username and not on the password.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经预见到，如果用户更改了他们的用户名或密码，设置的任何记住我令牌将不再有效。确保如果您允许用户更改账户这些部分，您要向用户提供适当的消息。在本章后面，我们将查看一个仅依赖于用户名而非密码的替代记住我实现。
- en: Note that it is still possible to differentiate between users who have been
    authenticated with a remember-me cookie and users who have presented the username
    and password (or equivalent) credentials. We'll experiment with this shortly when
    we investigate the security of the remember-me feature.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，仍然可以区分已通过记住我cookie进行身份验证的用户和提供用户名和密码（或等效）凭据的用户。当我们调查记住我功能的安全性时，我们将很快尝试这一点。
- en: Token-based remember-me configuration directives
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于令牌的记住我配置指令
- en: 'The following two configuration changes are commonly made to alter the default
    behavior of the remember-me functionality:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对记住我功能默认行为进行更改的两个常见配置更改：
- en: '| **Attribute** | **Description** |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **描述** |'
- en: '| `key` | Defines a unique key used when producing the remember-me cookie''s
    signature. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `key` | 定义用于生成记住我cookie签名时使用的唯一键。 |'
- en: '| `tokenValiditySeconds` | Defines the length of time (in seconds). The remember-me
    cookie will be considered valid for authentication. It is also used to set the
    cookie expiration timestamp. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `tokenValiditySeconds` | 定义时间长度（以秒为单位）。记住我cookie将被视为用于身份验证的有效cookie。它还用于设置cookie的过期时间戳。
    |'
- en: As you may infer from the discussion of how the cookie contents are hashed,
    the `key` attribute is critical for the security of the remember-me feature. Make
    sure that the key you choose is likely to be unique to your application and long
    enough so that it can't be easily guessed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能从讨论cookie内容是如何散列中推断出`key`属性对记住我功能的安全性至关重要。确保您选择的键很可能是您应用程序唯一的，并且足够长，以至于它不能轻易被猜测。
- en: Keeping in mind the purpose of this book, we've kept the key values relatively
    simple, but if you're using remember-me in your own application, it's suggested
    that your key contains the unique name of your application and is at least 36
    random characters long. Password generator tools (search Google for "online password
    generator") are a great way to get a pseudo-random mix of alphanumeric and special
    characters to compose your remember-me key. For applications that exist in multiple
    environments (such as development, test, and production), the remember-me cookie
    value should include this fact as well. This will prevent remember-me cookies
    from inadvertently being used in the wrong environment during testing!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到本书的目的，我们保留了键值相对简单，但如果你在自己的应用程序中使用记住我，建议你的键包含应用程序的唯一名称，并且至少36个随机字符长。密码生成工具（在Google中搜索“在线密码生成器”）是获得假随机字母数字和特殊字符混合来组成你的记住我键的好方法。对于存在于多个环境中的应用程序（例如开发、测试和生产），记住我cookie值也应该包括这个事实。这将防止在测试过程中无意中使用错误的环境的记住我cookie！
- en: 'An example key value in a production application might be similar to the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 生产应用程序中的一个示例键值可能与以下内容相似：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `tokenValiditySeconds` method is used to set the number of seconds after
    which the remember-me token will not be accepted for the automatic login function,
    even if it is otherwise a valid token. The same attribute is also used to set
    the maximum lifetime of the remember-me cookie on the user's browser.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`tokenValiditySeconds`方法用于设置记住我令牌在自动登录功能中不再被接受的时间秒数，即使它本身是一个有效的令牌。相同的属性也用于设置用户浏览器上记住我cookie的最大生命周期。'
- en: Configuration of the remember-me session cookies
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我会话cookie的配置
- en: If `tokenValiditySeconds` is set to `-1`, the login cookie will be set to a
    session cookie, which does not persist after the browser is closed by the user.
    The token will be valid (assuming the user doesn't close the browser) for a non-configurable
    length of two weeks. Don't confuse this with the cookie that stores your user's
    session ID-they're two different things with similar names!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`tokenValiditySeconds`设置为`-1`，登录cookie将被设置为会话cookie，用户关闭浏览器后它不会持续存在。令牌将在用户不关闭浏览器的情况下，有效期为两周的不可配置长度。不要将此与存储用户会话ID的cookie混淆——它们名称相似，但完全是两回事！
- en: You may have noticed that we listed very few attributes. Don't worry, we will
    spend time covering some of the other configuration attributes throughout this
    chapter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能注意到我们列出的属性非常少。别担心，我们将在本章中花时间介绍一些其他配置属性。
- en: Is remember-me secure?
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记住我是否安全？
- en: 'Any feature related to security that has been added for user convenience has
    the potential to expose our carefully-protected site to a security risk. The remember-me
    feature, in its default form, runs the risk of the user''s cookie being intercepted
    and reused by a malicious user. The following diagram illustrates how this might
    happen:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 任何为了用户方便而添加的安全相关特性都有可能使我们精心保护的网站面临安全风险。默认形式的记住我功能，存在用户cookie被拦截并恶意用户重复使用的风险。以下图表说明了这可能如何发生：
- en: '![](img/427022e2-68c7-4f5e-9be9-7bdec7389b27.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/427022e2-68c7-4f5e-9be9-7bdec7389b27.png)'
- en: The use of SSL (covered in the Appendix, *Additional Reference Material*) and
    other network security techniques can mitigate this type of attack, but be aware
    that there are other techniques, such as **cross-site scripting** (**XSS**), that
    can steal or compromise a remembered user session. While convenient for the user,
    we don't want to risk financial or other personal information being inadvertently
    changed or possibly stolen if the remembered session is misused.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SSL（在附录*附加参考资料*中有所涉及）和其他网络安全技术可以减轻这类攻击，但要注意还有其他技术，比如**跨站脚本攻击**（**XSS**），可能会窃取或破坏记住的用户会话。虽然这对用户方便，但如果我们不慎使用记住的会话，可能会导致财务或其他个人信息被无意修改或可能被盗用。
- en: Although we don't cover malicious user behavior in detail in this book, when
    implementing any secured system, it is important to understand the techniques
    employed by users who may be trying to hack your customers or employees. XSS is
    one such technique, but many others exist. It's highly recommended that you review
    the *OWASP Top Ten article* ([http://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project](http://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project))
    for a good list, and also pick up a web application security reference book in
    which many of the techniques demonstrated are illustrated to apply to any technology.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本书没有详细讨论恶意用户行为，但在实现任何安全系统时，了解可能试图攻击您客户或员工的用户所采用的技术是很重要的。XSS就是这样的技术，但还有很多其他技术。强烈建议您查阅*OWASP前十名文章*（[http://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project](http://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project)）获取一个不错的列表，并且也可以获取一本关于网络应用安全性的参考书籍，在这本书中，许多演示的技术都适用于任何技术。
- en: One common approach for maintaining the balance between convenience and security
    is identifying the functional locations on the site where personal or sensitive
    information could be present. You can then use the `fullyAuthenticated` expression
    to ensure these locations are protected using an authorization that checks not
    just the user's role, but that they have been authenticated with a full username
    and password. We will explore this feature in greater detail in the next section.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 保持方便和安全之间平衡的一种常见方法是识别网站上可能存在个人或敏感信息的职能位置。然后，您可以使用`fullyAuthenticated`表达式确保这些位置通过检查用户角色以及他们是否使用完整用户名和密码进行身份验证的保护。我们将在下一节更详细地探讨这一特性。
- en: Authorization rules for remember-me
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记住我功能的授权规则
- en: We'll fully explore the advanced authorization techniques later in [Chapter
    11](12.html), *Fine-Grained Access Control*, however, it's important to realize
    that it's possible to differentiate access rules based on whether or not an authenticated
    session was remembered.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第11章[细粒度访问控制](12.html)*中全面探讨高级授权技术*，不过，重要的是要意识到可以根据记住的认证会话与否来区分访问规则。
- en: 'Let''s assume we want to limit users trying to access the H2 `admin` console
    to administrators who have been authenticated using a username and password. This
    is similar to the behavior found in other major consumer-focused commerce sites,
    which restrict access to the elevated portions of the site until a password is
    entered. Keep in mind that every site is different, so don''t blindly apply such
    rules to your secure site. For our sample application, we''ll concentrate on protecting
    the H2 database console. Update the `SecurityConfig.java` file to use the keyword
    `fullyAuthenticated`, which ensures that remembered users who try to access the
    H2 database are denied access. This is shown in the following code snippet:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要限制尝试访问H2 `admin` 控制台的用户只能是使用用户名和密码认证的管理员。这与其他主要面向消费者的商业网站的行为类似，这些网站在输入密码之前限制对网站高级部分的访问。请记住，每个网站都是不同的，所以不要盲目地将此类规则应用于您的安全网站。对于我们的示例应用程序，我们将专注于保护H2数据库控制台。更新`SecurityConfig.java`文件以使用关键词`fullyAuthenticated`，确保尝试访问H2数据库的记住用户被拒绝访问。这显示在下面的代码片段中：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The existing rules remain unchanged. We've added a rule that requires requests
    for account information to have the appropriate `GrantedAuthority` of `ROLE_ADMIN`,
    and that the user is fully authenticated; that is, during this authenticated session,
    they have actually presented a username and password or other suitable credentials.
    Note the syntax of the SpEL logical operators here-`AND`, `OR`, and `NOT` are
    used for logical operators in SpEL. This was thoughtful of the SpEL designers,
    as the `&&` operator would be awkward to represent in XML, even though the preceding
    example is using Java-based configuration!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的规则保持不变。我们增加了一条规则，要求查询账户信息时必须拥有适当的`GrantedAuthority` of `ROLE_ADMIN`，并且用户已经完全认证；也就是说，在这个认证会话期间，他们实际上提供了一个用户名和密码或其他合适的凭据。注意这里SpEL逻辑运算符的语法-`AND`，`OR`和`NOT`用于SpEL中的逻辑运算符。SpEL设计者考虑得很周到，因为`&&`运算符在XML中表示起来会很不方便，尽管前面的例子是使用基于Java的配置！
- en: Your code should look like `chapter07.02-calendar`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码应该看起来像`chapter07.02-calendar`。
- en: Go ahead and log in with the username `admin1@example.com` and the password
    `admin1`, ensuring you select the remember-me feature. Access the H2 database
    console and you will see that the access is granted. Now, delete the `JSESSIONID`
    cookie (or close the tab and then all of the browser instances), and ensure that
    access is still granted to the All Events page. Now, navigate to the H2 console
    and observe that the access is denied.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 登录使用用户名`admin1@example.com`和密码`admin1`，确保选择记住我功能。访问H2数据库控制台，你会看到访问被授权。现在，删除`JSESSIONID`
    cookie（或者关闭标签页，然后关闭所有浏览器实例），确保仍然可以访问所有事件页面。现在，导航到H2控制台，观察访问被拒绝。
- en: This approach combines the usability enhancements of the remember-me feature
    with an additional level of security by requiring a user to present a full set
    of credentials to access sensitive information. Throughout the rest of the chapter,
    we will explore other ways of making the remember-me feature more secure.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法结合了记住我功能的易用性增强和通过要求用户提供完整的凭据来访问敏感信息的安全性。在本章的其余部分，我们将探讨其他使记住我功能更加安全的方法。
- en: Persistent remember-me
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久的记住我
- en: Spring Security provides the capability to alter the method for validating the
    remember-me cookie by leveraging different implementations of the `RememberMeServices`
    interface. In this section, we will discuss how we can use persistent remember-me
    tokens using a database, and how this can increase the security of our application.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security提供了通过利用`RememberMeServices`接口的不同实现来更改验证记住我cookie的方法的能力。在本节中，我们将讨论如何使用数据库来持久记住我令牌，以及这如何提高我们应用程序的安全性。
- en: Using the persistent-based remember-me feature
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基于持久性的记住我功能
- en: Modifying our remember-me configuration at this point to persist to the database
    is surprisingly trivial. The Spring Security configuration parser will recognize
    a new `tokenRepository` method on the `rememberMe` method, and simply switch implementation
    classes for `RememberMeServices`. Let's now review the steps required to accomplish
    this.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在此点修改我们的记住我配置以持久化到数据库是出奇地简单。Spring Security配置解析器将识别`rememberMe`方法上的新`tokenRepository`方法，只需切换实现类即可`RememberMeServices`。现在让我们回顾一下完成此操作所需的步骤。
- en: Adding SQL to create the remember-me schema
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加SQL创建记住我模式
- en: 'We have placed the SQL file containing the expected schema in our `resources`
    folder in the same place we did in [Chapter 3,](03.html) *Custom Authentication*.
    You can view the schema definition in the following code snippet:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将包含预期模式的SQL文件放在了`resources`文件夹中，位置与[第3章](03.html) *自定义认证*中的位置相同。您可以在下面的代码片段中查看模式定义：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Initializing the data source with the remember-me schema
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用记住我模式初始化数据源
- en: 'Spring Data will automatically initialize the embedded database with the `schema.sql`,
    as described in the preceding section. Note, however, that with JPA, in order
    for the schema to be created and the `data.sql` file used to seed the database,
    we must ensure we set `ddl-auto` to none, as shown in the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data将自动使用`schema.sql`初始化嵌入式数据库，如前一部分所述。请注意，但是，对于JPA，为了创建模式并使用`data.sql`文件来种子数据库，我们必须确保设置了`ddl-auto`到none，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Configuring the persistent-based remember-me feature
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置基于持久化的记住我功能
- en: 'Finally, we''ll need to make some brief configuration changes to the `rememberMe`
    declaration to point it to the data source we''re using, as shown in the following
    code snippet:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要对`rememberMe`声明进行一些简要的配置更改，以指向我们正在使用的数据源，如下面的代码片段所示：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is all we need to do to switch over to using persistent-based remember-me
    authentication. Go ahead and start up the application and give it a try. From
    a user standpoint, we do not notice any differences, but we know that the implementation
    backing this feature has changed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要做的，以便切换到基于持久化的记住我认证。大胆地启动应用程序并尝试一下。从用户的角度来看，我们感觉不到任何区别，但我们知道支持这个功能的实现已经发生了变化。
- en: Your code should look like `chapter07.03-calendar`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码应该看起来像`chapter07.03-calendar`。
- en: How does the persistent-based remember-me feature work?
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久化基于的记住我功能是如何工作的？
- en: 'Instead of validating a signature present in the cookie, the persistent-based
    remember-me service validates if the token exists in a database. Each persistent
    remember-me cookie consists of the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 持久化基于的记住我服务不是验证cookie中的签名，而是验证令牌是否存在于数据库中。每个持久记住我cookie包括以下内容：
- en: '**Series identifier**: This identifies the initial login of a user and remains
    consistent each time the user is automatically logged in to the original session'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**序列标识符**：这标识了用户的初始登录，并且每次用户自动登录到原始会话时都保持一致。'
- en: '**Token value**: A unique value that changes each time a user is authenticated
    using the remember-me feature'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**令牌值**：每次用户使用记住我功能进行身份验证时都会变化的唯一值。'
- en: 'Take a look at the following diagram:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下图表：
- en: '![](img/2e71b059-a28a-4b0f-955d-453845a6dbd1.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e71b059-a28a-4b0f-955d-453845a6dbd1.png)'
- en: When the remember-me cookie is submitted, Spring Security will use an `o.s.s.web.authentication.rememberme.PersistentTokenRepository`
    implementation to look up the expected token value and an expiration using the
    submitted series identifier. It will then compare the token value in the cookie
    to the expected token value. If the token is not expired and the two tokens match,
    the user is considered authenticated. A new remember-me cookie with the same series
    identifier, a new token value, and an updated expiration date will be generated.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当记住我cookie提交时，Spring Security将使用`o.s.s.web.authentication.rememberme.PersistentTokenRepository`实现来查找期望的令牌值和使用提交序列标识的过期时间。然后，它将比较cookie中的令牌值与期望的令牌值。如果令牌没有过期且两个令牌匹配，用户被认为是认证的。将生成一个新的记住我cookie，具有相同的序列标识符、新的令牌值和更新的过期日期。
- en: If the series token submitted is found in the database, but the tokens do not
    match, it can be assumed that someone stole the remember-me cookie. In this case,
    Spring Security will terminate these series of remember-me tokens and warn the
    user that their login has been compromised.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在数据库中找到了提交的序列令牌，但令牌不匹配，可以假设有人偷了记住我cookie。在这种情况下，Spring Security将终止这些记住我令牌，并警告用户他们的登录已经被泄露。
- en: 'The persisted tokens can be found in the database and viewed with the H2 console,
    as shown in the following screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 存储的令牌可以在数据库中找到，并通过H2控制台查看，如下面的屏幕截图所示：
- en: '![](img/e467fa2a-2bf3-4c0a-b650-60d0fac32b1c.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e467fa2a-2bf3-4c0a-b650-60d0fac32b1c.png)'
- en: JPA-based PersistentTokenRepository
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JPA基础持久化令牌存储库
- en: 'As we have seen in the earlier chapters, using a Spring Data project for our
    database mapping can greatly simplify our work. So, to keep things consistent,
    we are going to refactor our JDBC-based `PersistentTokenRepository` interface
    that uses `JdbcTokenRepositoryImpl` to one that is JPA-based. We will do so by
    performing the following steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前章节所看到的，使用Spring Data项目来映射我们的数据库可以大大简化我们的工作。因此，为了保持一致性，我们将重构我们的基于JDBC的`PersistentTokenRepository`接口，该接口使用`JdbcTokenRepositoryImpl`，改为基于JPA的。我们将通过执行以下步骤来实现：
- en: 'First, let''s create a domain object to hold the persistent logins, as shown
    in the following code snippet:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个领域对象来保存持久登录，如下面的代码片段所示：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we need to create a `o.s.d.jpa.repository.JpaRepository` repository instance,
    as shown in the following code snippet:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个`o.s.d.jpa.repository.JpaRepository`仓库实例，如下面的代码片段所示：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we need to create a custom `PersistentTokenRepository` interface to replace
    the `Jdbc` implementation. We have four methods we must override, but the code
    should look fairly familiar as we will be using JPA for all of the operations:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个自定义的`PersistentTokenRepository`接口来替换`Jdbc`实现。我们必须重写四个方法，但代码应该相当熟悉，因为我们所有操作都将使用JPA：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we need to make a few changes in the `SecurityConfig.java` file to declare
    the new `PersistentTokenTokenRepository` interface, but the rest of the configuration
    from the last section does not change, as shown in the following code snippet:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要在`SecurityConfig.java`文件中做些修改，以声明新的`PersistentTokenTokenRepository`接口，但其余的配置与上一节保持不变，如下面的代码片段所示：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is all we need to do to switch JDBC to JPA persistent-based remember-me
    authentication. Go ahead and start up the application and give it a try. From
    a user standpoint, we do not notice any differences, but we know that the implementation
    backing this feature has changed.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是我们将JDBC更改为基于JPA的持久化记住我认证所需要做的一切。现在启动应用程序并尝试一下。从用户的角度来看，我们并没有注意到任何区别，但我们知道支持这一功能的实现已经发生了变化。
- en: Your code should look like `chapter07.04-calendar`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码应该看起来像`chapter07.04-calendar`。
- en: Custom RememberMeServices
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义RememberMeServices
- en: Up to this point, we have used a fairly simple implementation of `PersistentTokenRepository`.
    We have used a JDBC-backed and JPA-backed implementation. This provided limited
    control over the cookie persistence; if we want more control, we wrap our `PersistentTokenRepository`
    interface in `RememberMeServices`. Barry Jaspan has a great article on *Improved
    Persistent Login Cookie Best Practice* ([http://jaspan.com/improved_persistent_login_cookie_best_practice](http://jaspan.com/improved_persistent_login_cookie_best_practice)).
    Spring Security has a slightly modified version, as previously described, called
    `PersistentTokenBasedRememberMeServices`, which we can wrap our custom `PersistentTokenRepository`
    interface in and use in our remember-me service.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用了一个相当简单的`PersistentTokenRepository`实现。我们使用了基于JDBC和基于JPA的实现。这为cookie持久化提供了有限的控制；如果我们想要更多控制，我们将把我们自己的`PersistentTokenRepository`接口包装在`RememberMeServices`中。Barry
    Jaspan有一篇关于*改进持久登录Cookie最佳实践*的优秀文章（[http://jaspan.com/improved_persistent_login_cookie_best_practice](http://jaspan.com/improved_persistent_login_cookie_best_practice)）。Spring
    Security有一个略有修改的版本，如前所述，称为`PersistentTokenBasedRememberMeServices`，我们可以将其包装在我们的自定义`PersistentTokenRepository`接口中，并在我们的记住我服务中使用。
- en: 'In the following section, we are going to wrap our existing `PersistentTokenRepository`
    interface with `PersistentTokenBasedRememberMeServices` and the use of the `rememberMeServices`
    method to wire it into our remember-me declaration:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将把我们的现有`PersistentTokenRepository`接口包装在`PersistentTokenBasedRememberMeServices`中，并使用`rememberMeServices`方法将其连接到我们的记住我声明：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Your code should look like `chapter07.05-calendar`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码应该看起来像`chapter07.05-calendar`。
- en: Are database-backed persistent tokens more secure?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 基于数据库的持久令牌是否更安全？
- en: Just like `TokenBasedRememberMeServices`, persistent tokens may be compromised
    by cookie theft or other man-in-the-middle techniques. The use of SSL, as covered
    in the Appendix, *Additional Reference Material* can circumvent man-in-the-middle
    techniques. If you are using a Servlet 3.0 environment (that is, Tomcat 7+), Spring
    Security will mark the cookie as `HttpOnly`, which will help to mitigate against
    the cookie being stolen in the event of an XSS vulnerability in the application.
    To learn more about the `HttpOnly` attribute, refer to the external resource on
    cookies provided earlier in the chapter.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`TokenBasedRememberMeServices`一样，持久化令牌可能会因cookie窃取或其他中间人技术而受到威胁。正如附录中提到的，使用SSL可以绕过中间人技术。如果你正在使用Servlet
    3.0环境（即Tomcat 7+），Spring Security会将cookie标记为`HttpOnly`，这将有助于减轻在应用程序中出现XSS漏洞时cookie被窃取的风险。要了解更多关于`HttpOnly`属性的信息，请参阅本章前面提供的关于cookie的外部资源。
- en: One of the advantages of using the persistent-based remember-me feature is that
    we can detect if the cookie is compromised. If the correct series token and an
    incorrect token is presented, we know that any remember-me feature using that
    series token should be considered compromised, and we should terminate any sessions
    associated with it. Since the validation is stateful, we can also terminate the
    specific remember-me feature without needing to change the user's password.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于持久化的记住我功能的一个优点是我们可以检测cookie是否被泄露。如果正确的一系列令牌和一个不正确的令牌被呈现，我们知道使用该系列令牌的任何记住我功能都应被视为被泄露，我们应该终止与它关联的任何会话。由于验证是状态ful的，我们还可以在不更改用户密码的情况下终止特定的记住我功能。
- en: Cleaning up the expired remember-me sessions
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理过期的记住我会话
- en: The downside of using the persistent-based remember-me feature is that there
    is no built-in support for cleaning up the expired sessions. In order to do this,
    we need to implement a background process that cleans up the expired sessions.
    We have included code in the chapter's sample code to perform the cleanup.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于持久化的记住我功能的缺点是，没有内置的支持来清理过期的会话。为了做到这一点，我们需要实现一个后台进程来清理过期的会话。我们在本章的示例代码中包含了用于执行清理的代码。
- en: 'For conciseness, we display a version that does not do validation or error
    handling in the following code snippet. You can view the full version in the sample
    code of this chapter:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我们显示一个不执行验证或错误处理的版本，如下面的代码片段所示。你可以在本章的示例代码中查看完整版本：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The sample code for this chapter also includes a simple Spring configuration
    that will execute the cleaner every ten minutes. If you are unfamiliar with Spring''s
    task abstraction and want to learn it, then you may want to read more about it
    in the Spring Reference at [https://docs.spring.io/spring/docs/current/spring-framework-reference/html/scheduling.html](https://docs.spring.io/spring/docs/current/spring-framework-reference/html/scheduling.html).
    You can find the relevant configuration in the following code snippet. For clarity,
    we are putting this scheduler in the `JavaConfig.java` file:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码还包括一个简单的Spring配置，每十分钟执行一次清理器。如果你不熟悉Spring的任务抽象并且想学习，那么你可能想阅读更多关于它在Spring参考文档中的内容：[https://docs.spring.io/spring/docs/current/spring-framework-reference/html/scheduling.html](https://docs.spring.io/spring/docs/current/spring-framework-reference/html/scheduling.html)。你可以在以下代码片段中找到相关的配置。为了清晰起见，我们将这个调度器放在`JavaConfig.java`文件中：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Keep in mind that this configuration is not cluster-aware. Therefore, if this
    is deployed to a cluster, the cleaner will execute once for every JVM that the
    application is deployed to.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，此配置不是集群友好的。因此，如果部署到集群，清理器将针对应用程序部署到的每个JVM执行一次。
- en: Start up the application and give the updates a try. The configuration that
    was provided will ensure that the cleaner is executed every ten minutes. You may
    want to change the cleaner task to run more frequently and to clean up the more
    recently used remember-me tokens by modifying the `@Scheduled` declaration. You
    can then create a few remember-me tokens and see that they get deleted by querying
    for them in the H2 database console.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序并尝试更新。提供的配置将确保每十分钟执行一次清理器。你可能想让清理任务更频繁地运行，通过修改`@Scheduled`声明来清理最近使用的记住我令牌。然后，你可以创建几个记住我令牌，并通过在H2数据库控制台查询它们来查看它们是否被删除。
- en: Your code should look like `chapter07.06-calendar`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码应该看起来像`chapter07.06-calendar`。
- en: The remember-me architecture
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记住我架构
- en: We have gone over the basic architecture of both `TokenBasedRememberMeServices`
    and `PersistentTokenBasedRememberMeServices`, but we have not described the overall
    architecture. Let's see how all of the remember-me pieces fit together.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了`TokenBasedRememberMeServices`和`PersistentTokenBasedRememberMeServices`的基本架构，但我们还没有描述总体架构。让我们看看所有remember-me部件是如何组合在一起的。
- en: 'The following diagram illustrates the different components involved in the
    process of validating a token-based remember-me token:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了验证基于令牌的remember-me令牌过程中涉及的不同组件：
- en: '![](img/10ed330e-3d74-468b-bcc1-2ba08fc03532.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/10ed330e-3d74-468b-bcc1-2ba08fc03532.png)'
- en: As with any of the Spring Security filters, `RememberMeAuthenticationFilter`
    is invoked from within `FilterChainProxy`. The job of `RememberMeAuthenticationFilter`
    is to inspect the request, and if it is of interest, an action is taken. The `RememberMeAuthenticationFilter`
    interface will use the `RememberMeServices` implementation to determine if the
    user is already logged in. The `RememberMeServices` interface does this by inspecting
    the HTTP request for a remember-me cookie that is then validated using either
    the token-based validation or the persistent-based validation we previously discussed.
    If the token checks out, the user will be logged in.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与Spring Security的任何一个过滤器一样，`RememberMeAuthenticationFilter`是从`FilterChainProxy`内部调用的。`RememberMeAuthenticationFilter`的工作是检查请求，如果它感兴趣，就采取行动。`RememberMeAuthenticationFilter`接口将使用`RememberMeServices`实现来确定用户是否已经登录。`RememberMeServices`接口通过检查HTTP请求中的remember-me
    cookie，然后使用我们之前讨论过的基于令牌的验证或基于持久性的验证来验证。如果令牌检查无误，用户将登录。
- en: Remember-me and the user life cycle
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Remember-me与用户生命周期
- en: 'The implementation of `RememberMeServices` is invoked at several points in
    the user life cycle (the life cycle of an authenticated user''s session). To assist
    you in your understanding of the remember-me functionality, it can be helpful
    to be aware of the points in time when remember-me services are informed of life
    cycle functions:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`RememberMeServices`的实现在整个用户生命周期中（认证用户的会话生命周期）的几个点被调用。为了帮助您理解remember-me功能，了解remember-me服务在生命周期功能通知的时间点可能会有所帮助：'
- en: '| **Action** | **What should happen?** | **The RememberMeServices method invoked**
    |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **应该发生什么？** | **调用的RememberMeServices方法** |'
- en: '| Successful login | Implementation sets a remember-me cookie (if the `form`
    parameter has been sent) | `loginSuccess` |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: 登录成功 | 实现设置remember-me cookie（如果已发送`form`参数） | `loginSuccess` |
- en: '| Failed login | Implementation should cancel the cookie, if it''s present
    | `loginFailed` |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: 登录失败 | 如果存在，实现应取消cookie | `loginFailed` |
- en: '| User logout | Implementation should cancel the cookie, if it''s present |
    `logout` |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: 用户登出 | 如果存在，实现应取消cookie | `logout` |
- en: The `logout` method is not present on the `RememberMeServices` interface. Instead,
    each `RememberMeServices` implementation also implements the `LogoutHandler` interface,
    which contains the `logout` method. By implementing the `LogoutHandler` interface,
    each `RememberMeServices` implementation can perform the necessary cleanup when
    the user logs out.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`RememberMeServices`接口上没有`logout`方法。相反，每个`RememberMeServices`实现也实现了`LogoutHandler`接口，该接口包含了`logout`方法。通过实现`LogoutHandler`接口，每个`RememberMeServices`实现可以在用户登出时执行必要的清理工作。'
- en: Knowing where and how `RememberMeServices` ties into the user's life cycle will
    be important when we begin to create custom authentication handlers, because we
    need to ensure that any authentication processor treats `RememberMeServices` consistently
    to preserve the usefulness and security of this functionality.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 了解`RememberMeServices`在哪里以及如何与用户的生命周期相关联，在我们开始创建自定义认证处理程序时将非常重要，因为我们需要确保任何认证处理器一致地对待`RememberMeServices`，以保持这种功能的有效性和安全性。
- en: Restricting the remember-me feature to an IP address
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制remember-me功能到IP地址
- en: Let's put our understanding of the remember-me architecture to use. A common
    requirement is that any remember-me token should be tied to the IP address of
    the user that created it. This adds additional security to the remember-me feature.
    To do this, we only need to implement a custom `PersistentTokenRepository` interface.
    The configuration changes that we will make will illustrate how to configure a
    custom `RememberMeServices`. Throughout this section, we will take a look at `IpAwarePersistentTokenRepository`,
    which is included in the chapter's source code. The `IpAwarePersistenTokenRepository`
    interface ensures that the series identifier is internally combined with the current
    user's IP address, and the series identifier includes only the identifier externally.
    This means that whenever a token is looked up or saved, the current IP address
    is used to lookup or persist the token. In the following code snippets, you can
    see how `IpAwarePersistentTokenRepository` works. If you want to dig in even deeper,
    we encourage you to view the source code included with the chapter.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把我们对记住我架构的理解付诸实践。一个常见的要求是，任何记住我令牌都应与创建它的用户的IP地址绑定。这为记住我功能增加了额外的安全性。为此，我们只需要实现一个自定义的`PersistentTokenRepository`接口。我们将要做的配置更改将说明如何配置自定义的`RememberMeServices`。在本节中，我们将查看`IpAwarePersistentTokenRepository`，该类包含在章节源代码中。`IpAwarePersistentTokenRepository`接口确保内部将系列标识与当前用户的IP地址结合，而外部仅包含标识。这意味着无论何时查找或保存令牌，都会使用当前IP地址来查找或持久化令牌。在以下代码片段中，你可以看到`IpAwarePersistentTokenRepository`是如何工作的。如果你想要更深入地了解，我们鼓励你查看随章节提供的源代码。
- en: 'The trick to looking up the IP address is using `RequestContextHolder` of Spring
    Security. The relevant code is as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 查找IP地址的技巧是使用Spring Security的`RequestContextHolder`。相关代码如下：
- en: It should be noted that in order to use `RequestContextHolder`, you need to
    ensure you have set up your `web.xml` file to use `RequestContextListener`. We
    have already performed this setup for our sample code. However, this can be useful
    when utilizing the example code in an external application. Refer to the Javadoc
    of `IpAwarePersistentTokenRepository` for details on how to set this up.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，为了使用`RequestContextHolder`，你需要确保你已经设置了你的`web.xml`文件以使用`RequestContextListener`。我们已经为我们的示例代码完成了这个设置。然而，这在使用示例代码的外部应用程序中可能很有用。参考`IpAwarePersistentTokenRepository`的Javadoc，了解如何进行此设置的详细信息。
- en: 'Take a look at the following code snippet:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下代码片段：
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can build on this method to force tokens that are saved to include the IP
    address in the series identifier, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在此基础上构建方法，强制保存的令牌中包含在系列标识中的IP地址，如下所示：
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can see that we first created a new series with the IP address concatenated
    to it. The `tokenWithSeries` method is just a helper that creates a new token
    with all of the same values, except a new series. We then submit the new token
    with a series identifier that includes the IP address to `delegateRepsository`,
    which is the original implementation of `PersistentTokenRepository`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们首先创建了一个新的系列，并将其与IP地址连接起来。`tokenWithSeries`方法只是一个创建具有所有相同值的新令牌的助手，除了新的系列。然后我们将包含IP地址的新系列标识的新令牌提交给`delegateRepsository`，这是`PersistentTokenRepository`的原始实现。
- en: 'Whenever the tokens are looked up, we require that the current user''s IP address
    is appended to the series identifier. This means that there is no way for a user
    to obtain a token for a user with a different IP address:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时查找令牌，我们都要求将当前用户的IP地址附加到系列标识上。这意味着用户无法获取不同IP地址的用户的令牌：
- en: '[PRE17]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The remainder of the code is quite similar. Internally, we construct the series
    identifier to be appended to the IP address, and externally, we present only the
    original series identifier. By doing this, we enforce the constraint that only
    the user who created the remember-me token can use it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的代码非常相似。内部我们构建的系列标识将附加到IP地址上，外部我们只展示原始系列标识。通过这样做，我们实施了这样的约束：只有创建了记住我令牌的用户才能使用它。
- en: 'Let''s review the Spring configuration included in this chapter''s sample code
    for `IpAwarePersistentTokenRepository`. In the following code snippet, we first
    create the `IpAwarePersistentTokenRepository` declaration that wraps a new `JpaPersistentTokenRepository`
    declaration. We then initialize a `RequestContextFilter` class by instantiating
    an `OrderedRequestContextFilter` interface:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下本章示例代码中包含的Spring配置，用于`IpAwarePersistentTokenRepository`。在以下代码片段中，我们首先创建了一个`IpAwarePersistentTokenRepository`声明，它包装了一个新的`JpaPersistentTokenRepository`声明。然后通过实例化`OrderedRequestContextFilter`接口来初始化一个`RequestContextFilter`类：
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In order for Spring Security to utilize our custom `RememberMeServices`, we
    need to update our security configuration to point to it. Go ahead and make the
    following updates to `SecurityConfig.java`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Spring Security使用我们的自定义`RememberMeServices`，我们需要更新我们的安全配置以指向它。接着，在`SecurityConfig.java`中进行以下更新：
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, go ahead and start up the application. You can use the second computer
    along with a plugin, such as Firebug, to manipulate your remember-me cookie. If
    you try to use the remember-me cookie from one computer on another computer, Spring
    Security will now ignore the remember-me request and delete the associated cookie.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，大胆尝试启动应用程序。您可以使用第二台计算机和插件（如Firebug），来操作您的remember-me cookie。如果您尝试从一个计算机使用remember-me
    cookie在另一台计算机上，Spring Security现在将忽略remember-me请求并删除相关cookie。
- en: Your code should look like `chapter07.07-calendar`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码应类似于`chapter07.07-calendar`。
- en: Note that the IP-based remember-me tokens may behave unexpectedly if the user
    is behind a shared or load balanced network infrastructure, such as a multi-WAN
    corporate environment. In most scenarios, however, the addition of an IP address
    to the remember-me function provides an additional, welcome layer of security
    to a helpful user feature.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，基于IP的remember-me令牌如果用户位于共享或负载均衡的网络基础架构后面，例如多WAN企业环境，可能会出现意外行为。然而，在大多数场景下，向remember-me功能添加IP地址为用户提供了一个额外的、受欢迎的安全层。
- en: Custom cookie and HTTP parameter names
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义cookie和HTTP参数名称
- en: 'Curious users may wonder if the expected value of the remember-me form field
    checkbox to be remember-me, or the cookie name to be remember-me, can be changed
    to obscure the use of Spring Security. This change can be made in one of two locations.
    Take a look at the following steps:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 好奇的用户可能会想知道remember-me表单字段的预期值是否可以更改为remember-me，或者cookie名称是否可以更改为remember-me，以使Spring
    Security的使用变得模糊。这个更改可以在两个位置中的一个进行。请按照以下步骤查看：
- en: 'First, we can add additional methods to the `rememberMe` method, as follows:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们可以在`rememberMe`方法中添加额外的方法，如下所示：
- en: '[PRE20]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Additionally, now that we''ve declared our own `RememberMeServices` implementation
    as a Spring bean, we can simply define more properties to change the checkbox
    and cookie names, as follows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，既然我们已经将自定义的`RememberMeServices`实现声明为Spring bean，我们只需定义更多的属性来更改复选框和cookie名称，如下所示：
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Don''t forget to change the `login.html` page to set the name of the checkbox
    `form` field and to match the parameter value we declared. Go ahead and make the
    updates to `login.html`, as follows:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记将`login.html`页面更改为设置复选框`form`字段的名称，并与我们声明的参数值相匹配。接着，按照以下内容更新`login.html`：
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We'd encourage you to experiment here to ensure you understand how these settings
    are related. Go ahead and start up the application and give it a try.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们鼓励您在此处进行实验，以确保您了解这些设置之间的关系。大胆尝试启动应用程序并尝试一下。
- en: Your code should look like `chapter07.08-calendar`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码应类似于`chapter07.08-calendar`。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter explained and demonstrated the use of the remember-me feature in
    Spring Security. We started with the most basic setup and learned how to gradually
    make the feature more secure. Specifically, we learned about a token-based remember-me
    service and how to configure it. We also explore how persistent-based remember-me
    services can provide additional security, how it works, and the additional considerations
    necessary when using them.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释并演示了Spring Security中remember-me功能的用法。我们从最基本的设置开始，学习了如何逐步使该功能更加安全。具体来说，我们了解了基于令牌的remember-me服务以及如何对其进行配置。我们还探讨了基于持久性的remember-me服务如何提供额外的安全功能，它是如何工作的，以及在使用它们时需要考虑的额外因素。
- en: We also covered the creation of a custom remember-me implementation that restricts
    the remember-me token to a specific IP address. We saw various other ways to make
    the remember-me feature more secure.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了创建自定义remember-me实现的过程，该实现将remember-me令牌限制为特定的IP地址。我们还看到了使remember-me功能更加安全的各种其他方法。
- en: Up next is certificate-based authentication, and we will discuss how to use
    trusted client-side certificates to perform authentication.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是基于证书的认证，我们将讨论如何使用受信任的客户端证书来进行认证。
