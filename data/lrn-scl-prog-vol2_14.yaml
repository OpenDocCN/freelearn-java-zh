- en: Testing in Scala
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala中的测试
- en: '"Change is the end result of all the true learning."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “改变是所有真正学习的最终结果。”
- en: '- Leo Buscaglia'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- 利奥·布斯卡利亚'
- en: 'Software development is an ever transforming process. We have seen in recent
    decades that many patterns have been discovered/rediscovered. These programming
    techniques/paradigms have become an important part and have changed the way we
    approach programming. One of them is **Test-Driven Development **(**TDD**). In
    the TDD approach, we first specify the requirement for our application through
    new tests. Then, one by one, we write concrete code to pass all those tests. In
    this manner, we complete our requirements by writing new test cases, implementing
    code to pass them, and end up building an application that runs as expected. Scala
    provides many frameworks for testing (for example, **ScalaTest***,* **Specs2**,
    and so on) and we have **Mockito** and **ScalaMock**for mocking objects*.* Testing,
    in a way, is a small concept with a vast number of explanations possible. In this
    chapter, we''ll focus on understanding the TDD approach and the way we can follow
    this approach to successfully apply it in Scala. For that, we''ll go through:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发是一个不断变化的过程。在过去的几十年里，我们已经看到许多模式被发现/重新发现。这些编程技术/范式已经成为一个重要的部分，并改变了我们处理编程的方式。其中之一是**测试驱动开发**（**TDD**）。在TDD方法中，我们首先通过新测试指定我们应用程序的需求。然后，一个接一个地，我们编写具体的代码来通过所有这些测试。通过这种方式，我们通过编写新的测试用例、实现通过它们的代码，最终构建了一个按预期运行的程序。Scala提供了许多测试框架（例如，**ScalaTest**、**Specs2**等），我们还有**Mockito**和**ScalaMock**用于模拟对象。从某种意义上说，测试是一个小概念，但可以有大量的解释。在本章中，我们将专注于理解TDD方法以及我们如何遵循这种方法在Scala中成功应用它。为此，我们将通过以下内容进行学习：
- en: The why and what of TDD
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TDD的为什么和是什么
- en: The process of TDD
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: TDD的过程
- en: '**Behavior-driven development** (**BDD**)'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为驱动开发**（**BDD**）'
- en: ScalaTest
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ScalaTest
- en: ScalaCheck
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ScalaCheck
- en: So, let's start with why this rocket called TDD is flying so high in the software
    development space nowadays.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们从为什么这个被称为TDD的火箭在当今软件开发空间中飞得如此之高开始吧。
- en: The why and what of TDD
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD的为什么和是什么
- en: To write expected and well-designed software, we tend to clarify the requirements
    before starting the development process. With agile practices in place, we translate
    our requirements to what we call user/functional stories. Transforming these stories
    into a simple specification of what we're going to implement adds an advantage.
    That's where writing test cases comes in handy. We specify our program's behavior
    in the form of test cases and then implement those behaviors.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写预期和设计良好的软件，我们倾向于在开发过程开始之前明确需求。有了敏捷实践，我们将需求转化为我们所说的用户/功能故事。将这些故事转化为我们将要实现的简单规范增加了优势。这就是编写测试用例派上用场的地方。我们以测试用例的形式指定我们程序的行为，然后实现这些行为。
- en: There are some advantages to this approach. Writing test cases first and then
    providing the implementation drives the design of our program. It means that as
    we approach toward implementing the behavior, we can think of our design and code
    for that. If one of your classes, `A`, is dependent on another class, `B`, we
    can make sure that *B* is injected into *A.* In a way, we can make it a practice
    to follow these ways, for example, inject dependencies from other classes. Apart
    from driving the design of your application, TDD also helps us think about the
    use cases and the way in which users of our application might use it. It helps
    us think clearly about the interface the user is going to get so that we can code
    accordingly.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有一些优点。先编写测试用例然后提供实现可以推动我们程序的设计。这意味着当我们接近实现行为时，我们可以思考我们的设计和代码。如果你的一个类`A`依赖于另一个类`B`，我们可以确保将`B`注入到`A`中。从某种意义上说，我们可以将其作为一种习惯来遵循这些方法，例如，从其他类中注入依赖。除了推动应用程序的设计，TDD还有助于我们思考用例以及我们的应用程序用户可能使用它的方式。它帮助我们清晰地思考用户将获得的接口，以便我们可以相应地编写代码。
- en: In TDD, just because we tend to write test cases first, we cover almost all
    lines of our software implementation. This provides automatic code coverage to
    us. Let's take a look at the process of TDD.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在TDD中，尽管我们倾向于先编写测试用例，但我们几乎覆盖了软件实现的全部行。这为我们提供了自动的代码覆盖率。让我们看看TDD的过程。
- en: The process of TDD
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD的过程
- en: 'As per the approach, we can break down the process of TDD into the following
    steps. The process can be included in your development workflow:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这种方法，我们可以将TDD的过程分解为以下步骤。这个过程可以包含在你的开发工作流程中：
- en: Write a test that will fail.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个会失败的测试。
- en: Write some code to pass the failing test.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一些代码以通过失败的测试。
- en: Refactor your code to improve quality without any changes in the behavior.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重构你的代码以提升质量，同时不改变行为。
- en: Repeat *steps 1* to *3.*
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤1到3。
- en: We broke down the process into these steps. Let's take a look at each of these
    steps to better understand the reasoning behind each of these.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个过程分解成这些步骤。让我们看看每个步骤，以更好地理解每个步骤背后的推理。
- en: Step 1 - write a test that will fail
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1步 - 编写一个会失败的测试
- en: Writing to fail is not something we feel confident about, but that's how TDD
    works. After we've determined what's needed from our application and are sure
    about a certain functionality, we can write a test case for functionality in the
    way we want it to work. We want to make sure that we run this test case and that
    it fails. The failure of our test case is expected because we have not implemented
    any code yet to make it successful. The initial failure we mean is step one of
    TDD.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 编写失败的代码并不是我们感到自信的事情，但这就是TDD的工作方式。在我们确定应用程序需要什么以及我们对某个功能有信心之后，我们可以按照我们希望它工作的方式编写功能测试用例。我们想确保运行这个测试用例，并且它失败了。我们的测试用例失败是预期的，因为我们还没有实现任何代码来使其成功。我们所说的初始失败是TDD的第一步。
- en: Step 2 - write code to pass the failing test
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2步 - 编写代码以通过失败的测试
- en: The best thing about this step is to know how we have to pass a failing test
    case. For that, we'll implement a functionality. In this step, we'll have to write
    some code. We can try to implement a function, not in the best way possible, but
    enough to pass the failing test. Passing a test guarantees the particular behavior
    of a functionality.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个步骤最好的地方是知道我们如何通过一个失败的测试用例。为此，我们将实现一个功能。在这个步骤中，我们需要编写一些代码。我们可以尝试以不是最佳的方式实现一个函数，但足以通过失败的测试。通过测试保证了特定功能的行为。
- en: Step 3 - refactor the code to improve the quality
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3步 - 重构代码以提升质量
- en: Now that we are confident that our functionality is working, we can go ahead
    and improve the code quality. If the functionality isn't too big, then this step
    can be a part of the previous one. It's logical to have a review of our code once
    the functionality is working. This might improve the quality of our code. After
    the refactor, we should ensure that the feature/functionality is in a working
    state and is intact.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们确信我们的功能正在工作，我们可以继续提高代码质量。如果功能不是很大，那么这一步可以是之前步骤的一部分。在功能工作后进行代码审查是合乎逻辑的。这可能会提高我们代码的质量。重构后，我们应该确保特性/功能处于工作状态且完好无损。
- en: Step 4 - repeat steps 1 to 3
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4步 - 重复步骤1到3
- en: Now, for this particular functionality, for which we wrote test cases and implemented
    code, we have ensured that it's working and the code quality is proper. We are
    done with this particular feature/functionality and now can write another test
    case and repeat the process steps.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于这个特定的功能，我们已经编写了测试用例并实现了代码，我们确保了它正在工作，代码质量是合适的。我们完成了这个特定的特性/功能，现在可以编写另一个测试用例并重复这个过程步骤。
- en: 'We can visualize the working of TDD as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样可视化TDD（测试驱动开发）的工作流程：
- en: '![](img/00076.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00076.jpeg)'
- en: From the previous diagram, it's clear that TDD is a repetitive process, where
    you specify a use case and write code for it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的图中可以看出，TDD是一个重复的过程，其中你指定一个用例并为它编写代码。
- en: One of the benefits of TDD is that our tests serve as a documentation. Library/framework
    developers tend to write test cases that serve the purpose of documentation too.
    How? By making use of DSL or, let's say, English-like sentences for designing
    our test suites. A test suite consists of multiple test cases for our program.
    Let's take a look at the scenario we have used in a couple of our chapters. The
    example we will be using is where we will read Football player's data from a CSV
    file named `football.csv`, convert those to `Player` objects, and further use
    the data to display the player's information or perform some analytics based on
    the information. How would we want to proceed with the test cases for such a scenario,
    or at least, how should it look when we say "English-like sentences" for our specifications?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: TDD的一个好处是我们的测试充当了文档。库/框架开发者倾向于编写测试用例，这些测试用例也服务于文档的目的。如何？通过使用领域特定语言（DSL）或者，让我们说，使用类似英语的句子来设计我们的测试套件。一个测试套件由我们程序的多个测试用例组成。让我们看看我们在几个章节中使用的场景。我们将使用的例子是从名为`football.csv`的CSV文件中读取足球运动员的数据，将其转换为`Player`对象，并进一步使用这些数据来显示球员信息或基于这些信息进行一些分析。我们如何进行这样的场景的测试用例，或者至少，当我们说“类似英语的句子”来指定规范时，它应该是什么样子？
- en: Scenario
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景
- en: 'Read the player data and showcase that on the console:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 读取玩家数据并在控制台上展示：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the given example scenario, we specified a service and named it `PlayerService`.
    Now, this service should have the methods that perform the specified cases. These
    cases are not too complicated, but each case expects our service to provide a
    simple functionality. This example is for explanation purposes, since we've already
    seen the code. We'll also try and implement the same using the TDD approach.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定的示例场景中，我们指定了一个服务并命名为 `PlayerService`。现在，这个服务应该有执行指定案例的方法。这些案例并不太复杂，但每个案例都期望我们的服务提供简单的功能。这个例子是为了解释目的，因为我们已经看到了代码。我们还将尝试使用测试驱动开发（TDD）方法来实现它。
- en: 'The point worth nothing about the preceding test specification is that before
    even trying to code, we are sure about certain things:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试规范值得注意的一点是，在尝试编码之前，我们确实对某些事情有把握：
- en: There should be a `PlayerService` service.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该有一个 `PlayerService` 服务。
- en: In `PlayerService`*,* we should have a `Player` entity*.*
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `PlayerService`*，* 中我们应该有一个 `Player` 实体*。
- en: In `PlayerService`*,* we should have a functionality to read the player's data.
    It has to be a collection; when the source can't be read or the source contains
    no data, the functionality should return an empty collection.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `PlayerService`*，* 中我们应该有一个读取玩家数据的功能。它必须是一个集合；当源无法读取或源不包含数据时，该功能应返回一个空集合。
- en: In `PlayerService`*,* there should be a `getPlayer` functionality that expects
    us to provide some data to it and return a concrete `Player` entity. When we provide
    wrong data (as in the format), the functionality doesn't throw an exception, but
    specifies that it couldn't create a concrete `Player` entity.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `PlayerService`*，* 中应该有一个 `getPlayer` 功能，它期望我们提供一些数据给它，并返回一个具体的 `Player` 实体。当我们提供错误数据（如格式）时，功能不会抛出异常，但指定它无法创建具体的
    `Player` 实体。
- en: In `PlayerService`*,* there should be a `getPlayer` functionality which expects
    us to provide some data to it and return a concrete *Player* entity on receiving
    correct data.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `PlayerService`*，* 中应该有一个 `getPlayer` 功能，它期望我们提供一些数据给它，并在接收到正确数据时返回一个具体的 *Player*
    实体。
- en: In `PlayerService`*,* there should be a `showPlayers` functionality which expects
    us to provide a collection of `Player` entities and print the player's information
    on the console.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `PlayerService`*，* 中应该有一个 `showPlayers` 功能，它期望我们提供一个 `Player` 实体的集合，并在控制台上打印玩家的信息。
- en: The fact that the preceding points and specifications we mentioned are similar
    in semantic meaning and that we can use one of these to write test cases makes
    TDD fun. These test specifications are too close to real-world test specs that
    we'll be writing. Take a closer look at the specification we just described; nowhere
    does it state about the programming language choice we had to make. We didn't
    get any hint about the language specifications, so these test cases will work
    in any language if the programming language we use can support such **domain-specific
    language** (**DSL**) lookalike mechanisms.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 事实是，我们之前提到的点和规范在语义上是相似的，并且我们可以使用其中之一来编写测试用例，这使得测试驱动开发（TDD）变得有趣。这些测试规范与我们将要编写的真实世界测试规范非常接近。仔细看看我们刚才描述的规范；它没有提到我们必须做出的编程语言选择。我们没有得到任何关于语言规范的提示，所以如果使用的编程语言可以支持这样的
    **领域特定语言**（**DSL**）类似机制，这些测试用例将适用于任何语言。
- en: This specification does not limit you to write test cases only in a specified
    format, but you can choose your own style of writing them. This is one of the
    conventions that emerged from TDD, and it's called **behavior-driven development**
    (**BDD**). This term BDD drives itself by specifying behaviors in order to start the
    development of any functionality. It also serves as documentation to our program.
    If you see the specification we wrote, in a way, we documented the way we can
    use functionalities. If these specs were written in Scala, we could have provided
    the method names according to the functionalities.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规范并不限制你只以指定格式编写测试用例，你可以选择自己的写作风格。这是从测试驱动开发（TDD）中出现的惯例之一，被称为 **行为驱动开发**（**BDD**）。这个术语BDD通过指定行为来驱动开发任何功能。它还充当我们程序的文档。如果你看到我们编写的规范，从某种意义上说，我们记录了我们可以使用功能的方式。如果这些规范是用Scala编写的，我们就可以根据功能提供方法名称。
- en: Let's discuss a bit about this way of driving development by specifying the
    behaviors.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下通过指定行为来驱动开发的方式。
- en: Behavior driven development (BDD)
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为驱动开发（BDD）
- en: We already saw the *should ... in* way of specifying the behavior of our functionality.
    There are other ways to specify the behaviors, or let's say, ensure the validity
    of our functionality. One of the example is *given**... when**... then**....*
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了指定我们功能行为的方式，即使用*should ... in*。还有其他方式来指定行为，或者说，确保我们功能的有效性。一个例子是*given**...
    when**... then**....*
- en: 'Here, we specify the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定以下内容：
- en: '**Given**: This is what is available at the time of executing some functionality'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Given**: 这是执行某些功能时可用的情况'
- en: '**When***:* We confront a condition that is based on the data that''s given'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**When***:* 我们面对的是一个基于给定数据的条件'
- en: '**Then***:* Execute the part which is expected to happen'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Then***:* 执行预期发生的部分'
- en: In this way, we validate the behavior of our functionality. One of the best
    practices when we write test cases for one of the functionalities is to specify
    all the possible scenarios (ideally, that's not possible, but we try our best
    to include all possibilities we can think of). These scenarios include the *empty
    case*, *unit case*, and *failure case*. Finally, we cover all the conditional
    possibilities. With these, we ensure the specifications are valid and that our
    implementations are too. These specifications serve as acceptance criteria for
    our functionality. There are lesser chances of you slipping past some important
    case. It's important to know that there's no hard and fast rule to describe our
    test cases.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，我们验证了功能的行为。当我们为某个功能编写测试用例时，最佳实践之一是指定所有可能的场景（理想情况下，这是不可能的，但我们尽力包括所有我们能想到的可能性）。这些场景包括*空场景*、*单元场景*和*失败场景*。最后，我们覆盖了所有条件可能性。有了这些，我们确保规范是有效的，我们的实现也是。这些规范作为我们功能性的验收标准。你漏掉一些重要情况的几率较小。重要的是要知道，描述我们的测试用例没有硬性规定。
- en: One of the benefits of behavior-driven development is that instead of talking
    in terms of tests, we talk in terms of specifications or scenarios. Hence, not
    just developers, but most of the business stakeholders and domain experts can
    also specify the requirements for an application.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 行为驱动开发的一个好处是，我们不是用测试术语来谈论，而是用规范或场景来谈论。因此，不仅开发者，大多数业务利益相关者和领域专家也可以指定应用程序的需求。
- en: Now, talking about Scala's offering for frameworks or toolkits provided for
    testing, there are a bunch of them. **ScalaTest**, **ScalaCheck**, and **Specs2**
    are a few that developers are using to write tests for their code. We'll go through
    one of the mostly widely used testing tools, ScalaTest, and try to see the way
    specs are implemented using examples.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，谈到Scala为测试提供的框架或工具包，有很多。**ScalaTest**、**ScalaCheck**和**Specs2**是开发者用来为代码编写测试的几个例子。我们将通过最广泛使用的测试工具之一，ScalaTest，并尝试通过示例查看规范是如何实现的。
- en: ScalaTest
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ScalaTest
- en: ScalaTest, as we mentioned, is famous for multiple styles provided to write
    specifications. Not just multiple styles, this kit also serves as a testing tool
    for **Scala.js** and even Java classes. ScalaTest covers most of the Scala ecosystem
    and allows you to choose different ways to write specifications based on the behavior
    of your functionality.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所提到的，ScalaTest因其提供的多种编写规范的风格而闻名。不仅限于多种风格，这个套件还作为**Scala.js**和Java类的测试工具。ScalaTest涵盖了Scala生态系统的大部分内容，并允许你根据功能的行为选择不同的方式来编写规范。
- en: Setting up for testing
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置测试环境
- en: 'To use ScalaTest, let''s go through some of the basic steps. We can create
    a fresh SBT project and add a dependency for **ScalaTest** via the `build.sbt` file
    or use Lightbend''s tech hub to download a simple Scala project. Let''s try out
    the second approach as it''ll give us ScalaTest already added as a dependency
    in our `build.sbt` file. Let''s follow these steps:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用ScalaTest，让我们通过一些基本步骤。我们可以创建一个新的SBT项目，并通过`build.sbt`文件添加**ScalaTest**依赖项，或者使用Lightbend的技术中心下载一个简单的Scala项目。让我们尝试第二种方法，因为它会在我们的`build.sbt`文件中添加ScalaTest作为依赖项。让我们按照以下步骤进行：
- en: In your favorite browser, open: [https://developer.lightbend.com](https://developer.lightbend.com).
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你喜欢的浏览器中打开：[https://developer.lightbend.com](https://developer.lightbend.com)。
- en: 'Click on the START A PROJECT button:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击START A PROJECT按钮：
- en: '![](img/00077.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00077.jpeg)'
- en: 'Choose Scala from project types:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目类型中选择Scala：
- en: '![](img/00078.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00078.jpeg)'
- en: You can name the project and click on CREATE A PROJECT FOR ME!*:*
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以命名项目并点击CREATE A PROJECT FOR ME!*：
- en: '![](img/00079.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00079.jpeg)'
- en: This will download a compressed file for you with the name you specified. Extract
    the compressed file to a specific location and open it in the IntelliJ IDE.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为你下载一个名为你指定的压缩文件。将压缩文件提取到特定位置并在IntelliJ IDE中打开它。
- en: 'We can open `build.sbt` to check the dependencies and project settings specified.
    Our `sbtbuild` file should look like as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以打开`build.sbt`来检查指定的依赖项和项目设置。我们的`sbtbuild`文件应该看起来像以下这样：
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, in the `libraryDependencies` settings, `scalaTest` is specified. Hence,
    we can use that. The sample project comes with some source code and test covering
    it. So, we''ll first try to run the test case. If you can see the `scalatest`
    library in the external dependencies directory, as shown in the following diagram,
    then we''re ready to execute tests:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在`libraryDependencies`设置中，指定了`scalaTest`。因此，我们可以使用它。示例项目包含一些源代码和测试。所以，我们首先尝试运行测试案例。如果你可以看到外部依赖目录中的`scalatest`库，如图所示，那么我们就准备好执行测试了：
- en: '![](img/00080.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00080.jpeg)'
- en: 'If these libraries are not shown in your project structure, we can fire the `sbt
    update` command so that SBT can download all the dependencies specified. There''re
    a few more SBT commands that we will use to run our test cases. Let''s take a
    look at them:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些库没有显示在你的项目结构中，我们可以执行`sbt update`命令，这样SBT就可以下载所有指定的依赖项。我们还将使用一些SBT命令来运行我们的测试案例。让我们看看它们：
- en: '`sbt test`: SBT assumes that test sources for Scala are located in the `src/test/scala`
    directory and resources like the configurations for test sources are located in
    the `src/test/resources` directory'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sbt test`：SBT假设Scala的测试源位于`src/test/scala`目录，而测试源的资源，如测试源的配置，位于`src/test/resources`目录'
- en: Based on previously described assumptions, when we fire a command described
    in the preceding text, SBT compiles all test files present in the respective locations
    and tests all of them. What if you're only concerned about specific test cases?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 根据之前描述的假设，当我们执行前文所述的命令时，SBT将编译相应位置的所有测试文件并对它们进行测试。如果你只关心特定的测试案例怎么办？
- en: '`sbt testOnly`: Based on similar assumptions that we had for the `sbt test`
    command, when we fire the `testOnly` command, SBT compiles and tests only test
    cases that we specified along with the command. Consider the following example:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sbt testOnly`：基于我们对`sbt test`命令的类似假设，当我们执行`testOnly`命令时，SBT仅编译和测试我们通过命令指定的测试案例。考虑以下示例：'
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`sbt testQuick`: Based on similar assumptions that we had for the `sbt test`
    command, when we fire the `testQuick` command, SBT compiles and tests only those
    test cases that fulfil the following conditions:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sbt testQuick`：基于我们对`sbt test`命令的类似假设，当我们执行`testQuick`命令时，SBT仅编译和测试满足以下条件的测试案例：'
- en: Failing tests from the previous runs
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上次运行失败的测试
- en: Tests that have not run yet
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尚未运行的测试
- en: Tests with transitive dependencies
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有传递性依赖的测试
- en: 'These are a few Scala commands we use to test our cases. Also, while testing
    our specs, we''ll use triggered execution. We initiate triggered execution by
    putting `~` before our test command. With this, SBT expects a save change, and
    saving the file again triggers a test execution. So with this, try out this command,
    assuming that we have the SBT shell opened (open the project directory, where
    `build.sbt` is located and the trigger `sbt` command) in the command prompt of
    our choice. Let''s locate our project in the SBT shell and fire the following
    command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们用来测试案例的几个Scala命令。此外，在测试我们的规范时，我们将使用触发执行。我们通过在测试命令前加上`~`来启动触发执行。这样，SBT期望保存更改，再次保存文件将触发测试执行。因此，尝试这个命令，假设我们已经打开了SBT
    shell（在命令提示符中打开项目目录，其中包含`build.sbt`文件和触发`sbt`命令的位置）。让我们在SBT shell中定位我们的项目并执行以下命令：
- en: '![](img/00081.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00081.jpeg)'
- en: There's this `HelloSpec` class*,* located in the test directory of the project
    we downloaded. If everything works right, as it should, we'll get our tests passed
    and you'll start loving the *green* color. But if the code is red, this means
    it has failed. So, we're ready to delve into `ScalaTest`*.*
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们下载的项目测试目录中有一个名为`HelloSpec`的类*，*。如果一切正常，我们应该通过测试，你将开始喜欢*绿色*的颜色。但如果代码是红色，这意味着它失败了。所以，我们准备深入研究`ScalaTest`*.*
- en: Testing in style using ScalaTest
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ScalaTest进行风格化的测试
- en: 'We''ve tested the `HelloSpec` class*,* so we''ll take a look at the test, and
    the way it''s written. So, we can open the file `Hello` located in `src/test/scala/example`*.*
    The source code looks as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经测试了`HelloSpec`类*，所以我们将查看测试以及它的编写方式。因此，我们可以打开位于`src/test/scala/example`的文件`Hello`*。源代码如下：
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Taking a look at the code sample, we can observe a few points:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下代码示例，我们可以观察到几个要点：
- en: We've imported `org.scalatest._` to bring all the traits we want to use.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们导入了`org.scalatest._`以引入我们想要使用的所有特性。
- en: The class definition named `HelloSpec` extends `FlatSpec` along with the mix-in
    `Matchers` class. It's a convention to name our test specifications as class name
    followed by `Spec`.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名为`HelloSpec`的类定义扩展了`FlatSpec`以及混合`Matchers`类。将我们的测试规范命名为类名后跟`Spec`是一种约定。
- en: The definition consists of only one *specification.* The specification states
    that "there's an object named Hello that says hello in the specified code snippet".
    That's how cool it is—the specification is written in a way any English sentence
    can be written.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义只包含一个*规范*。规范声明“有一个名为Hello的对象，在指定的代码片段中说hello”。这就是它多么酷——规范是以任何英语句子都可以编写的方式编写的。
- en: The specification is written in a DSL-like manner. The language looks natural,
    and further down, the specification states that there's going to be a method call
    that returns a string equal to `hello`.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规范是以类似DSL的方式编写的。语言看起来很自然，进一步下文，规范声明将有一个返回字符串等于`hello`的方法调用。
- en: The call to `shouldEqual` is a `Matcher`*.* The job of a `Matcher` is to match
    the left operand with the right operand. There are several other ways to write
    such `Matchers`, but we'll talk about those in subsequent sections.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`shouldEqual`的调用是一个`Matcher`*。`Matcher`的职责是将左操作数与右操作数匹配。还有几种其他方式可以编写这样的`Matchers`，但我们将后续章节中再讨论这些。
- en: 'That''s very simple and everything''s good till now. Now, let''s take a look
    at the corresponding code file written in the location `src/main/scala/example`*.*
    Let''s look at the file named `Hello.scala`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简单，到目前为止一切都很顺利。现在，让我们看看位于`src/main/scala/example`位置的相应代码文件*。让我们看看名为`Hello.scala`的文件：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There's this object named `Hello` according to our specification. We can make
    a call to `greeting`*,* which does nothing but print this string, `hello`*.* Well,
    this example was already available for us to observe, hence we didn't follow TDD.
    But we'll try writing something similar to this using the *test first approach*
    by specifying the behavior.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的规范，有一个名为`Hello`的对象。我们可以调用`greeting`*，它除了打印这个字符串`hello`*之外，什么都不做。嗯，这个例子已经对我们来说是可以观察到的，所以我们没有遵循TDD。但我们将尝试通过指定行为来编写类似的东西，使用*测试优先方法*。
- en: 'Before writing the first spec on our own, let''s follow some convention or
    one of the good practices and create an abstract class that extends `FlatSpec` 
    with `Matchers` by default so that we don''t have to extend those in every spec
    we write. We can do this by creating a spec file, and let''s name it `SomeSpec`
    and save it in the `src/test/scala/example/` directory. It should look like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写自己的第一个规范之前，让我们遵循一些约定或一项好的实践，创建一个扩展`FlatSpec`并默认带有`Matchers`的抽象类，这样我们就不必在编写的每个规范中扩展它们。我们可以通过创建一个规范文件来实现这一点，让我们将其命名为`SomeSpec`并保存在`src/test/scala/example/`目录中。它应该看起来像这样：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we've created some abstract class that extends the `FlatSpec` and `Matchers`
    classes, we are ready to follow our first step in TDD to write one failing test
    spec. Our `SomeSpec` abstract class takes a parameter named `toBeTested`, which
    is nothing but the name of the functionality.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建了一些扩展`FlatSpec`和`Matchers`类的抽象类，我们准备遵循TDD的第一步来编写一个失败的测试规范。我们的`SomeSpec`抽象类接受一个名为`toBeTested`的参数，它只是功能名称。
- en: 'Let''s create another test spec, name it `PlayerSpec`, and save it as `src/test/scala/example`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建另一个测试规范，命名为`PlayerSpec`，并保存在`src/test/scala/example`：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s write the Player case class:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写`Player`案例类：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With this code, we can save the file, and as our test is running in the *triggered
    mode,* we can see that the test case passes:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，我们可以保存文件，由于我们的测试是在*触发模式*下运行的，我们可以看到测试用例通过了：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We''ll follow the same steps again. So, let''s write a few more test cases:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次遵循相同的步骤。所以，让我们编写一些更多的测试用例：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As we are clear about the behavior of our functionality, we wrote a few more
    test cases. Now, our spec includes more test clauses. We have used a few `Matchers`
    available to us. Let''s see how our tests work:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对我们的功能行为有了清晰的了解，因此我们编写了更多的测试用例。现在，我们的规范包括了更多的测试条款。我们已经使用了几个可用的`Matchers`。让我们看看我们的测试是如何工作的：
- en: After checking for our code, it should compile. In the next clause, we specified
    that our code should throw `FileNotFoundException` when we try to access the wrong
    file path. We used an assertion `assertThrows` to specify such behavior. Here,
    we didn't have to specify any `Matchers` since specifying an *Assertion* was enough.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查我们的代码后，它应该能够编译。在下一个条款中，我们指定了当尝试访问错误的文件路径时，我们的代码应该抛出`FileNotFoundException`。我们使用了`assertThrows`断言来指定这种行为。在这里，我们不需要指定任何`Matchers`，因为指定一个*断言*就足够了。
- en: In the next clause, we mentioned that the result of `readPlayerDataFromSource` should
    not be empty, empty as in a collection.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个条款中，我们提到`readPlayerDataFromSource`的结果不应该为空，这里的空指的是集合为空。
- en: The next spec clause expects to return `None` when we try to call `parseToPlayer`
    with the wrong formatted data to a `Player` instance.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个规范条款期望当我们尝试用错误格式的数据调用`parseToPlayer`方法到`Player`实例时，将返回`None`。
- en: Finally, we expect the `parseToPlayer` method to return a player object when
    we call it with data in the correct format.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当我们用正确格式的数据调用`parseToPlayer`方法时，我们期望它返回一个玩家对象。
- en: 'It''s clear from our specification and clauses mentioned what we exactly want
    from our functionality. When we try to run the test case, it doesn''t compile
    because we don''t have our methods `readPlayerDataFromSource` and `parseToPlayer`.
    We can define all these methods and the corresponding code. The code should look
    like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的规范和提到的条款中可以清楚地看出我们对我们功能的具体要求。当我们尝试运行测试用例时，它无法编译，因为我们没有`readPlayerDataFromSource`和`parseToPlayer`这些方法。我们可以定义所有这些方法和相应的代码。代码应该看起来像这样：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After writing the code, we can refactor it if needed. In our case, we''ve already
    refactored the code. We may try to run the test cases if you have placed the corresponding
    file in the right path. All our test cases will pass successfully, meaning that
    they will all be green:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码之后，如果需要，我们可以对其进行重构。在我们的例子中，我们已经重构了代码。如果你已经将相应的文件放置在正确的路径，我们可以尝试运行测试用例。所有的测试用例都将成功通过，这意味着它们都将显示为绿色：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we have a some idea about the toolkit and the way TDD makes it fun to
    write software. We have used `FlatSpec` in our example. There are more of these;
    some of the frequently used Specs are as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们对工具包以及TDD如何使编写软件变得有趣有了一些了解。在我们的例子中，我们使用了`FlatSpec`。还有更多这样的工具；一些常用的Spec如下：
- en: '`FunSpec`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FunSpec`'
- en: '`WordSpec`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WordSpec`'
- en: '`FreeSpec`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FreeSpec`'
- en: '`PropSpec`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PropSpec`'
- en: '`FeatureSpec`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FeatureSpec`'
- en: 'These styles only differ in the way they look. If we consider our test specs
    written in an English-like language, we can say these styles consist of different
    ways in which we can write/speak our sentences. We''ve already seen `FlatSpec`*.*
    The `FunSpec` Spec uses nested clauses with keywords like `describe` and `it`.
    Let''s take a few examples of all of these Spec styles:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这些风格只在外观上有所不同。如果我们考虑用类似英语的语言编写的测试规范，我们可以说这些风格是由我们可以用不同的方式来写/说我们的句子组成。我们已经看到了`FlatSpec`*.*
    `FunSpec`规范使用嵌套条款和关键字如`describe`和`it`。让我们看看所有这些Spec风格的几个例子：
- en: '`FunSpec`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FunSpec`'
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`WordSpec`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WordSpec`'
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`FreeSpec`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FreeSpec`'
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These are a few styles that we can use to write our test specs in `ScalaTest`.
    You should definitely check out `ScalaTest`'s documentation ([http://www.scalatest.org/user_guide](http://www.scalatest.org/user_guide))
    to learn more about these styles.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们可以在`ScalaTest`中用来编写测试规范的几种风格。你绝对应该查看`ScalaTest`的文档([http://www.scalatest.org/user_guide](http://www.scalatest.org/user_guide))来了解更多关于这些风格的信息。
- en: We've seen the way we made assertions and used `Matchers` to check for test
    clause validity. Let's learn more about these. We'll start with the *Assertions*
    trait*.*
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用断言和`Matchers`来检查测试条款的有效性。让我们更深入地了解这些。我们将从*断言*特质*开始。
- en: Assertions
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言
- en: 'The trait* Assertions* contains assertions that we can make while specifying
    behaviors for our test cases. There are three default assertions available in
    all the style specs. These assertions are as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 特质*断言*包含在指定测试用例行为时我们可以做出的断言。所有风格规范中都有三个默认断言可用。这些断言如下：
- en: '`assert`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert`'
- en: '`assertResult`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertResult`'
- en: '`assertThrows`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertThrows`'
- en: We've already used `assertThrows`, and the other two can also be used in a similar
    fashion. The `assertResult` assertion expects us to provide a value that is going
    to be the result of some calculation we specify. Similarly, `assert` expects us
    to provide a Boolean predicate, which has left and right parts. Some equality
    checks can be performed on some conditions, which result in a Boolean value, based
    on which the test clause passes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了`assertThrows`，其他两个也可以以类似的方式使用。`assertResult`断言期望我们提供一个值，这个值将是我们要指定的某些计算的输出结果。同样，`assert`期望我们提供一个布尔谓词，它有左右两部分。在某些条件下，可以进行一些相等性检查，这些检查基于布尔值，根据这些值，测试条款通过。
- en: Apart from these, there are more assertions available. A few of them are `fail`,
    `cancel`, `succeed`, `intercept`, `assertCompiles`, `assertDoesNotCompile`, and
    so on. Apart from these assertions, we can also use `Matchers` to check for the
    validity of our test specifications. We've used `Matchers` along with keywords
    in a few of our example clauses.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，还有更多的断言可用。其中一些是`fail`、`cancel`、`succeed`、`intercept`、`assertCompiles`、`assertDoesNotCompile`等等。除了这些断言之外，我们还可以使用`Matchers`来检查测试规范的有效性。我们在一些示例条款中使用了`Matchers`和关键字。
- en: Matchers
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配器
- en: We've already seen a few `Matchers` in place when we were going through our
    example. These `Matchers` are DSL's way of writing assertions. `ScalaTest` provides
    a rich set of assertions that work with Strings to collections. We can also write
    `Matchers` for custom classes. With these `Matchers`, we can perform the most
    basic assertions like equality checks to custom ones, where we have to deal with
    aggregations and sequencing.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看示例时，我们已经看到了一些`Matchers`。这些`Matchers`是断言的DSL（领域特定语言）编写方式。`ScalaTest`提供了一套丰富的断言，这些断言与字符串和集合一起工作。我们还可以为自定义类编写`Matchers`。有了这些`Matchers`，我们可以执行最基础的断言，如相等性检查，到更复杂的断言，其中我们需要处理聚合和排序。
- en: 'These `Matchers` are cool, because of native language-like methods. Consider
    the following example:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`Matchers`很酷，因为它们有类似原生语言的方法。考虑以下示例：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There are so many ways in which you can speak a particular sentence to convey
    the same information. Similarly, using `ScalaTest`'s `Matchers`, we can specify
    some clause using different methods. `Matchers` come in handy for this.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多种方式可以表达一个特定的句子来传达相同的信息。同样，使用`ScalaTest`的`Matchers`，我们可以用不同的方法指定一些条款。`Matchers`在这方面非常有用。
- en: We also know that sometimes, while writing software, we get to create mock objects
    to pass as arguments. For that, we don't have to write mock objects ourselves,
    but, there're libraries that do this for us. Let's take a look at one of them
    available in Scala.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还知道，在编写软件时，有时我们需要创建模拟对象作为参数传递。为此，我们不必自己编写模拟对象，但有一些库会为我们做这件事。让我们看看Scala中可用的其中一个。
- en: ScalaMock – a native library to mock objects
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ScalaMock – 一个用于模拟对象的原生库
- en: As we discussed, at instances where we need some other services that we are
    yet to define or it's harder to create their instances since using them is a matter
    of complexity, we tend to use some Mocking framework.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们讨论的，在需要一些我们尚未定义的其他服务，或者由于使用它们是一个复杂的过程，创建它们的实例比较困难的情况下，我们倾向于使用一些模拟框架。
- en: '**ScalaMock** is a native framework available in Scala. To include ScalaMock
    in our project, we''ll add a dependency for it in our `build.sbt` file. Let''s
    do that. We''ll add the following line in the build file:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**ScalaMock**是一个在Scala中可用的原生框架。为了将ScalaMock包含到我们的项目中，我们将在`build.sbt`文件中添加一个对其的依赖项。让我们这样做。我们将在构建文件中添加以下行：'
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We''ve specified the test scope, because we''re sure that `scalamock` is only
    going to be used in our test cases. After writing this dependency, we''ll perform
    an `sbt update` command by calling the `sbt update` command in the SBT shell*.*
    This update is going to add the `scalamock` dependency to our project. We can
    ensure this by taking a look at the external sources folder. There''s going to
    be a dependency with the `scalamock` name. If that''s available there, we are
    ready to mock some services:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经指定了测试范围，因为我们确信`scalamock`只会在我们的测试用例中使用。在编写这个依赖项之后，我们将通过在SBT shell中调用`sbt
    update`命令来执行一个`sbt update`命令*.*这次更新将把`scalamock`依赖项添加到我们的项目中。我们可以通过查看外部源文件夹来确保这一点。那里将有一个名为`scalamock`的依赖项。如果它可用，我们就准备好模拟一些服务了：
- en: '![](img/00082.jpeg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00082.jpeg)'
- en: 'We''ll try to mock our `PlayerService` object in our application where we want
    to show a list of a few players. Let''s specify a spec for that:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的应用程序中尝试模拟`PlayerService`对象，我们想在其中显示一些玩家的列表。让我们为这个指定一个规范：
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, we can perform some test case execution, which includes a call to this
    mocked function. Our test case has to somehow call this function at least once
    in order for it to pass. Mocking of objects is a usual practice we do while writing
    test cases. It relieves us of the burden of manually writing instances of several
    classes/functions, letting us concentrate on what matters, that is, validating
    our program's behavior upfront. And that's why we have such frameworks available,
    making our lives easier as developers. With this, we've come to the end of the
    final chapter of this book. Let's summarize whatever you've learned.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以执行一些测试用例，这包括对模拟函数的调用。我们的测试用例必须以某种方式至少调用这个函数一次，才能通过。在编写测试用例时模拟对象是一种常见的做法。它减轻了我们手动编写多个类/函数实例的负担，让我们专注于真正重要的事情，即提前验证我们程序的行为。这就是为什么我们有这样的框架可用，使我们的开发生活更加轻松。带着这个，我们来到了这本书的最后一章的结尾。让我们总结一下你所学到的东西。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter never seemed like the last one; it was fun. After going through
    several Scala programming constructs and frameworks, you learned how to ensure
    the validity of our programs. We knew that testing the code we write is essential,
    but this new TDD style of programming was a different experience. We understood
    what TDD actually is—a design scheme driven by specifying the behaviors at the
    beginning, rather than after we complete our code. We talked about why this approach
    is good. Then, we started with the testing tools available in Scala, and learned
    about `ScalaTest`*.* We wrote the specifications and then coded for the same.
    Finally, we also took a look at the mocking framework available in Scala named
    ScalaMock.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章从未感觉像是最后一章；它很有趣。在经历了几个Scala编程结构和框架之后，你学会了如何确保我们程序的合法性。我们知道测试我们编写的代码是至关重要的，但这种新的TDD编程风格是一种不同的体验。我们理解了TDD实际上是什么——一种在代码完成后而不是开始时通过指定行为来驱动的设计方案。我们讨论了为什么这种方法是好的。然后，我们从Scala中可用的测试工具开始，学习了`ScalaTest`*.*
    我们编写了规范，然后为这些规范编写了代码。最后，我们还研究了Scala中名为ScalaMock的模拟框架。
- en: Though this is the last chapter, we can think of what more we can do to  make
    our understanding of this language better. One of the best ways is to practice
    more; this will help us understand the concepts well, and we'll also be well versed
    with the constructs. But we'll get the real insight when we go about learning functional
    programming, because that's where all the magic is. Trying to think in a functional
    way, where we do not mutate stuff it, is one of the most important aspects. Finally,
    let's thank the wonderful and ever growing Scala community. Join the community,
    ask questions, and contribute in your own way.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是最后一章，但我们可以思考还能做些什么来使我们对这门语言的理解更好。最好的方法之一是进行更多的练习；这将帮助我们更好地理解概念，并且我们也会对结构了如指掌。但当我们开始学习函数式编程时，我们才能真正获得洞察力，因为那里才是所有魔法的源泉。尝试用函数式思维去思考，即我们不改变任何东西，这是最重要的方面之一。最后，让我们感谢这个奇妙且不断成长的Scala社区。加入社区，提出问题，并以你自己的方式做出贡献。
