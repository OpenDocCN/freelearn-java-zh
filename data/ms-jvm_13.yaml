- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Java Framework Principles
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java框架原则
- en: In the intricate landscape of **Java Virtual Machine** (**JVM**) internals,
    the development and utilization of Java frameworks stand out as a cornerstone
    for building robust and scalable applications. This chapter delves into fundamental
    principles that underpin the art of crafting Java frameworks, offering a comprehensive
    exploration of the intricacies involved. As architects and developers navigate
    the dynamic realm of software design, understanding trade-offs inherent in framework
    development becomes paramount. This chapter illuminates critical considerations
    in framework design and sheds light on the delicate balance between flexibility
    and performance. Through insightful analysis and practical examples, readers will
    gain a profound understanding of decisions that shape the architecture of Java
    frameworks, empowering them to make informed choices in their software endeavors.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂的Java虚拟机（**JVM**）内部结构中，Java框架的开发和使用是构建稳健和可扩展应用程序的基石。本章深入探讨了支撑构建Java框架艺术的基本原则，全面探索了其中涉及的复杂性。随着架构师和开发者导航软件设计的动态领域，理解框架开发中固有的权衡变得至关重要。本章阐明了框架设计中的关键考虑因素，并揭示了灵活性和性能之间的微妙平衡。通过深入分析和实践例子的结合，读者将深刻理解塑造Java框架架构的决定，使他们能够在软件项目中做出明智的选择。
- en: In software development, a framework is a foundational structure that provides
    pre-defined components, tools, and design patterns to streamline application development.
    Examples in Java include the Spring Framework, Hibernate for database interaction,
    Struts for web applications, **JavaServer Faces** (**JSF**) for user interfaces,
    and Apache Wicket for web apps. Frameworks simplify development, encourage code
    reuse, and maintain best practices.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，框架是一个基础结构，它提供了预定义的组件、工具和设计模式，以简化应用程序的开发。Java中的例子包括Spring框架、Hibernate数据库交互、Struts网络应用、**JavaServer
    Faces**（**JSF**）用户界面和Apache Wicket网络应用。框架简化了开发，鼓励代码重用，并维护最佳实践。
- en: A pivotal aspect of this exploration lies in examining metadata and annotations
    within the Java framework ecosystem. These elements enhance code expressiveness,
    enabling developers to encapsulate and convey crucial information about classes,
    methods, and other components. By unraveling the intricacies of metadata and annotations,
    this chapter equips readers with the knowledge needed to harness the full potential
    of these tools in crafting flexible and extensible frameworks. Whether unraveling
    the mysteries of reflection or leveraging annotations for configuration and extension
    points, this chapter guides navigating the nuanced landscape of Java framework
    principles. Through a blend of theoretical insights and practical examples, readers
    will embark on a journey that demystifies the complexities of framework development,
    empowering them to architect sophisticated solutions on the robust foundation
    of JVM internals.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本探索的关键方面在于检查Java框架生态系统中的元数据和注解。这些元素增强了代码的表达性，使开发者能够封装和传达有关类、方法和其他组件的至关重要的信息。通过揭示元数据和注解的复杂性，本章为读者提供了利用这些工具的全面知识，以构建灵活和可扩展的框架。无论是揭示反射的奥秘还是利用注解进行配置和扩展点，本章引导读者在Java框架原则的微妙领域中导航。通过理论洞察和实践例子的结合，读者将开始一段揭示框架开发复杂性的旅程，使他们能够在JVM内部结构的坚实基础上构建复杂的解决方案。
- en: 'In this chapter, we’ll explore the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Why do we have frameworks?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为什么需要框架？
- en: Java metadata
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java元数据
- en: Trade-offs in framework adoption
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架采用中的权衡
- en: Java framework principles
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java框架原则
- en: Why do we have frameworks?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们为什么需要框架？
- en: We’ll explore the underlying reasons for the prevalence and evolution of Java
    frameworks in software development. Adopting frameworks aligns seamlessly with
    established software development practices, arising organically as a response
    to the perpetual quest for efficiency, reliability, and scalability. Developers,
    faced with the challenges of crafting intricate and feature-rich applications,
    find in frameworks a strategic ally that provides a structured and standardized
    foundation, facilitating the reuse of components and streamlining development
    processes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨Java框架在软件开发中普遍存在和演变的潜在原因。采用框架与既定的软件开发实践无缝对接，它自然地作为对效率、可靠性和可扩展性永恒追求的回应而出现。面对构建复杂和功能丰富的应用程序的挑战，开发者发现框架是一个战略盟友，它提供了一个结构化和标准化的基础，促进了组件的重用和简化了开发流程。
- en: A key motivation behind the widespread use of frameworks is their capacity to
    address challenges related to redundant code and duplicated bugs. By encapsulating
    best practices, design patterns, and common functionalities, frameworks empower
    developers to concentrate on distinctive aspects of their applications, fostering
    code efficiency and reducing the likelihood of errors. It expedites development
    cycles and enhances the overall quality of software products. As projects mature,
    the cumulative impact of leveraging frameworks becomes increasingly evident, expediting
    the journey from conceptualization to deployment.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 框架广泛使用背后的关键动机是它们能够解决与冗余代码和重复错误相关的挑战。通过封装最佳实践、设计模式和常见功能，框架使开发者能够专注于其应用程序的独特方面，从而提高代码效率并降低错误发生的可能性。它加速了开发周期，并提高了软件产品的整体质量。随着项目的成熟，利用框架的累积影响变得越来越明显，加速了从概念化到部署的过程。
- en: Moreover, the evolution of these reusable components has given rise to a thriving
    market of framework-based businesses. By recognizing the intrinsic value of streamlined
    development practices, companies actively invest in and adopt Java frameworks
    to catalyze their software development processes. These frameworks boost productivity
    and contribute to creating robust, maintainable, and scalable applications.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这些可重用组件的演变催生了一个繁荣的基于框架的商业市场。通过认识到简化开发实践的内生价值，公司积极投资并采用Java框架来催化他们的软件开发流程。这些框架提高了生产力，并有助于创建强大、可维护和可扩展的应用程序。
- en: In business-oriented software development, the concept of reusable components
    takes on a dual significance, manifesting both within the confines of an organization
    and across diverse companies. Internally, organizations harness inner-source power,
    fostering an environment where reusable components are cultivated and shared among
    different teams. This collaborative approach enhances code reusability, accelerates
    development cycles, and nurtures a culture of knowledge exchange within the organization.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向商业的软件开发中，可重用组件的概念具有双重意义，既体现在组织内部，也体现在不同公司之间。内部，组织利用内部源力量，营造一个可重用组件得以培养和在不同团队间共享的环境。这种协作方法增强了代码的可重用性，加速了开发周期，并在组织内部培育了知识交流的文化。
- en: Simultaneously, the broader landscape of Java frameworks extends beyond organizational
    boundaries, providing functionalities that transcend company-specific needs. Java
    is a linchpin for integration, seamlessly weaving disparate components and technologies
    together. Whether it’s database integration, handling HTTP requests, implementing
    caching mechanisms, or facilitating distributed observability, Java frameworks
    have become indispensable in ensuring interoperability and efficiency across many
    systems.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，Java框架的更广泛领域超越了组织边界，提供了超越公司特定需求的功能。Java是集成的关键，无缝地将不同的组件和技术编织在一起。无论是数据库集成、处理HTTP请求、实现缓存机制还是促进分布式可观察性，Java框架已成为确保许多系统之间互操作性和效率不可或缺的工具。
- en: What distinguishes Java in this ecosystem is its versatility and the robust
    open-source community surrounding it. Countless open-source products and proprietary
    solutions contribute to a rich tapestry of tools that aid software engineers on
    their development journey. For instance, widely adopted databases such as MySQL
    and PostgreSQL seamlessly integrate with Java applications, ensuring efficient
    data management. Advanced caching solutions such as Ehcache enhance application
    performance by optimizing data retrieval. Distributed observability platforms
    such as Prometheus and Jaeger also empower developers to monitor and troubleshoot
    applications effectively. These tools collectively form the backbone of Java’s
    strength in enterprise-level integration, enabling developers to build scalable
    and efficient solutions quickly.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个生态系统中，Java的独特之处在于其多功能性和围绕它的强大开源社区。无数的开源产品和专有解决方案共同构成了一个丰富的工具织锦，帮助软件工程师在他们的开发旅程中。例如，广泛采用的数据库如MySQL和PostgreSQL可以无缝集成到Java应用程序中，确保高效的数据管理。高级缓存解决方案如Ehcache通过优化数据检索来提高应用程序性能。分布式可观察性平台如Prometheus和Jaeger也使开发者能够有效地监控和调试应用程序。这些工具共同构成了Java在企业级集成中的强大支柱，使开发者能够快速构建可扩展和高效的解决方案。
- en: The multitude of frameworks available for Java, spanning database integration,
    HTTP requests, caching, and distributed observability, underscores its adaptability
    and resilience in addressing diverse business challenges. This amalgamation of
    open source and proprietary tools serves as a testament to the collaborative nature
    of the software development landscape, where shared resources and frameworks accelerate
    innovation and empower software engineers to navigate the complexities of modern,
    interconnected systems.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 可用于Java的众多框架，涵盖了数据库集成、HTTP请求、缓存和分布式可观察性，强调了其在应对各种商业挑战中的适应性和弹性。这种开源和专有工具的结合是软件开发景观协作性质的证明，共享资源和框架加速了创新，并赋予了软件工程师在复杂、互联系统中导航的能力。
- en: As we conclude our exploration of the expansive landscape of Java frameworks
    in business-oriented software development, it becomes evident that these tools
    are not merely coding conveniences but strategic assets that drive efficiency,
    reliability, and scalability. The dual nature of reusable components, thriving
    within organizational boundaries through inner-source practices and extending
    across companies through versatile Java frameworks, underscores the dynamic and
    collaborative spirit of modern software engineering.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们对面向商业软件开发中Java框架广阔领域的探索结束，这些工具不仅仅是编码便利，而是推动效率、可靠性和可扩展性的战略资产。可重用组件的双重特性，通过内部源实践在组织边界内蓬勃发展，并通过多才多艺的Java框架跨越公司，突显了现代软件工程的动态和协作精神。
- en: In our next section, we will delve into the crucial realm of metadata within
    Java, a cornerstone that enhances code expressiveness and functionality. Understanding
    how metadata and annotations operate in the context of Java frameworks is pivotal
    for navigating the intricate architecture of these tools. We will unravel the
    layers of information encapsulated within metadata, exploring its role in shaping
    flexible and extensible frameworks. Join us as we embark on a journey into the
    nuanced world of metadata, bridging the gap between theory and practical application
    in the context of Java’s rich framework ecosystem.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入探讨Java中元数据的至关重要领域，这是增强代码表达性和功能性的基石。理解元数据和注解在Java框架中的运作对于导航这些工具的复杂架构至关重要。我们将揭示元数据中封装的信息层，探索其在塑造灵活和可扩展框架中的作用。随着我们踏上探索元数据微妙世界的旅程，我们将理论与实践应用在Java丰富框架生态系统中的差距连接起来。
- en: Java metadata
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java元数据
- en: In the dynamic landscape of Java programming, metadata emerges as a powerful
    tool, quietly working behind the scenes to bridge gaps between disparate paradigms
    and streamline conversion processes that define modern software development. But
    why do we have metadata in Java, and what role does it play in simplifying complex
    tasks, particularly in scenarios such as conversion or mapping operations?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java编程的动态环境中，元数据作为一种强大的工具悄然出现，在幕后默默工作，连接着不同的范式，简化了现代软件开发中定义的转换过程。但为什么Java中有元数据，它在简化复杂任务中扮演什么角色，尤其是在转换或映射操作等场景中？
- en: At its core, metadata in Java is a critical facilitator, significantly easing
    the intricacies of processes such as converting Java entities to XML files or
    databases. The essence lies in its ability to decrease impedance between different
    paradigms, particularly when navigating the nuanced space between relational databases
    and Java objects.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，元数据是其核心，是一个关键的促进者，极大地简化了诸如将Java实体转换为XML文件或数据库等过程的复杂性。其本质在于其降低不同范式之间阻抗的能力，尤其是在导航关系数据库和Java对象之间细微空间时的能力。
- en: Consider the scenario where Java, following its convention of camelCase (for
    example, `clientId`) collaborates with a relational database, which adheres to
    the `snake_case` convention, for example, `client_id`. This misalignment in naming
    conventions can pose challenges, creating a disconnect between the two paradigms.
    Enter metadata — the unsung hero that enables seamless communication and relationship
    building between a Java class and a database. By encapsulating essential information
    about the data’s structure, properties, and relationships, metadata serves as
    a linchpin in harmonizing the syntax and semantics of these diverse worlds.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一个场景，Java遵循其驼峰命名法（例如，`clientId`）与遵循蛇形命名法（例如，`client_id`）的关系数据库协作。这种命名规范的错位可能带来挑战，造成两种范式之间的脱节。这时，元数据——这位默默的英雄，使得Java类与数据库之间的无缝通信和关系构建成为可能。通过封装关于数据结构、属性和关系的基本信息，元数据成为协调这些不同世界语法和语义的纽带。
- en: The strategic use of metadata is not just a mere workaround; it is a deliberate
    approach to enhance interoperability, reduce development friction, and uphold
    best practices in software engineering. Join us as we unravel the metadata layers
    in Java, exploring how these silent enablers play a pivotal role in minimizing
    the distance between paradigms and fostering a more cohesive and efficient development
    experience. From relational databases to Java objects, we will uncover the mechanisms
    by which metadata ensures that the intricate dance of data conversion and mapping
    unfolds seamlessly in the complex choreography of modern software development.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据的战略使用不仅仅是一个简单的权宜之计；它是一种旨在提高互操作性、减少开发摩擦并维护软件工程最佳实践的刻意方法。加入我们，我们将揭示Java中的元数据层，探索这些无声的促进者在缩小范式之间的距离和促进更紧密、更高效的开发体验方面发挥的关键作用。从关系数据库到Java对象，我们将揭示元数据确保数据转换和映射的复杂舞蹈在现代软件开发复杂编排中无缝展开的机制。
- en: 'Behold the synergy between a Java file and a relational database, harmonized
    by a silent influencer – metadata. This visual snapshot captures the seamless
    communication facilitated by metadata, transcending the naming conventions divergence
    between Java’s camelCase and the database’s `snake_case`. In the intricate dance
    of data conversion and mapping, metadata emerges as the unseen orchestrator, reducing
    impedance and fostering interoperability. This diagram encapsulates the pivotal
    role of metadata, transforming potential friction into a fluid exchange that underlies
    the creation of robust and adaptable software solutions:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 欣赏Java文件与关系数据库之间的协同作用，由一位无声的影响者——元数据——和谐统一。这个视觉快照捕捉了由元数据促进的无缝通信，超越了Java的驼峰命名法和数据库的蛇形命名法之间的命名规范差异。在数据转换和映射的复杂舞蹈中，元数据成为看不见的指挥者，降低阻抗并促进互操作性。此图封装了元数据的关键作用，将潜在的摩擦转化为创建强大和适应性软件解决方案的基础上的流畅交换：
- en: '![Figure 9.1: The Java application communicates with the database using metadata](img/B22030_09_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1：Java应用程序使用元数据与数据库进行通信](img/B22030_09_01.jpg)'
- en: 'Figure 9.1: The Java application communicates with the database using metadata'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：Java应用程序使用元数据与数据库进行通信
- en: Continuing the journey through metadata history in Java, early endeavors in
    metadata management leaned on XML, a practice notably exemplified in the `Person`
    entity as an example, defined in Java code, the subsequent step involved crafting
    an XML file to articulate the intricate relationship between this Java class and
    corresponding database mapping statements. This XML file, dynamically interpreted
    at runtime, played a dual role — not only serving as a blueprint for the association
    between the `Person` class and the database but also functioning as a conduit
    for generating real-time metadata. The provided XML snippet illustrates this crucial
    link, outlining the attributes, tables, and their respective mappings, marking
    a significant chapter in the evolution of Java’s metadata-handling capabilities.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续探索Java元数据历史的过程中，早期的元数据管理努力依赖于XML，这在`Person`实体中得到了显著体现，例如，在Java代码中定义的实体，接下来的步骤涉及创建一个XML文件来阐述这个Java类与相应的数据库映射语句之间的复杂关系。这个在运行时动态解释的XML文件扮演了双重角色——不仅作为`Person`类与数据库之间关联的蓝图，还作为生成实时元数据的渠道。提供的XML片段说明了这个关键链接，概述了属性、表及其相应的映射，标志着Java元数据处理能力演变中的一个重要章节。
- en: 'The provided Java code defines a `Person` class with three private fields:
    `id`, `name`, and `age`. This class encapsulates data related to an individual
    and includes the necessary getter and setter methods for each attribute. The intent
    is to represent a person with identifiable characteristics in a Java application:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的Java代码定义了一个具有三个私有字段`id`、`name`和`age`的`Person`类。该类封装了与个人相关的数据，并为每个属性提供了必要的getter和setter方法。目的是在Java应用程序中以可识别的特征来表示一个人：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Within the `<attributes>` section, the XML delineates individual attributes
    of the `Person` class. The `<id>` element signifies the primary key attribute,
    specifying the corresponding field (`id`). Additionally, two `<basic>` elements
    for the `name` and `age` attributes indicate simple, non-composite attributes.
    The `<column>` elements nested within the `name` attribute provide further details
    for database mapping, specifying the column name (`NAME`) and its maximum length.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<attributes>`部分，XML定义了`Person`类的单个属性。`<id>`元素表示主键属性，指定了相应的字段（`id`）。此外，两个`<basic>`元素分别用于`name`和`age`属性，表示简单、非组合属性。嵌套在`name`属性中的`<column>`元素提供了数据库映射的进一步细节，指定了列名（`NAME`）及其最大长度。
- en: This XML metadata is a configuration blueprint, establishing relationships between
    Java objects and their database representations. It not only defines the structure
    and characteristics of the `Person` class but also guides the runtime generation
    of metadata, facilitating seamless interaction between the Java application and
    the underlying database. This robust connection is a fundamental aspect of Java’s
    metadata-handling capabilities, contributing to the efficiency and coherence of
    data management in Java applications.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此XML元数据是一个配置蓝图，建立了Java对象与其数据库表示之间的关系。它不仅定义了`Person`类的结构和特征，还指导了元数据的运行时生成，促进了Java应用程序与底层数据库之间的无缝交互。这种强大的连接是Java元数据处理能力的基本方面，有助于提高Java应用程序中数据管理的效率和一致性。
- en: 'Frameworks such as Spring and Jakarta EE offer a more code-centric approach
    to defining metadata. For example, annotations such as `@Entity`, `@Table(name
    = "tutorial")`, and `@Column(name = "title")` serve as a simplified alternative
    to XML configuration files. Here’s a code sample using annotations:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 框架如Spring和Jakarta EE提供了一种更以代码为中心的方法来定义元数据。例如，`@Entity`、`@Table(name = "tutorial")`和`@Column(name
    = "title")`这样的注解可以作为XML配置文件的简化替代方案。以下是一个使用注解的代码示例：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Conversely, in XML-based configuration, the same metadata can be defined as
    follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在基于XML的配置中，相同的元数据可以定义如下：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Both approaches achieve the same result, with annotations providing a more concise
    and code-centric way to specify metadata, while XML offers a more externalized
    and customizable configuration option.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都达到了相同的结果，注解提供了一种更简洁、更以代码为中心的方式来指定元数据，而XML则提供了更外部化和可定制的配置选项。
- en: 'Step into the visual narrative of seamless database integration, where the
    synergy between a Java file and an XML configuration file unfolds with remarkable
    cohesion. This captivating diagram captures the intricate dance of integration,
    showcasing a Java file representing a `Person` class harmonizing effortlessly
    with an XML file crafted for JPA. As the framework combines these two entities,
    Java and XML, a symbiotic relationship emerges, paving the way for streamlined
    data integration into the database. This visual depiction encapsulates how, through
    careful coordination of Java code and XML metadata, the framework facilitates
    a seamless bridge between the application’s logic and the database structure.
    It is a compelling snapshot of the dynamic interplay between code and configuration,
    demonstrating the powerful capabilities of Java frameworks in orchestrating cohesive
    and efficient database integration:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 步入无缝数据库集成的视觉叙事，其中Java文件与XML配置文件之间的协同作用展现得非常紧密。这个引人入胜的图表捕捉了集成过程中的复杂舞蹈，展示了一个代表`Person`类的Java文件与为JPA制作的XML文件无缝和谐地结合。当框架结合这两个实体，Java和XML时，一种共生关系出现，为将数据流线化集成到数据库铺平了道路。这种视觉描述封装了如何通过精心协调Java代码和XML元数据，框架促进应用程序逻辑与数据库结构之间的无缝桥梁。这是代码和配置之间动态互动的引人注目快照，展示了Java框架在编排协调和高效数据库集成方面的强大能力：
- en: '![Figure 9.2: The Java application communicates with the database using metadata](img/B22030_09_02.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2：Java应用程序使用元数据与数据库通信](img/B22030_09_02.jpg)'
- en: 'Figure 9.2: The Java application communicates with the database using metadata'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：Java应用程序使用元数据与数据库通信
- en: The evolution of the Java language and its ecosystem revealed to developers
    that maintaining generated metadata separately from the code, as was conventionally
    done with XML files, presented challenges in intuitiveness and, notably, increased
    complexity during maintenance – updating a field required alterations in both
    the Java class and the corresponding database configuration, leading to potential
    discrepancies and inefficiencies.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Java语言及其生态系统的演变向开发者揭示了将生成的元数据与代码分开维护，如传统上使用XML文件所做的那样，在直观性和维护的复杂性方面带来了挑战——更新一个字段需要在Java类和相应的数据库配置中进行更改，从而导致潜在的不一致和低效。
- en: In a pivotal move to enhance developer experience and streamline this process,
    Java 5, introduced in mid-2004, ushered in the metadata facility for Java through
    **Java Specification Request** (**JSR**) *175*, affectionately known as **Java
    annotations**. This innovation eliminated the need for a separate configuration
    file, offering a unified solution where all essential information could reside
    within the Java class. It simplified the development workflow and significantly
    improved the maintainability of code and associated metadata, marking a transformative
    moment in the evolution of Java’s metadata-handling capabilities.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增强开发者的体验并简化这一过程，Java 5在2004年中期推出，通过**Java规范请求**（**JSR**）*175*引入了Java的元数据功能，亲切地称为**Java注解**。这一创新消除了需要单独配置文件的需求，提供了一个统一解决方案，其中所有必要信息都可以存储在Java类中。它简化了开发工作流程，显著提高了代码和相关元数据的可维护性，标志着Java元数据处理能力演变中的一个转折点。
- en: 'In Java annotations, developers can read and process annotations in two distinct
    phases: dynamically at runtime using reflection or statically at build time utilizing
    a dedicated tool, such as a Java annotation processor.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java注解中，开发者可以在两个不同的阶段读取和处理注解：在运行时动态地使用反射，或在构建时利用专用工具，如Java注解处理器。
- en: The runtime approach, leveraging reflection, involves inspecting and interpreting
    annotations while executing the program. This method allows for dynamic decision-making
    based on the presence or values of annotations within the code. However, it comes
    with some runtime performance overhead as the annotations are introspected during
    program execution.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时方法，利用反射，涉及在程序执行过程中检查和解释注解。这种方法允许根据代码中注解的存在或值进行动态决策。然而，它带来了运行时性能开销，因为注解在程序执行期间被检查。
- en: On the other hand, the build-time approach utilizes annotation processors, tools
    that operate during the compilation phase. Annotation processors analyze and manipulate
    annotated elements of the source code before the actual compilation occurs. This
    approach is beneficial for tasks determined at compile time, such as code generation,
    validation, or resource preparation. It offers the advantage of catching potential
    issues early in development and contributes to more efficient and optimized code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，编译时方法利用注解处理器，这些工具在编译阶段运行。注解处理器在编译实际发生之前分析和操作源代码中的注解元素。这种方法对于在编译时确定的任务有益，如代码生成、验证或资源准备。它具有在开发早期捕捉潜在问题的优势，并有助于更高效和优化的代码。
- en: Ultimately, the choice between runtime reflection and build-time annotation
    processing depends on the specific requirements of the task at hand. Runtime reflection
    suits scenarios where decisions must be made dynamically during program execution.
    At the same time, build-time processing is preferable for tasks that can be resolved
    at compile time, promoting efficiency and early error detection.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，运行时反射与编译时注解处理的抉择取决于手头任务的特定要求。运行时反射适用于在程序执行期间必须动态做出决策的场景。同时，编译时处理对于可以在编译时解决的问题更为可取，这促进了效率和早期错误检测。
- en: In conclusion, the evolution of metadata handling in Java, transitioning from
    XML-based configurations to the innovative realm of Java annotations, has marked
    a transformative phase in software development. The move toward annotations within
    the Java ecosystem, introduced through JSR *175*, simplified metadata integration
    with code and significantly enhanced maintainability. As we navigate the landscape
    of Java annotations, we find ourselves at a crossroads where choices between runtime
    reflection and build-time annotation processing present distinct trade-offs. Potential
    performance implications counterbalance the dynamic adaptability of runtime reflection,
    while the efficiency of build-time processing comes at the cost of static decision-making.
    Join us in the next section as we delve into the nuanced world of trade-offs in
    Java development, exploring the delicate balance between flexibility and performance
    when making crucial architectural decisions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，Java中元数据处理的发展，从基于XML的配置过渡到创新的Java注解领域，标志着软件开发的一个转型阶段。通过JSR *175* 引入Java生态系统中的注解，简化了元数据与代码的集成，并显著提高了可维护性。在我们探索Java注解的领域时，我们发现自己站在一个十字路口，在这里，运行时反射与编译时注解处理之间的选择带来了不同的权衡。潜在的性能影响与运行时反射的动态适应性相平衡，而编译时处理的效率则以静态决策为代价。请加入我们，在下一节中，我们将深入探讨Java开发中权衡的微妙世界，探讨在做出关键架构决策时，在灵活性和性能之间保持微妙的平衡。
- en: Trade-offs in framework adoption
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 框架采用的权衡
- en: As developers venture into software architecture, the decision to incorporate
    a framework introduces many considerations, each laden with trade-offs that profoundly
    impact the development process. Embracing a framework, be it for Java or any other
    language, entails a delicate balancing act between the conveniences it offers
    and the potential drawbacks it may introduce.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 随着开发者进入软件架构领域，决定采用框架引入了许多考虑因素，每个因素都充满了权衡，这些权衡深刻地影响着开发过程。无论是Java还是任何其他语言，采用框架都意味着在它提供的便利性和可能带来的潜在缺点之间进行微妙的平衡。
- en: One crucial trade-off revolves around the allure of rapid development facilitated
    by frameworks versus their imposed constraints. Frameworks often expedite the
    coding process, providing pre-built components and established conventions. However,
    this acceleration can come at the cost of flexibility, as developers may find
    themselves confined by the framework’s prescribed structure and paradigms.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关键的权衡在于，由框架带来的快速开发吸引力与它们强加的约束之间的权衡。框架通常可以加速编码过程，提供预构建的组件和既定规范。然而，这种加速可能会以灵活性的代价为代价，因为开发者可能会发现自己被框架规定的结构和范式所限制。
- en: Furthermore, the trade-off extends to the learning curve of adopting a new framework.
    While frameworks aim to simplify development, there’s an inherent investment in
    time and effort required for developers to become proficient. This initial learning
    phase may be perceived as a hurdle, especially in fast-paced development environments.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，权衡还扩展到采用新框架的学习曲线。虽然框架旨在简化开发，但开发者要成为熟练的专家需要投入时间和精力。这个初始的学习阶段可能被视为一个障碍，尤其是在快速发展的开发环境中。
- en: In this section, we will dissect these trade-offs and explore the nuanced decisions
    developers face when embracing a framework. From the promise of accelerated development
    to potential constraints and learning curves, understanding the intricate trade-offs
    involved is essential for making informed architectural choices. Join us as we
    navigate the delicate balance between the conveniences and constraints of framework
    adoption in the dynamic software development landscape.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将剖析这些权衡，并探讨开发者采用框架时所面临的微妙决策。从加速开发的承诺到潜在的约束和学习曲线，理解所涉及的复杂权衡对于做出明智的架构选择至关重要。请加入我们，我们将探讨在动态的软件开发环境中采用框架的便利性和约束之间的微妙平衡。
- en: The decision between adopting an existing framework and creating a custom one
    constitutes a significant trade-off in software development, each path laden with
    its considerations. Opting for a well-established framework from the market offers
    immediate advantages such as proven reliability, community support, and often
    a wealth of pre-built components. It accelerates development, reduces the need
    for reinventing the wheel, and taps into the collective knowledge of a user community.
    However, the trade-off here lies in a potential need for more customization and
    the risk of being constrained by design choices and opinions embedded in the chosen
    framework.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，选择采用现有框架还是创建自定义框架构成了一个重大的权衡，每条路径都充满了其考虑因素。选择市场上成熟的框架可以带来即时的优势，例如经过验证的可靠性、社区支持，以及通常丰富的预构建组件。这加速了开发过程，减少了重新发明轮子的需求，并利用了用户社区的集体知识。然而，这里的权衡在于可能需要更多的定制化，以及被所选框架中嵌入的设计选择和观点所限制的风险。
- en: Conversely, creating a custom framework provides the freedom to tailor solutions
    precisely to the project’s unique requirements. This approach offers unparalleled
    flexibility, allowing developers to craft a framework that perfectly aligns with
    the project’s goals and architecture. Yet, this freedom comes at a cost – the
    investment of time and resources to design, implement, and maintain a bespoke
    framework. Additionally, the absence of a proven track record may lead to unforeseen
    challenges and the need for extensive testing and refinement. It’s essential to
    consider whether creating *another framework* aligns with the project’s specific
    needs and goals. While it can offer benefits in terms of customization, it should
    be a well-considered decision to avoid unnecessary complexity and fragmentation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，创建自定义框架提供了根据项目独特需求定制解决方案的自由。这种方法提供了无与伦比的灵活性，允许开发者创建一个与项目目标和架构完美契合的框架。然而，这种自由是有代价的——设计、实施和维护定制框架所需的时间和资源投入。此外，缺乏经过验证的记录可能导致不可预见的问题和需要广泛的测试和改进。考虑是否创建*另一个框架*与项目的具体需求和目标相符是至关重要的。虽然它可以在定制方面提供好处，但应该是一个经过深思熟虑的决定，以避免不必要的复杂性和碎片化。
- en: Ultimately, the trade-off involves weighing an existing framework’s immediate
    benefits and conveniences against the long-term advantages and potential pitfalls
    of creating a custom solution. The decision hinges on project requirements, timeline,
    team expertise, and the strategic vision for the software’s evolution. Striking
    the right balance between leveraging existing solutions and crafting tailored
    frameworks is a delicate yet pivotal decision in the dynamic landscape of software
    development.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，权衡涉及权衡现有框架的即时利益和便利性与创建自定义解决方案的长期优势及潜在陷阱。决策取决于项目需求、时间表、团队的专业知识和软件演变的战略愿景。在利用现有解决方案和定制框架之间取得正确的平衡是一个微妙但至关重要的决策，在软件开发的动态环境中尤为重要。
- en: The trade-off between adopting an existing framework and creating a custom one
    in software development introduces a pivotal decision-making process. While established
    frameworks offer immediate benefits and community support, they may constrain
    flexibility. Conversely, crafting a bespoke framework provides tailored solutions
    but demands significant time and resources. As we transition to the next section,
    *Java framework principles*, we will delve into foundational principles guiding
    the design and development of frameworks. Recognizing how these principles shape
    intricate choices between leveraging existing solutions and crafting custom frameworks
    is essential for navigating the dynamic landscape of software development. Join
    us as we unravel the principles that underpin effective frameworks and illuminate
    their influence on trade-offs inherent in developers’ decisions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中采用现有框架和创建自定义框架之间的权衡引入了一个关键决策过程。虽然成熟的框架提供了即时的好处和社区支持，但它们可能会限制灵活性。相反，定制框架提供了定制的解决方案，但需要大量的时间和资源。随着我们过渡到下一节“Java框架原则”，我们将深入了解指导框架设计和开发的基础原则。认识到这些原则如何塑造在利用现有解决方案和定制框架之间进行复杂选择是导航软件开发动态景观的关键。加入我们，我们将揭示支撑有效框架的原则，并阐明它们对开发者决策中固有的权衡的影响。
- en: Java framework principles
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java框架原则
- en: A nuanced understanding of key principles is paramount for architects and developers
    in Java framework development. The first crucial aspect to consider is API design,
    which significantly influences the framework’s usability and adoption. Choosing
    between a declarative and an imperative API design is pivotal. Declarative APIs
    emphasize expressing the desired outcome, promoting readability and conciseness,
    while imperative APIs provide a step-by-step approach, offering more explicit
    control. Striking the right balance between these approaches is vital to ensure
    not only ease of use but also the long-term maintainability of the framework.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java框架开发中的架构师和开发者来说，对关键原则的细微理解至关重要。首先需要考虑的关键方面是API设计，它显著影响了框架的可使用性和采用度。在声明式和命令式API设计之间进行选择是至关重要的。声明式API强调表达期望的结果，促进可读性和简洁性，而命令式API提供了一种逐步的方法，提供了更明确的控制。在这两种方法之间取得正确的平衡对于确保不仅易于使用，而且框架的长期可维护性至关重要。
- en: Another critical principle is executability, where careful consideration of
    reflection becomes pivotal. Reflection can offer dynamic capabilities, enabling
    examining and manipulating classes, methods, and fields at runtime. However, this
    flexibility comes with a performance cost. Alternatively, frameworks can opt for
    solutions that eschew reflection, promoting efficiency within the JVM. Additionally,
    the advent of technologies allowing the execution of Java code outside the JVM,
    such as building native images, introduces new dimensions to the executability
    principle. Navigating these choices demands understanding trade-offs between flexibility,
    performance, and resource efficiency.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关键原则是可执行性，其中对反射的仔细考虑变得至关重要。反射可以提供动态能力，允许在运行时检查和操作类、方法和字段。然而，这种灵活性伴随着性能成本。另一方面，框架可以选择避免反射的解决方案，从而在JVM内提高效率。此外，允许在JVM之外执行Java代码的技术，如构建原生镜像，为可执行性原则带来了新的维度。导航这些选择需要理解灵活性、性能和资源效率之间的权衡。
- en: 'API design is a critical aspect of Java framework development, presenting developers
    with a choice between two fundamental styles: declarative and imperative. Each
    approach carries its trade-offs, and the decision between them hinges on factors
    such as readability, expressiveness, and the level of control developers desire.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: API设计是Java框架开发的一个关键方面，为开发者提供了两种基本风格的选项：声明式和命令式。每种方法都有其权衡之处，而选择它们取决于诸如可读性、表达性和开发者期望的控制水平等因素。
- en: A declarative API emphasizes expressing the desired outcome or end state, allowing
    developers to specify what they want to achieve without dictating the step-by-step
    process. This style promotes concise and expressive code, making it more readable
    and often easier to understand. Declarative APIs are particularly beneficial in
    scenarios focusing on higher-level abstractions and where a more intuitive, natural
    language-like syntax enhances code comprehension.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式API强调表达期望的结果或最终状态，允许开发者指定他们想要实现的目标，而不必规定逐步的过程。这种风格促进了简洁和表达性的代码，使其更易于阅读和理解。在关注高级抽象和需要更直观、类似自然语言的语法来增强代码理解的场景中，声明式API特别有益。
- en: On the other hand, imperative APIs adopt a more step-by-step or procedural approach,
    requiring developers to define each action and control flow explicitly. While
    this style provides a more granular level of control, it may result in more verbose
    and boilerplate code. Imperative APIs shine when precise control over the execution
    flow is paramount, especially when developers need to manage intricate details
    or handle complex branching logic.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，命令式API采用更逐步或程序化的方法，要求开发者明确地定义每个动作和控制流程。虽然这种风格提供了更细粒度的控制，但可能会导致代码更加冗长和模板化。当需要精确控制执行流程时，命令式API表现出色，尤其是在开发者需要管理复杂细节或处理复杂的分支逻辑时。
- en: The trade-off between declarative and imperative API design often concerns the
    balance between expressiveness and control. Declarative APIs are favored for their
    readability and conciseness, enhancing collaboration and reducing cognitive load
    on developers. However, they might be less suitable for scenarios demanding fine-grained
    control. In contrast, imperative APIs offer more explicit control but can be verbose
    and may require a deeper understanding of the underlying logic.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式和命令式API设计之间的权衡通常关注表达性和控制之间的平衡。声明式API因其可读性和简洁性而受到青睐，增强了协作并减轻了开发者的认知负担。然而，它们可能不适合需要细粒度控制的场景。相比之下，命令式API提供了更明确的控制，但可能冗长，可能需要更深入地理解底层逻辑。
- en: Choosing between declarative and imperative API design should be informed by
    the framework’s specific requirements and the development team’s preferences.
    Striking the right balance is crucial, and in many cases, a hybrid approach that
    combines elements of both styles may offer the best of both worlds, providing
    expressiveness and control where needed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择声明式和命令式API设计之间应该根据框架的具体需求和开发团队的首选来决定。找到正确的平衡至关重要，在许多情况下，结合两种风格元素的综合方法可能提供最佳效果，在需要的地方提供表达性和控制。
- en: The executability of a Java framework encompasses the mechanisms by which the
    framework’s code is executed within the JVM. This aspect involves crucial trade-offs,
    particularly when considering the use of reflection, avoiding reflection, and
    exploring options such as building native images.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Java框架的可执行性包括框架代码在JVM中执行时的机制。这一方面涉及到关键的权衡，尤其是在考虑使用反射、避免反射以及探索构建原生图像等选项时。
- en: Reflection, a dynamic feature in Java, enables the inspection and manipulation
    of classes, methods, and fields at runtime. While powerful, reflection comes with
    a performance cost, often resulting in slower execution times due to its dynamic
    nature. Additionally, reflection can reduce code safety, as errors might only
    be discovered during runtime. The trade-off here involves the flexibility and
    convenience offered by reflection versus potential performance drawbacks and the
    deferred nature of error detection.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 反射是Java中的一个动态特性，允许在运行时检查和操作类、方法和字段。虽然功能强大，但反射伴随着性能成本，由于其动态性质，通常会导致执行时间变慢。此外，反射可能会降低代码的安全性，因为错误可能只有在运行时才会被发现。这里的权衡涉及反射提供的灵活性和便利性与潜在的性能缺点和错误检测的延迟性之间的权衡。
- en: Frameworks can opt for approaches that avoid reflection, relying on more static
    and compile-time mechanisms. It promotes improved performance and early error
    detection but may require more explicit configuration and code generation. The
    decision to forego reflection often hinges on the framework’s specific needs,
    the desired performance level, and the trade-off between dynamism and static analysis.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 框架可以选择避免反射的方法，依靠更多静态和编译时机制。这促进了性能的提升和早期错误检测，但可能需要更多的显式配置和代码生成。是否放弃反射的决定通常取决于框架的具体需求、期望的性能水平以及动态性和静态分析之间的权衡。
- en: In recent developments, the concept of building native images has gained traction.
    Technologies such as GraalVM enable the compilation of Java code into native machine
    code, bypassing the need for the JVM during execution. This approach offers potential
    benefits regarding startup time, reduced memory footprint, and enhanced overall
    performance. However, it introduces trade-offs related to increased build complexity,
    potential compatibility issues, and the loss of some runtime features provided
    by the JVM.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在最近的发展中，构建原生图像的概念已经获得了关注。例如，GraalVM等技术能够将Java代码编译成原生机器代码，绕过了执行时对JVM的需求。这种方法在启动时间、减少内存占用和提升整体性能方面提供了潜在的好处。然而，它也引入了与增加构建复杂性、潜在的兼容性问题以及失去JVM提供的某些运行时功能相关的权衡。
- en: Ultimately, the choice of executability strategy involves careful consideration
    of the specific requirements of the framework, performance goals, and trade-offs
    between flexibility, convenience, and the overhead associated with reflection
    or native image compilation. Striking the right balance is crucial for achieving
    optimal performance while maintaining the desired level of dynamism and ease of
    development within the framework.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，可执行策略的选择需要对框架的具体要求、性能目标以及灵活性、便利性与反射或原生图像编译相关的开销之间的权衡进行仔细考虑。在保持框架所需动态性和开发便利性的同时，实现最佳性能的平衡至关重要。
- en: Indeed, in the landscape of Java framework principles and broader software development,
    several fundamental principles significantly influence the design and usability
    of frameworks. **Convention over configuration** is a pivotal principle emphasizing
    default conventions, reducing the need for explicit configuration when developers
    adhere to established patterns. It simplifies the framework’s usage, making it
    more intuitive and user-friendly.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，在Java框架原则和更广泛的软件开发领域，几个基本原则对框架的设计和可用性产生了重大影响。**约定优于配置**是一个关键原则，强调默认约定，当开发者遵循既定模式时，减少了对显式配置的需求。它简化了框架的使用，使其更加直观和用户友好。
- en: The creation of components follows the principle of modularity, encouraging
    the development of independent, reusable units that contribute to maintainability
    and scalability. Adhering to Java standards, such as coding conventions and design
    patterns, ensures consistency and interoperability within the Java ecosystem.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的创建遵循模块化原则，鼓励开发独立的、可重用的单元，有助于维护性和可扩展性。遵循Java标准，如编码规范和设计模式，确保在Java生态系统中的一致性和互操作性。
- en: Documentation and testing play indispensable roles in the success of a framework.
    Comprehensive and well-structured documentation enables users to understand the
    framework’s functionality, aiding its adoption and reducing the learning curve.
    Thorough testing ensures the reliability and robustness of the framework, instilling
    confidence in developers.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 文档和测试在框架的成功中扮演着不可或缺的角色。全面且结构良好的文档使用户能够理解框架的功能，有助于其采用并降低学习曲线。彻底的测试确保了框架的可靠性和健壮性，增强了开发者对框架的信心。
- en: Furthermore, the **Service Provider (SP)** approach introduces a plugin-like
    architecture, allowing developers to extend or modify the behavior of a framework
    seamlessly. This principle fosters a **plug-and-play (PnP)** effect, enabling
    users to incorporate additional functionalities or customize the framework without
    altering its core code base.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，**服务提供者（SP）**方法引入了一种类似插件的架构，允许开发者无缝地扩展或修改框架的行为。这一原则促进了**即插即用（PnP）**效应，使用户能够在不改变其核心代码库的情况下，集成额外的功能或自定义框架。
- en: Collectively, these principles contribute to creating effective and user-friendly
    frameworks in the Java ecosystem. They emphasize conventions, modularity, adherence
    to standards, robust documentation, testing rigor, and extensibility through SPs,
    fostering a holistic approach to framework design and development. Embracing these
    principles ensures that frameworks not only meet the immediate needs of developers
    but also stand the test of time as reliable and adaptable tools in the dynamic
    world of software development.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，这些原则共同促成了Java生态系统中有效且用户友好的框架的创建。它们强调惯例、模块化、遵循标准、稳健的文档、严格的测试以及通过SPs的可扩展性，培养了一种全面的框架设计和开发方法。接受这些原则确保框架不仅满足开发者的当前需求，而且在软件开发的动态世界中作为可靠和适应性的工具经受住时间的考验。
- en: Summary
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In concluding our exploration of Java framework principles and broader software
    development tenets, we’ve uncovered a tapestry of considerations—from API design
    and executability to convention over configuration and the significance of documentation
    and testing. These principles collectively guide the creation of robust, user-friendly
    frameworks that align with Java standards and embrace modularity. As we transition
    to the next chapter focused on Java reflection, we delve into a critical aspect
    of executability, unraveling dynamic capabilities and potential trade-offs inherent
    in the reflective nature of Java. Join us in this exploration as we navigate the
    intricacies of reflection, unlocking its power and understanding how it shapes
    the landscape of dynamic Java programming.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '在我们探索Java框架原则和更广泛的软件开发原则的过程中，我们揭示了一系列考虑因素——从API设计和可执行性到契约优于配置以及文档和测试的重要性。这些原则共同指导着创建稳健、用户友好的框架，这些框架与Java标准保持一致并拥抱模块化。随着我们过渡到下一章，专注于Java反射，我们深入探讨了可执行性的关键方面，揭示了Java反射本质中固有的动态能力和潜在权衡。加入我们的探索，我们将导航反射的复杂性，解锁其力量并了解它是如何塑造动态Java编程领域的。 '
- en: Questions
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章知识的掌握：
- en: What is a key consideration when deciding between a declarative and an imperative
    API design in a Java framework?
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Java框架中决定采用声明式API设计还是命令式API设计时，一个关键考虑因素是什么？
- en: Code verbosity
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码冗余
- en: Compilation speed
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译速度
- en: Memory consumption
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内存消耗
- en: Database compatibility
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库兼容性
- en: Which principle emphasizes reducing the need for explicit configuration by relying
    on established patterns and defaults?
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个原则强调通过依赖既定模式和默认值来减少显式配置的需求？
- en: Concurrency control
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并发控制
- en: Convention over configuration
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 契约优于配置
- en: '**Dependency** **injection** (**DI**)'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**依赖注入**（**DI**）'
- en: Modularization
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块化
- en: Why is comprehensive documentation crucial for a Java framework?
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么全面文档对于一个Java框架至关重要？
- en: To increase development complexity
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了增加开发复杂性
- en: To deter users from adopting the framework
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了阻止用户采用该框架
- en: To reduce the learning curve for users
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了降低用户的学习曲线
- en: To limit the framework’s capabilities
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了限制框架的功能
- en: What approach enables a plugin-like architecture, allowing developers to extend
    or modify the behavior of a framework seamlessly?
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种方法能够实现类似插件式的架构，允许开发者无缝地扩展或修改框架的行为？
- en: '**Aspect-oriented** **programming** (**AOP**)'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**面向方面**的**编程**（**AOP**）'
- en: '**Model-View-Controller** (**MVC**)'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模型-视图-控制器**（**MVC**）'
- en: Observer pattern
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察者模式
- en: SP approach
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: SP方法
- en: Answers
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Here are the answers to this chapter’s questions:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是本章问题的答案：
- en: A. Code verbosity
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A. 代码冗余
- en: B. Convention over configuration
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B. 契约优于配置
- en: C. To reduce the learning curve for users
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C. 为了降低用户的学习曲线
- en: D. SP approach
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: D. SP方法
