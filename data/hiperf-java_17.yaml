- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: Unit and Performance Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试和性能测试
- en: The importance of thoroughly testing our code cannot be overstated; moreover,
    this testing should be efficient. As our systems grow in complexity and scale,
    it becomes increasingly critical for us to ensure that every component of our
    software functions accurately and efficiently. This is where unit and performance
    testing comes into play. This is the focus of this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 代码彻底测试的重要性不容忽视；此外，这种测试应该是高效的。随着我们的系统在复杂性和规模上的增长，确保我们软件的每个组件都能准确且高效地运行变得越来越关键。这就是单元和性能测试发挥作用的地方。这也是本章的重点。
- en: The chapter starts by covering **unit testing**, which we use to verify individual
    units of code. The goal is to ensure that the units perform efficiently and as
    expected. Through unit testing, we can catch anomalies (bugs) early, before the
    code is deployed into a production environment. Performance testing is introduced
    as a complementary process, whereby we test our software under various conditions
    to assess behaviors such as responsiveness, availability, scalability, reliability,
    and scalability. As the chapter demonstrates, performance testing can help us
    identify potential bottlenecks and ensure our systems can handle anticipated use
    cases and loads.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先介绍了**单元测试**，这是我们用来验证代码各个单元的方法。目标是确保单元能够高效且按预期运行。通过单元测试，我们可以在代码部署到生产环境之前及早发现异常（错误）。性能测试作为一个补充过程被引入，在这个过程中，我们测试软件在各种条件下的行为，如响应性、可用性、可伸缩性、可靠性和可伸缩性。正如本章所展示的，性能测试可以帮助我们识别潜在的瓶颈，并确保我们的系统可以处理预期的用例和负载。
- en: Both theoretical and hands-on approaches are taken in this chapter, giving you
    the opportunity to gain knowledge and experience with unit and performance testing.
    We will cover overarching strategies to include integrating both types of testing,
    automation, test environments, continuous testing, and feedback loops.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章采用了理论和实践相结合的方法，给你提供了在单元和性能测试中获得知识和经验的机会。我们将涵盖包括集成两种类型测试、自动化、测试环境、持续测试和反馈循环在内的总体策略。
- en: By the end of this chapter, you will have a thorough understanding of unit and
    performance testing and be able to leverage them to enhance the reliability and
    efficiency of your Java applications.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将全面理解单元和性能测试，并能够利用它们来提高Java应用程序的可靠性和效率。
- en: 'This chapter covers the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主要主题：
- en: Unit testing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Performance testing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能测试
- en: Overarching strategies
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总体策略
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the examples and instructions in this chapter, you will need the ability
    to load, edit, and run Java code. If you have not set up your development environment,
    refer to [*Chapter 1*](B21942_01.xhtml#_idTextAnchor014), *Peeking Inside the
    Java Virtual* *Machine (JVM)*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章中的示例和说明，你需要能够加载、编辑和运行Java代码。如果你还没有设置你的开发环境，请参考[*第1章*](B21942_01.xhtml#_idTextAnchor014)，*Java虚拟机（JVM）内部窥视*。
- en: 'The finished code for this chapter can be found here:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完成代码可以在以下链接找到：
- en: '[https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter17](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter17)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter17](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter17)'
- en: Unit testing
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: The software developer’s adage of “test, test, and test again” still applies
    to modern systems but in a more refined way. Instead of testing our systems as
    a whole, we focus on small components of our code to ensure that they perform
    efficiently and as expected. These components are referred to as **units**. When
    we isolate units of code, we can more easily detect bugs and improve the overall
    quality of our code. This approach is referred to as unit testing and is the focus
    of this section.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发者的格言“测试，测试，再测试”仍然适用于现代系统，但方式更为精细。我们不再测试整个系统，而是关注代码的小组件，以确保它们能够高效且按预期运行。这些组件被称为**单元**。当我们隔离代码单元时，我们可以更容易地检测到错误并提高代码的整体质量。这种方法被称为单元测试，也是本节的重点。
- en: Unit testing
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit testing is an approach to software testing that involves testing the smallest
    sections of a system’s code to ensure that it performs correctly and efficiently
    in isolation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是一种软件测试方法，它涉及测试系统代码的最小部分，以确保它在独立的情况下能够正确且高效地运行。
- en: 'The primary benefits of unit testing include the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的主要好处包括以下内容：
- en: '**Bug detection**: Unit testing enables us to detect bugs early, before the
    code is published as part of the larger system.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误检测**：单元测试使我们能够在代码作为更大系统的一部分发布之前早期检测错误。'
- en: '**Code quality**: This testing approach, with its finite focus, results in
    higher code quality.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码质量**：这种具有有限关注点的测试方法导致代码质量更高。'
- en: '**Documentation**: The process of unit testing includes documentation of each
    unit’s functionality, purpose, connectivity, and dependencies.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档**：单元测试的过程包括记录每个单元的功能、目的、连接性和依赖关系。'
- en: Now that we understand what unit testing is and why it is important, let’s look
    at two popular unit testing frameworks.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了单元测试是什么以及为什么它很重要，让我们看看两个流行的单元测试框架。
- en: Frameworks
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架
- en: One of the most common unit testing frameworks is **JUnit**, perhaps because
    of its simplicity and ease of integration with **Integrated Development Environments**
    (**IDEs**). Another popular framework is **TestNG**, which is comparatively more
    flexible and has functionality in addition to JUnit.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的单元测试框架之一是**JUnit**，可能是因为它的简单性和与**集成开发环境**（**IDEs**）集成的容易性。另一个流行的框架是**TestNG**，它比JUnit更灵活，并具有JUnit之外的功能。
- en: We will focus on JUnit and demonstrate how to write a unit test in the next
    section.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于JUnit，并在下一节中演示如何编写单元测试。
- en: Writing unit tests
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: 'There are several ways you can write and implement unit testing. Here is a
    straightforward approach:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以多种方式编写和实现单元测试。这里有一个简单的方法：
- en: Ensure that you have a recent version of the **Java Development Kit** (**JDK**)
    installed.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你已经安装了最新的**Java开发工具包**（**JDK**）。
- en: Download and install the **JUnit Jupiter API and Engine JARs**. The process
    for accomplishing this will depend on your IDE.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并安装**JUnit Jupiter API和Engine JARs**。完成此过程的方法将取决于你的IDE。
- en: Assuming that you are using Visual Studio Code, install the **Test Runner for**
    **Java** extension.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你正在使用Visual Studio Code，请安装**Java测试运行器**扩展。
- en: 'To demonstrate unit testing, we will write a simple calculator program, as
    shown here:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示单元测试，我们将编写一个简单的计算器程序，如下所示：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, our application contains methods for adding, subtracting, multiplying,
    and dividing two numbers based on passed parameters. Next, let’s create a `testing`
    class:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的应用程序包含基于传递参数添加、减去、乘以和除以两个数字的方法。接下来，让我们创建一个`testing`类：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see in the preceding code, we have created individual methods to
    test the methods in the primary class file. The next step is to run the test.
    Using Visual Studio Code, you can select the testing icon (the beaker in the leftmost
    panel). Now you can run individual tests, or all of the tests, by selecting the
    **Run Test** button to the right of each test name.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们已为初级类文件中的方法创建了单独的测试方法。下一步是运行测试。使用Visual Studio Code，你可以选择左侧面板中的测试图标（烧杯）。现在，你可以通过选择每个测试名称右侧的**运行测试**按钮来运行单个测试或所有测试。
- en: '![Figure 17.1 – The Visual Studio Code navigation panel](img/B21942_17_1.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图17.1 – Visual Studio Code导航面板](img/B21942_17_1.jpg)'
- en: Figure 17.1 – The Visual Studio Code navigation panel
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.1 – Visual Studio Code导航面板
- en: 'The test results will be available in the bottom section of your `testMultiple()`
    method:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 测试结果将在你的`testMultiple()`方法的底部部分显示：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This demonstrates a simple unit test. Next, let’s review some best practices
    to help us get the most out of unit testing.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这演示了一个简单的单元测试。接下来，让我们回顾一些最佳实践，以帮助我们充分利用单元测试。
- en: Best practices
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: A key best practice for unit testing is to keep the tests as small as possible.
    This will give us a tighter focus and allow us to more rapidly troubleshoot and
    resolve issues through code edits.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的一个关键最佳实践是尽量保持测试尽可能小。这将使我们能够更紧密地关注，并允许我们通过代码编辑更快地调试和解决问题。
- en: Another best practice is to ensure that our tests are **isolated tests**, which
    are tests that are independent of any external factors. This helps ensure that
    any errors or issues we detect are caused by our code and not an external environment.
    If we do not take this approach, we might struggle to efficiently determine the
    source of any errors.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个最佳实践是确保我们的测试是**隔离测试**，即独立于任何外部因素的测试。这有助于确保我们检测到的任何错误或问题是由我们的代码而不是外部环境引起的。如果我们不采取这种做法，我们可能难以有效地确定错误的来源。
- en: A third practice is to ensure that our tests cover a myriad of scenarios, including
    error conditions and even edge cases. This is a thorough approach that strives
    to test for any possible situation. The extended time that this approach takes
    is worth it, as our approach can help ensure that our systems can perform under
    both routine and irregular conditions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个实践是确保我们的测试覆盖了各种场景，包括错误条件和甚至边缘情况。这是一个彻底的方法，旨在测试任何可能的情况。这种方法所花费的额外时间是值得的，因为它可以帮助确保我们的系统在常规和不规则条件下都能正常工作。
- en: A fourth best practice, **assertions**, will be covered next.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个最佳实践，**断言**，将在下一节中介绍。
- en: Assertions
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 断言
- en: Assertions are an important best practice. This best practice is simply to leverage
    assertions to validate expected outcomes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 断言是一个重要的最佳实践。这个最佳实践就是利用断言来验证预期的结果。
- en: Assertions
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 断言
- en: Assertions are code statements that are used to check whether a condition is
    true.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 断言是用于检查条件是否为真的代码语句。
- en: When an assertion fails, it indicates that the condition evaluated by the assertion
    is false, which usually results in the unit test failing. There are several assertion
    methods that we can use in JUnit. Let’s look at four of the most common assertion
    methods.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个断言失败时，这表明断言评估的条件是错误的，这通常会导致单元测试失败。在JUnit中，我们可以使用几种断言方法。让我们看看四种最常见的断言方法。
- en: '`assertEquals`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertEquals`'
- en: '`Assertions.assertEquals(expected, actual);`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Assertions.assertEquals(expected, actual);`'
- en: '**Example**:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**:'
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`assertNotEquals`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertNotEquals`'
- en: '`Assertions.assertNotEquals(unexpected, actual);`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Assertions.assertNotEquals(unexpected, actual);`'
- en: '**Example**:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**:'
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`assertTrue`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertTrue`'
- en: '`Assertions.assertTrue(condition)`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`Assertions.assertTrue(condition)`'
- en: '**Example**:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**:'
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`assertFalse`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertFalse`'
- en: '`Assertions.assertFalse(condition);`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Assertions.assertFalse(condition);`'
- en: '**Example**:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**:'
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To use an assertion in our application, we simply add a line of code to each
    unit test. For example, as you review the `testAdd()` method in our `CH17CalculatorTest`
    application, you will see that it uses the `assertEquals()` assertion method:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的应用程序中使用断言，我们只需在每个单元测试中添加一行代码。例如，当你审查我们的`CH17CalculatorTest`应用程序中的`testAdd()`方法时，你会看到它使用了`assertEquals()`断言方法：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that we have an understanding of some best practices in writing unit tests,
    let’s review some common pitfalls.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了编写单元测试的一些最佳实践，让我们回顾一些常见的陷阱。
- en: Pitfalls
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 陷阱
- en: 'As powerful as unit testing is, it also comes with several pitfalls. Here are
    three common pitfalls involved with unit testing and how to avoid them:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管单元测试非常强大，但它也伴随着一些陷阱。以下是与单元测试相关的三个常见陷阱以及如何避免它们：
- en: '| **Pitfall** | **Avoidance strategy** |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| **陷阱** | **避免策略** |'
- en: '| Ignoring edge cases | When we ignore edge cases in our unit testing, our
    systems can have undetected bugs. Ensure that you include a robust edge case strategy
    in your unit testing. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 忽略边缘情况 | 当我们在单元测试中忽略边缘情况时，我们的系统可能会有未检测到的错误。确保你在单元测试中包含一个健壮的边缘情况策略。|'
- en: '| Over-testing | Over-testing in our context is creating tests that are too
    large, covering multiple units. To avoid this pitfall, create unit tests that
    are isolated from external dependencies and are focused on a single unit of code.
    |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 过度测试 | 在我们的语境中，过度测试是指创建过大、覆盖多个单元的测试。为了避免这个陷阱，创建与外部依赖隔离且专注于单一代码单元的单元测试。|'
- en: '| Under-testing | Under-testing refers to not running tests frequently enough
    to catch issues, especially when changing environments and scaling systems. To
    avoid this pitfall, perform tests frequently. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 测试不足 | 测试不足是指没有频繁运行测试以捕捉问题，尤其是在更改环境和扩展系统时。为了避免这个陷阱，要频繁进行测试。|'
- en: Table 17.1 – Unit testing pitfalls and avoidance strategies
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 表17.1 – 单元测试陷阱和避免策略
- en: We will conclude our coverage of unit testing with a look at **Test-Driven**
    **Development** (**TTD**).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过查看**测试驱动开发**（**TTD**）来结束我们对单元测试的讨论。
- en: TDD
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TDD
- en: TTD is an interesting software development approach whereby the unit tests are
    written before the code is. The TDD cycle is often referred to as **Red-Green-Refactor**
    and is illustrated in *Figure 17**.2*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: TTD是一种有趣的软件开发方法，其中单元测试是在编写代码之前编写的。TDD周期通常被称为**红-绿-重构**，并在*图17.2*中展示。
- en: '![Figure 17.2 – The TTD cycle](img/B21942_17_2.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图17.2 – TTD周期](img/B21942_17_2.jpg)'
- en: Figure 17.2 – The TTD cycle
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.2 – TTD周期
- en: TDD implementation starts with the Red step, wherein we write a test that fails
    because the related functionality has not been written. Next, in the Green step,
    we write the minimum amount of code required so the test will pass. Finally, in
    the Refactor step, we refactor our code to make it more efficient, improve its
    readability, and ensure that all related unit tests continue to pass.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: TDD实施从红色步骤开始，我们编写一个失败的测试，因为相关的功能尚未编写。接下来，在绿色步骤中，我们编写所需的最少代码，以便测试通过。最后，在重构步骤中，我们重构代码以提高其效率、改善其可读性，并确保所有相关单元测试继续通过。
- en: 'The advantages of implementing TDD include the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 实施TDD的优势包括以下内容：
- en: Promoting clean code
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 促进编写干净的代码
- en: Ensuring that the code is testable
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保代码可测试
- en: Helping developers thoroughly consider requirements before writing code
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助开发者在编写代码前充分考虑需求
- en: 'There are also a few challenges to the TDD approach, including the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: TDD方法也有一些挑战，包括以下内容：
- en: It is not beginner-friendly
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它对初学者不友好
- en: It requires a mental paradigm shift
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这需要思维模式的转变
- en: It can slow initial development
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能会减缓初始开发
- en: Now that we have a firm handle on unit testing, let’s explore performance testing
    in the next section.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对单元测试有了牢固的掌握，让我们在下一节中探索性能测试。
- en: Performance testing
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能测试
- en: 'The crux of this book has been to ensure our Java applications perform at the
    highest possible level. Several strategies, tools, and techniques have been presented
    to help us achieve our goal of high performance. In the previous section, we covered
    unit testing to help us ensure proper functionality. With performance testing,
    we will test our applications to see whether they can perform under various conditions
    and loads. This testing strategy involves evaluating the following characteristics
    of our applications: efficiency (speed), stability, responsiveness, reliability,
    and scalability.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的核心在于确保我们的Java应用程序以尽可能高的水平运行。我们已经介绍了多种策略、工具和技术，以帮助我们实现高性能的目标。在前一节中，我们介绍了单元测试，以帮助我们确保功能的正确性。通过性能测试，我们将测试我们的应用程序，看它们是否能在各种条件和负载下运行。这种测试策略包括评估以下应用程序的特性：效率（速度）、稳定性、响应性、可靠性和可扩展性。
- en: There are several primary objectives of performance testing, including the determination
    of whether performance criteria have been met. We also want to identify performance
    bottlenecks so that we can refine our code. An additional objective is to ensure
    that our application can handle anticipated system and user loads.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试有几个主要目标，包括确定是否满足性能标准。我们还希望识别性能瓶颈，以便我们可以优化代码。另一个目标是确保我们的应用程序可以处理预期的系统和用户负载。
- en: Types and tools
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型与工具
- en: 'The five primary types of performance tests are detailed in the table that
    follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 五种主要性能测试类型在下面的表格中详细说明：
- en: '| **Type** | **Focus** |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **重点** |'
- en: '| **Endurance testing** | Checks for memory leaks and resource depletion with
    a sustained load over extended time |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| **耐久性测试** | 在长时间持续负载下检查内存泄漏和资源耗尽 |'
- en: '| **Load testing** | Tests performance with a specific number of concurrent
    users |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| **负载测试** | 使用特定数量的并发用户测试性能 |'
- en: '| **Scalability testing** | Checks scalability by adding transactions and users
    |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| **可扩展性测试** | 通过添加事务和用户来检查可扩展性 |'
- en: '| **Spike testing** | Determines whether the application can handle a sudden
    increase in load |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| **峰值测试** | 确定应用程序是否能够处理负载的突然增加 |'
- en: '| **Stress testing** | Pushes the load past capacity to determine the breaking
    point |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| **压力测试** | 将负载推过容量，以确定破坏点 |'
- en: Table 17.2 – Performance test types
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 表17.2 – 性能测试类型
- en: It is important to implement a performance testing plan that includes each type
    of performance test with an added focus on the types that are more critical to
    your specific application and goals.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 实施一个包含每种性能测试类型，并特别关注对你特定应用程序和目标更关键的类型的性能测试计划是很重要的。
- en: 'There are several tools available to help us with performance testing. The
    three most common ones are featured in the table that follows. The table includes
    use cases for each:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种工具可以帮助我们进行性能测试。以下表格中列出了三种最常见工具，并包括每个工具的使用案例：
- en: '| **Tool** | **Description** | **Use case** |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| **工具** | **描述** | **使用案例** |'
- en: '| Apache Bench | Basic command-line tool for benchmarking HTTP servers | Simple
    load tests of HTTP services |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| Apache Bench | 用于基准测试HTTP服务的基本命令行工具 | 简单的HTTP服务负载测试 |'
- en: '| Apache JMeter | Open source tool for load testing | Comprehensive testing
    with a variety of protocols (that is, HTTP, FTP, and so on) |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| Apache JMeter | 开源负载测试工具 | 支持多种协议的综合测试（即HTTP、FTP等）|'
- en: '| Gatling | Advanced open source tool that simulates high user loads | Advanced
    load testing scenarios |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| Gatling | 高级开源工具，用于模拟高用户负载 | 高级负载测试场景|'
- en: Table 17.3 – Performance testing tools
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 表17.3 – 性能测试工具
- en: Let’s wrap up this chapter with a look at big-picture approaches that are specific
    to unit testing and performance testing.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看针对单元测试和性能测试的具体的大图景方法来结束本章。
- en: Overarching strategies
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总体策略
- en: This chapter’s previous two sections were focused on unit testing and performance
    testing. This final section considers how we might combine the two types of testing
    for a cohesive strategy. This duality of testing is critical to our ability to
    develop and maintain robust and highly efficient Java applications.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的前两节专注于单元测试和性能测试。本节的最后部分考虑了如何将这两种测试类型结合起来形成一个连贯的策略。这种测试的双重性对于我们开发和维护健壮且高效Java应用程序的能力至关重要。
- en: We will start with a look at how to integrate the two types of testing.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先探讨如何整合这两种测试类型。
- en: Integrating unit and performance testing
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整合单元测试和性能测试
- en: There are a few strategies we can adopt for incorporating both types of testing.
    The first approach is **parallel testing**, which involves running unit tests
    and performance tests in parallel. This approach can save us time. Another approach
    is **shared test cases**, which can make our testing more efficient. This approach
    allows us to leverage shared test data and potential configurations. A third,
    more advanced strategy is to use a **unified testing framework**. These frameworks
    support both types of testing and can ensure a seamless transition between them.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采用一些策略来整合这两种测试类型。第一种方法是**并行测试**，它涉及并行运行单元测试和性能测试。这种方法可以节省我们的时间。另一种方法是**共享测试用例**，这可以使我们的测试更加高效。这种方法允许我们利用共享的测试数据和潜在配置。第三种，更高级的策略是使用**统一测试框架**。这些框架支持两种类型的测试，并确保它们之间的无缝过渡。
- en: Regardless of our implementation approach, we want to ensure that we have comprehensive
    test coverage. To accomplish this, we should use tools to measure our code coverage
    for both testing types. This is referred to as **coverage analysis** and helps
    us ensure that all critical paths are tested. We should also use **incremental
    testing**, whereby we gradually increase our test coverage until all code has
    been covered by tests. Finally, we should conduct a **cross-validation** of our
    test results with performance outcomes. This validation is used to confirm that
    functionality is accurate and performance efficiency is acceptable.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们的实现方法如何，我们都想确保我们有全面的测试覆盖。为了实现这一点，我们应该使用工具来测量这两种测试类型的代码覆盖率。这被称为**覆盖率分析**，有助于我们确保所有关键路径都已测试。我们还应该使用**增量测试**，通过逐渐增加我们的测试覆盖率，直到所有代码都被测试覆盖。最后，我们应该对我们的测试结果与性能结果进行**交叉验证**。这种验证用于确认功能准确性以及性能效率的可接受性。
- en: Summary
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter explored the critical role of testing in ensuring the reliability
    and efficiency of our Java applications. We started with an introduction to unit
    testing, highlighting its purpose, benefits, and best practices for writing effective
    tests. We then covered performance testing, explaining its objectives and the
    various types such as load and stress testing. The chapter concluded with a look
    at overarching strategies to integrate both testing types seamlessly into the
    development workflow, emphasizing the need for unified frameworks and comprehensive
    test coverage to enhance the overall quality and performance of our Java applications.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了测试在确保我们的Java应用程序可靠性和效率中的关键作用。我们从一个单元测试的介绍开始，强调了其目的、好处以及编写有效测试的最佳实践。然后我们介绍了性能测试，解释了其目标和各种类型，如负载和压力测试。本章最后讨论了将这两种测试类型无缝集成到开发工作流程中的总体策略，强调了统一框架和全面测试覆盖对于提高我们Java应用程序整体质量和性能的必要性。
- en: In the next chapter, we will take an extensive look at how to leverage **Artificial
    Intelligence** (**AI**) tools and technologies to help ensure that our applications
    are as efficient as possible and that they perform at the highest possible level.
    The chapter offers several opportunities for developers to harness the power of
    AI for the betterment of their Java applications’ performance.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将广泛探讨如何利用**人工智能**（**AI**）工具和技术来确保我们的应用程序尽可能高效，并且它们能够达到最高的性能水平。本章为开发者提供了几个机会，以利用人工智能的力量来提升他们Java应用程序的性能。
