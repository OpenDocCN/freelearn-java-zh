- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Ultra-Fast In-Memory Persistence with Eclipse Store
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Eclipse Store的超快内存持久化
- en: 'NoSQL and SQL databases can be impressive and powerful when handling their
    target use cases. However, users seeking optimal performance need to be aware
    of other aspects that can influence the application in terms of processing efficiency,
    speed, and even code design. In this regard, one example can be mentioned upfront:
    most of these database solutions will require some sort of mapping between the
    database schema and the application data models. As you can imagine, the mapping
    needs to happen every single time data flows back and forth between the application
    and the database. This characteristic, known as **object-relational impedance
    mismatch**, has a high potential to impact most of the database types we’ve mentioned
    so far – SQL and NoSQL.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL和SQL数据库在处理其目标用例时可以非常出色且强大。然而，寻求最佳性能的用户需要意识到其他可能影响应用程序在处理效率、速度甚至代码设计方面的因素。在这方面，可以提前提到一个例子：这些数据库解决方案中的大多数将需要在数据库模式与应用程序数据模型之间进行某种类型的映射。正如你可以想象的那样，映射需要在应用程序和数据库之间数据流动的每次都发生。这种被称为**对象关系阻抗不匹配**的特性，有很高的潜力影响我们之前提到的几乎所有数据库类型——SQL和NoSQL。
- en: In this chapter, we will discuss another database paradigm, in-memory databases.
    Adding to the significant performance boost, this is definitely the type of database
    to be leveraged when working on use cases such as data processing, web and mobile
    apps, and caching and real-time analytics. For such scenarios, a highly performant
    data storage solution, low-latency data access, and real-time data processing
    appear to be promising alternatives since they allow for the delivery of super-fast
    persistence solutions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论另一种数据库范式，即内存数据库。除了显著的性能提升外，这绝对是在处理数据处理、Web和移动应用、缓存和实时分析等用例时可以利用的数据库类型。对于此类场景，高性能的数据存储解决方案、低延迟的数据访问和实时数据处理似乎是有希望的替代方案，因为它们允许提供超快的持久化解决方案。
- en: We’ll explore the aforementioned concepts with **Eclipse Store**, a high-performance,
    lightweight solution for in-memory persistence. One of the points of this database
    is to be faster and eliminate extra processing, and reduce code size and complexity,
    especially when compared with the integration of, for example, SQL databases and
    Hibernate/JPA.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**Eclipse Store**，一个高性能、轻量级的内存持久化解决方案，来探索上述概念。这个数据库的一个要点是更快，消除额外处理，减少代码大小和复杂性，尤其是在与SQL数据库和Hibernate/JPA集成相比时。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Why is latency secretly added to every database operation? We will understand
    what object-relational impedance mismatch is and how it can affect persistence
    performance.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么每个数据库操作都会秘密地增加延迟？我们将了解对象关系阻抗不匹配是什么以及它如何影响持久化性能。
- en: What is an in-memory persistence storage and how does it differ from other database
    types?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是内存持久化存储，它与其他数据库类型有何不同？
- en: Exploring Eclipse Store.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Eclipse Store。
- en: Eclipse Store with Jakarta/MicroProfile.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eclipse Store与Jakarta/MicroProfile。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are the technical requirements for this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为本章的技术要求：
- en: Java 17
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 17
- en: Git
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git
- en: Maven
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven
- en: Any preferred IDE
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何首选IDE
- en: The source code for this chapter is available at [https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter-08](https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter-08).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在[https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter-08](https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter-08)找到。
- en: Object-relational impedance mismatch explained
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象关系阻抗不匹配解释
- en: As Java developers, we know the power of the **object-oriented programming**
    (**OOP**) paradigm – it allows us to explore several patterns based on polymorphism,
    encapsulation, heritage, interface, creating custom types, and so on. We love
    it! Mainly because we can combine these approaches with design patterns to create
    clean and readable code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Java开发者，我们知道面向对象编程（**OOP**）范式的力量——它允许我们根据多态性、封装、继承、接口、创建自定义类型等探索多个模式。我们非常喜欢它！主要是因为我们可以将这些方法与设计模式结合起来，创建干净且易于阅读的代码。
- en: Unfortunately, many of these OOP concepts and behaviors are not available on
    the database side, a characteristic named **impedance mismatch**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，许多这些面向对象的概念和行为在数据库端不可用，这种特性被称为**阻抗不匹配**。
- en: '**Object-Relational Mapping** (**ORM**) impedance mismatch is a specific type
    of impedance mismatch that occurs when mapping data between an oop language and
    a **relational database management** **system** (**RDBMS**).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象-关系映射**（**ORM**）阻抗不匹配是在将数据在面向对象语言和**关系数据库管理系统**（**RDBMS**）之间映射时发生的一种特定类型的阻抗不匹配。'
- en: OOP languages such as Java, Python, and C# use objects to represent and manipulate
    data, whereas relational databases use tables to store and manage data. ORM is
    a technique used to bridge the gap between these two different paradigms by mapping
    objects to database tables and vice versa.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如Java、Python和C#这样的面向对象（OOP）语言使用对象来表示和操作数据，而关系数据库使用表来存储和管理数据。ORM是一种技术，通过将对象映射到数据库表以及反向映射来弥合这两种不同范式之间的差距。
- en: '![Figure 8.1 – Example of Java object model equivalent mapping on the database
    schema](img/Figure_8.01_B19375.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 数据库模式上Java对象模型等价映射的示例](img/Figure_8.01_B19375.jpg)'
- en: Figure 8.1 – Example of Java object model equivalent mapping on the database
    schema
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 数据库模式上Java对象模型等价映射的示例
- en: The ORM impedance mismatch occurs because objects and tables have different
    properties and structures. For example, objects can have complex data types, inheritance,
    and polymorphism, while tables consist of simple rows and columns. In addition,
    objects can have relationships with other entities, whereas tables have relationships
    between rows.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ORM阻抗不匹配发生的原因是对象和表具有不同的属性和结构。例如，对象可以具有复杂的数据类型、继承和多态，而表由简单的行和列组成。此外，对象可以与其他实体有关系，而表则行与行之间存在关系。
- en: To mitigate this impedance mismatch and make the developer more efficient, ORM
    tools provide mapping strategies that allow developers to map objects to tables
    and vice versa. These strategies can include ORM patterns such as table inheritance,
    association mapping, and lazy loading.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻这种阻抗不匹配并提高开发效率，ORM工具提供了映射策略，允许开发人员将对象映射到表以及反向映射。这些策略可以包括ORM模式，如表继承、关联映射和延迟加载。
- en: Despite these strategies, ORM impedance mismatch can still occur due to differences
    in the query language, performance issues, and scalability problems. As a result,
    developers need to be aware of the limitations and trade-offs involved in using
    ORM tools and consider alternative solutions where necessary.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有这些策略，但由于查询语言、性能问题和可扩展性问题，ORM阻抗不匹配仍然可能发生。因此，开发人员需要了解使用ORM工具所涉及的限制和权衡，并在必要时考虑替代解决方案。
- en: Another item to highlight in regard to the mapping processing is that it uses
    a mapper. The mapper, used on every app-database interaction, is responsible for
    converting to/from entities and requires a lot of CPU power, which may end up
    being heavier than the executed query itself.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在映射处理方面，另一个需要强调的事项是它使用映射器。这个映射器在每次应用程序-数据库交互中使用，负责将实体转换为/从实体转换，并且需要大量的CPU资源，这可能会导致比执行的查询本身更重。
- en: This mapper has a bright mechanism for communicating between paradigms. Even
    with a cache and the most advanced techniques to improve performance, this process
    might be a nightmare in several applications.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个映射器具有一种在范式之间通信的明亮机制。即使有缓存和最先进的性能提升技术，这个过程在许多应用程序中也可能是一个噩梦。
- en: A technology we can adopt to beat this challenge and avoid doing extra Java
    processing on every database operation is Eclipse Store. Let’s get into what this
    in-memory database is, how it works, and how you can get started with it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采用的一种技术来克服这个挑战，并避免在每次数据库操作上都进行额外的Java处理，就是Eclipse Store。让我们深入了解这个内存数据库是什么，它是如何工作的，以及如何开始使用它。
- en: Eclipse Store is a Java-based, open source, in-memory data storage technology
    that offers a new approach to object persistence.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse Store是一种基于Java的开源内存数据存储技术，它提供了一种新的对象持久化方法。
- en: Unlike traditional databases that rely on ORM to map objects to relational tables,
    Eclipse Store’s internal mechanisms locate and use Java objects available on the
    heap. It can get the information *directly* from memory, eliminating the need
    for mapping or serialization. This approach results in faster application performance
    since it avoids the ORM impedance mismatch and reduces the need for costly database
    access.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与依赖于ORM将对象映射到关系表的传统数据库不同，Eclipse Store的内部机制定位并使用堆上的Java对象。它可以直接从内存中获取信息，消除映射或序列化的需要。这种方法由于避免了ORM阻抗不匹配并减少了昂贵的数据库访问需求，从而实现了更快的应用程序性能。
- en: Eclipse Store began as MicroStream 10 years ago as a closed source project.
    Recently, MicroStream went open source and became two Eclipse projects, one being
    Eclipse Store.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse Store 10 年前作为 MicroStream 的一个闭源项目开始。最近，MicroStream 开源了，并成为两个 Eclipse
    项目，其中一个是 Eclipse Store。
- en: Eclipse Store provides a Java API that allows developers to store, load, and
    manipulate Java objects directly in memory without the need to access a separate
    database. The data can optionally be persisted externally, and in such cases,
    it is stored in a compressed binary format, allowing for efficient memory resource
    use. This approach eliminates the need for ORM, which can be time-consuming and
    resource-intensive, especially for complex object hierarchies.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse Store 提供了一个 Java API，允许开发者直接在内存中存储、加载和操作 Java 对象，无需访问单独的数据库。数据可以选择外部持久化，在这种情况下，它以压缩的二进制格式存储，从而允许高效地使用内存资源。这种方法消除了
    ORM 的需求，ORM 可能耗时且资源密集，尤其是对于复杂的对象层次结构。
- en: Eclipse Store operates mostly in memory; therefore, it can provide ultra-fast
    read and write access to data, making it ideal for high-performance data-processing
    applications, such as real-time analytics, financial trading, and gaming.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse Store 主要在内存中运行；因此，它可以提供对数据的超快读写访问，使其非常适合高性能数据处理应用，如实时分析、金融交易和游戏。
- en: In addition to its speed and performance benefits, Eclipse Store offers a high
    degree of flexibility and scalability. It supports distributed data structures,
    allowing data to be distributed across multiple nodes and integrated with other
    databases or data sources.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其速度和性能优势外，Eclipse Store 还提供了高度的可灵活性和可扩展性。它支持分布式数据结构，允许数据跨多个节点分布，并与其他数据库或数据源集成。
- en: Overall, Eclipse Store provides a compelling alternative to traditional ORM-based
    databases, offering faster performance and reduced complexity for applications
    that require ultra-fast data processing.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，Eclipse Store 为传统基于 ORM 的数据库提供了一个有吸引力的替代方案，为需要超快数据处理的程序提供了更快的性能和更低的复杂性。
- en: '![Figure 8.2 – Architecture overview of Eclipse Store](img/Figure_8.02_B19375.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – Eclipse Store 架构概述](img/Figure_8.02_B19375.jpg)'
- en: Figure 8.2 – Architecture overview of Eclipse Store
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – Eclipse Store 架构概述
- en: 'Applications using Eclipse Store as the in-memory data storage solution can
    rely on the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Eclipse Store 作为内存数据存储解决方案的应用程序可以依赖以下功能：
- en: '**Fast performance**: Integrate fast and efficiently, relying on quick read
    and write operations without the extra overhead of an ORM tool.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速性能**：快速高效地集成，依赖于快速读写操作，无需 ORM 工具的额外开销。'
- en: '**In-memory storage**: Fast access to data, as it is obtained directly from
    the memory heap.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存存储**：快速访问数据，因为它直接从内存堆中获取。'
- en: '**Easy to use**: Developers can quickly get up to speed as the technology is
    designed to be simple and easy to use, with a familiar Java syntax and optional
    annotations that make it easy to define and persist data.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于使用**：由于该技术旨在简单易用，具有熟悉的 Java 语法和可选的注解，因此开发者可以快速上手，轻松定义和持久化数据。'
- en: '**No external dependencies**: Using it is pretty simple as the only dependency
    you’ll need is Eclipse Store (which basically depends on a logging library). You
    should have no concerns regarding library conflicts or compatibility issues.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无外部依赖**：使用它非常简单，因为您唯一需要的依赖项就是 Eclipse Store（它基本上依赖于一个日志库）。您不应担心库冲突或兼容性问题。'
- en: '**Lightweight**: A data storage solution that doesn’t require a lot of resources
    or configuration, and is easy to set up and deploy.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻量级**：一种不需要大量资源或配置的数据存储解决方案，易于设置和部署。'
- en: '**Flexibility**: Choose from all of the data types (with very few exceptions),
    and use it in various application sizes – from small-scale projects to enterprise-level
    systems.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：从所有数据类型（非常少数例外）中选择，并在各种应用规模中使用它——从小型项目到企业级系统。'
- en: '**Open source**: Eclipse Store is offered in multiple types, one of them being
    a free open source project, meaning unlimited usage and customization that can
    meet your specific needs.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开源**：Eclipse Store 提供多种类型，其中之一是免费开源项目，这意味着无限使用和定制，以满足您的特定需求。'
- en: '**High availability**: When used, it provides built-in high availability and
    redundancy features, ensuring your data is always available and protected.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高可用性**：使用时，它提供内置的高可用性和冗余功能，确保您的数据始终可用且受保护。'
- en: '**Scalability**: Easily add more nodes or resources to handle increasing data
    volumes, as the database is designed from scratch to meet such goals.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可伸缩性**：轻松添加更多节点或资源来处理不断增长的数据量，因为数据库是从零开始设计的，以满足这些目标。'
- en: In the following sections, we’ll drill down into this powerful and flexible
    solution for in-memory data management and persistence that can help developers
    build fast and efficient applications. Let’s learn about the basics of Eclipse
    Store, go through code examples, and understand how to create an ultra-fast application
    with a modern, cloud-native, in-memory, open source solution.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将深入探讨这个强大且灵活的内存数据管理和持久化解决方案，它可以帮助开发者构建快速高效的应用程序。让我们了解Eclipse Store的基本知识，通过代码示例，并理解如何使用现代、云原生、内存中、开源的解决方案创建一个超快的应用程序。
- en: In-memory persistence storage – Eclipse Store
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存持久化存储 – Eclipse Store
- en: Eclipse Store is a data storage solution that is fast due to the removal of
    the mapping process, the parse operation on queries, avoiding drawbacks of traditional
    query execution, and using a unique and advanced serialization process. Eclipse
    Store estimates that 90% of the query time is based on these operations.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse Store是一种数据存储解决方案，由于去除了映射过程、查询的解析操作，避免了传统查询执行的缺点，并使用独特且先进的序列化过程，因此运行速度快。Eclipse
    Store估计90%的查询时间基于这些操作。
- en: The benchmarks ([https://eclipsestore.io/](https://eclipsestore.io/)) show results
    that can be up to **1,000 times faster** than a SQL database with JPA. Positive
    aspects from a developer perspective are the short learning curve and the simplicity
    of installation and use.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试（[https://eclipsestore.io/](https://eclipsestore.io/)）显示的结果可以比使用JPA的SQL数据库快**1,000倍**。从开发者的角度来看，积极的一面是学习曲线短，安装和使用简单。
- en: To get started, the first step is to install Eclipse Store, which is as simple
    as adding a dependency to your application’s Maven configuration.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，第一步是安装Eclipse Store，这就像在应用程序的Maven配置中添加一个依赖项一样简单。
- en: Some key points of this solution include achieving lightning-fast in-memory
    data processing using pure Java, with the capability for microsecond query times,
    low-latency data access, and handling massive data workloads. This approach enables
    significant savings in CPU power, reduces CO2 emissions, and lowers costs within
    data centers.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 该解决方案的一些关键点包括使用纯Java实现闪电般的内存数据处理，具有微秒级查询时间、低延迟数据访问和处理海量数据负载的能力。这种方法可以实现显著的CPU功率节省，减少二氧化碳排放，并降低数据中心成本。
- en: 'Memory is volatile; therefore, in order to behave as a persistent storage,
    data must be stored somewhere else. Eclipse Store’s default storage target is
    the filesystem, in a local folder. That’s a good option to start with, but thinking
    of production needs, you’ll probably want to save your data in different locations.
    The good news is you can choose from over 15 different options: the storage targets
    ([https://docs.microstream.one/manual/storage/storage-targets/index.html](https://docs.microstream.one/manual/storage/storage-targets/index.html))
    range from relational databases to NoSQL databases, as well as blob services.
    Examples would be MariaDB, PostgreSQL, Redis, and Amazon S3.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 内存是易失的；因此，为了作为持久存储，数据必须存储在其他地方。Eclipse Store的默认存储目标是文件系统，在本地文件夹中。这是一个不错的起点，但考虑到生产需求，你可能希望将数据保存在不同的位置。好消息是你可以从超过15个不同的选项中进行选择：存储目标（[https://docs.microstream.one/manual/storage/storage-targets/index.html](https://docs.microstream.one/manual/storage/storage-targets/index.html)）从关系型数据库到NoSQL数据库，以及blob服务。例如，MariaDB、PostgreSQL、Redis和Amazon
    S3。
- en: Another possibility unlocked by using this technology that you may enjoy as
    well is that you can now create a custom graph structure as per your business
    needs and query with pure Java (no need to use SQL and similar!), decreasing the
    cognitive load for developers.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这项技术解锁的另一个可能性，你可能也会喜欢，那就是你现在可以按照业务需求创建自定义的图结构，并使用纯Java进行查询（无需使用SQL等！），这降低了开发者的认知负荷。
- en: You can use Eclipse Store with several runtime technologies, such as Helidon,
    Spring, and Quarkus. In this book, we explain how to use it relying only on CDI;
    in other words, you’ll learn how to use the technology independent of the vendor
    or platform it is going to be integrated with. Once we get up to speed on the
    basics using only the Java standard APIs, we should be able to start trying out
    different Jakarta EE and MicroProfile vendors, such as Helidon, Wildfly, and Payara.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Eclipse Store与多种运行时技术一起使用，例如Helidon、Spring和Quarkus。在这本书中，我们解释了如何仅依靠CDI来使用它；换句话说，您将学习如何在不考虑它将要集成的供应商或平台的情况下使用这项技术。一旦我们仅使用Java标准API掌握基础知识，我们就应该能够开始尝试不同的Jakarta
    EE和MicroProfile供应商，例如Helidon、Wildfly和Payara。
- en: In our context, CDI acts as the glue between our enterprise’s architectural
    components. Thus, it is the mechanism that enables you to inject Eclipse Store
    as a library, a component, a module, and so on. Let’s get started now with seeing
    how to persist and manage data using in-memory database storage and CDI.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的上下文中，CDI充当我们企业架构组件之间的粘合剂。因此，它是使您能够将Eclipse Store作为库、组件、模块等注入的机制。现在让我们开始了解如何使用内存数据库存储和CDI持久化和管理数据。
- en: The basics of how to store and manage data in memory
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储和管理内存中数据的基本方法
- en: 'To explain Eclipse Store further, let’s see it in action: we’ll create our
    first example with Java SE and CDI. The goal of this example is to demonstrate
    how to create a smooth CRUD process for a car, where each car should hold its
    model, make, and year as attributes.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步解释Eclipse Store，让我们看看它是如何工作的：我们将使用Java SE和CDI创建我们的第一个示例。这个示例的目标是展示如何为汽车创建一个平滑的CRUD流程，其中每辆汽车都应该将其型号、制造商和年份作为属性。
- en: 'First things first – create a simple Maven project using `maven-archetype-quickstart`.
    Installing Eclipse Store is simple; all you need is to add its dependencies to
    the Maven project. See an example of `pom.xml` as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用`maven-archetype-quickstart`创建一个简单的Maven项目。安装Eclipse Store很简单；您只需要将其依赖项添加到Maven项目中。以下是一个`pom.xml`的示例：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once the dependency is set, we can start coding. The following Java class,
    the `Car` entity, is our data model. As per Eclipse Store’s recommendation, the
    attributes should be defined as `final`, resulting in an immutable class:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项设置完成后，我们就可以开始编码了。以下Java类，`Car`实体，是我们的数据模型。根据Eclipse Store的建议，属性应该定义为`final`，从而产生一个不可变类：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The next step is to create the graph or structure to hold the data and provide
    it to us. To represent the collection of cars, we’ll create a `Garage` repository
    where all data manipulation should happen.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个图形或结构来存储数据并提供给我们。为了表示汽车集合，我们将创建一个`Garage`存储库，所有数据操作都应该在这里发生。
- en: You’re free to manipulate a car’s data or to create any other new data structure;
    you code it using pure Java and leave it to Eclipse Store to handle the rest.
    The only required component we must use is the identification of this `Garage`
    as a structure. To do so, annotate it with the `@``Storage` annotation.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以自由地操作汽车的数据或创建任何其他新的数据结构；您使用纯Java编写代码，并将其留给Eclipse Store来处理其余部分。我们唯一必须使用的组件是识别这个`Garage`作为一个结构。为此，使用`@Storage`注解对其进行注解。
- en: 'The `@Storage` annotation indicates the root object of the graph that will
    be handled by Eclipse Store. In this case, `Garage` is our root object:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Storage`注解表示将由Eclipse Store处理的图形的根对象。在这种情况下，`Garage`是我们的根对象：'
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This example covers all the required code and dependencies for us to be able
    to use `Garage` to add and find cars by model. And it only uses Java SE, no specific
    runtime!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例涵盖了所有必要的代码和依赖项，使我们能够使用`Garage`通过型号添加和查找汽车。而且它只使用Java SE，没有特定的运行时！
- en: Moving forward, we’ll cover the second sample focusing on the service layer,
    where we’ll implement the validation of the entity’s data before it is moved to
    storage. This validation is pretty straightforward; we’ll check whether `car`
    is `null`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍第二个示例，重点关注服务层，在那里我们将实现实体数据在移动到存储之前的验证。这种验证相当直接；我们将检查`car`是否为`null`。
- en: In order to manipulate the `cars` data, we’ll need an instance of `Garage` in
    our `CarService`. To use CDI to provide us with an instance of this class, we
    can use the `@Inject` annotation from CDI.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了操作`cars`数据，我们需要在`CarService`中有一个`Garage`的实例。为了使用CDI为我们提供这个类的实例，我们可以使用CDI的`@Inject`注解。
- en: 'When executing a database operation, we would probably want it to happen in
    a transaction, right? Yes, in the relational database maybe. Here, we rely on
    the `@Store` annotation to configure which methods should be allowed to change
    the data structure. Observe the `public` `void add` **(Car car)** method as follows
    and its annotation:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行数据库操作时，我们可能希望它在事务中发生，对吧？是的，在关系型数据库中可能如此。在这里，我们依赖于`@Store`注解来配置哪些方法应该允许更改数据结构。观察以下`public`
    `void add` **(Car car)** 方法及其注解：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Great, we have enough code at this point in order to test it out and have some
    fun, so let’s execute it! To consume our `CarService` APIs, we’ll need a new class,
    which we can call `App`, and a `public static void main(final String[] args)`
    method. In the first couple of lines of the code demonstrated next, notice the
    following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，到目前为止我们已经有足够的代码来测试它并享受乐趣了，所以让我们执行它！为了消费我们的`CarService` API，我们需要一个新的类，我们可以称之为`App`，以及一个`public
    static void main(final String[] args)`方法。在下面展示的代码的前几行中，请注意以下内容：
- en: The service API that retrieves the list of all the cars, `service.getCars()`
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取所有车辆列表的服务API，`service.getCars()`
- en: The search operation invoked by the service API, `service.findByModel("Corolla")`
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由服务API调用的搜索操作，`service.findByModel("Corolla")`
- en: 'When running the code for the first time, you’ll observe in the output logs
    that the retrieved cars list will be empty; however, when you run it twice, you
    can see the data:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当第一次运行代码时，你会在输出日志中观察到检索到的车辆列表将是空的；然而，当你再次运行它时，你可以看到数据：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you try running this code a couple of times, you may notice that around the
    third try, it looks like the items are getting duplicated! This is a behavior
    of our `list` object, which can be easily adjusted to solve this behavior. Update
    the structure to a `Set` instead of `List` and ensure that the `Car` entity has
    the equals and hashcode implemented adequately.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试运行此代码几次，你可能会注意到在第三次尝试左右，看起来项目正在重复！这是我们的`list`对象的行为，这可以通过将其结构更新为`Set`而不是`List`并确保`Car`实体适当地实现了equals和hashcode来解决。
- en: 'The application’s `properties` file holds the settings configuration for the
    *directory* and the *number of threads* used in the engine. The possibility to
    externalize this configuration is facilitated by to the integration with *Eclipse
    MicroProfile Configuration* ([https://download.eclipse.org/microprofile/microprofile-config-3.0/microprofile-config-spec-3.0.html](https://download.eclipse.org/microprofile/microprofile-config-3.0/microprofile-config-spec-3.0.html)).
    We saw a similar configuration approach in the previous chapter about JNoSQL,
    as it relies on the same underlying configuration mechanism:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的`properties`文件保存了引擎中使用的*目录*和*线程数*的设置配置。通过与*Eclipse MicroProfile Configuration*（[https://download.eclipse.org/microprofile/microprofile-config-3.0/microprofile-config-spec-3.0.html](https://download.eclipse.org/microprofile/microprofile-config-3.0/microprofile-config-spec-3.0.html)）的集成，可以简化外部化配置。我们在上一章关于JNoSQL的章节中看到了类似的配置方法，因为它依赖于相同的底层配置机制：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Pretty simple, right? Before we move forward, let’s understand the importance
    of the second setting listed previously, `one.Eclipse Store.channel.count`. This
    in-memory solution can be fine-tuned in multiple ways, one of them being adjusting
    the number of channels (threads) that the engine can use to execute I/O operations.
    This configuration should always be configured with a value equal to 2n.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，对吧？在我们继续前进之前，让我们了解之前列出的第二个设置的重要性，`one.Eclipse Store.channel.count`。这个内存解决方案可以通过多种方式微调，其中之一是调整引擎可以用来执行I/O操作的数量（线程）。这个配置应该始终配置为等于2n的值。
- en: Externalizing the configuration with specification-based approaches facilitates
    service maintenance. It should require very little effort when changing your application
    implementation, as you’ll notice in the upcoming section when we create a microservice
    based on this sample code. The reason for the simplified maintenance is that the
    chosen in-memory database storage, Eclipse Store, uses CDI, which happens to also
    be the core engine for both MicroProfile and Jakarta EE.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于规范的策略外部化配置简化了服务维护。在更改应用程序实现时，这应该需要非常少的努力，正如我们在创建基于此示例代码的微服务时将在下一节中看到的那样。简化维护的原因是所选的内存数据库存储，Eclipse
    Store，使用CDI，这恰好也是MicroProfile和Jakarta EE的核心引擎。
- en: After exploring how to configure and implement a service that relies on in-memory
    data storage, we will next see how to migrate the code sample as part of a microservice.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索如何配置和实现依赖于内存数据存储的服务之后，我们将接下来看到如何将代码示例作为微服务的一部分进行迁移。
- en: Using in-memory data storage with Jakarta EE and MicroProfile
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Jakarta EE 和 MicroProfile 的内存数据存储
- en: 'Thanks to the engines in the MicroProfile and Jakarta EE specifications, we
    can very easily choose which one best fits the application’s goal. In [*Chapter
    5*](B19375_05.xhtml#_idTextAnchor093), we discussed both specifications and why
    they are essential for the Java community:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了 MicroProfile 和 Jakarta EE 规范中的引擎，我们可以非常容易地选择最适合应用程序目标的一个。在 [*第 5 章*](B19375_05.xhtml#_idTextAnchor093)
    中，我们讨论了这两个规范以及为什么它们对 Java 社区至关重要：
- en: To get started, you can access the MicroProfile website ([https://start.microprofile.io/](https://start.microprofile.io/))
    and the starter project. It works just like the Spring initializer, for Spring-based
    applications.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始，您可以访问 MicroProfile 网站 ([https://start.microprofile.io/](https://start.microprofile.io/))
    和入门项目。它就像 Spring 初始化器一样，用于基于 Spring 的应用程序。
- en: Once on the page, confirm that MicroProfile version 3.3 is available, and choose
    one of the options. Make sure to check the **Config** checkbox in order to save
    some time and get some auto-generated basic files.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦进入页面，请确认 MicroProfile 版本 3.3 可用，并选择一个选项。确保勾选 **Config** 复选框以节省时间并获得一些自动生成的基本文件。
- en: For this example, we’ll use the **Helidon** runtime.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将使用 **Helidon** 运行时。
- en: '![Figure 8.3 – MicroProfile starter website](img/Figure_8.03_B19375.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3 – MicroProfile 入门网站](img/Figure_8.03_B19375.jpg)'
- en: Figure 8.3 – MicroProfile starter website
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – MicroProfile 入门网站
- en: 'Next, all we must do is add the Eclipse Store dependency to the `pom.xml` application,
    as the Eclipse MicroProfile implementation already provides both **config** and
    CDI:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们只需将 Eclipse Store 依赖项添加到 `pom.xml` 应用程序中，因为 Eclipse MicroProfile 实现已经提供了
    **config** 和 CDI：
- en: '[PRE6]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Next, use the ancient programmer technique… copy and paste! You can copy the
    dependency configurations from the previous project into your new MicroProfile-based
    project.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用古老的程序员技术…复制和粘贴！您可以将前一个项目的依赖项配置复制到您的新基于 MicroProfile 的项目中。
- en: Now, we need to be able to modify an entity, such as the `Car` entity. As the
    entity is immutable, creating new instances must be done through its constructor.
    The adoption of this good practice is not required by the data storage solution,
    Eclipse Store, but it is a good approach for using the entities in the REST endpoints.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要能够修改一个实体，例如 `Car` 实体。由于实体是不可变的，创建新实例必须通过其构造方法来完成。这种良好实践不是数据存储解决方案 Eclipse
    Store 所要求的，但它是用于 REST 端点的实体的一种好方法。
- en: In the `Car` class, identify and annotate its constructor method with `@JsonCreator`
    and `@JsonProperty`, which come from the JSON binding specifications ([https://jakarta.ee/specifications/jsonb/2.0/](https://jakarta.ee/specifications/jsonb/2.0/)).
    Notice that these are not annotations required by Eclipse Store.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Car` 类中，识别并使用来自 JSON 绑定规范的 `@JsonCreator` 和 `@JsonProperty` 注解来注释其构造方法，这些规范可以在
    [https://jakarta.ee/specifications/jsonb/2.0/](https://jakarta.ee/specifications/jsonb/2.0/)
    找到。请注意，这些不是 Eclipse Store 所要求的注解。
- en: 'Change the `Year` type to `Integer`, to avoid creating a custom interface to
    serialize and deserialize data:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Year` 类型更改为 `Integer`，以避免创建一个用于序列化和反序列化数据的自定义接口：
- en: '[PRE7]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We are building the `Car` entity as an immutable class; therefore, its fields
    are final and can be set by using injections on the constructor method. To help
    us achieve this goal, we’ll use a JSONB-compatible implementation.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将 `Car` 实体构建为一个不可变类；因此，其字段是最终的，并且可以通过构造方法上的注入来设置。为了帮助我们实现这个目标，我们将使用一个与 JSONB
    兼容的实现。
- en: Add the `@JsonbCreator` annotation, to turn this class into an eligible bean
    for the API, and so that the `@JsonProperty` annotation can link the respective
    parameter with the defined JSON property.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `@JsonbCreator` 注解，将这个类转换为 API 的合格 Bean，并且使得 `@JsonProperty` 注解可以将相应的参数与定义的
    JSON 属性链接起来。
- en: '*Note*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意*'
- en: We can delete CarBuilder once the creation process is through JSON.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦通过 JSON 完成创建过程，我们就可以删除 CarBuilder。
- en: 'We’ll create a resource where we’ll see the path and URL. We’ll expose all
    the services we made using the URL, so we’ll have to list the cars by finding
    a model and inserting a car:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个资源，我们将看到路径和 URL。我们将通过 URL 暴露我们创建的所有服务，因此我们需要通过查找型号并插入一辆车来列出汽车：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our resource class is ready to be used on our microservices. As you can see
    here, we’re injecting `CarService` and using this integration to connect with
    this `GarageResource`, which we can explore through HTTP requests.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的资源类已经准备好在我们的微服务中使用。正如你所看到的，我们正在注入`CarService`并使用这个集成来连接到这个`GarageResource`，我们可以通过HTTP请求来探索它。
- en: 'We have all the code ready; let’s build and execute the application:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了所有代码；让我们构建并执行应用程序：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When the service is up, we can explore it by creating a frontend that consumes
    this service or using an HTTP client UI. We’ll run our sample using `curl`. We’ll
    make three cars and then return them from the service:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务启动后，我们可以通过创建一个消耗此服务的客户端前端或使用HTTP客户端UI来探索它。我们将使用`curl`运行我们的示例。我们将创建三辆车，然后从服务中返回它们：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This was a sample HTTP request using the curl program; feel free to use any
    HTTP client that you wish, such as Postman.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用curl程序发出的示例HTTP请求；请随意使用你想要的任何HTTP客户端，例如Postman。
- en: We also need to append the Eclipse Store settings in this application. Another
    point is we updated the `ApplicationPath` annotation to `"/"`. Furthermore, we
    added the `Garage` resources, but we won’t put the full details here; please,
    check out the repository to get all the details.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将Eclipse Store设置附加到这个应用程序中。另一个要点是我们更新了`ApplicationPath`注解为`"/"`。此外，我们添加了`Garage`资源，但在这里不会提供全部细节；请查看仓库以获取所有详细信息。
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Eclipse Store brings a new persistence perspective; you can increase performance
    by reducing the mapper process. It impacts not only the application’s response
    time but also cloud costs since it requires fewer machines, and consequently reduces
    infrastructure cost.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse Store带来了新的持久化视角；你可以通过减少映射器进程来提高性能。它不仅影响应用程序的响应时间，还影响云成本，因为它需要更少的机器，从而降低了基础设施成本。
- en: This chapter looked at Java integration with CDI on Java SE and microservices
    using MicroProfile. We saw the power of several databases and persistence solutions,
    but how can we merge them? You’ll find out in the next chapter, about polyglot
    persistence.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了Java SE和微服务中CDI的集成，以及使用MicroProfile。我们看到了几个数据库和持久化解决方案的力量，但我们如何将它们合并？你将在下一章中找到答案，关于多语言持久化。
- en: 'Part 3: Architectural Perspective over Persistence'
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：持久化的架构视角
- en: In this section of the book, we take an architectural perspective on persistence,
    exploring various topics related to designing and implementing robust and scalable
    persistence solutions. This session delves into the architectural considerations
    and challenges associated with persistence in modern Java solutions, from polyglot
    persistence to modernization strategies.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，我们从架构的角度探讨了持久化，探讨了与设计和实现健壮和可扩展持久化解决方案相关的各种主题。本节深入探讨了与现代Java解决方案中持久化相关的架构考虑和挑战，从多语言持久化到现代化策略。
- en: 'This part has the following chapters:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分包含以下章节：
- en: '[*Chapter 9*](B19375_09.xhtml#_idTextAnchor165)*, Persistence Practices: Exploring
    Polyglot Persistence*'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B19375_09.xhtml#_idTextAnchor165)*，持久化实践：探索多语言持久化*'
- en: '[*Chapter 10*](B19375_10.xhtml#_idTextAnchor175)*, Architecting Distributed
    Systems: Challenges and Anti-Patterns*'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B19375_10.xhtml#_idTextAnchor175)*，构建分布式系统：挑战和反模式*'
- en: '[*Chapter 11*](B19375_11.xhtml#_idTextAnchor184)*, Modernization Strategies
    and Data Integration*'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B19375_11.xhtml#_idTextAnchor184)*，现代化策略和数据集成*'
- en: '[*Chapter 12*](B19375_12.xhtml#_idTextAnchor195)*, Final Considerations on
    Persistence in Modern Java Solutions*'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B19375_12.xhtml#_idTextAnchor195)*，现代Java解决方案中持久化的最终考虑*'
