- en: Chapter 4. Enterprise JavaBeans
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 企业JavaBeans
- en: 'Enterprise JavaBeans are server side components that encapsulate business logic
    of an application. Enterprise JavaBeans simplify application development by automatically
    managing transaction management and security. There are two types of Enterprise
    JavaBeans: Session beans, which execute business logic, and message-driven beans,
    which act as a message listener.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 企业JavaBeans是封装应用程序业务逻辑的服务端组件。企业JavaBeans通过自动管理事务管理和安全性来简化应用程序开发。企业JavaBeans有两种类型：执行业务逻辑的会话Bean，以及充当消息监听器的消息驱动Bean。
- en: Readers familiar with J2EE may notice that Entity Beans haven't been mentioned
    in the previous paragraph. In Java EE 5, Entity Beans were deprecated in favor
    of the **Java Persistence API** (**JPA**). Entity Beans are still supported for
    backwards compatibility, however, the preferred way of performing Object-relational
    mapping is through JPA.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉J2EE的读者可能会注意到，在前一段落中没有提到实体Bean。在Java EE 5中，实体Bean被废弃，取而代之的是**Java持久化API**（**JPA**）。尽管实体Bean仍然支持向后兼容，但执行对象关系映射的首选方式是通过JPA。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Session beans
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话Bean
- en: A simple session bean
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简单的会话Bean
- en: A more realistic example
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更现实的例子
- en: Using a session bean to implement the DAO design pattern
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用会话Bean实现DAO设计模式
- en: Singleton session beans
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例会话Bean
- en: Message-driven beans
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息驱动Bean
- en: Transactions in Enterprise JavaBeans
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业JavaBeans中的事务
- en: Container-managed transactions
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器管理的交易
- en: Bean-managed transactions
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bean管理的交易
- en: Enterprise JavaBeans life cycles
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业JavaBeans生命周期
- en: A stateful session bean life cycle
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态与会话Bean的生命周期
- en: A stateless session bean life cycle
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态会话Bean的生命周期
- en: Message-driven bean life cycle
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息驱动Bean的生命周期
- en: The EJB Timer Service
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: EJB定时器服务
- en: EJB Security
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: EJB安全性
- en: Introduction to session beans
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话Bean简介
- en: As we've previously mentioned, session beans typically encapsulate business
    logic. In Java EE, only one or two artifacts need to be created in order to create
    a session bean, namely, the bean itself and an optional business interface. These
    artifacts need to be decorated with the proper annotations to let the EJB container
    know they are session beans.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，会话Bean通常封装业务逻辑。在Java EE中，创建会话Bean只需要创建一个或两个工件，即Bean本身和可选的业务接口。这些工件需要用适当的注解装饰，以便让EJB容器知道它们是会话Bean。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: J2EE required application developers to create several artifacts in order to
    create a session bean. These artifacts included the bean itself, a local or remote
    interface (or both), a local home or a remote home interface (or both), and an
    XML deployment descriptor. As we shall see in this chapter, EJB development was
    greatly simplified in Java EE.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: J2EE要求应用程序开发者创建几个工件以创建会话Bean。这些工件包括Bean本身、本地或远程接口（或两者），本地Home或远程Home接口（或两者），以及XML部署描述符。正如我们将在本章中看到的，Java
    EE极大地简化了EJB开发。
- en: Developing a simple session bean
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发一个简单的会话Bean
- en: 'The following example illustrates a very simple session bean:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了一个非常简单的会话Bean：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `@Stateless` annotation lets the EJB container know that this class is
    a stateless session bean. There are three types of session beans: stateless, stateful,
    and singleton. Before we explain the difference between these types of session
    beans, we need to clarify how an instance of an EJB is provided to an EJB client
    application.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Stateless`注解让EJB容器知道这个类是一个无状态会话Bean。有三种类型的会话Bean：无状态、状态与会话和单例。在我们解释这些类型会话Bean之间的区别之前，我们需要明确EJB实例是如何提供给EJB客户端应用程序的。'
- en: When a stateless or stateful session bean is deployed, the EJB container creates
    a series of instances of each session bean. This is what is typically referred
    to as an EJB pool. When an EJB client application obtains an instance of EJB,
    the application server (GlassFish, in our case) provides one of the instances
    in the pool to the client application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当无状态或状态与会话Bean部署时，EJB容器为每个会话Bean创建一系列实例。这通常被称为EJB池。当EJB客户端应用程序获取EJB的一个实例时，应用程序服务器（在我们的例子中是GlassFish）将池中的一个实例提供给客户端应用程序。
- en: The difference between stateful and stateless session beans is that stateful
    session beans maintain a conversational state with the client, whereas stateless
    session beans do not. In simple terms, what this means is that when an EJB client
    application obtains an instance of a stateful session bean, we are guaranteed
    that the values of any instance variables in the bean will be consistent across
    method calls. It is safe to modify any instance variables on a stateful session
    bean, since they will retain their values for the next method call. The EJB container
    saves the conversational state by passivating stateful session beans, and retrieves
    that state when the bean is activated. Conversational state is the reason why
    the life cycle of stateful session beans is a bit more complex than that of stateless
    session beans and message driven beans (EJB life cycle is discussed later in this
    chapter).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有状态会话bean和无状态会话bean之间的区别在于，有状态会话bean与客户端保持会话状态，而无状态会话bean则不保持。简单来说，这意味着当一个EJB客户端应用程序获取一个有状态会话bean的实例时，我们可以保证bean中任何实例变量的值在方法调用之间是一致的。在有状态会话bean上修改任何实例变量都是安全的，因为它们将在下一次方法调用中保留其值。EJB容器通过钝化有状态会话bean来保存会话状态，并在bean被激活时检索该状态。会话状态是有状态会话bean的生命周期比无状态会话bean和消息驱动bean复杂一些的原因（EJB生命周期将在本章后面讨论）。
- en: The EJB container may provide any instance of EJB from the pool when an EJB
    client application requests an instance of a stateless session bean. Since we
    are not guaranteed the same instance for every method call, values set to any
    instance variables in a stateless session bean may be "lost" (they are not really
    lost; the modification is in another instance of the EJB in the pool).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当EJB客户端应用程序请求一个无状态会话bean的实例时，EJB容器可能会从池中提供任何EJB实例。由于我们不能保证每次方法调用都使用相同的实例，因此在无状态会话bean中设置的任何实例变量的值可能会“丢失”（它们实际上并没有丢失；修改发生在池中EJB的另一个实例中）。
- en: 'Other than being decorated with the `@Stateless` annotation, there is nothing
    special about the previous class. Notice that it implements an interface called
    `SimpleSession`. This interface is the bean''s business interface. The `SimpleSession`
    interface is shown in the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除了被`@Stateless`注解装饰之外，之前的类并没有什么特别之处。请注意，它实现了一个名为`SimpleSession`的接口。这个接口是bean的业务接口。`SimpleSession`接口在下面的代码中展示：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The only peculiar thing about this interface is that it is decorated with the
    `@Remote` annotation. This annotation indicates that this is a remote business
    interface. What this means is that the interface may be in a different JVM than
    the client application invoking it. Remote business interfaces may even be invoked
    across the network.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口唯一特殊的地方是它被`@Remote`注解装饰。这个注解表示这是一个远程业务接口。这意味着该接口可能位于调用它的客户端应用程序不同的JVM中。远程业务接口甚至可以在网络上被调用。
- en: Business interfaces may also be decorated with the `@Local` interface. This
    annotation indicates that the business interface is a local business interface.
    Local business interface implementations must be in the same JVM as the client
    application invoking its methods.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 业务接口也可以被`@Local`接口装饰。这个注解表示业务接口是一个本地业务接口。本地业务接口的实现必须与调用其方法的客户端应用程序在同一个JVM中。
- en: Since remote business interfaces can be invoked either from the same JVM or
    a different one than the client application, at first glance, we might be tempted
    to make all of our business interfaces remote. Before doing so, we must remind
    ourselves of the fact that the flexibility provided by remote business interfaces
    comes with a performance penalty, since method invocations are made under the
    assumption that they will be made across the network. As a matter of fact, most
    typical Java EE applications consist of web applications acting as client applications
    for EJBs; in such cases, the client application and the EJB are running on the
    same JVM, therefore local interfaces are used a lot more frequently than remote
    business interfaces.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于远程业务接口可以从与客户端应用程序相同的JVM或不同的JVM中调用，乍一看，我们可能会倾向于将所有业务接口都做成远程的。在这样做之前，我们必须提醒自己，远程业务接口提供的灵活性伴随着性能上的代价，因为方法调用是在假设它们将在网络上进行的情况下进行的。事实上，大多数典型的Java
    EE应用程序由充当EJB客户端应用程序的Web应用程序组成；在这种情况下，客户端应用程序和EJB运行在同一个JVM上，因此本地接口比远程业务接口使用得更多。
- en: Once we have compiled the session bean and its corresponding business interface,
    we need to place them in a JAR file and deploy them. Just like with WAR files,
    the easiest way to deploy an EJB JAR file is by copying it to `[glassfish installation
    directory]/glassfish/domains/domain1/autodeploy`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们编译了会话 Bean 及其对应的企业接口，我们需要将它们放入一个 JAR 文件中并部署它们。就像处理 WAR 文件一样，部署 EJB JAR 文件最简单的方法是将它复制到
    `[glassfish 安装目录]/glassfish/domains/domain1/autodeploy`。
- en: 'Now that we have seen the session bean and its corresponding business interface,
    let''s take a look at a client sample application:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看到了会话 Bean 及其对应的企业接口，让我们看一下一个客户端示例应用程序：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The previous code simply declares an instance variable of the type `net.ensode.SimpleSession`,
    which is the business interface for our session bean. The instance variable is
    decorated with the `@EJB` annotation. The `@EJB` annotation lets the EJB container
    know that this variable is a business interface for a session bean. The EJB container
    then injects an implementation of the business interface for the client code to
    use.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码只是声明了一个类型为 `net.ensode.SimpleSession` 的实例变量，这是我们的会话 Bean 的企业接口。这个实例变量被
    `@EJB` 注解所装饰。`@EJB` 注解让 EJB 容器知道这个变量是一个会话 Bean 的企业接口。然后 EJB 容器注入一个企业接口的实现供客户端代码使用。
- en: 'Since our client is a standalone application (as opposed to being a Java EE
    artifact, such as a WAR file or another EJB JAR file), in order for it to be able
    to access the code deployed in the server, it must be placed in a JAR file and
    executed through the appclient utility. The appclient utility is a GlassFish-specific
    tool that allows standalone Java applications to access resources deployed to
    the application server. This utility can be found at `[glassfish installation
    directory]/glassfish/bin/`. Assuming that this directory is in the `PATH` environment
    variable and that we''ve placed our client code in a JAR file called `simplesessionbeanclient.jar`,
    we will execute the previous client code by typing the following command in the
    command line:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的客户端是一个独立的应用程序（而不是像 WAR 文件或另一个 EJB JAR 文件这样的 Java EE 艺术品），为了使其能够访问服务器上部署的代码，它必须被放入一个
    JAR 文件中并通过 appclient 工具执行。appclient 工具是 GlassFish 特定的工具，允许独立 Java 应用程序访问部署到应用服务器的资源。这个工具可以在
    `[glassfish 安装目录]/glassfish/bin/` 找到。假设这个目录在 `PATH` 环境变量中，并且我们已经将我们的客户端代码放入了一个名为
    `simplesessionbeanclient.jar` 的 JAR 文件中，我们将在命令行中键入以下命令来执行前面的客户端代码：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Executing the previous command results in the following console output:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的命令会产生以下控制台输出：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That is the output of the `SessionBeanClient` class.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `SessionBeanClient` 类的输出。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are using Maven to build our code. For this example, we used the Maven Assembly
    plugin ([http://maven.apache.org/plugins/maven-assembly-plugin/](http://maven.apache.org/plugins/maven-assembly-plugin/))
    to build a client JAR file that includes all dependencies; this frees us from
    having to specify all the dependent JAR files in the `-classpath` command-line
    option of the `appclient` utility. To build this JAR file, simply invoke `mvn
    assembly:assembly` from the command line.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用 Maven 来构建我们的代码。在这个例子中，我们使用了 Maven Assembly 插件 ([http://maven.apache.org/plugins/maven-assembly-plugin/](http://maven.apache.org/plugins/maven-assembly-plugin/))
    来构建一个包含所有依赖项的客户端 JAR 文件；这使我们免去了在 `appclient` 工具的 `-classpath` 命令行选项中指定所有依赖 JAR
    文件的麻烦。要构建这个 JAR 文件，只需在命令行中调用 `mvn assembly:assembly` 即可。
- en: The first line of the output is simply the return value of the `getMessage()`
    method we implemented in the session bean. The second line of output displays
    the fully qualified class name of the class implementing the business interface.
    Notice that the class name is not the fully qualified name of the session bean
    we wrote; instead, what is actually provided is an implementation of the business
    interface created behind the scenes by the EJB container.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第一行仅仅是我们在会话 Bean 中实现的 `getMessage()` 方法的返回值。输出的第二行显示了实现企业接口的类的完全限定名称。请注意，类名不是我们所写的会话
    Bean 的完全限定名称；相反，实际上提供的是由 EJB 容器在幕后创建的企业接口的实现。
- en: A more realistic example
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个更实际的例子
- en: In the previous section, we saw a very simple, "Hello world" type of example.
    In this section, we will show a more realistic example. Session beans are frequently
    used as **Data Access Objects** (**DAOs**). Sometimes, they are used as wrappers
    for JDBC calls and other times, they are used to wrap calls to obtain or modify
    JPA entities. In this section, we will take the latter approach.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了一个非常简单、类似于“Hello world”的示例。在本节中，我们将展示一个更实际的示例。会话Bean通常用作**数据访问对象**（**DAO**）。有时，它们用作JDBC调用和其他调用（例如获取或修改JPA实体）的包装器。在本节中，我们将采用后一种方法。
- en: 'The following example illustrates how to implement the DAO design pattern in
    a session bean. Before looking at the bean implementation, let''s look at the
    business interface it corresponds to:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了如何在会话Bean中实现DAO设计模式。在查看Bean实现之前，让我们看看它对应的业务接口：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As we can see, the previous code is a remote interface implementing three methods:
    `the saveCustomer()` method saves customer data to the database, the `getCustomer()`
    method obtains data for a customer from the database, and the `deleteCustomer()`
    method deletes customer data from the database. Two of these methods take an instance
    of the `Customer` entity we developed in [Chapter 3](ch03.html "Chapter 3. Object
    Relational Mapping with JPA"), *Object Relational Mapping with JPA*, as their
    parameters. The third method, `getCustomer()`, takes a `Long` value representing
    the ID of the `Customer` object we wish to retrieve from the database.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，之前的代码是一个实现三个方法的远程接口：`the saveCustomer()`方法将客户数据保存到数据库中，`getCustomer()`方法从数据库中获取客户数据，而`deleteCustomer()`方法从数据库中删除客户数据。其中两个方法以我们在[第3章](ch03.html
    "第3章。使用JPA进行对象关系映射")中开发的`Customer`实体实例作为参数。第三个方法`getCustomer()`，它接受一个`Long`值，代表我们希望从数据库中检索的`Customer`对象的ID。
- en: 'Let''s now take a look at the session bean implementing the previous business
    interface. As we are about to see in the following code, there are some differences
    between the way the JPA code is implemented in a session bean and the way it is
    implemented in a plain old Java object:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看实现先前业务接口的会话Bean。正如我们将在下面的代码中看到的，在会话Bean中实现JPA代码的方式和在普通Java对象中实现的方式之间有一些区别：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The main difference between our session bean and previous JPA examples is that
    JPA calls were wrapped between calls to `UserTransaction.begin()` and `UserTransaction.commit()`.
    The reason we had to do this is because JPA calls are required to be wrapped in
    a transaction; if they are not wrapped in a transaction, most JPA calls will throw
    `TransactionRequiredException`. In this case we don't have to explicitly wrap
    JPA calls in a transaction as in previous examples, since session bean methods
    are implicitly transactional; there is nothing we need to do to make them that
    way. This default behavior is what is known as **Container-Managed Transactions**.
    Container-managed transactions are discussed in detail later in this chapter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会话Bean与之前的JPA示例之间的主要区别在于，JPA调用被包裹在`UserTransaction.begin()`和`UserTransaction.commit()`调用之间。我们必须这样做的原因是JPA调用需要被包裹在事务中；如果它们没有被包裹在事务中，大多数JPA调用将抛出`TransactionRequiredException`。在这种情况下，我们不需要像之前示例中那样显式地包裹JPA调用在事务中，因为会话Bean方法隐式地是事务性的；我们不需要做任何事情来使它们成为那样。这种默认行为被称为**容器管理事务**。容器管理事务将在本章后面详细讨论。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As mentioned in [Chapter 3](ch03.html "Chapter 3. Object Relational Mapping
    with JPA"), *Object Relational Mapping with JPA*, when a JPA entity is retrieved
    from one transaction and updated to a different transaction, the `EntityManager.merge()`
    method needs to be invoked to update the data in the database. Invoking `EntityManager.persist()`
    in this case will result in a `Cannot persist detached object` exception.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第3章](ch03.html "第3章。使用JPA进行对象关系映射")中所述，*使用JPA进行对象关系映射*，当从一笔交易中检索JPA实体并将其更新到另一笔交易时，需要调用`EntityManager.merge()`方法来更新数据库中的数据。在这种情况下调用`EntityManager.persist()`将导致`Cannot
    persist detached object`异常。
- en: Invoking session beans from web applications
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从Web应用程序调用会话Bean
- en: Frequently, Java EE applications consist of web applications acting as clients
    for EJBs. Before Java EE 6, the most common way of deploying a Java EE application
    that consists of both a web application and one or more session beans was by packaging
    both the WAR file for the web application and the EJB JAR files into an EAR (Enterprise
    Archive) file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Java EE应用程序由充当EJB客户端的Web应用程序组成。在Java EE 6之前，部署由Web应用程序和一个或多个会话Bean组成的Java
    EE应用程序的最常见方式是将Web应用程序的WAR文件和EJB JAR文件打包成一个EAR（企业存档）文件。
- en: Java EE 6 simplified the packaging and deployment of applications consisting
    of both EJB's and web components.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 6 简化了由EJB和Web组件组成的应用程序的打包和部署。
- en: In this section, we will develop a JSF application with a CDI named bean acting
    as a client to the DAO session bean we just discussed in the previous section.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发一个JSF应用程序，其中包含一个CDI命名的Bean作为我们之前章节中讨论的DAO会话Bean的客户端。
- en: 'In order to make this application act as an EJB client, we will develop a `CustomerController`
    named bean so that it delegates the logic to save a new customer to the database
    to the `CustomerDaoBean` session bean we developed in the previous section. We
    will develop a `CustomerController` named bean, as shown in the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个应用程序充当EJB客户端，我们将开发一个名为`CustomerController`的Bean，以便将保存新客户到数据库的逻辑委托给我们在上一节中开发的`CustomerDaoBean`会话Bean。我们将开发一个名为`CustomerController`的Bean，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we can see, all we had to do was declare an instance of the `CustomerDaoBean`
    session bean and decorate it with the `@EJB` annotation so that an instance of
    the corresponding EJB is injected, and then invoke the EJB `saveCustomer()` method.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们只需声明一个`CustomerDaoBean`会话Bean的实例，并用`@EJB`注解装饰它，以便注入相应的EJB实例，然后调用EJB的`saveCustomer()`方法。
- en: Notice that we injected an instance of the session bean directly into our client
    code. The reason we can do this is because of a feature introduced in Java EE
    6\. When using Java EE 6 or newer, we can do away with local interfaces and use
    session bean instances directly in our client code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们直接将会话Bean的实例注入到我们的客户端代码中。我们可以这样做的原因是Java EE 6引入的一个特性。当使用Java EE 6或更高版本时，我们可以去掉本地接口，并在客户端代码中直接使用会话Bean实例。
- en: Now that we have modified our web application to be a client for our session
    bean, we need to package it in a WAR (web archive) file and deploy it in order
    to use it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经修改了我们的Web应用程序以作为我们的会话Bean的客户端，我们需要将其打包成WAR（Web存档）文件并部署以使用它。
- en: Introduction to singleton session beans
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单例会话Bean简介
- en: A new type of session bean that was introduced in Java EE 6 is the singleton
    session bean. A single instance of each singleton session bean exists per application.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 6 中引入的一种新型会话Bean是单例会话Bean。每个单例会话Bean在应用程序中只存在一个实例。
- en: 'Singleton session beans are useful to cache database data. Caching frequently
    used data in a singleton session bean increases performance, since it greatly
    minimizes trips to the database. The common pattern is to have a method in our
    bean decorated with the `@PostConstruct` annotation; in this method, we retrieve
    the data we want to cache. Then we provide a setter method for the bean''s clients
    to call. The following example illustrates this technique:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 单例会话Bean对于缓存数据库数据很有用。在单例会话Bean中缓存常用数据可以提高性能，因为它大大减少了访问数据库的次数。常见的模式是在我们的Bean中有一个用`@PostConstruct`注解装饰的方法；在这个方法中，我们检索我们想要缓存的数据。然后我们提供一个setter方法供Bean的客户端调用。以下示例说明了这种技术：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Since our bean is a singleton, all of its clients would access the same instance,
    avoiding multiple queries to the database. Additionally, since it is a singleton,
    it is safe to specify an instance variable, as all clients access the same instance
    of the bean.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的Bean是单例的，所以所有客户端都会访问同一个实例，避免了多次查询数据库。此外，由于它是单例的，可以安全地指定实例变量，因为所有客户端都访问同一个Bean的实例。
- en: Asynchronous method calls
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步方法调用
- en: Sometimes it is useful to do some processing asynchronously, that is, invoke
    a method call and return control to the client immediately, without making the
    client wait for the method to finish.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有时进行一些异步处理是有用的，也就是说，调用一个方法调用并立即将控制权返回给客户端，而无需让客户端等待方法完成。
- en: In earlier versions of Java EE, the only way to invoke EJB methods asynchronously
    was using message-driven beans (which is discussed in the next section). Although
    message-driven beans are fairly easy to write, they do require some configuration
    before they can be used, such as setting up JMS message queues or topics.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java EE的早期版本中，调用EJB方法异步的唯一方法是使用消息驱动豆（将在下一节中讨论）。尽管消息驱动豆编写起来相对简单，但它们在使用之前确实需要一些配置，例如设置JMS消息队列或主题。
- en: EJB 3.1 introduced the `@Asynchronous` annotation, which can be used to mark
    a method in a session bean as asynchronous. When an EJB client invokes an asynchronous
    method, control immediately goes back to the client, without waiting for the method
    to finish.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: EJB 3.1引入了`@Asynchronous`注解，它可以用来标记会话豆中的方法为异步。当EJB客户端调用异步方法时，控制权立即返回客户端，无需等待方法完成。
- en: 'Asynchronous methods can only return void or an implementation of the `java.util.concurrent.Future`
    interface. The `Future` interface was introduced in Java 5 and represents the
    result of an asynchronous computation. The following example illustrates both
    scenarios:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 异步方法只能返回void或`java.util.concurrent.Future`接口的实现。`Future`接口是在Java 5中引入的，表示异步计算的最终结果。以下示例说明了这两种情况：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When our asynchronous method returns void, the only thing we need to do is decorate
    the method with the `@Asynchronous` annotation, then call it as usual from the
    client code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的异步方法返回void时，我们只需要用`@Asynchronous`注解装饰方法，然后像往常一样从客户端代码中调用它。
- en: If we need a return value, this value needs to be wrapped in an implementation
    of the `jav.util.concurrent.Future` interface. The Java EE API provides a convenience
    implementation in the form of the `javax.ejb.AsyncResult` class. Both the `Future`
    interface and the `AsyncResult` class use generics, so we need to specify our
    return type as the type parameter of these artifacts.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要返回值，则此值需要包装在`jav.util.concurrent.Future`接口的实现中。Java EE API以`javax.ejb.AsyncResult`类的形式提供了一个便利的实现。`Future`接口和`AsyncResult`类都使用泛型，因此我们需要指定我们的返回类型作为这些实体的类型参数。
- en: 'The `Future` interface has several methods we can use to cancel the execution
    of an asynchronous method, check to see whether or not the method is finished,
    get the return value of the method, and check to see whether or not the method
    is canceled. The following table lists these methods:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Future`接口有几种我们可以用来取消异步方法执行、检查方法是否完成、获取方法的返回值以及检查方法是否被取消的方法。以下表格列出了这些方法：'
- en: '| Method | Description |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `cancel(boolean mayInterruptIfRunning)` | This method cancels method execution.
    If the boolean parameter is `true`, this method will attempt to cancel the method
    execution even if it is already running. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `cancel(boolean mayInterruptIfRunning)` | 此方法将取消方法执行。如果布尔参数为`true`，则此方法将尝试取消方法执行，即使它已经在运行。
    |'
- en: '| `get()` | This method will return the "unwrapped" return value of the method;
    it will be of the type parameter of the `Future` interface implementation returned
    by the method. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `get()` | 此方法将返回方法的“未包装”返回值；它将是方法返回的`Future`接口实现类型参数。 |'
- en: '| `get(long timeout, TimeUnit unit)` | This method will attempt to get the
    `unwrapped` return value of the method; the return value will be of the type parameter
    of the `Future` interface implementation returned by the method. This method will
    block for the amount of time specified by the first parameter. The unit of time
    to wait is determined by the second parameter, the `TimeUnit` enum has constants
    for NANOSECONDS, MILLISECONDS, SECONDS, MINUTES, and so on. Refer to its Javadoc
    documentation for the complete list. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `get(long timeout, TimeUnit unit)` | 此方法将尝试获取方法的`未包装`返回值；返回值将是方法返回的`Future`接口实现类型参数。此方法将阻塞指定的时间参数。等待时间的单位由第二个参数确定，`TimeUnit`枚举具有NANOSECONDS、MILLISECONDS、SECONDS、MINUTES等常量。有关完整列表，请参阅其Javadoc文档。
    |'
- en: '| `isCancelled()` | This method returns `true` if the method has been cancelled;
    otherwise, it returns `false`. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `isCancelled()` | 如果方法已被取消，则此方法返回`true`；否则返回`false`。 |'
- en: '| `isDone()` | This method returns `true` if the method has finished executing;
    otherwise, it returns `false`. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `isDone()` | 如果方法已执行完成，则此方法返回`true`；否则返回`false`。 |'
- en: As we can see, the `@Asynchronous` annotation makes it very easy to make asynchronous
    calls without suffering the overhead of having to set up message queues or topics.
    It is certainly a welcome addition to the EJB specification.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`@Asynchronous` 注解使得在不设置消息队列或主题的开销下进行异步调用变得非常容易。这无疑是 EJB 规范中的一个受欢迎的补充。
- en: Message-driven beans
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息驱动 Bean
- en: The **Java Message Service** (**JMS**) is a Java EE API used for asynchronous
    communication between different applications. JMS messages are stored in either
    message queues or message topics.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java 消息服务**（**JMS**）是一个用于不同应用程序之间异步通信的 Java EE API。JMS 消息存储在消息队列或消息主题中。'
- en: 'The purpose of a message-driven bean is to consume messages from a JMS queue
    or a JMS topic, depending on the messaging domain used (refer to [Chapter 8](ch08.html
    "Chapter 8. The Java Message Service"), *The Java Message Service*). A message-driven
    bean must be decorated with the `@MessageDriven` annotation. The `mappedName`
    attribute of this annotation must contain the JNDI name of the JMS message queue
    or JMS message topic that the bean will be consuming messages from. The following
    example illustrates a simple message driven bean:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 消息驱动 Bean 的目的是从 JMS 队列或 JMS 主题（根据所使用的消息域）消费消息（参见第 8 章，*Java 消息服务*）。消息驱动 Bean
    必须使用 `@MessageDriven` 注解进行装饰。此注解的 `mappedName` 属性必须包含 Bean 将从中消费消息的 JNDI 名称的 JMS
    消息队列或 JMS 消息主题。以下示例演示了一个简单的消息驱动 Bean：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It is recommended, but not required, for message-driven beans to implement the
    `javax.jms.MessageListener` interface. However, message-driven beans must have
    a method called `onMessage()` whose signature is identical to that in the previous
    example.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 建议消息驱动 Bean 实现 `javax.jms.MessageListener` 接口，但这不是必需的。然而，消息驱动 Bean 必须有一个名为 `onMessage()`
    的方法，其签名与前面的示例相同。
- en: Client applications never invoke a message-driven bean's methods directly. Instead,
    they put messages in a message queue or topic, then the bean consumes those messages
    and acts appropriately. The previous example simply prints the message to standard
    output, since message-driven beans execute within an EJB container; standard output
    gets redirected to a log. To see the messages in the GlassFish's server log, open
    the `[GlassFish installation directory]/glassfish/domains/domain1/logs/server.log`
    file.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应用程序永远不会直接调用消息驱动 Bean 的方法。相反，它们将消息放入消息队列或主题，然后 Bean 消费这些消息并相应地执行。前面的示例只是将消息打印到标准输出，因为消息驱动
    Bean 在 EJB 容器中执行；标准输出被重定向到日志。要查看 GlassFish 服务器日志中的消息，请打开 `[GlassFish 安装目录]/glassfish/domains/domain1/logs/server.log`
    文件。
- en: Transactions in Enterprise JavaBeans
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 企业 JavaBean 中的事务
- en: As we mentioned earlier in this chapter, by default, all EJB methods are automatically
    wrapped in a transaction. This default behavior is known as **Container-managed
    transactions**, since transactions are managed by the EJB container. Application
    developers may also choose to manage transactions themselves; this can be accomplished
    using bean-managed transactions. Both of these approaches are discussed in the
    following sections.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们本章前面提到的，默认情况下，所有 EJB 方法都会自动被事务包装。这种默认行为被称为**容器管理事务**，因为事务是由 EJB 容器管理的。应用程序开发者也可以选择自己管理事务；这可以通过使用
    Bean 管理事务来实现。这两种方法将在以下章节中讨论。
- en: Container-managed transactions
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器管理事务
- en: Because EJB methods are transactional by default, we run into an interesting
    dilemma when an EJB method is invoked from client code that is already in a transaction.
    How should the EJB container behave? Should it suspend the client transaction,
    execute its method in a new transaction, then resume the client transaction? Should
    it not create a new transaction and execute its method as part of the client transaction?
    Should it throw an exception?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 EJB 方法默认是事务性的，当从已经处于事务中的客户端代码调用 EJB 方法时，我们会遇到一个有趣的困境。EJB 容器应该如何表现？它应该挂起客户端事务，在一个新的事务中执行其方法，然后恢复客户端事务？或者它不应该创建新的事务，而是将方法作为客户端事务的一部分执行？或者它应该抛出异常？
- en: By default, if an EJB method is invoked by a client code that is already in
    a transaction, the EJB container will simply execute the session bean method as
    part of the client transaction. If this is not the behavior we need, we can change
    it by decorating the method with the `@TransactionAttribute` annotation. This
    annotation has a `value` attribute that determines how the EJB container will
    behave when the session bean method is invoked within an existing transaction
    and also when it is invoked outside any transactions. The value of the `value`
    attribute is typically a constant defined in the `javax.ejb.TransactionAttributeType`
    enum.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果EJB方法被已经在事务中的客户端代码调用，EJB容器将简单地执行会话bean方法作为客户端事务的一部分。如果这不是我们需要的操作，我们可以通过使用`@TransactionAttribute`注解来改变它。这个注解有一个`value`属性，它决定了当会话bean方法在现有事务中调用以及在外部任何事务中调用时，EJB容器将如何行为。`value`属性的值通常是定义在`javax.ejb.TransactionAttributeType`枚举中的常量。
- en: 'The following table lists the possible values for the `@TransactionAttribute`
    annotation:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了`@TransactionAttribute`注解的可能值：
- en: '| @TransactionAttribute value | Description |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| @TransactionAttribute value | 描述 |'
- en: '| --- | --- |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `TransactionAttributeType.MANDATORY` | Forces the method to be invoked as
    part of a client transaction. If this method is called outside any transactions,
    it will throw a `TransactionRequiredException` exceptiom |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `TransactionAttributeType.MANDATORY` | 强制方法作为客户端事务的一部分被调用。如果这个方法在任何事务之外被调用，它将抛出`TransactionRequiredException`异常
    |'
- en: '| `TransactionAttributeType.NEVER` | The method is never executed in a transaction.
    If it is invoked as part of a client transaction, it will throw a `RemoteException`
    exception No transaction is created if the method is not invoked within a client
    transaction. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `TransactionAttributeType.NEVER` | 该方法永远不会在事务中执行。如果它作为客户端事务的一部分被调用，将抛出`RemoteException`异常。如果没有在客户端事务中调用该方法，则不会创建任何事务。
    |'
- en: '| `TransactionAttributeType.NOT_SUPPORTED` | The method is invoked as part
    of a client transaction, the client transaction is suspended and the method is
    executed outside any transaction. After the method is executed, the client transaction
    is resumed. No transaction is created if the method is not invoked within the
    client transaction. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `TransactionAttributeType.NOT_SUPPORTED` | 该方法作为客户端事务的一部分被调用，客户端事务被挂起，方法在任意事务之外执行。方法执行完毕后，客户端事务将恢复。如果没有在客户端事务中调用该方法，则不会创建任何事务。
    |'
- en: '| `TransactionAttributeType.REQUIRED` | The method is invoked as part of a
    client transaction, it is executed as part of that transaction. If the method
    is invoked outside a transaction, a new transaction is created for the method.
    This is the default behavior. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `TransactionAttributeType.REQUIRED` | 该方法作为客户端事务的一部分被调用，它作为该事务的一部分执行。如果方法在事务外部被调用，将为该方法创建一个新的事务。这是默认行为。
    |'
- en: '| `TransactionAttributeType.REQUIRES_NEW` | The method is invoked as part of
    a client transaction, that transaction is suspended, and a new transaction is
    created for the method. Once the method executes, the client transaction is resumed.
    If the method is called outside a transaction, a new transaction is created for
    the method. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `TransactionAttributeType.REQUIRES_NEW` | 该方法作为客户端事务的一部分被调用，该事务被挂起，并为该方法创建一个新的事务。一旦方法执行完毕，客户端事务将恢复。如果方法在事务外部被调用，将为该方法创建一个新的事务。
    |'
- en: '| `TransactionAttributeType.SUPPORTS` | The method is invoked as part of a
    client transaction, it is executed as part of that transaction. If the method
    is invoked outside a transaction, no new transaction is created for the method.
    |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `TransactionAttributeType.SUPPORTS` | 该方法作为客户端事务的一部分被调用，它作为该事务的一部分执行。如果方法在事务外部被调用，不会为该方法创建新的事务。
    |'
- en: 'Although the default transaction attribute is reasonable in most cases, it
    is good to be able to override this default if necessary. For example, transactions
    have a performance impact. Therefore, being able to turn off transactions for
    a method that does not need them is beneficial. For a case like this, we would
    decorate our method, as illustrated in the following code snippet:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在大多数情况下默认事务属性是合理的，但如果需要，能够覆盖这个默认设置是很好的。例如，事务会有性能影响。因此，能够关闭不需要事务的方法的事务是有益的。对于这种情况，我们可以在以下代码片段中看到，我们会对方法进行装饰：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Other transaction attribute types can be declared by annotating the methods
    with the corresponding constant in the `TransactionAttributeType` enum.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在`TransactionAttributeType`枚举中用相应的常量注解方法来声明其他事务属性类型。
- en: If we wish to override the default transaction attribute consistently across
    all methods in a session bean, we can decorate the session bean class with the
    `@TransactionAttribute` annotation; the value of its `value` attribute will be
    applied to every method in the session bean.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望一致地覆盖会话 Bean 中所有方法的默认交易属性，我们可以用 `@TransactionAttribute` 注解装饰会话 Bean 类；其
    `value` 属性的值将应用于会话 Bean 中的每个方法。
- en: 'Container-managed transactions are automatically rolled back whenever an exception
    is thrown within an EJB method. Additionally, we can programmatically roll back
    a container-managed transaction by invoking the `setRollbackOnly()` method on
    an instance of `javax.ejb.EJBContext` corresponding to the session bean in question.
    The following example is a new version of the session bean we saw earlier in this
    chapter, modified to roll back transactions if necessary:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 容器管理的交易在 EJB 方法中抛出异常时将自动回滚。此外，我们可以通过在对应于要讨论的会话 Bean 的 `javax.ejb.EJBContext`
    实例上调用 `setRollbackOnly()` 方法来程序化地回滚容器管理的交易。以下是一个示例，展示了我们在本章前面看到的会话 Bean 的新版本，修改后可以在必要时回滚交易：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this version of the DAO session bean, we deleted the `saveCustomer()` method
    and made the `saveNewCustomer()` and `updateCustomer()` methods public. Each of
    these methods now checks to see whether or not the `customerId` field is set correctly
    for the operation we are trying to perform (`null` for inserts and not `null`
    for updates). It also checks to make sure the object to be persisted is not `null`.
    If any of the checks result in invalid data, the method simply rolls back the
    transaction by invoking the `setRollBackOnly()` method on the injected instance
    of `EJBContext` and does not update the database.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 DAO 会话 Bean 的版本中，我们删除了 `saveCustomer()` 方法，并将 `saveNewCustomer()` 和 `updateCustomer()`
    方法设置为公共。现在，这些方法中的每一个都会检查我们试图执行的操作的 `customerId` 字段是否设置正确（对于插入为 `null`，对于更新则不为
    `null`）。它还会检查要持久化的对象是否不为 `null`。如果任何检查导致无效数据，方法将简单地通过在注入的 `EJBContext` 实例上调用 `setRollBackOnly()`
    方法来回滚交易，并且不会更新数据库。
- en: Bean-managed transactions
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bean 管理的交易
- en: 'As we have seen, container-managed transactions make it ridiculously easy to
    write code that is wrapped in a transaction. After all, there is nothing special
    that we need to do to make them that way; as a matter of fact, some developers
    are sometimes not even aware that they are writing code that will be transactional
    in nature when they develop session beans. Container-managed transactions cover
    most of the typical cases that we will encounter. However, they do have a limitation:
    each method can be wrapped in at most a single transaction. With container-managed
    transactions, it is not possible to implement a method that generates more than
    one transaction, this can be accomplished using bean-managed transactions, as
    shown in the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，容器管理的交易使得编写包含在交易中的代码变得极其容易。毕竟，我们不需要做任何特别的事情来使它们变得这样；事实上，一些开发者在开发会话 Bean
    时有时甚至没有意识到他们正在编写将具有交易性质的代码。容器管理的交易涵盖了我们将遇到的典型情况的大部分。然而，它们确实有一个限制：每个方法最多只能包含一个交易。使用容器管理的交易，无法实现生成多个交易的交易，这可以通过如以下代码所示的
    Bean 管理的交易来完成：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, we implemented a method named `saveMultipleNewCustomers()`.
    This method takes a `List` of customers as its sole parameter. The intention of
    this method is to save as many elements in `ArrayList` as possible. An exception
    saving one of the entities should not stop the method from attempting to save
    the remaining elements. This behavior is not possible using container-managed
    transactions, since if an exception is thrown when saving one of the entities
    it would roll back the whole transaction. The only way to achieve this behavior
    is through bean-managed transactions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们实现了一个名为 `saveMultipleNewCustomers()` 的方法。此方法仅接受一个客户 `List` 作为其唯一参数。此方法的目的是在
    `ArrayList` 中尽可能多地保存元素。保存实体时发生异常不应阻止方法尝试保存剩余元素。使用容器管理的交易无法实现此行为，因为如果在保存实体时抛出异常，则整个交易将回滚。实现此行为的唯一方法是使用
    Bean 管理的交易。
- en: As shown in the previous example, we declare that the session bean uses bean-managed
    transactions by decorating the class with the `@TransactionManagement` annotation,
    and using `TransactionManagementType.BEAN` as the value for its `value` attribute
    (the only other valid value for this attribute is `TransactionManagementType.CONTAINER`,
    but since this is the default value, it is not necessary to specify it).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，我们通过在类上添加`@TransactionManagement`注解，并使用`TransactionManagementType.BEAN`作为其`value`属性的值（此属性的另一个有效值是`TransactionManagementType.CONTAINER`，但由于这是默认值，因此没有必要指定它）来声明会话Bean使用Bean管理的交易。
- en: To be able to programmatically control transactions, we inject an instance of
    `javax.transaction.UserTransaction`, which is then used in the `for` loop within
    the `saveMultipleNewCustomers()` method to begin and commit transactions in each
    iteration of the loop.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够以编程方式控制事务，我们注入一个`javax.transaction.UserTransaction`的实例，然后在`saveMultipleNewCustomers()`方法内的`for`循环中使用它来开始和提交每个循环迭代的交易。
- en: If we need to roll back a bean-managed transaction, we can do so by simply calling
    the `rollback()` method on the appropriate instance of `javax.transaction.UserTransaction`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要回滚一个Bean管理的交易，我们可以通过在适当的`javax.transaction.UserTransaction`实例上调用`rollback()`方法来实现。
- en: Before moving on, it is worth noting that even though all the examples in this
    section were implemented as session beans, the concepts apply to message-driven
    beans as well.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，值得注意的是，尽管本节中的所有示例都实现为会话Bean，但这些概念同样适用于消息驱动Bean。
- en: Enterprise JavaBean life cycles
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 企业JavaBean生命周期
- en: Enterprise JavaBeans go through different states in their life cycle. Each type
    of EJB has different states. States specific to each type of EJB are discussed
    in the next sections.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 企业JavaBean在其生命周期中会经历不同的状态。每种类型的EJB都有不同的状态。每种类型EJB的特定状态将在下一节中讨论。
- en: The stateful session bean life cycle
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有状态会话Bean的生命周期
- en: 'Readers with experience in previous versions of J2EE may remember that in previous
    versions of the specification, session beans were required to implement the `javax.ejb.SessionBean`
    interface. This interface provided methods to be executed at certain points in
    the session bean''s life cycle. Methods provided by the `SessionBean` interface
    include:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉J2EE先前版本的读者来说，可能会记得在先前版本的规范中，会话Bean必须实现`javax.ejb.SessionBean`接口。此接口提供了在会话Bean生命周期中特定点执行的方法。由`SessionBean`接口提供的方法包括：
- en: '`ejbActivate()`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ejbActivate()`'
- en: '`ejbPassivate()`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ejbPassivate()`'
- en: '`ejbRemove()`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ejbRemove()`'
- en: '`setSessionContext(SessionContext ctx)`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setSessionContext(SessionContext ctx)`'
- en: The first three methods were meant to be executed at certain points in the bean's
    life cycle. In most cases, there was nothing to do in the implementation of these
    methods. This fact resulted in the vast majority of session beans implementing
    empty versions of these methods. Thankfully, starting with Java EE 5, it is no
    longer necessary to implement the `SessionBean` interface, however, if necessary,
    we can still write methods that will get executed at certain points in the bean's
    life cycle. We can achieve this by decorating methods with specific annotations.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个方法旨在在Bean的生命周期中的特定点执行。在大多数情况下，这些方法的实现中没有什么可做的。这一事实导致了绝大多数会话Bean实现了这些方法的空版本。幸运的是，从Java
    EE 5开始，不再需要实现`SessionBean`接口，然而，如果需要，我们仍然可以编写将在Bean生命周期中的特定点执行的方法。我们可以通过使用特定的注解来装饰方法来实现这一点。
- en: Before explaining the annotations available to implement life cycle methods,
    a brief explanation of the session bean life cycle is in order. The life cycle
    of a stateful session bean is different from that of a stateless session bean.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释可用于实现生命周期方法的可用的注解之前，有必要简要说明会话Bean的生命周期。有状态会话Bean的生命周期与无状态会话Bean的生命周期不同。
- en: 'A stateful session bean''s life cycle contains three states: **Does Not Exist**,
    **Ready**, and **Passive**, as shown in the following diagram:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有状态会话Bean的生命周期包含三个状态：**不存在**、**就绪**和**被动**，如下所示：
- en: '![The stateful session bean life cycle](img/6886_04_01.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![有状态会话Bean的生命周期](img/6886_04_01.jpg)'
- en: Before a stateful session bean is deployed, it is in the Does Not Exist state.
    Upon successful deployment, the EJB container does any required dependency injections
    for the bean and the bean goes into the Ready state. At this point, the bean is
    ready to have its methods called by a client application.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在有状态会话bean部署之前，它处于不存在状态。部署成功后，EJB容器为bean执行任何必需的依赖注入，bean进入就绪状态。此时，bean准备好被客户端应用程序调用其方法。
- en: 'When a stateful session bean is in Ready state, the EJB container may decide
    to passivate it, that is, to move it from main memory to secondary storage. When
    this happens, the bean goes into **Passive** state. If an instance of a stateful
    session bean hasn''t been accessed for a period of time, the EJB container will
    set the bean to the Does Not Exist state. By default, GlassFish will send a stateful
    session bean to the Does Not Exist state after 90 minutes of inactivity. This
    default can be changed by going through the following steps:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个有状态会话bean处于就绪状态时，EJB容器可能会决定将其钝化，即将其从主内存移动到二级存储。当这种情况发生时，bean进入**被动**状态。如果一段时间内没有访问有状态会话bean的实例，EJB容器将把bean设置为不存在状态。默认情况下，GlassFish将在90分钟的非活动状态后将有状态会话bean发送到不存在状态。此默认值可以通过以下步骤进行更改：
- en: Log in to the GlassFish administration console.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到GlassFish管理控制台。
- en: Expand the **Configuration** node in the tree to the left-hand side.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开左侧树中的**配置**节点。
- en: Expand the **server-config** node.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开**server-config**节点。
- en: Click on the **EJB Container** node.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**EJB容器**节点。
- en: Scroll down towards the bottom of the page and modify the value of the **Removal
    Timeout** text field.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将页面滚动到页面底部并修改**移除超时**文本字段的值。
- en: 'Click on the **Save** button, as shown in the following screenshot:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**保存**按钮，如下面的截图所示：
- en: '![The stateful session bean life cycle](img/6886_04_02.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![有状态会话bean的生命周期](img/6886_04_02.jpg)'
- en: 'This technique sets the timeout value for all stateful session beans. If we
    need to modify the timeout value for a specific session bean, we need to include
    a `glassfish-ejb-jar.xml` deployment descriptor in the JAR file containing the
    session bean. In this deployment descriptor, we can set the timeout value as the
    value of the `<removal-timeout-in-seconds>` element, as shown in the following
    code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此技术为所有有状态会话bean设置超时值。如果我们需要修改特定会话bean的超时值，我们需要在包含会话bean的JAR文件中包含一个`glassfish-ejb-jar.xml`部署描述符。在这个部署描述符中，我们可以将超时值设置为`<removal-timeout-in-seconds>`元素的值，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Even though we are not required to create an `ejb-jar.xml` file for our session
    beans anymore (which used to be the case in previous versions of the J2EE specification),
    we can still write one if we wish to. The `<ejb-name>` element in the `glassfish-ejb-jar.xml`
    deployment descriptor must match the value of the element of the same name in
    `ejb-jar.xml`. If we choose not to create an `ejb-jar.xml` file, this value must
    match the name of the EJB class. The timeout value for the stateful session bean
    must be the value of the `<removal-timeout-in-seconds>` element; as the name of
    the element suggests, the unit of time to use is seconds. In the previous example,
    we set the timeout value to 600 seconds, or 10 minutes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们不再需要为我们的会话bean创建`ejb-jar.xml`文件（这在J2EE规范的前版本中是必须的），但如果我们愿意，我们仍然可以创建一个。`glassfish-ejb-jar.xml`部署描述符中的`<ejb-name>`元素必须与`ejb-jar.xml`中同名元素的值匹配。如果我们选择不创建`ejb-jar.xml`文件，此值必须与EJB类的名称匹配。有状态会话bean的超时值必须是`<removal-timeout-in-seconds>`元素的值；正如元素名称所暗示的，时间单位是秒。在先前的例子中，我们将超时值设置为600秒，即10分钟。
- en: Any methods in a stateful session bean decorated with the `@PostActivate` annotation
    will be invoked just after the stateful session bean has been activated. This
    is equivalent to implementing the `ejbActivate()` method in previous versions
    of J2EE. Similarly, any method decorated with the `@PrePassivate` annotation will
    be invoked just before the stateful session bean is passivated; this is equivalent
    to implementing the `ejbPassivate()` method in previous versions of J2EE.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在有状态会话bean中装饰了`@PostActivate`注解的任何方法将在有状态会话bean激活后立即被调用。这相当于在J2EE的早期版本中实现`ejbActivate()`方法。同样，任何装饰了`@PrePassivate`注解的方法将在有状态会话bean钝化之前被调用；这相当于在J2EE的早期版本中实现`ejbPassivate()`方法。
- en: When a stateful session bean in the Ready state times out and is sent to the
    Does not Exist state, any method decorated with the `@PreDestroy` annotation is
    executed. If the session bean times out in the Passive state, methods decorated
    with the `@PreDestroy` annotation are not executed. Additionally, if a client
    of the stateful session bean executes a method decorated with the `@Remove` annotation,
    all methods decorated with the `@PreDestroy` annotation are executed and the bean
    is marked for garbage collection. Decorating a method with the `@Remove` annotation
    is equivalent to implementing the `ejbRemove()` method in previous versions of
    the J2EE specification.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个处于就绪状态的有状态会话豆超时并被发送到“不存在”状态时，任何被 `@PreDestroy` 注解装饰的方法都会执行。如果会话豆在被动状态下超时，则不会执行被
    `@PreDestroy` 注解装饰的方法。此外，如果状态会话豆的客户执行了一个被 `@Remove` 注解装饰的方法，则所有被 `@PreDestroy`
    注解装饰的方法都会执行，并且豆将被标记为垃圾回收。用 `@Remove` 注解装饰一个方法等同于在J2EE规范的前版本中实现 `ejbRemove()` 方法。
- en: The `@PostActivate`, `@PrePassivate`, and `@Remove` annotations are valid only
    for stateful session beans, whereas the `@PreDestroy` and `@PostConstruct` annotations
    are valid for stateful session beans, stateless session beans, and message-driven
    beans.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`@PostActivate`、`@PrePassivate` 和 `@Remove` 注解仅适用于有状态会话豆，而 `@PreDestroy` 和
    `@PostConstruct` 注解适用于有状态会话豆、无状态会话豆和消息驱动豆。'
- en: The stateless session bean life cycle
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无状态会话豆的生命周期
- en: 'A stateless session bean life cycle contains only the **Does Not Exist** and
    **Ready** states, as shown in the following diagram:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态会话豆的生命周期只包含**不存在**和**就绪**状态，如下面的图所示：
- en: '![The stateless session bean life cycle](img/6886_04_03.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![无状态会话豆生命周期](img/6886_04_03.jpg)'
- en: Stateless session beans are never passivated. A stateless session bean's methods
    can be decorated with the `@PostConstruct` and `@PreDestroy` annotations. Just
    like with stateful session beans, any methods decorated with the `@PostConstruct`
    annotation will be executed when the stateless session bean goes from the Does
    Not Exist to the Ready State, and any methods decorated with the `@PreDestroy`
    annotation will be executed when a stateless session bean goes from the Ready
    state to the Does Not Exist state. Stateless session beans are never passivated,
    any `@PrePassivate` and `@PostActivate` annotations in a stateless session bean
    are simply ignored by the EJB container.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态会话豆永远不会钝化。无状态会话豆的方法可以被 `@PostConstruct` 和 `@PreDestroy` 注解装饰。就像有状态会话豆一样，任何被
    `@PostConstruct` 注解装饰的方法将在无状态会话豆从“不存在”状态变为“就绪”状态时执行，任何被 `@PreDestroy` 注解装饰的方法将在无状态会话豆从“就绪”状态变为“不存在”状态时执行。无状态会话豆永远不会钝化，任何无状态会话豆中的
    `@PrePassivate` 和 `@PostActivate` 注解都将被 EJB 容器简单地忽略。
- en: 'Just like with stateful session beans, we can control how GlassFish manages
    the life cycle of stateless session beans (and message-driven beans) via the administration
    web console, as shown in the following screenshot:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 就像有状态会话豆一样，我们可以通过管理控制台来控制GlassFish如何管理无状态会话豆（和消息驱动豆）的生命周期，如下面的屏幕截图所示：
- en: '![The stateless session bean life cycle](img/6886_04_04.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![无状态会话豆生命周期](img/6886_04_04.jpg)'
- en: '**Initial and Minimum Pool Size** refers to the minimum number of beans in
    the pool'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**初始和最小池大小**指的是池中的最小豆数'
- en: '**Maximum Pool Size** refers to the maximum number of beans in the pool'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大池大小**指的是池中的最大豆数'
- en: '**Pool Resize Quantity** refers to how many beans will be removed from the
    pool when the **Pool Idle Timeout** value expires'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**池大小调整数量**指的是当**池空闲超时**值到期时，将从池中移除多少豆'
- en: '**Pool Idle Timeout** refers to the number of seconds of inactivity to let
    pass before removing beans from the pool'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**池空闲超时**指的是在从池中移除豆之前需要经过的不活动秒数'
- en: 'The previous settings affect all `poolable` EJBs, such as stateless session
    beans and message-driven beans. Just as with stateful session beans, these settings
    can be overridden on a case-by-case basis by adding a GlassFish specific `glassfish-ejb-jar.xml`
    deployment descriptor, as shown in the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的设置会影响所有 `poolable` EJB，例如无状态会话豆和无状态消息驱动豆。就像有状态会话豆一样，这些设置可以通过添加一个GlassFish特定的
    `glassfish-ejb-jar.xml` 部署描述符来逐个案例覆盖，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `<steady-pool-size>` line corresponds to **Initial and Minimum Pool Size**
    in the GlassFish web console
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<steady-pool-size>` 行对应于GlassFish控制台中的**初始和最小池大小**'
- en: The `<max-pool-size>` line corresponds to **Maximum Pool Size** in the GlassFish
    web console
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<max-pool-size>`行对应于GlassFish Web控制台中的**最大池大小**。'
- en: The `<resize-quantity>` line corresponds to **Pool Resize Quantity** in the
    GlassFish web console
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<resize-quantity>`行对应于GlassFish Web控制台中的**池调整数量**。'
- en: The `<pool-idle-timeout-in-seconds>` line corresponds to **Pool Idle Timeout**
    in the GlassFish web console
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<pool-idle-timeout-in-seconds>`行对应于GlassFish Web控制台中的**池空闲超时**。'
- en: Message-driven bean life cycle
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息驱动Bean生命周期
- en: 'Just like stateless session beans, message-driven beans exist only in the Does
    Not Exist and Ready states, as shown in the following diagram:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 就像无状态会话Bean一样，消息驱动Bean只存在于“不存在”和“就绪”状态，如下所示：
- en: '![Message-driven bean life cycle](img/6886_04_03.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![消息驱动Bean生命周期](img/6886_04_03.jpg)'
- en: The above image is exactly the same as the previous one. Message-driven beans
    have the same life cycle as stateless session beans. Therefore, the image to illustrate
    the life cycle was re-used.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的图像与之前的图像完全相同。消息驱动Bean与无状态会话Bean具有相同的生命周期。因此，用于说明生命周期的图像被重新使用。
- en: A message-driven bean can have methods decorated with the `@PostConstruct` and
    `@PreDestroy` methods. Methods decorated with the `@PostConstruct` method are
    executed just before the bean goes into the Ready state. Methods decorated with
    the `@PreDestroy` annotation are executed just before the bean goes to the Does
    Not Exist state.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 消息驱动Bean可以有被`@PostConstruct`和`@PreDestroy`方法装饰的方法。被`@PostConstruct`方法装饰的方法将在Bean进入就绪状态之前执行。被`@PreDestroy`注解装饰的方法将在Bean进入不存在状态之前执行。
- en: Introduction to the EJB Timer Service
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EJB计时器服务简介
- en: 'Stateless session beans and message-driven beans can have a method that is
    executed periodically at regular intervals of time. This can be accomplished using
    the **EJB Timer Service**. The following example illustrates how to take advantage
    of this feature:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态会话Bean和消息驱动Bean可以有一个在固定时间间隔定期执行的方法。这可以通过使用**EJB计时器服务**来实现。以下示例说明了如何利用此功能：
- en: '[PRE16]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In our example, we injected an implementation of the `javax.ejb.TimerService`
    interface by decorating an instance variable of this type with the `@Resource`
    annotation. We then created a timer by invoking the `createTimer()` method of
    the `TimerService` instance.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们通过使用`@Resource`注解装饰该类型的实例变量，注入了`javax.ejb.TimerService`接口的实现。然后，我们通过调用`TimerService`实例的`createTimer()`方法创建了一个计时器。
- en: There are several overloaded versions of the `createTimer()` method. The one
    we chose to use takes an instance of `java.util.Date` as its first parameter;
    this parameter is used to indicate the first time the timer should expire (go
    off). In the example, we chose to use a brand new instance of the `Date` class,
    which, in effect, makes the timer expire immediately. The second parameter of
    the `createTimer()` method is the amount of time to wait, in milliseconds, before
    the timer expires again. In our example, the timer is set to expire every five
    seconds. The third parameter of the `createTimer()` method can be an instance
    of any class implementing the `java.io.Serializable` interface. Since a single
    EJB can have several timers executing concurrently, this third parameter is used
    to uniquely identify each of the timers. If we don't need to identify the timers,
    `null` can be passed as a value for this parameter.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`createTimer()`方法有几个重载版本。我们选择使用的方法接受一个`java.util.Date`实例作为其第一个参数；此参数用于指示计时器应该何时首次到期（关闭）。在示例中，我们选择使用一个新的`Date`类实例，这实际上使得计时器立即到期。`createTimer()`方法的第二个参数是在计时器再次到期之前要等待的时间，以毫秒为单位。在我们的示例中，计时器被设置为每五秒到期一次。`createTimer()`方法的第三个参数可以是实现`java.io.Serializable`接口的任何类的实例。由于单个EJB可以同时执行多个计时器，因此此第三个参数用于唯一标识每个计时器。如果我们不需要标识计时器，可以将`null`作为此参数的值传递。'
- en: Tip
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The EJB method invoking `TimerService.createTimer()` must be called from an
    EJB client. Placing this call in an EJB method decorated with the `@PostConstruct`
    annotation to start the timer automatically when the bean is placed in the Ready
    state will result in an `IllegalStateException` exception to be thrown.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`TimerService.createTimer()`方法的EJB方法必须来自EJB客户端。将此调用放置在带有`@PostConstruct`注解的EJB方法中，以便在Bean处于就绪状态时自动启动计时器，将会导致抛出`IllegalStateException`异常。
- en: We can stop a timer by invoking its `cancel()` method. There is no way to directly
    obtain a single timer associated with an EJB. What we need to do is invoke the
    `getTimers()` method on the instance of `TimerService` that is linked to the EJB;
    this method will return a Collection containing all the timers associated with
    the EJB. We can then iterate through the collection and cancel the correct one
    by invoking its `getInfo()` method. This method will return the `Serializable`
    object we passed as a parameter to the `createTimer()` method.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用其 `cancel()` 方法来停止计时器。无法直接获取与 EJB 关联的单个计时器。我们需要做的是在 `TimerService` 实例上调用
    `getTimers()` 方法，该实例与 EJB 相关联；此方法将返回一个包含与 EJB 关联的所有计时器的集合。然后我们可以遍历集合，通过调用其 `getInfo()`
    方法来取消正确的计时器。此方法将返回我们传递给 `createTimer()` 方法的 `Serializable` 对象。
- en: Finally, any EJB method decorated with the `@Timeout` annotation will be executed
    when a timer expires. Methods decorated with this annotation must return void
    and take a single parameter of type `javax.ejb.Timer`. In our example, the method
    simply writes a message to the server log.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，任何带有 `@Timeout` 注解的 EJB 方法在计时器到期时都会执行。带有此注解的方法必须返回 void 并接受一个类型为 `javax.ejb.Timer`
    的单个参数。在我们的例子中，该方法只是将一条消息写入服务器日志。
- en: 'The following class is a standalone client for the previous EJB:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的类是之前 EJB 的独立客户端：
- en: '[PRE17]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The previous example simply starts a timer, waits for a couple of seconds,
    and then starts a second timer. It then sleeps for 30 seconds and then stops both
    timers. After deploying the EJB and executing the client, we should see some entries
    like the following in the server log:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子只是启动了一个计时器，等待几秒钟，然后启动第二个计时器。然后它睡眠 30 秒，然后停止两个计时器。部署 EJB 并执行客户端后，我们应该在服务器日志中看到一些如下所示的条目：
- en: '[PRE18]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: These entries are created each time one of the timers expires.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 每当其中一个计时器到期时，都会创建这些条目。
- en: Calendar-based EJB timer expressions
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于日历的 EJB 计时器表达式
- en: 'The example in the previous section has one disadvantage: the `startTimer()`
    method in the session bean must be invoked from a client in order to start the
    timer. This restriction makes it difficult to have the timer start as soon as
    the bean is deployed.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个示例中的例子有一个缺点：会话 beans 中的 `startTimer()` 方法必须从客户端调用才能启动计时器。这种限制使得计时器在 bean
    部署后立即启动变得困难。
- en: 'Java EE 6 introduced calendar-based EJB timer expressions. Calendar-based expressions
    allow one or more methods in our session beans to be executed at a certain date
    and time. For example, we could configure one of our methods to be executed every
    night at 8:10 p.m., which is exactly what the following example does:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 6 引入了基于日历的 EJB 计时器表达式。基于日历的表达式允许我们的会话 beans 中的一个或多个方法在特定的日期和时间执行。例如，我们可以配置我们的一个方法在每晚
    8:10 p.m. 执行，这正是以下示例所做的那样：
- en: '[PRE19]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see in this example, we set up the time when the method will be executed
    via the `javax.ejb.Schedule` annotation. In this particular example, we set up
    our method to be executed at 8:10 p.m. by setting the `hour` attribute of the
    `@Schedule` annotation to `"20"`, and its minute attribute to `"10"`. The value
    of the `hour` attribute is 24 hour based; hour 20 is equivalent to 8:00 p.m.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在这个例子中所看到的，我们通过 `javax.ejb.Schedule` 注解设置方法执行的时间。在这个特定的例子中，我们通过将 `@Schedule`
    注解的 `hour` 属性设置为 `"20"`，并将其分钟属性设置为 `"10"` 来设置我们的方法在晚上 8:10 p.m. 执行。`hour` 属性是基于
    24 小时的；20 点相当于晚上 8:00。
- en: The `@Schedule` annotation has several other attributes that allows a lot of
    flexibility in specifying when the method should be executed; we could, for instance,
    have a method being executed on the third Friday of every month, or the last day
    of the month, and so on and so forth.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Schedule` 注解有几个其他属性，允许在指定方法何时执行时具有很大的灵活性；例如，我们可以让一个方法在每月的第三个星期五执行，或者月底的最后一天，等等。'
- en: 'The following table lists all the attributes in the `@Schedule` annotation
    that allow us to control when the annotated method will be executed:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了 `@Schedule` 注解中所有允许我们控制注解方法何时执行的属性：
- en: '| Attribute | Description | Example values | Default value |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 | 示例值 | 默认值 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `dayOfMonth` | The day of the month. | `"3"`: the third day of the month`"Last"`:
    the last day of the month`"-2"`: two days before the end of the month`"1st Tue"`:
    the first Tuesday of the month | `"*"` |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `dayOfMonth` | 月份中的某一天。 | `"3"`：月份的第三天`"Last"`：月底的最后一天`"-2"`：月底前两天`"1st Tue"`：月份的第一个星期二
    | `"*"` |'
- en: '| `dayOfWeek` | The day of the week | `"3"`: every Wednesday`"Thu"`: every
    Thursday | `"*"` |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `dayOfWeek` | 周中的某一天 | `"3"`：每周三`"Thu"`：每周四 | `"*"` |'
- en: '| `hour` | The hour of the day (24 hour based) | `"14"`: 2:00 p.m. | `"0"`
    |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `hour` | 一天中的小时（基于24小时制） | `"14"`：下午2点 | `"0"` |'
- en: '| `minute` | The minute of the hour | `"10"`: ten minutes after the hour |
    `"0"` |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `minute` | 小时的分钟 | `"10"`：小时后的十分钟 | `"0"` |'
- en: '| `month` | The month of the year | `"2"`: February`"March"`: March | `"*"`
    |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `month` | 年份的月份 | `"2"`：二月`"March"`：三月 | `"*"` |'
- en: '| `second` | The second of the minute | `"5"`: five seconds after the minute
    | `"0"` |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `second` | 分钟的第二位 | `"5"`：分钟后的五秒 | `"0"` |'
- en: '| `timezone` | The timezone ID | `"America/New York"` | `""` |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `timezone` | 时区ID | `"America/New York"` | `""` |'
- en: '| `year` | The four-digit year | `"2010"` | `"*"` |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `year` | 四位数的年份 | `"2010"` | `"*"` |'
- en: In addition to single values, most attributes accept the asterisk (`"*"`) as
    a wildcard, meaning that the annotated method will be executed regularly (every
    day, hour, and so on).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 除了单个值之外，大多数属性接受星号（`"*"”）作为通配符，这意味着被注释的方法将定期执行（每天、每小时等）。
- en: Additionally, we can specify more than one value by separating the values with
    commas, for example, if we need a method to be executed every Tuesday and Thursday,
    we could annotate the method as `@Schedule(dayOfWeek="Tue, Thu")`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以通过逗号分隔值来指定多个值，例如，如果我们需要一种方法在每个星期二和星期四执行，我们可以将该方法注释为`@Schedule(dayOfWeek="Tue,
    Thu")`。
- en: We can also specify a range of values; the first and last values are separated
    by a hyphen (*-*). To execute a method from Monday through Friday, we could use
    `@Schedule(dayOfWeek="Mon-Fri")`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以指定一个值的范围；第一个和最后一个值由连字符（*-*）分隔。要执行从星期一到星期五的方法，我们可以使用`@Schedule(dayOfWeek="Mon-Fri")`。
- en: Additionally, we could specify that we need the method to be executed every
    n units of time (for example, every day, every 2 hours, every 10 minutes, and
    so on). To do something like this, we could use `@Schedule(hour="*/12")`, which
    would execute the method every 12 hours.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以指定方法需要每n个时间单位执行一次（例如，每天、每2小时、每10分钟等）。要执行类似的操作，我们可以使用`@Schedule(hour="*/12")`，这将使方法每12小时执行一次。
- en: As we can see, the `@Schedule` annotation provides a lot of flexibility in terms
    of how to specify when we need our methods executed. In addition, it provides
    us the advantage of not needing a client call to activate the scheduling. It also
    has the advantage of using cron-like syntax; therefore, developers familiar with
    this Unix tool will feel right at home using this annotation.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`@Schedule`注解在指定方法执行时间方面提供了很大的灵活性。此外，它还提供了我们不需要客户端调用即可激活调度的优势。它还具有使用类似于cron的语法的优势；因此，熟悉此Unix工具的开发者将感到使用此注解非常得心应手。
- en: EJB Security
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EJB安全
- en: Enterprise JavaBeans allow us to declaratively decide which users can access
    their methods. For example, some methods might only be available to users in certain
    roles. A typical scenario is that only users with the role of administrator can
    add, delete, or modify other users in the system.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 企业JavaBeans允许我们声明性地决定哪些用户可以访问其方法。例如，某些方法可能仅供具有特定角色的用户使用。一个典型的场景是，只有具有管理员角色的用户才能添加、删除或修改系统中的其他用户。
- en: The following example is a slightly modified version of the DAO session bean
    we saw earlier in this chapter. In this version, some methods that were previously
    private are made public. Additionally, the session bean was modified to allow
    only users in certain roles to access its methods.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例是本章前面看到的DAO会话bean的略微修改版本。在这个版本中，一些之前是私有的方法被改为公开。此外，会话bean被修改为只允许具有特定角色的用户访问其方法。
- en: '[PRE20]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we can see, we declare what roles have access to the methods using the `@RolesAllowed`
    annotation. This annotation can take either a single string or an array of strings
    as its parameter. When a single string is used as a parameter for this annotation,
    only users with the role specified by the parameter can access the method. If
    an array of Strings is used as the parameter, users with any of the roles specified
    by the array's elements can access the method.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们使用`@RolesAllowed`注解声明哪些角色可以访问方法。此注解可以接受单个字符串或字符串数组作为其参数。当使用单个字符串作为此注解的参数时，只有具有该参数指定的角色的用户可以访问该方法。如果使用字符串数组作为参数，则具有数组元素中指定的任何角色的用户都可以访问该方法。
- en: The `@RolesAllowed` annotation can be used to decorate an EJB class, in which
    case, its values apply to either all the methods in the EJB, or to one or more
    methods. In the second case, its values apply only to the method the annotation
    is decorating. If, like in our previous example, both the EJB class and one or
    more of its methods are decorated with the `@RolesAllowed` annotation, the method
    level annotation takes precedence.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`@RolesAllowed`注解来装饰EJB类，在这种情况下，其值适用于EJB中的所有方法，或者适用于一个或多个方法。在后一种情况下，其值仅适用于被注解的方法。如果，像我们之前的例子一样，EJB类及其一个或多个方法都被`@RolesAllowed`注解装饰，则方法级别的注解具有优先权。
- en: 'Application roles need to be mapped to a security realm''s group name (refer
    to [Chapter 9](ch09.html "Chapter 9. Securing Java EE Applications"), *Securing
    Java EE Applications*, for details). This mapping, along with what realm to use,
    is set in the `glassfish-ejb-jar.xml` deployment descriptor, as shown in the following
    code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序角色需要映射到安全域的组名称（有关详细信息，请参阅第9章[Securing Java EE Applications]，*Securing Java
    EE Applications*）。此映射以及要使用的域设置在`glassfish-ejb-jar.xml`部署描述符中，如下所示：
- en: '[PRE21]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `<security-role-mapping>` element of `glassfish-ejb-jar.xml` performs the
    mapping between application roles and the security realm's group. The value of
    the `<role-name>` subelement must contain the application role; this value must
    match the value used in the `@RolesAllowed` annotation. The value of the `<group-name>`
    subelement must contain the name of the security group in the security realm used
    by the EJB. In our example, we map two application roles to their corresponding
    groups in the security realm. Although in this particular example the name of
    the application role and the security group match, this does not need to be the
    case.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`glassfish-ejb-jar.xml`中的`<security-role-mapping>`元素执行应用程序角色与安全域组的映射。`<role-name>`子元素的值必须包含应用程序角色；此值必须与`@RolesAllowed`注解中使用的值匹配。`<group-name>`子元素的值必须包含EJB使用的安全域中的安全组名称。在我们的示例中，我们将两个应用程序角色映射到安全域中的相应组。尽管在这个特定的例子中应用程序角色的名称和安全组的名称匹配，但这并不一定需要如此。'
- en: Tip
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Automatically matching roles to security groups**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动匹配角色到安全组**'
- en: It is possible to automatically match any application roles to identically named
    security groups in the security realm. This can be accomplished by logging in
    to the GlassFish web console, clicking on the **Configuration** node, clicking
    on **Security**, then clicking on the checkbox labeled **Default Principal To
    Role Mapping**, and saving this configuration change.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 可以自动将任何应用程序角色匹配到安全域中具有相同名称的安全组。这可以通过登录到GlassFish Web控制台，点击**配置**节点，然后点击**安全**，接着点击标记为**默认主体到角色映射**的复选框，并保存此配置更改来实现。
- en: As shown in our example, the security realm to use for authentication is defined
    in the `<realm>` subelement of the `<as-context>` element. The value of this subelement
    must match the name of a valid security realm in the application server. Other
    sub elements of the `<as-context>` element include `<auth-method>`, the only valid
    value for this element is `username_password`, and `<required>`, the only valid
    values of which are `true` and `false`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们的示例所示，用于身份验证的安全域定义在`<as-context>`元素的`<realm>`子元素中。此子元素的值必须与应用服务器中有效安全域的名称匹配。`<as-context>`元素的其它子元素包括`<auth-method>`，此元素的唯一有效值是`username_password`，以及`<required>`，其唯一有效值是`true`和`false`。
- en: Client authentication
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端身份验证
- en: If the client code accessing a secured EJB is part of a web application the
    user of which has already been authenticated (the user logged in through the web
    interface), then the user's credentials will be used to determine whether or not
    the user should be allowed to access the method they are trying to execute.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果访问受保护EJB的客户端代码是某个已经通过其用户界面登录（即用户通过Web界面登录）的Web应用程序的一部分，那么用户的凭据将用于确定用户是否应该被允许访问他们试图执行的方法。
- en: 'Standalone clients must be executed through the `appclient` utility. The following
    code illustrates a typical client for the previous, secured session bean:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 独立客户端必须通过`appclient`实用程序执行。以下代码演示了之前受保护的会话Bean的典型客户端：
- en: '[PRE22]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As we can see, there is nothing the code is doing in order to authenticate
    the user. The session bean is simply injected into the code via the `@EJB` annotation
    and used as usual. The reason this works is because the `appclient` utility takes
    care of authenticating the user after invoking the client code via the `appclient`
    utility as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，代码中并没有执行任何用于验证用户的操作。会话 Bean 通过 `@EJB` 注解简单地注入到代码中，并按常规使用。这是因为 `appclient`
    工具在通过 `appclient` 工具调用客户端代码后负责验证用户，如下所示：
- en: '[PRE23]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `appclient` utility will present the user with a log in window when it
    attempts to invoke a secure method on EJB, as shown in the following screenshot:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `appclient` 工具尝试在 EJB 上调用安全方法时，它会向用户展示一个登录窗口，如下面的截图所示：
- en: '![Client authentication](img/6886_04_05.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![客户端认证](img/6886_04_05.jpg)'
- en: 'Assuming that the credentials are correct and the user has the appropriate
    permissions, the EJB code will execute, and we should see the expected output
    from the `Client` class:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 假设凭证正确且用户具有适当的权限，EJB 代码将执行，我们应该从 `Client` 类看到预期的输出：
- en: '[PRE24]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered how to implement business logic via stateless and
    stateful session beans. Additionally, we covered how to implement message-driven
    beans to consume JMS messages.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何通过无状态和有状态会话 Bean 实现业务逻辑。此外，我们还介绍了如何实现消息驱动 Bean 以消费 JMS 消息。
- en: We also explained how to take advantage of the transactional nature of EJBs
    to simplify implementing the Data Access Object (DAO) pattern.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还解释了如何利用 EJB 的事务性来简化实现数据访问对象（DAO）模式。
- en: Additionally, we explained the concept of container-managed transactions and
    how to control them using the appropriate annotations. We also explained how to
    implement Bean Managed Transactions for cases in which container-managed transactions
    are not enough to satisfy our requirements.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们解释了容器管理事务的概念以及如何使用适当的注解来控制它们。我们还解释了在容器管理事务不足以满足我们的要求时，如何实现 Bean 管理事务。
- en: Life cycles for the different types of Enterprise JavaBeans were covered, including
    an explanation on how to have EJB methods automatically invoked by the EJB container
    at certain points in the life cycle.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还涵盖了不同类型的企业 JavaBeans 的生命周期，包括如何让 EJB 容器在生命周期中的特定点自动调用 EJB 方法。
- en: We also covered how to have EJB methods invoked periodically by the EJB container
    by taking advantage of the EJB timer service.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还解释了如何利用 EJB 定时器服务让 EJB 容器定期调用 EJB 方法。
- en: Finally, we explained how to make sure EJB methods are only invoked by authorized
    users by annotating the EJB classes and/or methods and by adding the appropriate
    entries to the `glassfish-ejb-jar.xml` deployment descriptor.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们解释了如何通过注释 EJB 类和/或方法以及添加适当的条目到 `glassfish-ejb-jar.xml` 部署描述符中，以确保 EJB 方法只被授权用户调用。
- en: In the next chapter, we will cover Contexts and Dependency Injection.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍上下文和依赖注入。
