- en: Chapter 2. New Specifications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 新规范
- en: 'This chapter will only talk about new specifications that have been added in
    Java EE 7\. In concrete terms, we will present and show how to use the following
    APIs:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将仅讨论在Java EE 7中添加的新规范。具体来说，我们将介绍并展示如何使用以下API：
- en: Concurrency Utilities for Java EE 1.0
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java EE 1.0并发工具
- en: Batch Applications for Java Platform 1.0
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java平台1.0批处理应用程序
- en: Java API for JSON Processing 1.0
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java API for JSON Processing 1.0
- en: Java API for WebSocket 1.0
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java API for WebSocket 1.0
- en: Concurrency Utilities for Java EE 1.0
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java EE 1.0并发工具
- en: Concurrency Utilities for Java EE 1.0 was developed under JSR 236\. This section
    gives you only an overview of the API. The complete document specification (for
    more information) can be downloaded from [http://jcp.org/aboutJava/communityprocess/final/jsr236/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr236/index.html).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 1.0并发工具是在JSR 236下开发的。本节仅为您提供一个API的概述。完整的文档规范（更多信息）可以从[http://jcp.org/aboutJava/communityprocess/final/jsr236/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr236/index.html)下载。
- en: Why concurrency?
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么需要并发？
- en: In computer science, **concurrency** is the ability of an application or a system
    to execute many tasks in parallel. Before the advent of multitasking system, computers
    could only run one process at a time. At that time, the programs were not only
    difficult to design, but they were also executed sequentially from beginning to
    end and when the machine was running a program that had access to a peripheral
    device, the running program was first interrupted to allow the reading of the
    peripheral.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，**并发**是指一个应用程序或系统执行多个任务的能力。在多任务系统出现之前，计算机一次只能运行一个进程。当时，程序不仅难以设计，而且它们是从头到尾顺序执行的，当机器运行一个可以访问外围设备的程序时，正在运行的程序首先被中断以允许读取外围设备。
- en: Benefits of concurrency
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并发的益处
- en: The development of multitasking operating systems enabled the simultaneous execution
    of many processes (instances of running programs) within a machine and many threads
    (also called lightweight processes; they are subsets of a process that can be
    run concurrently with each other) within a process. Due to this progress, it has
    become possible to run multiple applications at the same time, for example, listening
    to music and downloading a document while writing a text document.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 多任务操作系统的开发使得在机器内同时执行多个进程（运行程序的实例）和进程内的多个线程（也称为轻量级进程；它们是可以在彼此之间并发运行的进程的子集）成为可能。由于这一进步，现在可以同时运行多个应用程序，例如，在写文本文档的同时听音乐和下载文档。
- en: In enterprise applications, concurrency can increase the interactivity of your
    program by running heavy processing asynchronously in a thread. It can also be
    used to improve the response time of an application by dividing a big task into
    smaller units that will be executed simultaneously by many threads.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业应用程序中，通过在线程中异步运行重处理，并发可以提高程序的交互性。它还可以通过将大任务分解成许多小单元，这些单元将由许多线程同时执行，来提高应用程序的响应时间。
- en: Risks of concurrency
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并发的风险
- en: Although each thread has its proper stack of execution, it is very common to
    have multiple threads that share the same resources or depend on each other. In
    such cases, the absence of good synchronization makes threading behavior unpredictable
    and can degrade system performance. For example, the lack of coordination of interrelated
    threads can result in deadlocks and indefinitely interrupt processing.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管每个线程都有其适当的执行栈，但多个线程共享相同资源或相互依赖的情况非常普遍。在这种情况下，缺乏良好的同步会使线程行为不可预测，并可能降低系统性能。例如，相互关联的线程缺乏协调可能导致死锁和无限中断处理。
- en: Concurrency and Java EE
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发与Java EE
- en: As we have seen previously, the misuse of threads can have catastrophic consequences
    on an application. In the case of a container, it could not only compromise its
    integrity, but also poorly exploit the resources provided to other components.
    This is one of the reasons why developers were not allowed to create threads in
    a container.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所看到的，线程的误用可能对应用程序产生灾难性的后果。在容器的情况下，它不仅可能损害其完整性，而且可能未能充分利用提供给其他组件的资源。这也是为什么开发者不允许在容器中创建线程的原因之一。
- en: To enable implementation of concurrency within Java EE components, the Java
    EE 7 platform has integrated Concurrency Utilities. Using this API, a Java EE
    server can become aware of the resources that are used by threads and provide
    them with good execution context. Furthermore, it allows the server to manage
    the pool and lifecycle of threads.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Java EE组件中实现并发，Java EE 7平台集成了并发实用工具。使用此API，Java EE服务器可以了解线程使用的资源，并为它们提供良好的执行上下文。此外，它允许服务器管理线程池和生命周期。
- en: Java EE Concurrency API
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java EE并发API
- en: 'Concurrency Utilities for Java EE 1.0 was developed with the followings goals
    in mind:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 1.0并发实用工具的开发目标是以下内容：
- en: To provide a simple and flexible concurrency API to the Java EE platform without
    compromising the container
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个简单且灵活的并发API给Java EE平台，同时不损害容器
- en: To facilitate migration from Java SE to Java EE by providing consistency between
    the concurrency programming models
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过提供一致性，促进从Java SE迁移到Java EE
- en: To allow the implementation of common and advanced concurrency patterns
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许实现常见的和高级并发模式
- en: 'Concurrency Utilities was built over the Concurrency Utilities API developed
    under JSR-166 for Java SE (which facilitates the migration from Java SE to Java
    EE). It offers four main programming interfaces whose instances must be made available
    to application components as container-managed objects. The offered interfaces
    are: `ContextService`, `ManagedExecutorService`, `ManagedScheduledExecutorService`,
    and `ManagedThreadFactory`. All these interfaces are contained in the `javax.enterprise.concurrent`
    package.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 并发实用工具是在Java SE下JSR-166开发的并发实用工具API之上构建的（这有助于从Java SE迁移到Java EE）。它提供了四个主要的编程接口，其实例必须作为容器管理的对象提供给应用程序组件。提供的接口有：`ContextService`、`ManagedExecutorService`、`ManagedScheduledExecutorService`和`ManagedThreadFactory`。所有这些接口都包含在`javax.enterprise.concurrent`包中。
- en: 'These four interfaces can be explained as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个接口可以这样解释：
- en: '**Managed executor service**: The `ManagedExecutorService` interface extends
    the `java.util.concurrent.ExecutorService` interface. It allows us to submit an
    asynchronous task that will be run on a separate thread created and managed by
    the container. By default, any Java EE 7-compliant server must provide a `ManagedScheduledExecutorService`
    that can be accessed by application components under the **JNDI** name `java:comp/DefaultManagedScheduledExecutorService`.
    But, if you want to create your own, you must first declare the `ManagedExecutorService`
    resource environment reference in the `web.xml` file for a web application or
    `ejb-jar.xml` for an EJB module. The specification recommends that all `ManagedExecutorService`
    resource environment references be organized in the `java:comp/env/concurrent`
    subcontext.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**托管执行服务**：`ManagedExecutorService`接口扩展了`java.util.concurrent.ExecutorService`接口。它允许我们提交一个将在由容器创建和管理的单独线程上运行的异步任务。默认情况下，任何符合Java
    EE 7规范的服务器都必须提供一个`ManagedScheduledExecutorService`，可以通过**JNDI**名称`java:comp/DefaultManagedScheduledExecutorService`访问。但是，如果您想创建自己的，您必须首先在`web.xml`文件中声明`ManagedExecutorService`资源环境引用，对于Web应用程序或`ejb-jar.xml`中的EJB模块。规范建议将所有`ManagedExecutorService`资源环境引用组织在`java:comp/env/concurrent`子上下文中。'
- en: 'The following configuration is an example declaration of a `ManagedExecutorService`
    resource environment reference:'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下配置是一个`ManagedExecutorService`资源环境引用的示例声明：
- en: '[PRE0]'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的账户下载您购买的所有Packt书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: 'After declaring the JNDI reference, you can then inject it by using the `@Resource`
    annotation as shown in the following code:'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在声明JNDI引用之后，您可以使用`@Resource`注解将其注入，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The task to submit to the container must either implement the `java.lang.Runnable`
    or `java.util.concurrent.Callable` interface. The differences between these interfaces
    are presented in the following table:'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交给容器的任务必须实现`java.lang.Runnable`或`java.util.concurrent.Callable`接口。这两个接口之间的区别在下面的表格中展示：
- en: '| Runnable | Callable |'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| Runnable | Callable |'
- en: '| --- | --- |'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Since JDK 1.0. | Since JDK 5.0. |'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| 自 JDK 1.0.0 以来。 | 自 JDK 5.0 以来。 |'
- en: '| It has `run()` method to define task. | It has the `call()` method to define
    task. |'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| 它具有 `run()` 方法来定义任务。 | 它具有 `Callable<V>` 实例的 `call()` 方法来定义任务。 |'
- en: '| It is not generic and the `run()` method does not return any value. | It
    is generic and the `call()` method of a `Callable<V>` instance returns a value
    of type `V`. |'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| 它具有 `run()` 方法来定义任务。 | 它具有 `Callable<V>` 实例的 `call()` 方法来定义任务。 |'
- en: '| The `run()` method cannot throw checked exception. | The `call()` method
    can throw checked exception. |'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `run()` 方法不能抛出受检异常。 | `call()` 方法可以抛出受检异常。 |'
- en: 'The following code demonstrates how to define a task that will run reports
    asynchronously:'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下代码演示了如何定义一个将异步运行报告的任务。
- en: '[PRE2]'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following code shows us how to submit a task. We can see that the `submit()`
    method of the `ManagedExecutorService` instance returns an object of type `Future`
    that will get back the result of the running task when it becomes available:'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下代码展示了如何提交任务。我们可以看到，`ManagedExecutorService` 实例的 `submit()` 方法返回一个 `Future`
    类型的对象，当任务可用时，将返回运行任务的结果：
- en: '[PRE3]'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Managed scheduled executor service:** The `ManagedScheduledExecutorService`
    interface extends the `ManagedExecutorService` and `java.util.concurrent.ScheduledExecutorService`
    interfaces in order to execute a task at a specific time.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**托管定时执行服务接口：** `ManagedScheduledExecutorService` 接口扩展了 `ManagedExecutorService`
    和 `java.util.concurrent.ScheduledExecutorService` 接口，以便在特定时间执行任务。'
- en: 'Instances of this interface are defined in the same way as that of the `ManagedExecutorService`
    interface. The following code demonstrates how to execute a task ten seconds after
    its submission:'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此接口的实例定义方式与 `ManagedExecutorService` 接口相同。以下代码演示了如何在提交后 10 秒执行任务：
- en: '[PRE4]'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Managed thread factory:** The `ManagedThreadFactory` interface provides method
    to create managed thread instances in a container. The task must implement the
    `java.lang.Runnable` interface. The following code demonstrates how to create
    and run a container-managed thread.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**托管线程工厂接口：** `ManagedThreadFactory` 接口提供在容器中创建托管线程实例的方法。任务必须实现 `java.lang.Runnable`
    接口。以下代码演示了如何创建和运行一个容器管理的线程。'
- en: '[PRE5]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Context service:** This interface allows the creation of contextual objects
    without using `ManagedExecutorService` or `ManagedScheduledExecutorService` interfaces,
    as we did in the previous cases, with the aim of allowing the extension of the
    capabilities of a Java EE platform for concurrency. Concretely, with this interface,
    you can create a workflow system or use customized Java SE platform `ExecutorService`
    implementations within a container. For example, if you desire to use the pool
    management mechanism provided by the class `java.util.concurrent.ThreadPoolExecutor`
    of Java SE to manage your threads in the context of a Java EE component, you will
    just need to combine `ManagedThreadFactory`, `ExecutorService`, and `ContextService`
    objects. The result is as shown in the following code:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文服务接口：** 此接口允许在不使用 `ManagedExecutorService` 或 `ManagedScheduledExecutorService`
    接口的情况下创建上下文对象，正如我们在之前的案例中所做的那样，目的是为了允许扩展 Java EE 平台的并发能力。具体来说，使用此接口，您可以在容器内创建工作流系统或使用定制的
    Java SE 平台 `ExecutorService` 实现。例如，如果您希望使用 Java SE 中 `java.util.concurrent.ThreadPoolExecutor`
    类提供的池管理机制来管理 Java EE 组件上下文中的线程，您只需将 `ManagedThreadFactory`、`ExecutorService` 和
    `ContextService` 对象组合起来即可。结果如下所示：'
- en: '[PRE6]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is probably a simple example of the use you can make of this feature. For
    more advanced examples, please consult the specification document in the *Context
    service* section.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是使用此功能的一个简单示例。对于更高级的示例，请参阅 *上下文服务* 部分的规范文档。
- en: 'The following diagram provides an overview of relationships between Concurrency
    Utilities and other Java EE platform elements:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表提供了并发工具与其他 Java EE 平台元素之间关系的概述：
- en: '![Java EE Concurrency API](img/9235OT_02_01.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![Java EE 并发 API](img/9235OT_02_01.jpg)'
- en: Besides, it is possible to refine the configurations of different resources
    for better performance (for details, see the specification document), and the
    Concurrency Utilities for Java EE 1.0 provide many other interfaces like `ManagedTaskListener`
    that can be used to monitor the state of a task's `Future` object.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还可以优化不同资源的配置以获得更好的性能（详细信息请参阅规范文档），Java EE 1.0 的并发工具还提供了许多其他接口，如 `ManagedTaskListener`，可用于监控任务
    `Future` 对象的状态。
- en: Batch Applications for Java Platform 1.0
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 平台 1.0 的批处理应用程序
- en: The Batch Applications API for the Java Platform 1.0 was developed under JSR
    352\. This section just gives you an overview of the API. The complete document
    specification (for more information) can be downloaded from [http://jcp.org/aboutJava/communityprocess/final/jsr352/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr352/index.html).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Java平台1.0的批处理应用程序API是在JSR 352下开发的。本节仅为你提供一个API的概述。完整的文档规范（更多信息）可以从[http://jcp.org/aboutJava/communityprocess/final/jsr352/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr352/index.html)下载。
- en: What is batch processing?
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是批处理？
- en: According to the Cambridge Advanced Learner's Dictionary, a batch is a group
    of things or people dealt with at the same time or considered similar in type.
    And a process is a series of actions that you take in order to achieve a result.
    Based on these two definitions, we can say that **batch processing** is a series
    of repetitive actions on a large amount of data in order to achieve a result.
    Given the large amounts of data that it has to deal with, batch processing is
    often used for end of day, month, period, and year processing.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 根据剑桥高级学习者词典，批处理是一组同时处理或被认为类型相似的事物或人。过程是一系列你为了达到某个结果而采取的行动。基于这两个定义，我们可以这样说，**批处理**是为了达到某个结果而在大量数据上重复执行的一系列操作。鉴于它必须处理的大量数据，批处理通常用于日终、月终、期终和年终处理。
- en: 'The following is a short list of domains where you can use batch processing:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些你可以使用批处理的领域简短列表：
- en: Data import/export from/to XML or CSV files
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从/到XML或CSV文件的数据导入/导出
- en: Accounting processing such as consolidations
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会计处理，如合并
- en: '**ETL** (**extract-transform-load**) in a data warehouse'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ETL**（**提取-转换-加载**）在数据仓库中'
- en: Digital files processing (downloading, processing, or saving)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字文件处理（下载、处理或保存）
- en: Notification of a service's subscribers (such as forum, group, and so on)
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知服务的订阅者（如论坛、群组等）
- en: Why a dedicated API for batch processing?
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么需要一个专门的批处理API？
- en: 'After having an idea about batch processing, some people might ask themselves:
    Why not just set a `foreach` loop that launches many threads? First of all, you
    have to know that batch processing is not only concerned with the execution speed.
    Indeed, the processing of large amounts of data is often affected by many exceptions,
    which could generate a number of preoccupations: What action should be taken in
    case of exceptions? Should we cancel the whole process for any exception? If not,
    what action should be canceled? For which type of exception? If you only need
    to cancel a certain number of transactions, how do you recognize them? And at
    the end of a batch processing, it is always important to know how many treatments
    have been canceled. How many have been registered successfully? How many have
    been ignored?'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在对批处理有了大致了解之后，有些人可能会问自己：为什么不直接设置一个`foreach`循环来启动多个线程呢？首先，你必须知道批处理并不仅仅关注执行速度。实际上，处理大量数据常常会受到许多异常的影响，这可能会产生许多担忧：在出现异常的情况下应该采取什么行动？我们应该因为任何异常而取消整个流程吗？如果不是，应该取消哪些操作？针对哪种类型的异常？如果你只需要取消一定数量的交易，你如何识别它们？在批处理结束时，了解有多少处理被取消总是很重要的。有多少被成功注册？有多少被忽略？
- en: As you can see, we have not finished identifying questions that batch processing
    can raise, but we discover that this is already a great deal. Trying to build
    such a tool on your own may not only complicate your application but also introduce
    new bugs.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们还没有完成识别批处理可能引发的问题，但我们发现这已经足够多了。试图自己构建这样的工具可能会不仅使你的应用程序复杂化，还可能引入新的错误。
- en: Understanding the Batch API
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解批处理API
- en: The Batch Applications API for the Java Platform 1.0 was developed to provide
    a solution to the different needs listed in the earlier bullet items. It targets
    both Java SE and Java EE applications and requires at least the 6th Version of
    JVM.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Java平台1.0的批处理应用程序API是为了解决前面列表中列出的不同需求而开发的。它针对Java SE和Java EE应用程序，并需要至少JVM的第6个版本。
- en: 'The features offered by this API can be summarized as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个API提供的功能可以概括如下：
- en: It offers the **Reader-Processor-Writer** pattern natively and gives you the
    ability to implement your own batch pattern. This allows you to choose the best
    pattern depending on the case.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它原生地提供了**读取器-处理器-写入器**模式，并赋予你实现自己的批处理模式的能力。这允许你根据具体情况选择最佳的模式。
- en: It gives the possibility of defining the behavior (skip, retry, rollback, and
    so on) of the batch processing for each type of error.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了为每种类型的错误定义批处理行为（跳过、重试、回滚等）的可能性。
- en: 'It supports many step-level metrics such as: `rollbackCount`, `readSkipCount`,
    `writeSkipCount`, and so on for monitoring.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持许多步骤级度量，例如：`rollbackCount`、`readSkipCount`、`writeSkipCount`等，用于监控。
- en: It can be configured to run some processes in parallel and offer the possibility
    to use JTA or `RESOURCE_LOCAL` transaction mode.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以被配置为并行运行一些进程，并提供使用JTA或`RESOURCE_LOCAL`事务模式的可能性。
- en: 'To do this, the Batch Applications API for the Java Platform 1.0 is based on
    a solid architecture that can be outlined by the following diagram. A **Job**
    is managed by a `JobOperator` and has one or many steps, which can be either **chunk**
    or **batchlet**. During its lifecycle, information (metadata) about a job is stored
    in `JobRepository`, as shown in the following diagram:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，Java平台1.0的批处理应用程序API基于一个稳固的架构，可以通过以下图表来概述。一个**工作**由一个`JobOperator`管理，并有一个或多个步骤，这些步骤可以是**块**或**批处理单元**。在其生命周期内，关于一个工作的信息（元数据）存储在`JobRepository`中，如下面的图表所示：
- en: '![Understanding the Batch API](img/9235OT_02_02.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![理解批处理API](img/9235OT_02_02.jpg)'
- en: JobRepository
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JobRepository
- en: As we said earlier, `JobRepository` stores metadata about current and past running
    jobs. It can be accessed through `JobOperator`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所述，`JobRepository`存储有关当前和过去运行的工作的元数据。它可以通过`JobOperator`访问。
- en: Job
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作
- en: A **Job** can be seen as an entity to encapsulate a unit of batch processing.
    It is made up of one or many steps, which must be configured within an XML file
    called a **Job configuration file** or **Job XML**. This file will contain job
    identification information and different steps that compose the job. The code
    that follows shows the skeleton of a Job XML file.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**工作**可以被视为封装一个批处理单元的实体。它由一个或多个步骤组成，这些步骤必须在名为**工作配置文件**或**工作XML**的XML文件中进行配置。该文件将包含工作识别信息以及构成工作的不同步骤。下面的代码展示了工作XML文件的骨架。
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Job XML file is named with the convention `<name>.xml` (for example, `inscriptionJob.xml`)
    and should be stored under the `META-INF/batch-jobs` directory for portable application.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 工作XML文件按照约定命名为`<name>.xml`（例如，`inscriptionJob.xml`），并且应该存储在`META-INF/batch-jobs`目录下，以便于便携式应用程序。
- en: Step
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤
- en: 'A **Step** is an autonomous phase of a batch. It contains all the necessary
    information to define and control a piece of batch processing. A batch step is
    either a chunk or a batchlet (the two are mutually exclusive). The step of the
    following code is a chunk type step:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤**是批处理的一个自主阶段。它包含定义和控制一个批处理片段所需的所有必要信息。批处理步骤要么是块要么是批处理单元（两者互斥）。以下代码的步骤是一个块类型步骤：'
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Chunk
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 块
- en: A **chunk** is a type of step that implements the Reader-Processor-Writer pattern.
    It runs in the scope of a configurable transaction and can receive many configuration
    values. The following code is a more enhanced version of the **inscription-validator-Job**
    shown in the preceding code. In this listing, we have added a configuration to
    define the unit element that will be used in order to manage the commit behavior
    of the chunk (`checkpoint-policy="item"`), and a configuration to define the number
    of items (unit elements) to process before commit (`item-count="15"`). We have
    also specified the number of exceptions a step will skip if any configured exceptions
    that can be skipped are thrown by the chunk (`skip-limit="30"`).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**块**是一种实现读取-处理-写入模式的步骤类型。它在可配置的事务范围内运行，并且可以接收许多配置值。以下代码是前面代码中显示的**inscription-validator-Job**的更完善版本。在这个列表中，我们添加了一个配置来定义将用于管理块提交行为的单元元素（`checkpoint-policy="item"`），以及一个配置来定义在提交之前要处理的项目（单元元素）数量（`item-count="15"`）。我们还指定了如果块抛出任何配置的可跳过的异常，步骤将跳过的异常数量（`skip-limit="30"`）。'
- en: 'The following code is an example of a chunk type step with some configuration:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个具有一些配置的块类型步骤示例：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The following code shows us what chunk batch artifact implementation looks like.
    The `InscriptionCheckpoint` allows you to know the line that is being processed.
    The source code of this section is a validation program that sends a message to
    the candidates to let them know if they have been accepted or not. At the end,
    it displays monitoring information in a web page. The processing is launched by
    the `ChunkStepBatchProcessing.java` Servlet.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了块批处理批件实现的样子。`InscriptionCheckpoint`允许您知道正在处理哪一行。本节的源代码是一个验证程序，向候选人发送消息，让他们知道是否被接受。最后，它在网页上显示监控信息。处理是通过`ChunkStepBatchProcessing.java`
    Servlet启动的。
- en: 'The following code is a skeleton of chunk batch artifact implementations:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是块批处理批件实现框架的示例：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Batchlet
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 批处理步骤
- en: A **batchlet** is a type of step to implement your own batch pattern. Unlike
    a chunk that performs tasks in three phases (reading, processing, and writing),
    a batchlet step is invoked once and returns an exit status at the end of processing.
    The following code shows us what a batchlet batch artifact implementation looks
    like. The source code of this section sends an information message to all students
    and displays some important information about the batch. The processing is launched
    by the `BatchletStepBatchProcessing.java` Servlet.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**批处理步骤**是实现您自己的批处理模式的一种步骤类型。与执行三个阶段（读取、处理和写入）的任务的块不同，批处理步骤只被调用一次，并在处理结束时返回一个退出状态。以下代码展示了批处理批件实现的样子。本节的源代码向所有学生发送信息消息，并显示有关批处理的一些重要信息。处理是通过`BatchletStepBatchProcessing.java`
    Servlet启动的。'
- en: 'The following code is a skeleton of batchlet batch artifact implementation:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是批处理批件实现框架的示例：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The batch.xml configuration file
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 批处理.xml配置文件
- en: The `batch.xml` file is an XML file that contains the batch artifacts of the
    batch application. It establishes a correspondence between the batch artifact
    implementation and the reference name that is used in the Job XML file. The `batch.xml`
    file must be stored in the `META-INF` directory for a portable application. The
    following code gives us the contents of the `batch.xml` file for the `inscription-validator-Job`
    Job shown in the preceding code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`batch.xml`文件是一个包含批处理应用程序批处理批件的XML文件。它建立了批处理批件实现与在作业XML文件中使用的参考名称之间的对应关系。`batch.xml`文件必须存储在`META-INF`目录中，以便于便携式应用程序。以下代码给出了前面代码中显示的`inscription-validator-Job`作业的`batch.xml`文件内容。'
- en: 'The following code is an example of `batch.xml`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是`batch.xml`的一个示例：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: JobOperator
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务操作员
- en: The `JobOperator` instance is accessible through the `getJobOperator()` method
    of the `BatchRuntime` class. It provides a set of operations to manage (`start`,
    `stop`, `restart` and so on) a job and access `JobRepository` (`getJobNames`,
    `getJobInstances`, `getStepExecutions`, and so on). The following code shows how
    to start the `inscription-validator-Job` Job shown earlier without any specific
    property. It is important to note that the `inscriptionJob` value that is specified
    in the `JobOperator.start` command is the name of the Job XML file (not the ID
    of the job). In the Servlet `ChunkStepBatchProcessing`, you will see how to retrieve
    the status and how to monitor information about batch processing from the `JobOperator`
    instance.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`JobOperator`实例可以通过`BatchRuntime`类的`getJobOperator()`方法访问。它提供了一组操作来管理（`启动`、`停止`、`重启`等）作业并访问`JobRepository`（`getJobNames`、`getJobInstances`、`getStepExecutions`等）。以下代码展示了如何在没有特定属性的情况下启动前面显示的`inscription-validator-Job`作业。重要的是要注意，在`JobOperator.start`命令中指定的`inscriptionJob`值是作业XML文件的名称（而不是作业的ID）。在Servlet
    `ChunkStepBatchProcessing`中，您将看到如何检索状态以及如何从`JobOperator`实例监控批处理信息。'
- en: 'The following code is an example of code to start a Job:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是启动作业的示例代码：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Java API for JSON Processing 1.0
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java API for JSON Processing 1.0
- en: The Java API for JSON Processing 1.0 was developed under JSR 353\. This section
    gives you only an overview of the API. The complete document specification (for
    more information) can be downloaded from [http://jcp.org/aboutJava/communityprocess/final/jsr353/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr353/index.html).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Java API for JSON Processing 1.0是在JSR 353下开发的。本节仅为您提供了API的概述。完整的文档规范（更多信息）可以从[http://jcp.org/aboutJava/communityprocess/final/jsr353/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr353/index.html)下载。
- en: What is JSON?
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是JSON？
- en: '**JavaScript Object Notation** (**JSON**) is a lightweight data-interchange
    text format. It is based on a subset of JavaScript, but it is completely language
    independent. JSON format is often used for data exchanges between web client and
    web server or web service. But, it can be used whenever you need to store or transmit
    relatively small amounts of data that can easily be represented as a combination
    of name-value pairs.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript 对象表示法**（**JSON**）是一种轻量级的数据交换文本格式。它基于 JavaScript 的一个子集，但它完全与语言无关。JSON
    格式常用于客户端和服务器或 Web 服务之间的数据交换。但是，当您需要存储或传输相对较小的数据，这些数据可以轻松地表示为键值对组合时，它也可以使用。'
- en: 'JSON is built on two structures, which are: a collection of name-value pairs
    and an ordered list of values. These structures are made from three data types:
    `object`, `array`, and `value`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 是基于两种结构构建的，这两种结构是：一组键值对集合和有序值列表。这些结构由三种数据类型组成：`对象`、`数组`和`值`。
- en: Object
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象
- en: 'An **object** is an unordered set of `name:value` pairs within braces (`{}`).
    After each name, there is a colon (`:`) and the name-value pairs are separated
    by a comma (`,`). The name is `string` type while the type of the value can be
    `string`, `object` and so on The following text gives an example of a JSON object,
    which contains some information about a student:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象**是无序的 `name:value` 对集合，用花括号（`{}`）括起来。每个名称后面都有一个冒号（`:`），名称值对用逗号（`,`）分隔。名称是
    `字符串` 类型，而值的类型可以是 `字符串`、`对象` 等等。以下文本给出了一个 JSON 对象的示例，其中包含有关学生的某些信息：'
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Array
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组
- en: An **array** is an ordered collection of values separated by a comma (`,`) within
    brackets (`[]`). The following text gives an example of a JSON array, which contains
    a list of students with their score in alphabetical order.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**数组**是有序值集合，值之间用逗号（`,`）分隔，并用方括号（`[]`）括起来。以下文本给出了一个 JSON 数组的示例，其中包含按字母顺序排列的学生及其分数列表。'
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Value
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 值
- en: A JSON **value** can be a `string` in double quotes, a `boolean` true or false,
    an `object`, an `array` or `null`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 的 **值** 可以是双引号中的 `字符串`，`布尔` 值 `true` 或 `false`，`对象`、`数组` 或 `null`。
- en: Why JSON?
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么选择 JSON？
- en: 'The **XML** (**Extensible Markup** **Language**) was released after the **SGML**
    (**Standardised Generalised Markup Language**, which was powerful and extensible
    but complex) and the **HTML** (**HyperText Markup** **Language**, a simple version
    of SGML focused on data presentation) to overcome the shortcomings of both languages.
    Its power, flexibility, and simplicity have favored its use in many applications
    for configuration management, storage, data transfer, and so on. With the advent
    of **AJAX** technologies, the use of XML was widespread in exchanges between browsers
    and web servers. But, it presented some limitations: XML documents are heavy in
    nature because of the duplication of information, loading, and handling of data
    can be complex and processing XML documents sometimes is browser dependent.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**XML**（**可扩展标记语言**，**Extensible Markup Language**）在**SGML**（**标准化通用标记语言**，它功能强大且可扩展，但复杂）和**HTML**（**超文本标记语言**，SGML
    的简单版本，专注于数据展示）之后发布，以克服这两种语言的不足。它的强大、灵活和简单使其在许多应用中受到青睐，如配置管理、存储、数据传输等。随着**AJAX**技术的出现，XML
    在浏览器和Web服务器之间的交换中得到了广泛应用。但是，它也带来了一些限制：由于信息重复、加载和处理数据复杂，XML 文档在本质上较重，有时处理XML文档还依赖于浏览器。'
- en: To provide a solution to these problems, the JSON format was developed as an
    alternative to XML. In fact, despite its portability and flexibility, JSON does
    not support namespaces, data access requires a knowledge of the document and until
    now, there is no **XSD** or **DTD** to validate the document's structure.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，JSON 格式被开发出来作为 XML 的替代品。实际上，尽管 JSON 具有可移植性和灵活性，但它不支持命名空间，数据访问需要了解文档，并且到目前为止，还没有
    **XSD** 或 **DTD** 来验证文档的结构。
- en: 'A simple comparison between XML and JSON data presentation is shown in the
    following table:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格展示了 XML 和 JSON 数据展示之间的简单比较：
- en: '| XML data presentation | JSON data presentation |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| XML 数据展示 | JSON 数据展示 |'
- en: '| --- | --- |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Java API for JSON processing
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Java JSON 处理API
- en: The Java API for JSON processing defines an API to process (`parse`, `generate`,
    `transform`, and `query`) JSON documents by using either the streaming API or
    the object model API.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Java JSON 处理API定义了一个API，通过使用流式API或对象模型API来处理（解析、生成、转换和查询）JSON文档。
- en: The streaming API
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 流式API
- en: The **streaming API** is for JSON as **StAX API** is for XML. In other words,
    the streaming API is an event-based JSON parsing. It parses a JSON file sequentially
    and fires an event whenever a it encounters a new tag in the stream (new value
    String, new start of objet, end of objet, new start of an array …). The example
    that follows shows us how to get contact information within the JSON data presented
    on the previous page.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**流式API**是针对JSON的，就像**StAX API**是针对XML的。换句话说，流式API是一种基于事件的JSON解析。它按顺序解析JSON文件，并在遇到流中的新标签时触发事件（新的值字符串、新的对象开始、对象结束、新的数组开始……）。下面的示例展示了如何获取上一页上展示的JSON数据中的联系信息。'
- en: 'Example of JSON processing using the streaming API:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用流式API处理JSON的示例：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The streaming API consists of five interfaces, one `enum` class, and two exceptions.
    All of them are contained in the `javax.json.stream` package. Among these interfaces,
    we have the `JsonParser` interface, which contains methods for step-by-step read-only
    access to JSON data, and the `JsonGenerator` interface, which provides methods
    to generate (write out) JSON step-by-step. Instances of these interfaces can be
    created respectively with `JsonParserFactory` and `JsonGeneratorFactory` factories.
    All events triggered by the streaming API are contained in the `JsonParser.Event`
    `enum` class.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 流式API由五个接口、一个枚举类和两个异常组成。所有这些都在`javax.json.stream`包中。在这些接口中，我们有`JsonParser`接口，它包含用于逐步只读访问JSON数据的方法，以及`JsonGenerator`接口，它提供逐步生成（写入）JSON的方法。这些接口的实例可以通过`JsonParserFactory`和`JsonGeneratorFactory`工厂分别创建。流式API触发的事件都包含在`JsonParser.Event`枚举类中。
- en: It's recommended to use the streaming API to parse large JSON files because,
    unlike the object model API, it does not require loading the whole file before
    processing. This ensures good memory management.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 建议使用流式API来解析大型JSON文件，因为与对象模型API不同，它不需要在处理之前加载整个文件。这确保了良好的内存管理。
- en: The object model API
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对象模型API
- en: The object model API is for JSON as **DOM API** is for XML. This means that
    it represents a JSON document as a tree structure in memory before giving the
    possibility to navigate in or query the document. This API provides the most flexible
    way to parse a JSON document by giving a random access to any data it contains.
    But in return, it requires more memory. That is why it is not suitable for large
    documents.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对象模型API是针对JSON的，就像DOM API是针对XML的。这意味着它在内存中将JSON文档表示为树结构，在提供导航或查询文档的可能性之前。此API通过提供对任何数据的随机访问，提供了解析JSON文档的最灵活方式。但作为交换，它需要更多的内存。这就是为什么它不适合大型文档。
- en: 'The object model API consists of thirteen interfaces, one class, one enum class
    and one exception. All of them are packages in `javax.json`. Among interfaces,
    we have: `JsonArrayBuilder` and `JsonObjectBuilder` to build JSON arrays and JSON
    objects respectively from scratch; `JsonArray` to access the ordered values of
    a JSON array as a list and `JsonObject` to access the values of a JSON object
    as a Map and `JsonBuilderFactory` to create `JsonObjectBuilder` or `JsonArrayBuilder`
    instances; `JsonReader` to read JSON from an input source and `JsonReaderFactory`
    to create `JsonReader` instances; `JsonWriter` to write JSON to an output source,
    and `JsonWriterFactory` to create `JsonWriter` instances. The following code demonstrates
    how to create an object model from scratch and access data within it.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对象模型API由十三个接口、一个类、一个枚举类和一个异常组成。所有这些都在`javax.json`包中。在接口中，我们有`JsonArrayBuilder`和`JsonObjectBuilder`，分别用于从头开始构建JSON数组和JSON对象；`JsonArray`用于将JSON数组的有序值作为列表访问，`JsonObject`用于将JSON对象的值作为Map访问，以及`JsonBuilderFactory`用于创建`JsonObjectBuilder`或`JsonArrayBuilder`实例；`JsonReader`用于从输入源读取JSON，`JsonReaderFactory`用于创建`JsonReader`实例；`JsonWriter`用于将JSON写入输出源，以及`JsonWriterFactory`用于创建`JsonWriter`实例。以下代码演示了如何从头创建对象模型并访问其中的数据。
- en: 'The following code is an example of JSON processing using the object model
    API:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是使用对象模型API处理JSON的示例：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Java API for WebSocket 1.0
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java API for WebSocket 1.0
- en: The Java API for WebSocket 1.0 was developed under JSR 356\. This section just
    gives you an overview of the API. The complete document specification (for more
    information) can be downloaded from [http://jcp.org/aboutJava/communityprocess/final/jsr356/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr356/index.html).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Java API for WebSocket 1.0是在JSR 356下开发的。本节仅为您提供一个API的概述。完整的文档规范（更多信息）可以从[http://jcp.org/aboutJava/communityprocess/final/jsr356/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr356/index.html)下载。
- en: What is WebSocket?
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是WebSocket？
- en: Originally called **TCPConnection** in previous versions of the HTML5 specification,
    **WebSocket** is an independent protocol built over the **TCP** (**Transmission
    Control Protocol**), which enables bidirectional and full-duplex communication
    between a client and a server.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML5规范的先前版本中最初被称为**TCPConnection**，**WebSocket**是一个建立在**TCP**（**传输控制协议**）之上的独立协议，它使得客户端和服务器之间能够进行双向和全双工通信。
- en: To open a WebSocket connection in web application , the web client uses an HTTP
    request to ask the server to upgrade the connection to a WebSocket connection.
    If the server supports and accepts the WebSocket protocol connection request,
    it will still return a response through HTTP. From that moment, the communication
    is established and both parties can send and receive data by using only the WebSocket
    protocol.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序中打开WebSocket连接时，Web客户端使用HTTP请求请求服务器将连接升级为WebSocket连接。如果服务器支持并接受WebSocket协议连接请求，它将通过HTTP返回响应。从那一刻起，通信就建立了，双方可以通过仅使用WebSocket协议来发送和接收数据。
- en: Why WebSocket?
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么选择WebSocket？
- en: Today, many web applications (instant messaging, trading platforms, some e-commerce
    platforms, online gaming, and so on) require a real-time communication between
    a client (browser) and a server. If you do not know, the HTTP protocol is a stateless
    half-duplex protocol. This means that, to access new information and update a
    web page, the client must always open a connection to the server, send a request,
    wait for the server response, and then close the connection. Thus, in a real-time
    context, the client will frequently send requests to the server in order to detect
    the presence of new data and many request-responses will be made even when there
    is no new information.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，许多Web应用程序（即时通讯、交易平台、一些电子商务平台、在线游戏等）需要在客户端（浏览器）和服务器之间进行实时通信。如果您不知道，HTTP协议是一个无状态的半双工协议。这意味着，为了访问新信息和更新网页，客户端必须始终打开到服务器的连接，发送请求，等待服务器响应，然后关闭连接。因此，在实时环境中，客户端将频繁地向服务器发送请求，以检测新数据的出现，并且即使没有新信息，也会进行许多请求-响应操作。
- en: 'To get around this problem, many solutions have been proposed. The most efficient
    was certainly long polling, which can be described like this: the client makes
    a request to the server; if there is data available, the server responds. Otherwise,
    it waits until there is new information before responding. After receiving the
    response, the client sends another request and so on. Although it seems good,
    this technique requires proprietary solutions (comet) and when data are frequently
    updated, the loop connection-request-response-disconnection may negatively impact
    the network.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，已经提出了许多解决方案。其中最有效的方法无疑是长轮询，它可以这样描述：客户端向服务器发送请求；如果服务器有数据可用，则服务器响应。否则，它将等待直到有新信息出现后再响应。在收到响应后，客户端发送另一个请求，如此循环。尽管看起来不错，但这种技术需要专有解决方案（彗星），并且当数据频繁更新时，循环连接-请求-响应-断开连接可能会对网络产生负面影响。
- en: WebSocket is not an HTTP-based technique, it is a protocol that provides a new
    and better way to overcome the shortcomings of the HTTP protocol in real-time
    communication between web client and web server/service.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket不是基于HTTP的技术，它是一个提供了一种新的、更好的方式来克服Web客户端和Web服务器/服务之间实时通信中HTTP协议的不足的协议。
- en: The WebSocket API
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebSocket API
- en: The Java API for WebSocket 1.0 defines a standard API to build WebSocket-driven
    applications in the Java EE platform.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Java API for WebSocket 1.0定义了一个标准API，用于在Java EE平台上构建WebSocket驱动的应用程序。
- en: 'A WebSocket application consists of two types of components called endpoints:
    a client endpoint and a server endpoint. A client endpoint is the component that
    initiates a WebSocket connection, while a server endpoint is waiting for connections.
    With the Java API for WebSocket 1.0, both component types can be created either
    programmatically or declaratively by using annotations. In this chapter we will
    only see annotated endpoints in a small student chat room application.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一个WebSocket应用程序由两种类型的组件组成，称为端点：客户端端点和服务器端点。客户端端点是发起WebSocket连接的组件，而服务器端点则是等待连接。使用Java
    API for WebSocket 1.0，这两种组件类型可以通过使用注解以编程方式或声明方式创建。在本章中，我们只将在一个小型学生聊天室应用程序中看到注解端点。
- en: Server endpoint
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器端点
- en: 'The following code demonstrates how to create a WebSocket endpoint that is
    able to accept client connections and send messages:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了如何创建一个WebSocket端点，该端点能够接受客户端连接并发送消息：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `@ServerEndpoint` annotation defines a server type endpoint and the path
    where it will be deployed. You will also notice that the API offers annotations
    to describe the method to be executed in each step of the endpoint lifecycle.
    The following table gives the list and the role of WebSocket endpoint lifecycle
    annotations.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ServerEndpoint` 注解定义了一个服务器类型端点以及它将被部署的路径。你也会注意到API提供了注解来描述端点生命周期中每个步骤要执行的方法。下表列出了WebSocket端点生命周期注解的列表及其作用。'
- en: 'The following table lists the WebSocket endpoint lifecycle annotations:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了WebSocket端点生命周期注解：
- en: '| Annotation | Role |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 注解 | 作用 |'
- en: '| --- | --- |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `@OnOpen` | Designates the method to be executed at the opening of a connection
    |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `@OnOpen` | 在连接打开时执行的方法 |'
- en: '| `@OnMessage` | Designates the method to be executed when a message is received
    |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `@OnMessage` | 在接收到消息时执行的方法 |'
- en: '| `@OnError` | Designates the method to be executed in case of a connection
    error |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `@OnError` | 在发生连接错误时执行的方法 |'
- en: '| `@OnClose` | Designates the method to be executed when the connection is
    closed |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `@OnClose` | 在连接关闭时执行的方法 |'
- en: 'Any message sent by a WebSocket client is intercepted by the `onMessage()`
    method, which takes the client session and the message as parameters (for other
    parameters that can be taken, please see the specification). Messages can be sent
    synchronously with the method `Session.getBasicRemote()` or asynchronously with
    the method `Session.getAsyncRemote()`. Each of these methods is used to send messages
    of type: `text`, `binary`, `object`, `ping`, and pong frames. The following codedemonstrates
    how to send a text message to all connected clients:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 任何由WebSocket客户端发送的消息都会被`onMessage()`方法拦截，该方法接收客户端会话和消息作为参数（有关可以接受的其它参数，请参阅规范）。消息可以通过`Session.getBasicRemote()`方法同步发送，或者通过`Session.getAsyncRemote()`方法异步发送。这些方法中的每一个都用于发送类型为：`text`、`binary`、`object`、`ping`和`pong`帧的消息。以下代码演示了如何向所有已连接客户端发送文本消息：
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The session object contains a variable to store some user-specific information.
    The code that follows demonstrates how to communicate with many customers by giving
    the name of the person who sent the message each time:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 会话对象包含一个变量用于存储一些用户特定的信息。下面的代码演示了如何通过每次发送消息的人的名字与许多客户进行通信：
- en: '[PRE22]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Client endpoint
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端端点
- en: Our client WebSocket endpoint is a `.jsp` web page (`websocketChatClient.jsp`)
    which is based on JavaScript code. As you can see, the client side has the same
    lifecycle methods and through the power of JSON, we can easily access and display
    messages sent by the server.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户端WebSocket端点是基于JavaScript代码的`.jsp`网页（`websocketChatClient.jsp`）。正如你所见，客户端具有相同的生命周期方法，通过JSON的力量，我们可以轻松访问并显示服务器发送的消息。
- en: 'The following code is an example of a web client WebSocket endpoint:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个Web客户端WebSocket端点的示例：
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we have tried to present the usefulness and implementation of
    the new specifications of Java EE 7\. In the coming chapters, we will analyze
    the improvements that have been made to the specifications inherited from Java
    EE 6 and use the opportunity to show how to integrate new specifications with
    existing ones.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们试图展示Java EE 7新规范的有用性和实现。在接下来的章节中，我们将分析继承自Java EE 6的规范所进行的改进，并利用这个机会展示如何将新规范与现有规范集成。
