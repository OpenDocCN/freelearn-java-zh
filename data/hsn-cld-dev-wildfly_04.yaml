- en: Tuning the Configuration of Your Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整您服务的配置
- en: In this chapter, you will learn how to configure your Swarm services. We will
    show you practical examples of different configuration tools that are available
    and how you can use them to steer the behavior of your applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何配置你的Swarm服务。我们将展示不同配置工具的实际示例，以及你如何使用它们来引导应用程序的行为。
- en: Modifying Swarm configuration
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改Swarm配置
- en: The fractions available in Swarm come with reasonable defaults. In the examples
    that we have seen so far, we didn't touch any configuration and yet we were able
    to see the applications working. Now, we will show you how you can tune the configuration
    of Swarm-created services.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Swarm中可用的分数都带有合理的默认值。在我们迄今为止看到的示例中，我们没有触摸任何配置，但我们仍然能够看到应用程序在工作。现在，我们将向你展示如何调整Swarm创建的服务配置。
- en: 'Swarm provides a set of tools that allows you to modify the configuration of
    your applications. In the following section, we will introduce them one by one
    and show their usage in different scenarios. Let''s start with the simplest one:
    system properties.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Swarm提供了一套工具，允许你修改应用程序的配置。在下一节中，我们将逐一介绍它们，并展示它们在不同场景中的使用。让我们从最简单的一个开始：系统属性。
- en: System properties
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统属性
- en: You are able to modify the configuration by specifying system properties. Let's
    return to our catalog-service. As you saw in the catalog-service examples from
    the last chapter, the JAX-RS application was listening for HTTP requests on port
    8080, which is the default configuration. Let's suppose that we want to change
    that port.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过指定系统属性来修改配置。让我们回到我们的catalog-service。正如你在上一章的catalog-service示例中所看到的，JAX-RS应用程序正在监听8080端口的HTTP请求，这是默认配置。让我们假设我们想要更改该端口。
- en: 'What we have to do is specify the `swarm.http.port` property during the application
    execution, as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做的是在应用程序执行期间指定`swarm.http.port`属性，如下所示：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When running the web browser, we can see that, indeed, the port on which the
    application runs has been changed:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行网络浏览器时，我们可以看到，确实，应用程序运行的端口已经发生了变化：
- en: '![](img/6f977254-4fb7-47db-9127-8c3f3a389086.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6f977254-4fb7-47db-9127-8c3f3a389086.png)'
- en: What has just happened here then? The undertow fraction has discovered that
    there is a configuration property that overrides the standard HTTP port, and it
    modifies the socket's configuration accordingly. As a result, the running application
    is using the specified port.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这里发生了什么？Undertow分数发现有一个配置属性覆盖了标准的HTTP端口，并相应地修改了套接字配置。结果，运行中的应用程序正在使用指定的端口。
- en: Each fraction contains a group of properties that can be used to configure it.
    You will be able to find them in Swarm documentation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每个分数包含一组可以用来配置它的属性。你将能在Swarm文档中找到它们。
- en: The method of editing the properties is very simple and can be sufficient in
    many cases, but the entry point to the more complex programmatic configurations
    may be more feasible let's learn how to do it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑属性的方法非常简单，在许多情况下可能足够，但更复杂的程序化配置的入口点可能更可行，让我们学习如何做到这一点。
- en: Implementing your own main class
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现自己的`main`类
- en: Each Swarm service contains the `main` class which is responsible for creating
    and configuring a runtime for the service and running service code on it. Swarm
    creates the default implementation of the `main` class (in fact, the default class
    was used in all the examples till now), but you are able to provide your own implementation
    of the `Main` class if you want to modify the default behavior. An example of
    such modification may be providing an additional configuration.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Swarm服务都包含一个`main`类，该类负责为服务创建和配置运行时，并在其上运行服务代码。Swarm创建了`main`类的默认实现（实际上，到目前为止所有示例都使用了默认类），但如果你想要修改默认行为，你可以提供自己的`Main`类实现。这种修改的一个例子可能是提供额外的配置。
- en: 'Let''s return to the catalog-service. Let''s recall its current operation:
    we created a `jaxrs` resource and injected the service providing the invitation
    message using CDI. Now, let''s modify this example to provide our own `main` class.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到catalog-service。让我们回顾一下它的当前操作：我们创建了一个`jaxrs`资源，并使用CDI注入了提供邀请消息的服务。现在，让我们修改这个示例以提供我们自己的`main`类。
- en: 'Examples reference: `chapter4/catalog-service-first-main`'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 示例参考：`chapter4/catalog-service-first-main`
- en: 'In order to do it, we have to modify the `pom.xml` of the catalog-service in
    the following way:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们必须按照以下方式修改catalog-service的`pom.xml`文件：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have to modify the Swarm plugin so that its configuration contains the class
    with our `main` method (1). When using your own `main` method, you have to specify
    manually on which fractions your service depends (2).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须修改Swarm插件，使其配置包含具有我们`main`方法的类（1）。当使用自己的`main`方法时，你必须手动指定你的服务依赖于哪些部分（2）。
- en: 'Now, let''s take a look at the `org.packt.swarm.petstore.Main` class, which
    implements the `main` method:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看实现了`main`方法的`org.packt.swarm.petstore.Main`类：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We created the instance of the `org.wildfly.swarm.Swarm` class (1). The `start`
    method has created the container, and the `deploy` method has deployed the created
    archive on it. We have also created (2) the log output to prove that the class
    is indeed working. We will look at the `Swarm` class in greater detail in just
    a moment, but before that here is the mentioned proof:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了`org.wildfly.swarm.Swarm`类的实例（1）。`start`方法创建了容器，`deploy`方法将创建的存档部署到容器上。我们还创建了（2）日志输出以证明该类确实在运行。我们将在稍后更详细地查看`Swarm`类，但在那之前，这里是有提到的证明：
- en: '![](img/13651764-af24-43ea-8d63-93743ab53505.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/13651764-af24-43ea-8d63-93743ab53505.png)'
- en: The message is there, and the method has been executed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 消息已经存在，方法已经执行。
- en: The Swarm class
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swarm类
- en: As we have seen in the preceding section, if you are implementing your own `main`
    method, you will interact with the `org.wildfly.swarm.Swarm` class. This class
    is responsible for instantiating the container based on the provided configuration
    and creating and deploying the archive with your application. Both of those steps
    can be modified by operations on the `Swarm` class. Let's learn more about them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中看到的，如果你正在实现自己的`main`方法，你将与`org.wildfly.swarm.Swarm`类进行交互。这个类负责根据提供的配置实例化容器，并创建和部署包含你的应用程序的存档。这两个步骤都可以通过`Swarm`类的操作进行修改。让我们更深入地了解它们。
- en: Providing the configuration
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供配置
- en: The `Swarm` class provides a group of methods that allow you to modify the configuration
    using the Java API, such as `fraction`, `socketBinding`, and `outboundSocketBinding`.
    The latter two methods, as their names imply, allow you to create your own socket
    binding and outbound socket binding groups. The method that is the most interesting
    to us is the `fraction` method. It takes one argument for the `org.wildfly.swarm.spi.api.Fraction`
    class implementations—the `fraction`. You will be able to modify and reconfigure
    all the fractions and provide them to Swarm. Let's get a first grasp of this functionality
    on our favorite example, that is, changing the HTTP port of the `CatalogService`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`Swarm`类提供了一组方法，允许你使用Java API修改配置，例如`fraction`、`socketBinding`和`outboundSocketBinding`。后两个方法，正如它们的名称所暗示的，允许你创建自己的套接字绑定和出站套接字绑定组。对我们来说最有趣的方法是`fraction`方法。它接受一个参数，即`org.wildfly.swarm.spi.api.Fraction`类实现的`fraction`。你将能够修改和重新配置所有部分，并将它们提供给Swarm。让我们通过我们最喜欢的示例，即更改`CatalogService`的HTTP端口，来初步了解这个功能。'
- en: 'Examples reference: `chapter4/catalog-service-config-main`'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 示例参考：`chapter4/catalog-service-config-main`
- en: 'Firstly, we have to add the `UndertowFraction` dependency to our `pom.xml`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须将`UndertowFraction`依赖项添加到我们的`pom.xml`中：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Secondly, let''s reimplement the `main` method:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，让我们重新实现`main`方法：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you run the preceding code, you will indeed see the same result as in the
    property example: the application is running on the `12345` port. So, what has
    just happened?'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行前面的代码，你确实会看到与属性示例中相同的结果：应用程序正在`12345`端口上运行。那么，刚才发生了什么？
- en: At the beginning of the preceding code, we created the `UndertowFraction` (1)
    and run the `applyDefaults` method (2). If the `fraction` is automatically created
    by Swarm, the default configuration is applied to it. On the other hand, if you
    create the `fraction` manually, you are creating the empty `fraction` object with
    no configuration. That's what the `applyDefaults`method is for. It applies the
    default configuration to the `fraction` object. As a result, whenever you don't
    want to create the configuration from scratch and just modify it, you have to
    invoke the `applyDefaults`method first and apply your configuration changes after
    that. That's exactly the scenario in our simple example. We didn't want to create
    the full configuration manually. Instead, we only wanted to change the one configuration
    parameter—the listening port. As a result, we applied the default configuration
    to the `fraction` object, and after that, we only changed the HTTP port.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一段代码的开始部分，我们创建了`UndertowFraction`（1）并运行了`applyDefaults`方法（2）。如果`fraction`是由Swarm自动创建的，则默认配置将应用于它。另一方面，如果你手动创建`fraction`，你将创建一个没有任何配置的空`fraction`对象。这就是`applyDefaults`方法的作用。它将默认配置应用于`fraction`对象。因此，每次你不想从头开始创建配置而只是修改它时，你必须首先调用`applyDefaults`方法，然后在此之后应用你的配置更改。这正是我们简单示例中的情况。我们不想手动创建完整的配置。相反，我们只想更改一个配置参数——监听端口。因此，我们将默认配置应用于`fraction`对象，然后只更改了HTTP端口。
- en: We created the `UndertowFraction` object that represents the configuration of
    the Undertow fraction. We have to provide this configuration to the container
    that will run the service. In order to do it, we used Swarm's `fraction` method
    (4). It is worth mentioning here that the application still consists of many `fraction`s
    but we have provided only the `Undertowfraction` configuration. If we don't add
    a customized `fraction` configuration to the `Swarm` class, then the default configuration
    is used. Swarm is still going to bootstrap CDI and JAX-RS among others, but their
    configuration will be created automatically, just as it was in our first example.
    On the other hand, the `Undertowconfiguration` object is provided by us manually
    and Swarm will use it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了代表Undertow分片配置的`UndertowFraction`对象。我们必须将此配置提供给将运行服务的容器。为了做到这一点，我们使用了Swarm的`fraction`方法（4）。这里值得提一下，应用程序仍然由许多`fraction`s组成，但我们只提供了`Undertowfraction`配置。如果我们不向`Swarm`类添加自定义的`fraction`配置，则将使用默认配置。Swarm仍然会启动CDI和JAX-RS等，但它们的配置将自动创建，就像我们第一个例子中那样。另一方面，`Undertowconfiguration`对象是由我们手动提供的，Swarm将使用它。
- en: After the application is configured, we are ready to start and deploy (5) it,
    just as we did in the previous example. If we run our application, we will see
    the same result that we obtained in the example that used the system property—the
    application runs on port `12345`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序配置完成后，我们准备启动和部署（5）它，就像我们在前面的例子中所做的那样。如果我们运行我们的应用程序，我们将看到我们在使用系统属性的那个例子中获得的结果——应用程序在端口`12345`上运行。
- en: However, in the property example, we have to add only one configuration parameter,
    and, here, we have to do quite a lot of stuff. You may ask whether you can use
    the Java API to provide a more elaborate configuration but still resort to the
    properties in cases such as an HTTP port; that's a good question. Let's find out.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在属性示例中，我们只需要添加一个配置参数，而在这里，我们必须做很多事情。你可能想知道是否可以使用Java API提供更详细的配置，但在像HTTP端口这样的情况下仍然求助于属性；这是一个好问题。让我们找出答案。
- en: Using your own main along with properties
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自己的主程序以及属性
- en: 'Let''s modify the `Main` class to the simplest possible form:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`Main`类修改为最简单的形式：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, run it with the HTTP port property:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用HTTP端口属性运行它：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Also, we will check in in the browser:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将在浏览器中检查：
- en: '![](img/3b021482-ea66-41f4-8e21-6820b71ea03a.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3b021482-ea66-41f4-8e21-6820b71ea03a.png)'
- en: Well, it didn't work. So, as it just turned out, you are not able to do it,
    sorry.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，它不起作用。所以，正如刚刚发生的那样，你无法做到这一点，很抱歉。
- en: 'I am kidding, of course. You can do it, but as it turned out, we have, completely
    accidentally, made a small mistake in our code from the last listing. What is
    wrong with it? The system properties with which the `main` method was executed
    were not propagated to Swarm in any way. Consider that, on the other hand, we
    have written our code in the following way:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我当然是在开玩笑。你可以做到，但正如我们所知，我们完全意外地在上一列表中的代码中犯了一个小错误。问题出在哪里？执行`main`方法时使用的系统属性没有以任何方式传播到Swarm。考虑另一方面，我们是这样编写我们的代码的：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The application will use specified properties and present the application behavior
    we will be able to see that it is working correctly.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将使用指定的属性并展示应用程序的行为，我们将能够看到它是否正在正确运行。
- en: To sum up, you are now able to mix the Java API with a properties-based configuration,
    but you have to remember to create Swarm with `main` function arguments.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，你现在可以将Java API与基于属性的配置混合使用，但必须记住使用带有`main`函数参数创建Swarm。
- en: Java API
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java API
- en: Let's return to the `Swarm` class. We have already seen that we are able to
    create the fraction class with our own configuration and hand it on to the `Swarm`
    class. In fact, we are able to steer the whole Swarm configuration programmatically.
    To create a more elaborate example, let's extend our `CatalogService` so that
    it stores its data in a database.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`Swarm`类。我们已经看到，我们能够使用自己的配置创建分数类并将其传递给`Swarm`类。实际上，我们能够通过编程方式控制整个Swarm配置。为了创建一个更详细的示例，让我们扩展我们的`CatalogService`，使其将数据存储在数据库中。
- en: 'Examples reference: `chapter4/catalog-service-database`.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 示例参考：`chapter4/catalog-service-database`。
- en: 'Let''s start with editing the `pom.xml`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从编辑`pom.xml`开始：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have added four new Maven dependencies. In order to configure our own `datasource`,
    we have to add the `datasource`s fraction (1). As we will use the Java Persistence
    API, we will need both the `jpa` fraction and the JPA API (2). We will also use
    `h2` in-memory database, and we need its `dependency` too (3). Finally, we provide
    the `dependency` to `h2` database (4).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了四个新的Maven依赖项。为了配置我们自己的`datasource`，我们必须添加`datasource`分数（1）。由于我们将使用Java持久化API，我们需要`jpa`分数和JPA
    API（2）。我们还将使用`h2`内存数据库，并且需要它的`dependency`（3）。最后，我们提供了`dependency`给`h2`数据库（4）。
- en: 'As we are going to persist the data about pets available in the store, we have
    to modify the `Item` class so that it is an entity, a JPA object representing
    a state that will be persisted in the relational database:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们打算持久化商店中可用的宠物数据，我们必须修改`Item`类，使其成为一个实体，一个表示将在关系数据库中持久化的状态的JPA对象：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is a simple `jpa` entity (1) with the corresponding table named `"ITEM"`
    (2). We have created the `NamedQuery` (3) to find pets by `name`. We have added
    the database ID field (4). Furthermore, we have added the `@Column` annotations
    so that `name` and `quantity` fields are persisted to the database (5).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的`jpa`实体（1），对应的表名为`"ITEM"`（2）。我们创建了`NamedQuery`（3）来通过`name`查找宠物。我们添加了数据库ID字段（4）。此外，我们还添加了`@Column`注解，以便`name`和`quantity`字段被持久化到数据库中（5）。
- en: 'We would also need to modify our `CatalogService` class so that it can load
    pet data from the database:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须修改我们的`CatalogService`类，使其能够从数据库中加载数据：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We referenced the `CatalogPU`persistence context (we will configure it in a
    moment) and used a named query defined in an `Item` class to find pets by `id`
    (2).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引用了`CatalogPU`持久化上下文（我们将在稍后进行配置）并使用在`Item`类中定义的命名查询通过`id`查找宠物（2）。
- en: 'OK, let''s move to the interesting part. We will create and use in-memory `h2`
    `datasource`; The following is the code to do so:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们转到有趣的部分。我们将创建并使用内存中的`h2`数据源；以下是如何做到这一点的代码：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The configuration of the `datasourcesFraction` is a bit more complex than the
    simple port change—let's look at it in greater detail. In (1), we defined the
    **Java Database Connectivity** (**JDBC**) driver named `"h2"` and provided lambda
    expression implementing the `org.wildfly.swarm.config.JDBCDriverConsumer` class—this
    is basically the acceptor that allows you to apply the additional configuration
    to the created JDBC driver. The analogous situation happens in (2). Here, we created
    the `CatalogDS` datasource and applied an additional configuration using the `org.wildfly.swarm.config.DatasourcesConsumer`
    class.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`datasourcesFraction`的配置比简单的端口更改要复杂一些，让我们更详细地看看。在（1）中，我们定义了一个名为`"h2"`的**Java数据库连接（JDBC**）驱动程序，并提供了实现`org.wildfly.swarm.config.JDBCDriverConsumer`类的lambda表达式——这基本上是一个接受者，允许你将额外的配置应用到创建的JDBC驱动程序上。在（2）中发生类似的情况。在这里，我们创建了`CatalogDS`数据源，并使用`org.wildfly.swarm.config.DatasourcesConsumer`类应用了额外的配置。'
- en: As you can see in the preceding code, this configuration is not as trivial as
    the `Undertowport` change, but don't worry. Swarm comes with the current Java
    API library with each release, and as all the configuration options are described
    there, you don't have to rely on guesswork while configuring your application
    using this method [1].
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，这个配置并不像`Undertowport`更改那样简单，但不用担心。Swarm在每个版本中都附带当前的Java API库，并且由于所有配置选项都在那里描述，你不需要在配置应用程序时依赖猜测。[1]
- en: We still have to do more things to make our example work, such as provide `persistence.xml`
    and fill our database with a group of messages on startup.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要做更多的事情来使我们的示例工作，比如提供`persistence.xml`并在启动时填充数据库中的一组消息。
- en: 'Let''s start with the first thing. The following is our `persistence.xml` file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一件事开始。以下是我们`persistence.xml`文件：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding configuration, we created the persistent-unit named `CatalogPU`,
    which uses `JTA` transactions (1), made the persistent-unit use the `CatalogDS`
    datasource created earlier (2), provided a configuration that will make the database
    create the new database on the deployment and delete it on undeployment using
    entity classes metadata (3), and, finally, provided the load script (4).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述配置中，我们创建了一个名为`CatalogPU`的持久单元，它使用`JTA`事务（1），使持久单元使用之前创建的`CatalogDS`数据源（2），提供了一个配置，将使数据库在部署时创建新数据库，在卸载时使用实体类元数据删除它（3），最后，提供了加载脚本（4）。
- en: 'The problem is that we don''t have it yet; let''s add it then:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是我们还没有它；让我们先添加它：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After all that is finally done, we should be able to see our application working.
    Let''s try it now:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些工作都最终完成之后，我们应该能够看到我们的应用程序正在运行。现在让我们试试：
- en: '![](img/648bbecc-8f5c-49dd-a3df-6bbe60bcc966.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/648bbecc-8f5c-49dd-a3df-6bbe60bcc966.png)'
- en: 'Oops! Instead of the browser page with a message, an awful red log appears.
    What went wrong? Let''s take a look at the first read message: `"WFLYJCA0041:
    Failed to load module for driver [com.h2database.h2]"`. True, as this is a custom
    driver module, we have to add it to our application manually. How are we able
    to do that? That is simple too.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '哎呀！不是浏览器页面上的消息，而是出现了一个可怕的红色日志。出了什么问题？让我们看看第一条读取消息："`WFLYJCA0041: Failed to
    load module for driver [com.h2database.h2]`"。确实如此，因为这个是一个自定义驱动模块，我们必须手动将其添加到我们的应用程序中。我们如何做到这一点呢？其实很简单。'
- en: 'To add an additional custom module to our application, we have to add it to
    the `resources` directory of our application:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个额外的自定义模块添加到我们的应用程序中，我们必须将其添加到应用程序的`resources`目录：
- en: '![](img/b8972de7-bbec-4945-92dc-149c1ccd599e.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b8972de7-bbec-4945-92dc-149c1ccd599e.jpg)'
- en: 'As shown in the preceding screenshot, the `modules` directory has to be placed
    inside the Maven''s `resources` directory inside our application, and the directory
    structure has to match the module name. Let''s look at the module descriptor:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，`modules`目录必须放置在我们的应用程序中Maven的`resources`目录内部，并且目录结构必须与模块名称匹配。让我们看看模块描述符：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To recall, this is the same kind of descriptor that we presented in [Chapter
    2](c00cfc93-f395-446e-9132-242f02216783.xhtml), *Getting Familiar with WildFly
    Swarm*, where we described the concept of modular classloading. In the preceding
    file, we are creating a module with the `"com.h2database.h2"` name (1), specifying
    that the only resource is the `h2` database artifact. Note that we are referencing
    the artifact using Maven coordinates. Finally, we have to specify all the module
    dependencies (3).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回忆，这和我们之前在[第二章](c00cfc93-f395-446e-9132-242f02216783.xhtml)《熟悉WildFly Swarm》中介绍的是同一种描述符，我们描述了模块化类加载的概念。在上一个文件中，我们创建了一个名为`"com.h2database.h2"`的模块（1），指定唯一资源是`h2`数据库组件。请注意，我们使用Maven坐标引用了该组件。最后，我们必须指定所有模块依赖项（3）。
- en: 'Let''s build and run the application again. We are indeed able to look up our
    pets now:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次构建并运行应用程序。现在我们确实能够查找我们的宠物了：
- en: '![](img/62112f99-add2-46fd-a8aa-b14e34aaf609.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/62112f99-add2-46fd-a8aa-b14e34aaf609.png)'
- en: We are indeed, able to search pets by `id` now.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在确实能够通过`id`搜索宠物了。
- en: Let's continue with the `Swarm` class usage. The next thing that we will look
    at is its `deploy` method.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用`Swarm`类的用法。接下来我们将查看它的`deploy`方法。
- en: Modifying your archive
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改你的存档
- en: In our previous examples, each time we created the `Swarm` instance and applied
    some configuration on top of it, we used the no-argument `deploy` method. This
    method takes the archive generated by the standard Maven build and deploys it
    on the previously configured container. This is not the only version of the `deploy`
    method, though. You are able to create your own archive (or archives) and deploy
    them to the Swarm container. How? It is possible using the `ShrinkWrap` API.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的示例中，每次我们创建`Swarm`实例并在其上应用一些配置时，我们都使用了无参数的`deploy`方法。该方法接受由标准Maven构建生成的存档，并将其部署到之前配置的容器上。尽管如此，`deploy`方法不止这一种版本。你可以创建自己的存档（或存档），并将它们部署到Swarm容器中。如何做到？可以使用`ShrinkWrap`
    API。
- en: The ShrinkWrap API
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ShrinkWrap API
- en: If you have ever worked with WildFly AS, and, especially, its testing framework
    Arquillian, you are probably also familiar with the `ShrinkWrap` API, which is
    used to build application archives before they are deployed in the test environment.
    However, if you have never used it, don't worry—the API is very simple and straightforward.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经与WildFly AS一起工作过，尤其是它的测试框架Arquillian，你可能也对`ShrinkWrap` API很熟悉，该API用于在测试环境中部署应用程序存档之前构建应用程序存档。然而，如果你从未使用过它，不要担心——API非常简单直观。
- en: The central class in the API is the `org.jboss.shrinkwrap.api.Archive`instance.
    It is an abstract class that represents the archive. The concrete implementations
    that interest us the most are `org.jboss.shrinkwrap.api.spec.JavaArchive` and
    `org.jboss.shrinkwrap.api.spec.WebArchive` that represent JARs and WARs as you
    probably have guessed. The API is simple; it contains a bunch of methods that
    allow you to add resources to the archive. Let's see its operation in practice.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: API中的核心类是`org.jboss.shrinkwrap.api.Archive`实例。它是一个抽象类，代表存档。我们最感兴趣的实体实现是`org.jboss.shrinkwrap.api.spec.JavaArchive`和`org.jboss.shrinkwrap.api.spec.WebArchive`，正如你可能猜到的，它们代表JAR和WAR。API很简单；它包含了一组方法，允许你向存档中添加资源。让我们看看它在实际操作中的表现。
- en: For the sake of this example, let's return to the first `CatalogService` version,
    which contained only the `jaxrs` resource and application.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个示例，让我们回到第一个`CatalogService`版本，它只包含`jaxrs`资源和应用程序。
- en: 'Examples reference: `chapter4/catalog-service-shrinkwrap`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 示例参考：`chapter4/catalog-service-shrinkwrap`
- en: 'To see the `ShrinkWrap` in action, we have to modify the `pom.xml`file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到`ShrinkWrap`的实际应用，我们必须修改`pom.xml`文件：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As we are providing our own `main`, we have to explicitly add the dependency
    on the `jaxrs` fraction (1). We also have to add the method to the Swarm plugin
    configuration (2).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们提供了自己的`main`方法，我们必须显式添加对`jaxrs`分片的依赖（1）。我们还需要将方法添加到Swarm插件配置（2）中。
- en: 'Let''s look at the `ShrinkWrap` API usage in the `org.packt.swarm.petstore.Main`
    class:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`ShrinkWrap` API在`org.packt.swarm.petstore.Main`类中的使用：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We created the web archive (1), added the classes that our example consists
    of (2), and deployed them on the created container (3). As a result, we have manually
    done the same thing that Swarm does for us automatically.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了Web存档（1），添加了我们的示例所包含的类（2），并将它们部署到创建的容器上（3）。结果，我们手动完成了Swarm为我们自动完成的事情。
- en: We have used the `addClass` method to add created classes to the archive. In
    a similar way, you are able to use other `ShrinkWrap` API methods. The `org.jboss.shrinkwrap.api.spec.JavaArchive`class
    apart from the native archive methods (`add` and `addDirectory)`) contains the
    methods that make it easy to work with classes (`addClass` and `addPackage`),
    resources (`addResource`), and manifests (`setManifest` and `addManifestResource`).
    The `org.jboss.shrinkwrap.api.spec.WebArchive`class additionally adds web resource
    methods (`addWebResource` and `setWebXML`). As in the preceding example, using
    those methods is usually straightforward, but in the case of any doubts, you can
    take advantage of the `ShrinkWrap` Java API.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了`addClass`方法将创建的类添加到存档中。以类似的方式，你也能够使用其他`ShrinkWrap` API方法。`org.jboss.shrinkwrap.api.spec.JavaArchive`类除了包含原生存档方法（`add`和`addDirectory`）外，还包含使处理类（`addClass`和`addPackage`）、资源（`addResource`）和清单（`setManifest`和`addManifestResource`）变得容易的方法。`org.jboss.shrinkwrap.api.spec.WebArchive`类还额外增加了网络资源方法（`addWebResource`和`setWebXML`）。与前面的例子一样，使用这些方法通常很简单，但在任何疑问的情况下，你可以利用`ShrinkWrap`
    Java API。
- en: Obtaining the default archive
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取默认存档
- en: 'Isn''t `ShrinkWrap` too tedious to be useful in any real-life circumstances?
    After all, we don''t want to manually add all classes and resources from our application
    to the archive. You don''t have to worry about it—you will be able to obtain default
    deployment from the Swarm instance:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShrinkWrap`不是太繁琐，以至于在现实生活中的任何情况下都派得上用场吗？毕竟，我们不想手动将应用程序中的所有类和资源添加到存档中。你不必担心这个问题——你将能够从Swarm实例中获取默认部署：'
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you see in the preceding example, we were able to obtain the default deployment
    by invoking the `createDefaultDeployment()` method. After we have it, we can only
    additional needed resources to it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前一个例子所示，我们通过调用`createDefaultDeployment()`方法获得了默认部署。在获得它之后，我们只能向其中添加额外的所需资源。
- en: Swarm ShrinkWrap extensions
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swarm ShrinkWrap扩展
- en: Swarm adds its own classes to complement the `ShripWrap` API. Let's introduce
    them.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Swarm添加了自己的类来补充`ShrinkWrap` API。让我们来介绍它们。
- en: JARArchive
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JARArchive
- en: The `org.wildfly.swarm.spi.api.JARArchive` is an alternative to the `JavaArchive`.
    Apart from all functions provided by it, the `JARArchive` adds an API to easily
    add modules, Maven dependencies, and service provider implementations.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`org.wildfly.swarm.spi.api.JARArchive`是`JavaArchive`的替代品。除了它提供的所有功能外，`JARArchive`还增加了一个API，可以轻松添加模块、Maven依赖项和服务提供者实现。'
- en: WARArchive
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WARArchive
- en: As the `WebArchive` adds a functionality on top of `JavaArchive`, the `WARArchive`
    adds new features on top of the `JARArchive`. Apart from an interface that allows
    working with web resources, it adds the possibility to easily add the static web
    content. Let's look at this for an example.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`WebArchive`在`JavaArchive`的基础上增加了功能，`WARArchive`则在`JARArchive`的基础上增加了新特性。除了提供一个用于处理网络资源的接口外，它还增加了轻松添加静态网络内容的功能。让我们通过一个例子来看看。
- en: As usual, we need the `pom.xml:`
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们需要`pom.xml`文件：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As we are using our own `main`, we will need to add an `undertow` fraction dependency
    (1) and configure the `main` method (2).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用自己的`main`，我们需要添加一个`undertow`分数依赖（1）并配置`main`方法（2）。
- en: 'Our static content will be a simple Hello World page:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的静态内容将是一个简单的Hello World页面：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We will add this class to the `webpage` directory inside our application''s
    resources:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个类添加到应用程序资源中的`webpage`目录下：
- en: '![](img/ab8d6a54-6b03-42d0-9369-61741ae8b6a7.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ab8d6a54-6b03-42d0-9369-61741ae8b6a7.png)'
- en: 'The `main` class looks like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`类看起来是这样的：'
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We have created the `WARArchive` and invoked the `staticContent` method. When
    we open the web browser, we will see the Hello World page:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了`WARArchive`并调用了`staticContent`方法。当我们打开网络浏览器时，我们将看到Hello World页面：
- en: '![](img/a42fac63-e643-4e5c-a393-d0a77453b151.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a42fac63-e643-4e5c-a393-d0a77453b151.jpg)'
- en: What has happened? The static content method has copied all non-Java files from
    the `webpage` directory (one file in our example) to the created archive so that
    they can be seen by `undertow`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？静态内容方法已经将`webpage`目录（在我们的例子中是一个文件）中的所有非Java文件复制到了创建的存档中，以便它们可以被`undertow`看到。
- en: JAXRSArchive
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JAXRSArchive
- en: The last type of Swarm archive that we want to look at right now is the `org.wildfly.swarm.JAXRSArchive`.
    This archive adds the ability to create a default JAX-RS application with the
    application path set to `"/"`. Till now, we have been doing this manually in all
    our examples. With the JAX-RS Archive, this class will be added automatically.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想要查看的Swarm存档的最后一类是`org.wildfly.swarm.JAXRSArchive`。这个存档增加了创建默认JAX-RS应用程序的能力，应用程序路径设置为`"/"`。到目前为止，我们一直在所有示例中手动完成这项操作。有了JAX-RS存档，这个类将自动添加。
- en: XML configuration
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XML配置
- en: Although Java API is convenient, this is not the only option that we have. If
    you are familiar with the WildFly XML configuration, or if you are migrating your
    application to Swarm and have a working XML file, you don't have to translate
    it to Java API as you can use it directly.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Java API很方便，但这并不是我们唯一的选择。如果你熟悉WildFly的XML配置，或者如果你正在将你的应用程序迁移到Swarm并且有一个可工作的XML文件，你不需要将其转换为Java
    API，因为你可以直接使用它。
- en: 'Examples reference: `chapter4/catalog-service-xmlconfig`'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 示例参考：`chapter4/catalog-service-xmlconfig`
- en: 'Let''s return to our database example. You may configure the datasource using
    XML. In such a case, the XML configuration will look like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的数据库示例。你可以使用XML配置数据源。在这种情况下，XML配置看起来像这样：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We have to add this configuration file to the `resources` directory:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将此配置文件添加到`resources`目录中：
- en: '![](img/b7410646-ea8f-4454-aef5-44462e54287d.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b7410646-ea8f-4454-aef5-44462e54287d.png)'
- en: 'Finally, we also have to tell Swarm to use the configuration file. The following
    is the modified `Main` class:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还需要告诉Swarm使用配置文件。以下是被修改的`Main`类：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We have obtained the classloader to be able to locate the configuration file(1).
    After reading the file, we instructed Swarm to use the configuration from it (2).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取了类加载器以便定位配置文件（1）。在读取文件后，我们指示Swarm使用其中的配置（2）。
- en: However, we have used the whole configuration file—will Swarm use all the subsystems
    now? The answer is no; only the fractions, whose dependencies have been specified
    will be added to the container. Swarm, given the XML file, will read only the
    configuration of those subsystems whose fractions constitute it. You are also
    able to provide a file with only those subsystems that you want to configure using
    XML.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们已经使用了整个配置文件——Swarm现在会使用所有子系统吗？答案是：不会；只有那些已经指定了依赖关系的部分才会被添加到容器中。给定XML文件，Swarm只会读取构成它的那些子系统的配置。你也可以提供一个只包含你想要使用XML配置的子系统的文件。
- en: YAML configuration
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: YAML配置
- en: Another way in which you can provide Swarm configuration is YAML data serialization
    language.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过YAML数据序列化语言提供Swarm配置。
- en: Once more, let's start with the port-change example. We will start again with
    JAX-RS example and modify it to use the YAML configuration.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们从端口更改示例开始。我们将再次从JAX-RS示例开始，并修改它以使用YAML配置。
- en: 'First, let''s create the HTTP-`port.yml` configuration file inside the `resources`
    directory:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在`resources`目录内创建HTTP-`port.yml`配置文件：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The nested properties are translated to flat properties by Swarm. So, the property
    specified by the preceding file is translated to `swarm.http.port`, which we know
    well already.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Swarm会将嵌套属性转换为平面属性。因此，前面文件中指定的属性被转换为`swarm.http.port`，这是我们非常熟悉的。
- en: 'To use the following configuration, we have to modify our `Main` class:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用以下配置，我们必须修改我们的`Main`类：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After obtaining the configuration from the `classpath` (1), we informed Swarm
    to use it using the `withConfig` method. That's it; now, Swarm will use the `12345`
    port.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在从`classpath`（1）获取配置后，我们使用`withConfig`方法通知Swarm使用它。就是这样；现在，Swarm将使用`12345`端口。
- en: Project stages
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目阶段
- en: The strength of the YAML configuration is its ability to provide different groups
    properties for different project stages. Again, let's take a look at the example
    first.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: YAML配置的强大之处在于它能够为不同的项目阶段提供不同的组属性。再次，让我们先看看示例。
- en: 'The new configuration file looks like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 新的配置文件看起来像这样：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The different parts of the file gather the configuration for different project
    stages. The first group is the default configuration. It is used when no stage
    name is provided. The other two specify the configurations for test and `QA` stages.
    However, how do you know the stage in which the application currently runs? You
    have to provide the `swarm.project.stage` property. So, consider that, for example,
    we run the preceding example with the following command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的不同部分收集了不同项目阶段的配置。第一组是默认配置。当没有提供阶段名称时使用。其他两个指定了测试和 `QA` 阶段的配置。然而，你如何知道应用程序当前运行在哪个阶段？你必须提供
    `swarm.project.stage` 属性。所以，例如，我们使用以下命令运行前面的例子：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Then, we will be able to access our application on the `12346` port.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将能够通过 `12346` 端口访问我们的应用程序。
- en: As you will have noticed in the preceding code, the YAML configuration makes
    it easy to create the configuration for different environments and choose what
    group of properties should be used using a simple command-line argument.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在前面的代码中注意到的那样，YAML配置使得为不同的环境创建配置以及使用简单的命令行参数选择应使用哪些属性组变得很容易。
- en: YAML database configuration
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: YAML 数据库配置
- en: 'As an another YAML config example, we are going to show you how to configure
    the datasources with the YAML configuration file. Let''s take a look:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个 YAML 配置示例，我们将向你展示如何使用 YAML 配置文件配置数据源。让我们看看：
- en: 'Examples reference: `chapter 4/catalog-service-database-ymlconfig`'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 示例参考：`第4章/catalog-service-database-ymlconfig`
- en: 'The example is very similar to the XML configuration example. We have to exchange
    the configuration file for its YAML equivalent:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子与 XML 配置示例非常相似。我们必须用其 YAML 等价物交换配置文件：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And also need to make the `Main` class use it (1):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要让 `Main` 类使用它（1）：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We are going to use such configurations a lot in the examples throughout the
    book.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的整个示例中大量使用此类配置。
- en: Mixing the configurations
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置的混合使用
- en: 'Now, what about mixing configurations? Are you allowed to do this? Yup. Let''s
    look at the following code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关于配置的混合使用呢？你被允许这样做吗？是的。让我们看看以下代码：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It is another variation of our database example, and you already know what is
    happening in the whole code. Just to recall, we loaded the configuration file
    and informed Swarm to use it (1), created the `UndertowFraction` and configured
    it to use the `12345` port (2), added the driver module to the application (3),
    and, finally, started the application and deployed the created archive on it (4).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的数据库示例的另一种变体，你已经知道整个代码中发生了什么。只是为了回顾，我们加载了配置文件，并通知 Swarm 使用它（1），创建了 `UndertowFraction`
    并将其配置为使用 `12345` 端口（2），将驱动模块添加到应用程序中（3），最后，启动了应用程序并在其上部署了创建的存档（4）。
- en: What would be the result of such code? As you probably have guessed, after running
    the application, we will be able to see the random messages on `localhost:12345/hello`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的代码会产生什么结果？正如你可能已经猜到的，在运行应用程序后，我们将在 `localhost:12345/hello` 上看到随机消息。
- en: 'Note that you are able to mix XML and Java API configurations. Can you use
    the properties too? Sure. Let''s add `swarm.http.port` with the `12346` port to
    the command line, and we will be able to see our messages on the address. Yeah,
    we have a conflict here. Is this an error? It is not an error. Swarm attaches
    different priorities to different configuration methods. The precedence is as
    follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以混合使用 XML 和 Java API 配置。你也能使用属性吗？当然。让我们将 `swarm.http.port` 与 `12346` 端口添加到命令行中，我们将在地址上看到我们的消息。是的，我们这里有一个冲突。这是一个错误吗？这不是错误。Swarm
    对不同的配置方法赋予不同的优先级。优先级如下：
- en: Java API overrides the configuration specified by XML
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java API 覆盖了由 XML 指定的配置
- en: YAML overrides the configuration specified by Java API
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: YAML 覆盖了 Java API 指定的配置
- en: Finally, the system properties override the YAML configuration
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，系统属性覆盖了 YAML 配置
- en: As a result, in our last example, we will see our messages on the `12346` port
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果，在我们的最后一个例子中，我们将在 `12346` 端口看到我们的消息
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to configure services created using Swarm.
    You learned how to modify the Swarm behavior using the system properties, provide
    your own `main` method and use it to provide the Swarm configuration using either
    Java API or XML, and, finally, how to modify the content of the deployed application.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何配置使用 Swarm 创建的服务。你学习了如何使用系统属性来修改 Swarm 的行为，提供自己的 `main` 方法并使用它来通过
    Java API 或 XML 提供Swarm配置，最后，如何修改已部署应用程序的内容。
- en: After the three initial chapters, you are now able to use WildFly Swarm to build
    microservices. In the next chapters, you will learn OpenShift so you are able
    to deploy your services in the cloud.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读了前三章之后，你现在可以使用 WildFly Swarm 来构建微服务。在接下来的章节中，你将学习 OpenShift，这样你就可以将你的服务部署到云端。
- en: Further reading
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[http://wildfly-swarm.io/documentation/](http://wildfly-swarm.io/documentation/)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://wildfly-swarm.io/documentation/](http://wildfly-swarm.io/documentation/)'
