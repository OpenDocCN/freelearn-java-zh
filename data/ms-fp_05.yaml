- en: Effect Types - Abstracting Away Side Effects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 效果类型 - 抽象化副作用
- en: In the previous chapter, we saw why side effects may be a source of trouble.
    We also briefly discussed effect types. Effect types are a technique of functional
    programming that allow for the abstraction of side effects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了副作用可能成为麻烦的来源。我们还简要讨论了效果类型。效果类型是函数式编程的一种技术，它允许抽象副作用。
- en: In this chapter, we will have a look at how this works. We will learn the philosophy
    behind the pattern. Also, we will see how to sequentially combine side effects
    trapped in effect types.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨这是如何工作的。我们将了解模式背后的哲学。我们还将看到如何按顺序组合被效果类型捕获的副作用。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Turning effects into data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将效果转换为数据
- en: The sequential combination of effect types with Monads – the `map` and `flatMap`
    functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Monads 的效果类型顺序组合——`map` 和 `flatMap` 函数
- en: Turning effects into data
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将效果转换为数据
- en: It's possible to compare the process of writing programs with modeling and describing
    a particular reality. For example, when you are writing an application for warehouse
    management, you are encoding in the rules of logic the concept of an online shop,
    its inventory, the place where the inventory is stored, and the rules according
    to which this inventory can be moved in and out of the warehouse. This is the
    reality of the business domain for which you are writing the application. We can
    say that your goal as a programmer is to model your business domain, that is,
    to encode it using your programming language into specific logical rules—to define
    the way information is to be stored, transformed, and interacted with.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 将编写程序的过程与建模和描述特定现实进行比较是可能的。例如，当你编写仓库管理应用程序时，你正在将在线商店的概念、其库存、库存存储的地方以及库存可以进出仓库的规则编码到逻辑规则中。这是你编写应用程序的业务领域现实。我们可以说，作为程序员，你的目标是模拟你的业务领域，即使用你的编程语言将其编码为特定的逻辑规则——定义信息存储、转换和交互的方式。
- en: However, in the process of execution, programs create their own reality. The
    same way a warehouse, an online shop, and a user are all members of the reality
    of the business domain, some elements are members of the domain of program execution.
    The same way you can define certain phenomena as they happen in your business
    domain, such as inventory shortage or the users buying from your shop, you can
    define certain phenomena that exist in the world of writing and running a program.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在执行过程中，程序会创造出自己的现实。正如仓库、在线商店和用户都是业务领域现实的成员一样，一些元素是程序执行领域的成员。同样，你可以在你的业务领域中定义某些现象，例如库存短缺或用户从你的商店购买，你可以在编写和运行程序的世界中定义某些现象。
- en: Reality is what is on your mind when you are working on a certain level of abstraction.
    When you are working in the business-domain level, one category of thing is on
    your mind. However, when you are creating programs, entirely different things
    are on your mind. These two separate sets of concepts and phenomena can be understood
    as separate realities you're working in.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现实是你处于某个抽象级别工作时心中的想法。当你处于业务领域级别工作时，你心中想的是一类事物。然而，当你创建程序时，你心中想的是完全不同的事物。这两组不同的概念和现象可以理解为你在其中工作的不同现实。
- en: For example, errors are in the reality of program-execution. The errors' life
    cycle is also the reality of the program execution. Errors can propagate up the
    call stack. When they are handled, they stop propagation. They disrupt programs
    in places where they happen.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，错误存在于程序执行的现实之中。错误的生命周期也是程序执行的现实。错误可以在调用栈中传播。当它们被处理时，它们会停止传播。它们在发生的地方破坏程序。
- en: Delays are also the reality of program-execution. When you perform a database
    operation, an input-output operation, or wait for a response from a server, you
    deal with delays.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟也是程序执行的现实。当你执行数据库操作、输入输出操作或等待服务器的响应时，你正在处理延迟。
- en: Concurrency, modularity, class hierarchies—all of these are elements of your
    programming reality. The programming reality is the concept and phenomena you
    are concerned with when you write your program. This reality, however, does not
    concern your boss, who lives in the reality of the business domain.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 并发、模块化、类层次结构——这些都是你编程现实中的元素。编程现实是你编写程序时所关注的理念和现象。然而，这种现实并不关乎你的老板，他生活在业务领域的现实中。
- en: For simplicity, let's name the business-domain reality the first-order reality,
    and the programming reality the second-order reality. Such naming is because the
    business-domain reality is something that you are immediately concerned with.
    The reality of your program is something that arises in the process of solving
    the business-domain problems, the first-order reality.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，让我们将业务域现实称为一级现实，将编程现实称为二级现实。这样的命名是因为业务域现实是你立即关心的事情。你的程序的现实是在解决业务域问题的过程中产生的，即一级现实。
- en: Sometimes, a programmer focuses only on the first-order reality. They may not
    care about the quality of the code or how it handles the second-order reality.
    Their primary concern is to describe the first order reality and to solve the
    business task. This situation can arise from the lack of experience of a programmer,
    or from a lack of infrastructure that would allow them to deal with the second-order
    reality quickly. Under pressing deadlines, trade-offs sometimes have to be made
    in favor of completing the task rather than the code quality.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，程序员只关注一级现实。他们可能不关心代码的质量或它如何处理二级现实。他们的主要关注点是描述一级现实和解决业务任务。这种情况可能源于程序员缺乏经验，或者源于缺乏能够让他们快速处理二级现实的基础设施。在紧迫的截止日期下，有时不得不在完成任务和代码质量之间做出权衡。
- en: Why is it dangerous to ignore the programming reality? Well, because it is a
    reality in itself, independent of the realities that may occur in business. This
    reality still exists, whether you ignore or address it. And if you do not pay
    attention to it, it may escalate in complexity, especially in large code bases.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 忽视编程现实为什么是危险的？好吧，因为它本身就是一种现实，独立于业务中可能发生的现实。无论你是否关注它，这种现实都仍然存在。而且，如果你不关注它，它可能会在复杂性上升级，尤其是在大型代码库中。
- en: For example, if there are too many asynchronous computations, you may find yourself
    in the situation of callback hell. In the context of callbacks, it is not easy
    to follow the execution flow of the program. Callback hell is when your program
    relies on callbacks too much, to the point where it starts to be hard to track
    what it does.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果有太多的异步计算，你可能会发现自己陷入回调地狱的情况。在回调的上下文中，很难追踪程序的执行流程。回调地狱是指你的程序过度依赖回调，以至于开始难以追踪其行为。
- en: When you are dealing with a concurrent program and multithreaded computations,
    if you're not careful, you may end up in a situation of race conditions. Alternatively,
    you may encounter deadlocks or problems with system liveliness. Without specific
    techniques to deal with these, such as an actor system, they may produce bugs
    that are particularly tricky to debug.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理并发程序和多线程计算时，如果你不小心，你可能会陷入竞态条件的情况。或者，你可能会遇到死锁或系统活跃度问题。如果没有特定的技术来处理这些问题，例如actor系统，它们可能会产生特别难以调试的bug。
- en: If you are not careful about when you throw exceptions and return nulls from
    methods, you can expect pretty much every method to throw an exception or return
    null. Abusing exceptions and nulls by itself should not lead to detrimental bugs,
    but this will still give you a headache.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不在意何时抛出异常和从方法中返回null，你几乎可以预期每个方法都会抛出异常或返回null。仅仅通过滥用异常和null本身不应该导致有害的bug，但这仍然会给你带来头疼。
- en: Finally, mutation is another reality that you are going to face. In the previous
    chapters, we discussed how mutation can increase your mental load.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，突变是你将要面对的另一个现实。在前几章中，我们讨论了突变如何增加你的心理负担。
- en: The several programming situations previously discussed demonstrate the mental
    load that we were talking about so extensively in the previous chapters. It is
    the second-order reality of how programs are run and how they are written. The
    programs are supposed to model the reality of their business domains. However,
    there is an entirely different reality that you encounter when you solve, run,
    or write programs. If you ignore this reality, it will overwhelm you with complexity
    and cause a mental overload.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 之前讨论的几个编程情况展示了我们在前几章中广泛讨论过的心理负担。这是程序运行和编写时的二级现实。程序应该模拟其业务域的现实。然而，当你解决、运行或编写程序时，你会遇到一个完全不同的现实。如果你忽略这个现实，它将用复杂性压倒你，并导致心理超负荷。
- en: 'Consider the following example of the division function, which we have encountered
    in previous chapters:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下我们在前几章中遇到的除法函数的例子：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first-order reality here is arithmetics. It is the business domain that
    we are trying to model. Precisely, we model an operation of dividing one number
    by another number. That's our first-order reality.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第一阶现实是算术。这是我们试图建模的业务领域。确切地说，我们模拟了一个数除以另一个数的操作。这就是我们的第一阶现实。
- en: However, when we start to write the code, we quickly encounter the second-order
    reality. That is, the possibility of the division by zero and the necessity to
    handle this case in the program. Now, we move from the world of mathematics and
    our primary business task to the world of programming.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们开始编写代码时，我们很快就会遇到第二阶现实。也就是说，除以零的可能性以及需要在程序中处理这种情况的必要性。现在，我们从一个数学世界和我们的主要业务任务转向编程的世界。
- en: A naive way to handle this reality is to throw an exception in case of division
    by zero. However, if you do not pay enough attention to the second-order reality,
    it will create the mental overhead that we've already discussed. There is nothing
    to warn you about the possibility of an error. There's nothing to force you to
    handle it. Hence, you need to remember all of this yourself, which contributes
    to the complexity of the program you need to keep in mind. The more things you
    need to keep in mind, the harder it is to do this, and the more things can go
    wrong.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这种现实的一种天真方式是在除以零的情况下抛出一个异常。然而，如果你没有足够关注第二阶现实，它将产生我们已经讨论过的心理负担。没有任何东西可以警告你错误的可能性。没有任何东西可以强迫你处理它。因此，你需要自己记住所有这些，这增加了你需要记住的程序复杂性。你需要记住的事情越多，做这件事就越困难，出错的可能性就越大。
- en: A more sophisticated programmer will think of both the first- and the second-order
    realities when designing their program. They will not only model the business
    domain; they will also design the program so that the complexity of its execution
    does not prevent scalability. Scalability means the size of the code base does
    not contribute to the complexity of the programming of individual components.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更复杂的程序员在设计程序时会同时考虑第一阶和第二阶现实。他们不仅会建模业务领域；他们还会设计程序，使其执行复杂性不会阻碍可扩展性。可扩展性意味着代码库的大小不会增加单个组件编程的复杂性。
- en: To develop a program qualitatively, programmers need specific tools and approaches.
    Functional programming offers one approach.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要开发一个高质量的程序，程序员需要特定的工具和方法。函数式编程提供了一种方法。
- en: Functional programming follows the fundamental principle of engineering—abstract
    away what repeats. The second-order reality has repeating phenomena. So functional
    programming devises its own abstractions to deal with them.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程遵循工程的基本原则——抽象出重复的部分。第二阶现实有重复的现象。因此，函数式编程设计了它自己的抽象来处理它们。
- en: Learning how to describe both realities at once is harder than learning how
    to describe only the first-order reality. Hence, languages such as Python are
    much easier to learn than, say, Java. Although Java is not a functional language,
    it also provides an infrastructure and a methodology to deal with the complexity
    of programming. At the same time, Python is focused on speed and ease of prototyping.
    Moreover, Java is much simpler than Scala because Scala provides even more abstractions
    and a means for you to control both realities of your program.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 同时学习如何描述两种现实比仅学习描述第一阶现实要困难。因此，像Python这样的语言比Java等语言更容易学习。尽管Java不是一种函数式语言，但它也提供了一种基础设施和方法来处理编程的复杂性。同时，Python专注于速度和原型设计的简便性。此外，Java比Scala简单得多，因为Scala提供了更多的抽象以及控制程序两种现实的方法。
- en: Although it is harder to learn the languages that allow for more qualitative
    programming, the value is well worth its price. You learn to control the effects
    of the second-order reality. Not only can you describe your immediate business
    domain, but you are also able to describe the way your program is run. The way
    to scalability and bug-free programming is having control over complexity.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然学习允许更高质量编程的语言更困难，但它的价值是值得其价格的。你学会了控制第二阶现实的影响。你不仅能够描述你的直接业务领域，还能够描述你的程序是如何运行的。控制复杂性以实现可扩展性和无错误编程的方法是掌握复杂性。
- en: 'Let''s revisit the division by zero example, but take into account the second-order
    reality:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视除以零的例子，但考虑到第二阶现实：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first thing to notice is that the second-order reality effect of an error
    gets modeled with the `Try` data structure. The concept of error handling is modeled
    by analyzing the `Try` data structure. It is enforced by the compiler—you cannot
    access the result value unless you analyze the data structure for errors. Hence
    the complexity is reduced.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，错误的二阶现实效果用`Try`数据结构来建模。错误处理的概念通过分析`Try`数据结构来建模。它由编译器强制执行——除非你分析数据结构以查找错误，否则你不能访问结果值。因此，复杂性降低了。
- en: The pattern where we detect a specific phenomenon of the second-order reality
    and create a data structure to encapsulate (reify) it is typical in functional
    programming. In this book, we will be calling the data structures that reify the
    phenomena of the second-order reality **effect types**.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，我们检测到二阶现实的具体现象并创建一个数据结构来封装（具体化）它的模式是典型的。在这本书中，我们将称封装二阶现实现象的数据结构为**效果类型**。
- en: The main point of this section is to look at the side effects from a wide angle
    to see the general pattern behind their abstraction. If you only focus on your
    business domain while ignoring your program's technical reality, the latter will
    create a tough mental load. A sophisticated programmer focuses on both realities
    equally. Functional programming allows you to address them adequately.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的主要目的是从广泛的角度审视副作用，以了解其抽象背后的通用模式。如果你只关注你的业务领域，而忽略了程序的技术现实，后者将创造一个沉重的心理负担。一个复杂的程序员会平等地关注这两种现实。函数式编程允许你充分地处理它们。
- en: The sequential combination of effects with Monads
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Monads 的效果序列组合
- en: Analyzing the preceding data structure was cumbersome. The code that has to
    do with analyzing functional data structures turns out to be pretty hard to read.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 分析前面的数据结构很麻烦。与分析函数数据结构相关的代码最终发现很难阅读。
- en: However, analyzing the data structures is a pattern in the functional world.
    Patterns are abstracted away in programming.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在函数式世界中，分析数据结构是一种模式。模式在编程中被抽象出来。
- en: In this section, we will have a look at some common abstractions that you will
    deal with as a functional programmer when working with effect types.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看一些常见的抽象，作为函数式程序员，当与效果类型一起工作时，你将处理这些抽象。
- en: Introducing the map function
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入 map 函数
- en: Imagine that we need to build upon the previous example of the custom-division
    function to construct another function. The function is parameterized by an argument, `x`,
    and computes an expression, `2 / x + 3`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要在自定义除法函数的先前示例的基础上构建另一个函数。该函数由一个参数`x`参数化，并计算表达式`2 / x + 3`。
- en: 'How do we express it in terms of our custom-division function? One approach
    is first to perform the division, then analyze its result, and if it is not an
    error, continue with the addition. However, if it is an error, return that error:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何用自定义的除法函数来表达它？一种方法是在执行除法后，分析其结果，如果不是错误，则继续进行加法。然而，如果是错误，则返回该错误：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The situation where we have a computation that returns an effect type, and we
    need to continue it with another computation that returns a raw value that is
    not wrapped in an effect type, is a frequent pattern in functional programming.
    The pattern is to analyze the structure returned by a computation, extract the
    result, and then apply the second computation to this result.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个返回效果类型的计算，并且我们需要用另一个返回未封装在效果类型中的原始值的计算来继续它时，这是函数式编程中的一种常见模式。模式是分析计算返回的结构，提取结果，然后应用第二个计算到这个结果上。
- en: 'This pattern is encapsulated in the `map` method. Most effect types have the
    `map` method defined on them. Here is how the preceding example will look if implemented
    with the help of the `map` method:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式封装在`map`方法中。大多数效果类型都有在它们上面定义的`map`方法。以下是如何使用`map`方法实现前面示例的示例：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let's try to develop an intuition for the `map` method. First of all, you can
    think of the `map` method as of the following higher-order function—`(A => B)
    => (Try[A] => Try[B])`. This is a higher-order function that accepts an `A =>
    B` function and outputs a `Try[A] => Try[B]` function.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试培养对`map`方法的直觉。首先，你可以将`map`方法视为以下高阶函数——`(A => B) => (Try[A] => Try[B])`。这是一个接受`A
    => B`函数并输出`Try[A] => Try[B]`函数的高阶函数。
- en: What it means is that if you have a function to convert a value of the `A` type
    into a value of the `B` type, you can also have a function to convert a value
    of the `Try[B]` type to a value of the `Try[B]` type. You can think of the `map`
    function as a lift that allows you to produce functions that work under the `Try` effect
    type from functions that work on the raw values.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果你有一个将`A`类型的值转换为`B`类型的值的函数，你也可以有一个将`Try[B]`类型的值转换为`Try[B]`类型的值的函数。你可以将`map`函数视为一个提升，它允许你从在原始值上工作的函数中产生在`Try`效果类型下工作的函数。
- en: Introducing the flatMap function
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍`flatMap`函数
- en: 'Another example of a function that encapsulates a pattern of functional programming
    is `flatMap`. Imagine we need to create a function that computes the following
    mathematical expression: `(2 / x)  / y + 3`. Let''s try to do this with the division
    function that we defined previously:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap`函数是封装函数式编程模式的一个函数的另一个例子。想象我们需要创建一个函数来计算以下数学表达式：`(2 / x) / y + 3`。让我们尝试使用我们之前定义的除法函数来做这件事：'
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The code becomes spaghetti-like here. First, we analyze the result of dividing
    `2` by `x`. If successful, we would divide it by `y`. Then we analyze the result
    of that division, and if there was no error, we add `3` to the result.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在这里变得像意大利面一样。首先，我们分析除以`2`的结果。如果成功，我们会将其除以`y`。然后我们分析那个除法的结果，如果没有错误，我们会将`3`加到结果上。
- en: Here, we can no longer use the `map` function because the division by `y` returns
    another try. `map` is a lift for a function that returns a raw value, not `Try`.
    If the logic sounds obscure to you, you are encouraged to try to implement the
    preceding example with the `map` function to see the problem.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不能再使用`map`函数，因为除以`y`会返回另一个尝试。`map`是一个用于返回原始值的函数的提升，而不是`Try`。如果你觉得这个逻辑很晦涩，鼓励你尝试使用`map`函数实现前面的例子，以查看问题。
- en: The `flatMap` function exists specifically for this situation. You can think
    of it as of a higher-order function with the `(A => Try[B]) => (Try[A] => Try[B])` signature.
    You can interpret it as follows. If you have a function that produces a value
    wrapped in the `Try` structure, `A => Try[B]`, you can turn it into another function, `Try[A]
    => Try[B]`, that lifts the original function's `A` domain to the domain of `Try[A]`.
    This means that if the original `A => Try[B]` function could be used on the `A`
    raw values, the new `Try[A] => Try[B]` function can be used on `Try[A]` as its
    input.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap`函数专门用于这种情况。你可以将其视为一个具有`(A => Try[B]) => (Try[A] => Try[B])`签名的更高阶函数。你可以这样理解它。如果你有一个产生值包裹在`Try`结构中的函数`A
    => Try[B]`，你可以将其转换成另一个函数`Try[A] => Try[B]`，该函数将原始函数的`A`域提升到`Try[A]`域。这意味着如果原始的`A
    => Try[B]`函数可以在`A`原始值上使用，新的`Try[A] => Try[B]`函数可以用于`Try[A]`作为其输入。'
- en: 'Let''s have a look at how it can be implemented with `flatMap`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何使用`flatMap`实现的：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We need to extract the raw result from the `Try` data structure we got after
    computing `2`/`x`, and we need to perform another computation on this result.
    This computation, the result divided by `y`, also produces `Try`. With the help
    of `flatMap`, we can lift the `Int => Try[Int]` computation into `Try[Int] =>
    Try[Int]`. In other words, once we have computed `2`/`x`, we can divide its result
    by `y`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从计算`2/x`后得到的`Try`数据结构中提取原始结果，并需要对这个结果进行另一个计算。这个计算，即结果除以`y`，也会产生`Try`。借助`flatMap`，我们可以将`Int
    => Try[Int]`计算提升为`Try[Int] => Try[Int]`。换句话说，一旦我们计算了`2/x`，我们就可以将其结果除以`y`。
- en: So `flatMap` is for situations when you need to continue a computation with
    another computation, and the continuation will produce a `Try` as its result.
    Compare that to the situation with the `map` function, which requires the continuation
    to produce a raw value. Corresponding versions of `map` and `flatMap` also exist
    for other effect types, such as Option or Future.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`flatMap`用于需要继续另一个计算的情况，并且这个延续将产生一个`Try`作为其结果。与`map`函数的情况相比，`map`函数要求延续产生一个原始值。`map`和`flatMap`的相应版本也存在于其他效果类型中，例如Option或Future。
- en: One thing can be confusing here regarding the signatures of `map` and `flatMap` that
    we have analyzed. The signatures are functions. They take a function as an input
    and return another function as an output. However, the `map` and `flatMap` methods
    we have called on the `Try` object do not return functions but `Try` objects.
    However, both of our `map` and `flatMap` signatures, as we have discussed previously,
    return a `Try[A] => Try[B]` function.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们分析过的 `map` 和 `flatMap` 签名方面，这里可能有一点令人困惑。签名是函数。它们接受一个函数作为输入，并返回另一个函数作为输出。然而，我们在
    `Try` 对象上调用的 `map` 和 `flatMap` 方法并不返回函数，而是返回 `Try` 对象。然而，正如我们之前讨论的，我们的 `map` 和
    `flatMap` 签名都返回一个 `Try[A] => Try[B]` 函数。
- en: In the functional world, we view functions outside the context of object-oriented
    programming. Scala is a convenient language because it combines the object-oriented
    and functional approaches. So, functions such as `flatMap` or `map` are defined
    as methods of the `Try` class. However, in functional programming, we get a better
    grasp of the nature of the functions by viewing them outside the context of object-oriented
    programming. In functional programming, they are not viewed as members of any
    class. They are means to transform the data.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程的世界里，我们脱离面向对象编程的上下文来看待函数。Scala 是一种方便的语言，因为它结合了面向对象和函数式编程方法。因此，像 `flatMap`
    或 `map` 这样的函数被定义为 `Try` 类的方法。然而，在函数式编程中，通过脱离面向对象编程的上下文，我们能更好地理解函数的本质。在函数式编程中，它们不被视为任何类的成员。它们是转换数据的方式。
- en: 'Imagine you have a function that is defined as a member of some `Dummy` class:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个定义为某个 `Dummy` 类成员的函数：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The function `f` takes some argument of type `Int` and outputs some result of
    type `String`. Its signature is `Int => String`. This signature is the signature
    of the function as it is defined inside the `Dummy` class. However, notice that
    since it is defined inside the `Dummy` object, the context of that object is always
    implied. We can use the data of the enclosing object when performing the computation
    inside the function.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `f` 接受一个 `Int` 类型的参数，并输出一个 `String` 类型的结果。它的签名是 `Int => String`。这个签名是函数在
    `Dummy` 类内部定义时的签名。然而，请注意，由于它是在 `Dummy` 对象内部定义的，因此该对象的上下文总是隐含的。我们可以在函数内部执行计算时使用封装对象的的数据。
- en: 'What happens if we decide to bring this function outside the scope of the class?
    Will the `Int => String` signature still reflect the nature of the function? Can
    we even implement it that way? Consider the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定将这个函数移出类的范围，会发生什么？`Int => String` 签名是否仍然反映了函数的本质？我们能否以这种方式实现它？考虑以下：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The answer is no because now we do not have the required class context. The
    preceding code produces a compile-time error. If we move the function outside
    the scope of the class, we need to define it with the `Dummy => (Int => String)` signature.
    That is, if we have a `Dummy` object, we can define a function from `Int` to `String`,
    with this object in context:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是否定的，因为我们现在没有所需的类上下文。前面的代码会产生编译时错误。如果我们将函数移出类的范围，我们需要用 `Dummy => (Int => String)`
    签名来定义它。也就是说，如果我们有一个 `Dummy` 对象，我们可以定义一个从 `Int` 到 `String` 的函数，并在这个对象上下文中实现它：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note that it is also possible to have it another way, `Int => (Dummy => String)`,
    without compromising the semantics:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，也可以以另一种方式实现，`Int => (Dummy => String)`，而不影响语义：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This idea was applied here when analyzing the `map` and `flatMap` signatures.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法在分析 `map` 和 `flatMap` 签名时得到了应用。
- en: Summary
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the philosophy behind side effects. We found
    out that in the process of solving a business-domain problem, programmers end
    up in a reality different from the one of their business logic. The way you write
    the program and the phenomena that happen at runtime constitute a reality of their
    own. If you ignore it, the latter reality can grow in complexity, and this results
    in a mental overhead.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了副作用背后的哲学。我们发现，在解决业务领域问题的过程中，程序员最终会进入一个与业务逻辑不同的现实。你编写程序和运行时发生的现象构成了一个自己的现实。如果你忽略它，后者的现实可能会变得复杂，这会导致心理负担。
- en: Functional programming allows you to address the problem of the second-order
    reality by providing techniques to reify its phenomena into effect types and define
    their behavior in the language of data structures and pure functions.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程通过提供将现象具体化为效果类型并在数据结构和纯函数的语言中定义它们行为的技巧，允许你通过解决二阶现实问题。
- en: Effect types lessen your mental load because they eliminate the necessity to
    remember all the phenomena that happen in your program, even outside the scope
    of the code you may currently be looking at.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 效果类型减轻了你的心理负担，因为它们消除了记住程序中发生的所有现象的必要性，即使这些现象超出了你当前可能正在查看的代码的作用域。
- en: Effect types also make the compiler force you to handle such phenomena. Working
    with effect types can quickly become quite verbose. Hence, functions such as `map`
    and `flatMap` exist to abstract away common scenarios that involve effect types.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 效果类型也会迫使编译器让你处理这类现象。使用效果类型很快就会变得相当冗长。因此，存在像`map`和`flatMap`这样的函数来抽象处理涉及效果类型的常见场景。
- en: Questions
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which realities does a programmer need to consider when writing a program?
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编程时，程序员需要考虑哪些现实？
- en: How does pure functional programming address the problem of complexity in the
    second-order reality?
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 纯函数式编程如何解决二阶现实中的复杂性问题？
- en: What are the benefits of taking the second-order reality into account in our
    programs?
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的程序中考虑二阶现实有哪些好处？
