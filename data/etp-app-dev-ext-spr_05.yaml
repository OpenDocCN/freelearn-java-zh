- en: Chapter 5. Testing the DAO Layer with Spring and JUnit
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章。使用Spring和JUnit测试DAO层
- en: Everyone would agree that software testing should be a fundamental part of the
    development process. Thorough testing will ensure that the business requirements
    are met, the software works as expected, and that the defects are discovered before
    your client finds them. Although testing can never completely identify all the
    bugs, it is commonly believed that the earlier an issue is found, the cheaper
    it is to fix. It is far quicker to fix a `NullPointerException` in a block of
    code during development than when the system has been deployed to your client's
    production server. When developing enterprise systems, it becomes even more critical
    to deliver high-quality code. The reputation of your company is at stake; identifying
    and fixing issues before delivery is an important reason to make testing a critical
    part of the development lifecycle.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都会同意软件测试应该是开发过程的一个基本部分。彻底的测试将确保业务需求得到满足，软件按预期工作，并且缺陷在客户发现之前被发现。尽管测试永远无法完全识别所有错误，但普遍认为，问题被发现得越早，修复成本就越低。在开发过程中修复代码块中的`NullPointerException`要比系统部署到客户的生产服务器后修复要快得多。在开发企业系统时，交付高质量代码变得更加关键。您公司的声誉岌岌可危；在交付之前识别和修复问题是使测试成为开发生命周期的关键部分的一个重要原因。
- en: 'There are many different types of testing, including but not limited to, unit
    testing, integration testing, regression testing, black/white box testing, and
    acceptance testing. Each of these testing strategies could warrant a chapter in
    their own right but are beyond the scope of this book. An excellent article covering
    software testing in general can be found here: [https://en.wikipedia.org/wiki/Software_testing](https://en.wikipedia.org/wiki/Software_testing).
    We will focus on **unit testing**.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同类型的测试，包括但不限于单元测试、集成测试、回归测试、黑盒/白盒测试和验收测试。每种测试策略都可能值得一章来详细讨论，但超出了本书的范围。关于软件测试的一篇优秀文章可以在这里找到：[https://en.wikipedia.org/wiki/Software_testing](https://en.wikipedia.org/wiki/Software_testing)。我们将专注于**单元测试**。
- en: Unit testing overview
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试概述
- en: 'Unit testing is a strategy for testing discrete units of source code. From
    a programmer''s perspective, a unit is the smallest testable part of an application.
    A unit of source code is usually defined as a **public method** that is callable
    within the application and has a specific purpose. Unit testing of the DAO layer
    will ensure that each public method has at least one appropriate test case. In
    practice, we will need many more test cases than just a single one for each public
    method. For example, every DAO `find(ID)` method requires at least two test cases:
    one with an outcome returning a valid found object and one with an outcome that
    does not find a valid object. As a result, for every line of code written, developers
    often need several lines of test code.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是测试源代码离散单元的策略。从程序员的角度来看，一个单元是应用程序中最小的可测试部分。源代码的一个单元通常被定义为可在应用程序中调用并具有特定目的的**公共方法**。DAO层的单元测试将确保每个公共方法至少有一个适当的测试用例。实际上，我们需要比每个公共方法只有一个测试用例更多的测试用例。例如，每个DAO的`find(ID)`方法都需要至少两个测试用例：一个返回有效找到对象的结果，一个返回未找到有效对象的结果。因此，对于每行代码编写，开发人员通常需要编写几行测试代码。
- en: 'Unit testing is an art form that takes time to master. Our goal is to establish
    a set of tests that cover as many scenarios as possible. This is inherently opposite
    to what we are trying to achieve as developers, where our goal is to ensure that
    a task is performed to meet the precise functional requirements. Consider the
    following business requirement: take the cost value in cents and convert it to
    the euro equivalent according to the exchange rate of the day.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是一门需要时间来掌握的艺术。我们的目标是建立一组尽可能多地覆盖各种场景的测试。这与我们作为开发人员试图实现的目标恰恰相反，我们的目标是确保任务按照精确的功能要求执行。考虑以下业务需求：将成本价值以分为单位，并根据当天的汇率转换为欧元等值。
- en: The solution may seem self-explanatory, but what happens if the exchange rate
    is not available? Or the date is in the future? Or the cost value is null? What
    is the expected behavior if the value cannot be calculated? These are all valid
    scenarios that should be considered when crafting test cases.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案可能看起来很简单，但如果汇率不可用会发生什么？或者日期是在未来？或者成本价值为空？如果无法计算值，预期的行为是什么？这些都是应该在制定测试用例时考虑的有效场景。
- en: With unit testing we define **how** the program should behave. Each unit test
    should tell a well-documented story of how that part of the program should act
    in a specific scenario. The tests become a contract that describes what should
    happen from the client code's point of view under the various reproducible conditions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过单元测试，我们定义程序应该如何行为。每个单元测试应该讲述程序的一部分在特定场景下应该如何行为的一个清晰的故事。这些测试成为了一个合同，描述了在各种可重现的条件下，从客户端代码的角度来看应该发生什么。
- en: The benefits of unit testing
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试的好处
- en: 'Unit testing gives us confidence that the code we have written works correctly.
    The unit testing process also encourages us to think about how our code will be
    used and what conditions need to be met. There are many benefits including:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试让我们确信我们编写的代码是正确的。单元测试过程还鼓励我们思考我们的代码将如何使用以及需要满足什么条件。其中包括许多好处：
- en: '**Identifying problems early:** Unit tests will help identify coding issues
    early in the development lifecycle when it is far easier to fix.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**早期识别问题：**单元测试将有助于在开发生命周期的早期识别编码问题，这时修复问题要容易得多。'
- en: '**Higher quality:** We don''t want customers to find bugs, resulting in downtime
    and expensive release cycles. We want to build software that has as few bugs as
    possible in the first place.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更高的质量：**我们不希望客户发现错误，导致停机和昂贵的发布周期。我们希望构建尽可能少bug的软件。'
- en: '**Confidence:** Developers are reluctant to touch code that is fragile. Well-tested
    code with solid test cases can be approached with confidence.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信心：**开发人员不愿触碰脆弱的代码。经过充分测试的代码和可靠的测试用例可以让人放心地处理。'
- en: '**Regression proofing:** Test cases build and evolve with the application.
    Enhancements and new functionalities may break the old code silently, but a well-written
    test suite will go a long way in identifying such scenarios.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回归测试：**测试用例随应用程序一起构建和演变。增强和新功能可能会悄无声息地破坏旧代码，但良好编写的测试套件将在识别这种情况方面发挥重要作用。'
- en: Enterprise applications, with many programmers doing parallel development across
    different modules, are even more vulnerable. Coding side effects may result in
    far-reaching consequences if not caught early.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 企业应用程序，许多程序员在不同模块上进行并行开发，甚至更容易受到影响。如果不及早发现，编码副作用可能会导致深远的后果。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A helper method was used to trim a Java String passed in as an argument. The
    argument was tested for null and the method returned an empty string " " if this
    was the case. The helper method was used everywhere in the application. One day,
    a developer changed the helper method to return null if the passed-in argument
    was null (they needed to identify the difference between null and an empty string).
    A simple test case would have ensured that this change did not get checked in
    to version control. The sheer number of null pointer exceptions when using the
    application was amazing!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个辅助方法用于修剪作为参数传递的Java字符串。如果参数为null，则对其进行测试，并且如果是这种情况，则该方法将返回一个空字符串" "。该辅助方法在应用程序的各个地方都被使用。有一天，开发人员将辅助方法更改为如果传入参数为null则返回null（他们需要区分null和空字符串）。一个简单的测试用例将确保此更改不会被提交到版本控制中。在使用应用程序时出现的大量空指针异常令人惊讶！
- en: Configuring the test environment
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置测试环境
- en: 'Our strategy for unit testing is to create a set of test cases that can be
    run in an automated manner at any time during the development lifecycle. "Automated"
    means that no developer interaction is required; the tests can be run as part
    of the build process and do not require user input. The entire process is managed
    seamlessly through the use of Maven, JUnit, and Spring. Maven convention expects
    a test directory structure under the `src` directory with testing resources and
    Java test cases in subdirectories as shown in the following screenshot:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的单元测试策略是创建一组可以在开发生命周期的任何时候以自动方式运行的测试用例。 "自动"意味着不需要开发人员交互；测试可以作为构建过程的一部分运行，不需要用户输入。整个过程通过Maven、JUnit和Spring无缝管理。Maven约定期望在`src`目录下有一个测试目录结构，其中包含测试资源和Java测试用例的子目录，如下面的屏幕截图所示：
- en: '![Configuring the test environment](img/5457OS_05_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![配置测试环境](img/5457OS_05_01.jpg)'
- en: 'Note how Maven uses the same directory structure for both source and testing
    layouts. All resources required to execute test cases will be found in the `src/test/resources`
    directory. Likewise, all the resources required for deployment will be found in
    the `src/main/resources` directory. The "convention over configuration" paradigm
    once again reduces the number of decisions that the developer needs to make. Maven-based
    testing will work without the need for any further configuration as long as this
    directory structure is followed. If you do not already have this directory structure,
    then you will need to create it manually by right-clicking on the required folder:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Maven对源代码和测试布局都使用相同的目录结构。执行测试用例所需的所有资源都将在`src/test/resources`目录中找到。同样，部署所需的所有资源都将在`src/main/resources`目录中找到。
    "约定优于配置"范式再次减少了开发人员需要做出的决策数量。只要遵循这个目录结构，基于Maven的测试将无需任何进一步的配置即可工作。如果您尚未拥有此目录结构，则需要通过右键单击所需的文件夹来手动创建它：
- en: '![Configuring the test environment](img/5457OS_05_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![配置测试环境](img/5457OS_05_02.jpg)'
- en: 'After adding the directory structure, we can create individual files as shown:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 添加目录结构后，我们可以创建如下的单个文件：
- en: '![Configuring the test environment](img/5457OS_05_18.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![配置测试环境](img/5457OS_05_18.jpg)'
- en: We will start by using NetBeans to create the `jdbc.properties` file.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用NetBeans创建`jdbc.properties`文件。
- en: The jdbc.properties file
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jdbc.properties文件
- en: 'Right-click on the `test/resources` folder and navigate to **New** | **Other**.
    The **New File** wizard will open where you can select **Other** from **Categories**
    and **Properties File** as shown:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击`test/resources`文件夹，导航到**新建** | **其他**。将打开**新建文件**向导，在其中可以从**类别**和**属性文件**中选择**其他**，如下所示：
- en: '![The jdbc.properties file](img/5457OS_05_03.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![jdbc.properties文件](img/5457OS_05_03.jpg)'
- en: 'Select **Next** and type in `jdbc` as the filename:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**下一步**，并输入`jdbc`作为文件名：
- en: '![The jdbc.properties file](img/5457OS_05_04.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![jdbc.properties文件](img/5457OS_05_04.jpg)'
- en: 'Click on the **Finish** button to create the `jdbc.properties` file. NetBeans
    will then open the file in the editor where you can add the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 单击**完成**按钮创建`jdbc.properties`文件。NetBeans将在编辑器中打开文件，您可以添加以下代码：
- en: '![The jdbc.properties file](img/5457OS_05_05.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![jdbc.properties文件](img/5457OS_05_05.jpg)'
- en: The `jdbc.properties` file is used to define the database connection details
    that will be used by Spring to configure our DAO layer for unit testing. Enterprise
    projects usually have one or more dedicated test databases that are prefilled
    with appropriate data for all testing scenarios. We will use the database that
    was generated and populated in [Chapter 2](ch02.html "Chapter 2. The Task Time
    Tracker Database"), *The Task Time Tracker Database*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`jdbc.properties`文件用于定义数据库连接详细信息，Spring将使用这些信息来配置我们的DAO层进行单元测试。企业项目通常有一个或多个专用的测试数据库，这些数据库预先填充了适用于所有测试场景的适当数据。我们将使用在[第2章](ch02.html
    "第2章。任务时间跟踪器数据库")中生成和填充的数据库，*任务时间跟踪器数据库*。'
- en: The logback.xml file
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: logback.xml文件
- en: 'Create this file by using the **New File** wizard **XML** category as shown:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用**新建文件**向导**XML**类别创建此文件，如下所示：
- en: '![The logback.xml file](img/5457OS_05_06.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![logback.xml文件](img/5457OS_05_06.jpg)'
- en: 'After creating the `logback.xml` file, you can enter the following content:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`logback.xml`文件后，您可以输入以下内容：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For those who are familiar with log4j, the syntax of the logback logger definitions
    is very similar. We have set the root log level to `INFO`, which will cover all
    the loggers that are not explicitly defined (note that the default level is `DEBUG`
    but this will usually result in extensive logging at the root level). Each individual
    logger, with the name matching a `com.gieman.tttracker` package, is set to log
    level `DEBUG`. This configuration gives us considerable flexibility and control
    over package-level logging properties. In production we would normally deploy
    a `WARN` level for all loggers to minimize logging. If an issue is encountered,
    we would then selectively enable logging in different packages to help identify
    any problems. Unlike log4j, this dynamic reloading of logger properties can be
    done on the fly thanks to logback''s `scan="true" scanPeriod="30 seconds"` option
    in the `<configuration>` node. More information about the logback configuration
    can be found here: [http://logback.qos.ch/manual/configuration.html](http://logback.qos.ch/manual/configuration.html).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉log4j的人来说，logback记录器定义的语法非常相似。我们将根日志级别设置为`INFO`，这将覆盖所有未明确定义的记录器（请注意，默认级别为`DEBUG`，但这通常会导致根级别的广泛记录）。每个名称与`com.gieman.tttracker`包匹配的单独记录器都设置为`DEBUG`级别。这种配置为我们提供了在包级别上灵活控制记录属性的能力。在生产环境中，我们通常会为所有记录器部署`WARN`级别以最小化记录。如果遇到问题，我们将有选择地在不同的包中启用记录以帮助识别任何问题。与log4j不同，由于logback的`scan="true"
    scanPeriod="30 seconds"`选项在`<configuration>`节点中，可以动态重新加载记录器属性。有关logback配置的更多信息，请参见：[http://logback.qos.ch/manual/configuration.html](http://logback.qos.ch/manual/configuration.html)。
- en: The test-persistence.xml file
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: test-persistence.xml文件
- en: 'Follow the **New File** steps outlined in the previous section to create the
    `test-persistence.xml` file. Enter the following persistence context definition:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 按照前一节中概述的**新建文件**步骤创建`test-persistence.xml`文件。输入以下持久化上下文定义：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This persistence unit definition is slightly different from the one created
    in [Chapter 3](ch03.html "Chapter 3. Reverse Engineering the Domain Layer with
    JPA"), *Reverse Engineering the Domain Layer with JPA*:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个持久化单元定义与[第3章](ch03.html "第3章。使用JPA反向工程领域层")中创建的定义略有不同，*使用JPA反向工程领域层*：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note that the testing `persistence-unit` transaction type is `RESOURCE_LOCAL`
    rather than `JTA`. Our testing environment uses a local (Spring-managed) transaction
    manager rather than the one provided by our GlassFish server container (which
    is `JTA`). In both cases, the `tttPU` persistence unit name matches the `@PersistenceContext`
    `unitName` annotation of the `EntityManager` field in the `GenericDaoImpl`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，测试`persistence-unit`的事务类型是`RESOURCE_LOCAL`，而不是`JTA`。我们的测试环境使用本地（由Spring管理的）事务管理器，而不是我们的GlassFish服务器容器提供的事务管理器（即`JTA`）。在两种情况下，`tttPU`持久化单元名称与`GenericDaoImpl`中的`EntityManager`字段的`@PersistenceContext`
    `unitName`注解匹配：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The second difference is the way the classes are discovered. During testing
    our domain entities are explicitly listed and we exclude any classes that are
    not defined. This simplifies processing and ensures that only the required entities
    are loaded for testing *without scanning the classpath*. This is an important
    point for Windows users; on some Windows versions, there''s a limit to the length
    of the command-line statement, and therefore, a limit on how long you can make
    your classpath argument. Using classpath scanning, the loading of domain entities
    for testing may not work, resulting in strange errors such as:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个区别是类的发现方式。在测试期间，我们的域实体被明确列出，并排除任何未定义的类。这简化了处理，并确保仅加载测试所需的实体*而不扫描类路径*。这对于Windows用户来说是一个重要的问题；在某些Windows版本中，命令行语句的长度有限，因此，您可以使类路径参数的长度有限。使用类路径扫描，加载域实体进行测试可能无法正常工作，导致诸如以下的奇怪错误：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Always ensure that your testing persistence XML definitions include all domain
    classes in your application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 始终确保您的测试持久化XML定义包括应用程序中的所有域类。
- en: Introducing the Spring IoC container
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Spring IoC容器
- en: The modern Spring Framework is an extensive suite of framework "stacks" based
    on architectural concepts that go back to the start of the century. The Spring
    Framework first came to prominence with *Expert One-on-One J2EE Design and Development*,
    *Rod Johnson*, in 2002\. Spring's implementation of the **Inversion of Control**
    (**IoC**) principle, sometimes also known as **Dependency Injection** (**DI**),
    was a breakthrough in enterprise application design and development. The Spring
    IoC container provided a simple way of configuring objects (JavaBeans) and injecting
    dependencies through constructor arguments, factory methods, object properties,
    or setter methods. We have already seen the `@PersistenceContext` annotation in
    our DAO layer that is used by Spring to identify whether an `EntityManager` object
    should be injected into the `GenericDaoImpl` class. The sophisticated configuration
    options available make the Spring Framework a very flexible foundation for enterprise
    development.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现代Spring框架是一个基于世纪初的架构概念的广泛框架“堆栈”。Spring框架最初是在2002年由*Rod Johnson*的*Expert One-on-One
    J2EE Design and Development*中首次引人注目。Spring对**控制反转**（**IoC**）原则的实现，有时也被称为**依赖注入**（**DI**），是企业应用设计和开发的突破。Spring
    IoC容器提供了一种简单的配置对象（JavaBeans）和通过构造函数参数、工厂方法、对象属性或setter方法注入依赖项的方式。我们已经在DAO层中看到了`@PersistenceContext`注解，该注解由Spring用于确定是否应将`EntityManager`对象注入`GenericDaoImpl`类中。可用的复杂配置选项使Spring框架成为企业开发的非常灵活的基础。
- en: It is beyond the scope of this book to cover more than the basics of the Spring
    Framework configuration as is required by our project needs. However, we recommend
    that you browse through the detailed description of how the IoC container works
    at [http://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/beans.html#beans-definition](http://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/beans.html#beans-definition)
    to enhance their knowledge of the core principles.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的范围超出了Spring框架配置的基础知识，这是我们项目需求所必需的。但是，我们建议您浏览有关IoC容器如何工作的详细描述，以增进对核心原则的了解。
- en: Exploring the testingContext.xml file
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索testingContext.xml文件
- en: This is the main configuration file used by Spring to configure and load the
    IoC bean container. The XML-based configuration has been the default way to configure
    Spring applications since the very start, but with Spring 3 Framework, it became
    possible to use the Java-based configuration. Both options achieve the same result—a
    fully configured Spring container. We will use the XML approach as it does not
    require any Java coding and is more intuitive and simple to use.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Spring用来配置和加载IoC bean容器的主要配置文件。自从一开始，基于XML的配置一直是配置Spring应用程序的默认方式，但是在Spring
    3框架中，可以使用基于Java的配置。这两种选项都可以实现相同的结果-一个完全配置的Spring容器。我们将使用XML方法，因为它不需要任何Java编码，而且更直观和简单。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There have been many articles written over the years about the "complexities"
    of the Spring XML configuration. Prior to Java 1.5 and the introduction of annotations,
    there could have been a case made for such comments. Configuration files were
    lengthy and daunting for new users. This is no longer the case. Configuring a
    Spring container with XML is now a trivial process. Be wary of anyone who tells
    you otherwise!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来已经有许多关于Spring XML配置的“复杂性”的文章。在Java 1.5之前和注解引入之前，可能会有这样的评论。配置文件对新用户来说既冗长又令人望而却步。但现在不再是这种情况。使用XML配置Spring容器现在是一个微不足道的过程。对于任何告诉你相反的人要小心！
- en: 'The `testingContext.xml` configuration file completely defines the Spring environment
    required for testing the DAO layer. The full file listing is:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`testingContext.xml`配置文件完全定义了测试DAO层所需的Spring环境。完整的文件清单如下：'
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's look at each section in detail.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看每个部分。
- en: The Spring XML namespaces
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Spring XML命名空间
- en: For those not familiar with XML, you can simply ignore the `xmlns` definitions
    and schema location URLs. Consider them as "shortcuts" or "qualifiers" in the
    configuration file that provide the ability to validate the entries. Spring understands
    what `<tx:annotation-driven />` means in the context of loading the Spring environment.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不熟悉XML的人，可以简单地忽略`xmlns`定义和模式位置URL。将它们视为配置文件中提供验证条目能力的“快捷方式”或“限定符”。Spring了解在加载Spring环境的上下文中`<tx:annotation-driven
    />`的含义。
- en: 'Each Spring application configuration file will have multiple namespace declarations
    depending on the resources your application needs. Defining the schema location
    in addition to the namespaces will allow NetBeans to provide helpful hints on
    configuration options:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Spring应用程序配置文件将具有多个命名空间声明，具体取决于应用程序所需的资源。除了命名空间之外，定义模式位置还将允许NetBeans提供有关配置选项的有用提示：
- en: '![The Spring XML namespaces](img/5457OS_05_07.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![Spring XML命名空间](img/5457OS_05_07.jpg)'
- en: The list of valid properties for different namespaces is very useful when new
    to Spring configuration.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于新手来说，不同命名空间的有效属性列表非常有用。
- en: The property file configuration
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性文件配置
- en: 'The following bean loads the `jdbc.properties` file and makes it available
    for use in the configuration file:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下bean加载`jdbc.properties`文件并使其在配置文件中可用：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `${}` syntax can then be used anywhere in the `testingContext.xml` file
    to replace the token with the required `jdbc` property.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以在`testingContext.xml`文件的任何地方使用`${}`语法来替换令牌为所需的`jdbc`属性。
- en: Creating the JDBC DataSource
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建JDBC DataSource
- en: 'DAO testing requires a connection to the MySQL database. The following Spring
    bean definition instantiates and makes available a fully configured DataSource:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: DAO测试需要连接到MySQL数据库。以下Spring bean定义实例化并提供了一个完全配置的DataSource：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The placeholders are automatically set with the properties loaded from the
    `jdbc.properties` file:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 占位符将自动设置为从`jdbc.properties`文件加载的属性：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This very simple Spring configuration snippet replaces many lines of equivalent
    Java code if we had to implement the DataSource instantiation ourselves. Note
    how simple it would be to change any of the database properties for different
    testing scenarios, or for example, even change the database server from MySQL
    to Oracle. This flexibility makes the Spring IoC container very powerful for enterprise
    use.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个非常简单的Spring配置片段可以替换许多等效的Java代码行，如果我们必须自己实现DataSource实例化。请注意，要更改任何数据库属性以进行不同的测试场景，或者例如，甚至将数据库服务器从MySQL更改为Oracle将是多么简单。这种灵活性使Spring
    IoC容器在企业使用中非常强大。
- en: You should note that the `org.springframework.jdbc.datasource.DriverManagerDataSource`
    should only be used for testing purposes and is not for use in a production environment.
    The GlassFish server will provide a connection-pooled `DataSource` for production
    use.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该注意`org.springframework.jdbc.datasource.DriverManagerDataSource`只应用于测试目的，不适用于生产环境。GlassFish服务器将为生产使用提供连接池`DataSource`。
- en: Defining helper beans
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义辅助bean
- en: 'The `loadTimeWeaver` and `jpaVendorAdapter` bean definitions help configure
    the `entityManagerFactory` bean that is used to load the persistence context.
    Note the way in which we identify the database platform (MySQL) and JPA implementation
    (EclipseLink) by using specific Spring bean classes:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadTimeWeaver`和`jpaVendorAdapter` bean定义有助于配置用于加载持久性上下文的`entityManagerFactory`
    bean。请注意我们如何使用特定的Spring bean类来标识数据库平台（MySQL）和JPA实现（EclipseLink）：'
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Spring provides a large number of database and JPA implementations as can be
    seen when using autocomplete in NetBeans (the *Ctrl* + Space bar combination in
    NetBeans triggers the autocomplete options):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了大量的数据库和JPA实现，可以在NetBeans中使用自动完成时看到（在NetBeans中使用*Ctrl* +空格组合键触发自动完成选项）：
- en: '![Defining helper beans](img/5457OS_05_08.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![定义辅助bean](img/5457OS_05_08.jpg)'
- en: Helper beans are used to define implementation-specific properties. It is very
    easy to swap implementation strategies for different enterprise environments.
    For example, developers may use MySQL databases running locally on their own environment
    for development purposes. Production enterprise servers may use an Oracle database
    running on a different physical server. Only very minor changes are required to
    the Spring XML configuration file to implement such differences for the application
    environment.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助bean用于定义特定于实现的属性。非常容易为不同的企业环境切换实现策略。例如，开发人员可以在本地环境中使用运行在自己环境上的MySQL数据库进行开发。生产企业服务器可能使用在不同物理服务器上运行的Oracle数据库。只需要对Spring
    XML配置文件进行非常小的更改，就可以为应用程序环境实现这些差异。
- en: Defining the EntityManagerFactory class
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义EntityManagerFactory类
- en: 'This Spring bean defines the `EntityManagerFactory` class that is used to create
    and inject the `EntityManager` instance into the `GenericDaoImpl` class:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Spring bean定义了`EntityManagerFactory`类，用于创建和注入`EntityManager`实例到`GenericDaoImpl`类中：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This definition references the `tttDataSource` and `jpaVendorAdapter` beans
    that are already configured, as well as the `test-persistence.xml` persistence
    context definition file. Once again, Spring does a lot of work in the background
    by creating and configuring the `EntityManager` instance and making it available
    for use in our code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义引用了已经配置的`tttDataSource`和`jpaVendorAdapter` bean，以及`test-persistence.xml`持久化上下文定义文件。再一次，Spring在后台做了大量工作，创建和配置`EntityManager`实例，并使其可以在我们的代码中使用。
- en: Configuring the transaction manager
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置事务管理器
- en: 'The Spring bean used to manage transactions is defined as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 用于管理事务的Spring bean定义如下：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This bean wires together the `tttDataSource` and `entityManagerFactory` instance
    to enable transactional behavior in our application. This behavior is applied
    to all classes with `@Transactional` annotations; in our current situation this
    applies to all the DAO objects. Spring scans for this annotation and applies a
    transactional wrapper to each annotated method when the following line is included
    in the configuration file:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个bean将`tttDataSource`和`entityManagerFactory`实例连接在一起，以启用我们应用程序中的事务行为。这种行为适用于所有带有`@Transactional`注解的类；在我们目前的情况下，这适用于所有的DAO对象。当在配置文件中包含以下行时，Spring会扫描这个注解并为每个带有注解的方法应用事务包装：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Which classes are scanned for the `@Transactional` annotation? The following
    line defines that Spring should scan the `com.gieman.tttracker.dao` package:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 哪些类被扫描以寻找`@Transactional`注解？以下行定义了Spring应该扫描`com.gieman.tttracker.dao`包：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Autowiring beans
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动装配bean
- en: '**Autowiring** is a Spring term used to automatically inject a resource into
    a managed bean. The following line enables autowiring in beans that have the `@Autowired`
    annotation:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 自动装配是Spring术语，用于自动将资源注入托管的bean中。以下行使能了拥有`@Autowired`注解的bean的自动装配：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We do not have any autowired annotations as of yet in our code; the next section
    will introduce how this annotation is used.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码中还没有任何自动装配的注解；下一节将介绍如何使用这个注解。
- en: Thanks for the plumbing!
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 感谢管道！
- en: The Spring configuration file, when loaded by the Spring container, will do
    an enormous amount of work in the background configuring and wiring together the
    many supporting classes required by our application. The tedious and often error-prone
    "plumbing" code is done for us. Never again will we need to commit a transaction,
    open a database connection, or close a JDBC resource. These low-level operations
    will be handled very elegantly for us by the Spring Framework.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当Spring容器加载Spring配置文件时，将在后台进行大量工作，配置和连接我们应用程序所需的许多支持类。这些繁琐且常常容易出错的“管道”代码已经为我们完成。我们再也不需要提交事务、打开数据库连接或关闭JDBC资源。这些低级操作将由Spring框架非常优雅地处理。
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'As enterprise application developers we can and should focus most of our time
    and energy on core application concerns: business logic, user interfaces, requirements,
    testing, and, of course, our customers. Spring makes sure we can stay focused
    on these tasks.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 作为企业应用程序开发人员，我们可以并且应该将大部分时间和精力集中在核心应用程序关注点上：业务逻辑、用户界面、需求、测试，当然还有我们的客户。Spring确保我们可以专注于这些任务。
- en: Enabling the Maven environment for testing
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为测试启用Maven环境
- en: 'The Maven build process includes the ability to execute test suites. We will
    now need to add this functionality to the `pom.xml` file. The required changes
    to the existing file are highlighted in the following code snippet:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Maven构建过程包括执行测试套件的功能。现在我们需要将这个功能添加到`pom.xml`文件中。现有文件的所需更改在以下代码片段中突出显示：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first two changes add the `mysql-connector-java` and `junit` dependencies.
    Without these we will not be able to connect to the database or write test cases.
    These dependencies will download the appropriate Java libraries for inclusion
    into our project.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个更改添加了`mysql-connector-java`和`junit`依赖项。没有这些依赖项，我们将无法连接到数据库或编写测试用例。这些依赖项将下载适当的Java库，以包含到我们的项目中。
- en: 'The most important settings are in the Maven plugin that performs the actual
    work. Adding the `maven-surefire-plugin` will allow the test case execution based
    on the contents of the `main/src/test` directory structure. This clearly separates
    the testing classes from our application classes. The main configuration properties
    for this plugin are:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的设置在执行实际工作的Maven插件中。添加`maven-surefire-plugin`将允许基于`main/src/test`目录结构的测试用例执行。这清楚地将测试类与我们的应用程序类分开。这个插件的主要配置属性包括：
- en: '`<skipTests>`: This property can be `true` (to disable testing) or `false`
    (to enable testing).'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<skipTests>`：此属性可以是`true`（禁用测试）或`false`（启用测试）。'
- en: '`<includes>`: This property includes a list of file sets during testing. The
    setting `<include>**/dao/*Test.java</include>` specifies that all the classes
    in any `dao` subdirectory with the filename ending in `Test.java` should be loaded
    and included in the testing process. You may specify any number of file sets.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<includes>`：此属性在测试期间包含文件集的列表。设置`<include>**/dao/*Test.java</include>`指定应加载并包含在测试过程中以`Test.java`结尾的任何`dao`子目录中的所有类。您可以指定任意数量的文件集。'
- en: '`<argLine>-javaagent:target/lib/spring-instrument-${spring.version}.jar</argLine>`:
    This property is used to configure the Java Agent for the testing JVM and is required
    by Spring for the load-time weaving of classes, a discussion of which is beyond
    the scope of this text.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<argLine>-javaagent:target/lib/spring-instrument-${spring.version}.jar</argLine>`：此属性用于配置测试JVM的Java代理，并且Spring需要它来进行类的加载时编织，这超出了本文的讨论范围。'
- en: Now that we have configured the Spring and Maven testing environments, we can
    start writing test cases.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了Spring和Maven测试环境，可以开始编写测试用例了。
- en: Defining a test case superclass
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义测试用例超类
- en: 'The first step is to create a superclass that all of our DAO test cases will
    inherit. This abstract class looks like the following code snippet:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个所有DAO测试用例都将继承的超类。这个抽象类看起来像下面的代码片段：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `AbstractDaoForTesting` class is marked as abstract so that it cannot be
    instantiated directly. It provides member variables that are accessible to all
    the subclasses, thus removing the need to replicate code in the descendents. As
    a result, each subclass will have access to the DAO instances as well as the SLF4J
    `logger`. There are two new Spring annotations:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractDaoForTesting`类被标记为抽象类，因此不能直接实例化。它提供了对所有子类可访问的成员变量，从而消除了在子类中复制代码的需要。因此，每个子类都将可以访问DAO实例以及SLF4J
    `logger`。有两个新的Spring注解：'
- en: '`@ContextConfiguration`: This annotation defines the Spring application context
    used to load the bean container. The `testingContext.xml` file has been covered
    in detail in the previous sections.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ContextConfiguration`：此注解定义了用于加载bean容器的Spring应用程序上下文。`testingContext.xml`文件在前几节中已经详细介绍过。'
- en: '`@Autowired`: This annotation indicates to Spring that the container-managed
    bean with matching type should be dependency injected into the class. For example,
    the `CompanyDao companyDao` definition will result in Spring querying the container
    for an object with type `CompanyDao`. There is only one object with this type:
    the `CompanyDaoImpl` class that was discovered and configured by Spring when scanning
    the `com.gieman.tttracker.dao` package via the `<context:component-scan base-package="com.gieman.tttracker.dao"/>`
    entry in the `testingContext.xml` file.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Autowired`：这个注解告诉Spring容器应该将匹配类型的受管bean注入到类中。例如，`CompanyDao companyDao`的定义将导致Spring查询容器中类型为`CompanyDao`的对象。这种类型只有一个对象：在扫描`com.gieman.tttracker.dao`包时Spring发现并配置的`CompanyDaoImpl`类，通过`testingContext.xml`文件中的`<context:component-scan
    base-package="com.gieman.tttracker.dao"/>`条目。'
- en: The final important thing to notice is that the `AbstractDaoForTesting` class
    extends the Spring `AbstractTransactionalJUnit4SpringContextTests` class. Apart
    from being a very long class name, this class provides transparent transactional
    rollbacks at the end of each test method. This means the database state at the
    end of any DAO testing operations (including any insert, update, or delete) will
    be the same as at the start of testing. If this behavior is not required, you
    should extend `AbstractJUnit4SpringContextTests` instead. In this case any testing
    database operations can be examined and confirmed after the tests have been run.
    It is also possible to mark a single method with `@Rollback(false)` when using
    `AbstractTransactionalJUnit4SpringContextTests` to commit changes if required.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个重要的事情是`AbstractDaoForTesting`类扩展了Spring的`AbstractTransactionalJUnit4SpringContextTests`类。除了类名很长之外，这个类在每个测试方法结束时提供透明的事务回滚。这意味着任何DAO测试操作（包括插入、更新或删除）结束时数据库状态将与测试开始时相同。如果不需要这种行为，应该扩展`AbstractJUnit4SpringContextTests`。在这种情况下，测试数据库操作可以在测试运行后进行检查和确认。还可以在使用`AbstractTransactionalJUnit4SpringContextTests`时标记单个方法为`@Rollback(false)`以提交更改。
- en: Let's now write our first test case for the `CompanyDao` operation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为`CompanyDao`操作编写我们的第一个测试用例。
- en: Defining the CompanyDao test case
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义CompanyDao测试用例
- en: Each `CompanyDao` method should have at least one test method defined. We will
    include exactly one test method per implemented `CompanyDao` method. In enterprise
    applications, we would expect many more scenarios to be covered than the ones
    identified in the code snippet that follows.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`CompanyDao`方法应该至少有一个测试方法。我们将为每个实现的`CompanyDao`方法包含一个测试方法。在企业应用程序中，我们期望覆盖的场景要比下面代码片段中识别的要多得多。
- en: 'We have also included minimum logging, just enough to split the output when
    running the test cases. You may wish to add more logging to help analyze the results.
    The test code assumes that the `ttt_company` table has appropriate data. In [Chapter
    2](ch02.html "Chapter 2. The Task Time Tracker Database"), *The Task Time Tracker
    Database*, we added three rows so that we know there is data available. Additional
    checks would need to be done if we do not have a database with consistent testing
    data. The file listing is:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还包括了最少的日志记录，足以在运行测试用例时拆分输出。您可能希望添加更多日志以帮助分析结果。测试代码假定`ttt_company`表具有适当的数据。在[第2章](ch02.html
    "第2章。任务时间跟踪器数据库")中，*任务时间跟踪器数据库*，我们添加了三行数据，以便知道有可用数据。如果没有具有一致测试数据的数据库，需要进行额外的检查。文件列表如下：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Running the JUnit test cases with Maven
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Maven运行JUnit测试用例
- en: 'The `pom.xml` configuration file will automatically run the test cases using
    `<skipTests>false</skipTests>` when doing **Clean and Build Project (task-time-tracker)**
    by clicking on the toolbar icon:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过单击工具栏上的**Clean and Build Project (task-time-tracker)**图标，`pom.xml`配置文件将自动使用`<skipTests>false</skipTests>`运行测试用例：
- en: '![Running the JUnit test cases with Maven](img/5457OS_05_09.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![使用Maven运行JUnit测试用例](img/5457OS_05_09.jpg)'
- en: 'It is also possible to only run the testing phase of the project by navigating
    to **Run** | **Test Project (task-time-tracker)**:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过导航到**Run** | **Test Project (task-time-tracker)**来仅运行项目的测试阶段：
- en: '![Running the JUnit test cases with Maven](img/5457OS_05_19.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![使用Maven运行JUnit测试用例](img/5457OS_05_19.jpg)'
- en: 'The results of the testing process can now be examined in the **Output – task-time-tracker**
    panel. Note that you may need to dock the output panel to the bottom of the IDE
    if it is minimized, as shown in the following screenshot (the minimized panel
    is usually in the bottom-left corner of the NetBeans IDE). The `[surefire:test]`
    plugin output is displayed at the start of the testing process. There are many
    lines of output for configuring Spring, connecting to the database, and loading
    the persistence context:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以在**Output - task-time-tracker**面板中检查测试过程的结果。请注意，如果最小化了输出面板，则可能需要将输出面板停靠到IDE底部，如下面的屏幕截图所示（最小化面板通常位于NetBeans
    IDE的左下角）。在测试过程开始时，会显示`[surefire:test]`插件输出。有许多行输出用于配置Spring，连接到数据库和加载持久化上下文：
- en: '![Running the JUnit test cases with Maven](img/5457OS_05_10.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![使用Maven运行JUnit测试用例](img/5457OS_05_10.jpg)'
- en: 'We will examine the key testing output in detail soon. Scroll through the output
    until you reach the end of the test section:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将很快详细检查关键的测试输出。滚动输出，直到到达测试部分的末尾：
- en: '![Running the JUnit test cases with Maven](img/5457OS_05_11.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![使用Maven运行JUnit测试用例](img/5457OS_05_11.jpg)'
- en: There were five tests executed in total with no errors—a great start!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 总共执行了五个测试，没有错误，非常好的开始！
- en: Running the CompanyDaoTest.java file
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行CompanyDaoTest.java文件
- en: 'You can execute a single test case file by right-clicking on the file displayed
    in the editor and selecting the **Test File** option:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过右键单击编辑器中显示的文件并选择**Test File**选项来执行单个测试用例文件：
- en: '![Running the CompanyDaoTest.java file](img/5457OS_05_12.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![运行CompanyDaoTest.java文件](img/5457OS_05_12.jpg)'
- en: 'This will execute the file''s test cases, producing the same testing output
    as shown previously, and present you with the results in the **Test Results**
    panel. This panel should appear under the file editor but may not be docked (it
    may be floating at the bottom of the NetBeans IDE; you can change the position
    and docking as required). The individual file testing results can then be examined:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行文件的测试用例，产生与之前相同的测试输出，并在**Test Results**面板中呈现结果。该面板应该出现在文件编辑器下方，但可能没有停靠（可能在NetBeans
    IDE底部漂浮；您可以根据需要更改位置和停靠）。然后可以检查单个文件的测试结果：
- en: '![Running the CompanyDaoTest.java file](img/5457OS_05_13.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![运行CompanyDaoTest.java文件](img/5457OS_05_13.jpg)'
- en: Single test file execution is a practical and quick way of debugging and developing
    code. We will continue to execute and examine single files during the rest of
    the chapter.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 单个测试文件的执行是调试和开发代码的实用快速方式。在本章的其余部分，我们将继续执行和检查单个文件。
- en: Let's now examine the results of each test case in detail.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们详细检查每个测试用例的结果。
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In all of the following testing outputs, the SLF4J-specific messages have been
    removed. This will include timestamps, threads, and session information. We will
    only focus on the generated SQL.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下所有测试输出中，已删除了SLF4J特定的消息。这将包括时间戳，线程和会话信息。我们只关注生成的SQL。
- en: The results for the CompanyDaoTests.testMerge test case
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CompanyDaoTests.testMerge测试用例的结果
- en: 'The output for this test case is:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试用例的输出是：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A `merge` call is used to update a persistent entity. The `testMerge` method
    is very simple:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`merge`调用用于更新持久实体。`testMerge`方法非常简单：'
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We find the first `Company` entity (the first item in the list returned by `findAll`)
    and then update the name of the company to the `NEW_NAME` value. The `companyDao.merge`
    call then updates the `Company` entity state in the persistence context. This
    is tested using the `assertTrue()` test.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们找到第一个`Company`实体（`findAll`返回的列表中的第一项），然后将公司的名称更新为`NEW_NAME`值。然后，`companyDao.merge`调用会更新持久化上下文中的`Company`实体状态。这是使用`assertTrue()`测试来测试的。
- en: 'Note that the testing output only has **one** SQL statement:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，测试输出只有**一个**SQL语句：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This output corresponds to the `findAll` method call. Note that there is no
    SQL update statement executed! This may seem strange because the entity manager's
    `merge` call should result in an update statement being issued against the database.
    However, the JPA implementation is **not** required to execute such statements
    immediately and may cache statements when possible, for performance and optimization
    purposes. The cached (or queued) statements are then executed only when an explicit
    `commit` is called. In our example, Spring executes a `rollback` immediately after
    the `testMerge` method returns (remember, we are running transactional test cases
    thanks to our `AbstractTransactionalJUnit4SpringContextTests` extension), and
    hence the persistence context never needs to execute the update statement.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出对应于`findAll`方法的调用。请注意，没有执行SQL更新语句！这可能看起来很奇怪，因为实体管理器的`merge`调用应该导致针对数据库执行更新语句。但是，JPA实现**不**要求立即执行这样的语句，并且可能在可能的情况下缓存语句，以进行性能和优化。缓存的（或排队的）语句只有在调用显式的`commit`时才会执行。在我们的例子中，Spring在`testMerge`方法返回后立即执行`rollback`（请记住，由于我们的`AbstractTransactionalJUnit4SpringContextTests`扩展，我们正在运行事务性测试用例），因此持久化上下文永远不需要执行更新语句。
- en: 'We can force a flush to the database by making a slight change to the `GenericDaoImpl`
    class:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过对`GenericDaoImpl`类进行轻微更改来强制刷新到数据库。
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `em.flush()` method results in an **immediate** update statement being
    executed; the entity manager is flushed with all pending changes. Changing this
    code in the `GenericDaoImpl` class and executing the test case again will result
    in the following testing output:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`em.flush()`方法导致**立即**执行更新语句；实体管理器被刷新以处理所有挂起的更改。更改`GenericDaoImpl`类中的此代码并再次执行测试用例将产生以下测试输出：'
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The update statement now appears as expected. If we now check the database
    directly after executing the test case, we find:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在更新语句出现了。如果我们现在在执行测试用例后直接检查数据库，我们会发现：
- en: '![The results for the CompanyDaoTests.testMerge test case](img/5457OS_05_14.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![CompanyDaoTests.testMerge测试用例的结果](img/5457OS_05_14.jpg)'
- en: As expected, Spring has rolled back the database at the end of the `testMerge`
    method call, and the company name of the first record has not changed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，Spring在`testMerge`方法调用结束时回滚了数据库，并且第一条记录的公司名称没有改变。
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In enterprise applications, it is recommended not to call `em.flush()` explicitly
    and to allow the JPA implementation to optimize statements according to their
    transactional behavior. There may be situations, however, where an immediate flush
    is required but these are rare.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业应用程序中，建议不要显式调用`em.flush()`，并允许JPA实现根据其事务行为优化语句。然而，可能存在需要立即刷新的情况，但这些情况很少见。
- en: The results for the CompanyDaoTests.testFindAll test case
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CompanyDaoTests.testFindAll测试用例的结果
- en: 'The output for this test case is:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试用例的输出是：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Even though the `testMerge` method uses the `findAll` method to retrieve the
    first item in the list, we should always include a separate `findAll` test method
    to compare the size of the result set with the database table. This is easy when
    using the Spring helper method `countRowsInTable`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`testMerge`方法使用`findAll`方法检索列表中的第一项，我们应该始终包括一个单独的`findAll`测试方法，以将结果集的大小与数据库表进行比较。使用Spring辅助方法`countRowsInTable`时很容易实现这一点：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can then compare the size of the `findAll` result list with `rowCount` using
    the `assertTrue` statement:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用`assertTrue`语句将`findAll`结果列表的大小与`rowCount`进行比较：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Note how the `assertTrue` statement is used; the message is displayed if the
    assertion is `false`. We can test the statement by slightly modifying the assertion
    so that it fails:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`assertTrue`语句的使用；如果断言为`false`，则显示消息。我们可以通过稍微修改断言来测试语句，使其失败：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It will now fail and result in the following output when the test case is executed:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它将失败，并在执行测试用例时产生以下输出：
- en: '![The results for the CompanyDaoTests.testFindAll test case](img/5457OS_05_15.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![CompanyDaoTests.testFindAll测试用例的结果](img/5457OS_05_15.jpg)'
- en: The results for the CompanyDaoTests.testFind test case
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CompanyDaoTests.testFind测试用例的结果
- en: 'The output for this test case is:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试用例的输出是：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This may seem a bit surprising for those new to JPA. The `SELECT` statement
    is executed from the code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于新接触JPA的人来说可能有点令人惊讶。`SELECT`语句是从代码中执行的：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: But where is the expected `SELECT` statement when calling the `find` method
    using the `id` attribute?
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在使用`id`属性调用`find`方法时，预期的`SELECT`语句在哪里呢？
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: JPA does not need to execute the `SELECT` statement using the primary key statement
    on the database as the entity with the required ID has already been loaded in
    the persistence context. There will be three entities loaded as a result of the
    `findAll` method with IDs 1, 2, and 3\. When asked to find the entity using the
    ID of the first item in the list, JPA will return the entity it has already loaded
    in the persistence context with the matching ID, avoiding the need to execute
    a database select statement.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: JPA不需要使用主键语句在数据库上执行`SELECT`语句，因为具有所需ID的实体已经在持久化上下文中加载。由于`findAll`方法的结果，将加载三个具有ID为1、2和3的实体。当要求使用列表中第一项的ID查找实体时，JPA将返回已在持久化上下文中加载的具有匹配ID的实体，避免执行数据库选择语句的需要。
- en: This is often a trap in understanding the behavior of JPA-managed applications.
    When an entity is loaded into the persistence context it will remain there until
    it expires. The definition of what constitutes "expires" will depend on the implementation
    and caching properties. It is possible that small sets of data will never expire;
    in our Company example with only a few records, this will most likely be the case.
    Performing an update statement directly on the underlying table, for example,
    changing the company name of the first record, may never be reflected in the JPA
    persistence context as the persistence context entity will never be refreshed.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是理解JPA管理应用程序行为的一个陷阱。当实体加载到持久化上下文中时，它将一直保留在那里，直到过期。构成“过期”的定义将取决于实现和缓存属性。可能小数据集永远不会过期；在我们的Company示例中，只有少量记录，这很可能是这种情况。例如，直接在底层表上执行更新语句，例如更改第一条记录的公司名称，可能永远不会在JPA持久化上下文中反映出来，因为持久化上下文实体永远不会被刷新。
- en: Note
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If an enterprise application expects data modification from multiple sources
    (for example, through stored procedures or web service calls via a different entity
    manager), a caching strategy to expire stale entities will be required. JPA does
    not automatically refresh the entity state from the database and will assume that
    the persistence context is the only mechanism for managing persistent data. EclipseLink
    provides several caching annotations to solve this problem. An excellent guide
    can be found here: [http://wiki.eclipse.org/EclipseLink/Examples/JPA/Caching](http://wiki.eclipse.org/EclipseLink/Examples/JPA/Caching).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果企业应用程序期望从多个来源进行数据修改（例如，通过存储过程或通过不同实体管理器的web服务调用），则需要一种缓存策略来使过期的实体失效。JPA不会自动从数据库刷新实体状态，并且会假定持久化上下文是管理持久化数据的唯一机制。EclipseLink提供了几个缓存注解来解决这个问题。可以在这里找到一个很好的指南：[http://wiki.eclipse.org/EclipseLink/Examples/JPA/Caching](http://wiki.eclipse.org/EclipseLink/Examples/JPA/Caching)。
- en: Results for the CompanyDaoTests.testPersist test case
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CompanyDaoTests.testPersist测试用例的结果
- en: 'We have added a few minor changes to the `GenericDaoImpl.persist` method as
    a result of the exercises from the previous chapter. The modified `persist` method
    in the `GenericDaoImpl` implementation is:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于上一章的练习，我们对`GenericDaoImpl.persist`方法进行了一些小的更改。`GenericDaoImpl`实现中修改后的`persist`方法是：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You will notice the `em.flush()` method in `GenericDaoImpl` after the `em.persist()`
    method. Without this flush to the database ,we cannot guarantee that a valid primary
    key has been set on the new `Company` entity. The output for this test case is:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在`em.persist()`方法之后，您会注意到`GenericDaoImpl`中的`em.flush()`方法。如果没有将此刷新到数据库，我们无法保证新的`Company`实体上已设置有效的主键。这个测试案例的输出是：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Note that the logging outputs the newly generated primary key value of `4`.
    This value is retrieved when JPA queries MySQL using the `SELECT LAST_INSERT_ID()`
    statement. In fact, removing the `em.flush()` method from `GenericDaoImpl` and
    executing the test case would result in the following output:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，日志输出了新生成的主键值`4`。当JPA使用`SELECT LAST_INSERT_ID()`语句查询MySQL时，会检索到这个值。事实上，从`GenericDaoImpl`中删除`em.flush()`方法并执行测试案例将导致以下输出：
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The assertion `assertTrue(c.getId() != null)` will fail and we will not even
    display the `FINISHED testPersist()` message. Our test case fails before the debug
    message is reached.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 断言`assertTrue(c.getId() != null)`将失败，我们甚至不会显示`FINISHED testPersist()`消息。我们的测试案例在调试消息到达之前失败。
- en: Once again we see the JPA optimization in action. Without the `em.flush()` method,
    JPA will wait until a transaction is committed in order to execute any changes
    in the database. As a result, the primary key may not be set as expected for any
    subsequent code using the newly created entity object within the same transaction.
    This is another trap for the unwary developer, and the `persist` method identifies
    the only situation where an entity manager `flush()` to the database may be required.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次看到JPA优化的作用。没有`em.flush()`方法，JPA将等到事务提交后才执行数据库中的任何更改。结果是，主键可能不会按预期设置为同一事务中新创建的实体对象的任何后续代码。这是对不谨慎开发人员的另一个陷阱，`persist`方法确定了实体管理器`flush()`到数据库可能需要的唯一情况。
- en: Results for the CompanyDaoTests.testRemove test case
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CompanyDaoTests.testRemove测试案例的结果
- en: 'This is probably the most interesting test case so far. The output is:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是迄今为止最有趣的测试案例。输出是：
- en: '[PRE33]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The first `SELECT` statement is executed as a result of finding the first company
    in the list:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`SELECT`语句是为了找到列表中的第一个公司而执行的。
- en: '[PRE34]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The second `SELECT` statement may not be as obvious:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`SELECT`语句可能不那么明显：
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Why does deleting a company result in a `SELECT` statement on the `ttt_project`
    table? The reason is that each `Company` entity may have one or more related `Projects`
    entities as defined in the `Company` class definition:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么删除公司会导致对`ttt_project`表的`SELECT`语句？原因是每个`Company`实体可能有一个或多个相关的`Projects`实体，如`Company`类定义中所定义的：
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'JPA understands that deleting a Company requires a check against the `ttt_project`
    table to see if there are any dependent Projects. In the `@OneToMany` annotation,
    the `cascade = CascadeType.ALL` property defines the behavior if a Company is
    deleted; the change should be cascaded to any dependent entities. In this example,
    deleting a company record will require the deletion of all related project records.
    Each `Project` entity in turn owns a collection of Task entities as defined in
    the `Project` class definition:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: JPA了解到删除公司需要检查`ttt_project`表，以查看是否有任何依赖的Projects。在`@OneToMany`注释中，`cascade =
    CascadeType.ALL`属性定义了删除公司时的行为；更改应该级联到任何依赖实体。在这个例子中，删除公司记录将需要删除所有相关的项目记录。每个`Project`实体依次拥有`Task`实体的集合，如`Project`类定义中所定义的：
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The result of removing a `Company` entity has far-reaching consequences as
    all related Projects and their related Tasks are deleted from the underlying tables.
    A cascade of `DELETE` statements in the testing output is the result of the final
    deletion being that of the company itself. This may not be suitable behavior for
    enterprise applications; in fact, such a cascading of deletions is usually **never**
    implemented without extensive checks to ensure data integrity. A simple change
    in the cascade annotation in the `Company` class will ensure that the deletion
    is not propagated:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 删除`Company`实体的结果具有深远的影响，因为所有相关的Projects及其相关的Tasks都从底层表中删除。在测试输出中级联的`DELETE`语句的结果是最终删除公司本身。这可能不适合企业应用程序的行为；事实上，通常**永远**不会在没有广泛检查以确保数据完整性的情况下实施这样的级联删除。在`Company`类中级联注释的简单更改将确保不会传播删除：
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now only the `MERGE` and `PERSIST` operations on the `Company` entity will
    be cascaded to the related `Project` entities. Running the test case again after
    making this change will result in:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只有对`Company`实体的`MERGE`和`PERSIST`操作将级联到相关的`Project`实体。在进行此更改后再次运行测试案例将导致：
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As the cascade type for `REMOVE` was not included, JPA does not check for related
    rows in the `ttt_project` table and simply attempts to execute the `DELETE` statement
    on the `ttt_company` table. This will fail, as there are related records on the
    `ttt_project` table. It will now only be possible to remove a `Company` entity
    if there are no related `Project` entities (the `projects` field is an empty list).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于未包括`REMOVE`的级联类型，JPA不会检查`ttt_project`表中的相关行，并尝试在`ttt_company`表上执行`DELETE`语句。这将失败，因为`ttt_project`表上有相关记录。现在只有在没有相关的`Project`实体时（`projects`字段是空列表）才能删除`Company`实体。
- en: Note
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Changing the `CascadeType` as outlined in this section adds **business logic**
    to the DAO layer. You will no longer be able to perform certain actions through
    the persistence context. There may, however, be a legitimate situation where you
    **do** want a cascading delete of a `Company` entity and this will no longer be
    possible. `CascadeType.ALL` is the most flexible option, allowing all possible
    scenarios. Business logic such as deletion strategies should be implemented in
    the service layer, which is the subject of the next chapter.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 按照本节中概述的更改`CascadeType`会向DAO层添加**业务逻辑**。您将不再能够通过持久性上下文执行某些操作。然而，可能存在一种合法情况，您**确实**希望对`Company`实体进行级联删除，这将不再可能。`CascadeType.ALL`是最灵活的选项，允许所有可能的情况。删除策略等业务逻辑应该在服务层中实现，这是下一章的主题。
- en: We will continue to use the `cascade = CascadeType.ALL` property and allow JPA-managed
    deletions to propagate. The business logic to restrict these actions will be implemented
    in the service layer.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用`cascade = CascadeType.ALL`属性，并允许JPA管理的删除进行传播。限制这些操作的业务逻辑将在服务层中实现。
- en: JPA traps for the unwary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JPA陷阱
- en: 'There are some JPA traps worthy of special examination. We will start by creating
    the following test case:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些值得特别研究的JPA陷阱。我们将从创建以下测试用例开始：
- en: '[PRE40]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Running this test case may surprise you:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此测试用例可能会让您感到惊讶：
- en: '![JPA traps for the unwary](img/5457OS_05_16.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![JPA陷阱](img/5457OS_05_16.jpg)'
- en: 'The first failure arises from the `userDao.findByUsernamePassword` statement,
    which uses the uppercase password:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个失败来自`userDao.findByUsernamePassword`语句，该语句使用大写密码：
- en: '[PRE41]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Why was the user found with an obviously incorrect password? The reason is
    very simple and is a trap for the unwary developer. Most databases, by default,
    are case insensitive when matching text fields. In this situation the uppercase
    `ADMIN` will match the lowercase `admin` in the password field. Not exactly what
    we want when checking passwords! The database term that describes this behavior
    is collation; we need to modify the password column to use a case-sensitive collation.
    This can be achieved in MySQL with the following SQL command:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会找到具有明显不正确密码的用户？原因非常简单，对于不谨慎的开发人员来说是一个陷阱。大多数数据库在匹配文本字段时默认是不区分大小写的。在这种情况下，大写的`ADMIN`将与密码字段中的小写`admin`匹配。这并不是我们在检查密码时想要的！描述此行为的数据库术语是排序规则；我们需要修改密码列以使用区分大小写的排序规则。这可以通过以下SQL命令在MySQL中实现：
- en: '[PRE42]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Other databases will have similar semantics. This will change the collation
    on the password field to be case sensitive (note the `_cs` appended in `latin1_general_cs`).
    Running the test case will now result in expected behavior for case-sensitive
    password checking:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 其他数据库将具有类似的语义。这将使密码字段的排序规则变为区分大小写（请注意在`latin1_general_cs`中附加的`_cs`）。运行测试用例现在将导致对区分大小写密码检查的预期行为：
- en: '![JPA traps for the unwary](img/5457OS_05_17.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![JPA陷阱](img/5457OS_05_17.jpg)'
- en: 'The `testManyToOne` failure is another interesting case. In this test case,
    we are reassigning the project to a different Company. The `p.setCompany(c2);`
    line will change the assigned company to the second one in the list. We would
    expect that after calling the `merge` method on the project, the collection of
    projects in the `c2` company would contain the newly reassigned project. In other
    words, the following code line should equate to `true`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`testManyToOne`失败是另一个有趣的案例。在这个测试用例中，我们正在将项目重新分配给另一家公司。`p.setCompany(c2);`行将分配的公司更改为列表中的第二家公司。我们期望在对项目调用`merge`方法后，`c2`公司的项目集合将包含新分配的项目。换句话说，以下代码行应该等于`true`：'
- en: '[PRE43]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Likewise, the old company should no longer contain the newly reassigned project
    and hence should be `false`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，旧公司不应再包含新分配的项目，因此应为`false`：
- en: '[PRE44]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This is obviously not the case and identifies a trap for developers new to JPA.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然不是这种情况，并且识别了对JPA新手的陷阱。
- en: 'Although the persistence context understands the relationship between entities
    using `@OneToMany` and `@ManyToOne`, the Java representation of the relationship
    needs to be handled by the developer when collections are concerned. The simple
    changes required are as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管持久性上下文使用`@OneToMany`和`@ManyToOne`理解实体之间的关系，但在涉及集合时，Java表示关系需要由开发人员处理。所需的简单更改如下：
- en: '[PRE45]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: When the `projectDao.merge(p)` line is executed, the persistence context has
    no way of knowing the **original** parent company (if there is one at all; this
    may be a newly inserted project). The original `Company` entity in the persistence
    context still has a collection of projects assigned. This collection will never
    be updated during the lifetime of the `Company` entity within the persistence
    context. The additional two lines of code are used to remove the project (using
    `remove`) from the original company's project list and we add (using `add`) the
    project to the new company to ensure that the persistence context entities are
    updated to the correct state.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行`projectDao.merge(p)`行时，持久性上下文无法知道**原始**父公司（如果有的话；这可能是一个新插入的项目）。持久性上下文中的原始`Company`实体仍然有一组分配的项目。在持久性上下文中，`Company`实体的生命周期内，此集合永远不会被更新。额外的两行代码用于从原始公司的项目列表中删除项目（使用`remove`），并且我们添加（使用`add`）项目到新公司，以确保持久性上下文实体更新到正确的状态。
- en: Exercises
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '1\. Add test assertions to the `CompanyDaoTest.find()` method to test for the
    following scenarios:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 为`CompanyDaoTest.find()`方法添加测试断言，以测试以下情况：
- en: Attempting to find a company with a null primary key
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试查找具有空主键的公司
- en: Attempting to find a company with a negative primary key
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试查找具有负主键的公司
- en: What do you consider to be the expected results?
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 您认为预期结果是什么？
- en: 2\. Create the missing test case files for the `ProjectDao`, `TaskDao`, `UserDao`,
    and `TaskLogDao` implementations.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 为`ProjectDao`、`TaskDao`、`UserDao`和`TaskLogDao`实现创建缺失的测试用例文件。
- en: 3\. Create a test case to determine if removing (deleting) a project will automatically
    remove the project from the owning company's project collection.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 创建一个测试用例，以确定删除项目是否会自动从所属公司的项目集合中删除项目。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have once again covered a lot of territory. Unit testing is a critical part
    of enterprise application development, and the combination of NetBeans, Maven,
    JUnit, and Spring provides us with a solid platform to launch both automated and
    single file test cases. Writing comprehensive test cases is an art form that is
    always appreciated and valued in any high-quality development team; never underestimate
    the confidence gained from working with well-tested code with a solid suite of
    test cases!
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次涵盖了很多领域。单元测试是企业应用程序开发的关键部分，NetBeans、Maven、JUnit和Spring的组合为我们提供了一个坚实的平台，可以启动自动化和单文件测试用例。撰写全面的测试用例是一种艺术形式，在任何高质量的开发团队中都受到赞赏和重视；永远不要低估与经过充分测试的代码一起工作所获得的信心，以及一套坚实的测试用例套件！
- en: In the next chapter, we will examine the role of the service layer in enterprise
    application development. Our 3T business logic will then be implemented using
    the **Data Transfer Objects** (**DTO**) design pattern.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨服务层在企业应用程序开发中的作用。然后，我们将使用**数据传输对象**（**DTO**）设计模式来实现我们的3T业务逻辑。
