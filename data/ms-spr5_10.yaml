- en: Spring Cloud Data Flow
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud Data Flow
- en: Spring Data Flow brings the microservices architecture into typical data flow
    and event flow scenarios. We will discuss more about these scenarios later in
    this chapter. Building on top of other Spring Projects, such as Spring Cloud Stream,
    Spring Integration, and Spring Boot, Spring Data Flow makes it easy to define
    and scale use cases involving data and event flows using message-based integration.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data Flow将微服务架构引入了典型的数据流和事件流场景。我们将在本章后面更多地讨论这些场景。基于其他Spring项目，如Spring
    Cloud Stream、Spring Integration和Spring Boot，Spring Data Flow使得使用基于消息的集成定义和扩展数据和事件流的用例变得容易。
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Why do we need asynchronous communication?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为什么需要异步通信？
- en: What is Spring Cloud Stream? How does it build on top of Spring Integration?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是Spring Cloud Stream？它如何构建在Spring Integration之上？
- en: Why do we need Spring Data Flow?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为什么需要Spring Data Flow？
- en: What are the important concepts in Spring Data Flow you would need to understand?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data Flow中的重要概念是什么？
- en: What are the use cases where Spring Data Flow is useful?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data Flow有哪些有用的用例？
- en: We will also implement a simple event flow scenario with three microservices
    acting as the source (application generating the events), processor, and sink
    (application consuming events). We will implement the microservices using Spring
    Cloud Stream and establish connections between them over the message broker using
    Spring Cloud Data Flow.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将实现一个简单的事件流场景，其中有三个微服务充当源（生成事件的应用程序）、处理器和汇（消费事件的应用程序）。我们将使用Spring Cloud Stream实现这些微服务，并使用Spring
    Cloud Data Flow在消息代理上建立它们之间的连接。
- en: Message-based asynchronous communication
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于消息的异步通信
- en: 'There are two options when integrating applications:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在集成应用程序时有两个选项：
- en: '**Synchronous**: Service consumer invokes the service provider and waits for
    a response.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步**：服务消费者调用服务提供者并等待响应。'
- en: '**Asynchronous**: Service consumer invokes the service provider by putting
    the message on the message broker but does not wait for the response.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步**：服务消费者通过将消息放在消息代理上调用服务提供者，但不等待响应。'
- en: The services that we built with Spring Boot in *Chapter 5, Building Microservices
    with Spring Boot,* (`random` service, `add` service) are examples of synchronous
    integration. These are typical web services that are exposed over HTTP. The service
    consumer calls the service and waits for a response. The next call is made only
    on the completion of the previous service call.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第5章，使用Spring Boot构建微服务*中构建的服务（`random`服务，`add`服务）是同步集成的示例。这些是典型的通过HTTP公开的Web服务。服务消费者调用服务并等待响应。下一次调用只有在前一个服务调用完成后才会进行。
- en: One important disadvantage of this approach is the expectation that the service
    provider is always available. The service consumer will need to re-execute the
    service again if the service provider is down or, for some reason, the service
    fails in execution.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个重要缺点是期望服务提供者始终可用。如果服务提供者宕机，或者由于某种原因服务执行失败，服务消费者将需要重新执行服务。
- en: An alternate approach is to use message-based asynchronous communications. Service
    consumer puts a message on the message broker. The service provider listens on
    the message broker and as soon as a message is available, it processes it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用基于消息的异步通信。服务消费者将消息放在消息代理上。服务提供者在消息代理上监听，一旦有消息可用，就会处理它。
- en: An advantage here is that even if the service provider is down for a while,
    it can process the messages on the message broker whenever it comes back up. The
    service provider does not need to be available all the time. While there is a
    possibility of a lag, data would eventually be consistent.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个优点是，即使服务提供者暂时宕机，它可以在恢复时处理消息代理上的消息。服务提供者不需要一直可用。虽然可能会有延迟，但数据最终会保持一致。
- en: 'The following figure shows an example of asynchronous message-based communication:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了基于异步消息的通信的示例：
- en: '![](img/e4e968de-1d77-43b1-bd60-0ce412b12ac0.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e4e968de-1d77-43b1-bd60-0ce412b12ac0.png)'
- en: 'There are two kinds of scenarios where asynchronous communication improves
    reliability:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 异步通信改善可靠性的两种情况：
- en: If the service provider is down, then the messages will be queued in the message
    broker. When service provider is back up, it will process these messages. So,
    the messages will not be lost even if service provider is down.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果服务提供者宕机，那么消息将在消息代理中排队。当服务提供者恢复时，它将处理这些消息。因此，即使服务提供者宕机，消息也不会丢失。
- en: If there is an error in processing the message, the service provider will put
    the message in an error channel. When the error is analyzed and fixed, the message
    can be moved from the error channel to the input channel and queued for reprocessing.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果消息处理出现错误，服务提供者将把消息放入错误通道。当错误被分析和修复后，消息可以从错误通道移动到输入通道，并排队等待重新处理。
- en: The important thing to note is that in both the preceding scenarios, service
    consumer does not need to worry if the service provider is down or message processing
    has failed. Service consumer sends a message and forgets about it. The messaging
    architecture ensures that the message is eventually processed successfully.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，在前面的两种情况中，服务消费者不需要担心服务提供者是否宕机或消息处理失败。服务消费者发送消息后就可以忘记它了。消息架构确保消息最终会成功处理。
- en: 'Message-based asynchronous communication is typically used in event flows and
    data flows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 基于消息的异步通信通常用于事件流和数据流：
- en: '**Event flows**: This involve processing logic based on an event. For example,
    a new customer event or a stock price change event or a currency change event.
    Downstream applications will be listening on the message broker for events and
    will react to them.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件流**：这涉及基于事件的处理逻辑。例如，新客户事件、股价变动事件或货币变动事件。下游应用程序将在消息代理上监听事件并对其做出反应。'
- en: '**Data flows**: This involve data that is enhanced through multiple applications
    and finally stored down to a data store.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据流**：这涉及通过多个应用程序增强的数据，并最终存储到数据存储中。'
- en: Functionally, the content of the message exchanged between data flow architectures
    is different from that of event flow architectures. However, technically, it is
    a just another message that is sent from one system to another. In this chapter,
    we will not differentiate between event and data flows. Spring Cloud Data Flow
    can handle all these flows--in spite of having only data flow in the name. We
    use event flow, data flow, or message flow interchangeably to indicate a flow
    of messages between different applications.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在功能上，数据流架构之间交换的消息内容与事件流架构不同。但从技术上讲，它只是从一个系统发送到另一个系统的另一条消息。在本章中，我们不会区分事件和数据流。Spring
    Cloud数据流可以处理所有这些流--尽管只有数据流在名称中。我们可以互换使用事件流、数据流或消息流来指示不同应用程序之间的消息流。
- en: Complexities of asynchronous communication
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步通信的复杂性
- en: While the preceding example is a simple communication between two applications,
    typical flows in real-world applications can be much more complex.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的示例是两个应用程序之间的简单通信，但在现实世界的应用程序中，典型的流程可能要复杂得多。
- en: 'The following figure shows an example scenario involving the message flow across
    three different applications. The source application generates the event. The
    processor application processes the event and generates another message that will
    be processed by the sink application:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了涉及消息流的三个不同应用程序的示例场景。源应用程序生成事件。处理器应用程序处理事件并生成另一条消息，将由接收应用程序处理：
- en: '![](img/1ef4605f-eba9-4a16-b50c-6be64bf87b15.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1ef4605f-eba9-4a16-b50c-6be64bf87b15.png)'
- en: 'Another example scenario involves an event that is consumed by multiple applications.
    For example, when a customer is registered, we would want to send them an e-mail,
    a welcome kit, and a mail. A simple messaging architecture for this scenario is
    shown in the following figure:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个示例场景涉及一个事件被多个应用程序消耗。例如，当客户注册时，我们希望给他们发送电子邮件、欢迎包和邮件。该场景的简单消息架构如下图所示：
- en: '![](img/d1fa3516-aa1e-4224-a9eb-2d92f5b566c8.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1fa3516-aa1e-4224-a9eb-2d92f5b566c8.png)'
- en: 'To implement the preceding scenarios, a number of different steps are involved:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现上述场景，涉及许多不同的步骤：
- en: Configuring the message broker.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置消息代理。
- en: Creating different channels on the message broker.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在消息代理上创建不同的通道。
- en: Writing application code to connect to a specific channel on the message broker.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写应用程序代码以连接到消息代理上的特定通道。
- en: Installing necessary binders in the applications to connect to the message brokers.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序中安装必要的绑定器以连接到消息代理。
- en: Setting up the connection between the applications and the message broker.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立应用程序与消息代理之间的连接。
- en: Building and deploying the applications.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建和部署应用程序。
- en: Consider a scenario where some of these applications in the flow have to process
    a huge load of messages. We would need to create multiple instances of such applications
    based on the load. The implementation complexity becomes multifold. These are
    the challenges that Spring Cloud Data Flow and Spring Cloud Stream aim to solve.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一个场景，其中流程中的一些应用程序必须处理大量的消息负载。我们需要根据负载创建多个这样的应用程序实例。实现复杂性变得多方面。这些是Spring
    Cloud数据流和Spring Cloud Stream旨在解决的挑战。
- en: In the next section, we will look at how different Spring projects--Spring Cloud
    Stream (built on top of Spring Integration) and Spring Cloud Data Flow enable
    us to do message-based integrations with little configuration.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看不同的Spring项目--Spring Cloud Stream（构建在Spring集成之上）和Spring Cloud数据流如何使我们能够进行基于消息的集成，而无需进行大量配置。
- en: Spring projects for asynchronous messages
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于异步消息的Spring项目
- en: In this section, we will look at different projects provided by Spring to enable
    message-based communication between applications. We will start with Spring Integration
    and then move on to projects that enable message-based integration even on the
    Cloud--Spring Cloud Stream and Spring Cloud Data Flow.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看Spring提供的不同项目，以实现应用程序之间基于消息的通信。我们将从Spring集成开始，然后转向在云上甚至能够实现基于消息的集成的项目--Spring
    Cloud Stream和Spring Cloud数据流。
- en: Spring Integration
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring集成
- en: 'Spring Integration helps integrate microservices seamlessly over a message
    broker. It allows programmers to focus on business logic and give control of the
    technical infrastructure (what message format to use? How to connect to message
    broker?) to the framework. Spring Integration provide a variety of configuration
    options through well-defined interfaces and message adapters. Spring Integration
    website ([https://projects.spring.io/spring-integration/](https://projects.spring.io/spring-integration/)):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Spring集成有助于在消息代理上无缝集成微服务。它允许程序员专注于业务逻辑，并将技术基础设施的控制（使用什么消息格式？如何连接到消息代理？）交给框架。Spring集成通过定义良好的接口和消息适配器提供了各种配置选项。Spring集成网站（[https://projects.spring.io/spring-integration/](https://projects.spring.io/spring-integration/)）：
- en: Extends the Spring programming model to support the well-known Enterprise Integration
    Patterns. Spring Integration enables lightweight messaging within Spring-based
    applications and supports integration with external systems via declarative adapters.
    Those adapters provide a higher-level of abstraction over Spring's support for
    remoting, messaging, and scheduling. Spring Integration's primary goal is to provide
    a simple model for building enterprise integration solutions while maintaining
    the separation of concerns that is essential for producing maintainable, testable
    code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展Spring编程模型以支持众所周知的企业集成模式。Spring集成使Spring应用程序内部实现轻量级消息传递，并通过声明性适配器支持与外部系统的集成。这些适配器提供了对Spring支持远程调用、消息传递和调度的更高级抽象。Spring集成的主要目标是提供一个简单的模型来构建企业集成解决方案，同时保持关注点的分离，这对于生成可维护、可测试的代码至关重要。
- en: 'Features provided by Spring Integration include the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Integration 提供的功能包括以下内容：
- en: Simple implementations for enterprise integration patterns
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业集成模式的简单实现
- en: Aggregation of responses from multiple services
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合来自多个服务的响应
- en: Filtering results from the service
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从服务中过滤结果
- en: Service message transformation
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务消息转换
- en: Multiple protocol support--HTTP, FTP/SFTP, TCP/UDP, JMS
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多协议支持--HTTP、FTP/SFTP、TCP/UDP、JMS
- en: Support for different styles of Webservices (SOAP and REST)
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持不同风格的 Web 服务（SOAP 和 REST）
- en: Support for multiple message brokers, for example, RabbitMQ
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持多个消息代理，例如 RabbitMQ
- en: In the previous chapter, we used Spring Cloud to make our microservices Cloud-Native--to
    be deployed in the Cloud and utilize all the benefits of Cloud deployment.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用了 Spring Cloud 来使我们的微服务成为云原生--部署在云中并利用云部署的所有优势。
- en: However, applications built with Spring Integration, especially those that interact
    with message brokers, need a lot of configuration to be deployed into the Cloud.
    This prevents them from taking advantage of the typical benefits of the Cloud,
    such as automatic scaling.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用 Spring Integration 构建的应用程序，特别是与消息代理交互的应用程序，需要大量配置才能部署到云中。这阻止它们利用云的典型优势，例如自动扩展。
- en: We would want to extend the features provided by Spring Integration and make
    them available on the Cloud. We would want new instances of our microservice cloud
    instances to be able to automatically integrate with message brokers. We would
    want to be able to scale our microservice cloud instances automatically without
    manual configuration. That's where Spring Cloud Stream and Spring Cloud Data Flow
    come in.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望扩展 Spring Integration 提供的功能，并在云上提供这些功能。我们希望我们的微服务云实例能够自动与消息代理集成。我们希望能够自动扩展我们的微服务云实例，而无需手动配置。这就是
    Spring Cloud Stream 和 Spring Cloud Data Flow 的用武之地。
- en: Spring Cloud Stream
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud Stream
- en: Spring Cloud Stream is the framework of choice to build message-driven microservices
    for the Cloud.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Stream 是构建面向云的消息驱动微服务的首选框架。
- en: 'Spring Cloud Stream allows programmers to focus on building microservices around
    the business logic of event processing, leaving infrastructure concerns, listed
    here, to the framework(s):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Stream 允许程序员专注于围绕事件处理的业务逻辑构建微服务，将这里列出的基础设施问题留给框架处理：
- en: Message broker configuration and channel creation
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息代理配置和通道创建
- en: Message-broker-specific conversions for message
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对消息代理的特定转换
- en: Creating binders to connect to the message broker
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建绑定器以连接到消息代理
- en: Spring Cloud Stream fits hand in glove into the microservices architecture.
    The typical microservices needed in use cases of event processing or data streaming
    can be designed with a clear separation of concerns. Individual microservices
    can handle business logic, define the input/output channels and leave the infrastructure
    concerns to the framework.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Stream 完美地融入了微服务架构。在事件处理或数据流的用例中，可以设计具有明确关注点分离的典型微服务。单独的微服务可以处理业务逻辑，定义输入/输出通道，并将基础设施问题留给框架。
- en: 'Typical stream applications involve the creation of events, processing of events,
    and storing down to a data store. Spring Cloud Stream provides three simple kinds
    of applications to support typical stream flows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的流应用程序涉及事件的创建、事件的处理和存储到数据存储中。Spring Cloud Stream 提供了三种简单的应用程序类型来支持典型的流程：
- en: '**Source**: Source is the creator of events, for example, the application that
    triggers a stock price change event.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Source**：Source 是事件的创建者，例如触发股价变动事件的应用程序。'
- en: '**Processor**: Processor consumes an even, that is, processes a message, does
    some processing around it, and creates an event with the result.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Processor**：Processor 消耗事件，即处理消息，对其进行一些处理，并创建带有结果的事件。'
- en: '**Sink**: Sink consumes events. It listens on to a message broker and stores
    the event to a persistent data store.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sink**：Sink 消耗事件。它监听消息代理并将事件存储到持久数据存储中。'
- en: Spring Cloud Stream is used to create individual microservices in the data flow.
    Spring Cloud Stream microservices define business logic and the connection points,
    the inputs and/or outputs. Spring Cloud Data Flow helps in defining the flow,
    that is, connecting different applications.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Stream 用于在数据流中创建单独的微服务。Spring Cloud Stream 微服务定义业务逻辑和连接点，即输入和/或输出。Spring
    Cloud Data Flow 有助于定义流程，即连接不同的应用程序。
- en: Spring Cloud Data Flow
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud Data Flow
- en: Spring Cloud Data Flow helps in establishing message flows between different
    kinds of microservices created using Spring Cloud Stream.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Data Flow 有助于在使用 Spring Cloud Stream 创建的不同类型的微服务之间建立消息流。
- en: Built on top of popular open source projects, **Spring XD** simplifies the creation
    of data pipelines and workflows--especially for Big Data use cases. However, Spring
    XD has challenges adapting to newer requirements (canary deployments and distributed
    tracing, for example) related to data pipelines. Spring XD architecture is based
    on a run-time dependent on a number of peripherals. This makes sizing the cluster
    a challenging exercise. Spring XD is now resigned as Spring Cloud Data Flow. The
    architecture of Spring Cloud Data Flow is based on composable microservice applications.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 基于流行的开源项目，**Spring XD** 简化了数据管道和工作流的创建--特别是针对大数据用例。然而，Spring XD 在适应与数据管道相关的新要求（例如金丝雀部署和分布式跟踪）方面存在挑战。Spring
    XD 架构基于运行时依赖于多个外围设备。这使得调整集群规模成为一项具有挑战性的任务。Spring XD 现在被重新命名为 Spring Cloud Data
    Flow。Spring Cloud Data Flow 的架构基于可组合的微服务应用程序。
- en: 'Important features in Spring Cloud Data Flow are as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Data Flow 中的重要特性如下：
- en: Configuring a stream, that is, how data or events flow from one application
    to another. Stream DSL is used to define the flow between applications.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置流，即数据或事件如何从一个应用程序流向另一个应用程序。Stream DSL 用于定义应用程序之间的流程。
- en: Establishing a connection between the applications and the message broker.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立应用程序与消息代理之间的连接。
- en: Providing analytics around applications and streams.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供围绕应用程序和流的分析。
- en: Deploying applications defined in streams to the target runtime.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将在流中定义的应用程序部署到目标运行时。
- en: Support for multiple target runtimes. Almost every popular cloud platform is
    supported.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持多个目标运行时。几乎每个流行的云平台都得到支持。
- en: Scaling up applications on the Cloud.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在云上扩展应用程序。
- en: Creating and invoking tasks.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和调用任务。
- en: Sometimes, the terminology can get a little confusing. A stream is an alternate
    terminology for a flow. It's important to remember that Spring Cloud Stream actually
    does not define the entire stream. It only helps in creating one of the microservices
    involved in the entire stream. As we will see in the next sections, streams are
    actually defined using Stream DSL in Spring Cloud Data Flow.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，术语可能会有点混淆。流是流的另一种术语。重要的是要记住，Spring Cloud Stream实际上并没有定义整个流。它只有助于创建整个流中涉及的微服务之一。正如我们将在接下来的部分中看到的，流实际上是使用Spring
    Cloud Data Flow中的Stream DSL来定义的。
- en: Spring Cloud Stream
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud Stream
- en: Spring Cloud Stream is used to create individual microservices involved in a
    stream and define the connection points to a message broker.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Stream用于创建涉及流的单个微服务，并定义与消息代理的连接点。
- en: 'Spring Cloud Stream is built on top of two important Spring Projects:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Stream是建立在两个重要的Spring项目之上的：
- en: '**Spring Boot**: To enable the creation of production-ready microservices'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring Boot**：使微服务能够创建适用于生产的微服务'
- en: '**Spring Integration**: To enable microservices to communicate over message
    brokers'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring Integration**：使微服务能够通过消息代理进行通信'
- en: 'Some of the important features of Spring Cloud Stream are as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Stream的一些重要特性如下：
- en: Bare minimum configuration to connect a microservice to a message broker.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将微服务连接到消息代理的最低配置。
- en: Support for a variety of message brokers--RabbitMQ, Kafka, Redis, and GemFire.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持各种消息代理--RabbitMQ、Kafka、Redis和GemFire。
- en: Support for persistence of messages--in case a service is down, it can start
    processing the messages once it is back up.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持消息的持久性--如果服务宕机，它可以在恢复后开始处理消息。
- en: Support for consumer groups--in cases of heavy loads, you need multiple instances
    of the same microservice. You can group all these microservice instances under
    a single consumer group so that the message is picked up only by one of the available
    instances.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持消费者组--在负载较重的情况下，您需要多个相同微服务的实例。您可以将所有这些微服务实例分组到一个消费者组中，以便消息只被可用实例中的一个接收。
- en: Support for partitioning--there can be situations where you would want to ensure
    that a specific set of messages are addressed by the same instance. Partitioning
    allows you to configure the criteria to identify messages to be handled by the
    same partition instance.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持分区--可能存在这样的情况，您希望确保一组特定的消息由同一个实例处理。分区允许您配置标准来识别由同一分区实例处理的消息。
- en: Spring Cloud Stream architecture
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud Stream架构
- en: 'The following figure shows an architecture of a typical Spring Cloud Stream
    microservice. A source would only have an input channel, the processor would have
    both the input and output channel, and a sink would have only an output channel:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了典型Spring Cloud Stream微服务的架构。源只有一个输入通道，处理器既有输入通道又有输出通道，而汇则只有一个输出通道：
- en: '![](img/4a31fe0b-fb4e-420d-9a05-a11cdff9254a.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a31fe0b-fb4e-420d-9a05-a11cdff9254a.png)'
- en: Applications declare what kind of connection they would want--an input and/or
    an output. Spring Cloud Stream will establish all that would be needed to connect
    applications over the message broker.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序声明它们想要什么样的连接--输入和/或输出。Spring Cloud Stream将建立连接应用程序与消息代理所需的一切。
- en: 'Spring Cloud Stream would do the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Stream将执行以下操作：
- en: Inject the input and/or output channels into the application
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将输入和/或输出通道注入到应用程序中
- en: Establish connections with the message broker through a message=broker-specific
    binder
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过特定于消息代理的绑定器建立与消息代理的连接。
- en: Binders bring configurability to Spring Cloud Stream applications. A String
    Cloud Stream application only declares the channels. Deployment team can configure,
    at runtime, which message broker (Kafka or RabbitMQ) the channels connect to.
    Spring Cloud Stream uses auto-configuration to detect the binder available on
    the classpath. To connect to a different message broker, all that we need to do
    is change the dependency for the project. Another option is to include multiple
    binders in the classpath and choose the one to use at runtime.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定器为Spring Cloud Stream应用程序带来了可配置性。一个Spring Cloud Stream应用程序只声明通道。部署团队可以在运行时配置通道连接到哪个消息代理（Kafka或RabbitMQ）。Spring
    Cloud Stream使用自动配置来检测类路径上可用的绑定器。要连接到不同的消息代理，我们只需要改变项目的依赖。另一个选项是在类路径中包含多个绑定器，并在运行时选择要使用的绑定器。
- en: Event processing - stock trading example
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件处理-股票交易示例
- en: 'Let''s imagine a scenario. A stock trader is interested in significant stock
    price changes of stocks that he/she has invested in. The following figure shows
    a simple architecture of such an application built with Spring Cloud Stream:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个场景。一位股票交易员对他/她投资的股票的重大股价变动感兴趣。以下图显示了使用Spring Cloud Stream构建的这样一个应用程序的简单架构：
- en: '![](img/07fb81a0-b47c-43c0-91de-bf6dedf0db93.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/07fb81a0-b47c-43c0-91de-bf6dedf0db93.png)'
- en: 'Important things to note are as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的重要事项如下：
- en: '**Significant stock price change microservice**: This triggers an event on
    the message broker whenever there is a significant change in the price of any
    stock listed on the exchange. This is the **Source** application.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重要股价变动微服务**：每当交易所上市的任何股票的价格发生重大变动时，它会在消息代理上触发一个事件。这是**源**应用程序。'
- en: '**Stock intelligence microservice**: This listens to the message brokers for
    stock price change events. When there is a new message, it checks the stock against
    inventory and adds information on the user''s current holdings to the message
    and puts another message on the message broker. This is the **Processor** application.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**股票智能微服务**：这个微服务监听股价变化事件的消息代理。当有新消息时，它会检查股票库存并将有关用户当前持仓的信息添加到消息中，并将另一条消息放在消息代理上。这是**处理器**应用程序。'
- en: '**Event store microservice**: This listens on the message broker for stock
    price change on an invested stock alert. When there is a new message, it stores
    it down in data store. This is the **Sink** application.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件存储微服务**：这个微服务在消息代理上监听投资股票警报的股价变化。当有新消息时，它将其存储在数据存储中。这是**接收器**应用程序。'
- en: 'The preceding architecture gives us the flexibility to enhance our systems
    without major changes:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的架构为我们提供了在不进行重大更改的情况下增强系统的灵活性：
- en: E-mail microservice and SMS microservice listens on the message broker for stock
    price change on an invested stock alert and sends an e-mail/SMS alert.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子邮件微服务和短信微服务在消息代理上监听投资股票警报的股价变化，并发送电子邮件/短信警报。
- en: A stock trader might want to make significant changes in other stocks they have
    not invested in. Stock intelligence microservice can be enhanced further.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 股票交易员可能希望对他们没有投资的其他股票进行重大更改。股票智能微服务可以进一步增强。
- en: As we discussed earlier, Spring Cloud Stream helps us build the basic building
    blocks of a stream, that is, the microservices. We will create three microservices
    using Spring Cloud Stream. We will later use these three microservices and create
    a stream, that is, a flow between the applications using Spring Cloud Data Flow.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，Spring Cloud Stream帮助我们构建流的基本构建模块，也就是微服务。我们将使用Spring Cloud Stream创建三个微服务。我们稍后将使用这三个微服务并使用Spring
    Cloud Data Flow创建一个流，也就是使用Spring Cloud Data Flow在应用程序之间创建一个流程。
- en: 'We will start with creating the microservices using Spring Cloud Stream in
    the next section. Before we start with source, processor, and sink stream applications,
    we will set up a simple model project:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从下一节开始使用Spring Cloud Stream创建微服务。在开始源、处理器和接收器流应用程序之前，我们将设置一个简单的模型项目：
- en: Model for stock trading example
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 股票交易示例的模型
- en: 'The `StockPriceChangeEvent` class contains the ticker of the stock, the old
    price of the stock, and the new prices of the stock:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`StockPriceChangeEvent`类包含股票的代码、股票的旧价格和股票的新价格：'
- en: '[PRE0]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `StockPriceChangeEventWithHoldings` class extends `StockPriceChangeEvent`.
    It has one additional property--`holdings`. The `holdings` variable is used to
    store the number of stocks the trader currently owns:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`StockPriceChangeEventWithHoldings`类扩展了`StockPriceChangeEvent`。它有一个额外的属性--`holdings`。`holdings`变量用于存储交易员当前拥有的股票数量：'
- en: '[PRE1]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `StockTicker` enum stores list of stocks that the application supports:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`StockTicker`枚举存储应用程序支持的股票列表：'
- en: '[PRE2]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The source application
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源应用程序
- en: The source application will be the producer of stock price change events. It
    will define an output channel and put a message on the message broker.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 源应用程序将是股价变化事件的生产者。它将定义一个输出通道并将消息放在消息代理上。
- en: 'Let''s use Spring Initializr ([https://start.spring.io](https://start.spring.io))
    to set up the application. Provide the details listed here and click on Generate
    Project:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Spring Initializr（[https://start.spring.io](https://start.spring.io)）来设置应用程序。提供这里列出的详细信息，然后点击生成项目：
- en: 'Group: `com.mastering.spring.cloud.data.flow`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组：`com.mastering.spring.cloud.data.flow`
- en: 'Artifact: `significant-stock-change-source`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Artifact：`significant-stock-change-source`
- en: 'Dependencies: `Stream Rabbit`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖项：`Stream Rabbit`
- en: 'Listed here are some of the important dependencies from the `pom.xml` file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`pom.xml`文件中的一些重要依赖项：
- en: '[PRE3]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Update the `SpringBootApplication` file with the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码更新`SpringBootApplication`文件：
- en: '[PRE4]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A few important things to note are as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一些重要事项如下：
- en: '`@EnableBinding(Source.class)`: The `EnableBinding` annotation enables binding
    a class with the respective channel it needs--an input and/or an output. The source
    class is used to register a Cloud Stream with one output channel.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@EnableBinding(Source.class)`：`EnableBinding`注解使类与它需要的相应通道进行绑定--输入和/或输出。源类用于注册一个具有一个输出通道的Cloud
    Stream。'
- en: '`@Bean @InboundChannelAdapter(value = Source.OUTPUT, poller = @Poller(fixedDelay
    = "60000", maxMessagesPerPoll = "1"))`: The `InboundChannelAdapter` annotation
    is used to indicate that this method can create a message to be put on a message
    broker. The value attribute is used to indicate the name of the channel where
    the message is to be put. `Poller` is used to schedule the generation of messages.
    In this example, we are using `fixedDelay` to generate messages every minute (60
    * 1000 ms).'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Bean @InboundChannelAdapter(value = Source.OUTPUT, poller = @Poller(fixedDelay
    = "60000", maxMessagesPerPoll = "1"))`：`InboundChannelAdapter`注解用于指示该方法可以创建要放在消息代理上的消息。value属性用于指示消息要放置的通道的名称。`Poller`用于调度消息的生成。在这个例子中，我们使用`fixedDelay`每分钟生成一次消息（60
    * 1000 ms）。'
- en: '`private int getRandomNumber(int min, int max)`: This method is used to create
    a random number in the range passed as parameters.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private int getRandomNumber(int min, int max)`：这个方法用于在传递的范围内创建一个随机数。'
- en: 'The `Source` interface defines an output channel, as shown in the following
    code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`Source`接口定义了一个输出通道，如下面的代码所示：'
- en: '[PRE5]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Processor
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理器
- en: The processor application will pick up the message from the input channel on
    the message broker. It will process the message and put it out on the output channel
    of the message broker. In this specific example, processing involves adding the
    position of current holdings to the message.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器应用程序将从消息代理的输入通道接收消息。它将处理消息并将其放在消息代理的输出通道上。在这个特定的例子中，处理包括将当前持仓的位置添加到消息中。
- en: 'Let''s use Spring Initializr ([https://start.spring.io](https://start.spring.io))
    to set up the application. Provide the details listed here and click on Generate
    Project:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Spring Initializr（[https://start.spring.io](https://start.spring.io)）来设置应用程序。提供这里列出的详细信息，然后点击生成项目：
- en: 'Group: `com.mastering.spring.cloud.data.flow`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组：`com.mastering.spring.cloud.data.flow`
- en: 'Artifact: `stock-intelligence-processor`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构件：`stock-intelligence-processor`
- en: 'Dependencies: `Stream Rabbit`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖：`Stream Rabbit`
- en: 'Update the `SpringBootApplication` file with the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码更新`SpringBootApplication`文件：
- en: '[PRE6]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A few important things to note are as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一些重要事项如下：
- en: '`@EnableBinding(Processor.class)`: The `EnableBinding` annotation enables binding
    a class with the respective channel it needs--an input and/or an output. The `Processor`
    class is used to register a Cloud Stream with one input channel and one output
    channel.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@EnableBinding(Processor.class)`: `EnableBinding`注解用于将类与其所需的相应通道绑定--输入和/或输出。`Processor`类用于注册一个具有一个输入通道和一个输出通道的Cloud
    Stream。'
- en: '`private static Map<StockTicker, Integer> getHoldingsFromDatabase()`: This
    method processes a message, updates the holdings, and return a new object, which
    will be put as a new message into the output channel.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private static Map<StockTicker, Integer> getHoldingsFromDatabase()`: 这个方法处理消息，更新持有量，并返回一个新对象，该对象将作为新消息放入输出通道。'
- en: '`@Transformer(inputChannel = Processor.INPUT, outputChannel = Processor.OUTPUT)`:
    The `Transformer` annotation is used to indicate a method that is capable of transforming/enhancing
    one message format into another.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Transformer(inputChannel = Processor.INPUT, outputChannel = Processor.OUTPUT)`:
    `Transformer`注解用于指示一个能够将一种消息格式转换/增强为另一种消息格式的方法。'
- en: 'As shown in the following code, the `Processor` class extends the `Source`
    and `Sink` classes. Hence, it defines both the output and input channels:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，`Processor`类扩展了`Source`和`Sink`类。因此，它定义了输出和输入通道：
- en: '[PRE7]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Sink
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sink
- en: Sink will pick the message from the message broker and process it. In this example,
    we will pick the message and log it. A Sink will define an input channel only.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Sink将从消息代理中提取消息并处理它。在这个例子中，我们将提取消息并记录它。Sink只定义了一个输入通道。
- en: 'Let''s use Spring Initializr ([https://start.spring.io](https://start.spring.io))
    to set up the application. Provide the details listed here and click on Generate
    Project:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Spring Initializr ([https://start.spring.io](https://start.spring.io))来设置应用程序。提供这里列出的细节，然后点击生成项目：
- en: 'Group: `com.mastering.spring.cloud.data.flow`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组：`com.mastering.spring.cloud.data.flow`
- en: 'Artifact: `event-store-sink`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构件：`event-store-sink`
- en: 'Dependencies: `Stream Rabbit`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖：`Stream Rabbit`
- en: 'Update the `SpringBootApplication` file with the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码更新`SpringBootApplication`文件：
- en: '[PRE8]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A few important things to note are as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一些重要事项如下：
- en: '`@EnableBinding(Sink.class)`: The `EnableBinding` annotation enables binding
    a class with the respective channel it needs--an input and/or an output. The `Sink`
    class is used to register a Cloud Stream with one input channel.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@EnableBinding(Sink.class)`: `EnableBinding`注解用于将类与其所需的相应通道绑定--输入和/或输出。`Sink`类用于注册一个具有一个输入通道的Cloud
    Stream。'
- en: '`public void loggerSink(StockPriceChangeEventWithHoldings event)`: This method
    typically contains the logic to store a message to the data store. In this example,
    we are printing the message to the log.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void loggerSink(StockPriceChangeEventWithHoldings event)`: 这个方法通常包含将消息存储到数据存储的逻辑。在这个例子中，我们将消息打印到日志中。'
- en: '`@StreamListener(Sink.INPUT)`: The `StreamListener` annotation is used to listen
    on a channel for incoming messages. In this example, `StreamListener` is configured
    to listen on the default input channel.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@StreamListener(Sink.INPUT)`: `StreamListener`注解用于监听传入消息的通道。在这个例子中，`StreamListener`配置为监听默认输入通道。'
- en: 'As shown in the following snippet, the `Sink` interface defines an input channel:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如下代码所示，`Sink`接口定义了一个输入通道：
- en: '[PRE9]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that we have the three stream applications ready, we will need to connect
    them. In the next section, we will cover how Spring Cloud Data Flow helps in connecting
    different streams.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了三个流应用程序准备好了，我们需要连接它们。在下一节中，我们将介绍Spring Cloud Data Flow如何帮助连接不同的流。
- en: Spring Cloud Data Flow
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud Data Flow
- en: Spring Cloud Data Flow helps in establishing message flows between different
    kinds of microservices created using Spring Cloud Stream. All the microservices
    that are deployed through the Spring Cloud Data Flow server should be Spring Boot
    microservices that define appropriate channels.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Data Flow有助于建立使用Spring Cloud Stream创建的不同类型的微服务之间的消息流。通过Spring Cloud
    Data Flow服务器部署的所有微服务都应该是定义了适当通道的Spring Boot微服务。
- en: Spring Cloud Data Flow provides interfaces to define applications and define
    flows between them using Spring DSL. Spring Data Flow Server understands the DSL
    and establishes the flow between applications.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Data Flow提供了接口来定义应用程序，并使用Spring DSL定义它们之间的流。Spring Data Flow服务器理解DSL并在应用程序之间建立流。
- en: 'Typically, this involves multiple steps:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这涉及多个步骤：
- en: Using a mapping between the application name and the deployable unit of the
    application to download the application artifacts from repositories. Spring Data
    Flow Server supports Maven and Docker repositories.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用应用程序名称和应用程序的可部署单元之间的映射来从存储库下载应用程序构件。Spring Data Flow Server支持Maven和Docker存储库。
- en: Deploying the applications to the target runtime.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序部署到目标运行时。
- en: Creating channels on the message broker.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在消息代理上创建通道。
- en: Establishing connections between the applications and the message broker channels.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立应用程序和消息代理通道之间的连接。
- en: 'Spring Cloud Data Flow also provides options for the scaling of the applications
    involved when needed. A deployment manifest maps applications to target runtime.
    A couple of questions that a deployment manifest answers are as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Data Flow还提供了在需要时扩展所涉及的应用程序的选项。部署清单将应用程序映射到目标运行时。部署清单需要回答的一些问题如下：
- en: How many instances of an application need to be created?
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要创建多少个应用程序实例？
- en: How much memory is needed by each instance of an application?
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个应用程序实例需要多少内存？
- en: 'Data Flow Server understands the deployment manifests and creates the target
    runtime as specified. Spring Cloud Data Flow supports a variety of runtimes:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流服务器理解部署清单并按照指定的方式创建目标运行时。Spring Cloud Data Flow支持各种运行时：
- en: Cloud Foundry
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云原生
- en: Apache YARN
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache YARN
- en: Kubernetes
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes
- en: Apache Mesos
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache Mesos
- en: Local server for development
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于开发的本地服务器
- en: We will use the local server in our examples in this chapter.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例将使用本地服务器。
- en: High-level architecture
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级架构
- en: 'In the preceding example, we have three microservices that need to be connected
    in a data flow. The following figure represents the high-level architecture of
    implementing the solution with Spring Cloud Data Flow:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们有三个需要在数据流中连接的微服务。以下图表示使用Spring Cloud Data Flow实现解决方案的高级架构：
- en: '![](img/60d12ed9-8204-48cf-a89f-6c162c9e5427.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60d12ed9-8204-48cf-a89f-6c162c9e5427.png)'
- en: 'In the preceding figure, source, sink, and processor are Spring Boot microservices
    created using Spring Cloud Stream:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，源、接收器和处理器是使用Spring Cloud Stream创建的Spring Boot微服务：
- en: The source microservice defines an output channel
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源微服务定义了一个输出通道
- en: The processor microservice defines both input and output channels
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理器微服务定义了输入和输出通道
- en: The sink microservice defines an input channel
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收器微服务定义了一个输入通道
- en: Implementing Spring Cloud Data Flow
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施Spring Cloud Data Flow
- en: 'Implementing Spring Cloud Data Flow involves five steps:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 实施Spring Cloud Data Flow涉及五个步骤：
- en: Setting up Spring Cloud Data Flow server.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置Spring Cloud Data Flow服务器。
- en: Setting up the Data Flow Shell project.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置Data Flow Shell项目。
- en: Configuring the apps.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置应用程序。
- en: Configuring the stream.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置流。
- en: Running the stream.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行流。
- en: Setting up Spring Cloud Data Flow server
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Spring Cloud Data Flow服务器
- en: 'Let''s use Spring Initializr ([https://start.spring.io](https://start.spring.io))
    to set up the application. Provide the details listed here and click on Generate
    Project:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Spring Initializr（[https://start.spring.io](https://start.spring.io)）来设置应用程序。提供这里列出的详细信息，然后单击“生成项目”：
- en: 'Group: `com.mastering.spring.cloud.data.flow`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组：`com.mastering.spring.cloud.data.flow`
- en: 'Artifact: `local-data-flow-server`'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Artifact：`local-data-flow-server`
- en: 'Dependencies: `Local Data Flow Server`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖项：`本地Data Flow服务器`
- en: 'Listed here are some of the important dependencies from the `pom.xml` file:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`pom.xml`文件中一些重要的依赖项：
- en: '[PRE10]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Update the `SpringBootApplication` file with the following code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`SpringBootApplication`文件，使用以下代码：
- en: '[PRE11]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `@EnableDataFlowServer` annotation is used to activate a Spring Cloud Data
    Flow Server implementation.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`@EnableDataFlowServer`注解用于激活Spring Cloud Data Flow服务器实现。'
- en: Before you run the Local Data Flow Server, ensure that the message broker RabbitMQ
    is up and running.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行本地Data Flow服务器之前，请确保消息代理RabbitMQ正在运行。
- en: 'The following is an important extract from the start up log when `LocalDataFlowServerApplication`
    is launched:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在启动`LocalDataFlowServerApplication`时的启动日志中的重要摘录：
- en: '[PRE12]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A few important things to note are as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一些重要事项如下：
- en: The default port for Spring Cloud Data Flow server is `9393`. This can be changed
    by specifying a different port as `server.port` in `application.properties`.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud Data Flow服务器的默认端口是`9393`。可以通过在`application.properties`中指定不同的端口`server.port`来更改这一点。
- en: Spring Cloud Data Flow Server uses an internal schema to store all the configuration
    of applications, tasks, and streams. In this example, we have not configured any
    database. So, by default, the `H2` in-memory database is used. Spring Cloud Data
    Flow Server supports a variety of databases, including MySQL and Oracle, to store
    the configuration.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud Data Flow服务器使用内部模式存储所有应用程序、任务和流的配置。在本例中，我们尚未配置任何数据库。因此，默认情况下使用`H2`内存数据库。Spring
    Cloud Data Flow服务器支持各种数据库，包括MySQL和Oracle，用于存储配置。
- en: Since `H2` in-memory database is used, you can see that different schemas are
    set up during start up and also the different SQL scripts to set up data are executed.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于使用了`H2`内存数据库，您可以看到在启动期间设置了不同的模式，并且还执行了不同的SQL脚本来设置数据。
- en: Spring Cloud Data Flow Server exposes a number of APIs around its configuration,
    applications, tasks, and streams. We will discuss more about these APIs in a later
    section.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud Data Flow服务器公开了许多围绕其配置、应用程序、任务和流的API。我们将在后面的部分更多地讨论这些API。
- en: 'The following screenshot shows the launch screen of Spring Cloud Data Flow
    at `http://localhost:9393/dashboard`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了Spring Cloud Data Flow的启动屏幕，网址为`http://localhost:9393/dashboard`：
- en: '![](img/077ee2c6-bf62-4989-824f-c19fb814bed1.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/077ee2c6-bf62-4989-824f-c19fb814bed1.png)'
- en: There are different tabs that can be used to view and modify applications, streams,
    and tasks. In the next step, we will use the command-line interface--the Data
    Flow Shell to set up applications and streams.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的选项卡可用于查看和修改应用程序、流和任务。在下一步中，我们将使用命令行界面--Data Flow Shell来设置应用程序和流。
- en: Setting up Data Flow Shell project
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Data Flow Shell项目
- en: Data Flow Shell provides options to use commands to configure streams and other
    things in Spring Data Flow Server.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Data Flow Shell提供了使用命令配置Spring Data Flow服务器中的流和其他内容的选项。
- en: 'Let''s use Spring Initializr ([https://start.spring.io](https://start.spring.io))
    to set up the application. Provide the details listed here and click on Generate
    Project:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Spring Initializr（[https://start.spring.io](https://start.spring.io)）来设置应用程序。提供这里列出的详细信息，然后单击“生成项目”：
- en: 'Group: `com.mastering.spring.cloud.data.flow`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组：`com.mastering.spring.cloud.data.flow`
- en: 'Artifact: `data-flow-shell`'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Artifact：`data-flow-shell`
- en: 'Dependencies: `Data Flow Shell`'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖项：`Data Flow Shell`
- en: 'Listed here are some of the important dependencies from the `pom.xml` file:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`pom.xml`文件中一些重要的依赖项：
- en: '[PRE13]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Update the `SpringBootApplication` file with the following code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`SpringBootApplication`文件，使用以下代码：
- en: '[PRE14]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `@EnableDataFlowShell` annotation is used to activate the Spring Cloud Data
    Flow shell.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`@EnableDataFlowShell`注解用于激活Spring Cloud Data Flow shell。'
- en: 'The following screenshot shows the message shown when Data Flow Shell application
    is launched. We can type in commands at command prompt:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了启动Data Flow Shell应用程序时显示的消息。我们可以在命令提示符中输入命令：
- en: '![](img/fc3c5ba3-ba93-471c-baf6-5189345a510c.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc3c5ba3-ba93-471c-baf6-5189345a510c.png)'
- en: 'You can try the "help" command to get the list of the commands supported. The
    following screenshot shows some of the commands that are printed when the `help`
    command is executed:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以尝试“help”命令以获取支持的命令列表。以下屏幕截图显示了执行“help”命令时打印的一些命令：
- en: '![](img/3593bc81-bec4-4e65-8a50-c3637dcce671.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3593bc81-bec4-4e65-8a50-c3637dcce671.png)'
- en: 'You will see that when you executed any of the following commands, you would
    find empty lists printed, as we do not have any of these configured yet:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当您执行以下任何命令时，您会发现打印出空列表，因为我们尚未配置这些：
- en: '`app list`'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app list`'
- en: '`stream list`'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stream list`'
- en: '`task list`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`task list`'
- en: '`runtime apps`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runtime apps`'
- en: Configuring the apps
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置应用程序
- en: Before we would start configuring the stream, we would need to register the
    applications that constitute the stream. We have three applications to register--source,
    processor, and sink.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始配置流之前，我们需要注册构成流的应用程序。我们有三个应用程序要注册--源、处理器和接收器。
- en: To register an application in Spring Cloud Data Flow, you would need to access
    the application deployable. Spring Cloud Data Flow gives the option of picking
    up the application deployable from a Maven repository. To keep things simple,
    we will pick up the applications from a local Maven repository.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Spring Cloud Data Flow中注册应用程序，您需要访问应用程序可部署。Spring Cloud Data Flow提供了从Maven存储库中获取应用程序可部署的选项。为了简化，我们将从本地Maven存储库中获取应用程序。
- en: 'Run `mvn clean install` on all the three applications that we created using
    Spring Cloud Stream:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Spring Cloud Stream创建的三个应用程序上运行`mvn clean install`：
- en: '`significant-stock-change-source`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`significant-stock-change-source`'
- en: '`stock-intelligence-processor`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stock-intelligence-processor`'
- en: '`event-store-sink`'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event-store-sink`'
- en: This will ensure that all these applications are built and stored in your local
    Maven repository.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保所有这些应用程序都构建并存储在您的本地Maven存储库中。
- en: 'The syntax of the command to register an app from a Maven repository is shown
    here:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 从Maven存储库注册应用的命令语法如下所示：
- en: '[PRE15]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The Maven URIs for the three applications are listed as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 三个应用程序的Maven URI如下所示：
- en: '[PRE16]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The commands to create the apps are listed here. These commands can be executed
    on the Data Flow Shell application:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 创建应用程序的命令在此处列出。这些命令可以在Data Flow Shell应用程序上执行：
- en: '[PRE17]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You will see the messages shown here when the app is successfully registered:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当成功注册应用程序时，您将看到此处显示的消息：
- en: '[PRE18]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can also see the registered apps on the Spring Cloud Data Flow Dashboard
    at `http://localhost:9393/dashboard`, as shown in the following screenshot:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在Spring Cloud Data Flow仪表板上查看已注册的应用程序，如下图所示：`http://localhost:9393/dashboard`
- en: '![](img/c6e3de16-73b2-40f4-9082-5cc2b80f568c.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6e3de16-73b2-40f4-9082-5cc2b80f568c.png)'
- en: 'We can also register an app using the dashboard, as shown in the following
    screenshot:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用仪表板注册应用程序，如下图所示：
- en: '![](img/15363632-47c4-45e1-822d-cf56cbe4ba9e.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/15363632-47c4-45e1-822d-cf56cbe4ba9e.png)'
- en: Configuring the stream
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置流
- en: 'Stream DSL can be used to configure a stream--a simple example has been shown
    here to connect `app1` to `app2`. The messages put on the output channel by `app1`
    will be received on the input channel of `app2`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Stream DSL可用于配置流--这里显示了一个简单的示例，用于连接`app1`到`app2`。由`app1`放在输出通道上的消息将在`app2`的输入通道上接收：
- en: '[PRE19]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We would want to connect the three applications. The following snippet shows
    an example of a DSL used to connect the preceding applications:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望连接这三个应用程序。以下代码片段显示了用于连接前述应用程序的DSL的示例：
- en: '[PRE20]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This indicates the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示以下内容：
- en: The output channel of the source should be linked to the input channel of processor
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源的输出通道应链接到处理器的输入通道
- en: The output channel of the processor should be linked to the input channel of
    sink
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理器的输出通道应链接到接收器的输入通道
- en: 'The entire command to create a stream is shown as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 创建流的完整命令如下所示：
- en: '[PRE21]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You should see the following output if the stream is successfully created:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功创建流，则应看到以下输出：
- en: '[PRE22]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can also see the registered stream on the Streams tab of Spring Cloud Data
    Flow dashboard at `http://localhost:9393/dashboard`, as shown in the following
    screenshot:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在Spring Cloud Data Flow仪表板的Streams选项卡上查看已注册的流，如下图所示：`http://localhost:9393/dashboard`
- en: '![](img/bbeb68d5-8170-4ce3-8230-3559120b0a4c.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbeb68d5-8170-4ce3-8230-3559120b0a4c.png)'
- en: Deploying the stream
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署流
- en: 'To deploy the stream, we can execute the following command on the Data Flow
    Shell:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署流，可以在Data Flow Shell上执行以下命令：
- en: '[PRE23]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You will see the message shown here when the request is sent for the creation
    of stream:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当发送请求创建流时，您将看到此处显示的消息：
- en: '[PRE24]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following extract shows an extract from the Local Data Flow Server log:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 以下摘录显示了本地数据流服务器日志中的一部分：
- en: '[PRE25]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A few important things to note are as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要注意的重要事项：
- en: When we deploy a stream, Spring Cloud Data Flow will deploy all the applications
    in the stream and set up the connections between the applications through the
    message broker. The application code is independent of the message broker. Kafka
    has a different message broker setup compared to RabbitMQ. Spring Cloud Data Flow
    will take care of it. If you want to switch from RabbitMQ to Kafka, the application
    code does not need to change.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当部署流时，Spring Cloud Data Flow将部署流中的所有应用程序，并通过消息代理设置应用程序之间的连接。应用程序代码独立于消息代理。Kafka与RabbitMQ相比具有不同的消息代理设置。Spring
    Cloud Data Flow会处理它。如果要从RabbitMQ切换到Kafka，则应用程序代码无需更改。
- en: The Local Data Flow Server log contains the path to logs of all the applications--
    source, processor, and sink.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地数据流服务器日志包含所有应用程序的日志路径--源、处理器和接收器。
- en: Log messages - setting up connections to the message factory
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志消息 - 设置与消息工厂的连接
- en: 'The following snippet shows extracts related to setting up the message broker
    from the `Source`, `Transformer`, and `Sink` applications:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了与从`Source`、`Transformer`和`Sink`应用程序设置消息代理相关的摘录：
- en: '[PRE26]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'A few things to note are as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要注意的事项：
- en: '`Created new connection: SimpleConnection@725b3815 [delegate=amqp://guest@127.0.0.1:5672/,
    localPort= 58373]`: Since we added `spring-cloud-starter-stream-rabbit` into the
    classpath of all three applications, the message broker used is RabbitMQ.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`创建新连接：SimpleConnection@725b3815 [delegate=amqp://guest@127.0.0.1:5672/, localPort=
    58373]`：由于我们将`spring-cloud-starter-stream-rabbit`添加到了三个应用程序的类路径中，所以使用的消息代理是RabbitMQ。'
- en: '`Adding {transformer:stockIntelligenceProcessorApplication.addOurInventory.transformer}
    as a subscriber to the ''input'' channel`: Similar to this, the input and/or output
    channels of each application are set up on the message broker. Source and processor
    applications listen on the channels for incoming messages.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`将{transformer:stockIntelligenceProcessorApplication.addOurInventory.transformer}添加为“input”通道的订阅者`：类似于此，每个应用程序的输入和/或输出通道在消息代理上设置。源和处理器应用程序在通道上监听传入消息。'
- en: Log messages - the flow of events
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志消息-事件流程
- en: 'Extracts related to processing of the message are shown as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 有关处理消息的提取如下所示：
- en: '[PRE27]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The source application sends `StockPriceChangeEvent`. The `Transformer` application
    receives the event, adds the holdings to the message, and creates a new `StockPriceChangeEventWithHoldings`
    event. The sink application receives and logs this message.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 源应用程序发送`StockPriceChangeEvent`。`Transformer`应用程序接收事件，将持有添加到消息中，并创建新的`StockPriceChangeEventWithHoldings`事件。接收器应用程序接收并记录此消息。
- en: Spring Cloud Data Flow REST APIs
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud Data Flow REST API
- en: Spring Cloud Data Flow offers RESTful APIs around applications, streams, tasks,
    jobs, and metrics. A complete list can be obtained by sending a `GET` request
    to `http://localhost:9393/`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Data Flow提供了围绕应用程序、流、任务、作业和指标的RESTful API。可以通过向`http://localhost:9393/`发送`GET`请求来获取完整列表。
- en: 'The following screenshot shows the response for the `GET` request:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了`GET`请求的响应：
- en: '![](img/317bf00f-c9e2-4511-b441-bbe455c25296.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](img/317bf00f-c9e2-4511-b441-bbe455c25296.png)'
- en: 'All the APIs are self-explanatory. Let''s look at an example of sending a `GET`
    request to `http://localhost:9393/streams/definitions`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 所有API都是不言自明的。让我们看一个向`http://localhost:9393/streams/definitions`发送`GET`请求的示例：
- en: '[PRE28]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Important things to note are as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的重要事项如下：
- en: The API is RESTful. `_embedded` element contains the data for the request. `_links`
    element contains HATEOAS links. The page element contains pagination information.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API是RESTful的。`_embedded`元素包含请求的数据。`_links`元素包含HATEOAS链接。页面元素包含分页信息。
- en: '`_embedded.streamDefinitionResourceList.dslText` contains the definition of
    the stream `"significant-stock-change-source|stock-intelligence-processor|event-store-sink"`.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_embedded.streamDefinitionResourceList.dslText`包含流的定义`"significant-stock-change-source|stock-intelligence-processor|event-store-sink"`。'
- en: '`_embedded.streamDefinitionResourceList.status`'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_embedded.streamDefinitionResourceList.status`'
- en: Spring Cloud Task
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud Task
- en: Spring Cloud Data Flow can also be used to create and schedule batch applications.
    For the last decade, Spring Batch has been the framework of choice to develop
    batch applications. Spring Cloud Task extends this and enables execution of batch
    programs on the Cloud.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Data Flow还可以用于创建和调度批处理应用程序。在过去的十年中，Spring Batch一直是开发批处理应用程序的首选框架。Spring
    Cloud Task扩展了这一点，并使批处理程序可以在云上执行。
- en: 'Let''s use Spring Initializr ([https://start.spring.io](https://start.spring.io))
    to set up the application. Provide the details listed here and click on Generate
    Project:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Spring Initializr ([https://start.spring.io](https://start.spring.io))来设置应用程序。提供此处列出的详细信息，然后单击“生成项目”：
- en: 'Group: `com.mastering.spring.cloud.data.flow`'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组：`com.mastering.spring.cloud.data.flow`
- en: 'Artifact: `simple-logging-task`'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构件：`simple-logging-task`
- en: 'Dependencies: `Cloud Task`'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖项：`Cloud Task`
- en: 'Update the `SimpleLoggingTaskApplication` class with the following code:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码更新`SimpleLoggingTaskApplication`类：
- en: '[PRE29]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This code simply puts a sysout with the current timestamp. The `@EnableTask`
    annotation enables the task features in a Spring Boot application.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码只是将当前时间戳与sysout放在一起。`@EnableTask`注解在Spring Boot应用程序中启用任务功能。
- en: 'We can register the task on the data flow shell using the following commands:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令在数据流shell上注册任务：
- en: '[PRE30]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The commands are very similar to those used to register the stream apps we created
    earlier. We are adding a task definition to be able to execute the task.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令与用于注册我们之前创建的流应用程序的命令非常相似。我们正在添加一个任务定义，以便能够执行该任务。
- en: 'The task can be launched using the following command:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令启动任务：
- en: '[PRE31]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Task executions can be triggered and monitored on the Spring Cloud Flow dashboard
    as well.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 任务执行也可以在Spring Cloud Flow仪表板上触发和监视。
- en: Summary
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Spring Cloud Data Flow brings Cloud-Native features to data flow and event flow
    streams. It makes it easy to create and deploy streams on the Cloud. In this chapter,
    we covered how individual applications in event-driven flows can be set up using
    Spring Cloud Stream. We took a 1000 feet view on creating tasks with Spring Cloud
    Task. We used Spring Cloud Data Flow to set up streams and also execute simple
    tasks.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Data Flow为数据流和事件流带来了云原生功能。它使得在云上创建和部署流变得容易。在本章中，我们介绍了如何使用Spring
    Cloud Stream设置事件驱动流中的单个应用程序。我们以1000英尺的视角来创建具有Spring Cloud Task的任务。我们使用Spring Cloud
    Data Flow来设置流，还执行简单任务。
- en: In the next chapter, we will start understanding a new way of building web applications--
    the reactive style. We will understand why nonblocking applications are being
    hyped up and how reactive applications can be built using Spring Reactive.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始了解构建Web应用程序的新方法--响应式风格。我们将了解为什么非阻塞应用程序备受推崇，以及如何使用Spring Reactive构建响应式应用程序。
