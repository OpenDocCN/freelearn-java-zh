- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Contexts and Dependency Injection
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文和依赖注入
- en: '**Contexts and Dependency Injection** (**CDI**) is a powerful dependency injection
    framework that allows us to easily integrate different parts of our Jakarta EE
    applications. CDI beans can have different scopes, allowing their life cycle to
    be managed automatically by the Jakarta EE runtime. They can be easily injected
    as dependencies by using a simple annotation. CDI also includes an event mechanism
    to allow decoupled communication between different parts of our application.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**上下文和依赖注入**（**CDI**）是一个强大的依赖注入框架，它允许我们轻松地将我们Jakarta EE应用程序的不同部分集成在一起。CDI豆可以有不同的作用域，允许Jakarta
    EE运行时自动管理它们的生命周期。它们可以通过简单的注解轻松地注入为依赖项。CDI还包括一个事件机制，允许我们应用程序的不同部分之间进行解耦通信。'
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Named beans
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名豆类
- en: Dependency injection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入
- en: Qualifiers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限定符
- en: CDI bean scopes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CDI豆作用域
- en: CDI events
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CDI事件
- en: CDI Lite
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CDI Lite
- en: Note
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Code samples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch02_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch02_src).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码示例可以在GitHub上找到：[https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch02_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch02_src)。
- en: Named beans
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名豆类
- en: CDI provides us with the ability to name our beans via the `@Named` annotation.
    Named beans allow us to easily inject our beans into other classes that depend
    on them (see the next section) and to easily refer to them from Jakarta Faces
    via the unified expression language.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: CDI通过`@Named`注解为我们提供了命名我们的豆的能力。命名豆允许我们轻松地将我们的豆注入到依赖它们的其他类中（参见下一节），并且可以通过统一的表达式语言轻松地从Jakarta
    Faces中引用它们。
- en: Note
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Jakarta Faces is covered in detail in *Chapters 6* and *7*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta Faces在*第6章*和*第7章*中有详细说明。
- en: 'The following example shows the `@Named` annotation in action:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了`@Named`注解的实际应用：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As we can see, all we need to do to name our class is to decorate it with the
    `@Named` annotation. By default, the name of the bean will be the class name with
    its first letter switched to lowercase. In our example, the name of the bean would
    be `customer`. If we wish to use a different name, we can do so by setting the
    `value` attribute of the `@Named` annotation. For example, if we wanted to use
    the name `customerBean` for our bean, we could have done so by modifying the `@Named`
    annotation as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，我们只需要用`@Named`注解装饰我们的类来命名我们的类。默认情况下，豆的名称将是类名，其首字母转换为小写。在我们的例子中，豆的名称将是`customer`。如果我们想使用不同的名称，我们可以通过设置`@Named`注解的`value`属性来实现。例如，如果我们想为我们的豆使用名称`customerBean`，我们可以通过修改`@Named`注解如下：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Or, we could simply use the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以简单地使用以下方法：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Since the `value` attribute name does not need to be specified, if we don’t
    use an attribute name, then `value` is implied.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`value`属性名称不需要指定，如果我们不使用属性名称，则默认`value`。
- en: 'This name can be used to access our bean from Jakarta Faces pages using the
    unified expression language:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此名称可以用来通过统一的表达式语言从Jakarta Faces页面访问我们的豆：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In our example, the `firstName` and `lastName` properties or our `Customer`
    named bean are bound to two text input fields in our Jakarta Faces page.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`firstName`和`lastName`属性或我们的`Customer`命名豆绑定到我们的Jakarta Faces页面中的两个文本输入字段。
- en: 'When deployed and executed, our simple application looks like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当部署和执行时，我们的简单应用程序看起来像这样：
- en: '![Figure 2.1 – CDI named beans in action](img/B21231_2_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – CDI命名豆的实际应用](img/B21231_2_01.jpg)'
- en: Figure 2.1 – CDI named beans in action
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – CDI命名豆的实际应用
- en: Now that we’ve seen how we can name our CDI beans, we will focus our attention
    on the dependency injection capabilities of CDI.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何命名我们的CDI豆，我们将关注CDI的依赖注入功能。
- en: Dependency injection
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: '`@Inject` annotation, which can be used to inject instances of CDI beans into
    any dependent objects.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Inject`注解，可以用来将CDI豆的实例注入到任何依赖对象中。'
- en: 'Jakarta Faces applications typically follow the **Model-View-Controller** (**MVC**)
    design pattern. As such, frequently some Jakarta Faces managed beans take the
    role of controllers in the pattern, while others take the role of the model. This
    approach typically requires the controller-managed bean to have access to one
    or more of the model-managed beans. CDI’s dependency injection capabilities make
    injecting beans into one another very simple, as illustrated in the following
    example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta Faces应用程序通常遵循**模型-视图-控制器**（MVC）设计模式。因此，通常情况下，一些Jakarta Faces管理bean在模式中扮演控制器的角色，而其他则扮演模型的角色。这种方法通常要求控制器管理bean能够访问一个或多个模型管理bean。CDI的依赖注入能力使得将bean注入到另一个bean中变得非常简单，如下面的示例所示：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that all we had to do to initialize our `Customer` instance was to annotate
    it with the `@Inject` annotation. When the bean is constructed by the application
    server, an instance of the `Customer` bean is automatically injected into this
    field. Notice that the injected bean is used in the `saveCustomer()` method.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们初始化`Customer`实例所需要做的只是用`@Inject`注解来注解它。当bean由应用服务器构建时，`Customer` bean的实例会自动注入到这个字段中。注意，注入的bean在`saveCustomer()`方法中被使用。
- en: As we have seen in this section, CDI dependency injection is very simple. We
    simply need to annotate the instance variable of the class we wish to inject with
    the `@``Inject` annotation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本节中看到的，CDI依赖注入非常简单。我们只需用`@Inject`注解来注解我们希望注入的类的实例变量。
- en: Qualifiers
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限定符
- en: In some instances, the type of bean we wish to inject into our code may be an
    interface or a Java superclass. However, we may be interested in injecting a specific
    subclass or a class implementing the interface. For cases like this, CDI provides
    qualifiers we can use to indicate the specific type we wish to inject into our
    code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们希望注入到我们的代码中的bean类型可能是一个接口或Java超类。然而，我们可能对注入特定的子类或实现该接口的类感兴趣。对于这种情况，CDI提供了我们可以用来指示我们希望注入到代码中的特定类型的限定符。
- en: A CDI qualifier is an annotation that must be decorated with the `@Qualifier`
    annotation. This annotation can then be used to decorate the specific subclass
    or interface implementation we wish to qualify. Additionally, the injected field
    in the client code needs to be decorated with the qualifier as well.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: CDI限定符是一个必须用`@Qualifier`注解装饰的注解。然后，我们可以使用这个注解来装饰我们希望限定的特定子类或接口实现。此外，客户端代码中注入的字段也需要用限定符进行装饰。
- en: 'Suppose our application could have a special kind of customer; for example,
    frequent customers could be given the status of premium customers. To handle these
    premium customers, we could extend our `Customer` named bean and decorate it with
    the following qualifier:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的应用程序可能有一种特殊的客户类型；例如，常客可能会被赋予高级客户的地位。为了处理这些高级客户，我们可以扩展我们的`Customer`命名bean，并用以下限定符进行装饰：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we mentioned before, qualifiers are standard annotations. They typically
    have retention of runtime and can target methods, fields, parameters, or types,
    as illustrated in the preceding example. The only difference between a qualifier
    and a standard annotation however is that qualifiers are decorated with the `@``Qualifier`
    annotation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，限定符是标准注解。它们通常具有运行时保留，可以针对方法、字段、参数或类型，如前例所示。然而，限定符和标准注解之间的唯一区别是，限定符是用`@Qualifier`注解装饰的。
- en: 'Once we have our qualifier in place, we need to use it to decorate the specific
    subclass or interface implementation, as illustrated in the following example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了我们的限定符，我们需要用它来装饰特定的子类或接口实现，如下面的示例所示：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once we have decorated the specific instance, we need to qualify it. We can
    use our qualifiers in the controller to specify the exact type of dependency we
    need:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们装饰了特定的实例，我们需要对其进行限定。我们可以在控制器中使用我们的限定符来指定所需的精确依赖类型：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Since we used our `@Premium` qualifier to annotate the `customer` field, an
    instance of `PremiumCustomer` is injected into that field, since this class is
    also decorated with the `@``Premium` qualifier.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了`@Premium`限定符来注解`customer`字段，因此将`PremiumCustomer`的实例注入到该字段，因为这个类也用`@Premium`限定符进行了装饰。
- en: 'As far as our Jakarta Faces pages go, we simply access our named bean as usual
    using its name, as shown in the following example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 就我们的Jakarta Faces页面而言，我们只需像下面示例中那样使用其名称来通常访问我们的命名bean：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, we are using the default name for our bean, which is the class
    name with the first letter switched to lowercase.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用Bean的默认名称，即类名，首字母转换为小写。
- en: Our simple application renders and acts just like a “plain” Jakarta Faces application,
    as far as the user is concerned. See *Figure 2**.2*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 就用户而言，我们的简单应用程序渲染和操作就像一个“普通”的Jakarta Faces应用程序。请参见*图2.2*。
- en: '![Figure 2.2 – Premium customer data displayed in the browser](img/B21231_2_02.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 浏览器中显示的优质客户数据](img/B21231_2_02.jpg)'
- en: Figure 2.2 – Premium customer data displayed in the browser
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 浏览器中显示的优质客户数据
- en: Now that we’ve seen how to use CDI qualifiers to inject different implementations
    of the same type, we’ll focus our attention on CDI scopes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何使用CDI限定符注入同一类型的不同实现，我们将关注CDI作用域。
- en: CDI bean scopes
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CDI Bean作用域
- en: CDI stands for “Contexts and Dependency Injection,” CDI Beans have a scope which
    defines their lifecycle, their scope determines when the Jakarta EE runtime creates
    and destroys CDI beans. “Contexts” in “Contexts and Dependency Injection” refers
    to CDI scopes. When a CDI bean is needed, either because of injection or because
    it is referred to from a Jakarta Faces page, CDI looks for an instance of the
    bean in the scope it belongs to and injects it into the dependent code. If no
    instance is found, one is created and stored in the appropriate scope for future
    use. The different scopes are the context in which the bean exists.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: CDI代表“上下文和依赖注入”，CDI Bean有一个作用域，它定义了其生命周期，其作用域决定了Jakarta EE运行时何时创建和销毁CDI Bean。“上下文”在“上下文和依赖注入”中指的是CDI作用域。当需要CDI
    Bean时，无论是由于注入还是因为它被Jakarta Faces页面引用，CDI都会在其所属的作用域中查找Bean的实例，并将其注入到依赖的代码中。如果没有找到实例，就会创建一个并存储在适当的作用域中供将来使用。不同的作用域是Bean存在的上下文。
- en: 'The following table lists the different valid CDI scopes:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了不同的有效CDI作用域：
- en: '| **Scope** | **Annotation** | **Description** |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **作用域** | **注解** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Request | `@``RequestScoped` | Request-scoped beans are shared through the
    duration of a single request. A single request could refer to an HTTP request,
    an invocation to a method in an EJB, a web service invocation, or sending a JMS
    message to a message-driven bean. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 请求 | `@``RequestScoped` | 请求作用域的Bean在整个单个请求期间共享。单个请求可能指一个HTTP请求、对EJB中方法的调用、Web服务调用，或者向消息驱动Bean发送JMS消息。
    |'
- en: '| Conversation | `@``ConversationScoped` | The conversation scope can span
    multiple requests, but is typically shorter than the session scope. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 会话 | `@``ConversationScoped` | 会话作用域可以跨越多个请求，但通常比会话作用域短。 |'
- en: '| Session | `@``SessionScoped` | Session-scoped beans are shared across all
    requests in an HTTP session. Each user of an application gets their own instance
    of a session-scoped bean. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 会话 | `@``SessionScoped` | 会话作用域的Bean在HTTP会话的所有请求之间共享。应用程序的每个用户都会获得一个会话作用域Bean的实例。
    |'
- en: '| Application | `@``ApplicationScoped` | Application-scoped beans live through
    the whole application lifetime. Beans in this scope are shared across user sessions.
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 应用 | `@``ApplicationScoped` | 应用作用域的Bean在整个应用生命周期中存活。此作用域中的Bean在用户会话之间共享。
    |'
- en: '| Dependent | `@``Dependent` | Dependent-scoped beans are not shared. Any time
    a dependent scoped bean is injected, a new instance is created. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 依赖 | `@``Dependent` | 依赖作用域的Bean不共享。每次注入依赖作用域的Bean时，都会创建一个新的实例。 |'
- en: Table 2.1 – CDI scopes
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1 – CDI作用域
- en: CDI’s **request scope** does not necessarily refer to an HTTP request; it could
    simply be an invocation on an EJB method, a web service invocation, or sending
    a JMS message to a message-driven bean.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: CDI的**请求作用域**不一定指HTTP请求；它可能只是一个对EJB方法的调用、Web服务调用，或者向消息驱动Bean发送JMS消息。
- en: The `jakarta.enterprise.context.Conversation` injected. At the point, where
    we want to start the conversation, the `begin()` method must be invoked on this
    object. At the point where we want to end the conversation, its `end()` method
    must be invoked on it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注入了`jakarta.enterprise.context.Conversation`。在我们要开始会话的点，必须在这个对象上调用`begin()`方法。在我们要结束会话的点，必须在这个对象上调用其`end()`方法。
- en: CDI’s **session scope** ties the life cycle of a CDI bean to an HTTP session.
    Session-scoped CDI beans are created when they are first injected, and stick around
    until the HTTP session is destroyed, usually when a user logs out of a web application
    or closes the browser.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: CDI的**会话作用域**将CDI Bean的生命周期绑定到HTTP会话。会话作用域的CDI Bean在首次注入时创建，并持续存在，直到HTTP会话被销毁，通常发生在用户从Web应用程序注销或关闭浏览器时。
- en: CDI’s **application scope** ties the life cycle of a CDI bean to the life of
    an application. A single instance of each application-scoped bean exists per application,
    which means that the same instance is accessible to all HTTP sessions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: CDI的**应用作用域**将CDI bean的生命周期与应用程序的生命周期绑定。每个应用程序只有一个应用程序作用域bean的实例，这意味着相同的实例对所有HTTP会话都是可访问的。
- en: CDI’s **dependent scope** is the default scope if none is explicitly specified.
    A new instance of a dependent-scoped bean is instantiated every time it is needed,
    usually when it is injected into a class that depends on it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有明确指定，CDI的**依赖作用域**是默认作用域。每次需要时，都会实例化一个新的依赖作用域bean，通常是在将其注入依赖于它的类时。
- en: For most of CDI’s scopes, simply annotating our CDI bean with the desired scope
    annotation is all we need to do. The Jakarta EE runtime then manages the bean’s
    life cycle behind the scenes. The conversation scope requires a bit more work
    on our part, namely we need to indicate when a conversation starts and ends. For
    this reason, we will use the conversation scope to illustrate the usage of CDI
    scopes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CDI的大多数作用域，只需用所需的作用域注解注解我们的CDI bean即可。然后，Jakarta EE运行时在幕后管理bean的生命周期。会话作用域需要我们做更多的工作，即我们需要指示会话何时开始和结束。因此，我们将使用会话作用域来展示CDI作用域的使用。
- en: 'Suppose we wanted to have a user enter some data that would be stored in a
    single named bean; however, this bean has several fields. Therefore, we would
    like to split the data entry into several pages. For cases like this, CDI’s conversation
    scope is a good solution. The following example illustrates how to use CDI’s conversation
    scope:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望让用户输入一些将被存储在单个命名bean中的数据；然而，这个bean有几个字段。因此，我们希望将数据输入分成几个页面。对于这种情况，CDI的会话作用域是一个很好的解决方案。以下示例说明了如何使用CDI的会话作用域：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We declare that our bean is conversation scoped by decorating it with the `@ConversationScoped`
    annotation. Conversation-scoped beans also need to implement `java.io.Serializable`.
    Other than these two requirements, there is nothing special about our code; it
    is a simple Java class with private properties and corresponding getter and setter
    methods.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用`@ConversationScoped`注解来装饰我们的bean，声明我们的bean是会话作用域的。会话作用域bean还需要实现`java.io.Serializable`接口。除了这两个要求之外，我们的代码没有特别之处；它是一个简单的Java类，具有私有属性和相应的getter和setter方法。
- en: 'In addition to having our conversation-scoped bean injected, our client code
    must also have an instance of `jakarta.enterprise.context.Conversation` injected,
    as illustrated in the following example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了注入我们的会话作用域bean之外，我们的客户端代码还必须注入`jakarta.enterprise.context.Conversation`的实例，如下例所示：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Conversations can be either **long-running** or **transient**. Transient conversations
    end at the end of a request. Long-running conversations span multiple requests.
    In most cases, we will use long-running conversations to hold a reference to a
    conversation-scoped bean across multiple HTTP requests in a web application.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 会话可以是**长运行**或**短暂的**。短暂的会话在请求结束时结束。长运行会话跨越多个请求。在大多数情况下，我们将使用长运行会话来在Web应用程序中跨越多个HTTP请求保持对会话作用域bean的引用。
- en: A long-running conversation starts when the `begin()` method is invoked in the
    injected `Conversation` instance, and it ends when we invoke the `end()` method
    on this same object.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 长运行会话在注入的`Conversation`实例上调用`begin()`方法时开始，并在我们在这个相同对象上调用`end()`方法时结束。
- en: 'Jakarta Faces pages simply access our CDI beans as usual:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta Faces页面像往常一样访问我们的CDI bean：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we navigate from one page to the next, we keep the same instance of our conversation-scoped
    bean; therefore, all user-entered data remains. When the `end()` method is called
    on our Conversation bean, the conversation ends and our conversation-scoped bean
    is destroyed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从一页导航到下一页时，我们保持我们的会话作用域bean的同一实例；因此，所有用户输入的数据都保持不变。当在会话bean上调用`end()`方法时，会话结束，我们的会话作用域bean被销毁。
- en: Keeping our bean in the conversation scope simplifies the task of implementing
    “wizard-style” user interfaces, where data can be entered across several pages.
    See *Figure 2**.3*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的bean保持在会话作用域中简化了实现“向导式”用户界面的任务，其中数据可以在多个页面中输入。参见*图2**.3*。
- en: "![Figure \uFEFF2.3 – Page 1 of CDI Conversation Scope Example](img/B21231_2_03.jpg)"
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3 – CDI会话作用域示例的第1页](img/B21231_2_03.jpg)'
- en: Figure 2.3 – Page 1 of CDI Conversation Scope Example
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – CDI会话作用域示例的第1页
- en: In our example, after clicking the **Next** button on the first page, we can
    see our partially populated bean in the application server log.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，在点击第一页上的**下一步**按钮后，我们可以在应用服务器日志中看到我们的部分填充的bean。
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: At this point, the second page in our simple wizard is displayed, as shown in
    *Figure 2**.4*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们简单向导的第二页被显示，如图*图2**.4*所示。
- en: "![Figure \uFEFF2.4 – Page 2 of CDI Conversation Scope Example](img/B21231_2_04.jpg)"
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4 – CDI会话作用域示例的第2页](img/B21231_2_04.jpg)'
- en: Figure 2.4 – Page 2 of CDI Conversation Scope Example
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – CDI会话作用域示例的第2页
- en: When clicking **Next**, we can see that additional fields are populated in our
    conversation-scoped bean.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击**下一步**时，我们可以看到在我们的会话作用域bean中填充了额外的字段。
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When we submit the third page in our wizard (not shown), additional bean properties
    corresponding to the fields on that page are populated.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在向导中提交第三页（未显示）时，与该页面上字段对应的额外bean属性将被填充。
- en: 'When we are at the point where we don’t need to keep the customer information
    in memory anymore, we need to call the `end()` method on the Conversation bean
    that was injected into our code. This is exactly what we do in our code before
    displaying the confirmation page:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们到达不再需要将客户信息保留在内存中的点时，我们需要在注入到我们代码中的会话bean上调用`end()`方法。这正是我们在显示确认页面之前在代码中所做的：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After the request to show the confirmation page is completed, our conversation-scoped
    bean is destroyed, since we invoked the `end()` method in our injected `Conversation`
    class.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成显示确认页面的请求后，我们的会话作用域bean被销毁，因为我们调用了注入的`Conversation`类中的`end()`方法。
- en: Now that we’ve seen all scopes supported by CDI, we will turn our attention
    to how we can implement loosely coupled communication via CDI events.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了CDI支持的所有作用域，我们将把注意力转向如何通过CDI事件实现松散耦合的通信。
- en: CDI events
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CDI事件
- en: CDI provides event-handling facilities. Events allow loosely coupled communication
    between different CDI beans. A CDI bean can fire an event, then one or more event
    listeners handle the event.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: CDI提供了事件处理功能。事件允许不同CDI bean之间的松散耦合通信。一个CDI bean可以触发一个事件，然后一个或多个事件监听器处理该事件。
- en: Firing CDI events
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 触发CDI事件
- en: 'The following example is a new version of the `CustomerInfoController` class
    we discussed in the previous section. The class has been modified to fire an event
    every time the user navigates to a new page:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例是我们在前一节中讨论的`CustomerInfoController`类的新版本。该类已被修改为每次用户导航到新页面时触发一个事件：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As we can see, to create an event, we inject an instance of `jakarta.enterprise.event.Event`.
    This class uses generics; therefore, we need to specify its type. The type of
    the `Event` class can be any class implementing `java.io.Serializable`. In our
    case, we are passing an instance of a simple POJO we wrote as the type parameter,
    our POJO is called `NavigationInfo` and has two properties, one of type `Customer`
    and a `String` containing the page the user is navigating to. Recall from the
    previous sections that each of the methods on our `CustomerInfoController` class
    triggers navigation from one page in the application to another. In this version
    of the controller, a CDI event is fired every time we navigate to a new page.
    In each case, we create a new instance of `NavigationInfo`, populate it, then
    fire the event by invoking the `fire()` method on our instance of `jakarta.enterprise.event.Event`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，要创建一个事件，我们需要注入一个`jakarta.enterprise.event.Event`实例。这个类使用泛型；因此，我们需要指定其类型。`Event`类的类型可以是任何实现`java.io.Serializable`的类。在我们的情况下，我们正在传递一个简单的POJO的实例作为类型参数，我们的POJO被称为`NavigationInfo`并有两个属性，一个是`Customer`类型，另一个是包含用户正在导航到的页面的`String`。回想一下，在前几节中，我们`CustomerInfoController`类上的每个方法都会触发从应用的一个页面到另一个页面的导航。在这个控制器的这个版本中，每次我们导航到新页面时都会触发一个CDI事件。在这种情况下，我们创建`NavigationInfo`的新实例，填充它，然后通过在`jakarta.enterprise.event.Event`的实例上调用`fire()`方法来触发事件。
- en: Handling CDI events
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理CDI事件
- en: 'To handle CDI events, the CDI bean handling the event needs to implement an
    `NavigationInfo`, as can be seen in the declaration of our event in the preceding
    section. To handle the event, the observer method needs to annotate the corresponding
    parameter with the `@Observes` annotation, as illustrated in the following example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理CDI事件，处理事件的CDI bean需要实现一个`NavigationInfo`，正如在前一节中我们事件声明的声明中可以看到。为了处理事件，观察方法需要用`@Observes`注解标注相应的参数，如下面的示例所示：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example event handler, the `handleNavigationEvent()` method takes an
    instance of `NavigationInfo` as a parameter. Notice that this parameter is annotated
    with `@Observes`. This causes the method to be invoked automatically by CDI every
    time an event of type `NavigationInfo` is fired. Notice that we never explicitly
    call this method; the Jakarta EE runtime invokes it automatically whenever a navigation
    event is fired.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在此事件处理器示例中，`handleNavigationEvent()`方法接受一个`NavigationInfo`实例作为参数。请注意，此参数被注解为`@Observes`。这导致CDI在每次触发类型为`NavigationInfo`的事件时自动调用该方法。请注意，我们从未显式调用此方法；每当导航事件被触发时，Jakarta
    EE运行时会自动调用它。
- en: CDI events allow us to implement loosely coupled communication between CDI beans.
    In our example, notice that our `CustomerController` CDI bean has no direct reference
    to `NavigationEventListener`. In general, the CDI bean firing the event does not
    need to know any details about the listeners; it just fires the event and CDI
    takes over the details.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: CDI事件允许我们在CDI beans之间实现松散耦合的通信。在我们的示例中，请注意我们的`CustomerController` CDI bean没有直接引用`NavigationEventListener`。一般来说，触发事件的CDI
    bean不需要了解任何关于监听器的细节；它只需触发事件，然后CDI接管细节。
- en: Note
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In our example, we have only one event listener, but in practice, we can have
    as many event listeners as we need.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们只有一个事件监听器，但在实践中，我们可以有我们需要的任意多个事件监听器。
- en: Asynchronous events
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步事件
- en: 'CDI has the ability to fire events asynchronously. Firing events asynchronously
    can help with performance, since various observer methods can be invoked concurrently.
    Firing an event asynchronously is very similar to firing an event synchronously.
    The only syntactical difference is that instead of invoking the `fire()` method
    in our `Event` instance, we invoke its `fireAsync()` method. The following example
    illustrates how to do this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: CDI具有异步触发事件的能力。异步触发事件可以帮助提高性能，因为各种观察者方法可以并发调用。异步触发事件与同步触发事件非常相似。唯一的语法区别是我们不是在`Event`实例中调用`fire()`方法，而是调用其`fireAsync()`方法。以下示例说明了如何做到这一点：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Observer methods to handle asynchronous events are identical to their synchronous
    counterparts.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 处理异步事件的观察者方法与其同步对应者相同。
- en: Event ordering
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件排序
- en: 'Another new feature introduced in CDI 2.0 is the ability to specify in what
    order our observer methods handle CDI events. This can be accomplished via the
    `@Priority` annotation, as illustrated in the following example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: CDI 2.0中引入的另一个新功能是能够指定我们的观察者方法处理CDI事件的顺序。这可以通过`@Priority`注解实现，如下面的示例所示：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `@Priority` annotation takes an argument of type `int`. This argument specifies
    the priority for the observer method. The highest priority is defined by the `APPLICATION`
    constant defined in the `Interceptor.Priority` class. This is the priority we
    gave to the observer method in our example. Lower-priority values take precedence
    and the default priority is `Interceptor.Priority.APPLICATION +` `100`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Priority`注解接受一个类型为`int`的参数。此参数指定了观察者方法的优先级。最高优先级由`Interceptor.Priority`类中定义的`APPLICATION`常量定义。这是我们给示例中观察者方法赋予的优先级。较低优先级的值具有优先权，默认优先级是`Interceptor.Priority.APPLICATION
    + 100`。'
- en: As mentioned in [*Chapter 1*](B21231_01.xhtml#_idTextAnchor014), in addition
    to the full Jakarta EE specification, there are two Jakarta EE profiles we can
    use if we are developing simpler applications that don’t need the full power of
    Jakarta EE. There’s the Web Profile, suitable for web applications, and the Core
    Profile, suitable for microservices. The Core Profile includes CDI support but
    does not support all of CDI’s features. This lightweight version of CDI included
    in the Jakarta EE Core Profile is called CDI Lite.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第1章*](B21231_01.xhtml#_idTextAnchor014)所述，除了完整的Jakarta EE规范外，如果我们开发的是不需要Jakarta
    EE全部功能的应用程序，我们还可以使用两个Jakarta EE配置文件。一个是Web Profile，适用于Web应用程序；另一个是Core Profile，适用于微服务。Core
    Profile包括CDI支持，但不支持CDI的所有功能。包含在Jakarta EE Core Profile中的这个轻量级CDI版本被称为CDI Lite。
- en: CDI Lite
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CDI Lite
- en: The Jakarta EE Core Profile contains a subset of the full CDI specification,
    named, appropriately enough, CDI Lite. Most of the changes of CDI Lite are at
    the implementation level; namely, some functionality that the full CDI implementation
    performs at runtime is moved to build time, allowing applications utilizing CDI
    Lite to initialize faster.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta EE Core Profile包含完整的CDI规范的一个子集，恰当地命名为CDI Lite。CDI Lite的大部分更改都在实现层面；也就是说，一些在运行时由完整CDI实现执行的功能被移动到构建时间，使得利用CDI
    Lite的应用程序可以更快地初始化。
- en: CDI Lite is primarily meant to be used in microservices applications, implementing
    functionality as RESTful web services. Since REST applications are typically stateless,
    not all CDI scopes are applicable when working on this type of application. For
    this reason, the session and conversation scopes are not available when using
    CDI Lite. This is the primary limitation of CDI Lite when compared to the full
    CDI specification.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: CDI Lite主要适用于微服务应用程序，实现RESTful Web服务的功能。由于REST应用程序通常是无状态的，因此在开发此类应用程序时，并非所有CDI作用域都适用。因此，当使用CDI
    Lite时，会话和会话作用域不可用。这是与完整的CDI规范相比，CDI Lite的主要限制。
- en: We only need to be concerned with CDI Lite limitations when deploying our code
    to a Jakarta EE Core Profile implementation. The Jakarta EE Web Profile and the
    full Jakarta EE platform contain full CDI functionality.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将代码部署到Jakarta EE Core Profile实现时，我们只需要关注CDI Lite的限制。Jakarta EE Web Profile和完整的Jakarta
    EE平台包含完整的CDI功能。
- en: Summary
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we provided an introduction to CDI, an integral part of the
    Jakarta EE specification. We looked into the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了CDI，它是Jakarta EE规范的一个核心部分。我们探讨了以下内容：
- en: We covered how Jakarta Faces pages can access CDI-named beans via the unified
    expression language.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还介绍了Jakarta Faces页面如何通过统一表达式语言访问CDI命名的Bean。
- en: We also covered how CDI makes it easy to inject dependencies into our code via
    the `@``Inject` annotation.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还介绍了如何通过`@Inject`注解使CDI（控制反转）使我们的代码注入依赖变得简单。
- en: Additionally, we explained how we can use qualifiers to determine what specific
    implementation of a dependency to inject into our code.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，我们还解释了如何使用限定符来确定将哪种特定的依赖注入到我们的代码中。
- en: We also discussed all the scopes that a CDI bean can be placed into, allowing
    us to delegate the life cycle of CDI beans to the Jakarta EE runtime.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还讨论了CDI Bean可以放置的所有作用域，使我们能够将CDI Bean的生命周期委托给Jakarta EE运行时。
- en: We discussed how to implement loosely coupled communication between CDI beans
    via CDI’s event handling.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了如何通过CDI的事件处理实现CDI Bean之间的松耦合通信。
- en: Lastly, we discussed CDI Lite, a lightweight version of CDI suitable for microservices
    development.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们讨论了CDI Lite，这是CDI的一个轻量级版本，适合微服务开发。
- en: CDI is an integral part of Jakarta EE, as it is used to integrate different
    layers of our Jakarta EE applications.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: CDI是Jakarta EE的一个核心部分，因为它被用来整合我们的Jakarta EE应用程序的不同层。
