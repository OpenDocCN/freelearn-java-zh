- en: '*Chapter 11*: Network Programming'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：网络编程'
- en: In this chapter, we will describe and discuss the most popular network protocols
    – **User Datagram Protocol** (**UDP**), **Transmission Control Protocol** (**TCP**),
    **HyperText Transfer Protocol** (**HTTP**), and **WebSocket** – and their support
    from the **Java Class Library** (**JCL**). We will demonstrate how to use these
    protocols and how to implement client-server communication in Java code. We will
    also review **Uniform Resource Locator** (**URL**)-based communication and the
    latest **Java HTTP Client API**. After studying this chapter, you will be able
    to create server and client applications that communicate using the **UDP**, **TCP**,
    and **HTTP** protocols as well as **WebSocket**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将描述和讨论最流行的网络协议——**用户数据报协议**（**UDP**）、**传输控制协议**（**TCP**）、**超文本传输协议**（**HTTP**）和**WebSocket**——以及它们对**Java类库**（**JCL**）的支持。我们将演示如何使用这些协议以及如何在Java代码中实现客户端-服务器通信。我们还将回顾基于**统一资源定位符**（**URL**）的通信和最新的**Java
    HTTP客户端API**。学习完本章后，你将能够创建使用**UDP**、**TCP**、**HTTP**协议以及**WebSocket**进行通信的服务器和客户端应用程序。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Network protocols
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络协议
- en: UDP-based communication
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于UDP的通信
- en: TCP-based communication
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于TCP的通信
- en: UDP versus TCP protocols
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UDP与TCP协议
- en: URL-based communication
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于URL的通信
- en: Using the HTTP 2 Client API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTP 2客户端API
- en: Creating a standalone application HTTP server
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建独立应用程序的HTTP服务器
- en: By the end of the chapter, you will be able to use all the most popular protocols
    to send/receive messages between the client and server. You will also learn how
    to create a server as a separate project and how to create and use a common shared
    library.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用所有最流行的协议在客户端和服务器之间发送/接收消息。你还将学习如何创建作为独立项目的服务器以及如何创建和使用公共共享库。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To be able to execute the code examples provided in this chapter, you will
    need the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行本章提供的代码示例，你需要以下内容：
- en: A computer with a Microsoft Windows, Apple macOS, or Linux operating system
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有Microsoft Windows、Apple macOS或Linux操作系统的计算机
- en: Java SE version 17 or later
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java SE版本17或更高
- en: An IDE or code editor of your choosing
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你选择的IDE或代码编辑器
- en: The instructions for how to set up a Java SE and IntelliJ IDEA editor were provided
    in [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015), *Getting Started with
    Java 17*, of this book. The files with the code examples for this chapter are
    available on GitHub in the [https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git)
    repository, in the `examples/src/main/java/com/packt/learnjava/ch11_network` folder,
    and in the `common` and `server` folders, as separate projects.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何设置Java SE和IntelliJ IDEA编辑器的说明提供在本书的**第1章**，*开始使用Java 17*，链接为[*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015)。本章的代码示例文件可在GitHub的[https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git)存储库中找到，位于`examples/src/main/java/com/packt/learnjava/ch11_network`文件夹中，以及`common`和`server`文件夹中，作为独立的项目。
- en: Network protocols
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络协议
- en: 'Network programming is a vast area. The **internet protocol** (**IP**) suite
    consists of four layers, each of which has a dozen or more protocols:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 网络编程是一个庞大的领域。**互联网协议**（**IP**）套件由四层组成，每一层都有十几个或更多的协议：
- en: '**The link layer**: The group of protocols used when a client is physically
    connected to the host; three core protocols include the **Address Resolution Protocol**
    (**ARP**), the **Reverse Address Resolution** **Protocol** (**RARP**), and the
    **Neighbor Discovery Protocol** (**NDP**).'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链路层**：当客户端物理连接到主机时使用的协议组；三个核心协议包括**地址解析协议**（**ARP**）、**反向地址解析协议**（**RARP**）和**邻居发现协议**（**NDP**）。'
- en: '`10011010.00010111.11111110.00010001`, which results in an IP address of `154.23.254.17`.
    The examples in this chapter use IPv4\. The industry, though, is slowly switching
    to IPv6\. An example of an IPv6 address is `594D:1A1B:2C2D:3E3F:4D4A:5B5A:6B4E:7FF2`.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10011010.00010111.11111110.00010001`，这导致IP地址为`154.23.254.17`。本章的示例使用IPv4。然而，行业正在缓慢地转向IPv6。一个IPv6地址的例子是`594D:1A1B:2C2D:3E3F:4D4A:5B5A:6B4E:7FF2`。'
- en: '**The transport layer**: The group of host-to-host communication services.
    It includes TCP, also known as the TCP/IP protocol, and UDP (which we are going
    to discuss shortly). The other protocols in this group are the **Datagram Congestion
    Control Protocol** (**DCCP**) and the **Stream Control Transmission Protocol**
    (**SCTP**).'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传输层**：一组主机间通信服务。它包括TCP，也称为TCP/IP协议，以及UDP（我们将在稍后讨论）。本组中的其他协议包括**数据报拥塞控制协议**（**DCCP**）和**流控制传输协议**（**SCTP**）。'
- en: '**The application layer**: The group of protocols and interface methods used
    by hosts in a communication network. It includes **Telnet**, **File Transfer Protocol**
    (**FTP**), **Domain Name System** (**DNS**), **Simple Mail Transfer Protocol**
    (**SMTP**), **Lightweight Directory Access Protocol** (**LDAP**), **Hypertext
    Transfer Protocol** (**HTTP**), **Hypertext Transfer Protocol Secure** (**HTTPS**),
    and **Secure Shell** (**SSH**).'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用层**：一组由通信网络中的主机使用的协议和接口方法。它包括**Telnet**、**文件传输协议**（**FTP**）、**域名系统**（**DNS**）、**简单邮件传输协议**（**SMTP**）、**轻量级目录访问协议**（**LDAP**）、**超文本传输协议**（**HTTP**）、**安全超文本传输协议**（**HTTPS**）和**安全外壳**（**SSH**）。'
- en: The link layer is the lowest layer; it is used by the internet layer, which
    is, in turn, used by the transport layer. This transport layer is then used by
    the application layer in support of the protocol implementations.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 链路层是最低层；它被互联网层使用，而互联网层反过来又被传输层使用。然后，传输层被应用层用于支持协议实现。
- en: For security reasons, Java does not provide access to the protocols of the link
    layer and the internet layer. This means that Java does not allow you to create
    custom transport protocols that, for example, serve as an alternative to TCP/IP.
    That is why, in this chapter, we will review only the protocols of the transport
    layer (TCP and UDP) and the application layer (HTTP). We will explain and demonstrate
    how Java supports them and how a Java application can take advantage of this support.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于安全原因，Java不提供对链路层和互联网层协议的访问。这意味着Java不允许您创建自定义传输协议，例如，作为TCP/IP的替代品。这就是为什么在本章中，我们只回顾传输层（TCP和UDP）和应用层（HTTP）的协议。我们将解释和演示Java如何支持它们，以及Java应用程序如何利用这种支持。
- en: Java supports the TCP and UDP protocols with classes of the `java.net` package,
    while the HTTP protocol can be implemented in the Java application using the classes
    of the `java.net.http` package (which was introduced with Java 11).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Java通过`java.net`包中的类支持TCP和UDP协议，而HTTP协议可以使用`java.net.http`包中的类在Java应用程序中实现（该包是在Java
    11中引入的）。
- en: Both the TCP and UDP protocols can be implemented in Java using *sockets*. Sockets
    are identified by a combination of an IP address and a port number, and they represent
    a connection between two applications. Since the UDP protocol is somewhat simpler
    than the TCP protocol, we’ll start with UDP.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: TCP和UDP协议都可以使用*套接字*在Java中实现。套接字由IP地址和端口号的组合标识，它们代表两个应用程序之间的连接。由于UDP协议比TCP协议简单一些，我们将从UDP开始。
- en: UDP-based communication
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于UDP的通信
- en: The UDP protocol was designed by David P. Reed in 1980\. It allows applications
    to send messages called **datagrams** using a simple connectionless communication
    model with a minimal protocol mechanism such as a checksum, for data integrity.
    It has no handshaking dialogs and, thus, does not guarantee message delivery or
    preserve the order of messages. It is suitable for those cases when dropping messages
    or mixing up orders are preferred instead of waiting for retransmission.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: UDP协议由David P. Reed于1980年设计。它允许应用程序使用具有最小协议机制（如校验和）的简单无连接通信模型发送称为**数据报**的消息，以实现数据完整性。它没有握手对话，因此不保证消息的交付或保持消息的顺序。它适用于那些宁愿丢弃消息或混淆顺序而不是等待重传的情况。
- en: 'A datagram is represented by the `java.net.DatagramPacket` class. An object
    of this class can be created using one of the six constructors; the following
    two constructors are the most commonly used:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 数据报由`java.net.DatagramPacket`类表示。可以使用六个构造函数中的任何一个来创建此类对象；以下两个构造函数是最常用的：
- en: '`DatagramPacket(byte[] buffer, int length)`: This constructor creates a datagram
    packet and is used to receive the packets; `buffer` holds the incoming datagram,
    while `length` is the number of bytes to be read.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DatagramPacket(byte[] buffer, int length)`: 此构造函数创建一个数据报包，用于接收数据包；`buffer`包含传入的数据报，而`length`是要读取的字节数。'
- en: '`DatagramPacket(byte[] buffer, int length, InetAddress address, int port)`:
    This creates a datagram packet and is used to send the packets; `buffer` holds
    the packet data, `length` is the packet data length, `address` holds the destination
    IP address, and `port` is the destination port number.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DatagramPacket(byte[] buffer, int length, InetAddress address, int port)`:
    这创建一个数据报包，并用于发送数据包；`buffer` 存储数据包数据，`length` 是数据包数据长度，`address` 存储目标 IP 地址，`port`
    是目标端口号。'
- en: 'Once constructed, the `DatagramPacket` object exposes the following methods
    that can be used to extract data from the object or set/get its properties:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构造，`DatagramPacket` 对象会公开以下方法，可用于从对象中提取数据或设置/获取其属性：
- en: '`void setAddress(InetAddress iaddr)`: This sets the destination IP address.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void setAddress(InetAddress iaddr)`: 这设置目标 IP 地址。'
- en: '`InetAddress getAddress()`: This returns the destination or source IP address.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InetAddress getAddress()`: 这返回目标或源 IP 地址。'
- en: '`void setData(byte[] buf)`: This sets the data buffer.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void setData(byte[] buf)`: 这设置数据缓冲区。'
- en: '`void setData(byte[] buf, int offset, int length)`: This sets the data buffer,
    data offset, and length.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void setData(byte[] buf, int offset, int length)`: 这设置数据缓冲区、数据偏移量和长度。'
- en: '`void setLength(int length)`: This sets the length for the packet.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void setLength(int length)`: 这设置数据包的长度。'
- en: '`byte[] getData()`: This returns the data buffer.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte[] getData()`: 这返回数据缓冲区。'
- en: '`int getLength()`: This returns the length of the packet that is to be sent
    or received.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int getLength()`: 这返回要发送或接收的数据包的长度。'
- en: '`int getOffset()`: This returns the offset of the data that is to be sent or
    received.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int getOffset()`: 这返回要发送或接收的数据的偏移量。'
- en: '`void setPort(int port)`: This sets the destination port number.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void setPort(int port)`: 这设置目标端口号。'
- en: '`int getPort()`: This returns the port number where data is to be sent or received
    from. Once a `DatagramPacket` object is created, it can be sent or received using
    the `DatagramSocket` class, which represents a connectionless socket for sending
    and receiving datagram packets. An object of this class can be created using one
    of six constructors; the following three constructors are the most commonly used:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int getPort()`: 这返回数据要发送或接收的端口号。一旦创建 `DatagramPacket` 对象，就可以使用 `DatagramSocket`
    类发送或接收，该类表示用于发送和接收数据报包的无连接套接字。可以使用六个构造函数之一创建此类对象；以下三个构造函数是最常用的：'
- en: '`DatagramSocket()`: This creates a datagram socket and binds it to any available
    port on the local host machine. It is typically used to create a sending socket
    because the destination address (and port) can be set inside the packet (see the
    preceding `DatagramPacket` constructors and methods).'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DatagramSocket()`: 这创建一个数据报套接字并将其绑定到本地主机上的任何可用端口。它通常用于创建发送套接字，因为目标地址（和端口）可以设置在数据包内（参见前面的
    `DatagramPacket` 构造函数和方法）。'
- en: '`DatagramSocket(int port)`: This creates a datagram socket and binds it to
    the specified port on the local host machine. It is used to create a receiving
    socket when any local machine address (called a `DatagramSocket(int port, InetAddress
    address)`: This creates a datagram socket and binds it to the specified port and
    the specified local address; the local port must be between `0` and `65535`. It
    is used to create a receiving socket when a particular local machine address needs
    to be bound.'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DatagramSocket(int port)`: 这创建一个数据报套接字并将其绑定到本地主机上的指定端口。它用于创建接收套接字，当任何本地机器地址（称为
    `DatagramSocket(int port, InetAddress address)`: 这创建一个数据报套接字并将其绑定到指定的端口和指定的本地地址；本地端口必须在
    `0` 和 `65535` 之间。它用于创建接收套接字，当需要绑定特定本地机器地址时。'
- en: 'The following two methods of the `DatagramSocket` object are the most commonly
    used for sending and receiving messages (or packets):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`DatagramSocket` 对象的以下两种方法是最常用的用于发送和接收消息（或数据包）：'
- en: '`void send(DatagramPacket p)`: This sends the specified packet.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void send(DatagramPacket p)`: 这发送指定的数据包。'
- en: '`void receive(DatagramPacket p)`: This receives a packet by filling the specified
    `DatagramPacket` object’s buffer with the data received. The specified `DatagramPacket`
    object also contains the sender’s IP address and the port number on the sender’s
    machine.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void receive(DatagramPacket p)`: 这通过填充指定的 `DatagramPacket` 对象的缓冲区以接收数据。指定的
    `DatagramPacket` 对象还包含发送者的 IP 地址和发送者机器上的端口号。'
- en: 'Let’s take a look at a code example. Here is the UDP message receiver that
    exits after the message has been received:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个代码示例。以下是一个在接收到消息后退出的 UDP 消息接收器：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, the receiver is listening for a text message (it interprets
    each byte as a character) on any address of the local machine on port `3333`.
    It uses a buffer of 16 bytes only; as soon as the buffer is filled with the received
    data, the receiver prints its content and exits.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，接收者在本地机器的任何地址上监听端口`3333`的文本消息（它将每个字节解释为字符）。它只使用16字节的缓冲区；一旦缓冲区被接收到的数据填满，接收者就会打印其内容并退出。
- en: 'Here is an example of the UDP message sender:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是UDP消息发送者的一个示例：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, the sender constructs a packet with the message, the local machine
    address, and the same port as the one that the receiver uses. After the constructed
    packet is sent, the sender exits.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，发送者构建了一个包含消息、本地机器地址以及与接收者使用的相同端口的包。在发送构建的包之后，发送者退出。
- en: 'We can run the sender now, but without the receiver running, there is nobody
    to get the message. So, we’ll start the receiver first. It listens on port `3333`,
    but there is no message coming – so it waits. Then, we run the sender and the
    receiver displays the following message:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行发送者，但如果没有接收者运行，就没有人能够接收到消息。所以，我们将首先启动接收者。它监听端口`3333`，但没有消息到来——所以它等待。然后，我们运行发送者，接收者显示以下消息：
- en: '![](img/B18388_Figure_11.1.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_11.1.jpg)'
- en: 'Since the buffer is smaller than the message, it was only partially received
    – the rest of the message is lost. That’s why we increase the buffer size to 30\.
    Also, we can create an infinite loop and let the receiver run indefinitely (see
    the `UdpReceiver2` class):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缓冲区小于消息，所以只部分接收了消息——其余的消息丢失了。这就是为什么我们将缓冲区大小增加到30的原因。此外，我们可以创建一个无限循环，并让接收者无限期地运行（参见`UdpReceiver2`类）：
- en: '[PRE28]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'By doing so, we can run the sender several times. Here is what the receiver
    `UdpReceiver2` prints if we run the sender three times:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们可以多次运行发送者。以下是当我们运行发送者三次时，接收者`UdpReceiver2`打印的内容：
- en: '![](img/B18388_Figure_11.2.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_11.2.jpg)'
- en: As you can see, all three messages are received. If you run the receiver `UdpReceiver2`,
    do not forget to stop it manually after you don’t need to run it anymore. Otherwise,
    it continues running indefinitely.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，所有三条消息都已接收。如果您运行`UdpReceiver2`接收者，不要忘记在您不再需要运行它时手动停止它。否则，它将继续无限期地运行。
- en: So, this is the basic idea of the UDP protocol. The sender sends a message to
    a certain address and port even if no socket *listens* on this address and port.
    It does not require establishing any kind of connection before sending the message,
    which makes the UDP protocol faster and more lightweight than the TCP protocol
    (which requires you to establish the connection first). This way, the TCP protocol
    takes message sending to another level of reliability by making sure that the
    destination exists and that the message can be delivered.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这就是UDP协议的基本思想。发送者即使没有套接字在这个地址和端口上监听，也会向特定的地址和端口发送消息。在发送消息之前，它不需要建立任何类型的连接，这使得UDP协议比TCP协议（需要你首先建立连接）更快、更轻量。这样，TCP协议通过确保目的地存在并且消息可以被投递，将消息发送提升到了另一个可靠性的层次。
- en: TCP-based communication
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于TCP的通信
- en: TCP was designed by the **Defense Advanced Research Projects Agency** (**DARPA**)
    in the 1970s for use in the **Advanced Research Projects Agency Network** (**ARPANET**).
    It complements IP and, thus, is also referred to as TCP/IP. The TCP protocol,
    even by its name, indicates that it provides reliable (that is, error-checked
    or controlled) data transmission. It allows the ordered delivery of bytes in an
    IP network and is widely used by the web, email, secure shell, and file transfer.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: TCP是在20世纪70年代由**国防高级研究计划局**（**DARPA**）为在**高级研究计划局网络**（**ARPANET**）中使用而设计的。它补充了IP，因此也被称为TCP/IP。从其名称来看，TCP协议表明它提供可靠（即，经过错误检查或控制的）数据传输。它允许在IP网络中按顺序交付字节，并被广泛应用于网页、电子邮件、安全外壳和文件传输。
- en: An application that uses TCP/IP is not even aware of all the handshaking that
    takes place between the socket and the transmission details – such as network
    congestion, traffic load balancing, duplication, and even the loss of some IP
    packets. The underlying protocol implementation of the transport layer detects
    these problems, resends the data, reconstructs the order of the sent packets,
    and minimizes network congestion.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TCP/IP的应用程序甚至不知道在套接字和传输细节之间发生的所有握手过程——例如网络拥塞、流量负载均衡、重复以及甚至某些IP数据包的丢失。传输层的底层协议实现检测到这些问题，重新发送数据，重建发送数据包的顺序，并最小化网络拥塞。
- en: In contrast to the UDP protocol, TCP/IP-based communication is focused on accurate
    delivery at the expense of the delivery period. That’s why it is not used for
    real-time applications, such as voice over IP, where reliable delivery and correct
    sequential ordering are required. However, if every bit needs to arrive exactly
    as it was sent and in the same sequence, then TCP/IP is irreplaceable.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与UDP协议相比，基于TCP/IP的通信更注重准确交付，而牺牲了交付周期。这就是为什么它不适用于需要可靠交付和正确顺序的实时应用，如IP语音。然而，如果每个比特都需要精确地按照发送的顺序到达，那么TCP/IP是不可或缺的。
- en: 'To support such behavior, TCP/IP communication maintains a session throughout
    the communication. The session is identified by the client address and port. Each
    session is represented by an entry in a table on the server. This contains all
    the metadata about the session: the client IP address and port, the connection
    status, and the buffer parameters. However, these details are usually hidden from
    the application developer, so we won’t go into any more detail here. Instead,
    we will turn to the Java code.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这种行为，TCP/IP通信在整个通信过程中保持一个会话。会话由客户端地址和端口标识。每个会话在服务器上的表中都有一个条目。这包含有关会话的所有元数据：客户端IP地址和端口、连接状态和缓冲区参数。然而，这些细节通常对应用程序开发者是隐藏的，所以我们不会在这里进一步详细说明。相反，我们将转向Java代码。
- en: Similar to the UDP protocol, the TCP/IP protocol implementation in Java uses
    sockets. But instead of the `java.net.DatagramSocket` class that implements the
    UDP protocol, the TCP/IP-based sockets are represented by the `java.net.ServerSocket`
    and `java.net.Socket` classes. They allow messages to be sent and received between
    two applications, one of them being a server and the other a client.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与UDP协议类似，Java中的TCP/IP协议实现使用套接字。但与实现UDP协议的`java.net.DatagramSocket`类不同，基于TCP/IP的套接字由`java.net.ServerSocket`和`java.net.Socket`类表示。它们允许两个应用程序之间发送和接收消息，其中一个作为服务器，另一个作为客户端。
- en: The `ServerSocket` and `SocketClass` classes perform very similar jobs. The
    only difference is that the `ServerSocket` class has the `accept()` method, which
    *accepts* the request from the client. This means that the server has to be up
    and ready to receive the request first. Then, the connection is initiated by the
    client that creates its own socket that sends the connection request (from the
    constructor of the `Socket` class). The server then accepts the request and creates
    a local socket connected to the remote socket (on the client side).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServerSocket`和`SocketClass`类执行非常相似的任务。唯一的区别是`ServerSocket`类有`accept()`方法，它*接受*来自客户端的请求。这意味着服务器必须首先启动并准备好接收请求。然后，客户端通过创建自己的套接字并发送连接请求（来自`Socket`类的构造函数）来发起连接。服务器随后接受请求并创建一个连接到远程套接字（在客户端端）的本地套接字。'
- en: After establishing the connection, data transmission can occur using I/O streams
    as described in [*Chapter 5*](B18388_05_ePub.xhtml#_idTextAnchor121), *Strings,
    Input/Output, and Files*. The `Socket` object has the `getOutputStream()` and
    `getInputStream()` methods that provide access to the socket’s data streams. Data
    from the `java.io.OutputStream` object on the local computer appears as coming
    from the `java.io.InputStream` object on the remote machine.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立连接后，可以使用如[*第五章*](B18388_05_ePub.xhtml#_idTextAnchor121)中描述的I/O流进行数据传输，即*字符串、输入/输出和文件*。`Socket`对象具有`getOutputStream()`和`getInputStream()`方法，这些方法提供了对套接字数据流的访问。来自本地计算机的`java.io.OutputStream`对象看起来像是来自远程机器的`java.io.InputStream`对象。
- en: Let’s now take a closer look at the `java.net.ServerSocket` and `java.net.Socket`
    classes and then run some examples of their usage.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将更详细地研究`java.net.ServerSocket`和`java.net.Socket`类，然后运行一些它们使用示例。
- en: The java.net.ServerSocket class
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`java.net.ServerSocket`类'
- en: 'The `java.net.ServerSocket` class has four constructors:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.net.ServerSocket`类有四个构造函数：'
- en: '`ServerSocket()`: This creates a server socket object that is not bound to
    a particular address and port. It requires the use of the `bind()` method to bind
    the socket.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServerSocket()`: 这将创建一个未绑定到特定地址和端口的服务器套接字对象。它需要使用`bind()`方法来绑定套接字。'
- en: '`ServerSocket(int port)`: This creates a server socket object bound to the
    provided port. The `port` value must be between `0` and `65535`. If the port number
    is specified as a value of `0`, this means that the port number needs to be bound
    automatically. This port number can then be retrieved by calling `getLocalPort()`.
    By default, the maximum queue length for incoming connections is `50`. This means
    that the maximum parallel incoming connections are `50` by default. Exceeding
    connections will be refused.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServerSocket(int port)`：这创建了一个绑定到提供的端口的服务器套接字对象。`port`值必须在`0`和`65535`之间。如果端口号指定为`0`的值，这意味着端口号需要自动绑定。然后可以通过调用`getLocalPort()`来检索此端口号。默认情况下，传入连接的最大队列长度为`50`。这意味着默认情况下最大并行传入连接为`50`。超出连接将被拒绝。'
- en: '`ServerSocket(int port, int backlog)`: This provides the same functionality
    as the `ServerSocket(int port)` constructor and allows you to set the maximum
    queue length for incoming connections by means of the `backlog` parameter.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServerSocket(int port, int backlog)`：这提供了与`ServerSocket(int port)`构造函数相同的功能，并允许您通过`backlog`参数设置传入连接的最大队列长度。'
- en: '`ServerSocket(int port, int backlog, InetAddress bindAddr)`: This creates a
    server socket object that is similar to the preceding constructor, but also bound
    to the IP address provided. When the `bindAddr` value is `null`, it will default
    to accepting connections on any or all local addresses.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServerSocket(int port, int backlog, InetAddress bindAddr)`：这创建了一个与前面的构造函数类似的服务器套接字对象，但还绑定到提供的IP地址。当`bindAddr`值为`null`时，它将默认接受任何或所有本地地址上的连接。'
- en: 'The following four methods of the `ServerSocket` class are the most commonly
    used, and they are essential for establishing a socket’s connection:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServerSocket`类的以下四种方法是使用最频繁的，它们对于建立套接字的连接是必不可少的：'
- en: '`void bind(SocketAddress endpoint)`: This binds the `ServerSocket` object to
    a specific IP address and port. If the provided address is `null`, then the system
    will pick up a port and a valid local address automatically (which can be later
    retrieved using the `getLocalPort()`, `getLocalSocketAddress()`, and `getInetAddress()`
    methods). Additionally, if the `ServerSocket` object was created by the constructor
    without any parameters, then this method, or the following `bind()` method, needs
    to be invoked before a connection can be established.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void bind(SocketAddress endpoint)`：这会将`ServerSocket`对象绑定到特定的IP地址和端口。如果提供的地址为`null`，则系统将自动选择一个端口和有效的本地地址（以后可以使用`getLocalPort()`、`getLocalSocketAddress()`和`getInetAddress()`方法检索）。此外，如果`ServerSocket`对象是通过不带任何参数的构造函数创建的，那么在建立连接之前，需要调用此方法或下面的`bind()`方法。'
- en: '`void bind(SocketAddress endpoint, int backlog)`: This acts in a similar way
    to the preceding method; the `backlog` argument is the maximum number of pending
    connections on the socket (that is, the size of the queue). If the `backlog` value
    is less than or equal to `0`, then an implementation-specific default will be
    used.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void bind(SocketAddress endpoint, int backlog)`：这与前面的方法类似；`backlog`参数是套接字上挂起的最大连接数（即队列的大小）。如果`backlog`值小于或等于`0`，则使用实现特定的默认值。'
- en: '`void setSoTimeout(int timeout)`: This sets the value (in milliseconds) of
    how long the socket waits for a client after the `accept()` method is called.
    If the client has not called and the timeout expires, a `java.net.SocketTimeoutException`
    exception is thrown, but the `ServerSocket` object remains valid and can be reused.
    The `timeout` value of `0` is interpreted as an infinite timeout (the `accept()`
    method blocks until a client calls).'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void setSoTimeout(int timeout)`：这设置了在调用`accept()`方法后套接字等待客户端的时间（以毫秒为单位）。如果客户端没有调用并且超时到期，将抛出`java.net.SocketTimeoutException`异常，但`ServerSocket`对象仍然有效并且可以被重用。`timeout`值为`0`表示无限超时（`accept()`方法会阻塞，直到客户端调用）。'
- en: '`Socket accept()`: This blocks until a client calls or the timeout period (if
    set) expires.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Socket accept()`：这会阻塞，直到客户端调用或超时期（如果已设置）到期。'
- en: Other methods of the class allow you to set or get other properties of the `Socket`
    object and they can be used for better dynamic management of the socket connection.
    You can refer to the online documentation of the class to understand the available
    options in more detail.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 类的其他方法允许您设置或获取`Socket`对象的其他属性，并且它们可以用于更好地动态管理套接字连接。您可以参考该类的在线文档以更详细地了解可用的选项。
- en: 'The following code is an example of a server implementation using the `ServerSocket`
    class:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是使用`ServerSocket`类实现服务器的一个示例：
- en: '[PRE46]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Let’s walk through the preceding code. In the try-with-resources statement,
    we create `Socket`, `DataInputStream`, and `DataOutputStream` objects based on
    our newly created socket, and the `BufferedReader` object to read the user input
    from the console (we will use it to enter the data). While creating the socket,
    the `accept()` method blocks until a client tries to connect to port `3333` of
    the local server.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分析前面的代码。在try-with-resources语句中，我们根据新创建的socket创建了`Socket`、`DataInputStream`和`DataOutputStream`对象，以及`BufferedReader`对象来读取控制台的用户输入（我们将用它来输入数据）。在创建socket时，`accept()`方法会阻塞，直到客户端尝试连接到本地服务器的`3333`端口。
- en: 'Then, the code enters an infinite loop. First, it reads the bytes sent by the
    client as a Unicode character string encoded in a modified UTF-8 format by using
    the `readUTF()` method of `DataInputStream`. The result is printed with the `"Client
    said: "` prefix. If the received message is an `"end"` string, then the code exits
    the loop and the server’s program exits. If the message is not `"end"`, then the
    `"Say something: "` prompt is displayed on the console and the `readLine()` method
    blocks until a user types something and clicks *Enter*.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '然后，代码进入一个无限循环。首先，它使用`DataInputStream`的`readUTF()`方法读取客户端发送的字节，并将其作为修改后的UTF-8格式的Unicode字符字符串读取。结果带有`"Client
    said: "`前缀打印出来。如果接收到的消息是`"end"`字符串，则代码退出循环，服务器程序退出。如果消息不是`"end"`，则控制台显示`"Say something:
    "`提示，`readLine()`方法会阻塞，直到用户输入一些内容并点击*Enter*。'
- en: The server takes the input from the screen and writes it as a Unicode character
    string to the output stream using the `writeUtf()` method. As we mentioned already,
    the output stream of the server is connected to the input stream of the client.
    If the client reads from the input stream, it receives the message sent by the
    server. If the sent message is `"end"`, then the sever exits the loop and the
    program. If not, then the loop body is executed again.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器从屏幕读取输入，并使用`writeUtf()`方法将其作为Unicode字符字符串写入输出流。正如我们之前提到的，服务器的输出流连接到客户端的输入流。如果客户端从输入流中读取，它会接收到服务器发送的消息。如果发送的消息是`"end"`，则服务器退出循环和程序。如果不是，则再次执行循环体。
- en: The described algorithm assumes that the client exits only when it sends or
    receives the `"end"` message. Otherwise, the client generates an exception if
    it tries to send a message to the server afterward. This demonstrates the difference
    between the UDP and TCP protocols that we mentioned already – TCP is based on
    the session that is established between the server and client sockets. If one
    side drops it, the other side immediately encounters an error.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 描述的算法假设客户端只有在发送或接收`"end"`消息时才会退出。否则，如果客户端在之后尝试向服务器发送消息，则会生成异常。这展示了我们之前提到的UDP和TCP协议之间的区别——TCP基于服务器和客户端socket之间建立的会话。如果任一方断开连接，另一方会立即遇到错误。
- en: Now, let’s review an example of a TCP-client implementation.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一个TCP客户端实现的例子。
- en: The java.net.Socket class
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: The java.net.Socket class
- en: 'The `java.net.Socket` class should now be familiar to you since it was used
    in the preceding example. We used it to access the input and output streams of
    the connected sockets. Now we are going to review the `Socket` class systematically
    and explore how it can be used to create a TCP client. The `Socket` class has
    five constructors:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在先前的例子中已经使用过，`java.net.Socket`类现在应该对您来说很熟悉。我们使用它来访问已连接socket的输入和输出流。现在我们将系统地回顾`Socket`类，并探讨如何使用它来创建TCP客户端。`Socket`类有五个构造函数：
- en: '`Socket()`: This creates an unconnected socket. It uses the `connect()` method
    to establish a connection of this socket with a socket on a server.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Socket()`: 这将创建一个未连接的socket。它使用`connect()`方法来建立此socket与服务器上socket的连接。'
- en: '`Socket(String host, int port)`: This creates a socket and connects it to the
    provided port on the `host` server. If it throws an exception, the connection
    to the server is not established; otherwise; you can start sending data to the
    server.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Socket(String host, int port)`: 这将创建一个socket并将其连接到`host`服务器上提供的端口。如果它抛出异常，则不会建立与服务器的连接；否则，您可以开始向服务器发送数据。'
- en: '`Socket(InetAddress address, int port)`: This acts similarly to the preceding
    constructor, except that the host is provided as an `InetAddress` object.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Socket(InetAddress address, int port)`: 这与前面的构造函数类似，只是将主机提供为`InetAddress`对象。'
- en: '`Socket(String host, int port, InetAddress localAddr, int localPort)`: This
    works similarly to the preceding constructor, except that it also allows you to
    bind the socket to the provided local address and port (if the program is run
    on a machine with multiple IP addresses). If the provided `localAddr` value is
    `null`, any local address is selected. Alternatively, if the provided `localPort`
    value is `null`, then the system picks up a free port in the bind operation.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Socket(String host, int port, InetAddress localAddr, int localPort)`: 这个构造函数的行为与前面的构造函数类似，但它还允许您将套接字绑定到提供的本地地址和端口（如果程序在具有多个
    IP 地址的机器上运行）。如果提供的 `localAddr` 值为 `null`，则选择任何本地地址。或者，如果提供的 `localPort` 值为 `null`，则系统在绑定操作中选取一个空闲端口。'
- en: '`Socket(InetAddress address, int port, InetAddress localAddr, int localPort)`:
    This acts similarly to the preceding constructor, except that the local address
    is provided as an `InetAddress` object.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Socket(InetAddress address, int port, InetAddress localAddr, int localPort)`:
    这个构造函数的行为与前面的构造函数类似，但提供了一个 `InetAddress` 对象作为本地地址。'
- en: 'Here are the following two methods of the `Socket` class that we have used
    already:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `Socket` 类我们已经使用过的以下两种方法：
- en: '`InputStream getInputStream()`: This returns an object that represents the
    source (the remote socket) and brings the data (inputs them) into the program
    (the local socket).'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InputStream getInputStream()`: 这个方法返回一个表示源（远程套接字）的对象，并将数据（输入）带入程序（本地套接字）。'
- en: '`OutputStream getOutputStream()`: This returns an object that represents the
    source (the local socket) and sends the data (outputs them) to a remote socket.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OutputStream getOutputStream()`: 这个方法返回一个表示源（本地套接字）的对象，并将数据（输出）发送到远程套接字。'
- en: 'Let’s now examine the TCP-client code, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检查一下 TCP 客户端代码，如下所示：
- en: '[PRE74]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The preceding `TcpClient` code looks almost exactly the same as the `TcpServer`
    code we reviewed. The only principal difference is that the `new Socket("localhost",
    3333)` constructor attempts to establish a connection with the `"localhost:3333"`
    server immediately, so it expects that the `localhost` server is up and listening
    on port `3333`; the rest is the same as the server code.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 `TcpClient` 代码几乎与我们所审查的 `TcpServer` 代码完全相同。唯一的根本区别是 `new Socket("localhost",
    3333)` 构造函数立即尝试与 `"localhost:3333"` 服务器建立连接，因此它期望 `localhost` 服务器正在端口 `3333` 上运行并监听；其余部分与服务器代码相同。
- en: Therefore, the only reason we need to use the `ServerSocket` class is to allow
    the server to run while waiting for the client to connect to it; everything else
    can be done using only the `Socket` class.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们唯一需要使用 `ServerSocket` 类的原因是允许服务器在等待客户端连接时运行；其余所有操作都可以仅使用 `Socket` 类来完成。
- en: Other methods of the `Socket` class allow you to set or get other properties
    of the `socket` object, and they can be used for better dynamic management of
    the socket connection. You can read the online documentation of the class to understand
    the available options in more detail.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`Socket` 类的其他方法允许您设置或获取 `socket` 对象的其他属性，并且它们可以用于更好地动态管理套接字连接。您可以阅读该类的在线文档以详细了解可用的选项。'
- en: Running the examples
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行示例
- en: 'Let’s now run the `TcpServer` and `TcpClient` programs. If we start `TcpClient`
    first, we get `java.net.ConnectException` with the `TcpServer` program first.
    When it starts, no messages are displayed. Instead, it just waits until the client
    connects. So, we then start `TcpClient` and see the following message on the screen:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行 `TcpServer` 和 `TcpClient` 程序。如果我们首先启动 `TcpClient`，我们会先遇到 `TcpServer`
    程序的 `java.net.ConnectException`。当它启动时，不会显示任何消息。相反，它只是等待客户端连接。因此，我们随后启动 `TcpClient`
    并在屏幕上看到以下消息：
- en: '![](img/B18388_Figure_11.3.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_11.3.jpg)'
- en: 'We type `Hello!` and then press *Enter*:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们输入 `Hello!` 然后按 *Enter* 键：
- en: '![](img/B18388_Figure_11.4.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_11.4.jpg)'
- en: 'Now let’s look at the server-side screen:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看服务器端屏幕：
- en: '![](img/B18388_Figure_11.5.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_11.5.jpg)'
- en: 'We type `Hi!` on the server-side screen and press *Enter*:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在服务器端屏幕上输入 `Hi!` 并按 *Enter* 键：
- en: '![](img/B18388_Figure_11.6.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_11.6.jpg)'
- en: 'On the client-side screen, we see the following messages:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端屏幕上，我们看到以下消息：
- en: '![](img/B18388_Figure_11.7.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_11.7.jpg)'
- en: 'We can continue this dialog indefinitely until the server or the client sends
    the message `end`. Let’s make the client do it; the client says `end` and then
    exits:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以无限期地继续这个对话，直到服务器或客户端发送消息 `end`。让我们让客户端来完成这个操作；客户端说 `end` 然后退出：
- en: '![](img/B18388_Figure_11.8.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_11.8.jpg)'
- en: 'Then, the server follows suit:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，服务器也照此办理：
- en: '![](img/B18388_Figure_11.9.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_11.9.jpg)'
- en: That’s all we wanted to demonstrate while discussing the TCP protocol. Now let’s
    review the differences between the UDP and TCP protocols.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们讨论TCP协议时想要展示的所有内容。现在让我们回顾UDP和TCP协议之间的区别。
- en: UDP versus TCP protocols
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UDP与TCP协议对比
- en: 'The differences between the UDP and TCP/IP protocols can be listed as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: UDP和TCP/IP协议之间的区别可以列举如下：
- en: UDP simply sends data, whether the data receiver is up and running or not. That’s
    why UDP is better suited to sending data compared to many other clients using
    multicast distribution. TCP, on the other hand, requires establishing the connection
    between the client and the server first. The TCP client sends a special control
    message; the server receives it and responds with a confirmation. The client then
    sends a message to the server that acknowledges the server confirmation. Only
    after this is data transmission between the client and server possible.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UDP简单地发送数据，无论数据接收器是否正在运行。这就是为什么UDP比许多使用多播分发的其他客户端更适合发送数据。另一方面，TCP需要首先在客户端和服务器之间建立连接。TCP客户端发送一个特殊的控制消息；服务器接收它并以确认响应。然后客户端向服务器发送一个消息以确认服务器的确认。只有在完成这些步骤后，客户端和服务器之间才能进行数据传输。
- en: TCP guarantees message delivery or raises an error, while UDP does not, and
    a datagram packet may be lost.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP保证消息的交付或引发错误，而UDP则不保证，数据报文可能丢失。
- en: TCP guarantees the preservation of the order of messages on delivery, while
    UDP does not.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP保证在交付时消息的顺序，而UDP则不保证。
- en: As a result of these provided guarantees, TCP is slower than UDP.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于这些提供的保证，TCP比UDP慢。
- en: Additionally, protocols require headers to be sent along with the packet. The
    header size of a TCP packet is 20 bytes, while a datagram packet is 8 bytes. The
    UDP header contains `Length`, `Source Port`, `Destination Port`, and `Checksum`,
    while the TCP header contains `Sequence Number`, `Ack Number`, `Data Offset`,
    `Reserved`, `Control Bit`, `Window`, `Urgent Pointer`, `Options`, and `Padding`,
    in addition to the UDP headers.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，协议需要将头部信息与数据包一起发送。TCP数据包的头部大小为20字节，而数据报文为8字节。UDP头部包含`长度`、`源端口`、`目的端口`和`校验和`，而TCP头部包含`序列号`、`确认号`、`数据偏移`、`保留位`、`控制位`、`窗口`、`紧急指针`、`选项`和`填充`，除了UDP头部之外。
- en: Different application protocols are based on the TCP or UDP protocols. The **TCP**-based
    protocols are **HTTP**, **HTTPS**, **Telnet**, **FTP**, and **SMTP**. The **UDP**-based
    protocols are **Dynamic Host Configuration Protocol** (**DHCP**), **DNS**, **Simple
    Network Management Protocol** (**SNMP**), **Trivial File Transfer Protocol** (**TFTP**),
    **Bootstrap Protocol** (**BOOTP**), and early versions of the **Network File System**
    (**NFS**).
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的应用程序协议基于TCP或UDP协议。基于**TCP**的协议有**HTTP**、**HTTPS**、**Telnet**、**FTP**和**SMTP**。基于**UDP**的协议有**动态主机配置协议**（**DHCP**）、**DNS**、**简单网络管理协议**（**SNMP**）、**简单文件传输协议**（**TFTP**）、**引导协议**（**BOOTP**）和**网络文件系统**（**NFS**）的早期版本。
- en: 'We can capture the difference between UDP and TCP in one sentence: the UDP
    protocol is faster and more lightweight than TCP, but less reliable. As with many
    things in life, you have to pay a higher price for additional services. However,
    not all these services will be needed in all cases, so think about the task at
    hand and decide which protocol to use based on your application requirements.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用一句话概括UDP和TCP之间的区别：UDP协议比TCP更快、更轻量，但可靠性较低。就像生活中的许多事情一样，你必须为额外的服务支付更高的代价。然而，并非所有这些服务在所有情况下都是必需的，所以考虑手头的任务，并根据应用程序需求决定使用哪种协议。
- en: URL-based communication
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于URL的通信
- en: Nowadays, it seems that everybody has some notion of a URL; those who use a
    browser on their computers or smartphones will see URLs every day. In this section,
    we will briefly explain the different parts that make up a URL and demonstrate
    how it can be used programmatically to request data from a website (or a file)
    or to send (post) data to a website.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，似乎每个人对URL都有一些概念；那些在电脑或智能手机上使用浏览器的用户会每天看到URL。在本节中，我们将简要解释构成URL的不同部分，并演示如何通过编程方式从网站（或文件）请求数据或向网站发送（发布）数据。
- en: The URL syntax
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: URL语法
- en: 'Generally speaking, the URL syntax complies with the syntax of a **Uniform
    Resource Identifier** (**URI**) that has the following format:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，URL语法符合以下格式的**统一资源标识符**（**URI**）语法：
- en: '[PRE104]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The square brackets indicate that the component is optional. This means that
    a URI will consist of `scheme:path` at the very least. The `scheme` component
    can be `http`, `https`, `ftp`, `mailto`, `file`, `data`, or another value. The
    `path` component consists of a sequence of path segments separated by a slash
    (`/`). Here is an example of a URL consisting only of `scheme` and `path`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号表示该组件是可选的。这意味着URI至少由`scheme:path`组成。`scheme`组件可以是`http`、`https`、`ftp`、`mailto`、`file`、`data`或另一个值。`path`组件由一系列由斜杠(`/`)分隔的路径段组成。以下是一个只包含`scheme`和`path`的URL示例：
- en: '[PRE105]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The preceding URL points to a file on a local filesystem that is relative to
    the directory where this URL is used. And here are examples that you are more
    familiar with: [https://www.google.com](https://www.google.com), [https://www.packtpub.com](https://www.packtpub.com).
    We will demonstrate how it works shortly.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的URL指向一个位于使用此URL的目录中的本地文件系统上的文件。以下是一些您更熟悉的例子：[https://www.google.com](https://www.google.com)，[https://www.packtpub.com](https://www.packtpub.com)。我们将很快演示它是如何工作的。
- en: 'The `path` component can be empty, but then the URL would seem useless. Nevertheless,
    an empty path is often used in conjunction with `authority`, which has the following
    format:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`path`组件可以是空的，但这样URL看起来就没什么用了。尽管如此，空路径通常与`authority`一起使用，其格式如下：'
- en: '[PRE106]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The only required component of authority is `host`, which can be either an IP
    address (`137.254.120.50`, for example) or a domain name (`oracle.com`, for example).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`authority`的唯一必需组件是`host`，它可以是IP地址（例如`137.254.120.50`）或域名（例如`oracle.com`）。'
- en: The `userinfo` component is typically used with the `mailto` value of the `scheme`
    component, so `userinfo@host` represents an email address.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`userinfo`组件通常与`scheme`组件的`mailto`值一起使用，因此`userinfo@host`代表一个电子邮件地址。'
- en: The `port` component, if omitted, assumes a default value. For example, if the
    `scheme` value is `http`, then the default `port` value is `80`, and if the `scheme`
    value is `https`, then the default `port` value is `443`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略了`port`组件，则假定默认值。例如，如果`scheme`值是`http`，则默认`port`值是`80`，如果`scheme`值是`https`，则默认`port`值是`443`。
- en: 'An optional `query` component of a URL is a sequence of key-value pairs separated
    by a delimiter (`&`):'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: URL的可选`query`组件是一系列由分隔符（`&`）分隔的键值对：
- en: '[PRE107]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Finally, the optional `fragment` component is an identifier of a section of
    an HTML document, meaning that a browser can scroll this section into view.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可选的`fragment`组件是HTML文档某部分的标识符，这意味着浏览器可以将此部分滚动到视图中。
- en: Note
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事项
- en: 'It is necessary to mention that Oracle''s online documentation uses slightly
    different terminology:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 有必要指出，Oracle的在线文档使用略微不同的术语：
- en: '`protocol` instead of `scheme`'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protocol`代替`scheme`'
- en: '`reference` instead of `fragment`'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reference`代替`fragment`'
- en: '`file` instead of `path[?query][#fragment]`'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file`代替`path[?query][#fragment]`'
- en: '`resource` instead of `host[:port]path[?query][#fragment]`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource`代替`host[:port]path[?query][#fragment]`'
- en: So, from the Oracle documentation perspective, the URL is composed of `protocol`
    and `resource` values.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，从Oracle文档的角度来看，URL由`protocol`和`resource`值组成。
- en: Let’s now take a look at the programmatic usage of URLs in Java.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看Java中URL的编程使用。
- en: The java.net.URL class
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java的`java.net.URL`类
- en: 'In Java, a URL is represented by an object of the `java.net.URL` class that
    has six constructors:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，URL由`java.net.URL`类的对象表示，该类有六个构造函数：
- en: '`URL(String spec)`: This creates a `URL` object from the URL as a string.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`URL(String spec)`: 从URL字符串创建一个`URL`对象。'
- en: '`URL(String protocol, String host, String file)`: This creates a `URL` object
    from the provided values of `protocol`, `host`, and `file` (`path` and `query`),
    and the default port number based on the `protocol` value provided.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`URL(String protocol, String host, String file)`: 从提供的`protocol`、`host`和`file`（`path`和`query`）值创建一个`URL`对象，并基于提供的`protocol`值使用默认端口号。'
- en: '`URL(String protocol, String host, int port, String path)`: This creates a
    `URL` object from the provided values of `protocol`, `host`, `port`, and `file`
    (`path` and `query`). A `port` value of `-1` indicates that the default port number
    needs to be used based on the `protocol` value provided.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`URL(String protocol, String host, int port, String path)`: 从提供的`protocol`、`host`、`port`和`file`（`path`和`query`）值创建一个`URL`对象。`port`值为`-1`表示需要根据提供的`protocol`值使用默认端口号。'
- en: '`URL(String protocol, String host, int port, String file, URLStreamHandler
    handler)`: This acts in the same way as the preceding constructor and additionally
    allows you to pass in an object of the particular protocol handler; all the preceding
    constructors load default handlers automatically.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`URL(String protocol, String host, int port, String file, URLStreamHandler
    handler)`: 这个构造函数与前面的构造函数作用相同，并且还允许您传递特定协议处理器的对象；所有前面的构造函数都会自动加载默认处理器。'
- en: '`URL(URL context, String spec)`: This creates a `URL` object that extends the
    `URL` object provided or overrides its components using the `spec` value provided,
    which is a string representation of a URL or some of its components. For example,
    if the scheme is present in both parameters, the scheme value from `spec` overrides
    the scheme value in `context` and many others.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`URL(URL context, String spec)`: 这个构造函数创建了一个`URL`对象，它扩展了提供的`URL`对象或使用提供的`spec`值覆盖其组件，其中`spec`是URL或其组件的字符串表示。例如，如果方案在两个参数中都存在，则`spec`中的方案值会覆盖`context`中的方案值以及许多其他值。'
- en: '`URL(URL context, String spec, URLStreamHandler handler)`: This acts in the
    same way as the preceding constructor and additionally allows you to pass in an
    object of the particular protocol handler.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`URL(URL context, String spec, URLStreamHandler handler)`: 这个构造函数与前面的构造函数作用相同，并且还允许您传递特定协议处理器的对象。'
- en: Once created, a `URL` object allows you to get the values of various components
    of the underlying URL. The `InputStream openStream()` method provides access to
    the stream of data received from the URL. In fact, it is implemented as `openConnection.getInputStream()`.
    The `URLConnection openConnection()` method of the `URL` class returns a `URLConnection`
    object with many methods that provide details about the connection to the URL,
    including the `getOutputStream()` method that allows you to send data to the URL.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，`URL`对象允许您获取底层URL的各个组件的值。`InputStream openStream()`方法提供了从URL接收到的数据流的访问权限。实际上，它是作为`openConnection.getInputStream()`实现的。`URL`类的`openConnection()`方法返回一个`URLConnection`对象，该对象具有许多方法，可以提供有关与URL的连接的详细信息，包括允许您向URL发送数据的`getOutputStream()`方法。
- en: 'Let’s take a look at the `UrlFileReader` code example that reads data from
    a `hello.txt` file, which is a local file that we created in [*Chapter 5*](B18388_05_ePub.xhtml#_idTextAnchor121),
    *Strings, Input/Output, and Files*. The file contains only one line: `Hello!`;
    here is the code that reads it:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下`UrlFileReader`代码示例，它从`hello.txt`文件读取数据，这是一个我们在[*第5章*](B18388_05_ePub.xhtml#_idTextAnchor121)，“字符串、输入/输出和文件”中创建的本地文件。该文件只包含一行：“Hello!”；以下是读取它的代码：
- en: '[PRE108]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: In the preceding code, we used a class loader to access the resource (`hello.txt`
    file) and construct a URL that points to it.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用类加载器访问资源（`hello.txt`文件）并构建一个指向它的URL。
- en: The rest of the preceding code is opening an input stream of data from a file
    and prints the incoming bytes as characters. The result is shown in the inline
    comment.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的代码是打开来自文件的数据输入流，并将接收到的字节作为字符打印出来。结果在内联注释中显示。
- en: 'Now, let’s demonstrate how Java code can read data from the URL that points
    to a source on the internet. Let’s call the Google search engine with the `Java`
    keyword (the `UrlSiteReader` class):'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们演示一下Java代码如何从指向互联网上源点的URL读取数据。让我们使用`Java`关键字调用Google搜索引擎（`UrlSiteReader`类）：
- en: '[PRE123]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Here, we came up with the [https://www.google.com/search?q=Java&num=10](https://www.google.com/search?q=Java&num=10)
    URL and requested the properties after some research and experimentation. There
    is no guarantee that it will always work, so do not be surprised if it does not
    return the same data we describe. Besides, it is a live search, so the result
    may change at any time. When it works, Google will return pages of data.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们经过一些研究和实验后提出了[https://www.google.com/search?q=Java&num=10](https://www.google.com/search?q=Java&num=10)
    URL，并请求了其属性。不能保证它总是有效，所以如果它没有返回我们描述的数据，请不要感到惊讶。此外，这是一个实时搜索，结果可能会随时改变。当它有效时，Google会返回包含数据的页面。
- en: The preceding code also demonstrates the difference in the values returned by
    the `getPath()` and `getFile()` methods. You can view the inline comments in the
    preceding code example.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码还演示了`getPath()`和`getFile()`方法返回值的差异。您可以在前面的代码示例中查看内联注释。
- en: 'In comparison to the example of using a file URL, the Google search example
    used the `URLConnection` object because we need to set the request header fields:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用文件URL的示例相比，Google搜索示例使用了`URLConnection`对象，因为我们需要设置请求头字段：
- en: '`Accept` tells the server what type of content the caller requests (`understands`).'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Accept` 告诉服务器调用者请求的内容类型（`理解`）。'
- en: '`Connection` tells the server that the connection will be closed after the
    response is received.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Connection` 告诉服务器在收到响应后关闭连接。'
- en: '`Accept-Language` tells the server which language the caller requests (`understands`).'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Accept-Language` 告诉服务器调用者请求的语言（`理解`）。'
- en: '`User-Agent` tells the server information about the caller; otherwise, the
    Google search engine (`www.google.com`) responds with a 403 (forbidden) HTTP code.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`User-Agent` 告诉服务器有关调用者的信息；否则，谷歌搜索引擎（`www.google.com`）会以 403（禁止）HTTP 状态码响应。'
- en: 'The remaining code in the preceding example just reads from the input stream
    of data (HTML code) coming from the URL and prints it, line by line. We captured
    the result (copied it from the screen), pasted it into the online HTML Formatter
    ([https://jsonformatter.org/html-pretty-print](https://jsonformatter.org/html-pretty-print)),
    and ran it. The result is presented in the following screenshot and this may be
    different when you run it since Google functionality is evolving over time:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例中的剩余代码只是从来自 URL 的数据（HTML 代码）输入流中读取并逐行打印。我们捕获了结果（从屏幕上复制），将其粘贴到在线 HTML 格式化工具（[https://jsonformatter.org/html-pretty-print](https://jsonformatter.org/html-pretty-print)）中，并运行它。结果在以下屏幕截图中展示，运行结果可能会有所不同，因为谷歌功能随着时间的推移而不断发展：
- en: '![](img/B18388_Figure_11.10.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_11.10.jpg)'
- en: As you can see, it looks like a typical page with the search results, except
    there is no Google image in the upper-left corner with the returned HTML.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它看起来像典型的页面，带有搜索结果，只是没有返回的 HTML 中的谷歌图片。
- en: Important Note
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Beware that if you execute this code many times, Google may block your IP address.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你多次执行此代码，谷歌可能会阻止你的 IP 地址。
- en: 'Similarly, it is possible to send (post) data to a URL. Here is an example
    code:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，可以向 URL 发送（POST）数据。以下是一个示例代码：
- en: '[PRE145]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: The preceding code expects a server running on the `localhost` server on port
    `3333` that can process the `POST` request with the `"/something"` path. If the
    server does not check the method (is it `POST` or any other HTTP method) and it
    does not check the `User-Agent` value, there is no need to specify any of it.
    So, we comment the settings out and keep them there just to demonstrate how these,
    and similar, values can be set if required.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码期望在 `localhost` 服务器上运行，端口为 `3333`，能够处理带有 `"/something"` 路径的 `POST` 请求。如果服务器没有检查方法（它是
    `POST` 还是其他 HTTP 方法）并且没有检查 `User-Agent` 值，则无需指定任何内容。因此，我们注释了这些设置，只是为了演示如果需要，这些以及类似值可以如何设置。
- en: Notice that we used the `setDoOutput()` method to indicate that output has to
    be sent; by default, it is set to `false`. Then, we let the output stream send
    the query parameters to the server.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用了 `setDoOutput()` 方法来指示必须发送输出；默认情况下，它设置为 `false`。然后，我们让输出流将查询参数发送到服务器。
- en: Another important aspect of the preceding code is that the output stream has
    to be closed before the input stream is opened. Otherwise, the content of the
    output stream will not be sent to the server. While we did it explicitly, a better
    way to do it is by using the try-with-resources block that guarantees the `close()`
    method is called, even if an exception was raised anywhere in the block.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的另一个重要方面是，在打开输入流之前必须关闭输出流。否则，输出流的内容将不会发送到服务器。虽然我们明确地这样做，但更好的方法是使用 try-with-resources
    块，该块保证即使在块中引发异常，也会调用 `close()` 方法。
- en: 'Here is a better version of the preceding example (using try-with-resources
    blocks) in the `UrlPost` class:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这是上述示例的更好版本（使用 try-with-resources 块）在 `UrlPost` 类中：
- en: '[PRE167]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: As you can see, this code calls the `localhost` server on port `3333` with the
    URI `something`, and the query parameters `parameter1=value1&parameter2=value2`.
    Then, it immediately reads the response from the server, prints it, and exits.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此代码在端口 `3333` 的 `localhost` 服务器上调用 URI `something`，并带有查询参数 `parameter1=value1&parameter2=value2`。然后，它立即读取服务器的响应，打印它，并退出。
- en: 'To demonstrate how this example works, we also created a simple server that
    listens on port `3333` of `localhost` and has a handler assigned to process all
    the requests that come with the `"/something"` path (refer to the `Server` class
    in a separate project in the `server` folder):'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个示例的工作原理，我们还创建了一个简单的服务器，该服务器监听 `localhost` 的 `3333` 端口，并分配了一个处理所有带有 `"/something"`
    路径的请求的处理程序（请参考 `server` 文件夹中单独项目中的 `Server` 类）：
- en: '[PRE189]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: To implement the server, we used the classes of the `com.sun.net.httpserver`
    package that comes with the JDK in the Java class library. It starts listening
    on port `3333` and blocks until the request comes with the `"/something"` path.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现服务器，我们使用了Java类库中随JDK提供的`com.sun.net.httpserver`包中的类。它开始监听端口`3333`，并阻塞直到带有`"/something"`路径的请求到来。
- en: 'We used the `common` library (a separate project in the `common` folder) that
    includes the `Prop` class, which provides access to the properties file in the
    `resources` folder. Please note how references to this library are included as
    the dependency in the `pom.xml` file of the `server` project:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了位于`common`文件夹中的`common`库（一个独立的项目），其中包含`Prop`类，该类提供了对`resources`文件夹中属性文件的访问。请注意，如何将此库作为依赖项包含在`server`项目的`pom.xml`文件中：
- en: '[PRE227]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: 'The `Prop` class includes two methods:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '`Prop`类包含两个方法：'
- en: '[PRE232]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: We use the `Prop` class to get the value of the `port` property from the `app.properties`
    file of the `server` project.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Prop`类从`server`项目的`app.properties`文件中获取`port`属性的值。
- en: 'The implementation of the internal `PostHandler` class in the `server` project
    demonstrates that the URL comes without parameters: we print the URI and the path.
    They both have the same `"/something"` value; the parameters come from the body
    of the request.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在`server`项目中，内部`PostHandler`类的实现展示了URL没有参数：我们打印了URI和路径。它们都有相同的`"/something"`值；参数来自请求体。
- en: 'After the request is processed, the server sends back the message *“Got it!
    Thanks.”* Let’s see how it works; we first run the server. This can be done in
    two ways:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 请求处理完毕后，服务器会发送回消息*“收到了！谢谢。”*让我们看看它是如何工作的；我们首先运行服务器。这也可以用两种方式来完成：
- en: 'Just run the `main()` method in the `Server` class using your IDE. Click any
    of the two green triangles, as shown in the following screenshot:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只需使用您的IDE在`Server`类中运行`main()`方法。点击以下截图中的任意一个绿色三角形：
- en: '![](img/B18388_Figure_11.11.jpg)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_11.11.jpg)'
- en: 'Go to the `common` folder and execute the following Maven command:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入`common`文件夹并执行以下Maven命令：
- en: '[PRE246]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE246]'
- en: 'This command compiles code in the `common` project and builds the `common-1.0-SNAPSHOT.jar`
    file in the `target` subdirectory. Now, repeat the same command in the `server`
    folder and run the following command in the `server` folder:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令在`common`项目中编译代码，并在`target`子目录中构建了`common-1.0-SNAPSHOT.jar`文件。现在，在`server`文件夹中重复相同的命令，并在`server`文件夹中运行以下命令：
- en: '[PRE247]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: As you can see, the preceding command lists on the classpath two `.jar` files
    (those we have just built) and runs the `main()` method of the `Server` class.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，前面的命令在类路径上列出了两个`.jar`文件（我们刚刚构建的），并运行了`Server`类的`main()`方法。
- en: The outcome is that the server is waiting for the client code to call it.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是服务器正在等待客户端代码调用它。
- en: 'Now, let’s execute the client (the `UrlPost` class). We can also do this in
    two ways:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们执行客户端（`UrlPost`类）。我们也可以用两种方式来做这件事：
- en: 'Just run the `main()` method in the `UrlPost` class using your IDE. Click any
    of the two green triangles, as shown in the following screenshot:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只需使用您的IDE在`UrlPost`类中运行`main()`方法。点击以下截图中的任意一个绿色三角形：
- en: '![](img/B18388_Figure_11.12.jpg)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_11.12.jpg)'
- en: 'Go to the `examples` folder and execute the following Maven command:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入`examples`文件夹并执行以下Maven命令：
- en: '[PRE248]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE248]'
- en: This command compiles code in the `examples` project and builds a `examples-1.0-SNAPSHOT.jar`
    file in the `target` subdirectory.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令在`examples`项目中编译代码，并在`target`子目录中构建了`examples-1.0-SNAPSHOT.jar`文件。
- en: 'Now, run the following command in the `examples` folder:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`examples`文件夹中运行以下命令：
- en: '[PRE249]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: 'After running the client code, observe the following output on the server-side
    screen:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 运行客户端代码后，在服务器端屏幕上观察以下输出：
- en: '![](img/B18388_Figure_11.13.jpg)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_11.13.jpg)'
- en: As you can see, the server received the parameters (or any other message for
    that matter) successfully. Now it can parse them and use them as needed.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，服务器成功接收到了参数（或者任何其他消息）。现在它可以解析它们并按需使用。
- en: 'If we look at the client-side screen, we will see the following output:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看客户端屏幕，我们会看到以下输出：
- en: '![](img/B18388_Figure_11.14.jpg)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_11.14.jpg)'
- en: This means that the client received the message from the server and exited as
    expected.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着客户端从服务器接收到了消息，并按预期退出了。
- en: Notice that the server in our example does not exit automatically and has to
    be stopped manually.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到在我们的例子中，服务器不会自动退出，必须手动停止。
- en: Other methods of the `URL` and `URLConnection` classes allow you to set/get
    other properties and can be used for more dynamic management of the client-server
    communication. There is also the `HttpUrlConnection` class (and other classes)
    in the `java.net` package that simplifies and enhances URL-based communication.
    You can read the online documentation of the `java.net` package to understand
    the available options better.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '`URL`和`URLConnection`类的其他方法允许您设置/获取其他属性，并可用于更动态地管理客户端-服务器通信。`java.net`包中还有`HttpUrlConnection`类（以及其他类），它简化并增强了基于URL的通信。您可以阅读`java.net`包的在线文档以更好地了解可用的选项。'
- en: Using the HTTP 2 Client API
  id: totrans-453
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HTTP 2客户端API
- en: The HTTP Client API was introduced with Java 9 as an incubating API in the `jdk.incubator.http`
    package. In Java 11, it was standardized and moved to the `java.net.http` package.
    It is a far richer and easier-to-use alternative to the `URLConnection` API. In
    addition to all the basic connection-related functionality, it provides non-blocking
    (asynchronous) requests and responses using `CompletableFuture` and supports both
    HTTP 1.1 and HTTP 2.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9中引入了HTTP客户端API，作为`jdk.incubator.http`包中的孵化API。在Java 11中，它被标准化并移动到`java.net.http`包。它是一个比`URLConnection`API更丰富且更易于使用的替代品。除了所有基本连接相关功能外，它还提供了使用`CompletableFuture`的非阻塞（异步）请求和响应，并支持HTTP
    1.1和HTTP 2。
- en: 'HTTP 2 added the following new capabilities to the HTTP protocol:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 2向HTTP协议添加了以下新功能：
- en: The ability to send data in a binary format rather than textual format; the
    binary format is more efficient for parsing, more compact, and less susceptible
    to various errors.
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够以二进制格式发送数据而不是文本格式；二进制格式在解析上更高效，更紧凑，且更不易受到各种错误的影响。
- en: It is fully multiplexed, thus allowing multiple requests and responses to be
    sent concurrently using just one connection.
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是完全多路复用的，因此只需使用一个连接就可以并发地发送多个请求和响应。
- en: It uses header compression, thus reducing the overhead.
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用头部压缩，从而减少了开销。
- en: It allows a server to push a response to the client’s cache if the client indicates
    that it supports HTTP 2.
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果客户端表示支持HTTP 2，它允许服务器将响应推送到客户端的缓存。
- en: 'The package contains the following classes:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 该包包含以下类：
- en: '`HttpClient`: This is used to send requests and receive responses both synchronously
    and asynchronously. An instance can be created using the static `newHttpClient()`
    method with default settings or by using the `HttpClient.Builder` class (returned
    by the static `newBuilder()` method) that allows you to customize the client configuration.
    Once created, the instance is immutable and can be used multiple times.'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpClient`：这用于同步和异步地发送请求和接收响应。可以使用具有默认设置的静态`newHttpClient()`方法或使用`HttpClient.Builder`类（由静态`newBuilder()`方法返回）创建一个实例，该类允许您自定义客户端配置。一旦创建，该实例是不可变的，并且可以被多次使用。'
- en: '`HttpRequest`: This creates and represents an HTTP request with the destination
    URI, headers, and other related information. An instance can be created using
    the `HttpRequest.Builder` class (returned by the static `newBuilder()` method).
    Once created, the instance is immutable and can be sent multiple times.'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpRequest`：这创建并代表一个带有目标URI、头部和其他相关信息的HTTP请求。可以使用`HttpRequest.Builder`类（由静态`newBuilder()`方法返回）创建一个实例。一旦创建，该实例是不可变的，并且可以被多次发送。'
- en: '`HttpRequest.BodyPublisher`: This publishes a body (for the `POST`, `PUT`,
    and `DELETE` methods) from a certain source, such as a string, a file, an input
    stream, or a byte array.'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpRequest.BodyPublisher`：它从某个来源（如字符串、文件、输入流或字节数组）发布一个体（用于`POST`、`PUT`和`DELETE`方法）。'
- en: '`HttpResponse`: This represents an HTTP response received by the client after
    an HTTP request has been sent. It contains the origin URI, headers, message body,
    and other related information. Once created, the instance can be queried multiple
    times.'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpResponse`：这代表客户端在发送HTTP请求后收到的HTTP响应。它包含原始URI、头部、消息体和其他相关信息。一旦创建，该实例可以被多次查询。'
- en: '`HttpResponse.BodyHandler`: This is a functional interface that accepts the
    response and returns an instance of `HttpResponse.BodySubscriber` that can process
    the response body.'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpResponse.BodyHandler`：这是一个函数式接口，它接受响应并返回一个`HttpResponse.BodySubscriber`实例，该实例可以处理响应体。'
- en: '`HttpResponse.BodySubscriber`: This receives the response body (its bytes)
    and transforms it into a string, a file, or a type.'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpResponse.BodySubscriber`：它接收响应体（其字节）并将其转换为字符串、文件或类型。'
- en: The `HttpRequest.BodyPublishers`, `HttpResponse.BodyHandlers`, and `HttpResponse.BodySubscribers`
    classes are factory classes that create instances of the corresponding classes.
    For example, the `BodyHandlers.ofString()` method creates a `BodyHandler` instance
    that processes the response body bytes as a string, while the `BodyHandlers.ofFile()`
    method creates a `BodyHandler` instance that saves the response body in a file.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpRequest.BodyPublishers`、`HttpResponse.BodyHandlers`和`HttpResponse.BodySubscribers`类是工厂类，用于创建相应类的实例。例如，`BodyHandlers.ofString()`方法创建一个`BodyHandler`实例，该实例将响应体字节作为字符串处理，而`BodyHandlers.ofFile()`方法创建一个`BodyHandler`实例，该实例将响应体保存到文件中。'
- en: You can read the online documentation of the `java.net.http` package to learn
    more about these and other related classes and interfaces. Next, we will take
    a look at and discuss some examples of HTTP API usage.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以阅读`java.net.http`包的在线文档，了解更多关于这些以及其他相关类和接口的信息。接下来，我们将查看并讨论一些HTTP API使用的示例。
- en: Blocking HTTP requests
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阻塞HTTP请求
- en: 'The following code is an example of a simple HTTP client that sends a `GET`
    request to an HTTP server (see the `get()` method in the `HttpClientDemo` class):'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单HTTP客户端的示例，它向HTTP服务器发送一个`GET`请求（请参阅`HttpClientDemo`类中的`get()`方法）：
- en: '[PRE250]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: 'We created a builder to configure an `HttpClient` instance. However, since
    we used default settings only, we can do it with the same result, as follows:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个构建器来配置`HttpClient`实例。然而，由于我们只使用了默认设置，我们可以用相同的结果来完成，如下所示：
- en: '[PRE265]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: 'To demonstrate the client’s functionality, we will use the same `Server` class
    that we used already. As a reminder, this is how it processes the client’s request
    and responds with `"Got it! Thanks."`:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示客户端的功能，我们将使用之前已经使用过的相同的`Server`类。提醒一下，这是它处理客户端请求并响应`"Got it! Thanks."`的方式：
- en: '[PRE266]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: 'If we launch this server and run the preceding client’s code, the server prints
    the following message on its screen:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们启动这个服务器并运行前面的客户端代码，服务器会在其屏幕上打印以下信息：
- en: '![](img/B18388_Figure_11.15.jpg)'
  id: totrans-503
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_11.15.jpg)'
- en: 'The client did not send a message because it used the HTTP `GET` method. Nevertheless,
    the server responds, and the client’s screen shows the following message:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端没有发送消息，因为它使用了HTTP的`GET`方法。尽管如此，服务器仍然响应，客户端的屏幕显示了以下信息：
- en: '![](img/B18388_Figure_11.16.jpg)'
  id: totrans-505
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_11.16.jpg)'
- en: The `send()` method of the `HttpClient` class is blocked until the response
    has come back from the server.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClient`类的`send()`方法在收到来自服务器的响应之前会阻塞。'
- en: 'Using the HTTP `POST`, `PUT`, or `DELETE` methods produces similar results;
    let’s run the following code now (see the `post()` method in the `HttpClientDemo`
    class):'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTTP的`POST`、`PUT`或`DELETE`方法会产生类似的结果；现在让我们运行以下代码（请参阅`HttpClientDemo`类中的`post()`方法）：
- en: '[PRE279]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: 'As you can see, this time the client posts the message `Hi there!` and the
    server’s screen shows the following:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这次客户端发送了消息`Hi there!`，服务器的屏幕显示了以下内容：
- en: '![](img/B18388_Figure_11.17.jpg)'
  id: totrans-524
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_11.17.jpg)'
- en: 'The `send()` method of the `HttpClient` class is blocked until the same response
    has come back from the server:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClient`类的`send()`方法在收到相同的响应后才会解除阻塞：'
- en: '![](img/B18388_Figure_11.18.jpg)'
  id: totrans-526
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_11.18.jpg)'
- en: So far, the demonstrated functionality was not much different from the URL-based
    communication that we saw in the previous section. Now we are going to use the
    `HttpClient` methods that are not available in the URL streams.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所展示的功能与我们在上一节中看到的基于URL的通信并没有太大的不同。现在我们将使用`HttpClient`方法，这些方法在URL流中是不可用的。
- en: Non-blocking (asynchronous) HTTP requests
  id: totrans-528
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非阻塞（异步）HTTP请求
- en: 'The `sendAsync()` method of the `HttpClient` class allows you to send a message
    to a server without blocking. To demonstrate how it works, we will execute the
    following code (see the `getAsync1()` method in the `HttpClientDemo` class):'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClient`类的`sendAsync()`方法允许您在不阻塞的情况下向服务器发送消息。为了演示它是如何工作的，我们将执行以下代码（请参阅`HttpClientDemo`类中的`getAsync1()`方法）：'
- en: '[PRE294]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: In comparison to the example with the `send()` method (which returns the `HttpResponse`
    object), the `sendAsync()` method returns an instance of the `CompletableFuture<HttpResponse>`
    class. If you read the documentation of the `CompletableFuture<T>` class, you
    will see that it implements the `java.util.concurrent.CompletionStage` interface,
    which provides many methods that can be chained and allows you to set various
    functions to process the response.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用`send()`方法的示例（它返回`HttpResponse`对象）相比，`sendAsync()`方法返回`CompletableFuture<HttpResponse>`类的实例。如果你阅读`CompletableFuture<T>`类的文档，你会看到它实现了`java.util.concurrent.CompletionStage`接口，该接口提供了许多可以链式调用的方法，允许你设置各种函数来处理响应。
- en: 'To give you an idea, here is the list of the methods declared in the `CompletionStage`
    interface: `acceptEither`, `acceptEitherAsync`, `acceptEitherAsync`, `applyToEither`,
    `applyToEitherAsync`, `applyToEitherAsync`, `handle`, `handleAsync`, `handleAsync`,
    `runAfterBoth`, `runAfterBothAsync`, `runAfterBothAsync`, `runAfterEither`, `runAfterEitherAsync`,
    `runAfterEitherAsync`, `thenAccept`, `thenAcceptAsync`, `thenAcceptAsync`, `thenAcceptBoth`,
    `thenAcceptBothAsync`, `thenAcceptBothAsync`, `thenApply`, `thenApplyAsync`, `thenApplyAsync`,
    `thenCombine`, `thenCombineAsync`, `thenCombineAsync`, `thenCompose`, `thenComposeAsync`,
    `thenComposeAsync`, `thenRun`, `thenRunAsync`, `thenRunAsync`, `whenComplete`,
    `whenCompleteAsync`, and `whenCompleteAsync`.'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给你一个概念，以下是`CompletionStage`接口中声明的函数列表：`acceptEither`, `acceptEitherAsync`,
    `acceptEitherAsync`, `applyToEither`, `applyToEitherAsync`, `applyToEitherAsync`,
    `handle`, `handleAsync`, `handleAsync`, `runAfterBoth`, `runAfterBothAsync`, `runAfterBothAsync`,
    `runAfterEither`, `runAfterEitherAsync`, `runAfterEitherAsync`, `thenAccept`,
    `thenAcceptAsync`, `thenAcceptAsync`, `thenAcceptBoth`, `thenAcceptBothAsync`,
    `thenAcceptBothAsync`, `thenApply`, `thenApplyAsync`, `thenApplyAsync`, `thenCombine`,
    `thenCombineAsync`, `thenCombineAsync`, `thenCompose`, `thenComposeAsync`, `thenComposeAsync`,
    `thenRun`, `thenRunAsync`, `thenRunAsync`, `whenComplete`, `whenCompleteAsync`,
    和 `whenCompleteAsync`。
- en: 'We will talk about functions and how they can be passed as parameters in [*Chapter
    13*](B18388_13_ePub.xhtml#_idTextAnchor281), *Functional Programming*. For now,
    we will just mention that the `resp -> System.out.println("Response: " + resp.statusCode()
    + " : " + resp.body())` construction represents the same functionality as the
    following method:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将在[*第13章*](B18388_13_ePub.xhtml#_idTextAnchor281)“函数式编程”中讨论函数以及它们如何作为参数传递。现在，我们只是提到`resp
    -> System.out.println("Response: " + resp.statusCode() + " : " + resp.body())`构造表示与以下方法相同的功能：'
- en: '[PRE311]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: The `thenAccept()` method applies the passed-in functionality to the result
    returned by the previous method of the chain.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '`thenAccept()` 方法将传入的功能应用于链中前一个方法返回的结果。'
- en: After the `CompletableFuture<Void>` instance is returned, the preceding code
    prints `The request was sent asynchronously...` message and blocks it on the `get()`
    method of the `CompletableFuture<Void>` object. This method has an overloaded
    version `get(long timeout, TimeUnit unit)`, with two parameters, `TimeUnit unit`
    and `long` `timeout`, which specify the number of the units, indicating how long
    the method should wait for the task that is represented by the `CompletableFuture<Void>`
    object to complete. In our case, the task is to send a message to the server and
    to get back the response (and process it using the function provided). If the
    task is not completed in the allotted time, the `get()` method is interrupted
    (and the stack trace is printed in the `catch` block).
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回`CompletableFuture<Void>`实例之后，前面的代码打印出“请求已异步发送...”消息，并在`CompletableFuture<Void>`对象的`get()`方法上阻塞它。此方法有一个重载版本`get(long
    timeout, TimeUnit unit)`，有两个参数，`TimeUnit unit`和`long timeout`，它们指定了单位的数量，表示该方法应该等待由`CompletableFuture<Void>`对象表示的任务完成多长时间。在我们的例子中，任务是向服务器发送消息并获取响应（并使用提供的函数进行处理）。如果任务在指定的时间内未完成，`get()`方法将被中断（并在`catch`块中打印堆栈跟踪）。
- en: The `Exit the client...` message should appear on the screen either in 5 seconds
    (in our case) or after the `get()` method returns.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: “退出客户端...”的消息应该在屏幕上出现，要么是5秒后（在我们的例子中），要么在`get()`方法返回之后。
- en: 'If we run the client, the server’s screen shows the following message again
    with the blocking HTTP `GET` request:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行客户端，服务器的屏幕上会再次显示以下消息，这是由于阻塞的 HTTP `GET` 请求：
- en: '![](img/B18388_Figure_11.19.jpg)'
  id: totrans-558
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_11.19.jpg)'
- en: 'The client’s screen displays the following message:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的屏幕显示以下消息：
- en: '![](img/B18388_Figure_11.20.jpg)'
  id: totrans-560
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_11.20.jpg)'
- en: As you can see, `CompletableFuture<Void>` object around and call it at any time
    to get the result. In our case, the result is `void`, so the `get()` method simply
    indicates that the task was completed.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`CompletableFuture<Void>`对象被包围，并且可以在任何时间调用它以获取结果。在我们的情况下，结果是`void`，因此`get()`方法仅表示任务已完成。
- en: 'We know that the server returns the message, and so we can take advantage of
    it by using another method of the `CompletionStage` interface. We have chosen
    the `thenApply()` method, which accepts a function that returns a value:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道服务器返回了消息，因此我们可以通过使用`CompletionStage`接口的另一个方法来利用它。我们选择了`thenApply()`方法，它接受一个返回值的函数：
- en: '[PRE315]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: 'Now, the `get()` method returns the value produced by the `resp -> "Server
    responded: " + resp.body()` function, so it should return the server message body;
    let’s run this code (see the `getAsync2()` method in the `HttpClientDemo` class)
    and see the result:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，`get()`方法返回由`resp -> "Server responded: " + resp.body()`函数产生的值，因此它应该返回服务器消息体；让我们运行此代码（请参阅`HttpClientDemo`类中的`getAsync2()`方法）并查看结果：'
- en: '![](img/B18388_Figure_11.21.jpg)'
  id: totrans-568
  prefs: []
  type: TYPE_IMG
  zh: '![图11.21](img/B18388_Figure_11.21.jpg)'
- en: Now, the `get()` method returns the server’s message as expected, and it is
    presented by the function and passed as a parameter to the `thenApply()` method.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`get()`方法按预期返回服务器的消息，并通过函数呈现，并将其作为参数传递给`thenApply()`方法。
- en: 'Similarly, we can use the HTTP `POST`, `PUT`, or `DELETE` methods for sending
    a message (see the `postAsync()` method in the `HttpClientDemo` class):'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以使用HTTP的`POST`、`PUT`或`DELETE`方法来发送消息（请参阅`HttpClientDemo`类中的`postAsync()`方法）：
- en: '[PRE319]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: '[PRE333]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: 'The only difference from the previous example is that the server now displays
    the received client’s message:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个示例的唯一区别是，现在服务器显示了接收到的客户端消息：
- en: '![](img/B18388_Figure_11.22.jpg)'
  id: totrans-588
  prefs: []
  type: TYPE_IMG
  zh: '![图11.22](img/B18388_Figure_11.22.jpg)'
- en: 'The client’s screen displays the same message as in the case of the `GET` method:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的屏幕显示与`GET`方法相同的信息：
- en: '![](img/B18388_Figure_11.23.jpg)'
  id: totrans-590
  prefs: []
  type: TYPE_IMG
  zh: '![图11.23](img/B18388_Figure_11.23.jpg)'
- en: 'The advantage of asynchronous requests is that they can be sent quickly and
    without needing to wait for each of them to complete. The HTTP 2 protocol supports
    it by multiplexing; for example, let’s send three requests as follows (see the
    `postAsyncMultiple()` method in the `HttpClientDemo` class):'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 异步请求的优点是它们可以快速发送，而且不需要等待每个请求完成。HTTP 2协议通过多路复用来支持它；例如，让我们发送三个请求如下（请参阅`HttpClientDemo`类中的`postAsyncMultiple()`方法）：
- en: '[PRE335]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '[PRE338]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[PRE341]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '[PRE346]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: '[PRE347]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '[PRE350]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[PRE351]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[PRE352]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: '[PRE359]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: 'The server’s screen shows the following messages:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的屏幕显示以下消息：
- en: '![](img/B18388_Figure_11.24.jpg)'
  id: totrans-618
  prefs: []
  type: TYPE_IMG
  zh: '![图11.24](img/B18388_Figure_11.24.jpg)'
- en: Notice the arbitrary sequence of the incoming requests; this is because the
    client uses a pool of `Executors.newCachedThreadPool()` threads to send the messages.
    Each message is sent by a different thread, and the pool has its own logic for
    using the pool members (threads). If the number of messages is large, or if each
    of them consumes a significant amount of memory, it may be beneficial to limit
    the number of threads run concurrently.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 注意传入请求的任意顺序；这是因为客户端使用`Executors.newCachedThreadPool()`线程池来发送消息。每条消息由不同的线程发送，线程池有自己的逻辑来使用池成员（线程）。如果消息数量很大，或者每条消息消耗了大量的内存，限制并发运行的线程数量可能是有益的。
- en: 'The `HttpClient.Builder` class allows you to specify the pool that is used
    for acquiring the threads that send the messages (see the `postAsyncMultipleCustomPool()`
    method in the `HttpClientDemo` class):'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClient.Builder`类允许您指定用于获取发送消息的线程的池（请参阅`HttpClientDemo`类中的`postAsyncMultipleCustomPool()`方法）：'
- en: '[PRE360]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '[PRE361]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: '[PRE366]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: '[PRE367]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: '[PRE368]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[PRE370]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[PRE371]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: '[PRE373]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[PRE374]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '[PRE377]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '[PRE379]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[PRE380]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: '[PRE381]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: '[PRE383]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[PRE384]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '[PRE385]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: If we run the preceding code, the results will be the same, but the client will
    use only two threads to send messages. The performance may be a bit slower (in
    comparison to the previous example) as the number of messages grows. So, as is
    often the case in a software system design, you need to balance the amount of
    memory used and the performance.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行前面的代码，结果将相同，但客户端将只使用两个线程来发送消息。随着消息数量的增加，性能可能会稍微慢一些（与上一个示例相比）。因此，在软件系统设计中，通常需要平衡使用的内存量和性能。
- en: Similar to the executor, several other objects can be set on the `HttpClient`
    object to configure the connection to handle authentication, request redirection,
    cookie management, and more.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 与执行器类似，可以在`HttpClient`对象上设置几个其他对象来配置连接以处理身份验证、请求重定向、Cookie管理等功能。
- en: Server push functionality
  id: totrans-649
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器推送功能
- en: 'The second (after multiplexing) significant advantage of the HTTP 2 protocol
    over HTTP 1.1 is allowing the server to push the response into the client’s cache
    if the client indicates that it supports HTTP 2\. Here is the client code that
    takes advantage of this feature (see the `push()` method in the `HttpClientDemo`
    class):'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2 协议相对于 HTTP/1.1 的第二个（在多路复用之后）显著优势是允许服务器在客户端表明它支持 HTTP/2 的情况下将响应推送到客户端的缓存。以下是利用此功能的客户端代码（请参阅
    `HttpClientDemo` 类中的 `push()` 方法）：
- en: '[PRE386]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '[PRE387]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '[PRE388]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '[PRE389]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: '[PRE391]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: '[PRE392]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: '[PRE393]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: '[PRE394]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: '[PRE395]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: '[PRE397]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '[PRE398]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: '[PRE399]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '[PRE400]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: '[PRE401]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: 'Notice the third parameter of the `sendAsync()` method. It is a function that
    handles the push response if one comes from the server. It is up to the client
    developer to decide how to implement this function; here is one possible example:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `sendAsync()` 方法的第三个参数。它是一个处理来自服务器的推送响应的函数。客户端开发者需要决定如何实现这个函数；这里有一个可能的示例：
- en: '[PRE402]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: '[PRE403]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: '[PRE404]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: '[PRE405]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '[PRE406]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: '[PRE407]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: '[PRE408]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: '[PRE409]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: '[PRE410]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: '[PRE411]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '[PRE412]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: '[PRE413]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '[PRE414]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: '[PRE415]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '[PRE416]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: This implementation of the function does not do much. It just prints out the
    URI of the push origin. But, if necessary, it can be used to receive the resources
    from the server (for example, images that support the provided HTML) without requesting
    them. This solution saves the round-trip request-response model and shortens the
    time of the page loading. It also can be used for updating the information on
    the page.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的实现并没有做太多。它只是打印出推送源 URI。但是，如果需要，它可以用来从服务器接收资源（例如，支持提供的 HTML 的图片）而无需请求它们。这种解决方案节省了往返请求-响应模型并缩短了页面加载时间。它还可以用于更新页面上的信息。
- en: You can find many code examples of a server that sends push requests; all major
    browsers support this feature too.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以找到许多发送推送请求的服务器代码示例；所有主流浏览器也支持这一功能。
- en: WebSocket support
  id: totrans-685
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebSocket 支持
- en: HTTP is based on the request-response model. A client requests a resource, and
    the server provides a response to this request. As we have demonstrated several
    times, the client initiates the communication. Without it, the server cannot send
    anything to the client. To get over this limitation, the idea was first introduced
    as a TCP connection in the HTML5 specification and, in 2008, the first version
    of the WebSocket protocol was designed.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 基于请求-响应模型。客户端请求一个资源，服务器对此请求提供响应。正如我们多次演示的那样，客户端是通信的发起者。没有它，服务器无法向客户端发送任何内容。为了克服这一限制，最初在
    HTML5 规范中引入了 TCP 连接的概念，并在 2008 年设计了 WebSocket 协议的第一版。
- en: It provides a full-duplex communication channel between the client and the server.
    After the connection is established, the server can send a message to the client
    at any time. Together with JavaScript and HTML5, the WebSocket protocol support
    allows web applications to present a far more dynamic user interface.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 它在客户端和服务器之间提供了一个全双工通信通道。连接建立后，服务器可以在任何时候向客户端发送消息。结合 JavaScript 和 HTML5，WebSocket
    协议的支持使得 Web 应用程序能够提供更加动态的用户界面。
- en: The WebSocket protocol specification defines WebSocket (`ws`) and WebSocket
    Secure (`wss`) as two schemes that are used for unencrypted and encrypted connections,
    respectively. The protocol does not support fragmentation, but allows all the
    other URI components described in the *URL syntax* section.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket 协议规范定义了 WebSocket (`ws`) 和 WebSocket Secure (`wss`) 作为两种分别用于未加密和加密连接的方案。该协议不支持分片，但允许所有在
    *URL 语法* 部分中描述的其他 URI 组件。
- en: 'All the classes that support the WebSocket protocol for a client are located
    in the `java.net` package. To create a client, we need to implement the `WebSocket.Listener`
    interface, which has the following methods:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 支持客户端 WebSocket 协议的所有类都位于 `java.net` 包中。要创建一个客户端，我们需要实现 `WebSocket.Listener`
    接口，该接口有以下方法：
- en: '`onText()`: Invoked when textual data has been received'
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onText()`: 当收到文本数据时被调用'
- en: '`onBinary()`: Invoked when binary data has been received'
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onBinary()`: 当收到二进制数据时被调用'
- en: '`onPing()`: Invoked when a ping message has been received'
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPing()`: 当收到 ping 消息时被调用'
- en: '`onPong()`: Invoked when a pong message has been received'
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPong()`: 当收到 pong 消息时被调用'
- en: '`onError()`: Invoked when an error has happened'
  id: totrans-694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onError()`: 当发生错误时被调用'
- en: '`onClose()`: Invoked when a close message has been received'
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onClose()`: 当收到关闭消息时被调用'
- en: 'All the methods of this interface are `default`. This means that you do not
    need to implement all of them, but only those that the client requires for a particular
    task (see the private `WsClient` class in the `HttpClientDemo` class):'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 该接口的所有方法都是 `default`。这意味着您不需要实现所有这些方法，而只需实现客户端为特定任务所需的方法（请参阅 `HttpClientDemo`
    类中的私有 `WsClient` 类）：
- en: '[PRE417]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: '[PRE418]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: '[PRE419]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: '[PRE420]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '[PRE421]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: '[PRE422]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: '[PRE423]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: '[PRE424]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: '[PRE425]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: '[PRE426]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: '[PRE427]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: '[PRE428]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: '[PRE429]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: '[PRE430]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: '[PRE431]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: '[PRE432]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: '[PRE433]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: '[PRE434]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: '[PRE435]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: '[PRE436]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: '[PRE437]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: '[PRE438]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: '[PRE439]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: '[PRE440]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: '[PRE441]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: '[PRE442]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: A server can be implemented in a similar way, but server implementation is beyond
    the scope of this book. To demonstrate the preceding client code, we are going
    to use a WebSocket server provided by the `echo.websocket.events` website. It
    allows a WebSocket connection and sends the received message back; such a server
    is typically called an **echo server**.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可以以类似的方式实现，但服务器实现超出了本书的范围。为了演示前面的客户端代码，我们将使用由`echo.websocket.events`网站提供的WebSocket服务器。它允许WebSocket连接并将接收到的消息发送回；这样的服务器通常被称为**回声服务器**。
- en: 'We expect that our client will send the message after the connection is established.
    Then, it will receive (the same) message from the server, display it, and send
    back another message, and so on, until it is closed. The following code invokes
    the client that we created (see the `webSocket()` method in the `HttpClientDemo`
    class):'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 我们预计我们的客户端将在建立连接后发送消息。然后，它将从服务器接收（相同的）消息，显示它，并发送另一条消息，依此类推，直到它关闭。以下代码调用了我们创建的客户端（请参阅`HttpClientDemo`类中的`webSocket()`方法）：
- en: '[PRE443]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: '[PRE444]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: '[PRE445]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: '[PRE446]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: '[PRE447]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: '[PRE448]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: '[PRE449]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: '[PRE450]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: '[PRE451]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: '[PRE452]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: '[PRE453]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: '[PRE454]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: 'The preceding code creates a `WebSocket` object using the `WebSocket.Builder`
    class. The `buildAsync()` method returns the `CompletableFuture` object. The `join()`
    method of the `CompletableFuture` class returns the result value when complete,
    or throws an exception. If an exception is not generated, then, as we mentioned
    already, the `WebSocket` communication continues until either side sends a **Close**
    message. That is why our client waits for 200 milliseconds, and then sends the
    **Close** message and exits. If we run this code, we will see the following messages:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用`WebSocket.Builder`类创建了一个`WebSocket`对象。`buildAsync()`方法返回`CompletableFuture`对象。`CompletableFuture`类的`join()`方法在完成时返回结果值，或者抛出异常。如果没有生成异常，那么，正如我们之前提到的，`WebSocket`通信将继续，直到任一方发送**关闭**消息。这就是为什么我们的客户端等待200毫秒，然后发送**关闭**消息并退出。如果我们运行此代码，我们将看到以下消息：
- en: '![](img/B18388_Figure_11.25.jpg)'
  id: totrans-738
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_11.25.jpg)'
- en: As you can see, the client behaves as expected. To finish our discussion, we
    would like to mention the fact that all modern web browsers support the WebSocket
    protocol.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，客户端表现如预期。为了完成我们的讨论，我们想提到所有现代网络浏览器都支持WebSocket协议的事实。
- en: Summary
  id: totrans-740
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you were presented with a description of the most popular
    network protocols: UDP, TCP/IP, and WebSocket. The discussion was illustrated
    with code examples using JCL. We also reviewed URL-based communication and the
    latest Java HTTP 2 Client API.'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您被介绍了一些最流行的网络协议的描述：UDP、TCP/IP和WebSocket。讨论通过使用JCL的代码示例进行了说明。我们还回顾了基于URL的通信和最新的Java
    HTTP 2客户端API。
- en: Now you can use the basic internet protocols to send/receive messages between
    client and server, and also know how to create a server as a separate project
    and how to create and use a common shared library.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用基本的互联网协议在客户端和服务器之间发送/接收消息，并且还知道如何创建一个作为独立项目的服务器，以及如何创建和使用公共共享库。
- en: The next chapter provides an overview of Java GUI technologies and demonstrates
    a GUI application using JavaFX, including code examples with control elements,
    charts, CSS, FXML, HTML, media, and various other effects. You will learn how
    to use JavaFX to create a GUI application.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章提供了Java GUI技术的概述，并演示了一个使用JavaFX的GUI应用程序，包括带有控件、图表、CSS、FXML、HTML、媒体和各种其他效果的代码示例。您将学习如何使用JavaFX创建GUI应用程序。
- en: Quiz
  id: totrans-744
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测验
- en: Name five network protocols of the application layer.
  id: totrans-745
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出应用层五个网络协议。
- en: Name two network protocols of the transport layer.
  id: totrans-746
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出两个传输层的网络协议。
- en: Which Java package includes classes that support the HTTP protocol?
  id: totrans-747
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个Java包包括支持HTTP协议的类？
- en: Which protocol is based on exchanging datagrams?
  id: totrans-748
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个协议是基于交换数据报文的？
- en: Can a datagram be sent to the IP address where there is no server running?
  id: totrans-749
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否可以向没有运行服务器的IP地址发送数据报？
- en: Which Java package contains classes that support UDP and TCP protocols?
  id: totrans-750
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个Java包包含支持UDP和TCP协议的类？
- en: What does TCP stand for?
  id: totrans-751
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TCP代表什么？
- en: What is common between the TCP and TCP/IP protocols?
  id: totrans-752
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TCP和TCP/IP协议有什么共同之处？
- en: How is a TCP session identified?
  id: totrans-753
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何识别TCP会话？
- en: Name one principal difference between the functionality of `ServerSocket` and
    `Socket`.
  id: totrans-754
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ServerSocket`和`Socket`的功能之间有一个主要区别是什么？'
- en: Which is faster, TCP or UDP?
  id: totrans-755
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TCP和UDP哪个更快？
- en: Which is more reliable, TCP or UDP?
  id: totrans-756
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TCP和UDP哪个更可靠？
- en: Name three TCP-based protocols.
  id: totrans-757
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出三个基于TCP的协议。
- en: 'Which of the following are the components of a URI? Select all that apply:'
  id: totrans-758
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些是URI的组成部分？选择所有适用的选项：
- en: Fragment
  id: totrans-759
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分节
- en: Title
  id: totrans-760
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标题
- en: Authority
  id: totrans-761
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 权限
- en: Query
  id: totrans-762
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询
- en: What is the difference between `scheme` and `protocol`?
  id: totrans-763
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`scheme`和`protocol`之间的区别是什么？'
- en: What is the difference between a URI and a URL?
  id: totrans-764
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: URI和URL之间的区别是什么？
- en: What does the following code print?
  id: totrans-765
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码会打印什么？
- en: '[PRE455]'
  id: totrans-766
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE455]'
- en: Name two new features that HTTP 2 has that HTTP 1.1 does not.
  id: totrans-767
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举HTTP 2相对于HTTP 1.1的两个新特性。
- en: What is the fully qualified name of the `HttpClient` class?
  id: totrans-768
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`HttpClient`类的完全限定名称是什么？'
- en: What is the fully qualified name of the `WebSocket` class?
  id: totrans-769
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WebSocket`类的完全限定名称是什么？'
- en: What is the difference between `HttpClient.newBuilder().build()` and `HttpClient.newHttpClient()`?
  id: totrans-770
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`HttpClient.newBuilder().build()`和`HttpClient.newHttpClient()`之间的区别是什么？'
- en: What is the fully qualified name of the `CompletableFuture` class?
  id: totrans-771
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CompletableFuture`类的完全限定名称是什么？'
