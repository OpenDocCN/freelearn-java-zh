- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Securing Jakarta EE Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护Jakarta EE应用程序
- en: Jakarta EE Security standardizes application security across all Jakarta EE-compliant
    application servers. The API includes standardized access to identity stores,
    which allow a uniform way of retrieving user credentials from a relational or
    **Lightweight Directory Access Protocol** (**LDAP**) database, as well as allowing
    us to implement access to custom identity stores. Jakarta EE Security includes
    authentication mechanism support, allowing us to authenticate a user in a standard
    way. Several authentication mechanisms are supported, such as the basic authentication
    supported by most browsers, client certificates, and HTML forms.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta EE标准化了所有Jakarta EE兼容应用程序服务器中的应用程序安全。API包括对身份存储的标准化访问，允许以统一的方式从关系型或 **轻量级目录访问协议**（**LDAP**）数据库中检索用户凭证，并允许我们实现自定义身份存储的访问。Jakarta
    EE安全包括认证机制支持，允许我们以标准方式认证用户。支持多种认证机制，例如大多数浏览器支持的基线认证、客户端证书和HTML表单。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Identity stores
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份存储
- en: Authentication mechanisms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证机制
- en: Note
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Example source code for this chapter can be found on GitHub at the following
    link: [https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch10_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch10_src).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例源代码可以在GitHub上找到，链接如下：[https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch10_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch10_src)。
- en: Identity stores
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份存储
- en: Identity stores provide access to a persistence storage system, such as a relational
    or LDAP database, where user credentials are stored. The Jakarta EE Security API
    supports relational and LDAP databases directly, and it allows us to integrate
    with custom identity stores, if necessary.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 身份存储提供了对持久存储系统的访问，例如关系型或LDAP数据库，其中存储了用户凭证。Jakarta EE安全API直接支持关系型和LDAP数据库，并且允许我们在必要时与自定义身份存储集成。
- en: Setting up an identity store stored in a relational database
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在关系型数据库中设置身份存储
- en: 'To authenticate a secured resource, such as a servlet or RESTful web service,
    against credentials stored in a relational database, annotate an application-scoped
    CDI bean with the `@DatabaseIdentityStoreDefinition` annotation, as illustrated
    in the following example:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要对存储在关系型数据库中的凭证进行认证，例如servlet或RESTful Web服务，请将具有 `@DatabaseIdentityStoreDefinition`
    注解的应用程序范围CDI bean注解，如下例所示：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In our example, the JNDI name for the JDBC connection for the relational database
    containing user credentials is `java:global/jdbc/userauthdbDatasource`, which
    is the value we provided to the `dataSourceLookup` attribute of the `@``DatabaseIdentityStoreDefinition`
    annotation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，包含用户凭证的关系型数据库的JNDI名称为 `java:global/jdbc/userauthdbDatasource`，这是我们提供给
    `@DatabaseIdentityStoreDefinition` 注解的 `dataSourceLookup` 属性的值。
- en: The `callerQuery` parameter of `@DatabaseIdentityStoreDefinition` is used to
    specify the SQL query used to retrieve the username and password for the user
    we are authenticating. The values retrieved from the database must match the values
    provided by the user (via an authentication mechanism, which we will discuss in
    the next section).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`@DatabaseIdentityStoreDefinition` 的 `callerQuery` 参数用于指定用于检索我们正在验证的用户用户名和密码的SQL查询。从数据库检索的值必须与用户提供的值（通过认证机制，我们将在下一节讨论）匹配。'
- en: Most secured applications have different types of users, separated into roles;
    for example, an application could have “regular” users plus administrators. Administrators
    would be allowed to perform certain actions that regular users would not. For
    example, administrators could be able to reset user passwords and add or remove
    users from the system. The `groupsQuery` attribute of `@DatabaseIdentityStoreDefinition`
    allows us to retrieve all roles for the user.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数受保护的应用程序都有不同类型的用户，分为不同的角色；例如，一个应用程序可以有“普通”用户和管理员。管理员将能够执行普通用户无法执行的操作。例如，管理员可以重置用户密码并从系统中添加或删除用户。`@DatabaseIdentityStoreDefinition`
    的 `groupsQuery` 属性允许我们检索用户的全部角色。
- en: Setting up an identity store stored in an LDAP database
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在LDAP数据库中设置身份存储
- en: 'To secure resources against credentials stored in an LDAP database, we need
    to annotate the resource to be secured (such as a servlet or RESTful web service)
    with the `@LdapIdentityStoreDefinition` annotation; the following example illustrates
    how to do this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护存储在LDAP数据库中的凭据，我们需要使用`@LdapIdentityStoreDefinition`注解来注解要保护的资源（如servlet或RESTful
    Web服务）；以下示例说明了如何进行此操作：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `url` attribute of `@LdapIdentityStoreDefinition` is used to specify the
    URL of the LDAP server containing user credentials for our application; its `callerBaseDn`
    attribute is used to specify the LDAP base distinguished name to verify user credentials
    supplied by the user, and, finally, its `groupSearchBase` attribute is used to
    retrieve the roles for the user.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`@LdapIdentityStoreDefinition`的`url`属性用于指定包含我们应用程序用户凭据的LDAP服务器的URL；其`callerBaseDn`属性用于指定用于验证用户提供的用户凭据的LDAP基本区分名称，最后，其`groupSearchBase`属性用于检索用户的角色。'
- en: Custom identity stores
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义标识存储
- en: In some cases, we may need to integrate our application security with an identity
    store not directly supported by the Security API. For example, we may have a requirement
    to integrate with an existing commercial security product. For such cases, the
    Jakarta EE Security API allows us to roll out our own identity store definition.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能需要将我们的应用程序安全性与Security API不直接支持的标识存储系统集成。例如，我们可能需要与现有的商业安全产品集成。对于此类情况，Jakarta
    EE安全API允许我们推出自己的标识存储定义。
- en: 'To handle custom identity stores, we need to create an application-scoped CDI
    bean (refer to [*Chapter 2*](B21231_02.xhtml#_idTextAnchor022)), and the bean
    must implement the `IdentityStore` interface, as illustrated in the following
    example:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理自定义标识存储，我们需要创建一个应用程序范围的CDI bean（参考[*第2章*](B21231_02.xhtml#_idTextAnchor022)），并且该bean必须实现`IdentityStore`接口，如下面的示例所示：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `validate()` method is defined in the `IdentityStore` interface provided
    by the security API in our example. We implement this method so that we can use
    custom validation in our application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们示例中，安全API提供的`IdentityStore`接口中定义了`validate()`方法。我们实现此方法以便在我们的应用程序中使用自定义验证。
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In our example, we are hard coding valid credentials into the code; do not do
    this for real applications as this would be a major security risk.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将有效的凭据硬编码到代码中；不要在实际应用程序中这样做，因为这会是一个重大的安全风险。
- en: The `validate()` method defined in the `IdentityStore` interface accepts an
    instance of a class implementing the `Credential` interface as its sole argument.
    In the body of our method, we cast it down to `UserNamePasswordCredential`, and
    then we invoke its `compareTo()` method, passing the expected username and password.
    If the provided credentials match either one of the expected set of credentials,
    then we allow the user to successfully log in. We do this by returning an instance
    of `CredentialValidationResult` containing the username and `Set` containing all
    the roles that the user has in our application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 定义在`IdentityStore`接口中的`validate()`方法接受一个实现`Credential`接口的类的实例作为其唯一参数。在我们的方法体中，我们将其向下转换为`UserNamePasswordCredential`，然后调用其`compareTo()`方法，传递预期的用户名和密码。如果提供的凭据与预期的任何一组凭据匹配，则允许用户成功登录。我们通过返回一个包含用户名和包含用户在我们应用程序中所有角色的`Set`的`CredentialValidationResult`实例来完成此操作。
- en: If the supplied credentials don’t match either of the expected credentials,
    then we prevent the user from logging in by returning `CredentialValidationResult.INVALID_RESULT`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供的凭据与预期的任何凭据都不匹配，那么我们通过返回`CredentialValidationResult.INVALID_RESULT`来阻止用户登录。
- en: Now that we have seen how to access user credential information via identity
    stores, we’ll focus our attention on the different authentication mechanisms provided
    by Jakarta EE.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何通过标识存储访问用户凭据信息，我们将关注Jakarta EE提供的不同认证机制。
- en: Authentication mechanisms
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证机制
- en: Authentication mechanisms provide a way for the user to provide their credentials
    so that they can be authenticated against an identity store.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 认证机制提供了一种让用户提供其凭据的方法，以便它们可以与标识存储进行认证。
- en: The Jakarta EE Security API provides support for the HTTP Basic authentication
    mechanism provided by most browsers, as well as form authentication, which is
    the most common authentication mechanism where users provide their credentials
    via an HTML form.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta EE安全API提供了对大多数浏览器提供的HTTP Basic认证机制以及表单认证的支持，后者是最常见的认证机制，其中用户通过HTML表单提供其凭据。
- en: Form authentication by default submits a form to the security servlet provided
    by the Jakarta EE implementation. If we need more flexibility or to better align
    with other Jakarta EE technologies, the Security API provides custom form authentication
    as well, which allows us as application developers to have more control over how
    to authenticate users attempting to access our application.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，表单认证会将表单提交给 Jakarta EE 实现提供的安全 servlet。如果我们需要更多的灵活性或更好地与其他 Jakarta EE
    技术对齐，安全 API 还提供了自定义表单认证，这允许我们作为应用程序开发者对尝试访问我们应用程序的用户进行认证有更多的控制。
- en: Basic authentication mechanism
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本认证机制
- en: 'A basic authentication mechanism can be achieved by annotating the resource
    as secure (i.e, a servlet or RESTful web service) with the `@``BasicAuthenticationMechanismDefinition`
    annotation:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将资源（例如 servlet 或 RESTful Web 服务）标注为安全（即使用 `@BasicAuthenticationMechanismDefinition`
    注解），可以实现基本认证机制：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We declare the user roles that are allowed to access the secured resource via
    the `@HttpConstraint` annotation, which is an attribute of the `@ServletSecurity`
    annotation. In our example, only users with the `admin` role are allowed to access
    the secured resource.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 `@HttpConstraint` 注解声明允许访问受保护资源的用户角色，该注解是 `@ServletSecurity` 注解的属性。在我们的示例中，只有具有
    `admin` 角色的用户才能访问受保护的资源。
- en: 'Using basic authentication will cause a window to pop up in the browser asking
    for a username and a password, as illustrated in *Figure 10**.1*:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基本认证将在浏览器中弹出一个窗口，要求输入用户名和密码，如图 *图 10.1* 所示：
- en: '![Figure 10.1 – Basic authentication login prompt](img/B21231_10_01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – 基本认证登录提示](img/B21231_10_01.jpg)'
- en: Figure 10.1 – Basic authentication login prompt
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 基本认证登录提示
- en: 'If the user enters the correct credentials and has the necessary role, access
    is granted to the protected resource, as shown in *Figure 10**.2*:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入了正确的凭据并且具有必要的角色，则允许访问受保护的资源，如图 *图 10.2* 所示：
- en: '![Figure 10.2 – Successful basic authentication](img/B21231_10_02.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – 成功的基本认证](img/B21231_10_02.jpg)'
- en: Figure 10.2 – Successful basic authentication
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 成功的基本认证
- en: If the user enters incorrect credentials, the login popup will show up again,
    allowing the user to re-enter their credentials.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入了错误的凭据，登录弹出窗口将再次出现，允许用户重新输入他们的凭据。
- en: If the user enters the correct credentials but does not have the appropriate
    role to access the protected resource, the server will return an HTTP 403 error
    code, indicating that the user is forbidden from accessing the protected resource.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入了正确的凭据但没有适当的角色来访问受保护的资源，服务器将返回 HTTP 403 错误代码，表示用户被禁止访问受保护的资源。
- en: Form authentication mechanism
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表单认证机制
- en: 'Another way we can authenticate our users is to develop an HTML form to collect
    the user’s credentials, and then delegate authentication to the Jakarta EE Security
    API. The first step when following this approach is to develop an HTML page containing
    a form where the user can log in to the application, as illustrated in the following
    example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过开发一个 HTML 表单来收集用户的凭据，然后将认证委托给 Jakarta EE 安全 API 来认证我们的用户。采用这种方法的第一步是开发一个包含表单的
    HTML 页面，用户可以通过该表单登录到应用程序，如下面的示例所示：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As seen in the example, the HTML form used for logging in must submit an HTTP
    POST request, and the value for its `action` attribute must be `j_security_check`.
    Now, `j_security_check` maps to a servlet provided by the Jakarta EE Security
    API. We don’t need to develop any validation logic ourselves. The form must have
    a couple of input fields, one for the username and one for the password. The names
    for these fields must be `j_username` and `j_password` respectively; the security
    servlet provided by the Jakarta EE API will retrieve these values and authenticate
    the user automatically.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例所示，用于登录的 HTML 表单必须提交 HTTP POST 请求，并且其 `action` 属性的值必须是 `j_security_check`。现在，`j_security_check`
    映射到由 Jakarta EE 安全 API 提供的 servlet。我们不需要自己开发任何验证逻辑。表单必须包含几个输入字段，一个用于用户名，一个用于密码。这些字段的名称必须分别是
    `j_username` 和 `j_password`；由 Jakarta EE API 提供的安全 servlet 将检索这些值并自动验证用户。
- en: 'Additionally, we need to provide an HTML page where the user will be redirected
    if login fails. The page can have any valid HTML markup. In our example, we simply
    provide an error message and a link to direct the user back to the login page
    so that they can try to log in again:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要提供一个HTML页面，当登录失败时用户将被重定向到该页面。该页面可以包含任何有效的HTML标记。在我们的示例中，我们只是提供了一个错误消息和一个链接，以便将用户引导回登录页面，以便他们可以再次尝试登录：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'On the server side, all we need to do is annotate the secured resource with
    the `@FormAuthenticationMechanismDefinition` annotation, which will let the Jakarta
    EE Security API know we are using form-based authentication, and what HTML pages
    to use to log in or to display when logging in fails:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，我们只需要使用`@FormAuthenticationMechanismDefinition`注解来标记受保护的资源，这将让Jakarta
    EE安全API知道我们正在使用基于表单的认证，以及用于登录或登录失败时显示的HTML页面：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `@FormAuthenticationMechanismDefinition` annotation has a required `loginToContinue`
    attribute. The value of this attribute must be an instance of the `@LoginToContinue`
    annotation. `@LoginToContinue` has two required attributes: `loginPage` and `errorPage`.
    The value of these attributes must indicate the path for the login page and the
    path of the page to display in case of authentication failure, respectively.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`@FormAuthenticationMechanismDefinition`注解有一个必需的`loginToContinue`属性。此属性的值必须是`@LoginToContinue`注解的一个实例。`@LoginToContinue`有两个必需的属性：`loginPage`和`errorPage`。这些属性的值必须分别指示登录页面的路径和认证失败时显示的页面路径。'
- en: 'After building and deploying our code, and then attempting to access a protected
    resource, the user is automatically redirected to our login page:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建和部署我们的代码后，尝试访问受保护资源时，用户将被自动重定向到我们的登录页面：
- en: '![Figure 10.3 – Form authentication mechanism](img/B21231_10_03.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 表单认证机制](img/B21231_10_03.jpg)'
- en: Figure 10.3 – Form authentication mechanism
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 表单认证机制
- en: 'If the user enters the correct credentials and has the appropriate role, then
    access to the protected resource is granted, as illustrated in *Figure 10**.4*:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入正确的凭据并且具有适当的角色，则可以访问受保护的资源，如图*图10.4*所示：
- en: '![Figure 10.4 – Successful form authentication](img/B21231_10_04.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – 表单认证成功](img/B21231_10_04.jpg)'
- en: Figure 10.4 – Successful form authentication
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 表单认证成功
- en: 'If invalid credentials are entered, then the user is directed to our custom
    error page, as shown in *Figure 10**.5*:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入了无效的凭据，则用户将被引导到我们的自定义错误页面，如图*图10.5*所示：
- en: '![Figure 10.5 – Unsuccessful form authentication](img/B21231_10_05.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 – 表单认证失败](img/B21231_10_05.jpg)'
- en: Figure 10.5 – Unsuccessful form authentication
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – 表单认证失败
- en: Custom form authentication mechanism
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义表单认证机制
- en: 'Another way we can authenticate users in our application is to use a **custom
    form authentication mechanism**. This type of authentication mechanism is useful
    when we want to integrate our application with a web framework, such as Jakarta
    Faces. In our next example, we will illustrate how to do just that: integrating
    the Jakarta EE Security API with Jakarta Faces via custom form authentication.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在应用程序中通过使用**自定义表单认证机制**来认证用户。当我们要将应用程序与Web框架（如Jakarta Faces）集成时，这种认证机制非常有用。在我们的下一个示例中，我们将展示如何做到这一点：通过自定义表单认证将Jakarta
    EE安全API与Jakarta Faces集成。
- en: 'To use custom form authentication in our applications, we need to use the aptly
    named `@CustomFormAuthenticationMechanismDefinition` annotation, as illustrated
    in the following example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的应用程序中使用自定义表单认证，我们需要使用名为`@CustomFormAuthenticationMechanismDefinition`的注解，如下例所示：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Just like `@FormAuthenticationMechanismDefinition` we saw previously, the `@CustomFormAuthenticationMechanismDefinition`
    annotation has a `loginToContinue` attribute that takes an instance of the `@LoginToContinue`
    annotation as its value. In this case, since we are integrating with Jakarta Faces,
    the value of the `loginPage` attribute of `@LoginToContinue` must point to the
    path of a Facelets page used for the user to log in. When using Jakarta Faces
    to authenticate the user, it is expected that the login page will display an error
    message if authentication fails. Therefore, we need to leave the `errorPage` attribute
    of `@``LoginToContinue` blank.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前看到的`@FormAuthenticationMechanismDefinition`一样，`@CustomFormAuthenticationMechanismDefinition`注解有一个`loginToContinue`属性，它接受一个`@LoginToContinue`注解的实例作为其值。在这种情况下，由于我们正在与Jakarta
    Faces集成，`@LoginToContinue`的`loginPage`属性值必须指向用户登录所使用的Facelets页面的路径。当使用Jakarta
    Faces进行用户认证时，预期登录页面会在认证失败时显示错误消息。因此，我们需要将`@LoginToContinue`的`errorPage`属性留空。
- en: 'Our login page is a standard Facelets page that collects user credentials and
    redirects to a CDI bean that acts as a controller:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的登录页面是一个标准的Facelets页面，用于收集用户凭据并将请求重定向到一个充当控制器的CDI bean：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Our login page has input fields for `userName` and `password`, and it stores
    those values in a CDI named bean (not shown as it is trivial) via value binding
    expressions. When the user clicks on the `loginController` CDI named bean that
    performs the actual authentication:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的登录页面有`userName`和`password`的输入字段，并且通过值绑定表达式将这些值存储在一个CDI命名bean中（未显示，因为它很 trivial）。当用户点击执行实际认证的`loginController`
    CDI命名bean时：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In our `LoginController` class, we need to inject an instance of `jakarta.security.enterprise.SecurityContext`
    since we will need it for authentication. We implement the authentication logic
    in our `login()` method. The first thing we need to do is create an instance of
    `UsernamePasswordCredential`, passing the user-entered username and password as
    parameters to its constructor.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`LoginController`类中，我们需要注入一个`jakarta.security.enterprise.SecurityContext`的实例，因为我们将在认证中使用它。我们在`login()`方法中实现认证逻辑。我们需要做的第一件事是创建一个`UsernamePasswordCredential`的实例，将用户输入的用户名和密码作为参数传递给其构造函数。
- en: We then create an instance of `jakarta.security.enterprise.authentication.mechanism.http.AuthenticationParameters`
    by invoking the static `withParams()` method on `AuthenticationParameters`, then
    invoking the `credential()` method on the resulting instance of `AuthenticationParameters`,
    and passing the instance of `UserNamePasswordCredential` we just created as a
    parameter. This returns yet another instance of `AuthenticationParameters`, which
    we can use to actually validate the user-entered credentials.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在`AuthenticationParameters`上调用静态的`withParams()`方法来创建一个`jakarta.security.enterprise.authentication.mechanism.http.AuthenticationParameters`的实例，然后在该实例上调用`credential()`方法，并将我们刚刚创建的`UserNamePasswordCredential`实例作为参数传递。这会返回另一个`AuthenticationParameters`的实例，我们可以使用它来实际验证用户输入的凭据。
- en: We validate user-entered credentials by invoking the `authenticate()` method
    on our `SecurityContext` instance, passing the HTTP `Request` and `Response` objects
    as parameters, as well as the instance of `AuthenticationParameters` containing
    the user-entered credentials. This method invocation will return an instance of
    `AuthenticationStatus`. We need to check the returned instance to determine whether
    the user entered valid credentials.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在`SecurityContext`实例上调用`authenticate()`方法来验证用户输入的凭据，将HTTP `Request`和`Response`对象作为参数传递，以及包含用户输入凭据的`AuthenticationParameters`实例。这个方法调用将返回一个`AuthenticationStatus`的实例。我们需要检查返回的实例以确定用户是否输入了有效的凭据。
- en: If `SecurityContext.authenticate()` returns `AuthenticationStatus.SEND_CONTINUE`,
    then the user-entered credentials are valid, and we can allow the user to access
    the requested resource. If instead, the method returns `AuthenticationStatus.SEND_FAILURE`,
    then the user-entered credentials are invalid, and we need to prevent the user
    from accessing the protected resource.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`SecurityContext.authenticate()`返回`AuthenticationStatus.SEND_CONTINUE`，则用户输入的凭据有效，我们可以允许用户访问请求的资源。如果该方法返回`AuthenticationStatus.SEND_FAILURE`，则用户输入的凭据无效，我们需要阻止用户访问受保护的资源。
- en: 'After deploying and running our application, when a user attempts to access
    a protected resource, he is automatically redirected to a login page, which in
    this case, since we are using custom form authentication, is implemented using
    Jakarta Faces. This is illustrated in *Figure 10**.6*:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署和运行我们的应用程序后，当用户尝试访问受保护的资源时，他们将被自动重定向到登录页面，在这种情况下，由于我们使用自定义表单认证，它是使用Jakarta
    Faces实现的。这如图*图10.6*所示：
- en: '![Figure 10.6 – Custom form authentication](img/B21231_10_06.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – 自定义表单认证](img/B21231_10_06.jpg)'
- en: Figure 10.6 – Custom form authentication
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – 自定义表单认证
- en: Entering correct credentials directs the user to the protected resource (not
    shown) while entering incorrect credentials directs the user back to the login
    page, which should show an appropriate error message as shown in *Figure 10**.7*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 输入正确的凭证将用户引导到受保护的资源（未显示），而输入错误的凭证将用户引导回登录页面，该页面应显示如图*图10.7*所示的适当错误消息。
- en: '![Figure 10.7 – Custom form authentication failure](img/B21231_10_07.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7 – 自定义表单认证失败](img/B21231_10_07.jpg)'
- en: Figure 10.7 – Custom form authentication failure
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 自定义表单认证失败
- en: It is worth noting that custom form authentication is flexible enough to integrate
    with any web application framework, although it is most commonly used with Jakarta
    Faces as discussed in this section.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，自定义表单认证足够灵活，可以与任何Web应用程序框架集成，尽管如本节所述，它最常与Jakarta Faces一起使用。
- en: Summary
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we covered the Jakarta Security API. We discussed the following
    topics in this chapter:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Jakarta Security API。本章讨论了以下主题：
- en: How to access different types of identity stores to retrieve user credentials,
    such as relational databases or LDAP databases
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何访问不同类型的身份存储以检索用户凭证，例如关系数据库或LDAP数据库
- en: How the Security API provides the ability to integrate with custom identity
    stores, in case we need to access one not directly supported, and how to use different
    authentication mechanisms to allow access to our secured Jakarta EE applications
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全API如何提供与自定义身份存储集成的能力，以防我们需要访问一个直接不支持的身份存储，以及如何使用不同的认证机制来允许访问我们的受保护Jakarta
    EE应用程序
- en: How to implement the basic authentication mechanism provided by all web browsers
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现所有Web浏览器提供的基本认证机制
- en: How to implement a form-based authentication mechanism, where we provide custom
    HTML pages used for authentication
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现基于表单的认证机制，其中我们提供用于认证的自定义HTML页面
- en: How to use custom form authentication, so that we can integrate our application
    security with a web framework such as Jakarta Faces
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用自定义表单认证，以便我们可以将我们的应用程序安全性与Web框架（如Jakarta Faces）集成
- en: Using the security features provided by Jakarta EE allows us to develop secure
    applications. The API is flexible enough to allow integration with arbitrary data
    stores, as well as any Java web application framework.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Jakarta EE提供的安全功能，我们可以开发安全的应用程序。API足够灵活，允许与任意数据存储进行集成，以及任何Java Web应用程序框架。
