- en: JDBC-Based Authentication
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JDBC基础认证
- en: 'In the previous chapter, we saw how we can extend Spring Security to utilize
    our `CalendarDao` interface and our existing domain model to authenticate users.
    In this chapter, we will see how we can use Spring Security''s built-in JDBC support.
    To keep things simple, this chapter''s sample code is based on our Spring Security
    setup from [Chapter 2](02.html), *Getting Started with Spring Security*. In this
    chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何扩展Spring Security以利用我们的`CalendarDao`接口和现有的领域模型来对用户进行身份验证。在本章中，我们将了解如何使用Spring
    Security的内置JDBC支持。为了保持简单，本章的示例代码基于我们在[第2章](02.html)，《使用Spring Security入门》中设置的Spring
    Security。在本章中，我们将涵盖以下主题：
- en: Using Spring Security's built-in JDBC-based authentication support
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Security内置的基于JDBC的认证支持
- en: Utilizing Spring Security's group-based authorization to make administering
    users easier
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用Spring Security的基于组授权来简化用户管理
- en: Learning how to use Spring Security's `UserDetailsManager` interface
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用Spring Security的`UserDetailsManager`接口
- en: Configuring Spring Security to utilize the existing `CalendarUser` schema to
    authenticate users
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Spring Security以利用现有的`CalendarUser`模式对用户进行身份验证
- en: Learning how we can secure passwords using Spring Security's new cryptography
    module
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用Spring Security的新加密模块来保护密码
- en: Using Spring Security's default JDBC authentication
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Security的默认JDBC认证
- en: If your application has not yet implemented security, or if your security infrastructure
    is using a database, Spring Security provides out-of-the-box support that can
    simplify the solving of your security needs. Spring Security provides a default
    schema for users, authorities, and groups. If that does not meet your needs, it
    allows for the querying and managing of users to be customized. In the next section,
    we are going to go through the basic steps for setting up JDBC authentication
    with Spring Security.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序尚未实现安全功能，或者你的安全基础设施正在使用一个数据库，Spring Security提供了开箱即用的支持，可以简化你安全需求的解决。Spring
    Security为用户、权限和组提供了一个默认模式。如果这还不能满足你的需求，它允许用户查询和管理被自定义。在下一节中，我们将介绍如何使用Spring Security设置JDBC认证的基本步骤。
- en: Required dependencies
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所需的依赖项
- en: Our application has already defined all the necessary dependencies required
    for this chapter. However, if you are using Spring Security's JDBC support, you
    are likely going to want the following dependencies listed in your `build.gradle`
    file. It is important to highlight that the JDBC driver that you will use will
    depend on which database you are using. Consult your database vendor's documentation
    for details on which driver is needed for your database.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序已经定义了本章所需的所有必要依赖项。然而，如果你正在使用Spring Security的JDBC支持，你可能会希望在你的`build.gradle`文件中列出以下依赖项。重要的是要强调，你将使用的JDBC驱动将取决于你正在使用的哪个数据库。请查阅你的数据库供应商的文档，了解需要为你的数据库安装哪个驱动。
- en: Remember that all the Spring versions need to match, and all Spring Security
    versions need to match (this includes transitive dependency versions). If you
    are having difficulty getting this to work in your own application, you may want
    to define the dependency management section in `build.gradle` to enforce this,
    as shown in [Chapter 2](02.html), *Getting Started with Spring Security*. As previously
    mentioned, you will not need to worry about this when using the sample code, since
    we have already set up the necessary dependencies for you.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，所有的Spring版本需要一致，所有的Spring Security版本也需要一致（这包括传递依赖版本）。如果你在自己的应用程序中遇到难以解决的问题，你可以在`build.gradle`中定义依赖管理部分来强制执行这一点，如[第2章](02.html)，《使用Spring
    Security入门》所示。如前所述，使用示例代码时，你不需要担心这个问题，因为我们已经为你设置了必要的依赖项。
- en: 'The following snippet defines the required dependencies needed for this chapter,
    including Spring Security and JDBC dependencies:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段定义了本章所需的依赖项，包括Spring Security和JDBC依赖项：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Using the H2 database
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用H2数据库
- en: The first portion of this exercise involves setting up an instance of the Java-based
    H2 relational database, populated with the Spring Security default schema. We'll
    configure H2 to run in memory using Spring's `EmbeddedDatabase` configuration
    feature-a significantly simpler method of configuration than
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的第一部分涉及设置一个基于Java的H2关系数据库实例，其中包含Spring Security的默认模式。我们将配置H2在内存中运行，使用Spring的`EmbeddedDatabase`配置特性——一种比
- en: setting up the database by hand. You can find additional information on the
    H2 website at [http://www.h2database.com/](http://www.h2database.com/).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 手动设置数据库。你可以在H2网站上的[http://www.h2database.com/](http://www.h2database.com/)找到更多信息。
- en: Keep in mind that in our sample application, we'll primarily use H2 due to its
    ease of setup. Spring Security will work with any database that supports ANSI
    SQL out of the box. We encourage you to tweak the configuration and use the database
    of your preference if you're following along with the examples. As we didn't want
    this portion of the book to focus on the complexities of database setup, we chose
    convenience over realism for the purpose of the exercises.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在我们的示例应用程序中，我们主要使用H2，因为它的设置非常简单。Spring Security可以与任何支持ANSI SQL的数据库无缝工作。如果你在跟随示例操作，我们鼓励你调整配置并使用你偏好的数据库。由于我们不想让本书的这部分内容专注于数据库设置的复杂性，因此我们选择了便利性而不是现实性作为练习的目的。
- en: Provided JDBC scripts
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供的JDBC脚本
- en: We've supplied all the SQL files that are used for creating the schema and data
    in an H2 database for this chapter in the `src/main/resources/database/h2/` folder.
    Any files prefixed with `security` are to support Spring Security's default JDBC
    implementation. Any SQL files prefixed with `calendar` are custom SQL files for
    the JBCP calendar application. Hopefully, this will make running the samples a
    little easier. If you're following along with your own database instance, you
    may have to adjust the schema definition syntax to fit your particular database.
    Additional database schemas can be found in the Spring Security reference. You
    can find a link to the Spring Security Reference in the book's Appendix, *Additional
    Reference Material*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`src/main/resources/database/h2/`目录下提供了所有用于在H2数据库中创建模式和数据的SQL文件。所有以`security`为前缀的文件是为了支持Spring
    Security的默认JDBC实现。所有以`calendar`为前缀的SQL文件是JBCP日历应用程序的定制SQL文件。希望这能稍微简化样例的运行。如果你在自己的数据库实例中跟随操作，你可能需要调整模式定义语法以适应你的特定数据库。可以在Spring
    Security参考资料中找到其他数据库模式。你可以在书的附录*附加参考资料*中找到指向Spring Security参考资料的链接。
- en: Configuring the H2 embedded database
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置H2嵌入式数据库
- en: 'To configure the H2 embedded database, we need to create a `DataSource` and
    run SQL to create the Spring Security table structure. We will need to update
    the SQL that is loaded at startup to include Spring Security''s basic schema definition,
    Spring Security user definitions, and the authority mappings for users. You can
    find the `DataSource` definition and the relevant updates in the following code
    snippet:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置H2嵌入式数据库，我们需要创建一个`DataSource`并运行SQL来创建Spring Security的表结构。我们需要更新在启动时加载的SQL，以包括Spring
    Security的基本模式定义、Spring Security用户定义以及用户权限映射。你可以在以下代码片段中找到`DataSource`定义和相关更新：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Remember that the `EmbeddedDatabaseBuilder()` method creates this database only
    in memory, so you won't see anything on the disk, and you won't be able to use
    standard tools to query it. However, you can use the H2 console that is embedded
    in the application to interact with the database. See the instructions on the
    Welcome page of our application to learn how to use it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`EmbeddedDatabaseBuilder()`方法只在内存中创建数据库，所以你不会在磁盘上看到任何东西，也无法使用标准工具来查询它。然而，你可以使用嵌入在应用程序中的H2控制台与数据库进行交互。你可以通过查看我们应用程序的欢迎页面的说明来学习如何使用它。
- en: Configuring a JDBC UserDetailsManager implementation
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置JDBC UserDetailsManager实现
- en: 'We''ll modify the `SecurityConfig.java` file to declare that we''re using a
    JDBC `UserDetailsManager` implementation, instead of the Spring Security in-memory
    `UserDetailsService` implementation that we configured in [Chapter 2](02.html),
    *Getting Started with Spring Security*. This is done with a simple change to the
    `UserDetailsManager` declaration, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改`SecurityConfig.java`文件，声明我们使用JDBC`UserDetailsManager`实现，而不是我们在第[2章](02.html)，*开始使用Spring
    Security*中配置的Spring Security内存中的`UserDetailsService`实现。这是通过简单地更改`UserDetailsManager`声明来完成的，如下所示：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We replace the previous `configure(AuthenticationManagerBuilder)` method, along
    with all of the child elements, with the `userDetailsService()` method, as shown
    in the preceding code snippet.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将替换之前的`configure(AuthenticationManagerBuilder)`方法及其所有子元素，使用如前一个代码片段所示的`userDetailsService()`方法。
- en: The default user schema of Spring Security
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认的Spring Security用户模式
- en: 'Let''s take a look at each of the SQL files used to initialize the database.
    The first script we added contains the default Spring Security schema definition
    for users and their authorities. The following script has been adapted from Spring
    Security''s Reference, which is listed in the Appendix, *Additional Reference
    Material* to have explicitly named constraints, to make troubleshooting easier:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看用于初始化数据库的每个SQL文件。我们添加的第一个脚本包含了默认的Spring Security用户及其权限的架构定义。接下来的脚本已从Spring
    Security的参考资料中改编，列在附录中的*附加参考资料*，以具有明确命名的约束，使故障排除更容易：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Defining users
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义用户
- en: 'The next script is in charge of defining the users in our application. The
    included SQL statement creates the same users that we have used throughout the
    entire book so far. The file also adds an additional user, `disabled1@example.com`,
    who will not be able to log in since we indicate the user as disabled:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个脚本是负责定义我们应用程序中的用户。包含的SQL语句创建了到目前为止在整个书中使用的相同用户。该文件还添加了一个额外的用户`disabled1@example.com`，由于我们指示用户为禁用状态，因此该用户将无法登录：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Defining user authorities
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义用户权限
- en: 'You may have noticed that there is no indication if a user is an administrator
    or a regular user. The next file specifies a direct mapping of the user to the
    corresponding authorities. If a user did not have an authority mapped to it, Spring
    Security would not allow that user to be logged in:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到没有指示用户是管理员还是普通用户。下一个文件指定了用户与相应权限的直接映射。如果一个用户没有映射到权限，Spring Security将不允许该用户登录：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After the SQL is added to the embedded database configuration, we should be
    able to start the application and log in. Try logging in with the new user using
    `disabled1@example.com` as the `username` and `disabled1` as the `password`. Notice
    that Spring Security does not allow the user to log in and provides the error
    message `Reason: User is disabled`.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '在将SQL添加到嵌入式数据库配置之后，我们应该能够启动应用程序并登录。尝试使用`disabled1@example.com`作为`username`和`disabled1`作为`password`登录新用户。注意Spring
    Security不允许用户登录并提供错误消息`Reason: User is disabled`。'
- en: 'Your code should now look like this: `calendar04.01-calendar`.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应该看起来像这样：`calendar04.01-calendar`。
- en: The UserDetailsManager interface
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`UserDetailsManager`接口'
- en: We have already leveraged the `InMemoryUserDetailsManager` class in Spring Security
    in [Chapter 3](03.html), *Custom Authentication*, to look up the current `CalendarUser`
    application in our `SpringSecurityUserContext` implementation of `UserContext`.
    This allowed us to determine which `CalendarUser` should be used when looking
    up the events for the My Events page. [Chapter 3](03.html), *Custom Authentication*,
    also demonstrated how to update the `DefaultCalendarService.java` file to utilize
    `InMemoryUserDetailsManager`, to ensure that we created a new Spring Security
    user when we created `CalendarUser`. This chapter reuses exactly the same code.
    The only difference is that the `UserDetailsManager` implementation is backed
    by the `JdbcUserDetailsManager` class of Spring Security, which uses a database
    instead of an in-memory datastore.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3章](03.html)，*自定义认证*中已经利用了Spring Security中的`InMemoryUserDetailsManager`类，在`SpringSecurityUserContext`实现的`UserContext`中查找当前的`CalendarUser`应用程序。这使我们能够确定在查找My
    Events页面的活动时应使用哪个`CalendarUser`。 [第3章](03.html)，*自定义认证*还演示了如何更新`DefaultCalendarService.java`文件以利用`InMemoryUserDetailsManager`，以确保我们创建`CalendarUser`时创建了一个新的Spring
    Security用户。本章正好重用了相同的代码。唯一的区别是`UserDetailsManager`实现由Spring Security的`JdbcUserDetailsManager`类支持，该类使用数据库而不是内存数据存储。
- en: What other features does `UserDetailsManager` provide out of the box?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserDetailsManager`还提供了哪些其他功能？'
- en: 'Although these types of functions are relatively easy to write with additional
    JDBC statements, Spring Security actually provides out-of-the-box functionality
    to support many common **create, read, update, and delete** (**CRUD**) operations
    on users in JDBC databases. This can be convenient for simple systems, and a good
    base to build on for any custom requirements that a user may have:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些功能通过额外的JDBC语句相对容易编写，但Spring Security实际上提供了开箱即用的功能，以支持许多常见的**创建、读取、更新和删除**（**CRUD**）操作，这些操作针对JDBC数据库中的用户。这对于简单的系统来说很方便，也是一个很好的基础，可以在此基础上构建用户可能有的任何自定义要求：
- en: '| **Method** | **Description** |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `void createUser(UserDetails user)` | It creates a new user with the given
    `UserDetails` information, including any declared `GrantedAuthority` authorities.
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `void createUser(UserDetails user)` | 它使用给定的`UserDetails`信息创建一个新的用户，包括任何声明的`GrantedAuthority`权威。|'
- en: '| `void updateUser(final UserDetails user)` | It updates a user with the given
    `UserDetails` information. It updates `GrantedAuthority` and removes the user
    from the user cache. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `void updateUser(final UserDetails user)` | 它使用给定的`UserDetails`信息更新用户。它更新`GrantedAuthority`并从用户缓存中移除用户。
    |'
- en: '| `void deleteUser(String username)` | It deletes the user with the given username
    and removes the user from the user cache. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `void deleteUser(String username)` | 它删除给定用户名的用户，并将用户从用户缓存中移除。 |'
- en: '| `boolean userExists(String username)` | It indicates whether or not a user
    (active or inactive) exists with the given username. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `boolean userExists(String username)` | 它表示是否具有给定用户名的活动用户或非活动用户存在。 |'
- en: '| `void changePassword(String oldPassword, String newPassword)` | It changes
    the password of the currently logged-in user. The user must then supply the correct
    password in order for the operation to succeed. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `void changePassword(String oldPassword, String newPassword)` | 它更改当前登录用户的密码。为了使操作成功，用户必须提供正确的密码。
    |'
- en: If `UserDetailsManager` does not provide all the methods that are necessary
    for your application, you can extend the interface to provide these custom requirements.
    For example, if you needed the ability to list all of the possible users in an
    administrative view, you could write your own interface with this method and provide
    an implementation that points to the same datastore as the `UserDetailsManager`
    implementation you are currently using.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`UserDetailsManager`没有为您的应用程序提供所有必要的方法，您可以扩展该接口以提供这些自定义要求。例如，如果您需要能够在管理视图中列出所有可能用户的权限，您可以编写自己的接口并实现此方法，使其指向与您当前使用的`UserDetailsManager`实现相同的存储库。
- en: Group-based access control
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于组的访问控制
- en: The `JdbcUserDetailsManager` class supports the ability to add a level of indirection
    between the users and the `GrantedAuthority` declarations by grouping `GrantedAuthority`
    into logical sets called groups.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`JdbcUserDetailsManager`类支持通过将`GrantedAuthority`分组到称为组的逻辑集合中，为用户和`GrantedAuthority`声明之间添加一个间接层的能力。'
- en: 'Users are then assigned one or more groups, and their membership confers a
    set of the `GrantedAuthority` declarations:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 用户随后被分配一个或多个组，他们的成员资格赋予了一组`GrantedAuthority`声明：
- en: '![](img/bfe04baf-36ce-4144-8e17-62bc6ac1423a.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bfe04baf-36ce-4144-8e17-62bc6ac1423a.png)'
- en: As you can see in the preceding diagram, this indirection allows the assignment
    of the same set of roles to multiple users, by simply assigning any new users
    to existing groups. This is different behavior that we've seen so far, where previously
    we assigned `GrantedAuthority` directly to individual users.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的图表中所看到的，这种间接性允许通过简单地将新用户分配到现有组中来为多个用户分配相同的角色集。这与我们迄今为止看到的行为不同，以前我们直接将`GrantedAuthority`分配给个别用户。
- en: 'This bundling of common sets of authorities can be helpful in the following
    scenarios:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这种将常见权限集打包的方法在以下场景中很有帮助：
- en: You need to segregate users into communities, with some overlapping roles between
    groups.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要将用户划分为具有组之间一些重叠角色的社区。
- en: You want to globally change the authorization for a class of user. For example,
    if you have a supplier group, you might want to enable or disable their access
    to particular portions of the application.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您想要为某一类用户全局更改授权。例如，如果您有一个供应商组，您可能想要启用或禁用他们对应用程序特定部分的使用。
- en: You have a large number of users, and you don't need user-level authority configuration.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您有很多用户，而且不需要对用户级别的授权进行配置。
- en: Unless your application has a very small user base, there is a very high likelihood
    that you'll be using group-based access control. While group-based access control
    is slightly more complex than other strategies, the flexibility and simplicity
    of managing a user's access makes this complexity worthwhile. This indirect technique
    of aggregating user privileges by group is commonly referred to as **group-based
    access control** (**GBAC**).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您的应用程序用户基数非常小，否则您很可能正在使用基于组的访问控制。虽然基于组的访问控制比其他策略稍微复杂一些，但管理用户访问的灵活性和简单性使得这种复杂性是值得的。这种通过组聚合用户权限的间接技术通常被称为**基于组的访问控制**（**GBAC**）。
- en: GBAC is an approach common to almost every secured operating system or software
    package on the market. **Microsoft** **Active Directory** (**AD**) is one of the
    most visible implementations of large-scale GBAC, due to its design of slotting
    AD users into groups and assigning privileges to those groups. Management of privileges
    in large AD-based organizations is made exponentially simpler through the use
    of GBAC.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: GBAC是市场上几乎所有受保护的操作系统或软件包中常见的做法。**微软** **活动目录**（**AD**）是基于大规模GBAC的最显著实现之一，这是因为它将AD用户分入组并分配给这些组的权限。通过使用GBAC，大型AD基础组织的权限管理变得简单得多。
- en: Try to think of the security models of the software you use-how are the users,
    groups, and privileges managed? What are the pros and cons of the way the security
    model is written?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试思考您使用的软件的安全模型-用户、组和权限是如何管理的？安全模型编写方式的优势和劣势是什么？
- en: Let's add a level of abstraction to the JBCP calendar application and apply
    the concept of group-based authorization to the site.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给JBCP日历应用程序增加一个抽象层，并将基于组的授权概念应用于该网站。
- en: Configuring group-based access control
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置基于组的访问控制
- en: 'We''ll add two groups to the application: regular users, which we''ll call
    `Users`, and administrative users, which we''ll call `Administrators`. Our existing
    accounts will be associated with the appropriate groups through an additional
    SQL script.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在应用程序中添加两个组：普通用户，我们将其称为`Users`，以及管理用户，我们将其称为`Administrators`。我们的现有账户将通过一个额外的SQL脚本与适当的组关联。
- en: Configuring JdbcUserDetailsManager to use groups
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置JdbcUserDetailsManager以使用组
- en: 'By default, Spring Security does not use GBAC. Therefore, we must instruct
    Spring Security to enable the use of groups. Modify the `SecurityConfig.java`
    file to use `GROUP_AUTHORITIES_BY_USERNAME_QUERY`, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Spring Security不使用GBAC。因此，我们必须指导Spring Security启用组的使用。修改`SecurityConfig.java`文件以使用`GROUP_AUTHORITIES_BY_USERNAME_QUERY`，如下所示：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Utilizing GBAC JDBC scripts
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GBAC JDBC脚本
- en: 'Next, we need to update the scripts that are being loaded at startup. We need
    to remove the `security-user-authorities.sql` mapping so that our users no longer
    obtain their authorities with direct mapping. We then need to add two additional
    SQL scripts. Update the `DataSource` bean configuration to load the SQL required
    for GBAC, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新在启动时加载的脚本。我们需要删除`security-user-authorities.sql`映射，以便用户不再通过直接映射来获取他们的权限。然后我们需要添加两个额外的SQL脚本。更新`DataSource`bean配置以加载GBAC所需的SQL，如下所示：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The group-based schema
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于组的模式
- en: 'It may be obvious, but the first SQL file we added contains updates to the
    schema to support group-based authorization. You can find the contents of the
    file in the following code snippet:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 可能很显然，但我们添加的第一个SQL文件包含了对模式的支持以支持基于组的授权的更新。您可以在以下代码片段中找到文件的正文：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Group authority mappings
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组权限映射
- en: 'Now we need to map our existing users to groups, and the groups to authorities.
    This is done in the `security-groups-mappings.sql` file. Mapping based on groups
    can be convenient because often, organizations already have a logical group of
    users for various reasons. By utilizing the existing groupings of users, we can
    drastically simplify our configuration. This is how a layer of indirection helps
    us. We have included the group definitions, group to authority mappings, and a
    few users in the following group mapping:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将我们的现有用户映射到组，并将组映射到权限。这在`security-groups-mappings.sql`文件中完成。基于组的映射很方便，因为通常，组织已经有了出于各种原因的逻辑用户组。通过利用现有用户分组，我们可以大大简化我们的配置。这就是间接层如何帮助我们。我们在以下组映射中包括了组定义、组到权限的映射以及几个用户：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Go ahead and start the application, and it will behave just as before; however,
    the additional layer of abstraction between the users and roles simplifies the
    managing of large groups of users.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序，它将表现得和以前一样；然而，用户和角色之间的额外抽象层简化了大量用户组的管理。
- en: Your code should now look like `calendar04.02-calendar`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应该看起来像`calendar04.02-calendar`。
- en: Support for a custom schema
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持自定义模式
- en: It's common for new users of Spring Security to begin their experience by adapting
    the JDBC user, group, or role mapping to an existing schema. Even though a legacy
    database doesn't conform to the expected Spring Security schema, we can still
    configure `JdbcDaoImpl` to map to it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 新用户在开始使用Spring Security时，通常会通过将JDBC用户、组或角色映射适应现有的模式。即使遗留数据库不符合Spring Security预期的模式，我们仍然可以配置`JdbcDaoImpl`以与之对应。
- en: We will now update Spring Security's JDBC support to use our existing `CalendarUser`
    database along with a new `calendar_authorities` table.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将更新Spring Security的JDBC支持，使其使用我们的现有`CalendarUser`数据库以及新的`calendar_authorities`表。
- en: We can easily change the configuration of `JdbcUserDetailsManager` to utilize
    this schema and override Spring Security's expected table definitions and columns,
    which we're using for the JBCP calendar application.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地更改`JdbcUserDetailsManager`的配置，以利用此架构并覆盖Spring Security期望的表定义和列，这些表定义和列是我们用于JBCP日历应用程序的。
- en: Determining the correct JDBC SQL queries
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定正确的JDBC SQL查询
- en: 'The `JdbcUserDetailsManager` class has three SQL queries that have a well-defined
    parameter and a set of returned columns. We must determine the SQL that we''ll
    assign to each of these queries, based on the intended functionality. Each SQL
    query used by `JdbcUserDetailsManager` takes the username presented at login as
    its one and only parameter:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`JdbcUserDetailsManager`类有三个SQL查询，每个查询都有明确定义的参数和返回的列集合。我们必须根据预期的功能确定我们将分配给这些查询的SQL。`JdbcUserDetailsManager`中使用的每个SQL查询都将其作为登录时呈现的用户名作为唯一参数：'
- en: '| **Namespace query attribute name** | **Description** | **Expected SQL columns**
    |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '`**命名空间查询属性名称**` | `**描述**` | `**预期的SQL列**` |'
- en: '| `users-by-username-query` | Returns one or more users matching the username;
    only the first user is used. | `Username` (`string`)`Password` (`string`)`Enabled`
    (`Boolean`) |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '`users-by-username-query` | 返回与用户名匹配的一个或多个用户；只使用第一个用户。 | `Username` (`string`)`Password`
    (`string`)`Enabled` (`Boolean`) |'
- en: '| `authorities-by-username-query` | Returns one or more granted authorities
    directly provided to the user. Typically used when GBAC is disabled. | `Username`
    (`string`)`GrantedAuthority` (`string`) |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '`authorities-by-username-query` | 直接向用户返回一个或多个授予的权限。通常在禁用GBAC时使用。 | `Username`
    (`string`)`GrantedAuthority` (`string`) |'
- en: '| `group-authorities-by-username-query` | Returns granted authorities and group
    details provided to the user through group membership. Used when GBAC is enabled.
    | `Group Primary Key` (any)`Group Name` (any)`GrantedAuthority` (string) |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '`group-authorities-by-username-query` | 返回通过组成员身份提供给用户的授予权限和组详细信息。当启用GBAC时使用。
    | `Group Primary Key` (任何)`Group Name` (任何)`GrantedAuthority` (字符串) |'
- en: Be aware that in some cases, the return columns are not used by the default
    `JdbcUserDetailsManager` implementation, but they must be returned anyway.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在某些情况下，返回的列没有被默认的`JdbcUserDetailsManager`实现使用，但它们无论如何都必须返回。
- en: Updating the SQL scripts that are loaded
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新加载的SQL脚本
- en: 'We need to initialize the `DataSource` with our custom schema, rather than
    with Spring Security''s default schema. Update the `DataSourceConfig.java` file,
    as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要初始化具有自定义架构的`DataSource`，而不是使用Spring Security的默认架构。按照以下方式更新`DataSourceConfig.java`文件：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that we have removed all of the scripts that start with security, and
    replaced them with `calendar-authorities.sql`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经移除了所有以`security`开头的脚本，并将它们替换为`calendar-authorities.sql`。
- en: The CalendarUser authority SQL
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日历用户权限SQL
- en: 'You can view the `CalendarUser` authority mappings in the following code snippet:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下代码片段中查看`CalendarUser`权限映射：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice that we use the `id` as the foreign key, which is better than utilizing
    the username as a foreign key (as Spring Security does). By using the `id` as
    the foreign key, we can allow users to easily change their username.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用`id`作为外键，这比使用用户名作为外键（如Spring Security所做的那样）要好。通过使用`id`作为外键，我们可以允许用户轻松地更改他们的用户名。
- en: Inserting custom authorities
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入自定义权限
- en: 'We need to update `DefaultCalendarService` to insert the authorities for the
    user using our custom schema when we add a new `CalendarUser` class. This is because
    while we reused the schema for the user definition, we did not define custom authorities
    in our existing application. Update `DefaultCalendarService`, as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们添加一个新的`CalendarUser`类时，我们需要更新`DefaultCalendarService`以使用我们的自定义架构为用户插入权限。这是因为虽然我们重用了用户定义的架构，但我们在现有的应用程序中没有定义自定义权限。按照以下方式更新`DefaultCalendarService`：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You may have noticed the `JdbcOperations` interface that is used for inserting
    our user. This is a convenient template provided by Spring that helps manage boilerplate
    code, such as connection and transaction handling. For more details, refer to
    the Appendix, *Additional Reference Material* of this book to find the Spring
    Reference.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能注意到了用于插入我们用户的`JdbcOperations`接口。这是Spring提供的一个方便的模板，它有助于管理诸如连接和事务处理之类的样板代码。有关详细信息，请参阅本书附录*附加参考资料*，以找到Spring参考资料。
- en: Configuring JdbcUserDetailsManager to use custom SQL queries
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置`JdbcUserDetailsManager`以使用自定义SQL查询。
- en: 'In order to use custom SQL queries for our non-standard schema, we''ll simply
    update our `userDetailsService()` method to include new queries. This is quite
    similar to how we enabled support for GBAC, except instead of using the default
    SQL, we will use our modified SQL. Notice that we remove our old `setGroupAuthoritiesByUsernameQuery()`
    method call, since we will not be using it in this example, in order to keep things
    simple:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用我们非标准架构的自定义SQL查询，我们只需更新我们的`userDetailsService()`方法以包括新的查询。这和启用GBAC支持的过程非常相似，只不过我们这次不使用默认的SQL，而是使用我们修改后的SQL。注意我们移除了我们旧的`setGroupAuthoritiesByUsernameQuery()`方法调用，因为在这个例子中我们不会使用它，以保持事情的简单性：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is the only configuration required to use Spring Security to read settings
    from an existing, non-default schema! Start up the application and ensure that
    everything is working properly.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用Spring Security从现有的非默认架构中读取设置所需的所有配置！启动应用程序并确保一切正常运行。
- en: 'Your code should now look like this: `calendar04.03-calendar`.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码现在应该看起来像这样：`calendar04.03-calendar`。
- en: Keep in mind that the utilization of an existing schema commonly requires an
    extension of `JdbcUserDetailsManager` to support the changing of passwords, the
    renaming of user accounts, and other user-management functions.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，使用现有架构通常需要扩展`JdbcUserDetailsManager`以支持密码的更改、用户账户的更名和其他用户管理功能。
- en: If you are using `JdbcUserDetailsManager` to perform user-management tasks,
    then there are over 20 SQL queries utilized by the class that are accessible through
    the configuration. However, only the three covered are available through the namespace
    configuration. Please refer to the Javadoc or source code to review the defaults
    for the queries used by `JdbcUserDetailsManager`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`JdbcUserDetailsManager`来执行用户管理任务，那么这个类中有超过20个可以通过配置访问的SQL查询。然而，只有三个是可以通过命名空间配置访问的。请参阅Javadoc或源代码，以查看`JdbcUserDetailsManager`使用的查询的默认值。
- en: Configuring secure passwords
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置安全密码。
- en: You might recall from the security audit in [Chapter 1](01.html), *Anatomy of
    an Unsafe Application*, that the security of passwords stored in cleartext was
    a top priority of the auditors. In fact, in any secured system, password security
    is a critical aspect of trust and authoritativeness of an authenticated principal.
    Designers of a fully secured system must ensure that passwords are stored in a
    way in which malicious users would have an impractically difficult time compromising
    them.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会记得，在[第1章](01.html)，《不安全应用程序的剖析》，的安全审计中，存储在明文中的密码的安全是审计员的首要任务。实际上，在任何一个安全系统中，密码的安全是验证主体信任和权威性的关键方面。一个完全安全的系统的设计者必须确保密码以恶意用户几乎不可能妥协的方式存储。
- en: 'The following general rules should be applied to passwords stored in a database:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下一般规则应适用于数据库中存储的密码：
- en: Passwords must not be stored in cleartext (plaintext)
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码不应当以明文（纯文本）形式存储。
- en: Passwords supplied by the user must be compared to the recorded passwords in
    the database
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户提供的密码必须与数据库中记录的密码进行比较。
- en: A user's password should not be supplied to the user upon demand (even if the
    user forgets it)
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不应在用户请求时（即使用户忘记了）向用户提供密码。
- en: For the purposes of most applications, the best fit for these requirements involves
    one-way encoding, known as the **hashing** of the passwords. Using a cryptographic
    hash provides properties such as security and uniqueness that are important to
    properly authenticate users, with the added bonus that once it is hashed, the
    password cannot be extracted from the value that is stored.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数应用程序来说，最适合这些要求的是单向编码，也就是密码的**哈希**。使用密码学哈希可以提供诸如安全和唯一性等重要特性，这对于正确验证用户非常重要，而且一旦哈希，密码就不能从存储的值中提取。
- en: In most secure application designs, it is neither required nor desirable to
    ever retrieve the user's actual password upon request, as providing the user's
    password to them without the proper additional credentials could present a major
    security risk. Instead, most applications provide the user the ability to reset
    their password, either by presenting additional credentials (such as their social
    security number, date of birth, tax ID, or other personal information), or through
    an email-based system.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数安全的应用设计中，当请求时既不需要也不应该检索用户的实际密码，因为在不具备适当额外凭证的情况下向用户提供其密码可能会带来重大的安全风险。相反，大多数应用会提供用户重置密码的能力，要么通过提供额外凭证（如他们的社会安全号码、出生日期、税务ID或其他个人信息），要么通过基于电子邮件的系统。
- en: Storing other types of sensitive information
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 存储其他类型的敏感信息
- en: Many of the guidelines listed that apply to passwords apply equally to other
    types of sensitive information, including social security numbers and credit card
    information (although, depending on the application, some of these may require
    the ability to decrypt). Storing this type of information to represent it in multiple
    ways, for example, a customer's full 16-digit credit card number, would be stored
    in a highly encrypted form, but the last four digits might be stored in cleartext.
    For reference, think of any internet commerce site that displays `XXXX XXXX XXXX
    1234` to help you identify your stored credit cards.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 适用于密码的大部分指南同样适用于其他类型的敏感信息，包括社会安全号码和信用卡信息（尽管根据应用程序，其中一些可能需要解密的能力）。以多种方式存储此类信息，例如，客户的完整16位信用卡号码以高度加密的形式存储，但最后四位可能以明文形式存储。作为参考，想想任何显示`XXXX
    XXXX XXXX 1234`以帮助您识别存储的信用卡的互联网商务网站。
- en: You may already be thinking ahead and wondering, given our admittedly unrealistic
    approach of using SQL to populate our H2 database with users, how do we encode
    the passwords? H2, or most other databases for that matter, don't offer encryption
    methods as built-in database functions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经在思考，鉴于我们使用SQL来为H2数据库填充用户这一显然不切实际的方法，我们是如何编码密码的？H2数据库，或者大多数其他数据库，并没有将加密方法作为内置数据库函数提供。
- en: Typically, the bootstrap process (populating a system with initial users and
    data) is handled through a combination of SQL loads and Java code. Depending on
    the complexity of your application, this process can get very complicated.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，引导过程（用初始用户和数据填充系统）是通过SQL加载和Java代码的组合来处理的。根据应用程序的复杂性，这个过程可能会变得非常复杂。
- en: For the JBCP calendar application, we'll retain the `dataSource()` bean declaration
    and `DataSource` is a name in code in the corresponding SQL, and then add some
    SQL that will modify the passwords to their hashed values.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于JBCP日历应用程序，我们将保留`dataSource()`bean声明和`DataSource`在相应的SQL中的代码名称，然后添加一些SQL，将密码更改为它们的散列值。
- en: The PasswordEncoder method
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码编码器（PasswordEncoder）方法
- en: 'Password hashing in Spring Security is encapsulated and defined by implementations
    of the `o.s.s.authentication.encoding.PasswordEncoder` interface. The simple configuration
    of a password encoder is possible through the `passwordEncoder()` method within
    the `AuthenticationManagerBuilder` element, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security中的密码散列是由`o.s.s.authentication.encoding.PasswordEncoder`接口的实现定义的。通过`AuthenticationManagerBuilder`元素中的`passwordEncoder()`方法配置密码编码器是简单的，如下所示：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You'll be happy to learn that Spring Security ships with a number of implementations
    of `passwordEncoder`, which are applicable for different needs and security requirements.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您会高兴地了解到，Spring Security随带有一系列`passwordEncoder`的实现，适用于不同的需求和安全要求。
- en: 'The following table provides a list of the out-of-the-box implementation classes
    and their benefits. Note that all implementations reside in the `o.s.s.authentication.encoding`
    package:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的表格提供了一系列内置实现类及其优点。请注意，所有实现都位于`o.s.s.authentication.encoding`包中：
- en: '| **Implementation class** | **Description** | **Hash value** |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| **实现类** | **描述** | **哈希值** |'
- en: '| --- | --- | --- |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `PlaintextPasswordEncoder` | It encodes the password as plaintext; this is
    the default. | `&lt;p>plaintext` |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `PlaintextPasswordEncoder` | 它将密码编码为明文；这是默认选项。 | `&lt;p>plaintext` |'
- en: '| `Md4PasswordEncoderPasswordEncoder` | This encoder utilizes the `MD4` hash
    algorithm. The `MD4` hash algorithm is not a secure algorithm-use of this encoder
    is not recommended. | `md4` |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `Md4PasswordEncoderPasswordEncoder` | 这个编码器使用`MD4`散列算法。`MD4`散列算法不是一个安全的算法——不建议使用这个编码器。
    | `md4` |'
- en: '| `Md5PasswordEncoderPassword` | This encoder utilizes the `MD5` one-way encoding
    algorithm. |  |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `Md5PasswordEncoderPassword` | 这个编码器使用`MD5`单向编码算法。 |  |'
- en: '| `ShaPasswordEncoderPasswordEncoder` | This encoder utilizes the `SHA` one-way
    encoding algorithm. This encoder can support configurable levels of encoding strength.
    | `sha``sha-256` |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `ShaPasswordEncoderPasswordEncoder` | 这个编码器使用`SHA`单向编码算法。此编码器可以支持可配置的编码强度级别。
    | `sha``sha-256` |'
- en: '| `LdapShaPasswordEncoder` | An implementation of `LdapSha` and `LdapSsha`
    algorithms used in integration with LDAP authentication stores. We''ll learn more
    about this algorithm in [Chapter 6](07.html), *LDAP Directory Services*, where
    we will cover LDAP. | `{sha}``{ssha}` |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `LdapShaPasswordEncoder` | 在与LDAP身份验证存储集成时使用的`LdapSha`和`LdapSsha`算法的实现。我们将在[第6章](07.html)，*LDAP目录服务*中了解更多关于这个算法，届时我们将覆盖LDAP。
    | `{sha}``{ssha}` |'
- en: As with many other areas of Spring Security, it's also possible to reference
    a bean definition by implementing `PasswordEncoder` to provide more precise configuration
    and allowing `PasswordEncoder` to be wired into other beans through the dependency
    injection. For the JBCP calendar application, we'll need to use this bean reference
    method in order to hash the passwords of the newly created users.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他Spring Security领域的许多方面一样，也可以通过实现`PasswordEncoder`来引用bean定义，以提供更精确的配置，并允许`PasswordEncoder`通过依赖注入与其他bean连接。对于JBCP日历应用程序，我们需要使用这种bean引用方法来哈希新创建用户的密码。
- en: Let's walk through the process of configuring basic password encoding for the
    JBCP calendar application.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤了解为JBCP日历应用程序配置基本密码编码的过程。
- en: Configuring password encoding
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置密码编码
- en: 'Configuring basic password encoding involves two steps: hashing the passwords
    we load into the database after the SQL script executes, and ensuring that Spring
    Security is configured to work with `PasswordEncoder`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 配置基本密码编码涉及两个步骤：在SQL脚本执行后，将加载到数据库中的密码进行哈希，并确保Spring Security配置为与`PasswordEncoder`一起工作。
- en: Configuring the PasswordEncoder method
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置PasswordEncoder方法
- en: 'First, we''ll declare an instance of `PasswordEncoder` as a normal Spring bean,
    as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将声明一个`PasswordEncoder`实例作为一个普通的Spring bean，如下所示：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You'll notice that we're using the `SHA-256` `PasswordEncoder` implementation.
    This is an efficient one-way encryption algorithm, commonly used for password
    storage.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们使用的是`SHA-256` `PasswordEncoder`实现。这是一个高效的单向加密算法，通常用于密码存储。
- en: Making Spring Security aware of the PasswordEncoder method
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使Spring Security了解PasswordEncoder方法
- en: 'We''ll need to configure Spring Security to have a reference to `PasswordEncoder`,
    so that it can encode and compare the presented password during user login. Simply
    add a `passwordEncoder` method and refer to the bean ID we defined in the previous
    step:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要配置Spring Security以引用`PasswordEncoder`，这样它可以在用户登录时对呈现的密码进行编码和比较。只需添加一个`passwordEncoder`方法，并参考我们在上一步定义的bean
    ID：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you were to try the application at this point, you'd notice that what were
    previously valid login credentials would now be rejected. This is because the
    passwords stored in the database (loaded with the `calendar-users.sql` script)
    are not stored as a `hash` that matches the password encoder. We'll need to update
    the stored passwords to be hashed values.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在此时尝试应用程序，您会发现之前有效的登录凭据现在被拒绝。这是因为存储在数据库中的密码（使用`calendar-users.sql`脚本加载）不是以与密码编码器匹配的`hash`形式存储。我们需要将存储的密码更新为哈希值。
- en: Hashing the stored passwords
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储密码的哈希
- en: 'As illustrated in the following diagram, when a user submits a password, Spring
    Security hashes the submitted password and then compares that against the unhashed
    password in the database:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下图表所示，当用户提交密码时，Spring Security哈希提交的密码，然后将其与数据库中的未哈希密码进行比较：
- en: '![](img/d954ef32-d7a9-4612-a6d5-8c6711626464.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d954ef32-d7a9-4612-a6d5-8c6711626464.png)'
- en: 'This means that users cannot log in to our application. To fix this, we will
    update the SQL that is loaded at startup time to update the passwords to be the
    hashed values. Update the `DataSourceConfig.java` file, as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着用户无法登录我们的应用程序。为了解决这个问题，我们将更新在启动时加载的SQL，以将密码更新为哈希值。如下更新`DataSourceConfig.java`文件：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `calendar-sha256.sql` file simply updates the existing passwords to their
    expected hashed values, as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`calendar-sha256.sql`文件简单地将现有密码更新为其预期的哈希值，如下所示：'
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'How did we know what value to update the password to? We have provided `o.s.s.authentication.encoding.Sha256PasswordEncoderMain`
    to demonstrate how to use the configured `PasswordEncoder` interface to hash the
    existing passwords. The relevant code is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是如何知道要更新密码的值的？我们已经提供了`o.s.s.authentication.encoding.Sha256PasswordEncoderMain`，以展示如何使用配置的`PasswordEncoder`接口来散列现有的密码。相关代码如下：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Hashing the passwords of new users
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 散列新用户的密码
- en: 'If we tried running the application and creating a new user, we would not be
    able to log in. This is because the newly-created user''s password would not be
    hashed. We need to update `DefaultCalendarService` to hash the password. Make
    the following updates to ensure that the newly-created users'' passwords are hashed:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试运行应用程序并创建一个新用户，我们将无法登录。这是因为新创建的用户的密码还没有被散列。我们需要更新`DefaultCalendarService`以散列密码。确保新创建用户的密码被散列，请进行以下更新：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Not quite secure
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不太安全
- en: Go ahead and start the application. Try creating a new user with `user1` as
    the password. Log out of the application, then use the instructions on the Welcome
    page to open the H2 console and view all of the users' passwords. Did you notice
    that the hashed values for the newly created user and `user1@example.com` are
    the same value? The fact that we have now figured out another user's password
    is a little disturbing. We will solve this with a technique known as **salting**.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序。尝试使用`user1`作为密码创建一个新用户。退出应用程序，然后按照欢迎页面的说明打开H2控制台并查看所有用户的密码。你注意到新创建用户和`user1@example.com`的散列值是相同的值吗？我们现在发现另一个用户的密码有点令人不安。我们将使用一种名为**加盐**的技术来解决这个问题。
- en: 'Your code should now look like this: `calendar04.04-calendar` .'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应该看起来像这样：`calendar04.04-calendar`。
- en: 'Would you like some salt with that password? If the security auditor were to
    examine the encoded passwords in the database, he''d find something that would
    still make him concerned about the website''s security. Let''s examine the following
    stored username and password values for a few of our users:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你想给密码加些盐吗？如果安全审计员检查数据库中编码的密码，他会发现一些仍然让他担心网站安全的东西。让我们检查以下几个用户的存储用户名和密码值：
- en: '| **Username** | **Plaintext password** | **Hashed password** |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| **用户名** | **明文密码** | **散列密码** |'
- en: '| `admin1@example.com` | `admin1` | `25f43b1486ad95a1398e3eeb3d83bc4010015fcc9bed
    b35b432e00298d5021f7` |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `admin1@example.com` | `admin1` | `25f43b1486ad95a1398e3eeb3d83bc4010015fcc9bed
    b35b432e00298d5021f7` |'
- en: '| `user1@example.com` | `user1` | `0a041b9462caa4a31bac3567e0b6e6fd9100787db2ab
    433d96f6d178cabfce90` |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `user1@example.com` | `user1` | `0a041b9462caa4a31bac3567e0b6e6fd9100787db2ab
    433d96f6d178cabfce90` |'
- en: This looks very secure-the encrypted passwords obviously bear no resemblance
    to the original passwords. What could the auditor be concerned about? What if
    we add a new user who happens to have the same password as our `user1@example.com`
    user?
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来非常安全——加密后的密码显然与原始密码没有任何相似之处。审计员会担心什么？如果我们添加一个新用户，而这个新用户的密码恰好与我们的`user1@example.com`用户相同呢？
- en: '| **Username** | **Plaintext password** | **Hashed password** |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| **用户名** | **明文密码** | **散列密码** |'
- en: '| `hacker@example.com` | `user1` | `0a041b9462caa4a31bac3567e0b6e6fd9100787d
    b2ab433d96f6d178cabfce90` |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `hacker@example.com` | `user1` | `0a041b9462caa4a31bac3567e0b6e6fd9100787d
    b2ab433d96f6d178cabfce90` |'
- en: Now, note that the encrypted password of the `hacker@example.com` user is exactly
    the same as the real user! Thus, a hacker who had somehow gained the ability to
    read the encrypted passwords in the database could compare their known password's
    encrypted representation with the unknown one for the user account, and see they
    are the same! If the hacker had access to an automated tool to perform this analysis,
    they could likely compromise the user's account within a matter of hours.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请注意`hacker@example.com`用户的加密密码与真实用户完全相同！因此，如果黑客以某种方式获得了读取数据库中加密密码的能力，他们可以将自己的已知密码的加密表示与用户账户的未知密码进行比较，看它们是否相同！如果黑客有权访问执行此分析的自动化工具，他们可能在几小时内就能威胁到用户的账户。
- en: While it is difficult to guess a single password, hackers can calculate all
    the hashes ahead of time and store a mapping of the hash to the original password.
    Then, figuring out the original password is a matter of looking up the password
    by its hashed value in constant time. This is a hacking technique known as **rainbow
    tables**.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然猜测一个密码很困难，但黑客可以提前计算出所有的散列值并将散列值与原始密码的映射存储起来。然后，通过查找散列值来确定原始密码，只需常数时间即可。这是一种名为**彩虹表**的黑客技术。
- en: One common and effective method of adding another layer of security to encrypted
    passwords is to incorporate a **salt**. A salt is a second plaintext component,
    which is concatenated with the plaintext password prior to performing the hash,
    in order to ensure that two factors must be used to generate (and thus compare)
    the hashed password values. Properly selected salts can guarantee that no two
    passwords will ever have the same hashed value, thus preventing the scenario that
    concerned our auditor, and avoiding many common types of brute force password
    cracking techniques.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 向加密密码中添加另一层安全性的一个常见且有效的方法是使用**盐值**。盐值是一个第二个明文组件，它在与明文密码连接后进行哈希之前，以确保必须使用两个因素来生成（从而比较）哈希密码值。适当选择的盐值可以保证没有任何两个密码会有相同的哈希值，从而防止了我们审计员所担忧的情况，并避免了多种常见的暴力破解密码技术。
- en: 'Best practice salts generally fall into one of the following three categories:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践的盐值通常属于以下三个类别之一：
- en: They are algorithmically generated from some pieces of data associated with
    the user, for example, the timestamp that the user created
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是从与用户相关的某些数据算法生成的，例如用户创建的时间戳
- en: They are randomly generated and stored in some form
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是随机生成的并以某种形式存储
- en: They are plaintext or two-way encrypted along with the user's password record
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们与用户密码记录一起明文或双向加密
- en: Remember that because the `salt` is added to the plaintext password, it can't
    be one-way encrypted-the application needs to be able to look up or derive the
    appropriate `salt` value for a given user's record in order to calculate the `hash`
    of the password, and to compare it with the stored `hash` of the user when performing
    authentication.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，因为`salt`添加到明文密码中，所以它不能单向加密——应用程序需要能够查找或推导出给定用户记录的适当`salt`值，以便计算密码的`hash`，并与进行身份验证时存储的用户`hash`进行比较。
- en: Using salt in Spring Security
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Spring Security中使用盐值
- en: 'Spring Security 3.1 provides a new cryptography module that is included in
    the `spring-security-core` module and is available separately in `spring-security-crypto`.
    The `crypto` module contains its own `o.s.s.crypto.password.PasswordEncoder` interface.
    In fact, using this interface is the preferred method for encoding passwords,
    because it will salt passwords using a random `salt`. At the time of this writing,
    there are the following three implementations of `o.s.s.crypto.password.PasswordEncoder`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 3.1提供了一个新的加密模块，该模块包含在`spring-security-core`模块中，也可以在`spring-security-crypto`中单独使用。`crypto`模块包含自己的`o.s.s.crypto.password.PasswordEncoder`接口。实际上，使用这个接口是编码密码的首选方法，因为它会使用随机的`salt`来加密密码。在撰写本文时，有以下三个实现`o.s.s.crypto.password.PasswordEncoder`：
- en: '| **Class** | **Description** |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| **类** | **描述** |'
- en: '| `o.s.s.crypto.bcrypt.BCryptPasswordEncoder` | This class uses the `bcrypt`
    hashing function. It supports `salt` and the ability to slow down to perform over
    time as technology improves. This helps protect against brute-force search attacks.
    |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `o.s.s.crypto.bcrypt.BCryptPasswordEncoder` | 这个类使用`bcrypt`哈希函数。它支持盐值和随时间推移减慢速度的能力，随着技术的改进。这有助于保护免受暴力搜索攻击。
    |'
- en: '| `o.s.s.crypto.password.NoOpPasswordEncoder` | This class does no encoding
    (it returns the password in its plaintext form). |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `o.s.s.crypto.password.NoOpPasswordEncoder` | 这个类不进行编码（它以明文形式返回密码）。 |'
- en: '| `o.s.s.crypto.password.StandardPasswordEncoder` | This class uses `SHA-256`
    with multiple iterations and a random `salt` value. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `o.s.s.crypto.password.StandardPasswordEncoder` | 这个类使用多次迭代和随机盐值的`SHA-256`。
    |'
- en: For those who are familiar with Spring Security 3.0, `salt` used to be provided
    using `o.s.s.authentication.dao.SaltSource`. While still supported, this mechanism
    is not demonstrated in this book, since it is not the preferred mechanism for
    providing `salt`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 对那些熟悉Spring Security 3.0的人来说，`salt`曾经是通过`o.s.s.authentication.dao.SaltSource`提供的。尽管仍然支持，但本书不演示这种机制，因为它不是提供`salt`的首选机制。
- en: Updating the Spring Security configuration
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新Spring Security配置
- en: 'This can be done by updating the Spring Security configuration. Remove the
    old `ShaPasswordEncoder` encoder and add the new `StandardPasswordEncoder` encoder,
    as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过更新Spring Security配置来实现。删除旧的`ShaPasswordEncoder`编码器，并添加新的`StandardPasswordEncoder`编码器，如下所示：
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Migrating existing passwords
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移现有密码
- en: 'Let''s take a look at the following steps and learn about migrating existing
    passwords:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看以下步骤，了解迁移现有密码：
- en: 'We need to update our existing passwords to use the values produced by the
    new `PasswordEncoder` class. If you would like to generate your own passwords,
    you can use the following code snippet:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要更新我们现有的密码，使其使用新`PasswordEncoder`类产生的值。如果您想生成自己的密码，可以使用以下代码片段：
- en: '[PRE24]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Remove the previously used `calendar-sha256.sql` file, and add the provided
    `saltedsha256.sql` file as follows:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除之前使用的`calendar-sha256.sql`文件，并按照以下方式添加提供的`saltedsha256.sql`文件：
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Updating DefaultCalendarUserService
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新DefaultCalendarUserService
- en: 'The `passwordEncoder()` method we defined previously is smart enough to handle
    the new password encoder interface. However, `DefaultCalendarUserService` needs
    to update to the new interface. Make the following updates to the `DefaultCalendarUserService`
    class:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前定义的`passwordEncoder()`方法足够智能，可以处理新的密码编码器接口。然而，`DefaultCalendarUserService`需要更新到新的接口。对`DefaultCalendarUserService`类进行以下更新：
- en: '[PRE26]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Trying out the salted passwords
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试使用加盐密码
- en: Start up the application and try creating another user with the password `user1`.
    Use the H2 console to compare the new user's password, and observe that they are
    different.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序，尝试使用密码`user1`创建另一个用户。使用H2控制台比较新用户的密码，并观察它们是不同的。
- en: 'Your code should now look like this: `calendar04.05-calendar`.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应该看起来像这样：`calendar04.05-calendar`。
- en: 'Spring Security now generates a random `salt` and combines this with the password
    before hashing our password. It then adds the random `salt` to the beginning of
    the password in plaintext, so that passwords can be checked. The stored password
    can be summarized as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Spring Security会生成一个随机的`salt`，然后将其与密码结合后再进行哈希处理。接着，它将这个随机的`salt`添加到明文密码的前面，以便进行密码校验。存储的密码可以总结如下：
- en: '[PRE27]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is the pseudocode for hashing a newly created password.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对新创建密码进行哈希处理的伪代码。
- en: 'To authenticate a user, `salt` and `hash` can be extracted from the stored
    password, since both `salt` and `hash` are fixed lengths. Then, the extracted
    `hash` can be compared against a new `hash`, computed with extracted `salt` and
    the inputted password:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证用户，可以从存储的密码中提取`salt`和`hash`，因为`salt`和`hash`都是固定长度的。然后，可以将提取的`hash`与新的`hash`进行比较，新的`hash`是通过提取的`salt`和输入的密码计算得出的：
- en: '![](img/f5227c6d-faf2-4bff-8767-c5134963bee1.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f5227c6d-faf2-4bff-8767-c5134963bee1.png)'
- en: 'The following is the pseudocode for validating a salted password:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对加盐密码进行验证的伪代码：
- en: '[PRE28]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to use Spring Security's built-in JDBC support.
    Specifically, we have learned that Spring Security provides a default schema for
    new applications. We also explored how to implement GBAC and how it can make managing
    users easier.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用Spring Security内置的JDBC支持。具体来说，我们了解到Spring Security为新的应用程序提供了一个默认模式。我们还探索了如何实现GBAC，以及它如何使用户管理变得更容易。
- en: We also learned how to integrate Spring Security's JDBC support with an existing
    database and also how to secure our passwords by hashing them and using a randomly-generated
    salt.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学会了如何将Spring Security的JDBC支持与现有的数据库集成，以及如何通过哈希处理和使用随机生成的`salt`来保护我们的密码。
- en: In the next chapter, we will explore the **Spring Data** project and how to
    configure Spring Security to use **object-relational mapping** (**ORM**) to connect
    to an RDBMS, as well as a document database.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨**Spring Data**项目以及如何配置Spring Security使用**对象关系映射**（**ORM**）来连接RDBMS，以及文档数据库。
