- en: Functions and Lambdas
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数与Lambda表达式
- en: The paradigm of functional programming has a lot of common features with the
    paradigm of declarative programming. One of the defining features of functional
    languages and declarative programming is the extensive use of functions. This
    chapter will discuss in more detail what functions are and their meaning in different
    paradigms. We will have a look at how we can use functions and what their role
    is in modern programming languages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程范式与声明式编程范式有很多共同特征。函数式语言和声明式编程的一个定义特征是广泛使用函数。本章将更详细地讨论函数是什么以及它们在不同范式中的意义。我们将探讨如何使用函数以及它们在现代编程语言中的角色。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Functions as behaviors
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数作为行为
- en: Functions in functional programming
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程中的函数
- en: Higher-order functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶函数
- en: Lambdas
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda表达式
- en: The concept of functions in different programming languages
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同编程语言中函数的概念
- en: Functions as behavior
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作为行为
- en: So what are functions? We can define them as **parameterized**, named chunks
    of code. This means that they are chunks of code that can be called from any other
    part of the program by their name. Parameterized means that you can call them
    with certain arguments. Different calls executed with different parameters usually
    lead to different results.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是函数？我们可以将它们定义为**参数化**、命名的代码块。这意味着它们是可以从程序的任何其他部分通过其名称调用的代码块。参数化意味着你可以用某些参数来调用它们。使用不同参数执行的不同调用通常会导致不同的结果。
- en: What is the motivation behind functions? The answer is the basic principle of
    engineering – abstract away that which repeats itself. In [Chapter 1](485603d0-9f5e-4644-bd73-c46a8a317448.xhtml),
    The *Declarative Programming Style*, we saw something similar in the case of loops.
    However, loops are built-in control structures. This means they are defined at
    the language level. When we need to define some logic on the language-user level,
    and this logic repeats itself across different parts of the project, functions
    come into play.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 函数背后的动机是什么？答案是工程的基本原则——抽象出重复的部分。在[第1章](485603d0-9f5e-4644-bd73-c46a8a317448.xhtml)《声明式编程风格》中，我们看到了循环中的类似情况。然而，循环是内置的控制结构。这意味着它们在语言级别上定义。当我们需要在语言用户级别上定义某些逻辑，并且这种逻辑在项目的不同部分中重复时，函数就派上用场了。
- en: We can trace functions across paradigms to as early as procedural programming.
    In procedural programming, functions are one of the units of abstraction. This
    means that functions encapsulate the logic that repeats. In object-oriented programming,
    we have an evolution of the understanding of functions. Functions are usually
    viewed in the context of an object or a class. In this context, they play the
    role of the behavior of an object.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将函数的概念追溯到过程式编程。在过程式编程中，函数是抽象的一个单元。这意味着函数封装了重复的逻辑。在面向对象编程中，我们对函数的理解有所发展。函数通常在对象或类的上下文中被看待。在这种情况下，它们扮演着对象行为的作用。
- en: For example, if you have an object called a soda machine, this object may have
    certain behaviors associated with it, such as inserting a coin into the machine,
    or pressing the button to get a can of soda from the machine.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你有一个名为汽水机的对象，这个对象可能与其关联某些行为，例如将硬币投入机器，或者按按钮从机器中获取一听汽水。
- en: Functions in functional programming
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程中的函数
- en: In imperative programming, functions are used to represent the behavior of an
    object. In object-oriented programming, the behavior usually implies side effects.
    For the purposes of this book, we can understand side effects as follows—a function
    is side-effecting when it modifies the environment outside its own body. For example,
    it can have a global variable of its parent object modified, it can write a file
    into the filesystem, or the function can perform some web API calls over the network.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式编程中，函数用于表示对象的行为。在面向对象编程中，行为通常意味着副作用。为了本书的目的，我们可以将副作用理解为以下内容——当一个函数修改其自身主体之外的环境时，它就是有副作用的。例如，它可以修改其父对象的全局变量，它可以向文件系统写入文件，或者函数可以在网络上执行某些Web
    API调用。
- en: In functional programming, the understanding of functions is quite different.
    In functional programming, we prise purity and referential transparency. Purity
    means the absence of side effects. Referential transparency means that the result
    value the function has computed can be substituted in place of the function call,
    while the semantics of the program execution will remain unchanged.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，对函数的理解相当不同。在函数式编程中，我们重视纯净性和引用透明性。纯净性意味着没有副作用。引用透明性意味着函数计算出的结果值可以替换函数调用，而程序执行的语义将保持不变。
- en: 'Consider the following example. You have an application that simulates a soda
    machine. Its behavior is that of the insertion of the coin into the soda machine
    and getting a soda can back from it. A soda machine consists of the data: the
    amount of money and soda cans present in the machine. Whenever a coin is inserted,
    a soda can will be sold.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例。你有一个模拟饮料机的应用程序。它的行为是将硬币插入饮料机并从饮料机中取回饮料罐。饮料机由数据组成：机器中存在的钱和饮料罐的数量。每次插入硬币时，就会卖出一个饮料罐。
- en: How do we express this behavior in an imperative style? We can create a separate
    object called a soda machine and, in that object, a method to dispatch cans. Whenever
    this method is called, the number of coins present in it is increased by one and
    the number of soda cans decreases by one. Also, we want to return an object called
    `SodaCan` from the method.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何以命令式风格表达这种行为？我们可以创建一个单独的对象，称为饮料机，并在该对象中创建一个分发罐子的方法。每当这个方法被调用时，其中的硬币数量就会增加一个，而饮料罐的数量就会减少一个。此外，我们还想从该方法返回一个名为`SodaCan`的对象。
- en: 'In the spirit of object-oriented programming, we can represent the soda machine
    as an object with some internal state:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程的精神下，我们可以将饮料机表示为一个具有一些内部状态的对象：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can also define some behavior on this machine: the behavior of what needs
    to happen upon inserting a coin and getting a soda can back. If there are soda
    cans left in the machine, we decrease the number of soda cans by one, increase
    the number of coins by one, and return a `soda can` object to the user. If there
    are no cans left, we throw an exception:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以定义一些机器上的行为：插入硬币并取回饮料罐时需要发生的行为。如果机器中还有饮料罐，我们就减少一个饮料罐的数量，增加一个硬币的数量，并返回一个`饮料罐`对象给用户。如果没有饮料罐了，我们抛出一个异常：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, the `SodaCan` object is defined as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`SodaCan`对象被定义为以下内容：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The cans and the amount of money present in the soda machine are the variables
    of the soda machine. They don't belong to the function's body. This is why the
    function that changes variables that are outside its own scope constitutes a side-effecting
    function.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在饮料机中存在的罐子和钱数是饮料机的变量。它们不属于函数体。这就是为什么改变其自身作用域之外变量的函数构成了一个有副作用的函数。
- en: 'While imperative methods are conceptualized as side-effecting behaviors, functions
    in the functional style are conceptualized as computations that compute some value.
    In the functional world, side effects are not welcome. Let''s express the preceding
    program in a purely functional way. We would have a soda machine with no behavior
    because the behavior is side-effecting. Side effects are generally bad in the
    functional world, as we will learn in subsequent chapters. Instead of that behavior,
    you would have a function that computes a new state of the soda machine. That
    is a new soda machine object from the old soda machine object. Such a soda machine
    object is an immutable object, which means that it only contains values that cannot
    be modified. This helps to eliminate side effects, since now, functions defined
    on the soda machine cannot modify its variables that are outside the scope of
    the functions. Whenever we want to get a new soda can, we would also need to compute
    the new state of the soda machine after the can is dispatched, and then return
    a soda can from this machine:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然命令式方法被概念化为有副作用的操作，但函数式风格的函数被概念化为计算某些值的计算。在函数式世界中，副作用是不受欢迎的。让我们以前面程序的方式表达纯函数式的程序。我们将有一个没有行为的饮料机，因为行为是有副作用的。在函数式世界中，副作用通常是不好的，正如我们在后续章节中将学到的。而不是那种行为，你将有一个计算饮料机新状态的函数。这是一个从旧饮料机对象生成的新饮料机对象。这样的饮料机对象是一个不可变对象，这意味着它只包含无法修改的值。这有助于消除副作用，因为现在，定义在饮料机上的函数不能修改其作用域之外的变量。每次我们想要得到一个新的罐子时，我们也需要计算罐子分发后的饮料机新状态，然后从这个机器中返回一个罐子：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Expressed this way, the computation does not affect the environment outside
    its own scope. We no longer have the modification of some external variables,
    nor do we interact with the world outside the scope of the function. We just compute
    the result values based on the inputs to the function. This is the understanding
    of a function in the world of functional programming. Later on in this book, we
    will cover how this understanding is more beneficial than the original understanding
    of a method in terms of the behavior.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式表达的计算不会影响其自身作用域之外的环境。我们不再修改某些外部变量，也不会与函数作用域之外的世界交互。我们只是根据函数的输入计算结果值。这是函数式编程世界中函数的理解。本书稍后我们将讨论这种理解在行为方面比原始的方法理解更有益。
- en: The absence of side effects is not the only feature of the functional style.
    The next feature we are going to look at is higher-order functions—functions that
    accept other functions as their inputs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式风格的唯一特征不是副作用的存在。接下来我们要看的是高阶函数——接受其他函数作为输入的函数。
- en: Higher-order functions
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶函数
- en: Another important concept that appears in functional programming is that of
    higher-order functions. A higher-order function is a function that accepts a function
    as an argument. A very trivial example of where this may be useful is control
    structures. For example, a `while` loop can be expressed in a functional way as
    a higher-order function that accepts the body of the loop and a predicate as an
    argument.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程中出现的另一个重要概念是高阶函数。高阶函数是接受一个函数作为参数的函数。一个可能非常有用的简单例子是控制结构。例如，一个`while`循环可以用函数式的方式表示为一个接受循环体和谓词作为参数的高阶函数。
- en: The body of the loop can be expressed as a function that does not accept any
    arguments, but computes some side effects. The way it works is that we have a
    function accept a `0-argument` function and a predicate, and we call the same
    `loop` function recursively while the predicate is true.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 循环体可以表示为一个不接受任何参数但计算一些副作用的功能。其工作方式是，我们有一个函数接受一个`0-参数`函数和一个谓词，当谓词为真时，我们递归地调用相同的`loop`函数。
- en: 'We can call the new control structure `whileDiy`, and it can be defined as
    follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将新的控制结构命名为`whileDiy`，它可以定义为如下：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `whileDiy` construct accepts a predicate and a body. The predicate will
    be evaluated on each function call and, if it is true, we will run the body and
    recursively invoke the `whileDiy` construct again. Notice also that in the `@annotation.tailrec` annotation
    on top of the method, it indicates that the method will be called in a tail-recursive
    manner, which means there's no chance it will result in a `StackOverflowError`,
    even though it is recursive. This is because it will reuse the frame of its initial
    call for all subsequent recursive calls.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`whileDiy`构造接受一个谓词和一个体。谓词将在每次函数调用时被评估，如果为真，我们将运行体并再次递归调用`whileDiy`构造。注意，在方法顶部的`@annotation.tailrec`注解上，它表明该方法将以尾递归方式调用，这意味着即使它是递归的，也没有机会导致`StackOverflowError`。这是因为它将重用其初始调用的框架进行所有后续递归调用。'
- en: 'We can use the new construction as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用新的构造：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Compare this to how the built-in `while` loop is used:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与内置的`while`循环的使用方式进行比较：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The usage is almost identical. This illustrates how higher-order functions can
    be used to define control structures very close to the ones built in to the language.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方式几乎相同。这说明了高阶函数可以用来定义与语言内建的控制结构非常接近的控制结构。
- en: Understanding lambda functions
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解lambda函数
- en: 'Most functional languages have a concept of a lambda function. It is an anonymous
    function defined inline. It can be assigned to a variable if needed. For example,
    consider that we need a function that accepts a cookie with user session data,
    in the context of a web application. Its job is to print a greeting to the user
    to the standard output. However, before printing, we need to decorate the user''s
    name in a certain way. To complicate matters further, we also have a database
    of users who hold PhDs and, if they do, we need to refer to them as Dr. Here is
    how it can be done in Scala:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数函数式语言都有一个lambda函数的概念。它是一个定义在行内的匿名函数。如果需要，它可以被分配给一个变量。例如，考虑在一个Web应用程序的上下文中，我们需要一个接受带有用户会话数据的cookie的函数。它的任务是向用户打印标准输出的问候语。然而，在打印之前，我们需要以某种方式装饰用户的姓名。更复杂的是，我们还有一个拥有博士学位的用户数据库，如果他们有，我们需要称他们为Dr.以下是在Scala中如何实现它的示例：
- en: 'We define the dummy `Cookie` class for our example:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为示例定义了一个虚拟的`Cookie`类：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We define the `greeting` method. The job of the method is to extract the data
    from the `cookie` object, and apply the modifier to the user's name based on their
    gender.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了`greeting`方法。该方法的工作是从`cookie`对象中提取数据，并根据用户的性别应用修改器到用户的名字。
- en: 'After that, greet the user. This method does not know how exactly to modify
    the name. The `modifier` logic is abstracted away and we rely on the caller to
    specify how to do this:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，问候用户。此方法不知道如何确切地修改名字。`modifier`逻辑被抽象化，我们依赖于调用者指定如何进行此操作：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, this is how we can call this method:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，这是调用此方法的方式：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `greeting` function accepts a string and also a function that modifies this
    string. Notice how, when calling this function, we specify the function that modifies
    the string inline. We do not define the function prior to passing it to the `greeting`
    function.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`greeting`函数接受一个字符串和一个修改这个字符串的函数。注意，在调用此函数时，我们如何内联指定修改字符串的函数。我们不需要在传递给`greeting`函数之前定义该函数。'
- en: This is the idea behind a lambda function. You don't need to define a function
    before you can use it in some other higher-order function. Instead, you can define
    functions like that inline, using lambda syntax. Obviously, this kind of approach
    is especially useful in the context of higher-order functions. It allows you to
    use higher-order functions without first defining their arguments.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是lambda函数背后的理念。在使用某些高阶函数之前，你不需要先定义一个函数。相反，你可以使用lambda语法内联定义这样的函数。显然，这种方法在处理高阶函数的上下文中特别有用。它允许你使用高阶函数，而无需首先定义它们的参数。
- en: The concept of the lambda function is present in the majority of functional
    languages, including Scala, Haskell, and Python.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套函数的概念在大多数函数式语言中都有体现，包括Scala、Haskell和Python。
- en: The concept of functions in different programming languages
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同编程语言中函数的概念
- en: Functions are present in many programming languages. Some of the languages have
    better support for purely functional styles, while others favor declarative styles.
    This is why, for example, using Scala over Java can give you tremendous leverage,
    because you can declare functions inside other functions, you can declare functions
    that accept other functions (higher-order functions) more easily, and you can
    declare anonymous lambda functions (functionality also available in Java, starting
    from Java 8). This greatly increases your capacity for abstraction, creating control
    structures, and thereby enabling your application to be expressed in a more **DRY**
    (**Don't Repeat Yourself**) way.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 函数存在于许多编程语言中。有些语言对纯函数式风格的支持更好，而有些则更倾向于声明式风格。这就是为什么，例如，使用Scala而不是Java可以给你带来巨大的优势，因为你可以更容易地在其他函数内部声明函数，你可以声明接受其他函数（高阶函数）的函数，并且你可以声明匿名lambda函数（从Java
    8开始，Java也提供了这种功能）。这大大增加了你的抽象能力，创建控制结构的能力，从而使得你的应用程序能够以更**DRY**（**不要重复自己**）的方式表达。
- en: Summary
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen what functions are and how they have evolved from
    the early days of programming to today. We have seen how functions were initially
    treated as abstractions of common logic. After that, in object-oriented programming,
    they represented the behavior of certain objects. Object-oriented programmers
    attempted to represent everything as an object. So it is only natural that functions
    started to be viewed in the context of a world that consists of objects. In this
    context, functions are best viewed as behaviors of these objects.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了函数是什么以及它们是如何从编程的早期发展到今天的。我们看到了函数最初是如何被视为常见逻辑的抽象的。之后，在面向对象编程中，它们代表了某些对象的行为。面向对象程序员试图将一切视为对象。因此，函数开始从由对象组成的世界中看待。在这种情况下，函数最好被视为这些对象的行为。
- en: In functional programming, functions can be viewed in a different context. Now,
    the best way to view functions is as mathematical computations. They compute some
    value out of its inputs, in a pure way, which means without any side effects.
    The idea is to view them as mathematical functions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，函数可以从不同的角度来理解。现在，最好的方式是将函数视为数学计算。它们以纯方式从输入中计算出一些值，这意味着没有任何副作用。这种想法是将它们视为数学函数。
- en: Functional programming is close to declarative programming, so its functions
    are also often tailored to the needs of that style. This way, in functional languages,
    there is a concept of higher-order functions, anonymous lambda functions, and
    partial functions. From an engineering perspective, this is useful because it
    greatly enhances your capability for abstraction.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程接近声明式编程，因此其函数也经常根据那种风格的需求进行定制。这种方式，在函数式语言中，存在高阶函数、匿名lambda函数和部分函数的概念。从工程角度来看，这很有用，因为它极大地增强了你的抽象能力。
- en: In programming, data structures are ubiquitous. When adopting functional style,
    sooner or later you will encounter a problem of working with data structures in
    a functional way. In the next chapter, we will see how this problem is addressed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，数据结构无处不在。当采用函数式风格时，迟早你会遇到如何在函数式方式下处理数据结构的问题。在下一章中，我们将看到这个问题是如何被解决的。
- en: Questions
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How are functions interpreted in the context of object-oriented programming?
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数在面向对象编程的上下文中是如何被解释的？
- en: How are functions interpreted in the context of pure functional programming?
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数在纯函数式编程的上下文中是如何被解释的？
- en: What are higher-order functions?
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高阶函数是什么？
- en: Why are higher-order functions useful?
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高阶函数为什么有用？
