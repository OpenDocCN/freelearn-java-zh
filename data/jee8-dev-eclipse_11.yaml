- en: Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务
- en: In the previous chapter, we learned how to profile Java applications in order
    to troubleshoot performance issues.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何对Java应用程序进行性能分析，以便解决性能问题。
- en: In this chapter, we will learn how to develop JEE microservices using Eclipse.
    We will also learn how to deploy microservices in Docker containers. We will develop
    simple microservices for our *Course Management* use case.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用Eclipse开发JEE微服务。我们还将学习如何在Docker容器中部署微服务。我们将为我们的*课程管理*用例开发简单的微服务。
- en: 'We will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Introduction to microservices and Eclipse MicroProfile
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务和Eclipse MicroProfile简介
- en: Developing JEE microservices using the WildFly Swarm and Spring Boot frameworks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用WildFly Swarm和Spring Boot框架开发JEE微服务
- en: Introduction to Docker and Docker Compose
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker和Docker Compose简介
- en: Deploying microservices in Docker containers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker容器中部署微服务
- en: What is a microservice?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是微服务？
- en: 'A microservice is a small application designed to perform a specific business
    task well. Microservices are typically implemented as RESTful web services. The
    following are some of the characteristics of a microservice:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是一个设计得很好的小应用，用于执行特定的业务任务。微服务通常实现为RESTful Web服务。以下是一些微服务的特点：
- en: Smaller in size (compared to monolithic applications), and focuses on a single
    business task/module
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尺寸较小（与单一应用相比），专注于单一业务任务/模块
- en: Has its own database, in contrast to a monolithic application that has one database
    for all business functionalities
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它拥有自己的数据库，与所有业务功能使用单一数据库的单一应用形成对比
- en: Is typically a standalone application, with a web container bundled into it
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常是一个独立的应用程序，其中包含捆绑的Web容器
- en: 'A large business application can be built by assembling smaller microservices.
    Compared to a large monolithic application, a microservice architecture provides
    the following benefits:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通过组装较小的微服务可以构建大型业务应用。与大型单一应用相比，微服务架构提供了以下好处：
- en: They are easy to deploy. In a monolithic application, deployment can be quite
    cumbersome because of the complexity of the application. Microservices are small
    and can be easily deployed on servers.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们易于部署。在单一应用中，由于应用的复杂性，部署可能相当繁琐。微服务体积小，可以轻松部署到服务器上。
- en: Microservices are loosely coupled, so changes in one can be isolated from other
    services in an application. Also, having a separate database for each service
    can further insulate the main application and other services from changes made
    in the schema of the database.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务是松散耦合的，因此一个微服务的变更可以与应用程序中其他服务的变更隔离。此外，为每个服务拥有单独的数据库可以进一步隔离主应用程序和其他服务，防止数据库模式变更带来的影响。
- en: 'To understand the contrast between monolithic application architecture and
    microservice architecture, let’s see an example. Throughout this book, we have
    been following the *Course Management* example. Let’s say this module is part
    of a larger **University Management System**, which has many more modules. A monolithic
    architecture for this application can be viewed as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解单一应用架构和微服务架构之间的对比，让我们看一个例子。在整个书中，我们一直在跟随*课程管理*的例子。假设这个模块是更大型的**大学管理系统**的一部分，该系统包含更多模块。这个应用的单一架构可以看作如下：
- en: '![](img/00224.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00224.jpeg)'
- en: Figure 12.1: Monolithic application architecture
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：单一应用架构
- en: We have one large application, the **University Management System**, with multiple
    modules and a single database.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个大型应用，即**大学管理系统**，包含多个模块和单一数据库。
- en: 'The same application can be architected using microservices as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 同一应用程序可以使用微服务按以下方式架构：
- en: '![](img/00225.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00225.jpeg)'
- en: 'Figure 12.2: Microservice application architecture'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：微服务应用架构
- en: In the microservice architecture, the **University Management System** is composed
    of many microservices, each with its own database.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，**大学管理系统**由许多微服务组成，每个微服务都有自己的数据库。
- en: Eclipse MicroProfile
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Eclipse MicroProfile
- en: Microservices can be built with the current JEE specification (JEE 8). However,
    there are certain specifications within JEE that are more important for developing
    microservices, such as JAX-RS (for RESTful Web Services) and JSON-P (for processing
    JSON data). So, a group of organizations has come together to create specifications
    for developing and running microservices, which are categorized as MicroProfile.
    Many of the specifications under MicroProfile are already part of the JEE specification
    (such as JAX-RS and JSON-P), but some are new specifications, such as for configuring
    and monitoring microservices.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用当前的JEE规范（JEE 8）构建微服务。然而，JEE中存在一些对开发微服务更为重要的规范，例如JAX-RS（用于RESTful Web服务）和JSON-P（用于处理JSON数据）。因此，一些组织联合起来制定了一系列用于开发和运行微服务的规范，这些规范被归类为MicroProfile。MicroProfile下的许多规范已经是JEE规范的一部分（如JAX-RS和JSON-P），但也有一些是新的规范，例如用于配置和监控微服务的规范。
- en: 'The group has come up with two profiles so far. Each MicroProfile-compliant
    implementation is expected to implement each specification in the supported profile.
    This ensures that a microservice created with a particular profile runs on all
    Microprofile implementations supporting that profile. At the time of writing this
    chapter, the group has come up with two profiles. Here is the list of MicroProfiles
    and specifications that they include:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 该小组到目前为止已经提出了两个配置文件。每个符合MicroProfile的实现都应实现所支持配置文件中的每个规范。这确保了使用特定配置文件创建的微服务可以在支持该配置文件的所有Microprofile实现上运行。在撰写本章时，该小组已经提出了两个配置文件。以下是MicroProfiles及其包含的规范列表：
- en: 'MicroProfile 1.0 (released in Sep 2016):'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'MicroProfile 1.0（2016年9月发布）:'
- en: CDI 1.2
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: CDI 1.2
- en: JSON-P 1.0
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON-P 1.0
- en: JAX-RS 2.0
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: JAX-RS 2.0
- en: 'MicroProfile 1.1 (released in August 2017):'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'MicroProfile 1.1（2017年8月发布）:'
- en: Config 1.0
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Config 1.0
- en: CDI 1.2
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: CDI 1.2
- en: JSON-P 1.0
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON-P 1.0
- en: JAX-RS 2.0
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: JAX-RS 2.0
- en: MicroProfile 2.0 is expected to be released in June 2018, and it will include
    updates to some of the specifications as per JEE 8\. Some of the implementations
    of MicroProfiles are WildFly Swarm ([http://wildfly-swarm.io/](http://wildfly-swarm.io/)),
    WebSphere Liberty ([https://developer.ibm.com/wasdev/websphere-liberty/](https://developer.ibm.com/wasdev/websphere-liberty/)),
    Payara ([http://www.payara.fish/](http://www.payara.fish/)), and Apache TomEE
    ([http://tomee.apache.org/](http://tomee.apache.org/)). Visit the official website
    for MicroProfiles at [https://microprofile.io/](https://microprofile.io/) for
    more information.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 预计MicroProfile 2.0将于2018年6月发布，并将包括对JEE 8规范的一些更新。MicroProfile的一些实现包括WildFly Swarm
    ([http://wildfly-swarm.io/](http://wildfly-swarm.io/))、WebSphere Liberty ([https://developer.ibm.com/wasdev/websphere-liberty/](https://developer.ibm.com/wasdev/websphere-liberty/))、Payara
    ([http://www.payara.fish/](http://www.payara.fish/))和Apache TomEE ([http://tomee.apache.org/](http://tomee.apache.org/))。有关MicroProfile的更多信息，请访问其官方网站[https://microprofile.io/](https://microprofile.io/)。
- en: 'In the next section, we will see how to implement a microservice for our *Course
    Management* use case using two solutions:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何使用两种解决方案实现我们的*课程管理*用例的微服务：
- en: Using a MicroProfile implementation (WildFly Swarm)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MicroProfile实现（WildFly Swarm）
- en: Using Spring Boot, which is not part of MicroProfile
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Boot，它不是MicroProfile的一部分
- en: Later, we will see how to deploy microservices in Docker containers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何将微服务部署到Docker容器中。
- en: To follow the code examples in this chapter, you need to be familiar with JPA
    and REST APIs. Refer to [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Database Applications*, for JPA concepts and [Chapter 9](part0176.html#57R300-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating Web Services*, for RESTful web services.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章中的代码示例，您需要熟悉JPA和REST API。请参考[第4章](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)，*创建JEE数据库应用程序*，了解JPA概念，以及[第9章](part0176.html#57R300-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)，*创建Web服务*，了解RESTful
    Web服务。
- en: Setting up a database for a microservice project
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为微服务项目设置数据库
- en: We are going to implement a microservice to get a list of courses.  We will
    use the same MySQL database, `course_management`, that we have been using in this
    book. Refer to *Installing MySQL* in [Chapter 1](part0008.html#7K4G0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Introducing JEE and Eclipse*, if you need information on how to install and set
    up MySQL. If you haven’t already created the `course_management` schema, then
    refer to the *Creating database schema* section in [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Database Applications*. At this point, we will assume that the MySQL
    database is running and the `course_management` schema with the `Course`, `Course_Student`,
    `Student`, and `Teacher` tables exists.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个微服务来获取课程列表。我们将使用与本书中相同的 MySQL 数据库，`course_management`。如果您需要有关如何安装和设置
    MySQL 的信息，请参阅第 1 章 *介绍 JEE 和 Eclipse* 中的 *安装 MySQL* 部分。如果您尚未创建 `course_management`
    模式，请参阅第 4 章 *创建 JEE 数据库应用程序* 中的 *创建数据库模式* 部分。[第 4 章](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)。此时，我们将假设
    MySQL 数据库正在运行，并且包含 `Course`、`Course_Student`、`Student` 和 `Teacher` 表的 `course_management`
    模式存在。
- en: We will use JPA to access this database. See the *Creating a database application
    using JPA* section in [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Database Applications*, if you are not familiar with JPA. We are
    going to use EclipseLink as the JPA provider.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 JPA 访问此数据库。如果您不熟悉 JPA，请参阅第 4 章 *使用 JPA 创建数据库应用程序* 部分中的 *创建 JEE 数据库应用程序*，[第
    4 章](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)。我们将使用 EclipseLink
    作为 JPA 提供者。
- en: Implementing microservices using WildFly Swarm
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 WildFly Swarm 实现微服务
- en: WildFly Swarm ( [http://wildfly-swarm.io/](http://wildfly-swarm.io/) ) is a
    MicroProfile implementation from Red Hat. It allows you to assemble an application
    container for running microservices with just the specifications you need.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: WildFly Swarm ([http://wildfly-swarm.io/](http://wildfly-swarm.io/)) 是 Red Hat
    的 MicroProfile 实现。它允许您仅使用所需的规范来组装应用程序容器以运行微服务。
- en: Creating a WildFly Swarm project
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 WildFly Swarm 项目
- en: 'Let’s use WildFly Swarm Project Generator at [http://wildfly-swarm.io/generator/](http://wildfly-swarm.io/generator/)
    to select the specifications we want to include in our application and to create
    the starter project:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 [http://wildfly-swarm.io/generator/](http://wildfly-swarm.io/generator/)
    使用 WildFly Swarm 项目生成器选择我们想要包含在我们的应用程序中的规范，并创建起始项目：
- en: '![](img/00226.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00226.jpeg)'
- en: 'Figure 12.3: WildFly Swarm Project Generator'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3：WildFly Swarm 项目生成器
- en: Enter Group ID and Artifact ID as shown in the previous screenshot. In the Dependencies
    textbox, start typing features such as JPA or JAX-RS and then select them from the
    auto-suggested options. Make sure JPA EclipseLink , JAX-RS, and CDI are selected
    as dependencies. If you want to see all available dependencies and select from
    that list, then click the View all available dependencies link.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 输入组 ID 和工件 ID，如前一张截图所示。在依赖项文本框中，开始输入如 JPA 或 JAX-RS 等功能，然后从自动建议的选项中选择它们。确保已选择
    JPA EclipseLink、JAX-RS 和 CDI 作为依赖项。如果您想查看所有可用的依赖项并从中选择，请点击查看所有可用依赖项链接。
- en: Click the Generate Project button to create the project and download the ZIP
    file. This is a Maven project. Unzip the file in a folder and import the project
    as a Maven project in Eclipse (by selecting the menu option File | Import and
    then selecting Existing Maven Projects in the Maven category).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 点击生成项目按钮以创建项目和下载 ZIP 文件。这是一个 Maven 项目。将文件解压到一个文件夹中，并在 Eclipse 中将其作为 Maven 项目导入（通过选择菜单选项文件
    | 导入，然后在 Maven 类别中选择现有 Maven 项目）。
- en: 'Right-click on the Eclipse Project Explorer and select Run As | Maven Build.
    In the configuration window, type `wildfly-swarm:run` in the Goals field:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击 Eclipse 项目资源管理器，选择运行方式 | Maven 构建。在配置窗口中，在目标字段中输入 `wildfly-swarm:run`：
- en: '![](img/00227.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00227.jpeg)'
- en: 'Figure 12.4: Maven Build Configuration to create a WildFly Swarm application'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4：创建 WildFly Swarm 应用程序的 Maven 构建配置
- en: Click Run. Maven will download and install the dependencies and then run the
    application (you will see a Wildfly Swarm is Ready message in the console when
    the application is ready). Open `http://localhost:8080/hello` to test the default
    endpoint created by the application generator. You should see the `hello` message.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 点击运行。Maven 将下载和安装依赖项，然后运行应用程序（当应用程序准备就绪时，您将在控制台中看到 Wildfly Swarm is Ready 消息）。打开
    `http://localhost:8080/hello` 以测试应用程序生成器创建的默认端点。您应该看到 `hello` 消息。
- en: 'If you look into the target folder of the project, you will see `demo-swarm.jar`
    and `demo.war`. When we executed the wildfly-swarm:run goal, Maven starts a JBoss
    container and deploys the WAR file. The microservice can also be run by executing
    the single JAR file, `demo-swarm.jar`. This JAR contains all the packages, including
    the application server to run the microservice. Simply run this from the command
    line:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看项目的目标文件夹，你会看到 `demo-swarm.jar` 和 `demo.war`。当我们执行 `wildfly-swarm:run` 目标时，Maven
    启动 JBoss 容器并部署 WAR 文件。微服务也可以通过执行单个 JAR 文件 `demo-swarm.jar` 来运行。这个 JAR 包含了所有包，包括运行微服务所需的应用服务器。只需从命令行运行它即可：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To change the name of the output file from demo to, say, `coursemanagement`,
    change the name in `pom.xml` in `<filename>` under the `<build>` tag.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要将输出文件名从 demo 改为，例如，`coursemanagement`，请更改 `<build>` 标签下的 `<filename>` 中的名称。
- en: Configuring JPA
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 JPA
- en: 'Now, let’s add a dependency for MySQL in the project. Refer to *Figure 4.11*
    in [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating
    JEE Database Applications*, for adding a Maven dependency for the MySQL JDBC driver,
    or simply add the following dependency to `pom.xml`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在项目中添加 MySQL 的依赖项。参考 [第 4 章](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)
    中 *创建 JEE 数据库应用程序* 部分的 *图 4.11*，添加 Maven 依赖项以使用 MySQL JDBC 驱动程序，或者简单地将以下依赖项添加到
    `pom.xml` 中：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Convert the project to a JPA project so that we can use the JPA tooling provided
    by Eclipse. Right-click on the project in the Project Explorer and select the
    Configure | Convert to JPA Project option. Make sure the following Project Facets
    are selected, along with the default facets:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 将项目转换为 JPA 项目，以便我们可以使用 Eclipse 提供的 JPA 工具。在项目资源管理器中右键单击项目，选择 Configure | Convert
    to JPA Project 选项。确保选中以下项目特性，包括默认特性：
- en: Dynamic Web Module
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态 Web 模块
- en: JAX-RS (RESTful web services)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JAX-RS（RESTful Web 服务）
- en: JPA
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JPA
- en: Click the Next button (refer to *Figure 4.20* <q class="calibre207">Add JPA
    facet to the project</q> of [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Database Applications*) and configure the JPA facet as shown in
    <q class="calibre207">Figure 4.21</q>. Click Finish.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 点击下一步按钮（参考 [第 4 章](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55) 中
    *创建 JEE 数据库应用程序* 部分的 *图 4.20* <q class="calibre207">向项目中添加 JPA 特性</q>），并按 <q class="calibre207">图
    4.21</q> 中所示配置 JPA 特性。点击完成。
- en: 'Let’s now configure the JDBC connection in `persistence.xml`. Follow steps
    7 through 9 in the *Converting project into a JPA project* section in [Chapter
    4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating JEE Database
    Applications*. Your `persistence.xml` should now have the following persistence
    unit:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来配置 `persistence.xml` 中的 JDBC 连接。按照 [第 4 章](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)
    中 *将项目转换为 JPA 项目* 部分的步骤 7 到 9 进行，*创建 JEE 数据库应用程序*。现在你的 `persistence.xml` 应该包含以下持久化单元：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the previous XML file, we are specifying the `org.eclipse.persistence.jpa.PersistenceProvider`
    class as our JPA provider and then setting properties for connecting to the MySQL
    database.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的 XML 文件中，我们指定 `org.eclipse.persistence.jpa.PersistenceProvider` 类作为我们的 JPA
    提供程序，然后设置连接到 MySQL 数据库的属性。
- en: Next, create folders named `resources/META-INF` under `src/main` and copy `persistence.xml`
    into the `src/main/resources` folder. If Eclipse displays errors in JPA configuration,
    right-click on the project name in Project Explorer and select Maven | Update
    Project. The reason for doing this is that Maven expects files that you want to
    copy to the `classes` folder to be in the `src/main/resources` folder. We need
    to have `META-INF/persistence.xml` in the `classes` folder so that the JPA provider
    can load it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `src/main` 下创建名为 `resources/META-INF` 的文件夹，并将 `persistence.xml` 复制到 `src/main/resources`
    文件夹中。如果 Eclipse 在 JPA 配置中显示错误，请在项目资源管理器中右键单击项目名称，选择 Maven | 更新项目。这样做的原因是 Maven
    预期你想要复制到 `classes` 文件夹的文件位于 `src/main/resources` 文件夹中。我们需要在 `classes` 文件夹中拥有 `META-INF/persistence.xml`，以便
    JPA 提供程序可以加载它。
- en: Creating a course entity bean and a JPA factory
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建课程实体和 JPA 工厂
- en: If you are not familiar with JPA, refer to the *JPA concepts* section in [Chapter
    4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating JEE Database
    Applications*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉 JPA，请参考 [第 4 章](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)
    中 *创建 JEE 数据库应用程序* 部分的 *JPA 概念* 部分。
- en: 'We will now create `Course.java` in the `packt.book.jeeeclipse.wildflyswarm.coursemanagement.rest`
    package:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将在 `packt.book.jeeeclipse.wildflyswarm.coursemanagement.rest` 包中创建 `Course.java`：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is a simple JPA entity class with appropriate annotations. We need to tell
    JPA that this is a managed bean. To do this, open `persistence.xml` and in the
    General tab of the editor, click the Add button in the Managed Classes section.
    Add the `Course` entity class to the list.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的JPA实体类，带有适当的注解。我们需要告诉JPA这是一个受管理的bean。为此，打开`persistence.xml`，并在编辑器的“常规”选项卡中，点击“受管理类”部分中的“添加”按钮。将`Course`实体类添加到列表中。
- en: 'Create a JPA `EntityManagerFactory` class called `CourseManagementJPAFactory`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`CourseManagementJPAFactory`的JPA `EntityManagerFactory`类：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this class, we are creating an instance of `EntityManager` from `EntityManagerFactory`.
    Note that name passed to the `Persistence.createEntityManagerFactory` method is the
    same as the name we specified in `persistence.xml`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们正在从`EntityManagerFactory`创建`EntityManager`的实例。请注意，传递给`Persistence.createEntityManagerFactory`方法的名称与我们指定的`persistence.xml`中的名称相同。
- en: 'Finally, we will create the main class, called `CourseManagementEndpoint`,
    and also the REST endpoint function to handle the `/course_management/courses`
    URL path:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建主类，称为`CourseManagementEndpoint`，以及处理`/course_management/courses` URL路径的REST端点函数：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If the application is not already running, right-click on the project in Project
    Explorer and select Run As | Maven build. Open `http://localhost:8080/course_managment/courses` in
    the browser and you should see a JSON list of courses in the database.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序尚未运行，请在项目资源管理器中右键单击项目，然后选择运行 As | Maven构建。在浏览器中打开`http://localhost:8080/course_managment/courses`，你应该会看到数据库中课程的JSON列表。
- en: 'To change the default server port from `8080` to any other port number, say
    `8000`, set the `swarm.http.port=8000` environment variable. You can set this
    in the run configuration for the project (select Run | Run Configurations from
    the main menu and look for the configuration for your project in the Maven Build
    section):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要将默认服务器端口从`8080`更改为任何其他端口号，例如`8000`，请设置`swarm.http.port=8000`环境变量。您可以在项目的运行配置中设置此变量（从主菜单中选择运行
    | 运行配置，然后在Maven构建部分查找您项目的配置）：
- en: '![](img/00228.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00228.jpeg)'
- en: 'Figure 12.5: Set the environment variable in the run configuration'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5：在运行配置中设置环境变量
- en: Click on the Environment tab and add the environment variable and its value.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 点击环境标签并添加环境变量及其值。
- en: Implementing microservices using Spring Boot
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Boot实现微服务
- en: A microservice can be implemented in many ways; in the previous section, we
    saw one way to implement it, using WildFly Swarm, which is a MicroProfile implementation.
    In this section, we will see how to implement a microservice using Spring Boot,
    which is not a MicroProfile implementation but is a popular framework.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务可以通过多种方式实现；在前一节中，我们看到了使用WildFly Swarm实现微服务的一种方法，WildFly Swarm是一个MicroProfile实现。在本节中，我们将了解如何使用Spring
    Boot实现微服务，Spring Boot不是一个MicroProfile实现，但是一个非常流行的框架。
- en: 'Spring Boot ([https://spring.io/projects/spring-boot/](http://spring.io/projects/spring-boot))
    is a framework to create standalone Spring applications. Refer to [Chapter 8](part0154.html#4IRMK0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating
    Web Applications with Spring MVC*, for more information on Spring and specific
    information on the Spring MVC framework. Similar to the WildFly Swarm Project
    Generator, Spring Boot also has a web page for creating a starter application
    for Spring Boot, where you can select the features/specifications of JEE that
    you want to be included in the application. Go to [https://start.spring.io/](https://start.spring.io/):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot ([https://spring.io/projects/spring-boot/](http://spring.io/projects/spring-boot))
    是一个用于创建独立Spring应用程序的框架。有关Spring和Spring MVC框架的更多信息，请参阅第8章，*使用Spring MVC创建Web应用程序*。与WildFly
    Swarm项目生成器类似，Spring Boot也有一个用于创建Spring Boot入门应用程序的网页，您可以在其中选择要包含在应用程序中的JEE功能/规范。访问[https://start.spring.io/](https://start.spring.io/)：
- en: '![](img/00229.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00229.jpeg)'
- en: 'Figure 12.6: Spring Boot project generator'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6：Spring Boot项目生成器
- en: 'Select the Web, JPA, and Jersey(JAX-RS) dependencies. Download the starter
    project and unzip it in a folder. We won’t be able to run the application yet.
    Since we have selected JPA as one of the dependencies of the application, Spring
    Boot expects us to configure database connection properties in the application.properties
    file, located in `src/main/resources`. Add the following properties to `application.properties`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 选择Web、JPA和Jersey(JAX-RS)依赖项。下载入门项目并将其解压缩到一个文件夹中。由于我们已将JPA选为应用程序的一个依赖项，Spring
    Boot期望我们在`src/main/resources`中的`application.properties`文件中配置数据库连接属性。将以下属性添加到`application.properties`中：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can run the server now, but we haven’t defined any REST endpoints yet. So,
    let’s do that. We will use the `Course` entity bean that we created for the WildFly
    Swarm project in the previous section. So, copy the same file to this project,
    in the `packt.book.jeeeclipse.springboot.coursemanagementspring` package. See the
    *Create course entity bean and JPA factory* section for listings of the `Course`
    class.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行服务器了，但我们还没有定义任何REST端点。所以，让我们来做这件事。我们将使用上一节中为WildFly Swarm项目创建的`Course`实体bean。因此，将相同的文件复制到这个项目中，在`packt.book.jeeeclipse.springboot.coursemanagementspring`包中。参见*创建课程实体bean和JPA工厂*部分中的`Course`类列表。
- en: 'Spring provides a utility interface named `CrudRepository` that tells the framework
    to create CRUD boilerplate code for the given entity/class. We will create a repository
    interface that extends `CrudRepository` and create a CRUD implementation for the
    `Course` class. See [https://docs.spring.io/spring-data/data-commons/docs/1.6.1.RELEASE/reference/html/repositories.html](https://docs.spring.io/spring-data/data-commons/docs/1.6.1.RELEASE/reference/html/repositories.html)
    for more information on `CrudRepository`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了一个名为`CrudRepository`的实用接口，它告诉框架为给定的实体/类创建CRUD样板代码。我们将创建一个扩展`CrudRepository`的仓库接口，并为`Course`类创建一个CRUD实现。有关`CrudRepository`的更多信息，请参阅[https://docs.spring.io/spring-data/data-commons/docs/1.6.1.RELEASE/reference/html/repositories.html](https://docs.spring.io/spring-data/data-commons/docs/1.6.1.RELEASE/reference/html/repositories.html)：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is just a marker interface to tell Spring Framework to create CRUD code
    for the `Course` class/entity that has the primary key of type `Long`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个标记接口，用于告诉Spring框架为具有类型`Long`主键的`Course`类/实体创建CRUD代码。
- en: 'In Spring, a REST endpoint is created by creating a controller, actually annotating
    the class with `@RestController`. See [https://spring.io/guides/gs/rest-service/](https://spring.io/guides/gs/rest-service/) for
    information on creating RESTful web services using Spring. So, let’s create the
    `CourseController` class:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring中，通过创建一个控制器并实际上用`@RestController`注解类来创建REST端点。有关使用Spring创建RESTful Web服务的更多信息，请参阅[https://spring.io/guides/gs/rest-service/](https://spring.io/guides/gs/rest-service/)。因此，让我们创建`CourseController`类：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this class, we are mapping the GET HTTP request to the `/course_management/courses` URL
    to the `getCourses` method.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们将GET HTTP请求映射到`/course_management/courses` URL的`getCourses`方法。
- en: An instance of `CourseRepository` is auto injected into this class using the
    `@Autowired` annotation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@Autowired`注解，`CourseRepository`的实例会自动注入到这个类中。
- en: We are now ready to run the application. Create a run configuration for this
    application by right-clicking on the project in Project Explorer and selecting
    Run As **|** Maven Build. Then, type `spring-boot:run` in the Goals field ( see
    *Figure 12.4* for reference) and click the Run button. Once the server is ready,
    browse to `http://localhost:8080/course_management/courses` and you should see
    JSON output (for `Courses`).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好运行应用程序。通过在项目资源管理器中右键单击项目并选择“运行As **|** Maven Build”来为此应用程序创建一个运行配置。然后，在Goals字段中输入`spring-boot:run`（参见*图12.4*以获取参考），然后单击运行按钮。一旦服务器准备就绪，请浏览到`http://localhost:8080/course_management/courses`，你应该会看到JSON输出（对于`Courses`）。
- en: To change the default server port from `8080` to any other port number, say
    `8000`, set the environment variable `server.port=8000`. See *Figure 12.5* for
    reference.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要将默认服务器端口从`8080`更改为任何其他端口号，例如`8000`，请设置环境变量`server.port=8000`。参见*图12.5*以获取参考。
- en: See [https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/)
    for a complete reference to Spring Boot.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/)以获取Spring
    Boot的完整参考。
- en: Deploying microservices in a Docker container
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker容器中部署微服务
- en: In this section, we will learn how to deploy a microservice in a Docker container,
    but let’s first understand what Docker is.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在Docker容器中部署微服务，但首先让我们了解什么是Docker。
- en: What is Docker?
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Docker？
- en: Docker is container management software. In general, software containers allow
    you to package your application with all dependencies, including the OS, in one
    package. Your application runs in isolation in the container in which it is packaged.
    This reduces discrepancies in environments when developing, testing, and deploying.
    Since all the dependencies for your application are already resolved and packaged
    with it, you generally do not run into situations where your application ran fine
    in a dev/test environment, but failed in production—maybe because some of the
    dependencies were not met. For example, even if you have developed and tested
    in the same OS version, in production some of the dependencies may fail because
    of OS updates.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是容器管理软件。通常，软件容器允许你将应用程序及其所有依赖项，包括操作系统，打包在一个包中。你的应用程序在打包的容器中独立运行。这减少了在开发、测试和部署时环境差异。由于你的应用程序的所有依赖项都已经解决并与其打包，因此你通常不会遇到在开发/测试环境中应用程序运行良好，但在生产环境中失败的情况——可能是因为某些依赖项未满足。例如，即使你在相同的操作系统版本上开发和测试，在生产环境中，由于操作系统更新，某些依赖项可能会失败。
- en: 'Docker is the most popular container management technology currently. Docker
    makes it easy to package and run your application in a container. It is often
    compared with virtual machines. The following diagram shows the difference between
    them:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是目前最受欢迎的容器管理技术。Docker使得将你的应用程序打包并运行在容器中变得非常容易。它通常与虚拟机进行比较。以下图表显示了它们之间的区别：
- en: '![](img/00230.gif)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00230.gif)'
- en: 'Figure 12.7: Difference between Virtual Machines Technology and Docker Container
    Technology'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7：虚拟机技术与Docker容器技术之间的区别
- en: VMs are guest operating systems in *Figure 12.7*, running on top of hypervisor
    software (a hypervisor isolates the guest OS from the host OS and manages them).
    Docker containers run on top of Docker Engine and a shared OS kernel (for example,
    Linux or Windows). Docker containers are not full-fledged OSes; they are processes
    with isolated resources such as filesystems and networks.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在图12.7中，虚拟机是运行在虚拟化软件（虚拟机管理程序将客户操作系统与宿主操作系统隔离开来并管理它们）之上的客户操作系统。Docker容器运行在Docker引擎和共享的操作系统内核（例如，Linux或Windows）之上。Docker容器不是完整的操作系统；它们是具有隔离资源（如文件系统和网络）的进程。
- en: Compared to VMs, Docker containers are easy to package and deploy, and they
    start much more quickly (because they are just processes and not complete OSes).
    Docker containers also take up a lot fewer resources than VMs. So, you can run
    more Docker containers in the same environment than VMs.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与虚拟机相比，Docker容器易于打包和部署，并且启动速度要快得多（因为它们只是进程，而不是完整的操作系统）。Docker容器也比虚拟机占用更少的资源。因此，你可以在相同的环境中运行比虚拟机更多的Docker容器。
- en: See this official Docker link, [https://www.docker.com/what-docker](https://www.docker.com/what-docker),
    for more information.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 查看这个官方Docker链接，[https://www.docker.com/what-docker](https://www.docker.com/what-docker)，获取更多信息。
- en: How to get Docker
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何获取Docker
- en: 'Download Docker for Mac from here: [https://docs.docker.com/docker-for-mac/install/](https://docs.docker.com/docker-for-mac/install/)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里下载Mac版本的Docker：[https://docs.docker.com/docker-for-mac/install/](https://docs.docker.com/docker-for-mac/install/)
- en: 'Download Docker for Windows from here: [https://docs.docker.com/docker-for-windows/install/](https://docs.docker.com/docker-for-windows/install/)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里下载Windows版本的Docker：[https://docs.docker.com/docker-for-windows/install/](https://docs.docker.com/docker-for-windows/install/)
- en: 'Download Docker for Linux: [https://docs.docker.com/engine/installation/](https://docs.docker.com/engine/installation/)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里下载Linux版本的Docker：[https://docs.docker.com/engine/installation/](https://docs.docker.com/engine/installation/)
- en: How to use Docker
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用Docker
- en: In this section, we will briefly see how to use Docker. To create a new container,
    you typically create a Dockerfile. In this file, you need to specify the base
    image to extend your container from, for example, the base image for Ubuntu or
    Debian. You can think of Docker images as templates, and containers as running
    instances of those templates. Docker Hub, [https://hub.docker.com/](https://hub.docker.com/),
    is a repository of Docker images.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要介绍如何使用Docker。要创建一个新的容器，你通常需要创建一个Dockerfile。在这个文件中，你需要指定要扩展容器的基镜像，例如Ubuntu或Debian的基镜像。你可以将Docker镜像视为模板，容器则是这些模板的运行实例。Docker
    Hub，[https://hub.docker.com/](https://hub.docker.com/)，是Docker镜像的存储库。
- en: Dockerfile
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dockerfile
- en: 'You create a Dockerfile to create an image for your own container. You can
    specify the base image for your container, commands to execute when setting up
    the container, ports to expose, files to copy to the container, and the entry
    point (the program to run when the container starts). Here are some of the frequently
    used instructions in a Dockerfile:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您创建一个Dockerfile来创建自己的容器镜像。您可以指定容器的基镜像、设置容器时执行的命令、要公开的端口、要复制到容器的文件以及入口点（容器启动时运行的程序）。以下是Dockerfile中常用的一些指令：
- en: '`FROM`: Specify the base image for your Docker container, for example, `FROM
    Ubuntu`.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM`: 指定Docker容器的基镜像，例如，`FROM Ubuntu`。'
- en: '`ADD`: Add file(s) from the host machine to the Docker container. For example,
    to copy the `setup.sh` file from the directory from where Docker commands are
    run to a container. For example, `ADD ./setup.sh /setup.sh`.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADD`: 从主机机器添加文件（s）到Docker容器。例如，将`setup.sh`文件从运行Docker命令的目录复制到容器中。例如，`ADD ./setup.sh
    /setup.sh`。'
- en: '`RUN`: Runs a command in the container. For example, to make the `setup.sh`
    file executable after copying to a container. Example, `RUN chmod +x /setup.sh`.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN`: 在容器中运行一个命令。例如，在将`setup.sh`文件复制到容器后使其可执行。例如，`RUN chmod +x /setup.sh`。'
- en: '`ENTRYPOINT`: Docker containers are meant to have one main application, and
    when it stops running, the container stops. That main program is specified using the
    `ENTRYPOINT` directive. For example, to run the Apache server after it is installed
    (possibly using the `RUN` command) `ENTRYPOINT apachectl start`.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT`: Docker容器旨在有一个主要的应用程序，当它停止运行时，容器也会停止。该主程序使用`ENTRYPOINT`指令指定。例如，在安装后（可能使用`RUN`命令）运行Apache服务器时，`ENTRYPOINT
    apachectl start`。'
- en: '`CMD`**:** A command to execute. In the absence of `ENTRYPOINT`, `CMD` specifies
    the main application in the container. If specified along with `ENTRYPOINT`, then the
    value of `CMD` is passed as arguments to the application specified in `ENTRYPOINT`.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD`**:** 一个执行命令。在没有`ENTRYPOINT`的情况下，`CMD`指定容器中的主应用程序。如果与`ENTRYPOINT`一起指定，则`CMD`的值作为`ENTRYPOINT`中指定应用程序的参数传递。'
- en: '`EXPOSE`:  Tells Docker that the container listens on specified port(s) at
    runtime. For example, if the Apache server is listening on port `80` in a container, then
    you would specify `EXPOSE 80`.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPOSE`: 告诉Docker容器在运行时监听指定的端口（s）。例如，如果Apache服务器在容器中监听端口`80`，则您将指定`EXPOSE
    80`。'
- en: '`ENV`: Sets environment variable(s) in a container. An example is `ENV PATH=/some/path:$PATH`.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENV`: 在容器中设置环境变量（s）。例如，`ENV PATH=/some/path:$PATH`。'
- en: '`VOLUME`: Creates a mountable point for a volume. A volume is just like a folder
    or virtual folder. From within the container, it can be accessed as any other
    folder. Volumes can be used to share folders across different running containers.
    One container can also import volumes from another container.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VOLUME`: 创建一个可挂载的卷点。卷就像一个文件夹或虚拟文件夹。在容器内部，它可以像其他文件夹一样访问。卷可以用于在不同运行的容器之间共享文件夹。一个容器也可以从另一个容器导入卷。'
- en: This is a list of commonly used Docker instructions in a Dockerfile. See the
    Dockerfile reference at [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)
    for all instructions.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个Dockerfile中常用Docker指令的列表。有关所有指令的详细信息，请参阅[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)中的Dockerfile参考。
- en: Docker commands
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker命令
- en: 'Here is a short list of Docker commands for operations such as start, stop,
    and delete:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是启动、停止和删除等操作的一些Docker命令的简短列表：
- en: '| **Operation** | **Command** |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **命令** |'
- en: '| Run a container from an image | The syntax is as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '| 从镜像运行容器 | 语法如下：'
- en: '[PRE9]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For example, to run a container from an Ubuntu image, open a Terminal and execute
    the bash shell with the following command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要从Ubuntu镜像运行容器，打开终端并使用以下命令执行bash shell：
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Create an image from a Dockerfile | The syntax is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '| 从Dockerfile创建镜像 | 语法如下：'
- en: '[PRE11]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For example, to create `my_image` from a Dockerfile in the current folder,
    run the following Docker command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要从当前文件夹中的Dockerfile创建`my_image`，运行以下Docker命令：
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| List currently running containers |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 列出当前运行的容器 |'
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '|'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| List all containers, including stopped containers |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 列出所有容器，包括停止的容器 |'
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Start (a stopped) container | The syntax is as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '| 启动（停止的）容器 | 语法如下：'
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `-i` option keeps `stdin` (standard input) open and allows you to run commands
    in the container. To identify the container, you can either use the container
    name or ID. |
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`-i`选项保持`stdin`（标准输入）开启，并允许您在容器中运行命令。要识别容器，您可以使用容器名称或ID。|'
- en: '| Remove a container |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 删除容器 |'
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Execute command in running container | The syntax is as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '| 在运行容器中执行命令 | 语法如下：'
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For example, to open a bash shell in a running container called `my_container`,
    execute the following command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要在名为`my_container`的运行容器中打开bash shell，请执行以下命令：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Listing all images |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 列出所有镜像 |'
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Deleting images | Image IDs are space separated in this command:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '| 删除镜像 | 在此命令中，镜像ID由空格分隔：'
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Get information about running container |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 获取运行容器的信息 |'
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: See [https://docs.docker.com/engine/reference/commandline/docker/](https://docs.docker.com/engine/reference/commandline/docker/)
    for the complete reference.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[https://docs.docker.com/engine/reference/commandline/docker/](https://docs.docker.com/engine/reference/commandline/docker/)获取完整参考。
- en: That was a short introduction to Docker. There are many more details of Docker
    that are out of the scope of this book. Please refer to the links provided and
    also the Docker website ([https://www.docker.com/](https://www.docker.com/)) for
    more information. We will now focus on Eclipse tooling for Docker and deploying
    microservices in Docker containers.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对Docker的简要介绍。本书范围之外还有许多关于Docker的详细信息。请参阅提供的链接以及Docker网站([https://www.docker.com/](https://www.docker.com/))获取更多信息。现在我们将专注于Eclipse
    Docker工具以及如何在Docker容器中部署微服务。
- en: Setting up Docker Tooling in Eclipse
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Eclipse中设置Docker工具
- en: 'There is a Docker plugin for Eclipse, using which you can perform many of the
    mentioned Docker tasks from within Eclipse. To install the plugin in Eclipse,
    from the menu, select Help | Eclipse Marketplace.... Search for `Eclipse Docker
    Tooling` and install it:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个Eclipse的Docker插件，使用它可以执行许多提到的Docker任务。要在Eclipse中安装插件，从菜单中选择帮助 | Eclipse Marketplace....
    搜索“Eclipse Docker Tooling”并安装它：
- en: '![](img/00231.jpeg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00231.jpeg)'
- en: 'Figure 12.8: Install Eclipse Docker Tooling from Eclipse Marketplace'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8：从Eclipse Marketplace安装Eclipse Docker工具
- en: Switch to the Docker Tooling perspective (either click on the Open Perspective
    toolbar button at the top-right of the editor window, or select from the Window
    | Perspective | Open Perspective | Other menu).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到Docker工具视角（要么点击编辑窗口右上角的“打开视角”工具栏按钮，要么从“窗口 | 视角 | 打开视角 | 其他”菜单中选择）。
- en: 'We will now add a Docker connection in Eclipse (make sure the Docker daemon
    is running):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在Eclipse中添加一个Docker连接（确保Docker守护进程正在运行）：
- en: '![](img/00232.jpeg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00232.jpeg)'
- en: 'Figure 12.9: Add Docker connection'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9：添加Docker连接
- en: 'Click on the Add Connection toolbar button in Docker Explorer and create a
    connection, as shown in the following screenshot:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker资源管理器中点击“添加连接”工具栏按钮并创建连接，如图下截图所示：
- en: '![](img/00233.jpeg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00233.jpeg)'
- en: 'Figure 12.10: Add connection dialog box'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10：添加连接对话框
- en: On Windows, you need to select TCP Connection and specify the URI where Docker
    daemon is listening. You can find the URI in Docker settings, in General tab.
    Make sure Expose daemon on... option is selected. Copy the TCP URI from this option
    and paste it in TCP Connection | URI textbox in the dialog box shown in *Fig.
    12.10*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，您需要选择TCP连接并指定Docker守护进程监听的URI。您可以在Docker设置中的“常规”选项卡中找到URI。请确保已选中“在...公开守护进程”选项。从该选项复制TCP
    URI并将其粘贴到对话框中*图12.10*所示的“TCP连接 | URI”文本框中。
- en: Once the connection is added successfully, you will see lists of existing containers
    and images, if any, on your local machine.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦成功添加连接，您将看到您本地机器上现有容器和图像的列表，如果有。
- en: Creating a Docker network
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Docker网络
- en: 'We are going to deploy two servers in two separate Docker containers in the
    same machine: a MySQL DB server and an application server to run our microservice.
    The application server will need to know about the DB server to access it. The
    recommended way to allow two Docker containers to access each other is by deploying
    them in the same Docker network. A complete discussion of Docker networks is out
    of scope of this book, so readers are encouraged to read about Docker networks
    at [https://docs.docker.com/engine/userguide/networking](https://docs.docker.com/engine/userguide/networking).'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在同一台机器上的两个不同的Docker容器中部署两个服务器：一个MySQL数据库服务器和一个运行我们的微服务的应用服务器。应用服务器需要知道数据库服务器以便访问它。允许两个Docker容器相互访问的推荐方法是部署它们在同一个Docker网络中。关于Docker网络的完整讨论超出了本书的范围，因此鼓励读者阅读有关Docker网络的文档[https://docs.docker.com/engine/userguide/networking](https://docs.docker.com/engine/userguide/networking)。
- en: 'Knowing that the two containers we are going to create shortly need to run
    in the same Docker network, let’s create a Docker network by running the following
    command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 知道我们即将创建的两个容器需要在同一个Docker网络中运行，让我们通过运行以下命令来创建一个Docker网络：
- en: '[PRE22]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this command, `coursemanagment` is the name of the network we are creating.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在此命令中，`coursemanagment`是我们正在创建的网络名称。
- en: Creating MySQL container
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建MySQL容器
- en: We have been using a MySQL server installed on the host machine so far in this
    book. We will now see how to create a Docker container with MySQL. If you are
    running an instance of MySQL on your host OS (the OS in which Docker is running),
    then stop the instance or configure MySQL to run on a different port than `3306`
    in the Docker container (we will see how to do this shortly).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们迄今为止一直在使用安装在主机机器上的MySQL服务器。现在我们将看到如何创建一个带有MySQL的Docker容器。如果你在你的主机操作系统（Docker运行的操作系统）上运行MySQL实例，那么停止该实例或将MySQL配置为在Docker容器中不同于`3306`的端口上运行（我们很快就会看到如何做到这一点）。
- en: 'We will use the official MySQL Docker image; see [https://hub.docker.com/_/mysql/](https://hub.docker.com/_/mysql/).
    Run the following command:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用官方的MySQL Docker镜像；请参阅[https://hub.docker.com/_/mysql/](https://hub.docker.com/_/mysql/)。运行以下命令：
- en: '[PRE23]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Replace `your_password` with the root password you want to set. This command
    will install the latest version of MySQL. The `-d` option runs the container in
    detached/background mode. Also note that the container is created in the `coursemanagement`
    network that we created in the previous section. If you want to use a specific
    version of MySQL, then tag that version; for example, to install MySQL Version
    5.5.58, use the following command:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将`your_password`替换为你想要设置的root密码。此命令将安装MySQL的最新版本。`-d`选项以分离/后台模式运行容器。此外，请注意，容器是在我们之前创建的`coursemanagement`网络中创建的。如果你想要使用MySQL的特定版本，那么标记该版本；例如，要安装MySQL版本5.5.58，请使用以下命令：
- en: '[PRE24]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`MySQL` will run on port `3306` in the container, and the container exposes
    the service at the same port on the host machine. To expose this service at a
    different port on the host machine, say port `3305`, use the `–p` or `--publish`
    option:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`MySQL`将在容器中运行于端口`3306`，并且容器会在主机机器上以相同的端口暴露服务。若要在主机机器上以不同的端口（例如端口`3305`）暴露此服务，请使用`–p`或`--publish`选项：'
- en: '[PRE25]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `-p` option in this command maps port `3306` in the Docker container to
    port `3305` on the host machine.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令中的`-p`选项将Docker容器中的端口`3306`映射到主机机器上的端口`3305`。
- en: 'Once the command is executed successfully, you can verify that the container
    is running by executing the `docker ps` command. The container will also be visible
    in Docker Explorer in Eclipse. Switch to the Docker Tooling perspective in Eclipse
    and expand the Containers group under the Local connection:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦命令执行成功，你可以通过执行`docker ps`命令来验证容器正在运行。容器也将出现在Eclipse的Docker Explorer中。切换到Eclipse的Docker
    Tooling视角，并展开Local connection下的Containers组：
- en: '![](img/00234.jpeg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00234.jpeg)'
- en: 'Figure 12.11: Docker Explorer listing containers and images'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11：Docker Explorer列出容器和镜像
- en: Right-click on the container name to show menu options for different actions
    on the container, such as Start, Stop, and Restart.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击容器名称以显示对容器执行不同操作（如启动、停止和重启）的菜单选项。
- en: 'The Execute Shell option is very useful for opening a shell in the container
    and executing commands. For example, to execute MySQL commands from within the
    container, select the Execute Shell option and execute the `mysql -u root –p`
    command:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 执行Shell选项非常有用，可以在容器中打开shell并执行命令。例如，要从容器内部执行MySQL命令，请选择执行Shell选项并执行`mysql -u
    root –p`命令：
- en: '![](img/00235.jpeg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00235.jpeg)'
- en: 'Figure 12.12: The Execute Shell in a Docker container'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.12：在 Docker 容器中执行 Shell
- en: 'Assuming you have mapped port `3306` from the container to the same port on
    the host machine, you can connect to the instance of MySQL in the container from
    the host machine as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已将容器中的端口 `3306` 映射到主机机器上的相同端口，您可以从主机机器连接到容器中的 MySQL 实例，如下所示：
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Make sure you specify the `-h` or `--host` option, or it will try to connect
    using the local `.sock` file and that will fail. You can also connect to this
    MySQL instance from MySQL Workbench.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您指定了 `-h` 或 `--host` 选项，否则它将尝试使用本地的 `.sock` 文件进行连接，这将失败。您也可以从 MySQL Workbench
    连接到这个 MySQL 实例。
- en: Next, create the `course_management` schema in the database. See the *Setting
    up Database* section of this chapter for details.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在数据库中创建 `course_management` 模式。有关详细信息，请参阅本章的 *设置数据库* 部分。
- en: 'If you do not want to type long Docker commands and remember options, you can
    use Docker Explorer’s user interface to create containers. We used the `run` command
    of Docker to run a MySQL container using the `mysql` image. The command first
    checks whether the required image is already downloaded on the local machine,
    and if not, it downloads it. Docker images can also be downloaded explicitly using the `docker
    pull` command. For example, we could have first downloaded the `mysql` image by
    executing the following command:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想输入长的 Docker 命令并记住选项，可以使用 Docker Explorer 的用户界面来创建容器。我们使用 Docker 的 `run`
    命令通过 `mysql` 镜像运行 MySQL 容器。该命令首先检查所需的镜像是否已经下载到本地机器上，如果没有，则下载它。也可以使用 `docker pull`
    命令显式下载 Docker 镜像。例如，我们首先可以通过执行以下命令下载 `mysql` 镜像：
- en: '[PRE27]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once the image is downloaded, it will be displayed in Docker Explorer. Right-click
    the image and select Run:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 下载镜像后，它将在 Docker 探索器中显示。右键单击镜像并选择运行：
- en: '![](img/00236.jpeg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00236.jpeg)'
- en: 'Figure 12.13: Create Docker container from image in Docker Explorer'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.13：在 Docker 探索器中从镜像创建 Docker 容器
- en: Follow the wizard to create a container. You can use this option to create multiple
    instances from the same image, for example, to run multiple MySQL containers.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 按照向导创建一个容器。您可以使用此选项从相同的镜像创建多个实例，例如，运行多个 MySQL 容器。
- en: The last page in this wizard lets you specify a network for the container.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在此向导的最后一页，您可以指定容器的网络。
- en: Deploying microservices in a Docker container
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Docker 容器中部署微服务
- en: We will now deploy the `CourseManagement` microservice that we created earlier
    in this chapter (the one using WildFly Swarm) in a Docker container. You can either
    copy the project and paste it in Eclipse Project Explorer with a different name,
    or use the same project. The example code has a project called `coursemanagement-docker`
    for this section.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在此章中创建的 `CourseManagement` 微服务（使用 WildFly Swarm）部署到 Docker 容器中。您可以选择复制项目并将其粘贴到
    Eclipse 项目资源管理器中，使用不同的名称，或者使用相同的项目。示例代码中有一个名为 `coursemanagement-docker` 的项目用于本节。
- en: We need to make one change in `persistence.xml`. Recall that in our earlier
    example, the JDBC URL in this file referred to `127.0.0.1` or localhost. This
    worked then because both the application and the database were running in the
    same environment. But now our database and application are going to run in separate
    Docker containers, with isolated runtime environments. Therefore, we can no longer
    access the database using the localhost URL in the microservice. So, how do we
    access a database running in a separate container? The answer is using the container
    name, if both containers are running in the same Docker network mode. We configured
    the container for the DB to run in the `coursemanagment` network, and later in
    this section we are going to do the same for the microservice container. So, we
    will need to change the JDBC URL in `persistence.xml` to refer to name of the
    container running our database server, which is `course-management-mysql`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 `persistence.xml` 中进行一项更改。回想一下，在我们之前的示例中，此文件中的 JDBC URL 指的是 `127.0.0.1`
    或本地主机。那时这可行，因为应用程序和数据库都在同一环境中运行。但现在我们的数据库和应用程序将分别在单独的 Docker 容器中运行，具有隔离的运行时环境。因此，我们不能再使用微服务中的
    localhost URL 访问数据库。那么，我们如何访问在单独容器中运行的数据库呢？答案是使用容器名称，如果两个容器都在相同的 Docker 网络模式下运行。我们已将数据库容器的容器配置为在
    `coursemanagment` 网络中运行，在本节的后面我们将对微服务容器做同样的操作。因此，我们需要将 `persistence.xml` 中的 JDBC
    URL 更改为指向运行数据库服务器的容器名称，该名称为 `course-management-mysql`。
- en: 'Open `persistence.xml` and replace IP `127.0.0.1` in the JDBC URL with `course-management-mysql`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `persistence.xml` 并将 JDBC URL 中的 IP `127.0.0.1` 替换为 `course-management-mysql`：
- en: '[PRE28]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, create a file named Dockerfile in root of the project with the following
    content:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在项目的根目录中创建一个名为Dockerfile的文件，内容如下：
- en: '[PRE29]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We will be using this Dockerfile to create the image for our microservice container.
    Let’s understand each of the instructions in this file:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个Dockerfile来创建我们的微服务容器的镜像。让我们理解这个文件中的每条指令：
- en: '`FROM openjdk:8`: The base image for this container is OpenJDK, Version 8.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM openjdk:8`: 这个容器的基镜像是OpenJDK，版本8。'
- en: '`ENV swarm.http.port 8080`: We are setting the `swarm.http.port` environment
    variable in the container. This is really not necessary for this example, because
    the WildFly Swarm server runs on port `8080` by default. Change the port number
    if you want to run the server on a different port.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENV swarm.http.port 8080`: 我们正在设置容器中的`swarm.http.port`环境变量。在这个示例中，这实际上并不是必要的，因为WildFly
    Swarm服务器默认运行在端口`8080`。如果你想将服务器运行在不同的端口上，请更改端口号。'
- en: '`RUN mkdir microservices`: We are creating a folder named `microservices` in
    the container.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN mkdir microservices`: 我们在容器中创建一个名为`microservices`的文件夹。'
- en: '`COPY ./target/coursemanagement-swarm.jar ./microservices`: We are `copying
    coursemanagement-swarm.jar` from the target folder in our project to the `microservices`
    folder in the container.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COPY ./target/coursemanagement-swarm.jar ./microservices`: 我们正在将项目中的目标文件夹中的`coursemanagement-swarm.jar`复制到容器的`microservices`文件夹中。'
- en: '`EXPOSE 8080`:  We ask Docker Engine to expose port `8080` from the container.
    Our application server listens for requests on port `8080` in the container.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPOSE 8080`: 我们请求Docker引擎从容器中暴露端口`8080`。我们的应用程序服务器在容器中监听端口`8080`上的请求。'
- en: '`ENTRYPOINT java -jar -Djava.net.preferIPv4Stack=true ./microservices/coursemanagement-swarm.jar`: Finally,
    we specify the main application to execute in the container, which is running
    the standalone microservice application.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT java -jar -Djava.net.preferIPv4Stack=true ./microservices/coursemanagement-swarm.jar`:
    最后，我们指定在容器中执行的主应用程序，该应用程序运行独立的微服务应用程序。'
- en: 'We need to build the application to create a single JAR file that we will run
    in the Docker container. If you try to build the application by running the Maven
    goal `wildfly-swarm:run` (we did that to run the application earlier), it is going
    to fail because it will also try to run the application. This is not going to
    work because we modified the JDBC URL in `persistence.xml` with the name of the
    DB container. So, run the Maven goal to only package the application, without
    running tests. Right-click on the project in Project Explorer and select Run As
    | Maven Build:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要构建应用程序以创建一个单一的JAR文件，我们将在Docker容器中运行它。如果你尝试通过运行Maven目标`wildfly-swarm:run`（我们之前这样做来运行应用程序）来构建应用程序，它将会失败，因为它也会尝试运行应用程序。这不会工作，因为我们修改了`persistence.xml`中的JDBC
    URL，使用了DB容器的名称。因此，运行Maven目标仅打包应用程序，不运行测试。在项目资源管理器中右键单击项目，选择“运行方式”|“Maven构建”：
- en: '![](img/00237.jpeg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00237.jpeg)'
- en: 'Figure 12.14: Eclipse run configuration to package the Docker-microservice
    project'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.14：Eclipse运行配置以打包Docker-microservice项目
- en: Enter `package` in the Goals field. Select the Skip Tests option and click Run
    to create the application JAR file in the target folder.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在“目标”字段中输入`package`。选择跳过测试选项，然后点击运行以在目标文件夹中创建应用程序JAR文件。
- en: Let’s now create the Docker image from the Dockerfile we created. Right-click
    on the file in Project Explorer and select the Run As | Docker Image Build menu
    option.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们从我们创建的Dockerfile创建Docker镜像。在项目资源管理器中右键单击文件，然后选择“运行方式”|“Docker镜像构建”菜单选项。
- en: '![](img/00238.jpeg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00238.jpeg)'
- en: 'Figure 12.15: Building a Docker image from a Dockerfile'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.15：从Dockerfile构建Docker镜像
- en: This will create a Docker image named coursemanagement-microservice and tag
    it as the 1.0 version. Switch to the Docker Tooling perspective in Eclipse and
    you should see this image listed.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`coursemanagement-microservice`的Docker镜像，并标记为1.0版本。切换到Eclipse中的Docker工具视图，你应该能看到这个镜像列出来。
- en: 'We are going to create an instance of this image, that is, create a container
    from this image that will actually run our microservice. Right-click on the image
    and select Run...:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建这个镜像的一个实例，也就是说，从这个镜像创建一个容器，这个容器将实际运行我们的微服务。在镜像上右键单击，然后选择“运行...”：
- en: '![](img/00239.jpeg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00239.jpeg)'
- en: 'Figure 12.16: Creating a container from an image'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.16：从镜像创建容器
- en: 'This opens a wizard to configure the container:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开一个向导来配置容器：
- en: '![](img/00240.jpeg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00240.jpeg)'
- en: 'Figure 12.17: Configuring a Docker container'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.17：配置Docker容器
- en: Specify a name for the container in the first page of the wizard. Leave Endpoint
    and Command empty; the image is already created with the `ENTRYPOINT` that we
    specified in the Dockerfile. You can override that in this page, but we are not
    going to do that.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在向导的第一页中为容器指定一个名称。留空端点和命令；镜像已经通过 Dockerfile 中我们指定的 `ENTRYPOINT` 创建。你可以在这一页中覆盖它，但我们不会这么做。
- en: Make sure the Publish all exposed ports to random ports on the host interfaces
    option is unchecked. We want to publish port `8080` from the container as the
    same port number to the host. Click Next. Leave the default options on the second
    page and click Next again.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 确保未勾选“将所有公开端口发布到主机接口上的随机端口”选项。我们希望将容器的端口 `8080` 以相同的端口号发布到主机。点击下一步。在第二页上保留默认选项，然后再次点击下一步。
- en: '![](img/00241.jpeg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00241.jpeg)'
- en: 'Figure 12.18: Setting network mode for a Docker container'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.18：设置 Docker 容器的网络模式
- en: The last page (see *Figure 12.18*) allows you to specify a network for the container.
    Here, we are going to specify the network we created earlier, `coursemanagement`.
    Recall that we also created a MySQL container with the same network, so that microservice
    container can access the MySQL container with the container name.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一页（见 *图 12.18*）允许你为容器指定一个网络。在这里，我们将指定我们之前创建的网络，`coursemanagement`。回想一下，我们还创建了一个具有相同网络名称的
    MySQL 容器，这样微服务容器就可以通过容器名称访问 MySQL 容器。
- en: Once the application starts in the microservice container, browse to `http://localhost:8080/course_management/courses`
    and you should see list of courses in the database.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序在微服务容器中启动，请浏览到 `http://localhost:8080/course_management/courses`，你应该能看到数据库中的课程列表。
- en: The process to deploy the microservice we created using Spring Boot earlier
    is also similar to the one we saw in this section. One main difference is that
    in the Spring Boot project, you need to update the JDBC URL in `application.properties`,
    instead of the `persistence.xml` that we modified in this section. For your reference,
    the sample code has a project named `coursemanagementspring-docker`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Spring Boot 创建的微服务的部署过程与我们在本节中看到的类似。主要区别在于，在 Spring Boot 项目中，你需要更新 `application.properties`
    中的 JDBC URL，而不是本节中我们修改的 `persistence.xml`。供你参考，示例代码有一个名为 `coursemanagementspring-docker`
    的项目。
- en: Running containers using Docker Compose
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 运行容器
- en: We have seen in the preceding sections how to create Docker containers separately
    by running command-line Docker commands (or from Eclipse plugins). If you want
    to run multiple containers on a host machine, you should consider using Docker
    Compose. It allows you to configure multiple Docker containers in one file and
    also specify dependencies between them. A `docker-compose` command reads configuration/instructions
    from `docker-compose.yml`, and creates and runs containers. The `.yml` file requires
    the version number of `docker-compose` at the top, followed by a services section,
    which lists container definitions—specifying image or Dockerfile location, environment
    variables to be set in the container, ports to be exposed and mapped to the host
    OS, and many other configurations. See [https://docs.docker.com/compose/overview/](https://docs.docker.com/compose/overview/)
    for more details.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经看到了如何通过运行命令行 Docker 命令（或从 Eclipse 插件）单独创建 Docker 容器。如果你想在主机机器上运行多个容器，你应该考虑使用
    Docker Compose。它允许你在一个文件中配置多个 Docker 容器，并指定它们之间的依赖关系。一个 `docker-compose` 命令从 `docker-compose.yml`
    读取配置/指令，创建并运行容器。`.yml` 文件需要在顶部指定 `docker-compose` 的版本号，然后是服务部分，其中列出容器定义——指定镜像或
    Dockerfile 位置、要在容器中设置的环境变量、要公开并映射到主机 OS 的端口，以及许多其他配置。有关更多详细信息，请参阅 [https://docs.docker.com/compose/overview/](https://docs.docker.com/compose/overview/)。
- en: In this section, we will use `docker-compose` to run MySQL and our webservice
    containers together. In the later chapter on deploying JEE applications in the
    cloud, we will use this configuration for deployment. First, install `docker-compose`
    from [https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 `docker-compose` 同时运行 MySQL 和我们的 webservice 容器。在后续章节中关于在云中部署 JEE
    应用程序的部分，我们将使用此配置进行部署。首先，从 [https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/)
    安装 `docker-compose`。
- en: Create a new General Eclipse project (File | New | Project and then General
    | Project) and name it `coursemanagement-docker-compose`. We don’t need a JEE
    project for this section because we are going to take the single JAR file that
    we created in the last section for our microservice and deploy it in a Docker
    container. So, copy `coursemanagementspring-docker/coursemanagementspring-0.0.1-SNAPSHOT.jar`
    to the project folder.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的通用 Eclipse 项目（文件 | 新建 | 项目，然后通用 | 项目），并将其命名为 `coursemanagement-docker-compose`。我们不需要
    JEE 项目，因为我们将使用上一节中创建的单个 JAR 文件作为我们的微服务，并将其部署在 Docker 容器中。因此，将 `coursemanagementspring-docker/coursemanagementspring-0.0.1-SNAPSHOT.jar`
    复制到项目文件夹。
- en: We need to create and initialize a MySQL database in the container. We are going
    to use a SQL script with **data definition language** (**DDL** for example, `CREATE`)
    statements to create database schema and tables. The source code project for this
    section, `coursemanagement-docker-compose`, has a file, `course-management-db.sql`,
    containing DDL statements. This script creates empty tables with no data.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在容器中创建和初始化一个 MySQL 数据库。我们将使用包含数据定义语言（例如，`CREATE`）语句的 SQL 脚本来创建数据库模式和表。本节源代码项目
    `coursemanagement-docker-compose` 有一个名为 `course-management-db.sql` 的文件，其中包含 DDL
    语句。此脚本创建空表，不包含数据。
- en: If you want also to export data from your existing database, then you can create
    the script from MySQL Workbench. From MySQL Workbench, select Server | Data Export.
    Select the schema to export, `course_management`. From the drop-down options,
    select Dump Structure and Data. In Export Options, select Export to Self-Contained
    File and specify the path of the file, for example, `<your_project_path>/course-management-db.sql`.
    Then, click the Start Export button.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还想从现有的数据库导出数据，则可以创建 MySQL Workbench 中的脚本。从 MySQL Workbench 中，选择服务器 | 数据导出。选择要导出的模式，`course_management`。从下拉选项中选择导出结构和数据。在导出选项中，选择导出到自包含文件，并指定文件路径，例如，`<your_project_path>/course-management-db.sql`。然后，单击开始导出按钮。
- en: 'Now, let’s create two Dockerfiles in the project:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在项目中创建两个 Dockerfile：
- en: '`course-management-db.dockerfile` for the MySQL container'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`course-management-db.dockerfile` 用于 MySQL 容器'
- en: '`course-management-service.dockerfile` for the microservice container'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`course-management-service.dockerfile` 用于微服务容器'
- en: 'Create `course-management-db.dockerfile` with the following content:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下内容创建 `course-management-db.dockerfile`：
- en: '[PRE30]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With the `COPY` statement in this file, we are copying `course-management-db.sql`
    from the project folder to the `docker-entrypoint-initdb.d` folder in the container.
    Any SQL script in this file will be executed by the base MySQL image to initialize
    the database. See the *Initializing a fresh instance* section at [https://hub.docker.com/_/mysql/](https://hub.docker.com/_/mysql/).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中的 `COPY` 语句中，我们将 `course-management-db.sql` 从项目文件夹复制到容器中的 `docker-entrypoint-initdb.d`
    文件夹。此文件中的任何 SQL 脚本都将由基础 MySQL 镜像执行以初始化数据库。请参阅 [https://hub.docker.com/_/mysql/](https://hub.docker.com/_/mysql/)
    中的 *初始化新实例* 部分。
- en: 'Create `course-management-service.dockerfile` with the following content:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下内容创建 `course-management-service.dockerfile`：
- en: '[PRE31]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this Dockerfile, we are creating the container from the `openjdk:8` base
    image. Then, we are creating a folder, `microservices`, in the container and then
    copying `coursemanagementspring-0.0.1-SNAPSHOT.jar` from the project folder to the
    `microservices` folder in the container. We then set the `ENTRYPOINT` for the
    container with the command to execute the copied JAR file.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在此 Dockerfile 中，我们使用 `openjdk:8` 基础镜像创建容器。然后，我们在容器中创建一个名为 `microservices` 的文件夹，并将
    `coursemanagementspring-0.0.1-SNAPSHOT.jar` 从项目文件夹复制到容器中的 `microservices` 文件夹。然后，我们使用执行复制的
    JAR 文件的命令设置容器的 `ENTRYPOINT`。
- en: 'Lastly, create `docker-compose.yml` with the following content:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，创建 `docker-compose.yml`，内容如下：
- en: '[PRE32]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We are creating two services in this file: `course-managemnt-db` for the DB
    container and `course-management-service` for the microservice container. Both
    are built from separate Dockerfiles. The context field specifies the path of the
    folder containing the Dockerfile; in this case it is the present folder (which
    is the project folder). Note that we have specified the dependency of `course-management-service`
    container on `course-managemnt-db`. This results in the DB container getting started
    before the microservice container.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中，我们创建了两个服务：`course-managemnt-db` 用于数据库容器和 `course-management-service` 用于微服务容器。两者都是基于单独的
    Dockerfile 构建的。上下文字段指定包含 Dockerfile 的文件夹路径；在这种情况下，它是当前文件夹（即项目文件夹）。请注意，我们已指定 `course-management-service`
    容器对 `course-managemnt-db` 的依赖。这导致数据库容器在微服务容器之前启动。
- en: We are mapping port `8080` from the microservice container to port `80` on the
    host. The reason is that we are going to deploy these services later in the cloud
    with the default web server on port `80`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将微服务容器的端口`8080`映射到主机的端口`80`。原因是我们将稍后在云中部署这些服务，并使用默认的Web服务器在端口`80`上。
- en: '**Warning** The deployment of JEE container in this chapter is meant for the
    purpose of development and testing only. It is not meant for production and does
    not follow best practices for a production environment. That falls under the realm
    of DevOps, which is not within the scope of this book.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**本章中JEE容器的部署仅用于开发和测试目的。它不适用于生产环境，也不遵循生产环境最佳实践。这属于DevOps的范畴，而不在本书的范围之内。'
- en: Since both the services are in the same `docker-compose.yml`, `docker-compose`
    creates a network and adds both containers to the network. So, the `course-management-service`
    container can access the `course-management-mysql` container by its name. We do
    not need to create a separate network as we did in the previous section.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个服务都在同一个`docker-compose.yml`文件中，`docker-compose`创建了一个网络并将两个容器都添加到该网络中。因此，`course-management-service`容器可以通过其名称访问`course-management-mysql`容器。我们不需要像上一节那样创建一个单独的网络。
- en: See the `docker-compose` file reference at [https://docs.docker.com/compose/compose-file/](https://docs.docker.com/compose/compose-file/)
    for more configuration options.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[https://docs.docker.com/compose/compose-file/](https://docs.docker.com/compose/compose-file/)以获取更多配置选项的`docker-compose`文件参考。
- en: 'To start all the containers configured in `docker-compose.yml` together, run the
    following command from the Command Prompt (make sure port `80` is not taken by
    another process, because we have mapped microservice container port `8080` to
    port `80` on the host):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 要一起启动`docker-compose.yml`中配置的所有容器，请从命令提示符运行以下命令（确保端口`80`没有被其他进程占用，因为我们已经将微服务容器的端口`8080`映射到主机的端口`80`）：
- en: '[PRE33]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Once the containers have started successfully, browse to `http://localhost/course_management/courses`
    and you should see a list of courses, or an empty list if there are no courses
    in the database.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦容器成功启动，请浏览到`http://localhost/course_management/courses`，你应该会看到课程列表，如果没有课程在数据库中，则显示空列表。
- en: 'To run containers in detached/background mode, run the following command:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要以分离/后台模式运行容器，请运行以下命令：
- en: '[PRE34]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To stop containers started with `docker-compose`, run the following command:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止使用`docker-compose`启动的容器，请运行以下命令：
- en: '[PRE35]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you make any changes to Dockerfiles or to `docker-compose.yml`, then you
    need to rebuild the images. Run the following command to do so:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你修改了Dockerfile或`docker-compose.yml`，那么你需要重新构建镜像。运行以下命令来完成此操作：
- en: '[PRE36]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Refer to [https://docs.docker.com/compose/reference/overview/](https://docs.docker.com/compose/reference/overview/)
    for details on `docker-compose` command-line options.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考[https://docs.docker.com/compose/reference/overview/](https://docs.docker.com/compose/reference/overview/)获取关于`docker-compose`命令行选项的详细信息。
- en: Summary
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: A microservice is a small application serving a single use case. Microservices
    are typically REST services and can be deployed quickly. Docker containers are
    ideally suited to deploying microservices because they allow applications to run
    in isolation, with little or no difference in development, testing, and production
    environments. Docker containers can also be deployed very quickly and can scale
    well.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是一个为单个用例提供服务的应用程序。微服务通常是REST服务，可以快速部署。Docker容器非常适合部署微服务，因为它们允许应用程序在隔离的环境中运行，在开发、测试和生产环境之间几乎没有差异。Docker容器也可以非常快速地部署，并且可以很好地扩展。
- en: In this chapter, we saw how to develop microservices using WildFly Swarm and
    Spring Boot. We created a simple microservice to list courses for our *Course
    Management* application. The concepts we learned can be extended to create microservices
    using other frameworks. We also learned how to deploy these services in Docker
    containers using the Eclipse plugin for Docker Tooling.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用WildFly Swarm和Spring Boot开发微服务。我们创建了一个简单的微服务来列出我们的*课程管理*应用程序的课程。我们学到的概念可以扩展到使用其他框架创建微服务。我们还学习了如何使用Docker
    Tooling的Eclipse插件将这些服务部署到Docker容器中。
- en: In the next chapter, we will learn how to deploy a JEE application in the cloud.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何在云中部署JEE应用程序。
