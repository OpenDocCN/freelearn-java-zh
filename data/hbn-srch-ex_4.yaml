- en: Chapter 4. Advanced Mapping
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。高级映射
- en: So far, we have learned the basics of mapping objects to Lucene indexes. We
    have seen how to handle relationships with associated entities and embedded objects.
    However, the searchable fields have mostly been simple string data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了将对象映射到Lucene索引的基本知识。我们看到了如何处理与相关实体和嵌入对象的关系。然而，可搜索的字段大多是简单的字符串数据。
- en: In this chapter, we will look at how to effectively map other data types. We
    will explore the process by which Lucene analyzes entities for indexing, and the
    Solr components that can customize that process. We will see how to adjust the
    importance of each field, to make sorting by relevance more meaningful. Finally,
    we will conditionally determine whether or not to index an entity at all, based
    on its state at runtime.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何有效地映射其他数据类型。我们将探讨Lucene为索引分析实体以及可以自定义该过程的Solr组件的过程。我们将了解如何调整每个字段的重要性，使按相关性排序更有意义。最后，我们将根据运行时实体的状态条件性地确定是否索引实体。
- en: Bridges
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 桥梁
- en: The member variables in a Java class may be of an infinite number of custom
    types. It is usually possible to create custom types in your database as well.
    With Hibernate ORM, there are dozens of basic types from which more complex types
    can be constructed.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Java类中的成员变量可能是无数的自定义类型。通常，您也可以在自己的数据库中创建自定义类型。使用Hibernate ORM，有数十种基本类型，可以构建更复杂的类型。
- en: However, in a Lucene index, everything ultimately boils down to a string. When
    you map fields of any other data type for searching, the field is converted to
    a string representation. In Hibernate Search terminology, the code behind this
    conversion is called a bridge. Default bridges handle most common situations for
    you transparently, although you have the ability to write your own bridges for
    custom scenarios.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Lucene索引中，一切最终都归结为字符串。当你为搜索映射其他数据类型的字段时，该字段被转换为字符串表示。在Hibernate Search术语中，这种转换背后的代码称为桥梁。默认桥梁为您处理大多数常见情况，尽管您有能力为自定义场景编写自己的桥梁。
- en: One-to-one custom conversion
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一对一自定义转换
- en: The most common mapping scenario is where a single Java property is tied to
    a single Lucene index field. The `String` variables obviously don't require any
    conversion. With most other common data types, how they would be expressed as
    strings is fairly intuitive.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的映射场景是一个Java属性与一个Lucene索引字段绑定。`String`变量显然不需要任何转换。对于大多数其他常见数据类型，它们作为字符串的表达方式相当直观。
- en: Mapping date fields
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射日期字段
- en: The `Date` values are adjusted to GMT time, and then stored as a string with
    the format `yyyyMMddHHmmssSSS`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date`值被调整为GMT时间，然后以`yyyyMMddHHmmssSSS`的格式存储为字符串。'
- en: Although this all happens automatically, you do have the option to explicitly
    annotate the field with `@DateBridge`. You would do so when you don't want to
    index down to the exact millisecond. This annotation has one required element,
    `resolution`, which lets you choose a level of granularity from `YEAR`, `MONTH`,
    `DAY`, `HOUR`, `MINUTE`, `SECOND`, or `MILLISECOND` (the normal default).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这一切都是自动发生的，但你确实可以选择显式地将字段注解为`@DateBridge`。当你不想索引到确切的毫秒时，你会这样做。这个注解有一个必需的元素`resolution`，让你从`YEAR`、`MONTH`、`DAY`、`HOUR`、`MINUTE`、`SECOND`或`MILLISECOND`（正常默认）中选择一个粒度级别。
- en: The downloadable `chapter4` version of the VAPORware Marketplace application
    now adds a `releaseDate` field to the `App` entity. It is configured such that
    Lucene will only store the day, and not any particular time of day.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 可下载的`chapter4`版本的VAPORware Marketplace应用现在在`App`实体中添加了一个`releaseDate`字段。它被配置为仅存储日期，而不存储具体的一天中的任何时间。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Handling null values
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理null值
- en: By default, fields with null values are not indexed regardless of their type.
    However, you can also customize this behavior. The `@Field` annotation has an
    optional element, `indexNullAs` , which controls the handling of null values for
    that mapped field.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，无论其类型如何，带有null值的字段都不会被索引。然而，您也可以自定义这种行为。`@Field`注解有一个可选元素`indexNullAs`，它控制了映射字段的null值的处理。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The default setting for this element is `Field.DO_NOT_INDEX_NULL`, which causes
    null values to be omitted from Lucene indexing. However, when `Field.DEFAULT_NULL_TOKEN`
    is used, Hibernate Search will index the field with a globally configured value.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此元素的默认设置是`Field.DO_NOT_INDEX_NULL`，这导致null值在Lucene索引中被省略。然而，当使用`Field.DEFAULT_NULL_TOKEN`时，Hibernate
    Search将使用一个全局配置的值索引该字段。
- en: The name for this value is `hibernate.search.default_null_token`, and it is
    set within `hibernate.cfg.xml` (for traditional Hibernate ORM) or `persistence.xml`
    (for Hibernate configured as a JPA provider). If this value is not configured,
    then null fields will be indexed with the string `"_null_"`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值的名称是`hibernate.search.default_null_token`，它是在`hibernate.cfg.xml`（对于传统的Hibernate
    ORM）或`persistence.xml`（对于作为JPA提供者的Hibernate）中设置的。如果这个值没有配置，那么空字段将被索引为字符串`"_null_"`。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may use this mechanism to apply null-substitution on some fields, and keep
    the default behavior on other fields. However, the `indexNullAs` element only
    works with that one substitute value, configured at the global level. If you want
    to use different null substitutes for different fields or in different scenarios,
    you must implement that logic through a custom bridge (discussed in the following
    subsection).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这个机制对某些字段进行空值替换，而保持其他字段的行为。然而，`indexNullAs`元素只能与在全局级别配置的那个替代值一起使用。如果您想要为不同的字段或不同的场景使用不同的空值替代，您必须通过自定义桥接实现那个逻辑（在下一小节中讨论）。
- en: Custom string conversion
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义字符串转换
- en: Sometimes you need more flexibility in converting a field to a string value.
    Rather than relying on the built-in bridge to handle it automatically, you can
    create your own custom bridge.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您需要在将字段转换为字符串值方面具有更多的灵活性。而不是依赖内置的桥接自动处理，您可以创建自己的自定义桥接。
- en: StringBridge
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: StringBridge
- en: To map a single Java property to a single index field, your bridge can implement
    one of two interfaces offered by Hibernate Search. The first of these, `StringBridge`,
    is for a one-way translation between a property and a string value.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要将对单个Java属性的映射映射到一个索引字段上，您的桥接可以实现Hibernate Search提供的两个接口中的一个。第一个，`StringBridge`，是为了在属性和字符串值之间进行单向翻译。
- en: Let's say that our `App` entity has a `currentDiscountPercentage` member variable,
    representing any promotional discount being offered for that app (for example,
    *25 percent off!*). For easier math operations, this field is stored as a float
    (*0.25f*). However, if we ever wanted to make discounts searchable, we would want
    them indexed in a more human-readable percentage format (*25*).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的`App`实体有一个`currentDiscountPercentage`成员变量，表示该应用程序正在提供的任何促销折扣（例如，*25% 折扣!*）。为了更容易进行数学运算，这个字段被存储为浮点数(*0.25f*)。然而，如果我们想要使折扣可搜索，我们希望它们以更易读的百分比格式(*25*)进行索引。
- en: 'To provide that mapping, we would start by creating a bridge class, implementing
    the `StringBridge` interface. The bridge class must implement an `objectToString`
    method, which expects to take our `currentDiscountPercentage` property as an input
    parameter:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供这种映射，我们首先需要创建一个桥接类，实现`StringBridge`接口。桥接类必须实现一个`objectToString`方法，该方法期望将我们的`currentDiscountPercentage`属性作为输入参数：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `objectToString` method converts the input as desired, and returns its `String`
    representation. This will be the value indexed by Lucene.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`objectToString`方法按照预期转换输入，并返回其`String`表示。这将是由Lucene索引的值。'
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that this method returns a hardcoded `"0"` when given a null value, or
    when it encounters any other sort of problem. Custom null-handling is another
    possible reason for creating a field bridge.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当给定一个空值时，或者当遇到任何其他问题时，这个方法返回一个硬编码的`"0"`。自定义空值处理是创建字段桥接的另一个可能原因。
- en: 'To invoke this bridge class at index-time, add a `@FieldBridge` annotation
    to the `currentDiscountPercentage` property:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要在索引时间调用这个桥接类，请将`@FieldBridge`注解添加到`currentDiscountPercentage`属性上：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This entity field is a primitive `float`, yet the bridge class is working with
    a `Float` wrapper object. For flexibility, `objectToString` takes a generic `Object`
    parameter that must be cast to the appropriate type. However, thanks to autoboxing,
    primitives are converted into their object wrappers for us seamlessly.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实体字段是一个原始`float`，然而桥接类却在与一个`Float`包装对象一起工作。为了灵活性，`objectToString`接受一个泛型`Object`参数，该参数必须转换为适当的类型。然而，多亏了自动装箱，原始值会自动转换为它们的对象包装器。
- en: TwoWayStringBridge
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: TwoWayStringBridge
- en: The second interface for mapping single variables to single fields, `TwoWayStringBridge`,
    provides bidirectional translation between a value and its string representation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个接口用于将单个变量映射到单个字段，`TwoWayStringBridge`，提供双向翻译，在值及其字符串表示之间进行翻译。
- en: 'You implement `TwoWayStringBridge` in a manner similar to what we just saw
    with the regular `StringBridge` interface. The only difference is that this bidirectional
    version also requires a `stringToObject` method, for conversions going the other
    way:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`TwoWayStringBridge`的方式与刚刚看到的常规`StringBridge`接口类似。唯一的区别是，这个双向版本还要求有一个`stringToObject`方法，用于反向转换：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A bidirectional bridge is only necessary when the field will be an `ID` field
    within a Lucene index (that is, annotated with `@Id` or `@DocumentId`).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在字段将成为Lucene索引中的`ID`字段（即，用`@Id`或`@DocumentId`注解）时，才需要双向桥。
- en: ParameterizedBridge
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数化桥
- en: For even greater flexibility, it is possible to pass configuration parameters
    to a bridge class. To do so, your bridge should implement the `ParameterizedBridge`
    interface, in addition to `StringBridge` or `TwoWayStringBridge`. The class must
    then implement a `setParameterValues` method for receiving the extra parameters.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更大的灵活性，可以向桥接类传递配置参数。为此，您的桥接类应该实现`ParameterizedBridge`接口，以及`StringBridge`或`TwoWayStringBridge`。然后，该类必须实现一个`setParameterValues`方法来接收这些额外的参数。
- en: 'For the sake of argument, let''s say that we wanted our example bridge to be
    able to write percentages with a greater level of precision, rather than rounding
    to a whole number. We could pass it a parameter specifying the number of decimal
    places to use:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明问题，假设我们想让我们的示例桥接能够以更大的精度写出百分比，而不是四舍五入到整数。我们可以传递一个参数，指定要使用的小数位数：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This version of our bridge class expects to receive a parameter named `decimal_places`.
    Its value is stored in the `decimalPlaces` member variable, and then used inside
    the `objectToString` method. If no such parameter is passed, then a default of
    two decimal places will be used to build percentage strings.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们桥接类的这个版本期望收到一个名为`decimal_places`的参数。它的值存储在`decimalPlaces`成员变量中，然后在`objectToString`方法中使用。如果没有传递这样的参数，那么将使用两个小数位来构建百分比字符串。
- en: 'The mechanism for actually passing one or more parameters is the `params` element
    of the `@FieldBridge` annotation:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`@FieldBridge`注解中的`params`元素是实际传递一个或多个参数的机制：'
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be aware that all implementations of `StringBridge` or `TwoWayStringBridge`
    must be thread-safe. Generally, you should avoid any shared resources, and only
    take additional information through the `ParameterizedBridge` parameters.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有`StringBridge`或`TwoWayStringBridge`的实现都必须是线程安全的。通常，您应该避免任何共享资源，并且只通过`ParameterizedBridge`参数获取额外信息。
- en: More complex mappings with FieldBridge
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用FieldBridge进行更复杂的映射
- en: The bridge types covered so far are the easiest and most straightforward way
    to map a Java property to a string index value. However, sometimes you need even
    greater flexibility, so there are a few field bridge variations supporting a free-form
    approach.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止所涵盖的桥接类型是将Java属性映射到字符串索引值的最简单、最直接的方法。然而，有时您需要更大的灵活性，因此有一些支持自由形式的字段桥接变体。
- en: Splitting a single variable into multiple fields
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将单个变量拆分为多个字段
- en: Occasionally, the desired relationship between a class property and Lucene index
    fields may not be one-to-one. For example, let's say that one property represents
    a filename. However, we would like the ability to search not only by filename,
    but also by file type (that is, the file extension). One approach is to parse
    the file extension from the filename property, and thereby use that one variable
    to create both fields.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，类属性与Lucene索引字段之间的期望关系可能不是一对一的。例如，假设一个属性表示文件名。然而，我们希望能够不仅通过文件名搜索，还可以通过文件类型（即文件扩展名）搜索。一种方法是从文件名属性中解析文件扩展名，从而使用这个变量创建两个字段。
- en: 'The `FieldBridge` interface allows us to do this. Implementations must provide
    a `set` method, which in this example parses the file type from the file name
    field, and stores them separately:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`FieldBridge`接口允许我们这样做。实现必须提供一个`set`方法，在这个例子中，它从文件名字段中解析文件类型，并将其分别存储：'
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `luceneOptions` parameter is a helper object for interacting with Lucene,
    and `document` represents the Lucene data structure to which we are adding fields.
    We use `luceneOptions.addFieldToDocument()` to add fields to the index, without
    having to fully understand the Lucene API details.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`luceneOptions`参数是与Lucene交互的帮助对象，`document`表示我们正在添加字段的Lucene数据结构。我们使用`luceneOptions.addFieldToDocument()`将字段添加到索引，而不必完全理解Lucene
    API的细节。'
- en: The `name` parameter passed to `set` represents the name of the entity being
    indexed. Notice that we use this as a base when declaring the names of the two
    entities being added (that is, `name+".file"` for the filename, and `name+".file_type"`
    for the file type).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`set`的`name`参数代表了被索引的实体名称。注意我们用这个作为基础来声明要添加的两个实体的名称（也就是说，对于文件名，使用`name+".file"`；对于文件类型，使用`name+".file_type"`）。
- en: Finally, the `value` parameter is the current field being mapped. Just as with
    the `StringBridge` interface seen in the `Bridges` section, the method signature
    here uses a generic `Object` for flexibility. The value must be cast to its appropriate
    type.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`value` 参数是指当前正在映射的字段。就像在`Bridges`部分看到的`StringBridge`接口一样，这里的函数签名使用了一个通用的`Object`以提高灵活性。必须将值转换为其适当的类型。
- en: 'To apply a `FieldBridge` implementation, use the `@FieldBridge` annotation
    just as we''ve already seen with the other custom bridge types:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用`FieldBridge`实现，就像我们已经看到的其他自定义桥接类型一样，使用`@FieldBridge`注解：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Combining multiple properties into a single field
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将多个属性合并为一个字段
- en: A custom bridge implementing the `FieldBridge` interface may also be used for
    the reverse purpose, to combine more than one property into a single index field.
    To gain this degree of flexibility, the bridge must be applied to the *class*
    level rather than the *field* level. When the `FieldBridge` interface is used
    in this manner, it is known as a **class bridge**, and replaces the usual mapping
    mechanism for the entire entity class.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`FieldBridge`接口的自定义桥接也可以用于相反的目的，将多个属性合并为一个索引字段。为了获得这种灵活性，桥接必须应用于*类*级别而不是*字段*级别。当以这种方式使用`FieldBridge`接口时，它被称为**类桥接**，并替换了整个实体类的常规映射机制。
- en: 'For example, consider an alternate approach we could have taken with the `Device`
    entity in our VAPORware Marketplace application. Instead of indexing `manufacturer`
    and `name` as separate fields, we could have combined them into one `fullName`
    field. The class bridge for this would still implement the `FieldBridge` interface,
    but it would concatenate the two properties into one index field as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑我们在VAPORware Marketplace应用程序中处理`Device`实体时可以采取的另一种方法。而不是将`manufacturer`和`name`作为单独的字段进行索引，我们可以将它们合并为一个`fullName`字段。这个类桥接仍然实现`FieldBridge`接口，但它会将两个属性合并为一个索引字段，如下所示：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Rather than applying an annotation to any particular fields within the `Device`
    class, we would instead apply a `@ClassBridge` annotation at the class level.
    Notice that the field-level Hibernate Search annotations have been completely
    removed, as the class bridge will be responsible for mapping all index fields
    in this class.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在`Device`类的任何特定字段上应用注解，我们可以在类级别应用一个`@ClassBridge`注解。注意字段级别的Hibernate Search注解已经被完全移除，因为类桥接将负责映射这个类中的所有索引字段。
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: TwoWayFieldBridge
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TwoWayFieldBridge
- en: Earlier we saw that the simple `StringBridge` interface has a `TwoWayStringBridge`
    counterpart, providing bidirectional mapping capability for document ID fields.
    Likewise, the `FieldBridge` interface has a `TwoWayFieldBridge` counterpart for
    the same reason. When you apply a field bridge interface to a property used by
    Lucene as an ID (that is, annotated with `@Id` or `@DocumentId`), then you must
    use the two-way variant.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们看到了简单的`StringBridge`接口有一个`TwoWayStringBridge`对应接口，为文档ID字段提供双向映射能力。同样，`FieldBridge`接口也有一个`TwoWayFieldBridge`对应接口出于相同原因。当你将字段桥接接口应用于Lucene用作ID的属性（即，用`@Id`或`@DocumentId`注解）时，你必须使用双向变体。
- en: 'The `TwoWayStringBridge` interface requires the same `objectToString` method
    as `StringBridge`, and the same `set` method as `FieldBridge`. However, this two-way
    version also requires a `get` counterpart, for retrieving the string representation
    from Lucene and converting if the true type is different:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`TwoWayStringBridge`接口需要与`StringBridge`相同的`objectToString`方法，以及与`FieldBridge`相同的`set`方法。然而，这个双向版本还需要一个`get`对应方法，用于从Lucene检索字符串表示，并在真实类型不同时进行转换：'
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Analysis
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析
- en: When a field is indexed by Lucene, it undergoes a parsing and conversion process
    called **analysis**. In [Chapter 3](ch03.html "Chapter 3. Performing Queries"),
    *Performing Queries*, we mentioned that the default **analyzer** tokenizes string
    fields, and that this behavior should be disabled if you plan to sort on that
    field.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个字段被Lucene索引时，它会经历一个称为**分析**的解析和转换过程。在[第3章](ch03.html "第3章 执行查询")《执行查询》中，我们提到了默认的**分析器**会分词字符串字段，如果你打算对该字段进行排序，则应该禁用这种行为。
- en: However, much more is possible during analysis. Apache Solr components may be
    assembled in hundreds of combinations. They can manipulate text in various ways
    during indexing, and open the door to some really powerful search functionally.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在分析过程中可以实现更多功能。Apache Solr组件可以组装成数百种组合。 它们可以在索引过程中以各种方式操纵文本，并打开一些非常强大的搜索功能的大门。
- en: 'In order to discuss the Solr components that are available, or how to assemble
    them into a custom analyzer definition, we must first understand the three phases
    of Lucene analysis:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了讨论可用的Solr组件，或者如何将它们组装成自定义分析器定义，我们首先必须了解Lucene分析的三个阶段：
- en: Character filtering
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符过滤
- en: Tokenization
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记化
- en: Token filtering
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记过滤
- en: Analysis begins by applying zero or more **character filters**, which strip
    or replace characters prior to any other processing. The filtered string then
    undergoes **tokenization**, splitting it into smaller tokens to make keyword searches
    more efficient. Finally, zero or more **token filters** remove or replace tokens
    before they are saved to the index.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 分析首先通过应用零个或多个**字符过滤器**进行，这些过滤器在处理之前去除或替换字符。 过滤后的字符串然后进行**标记化**，将其拆分为更小的标记，以提高关键字搜索的效率。
    最后，零个或多个**标记过滤器**在将它们保存到索引之前去除或替换标记。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: These components are provided by the Apache Solr project, and they number over
    three-dozen in total. This book cannot dive deeply into every single one, but
    we can take a look at a few key examples of the three types and see how to apply
    them generally.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件由Apache Solr项目提供，总共有三十多个。 本书无法深入探讨每一个，但我们可以查看三种类型的一些关键示例，并了解如何一般地应用它们。
- en: The full documentation for all of these Solr analyzer components may be found
    at [http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters](http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters),
    with Javadocs at [http://lucene.apache.org/solr/api-3_6_1](http://lucene.apache.org/solr/api-3_6_1).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些Solr分析器组件的完整文档可以在[http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters](http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters)找到，Javadocs在[http://lucene.apache.org/solr/api-3_6_1](http://lucene.apache.org/solr/api-3_6_1)。
- en: Character filtering
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符过滤
- en: 'When defining a custom analyzer, character filtering is an optional step. Should
    this step be desired, there are only three character filter types available:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 定义自定义分析器时，字符过滤是一个可选步骤。如果需要此步骤，只有三种字符过滤类型可用：
- en: '`MappingCharFilterFactory`: This filter replaces characters (or sequences of
    characters) with specifically defined replacement text, for example, you might
    replace occurrences of *1* with *one*, *2* with *two*, and so on.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MappingCharFilterFactory`：此过滤器将字符（或字符序列）替换为特定定义的替换文本，例如，您可能会将*1*替换为*one*，*2*替换为*two*，依此类推。'
- en: The mappings between character(s) and replacement value(s) are stored in a resource
    file, using the standard `java.util.Properties` format, located somewhere in the
    application's classpath. For each property, the key is the sequence to look for,
    and the value is the mapped replacement.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 字符（或字符序列）与替换值之间的映射存储在一个资源文件中，该文件使用标准的`java.util.Properties`格式，位于应用程序的类路径中的某个位置。对于每个属性，键是查找的序列，值是映射的替换。
- en: The classpath-relative location of this mappings file is passed to the `MappingCharFilterFactory`
    definition, as a parameter named `mapping` . The exact mechanism for passing this
    parameter will be illustrated shortly in the *Defining and Selecting Analyzers*
    section.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个映射文件相对于类路径的位置被传递给`MappingCharFilterFactory`定义，作为一个名为`mapping`的参数。传递这个参数的确切机制将在*定义和选择分析器*部分中详细说明。
- en: '`PatternReplaceCharFilter`: This filter applies a regular expression, passed
    via a parameter named `pattern`. Any matches will be replaced with a string of
    static text passed via a `replacement` parameter.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PatternReplaceCharFilter`：此过滤器应用一个通过名为`pattern`的参数传递的正则表达式。 任何匹配项都将用通过`replacement`参数传递的静态文本字符串替换。'
- en: '`HTMLStripCharFilterFactory`: This extremely useful filter removes HTML tags,
    and replaces escape sequences with their usual text forms (for example, `&gt;`
    becomes `>`).'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTMLStripCharFilterFactory`：这个极其有用的过滤器移除HTML标签，并将转义序列替换为其通常的文本形式（例如，`&gt;`变成`>`）。'
- en: Tokenization
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标记化
- en: Character and token filters are both optional when defining a custom analyzer,
    and you may combine multiple filters of both types. However, the `tokenizer` component
    is unique. An analyzer definition must contain one, and no more than one.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义自定义分析器时，字符和标记过滤器都是可选的，您可以组合多种过滤器。然而，`tokenizer`组件是唯一的。分析器定义必须包含一个，最多一个。
- en: 'There are 10 `tokenizer` components available in total. Some illustrative examples
    include:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 总共有10个`tokenizer`组件可供使用。一些说明性示例包括：
- en: '`WhitespaceTokenizerFactory`: This simply splits text on whitespace. For instance,
    *hello world* is tokenized into *hello* and *world*.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WhitespaceTokenizerFactory`：这个组件只是根据空白字符分割文本。例如，*hello world* 被分词为 *hello*
    和 *world*。'
- en: '`LetterTokenizerFactory`: This is similar to `WhitespaceTokenizrFactory` in
    functionality, but this tokenizer also splits text on non-letter characters. The
    non-letter characters are discarded altogether, for example, *please don''t go*
    is tokenized into *please*, *don*, *t*, and *go*.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LetterTokenizerFactory`：这个组件的功能与`WhitespaceTokenizrFactory`类似，但这个分词器还会在非字母字符处分割文本。非字母字符完全被丢弃，例如，*please
    don''t go*被分词为*please*, *don*, *t*, 和 *go*。'
- en: '`StandardTokenizerFactory`: This is the default `tokenizer` that is automatically
    applied when you don''t define a custom analyzer. It generally splits on whitespace,
    discarding extraneous characters. For instance, *it''s 25.5 degrees outside!!!*
    becomes *it''s*, *25.5*, *degrees*, and *outside*.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StandardTokenizerFactory`：这是默认的`tokenizer`，在未定义自定义分析器时自动应用。它通常根据空白字符分割，丢弃多余字符。例如，*it''s
    25.5 degrees outside!!!* 变为 *it''s*, *25.5*, *degrees*, 和 *outside*。'
- en: Tip
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When in doubt, `StandardTokenizerFactory` is almost always the sensible choice.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当有疑问时，`StandardTokenizerFactory`几乎总是合理的选择。
- en: Token filtering
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分词过滤器
- en: 'By far the greatest variety in analyzer functionality comes through token filters,
    with Solr offering two dozen options for use alone or in combination. These are
    only a few of the more useful examples:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，分析器功能的最大多样性是通过分词过滤器实现的，Solr 提供了二十多个选项供单独或组合使用。以下是更有用的几个示例：
- en: '`StopFilterFactory`: This filter simply throws away "stop words", or extremely
    common words for which no one would ever want to perform a keyword query anyway.
    The list includes *a*, *the*, *if*, *for*, *and*, *or*, and so on (the Solr documentation
    presents the full list).'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StopFilterFactory`：这个过滤器简单地丢弃“停用词”，或者根本没有人想要对其进行关键词查询的极其常见的词。列表包括 *a*, *the*,
    *if*, *for*, *and*, *or* 等（Solr 文档列出了完整列表）。'
- en: '`PhoneticFilterFactory`: When you use a major search engine, you would probably
    notice that it can be very intelligent in dealing with your typos. One technique
    for doing this is to look for words that sound similar to the searched keyword,
    in case it was misspelled. For example, if you meant to search for *morning*,
    but misspelled it as *mourning*, the search would still match the intended term!
    This token filter provides that functionality by indexing phonetically similar
    strings along with the actual token. The filter requires a parameter named `encoder`,
    set to the name of a supported encoding algorithm `("DoubleMetaphone"` is a sensible
    option).'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PhoneticFilterFactory`：当你使用主流搜索引擎时，你可能会注意到它在处理你的拼写错误时非常智能。这样做的一种技术是寻找与搜索关键字听起来相似的单词，以防它被拼写错误。例如，如果你本想搜索*morning*，但误拼为*mourning*，搜索仍然能匹配到意图的词条！这个分词过滤器通过与实际分词一起索引音似字符串来实现这一功能。该过滤器需要一个名为`encoder`的参数，设置为支持的字符编码算法名称（`"DoubleMetaphone"`是一个合理的选择）。'
- en: '`SnowballPorterFilterFactory`: Stemming is a process in which tokens are broken
    down into their root form, to make it easier to match related words. Snowball
    and Porter refer to stemming algorithms. For instance, the words *developer* and
    *development* can both be broken down to the root stem *develop*. Therefore, Lucene
    can recognize a relationship between the two longer words (even though neither
    one is a substring of the other!) and can return matches on both. This filter
    takes one parameter, named `language` (for example, `"English"`).'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SnowballPorterFilterFactory`：词干提取是一个将分词转化为其根形式的过程，以便更容易匹配相关词汇。Snowball 和 Porter
    指的是词干提取算法。例如，单词 *developer* 和 *development* 都可以被分解为共同的词干 *develop*。因此，Lucene 能够识别这两个较长词汇之间的关系（即使没有一个词汇是另一个的子串！）并能返回两个匹配项。这个过滤器有一个参数，名为
    `language`（例如，`"English"`）。'
- en: Defining and selecting analyzers
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义和选择分析器
- en: An **analyzer definition** assembles some combination of these components into
    a logical whole, which can then be referenced when indexing an entity or individual
    field. Custom analyzers may be defined in a static manner, or may be assembled
    dynamically based on some conditions at runtime.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析器定义**将一些这些组件的组合成一个逻辑整体，在索引实体或单个字段时可以引用这个整体。分析器可以在静态方式下定义，也可以根据运行时的一些条件动态地组装。'
- en: Static analyzer selection
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态分析器选择
- en: 'Either approach for defining a custom analyzer begins with an `@AnalyzerDef`
    annotation on the relevant persistent class. In the `chapter4` version of our
    VAPORware Marketplace application, let''s define a custom analyzer to be used
    with the `App` entity''s `description` field. It should strip out any HTML tags,
    and apply various token filters to reduce clutter and account for typos:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 定义自定义分析器的任何方法都以在相关持久类上的`@AnalyzerDef`注解开始。在我们的`chapter4`版本的VAPORware Marketplace应用程序中，让我们定义一个自定义分析器，用于与`App`实体的`description`字段一起使用。它应该移除任何HTML标签，并应用各种分词过滤器以减少杂乱并考虑拼写错误：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `@AnalyzerDef` annotation must have a name element set, and as previously
    discussed, an analyzer must always include one and only one tokenizer.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`@AnalyzerDef`注解必须有一个名称元素设置，正如之前讨论的，分析器必须始终包括一个且只有一个分词器。'
- en: The `charFilters` and `filters` elements are optional. If set, they receive
    lists of one or more factory classes, for character filters and token filters
    respectively.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`charFilters`和`filters`元素是可选的。如果设置，它们分别接收一个或多个工厂类列表，用于字符过滤器和分词过滤器。'
- en: Tip
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Be aware that character filters and token filters are applied *in the order
    they are listed*. In some cases, changes to the ordering can affect the final
    result.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，字符过滤器和分词过滤器是按照它们列出的顺序应用的。在某些情况下，更改顺序可能会影响最终结果。
- en: 'The `@Analyzer` annotation is used to select and apply a custom analyzer. This
    annotation may be placed on an individual field, or on the overall class where
    it will affect every field. In this case, we are only selecting our analyzer definition
    for the `desciption` field:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Analyzer`注解用于选择并应用一个自定义分析器。这个注解可以放在个别字段上，或者放在整个类上，影响每个字段。在这个例子中，我们只为`desciption`字段选择我们的分析器定义：'
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It is possible to define multiple analyzers in a single class, by wrapping
    their `@AnalyzerDef` annotations within a plural `@AnalyzerDefs`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个类中定义多个分析器是可能的，通过将它们的`@AnalyzerDef`注解包裹在一个复数`@AnalyzerDefs`中来实现：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Obviously, where the `@Analyzer` annotation is later applied, its definition
    element has to match the appropriate `@AnalyzerDef` annotation's name element.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在后来应用`@Analyzer`注解的地方，其定义元素必须与相应的`@AnalyzerDef`注解的名称元素匹配。
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `chapter4` version of the VAPORware Marketplace application now strips HTML
    from the customer reviews. If a search includes the keyword *span*, there will
    not be a false positive match on reviews containing the `<span>` tag, for instance.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`chapter4`版本的VAPORware Marketplace应用程序现在会从客户评论中移除HTML。如果搜索包括关键词*span*，例如，不会在包含`<span>`标签的评论中出现假阳性匹配。'
- en: Snowball and phonetic filters are being applied to the app descriptions. The
    keyword *mourning* finds a match containing the word *morning*, and a search for
    *development* returns an app with *developers* in its description.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Snowball和音译过滤器被应用于应用描述中。关键词*mourning*找到包含单词*morning*的匹配项，而*development*的搜索返回了描述中包含*developers*的应用程序。
- en: Dynamic analyzer selection
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态分析器选择
- en: It is possible to wait until runtime to select a particular analyzer for a field.
    The most obvious scenario is an application supporting different languages, with
    analyzer definitions configured for each language. You would want to select the
    appropriate analyzer based on a language attribute for each object.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 可以等到运行时为字段选择一个特定的分析器。最明显的场景是一个支持不同语言的应用程序，为每种语言配置了分析器定义。您希望根据每个对象的言语属性选择适当的分析器。
- en: 'To support such a dynamic selection, an `@AnalyzerDiscriminator` annotation
    is added to a particular field or to the class as a whole. This code snippet uses
    the latter approach:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这种动态选择，对特定的字段或整个类添加了`@AnalyzerDiscriminator`注解。这个代码段使用了后者的方法：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There are two analyzer definitions, one for English and the other for French,
    and the class `CustomerReviewDiscriminator` is declared responsible for deciding
    which to use. This class must implement the `Discriminator` interface, and its
    `getAnalyzerDefinitionName` method:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个分析器定义，一个是英语，另一个是法语，类`CustomerReviewDiscriminator`被宣布负责决定使用哪一个。这个类必须实现`Discriminator`接口，并它的`getAnalyzerDefinitionName`方法：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If the `@AnalyzerDiscriminator` annotation is placed on a field, then its value
    for the current object is automatically passed as the first parameter to `getAnalyzerDefinitionName`.
    If the annotation is placed on the class itself, then a null value is passed instead.
    The second parameter is the current entity object either way.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`@AnalyzerDiscriminator`注解放在字段上，那么其当前对象的值会自动作为第一个参数传递给`getAnalyzerDefinitionName`。如果注解放在类本身上，则传递`null`值。无论如何，第二个参数都是当前实体对象。
- en: In this case, the discriminator is applied at the class level. So we cast that
    second parameter to type `CustomerReview`, and return the name of the appropriate
    analyzer based on the object's `language` field. If the language is unknown or
    if there are other issues, then the method simply returns `null`, telling Hibernate
    Search to fall back to the default analyzer.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，鉴别器应用于类级别。所以我们将第二个参数转换为`CustomerReview`类型，并根据对象的`language`字段返回适当的分析器名称。如果语言未知或存在其他问题，则该方法简单地返回`null`，告诉Hibernate
    Search回退到默认分析器。
- en: Boosting search result relevance
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升搜索结果的相关性
- en: We have already seen that the default sort order for search results is by relevance,
    meaning the degree to which they match the query. If one entity matches on two
    fields, while another has only one field match, then that first entity is the
    more relevant result.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道，搜索结果的默认排序顺序是按相关性，即它们与查询匹配的程度。如果一个实体在两个字段上匹配，而另一个只有一个字段匹配，那么第一个实体是更相关的结果。
- en: Hibernate Search allows us to adjust how relevance is calculated, by **boosting**
    the relative importance of entities or fields when they are indexed. These adjustments
    can be static and fixed, or they can be dynamic and driven by the state of the
    data at runtime.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate Search允许我们通过在索引时调整实体或字段的相对重要性来调整相关性**提升**。这些调整可以是静态和固定的，也可以是动态的，由运行时数据状态驱动。
- en: Static boosting at index-time
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 索引时间的静态提升
- en: Fixed boosting, regardless of the actual data, is as simple as annotating a
    class or field with `@Boost`. This annotation takes a floating-point parameter
    for its relative weight, with the default weight being 1.0\. So for example, `@Boost(2.0f)`
    would double the weight of a class or field relative to non-annotated classes
    and fields.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 固定的提升，无论实际数据如何，都像注解一个类或字段一样简单，只需要使用`@Boost`。这个注解接受一个浮点数参数作为其相对权重，默认权重为1.0\。所以，例如，`@Boost(2.0f)`会将一个类或字段的权重相对于未注解的类和字段加倍。
- en: Our VAPORware Marketplace application searches on several fields and associations,
    such as the names of supported devices, and comments posted in customer reviews.
    However, doesn't it make sense that the text under our control (each app's name
    and full description) should carry more weight than text coming from outside parties?
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的VAPORware Marketplace应用程序在几个字段和关联上进行搜索，比如支持设备的名称，以及客户评论中的评论。然而，文本应该比来自外部各方的文本更重要，这难道不是合情合理的吗？（每个应用的名称和完整描述）
- en: 'To make this adjustment, the `chapter4` version starts by annotating the `App`
    class itself:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行此调整，`chapter4`版本首先注释了`App`类本身：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This essentially makes `App` twice as relevant as `Device` or `CustomerReview`.
    Next, we apply field-level boosting to the name and full description fields:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上使得`App`的权重是`Device`或`CustomerReview`的两倍。接下来，我们对名称和完整描述字段应用字段级提升：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We are declaring here that `name` carries slightly more weight than `description`,
    and they each carry more weight relative to normal fields.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里声明`name`的权重略高于`description`，并且它们相对于普通字段都带有更多的权重。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be aware that class-level and field-level boosting cascade and combine! When
    more than one boost factor applies to a given field, they are multiplied to form
    the total factor.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，类级别和字段级别的提升是级联和结合的！当给定字段应用多个提升因子时，它们会被乘以形成总因子。
- en: Here, because a weight of 2.0 was already applied to the `App` class itself,
    `name` has a total effective weight of 3.0 and `description` is at 2.4.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，因为已经对`App`类本身应用了2.0的权重，`name`的总有效权重为3.0，`description`为2.4。
- en: Dynamic boosting at index-time
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 索引时间的动态提升
- en: 'For an example of boosting an entity dynamically based on its data at index-time,
    let''s say that we wanted to give the `CustomerReview` objects a bit more weight
    when the reviewer gives a five-star rating. To do this, we apply a `@DynamicBoost`
    annotation to the class:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们希望在评论者给出五星评价时，给`CustomerReview`对象更多的权重。为此，我们在类上应用一个`@DynamicBoost`注解：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This annotation must be passed a class that implements the `BoostStrategy`
    interface, and its `defineBoost` method:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个注解必须传递一个实现`BoostStrategy`接口的类，以及它的`defineBoost`方法：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When the `@DynamicBoost` annotation was applied to a class, the parameter automatically
    passed to `defineBoost` is an instance of that class (a `CustomerReview` object
    in this case). If the annotation had been applied to a particular field, then
    the automatically-passed parameter would be that field's value.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当`@DynamicBoost`注解应用于一个类时，传递给`defineBoost`的参数自动是该类的一个实例（在这个例子中是一个`CustomerReview`对象）。如果注解是应用于一个特定的字段，那么自动传递的参数将是那个字段的值。
- en: The `float` value returned by `defineBoost` becomes the weight of the class
    or field that was annotated. In this case, we increase a `CustomerReview` object's
    weight to 1.5 when it represents a five-star review. Otherwise, we keep the 1.0
    default.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`defineBoost`返回的`float`值变成了被注解的类或字段的权重。在这个例子中，当`CustomerReview`对象代表一个五星评论时，我们将它的权重增加到1.5。否则，我们保持默认的1.0。'
- en: Conditional indexing
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件索引
- en: There are specialized ways to go about indexing fields, such as using a class
    bridge or the programmatic mapping API. Generally speaking, though, a property
    is indexed when it is annotated with `@Field`. Therefore, one obvious way to avoid
    indexing a field is to simply not apply the annotation.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 字段索引有专门的处理方式，比如使用类桥接或程序化映射API。总的来说，当一个属性被注解为`@Field`时，它就会被索引。因此，避免索引字段的一个明显方法就是简单地不应用这个注解。
- en: However, what if we want an entity class to be searchable in general, but we
    need to exclude certain instances of that class, based on the state of their data
    at runtime?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们希望一个实体类通常可被搜索，但我们需要根据它们数据在运行时的状态排除这个类的某些实例怎么办？
- en: The `@Indexed` annotation has an experimental second element, `interceptor`
    , that gives us the ability to index conditionally. When this element is set,
    the normal indexing process will be intercepted by custom code, which can prevent
    an entity from being indexed based on its current state.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Indexed`注解有一个实验性的第二个元素`interceptor`，它给了我们条件索引的能力。当这个元素被设置时，正常的索引过程将被自定义代码拦截，这可以根据实体的当前状态阻止实体被索引。'
- en: 'Let''s give our VAPORware Marketplace the ability to make apps inactive. Inactive
    apps will still exist in the database, but should not be shown to customers or
    indexed for searching. To start, we will add a new property to the `App` entity
    class:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给我们的VAPORware Marketplace添加使应用失效的能力。失效的应用仍然存在于数据库中，但不应该向客户展示或进行索引。首先，我们将向`App`实体类添加一个新属性：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This new `active` variable has the standard getter and setter methods, and
    is being defaulted to `true` in our normal constructor. We want individual apps
    to be excluded from the Lucene index when this variable is `false`, so we add
    an `interceptor` element to the `@Indexed` annotation:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的`active`变量有标准的getter和setter方法，并且在我们的正常构造函数中被默认为`true`。我们希望在`active`变量为`false`时，个别应用被排除在Lucene索引之外，所以我们给`@Indexed`注解添加了一个`interceptor`元素：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This element must be tied to a class that implements the `EntityIndexingInterceptor`
    interface. Since we just specified a class named `IndexWhenActiveInterceptor`,
    we need to now create this class.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个元素必须绑定到一个实现`EntityIndexingInterceptor`接口的类上。由于我们刚刚指定了一个名为`IndexWhenActiveInterceptor`的类，所以我们现在需要创建这个类。
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `EntityIndexingInterceptor` interface declares **four methods**, which
    Hibernate Search will call at various points during an entity object''s life cycle:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`EntityIndexingInterceptor`接口声明了**四个方法**，Hibernate Search会在实体对象的生命周期的不同阶段调用它们：'
- en: '`onAdd()`: This is called when the entity instance is first created.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onAdd()`: 当实体实例第一次被创建时调用。'
- en: '`onDelete()`: This is called when the entity instance is removed from the database.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onDelete()`: 当实体实例从数据库中被移除时调用。'
- en: '`onUpdate()`: This is called when an existing instance is updated.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onUpdate()`: 当一个现有实例被更新时调用。'
- en: '`onCollectionUpdate()`: This version is used when an entity is modified as
    part of a bulk update with other entities. Typically, implementations of this
    method simply invoke `onUpdate()`.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCollectionUpdate()`: 当一个实体作为其他实体的批量更新的一部分被修改时使用这个版本。通常，这个方法的实现简单地调用`onUpdate()`。'
- en: 'Each of these methods should return one of the four possible `IndexingOverride`
    enum values. The possible **return values** tell Hibernate Search what to do:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法中的每一个都应该返回`IndexingOverride`枚举的四种可能值之一。可能的**返回值**告诉Hibernate Search应该做什么：
- en: '`IndexingOverride.SKIP`: This tells Hibernate Search to not modify the Lucene
    index for this entity instance at this time.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IndexingOverride.SKIP`：这告诉Hibernate Search在当前时间不要修改此实体实例的Lucene索引。'
- en: '`IndexingOverride.REMOVE`: Hibernate Search will remove the entity if it already
    exists in an index, or else will do nothing if the entity is not indexed.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IndexingOverride.REMOVE`：如果实体已经在索引中，Hibernate Search将删除该实体；如果实体没有被索引，则什么也不做。'
- en: '`IndexingOverride.UPDATE`: The entity will be updated in the index, or added
    if it is not already indexed.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IndexingOverride.UPDATE`：实体将在索引中更新，或者如果它还没有被索引，将被添加。'
- en: '`IndexingOverride.APPLY_DEFAULT`: This is equivalent to the custom interceptor
    not being used in the first place. Hibernate Search will index the entity if this
    is an `onAdd()` operation, remove it from the index if this is an `onDelete()`,
    or update the index if this is `onUpdate()` or `onCollectionUpdate()`.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IndexingOverride.APPLY_DEFAULT`：这等同于自定义拦截器根本没有被使用。Hibernate Search将索引实体，如果这是一个`onAdd()`操作；如果这是一个`onDelete()`，则将其从索引中移除；或者如果这是`onUpdate()`或`onCollectionUpdate()`，则更新索引。'
- en: Although the four methods logically imply certain return values, it is actually
    possible to mix them in any combination if you are dealing with unusual conditions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这四种方法在逻辑上暗示了某些返回值，但实际上如果你处理的是异常情况，可以任意组合它们。
- en: In our example application, our interceptor examines the entity in `onAdd()`
    and `onDelete()`. When a new `App` is created, indexing is skipped if its `active`
    variable is false. When an `App` is updated, it will be removed from the index
    if has become inactive.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例应用程序中，我们的拦截器在`onAdd()`和`onDelete()`中检查实体。当创建一个新的`App`时，如果其`active`变量为false，则跳过索引。当`App`被更新时，如果它变得不活跃，它将被从索引中移除。
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we toured the full range of functionality available in mapping
    persistent objects for search. We can now adjust settings for Hibernate Search's
    built-in type bridges, and can create highly advanced custom bridges of our own.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们全面了解了为搜索而映射持久对象所提供的所有功能。现在我们可以调整Hibernate Search内置类型桥接的设置，并且可以创建高度先进的自定义桥接。
- en: We now have a deeper understanding of Lucene analysis. We have worked with some
    of the most useful custom analyzer components, and know how to independently obtain
    information on dozens of other Solr components.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对Lucene分析有了更深入的了解。我们使用了一些最实用的自定义分析器组件，并且知道如何独立获取数十个其他Solr组件的信息。
- en: We are now able to adjust the relative weight of classes and fields through
    boosting, to improve the quality of our search results when there are sorted by
    relevance. Last but not least, we learned how to use conditional indexing to dynamically
    prevent certain data from being searchable based on its state.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过提升来调整类和字段的相对权重，以在按相关性排序时提高我们的搜索结果质量。最后但同样重要的是，我们学会了如何使用条件索引动态地阻止某些数据根据其状态变得可搜索。
- en: In the next chapter, we will turn to more advanced query concepts. We will learn
    how to filter and categorize search results, and pull data from Lucene alone without
    needing a database call.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将转向更高级的查询概念。我们将学习如何过滤和分类搜索结果，并从Lucene中提取数据，而不需要数据库调用。
