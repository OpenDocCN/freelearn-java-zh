- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Performance-Focused Libraries
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能重点库
- en: The performance of modern Java applications is a paramount concern that can
    significantly impact the success of an application and the organization. Performance
    can include execution speed, network responsiveness, and data handling optimization.
    Regardless of the type of performance you are trying to improve, selecting and
    properly implementing the most ideal tools and libraries are key to bringing your
    performance improvement goals to fruition.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现代Java应用程序的性能是一个至关重要的关注点，它可以显著影响应用程序和组织的成功。性能可以包括执行速度、网络响应性和数据处理优化。无论你试图提高哪种类型的性能，选择和正确实施最理想的工具和库是实现性能改进目标的关键。
- en: This chapter highlights a specific set of tools that can be instrumental in
    improving the performance of Java applications. The first tool reviewed is **Java
    Microbenchmark Harness** (**JMH**), which helps us create reliable benchmarks.
    Our JMH coverage will include fundamental knowledge and hands-on application.
    Netty, a network application framework focused on high performance, will also
    be covered. This framework’s greatest value is in applications that require rapid
    response times or scalable network architectures.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章突出了可以显著提高Java应用程序性能的一组特定工具。首先介绍的工具是**Java微基准工具**（**JMH**），它帮助我们创建可靠的基准。我们的JMH覆盖范围将包括基本知识和实践应用。Netty，一个专注于高性能的网络应用程序框架，也将被介绍。该框架的最大价值在于需要快速响应时间或可扩展网络架构的应用程序。
- en: Our coverage of performance-focused libraries includes an examination of FasterXML
    Jackson, a high-speed **JavaScript Object Notation** (**JSON**) processor that,
    as you will have the opportunity to learn, facilitates data processing efficiencies.
    FasterXML Jackson, also referred to as just Jackson, has streaming and data-binding
    APIs that can significantly improve performance when working with JSON data. The
    chapter concludes with a section on other notable libraries, including Eclipse
    Collections, Agrona, and Guava.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对以性能为重点的库的覆盖范围包括对FasterXML Jackson的考察，这是一个高速的**JavaScript对象表示法**（**JSON**）处理器，正如你将有机会学习的，它促进了数据处理效率。FasterXML
    Jackson，也简称为Jackson，具有流式和数据绑定API，可以在处理JSON数据时显著提高性能。本章最后将介绍其他值得注意的库，包括Eclipse
    Collections、Agrona和Guava。
- en: By the end of this chapter, you should have a foundational understanding of
    performance-focused libraries and be able to leverage the knowledge you gained
    from the hands-on exercises to improve the performance of your Java applications.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你应该对以性能为重点的库有基础的了解，并能够利用从实践练习中获得的知识来提高你的Java应用程序的性能。
- en: 'This chapter covers the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主要内容：
- en: Java Microbenchmark Harness
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java Microbenchmark Harness
- en: Netty
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Netty
- en: FasterXML Jackson
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FasterXML Jackson
- en: Other notable libraries
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他值得注意的库
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the examples and instructions in this chapter, you will need the ability
    to load, edit, and run Java code. If you have not set up your development environment,
    refer to [*Chapter 1*](B21942_01.xhtml#_idTextAnchor014), *Peeking Inside the
    Java Virtual* *Machine (JVM)*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章中的示例和说明，你需要具备加载、编辑和运行Java代码的能力。如果你还没有设置你的开发环境，请参考[*第1章*](B21942_01.xhtml#_idTextAnchor014)，*探索Java虚拟机（JVM）*。
- en: 'The finished code for this chapter can be found here: [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter13](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter13).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码可以在以下链接找到：[https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter13](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter13)。
- en: Java Microbenchmark Harness
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java Microbenchmark Harness
- en: Benchmarking is critical to the ability to measure performance. JMH is a toolkit
    used to implement rigorous benchmarks. This section explores JMH and its key features
    and provides implementation examples.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试对于衡量性能的能力至关重要。JMH是一个用于实施严格基准的工具包。本节将探讨JMH及其关键特性，并提供实现示例。
- en: Java Microbenchmark Harness (JMH)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Java Microbenchmark Harness (JMH)
- en: JMH is used to build and implement benchmarks to analyze the performance of
    Java code. It was written in Java by the team that created the **Java Virtual**
    **Machine** (**JVM**).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: JMH用于构建和实施基准来分析Java代码的性能。它是由创建**Java虚拟机**（**JVM**）的团队用Java编写的。
- en: Developers that use JMH can measure the performance of Java code snippets with
    repeatable and controlled conditions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JMH的开发者可以以可重复和受控的条件来衡量Java代码片段的性能。
- en: Key features
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键特性
- en: JMH is an open source toolkit used to build and implement benchmarks at the
    nano, micro, and macro levels. JMH is more than a performance tester; it is designed
    to overcome or avoid common performance measurement pitfalls, including warm-up
    times and the effects of **just-in-time** (**JIT**) compilations.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: JMH是一个开源工具包，用于在纳米、微和宏观层面构建和实现基准测试。JMH不仅仅是一个性能测试器；它旨在克服或避免常见的性能测量陷阱，包括预热时间和即时编译（**JIT**）的影响。
- en: 'Key features of the JMH toolkit include the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: JMH工具包的关键特性包括以下内容：
- en: '**Annotations**: As you will see in the next section, JMH uses Java annotations
    to easily define benchmarks. This feature is developer-friendly.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注解**：正如您将在下一节中看到的那样，JMH使用Java注解轻松定义基准测试。这个特性对开发者友好。'
- en: '**JVM integration**: JMH works in step with JVM intervals. This provides us
    with consistent and reliable results.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JVM集成**：JMH与JVM间隔同步工作。这为我们提供了一致和可靠的结果。'
- en: '**Microbenchmarking support**: JMH, as the name suggests, focuses on small
    code snippets. This helps increase the accuracy of performance measurements.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微基准测试支持**：正如其名所示，JMH专注于小的代码片段。这有助于提高性能测量的准确性。'
- en: Now that you have a basic understanding of the JMH toolkit, let’s look at how
    to write benchmarks.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对JMH工具包有了基本的了解，让我们看看如何编写基准测试。
- en: Adding JMH libraries to your IDE
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将JMH库添加到您的IDE中
- en: 'Depending on your **Integrated Development Environment** (**IDE**) setup, you
    may have to manually add the JMH libraries to your Java project. The following
    steps can be used with Visual Studio Code to add the JMH libraries to a Java project:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的**集成开发环境**（**IDE**）设置，您可能需要手动将JMH库添加到Java项目中。以下步骤可用于Visual Studio Code将JMH库添加到Java项目中：
- en: Create a **Maven** **quickstart** project.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个**Maven** **quickstart**项目。
- en: 'Edit the `pom.xml` file by adding the following dependencies:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下依赖项编辑`pom.xml`文件：
- en: '[PRE0]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Save and reload the project using **Maven: Reload project** via the command
    palette.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用命令面板通过**Maven：重新加载项目**保存并重新加载项目。
- en: 'You might opt to use a more robust IDE, such as IntelliJ IDEA. Here are the
    steps to add these libraries to a project in that IDE:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会选择使用更健壮的IDE，例如IntelliJ IDEA。以下是向该IDE中的项目添加这些库的步骤：
- en: Create a project in IntelliJ IDEA.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在IntelliJ IDEA中创建一个项目。
- en: Select the **File** | **Project Structure** menu option.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**文件** | **项目结构**菜单选项。
- en: In the **Project Structure** interface, select **Project Settings** | **Libraries**.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目结构**界面中，选择**项目设置** | **库**。
- en: Click the **+** button to add a new library.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**+**按钮添加新的库。
- en: Choose the **From** **Maven** option.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**从Maven**选项。
- en: Use the search feature to find the most recent version of `org.openjdk.jmh:jmh-core`
    and click **OK** to add the library to your project.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用搜索功能查找`org.openjdk.jmh:jmh-core`的最新版本，然后点击**OK**将库添加到您的项目中。
- en: Use the search feature to find the most recent version of `org.openjdk.jmh:jmh-generator-annprocess`
    and click **OK** to add the library to your project.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用搜索功能查找`org.openjdk.jmh:jmh-generator-annprocess`的最新版本，然后点击**OK**将库添加到您的项目中。
- en: Click **Apply** to apply the changes and then **OK** to close the **Project
    Structure** dialog window.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**应用**以应用更改，然后点击**OK**关闭**项目结构**对话框窗口。
- en: Lastly, ensure that the libraries have been automatically added to your module.
    If this is not the case, select the **File** | **Project Structure** | **Modules**
    menu option. If the new JMH libraries are not listed in the **Dependencies** area,
    use the **+** button to add them.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，确保库已自动添加到您的模块中。如果不是这种情况，请选择**文件** | **项目结构** | **模块**菜单选项。如果新的JMH库未列在**依赖项**区域中，请使用**+**按钮添加它们。
- en: If you are not using Visual Studio Code or IntelliJ IDEA, follow the steps appropriate
    for your IDE.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不使用Visual Studio Code或IntelliJ IDEA，请按照适合您IDE的步骤进行操作。
- en: Writing benchmarks
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写基准测试
- en: 'To use JMH in Java code, we simply add the `@Benchmark` annotation and use
    JMH’s core APIs to configure and execute our benchmarks. Let’s look at an example
    in code. Our example tests two methods, both with a different approach to string
    reversal:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Java代码中使用JMH，我们只需添加`@Benchmark`注解，并使用JMH的核心API配置和执行基准测试。让我们看看代码中的示例。我们的示例测试了两种方法，它们以不同的方法进行字符串反转：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next, let’s run our code and review the results.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们运行我们的代码并查看结果。
- en: Running benchmarks
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行基准测试
- en: Once we define our benchmarks, we simply run them via the `main()` method in
    our Java application or, alternatively, via the command line. If our application
    does not contain a `main()` method, then we would run the class containing the
    benchmarks. In our previous code example, that would be the `Ch13StringBenchmark()`
    class. JMH provides detailed output with time measurements and throughput rates.
    Analysis of this data can provide significant performance-related insights into
    the benchmarked code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了基准，我们只需通过Java应用程序中的`main()`方法或通过命令行运行它们。如果我们的应用程序不包含`main()`方法，那么我们将运行包含基准的类。在我们的上一个代码示例中，那将是`Ch13StringBenchmark()`类。JMH提供了带有时间测量和吞吐量率的详细输出。分析这些数据可以为基准代码提供有关性能的显著见解。
- en: Even our simple test results in extensive output. The final segment of the output
    is provided in the following figure. The complete output is provided in the `Ch13StringBenchmarkOutput.txt`
    file in this chapter’s GitHub repository.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们的简单测试也产生了大量的输出。以下图提供了输出的最后一段。完整的输出可以在本章GitHub仓库的`Ch13StringBenchmarkOutput.txt`文件中找到。
- en: '![Figure 13.1 – Final benchmark output'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.1 – 最终基准输出'
- en: '](img/B21942_13_1.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B21942_13_1.jpg)'
- en: Figure 13.1 – Final benchmark output
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 – 最终基准输出
- en: Referring to the preceding output, let’s look at how that information can be
    analyzed to provide performance insights.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 参考前面的输出，让我们看看如何分析这些信息以提供性能洞察。
- en: Analyzing results
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析结果
- en: 'As you saw in the previous section, JMH provides extensive output. Looking
    at the final three lines of output illustrated in *Figure 13**.1*, there are several
    columns that we should understand:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在上一节中看到的，JMH提供了大量的输出。查看*图13.1*中展示的最后三行输出，有几个列是我们应该理解的：
- en: '`Mode`: This is the benchmark mode. Our mode was `thrpt` for throughput. It
    could have alternatively been `avgt` for average time.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mode`：这是基准模式。我们的模式是`thrpt`，用于吞吐量。它也可以是`avgt`，用于平均时间。'
- en: '`Cnt`: This is the count of benchmark iterations. In our case, it was `5` for
    each benchmark.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cnt`：这是基准迭代的计数。在我们的案例中，每个基准都是`5`。'
- en: '`Score`: This is the benchmark score that shows, in our case, the average throughput
    time in microseconds.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Score`：这是基准分数，显示在我们的案例中是平均吞吐量时间（以微秒为单位）。'
- en: '`Error`: This column contains the margin of error for the score.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Error`：此列包含分数的误差范围。'
- en: Based on the output, we can see that the first benchmark was faster than the
    second benchmark. Viewing these types of results can help developers decide how
    to implement certain functionality to achieve high performance in their code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 根据输出，我们可以看到第一个基准比第二个基准快。查看这类结果可以帮助开发者决定如何实现某些功能，以在代码中实现高性能。
- en: Use cases
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例
- en: 'There are a few common JMH use cases:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个常见的JMH用例：
- en: Algorithm optimization
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法优化
- en: Comparative analysis
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较分析
- en: Performance regression tests
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能回归测试
- en: JMH empowers Java developers to create and implement benchmarks. Analyzing the
    results can help developers make informed decisions based on an analysis of empirical
    data. This can lead to more performant Java applications.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: JMH赋予Java开发者创建和实施基准的能力。分析结果可以帮助开发者根据经验数据进行分析，从而做出明智的决策。这可以导致更高效的Java应用程序。
- en: Netty
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Netty
- en: Netty, cutely named for networking, is a high-performance, event-driven application
    framework. This framework helps developers create network applications by simplifying
    network functionality programming such as with **User Datagram Protocol** (**UDP**)
    and **Transmission Control Protocol** (**TCP**) socket servers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Netty，因其网络特性而巧妙地命名，是一个高性能、事件驱动的应用程序框架。这个框架通过简化网络功能编程（如使用**用户数据报协议**（UDP）和**传输控制协议**（TCP）套接字服务器）来帮助开发者创建网络应用程序。
- en: Network programming often involves low-level APIs and Netty provides a level
    of abstraction making it easier to develop with. The Netty architecture is scalable,
    supports many connections, and is designed to minimize latency and resource overhead.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 网络编程通常涉及低级API，Netty提供了一定程度的抽象，使其更容易开发。Netty架构可扩展，支持许多连接，并设计用于最小化延迟和资源开销。
- en: Core features
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心功能
- en: 'Netty is the framework of choice for many network developers due to its reliability,
    scalability, and ease of use. The core features of Netty include the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其可靠性、可扩展性和易用性，Netty是许多网络开发者的首选框架。Netty的核心功能包括以下内容：
- en: '**Built-in codec support**: Netty has built-in encoders and decoders to help
    developers work with various protocols including HTTP and WebSocket. Netty negates
    the need for separate implementations for supported protocols.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内置编解码器支持**：Netty具有内置的编解码器，可以帮助开发人员处理包括HTTP和WebSocket在内的各种协议。Netty否定了为支持的协议进行单独实现的需要。'
- en: '**Customizable pipeline**: The Netty framework includes a pipeline architecture
    that facilitates data encapsulation and handlers. It uses a modular approach,
    making pipeline configuration an easy task for developers.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可定制管道**：Netty框架包括一个管道架构，该架构有助于数据封装和处理程序。它采用模块化方法，使管道配置对开发人员来说变得简单易行。'
- en: '**Event-driven**: Netty’s event-driven design results in asynchronous input/output
    handling. This non-blocking approach minimizes network latency.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件驱动**：Netty的事件驱动设计导致异步输入/输出处理。这种非阻塞方法最小化了网络延迟。'
- en: Armed with an understanding of Netty’s core features, let’s review performance
    considerations.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解Netty核心功能的基础上，让我们回顾性能考虑因素。
- en: Performance considerations
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能考虑因素
- en: 'Our focus throughout this book has been on high-performance Java applications.
    Netty is a great addition to our high-performance tool kit. It emphasizes high
    performance with its **thread model flexibility** and **zero-copy capabilities**.
    Let’s look at those performance considerations:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们的重点是高性能Java应用程序。Netty是我们高性能工具套件的一个很好的补充。它通过其**线程模型灵活性**和**零拷贝能力**强调高性能。让我们看看那些性能考虑因素：
- en: '**Thread model flexibility**: Netty’s thread management is highly configurable.
    Developers can configure Netty to manage their application’s threads based on
    specific use cases, such as scaling up or down and reducing the number of threads.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程模型灵活性**：Netty的线程管理高度可配置。开发人员可以根据特定的用例（如扩展或缩减规模以及减少线程数量）配置Netty来管理其应用程序的线程。'
- en: '**Zero-copy capabilities**: Netty’s zero-copy API helps make data processing
    (input and output) more efficient. This is accomplished by minimizing unnecessary
    memory duplication.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**零拷贝能力**：Netty的零拷贝API有助于使数据处理（输入和输出）更高效。这是通过最小化不必要的内存复制来实现的。'
- en: Let’s look at an example of using Netty to create an echo server that simply
    echoes data it receives to the client.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用Netty创建一个回显服务器的示例，该服务器简单地将其接收到的数据回显给客户端。
- en: Implementation
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'The following example demonstrates the relative ease with which Netty can be
    used to handle network events and how Netty can facilitate high performance in
    network communications. Note that you will document your dependencies in the `pom.xml`
    file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了Netty处理网络事件相对容易，以及Netty如何促进网络通信中的高性能。请注意，你将在`pom.xml`文件中记录你的依赖项：
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is simulated output of the Netty echo server:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是Netty回显服务器的模拟输出：
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Netty is a mature and robust framework for network application development.
    It is inherently scalable and offers performance benefits with network functionality.
    Netty also introduces development efficiencies and shorter development times.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Netty是一个成熟且健壮的网络应用程序开发框架。它本身具有可伸缩性，并提供了网络功能方面的性能优势。Netty还引入了开发效率和更短的开发时间。
- en: FasterXML Jackson
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FasterXML Jackson
- en: 'JSON is a file format used for interchanging data. It is structured and human-readable
    text used to transmit data objects. The format consists of arrays and attribute-value
    pairs. The example JSON object provided in the following code block represents
    a user profile for a social media system. As you can see, the fields contain the
    user’s name, age, email address, and hobbies:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: JSON是一种用于数据交换的文件格式。它是有结构和可读的文本，用于传输数据对象。该格式由数组和属性值对组成。以下代码块中提供的示例JSON对象代表一个社交媒体系统的用户配置文件。正如你所看到的，字段包含用户的姓名、年龄、电子邮件地址和爱好：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This JSON object consists of attribute-value or key-value pairs and an array
    of strings for the user’s hobbies. JSON is a common method of data representation
    in data storage and web applications.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个JSON对象由属性值或键值对以及用户爱好的字符串数组组成。JSON是数据存储和Web应用程序中数据表示的常用方法。
- en: '**FasterXML Jackson** is a library with the primary ability to rapidly process
    and create JSON objects. These objects are read sequentially and FasterXML Jackson,
    referred to from this point as **Jackson**, uses a cursor to keep track of its
    place. Jackson is lauded as a performance maximizer and memory minimizer.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**FasterXML Jackson**是一个具有快速处理和创建JSON对象主要能力的库。这些对象是顺序读取的，从现在起称为**Jackson**，它使用游标来跟踪其位置。Jackson被誉为性能最大化者和内存最小化者。'
- en: The *XML* in *FasterXML Jackson* suggests it can handle XML files too. In addition
    to Jackon’s ability to rapidly process JSON, it can also process **Comma-Separated
    Values** (**CSV**), **eXtensible Markup Language** (**XML**), **YAML Ain’t Markup
    Language** (**YAML**), and other file formats.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*FasterXML Jackson*中的*XML*表明它也能处理XML文件。除了Jackson快速处理JSON的能力外，它还可以处理**逗号分隔值**（**CSV**）、**可扩展标记语言**（**XML**）、**YAML
    Ain’t Markup Language**（**YAML**）和其他文件格式。'
- en: Core features
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心特性
- en: 'Core features of Jackson include the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Jackson的核心特性包括以下内容：
- en: '**Data binding**: Data binding is a Jackson feature that supports efficient
    and reliable conversion between Java objects and JSON text. Implementation is
    straightforward.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据绑定**：数据绑定是Jackson的一个特性，它支持高效且可靠的Java对象与JSON文本之间的转换。实现方式简单直接。'
- en: Data binding
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定
- en: A technique in computer programming that links (binds) data sources to the sender
    (provider) and receiver (client).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机编程中的一种技术，它将数据源（提供者）和接收者（客户端）链接（绑定）在一起。
- en: '**Streaming API**: Jackon has a highly efficient, low-level streaming API for
    parsing and generating JSON.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流式API**：Jackson有一个高效、低级的流式API用于解析和生成JSON。'
- en: '**Tree model**: When flexible JSON operations are needed, Jackson’s tree model
    can be implemented to represent JSON documents in a tree structure – a tree of
    nodes. This is often used when the JSON structures are complex.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**树模型**：当需要灵活的JSON操作时，Jackson的树模型可以实现，以树结构表示JSON文档——节点树。这通常用于JSON结构复杂的情况下。'
- en: Now that you understand Jackson’s core features, let’s review performance considerations.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了Jackson的核心特性，让我们回顾一下性能考虑因素。
- en: Performance considerations
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能考虑
- en: 'The performance considerations detailed here illustrate how Jackson was designed
    as a performance-focused library:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里详细说明的性能考虑因素展示了Jackson是如何被设计为一个以性能为重点的库：
- en: '**Custom serialization and deserialization**: Jackson empowers developers to
    define their own serializers and deserializers for custom fields. This can lead
    to significant performance enhancements.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义序列化和反序列化**：Jackson使开发者能够为自定义字段定义自己的序列化和反序列化器。这可以带来显著的性能提升。'
- en: '**Zero-copy**: Like Netty, Jackson’s zero-copy API helps make data processing
    (input and output) efficient. This is accomplished by minimizing unnecessary memory
    duplication.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**零拷贝**：与Netty一样，Jackson的零拷贝API有助于使数据处理（输入和输出）高效。这是通过最小化不必要的内存复制来实现的。'
- en: Let’s look at an example of using Jackson to serialize and deserialize Java
    objects.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用Jackson序列化和反序列化Java对象的示例。
- en: Implementation
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'Let’s start by adding dependencies to our `pom.xml` file to include Jackson
    in our project. Here is what that might look like:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先在我们的`pom.xml`文件中添加依赖项，以将Jackson包含到我们的项目中。这可能看起来是这样的：
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following example illustrates how straightforward Jackson is for developing
    object serialization and deserialization:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了Jackson在开发对象序列化和反序列化方面的直接性：
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this section, we learned that Jackson is a key tool for processing JSON.
    It is fast, flexible, and robust. Jackson can be the first tool you think of when
    needing to work with JSON in your Java applications.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解到Jackson是处理JSON的关键工具。它速度快、灵活且健壮。当需要在Java应用程序中处理JSON时，Jackson可能是你首先想到的工具。
- en: Other notable libraries
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他值得注意的库
- en: 'So far, we have covered JMH, Netty, and Jackson and posited that they are core
    libraries focused on high performance in Java. Each is designed for a specific
    type of task. There are other libraries available that are worth learning about.
    This section explores three additional libraries: **Agrona**, **Eclipse Collections**,
    and **Guava**.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了JMH、Netty和Jackson，并提出了它们是专注于Java高性能的核心库。每个库都是为特定类型的任务设计的。还有其他值得学习的库。本节探讨了三个额外的库：**Agrona**、**Eclipse
    Collections**和**Guava**。
- en: Agrona
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Agrona
- en: Agrona is a data structure collection specifically designed for creating high-performance
    Java applications. These data structures include maps and ring buffers. An example
    use case is a stock trading application whose success hinges on low latency.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Agrona是一个专门设计用于创建高性能Java应用程序的数据结构集合。这些数据结构包括映射和环形缓冲区。一个示例用例是一个股票交易应用程序，其成功取决于低延迟。
- en: 'Key features of Agrona include the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Agrona的关键特性包括以下内容：
- en: Non-blocking data structures – this supports high throughput and results in
    low latency
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非阻塞数据结构——这支持高吞吐量和低延迟
- en: Specifically designed for high-frequency stock and securities trading systems
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专门为高频股票和证券交易系统设计
- en: Uses direct buffers, contributing to off-heap memory management efficiencies
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用直接缓冲区，有助于提高堆外内存管理的效率
- en: 'Let’s look at an implementation example of Agrona that illustrates how to use
    a specific high-performance data structure. For our example, we will use the `ManyToOneConcurrentArrayQueue`
    data structure:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Agrona 的实现示例，它说明了如何使用特定的性能数据结构。在我们的示例中，我们将使用 `ManyToOneConcurrentArrayQueue`
    数据结构：
- en: '[PRE7]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see in the preceding code and surmise from the in-code comments,
    we initialize `ManyToOneConcurrentArrayQueue` with a capacity value of `10`. This
    type of queue is well suited for use cases where there is a single **customer**
    and multiple **producers**. Our example includes consumer and producer threads.
    The code implemented basic thread handling.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面代码中看到的，并从代码注释中推断，我们使用容量值 `10` 初始化 `ManyToOneConcurrentArrayQueue`。这种类型的队列非常适合只有一个
    **客户** 和多个 **生产者** 的用例。我们的示例包括消费者和生产者线程。代码实现了基本的线程处理。
- en: Eclipse Collections
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Eclipse Collections
- en: Eclipse Collections is a set of memory-efficient algorithms and data structures.
    These collections can be used to significantly improve performance. Engineered
    for large-scale systems, Eclipse collections come in both mutable and immutable
    forms. They offer efficient memory management.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse Collections 是一组内存高效的算法和数据结构。这些集合可以用来显著提高性能。为大规模系统设计，Eclipse Collections
    提供了可变和不可变两种形式。它们提供了高效的内存管理。
- en: 'Key features of Eclipse collections include the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse Collections 的关键特性包括以下内容：
- en: A comprehensive set of data structures to include bags, lists, maps, sets, stacks,
    and more
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个全面的数据结构集合，包括包、列表、映射、集合、栈等
- en: Primitive collections and associated classes
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始集合及其相关类
- en: Utility methods that can transform collections and be used for filtering, iterating,
    and sorting
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以转换集合并用于过滤、迭代和排序的实用方法
- en: 'Let’s demonstrate how to use an `ImmutableList` from an Eclipse collection.
    This is one of the more memory-efficient collections:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们演示如何使用 Eclipse Collections 中的 `ImmutableList`。这是更内存高效的集合之一：
- en: '[PRE8]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our example starts with the creation of an immutable list of fruits. Next, we
    add an element to the list, then we iterate through the list for output.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例从创建一个不可变的水果列表开始。接下来，我们在列表中添加一个元素，然后遍历列表进行输出。
- en: 'To use Eclipse Collections in our applications, we need to include the library
    in our project. With the example of Maven, we would simply add the following to
    our `pom.xml` file:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的应用程序中使用 Eclipse Collections，我们需要将库包含到我们的项目中。以 Maven 为例，我们只需简单地将以下内容添加到我们的
    `pom.xml` 文件中：
- en: '[PRE9]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Our code snippet provided a basic introduction to using Eclipse Collections.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供的代码片段为使用 Eclipse Collections 提供了基本介绍。
- en: Guava
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Guava
- en: 'Guava is a product from Google that includes new collection types such as multimap
    and multiset. It also includes immutable collections, a graph library, support
    for primitives, and caching utilities. Here is a list of key features of Guava:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Guava 是来自 Google 的一个产品，包括新的集合类型，如 multimap 和 multiset。它还包括不可变集合、图形库、对原生的支持以及缓存实用工具。以下是
    Guava 的关键特性列表：
- en: Advanced collection types.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级集合类型。
- en: Advanced collection utilities.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级集合实用工具。
- en: Caching support using `CacheBuilder`. This can be used to improve application
    speed.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `CacheBuilder` 的缓存支持。这可以用来提高应用程序的速度。
- en: Utilities for concurrency.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发实用工具。
- en: Utilities for hashing.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希实用工具。
- en: Utilities for input/output operations.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入/输出操作实用工具。
- en: 'Here is an example application that demonstrates the use of Guava’s `CacheBuilder`.
    The application creates a cache that automatically loads and stores value-based
    keys:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例应用程序，展示了 Guava 的 `CacheBuilder` 的使用。该应用程序创建了一个自动加载和存储基于值的键的缓存：
- en: '[PRE10]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Java has several libraries and frameworks that can be used to improve overall
    performance. Understanding what libraries are available to us and how to implement
    them can be crucial to an application’s success.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Java 有几个库和框架可以用来提高整体性能。了解我们可用的库以及如何实现它们对于应用程序的成功至关重要。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter explored several key high-performance libraries that we can employ
    to improve the performance of our Java applications. Specifically, we reviewed
    JMH and indicated that it provides reliable performance benchmarking. We also
    looked at Netty and identified its applicability to improving the performance
    of network applications. FastXML Jackson was also reviewed for its specialized
    use in handling JSON objects. Lastly, we covered three additional libraries: Agrona,
    Eclipse Collections, and Guava.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了几个关键的高性能库，我们可以利用这些库来提升我们的Java应用程序的性能。具体来说，我们回顾了JMH，并指出它提供了可靠的性能基准测试。我们还研究了Netty，并确定了它在提升网络应用程序性能方面的适用性。FastXML
    Jackson也被审查，因为它在处理JSON对象方面的专用用途。最后，我们还介绍了三个额外的库：Agrona、Eclipse Collections和Guava。
- en: Each library featured in the chapter is tailored to a specific Java programming
    need. These tools are poised to help us significantly improve the performance
    of our Java applications. Experimenting with these libraries with your own Java
    projects can help solidify your understanding of them and the best use case for
    each of them. Furthermore, implementing these libraries appropriately can lead
    to overall improved performance of your Java application.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中介绍的所有库都是针对特定的Java编程需求定制的。这些工具有望帮助我们显著提升Java应用程序的性能。在自己的Java项目中尝试这些库可以帮助巩固你对它们的理解，以及每个库的最佳使用案例。此外，适当地实现这些库可以导致Java应用程序的整体性能提升。
