- en: Chapter 4. File Upload and Error Handling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 文件上传和错误处理
- en: In this chapter, we will enable our user to upload a profile picture. We will
    also see how to handle errors in Spring MVC.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使我们的用户能够上传个人资料图片。我们还将了解如何在 Spring MVC 中处理错误。
- en: Uploading a file
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上传文件
- en: 'We will now make it possible for our user to upload a profile picture. This
    will be available from the profile page later on, but for now, we will simplify
    things and create a new page in the templates directory under `profile/uploadPage.html`:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使我们的用户能够上传个人资料图片。这将在稍后的个人资料页面中提供，但现在，我们将简化事情，并在模板目录下的 `profile/uploadPage.html`
    中创建一个新的页面：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Not much to see besides the `enctype` attribute on the form. The file will
    be sent by the `POST` method to the `upload` URL. We will now create the corresponding
    controller right beside `ProfileController` in the `profile` package:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 除了表单上的 `enctype` 属性外，没有太多可看的内容。文件将通过 `POST` 方法发送到 `upload` URL。现在，我们将在 `profile`
    包中的 `ProfileController` 旁边创建相应的控制器：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first thing this code will do is create a temporary file in the `pictures`
    directory, which can be found inside the project's root folder; so, ensure that
    it exists. In Java, a temporary file is just a commodity to obtain a unique file
    identifier on the filesystem. It is up to the user to optionally delete it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先会在 `pictures` 目录中创建一个临时文件，该目录位于项目的根文件夹内；因此，请确保它存在。在 Java 中，临时文件只是用于在文件系统中获取唯一文件标识符的一种商品。用户可以选择性地删除它。
- en: Create a pictures directory at the root of the project and add an empty file
    called `.gitkeep` to ensure that you can commit it in Git.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的根目录下创建一个图片目录，并添加一个名为 `.gitkeep` 的空文件，以确保您可以在 Git 中提交它。
- en: Tip
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Empty directories in Git**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**Git 中的空目录**'
- en: Git is file-based and it is not possible to commit an empty directory. A common
    workaround is to commit an empty file, such as `.gitkeep`, in a directory to force
    Git to keep it under version control.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Git 是基于文件的，无法提交空目录。一个常见的解决方案是在目录中提交一个空文件，例如 `.gitkeep`，以强制 Git 将其纳入版本控制。
- en: The file uploaded by the user will be injected as a `MultipartFile` interface
    in our controller. This interface provides several methods to get the name of
    the file, its size, and its contents.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 用户上传的文件将被注入到我们的控制器中的 `MultipartFile` 接口中。该接口提供了几种方法来获取文件名、大小和内容。
- en: The method that particularly interests us here is `getInputStream()`. We will
    indeed copy this stream to a `fileOutputStream` method, thanks to the `IOUtils.copy`
    method. The code to write an input stream to an output stream is pretty boring,
    so it's handy to have the Apache Utils in the classpath (it is part of the `tomcat-embedded-core.jar`
    file).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们特别感兴趣的方法是 `getInputStream()`。我们将使用 `IOUtils.copy` 方法将这个流复制到 `fileOutputStream`
    方法中。将输入流写入输出流的代码相当无聊，所以将 Apache Utils 添加到类路径中很方便（它是 `tomcat-embedded-core.jar`
    文件的一部分）。
- en: 'We make heavy use of the pretty cool Spring and Java 7 NIO features:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们大量使用了相当酷的 Spring 和 Java 7 NIO 功能：
- en: The resource class of string is a utility class that represents an abstraction
    of resources that can be found in different ways
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串的资源类是一个实用工具类，它表示可以通过不同方式找到的资源抽象。
- en: The `try…with` block will automatically close our streams even in the case of
    an exception, removing the boilerplate of writing a `finally` block
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try…with` 块将自动关闭我们的流，即使在异常的情况下也会关闭，从而消除了编写 `finally` 块的样板代码。'
- en: With the preceding code, any file uploaded by the user will be copied into the
    `pictures` directory.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，用户上传的任何文件都将被复制到 `pictures` 目录中。
- en: There are a handful of properties available in Spring Boot to customize file
    upload. Take a look at the `MultipartProperties` class.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spring Boot 中有一些可用的属性来定制文件上传。看看 `MultipartProperties` 类。
- en: 'The most interesting ones are:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的是：
- en: '`multipart.maxFileSize`: This defines the maximum file size allowed for the
    uploaded files. Trying to upload a bigger one will result in a `MultipartException`
    class. The default value is `1Mb`.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`multipart.maxFileSize`：这定义了允许上传文件的最大文件大小。尝试上传更大的文件将导致 `MultipartException`
    类异常。默认值是 `1Mb`。'
- en: '`multipart.maxRequestSize`: This defines the maximum size of the multipart
    request. The default value is `10Mb`.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`multipart.maxRequestSize`：这定义了多部分请求的最大大小。默认值是 `10Mb`。'
- en: 'The defaults are good enough for our application. After a few uploads, our
    picture directory will look like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值对我们的应用程序来说已经足够好了。上传几次之后，我们的图片目录将看起来像这样：
- en: '![Uploading a file](img/2117_04_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![上传文件](img/2117_04_01.jpg)'
- en: 'Wait! Somebody uploaded a ZIP file! I cannot believe it. We better add some
    checks in our controller to ensure that the uploaded files are real images:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 等等！有人上传了一个ZIP文件！我简直不敢相信。我们最好在我们的控制器中添加一些检查，以确保上传的文件是真实的图片：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Pretty easy! The `getContentType()` method returns the **Multipurpose Internet
    Mail Extensions** (**MIME**) type of the file. It will be `image/png`, `image/jpg`,
    and so on. So we just have to check if the MIME type starts with "image".
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单！`getContentType()`方法返回文件的**多用途互联网邮件扩展**（**MIME**）类型。它将是`image/png`、`image/jpg`等等。所以我们只需要检查MIME类型是否以"image"开头。
- en: 'We added an error message to the form so we should add something in our web
    page to display it. Place the following code just under the title in the `uploadPage`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在表单中添加了一个错误消息，所以我们应该在我们的网页中添加一些内容来显示它。将以下代码放在`uploadPage`标题下方：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The next time you try to upload a ZIP file, you will get an error! This is
    shown in the following screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下次你尝试上传ZIP文件时，你会得到一个错误！如下截图所示：
- en: '![Uploading a file](img/2117_04_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![上传文件](img/2117_04_02.jpg)'
- en: Writing an image to the response
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将图片写入响应
- en: The uploaded images are not served from the static directories. We will need
    to take special measures to display them in our web page.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 上传的图片不是从静态目录中提供的。我们需要采取特殊措施在网页中显示它们。
- en: 'Let''s add the following lines to our upload page, just above the form:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在表单上方添加以下行：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will try and get the image from our controller. Let''s add the corresponding
    method to the `PictureUploadController` class:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将尝试从我们的控制器中获取图片。让我们在`PictureUploadController`类中添加相应的方法：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code will write an image found in the `src/main/resources/images/anonymous.png`
    directory directly to the response! How exciting!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将直接将`src/main/resources/images/anonymous.png`目录中的图片写入响应！多么令人兴奋！
- en: 'If we go to our page again, we will see the following image:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次访问我们的页面，我们会看到以下图片：
- en: '![Writing an image to the response](img/2117_04_03.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![将图片写入响应](img/2117_04_03.jpg)'
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: I found the anonymous user image on iconmonstr ([http://iconmonstr.com/user-icon](http://iconmonstr.com/user-icon))
    and downloaded it as a 128 x 128 PNG file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我在iconmonstr([http://iconmonstr.com/user-icon](http://iconmonstr.com/user-icon))上找到了匿名用户头像并将其下载为128
    x 128的PNG文件。
- en: Managing upload properties
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理上传属性
- en: A good thing to do at this point is to allow the configuration of the upload
    directory and the path to the anonymous user image through the `application.properties`
    file.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，允许通过`application.properties`文件配置上传目录和匿名用户图片的路径是个好主意。
- en: 'Let''s create a `PicturesUploadProperties` class inside a newly created `config`
    package:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在新创建的`config`包中创建一个`PicturesUploadProperties`类：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this class, we make use of the Spring Boot `ConfigurationProperties`. This
    will tell Spring Boot to automatically map properties found in the classpath (by
    default, in the `application.properties` file) in a type-safe fashion.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们使用了Spring Boot的`ConfigurationProperties`。这将告诉Spring Boot以类型安全的方式自动映射在类路径中找到的属性（默认情况下，在`application.properties`文件中）。
- en: Notice that we defined setters taking 'String's as arguments but are at liberty
    to let the getters return any type is the most useful.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们定义了接受'String'作为参数的setter，但允许getters返回任何类型是最有用的。
- en: 'We now need to add the `PicturesUploadProperties` class to our configuration:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将`PicturesUploadProperties`类添加到我们的配置中：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can now add the properties'' values inside the `application.properties`
    file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在`application.properties`文件中添加属性的值：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Because we use Spring's `DefaultResourceLoader` class, we can use prefixes such
    as `file:` or `classpath:` to specify where our resources can be found.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了Spring的`DefaultResourceLoader`类，我们可以使用`file:`或`classpath:`等前缀来指定我们的资源可以在哪里找到。
- en: This would be the equivalent of creating a `FileSystemResource` class or a `ClassPathResource`
    class.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于创建一个`FileSystemResource`类或`ClassPathResource`类。
- en: This approach also has the advantage of documenting the code. We can easily
    see that the picture directory will be found in the application root, whereas
    the anonymous picture will be found in the classpath.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法也有文档化的优势。我们可以很容易地看到图片目录将在应用程序根目录中找到，而匿名图片将在类路径中找到。
- en: 'That''s it. We can now use our properties inside our controller. The following
    are the relevant parts of the `PictureUploadController` class:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。我们现在可以在我们的控制器中使用我们的属性。以下是`PictureUploadController`类的相关部分：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: At this point, if you launch your application again, you will see that the result
    hasn't changed. The anonymous picture is still displayed and the pictures uploaded
    by our users still end up in the `pictures` directory at the project root.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，如果你再次启动你的应用程序，你会看到结果并没有改变。匿名图片仍然被显示，用户上传的图片仍然位于项目根目录下的`pictures`目录中。
- en: Displaying the uploaded picture
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示上传的图片
- en: 'It would be nice to display the user''s picture now, wouldn''t it? To do this,
    we will add a model attribute to our `PictureUploadController` class:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在显示用户的图片不是很好吗？为了做到这一点，我们将在`PictureUploadController`类中添加一个模型属性：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can now inject it to retrieve its value when we serve the uploaded picture:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以注入它以在服务上传的图片时检索其值：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `@ModelAttribute` annotation is a handy way to create model attributes with
    an annotated method. They can then be injected with the same annotation into controller
    methods. With this code, a `picturePath` parameter will be available in the model
    as long as we are not redirected to another page. Its default value is the anonymous
    picture we defined in our properties.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ModelAttribute`注解是一个创建带有注解方法的模型属性的便捷方式。然后，它们可以用相同的注解注入到控制器方法中。使用这段代码，只要我们没有重定向到另一个页面，`picturePath`参数就会在模型中可用。它的默认值是我们定义在属性文件中的匿名图片。'
- en: 'We need to update this value when the file is uploaded. Update the `onUpload`
    method:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在文件上传时更新此值。更新`onUpload`方法：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: By injecting the model, we can update the `picturePath` parameter after the
    upload is complete.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过注入模型，我们可以在上传完成后更新`picturePath`参数。
- en: Now, the problem is that our two methods, `onUpload` and `getUploadedPicture`,
    will occur in different requests. Unfortunately, the model attributes will be
    reset between each.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，问题是我们的两个方法，`onUpload`和`getUploadedPicture`，将在不同的请求中发生。不幸的是，模型属性将在每次之间重置。
- en: 'That''s why we will define the `picturePath` parameter as a session attribute.
    We can do this by adding another annotation to our controller class:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将`picturePath`参数定义为会话属性。我们可以通过向我们的控制器类添加另一个注解来实现这一点：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Phew! That''s a lot of annotations just to handle a simple session attribute.
    You will get the following output:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！仅仅为了处理一个简单的会话属性，就需要这么多注解。你将得到以下输出：
- en: '![Displaying the uploaded picture](img/2117_04_04.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![显示上传的图片](img/2117_04_04.jpg)'
- en: This approach makes code composition really easy. Plus, we didn't use `HttpServletRequest`
    or `HttpSession` directly. Moreover, our object can be typed easily.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使代码组合变得非常容易。此外，我们没有直接使用`HttpServletRequest`或`HttpSession`。此外，我们的对象可以轻松地进行类型化。
- en: Handling file upload errors
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理文件上传错误
- en: 'It must have certainly occurred to my attentive readers that our code is susceptible
    to throw two kinds of exceptions:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一定已经让我的细心读者意识到，我们的代码可能会抛出两种类型的异常：
- en: '`IOException`: This error is thrown if something bad happens while writing
    the file to disk.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IOException`：如果在将文件写入磁盘时发生错误，则会抛出此错误。'
- en: '`MultipartException`: This error is thrown if an error occurs while uploading
    the file. For instance, when the maximum file size is exceeded.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MultipartException`：如果在上传文件时发生错误，则会抛出此错误。例如，当超过最大文件大小时。'
- en: 'This will give us a good opportunity to look at two ways of handling exceptions
    in Spring:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们一个很好的机会来探讨在Spring中处理异常的两种方式：
- en: Using the `@ExceptionHandler` annotation locally in a controller method
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在控制器方法中局部使用`@ExceptionHandler`注解
- en: Using a global exception handler defined at the Servlet container level
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用在Servlet容器级别定义的全局异常处理器
- en: 'Let''s handle `IOException` with the `@ExceptionHandler` annotation inside
    our `PictureUploadController` class by adding the following method:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`PictureUploadController`类中通过添加以下方法来使用`@ExceptionHandler`注解处理`IOException`：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is a simple yet powerful approach. This method will be called every time
    an `IOException` is thrown in our controller.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单而强大的方法。每次在我们的控制器中抛出`IOException`时，都会调用此方法。
- en: 'In order to test the exception handler, since making the Java IO code throw
    an exception can be tricky, just replace the `onUpload` method body during the
    test:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试异常处理器，由于使Java IO代码抛出异常可能很棘手，只需在测试期间替换`onUpload`方法体：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After this change, if we try to upload a picture, we will see the error message
    of this exception displayed on the upload page:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在此更改之后，如果我们尝试上传图片，我们将在上传页面上看到此异常的错误消息：
- en: '![Handling file upload errors](img/2117_04_05.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![处理文件上传错误](img/2117_04_05.jpg)'
- en: Now, we will handle the `MultipartException`. This needs to happen at the Servlet
    container level (that is, at the Tomcat level), as this exception is not thrown
    directly by our controller.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将处理`MultipartException`。这需要在Servlet容器级别（即Tomcat级别）发生，因为这个异常不是由我们的控制器直接抛出的。
- en: 'We will need to add a new `EmbeddedServletContainerCustomizer` bean to our
    configuration. Add this method to the `WebConfiguration` class:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要向我们的配置中添加一个新的`EmbeddedServletContainerCustomizer` bean。将此方法添加到`WebConfiguration`类中：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is a little verbose. Note that `EmbeddedServletContainerCustomizer` is
    an interface that contains a single method; it can therefore be replaced by a
    lambda expression:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点冗长。请注意，`EmbeddedServletContainerCustomizer`是一个包含单个方法的接口；因此，它可以被lambda表达式替换：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'So, let''s just write the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们只需写下以下内容：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This code creates a new error page, which will be called when a `MultipartException`
    happens. It can also be mapped to an HTTP status. The `EmbeddedServletContainerCustomizer`
    interface has many other features that will allow the customization of the Servlet
    container in which our application runs. Visit [http://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-customizing-embedded-containers](http://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-customizing-embedded-containers)
    for more information.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个新的错误页面，当发生`MultipartException`时将被调用。它也可以映射到HTTP状态。`EmbeddedServletContainerCustomizer`接口还有许多其他功能，将允许定制我们的应用程序运行在其中的Servlet容器。访问[http://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-customizing-embedded-containers](http://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-customizing-embedded-containers)获取更多信息。
- en: 'We now need to handle this `uploadError` URL in our `PictureUploadController`
    class:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要在我们的`PictureUploadController`类中处理这个`uploadError` URL：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The error pages defined in a Servlet environment contain a number of interesting
    attributes that will help debug the error:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在Servlet环境中定义的错误页面包含了一些有趣的属性，这些属性将有助于调试错误：
- en: '| Attribute | Description |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `javax.servlet.error.status_code` | This is the HTTP status code of the error.
    |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `javax.servlet.error.status_code` | 这是错误的HTTP状态码。|'
- en: '| `javax.servlet.error.exception_type` | This is the exception class. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `javax.servlet.error.exception_type` | 这是异常类。|'
- en: '| `javax.servlet.error.message` | This is the message of the exception thrown.
    |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `javax.servlet.error.message` | 这是抛出异常的消息。|'
- en: '| `javax.servlet.error.request_uri` | This is the URI on which the exception
    occurred. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `javax.servlet.error.request_uri` | 这是异常发生的URI。|'
- en: '| `javax.servlet.error.exception` | This is the actual exception. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `javax.servlet.error.exception` | 这是实际的异常。|'
- en: '| `javax.servlet.error.servlet_name` | This is the name of the Servlet that
    caught the exception. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `javax.servlet.error.servlet_name` | 这是捕获异常的Servlet的名称。|'
- en: All these attributes are conveniently accessible on the `WebUtils` class of
    Spring Web.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些属性都可以方便地在Spring Web的`WebUtils`类中访问。
- en: If someone tries to upload too big a file, they will get a very clear error
    message.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人尝试上传太大的文件，他们将收到一个非常清晰的错误消息。
- en: 'You can now test that the error is handled correctly by uploading a really
    big file (> 1Mb) or setting the `multipart.maxFileSize` property to a lower value:
    1kb for instance:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以通过上传一个非常大的文件（> 1Mb）或将`multipart.maxFileSize`属性设置为更低的值（例如：1kb）来测试错误是否被正确处理：
- en: '![Handling file upload errors](img/2117_04_06.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![处理文件上传错误](img/2117_04_06.jpg)'
- en: Translating the error messages
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 翻译错误消息
- en: 'It is really good for a developer to see the exceptions thrown by the application.
    However, for our users, they bear little value. We will therefore translate them.
    In order to do that, we have to inject our application''s `MessageSource` class
    into our controller''s constructor:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发者来说，看到应用程序抛出的异常是非常有用的。然而，对于我们的用户来说，它们的价值很小。因此，我们将翻译它们。为了做到这一点，我们必须在我们的控制器构造函数中注入我们的应用程序的`MessageSource`类：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, we can retrieve messages from our messages bundle:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从我们的消息包中检索消息：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here are the English messages:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是英文消息：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, the French ones:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们处理法语消息：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Placing the profile in a session
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将配置文件放在会话中
- en: The next thing we want is the profile to be stored in a session so that it does
    not get reset every time we go on the profile page. This can apparently prove
    tiresome to some users and we have to address it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来想要的是将配置文件存储在会话中，这样每次我们访问配置文件页面时它就不会被重置。这可能会让一些用户感到烦恼，我们必须解决这个问题。
- en: Tip
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**HTTP sessions** are a way to store information between requests. HTTP is
    a stateless protocol, which means that there is no way to relate two requests
    coming from the same user. What most Servlet containers do is they associate a
    cookie called `JSESSIONID` to each user. This cookie will be transmitted in the
    request header and will allow you to store arbitrary objects in a map, an abstraction
    called `HttpSession`. Such a session will typically end when the user closes or
    switches web browsers or after a predefined period of inactivity.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTTP会话**是存储请求之间信息的一种方式。HTTP是一个无状态协议，这意味着无法关联来自同一用户的两个请求。大多数Servlet容器所做的是，它们将一个名为`JSESSIONID`的cookie与每个用户关联。这个cookie将在请求头中传输，并允许你在`HttpSession`这个抽象的map中存储任意对象。这样的会话通常在用户关闭或切换Web浏览器，或者经过预定义的不活动期后结束。'
- en: We just saw a method to put objects in a session using the `@SessionAttributes`
    annotation. This works well within a controller but makes the data difficult to
    share when spread across multiple controllers. We have to rely on a string to
    resolve the attribute from its name, which is hard to refactor. For the same reason,
    we don't want to manipulate the `HttpSession` directly. Another argument that
    will discourage the direct usage of the session is how difficult it is to unit
    test the controller that depends on it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了一个使用`@SessionAttributes`注解将对象放入会话中的方法。这在控制器内部工作得很好，但当数据分散在多个控制器之间时，会使数据共享变得困难。我们必须依赖于一个字符串来解析属性名称，这很难重构。出于同样的原因，我们不想直接操作`HttpSession`。另一个会阻止直接使用会话的论点是，依赖于它的控制器进行单元测试是多么困难。
- en: 'There is another popular approach when it comes to saving things in a session
    with Spring: annotate a bean with `@Scope("session")`.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Spring在会话中保存东西时，还有一种流行的方法：用`@Scope("session")`注解一个bean。
- en: You will then be able to inject your session bean in your controllers and other
    Spring components to either set or retrieve values from it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将能够将你的会话bean注入到你的控制器和其他Spring组件中，以便设置或从中检索值。
- en: 'Let''s create a `UserProfileSession` class in the `profile` package:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`profile`包中创建一个`UserProfileSession`类：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We have conveniently provided a way to convert from and to a `ProfileForm`
    object. This will help us store and retrieve the form data from our `ProfileController`
    constructor. We need to inject our `UserProfileSession` variable in the controller''s
    constructor and store it as a field. We also need to expose the `ProfileForm`
    as a model attribute, which will remove the need to inject it in the `displayProfile`
    method. Finally, we can save the profile once it has been validated:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个方便的方法来转换`ProfileForm`对象。这将帮助我们从`ProfileController`构造函数中存储和检索表单数据。我们需要在控制器构造函数中注入我们的`UserProfileSession`变量并将其存储为一个字段。我们还需要将`ProfileForm`作为模型属性暴露，这将消除在`displayProfile`方法中注入它的需要。最后，一旦验证通过，我们就可以保存配置文件：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: That's all it takes to save data in a session with Spring MVC.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用Spring MVC在会话中保存数据所需的所有步骤。
- en: Now, if you complete the profile form and refresh the page, the data will be
    persisted between requests.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你完成配置文件表单并刷新页面，数据将在请求之间持久化。
- en: Just before moving on to the next chapter, I want to detail a couple of concepts
    we just used.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一章之前，我想详细说明我们刚刚使用的一些概念。
- en: 'The first is the injection by the constructor. The `ProfileController` constructor
    is annotated with `@Autowired`, which means Spring will resolve the constructor
    arguments from the application context before instantiating the bean. The alternative,
    which is a little less verbose, would have been to use field injection:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种是通过构造函数进行注入。`ProfileController`构造函数被注解为`@Autowired`，这意味着Spring将在实例化bean之前从应用程序上下文中解析构造函数参数。另一种稍微不那么冗长的方法是使用字段注入：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Constructor injection is arguably better because it makes the unit testing of
    our controller easier if we were to move away from the `spring-test` framework
    and it makes the dependencies of our bean somewhat more explicit.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数注入可以说是更好的，因为它使得如果我们从`spring-test`框架中移除，我们的控制器单元测试更容易，并且使我们的bean的依赖关系更加明确。
- en: For a detailed discussion on field injection and constructor injection, refer
    to the excellent blog post by Oliver Gierke at [http://olivergierke.de/2013/11/why-field-injection-is-evil/](http://olivergierke.de/2013/11/why-field-injection-is-evil/).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 关于字段注入和构造函数注入的详细讨论，请参阅Oliver Gierke在[http://olivergierke.de/2013/11/why-field-injection-is-evil/](http://olivergierke.de/2013/11/why-field-injection-is-evil/)的优秀博客文章。
- en: 'Another thing that might need clarification is the `proxyMode` parameter on
    the `Scope` annotation:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能需要澄清的是`Scope`注解上的`proxyMode`参数：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'There are three `proxyMode` parameters available with Spring, if we don''t
    count the default one:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring中，如果我们不计默认的参数，有三个`proxyMode`参数可用：
- en: '`TARGET_CLASS`: This uses a CGI proxy'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TARGET_CLASS`：这使用CGI代理'
- en: '`INTERFACES`: This creates a JDK proxy'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INTERFACES`：这会创建一个JDK代理'
- en: '`NO`: This does not create any proxy'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NO`：这不会创建任何代理'
- en: The advantage of a proxy typically comes into play when you inject something
    into a long-lived component such as a singleton. Because injection only happens
    once, when the bean is created, subsequent calls to the injected bean might not
    reflect its actual state.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 代理的优点通常在将某些东西注入到长生命周期的组件（如单例）时体现出来。因为注入只发生在bean创建时，所以后续对注入bean的调用可能不会反映其实际状态。
- en: 'In our case, a session bean''s actual state is stored in the session and not
    directly on the bean. This explains why Spring has to create a proxy: it needs
    to intercept calls to our bean methods and listen for its mutations. This way,
    the state of the bean can be transparently stored and retrieved from the underlying
    HTTP session.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，会话bean的实际状态存储在会话中，而不是直接在bean上。这就解释了为什么Spring必须创建一个代理：它需要拦截对bean方法的调用并监听其变化。这样，bean的状态就可以透明地存储和从底层的HTTP会话中检索。
- en: For a session bean, we are forced to use a proxy mode. The CGI proxy will instrument
    your bytecode and work on any class, whereas the JDK approach might be a bit more
    lightweight but requires you to implement an interface.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于会话bean，我们被迫使用代理模式。CGI代理会对你的字节码进行操作，并适用于任何类，而JDK方法可能更轻量级，但需要你实现一个接口。
- en: Lastly, we made the `UserProfileSession` bean implement the `Serializable` interface.
    This is not strictly required because the HTTP sessions can store arbitrary objects
    in memory, but making objects that end up in the session serializable really is
    a good practice.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们让`UserProfileSession`bean实现了`Serializable`接口。这并不是严格必要的，因为HTTP会话可以在内存中存储任意对象，但将最终存储在会话中的对象序列化确实是一个好习惯。
- en: Indeed, we might change the way the session is persisted. In fact, we will store
    the session in a Redis database in [Chapter 8](ch08.html "Chapter 8. Optimizing
    Your Requests"), *Optimizing Your Requests*, where Redis has to work with `Serializable`
    objects. It's always best to think of the session of a generic data store. We
    have to provide a way to write and read objects from this storage system.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们可能会改变会话持久化的方式。实际上，我们将在第8章[优化您的请求](ch08.html "Chapter 8. Optimizing Your
    Requests")中存储会话到Redis数据库，其中Redis必须与`Serializable`对象一起工作。始终将通用数据存储的会话视为最佳做法。我们必须提供一种方法来从这个存储系统中写入和读取对象。
- en: For serialization to work properly on our bean, we also need every one of its
    field to be serializable. In our case, strings and dates are serializable so we
    are good to go.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的bean能够正确地进行序列化，我们还需要确保它的每个字段都是可序列化的。在我们的例子中，字符串和日期是可序列化的，所以我们一切准备就绪。
- en: Custom error pages
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义错误页面
- en: Spring Boot lets you define your own error view instead of the Whitelabel error
    page that we saw earlier. It must have the name `error` and its purpose is to
    handle all exceptions. The default `BasicErrorController` class will expose a
    lot of useful model attributes that you can display on this page.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot允许你定义自己的错误视图，而不是我们之前看到的Whitelabel错误页面。它必须命名为`error`，其目的是处理所有异常。默认的`BasicErrorController`类将公开许多有用的模型属性，你可以在页面上显示这些属性。
- en: 'Let''s create a custom error page in `src/main/resources/templates`. Let''s
    call it `error.html`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`src/main/resources/templates`中创建一个自定义错误页面。让我们称它为`error.html`：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, if we navigate to a URL that is not handled by our application, we see
    our custom error page:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们导航到一个我们的应用程序未处理的URL，我们会看到我们的自定义错误页面：
- en: '![Custom error pages](img/2117_04_07.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![自定义错误页面](img/2117_04_07.jpg)'
- en: A more advanced option to handle errors is to define your own implementation
    of the `ErrorController` class, a controller in charge of handling all the exceptions
    at a global level. Take a look at the `ErrorMvcAutoConfiguration` class and the
    `BasicErrorController` class, which is the default implementation.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 处理错误的一个更高级的选项是定义自己的`ErrorController`类实现，这是一个负责在全局级别处理所有异常的控制器。查看`ErrorMvcAutoConfiguration`类和默认实现`BasicErrorController`类。
- en: URL mapping with matrix variables
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有矩阵变量的URL映射
- en: We are now aware of what our user is interested in. It would be a good idea
    to improve our Tweet controller so that it allows searching from a list of keywords.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道用户感兴趣的内容。改进我们的推文控制器，使其能够从关键字列表中进行搜索，将是一个好主意。
- en: 'One interesting way to pass key-value pairs in a URL is to use a matrix variable.
    It is pretty similar to request parameters. Consider the following code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在URL中传递键值对的一个有趣方式是使用矩阵变量。它与请求参数非常相似。考虑以下代码：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Instead of the preceding parameter, matrix variables understand this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的参数不同，矩阵变量理解以下内容：
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'They also allow each parameter to be a list:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 它们还允许每个参数都是一个列表：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'A matrix variable can be mapped to different object types inside a controller:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵变量可以映射到控制器内部的不同对象类型：
- en: '`Map<String, List<?>>`: This handles multiple variables and multiple values'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map<String, List<?>>`：这处理多个变量和多个值'
- en: '`Map<String, ?>`: This handles a case in which each variable has only one value'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map<String, ?>`：这处理每个变量只有一个值的情况'
- en: '`List<?>`: This is used if we are interested in a single variable whose name
    can be configured'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<?>`：如果我们对单个变量感兴趣，其名称可以配置，则使用此'
- en: 'In our case, we want to handle something like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们想要处理类似以下内容：
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The first parameter, `popular`, is the result type known by the Twitter search
    API. It can take the following values: `mixed`, `recent`, or `popular`.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数`popular`是Twitter搜索API所知的结果类型。它可以取以下值：`mixed`、`recent`或`popular`。
- en: The rest of our URL is a list of keywords. We will therefore map them to a simple
    `List<String>` object.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们URL的其余部分是关键字列表。因此，我们将它们映射到一个简单的`List<String>`对象。
- en: By default, Spring MVC removes every character following a semicolon in a URL.
    The first thing we need to do to enable matrix variables in our application is
    to turn off this behavior.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Spring MVC会移除URL中分号后面的每个字符。为了在我们的应用程序中启用矩阵变量，我们首先需要关闭此行为。
- en: 'Let''s add the following code to our `WebConfiguration` class:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`WebConfiguration`类中添加以下代码：
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s create a new controller in the `search` package, which we will call
    `SearchController`. Its role is to handle the following request:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`search`包中创建一个新的控制器，我们将称之为`SearchController`。其作用是处理以下请求：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As you can see, we are able reuse the existing result page to display the tweets.
    We also want to delegate the search to another class called `SearchService`. We
    will create this service in the same package as `SearchController`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们能够重用现有的结果页面来显示推文。我们还希望将搜索委托给另一个名为`SearchService`的类。我们将在与`SearchController`相同的包中创建此服务：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, we need to implement the `search()` method.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要实现`search()`方法。
- en: The search operation accessible on `twitter.searchOperations().search(params)`
    takes `searchParameters` as an argument for an advanced search. This object allows
    us to conduct a search on a dozen of criteria. We are interested in the `query`,
    `resultType`, and `count` attributes.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在`twitter.searchOperations().search(params)`上可访问的搜索操作将`searchParameters`作为高级搜索的参数。此对象允许我们在十几个标准上进行搜索。我们对`query`、`resultType`和`count`属性感兴趣。
- en: 'First, we need to create a `ResultType` constructor with the `searchType` path
    variable. The `ResultType` is an enum, so we can iterate over its different values
    and find one that matches the input, ignoring the case:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个带有`searchType`路径变量的`ResultType`构造函数。`ResultType`是一个枚举，因此我们可以遍历其不同的值，找到一个与输入匹配的值，忽略大小写：
- en: '[PRE36]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can now create a `SearchParameters` constructor with the following method:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建一个带有以下方法的`SearchParameters`构造函数：
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, creating a list of the `SearchParameters` constructor is as easy as conducting
    a map operation (taking a list of keywords and returning a `SearchParameters`
    constructor for each one):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个`SearchParameters`构造函数的列表就像执行一个映射操作（取一个关键字列表，并为每个关键字返回一个`SearchParameters`构造函数）一样简单：
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we want to fetch the tweets for each `SearchParameters` constructor. You
    might think of something like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要获取每个`SearchParameters`构造函数的推文。您可能会想到以下内容：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'However, if you think about it, this will return a list of tweets. What we
    want is to flatten all the tweets to get them as a simple list. It turns out that
    calling `map` and then flattening the result is an operation known as `flatMap`.
    So we can write:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您这么想，这将返回一个推文列表。我们想要的却是将所有推文展平，以获得一个简单的列表。结果是调用`map`然后展平结果的操作被称为`flatMap`。因此，我们可以写出：
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The syntax of `flatMap` function, that takes a stream as a parameter, is a
    bit difficult to understand at first. Let me show you the entire code of the `SearchService`
    class so we can take a step back:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap`函数的语法，它接受一个流作为参数，一开始可能有点难以理解。让我展示`SearchService`类的整个代码，这样我们可以回顾一下：'
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, if we navigate to `http://localhost:8080/search/mixed;keywords=scala,java`,
    we get the expected result. A search for the Scala keyword and then for Java:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们导航到`http://localhost:8080/search/mixed;keywords=scala,java`，我们会得到预期的结果。搜索Scala关键字，然后是Java：
- en: '![URL mapping with matrix variables](img/2117_04_08.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![使用矩阵变量的URL映射](img/2117_04_08.jpg)'
- en: Putting it together
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合起来
- en: 'Now that everything works separately, it''s time to assemble everything. We
    will do this in three steps:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都独立工作，是时候将它们组合在一起了。我们将分三步完成：
- en: Move the upload form to the profile page and remove the old upload page.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将上传表单移至个人资料页面，并删除旧的上传页面。
- en: Change the submit button on the profile page to trigger the taste search directly.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将个人资料页面的提交按钮更改为直接触发口味搜索。
- en: Change the home page of our application. It should display search results matching
    our users' tastes right away. If they are unavailable, go to the profile page.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改我们应用程序的首页。它应该立即显示与用户口味匹配的搜索结果。如果它们不可用，则转到个人资料页面。
- en: I encourage you to try to do it on your own. You will run into very manageable
    problems along the way but you should know enough to resolve them on your own.
    I believe in you.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你尝试自己完成。在过程中你会遇到一些非常容易处理的问题，但你应该有足够的知识自己解决它们。我相信你。
- en: OK, now that you have done the work (you have, haven't you?), let's take a look
    at my solution.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在你已经完成了工作（你已经完成了，不是吗？），让我们看看我的解决方案。
- en: The first step is to remove the old `uploadPage` title. Don't look back, just
    do it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是删除旧的`uploadPage`标题。不要回头，只管做。
- en: 'Next, put these lines just below the `profilePage` title:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将这些行放在`profilePage`标题下方：
- en: '[PRE42]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: It is very similar to the content of the late `uploadPage`. We just removed
    the title and changed the label of the submit button. Add the corresponding translation
    to the bundles.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 它与旧的`uploadPage`的内容非常相似。我们只是删除了标题并更改了提交按钮的标签。将相应的翻译添加到资源包中。
- en: 'In English:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 英语：
- en: '[PRE43]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In French:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 法语：
- en: '[PRE44]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We also changed the name of the submit button to `upload`. That will help us
    identify this action on the controller side.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还更改了提交按钮的名称为`upload`。这将帮助我们识别控制器侧的这个动作。
- en: 'Now, if we try to upload our picture, it will redirect us to the old upload
    page. We need to fix this in the `onUpload` method of our `PictureUploadController`
    class:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试上传我们的图片，它将重定向我们到旧的上传页面。我们需要在我们的`PictureUploadController`类的`onUpload`方法中修复这个问题：
- en: '[PRE45]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note that we changed the URL that handles the post. It is now `/profile` instead
    of `/upload`. Form handling is much simpler when the `GET` and `POST` requests
    have the same URL, and will save us a lot of trouble especially when dealing with
    exceptions. This way, we will not have to redirect the user after an error.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们更改了处理POST请求的URL。现在它是`/profile`而不是`/upload`。当`GET`和`POST`请求有相同的URL时，表单处理会更简单，这将为我们节省很多麻烦，尤其是在处理异常时。这样，我们就不需要在出错后重定向用户。
- en: We also removed the model attribute, `picturePath`. Since we now have a bean
    representing our user in a session, `UserProfileSession`, we decided to add it
    there. We added a `picturePath` attribute to the `UserProfileSession` class and
    the associated getters and setters.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还删除了模型属性`picturePath`。由于我们现在有一个在会话中代表我们的用户的bean，即`UserProfileSession`，我们决定将其添加到那里。我们在`UserProfileSession`类中添加了`picturePath`属性以及相关的getter和setter。
- en: Don't forget to inject the `UserProfileSession` class and make it available
    as a field in our `PictureUploadController` class.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记注入`UserProfileSession`类，并将其作为字段在我们的`PictureUploadController`类中使其可用。
- en: 'Remember that all the properties of our session bean must be serializable,
    unlike resources. So we need to store it differently. The URL class seems to be
    a good fit. It is serializable and it is easy to create a resource from a URL
    with the `UrlResource` class:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们会话中的会话bean的所有属性必须是可序列化的，与资源不同。因此，我们需要以不同的方式存储它。URL类似乎是一个很好的选择。它是可序列化的，并且使用`UrlResource`类从URL创建资源很容易：
- en: '[PRE46]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The last thing that I had to do is to make the `profileForm` available as a
    model attribute after an error. This is because the `profilePage` requires it
    when it is rendered.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我最后要做的就是在一个错误发生后使`profileForm`作为模型属性可用。这是因为当它被渲染时，`profilePage`需要它。
- en: 'To sum up, here is the final version of the `PictureUploadController` class:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，以下是`PictureUploadController`类的最终版本：
- en: '[PRE47]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'So, now we can go to the profile page and upload our picture as well as provide
    personal information, as shown in the following screenshot:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们可以转到个人资料页面并上传我们的图片，以及提供个人信息，如下面的截图所示：
- en: '![Putting it together](img/2117_04_09.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![整合在一起](img/2117_04_09.jpg)'
- en: 'Now, let''s redirect our user to its search after the profile is completed.
    For this, we need to modify the `saveProfile` method in the `ProfileController`
    class:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在完成个人资料后重定向我们的用户到其搜索。为此，我们需要修改`ProfileController`类中的`saveProfile`方法：
- en: '[PRE48]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now that we are able to search for tweets from our profile, we don't need the
    `searchPage` or `TweetController` we previously made. Simply delete the `searchPage.html`
    page and the `TweetController`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够从我们的个人资料中搜索推文，我们不再需要之前制作的`searchPage`或`TweetController`。只需删除`searchPage.html`页面和`TweetController`。
- en: To finish, we can modify our home page so that it redirects us to a search matching
    our tastes if we have already completed our profile.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以修改我们的主页，以便如果已经完成了我们的个人资料，它将重定向我们到一个匹配我们喜好的搜索。
- en: 'Let''s create a new controller in the controller package. It is responsible
    for redirecting a user arriving at the root of our website either to their profile
    if it''s incomplete or to the `resultPage` if their tastes are available:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在控制器包中创建一个新的控制器。它负责将到达我们网站根目录的用户重定向到他们的个人资料（如果它不完整）或到`resultPage`（如果他们的喜好可用）：
- en: '[PRE49]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The check point
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查点
- en: In this chapter, we added two controllers, the `PictureUploadController`, which
    is in charge of writing uploaded files to the disk and handling upload errors,
    and the `SearchController` that can search tweets from a list of keywords with
    matrix parameters.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们添加了两个控制器，`PictureUploadController`，负责将上传的文件写入磁盘并处理上传错误，以及`SearchController`，它可以使用矩阵参数从关键词列表中搜索推文。
- en: This controller then delegates the search to a new service, `SearchService`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 此控制器然后将搜索委托给一个新的服务，`SearchService`。
- en: We deleted the old `TweetController`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们删除了旧的`TweetController`。
- en: We created a session bean, `UserProfileSession`, to store the information about
    our user.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个会话bean，`UserProfileSession`，用于存储有关我们用户的信息。
- en: Finally, we added two things to `WebConfiguration`. We added the error pages
    for our Servlet container and support for matrix variables.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`WebConfiguration`中添加了两项内容。我们添加了我们的Servlet容器的错误页面以及矩阵变量的支持。
- en: '![The check point](img/2117_04_10.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![检查点](img/2117_04_10.jpg)'
- en: On the resources side, we added a picture representing an anonymous user and
    a static page to handle errors. We added the file upload to `profilePage` and
    got rid of the old `searchPage`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在资源方面，我们添加了一个代表匿名用户的图片和一个用于处理错误的静态页面。我们将文件上传添加到`profilePage`，并淘汰了旧的`searchPage`。
- en: '![The check point](img/2117_04_11.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![检查点](img/2117_04_11.jpg)'
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed file upload and error handling. Uploading a file
    is not really complicated. However, a big design decision is what to do with the
    uploaded files. We could have stored the images it in a database, but instead
    we chose to write it to the disk and save the location of each user's picture
    in their session.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了文件上传和错误处理。上传文件实际上并不复杂。然而，一个重大的设计决策是关于上传文件的处理。我们本可以将图像存储在数据库中，但相反，我们选择将其写入磁盘，并在用户的会话中保存每个用户图片的位置。
- en: We saw typical ways to handle exceptions at the controller level and at the
    servlet container level. For additional resources on Spring MVC error handling,
    you can refer to the blog post at [https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc](https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了在控制器级别和servlet容器级别处理异常的典型方法。有关Spring MVC错误处理的更多信息，您可以参考[https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc](https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc)博客文章。
- en: Our application is looking pretty good already and yet the amount of code we
    had to write is very reasonable.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序看起来已经相当不错了，但我们不得不编写的代码量非常合理。
- en: Stay tuned for the next chapter where we will see that Spring MVC is also a
    powerful framework to build REST applications.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 请期待下一章，我们将看到Spring MVC也是一个构建REST应用程序的强大框架。
