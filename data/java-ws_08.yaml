- en: 8\. Sockets, Files, and Streams
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8. 套接字、文件和流
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter will teach you to work with external data storage systems. In the
    early sections, you will be taken through how to list the contents of directories—the
    logical first step to learning to create, open, read, and write to external files
    using Java. From there, you will study different methods, buffered and unbuffered,
    and how to distinguish between them. You will then learn to identify two main
    `java.io` and `java.nio`, their respective relationship to the aforementioned
    methods, and when and where to use them. In this chapter's final activity, you
    will be asked to use all these Java skills and tools in order to communicate between
    two different programs running on remote computers, in preparation for the chapters
    to come.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教会你如何与外部数据存储系统协同工作。在早期部分，你将学习如何列出目录的内容——这是学习使用Java创建、打开、读取和写入外部文件的逻辑第一步。从那里，你将研究不同的方法，缓冲和非缓冲，以及如何区分它们。然后，你将学习识别两个主要的`java.io`和`java.nio`，它们与上述方法的相应关系，以及何时何地使用它们。在本章的最终活动中，你将被要求使用所有这些Java技能和工具，以便在远程计算机上运行的两个不同的程序之间进行通信，为接下来的章节做准备。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: On an operating system level, files and directories are kind of similar. They
    are names representing a link to something in storage, whether it is your hard
    drive, somewhere in the cloud, or the USB drive in your pocket. However, at a
    conceptual level, they are inherently different. Files contain information, while
    directories link to other directories and files.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作系统层面，文件和目录在某种程度上是相似的。它们是代表存储中某个链接的名称，无论是你的硬盘、云中的某个地方，还是你口袋里的USB驱动器。然而，在概念层面上，它们本质上是不同的。文件包含信息，而目录链接到其他目录和文件。
- en: 'There are two main `java.io` and `java.nio`. Both APIs can be used to navigate
    directories and manipulate files. The information about the location of a file
    is called a pathname. It contains the full information of the directory in your
    hard drive in which the file resides, all the way to the file''s name and extension.
    It should have the following form:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个主要的`java.io`和`java.nio`。这两个API都可以用来导航目录和操作文件。关于文件位置的信息称为路径名。它包含文件所在硬盘上目录的完整信息，一直到文件名和扩展名。它应该具有以下形式：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Different operating systems refer to files and folder structures differently.
    In Unix systems (such as Linux or macOSX), the `/` symbol represents the separation
    between folders. Having one at the beginning of the pathname indicates an absolute
    positioning against the root folder of the system. Not having that symbol will
    indicate a relative positioning against the `classpath` or the path where our
    program is being executed from. In Windows computers, the folder separator is
    \, and the root is determined by a hard drive label. By default, the root folder
    in Windows is `C:`, but you can also store files in any other drive, such as `D:`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的操作系统对文件和文件夹结构的称呼不同。在Unix系统（如Linux或macOSX）中，`/`符号代表文件夹之间的分隔。在路径名开头有一个`/`表示相对于系统根文件夹的绝对定位。没有这个符号将表示相对于`classpath`或程序执行的路径的相对定位。在Windows计算机中，文件夹分隔符是`\`，根目录由硬盘标签确定。默认情况下，Windows的根文件夹是`C:`，但你也可以在任何其他驱动器中存储文件，例如`D:`。
- en: The main difference between the two APIs mentioned previously (that is, `java.io`
    and `java.nio`) is in the way they read and write data. The first one, `java.io`,
    can work with streams (this is a concept that we will explore later in the chapter)
    and carries data byte to byte in a blocking manner from one point to another.
    The second one, `java.nio`, works with buffers. This means that data is read and
    written in chunks into a part of the memory (a buffer) and not directly from the
    stream. This allows non-blocking communication, which will, for example, allow
    your code to continue doing something else without having to wait until all the
    data is sent—you simply start copying the information into the buffer and move
    on to doing other things.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的两个API（即`java.io`和`java.nio`）之间的主要区别在于它们读取和写入数据的方式。第一个，`java.io`，可以与流（这是我们将在本章后面探讨的概念）协同工作，并以阻塞方式从一点到另一点逐字节传输数据。第二个，`java.nio`，与缓冲区协同工作。这意味着数据以块的形式读入和写入内存的一部分（缓冲区），而不是直接从流中读取。这允许非阻塞通信，例如，允许你的代码在不需要等待所有数据发送的情况下继续做其他事情——你只需开始将信息复制到缓冲区，然后继续做其他事情。
- en: When it comes to files, the big difference is how using one method or the other
    will translate into faster or slower programs when trying to perform the same
    task in different ways. We will mainly focus on using `java.nio`, since it is
    easier to use files with it, and then refer to `java.io` occasionally. The `java.nio.file`
    (note the difference from `java.io.File`) API defines classes and interfaces for
    the JVM—which makes use of files, their attributes, and filesystems—is more recent,
    and offers an easier way to use interfaces. However, this is not true for all
    cases, as we will see in this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到文件时，主要区别在于使用一种方法或另一种方法在尝试以不同的方式执行相同任务时，程序的速度会更快或更慢。我们将主要关注使用`java.nio`，因为它更容易用它来使用文件，然后偶尔会提到`java.io`。`java.nio.file`
    API（注意与`java.io.File`的区别）定义了JVM使用的类和接口——包括文件、它们的属性和文件系统——是较新的，并提供了一种更简单的方式来使用接口。然而，并非所有情况都如此，正如我们将在本章中看到的。
- en: Listing Files and Directories
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出文件和目录
- en: We are going to examine how to list files and directories in different ways.
    These techniques can come in handy when checking whether a certain file exists,
    which will allow you to give more sensitive information to users when, for example,
    trying to find a properties file. If you detect that the file you're looking for
    doesn't exist and, at the same time, you notice that you are not in the right
    directory, you could make your program locate the actual folder in which the file
    resides, or you could simply inform the user about this situation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何以不同的方式列出文件和目录。当检查某个文件是否存在时，这些技术可能会派上用场，这将在您尝试找到属性文件等情况下，允许您向用户提供更敏感的信息。如果您发现您正在寻找的文件不存在，同时您还注意到您不在正确的目录中，您可以让您的程序定位文件实际所在的文件夹，或者您可以简单地通知用户这种情况。
- en: Note
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are different techniques to list the files and directories at any location
    on your computer. You must choose wisely depending on the circumstances. While
    the latest API seems more complex at first sight, as you will see in the following
    examples, it is a lot more powerful than any of the previous versions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的计算机上的任何位置列出文件和目录都有不同的技术。您必须根据具体情况明智地选择。虽然乍一看最新的API似乎更复杂，但正如您将在以下示例中看到的，它比之前的任何版本都要强大得多。
- en: Let's start with the old way of listing the contents of a directory. In the
    next exercise, we will only use `java.io`. It requires making a call to `File(dir).list()`,
    where `dir` is a string representing the name of the folder you want to access.
    To ensure the code in this book works with your operating system, we have chosen
    to check your operating system's temporary folder. Java stores that in a JVM property,
    which is labeled `java.io.tmpdir`. Therefore, the call to `getProperty()` at the
    beginning of the method extracts the name of the folder. For example, for any
    Unix OS, that property points to the `/tmp` folder.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从列出目录内容的老方法开始。在下一个练习中，我们只会使用`java.io`。它需要调用`File(dir).list()`，其中`dir`是一个表示您想要访问的文件夹名称的字符串。为了确保本书中的代码与您的操作系统兼容，我们选择检查您的操作系统的临时文件夹。Java将其存储在JVM属性中，标记为`java.io.tmpdir`。因此，方法开始时的`getProperty()`调用提取了文件夹的名称。例如，对于任何Unix操作系统，该属性指向`/tmp`文件夹。
- en: 'Your temporary folder is going to be filled up with a lot of files and folders
    created by the different programs running in your computer. Therefore, we have
    chosen to display only the first five listed by the OS – the order is determined
    by the OS. Unless you sort the results of calling `list()`, you will most likely
    not find any logic in how the output is sorted:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您的临时文件夹将被许多由您计算机中运行的不同程序创建的文件和文件夹填满。因此，我们选择只显示操作系统列出的前五个——顺序由操作系统决定。除非您对`list()`调用的结果进行排序，否则您很可能找不到输出排序的逻辑：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output of this example will be as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的输出将如下所示：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Since the contents of computers are different for every one of us—even within
    specific folders—the kind of information you will see as output to the code listings
    in this chapter will look different from what you will see in your terminal.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个人的计算机内容都不同——即使在特定的文件夹中也是如此——因此，您将在本章的代码列表中看到的输出信息将与您在终端中看到的不同。
- en: 'In the previous example, we have been intentionally hiding the part of the
    APIs that take care of each block of code to simplify the code listing. If you
    remove the three import statements from the code and follow the instructions from
    the IDE to add the more granular APIs to handle this code, you will get the following
    instead:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们故意隐藏了处理每个代码块的API部分，以简化代码列表。如果你从代码中删除三个导入语句，并按照IDE的指示添加更细粒度的API来处理此代码，你将得到以下结果：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You have learned about almost all these APIs throughout the book up to now.
    Even `java.io.File` was briefly presented in the chapter on exceptions to catch
    `IOException`. In the following examples, we will follow the same principle, just
    to keep the program headers as short as possible. However, it is better to reduce
    the lines of code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你在本书中几乎已经学习了所有这些API。甚至在异常章节中，为了捕获`IOException`，也简要介绍了`java.io.File`。在接下来的示例中，我们将遵循同样的原则，只是为了尽可能缩短程序头。然而，最好还是减少代码行数。
- en: 'Let''s explore another way to list the contents of a directory, but this time
    using `java.nio`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索另一种列出目录内容的方法，但这次使用`java.nio`：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output of this listing is different from the previous example, as you can
    see here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个列表的输出与之前的示例不同：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, the full path to the directories and files are shown. This has to do
    with the way `DirectoryStream` captures information from the OS. The `for` loop
    in this example might look new for you. This has to do with how we work with streams.
    We haven''t explained them yet, and we will not do so until later in this chapter.
    But you can see what it is doing: it creates a buffer that stores the information
    about the different directories inside. Then, it is possible to iterate through
    the buffer using the `for(Path path : directoryStream)` statement if there is
    data in it. Since we don''t know about its size from the start, we will need a
    list to store the string containing the contents of the directory. However, at
    this point, we are still not calling the `java.util.stream` API yet, since `DirectoryStream`
    belongs to the `java.nio` API.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，显示了目录和文件的完整路径。这与`DirectoryStream`从操作系统捕获信息的方式有关。这个例子中的`for`循环可能对你来说看起来很新。这与我们处理流的方式有关。我们还没有解释它们，而且我们将在本章的后面部分进行解释。但你可以看到它在做什么：它创建了一个缓冲区，用于存储关于不同目录的信息。然后，如果缓冲区中有数据，就可以使用`for(Path
    path : directoryStream)`语句遍历缓冲区。由于我们一开始不知道它的大小，我们需要一个列表来存储包含目录内容的字符串。然而，在这个阶段，我们还没有调用`java.util.stream`
    API，因为`DirectoryStream`属于`java.nio` API。'
- en: 'Another code listing that uses streams properly is shown here. Note that we
    do not show its output because it''s the same as the previous example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了另一个正确使用流的代码示例。请注意，我们没有显示其输出，因为它与之前的示例相同：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Separating Directories from Files
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将目录与文件分离
- en: 'Imagine that you want to mark files differently from directories when listing
    a folder''s contents. In order to do so, you can use a method from `java.nio`
    called `isDirectory()`, as shown in the following example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你希望在列出文件夹内容时将文件与目录区分开来。为了做到这一点，你可以使用`java.nio`中的一个方法，即`isDirectory()`，如下面的示例所示：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We have highlighted the part of the code that is new compared with the previous
    example in which we accessed the directory using the java.nio API. `Files.isDirectory()`
    requires an object of the `Paths` class. `Paths.get()` transforms the path from
    a directory item, passed as a string to the actual instance of the Paths class.
    With that, `Files.isDirectory()` will answer with a Boolean that is `true` if
    the item is a directory and `false` if not. We used an inline `if` statement to
    assign the string `Dir` or `Fil`, depending on whether we are dealing with a directory
    or with a file. The result of this code listing is as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经突出了与之前使用java.nio API访问目录的示例相比的新代码部分。`Files.isDirectory()`需要一个`Paths`类的对象。`Paths.get()`将路径从目录项（作为字符串传递）转换为`Paths`类的实际实例。有了这个，`Files.isDirectory()`将返回一个布尔值，如果是目录则为`true`，如果不是则为`false`。我们使用内联`if`语句根据我们处理的是目录还是文件来分配字符串`Dir`或`Fil`。这段代码的输出结果如下：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see, in the temporary directory, there are both files and subdirectories.
    The next question is how to list the content of the subdirectories. We will approach
    that question as an exercise, but before we do that, try one more example that
    will list only those items that are directories. This is a more advanced technique,
    but it will give us an excuse to step back and try to implement our own solution
    with the knowledge we have gained so far:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在临时目录中，既有文件也有子目录。下一个问题是如何列出子目录的内容。我们将把这个问题作为一个练习来处理，但在我们这样做之前，尝试一个更进一步的例子，该例子将只列出目录项。这是一个更高级的技术，但它将给我们一个机会，回顾并尝试使用我们到目前为止所获得的知识来实现自己的解决方案：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First, to show that there is the possibility of using other environment variables
    (that's what we call the system properties as defined for your OS), we changed
    the folder to user home, which corresponds to your user space, or the directory
    where you will typically store your files. Please be careful from now on to avoid
    any kind of accidents with your files.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了展示使用其他环境变量的可能性（这就是我们所说的系统属性，它是为您的操作系统定义的），我们将文件夹更改为用户主目录，这对应于您的用户空间，或者您通常存储文件的目录。请从现在开始小心，以避免任何与您的文件相关的意外。
- en: '`Files.walk()` will extract the directory structure up to a certain depth,
    in our case, one. The depth represents how many levels of subdirectories your
    code will be digging into. `filter(Files::isDirectory)` is going to exclude anything
    that is not a directory. We have not seen filters yet, but it is a clear enough
    concept to not need any further explanation at this point. The final part of the
    call, `collect(Collectors.toList())`, will be creating a list of the output. This
    means that the `subDirectories` object will contain a list of paths to directories.
    That is why in this example, unlike the previous one, we do not have to make a
    call to `Paths.get(filePath)`. The output of that call will depend on what your
    OS is and whatever you have in your home folder. The result on my computer, which
    runs a version of Linux, is as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`Files.walk()` 将提取到一定深度的目录结构，在我们的例子中，是深度一。深度表示您的代码将挖掘多少层子目录。`filter(Files::isDirectory)`
    将排除任何不是目录的东西。我们还没有看到过滤器，但这个概念足够清晰，不需要进一步解释。调用最后的部分，`collect(Collectors.toList())`，将创建一个输出列表。这意味着
    `subDirectories` 对象将包含目录路径的列表。这就是为什么在这个例子中，与上一个例子不同，我们不需要调用 `Paths.get(filePath)`。该调用的输出将取决于您的操作系统以及您主文件夹中的内容。在我的计算机上，它运行的是Linux版本，结果如下：'
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, `<userName>` corresponds to the user's nickname on the computer. As you
    can see, this is only representing the contents of the directory initialized at
    `pathString`. The question is, can we represent the content of the nested subdirectories
    to the initial `pathString` in our program?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<userName>` 对应于计算机上用户的昵称。如您所见，这仅表示在 `pathString` 初始化的目录的内容。问题是，我们能否在我们的程序中表示嵌套子目录的内容到初始的
    `pathString`？
- en: 'Exercise 1: Listing the Contents of Subdirectories'
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1：列出子目录的内容
- en: 'Let''s make a program to navigate through subdirectories using the knowledge
    we have gained so far. It might not be the most optimal way of solving this challenge,
    but it will work:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用到目前为止所获得的知识，编写一个程序来导航子目录。这可能不是解决这个挑战的最佳方式，但它会有效：
- en: 'Let''s start with the latest example, where we used a call to `Files.walk()`
    with a depth of 1 and a filter to list the contents—just the directories—of a
    certain directory, `pathString`. The depth in a directory search determines how
    many levels of subdirectories our will program navigate into. Level 1 is the same
    level as where the search is initiated. Level 2 indicates that we should also
    represent the contents of the directories inside the main directory. In principle,
    it should be as easy as giving the call a higher value for depth, like this:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从最新的例子开始，我们使用 `Files.walk()` 调用，深度为 1，并使用过滤器来列出特定目录 `pathString` 的内容——只是目录。目录搜索中的深度决定了我们的程序将导航到多少层子目录。级别
    1 与搜索发起的同一级别相同。级别 2 表示我们还应该表示主目录内部的目录内容。原则上，这应该像给调用一个更高的深度值一样简单，如下所示：
- en: '[PRE11]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'But there is the catch. When running a call like that, it is likely that there
    are directories or files that your program is not allowed to access. An exception
    regarding permissions will be fired and your program will stop:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但有一个问题。当运行这样的调用时，很可能存在程序不允许访问的目录或文件。将触发一个关于权限的异常，并且程序将停止：
- en: '[PRE12]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Accessing any directory or file that is contained in any of these subdirectories,
    which are under strict administrative user permissions, will make this program
    crash. It is of no use to catch this exception because the result will still be
    a non-functional directory listing. There is a pretty advanced technique to get
    this to work, but you have not been introduced to everything you need to know
    in order to do so. Instead, let's focus on the tools you have gained so far to
    create your own method to dig into subdirectories and extract their contents.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问任何包含在这些子目录中的目录或文件，这些子目录处于严格的行政用户权限之下，将导致此程序崩溃。捕获这个异常没有任何用处，因为结果仍然是一个无法使用的目录列表。有一种相当高级的技术可以使它工作，但你还没有被介绍到完成这个任务所需知道的一切。相反，让我们专注于你已经获得的工具，以便创建自己的方法来深入子目录并提取其内容。
- en: 'Let''s go back to *Example 03* and modify it to just display directories inside
    user.home:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到*示例 03*并修改它，使其仅显示user.home目录内的目录：
- en: '[PRE13]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, we have applied the `filter()` method we saw earlier. We could
    have also implemented the alternative of checking with `isDirectory()`, as we
    saw in *Example 04*, but this is cleaner, and simplicity is key.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，我们应用了之前看到的`filter()`方法。我们也可以实现使用`isDirectory()`的替代方案，就像我们在*示例 04*中看到的那样，但这更简洁，简洁是关键。
- en: 'Based on the idea that `list()` can give you the contents of any folder, let''s
    call it again for each filename. This means we will have to modify the `forEach()`
    statement we are using so that we can access the second level of nested directories:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于这样的想法，即`list()`可以给出任何文件夹的内容，让我们再次为每个文件名调用它。这意味着我们将不得不修改我们正在使用的`forEach()`语句，以便我们可以访问嵌套目录的第二层：
- en: '[PRE14]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see, the highlighted code is a repetition of the code we had earlier,
    with the name of the object changed to `fileNames2`. This time, we removed the
    limit, which means it will print the output of any subdirectories each directory
    has. The real novelty is how we have gone from calling just `System.out::print`
    to writing more complex code where we first print out the path we are at, and
    then we print the paths to the subfolders of that path. We are anticipating something
    called a lambda expression here. They will be explained in a later chapter. However,
    the code here is easy enough for you to understand. For each `(item)` in the `fileNames`
    buffer, we will perform the operations just mentioned. The result looks like this:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，高亮显示的代码是我们之前代码的重复，只是对象名称改为`fileNames2`。这次，我们移除了限制，这意味着它将打印出每个目录拥有的任何子目录的输出。真正的创新之处在于我们是如何从仅调用`System.out::print`转变为编写更复杂的代码，首先打印出我们所在的路径，然后打印该路径的子文件夹路径。我们在这里期待的是一种称为lambda表达式的功能。它们将在后面的章节中解释。然而，这里的代码足够简单，您可以理解。对于`fileNames`缓冲区中的每个`(item)`，我们将执行上述提到的操作。结果看起来像这样：
- en: '[PRE15]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Also, `IOException` must be caught at the time of generating the list, otherwise
    the code will not compile. `throw IOException` in the declaration of the `main`
    method doesn't apply to the `forEach()` expression because it is one level deeper
    in the program's scope. We are looking at an inline definition of a method in
    this case. But the question is, how can we get around the idea of having an arbitrary
    depth in the directory exploration?
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，必须在生成列表时捕获`IOException`，否则代码将无法编译。在`main`方法的声明中`throw IOException`不适用于`forEach()`表达式，因为它在程序的作用域中更深一层。在这种情况下，我们正在查看方法的内联定义。但问题是，我们如何绕过目录探索任意深度的想法？
- en: 'Digging deeper in the `java.nio` API, we find the `walkFileTree()` method,
    which can browse through directory structures up to a certain depth – two in the
    following example – and offers the possibility of overriding some of its methods
    to decide what happens when reaching a directory item and trying to access it.
    A call to this method could look like this:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在深入`java.nio` API中，我们发现`walkFileTree()`方法，它可以浏览目录结构，直到达到一定的深度——在下面的示例中是两层——并提供覆盖其部分方法的可能性，以决定到达目录项并尝试访问时会发生什么。对这个方法的调用可能看起来像这样：
- en: '[PRE16]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, you can see how the `preVisitDirectory()` method is called at the time
    of trying to open a directory item in a folder. A program including that line
    will run until, for example, a permissions-related exception arrives. If there
    is no exceptional situation, the overridden method will print out all directory
    names up to two levels of depth. In the case of the home directory we are experimenting
    with, we know that there is a folder that Java''s default user permissions are
    not enough for our program to gain access to. Therefore, if we run this program,
    we will see it operate normally until an exception is reached:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，你可以看到当尝试在文件夹中打开一个目录项时，`preVisitDirectory()` 方法是如何被调用的。包含该行的程序将一直运行，直到例如，出现与权限相关的异常。如果没有异常情况，重写的方法将打印出所有深度达两级的目录名称。在我们实验的主目录的情况下，我们知道有一个文件夹，Java
    的默认用户权限不足以让我们的程序访问。因此，如果我们运行这个程序，我们会看到它正常操作直到遇到异常：
- en: '[PRE17]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `preVisitDirectory()` method will tell the `walkFileTree` method that it
    should continue to work through its return. The issue here is that because of
    the `AccessDeniedException`, our program will not enter `preVisitDirectory()`.
    We need to override yet another method called `visitFileFailed()` to see how to
    handle any kind of exception that occurs when trying to access an item in the
    directory:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`preVisitDirectory()` 方法将告诉 `walkFileTree` 方法它应该继续通过其返回值工作。这里的问题是，由于 `AccessDeniedException`，我们的程序将不会进入
    `preVisitDirectory()`。我们需要重写另一个名为 `visitFileFailed()` 的方法来了解如何处理尝试访问目录项时发生的任何类型的异常：'
- en: '[PRE18]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output of this will be the desired result, as follows:'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将产生预期的结果，如下所示：
- en: '[PRE19]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can conclude from this process that, even though there are many ways to perform
    the same task, the way those solutions are implemented will allow us to have control.
    In this case, the `walk()` method is not enough for us to handle exceptions easily,
    so we had to explore an alternative that, in the end, turned out to be easier
    to understand.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从这个过程我们可以得出结论，尽管有多种方法可以执行相同的任务，但那些解决方案的实现方式将使我们能够有所控制。在这种情况下，`walk()` 方法不足以让我们轻松处理异常，因此我们必须探索一个替代方案，最终发现这个方案更容易理解。
- en: 'For reference, the final code resulting from this exercise should be as follows:'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为参考，这个练习的最终代码应该如下所示：
- en: '[PRE20]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Creating and Writing to a File
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和写入文件
- en: 'Once we are familiar with how to list the contents of directories, the next
    logical step is to proceed with the creation of files and folders. Let''s start
    by creating and writing data into a file by using `java.nio`. The easiest way
    to create a file using this API requires calling the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们熟悉了如何列出目录的内容，下一步合乎逻辑的步骤就是继续创建文件和文件夹。让我们先通过使用 `java.nio` 创建并写入文件。使用此 API
    创建文件的最简单方法需要调用以下代码：
- en: '[PRE21]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'At the same time, creating a directory is as simple as this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，创建一个目录就像这样简单：
- en: '[PRE22]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As a good practice, you should check whether directories and/or files exist
    prior to creating any with the same name. There is a simple method that will look
    into any objects of the Path class to see whether any can be found in the folder
    our program is exploring:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种良好的实践，你应该在创建具有相同名称的目录和/或文件之前检查它们是否存在。有一个简单的方法可以检查 Path 类的任何对象是否可以在程序正在探索的文件夹中找到：
- en: '[PRE23]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s put all of this together into a single example that will create a folder,
    and then a file inside the folder:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把所有这些放在一起，通过一个示例来创建一个文件夹，然后在文件夹内创建一个文件：
- en: '[PRE24]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The result of this code listing, the first time you execute it, should be as
    follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次执行此代码列表的结果应该如下所示：
- en: '[PRE25]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Any subsequent executions should give us the following result:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 任何后续执行都应该给出以下结果：
- en: '[PRE26]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This created a file that is essentially empty. Making use of the terminal,
    you could list the size of the file by calling the `ls -lah ~/javaTemp/temp.txt`
    command, which will throw a result like the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个本质上为空的文件。使用终端，你可以通过调用 `ls -lah ~/javaTemp/temp.txt` 命令来列出文件的大小，这将返回如下结果：
- en: '[PRE27]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This means that the file takes zero bytes of hard drive space. This means that
    the file is there, but it is empty. Writing text to the file can easily be done
    using a method from the `java.nio.file.Files` API: `write()`. The only issue is
    that it is not trivial passing arguments to this method. In its easiest interface,
    you must pass two arguments: the `Path` object and a `List` containing a text.
    On top of that, there is a risk that the file may not exist, which requires handling
    the classic `IOException`. It could be something like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着文件在硬盘上不占用任何字节的存储空间。这意味着文件存在，但它为空。使用`java.nio.file.Files` API中的`write()`方法轻松地将文本写入文件：`write()`。唯一的问题是传递给此方法的参数不是显而易见的。在其最简单的接口中，你必须传递两个参数：`Path`对象和一个包含文本的`List`。除此之外，还存在着文件可能不存在的风险，这需要处理经典的`IOException`。它可能看起来像这样：
- en: '[PRE28]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When calling `write()` to write text to a file, you don't have to add the end-of-line
    symbol at the end of the string. It will be added automatically by the method
    as one would expect when using commands such as println().
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`write()`向文件写入文本时，你不需要在字符串的末尾添加换行符。它将自动由方法添加，就像使用`println()`等命令时预期的那样。
- en: 'Once you have added the last code snippet to the latest example, the program
    will give the following result:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将最后一个代码片段添加到最新的例子中，程序将给出以下结果：
- en: '[PRE29]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The previous example just writes text to the file but also deletes everything
    that was there before. In order to append text instead, you need to modify the
    call to the write command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子只是将文本写入文件，同时也删除了之前的内容。如果你想追加文本而不是覆盖，你需要修改对写入命令的调用：
- en: '[PRE30]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The highlighted part of the call is responsible for determining what text will
    be added at the end of the file instead of erasing everything and writing everything
    from scratch. The following example simply appends text to an existing file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 调用中高亮的部分负责确定在文件末尾添加什么文本，而不是删除所有内容并从头开始写入。以下示例简单地追加文本到一个现有文件：
- en: '[PRE31]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This program appended a whole sentence to the example text file. The final
    content of the file will read is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序将整个句子追加到了示例文本文件中。文件最终的读取内容如下：
- en: '[PRE32]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is asking for a soda in Spanish. In the next section, let's examine how
    to read the file we just created.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在西班牙语中点一杯苏打水的说法。在下一节中，我们将探讨如何读取我们刚刚创建的文件。
- en: 'Activity 1: Writing the Directory Structure to a File'
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动一：将目录结构写入文件
- en: 'The goal of this activity is to program an application that will read the directory
    structure, starting from a directory that is stored in a variable. The results
    will be written to a text file so that, for each nesting level, you will include
    either a tab space or four white spaces to indent nested folders visually from
    their respective parents. Also, you will have to show only the name of the folder
    and not the full path to it. In other words, the content of the file should correspond
    to the following structure:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的目标是编写一个应用程序，该程序将读取目录结构，从存储在变量中的目录开始。结果将写入一个文本文件，这样，对于每个嵌套级别，你将包括一个制表符或四个空格来从其父目录中视觉上缩进嵌套文件夹。此外，你还需要只显示文件夹的名称，而不是其完整路径。换句话说，文件的内容应该对应以下结构：
- en: '[PRE33]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The program that you will have to create will need to have a certain depth
    of directories as a parameter, but we recommend you don''t go too deep with this—a
    maximum of 10 is fine:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将要创建的程序需要将目录的深度作为参数，但我们建议你不要过于深入——最多10层是合适的：
- en: '[PRE34]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When working with the obtained paths to the directories, you need to split
    the resulting string using the / symbol as a separator and then take the last
    item. Additionally, you will have to print the number of indents based on the
    depth, which will require having some code that can estimate the current depth
    given the initial path. A trick for solving those problems could be by making
    the content of `preVisitDirectory()` like the following:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当处理获取到的目录路径时，你需要使用/符号作为分隔符来分割结果字符串，然后取最后一个项目。此外，你还需要根据深度打印缩进的数量，这需要有一些代码可以估计给定初始路径的当前深度。解决这些问题的技巧可能是使`preVisitDirectory()`的内容如下：
- en: '[PRE35]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 552.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第552页找到。
- en: Reading an Existing File
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取现有文件
- en: 'Reading a file can be done in a simple way. The question is about where you
    will store the data once you have it. We will work with lists, iterate through
    the lists, and then print out the results to `System.out`. The next example uses
    `readAllLines()` to open the existing file and reads the contents into the computer''s
    memory, putting them into the `fileContent` list. After that, we use an iterator
    to go through each line and send them to the Terminal:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以简单的方式读取文件。问题是关于你将数据存储在哪里。我们将使用列表，遍历列表，然后将结果打印到 `System.out`。下一个示例使用 `readAllLines()`
    打开现有文件，并将内容读取到计算机内存中，放入 `fileContent` 列表中。之后，我们使用迭代器遍历每一行并将它们发送到终端：
- en: '[PRE36]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `temp.txt` file is the one where we saved a message earlier; therefore,
    the result will be as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`temp.txt` 文件是我们之前保存消息的地方；因此，结果如下：'
- en: '[PRE37]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If the file wasn''t there (you may have deleted it after the previous exercise),
    you would instead get the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件不存在（你可能在之前的练习中删除了它），你将得到以下结果：
- en: '[PRE38]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A different approach that gets the same result, but avoids Lists and uses Streams
    instead, is as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种达到相同结果但避免使用列表并使用流的方法如下：
- en: '[PRE39]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Reading a Properties File
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取属性文件
- en: 'Property files store key-value (also called key-map) pairs in a standard format.
    An example of the content of such a file is:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 属性文件以标准格式存储键值对（也称为键映射）。此类文件的示例内容如下：
- en: '[PRE40]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This is a made-up example of the properties file for an imaginary user. Note
    how the comment is marked using a hashtag symbol, #. You will use properties files
    to store the configurable parameters of applications or even for localization
    strings.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个虚构的用户属性文件的示例。注意，注释是用井号符号标记的。你将使用属性文件来存储应用程序的可配置参数，甚至用于本地化字符串。
- en: Let's try reading a properties file. You can create a text file in the same
    temporary folder that we created in the user's space earlier in the chapter. Name
    it `user.properties` and write to it the contents of the preceding example. This
    follows an example of a program using `java.io` to read and print out the contents
    of a properties file. Given the way Java works, there is no better alternative
    to performing this task than using `java.nio`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试读取一个属性文件。你可以在本章前面创建的用户空间中的同一个临时文件夹中创建一个文本文件。命名为 `user.properties`，并将前面示例的内容写入其中。这遵循了一个使用
    `java.io` 读取并打印属性文件内容的程序示例。鉴于 Java 的工作方式，没有比使用 `java.nio` 更好的替代方案来完成这项任务。
- en: Note
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Reading the contents of a properties file consists not just in getting each
    line of the file, but also parsing the key-value pairs and being able to extract
    data from them.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读属性文件的内容并不仅限于获取文件的每一行，还包括解析键值对并能够从中提取数据。
- en: The first thing you will notice is that reading the properties file requires
    opening a file as a stream – again, a concept we will explore later in the chapter
    – using `FileInputStream`. From there, the `Properties` class contains a method
    called `load()` that can extract the key-value pairs from the data stream. To
    clean up the code listing, we have separated the loading and printing aspects
    of the code from the ones handling the opening of the file. Additionally, we have
    made sure that all exceptions are handled in the main class, just to have a single
    point where we can manage them, which makes for more readable code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先会注意到，读取属性文件需要以流的形式打开一个文件——再次强调，这是我们将在本章后面探讨的概念——使用 `FileInputStream`。从那里开始，`Properties`
    类包含一个名为 `load()` 的方法，可以从数据流中提取键值对。为了清理代码列表，我们将代码的加载和打印方面与处理文件打开的部分分开。此外，我们确保所有异常都在主类中处理，以便有一个单一的管理点，这使得代码更易于阅读。
- en: '[PRE41]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: There is also an aspect that we have not yet discussed in this chapter. Streams
    must be closed once you are done working with them. This means that they will
    be unavailable for further data handling after you close them. This step is important
    for avoiding any kind of JVM memory issues during runtime. Therefore, the example
    code calls `fileStream.close()` once we are done loading the properties file.
    If you remember the *Good Practices* section in *Chapter 5*, *Exceptions*, it
    was mentioned that you should close streams inside the `finally` statement. This
    is also the reason why this program must throw `IOException` in the main method.
    If you wanted to handle this in a clean way (by avoiding nested try-catch statements
    or using `throws IOException` in the main method), you can wrap the whole `try`
    block in a method that you would, in turn, call from the main method where you
    could catch the `IOException`. Look at the forthcoming exercise to see how this
    is done.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还没有讨论的一个方面是，一旦你完成与流的工作，就必须关闭流。这意味着关闭后它们将无法用于进一步的数据处理。这一步骤对于避免运行时任何类型的
    JVM 内存问题非常重要。因此，示例代码在加载属性文件后调用 `fileStream.close()`。如果你记得 *第五章* 中的 *良好实践* 部分，*异常*
    部分提到你应该在 `finally` 语句中关闭流。这也是为什么这个程序必须在主方法中抛出 `IOException` 的原因。如果你想要以干净的方式处理这个问题（通过避免嵌套
    try-catch 语句或在主方法中使用 `throws IOException`），你可以将整个 `try` 块包裹在一个方法中，然后从主方法中调用该方法，在那里你可以捕获
    `IOException`。查看即将到来的练习，看看这是如何完成的。
- en: 'The output of the previous example is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例的输出如下：
- en: '[PRE42]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: There are interesting methods within the `Properties` class for you to explore.
    For example, `properties.keys()` will return an enumeration of all the keys in
    the file, in our case name, familyName, userName, and so on. This specific method
    is inherited by `Properties` because of its relation to the `Hashtable` class.
    It is recommended that you read through the API's documentation for this class
    to discover the other interesting methods you can make use of.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Properties` 类中包含一些有趣的方法供你探索。例如，`properties.keys()` 将返回文件中所有键的枚举，在我们的例子中是 name、familyName、userName
    等等。这个特定方法由于与 `Hashtable` 类的关系而被 `Properties` 类继承。建议你阅读该类的 API 文档，以发现你可以使用的其他有趣方法。'
- en: When it comes to the properties files location, they could be stored inside
    the classpath, sometimes even inside the actual JAR file, which provides a very
    compact way to distribute applications with properties files inside.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到属性文件的位置时，它们可以存储在类路径中，有时甚至存储在实际的 JAR 文件中，这为带有属性文件的应用程序的紧凑式分发提供了一种方式。
- en: The next aspect to explore is how to programmatically make your own properties
    files. Let's look into this topic through a step-by-step exercise.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要探索的另一个方面是如何以编程方式创建自己的属性文件。让我们通过一个逐步练习来探讨这个主题。
- en: 'Exercise 2: Creating a Properties File from the CLI'
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2：从 CLI 创建属性文件
- en: 'In this exercise, you will be making an application capable of creating a properties
    file (or modifying an existing one) from input on the CLI. You will pass the properties
    file''s name and key-value pairs as arguments to your program. This will allow
    you to create any kind of properties file easily. An example of the expected call
    to the application will be as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将制作一个能够从 CLI 输入创建属性文件（或修改现有文件）的应用程序。你将通过将属性文件的名称和键值对作为参数传递给程序来实现这一点。这将使你能够轻松地创建任何类型的属性文件。应用程序预期调用的示例如下：
- en: '[PRE43]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The process of operations in such a program is simple. First, you need to check
    whether the file exists. If so, load the properties. Then, add the new properties
    or modify the existing ones with the data handed over as an argument. Later, write
    the information to the file and give feedback to the user on the final content
    sent to the file. In that way, the user will be able to see that the modifications
    they made are working without having to open the file.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一个程序的操作过程很简单。首先，你需要检查文件是否存在。如果存在，则加载属性。然后，添加新的属性或使用作为参数传递的数据修改现有的属性。稍后，将信息写入文件，并向用户反馈最终发送到文件的内容。这样，用户将能够看到他们所做的修改正在生效，而无需打开文件。
- en: 'Let''s see how to make such a program step by step:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步看看如何制作这样的程序：
- en: Open IntelliJ and create a new Java CLI project called `Exercise02`.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 IntelliJ 并创建一个名为 `Exercise02` 的新 Java CLI 项目。
- en: 'First, we need to check whether the properties file we are defining in the
    CLI already exists. The program we are going to implement will check whether the
    file exists. If that is the case, it will open it and load the existing properties.
    The rest of the arguments in the CLI will be used to either modify existing key-value
    pairs or add new ones. To see whether a properties file exists and load it, we
    will need to execute the following:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要检查在CLI中定义的属性文件是否已经存在。我们将要实现的程序将检查文件是否存在。如果是这样，它将打开它并加载现有的属性。CLI中的其余参数将用于修改现有的键值对或添加新的键值对。为了查看属性文件是否存在并加载它，我们需要执行以下操作：
- en: '[PRE44]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Loading the properties is done reusing the code from *Example 10*, but wrapping
    it into the `LoadPoperties()` method that we called in the previous step. Let''s
    implement it to return an object of the `Properties` class (note what we did to
    implement the `finally` statement to make sure that the stream is closed after
    a possible exception. We had to initialize the stream as null):'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载属性是通过重用*示例10*中的代码来完成的，但将其包装在我们在上一步中调用的`LoadProperties()`方法中。让我们实现它以返回`Properties`类的对象（注意我们为了确保在可能发生的异常后关闭流而实现的`finally`语句。我们必须将流初始化为null）：
- en: '[PRE45]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If the file doesn't exist, it will be created when calling the `store()` method
    later—there is no need to create an empty file at this point.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件不存在，在稍后调用`store()`方法时将创建它——在这个阶段不需要创建一个空文件。
- en: 'Next, we need to read the remaining arguments at the CLI from the `arg[]` array
    and push them, one by one, into the properties object. The properties object inherits
    its behavior from the `Hashtable` class, which handles key-value pairs. The `setProperty()`
    method will be used to either modify an existing property or to write a new one.
    Since the arguments are expressed as a string formatted as key=value, we can use
    `split()` to separate the arguments we need to pass to `setProperty()`:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要从`arg[]`数组中读取CLI上的剩余参数，并将它们逐个推入属性对象中。属性对象从`Hashtable`类继承其行为，该类处理键值对。将使用`setProperty()`方法来修改现有属性或写入新属性。由于参数以key=value的字符串格式表达，我们可以使用`split()`来分隔需要传递给`setProperty()`的参数：
- en: '[PRE46]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We are going to be writing to a file, but instead of using a stream that will
    be inputting data, we will use one that will be outputting data. Its name is simple
    to infer, `FileOutputStream`. The declaration of a variable of that class will
    be as follows:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将要写入文件，但不是使用输入数据的流，而是使用输出数据的流。它的名字很容易推断，`FileOutputStream`。该类的变量声明如下：
- en: '[PRE47]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To add some comments to the properties file, we simply need to add a parameter
    to the `store()` method. In this case, just to add some contextual information,
    let''s add a timestamp by calling the following:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要向属性文件添加一些注释，我们只需向`store()`方法添加一个参数。在这种情况下，只是为了添加一些上下文信息，让我们通过调用以下操作添加时间戳：
- en: '[PRE48]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We call the `store()` method, which will send the properties into the file.
    We will be overwriting whatever existed in it before. This call uses, as an argument,
    the output `Stream` and whatever comment we have chosen:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用`store()`方法，该方法将属性发送到文件中。我们将覆盖之前文件中的任何内容。这个调用使用输出`Stream`和我们所选择的任何注释作为参数：
- en: '[PRE49]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To improve the program''s usability, make a method that will iterate through
    the whole properties set and print it out. In that way, the user can see whether
    they wrote things properly:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了提高程序的可用性，创建一个方法来遍历整个属性集并打印出来。这样，用户就可以看到他们是否正确地写下了内容：
- en: '[PRE50]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Run the code with, for example, the following call in the CLI. In this case,
    we are intentionally modifying the file we have been working with throughout the
    chapter. The program will print out the modified set. Please note that there is
    no clear order to the key-value pairs:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用CLI中的以下调用运行代码，例如。在这种情况下，我们故意修改了本章中一直在工作的文件。程序将打印出修改后的集合。请注意，键值对没有明确的顺序：
- en: '[PRE51]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Open the resulting file in a text editor and see whether your changes took effect
    or not. Also note that the comments, as well as the `\` sign added by the `store()`
    method to avoid the color parameter (which is expressed in HEX format using the
    hashtag symbol) being misunderstood as a comment.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开生成的文件，查看您的更改是否生效。同时请注意，注释以及`store()`方法添加的`\`符号，以避免将颜色参数（使用井号符号以十六进制格式表达）误认为是注释。
- en: 'You could now consider making other modifications to the program so it can
    clear up an existing file, append several files, and more. You could do that using
    different commands as arguments. The code for the full exercise is available on
    GitHub: [https://packt.live/2JjUHZL](https://packt.live/2JjUHZL)'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以考虑对程序进行其他修改，使其能够清除现有文件、追加多个文件等。你可以使用不同的命令作为参数来完成这项工作。完整的练习代码可在GitHub上找到：[https://packt.live/2JjUHZL](https://packt.live/2JjUHZL)
- en: What are Streams?
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是流？
- en: Streams in Java are sequences of bytes and eventually, by extension, also objects.
    You can understand a stream as a flow of data between two places. Creating a variable
    of the stream type is like opening a peephole to look into a pipe carrying water
    between two containers and seeing the water passing through. What we are trying
    to say is that data inside a stream is always changing.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的流是字节序列，最终通过扩展也可以是对象。你可以将流理解为两个地方之间的数据流动。创建流类型的变量就像打开一个窥视孔，查看两个容器之间运送水的管道，并看到水通过。我们试图表达的是，流内部的数据始终在变化。
- en: 'As we have seen before, we have two different ways of looking at things in
    this chapter: one through the lens of the `java.io` API and one through the `java.nio`
    API. While the second one works at a more abstract and therefore easier level,
    the first one is extremely powerful and low-level. Continuing with the water analogy,
    `java.io` would allow you to see the drops, while `java.nio` would let you play
    only with 1-liter bottles at a time. Each one of them has its advantages.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所看到的，在本章中，我们有两种不同的方式来看待事物：一种是通过`java.io` API的视角，另一种是通过`java.nio` API的视角。虽然后者在更抽象的层面上工作，因此更容易理解，但前者非常强大且底层。继续使用水的类比，`java.io`将允许你看到水滴，而`java.nio`则只允许你一次玩一个1升瓶子的水。每个都有其优点。
- en: 'Streams in `java.io` can be as granular as going down to the level of the byte.
    If we were, for example, to look at a stream of sound data coming from the computer''s
    microphone input, we would see the different bytes representing the sound, one
    by one. The other API, `java.nio` is buffer-oriented, and not so much stream-oriented.
    While this is true, there is a way to work with streams in `java.nio`. Because
    of its simplicity, in this section, we will see an example relating to `java.nio`,
    while in the following section, we will deal with streams using the API that is
    best prepared is to handle them: `java.io`.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.io`中的流可以细化到字节级别。例如，如果我们查看来自计算机麦克风输入的音频数据流，我们会看到代表声音的不同字节，一个接一个。另一个API，`java.nio`是面向缓冲区的，而不是面向流的。虽然这是真的，但有一种在`java.nio`中处理流的方法。由于其简单性，在本节中，我们将看到一个与`java.nio`相关的示例，而在下一节中，我们将使用最适合处理它们的API来处理流：`java.io`。'
- en: Streams in `java.nio` are sequences of objects (not arbitrary unsorted data).
    Since those objects belong to specific classes, streams offer the possibility
    of applying the objects' corresponding methods to the stream directly. The result
    of applying a method to a stream is yet another stream, which means that methods
    can, therefore, be pipelined.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.nio`中的流是对象的序列（不是任意无序的数据）。由于这些对象属于特定的类，流提供了直接将对象对应的方法应用于流的可能性。将方法应用于流的结果是另一个流，这意味着方法可以被管道化。'
- en: We have seen different streams in this chapter, mainly because streams play
    such a big role in Java that it is almost impossible to do any kind of file-related
    example without using them. Now you will see how they work in more depth. This
    will help you understand some of the aspects that may not have been so clear to
    you so far.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看到了不同的流，主要是因为流在Java中扮演着如此重要的角色，以至于几乎不可能在不使用它们的情况下进行任何类型的文件相关示例。现在，你将更深入地了解它们是如何工作的。这将帮助你理解一些可能之前并不那么清晰的方面。
- en: 'The nature of streams is typically hard to grasp in the first place. As mentioned,
    they are not plain data structures. Information is arranged in the form of objects.
    Input is taken from `Arrays`, I/O channels in the program, or `Collections`. The
    kinds of operation we can perform on streams are as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 流的本质通常很难一开始就理解。正如之前提到的，它们不是普通的数据结构。信息以对象的形式排列。输入来自`Arrays`、程序中的I/O通道或`Collections`。我们可以在流上执行的操作类型如下：
- en: '`map` (intermediate): This will let you map objects following a predicate that
    you can give as an argument.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map`（中间操作）：这将允许你将对象映射到一个你可以作为参数提供的谓词。'
- en: '`filter` (intermediate): This is used to exclude some elements from the whole
    stream.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter`（中间操作）：这个操作用于从整个流中排除某些元素。'
- en: '`sorted` (intermediate): This will sort the stream.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sorted`（中间操作）：这将排序流。'
- en: '`collect` (terminal): This will put the results of the different operations
    into an object a form, for example, a list.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collect`（终端操作）：这将把不同操作的结果放入一个对象形式，例如，一个列表。'
- en: '`forEach` (terminal): This will iterate through all of the objects in the stream.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEach`（终端操作）：这将遍历流中的所有对象。'
- en: '`reduce` (terminal): This operates the stream to answer a single value.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduce`（终端操作）：这个操作对流进行操作以得到一个单一值。'
- en: We have marked each one of the operations with either intermediate or terminal.
    The former means that the operation that will be performed will give another stream
    as a result, and therefore it should be possible to chain another operation onto
    it afterward. The latter means that there cannot be further operations performed
    after that one has finished.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经用中间或终端来标记每个操作。前者意味着将要执行的操作将产生另一个流作为结果，因此可以在其后链式调用另一个操作。后者意味着在该操作完成后，不能执行进一步的操作。
- en: 'Until now, you have seen some of those operations in action in this chapter.
    You can go back to the examples where those operations showed up and revisit them.
    It will make it a lot clearer what `filter()`, `collect()`, and `forEach()` are
    doing. Let''s see the other three operations in action:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经在这个章节中看到了一些这些操作的实际应用。你可以回到那些操作出现的地方，重新审视它们。这将使 `filter()`、`collect()`
    和 `forEach()` 的作用更加清晰。让我们看看其他三个操作的实际应用：
- en: '[PRE52]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The complete code of `Example11.java` is available at `Chapter 1/Code.java`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`Example11.java` 的完整代码可以在 `Chapter 1/Code.java` 中找到。'
- en: 'This example is divided into two parts. The first half of the program checks
    whether a file called `numbers.txt` exists in the `javaTemp` folder that we have
    been using throughout the chapter. If this file doesn''t exist, the program creates
    it with `Files.createFile(pathFile)` and then populates it with 10 random numbers
    previously stored in an array of `int` called `numbers`. The call to `Files.write(pathFile,
    Arrays.asList("" + n), StandardOpenOption.APPEND)` is responsible for adding each
    number in the array as separate lines in the file. The resulting file will look
    like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子分为两部分。程序的前半部分检查我们一直在使用的 `javaTemp` 文件夹中是否存在名为 `numbers.txt` 的文件。如果这个文件不存在，程序将使用
    `Files.createFile(pathFile)` 创建它，然后用之前存储在名为 `numbers` 的 `int` 数组中的10个随机数字填充它。调用
    `Files.write(pathFile, Arrays.asList("" + n), StandardOpenOption.APPEND)` 负责将数组中的每个数字作为单独的行添加到文件中。生成的文件将如下所示：
- en: '[PRE53]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The idea of having one number per line is that we can then read the file as
    a list, transform the list into a stream, and then start making different operations.
    The simplest operation consists of calling `fileContent.forEach(System.out::print)`,
    which will print the raw data as the output:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 每行一个数字的想法是，我们可以然后以列表的形式读取文件，将列表转换成流，然后开始进行不同的操作。最简单的操作是调用 `fileContent.forEach(System.out::print)`，这将把原始数据作为输出打印出来：
- en: '[PRE54]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Before applying other operations, such as `sorted()`, we need to transform
    the data into a stream, something that is done with the `stream()` method. This
    is done using the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用其他操作，例如 `sorted()` 之前，我们需要将数据转换成一个流，这可以通过 `stream()` 方法实现。以下是具体操作：
- en: '[PRE55]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The result of this operation will be sorted. Equal values will show up side
    by side, repeated:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作的结果将会被排序。相等的值将并排显示，重复：
- en: '[PRE56]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'With `map()`, we will be able to handle the data and perform different operations
    on it. For example, here, we multiply it by 2 and print it to the terminal:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `map()`，我们将能够处理数据并对它执行不同的操作。例如，在这里，我们将它乘以2并打印到终端：
- en: '[PRE57]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The result is as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE58]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, there are different terminations that can be used. To do this, we
    will use lambda expressions, which are not introduced until a much later chapter.
    However, the following is easy enough to not need any further explanation. To
    perform the sum of all the numbers, we need to do the following operation:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有不同类型的终止操作可以使用。为此，我们将使用直到更后面的章节才会介绍到的lambda表达式。然而，以下内容足够简单，不需要进一步解释。为了计算所有数字的总和，我们需要执行以下操作：
- en: '[PRE59]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The following is the result:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为结果：
- en: '[PRE60]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note that, when reading the file, we have read it as a `List` of `String`, and
    therefore, the numbers are stored as strings. This means that, in order to operate
    them as numbers, we need to cast them back into integers, which is done through
    the call to `Integer.parseInt(x)`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在读取文件时，我们将其读取为`String`的`List`，因此数字被存储为字符串。这意味着，为了将它们作为数字操作，我们需要将它们转换回整数，这通过调用`Integer.parseInt(x)`来完成。
- en: The Different Streams of the Java Language
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java语言的流的不同类型
- en: 'To discuss types of streams, we need to take one step back and move away from
    `java.nio` and into `java.io`. This API is the one that has the best support for
    streams. Depending on the situation, streams can either go into the program or
    out from the program. This gives us two main interfaces for streams: `InputStream`
    and `OutputStream`.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要讨论流类型，我们需要退一步，从`java.nio`转向`java.io`。这个API是支持流最好的API。根据情况，流可以进入程序或从程序中出来。这为我们提供了两个主要的流接口：`InputStream`和`OutputStream`。
- en: 'Within each of those two main categories, there are four ways to look at streams
    from the perspective of the type of data they are dealing with: `File`, `ByteArray`,
    `Filter`, or `Object`. In other words, there is a `FileInputStream` class, a `FileOutputStream`
    class, a `ByteArrayInputStream` class, and more.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个主要类别中，有四种从它们处理的数据类型的角度来看待流的方法：`File`、`ByteArray`、`Filter`或`Object`。换句话说，有一个`FileInputStream`类、一个`FileOutputStream`类、一个`ByteArrayInputStream`类等等。
- en: According to Javadocs, it is important to understand that there is a hierarchy
    of streams. All streams are built on top of byte streams. But we should try, as
    much as possible, to use the kind of stream type that is the closest in the hierarchy
    to the kind of data we are using. For example, if we were to deal with a series
    of images coming from the internet, we should avoid working at a low level with
    byte streams to store the images, and we should use object streams instead.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Javadocs，重要的是要理解流有一个层次结构。所有流都是建立在字节流之上的。但我们应尽可能使用与我们所使用的数据类型在层次结构中最接近的流类型。例如，如果我们需要处理来自互联网的一系列图像，我们应该避免在低级别使用字节流来存储图像，而应使用对象流。
- en: Note
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Read more about streams in the official Java documentation at [https://docs.oracle.com/javase/tutorial/essential/io/bytestreams.html](https://docs.oracle.com/javase/tutorial/essential/io/bytestreams.html).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在官方Java文档中了解更多关于流的信息，请访问[https://docs.oracle.com/javase/tutorial/essential/io/bytestreams.html](https://docs.oracle.com/javase/tutorial/essential/io/bytestreams.html)。
- en: 'How would it then open and print out a file using java.io and `FileInputStream`?
    We saw a bit of this when dealing with the properties files. Let''s do the lowest-level
    example possible that will read a file and print out its contents byte by byte:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如何使用java.io和`FileInputStream`打开并打印文件呢？我们在处理属性文件时已经看到了一些这方面的内容。让我们来看一个最低级别的例子，它将读取一个文件并逐字节打印其内容：
- en: '[PRE61]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This example opens the temp.txt file we created earlier in the chapter and
    prints out its contents. Remember that it contained some plain text in the lines
    of `hola\nHola,\nme da un ...`. When looking at the terminal, what you will read
    will be something like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例打开我们在本章中创建的temp.txt文件，并打印其内容。请记住，它包含了一些简单的文本，如`hola\nHola,\nme da un ...`。当查看终端时，你将读到如下内容：
- en: '[PRE62]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You might be wondering – what happened to the text? As you know, every symbol
    of the English alphabet is represented by a standard called ASCII. This standard
    represents each symbol with a number. It differentiates uppercase from lowercase,
    different symbols such as exclamation marks or hashtags, numbers, and more. An
    excerpt of the ASCII table representing the lowercase symbols is as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道——文本怎么了？正如你所知，英语字母表中的每个符号都由一个称为ASCII的标准来表示。这个标准用数字表示每个符号。它区分了大写和小写，不同的符号，如感叹号或井号，数字等等。以下是一个表示小写符号的ASCII表的摘录：
- en: '[PRE63]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: If you start taking the stream of numbers you get and parse it using the table
    for the ASCII symbols, you will see that `104` corresponds to `h`, `111` to `o`,
    `108` to `l`, and `97` to `a`. If you had a full ASCII table (including capitals,
    symbols, and numbers) you would be able to decode the whole message. We did get
    the content of the file, but we didn't interpret the data we got in our program,
    which rendered the output unreadable. This is the reason why you should try to
    use a higher-level kind of stream, which will stop you having to decode the information
    at such a low level, which for characters – as in this example – is not such a
    big deal. But data transfers between software entities can get complex very quickly.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你开始使用你得到的数字流，并使用ASCII符号表进行解析，你会发现`104`对应于`h`，`111`对应于`o`，`108`对应于`l`，`97`对应于`a`。如果你有一个完整的ASCII表（包括大写字母、符号和数字），你将能够解码整个消息。我们确实得到了文件的内容，但我们没有在程序中解释我们得到的数据，这使得输出不可读。这就是为什么你应该尝试使用更高层次的流，这样你就不必在如此低级别解码信息，对于字符——就像这个例子一样——这不是什么大问题。但软件实体之间的数据传输可以很快变得复杂。
- en: 'Let''s examine another way of performing the same operation of opening the
    file, but with a different type of stream. In this case, we will use `FileReader`,
    which is a different type of stream, on top of `FileInputStream`. To get the stream
    in the form of characters and pass it over to `BufferedReader`, which is a stream
    class that includes the possibility of reading full lines of a text. Since we
    know that our file contains text arranged in lines, this will probably be the
    best way to see the contents of the file in a neat way:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考察另一种执行相同操作（打开文件）的方法，但使用不同类型的流。在这种情况下，我们将在`FileInputStream`之上使用`FileReader`，这是一种不同类型的流。为了以字符的形式获取流并将其传递给`BufferedReader`，这是一个可以读取文本完整行的流类。由于我们知道我们的文件包含按行排列的文本，这可能是以整洁方式查看文件内容的最优方法：
- en: '[PRE64]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The output of this example will be what we expected to see in the first place:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的输出将是我们最初期望看到的结果：
- en: '[PRE65]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In a nutshell, the information is the same, but it matters how we look at it.
    Using a higher-level class from the stream family will offer us better methods
    to handle the same information in a different yet more usable way.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，信息是相同的，但关键在于我们如何看待它。使用流家族中的高级类将为我们提供更好的方法来以不同但更实用的方式处理相同的信息。
- en: There is another concept that we haven't introduced yet, and that is the difference
    between buffered streams and unbuffered streams. When working at a low level with
    java.io, you will be most likely working in an unbuffered way. This means that
    you will be addressing the OS directly from your code. Those exchanges are computationally
    hungry, especially in comparison with loading any information into a buffer inside
    the JVM and operating directly there instead (it doesn't mean that it will not
    be accessing the OS directly — it will, but it will optimize its use.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个我们尚未介绍的概念，那就是缓冲流和非缓冲流之间的区别。在用java.io进行低级工作时，你很可能会以非缓冲的方式工作。这意味着你将从代码中直接与操作系统交互。这些交换计算密集，尤其是在与在JVM内部加载任何信息到缓冲区并直接在那里操作相比（这并不意味着它不会直接访问操作系统——它会，但它将优化其使用）。
- en: This example is clearly using `BufferedReader`, which differs from the previous
    one. We mentioned earlier in the chapter how `java.nio` works with buffers – this
    means that, unlike `java.io`, it doesn't offer the possibility of doing those
    direct calls to the OS. In a way, it is better because it is less prone to errors.
    If you have a properly constructed API with all the methods needed to perform
    whatever you want to do, you should avoid using other less optimal tools.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例明显使用了`BufferedReader`，这与前一个示例不同。我们在本章前面提到了`java.nio`如何与缓冲区一起工作——这意味着，与`java.io`不同，它不提供直接调用操作系统的可能性。从某种意义上说，这更好，因为它更不容易出错。如果你有一个构建良好的API，其中包含了执行你想要执行的所有操作所需的所有方法，你应该避免使用其他不太理想的工具。
- en: What are Sockets?
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是套接字？
- en: A socket is the endpoint of a bidirectional communication channel between two
    programs operating over a network. It is as if a virtual cable was connecting
    those two programs, offering the possibility of sending data back and forth. Java's
    APIs have classes to easily construct programs at both ends of the communication.
    The exchanges on, for example, the internet happen over a TCP/IP network, where
    we distinguish between the roles of those that participate in the communication.
    There are servers and clients. The former can be implemented using the ServerSocket
    class, while the latter can use the socket class.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字是两个在网络上运行的程序之间的双向通信通道的端点。这就像一条虚拟电缆连接了这两个程序，提供了来回发送数据的能力。Java的API有类可以轻松构建通信两端的程序。例如，互联网上的交换发生在TCP/IP网络上，我们区分参与通信的角色。有服务器和客户端。前者可以使用ServerSocket类实现，而后者可以使用套接字类。
- en: The way the communication process works involves both parties. The client will
    send a request to the server asking for a connection. This is done through one
    of the available TCP/IP ports on your computer. If the connection is accepted,
    the socket is opened at both ends. The endpoints at the server and the client
    will be uniquely identifiable. This means that you will be able to use that port
    for multiple connections.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 通信过程的工作方式涉及双方。客户端将向服务器发送请求，请求建立连接。这是通过计算机上可用的一个TCP/IP端口完成的。如果连接被接受，两端都会打开套接字。服务器和客户端的端点将是唯一可识别的。这意味着您可以使用该端口进行多个连接。
- en: Knowing how to deal with sockets, together with streams, will allow you to work
    with information coming directly from the internet, which will bring your programs
    to the next level. In the following sections, we are going to see how to implement
    a client and a server to prototype this communication.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何处理套接字，以及与流一起使用，将使您能够直接从互联网处理信息，这将使您的程序达到新的水平。在接下来的章节中，我们将看到如何实现客户端和服务器以原型化这种通信。
- en: Note
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While working with these examples, make sure your computer's security system
    (firewalls and the like) allow communicating over whatever port you decide to
    use. It wouldn't be the first time someone has wasted several hours thinking their
    code is wrong when the issue is somewhere else.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用这些示例进行工作时，请确保您的计算机安全系统（防火墙等）允许通过您决定使用的任何端口进行通信。这种情况并非第一次发生，有人浪费了几个小时以为自己的代码有误，而问题实际上出在其他地方。
- en: Creating a SocketServer
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建SocketServer
- en: Trying to read data from sockets requires a little involvement from existing
    networked resources. If you want to have a program that connects to a server,
    you will require a known server before you can even try the connection. On the
    internet, there are servers offering the possibility of connecting, opening a
    socket, sending data, and receiving it back. These servers are called EchoServers—a
    name that leaves little doubt about what they do.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 从套接字中读取数据需要现有网络资源的一点点参与。如果您想要一个连接到服务器的程序，您在尝试连接之前需要知道一个服务器。在互联网上，有提供连接可能性的服务器，可以打开套接字，发送数据，并接收回数据。这些服务器被称为EchoServer——这个名字几乎不会让人对其功能产生怀疑。
- en: 'On the other hand, you can implement your own server and play it safe. Oracle
    offers a simple example of an EchoServer for you to test. This is going to be
    a new kind of challenge because you are going to need to run two programs on your
    computer at once: the EchoServer and whatever client you will implement.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，您可以自己实现服务器并确保安全。Oracle提供了一个简单的EchoServer示例供您测试。这将是一个新的挑战，因为您需要在计算机上同时运行两个程序：EchoServer和您将实现的任何客户端。
- en: 'Let''s start by implementing the EchoServer that you can get from [https://packt.live/33LmH0k](https://packt.live/33LmH0k).
    The code for you to analyze is included in the next example. Note that we have
    removed the opening disclaimer and code comments to keep it short:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实现EchoServer开始，您可以从[https://packt.live/33LmH0k](https://packt.live/33LmH0k)获取。您要分析的代码包含在下一个示例中。请注意，我们已经删除了开头的免责声明和代码注释，以保持其简洁：
- en: '[PRE66]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The first part of the code checks that you have selected a port for your server
    to be listening to. This port number is given as an argument on the CLI:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一部分检查您是否为服务器选择了一个监听端口。这个端口号作为CLI上的参数给出：
- en: '[PRE67]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: If no port was chosen, this program will simply exit. Remember, as we mentioned
    earlier, to make sure that whatever port you use, it is not blocked by your computer's
    firewall.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有选择端口号，此程序将简单地退出。记住，正如我们之前提到的，确保您使用的任何端口号都没有被计算机的防火墙阻止。
- en: The call to `ServerSocket(Integer.parseInt(args[0]))` will start the object
    of the `ServerSocket` class, configuring the port defined in the arguments to
    call the program as the one to listen to. Later, `serverSocket.accept()` will
    block the server and make it wait until a connection arrives. Once it arrives,
    it will be automatically accepted.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `ServerSocket(Integer.parseInt(args[0]))` 将启动 `ServerSocket` 类的对象，配置在参数中定义的端口号，以便调用程序作为监听程序。稍后，`serverSocket.accept()`
    将阻塞服务器，使其等待连接的到来。一旦到来，它将自动接受。
- en: 'In the beginning code in this example, there are two different streams: `BufferReader
    in` for the input, and `PrinterWriter out` for the output. As soon as a connection
    is established, `in` will get the data, and `out` will send it – without any further
    processing—back to the socket. The server program will run until forcing an exit
    when pressing *Ctrl*+*C* on the terminal.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例的初始代码中，有两个不同的流：`BufferedReader in` 用于输入，`PrintWriter out` 用于输出。一旦建立连接，`in`
    将获取数据，而 `out` 将发送它——无需任何进一步处理——回套接字。服务器程序将一直运行，直到在终端上按下 *Ctrl*+*C* 强制退出。
- en: 'To get the server started, you will need to compile it using the build icon
    (the hammer) and call it from the terminal using a specific port name. Try port
    8080, because that is typically used for experiments like the one, we are going
    to do now:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动服务器，您需要使用构建图标（锤子）编译它，并在终端中使用特定的端口号调用它。尝试端口号 8080，因为这个端口号通常用于我们即将进行的实验：
- en: '[PRE68]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: If everything goes as planned, the program will start running and will not print
    any messages. It is there just waiting for a connection to be made.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切按计划进行，程序将开始运行，不会打印任何消息。它只是在那里等待建立连接。
- en: Note
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that, by default, your own computer always has the IP number 127.0.0.1,
    which allows you to figure out the IP number of your computer in the network.
    We will use this for the connection with the client.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，默认情况下，您的计算机始终具有 IP 地址 127.0.0.1，这允许您确定计算机在网络中的 IP 地址。我们将使用此地址与客户端建立连接。
- en: Writing Data on and Reading Data from a Socket
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在套接字上写入数据和从套接字读取数据
- en: While our server runs in the background, we will need to produce a simple program
    that will open a socket and send something to the server. To do this, you need
    to create a new project in the IDE but in a separate window. Remember that your
    server is currently running!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的服务器在后台运行时，我们需要生成一个简单的程序来打开套接字并向服务器发送一些内容。为此，您需要在 IDE 中创建一个新的项目，但在一个单独的窗口中。记住，您的服务器目前正在运行！
- en: The simplest client that you can produce is Oracle's companion to the *EchoServer*.
    For obvious reasons, it is called *EchoClient*, and you can find it at [https://packt.live/2PbLNBx](https://packt.live/2PbLNBx).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以生成的最简单的客户端是 Oracle 的 *EchoServer* 伴侣。出于明显的原因，它被称为 *EchoClient*，您可以在 [https://packt.live/2PbLNBx](https://packt.live/2PbLNBx)
    找到它。
- en: '[PRE69]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Note that, in this case, instead of creating a `SocketServer` object, we create
    a `Socket` object. This second program introduces the idea of using one of the
    system streams to capture data and send it to the socket: `System.in`. This program
    will run for as long as the input in `System.in` is `not null`. This is something
    that cannot really be achieved through direct interaction with System.in, because
    we will be just pressing keys on the keyboard. Therefore, you will need to call
    *Ctrl* + *C* to stop the client, just as was the case with the server.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，我们不是创建一个 `SocketServer` 对象，而是创建一个 `Socket` 对象。这个第二个程序介绍了使用系统流之一来捕获数据并发送到套接字：`System.in`。这个程序将一直运行，直到
    `System.in` 中的输入为 `null`。这是通过直接与 `System.in` 交互无法真正实现的事情，因为我们只是按键盘上的键。因此，您需要按
    *Ctrl* + *C* 来停止客户端，就像服务器的情况一样。
- en: Note how sending data to the server is done with `out.println()`, where out
    is a `PrinterWriter` object, a stream, that is constructed on top of the `Socket`.
    On the other hand, to read the incoming `Socket`, we have implemented a `BufferedReader`
    object called `in`. Since it is buffered, we can poll the object whenever we want.
    The call to `out.readLine()` and `in.readLine()` is blocking. It will not stop
    reading from `System.in` or from the socket until the end of the line has been
    reached.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 注意发送数据到服务器是通过`out.println()`完成的，其中`out`是一个`PrinterWriter`对象，一个流，它是基于`Socket`构建的。另一方面，为了读取传入的`Socket`，我们实现了一个名为`in`的`BufferedReader`对象。由于它是缓冲的，我们可以随时轮询该对象。对`out.readLine()`和`in.readLine()`的调用是阻塞的。它不会停止从`System.in`或从套接字读取，直到行尾到达。
- en: This makes this reader synchronous because it waits for the user to type, sends
    the data, and, finally, waits until getting an answer from the socket.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得这个读者是同步的，因为它等待用户输入，发送数据，最后等待从套接字获取答案。
- en: Note
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Every operating system makes three different system streams available to the
    JVM: System.in, System.out, and System.err. As they are streams, you can use the
    full power of the Stream classes to read data from them, put them into buffers,
    parse them, and so on.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作系统都向JVM提供了三个不同的系统流：System.in、System.out和System.err。由于它们是流，您可以使用Stream类的全部功能从它们读取数据，将它们放入缓冲区，解析它们等。
- en: 'To get the client started, you will need to compile it using the build icon
    (the hammer) and call it from the terminal using a specific IP and port name.
    Try the IP 127.0.0.1 and port 8080\. Remember that you need to start the server
    before you start the client:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动客户端，您需要使用构建图标（锤子图标）编译它，并通过特定的IP地址和端口号从终端调用它。尝试使用IP地址127.0.0.1和端口号8080。记住，在启动客户端之前，您需要先启动服务器：
- en: '[PRE70]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'From that moment on, and until you issue the Ctrl + C command, for as long
    as the server is connected, you will be able to type whatever you want on the
    terminal, and when you press Enter, it will be sent to and from the server. Upon
    arrival, the client will write it to the terminal by adding the message echo before
    it. We highlight the response coming from the server by making the typeface bold:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，直到您发出Ctrl + C命令，只要服务器保持连接，您就可以在终端上输入任何内容，当您按下Enter键时，它将被发送到服务器，并从服务器返回。到达后，客户端会在它前面添加消息echo将其写入终端。我们通过使来自服务器的响应字体加粗来突出显示：
- en: '[PRE71]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Also, when forcing an exit on the client, it will force an exit on the server.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当强制客户端退出时，它也会强制服务器退出。
- en: 'Activity 2: Improving the EchoServer and EchoClient Programs'
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动二：改进EchoServer和EchoClient程序
- en: 'In this activity, you will have to make improvements to the programs in the
    last two sections. First, you will have to add some text to the data relayed on
    the server. This will make it easier for the user to understand that the data
    was sent back from the server. Let''s make it a counter that will act as a sort
    of unique ID for the exchange. In this way, the answer from the server will be
    shown with a number added to the message:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，您需要对最后两个部分中的程序进行改进。首先，您需要向服务器上传输的数据中添加一些文本。这将使用户更容易理解数据是从服务器发送回来的。让我们将其制作成一个计数器，它将充当交换的唯一ID。这样，服务器的回答将显示在消息中添加的数字：
- en: '[PRE72]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: On the other hand, you should add a command in the client that will send a termination
    signal to the server. This command will exit the server, and then exit the client.
    To terminate any of the programs, you can call `System.exit()` after sending a
    message to the terminal informing the user that the program is ending. As a termination
    command, you could make something simple, such as a message that contains the
    word 'bye'.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，您应该在客户端添加一个命令，该命令将发送一个终止信号到服务器。这个命令将退出服务器，然后退出客户端。要终止任何程序，您可以在向终端发送消息告知用户程序即将结束时调用`System.exit()`。作为一个终止命令，您可以创建一个简单的消息，其中包含单词“bye”。
- en: 'The expected results will require you to modify both the server and the client
    in a very similar way. On the client-side, you will have to do something like
    the following:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预期结果将需要您以非常相似的方式修改服务器和客户端。在客户端，您需要做如下操作：
- en: '[PRE73]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'On the server, the modifications should look like the following:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务器上，修改应该如下所示：
- en: '[PRE74]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The expected interaction between the server and the client should be as follows:'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 服务器和客户端之间的预期交互应该如下所示：
- en: '![Figure 8.1: The interaction between the client and the server.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1：客户端与服务器之间的交互。'
- en: '](img/C13927_08_01.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C13927_08_01.jpg]'
- en: 'Figure 8.1: The interaction between the client and the server.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：客户端与服务器之间的交互。
- en: Note
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 555.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第555页找到。
- en: Blocking and Non-Blocking Calls
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阻塞和非阻塞调用
- en: This is a topic we have been covering in this chapter, but we have not addressed
    it directly. The `java.io` read and write operations are blocking. This means
    that the program will wait until the data is fully read or until the data has
    been fully written. However, working with buffered streams as implemented in `java.nio`
    allows you to check whether the data is ready to be read. When writing data, `java.nio`
    will copy the data to the buffer and let the API write the data to the channel
    by itself. This allows an entirely different programming style where we don't
    need to wait for the operations to happen. At the same time, this means that we
    will not have low-level control of the communication. A different part of the
    JVM performs that action for us.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章一直在讨论的话题，但我们没有直接解决它。`java.io`的读写操作是阻塞的。这意味着程序将等待直到数据完全读取或数据已经完全写入。然而，使用`java.nio`中实现的缓冲流可以让你检查数据是否准备好读取。在写入数据时，`java.nio`会将数据复制到缓冲区，并让API自己将数据写入通道。这允许一种完全不同的编程风格，我们不需要等待操作发生。同时，这也意味着我们将不会对通信有低级控制。JVM的另一个部分会为我们执行这个动作。
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you have been introduced to two main APIs in the Java language:
    java.io and java.nio. They have some overlapping functions, and they are needed
    to deal with streams and files. On top of that, you have seen how to work with
    sockets, a natural source of data that can only be handled with streams.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经了解了Java语言中的两个主要API：java.io和java.nio。它们有一些重叠的功能，并且它们被用来处理流和文件。除此之外，你还看到了如何使用流来处理套接字，套接字是数据的一个自然来源，只能通过流来处理。
- en: There have been a series of examples looking at how to capture data from the
    terminal, which in the end happened to be `stream (System.in)`. You then explored
    how to process it using streams with all sorts of high-level functions, such as
    filter, map, sorted, foreach, reduce, and collect. You have seen how to open files
    and properties files, and how java.nio is very capable with the former, but not
    with the latter.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 已经有一系列示例展示了如何从终端捕获数据，最终发现是`stream (System.in)`。然后你探索了如何使用各种高级函数，如filter、map、sorted、foreach、reduce和collect来处理它。你已经看到了如何打开文件和属性文件，以及java.nio在前者上非常强大，但在后者上则不然。
- en: 'From a more practical perspective, this chapter has introduced one important
    technique that was only explained in theory in an earlier chapter: how to use
    `finally` to close streams, and avoid potential memory issues during runtime.
    You have seen that, in order to handle exceptions cleanly, you may have to move
    blocks of code into methods. In this way, you can avoid throwing exceptions and
    can always process them with try-catch statements.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 从更实际的角度来看，本章介绍了一种在早期章节中仅从理论上解释的重要技术：如何使用`finally`来关闭流，并在运行时避免潜在的内存问题。你已经看到，为了干净地处理异常，你可能不得不将代码块移动到方法中。这样，你可以避免抛出异常，并且总是可以通过try-catch语句来处理它们。
- en: In order to play around with sockets, you have experimented with building an
    EchoServer and an EchoClient. You had two different programs interacting with
    one another and sending data over the internet. You saw how to run both the server
    and the client on your own computer, and it is now time to try those two programs
    running on different computers.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与套接字进行实验，你已经尝试构建了一个EchoServer和一个EchoClient。你有两个不同的程序相互交互，并通过互联网发送数据。你已经看到了如何在你的电脑上运行服务器和客户端，现在是时候尝试在不同的电脑上运行这两个程序了。
- en: Finally, the two activities in this chapter introduced you to creating or modifying
    properties files on the fly by typing key-value pairs as arguments to a program,
    and remotely controlling another program via commands over the internet.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，本章中介绍的两个活动通过在程序中键入键值对作为参数来动态创建或修改属性文件，以及通过互联网上的命令远程控制另一个程序。
- en: In the next chapter, you'll learn about HTTP and how to create a program that
    connects to a specific web server and downloads data.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习关于HTTP以及如何创建一个连接到特定Web服务器并下载数据的程序。
