- en: Chapter 10. Testing Apache Karaf with Pax Exam
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章 测试Apache Karaf与Pax Exam
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Setting up a Pax Exam test environment
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Pax Exam测试环境
- en: Testing Apache Karaf features
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试Apache Karaf功能
- en: Testing commands with Apache Karaf
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Apache Karaf测试命令
- en: Coverage with Apache Karaf Pax exam tests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Apache Karaf Pax exam测试的覆盖率
- en: Testing Apache Camel with Blueprint and Apache Karaf
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Blueprint和Apache Karaf测试Apache Camel
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter explains how to set up a test environment for Apache Karaf. As
    developing OSGi applications for Apache Karaf also needs thorough testing, an
    environment for integration testing is needed. Pax Exam is a powerful tool for
    developing integration tests and can be combined with Apache Karaf.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了如何为Apache Karaf设置测试环境。由于为Apache Karaf开发OSGi应用程序也需要彻底的测试，因此需要一个集成测试环境。Pax
    Exam是一个强大的集成测试开发工具，可以与Apache Karaf结合使用。
- en: Tip
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: More details about Pax Exam can be found at the OPS4j community website at [https://ops4j1.jira.com/wiki/display/PAXEXAM3/Pax+Exam](https://ops4j1.jira.com/wiki/display/PAXEXAM3/Pax+Exam).
    If help is needed, you can find a working community at [https://groups.google.com/forum/#!forum/ops4j](https://groups.google.com/forum/#!forum/ops4j).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于Pax Exam的详细信息可以在OPS4j社区网站上找到，网址为[https://ops4j1.jira.com/wiki/display/PAXEXAM3/Pax+Exam](https://ops4j1.jira.com/wiki/display/PAXEXAM3/Pax+Exam)。如果需要帮助，你可以在[https://groups.google.com/forum/#!forum/ops4j](https://groups.google.com/forum/#!forum/ops4j)找到一个活跃的社区。
- en: Setting up a Pax Exam test environment
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Pax Exam测试环境
- en: This recipe will guide you through the basic setup of a Pax Exam test environment
    using the Felix framework as the core OSGi container. The next recipe will cover
    how to combine Pax Exam and Apache Karaf.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱将指导你使用Felix框架作为核心OSGi容器的基本设置Pax Exam测试环境。下一个食谱将介绍如何结合Pax Exam和Apache Karaf。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As usual, the sources can be found at [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe1](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe1).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，源代码可以在[https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe1](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe1)找到。
- en: How to do it…
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To perform integration tests with Pax Exam, the POM configuration is essential,
    since it is already part of the build environment. For example, use the `pax-exam-container-native`
    artifact and of course it is mandatory to connect JUnit with Pax Exam. This can
    be done as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Pax Exam执行集成测试，POM配置是必不可少的，因为它已经是构建环境的一部分。例如，使用`pax-exam-container-native`构件，当然，将JUnit与Pax
    Exam连接是强制性的。这可以通过以下方式完成：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Besides this, it is required to define the OSGi framework in which to run this
    test scenario. This can either be the Felix framework, Equinox, or any other framework
    available as a Maven dependency.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个，还需要定义运行此测试场景的OSGi框架。这可以是Felix框架、Equinox或任何其他作为Maven依赖项可用的框架。
- en: Now that we are done with the important parts of the POM configuration, let's
    focus on the JUnit integration test.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了POM配置的重要部分，让我们专注于JUnit集成测试。
- en: 'This test class only consists of two major methods: the test method itself
    where we have a minor test setup for the container to work properly, and the far
    more important method at this point—the configuration. Consider the following
    code snippet:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试类只包含两个主要方法：测试方法本身，其中我们有一个小的测试设置以确保容器正常工作，以及在这个阶段更为重要的方法——配置。考虑以下代码片段：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The unit test class needs the `@RunWith(PaxExam.class)` annotation to make clear
    it is a Pax Exam test. The `@ExamReactorStrategy` annotation lets you define a
    strategy for testing, either `PerClass`, `PerMethod`, or `PerSuite`, where you
    also need to define the test classes to run with. In our test, it is sufficient
    to run with the `PerClass` strategy as it starts the container only once per class,
    whereas the `PerMethod` strategy starts the test and its setup for each method
    invocation. The `PerSuite` strategy starts and configures the test setup for a
    suite of tests.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试类需要`@RunWith(PaxExam.class)`注解来明确它是一个Pax Exam测试。`@ExamReactorStrategy`注解允许你定义一个测试策略，可以是`PerClass`、`PerMethod`或`PerSuite`，其中你还需要定义要运行的测试类。在我们的测试中，使用`PerClass`策略就足够了，因为它只为每个类启动一次容器，而`PerMethod`策略则为每次方法调用启动测试及其设置。`PerSuite`策略为一系列测试启动和配置测试设置。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For details about the test strategies, refer to the Pax Exam documentation at
    [https://ops4j1.jira.com/wiki/display/PAXEXAM3/Pax+Exam](https://ops4j1.jira.com/wiki/display/PAXEXAM3/Pax+Exam).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有关测试策略的详细信息，请参阅 Pax Exam 文档，网址为 [https://ops4j1.jira.com/wiki/display/PAXEXAM3/Pax+Exam](https://ops4j1.jira.com/wiki/display/PAXEXAM3/Pax+Exam)。
- en: 'A Pax Exam test class always needs a `configuration` method annotated with
    the `@Configuration` annotation. This is needed for Pax Exam to know the configuration
    needed to run the test. For example, it is best to give a `workingDirectory` method,
    otherwise the working directory is placed in the temporary directory of the system.
    With the `junitBundles` method, the JUnit bundles are included so Pax Exam is
    capable of running JUnit tests. To run the tests with TestNG, it is required to
    add the dependencies of TestNG to the `configuration` method as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Pax Exam 测试类总是需要一个带有 `@Configuration` 注解的 `configuration` 方法。这是为了让 Pax Exam
    知道运行测试所需的配置。例如，最好提供一个 `workingDirectory` 方法，否则工作目录将放置在系统的临时目录中。通过 `junitBundles`
    方法，包括 JUnit 包，使 Pax Exam 能够运行 JUnit 测试。要使用 TestNG 运行测试，需要在 `configuration` 方法中添加
    TestNG 的依赖项，如下所示：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With the `frameworkProperty("osgi.console")` property, you're able to add an
    OSGi console to the test; if you run the test in debug mode, you're able to access
    this console via port `6666`. This completes the basic setup of a Pax Exam test
    where we already have one test method that checks whether the injected (`@Inject`)
    bundle context is available.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `frameworkProperty("osgi.console")` 属性，您可以为测试添加一个 OSGi 控制台；如果您以调试模式运行测试，您可以通过端口
    `6666` 访问此控制台。这完成了 Pax Exam 测试的基本设置，其中我们已经有了一个测试方法，用于检查注入的（`@Inject`）bundle上下文是否可用。
- en: How it works…
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As Pax Exam finds its own modules on the classpath through Maven, it starts
    the container by itself. This is true for either a Felix or Equinox or any other
    kind of container supplied to Pax Exam by the POM configuration. Everything else
    needs to be specified using the `configuration` method. If you are using other
    bundles in your test scenario, you also need to specify their Maven coordinates.
    It's usually best to specify the version of the bundle in question in your POM
    configuration, and reuse this version in your configuration. You'll find more
    on this in the upcoming recipes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Pax Exam 通过 Maven 在类路径上找到自己的模块，它通过自己启动容器。这对于 Felix、Equinox 或任何其他由 POM 配置提供给
    Pax Exam 的容器都是正确的。其他所有内容都需要使用 `configuration` 方法进行指定。如果您在测试场景中使用其他包，您还需要指定它们的
    Maven 坐标。通常最好在您的 POM 配置中指定所涉及包的版本，并在配置中重用此版本。您将在即将到来的菜谱中了解更多信息。
- en: So how does Pax Exam compare with a standard unit test? While testing on a unit
    level, maybe even with mocks, the tests are about the unit alone. Integration
    tests usually cover a wider range or a bigger scope with more units under test.
    Integration tests might be run as external tests against an externally available
    API. This is a bit hard if your APIs are services within a container. Pax Exam
    works with and within the container. The test class will be part of the deployed
    artifacts. In an OSGi environment, Pax Exam builds a dynamical bundle containing
    your test class, even with package imports. These bundle manifest headers can
    also be manipulated by the test; more details are available in the next recipe.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 Pax Exam 与标准单元测试相比如何？在单元级别进行测试时，也许甚至使用模拟，测试仅关注单元本身。集成测试通常覆盖更广泛的范围或更大的范围，测试的单元更多。集成测试可能作为外部测试针对外部可用的
    API 运行。如果您的 API 是容器内的服务，这将有点困难。Pax Exam 在容器内与容器一起工作。测试类将成为部署的工件的一部分。在 OSGi 环境中，Pax
    Exam 构建包含您的测试类的动态包，即使有包导入。这些包清单头也可以由测试进行操作；更多详细信息请参阅下一道菜谱。
- en: There's more…
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'An integration test usually tests an already built artifact, but sometimes
    it is essential to either alter the artifact or to test not after the artifact
    is built but when building this artifact. For this scenario, it is possible to
    build a *dynamic* bundle on the fly by configuring a `streamBundle`. This can
    be done as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试通常测试已经构建的工件，但有时修改工件或测试在构建工件之后而不是在构建工件时是必要的。对于这种情况，可以通过配置 `streamBundle`
    在线构建一个 *动态* 包。可以这样做：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This example shows how to build a dynamic bundle including an activator and
    exporting the right packages and other manifest header entries. The registered
    service can be directly imported into the test and used.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例展示了如何构建一个包含激活器并导出正确包和其他清单头条目的动态包。注册的服务可以直接导入到测试中并使用。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You might also be interested in using Pax Exam with other environments; it also
    supports Tomcat, Jetty, or JEE servers as backend for the runtime.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还对使用 Pax Exam 与其他环境感兴趣；它还支持 Tomcat、Jetty 或 JEE 服务器作为运行时的后端。
- en: Testing Apache Karaf features
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 Apache Karaf 功能
- en: After going through the *Setting up a Pax Exam test environment* recipe, you
    should be ready to test OSGi applications in general. Now, let's take a closer
    look at what is needed to run a test with Apache Karaf as the container.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成 *设置 Pax Exam 测试环境* 食谱后，您应该准备好测试 OSGi 应用程序。现在，让我们更详细地看看使用 Apache Karaf 作为容器运行测试所需的条件。
- en: Getting ready
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As in the previous chapters, the sources are available at [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe2](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe2).
    To fully understand this recipe, it is best to have gone through the previous
    recipe.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，源代码可在 [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe2](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe2)
    找到。为了完全理解这个食谱，最好已经完成了前面的食谱。
- en: How to do it…
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In the *Setting up a Pax Exam test environment* recipe, we defined the Felix
    framework as the runtime container. Now, we need to change this to Apache Karaf,
    so the first changes need to be done to the POM configuration. Pax Exam needs
    to know that it needs to run with Apache Karaf as the container; this is configured
    using the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *设置 Pax Exam 测试环境* 食谱中，我们定义了 Felix 框架作为运行时容器。现在，我们需要将其更改为 Apache Karaf，因此需要对
    POM 配置进行第一次更改。Pax Exam 需要知道它需要以 Apache Karaf 作为容器运行；这是通过以下方式配置的：
- en: The `pax-exam-container-karaf` dependency as a replacement dependency for the
    Felix framework.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为 Felix 框架替代依赖的 `pax-exam-container-karaf` 依赖项。
- en: The `apache-karaf` ZIP artifact to be used as the runtime container.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为运行时容器的 `apache-karaf` ZIP 艺术品。
- en: The standard features file for installing the standard features.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装标准功能的标准功能文件。
- en: 'Consider the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After these changes are made to the POM configuration, the test itself needs
    to be reconfigured as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在对 POM 配置进行这些更改后，测试本身需要按照以下方式进行重新配置：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The first major change should jump out at you right away: the Apache Karaf
    configuration, which has the `karafDistributionConfiguration` function with the
    Maven coordinates to an Apache Karaf ZIP file. As it is already defined in the
    POM configuration, the `versionAsInProject()` configuration can be used. Besides
    this, a feature is installed right away from the configuration and is available
    as soon as the container is up and running. The tests make sure the expected feature
    is installed.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个主要变化应该会立即跳入你的眼帘：Apache Karaf 配置，其中包含 `karafDistributionConfiguration` 函数和指向
    Apache Karaf ZIP 文件的 Maven 坐标。由于它已经在 POM 配置中定义，因此可以使用 `versionAsInProject()` 配置。除此之外，一个功能可以从配置中立即安装，并在容器启动并运行后立即可用。测试确保安装了预期的功能。
- en: How it works…
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Pax Exam uses Karaf as container instead of a given OSGi framework. Some extra
    configuration is needed because the container is assembled as a ZIP file and needs
    to be unwrapped first. After this is done, the Apache Karaf container is started
    at the given location with the configured constraints, for example, to turn off
    the `Deploy` folder. The `versionAsInProject()` configuration needs some extra
    handling. For this to work, you need to make sure a Maven dependency file is generated.
    This can be done by configuring `depends-maven-plugin` from the ServiceMix project.
    This will generate a file containing all dependency information contained in the
    POM configuration readable by Pax Exam. Consider the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Pax Exam 使用 Karaf 作为容器而不是给定的 OSGi 框架。由于容器是以 ZIP 文件的形式组装的，需要先解包，因此需要一些额外的配置。完成此操作后，Apache
    Karaf 容器将在指定位置启动，并使用配置的约束，例如关闭 `Deploy` 文件夹。`versionAsInProject()` 配置需要一些额外的处理。为了使其工作，您需要确保生成一个
    Maven 依赖文件。这可以通过从 ServiceMix 项目配置 `depends-maven-plugin` 来完成。这将生成一个包含 Pax Exam
    可读的 POM 配置中所有依赖信息的文件。考虑以下代码：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With these configurations done, your tests are set. In the given test sample,
    we used an internal feature descriptor; if you want to test any other kind of
    custom feature, you just need to add it to the configuration and tell it which
    feature should be deployed. In the previous sample, it is the `eventadmin` feature.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些配置后，你的测试就设置好了。在给定的测试示例中，我们使用了内部功能描述符；如果你想测试任何其他类型的自定义功能，你只需将其添加到配置中，并告诉它应该部署哪个功能。在先前的示例中，是
    `eventadmin` 功能。
- en: Besides the already known simple injection of the `bundlecontext` object, it
    is also possible to inject any kind of service to the test that is available in
    the container. In the previous sample, we injected `featuresService`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 除了已知的简单注入 `bundlecontext` 对象外，还可以将容器中可用的任何类型的服务注入到测试中。在先前的示例中，我们注入了 `featuresService`。
- en: Testing commands with Apache Karaf
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Apache Karaf 测试命令
- en: After you've gone through the first two recipes, you should be set for thorough
    testing of OSGi bundles, either standalone or in Apache Karaf. When working with
    Apache Karaf, it is sometimes necessary to also have new commands. This recipe
    will cover how to test with commands and make sure these commands are executed
    inside the Apache Karaf shell.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成前两个配方后，你应该已经准备好对 OSGi 包进行彻底测试，无论是独立测试还是 Apache Karaf 中的测试。当与 Apache Karaf
    一起工作时，有时还需要有新的命令。本配方将介绍如何使用命令进行测试，并确保这些命令在 Apache Karaf 壳中执行。
- en: Getting ready
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: It's best to have gone through the *Testing Apache Karaf features* recipe before
    starting this recipe, as this one is a follow up. The sources can be found at
    [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe3](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe3).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本配方之前最好已经阅读过 *Testing Apache Karaf features* 配方，因为本配方是一个后续配方。源代码可以在 [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe3](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe3)
    找到。
- en: How to do it...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To test the execution of an Apache Karaf shell command, you need to tweak the
    test class. First, you need to alter the way the test is run. For this, we add
    the probe builder which configures the way the test bundle is built. Consider
    the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试 Apache Karaf 壳命令的执行，你需要调整测试类。首先，你需要改变测试的运行方式。为此，我们添加了探针构建器，它配置了测试包的构建方式。考虑以下代码：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following lines of code make sure the injection for the `CommandProcessor`
    interface works properly:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行确保 `CommandProcessor` 接口的注入工作正常：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For the actual testing of commands, we add a convenience method that sends
    the command to the Karaf shell and receives the output from it. This can be done
    as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实际测试命令，我们添加了一个方便的方法，该方法将命令发送到 Karaf 壳，并从中接收输出。这可以按以下方式完成：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This string containing the response is testable for the expected output.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 包含响应的字符串可以测试预期的输出。
- en: How it works…
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The essential part of this test is the addition of the `ProbeBuilder` annotation.
    The `ProbeBuilder` annotation alters the way the bundle containing the test class
    is built. In our case, it alters the `Package-Import` header of the generated
    bundle. It is not only possible to alter or add manifest headers, but also to
    add additional classes or test classes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 本测试的关键部分是添加 `ProbeBuilder` 注解。`ProbeBuilder` 注解改变了包含测试类的包的构建方式。在我们的例子中，它改变了生成的包的
    `Package-Import` 标头。不仅可能改变或添加清单头，还可以添加额外的类或测试类。
- en: Coverage with Apache Karaf Pax Exam tests
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Apache Karaf Pax Exam 测试覆盖率
- en: Apart from testing the application, it is usually also a requirement to know
    how well the unit and integration tests actually cover the code. For code coverage,
    a couple of technologies are available. This recipe will cover how to set up your
    test environment to find the coverage of the test.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 除了测试应用程序外，通常还需要知道单元和集成测试实际上覆盖了代码的程度。对于代码覆盖率，有一些技术可用。本配方将介绍如何设置测试环境以找到测试的覆盖率。
- en: Getting ready
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: It's best to have gone through the *Testing Apache Karaf features* recipe before
    starting this follow-up recipe. The sources of this recipe are available at [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe4](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe4).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始此后续配方之前最好已经阅读过 *Testing Apache Karaf features* 配方。本配方的源代码可以在 [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe4](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe4)
    找到。
- en: How to do it…
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To find out about the coverage of the test, a code coverage tool is needed.
    We will take the Java Code Coverage Library as it has a Maven plugin for automated
    coverage analysis. At first, the Maven coordinates for the plugin are added as
    shown in the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解测试的覆盖率，需要一个代码覆盖率工具。我们将采用 Java 代码覆盖率库，因为它有一个用于自动化覆盖率分析的 Maven 插件。首先，将插件的 Maven
    坐标添加到如下代码中：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We need to prepare the code first so it can be covered by the agent as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要首先准备代码，以便代理可以按照以下方式覆盖它：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will include the `com.packt` package, including subpackages. After the
    integration tests are done, the test report needs to be generated as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这将包括 `com.packt` 包，包括子包。在集成测试完成后，需要按照以下方式生成测试报告：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Besides these additions to the POM configuration, you need to add the VM options
    to the configuration of the Apache Karaf test. Without setting these options to
    the virtual machine, which executes the test, the executing environment doesn''t
    know of the coverage and, therefore, no coverage is done. This can be done as
    follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些对 POM 配置的添加之外，你还需要将 VM 选项添加到 Apache Karaf 测试的配置中。如果不将这些选项设置到执行测试的虚拟机中，执行环境就不知道覆盖率，因此不会进行覆盖率测试。这可以按照以下方式完成：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The resulting report of this coverage looks like the following screenshot. It
    shows the coverage of the `CalculatorImpl` class and its methods. While the `add`
    method has been called by the test, the `sub` method wasn't. This results in zero
    coverage for that method.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此覆盖率的报告看起来如下截图所示。它显示了 `CalculatorImpl` 类及其方法的覆盖率。虽然 `add` 方法已被测试调用，但 `sub` 方法没有被调用。这导致该方法的覆盖率为零。
- en: '![How to do it…](img/5081OS_10_01.png.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/5081OS_10_01.png.jpg)'
- en: How it works…
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: First, you need to prepare the agent for covering, this will be inserted into
    the `jcoverage.command` property. This property is passed to the test by adding
    the `vmOption` directory. This way the coverage agent is added to the Java Virtual
    Machine and it tracks the coverage of the test execution. After the test is run
    successfully, the report is generated by the `jacoco-maven-plugin`. All of this
    works fine with a single Maven module. A multimodule project setup will require
    additional work, especially if you want to combine unit and integration test coverage.
    More details can be found at [http://www.eclemma.org/jacoco/index.html](http://www.eclemma.org/jacoco/index.html).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要为覆盖准备代理，这将插入到 `jcoverage.command` 属性中。此属性通过添加 `vmOption` 目录传递给测试。这样，覆盖率代理就被添加到
    Java 虚拟机中，并跟踪测试执行的覆盖率。测试成功运行后，由 `jacoco-maven-plugin` 生成报告。所有这些都可以在单个 Maven 模块中正常工作。对于多模块项目设置，将需要额外的工作，特别是如果你想要结合单元和集成测试覆盖率。更多详细信息可以在
    [http://www.eclemma.org/jacoco/index.html](http://www.eclemma.org/jacoco/index.html)
    找到。
- en: Testing Apache Camel with Blueprint and Apache Karaf
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Blueprint 和 Apache Karaf 测试 Apache Camel
- en: This recipe will cover how to test a Camel Blueprint definition. The focus of
    this recipe will be on the test and how it differs from the *Testing Apache Karaf
    features* recipe.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方将介绍如何测试 Camel Blueprint 定义。本配方的重点是测试，以及它与 *Testing Apache Karaf features*
    脚本的不同之处。
- en: Getting ready
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: It's best to have gone through the *Testing Apache Karaf features* recipe and
    the *Creating a Blueprint-based Camel Router for deployment in Apache Karaf* recipe
    before starting this follow-up recipe. The sources of this chapter are available
    at [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe5](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe5).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始此后续配方之前，最好已经熟悉了 *Testing Apache Karaf features* 脚本和 *Creating a Blueprint-based
    Camel Router for deployment in Apache Karaf* 脚本。本章的源代码可在 [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe5](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe5)
    找到。
- en: How to do it…
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Since we have based this recipe on the *Testing Apache Karaf features* recipe,
    we already have a basic setup containing the setup of the Apache Karaf container.
    Additionally, we need the Apache Camel feature for Karaf. This way all the bundles
    required for testing a Camel route are present. The test itself requires the Camel
    Context of the `blueprint.xml` definition to attach itself to its mock object.
    This can be done as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们基于 *Testing Apache Karaf features* 脚本创建了此配方，因此我们已经有了一个包含 Apache Karaf 容器设置的初步设置。此外，我们还需要
    Apache Camel 的功能。这样，所有用于测试 Camel 路由所需的包都齐备了。测试本身需要将 `blueprint.xml` 定义中的 Camel
    Context 连接到其模拟对象。这可以按照以下方式完成：
- en: 'The test class itself inherits from the `CamelTestSupport` class for easier
    testing of Camel:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试类本身继承自`CamelTestSupport`类，以便更容易地对Camel进行测试：
- en: '[PRE14]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To have access to the mock contained in the Camel route, we make sure the Camel
    Context is injected. The `@Filter` annotation makes sure only the desired Camel
    Context is injected within the given timeout.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了访问Camel路由中包含的模拟对象，我们确保Camel上下文被注入。`@Filter`注解确保在给定的超时时间内只注入所需的Camel上下文。
- en: 'The configuration contains the targeted Karaf runtime and installs the required
    `camel-blueprint` and `camel-test` features as shown in the following code:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置包含目标Karaf运行时，并安装所需的`camel-blueprint`和`camel-test`特性，如下所示：
- en: '[PRE15]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Additionally, the `HelloBean` class and `blueprint.xml` file are wrapped up
    in a streamed bundle so the test is runnable inside the same module. As the last
    specialty to the test, we make sure the Camel Context is only created once per
    class creation. This can be done as follows:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，`HelloBean`类和`blueprint.xml`文件被封装在一个流式捆绑包中，以便测试可以在同一模块内运行。作为测试的最后一个特殊之处，我们确保每个类创建时Camel上下文只创建一次。这可以通过以下方式实现：
- en: '[PRE16]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This completes the setup for testing a Camel route with Pax Exam inside the
    Karaf container.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就完成了在Karaf容器内使用Pax Exam测试Camel路由的设置。
- en: 'In the `Test` method, we make sure that the required features are installed,
    the Camel Context has been injected, and that the mock is satisfied. Consider
    the following code:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Test`方法中，我们确保所需的特性已安装，Camel上下文已注入，并且模拟对象已满足。考虑以下代码：
- en: '[PRE17]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works…
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: As in the previous recipes, Pax Exam makes sure Apache Karaf is run as the basic
    container. With the feature configuration inside the `@Configuration` method,
    we install the `camel-blueprint` and `camel-test` features. The test makes sure
    those features are indeed installed and running. To verify that the `HelloBean`
    class has actually sent a message to the mock endpoint, the test gets the mock
    endpoint from the injected Camel Context and expects at least a message count
    of one. Pax Exam injects the Camel Context used by the `blueprint.xml` file into
    the test class. To make sure it is the context that is actually needed, the `@Filter`
    annotation given with the LDAP filter syntax for OSGi services is used. While
    the `blueprint.xml` file containing the Camel Context is started, the Camel Context
    itself is registered as a service in the OSGi registry with the Camel Context
    ID registered as the `camel.context.name` property.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的食谱，Pax Exam确保Apache Karaf作为基本容器运行。在`@Configuration`方法内的特性配置中，我们安装了`camel-blueprint`和`camel-test`特性。测试确保这些特性确实已安装并正在运行。为了验证`HelloBean`类是否确实向模拟端点发送了消息，测试从注入的Camel上下文中获取模拟端点并期望至少有一个消息计数。Pax
    Exam将`blueprint.xml`文件使用的Camel上下文注入到测试类中。为了确保它是实际需要的上下文，使用了带有LDAP过滤器语法的`@Filter`注解。当包含Camel上下文的`blueprint.xml`文件启动时，Camel上下文本身在OSGi注册表中注册为服务，Camel上下文ID注册为`camel.context.name`属性。
- en: Because of the inheritance and the overridden `isCreateCamelContextPerClass`
    method, the Camel Context is only created once during the test execution. This
    is essential for running the Camel tests with Pax Exam because the container is
    only created once in the test. Otherwise, the Camel Context would be created a
    couple of times resulting in various errors.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于继承和重写的`isCreateCamelContextPerClass`方法，Camel上下文在测试执行期间只创建一次。这对于使用Pax Exam运行Camel测试是必要的，因为容器在测试中只创建一次。否则，Camel上下文会被创建几次，导致各种错误。
- en: To assert the successful execution of the test and to verify the expected message
    count, you are required to call the `assertIsSatisfied` method on the mock instead
    of calling the `assertMockEndpointsSatisfied` method. The latter method asserts
    all mock endpoints of the Camel Context bound to the test itself, while the former
    one asserts the mock that is contained in the Camel Context created by the Blueprint
    handler.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了断言测试的成功执行并验证预期的消息计数，您需要在模拟对象上调用`assertIsSatisfied`方法，而不是调用`assertMockEndpointsSatisfied`方法。后者方法断言绑定到测试本身的Camel上下文的所有模拟端点，而前者方法断言由Blueprint处理器创建的Camel上下文中包含的模拟对象。
