- en: Miscellaneous Improvements in JDK 10
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JDK 10的其他改进
- en: Prior to Java 9, new versions of Java were released every three years (on average).
    The release timeline changed with Java 9, with the adoption of a six-month release
    cadence. Java 10 was released just six months after the release of Java 9\. We
    already covered the major features of Java 10 in the first three chapters; [Chapter
    1](0ffcea11-5fd2-4b3a-a791-b5917061c1c7.xhtml), *Type Inference*, [Chapter 2](210b06d5-c434-43dd-90a7-23c1d83d69bf.xhtml),
    *AppCDS*, and [Chapter 3](5dad8c1c-c2c4-4f32-8e5e-e39ce138d989.xhtml), *Garbage
    Collector Optimizations*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9之前，Java的新版本每三年（平均）发布一次。Java 9的发布时间表发生了变化，采用了六个月的发布周期。Java 10在Java 9发布后的六个月内发布。我们已经在前三章中介绍了Java
    10的主要功能；[第一章](0ffcea11-5fd2-4b3a-a791-b5917061c1c7.xhtml)，*类型推断*，[第二章](210b06d5-c434-43dd-90a7-23c1d83d69bf.xhtml)，*AppCDS*，和[第三章](5dad8c1c-c2c4-4f32-8e5e-e39ce138d989.xhtml)，*垃圾收集器优化*。
- en: In this chapter, we'll cover the remaining additions or updates to Java 10,
    most of which are related to changes in the JDK or its implementation. We'll also
    cover a few additions and modifications to the Java API.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖Java 10剩余的添加或更新，其中大部分与JDK或其实现的变化有关。我们还将涵盖对Java API的一些添加和修改。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Thread-local handshakes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程局部握手
- en: Time-based release versioning
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于时间的发布版本号
- en: Consolidating the JDK forest into a single repository
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将JDK森林合并为一个单一存储库
- en: Heap allocation on alternative memory devices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在替代内存设备上进行堆分配
- en: Additional Unicode language-tag extensions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外的Unicode语言标记扩展
- en: Root certificates
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根证书
- en: The experimental Java-based JIT compiler
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于实验性Java的JIT编译器
- en: Removal of the Native-Header Generation Tool
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除原生头生成工具
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter will include an overview of the JDK 10 features that are related
    to the JDK or their implementation. This chapter will not include any code for
    you to work with.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将概述与JDK或其实现相关的JDK 10功能。本章将不包括任何供您使用的代码。
- en: Since this chapter covers multiple features in Java 10, let's quickly map the
    features with its **JDK Enhancement Proposal** (**JEP**) number and scope.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章涵盖了Java 10的多个功能，让我们快速将功能与其**JDK增强提案**（**JEP**）编号和范围进行关联。
- en: Mapping JDK 10 features with scopes and JEPs
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将JDK 10功能与范围和JEP关联
- en: 'The following table lists the JDK 10 features that will be covered in this
    chapter, the features'' corresponding JEP numbers, and their scopes:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了本章将涵盖的JDK 10功能，功能的对应JEP编号以及它们的范围：
- en: '| **JEP No.** | **Scope** | **Description** |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| **JEP No.** | **Scope** | **Description** |'
- en: '| 296 | Implementation | Consolidate the JDK forest into a single repository
    |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 296 | 实现 | 将JDK森林合并为一个单一存储库 |'
- en: '| 312 | JDK | Thread-local handshakes |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 312 | JDK | 线程局部握手 |'
- en: '| 313 | JDK | Removal of the Native-Header Generation Tool (`javah`) |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 313 | JDK | 移除原生头生成工具(`javah`) |'
- en: '| 314 | SE | Additional Unicode language-tag extensions |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 314 | SE | 额外的Unicode语言标记扩展 |'
- en: '| 316 | JDK | Heap allocation on alternative memory devices |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 316 | JDK | 在替代内存设备上进行堆分配 |'
- en: '| 317 | JDK | Experimental Java-based JIT compiler |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 317 | JDK | 基于实验性Java的JIT编译器 |'
- en: '| 319 | JDK | Root certificates |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 319 | JDK | 根证书 |'
- en: '| 322 | SE | Time-based release versioning |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 322 | SE | 基于时间的发布版本号 |'
- en: Let's get started with the first feature.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个功能开始。
- en: Consolidating the JDK forest into a single repository
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将JDK森林合并为一个单一存储库
- en: Up to Java 9, JDK's code base used multiple repositories (there are eight repositories
    in Java 9—`root`, `corba`, `hotspot`, `jaxp`, `jaxws`, `jdk`, `langtools`, and
    `nashorn`). Consolidating the JDK forest aims to combine the multiple repositories
    used by the JDK into a single repository.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 到Java 9为止，JDK的代码库使用了多个存储库（Java 9中有八个存储库——`root`，`corba`，`hotspot`，`jaxp`，`jaxws`，`jdk`，`langtools`和`nashorn`）。合并JDK森林的目标是将JDK使用的多个存储库合并为一个单一存储库。
- en: As JDK's code base grew over the years, it was stored in separate repositories
    on purpose, for a separation of concerns. However, as the JDK evolved, the code
    base also developed interdependencies across different repositories.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 随着JDK代码库多年来的增长，它故意存储在单独的存储库中，以实现关注点的分离。然而，随着JDK的发展，代码库在不同存储库之间也发展出了相互依赖性。
- en: The advantages offered by these multiple repositories have outgrown the disadvantages
    with their maintenance. For interdependent changesets, you can't perform a single
    commit to a repository. There have been cases where the code for even a single
    (and simple) bug fix spanned multiple repositories. In such cases, the commit
    can't be performed atomically. A common approach is to use the same bug ID across
    multiple repositories. But this is not mandated, since using the same bug ID is
    not mandated, commits for same bug across different repositories could be made
    using different bug IDs. This can lead to difficulty in tracking bug fixes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些多个仓库提供的优势已经超过了它们的维护劣势。对于相互依赖的变更集，你无法对仓库执行单个提交。有些情况下，即使是单个（且简单的）错误修复的代码也跨越了多个仓库。在这种情况下，提交无法原子化执行。一种常见的方法是在多个仓库中使用相同的bug
    ID。但这并不是强制性的，因为使用相同的bug ID不是强制性的，不同仓库中相同bug的提交可以使用不同的bug ID。这可能导致跟踪错误修复的困难。
- en: Also, the individual repositories don't have independent development tracks
    and release cycles. Java has one main release cycle, which includes changes in
    all of these repositories. Therefore, it was high time to integrate the JDK code
    base into one repository, to ease its maintenance.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，各个仓库没有独立的发展轨道和发布周期。Java有一个主要的发布周期，包括所有这些仓库的变化。因此，将JDK代码库集成到一个仓库中，以简化其维护，已经势在必行。
- en: This is a housekeeping feature that won't affect how you write your code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个维护功能，不会影响你编写代码的方式。
- en: Thread-local handshakes
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Thread-local handshakes
- en: Suppose that you need to pause a particular thread, executing a callback on
    it. Prior to thread-local handshakes, there wasn't any way to do that. The norm
    was to perform a global VM safepoint, which pauses all of the executing threads
    (and what a waste that is, if you meant to pause only one thread). With thread-local
    handshakes, it is possible to stop individual threads.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要暂停一个特定的线程，并在其上执行回调。在thread-local handshakes之前，没有方法可以做到这一点。通常的做法是执行全局VM
    safepoint，这将暂停所有正在执行的线程（如果你只想暂停一个线程，这无疑是一种浪费）。有了thread-local handshakes，可以停止单个线程。
- en: By aiming to reduce global VM safepoints, thread-local handshakes will reduce
    JVM latency and improve its efficiency.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过旨在减少全局VM safepoints，thread-local handshakes将减少JVM延迟并提高其效率。
- en: Thread-local handshakes are a JVM implementation feature that can't be used
    directly by developers.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Thread-local handshakes是JVM实现的一个特性，开发者不能直接使用。
- en: Removal of the Native-Header Generation Tool (javah)
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除Native-Header生成工具（javah）
- en: This version of JEP has removed the `javah` tool from the tools shipped with
    the JDK.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: JEP的这个版本已经从JDK附带工具中移除了`javah`工具。
- en: Suppose that you need instances of your class to be referenced by native code
    in C. Developers have used the `javah` tool to generate the C header and source
    files from a Java class. The generated code is used to enable native code (say,
    written in C) to access the instances of your Java class. The `javah` tool creates
    a `.h` file, which defines `struct`, similar to the structure of your class. For
    multiple classes in a source file, the `javah` tool generates separate `.h` files.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要你的类的实例在C的本地代码中被引用。开发者们使用`javah`工具从Java类生成C的头文件和源文件。生成的代码用于使本地代码（比如用C编写的代码）能够访问你的Java类的实例。`javah`工具创建一个`.h`文件，它定义了一个`struct`，类似于你的类的结构。对于源文件中的多个类，`javah`工具会生成单独的`.h`文件。
- en: The removal of `javah` doesn't imply any decline in the usage of your Java classes
    by the native code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 移除`javah`并不意味着你的Java类在本地代码中的使用量有所下降。
- en: With Java 8, `javah` was enhanced to take on the responsibility of generating
    the C header and source code files. After testing over two versions, `javah` is
    being removed from Java SE 10.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8中，`javah`被增强以承担生成C头文件和源代码文件的责任。经过两个版本的测试后，`javah`将从Java SE 10中移除。
- en: The removal of the `javah` tool is compensated by the advanced compilation options
    in `javac`, which can be used to generate the C header and source files.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`javah`工具的移除由`javac`中的高级编译选项所补偿，这些选项可以用来生成C头文件和源文件。'
- en: Additional Unicode language-tag extensions
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外的Unicode语言标签扩展
- en: This feature enhances `java.util.Locale` and its related API to implement an
    additional Unicode extension of the BCP 47 language tag. Support for the BCP 47
    language was added to JDK 7\. However, in JDK 7, support for the Unicode locale
    extension was limited to calendar and numbers. This feature allowed for the addition
    of an extension to a locale. JDK 9 added support for `ca` and `nu` tags, from
    BCP 47.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能增强了`java.util.Locale`及其相关API，以实现BCP 47语言标签的附加Unicode扩展。对BCP 47语言的支持添加到了JDK
    7。然而，在JDK 7中，对Unicode区域扩展的支持仅限于日历和数字。此功能允许向区域添加扩展。JDK 9添加了对`ca`和`nu`标签的支持，这些标签来自BCP
    47。
- en: 'JDK 10 added support for the following extensions:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 10添加了对以下扩展的支持：
- en: '`cu` (currency type)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cu`（货币类型）'
- en: '`fw` (first day of the week)'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fw`（一周的第一天）'
- en: '`rg` (region over)'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rg`（区域覆盖）'
- en: When you specify a locale extension, such as a number or currency type, it is
    not guaranteed that the underlying platform supports the requested extension.
    Unicode tag extensions are a language feature, and they can be used directly by
    the developers.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当你指定一个区域扩展，如数字或货币类型时，并不能保证底层平台支持所请求的扩展。Unicode标签扩展是一种语言特性，开发者可以直接使用。
- en: Heap allocation on alternative memory devices
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在替代内存设备上的堆分配
- en: When JVM exhausts its heap memory, your application crashes with `OutOfMemoryException`.
    Imagine if you could configure your JVM to use an alternate memory device, like
    a **non-volatile dual in-line memory module** (**NV-DIMM**).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当JVM耗尽其堆内存时，你的应用程序会因`OutOfMemoryException`而崩溃。想象一下，如果你能配置你的JVM使用替代内存设备，比如一个**非易失性双列内存模块**（**NV-DIMM**）。
- en: With the ever-increasing memory demands of applications that deal with large
    amounts of data, and with the availability of low-cost NV-DIMM memory, the ability
    to use alternate memory devices for heap allocations is bliss. It also leads to
    systems that work with heterogeneous memory architectures.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 随着处理大量数据的应用程序对内存需求的不断增长，以及低成本NV-DIMM内存的可用性，能够使用替代内存设备进行堆分配是一种幸福。这也导致了使用异构内存架构的系统。
- en: This enhancement targets alternative memory devices that have the same semantics
    as **Dynamic Random Access Memory** (**DRAM**), so that they can be used instead
    of DRAM, without requiring any changes to the existing application code. All of
    the other memory structures, such as the stack, code heap, and so on, will continue
    to use DRAM.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此增强针对具有与**动态随机存取存储器**（**DRAM**）相同语义的替代内存设备，以便它们可以替代DRAM使用，而无需对现有应用程序代码进行任何更改。所有其他内存结构，如栈、代码堆等，将继续使用DRAM。
- en: A quick detail before we move forward—NV-DIMM has higher access latency compared
    to DRAM. But NV-DIMM has a larger capacity at a lower cost compared to DRAM. So,
    the low-priority processes can use NV-DIMM, whereas the high-priority processes
    can use DRAM memory.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续前进之前的一个快速细节——NV-DIMM与DRAM相比，访问延迟更高。但与DRAM相比，NV-DIMM具有更大的容量且成本更低。因此，低优先级的过程可以使用NV-DIMM，而高优先级的过程可以使用DRAM内存。
- en: Heap allocation is a JVM implementation detail that can't be used directly by
    developers.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 堆分配是JVM实现细节，开发者不能直接使用。
- en: The experimental Java-based JIT compiler
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验性的基于Java的JIT编译器
- en: The Java compilers that you worked with until now were usually written in C/C++.
    What would you think about a Java compiler written in Java?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你至今所使用的Java编译器通常是用C/C++编写的。你会怎么想一个用Java编写的Java编译器？
- en: Graal, a Java-based **just in-time** (**JIT**) compiler, was introduced in Java
    9\. Java 10 enables the use of Graal as an experimental JIT compiler on Linux/x64
    platforms. Eventually, Oracle will explore the possibility of using Graal as a
    Java-based JIT for the JDK.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Graal，一个基于Java的**即时编译器**（**JIT**），在Java 9中引入。Java 10使Linux/x64平台上的Graal作为实验性JIT编译器可用。最终，Oracle将探索使用Graal作为基于Java的JIT编译器用于JDK的可能性。
- en: Graal uses the JVM compiler interface, introduced in JDK 9\. The objective of
    Graal is not to compete with the existing JIT compilers. It is a part of the project
    Metropolis, which explores and incubates Java-on-Java implementation techniques
    for HotSpot, the open JDK implementation of the JVM.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Graal使用JDK 9中引入的JVM编译器接口。Graal的目标不是与现有的JIT编译器竞争。它是Metropolis项目的一部分，该项目探索和孵化HotSpot（JVM的开放JDK实现）的Java-on-Java实现技术。
- en: Since Graal is written in Java, fears of using Graal are related to lower startup
    performance of applications and increased heap usage.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Graal是用Java编写的，使用Graal的担忧与应用程序较低的启动性能和增加的堆使用量有关。
- en: 'The following command-line compiler option can be used to enable Graal as your
    JIT compiler:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令行编译器选项可用于启用 Graal 作为您的 JIT 编译器：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Graal is an experimental JIT compiler that can be configured for use with command-line
    options.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Graal 是一个实验性的 JIT 编译器，可以通过命令行选项进行配置以供使用。
- en: Root certificates
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根证书
- en: Imagine configuring an account on a cloud storage service provider, using your
    system. The cloud interface can request a certificate and their values to be stored
    on your system. When reconnecting to the cloud service, your system automatically
    authenticates it using the certificate.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下在云存储服务提供商上配置一个账户，使用您的系统。云接口可以请求证书及其值存储在您的系统中。当重新连接到云服务时，您的系统会自动使用证书对其进行身份验证。
- en: 'With JDK, such certificates are stored in the `cacerts` keystore. The certificate
    file `cacerts` resides in the security directory of your JDK installation directory
    and represents **Certification Authority** (**CA**) certifications applicable
    to the system-wide key store, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JDK，此类证书存储在 `cacerts` 密钥库中。证书文件 `cacerts` 位于 JDK 安装目录的安全目录中，代表适用于系统级密钥库的
    **认证机构**（**CA**）证书，如下所示：
- en: 'Windows: `JAVA_HOME\lib\security`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows：`JAVA_HOME\lib\security`
- en: 'Linux, Solaris, and macOS X: `JAVA_HOME/lib/security`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux、Solaris 和 macOS X：`JAVA_HOME/lib/security`
- en: The root certificates are used to establish trust in the certificate chains
    employed in the various security protocols. The problem is that the `cacerts`
    keystore doesn't have any certificates in the JDK source code, which is mandatory
    for the default functionality of security components, such as TLS, in OpenJDK
    builds.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 根证书用于在各个安全协议中建立对证书链的信任。问题是 `cacerts` 密钥库在 JDK 源代码中没有任何证书，这对于 OpenJDK 构建中安全组件（如
    TLS）的默认功能是必需的。
- en: With root certificates, Oracle plans to bridge the gap between the OpenJDK build
    and OracleJDK builds. The users must populate their `cacerts` keystore with a
    set of root certificates to bridge this gap.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用根证书，Oracle 计划弥合 OpenJDK 构建与 OracleJDK 构建之间的差距。用户必须将一组根证书填充到 `cacerts` 密钥库中，以弥合这一差距。
- en: The plan is to provide a default set of rootCA certificates in JDK, and open
    source the root certificates in Oracle's Java SE Root CA program.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 计划在 JDK 中提供一组默认的根 CA 证书，并将 Oracle 的 Java SE Root CA 程序中的根证书开源。
- en: The root certificates can be issued by the CAs of Oracle's Java SE Root CA program.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 根证书可以由 Oracle 的 Java SE Root CA 程序的 CA 发布。
- en: Root certificates are a JDK feature.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 根证书是 JDK 的一个功能。
- en: Time-based release versioning
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于时间的发布版本控制
- en: The feature of time-based release versioning revises the version-string scheme
    of JDK SE platform, for current and future time-based release versions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 基于时间的发布版本控制功能修订了 JDK SE 平台的版本字符串方案，适用于当前和未来的基于时间的发布版本。
- en: 'The proposed format is as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 建议的格式如下：
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following are the details of the elements used in the preceding string:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在前述字符串中使用的元素详情：
- en: '`$FEATURE`: With the new (and strict) six-month release cadence, this value
    is incremented every six months. The JDK version released on Mar 2018 was 10,
    the version released in Sep 2018 was JDK 11\. JDK 12 released in Mar 2019, and
    so on.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$FEATURE`：由于新的（且严格的）六个月发布节奏，此值每六个月增加一次。2018 年 3 月发布的 JDK 版本是 10，2018 年 9 月发布的版本是
    JDK 11。2019 年 3 月发布了 JDK 12，以此类推。'
- en: '`$INTERIM`: With the six-month release cadence, there aren''t any interim releases.
    However, this element is retained for potential future use cases.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$INTERIM`：由于六个月一次的发布节奏，没有临时发布。然而，此元素保留以供未来潜在的使用场景。'
- en: '`$UPDATE`: This element represents an update, incremented for compatible update
    releases that fix security issues, regressions, and bugs in newer features. This
    is incremented a month after the increment in `$FEATURE`, and every three months
    thereafter.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$UPDATE`：此元素表示更新，用于兼容更新发布，以修复安全漏洞、回归和新功能中的错误。此值在 `$FEATURE` 增量后一个月增加，之后每三个月增加一次。'
- en: '`$PATCH`: This element represents the emergency patch-release counter, for
    emergency releases for a critical bug.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$PATCH`：此元素表示紧急补丁发布计数器，用于针对关键错误的紧急发布。'
- en: Summary
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you skimmed through the various additions and modifications
    to JDK 10, barring its main features of type inference, application class data
    sharing, and garbage collector optimization.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您浏览了 JDK 10 的各种新增和修改，但排除了其主特性，如类型推断、应用程序类数据共享和垃圾收集器优化。
- en: Most of the features covered in this chapter were related to the changes in
    JDK, including reducing global VM safepoints with thread-local handshakes, the
    removal of `javah`, using alternative memory devices for heap allocation, Graal,
    and root certificates. It includes fewer SE features—additional Unicode language-tag
    extensions and time-based release versioning. The consolidation of the JDK forest
    into a single repository is more of a housekeeping detail.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中介绍的大部分功能都与 JDK 的变化有关，包括通过线程局部握手减少全局 VM 安全点、移除 `javah`、使用替代内存设备进行堆分配、Graal
    和根证书。它包含较少的 SE 功能——额外的 Unicode 语言标签扩展和基于时间的发布版本编号。将 JDK 森林合并为单个存储库更多是一个日常维护细节。
- en: In the next chapter, we'll look at the new additions and modifications to JDK
    11\. I'm excited and hope you are, too!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 JDK 11 的新增功能和修改。我非常兴奋，也希望你们也是一样！
