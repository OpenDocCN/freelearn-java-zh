- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Adding Authentication in Angular
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Angular 中添加认证
- en: In the previous chapter, we completed the CRUD features of our Angular application
    using the building blocks of NgRx. We also learned the step-by-step process of
    writing the actions, reducers, and effects in our application that will be used
    to modify the value of states. We also learned the difference between using and
    not using effects in the application. Effects are essential for us to communicate
    with the external APIs that allow the database changes to be synced in the NgRx
    store.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用 NgRx 的构建块完成了我们的 Angular 应用程序的 CRUD 功能。我们还学习了在应用程序中编写 actions、reducers
    和 effects 的逐步过程，这些将被用于修改状态值。我们还学习了在应用程序中使用和不使用 effects 的区别。Effects 对于我们与允许数据库更改同步到
    NgRx 存储的外部 API 进行通信至关重要。
- en: In this chapter, we will learn how to add authentication in our Angular application;
    we will implement a login page that will provide a valid JWT, protect routes,
    and apply API authentication with the use of NgRx.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何在我们的 Angular 应用程序中添加认证；我们将实现一个登录页面，该页面将提供有效的 JWT，保护路由，并使用 NgRx 应用
    API 认证。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Adding user authentication
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加用户认证
- en: Protecting routes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护路由
- en: Calling an API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 API
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The complete code for this chapter can be found at: https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-14.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码可以在以下位置找到：https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-14。
- en: Adding user authentication
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加用户认证
- en: Adding user authentication is one of the main requirements in developing an
    application. This feature allows us to restrict pages and features from unauthorized
    users. We can achieve user authentication in different ways, and one way to implement
    this is by providing a login page that will ask for credentials.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用程序时，添加用户认证是主要要求之一。此功能允许我们限制页面和功能不被未经授权的用户访问。我们可以以不同的方式实现用户认证，其中一种实现方式是提供一个要求凭证的登录页面。
- en: Let’s have a look at the step-by-step process of implementing the authentication
    feature.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地看看实现认证功能的步骤。
- en: The authentication API
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证 API
- en: 'Let us first recap the authentication API we created in our Spring Boot project.
    The endpoints for authentication are as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先回顾一下我们在 Spring Boot 项目中创建的认证 API。认证端点如下：
- en: '`{BASE_URL}/authenticate`: The main endpoint for authentication accepts an
    object with email and password fields and returns a valid JWT that will be used
    for calling endpoints. The following is an example response object of the endpoint:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{BASE_URL}/authenticate`：主要的认证端点接受包含电子邮件和密码字段的对象，并返回一个有效的 JWT，该 JWT 将用于调用端点。以下是该端点的示例响应对象：'
- en: '[PRE0]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`{BASE_URL}/register`: The endpoint for creating new valid credentials for
    login. JWT, as stated in [*Chapter 7*](B18159_07.xhtml#_idTextAnchor123), *Adding
    Spring Boot Security with JWT*, is used chiefly on RESTful web services that cannot
    maintain a client state since JWT holds some information connected to the user.
    This will be used primarily in the headers of endpoints that we will request.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{BASE_URL}/register`：创建新有效登录凭证的端点。正如在[*第7章*](B18159_07.xhtml#_idTextAnchor123)中所述，*使用
    JWT 添加 Spring Boot 安全性*，JWT 主要用于无法维护客户端状态的 RESTful 网络服务，因为它包含与用户相关的某些信息。这将在我们请求的端点头部中使用。'
- en: 'In our project, let’s create a service named `AuthenticateService` under the
    `core/services` folder by executing the following command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，让我们在 `core/services` 文件夹下创建一个名为 `AuthenticateService` 的服务，通过执行以下命令：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After successfully creating the service, we will place the following code in
    the service:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功创建服务后，我们将以下代码放置在服务中：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`AuthenticateService` will hold the two endpoints we will use for our login
    page. Now, let’s create the interceptor for our application.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthenticateService` 将持有我们将用于登录页面的两个端点。现在，让我们为我们的应用程序创建拦截器。'
- en: The HTTP interceptor
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP 拦截器
- en: '`intercept()` function, which will enable us to get the outgoing request and
    call the next interceptor or the backend.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`intercept()` 函数，它将使我们能够获取出站请求并调用下一个拦截器或后端。'
- en: 'We will mainly use the interceptor to modify the headers of our endpoint requests,
    which will be responsible for adding the `Authorization: Bearer {JWT}` header
    for each invoked request.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将主要使用拦截器来修改端点请求的头部，这将负责为每个调用的请求添加 `Authorization: Bearer {JWT}` 头部。'
- en: 'To implement the interceptor, we will create the `core/interceptors/header.interceptor.ts`
    file, and we will place the following code within it:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现拦截器，我们将创建`core/interceptors/header.interceptor.ts`文件，并将以下代码放置在其中：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code example, we have added a new implementation for the `intercept()`
    function. The first step is to retrieve the valid JWT in our local storage that
    will be used in the HTTP headers. We will only use the JWT if the request endpoint
    has an `api/v1` substring, as these are the endpoints that are protected.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们已经为`intercept()`函数添加了一个新的实现。第一步是从我们的本地存储中检索有效的JWT，它将被用于HTTP头中。我们只有在请求端点包含`api/v1`子字符串时才会使用JWT，因为这些是受保护的端点。
- en: 'The next step is to clone the request and add the `Authorization: Bearer {JWT}`
    header in the cloned request and call the `next()` function to call the API with
    the added header.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '下一步是克隆请求并添加`Authorization: Bearer {JWT}`头到克隆的请求中，并调用`next()`函数以带有添加的头的API。'
- en: We have now created our interceptor; the last step is to add the interceptor
    in `AppModule`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经创建了我们的拦截器；最后一步是将拦截器添加到`AppModule`中。
- en: 'Let’s have a look at the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code example, we will now intercept every HTTP call on the
    anti-heroes endpoint and will add the generated JWT in the request headers.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们现在将拦截反英雄端点的每个HTTP调用，并将生成的JWT添加到请求头中。
- en: The authentication module
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证模块
- en: The next step is to create an authentication module; this module will be responsible
    for holding the login and registration page that will accept the users and credentials
    and call the authenticate and register endpoints.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建认证模块；这个模块将负责包含登录和注册页面，该页面将接受用户和凭据并调用认证和注册端点。
- en: 'To create the authentication module, we will execute the following command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建认证模块，我们将执行以下命令：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After successfully creating the authentication module, we will import several
    modules we need for our authentication module:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功创建认证模块后，我们将导入我们认证模块所需的几个模块：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, we will create the different parts of our module.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建我们模块的不同部分。
- en: The authentication form
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 认证表单
- en: We will create the main form for our authentication module; this is considered
    the dumb component of our module as it will accept and emit the values of the
    form to the login and registration page.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的认证模块创建主要表单；这被认为是我们的模块中的哑组件，因为它将接受和发射表单的值到登录和注册页面。
- en: 'To create the authentication form component, we will execute the following
    command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建认证表单组件，我们将执行以下命令：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After successfully creating the component, we will now implement the form’s
    code. In the TypeScript file of the `auth-form` component, we will place the following
    code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功创建组件后，我们现在将实现表单的代码。在`auth-form`组件的类型Script文件中，我们将放置以下代码：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code example, we can see that we have created a reactive form
    with an email and password form control. We have also created an emitter that
    will pass the values of the form into the parent component, as this component
    will be used by both the login and the register page. Now, we will implement the
    HTML code and the CSS of the `auth-form` component.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们可以看到我们创建了一个具有电子邮件和密码表单控件的响应式表单。我们还创建了一个发射器，它将表单的值传递给父组件，因为这个组件将被登录和注册页面使用。现在，我们将实现`auth-form`组件的HTML代码和CSS。
- en: Note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please refer to the link provided for the entire code implementation:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅提供的链接以获取完整的代码实现：
- en: '[https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-14/superheroes/src/app/auth/components/auth-form](https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-14/superheroes/src/app/auth/components/auth-form)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-14/superheroes/src/app/auth/components/auth-form](https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-14/superheroes/src/app/auth/components/auth-form)'
- en: In the implemented code, we have bound the reactive form with the email and
    password input. We have also created a condition where the button changes if the
    page is currently on login or register.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现的代码中，我们已经将响应式表单与电子邮件和密码输入绑定。我们还创建了一个条件，按钮会根据页面当前是登录还是注册而改变。
- en: We have successfully created our authentication form; now, we will create our
    login and registration page.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功创建了我们的认证表单；现在，我们将创建登录和注册页面。
- en: The login and registration page
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 登录和注册页面
- en: The login and registration pages are considered to be the smart components of
    our application, as these are the components that will dispatch the action for
    calling the authentication API.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 登录和注册页面被认为是我们的应用程序的智能组件，因为这些是会调度调用认证API的动作的组件。
- en: 'To create the login and register page, we will execute the following command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建登录和注册页面，我们将执行以下命令：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After successfully creating the two pages, we will run the code for the login
    and register components:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功创建两个页面后，我们将运行登录和注册组件的代码：
- en: Login Page
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 登录页面
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Register Page
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注册页面
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code example, we can see that the login page and registration
    pages are using the same authentication form component. Once the form is submitted,
    it will pass the form value into the `login()` or `register()` functions to authenticate
    or create the user, respectively. If the login is successful, we will redirect
    the user to the anti-heroes list page and place the generated token from the API
    in the local storage.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们可以看到登录页面和注册页面正在使用相同的认证表单组件。一旦表单提交，它将表单值传递给`login()`或`register()`函数以进行认证或创建用户。如果登录成功，我们将用户重定向到反英雄列表页面，并将API生成的令牌放置在本地存储中。
- en: The routing module
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由模块
- en: 'The next step is to create the `auth-routing` module that will define the routes
    for the authentication module. To create the module, let’s execute the following
    command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建`auth-routing`模块，该模块将定义认证模块的路由。要创建该模块，让我们执行以下命令：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After creating the routing module, we will run the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建路由模块后，我们将运行以下代码：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We also need to modify our `app-routing` module, as we need our base path to
    redirect to the login page; let’s implement the following modification:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改我们的`app-routing`模块，因为我们需要基本路径重定向到登录页面；让我们实现以下修改：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding implemented code, we can see that once we go to the base path,
    this will now load the `AuthModule` and redirect us to the login page, as shown
    in *Figure 14**.1*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面实现的代码中，我们可以看到，一旦我们访问基本路径，现在将加载`AuthModule`并将我们重定向到登录页面，如图*图14.1*所示。
- en: '![Figure 14.1 – The Login page](img/B18159_14_01.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图14.1 – 登录页面](img/B18159_14_01.jpg)'
- en: Figure 14.1 – The Login page
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 – 登录页面
- en: We should now be able to log in with our user in the database. If no user has
    been created, we can create a new one using the registration page, and once the
    login is successful, we will be redirected to the anti-hero list page, as shown
    in *Figure 14**.2*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该能够使用数据库中的用户登录。如果没有创建用户，我们可以通过注册页面创建一个新的用户，一旦登录成功，我们将被重定向到反英雄列表页面，如图*图14.2*所示。
- en: '![Figure 14.2 – The anti-hero list page](img/B18159_14_02.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图14.2 – 反英雄列表页面](img/B18159_14_02.jpg)'
- en: Figure 14.2 – The anti-hero list page
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 – 反英雄列表页面
- en: 'We can also observe that our valid JWT is already placed in our local storage
    as the HTTP interceptor is using the JWT. As we open a request made by our application,
    we can see that the headers have the generated JWT:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以观察到我们的有效JWT已经放置在我们的本地存储中，因为HTTP拦截器正在使用JWT。当我们打开应用程序发出的请求时，我们可以看到头中有生成的JWT：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding example headers, we can see that the `Authorization` header
    contains the valid JWT for every API request the application calls. The placement
    of the JWT in the header is done when our login is successful and we are redirected
    to the `AntiHeromodule`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例头中，我们可以看到`Authorization`头包含应用程序对每个API请求的有效JWT。JWT在头中的放置是在我们登录成功并被重定向到`AntiHeromodule`时完成的。
- en: Token validation
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 令牌验证
- en: 'The next step we need to do is to add token validation to check whether our
    token already expired. To implement this feature, we add the `@auth0/angular-jwt`
    library by executing the following command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步我们需要做的是添加令牌验证来检查我们的令牌是否已经过期。为了实现这个功能，我们通过执行以下命令添加`@auth0/angular-jwt`库：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `@auth0/angular-jwt` library provides useful functions, such as `isTokenExpired()`,
    which checks whether the JWT is expired, and `decodeToken()`, which retrieves
    the information from the JWT.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`@auth0/angular-jwt`库提供了有用的函数，例如`isTokenExpired()`，它检查JWT是否已过期，以及`decodeToken()`，它从JWT中检索信息。'
- en: 'After successfully installing the library, we will add the following code to
    our authenticate service:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功安装库后，我们将以下代码添加到我们的认证服务中：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We also need to import the JWT module into our `app.module.ts` file:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将JWT模块导入到我们的`app.module.ts`文件中：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We will use the `isAuthenticated()` function on our login and register pages
    to check whether a JWT is present in our local storage. If there is a valid JWT,
    we will redirect the application to the anti-hero list page.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在登录和注册页面上使用`isAuthenticated()`函数来检查我们的本地存储中是否存在JWT。如果存在有效的JWT，我们将重定向应用程序到反英雄列表页面。
- en: 'Let’s have a look at the following implementation:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下实现：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Logout implementation
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注销实现
- en: 'The last feature we need to implement is the logout function. To add this feature,
    the only function we need to add is a function that will remove the token from
    our storage. Let’s have the code implementation as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的最后一个功能是注销功能。为了添加此功能，我们只需要添加一个将令牌从我们的存储中删除的函数。让我们看看以下代码实现：
- en: authenticate.service.ts
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: authenticate.service.ts
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding code example, we have added a `doLogout()` function that removes
    the token in the storage and redirects the application to the login page. Now,
    let’s edit our `navbar` component to have a logout button:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们添加了一个`doLogout()`函数，该函数从存储中删除令牌并将应用程序重定向到登录页面。现在，让我们编辑我们的`navbar`组件以添加注销按钮：
- en: navbar.component.html
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: navbar.component.html
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: navbar.component.css
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: navbar.component.css
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: navbar.component.ts
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: navbar.component.ts
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code implementation, we created an emitter for our navbar component.
    This will emit the action we have triggered in our navbar, and it will be passed
    into our app component.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码实现中，我们为我们的导航栏组件创建了一个发射器。这将发射我们在导航栏中触发的操作，并将其传递到我们的应用程序组件中。
- en: 'The last step is to call the `doLogout()` function in our app component when
    the logout button is clicked. Let’s have a look at the code implementation, as
    follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是在注销按钮被点击时在我们的应用程序组件中调用`doLogout()`函数。让我们看看以下代码实现：
- en: app.component.html
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: app.component.html
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: app.component.ts
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: app.component.ts
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding code implementation, we injected the authenticate service into
    our app component and called the `doLogout()` function. If the action is `logout`,
    we have also added a listener to the router change to check if our route is currently
    on login or register, and if it is, we will remove the logout button on the navbar
    component.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码实现中，我们将认证服务注入到我们的应用程序组件中，并调用了`doLogout()`函数。如果操作是`logout`，我们还在路由更改上添加了一个监听器来检查我们的路由是否当前在登录或注册页面上，如果是，我们将从导航栏组件中移除注销按钮。
- en: We have successfully implemented user authentication with our application, but
    we will still improve this implementation as we go on through this chapter. In
    the next section, we will discuss how to protect routes in our Angular application.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功实现了应用程序的用户认证，但随着我们继续本章的学习，我们还将改进此实现。在下一节中，我们将讨论如何在Angular应用程序中保护路由。
- en: Protecting routes
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护路由
- en: One of the essential features of Angular is router guards. Guards are helpful
    if we want to protect our routes from being accessed directly without authentication
    or prevent the user from losing changes when navigating accidentally from the
    route.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的一个基本特性是路由守卫。如果我们要保护我们的路由免受未经认证的直接访问，或者防止用户在意外导航时丢失更改，守卫非常有用。
- en: Guards are interfaces provided by Angular that allow us to control the accessibility
    of a route with a provided condition. These are applied directly to the routes
    we want to protect.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 守卫是Angular提供的接口，允许我们通过提供的条件来控制路由的可访问性。这些直接应用于我们想要保护的路由。
- en: 'Let’s have a look at some of the guards provided by Angular:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Angular提供的一些守卫：
- en: '`CanActivate`: This is implemented on a route we want to prevent access to.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CanActivate`：这是在我们要阻止访问的路由上实现的。'
- en: '**Method signature**:'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法签名**：'
- en: '[PRE29]'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding code defines the signature of the `CanActivate` guard. The function
    accepts the `ActivatedRouteSnapshot` and `RouterStateSnapshot` parameters and
    returns an `Observable` or `Promise` that can be of type `Boolean` or `UrlTree`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码定义了`CanActivate`守卫的签名。该函数接受`ActivatedRouteSnapshot`和`RouterStateSnapshot`参数，并返回一个`Observable`或`Promise`，可以是`Boolean`或`UrlTree`类型。
- en: '**Creating** **the guard**:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建** **守卫**：'
- en: '[PRE30]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding code example, we have created a new class named `AuthGuard`;
    we have also implemented it with the `CanActivate` guard and added the `canActivate()`
    function for the required logic.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们创建了一个名为`AuthGuard`的新类；我们还使用`CanActivate`守卫实现了它，并为所需的逻辑添加了`canActivate()`函数。
- en: '**Using** **the guard**:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用** **守卫**：'
- en: '[PRE38]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding code example, we have used the newly created `AuthGuard` class
    in our hero route to protect it from users without a valid JWT.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码示例中，我们使用新创建的`AuthGuard`类在我们的英雄路由中保护它，防止没有有效JWT的用户访问。
- en: '`CanActivateChild`: This is similar to `CanActivateGuard`, but this guard is
    applied to prevent access to child routes. Once this is added to the parent route,
    the guard will protect all child routes.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CanActivateChild`：这与`CanActivateGuard`类似，但这个守卫用于防止访问子路由。一旦将其添加到父路由，守卫将保护所有子路由。'
- en: '**Method signature**:'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法签名**:'
- en: '[PRE43]'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The preceding code example defines the signature of the `CanActivateChild` guard.
    The function accepts the `ActivatedRouteSnapshot` and `RouterStateSnapshot` parameters
    and returns an `Observable` or `Promise` that can be of type `Boolean` or `UrlTree`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码示例定义了`CanActivateChild`守卫的签名。该函数接受`ActivatedRouteSnapshot`和`RouterStateSnapshot`参数，并返回一个可以是`Boolean`或`UrlTree`类型的`Observable`或`Promise`。
- en: '**Creating** **the guard**:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建** **守卫**:'
- en: '[PRE44]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the preceding code example, we have created a new class named `AuthGuard`.
    We have also implemented it with the `CanActivateChild` guard and added the `canActivateChild()`
    function for the required logic.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码示例中，我们创建了一个名为`AuthGuard`的新类。我们还使用`CanActivateChild`守卫实现了它，并添加了`canActivateChild()`函数以实现所需的逻辑。
- en: '**Using** **the guard**:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用** **守卫**:'
- en: '[PRE50]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the preceding code example, we have used the newly created `AuthGuard` class
    in our user path to protect its child routes that navigate to the `ProfileComponent`
    and `SettingsComponent` components from users without a valid JWT.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码示例中，我们使用新创建的`AuthGuard`类在我们的用户路径中保护其子路由，这些子路由导航到`ProfileComponent`和`SettingsComponent`组件，防止没有有效JWT的用户访问。
- en: '`CanLoad`: This guard is used for lazy-loaded modules. The `CanActivate` guard
    can only prevent users from navigating through a route; the `CanLoad` guard prevents
    both navigating to and downloading the lazy-loaded module.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CanLoad`：这个守卫用于懒加载模块。`CanActivate`守卫只能防止用户通过路由导航；而`CanLoad`守卫则防止导航到和下载懒加载的模块。'
- en: '**Method signature**:'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法签名**:'
- en: '[PRE58]'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The preceding code example defines the signature of the `CanLoad` guard. The
    function accepts the `Route` and `UrlSegment[]` parameters and returns an `Observable`
    or `Promise` that can be of type `Boolean`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码示例定义了`CanLoad`守卫的签名。该函数接受`Route`和`UrlSegment[]`参数，并返回一个可以是`Boolean`类型的`Observable`或`Promise`。
- en: '**Creating** **the guard**:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建** **守卫**:'
- en: '[PRE59]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In the preceding code example, we have created a new class named `AuthGuard`.
    We have also implemented it with the `CanLoad` guard and added the `canLoad()`
    function for the required logic.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码示例中，我们创建了一个名为`AuthGuard`的新类。我们还使用`CanLoad`守卫实现了它，并添加了`canLoad()`函数以实现所需的逻辑。
- en: '**Using** **the guard**:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用** **守卫**:'
- en: '[PRE66]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In the preceding code example, we have used the newly created `AuthGuard` class
    in our hero route to protect it from users accessing and downloading the resources
    without a valid JWT.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码示例中，我们使用新创建的`AuthGuard`类在我们的英雄路由中保护它，防止用户在没有有效JWT的情况下访问和下载资源。
- en: '`CanDeactivate`: This is a guard used to prevent the user from navigating away
    from the current route. This is useful in scenarios such as filling out forms
    in the application, to avoid losing some changes on navigating out accidentally.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CanDeactivate`：这是一个用于防止用户离开当前路由的守卫。这在应用中填写表单等场景中非常有用，可以避免在意外导航时丢失一些更改。'
- en: '**Method signature**:'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法签名**:'
- en: '[PRE73]'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The preceding code example defines the signature of the `CanDeactivate` guard.
    The function accepts a generic component, the `ActivatedRouteSnapshot` and `RouterStateSnapshot`
    parameters, and returns an `Observable` or `Promise` that can be of type `Boolean`
    or `UrlTree`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码示例定义了`CanDeactivate`守卫的签名。该函数接受一个泛型组件，以及`ActivatedRouteSnapshot`和`RouterStateSnapshot`参数，并返回一个可以是`Boolean`或`UrlTree`类型的`Observable`或`Promise`。
- en: '**Creating** **the guard**:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建** **守卫**:'
- en: '[PRE74]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'In the preceding implementation, we have created an interface that will be
    used in the component of the `CanDeactivateGuard` service:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述实现中，我们创建了一个接口，该接口将在`CanDeactivateGuard`服务的组件中使用：
- en: '[PRE85]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: In the preceding code example, we have implemented the interface we have created
    for the component.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码示例中，我们实现了为组件创建的接口。
- en: '**Using** **the guard**:'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用** **守卫**:'
- en: '[PRE86]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: In the preceding code example, we have used the newly created `CanDeactivateGuard`
    to prevent the user from navigating out of the `FormComponent` based on the applied
    condition on the `canDeactivate()` function.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们使用了新创建的`CanDeactivateGuard`来防止用户根据`canDeactivate()`函数上应用的条件从`FormComponent`导航出去。
- en: We have learned about the different guards we can use in our application. Now,
    let’s implement this in our Angular project.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了我们可以在应用程序中使用的不同守卫。现在，让我们在我们的Angular项目中实现它。
- en: Project implementation
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目实施
- en: 'The first guard we need to apply in our application is the `CanLoad` guard.
    This is necessary as we want to protect our anti-heroes routes from being accessed
    if there is no valid JWT. To create the `CanLoad` guard, execute the following
    command:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中需要应用的第一道防线是`CanLoad`守卫。这是必要的，因为我们希望在没有有效的JWT的情况下保护我们的反英雄路由不被访问。要创建`CanLoad`守卫，执行以下命令：
- en: '[PRE87]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: After executing the command, select the `CanLoad` option to generate a new `AuthGuard`
    class. The only thing we need to change here is the implementation of the `canLoad()`
    function. The condition we want to apply is to allow the route and modules to
    be loaded if the JWT is valid.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 执行命令后，选择`CanLoad`选项以生成新的`AuthGuard`类。这里我们需要更改的唯一事情是`canLoad()`函数的实现。我们想要应用的条件是如果JWT有效，则允许加载路由和模块。
- en: 'Let’s have a look at the following implementation:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下实现：
- en: '[PRE88]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: In the preceding code example, we have used the `isAuthenticated()` function
    to check that the JWT is valid and not expired. If it is valid, this will return
    `true` and allow us to navigate the route. Otherwise, it will redirect us to the
    login page.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们使用了`isAuthenticated()`函数来检查JWT是否有效且未过期。如果它是有效的，这将返回`true`并允许我们导航路由。否则，它将重定向我们到登录页面。
- en: 'The last step is to apply the `AuthGuard` class in the anti-heroes route; in
    the `app-routing.module.ts` file, we will use the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是在反英雄路由中应用`AuthGuard`类；在`app-routing.module.ts`文件中，我们将使用以下代码：
- en: '[PRE89]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: We have now successfully applied the `CanLoad` guard in our anti-heroes route.
    To test whether this works, we can try deleting the token in our local storage,
    and this should redirect us to the login page having no valid JWT.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经在我们的反英雄路由中成功应用了`CanLoad`守卫。为了测试它是否工作，我们可以尝试删除本地存储中的令牌，这将导致我们重定向到没有有效JWT的登录页面。
- en: 'The last route guard we need is the `CanDeactivate` guard; we will apply this
    guard on our anti-hero form to prevent the user from losing changes when navigating
    away from the form. To create our `CanDeactivate` guard, we will execute the following
    command:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的最后一个路由守卫是`CanDeactivate`守卫；我们将在这个反英雄表单上应用这个守卫，以防止用户在离开表单时丢失更改。要创建我们的`CanDeactivate`守卫，我们将执行以下命令：
- en: '[PRE90]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: After executing the command, select the `CanDeactivate` option, and this will
    generate a new `FormGuard` class. We will add an interface to this class that
    we will use in our `form` component.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 执行命令后，选择`CanDeactivate`选项，这将生成新的`FormGuard`类。我们将向此类添加一个接口，我们将在`form`组件中使用它。
- en: 'Let’s have a look at the following code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码：
- en: '[PRE91]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'In the preceding code example, we have created the `CanComponentDeactivate`
    interface that the form component will implement. This means that the condition
    will be placed in the component instead of the guard. In `FormComponent`, we will
    add the following code:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们创建了`CanComponentDeactivate`接口，该接口将由表单组件实现。这意味着条件将被放置在组件中而不是守卫中。在`FormComponent`中，我们将添加以下代码：
- en: '[PRE92]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: In the preceding code example, we have implemented the `FormComponent` with
    the `CanComponentDeactivate` interface that we have created; we have added a `window.
    confirm()`, which will pop up a dialog box that will ask if the user wants to
    leave the current route. This is a simple implementation of the guard, as we can
    also add other conditions, such as if we only want to ask this question if there
    are changes in the form.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们实现了`FormComponent`，并添加了我们创建的`CanComponentDeactivate`接口；我们添加了一个`window.confirm()`，这将弹出一个对话框，询问用户是否想要离开当前路由。这是一个简单的守卫实现，因为我们还可以添加其他条件，例如，如果我们只想在表单有更改时提出这个问题。
- en: The last step is to apply the guard in the `FormComponent` route.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是在`FormComponent`路由中应用守卫。
- en: 'Let’s have a look at the following code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码：
- en: '[PRE93]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Once we have applied the `CanDeactivate` guard, navigating out from the anti-hero
    form will pop up a dialog box for the user, as shown in *Figure 14**.3*.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们应用了`CanDeactivate`守卫，从反英雄表单导航出去将弹出一个对话框，如图*14**.3*所示。
- en: '![](img/B18159_14_03.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18159_14_03.jpg)'
- en: 14.3 – Dialog box on navigating away from the form
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 14.3 – 在离开表单时显示对话框
- en: We have now successfully applied guards in our Angular application; in the next
    section, we will directly improve our calling of API authentication with the use
    of NgRx state management.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经在我们的Angular应用程序中成功应用了守卫；在下一节中，我们将使用NgRx状态管理直接改进我们的API认证调用。
- en: Calling an API
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用API
- en: We have already created user authentication in the previous section by calling
    the authentication service directly in our component. We have also stored the
    generated JWT in our local storage using the `setItem` function, which is also
    happening in our login component.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的一节中，我们已经通过在组件中直接调用认证服务来创建了用户认证。我们还使用`setItem`函数将生成的JWT存储在我们的本地存储中，这也在我们的登录组件中发生。
- en: What we want to achieve is to reduce the responsibility of our components, and
    as we remember, we are using NgRx state management to call the APIs, and the only
    responsibility of our components is to dispatch the action, and NgRx will do the
    rest.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要实现的是减少我们组件的责任，并且正如我们记得的，我们正在使用NgRx状态管理来调用API，我们组件的唯一责任是派发动作，而NgRx将完成剩余的工作。
- en: In this section, we will improve our API calls by using the building blocks
    of the NgRx state management.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过使用NgRx状态管理的构建块来改进我们的API调用。
- en: Creating the actions
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建actions
- en: 'The first step we need is to create the actions for our authentication feature.
    We will create a file named `auth.actions.ts` in the `auth/state` folder, and
    we will have the following code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要创建我们认证功能的actions。我们将在`auth/state`文件夹中创建一个名为`auth.actions.ts`的文件，并将有以下的代码：
- en: '[PRE94]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'In the preceding code, we can see that we have created four action types: the
    `LOGIN` type will be used for the effect responsible for calling the login API;
    the `CREATE_USER` type will be used for the effect accountable for calling the
    register API; the `SET_TOKEN` type will be used by a reducer that will set the
    generated JWT in the store after the login API has been reached; and lastly, the
    `AUTH_ERROR` type will be used to set errors in the store if the login or register
    API has returned an error.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们创建了四种动作类型：`LOGIN`类型将被用于调用登录API的效果；`CREATE_USER`类型将被用于调用注册API的效果；`SET_TOKEN`类型将被用于在登录API调用后，将生成的JWT设置到store中的reducer；最后，`AUTH_ERROR`类型将被用于在登录或注册API返回错误时在store中设置错误。
- en: Creating the effects
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建effects
- en: 'After creating our actions, now, we will create the effects for calling the
    login and register API. We will create a file named `auth.effects.ts` in the `auth/state`
    folder, and we will have the following implementation:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我们的actions之后，现在我们将创建用于调用登录和注册API的效果。我们将在`auth/state`文件夹中创建一个名为`auth.effects.ts`的文件，并将有以下的实现：
- en: Login Effect
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 登录Effect
- en: '[PRE95]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Register Effect
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 注册Effect
- en: '[PRE96]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: In the preceding code, we have created effects for the login and register API.
    In the `loginUser$` effect, once the login API is successful, it will dispatch
    the `SET_TOKEN` action and pass the generated JWT, and this will also redirect
    us to the anti-heroes page.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们已经为登录和注册API创建了效果。在`loginUser$`效果中，一旦登录API调用成功，它将派发`SET_TOKEN`动作并传递生成的JWT，这也会将我们重定向到反英雄页面。
- en: This is the same behavior we implemented in the previous section. On the other
    hand, the `createUser$` effect, once the register API is successful, will redirect
    us to the login page again. This is a simple behavior, and you can customize what
    will happen next if the registration is successful.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前章节中实现的行为。另一方面，一旦注册API调用成功，`createUser$`效果将再次将我们重定向到登录页面。这是一个简单的行为，如果你希望注册成功后发生其他操作，你可以自定义。
- en: We have also implemented the `AUTH_ERROR` action, which will be called when
    the login or register API fails.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还实现了`AUTH_ERROR`动作，当登录或注册API失败时将被调用。
- en: Creating the reducers
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建reducers
- en: 'The next step we need is to create the reducers. We will create a file named
    `auth.reducers.ts` in the `auth/state` folder, and we will have the following
    implementation:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步需要做的是创建reducers。我们将在`auth/state`文件夹中创建一个名为`auth.reducers.ts`的文件，并将有以下的实现：
- en: '[PRE97]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: In the preceding code example, we can see that `AuthState` has two fields, which
    are `token` and `error`. The `token` field will contain the valid JWT once the
    `setToken` action is called when the authentication API is successful, and the
    `error` field will contain the generated error if the login or register API fails.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们可以看到`AuthState`有两个字段，分别是`token`和`error`。`token`字段将在认证API成功调用`setToken`动作后包含有效的JWT，而`error`字段将包含登录或注册API失败时生成的错误。
- en: Creating the selectors
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建selectors
- en: 'After creating the reducers, we will now create our selector. In this case,
    our selector will be simple as we only need a selector for the `error` field.
    We will create a file named `auth.selectors.ts` in the `auth/state` folder, and
    we will have the following implementation:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建reducer之后，我们现在将创建我们的selector。在这种情况下，我们的selector将非常简单，因为我们只需要一个用于`error`字段的selector。我们将在`auth/state`文件夹中创建一个名为`auth.selectors.ts`的文件，并且我们将有以下的实现：
- en: '[PRE98]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: In the preceding code example, we have created a selector for our `error` field;
    we will need this selector to display the error message in our component for the
    user.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们为我们的`error`字段创建了一个selector；我们需要这个selector来在我们的组件中向用户显示错误信息。
- en: Syncing in local storage
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在本地存储中同步
- en: The next feature we will implement is the syncing of our state in local storage.
    We can achieve this by using `localStorage.setItem()` in our application. However,
    using this will not be maintainable, and the setting of values in the storage
    will be in different places.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的下个功能是我们状态在本地存储中的同步。我们可以通过在我们的应用程序中使用`localStorage.setItem()`来实现这一点。然而，使用这种方法将不会是可维护的，并且存储中的值设置将位于不同的位置。
- en: 'To have a better implementation, we will use the `ngrx-store-localstorage`
    library. To install the library, we will execute the following command:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有更好的实现，我们将使用`ngrx-store-localstorage`库。为了安装库，我们将执行以下命令：
- en: '[PRE99]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'After successfully installing the library, we should determine the states we
    want to sync with our local storage. In our case, we want the `token` field in
    our `auth` state to be synced. To achieve this, we make the following code changes
    in `auth.module.ts`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功安装库之后，我们应该确定我们想要与本地存储同步的状态。在我们的例子中，我们希望`auth`状态中的`token`字段能够同步。为了实现这一点，我们在`auth.module.ts`文件中进行了以下代码更改：
- en: '[PRE100]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: In the preceding code, we can see that we have created a dedicated reducer that
    calls the `localStorageSync` from the `ngrx-store-localstorage`, which is responsible
    for adding values in the local storage.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们创建了一个专门的reducer，它从`ngrx-store-localstorage`中调用`localStorageSync`，负责在本地存储中添加值。
- en: We can also specify what fields we want to sync and, in this case, we have added
    the token in the keys array. Once the token state changes its value, the new value
    will also be placed in our storage.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以指定我们想要同步的字段，在这种情况下，我们在键数组中添加了token。一旦token状态值发生变化，新的值也将被放置在我们的存储中。
- en: Dispatching and selecting a component
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分发和选择组件
- en: 'The last step is to dispatch the actions and use the selector for our login
    and register a component. Let’s have a look at the following code implementation
    for the login and register a component:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是分发动作并使用selector来处理登录和注册组件。让我们看看以下代码实现中的登录和注册组件：
- en: login.component.ts
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: login.component.ts
- en: '[PRE101]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: register.component.ts
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: register.component.ts
- en: '[PRE102]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: We can see in the preceding code the login and register pages have almost the
    same implementation. We have already removed the call for the login and register
    service in the `submit` function and replaced it with the dispatching of an action.
    We have also used the `selectError()` selector to listen to see if the APIs have
    produced errors.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前面的代码中看到，登录和注册页面几乎有相同的实现。我们已经在`submit`函数中移除了对登录和注册服务的调用，并用分发动作来替换。我们还使用了`selectError()`selector来监听API是否产生了错误。
- en: Summary
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: With this, we have reached the end of this chapter; let’s have a recap of the
    valuable things you have learned.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经到达了本章的结尾；让我们回顾一下你学到的宝贵知识。
- en: We now know how to implement user authentication in the Angular application,
    and we have used an HTTP interceptor to intercept HTTP requests to transform its
    headers and add the valid JWT for the API calls. We have also learned about the
    different route guards that allow us to protect routes from unauthorized access
    or prevent accidental loss of data when navigating out from the route. Lastly,
    we have learned how to use NgRx state management by improving how to implement
    authentication in Angular.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道了如何在 Angular 应用中实现用户认证，我们使用了一个 HTTP 拦截器来拦截 HTTP 请求，以转换其头部并添加有效的 JWT 以进行
    API 调用。我们还了解到了不同的路由守卫，它们允许我们保护路由免受未经授权的访问或防止在离开路由时意外丢失数据。最后，我们学习了如何通过改进 Angular
    中认证的实现方式来使用 NgRx 状态管理。
- en: The next chapter will teach us how to write end-to-end testing in Angular using
    the Cypress framework.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将教会我们如何使用 Cypress 框架在 Angular 中编写端到端测试。
