- en: Chapter 5. Efficient Searching – Binary Search and Sorting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 高效搜索 – 二分搜索和排序
- en: What is searching? Searching is trying to locate a given value in a collection
    of values. For example, you are given an array of integers, and your problem is
    to check whether the integer *5* is in that array. This is a search problem. In
    addition to just deciding whether the element *5* is in the array, we may be interested
    in its location as well when it is found. This is also a search problem.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是搜索？搜索是在一组值中定位给定值的过程。例如，你被给了一个整数数组，你的问题是检查整数 *5* 是否在该数组中。这是一个搜索问题。除了决定整数 *5*
    是否在数组中之外，我们还可能对其位置感兴趣，当找到它时。这也是一个搜索问题。
- en: 'Another interesting take on it would be to imagine a dictionary, that is, an
    array of values and associated values. For example, you have an array of names
    of students and their marks, as shown in the following table:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对此的一个有趣的看法是想象一个字典，即值和关联值的数组。例如，你有一个包含学生名字和分数的数组，如下表所示：
- en: '| Name | Marks |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| 姓名 | 分数 |'
- en: '| --- | --- |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Tom | 63 |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| 汤姆 | 63 |'
- en: '| Harry | 70 |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| 哈里 | 70 |'
- en: '| Merry | 65 |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| 梅里 | 65 |'
- en: '| Aisha | 85 |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| 阿伊莎 | 85 |'
- en: '| Abdullah | 72 |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| 阿卜杜拉 | 72 |'
- en: '| … | ... |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| … | ... |'
- en: The list continues. Suppose, our system lets the student view his/her own marks.
    They would type their name and the system would show their marks. For simplicity,
    let's assume that there are no duplicate names. Now, we have to search for the
    name provided and return the corresponding values. This is, thus, another search
    problem. As we will see, search problems are quite ubiquitous in programming.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 列表继续。假设，我们的系统允许学生查看自己的分数。他们会输入他们的名字，系统会显示他们的分数。为了简单起见，让我们假设没有重复的名字。现在，我们必须搜索提供的名字并返回相应的值。因此，这又是一个搜索问题。正如我们将看到的，搜索问题在编程中相当普遍。
- en: 'In this chapter, you will learn the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Search algorithms
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索算法
- en: Efficient searching in a sorted list
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在有序列表中进行高效搜索
- en: Some sorting algorithms
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些排序算法
- en: Search algorithms
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索算法
- en: 'Suppose you are given an array of values and you are required to check whether
    a particular value is in that array, what is the most natural way to find that
    element? Well, it seems that the natural way is to go through each element one
    by one and check whether they match the given value. If any one does, we have
    found that element and we can return the index; if not, we can return `-1` at
    the end of processing all the elements to report that such an element could not
    be found. This is what we would call a **linear search**. The following demonstrates
    a linear search algorithm in an array:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你被给了一个值数组，你需要检查特定的值是否在该数组中，最自然的方法是逐个检查每个元素是否与给定的值匹配。如果任何一个匹配，我们就找到了那个元素，我们可以返回索引；如果没有，我们可以在处理完所有元素后返回特殊值
    `-1` 来报告找不到这样的元素。这就是我们所说的**线性搜索**。以下演示了在数组中的线性搜索算法：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The function `linearSearch` takes an array of values and a value to search
    in it, and returns the index if the value is found. If not, it returns a special
    value, `-1`. The program simply goes through each element and checks whether the
    current element matches with the value to lookup; if it does, then it just returns
    the current index, otherwise it keeps looking. At the end of the array, it returns
    the special value, `-1`. Now the following piece of code should return `-1` in
    the first case and the value `5` in the second case:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `linearSearch` 接收一个值数组和要搜索的值，如果找到该值则返回索引。如果没有找到，它返回一个特殊值 `-1`。程序简单地遍历每个元素并检查当前元素是否与要查找的值匹配；如果匹配，则返回当前索引，否则继续查找。数组的末尾返回特殊值
    `-1`。现在以下代码块应该在第一种情况下返回 `-1`，在第二种情况下返回值 `5`：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, if we want to solve the student-marks problem described in the introduction
    of this chapter, we just need to have the marks of the students stored in a different
    array in the same order, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想解决本章引言中描述的学生分数问题，我们只需要将学生的分数存储在同一个顺序的不同数组中，如下所示：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now we can write a function to search for a name:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写一个函数来搜索一个名字：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'First, we look for the name of the students in the list of students. If the
    name is found, the corresponding index would be assigned to the variable index
    and the value would be greater than or equal to zero. In such a case, we return
    the marks stored in the same index as of the marks array. If it is not found,
    we return null. To lookup the marks for Merry, for example, we call as shown here:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在学生名单中查找学生的名字。如果找到名字，相应的索引将被分配给变量index，并且值将大于或等于零。在这种情况下，我们返回与分数数组相同索引存储的值。如果没有找到，我们返回null。例如，要查找Merry的分数，我们可以像下面这样调用：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We correctly obtain her marks, that are, `65`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正确地获得了她的分数，即`65`。
- en: What is the complexity of linear search? We have a `for` loop that moves through
    each element of an array of length *n* (say); in the worst case, we would go through
    all the elements, so the worst case complexity is *θ(n)*. Even on an average,
    we would be visiting half the elements before we hit the correct element, so the
    average case complexity is *θ(n/2) = θ(n)*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 线性搜索的复杂度是多少？我们有一个`for`循环，它遍历长度为*n*（比如说）的数组中的每个元素；在最坏的情况下，我们会遍历所有元素，所以最坏情况复杂度是*θ(n)*。即使在平均情况下，我们也会在找到正确元素之前访问一半的元素，所以平均情况复杂度是*θ(n/2)
    = θ(n)*。
- en: Binary search
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二分查找
- en: Is a linear search the best we can do? Well, it turns out that if we are looking
    at an arbitrary array, this is what we have to do. After all, in an arbitrary
    array, there is no way to know whether an element is there without potentially
    looking at all of them. More specifically, we cannot say for sure that some element
    does not exist, without verifying all the elements. The reason is that the value
    of one element does not say anything about the values of the other elements.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 线性搜索就是我们能做的最好的吗？好吧，结果证明，如果我们正在查看一个任意数组，这就是我们必须做的事情。毕竟，在一个任意数组中，没有方法可以知道一个元素是否存在，而不可能查看所有元素。更具体地说，我们无法确定某个元素不存在，除非验证所有元素。原因是单个元素的价值对其他元素的价值没有任何说明。
- en: 'But, what information can one element have about other elements in an array?
    One way to make elements have information about the other elements is to have
    a sorted array instead of just an arbitrary array. What is a sorted array? A sorted
    array is an array that has all the elements arranged in order of their values.
    When an array is sorted, every element contains the information that everything
    on the left is smaller than that particular element, and everything on the right
    is bigger (or the other way round if the order of the elements is opposite, but
    we will consider the arrays that are sorted in an increasing order from left to
    right). This information can, amazingly, make this search a lot faster. Here is
    what we do:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，一个元素能有多少信息可以告诉我们数组中的其他元素？让元素具有关于其他元素信息的一种方法是将数组排序，而不是仅仅是一个任意数组。什么是排序数组？排序数组是一个将所有元素按其值排序的数组。当一个数组被排序时，每个元素都包含有关左侧一切小于该特定元素的信息，以及右侧一切更大的信息（或者如果元素的顺序相反，但我们将考虑从左到右递增排序的数组）。这种信息惊人地使这个搜索变得更快。以下是我们要做的事情：
- en: Check the middle element of the array. If it matches the element we are searching
    for, we are done.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查数组的中间元素。如果它与我们要查找的元素匹配，我们就完成了。
- en: If the middle element is smaller than the value we are searching for, search
    on the subarray on the right of the current array. This is because everything
    on the left is even smaller.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果中间元素小于我们要查找的值，则在当前数组的右侧子数组中进行搜索。这是因为左侧的一切都更小。
- en: If the middle element is bigger than the value we are searching for, search
    only in the left sub-array.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果中间元素大于我们要查找的值，则只搜索左侧子数组。
- en: 'To avoid creating copies of the array while creating a sub-array, we just pass
    on the whole array, but we remember the start and end positions we are looking
    at. The start is included in the range and end is excluded. So, only elements
    on the right of the start position and the left of the end position are included
    in the subarray being searched. The following figure gives a visual understanding
    of binary search:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在创建子数组时创建数组的副本，我们只需传递整个数组，但我们要记住我们正在查看的起始和结束位置。起始位置包含在范围内，结束位置不包含。因此，只有位于起始位置右侧和结束位置左侧的元素包含在正在搜索的子数组中。以下图示给出了二分查找的直观理解：
- en: '![Binary search](img/00027.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![二分查找](img/00027.jpeg)'
- en: 'Figure 1: Binary Search.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：二分查找。
- en: An arrow representing moving one element to another during the search.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一个表示在搜索过程中将一个元素移动到另一个位置的箭头。
- en: 'But, before implementing this algorithm, we need to understand the concept
    of `Comparable`. `Comparable` is an interface in the Java standard library that
    looks like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在实现这个算法之前，我们需要理解 `Comparable` 的概念。`Comparable` 是 Java 标准库中的一个接口，其形式如下：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Any class implementing this interface has to compare a different object with
    itself. It is required that the type parameter, *T*, must be instantiated with
    the same class that implements it, like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此接口的任何类都必须与自己比较不同的对象。必须要求类型参数 *T* 使用实现它的相同类实例化，如下所示：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `compareTo` method intends to compare an object of the same type. If the
    current object (the one that the `this` reference refers to) is smaller than the
    object passed, `compareTo` must return a negative value. If the object passed
    is smaller, the method must return a positive value. Otherwise, if they are equal,
    it must return `0`. The following conditions are required to be fulfilled by the
    `compareTo` method:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`compareTo` 方法旨在比较相同类型的对象。如果当前对象（`this` 引用指向的对象）小于传入的对象，`compareTo` 必须返回一个负值。如果传入的对象较小，该方法必须返回一个正值。否则，如果它们相等，它必须返回
    `0`。`compareTo` 方法必须满足以下条件：'
- en: If `a.compareTo(b) == 0`, then `a.equals(b)` must be `true`
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `a.compareTo(b) == 0`，那么 `a.equals(b)` 必须为 `true`
- en: If `a.compareTo(b) < 0` and b`.compareTo(c) < 0`, then `a.compareTo(c) <0`
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `a.compareTo(b) < 0` 且 `b.compareTo(c) < 0`，那么 `a.compareTo(c) <0`
- en: If `a.compareTo(b) <0`, then `b.compareTo(a) > 0`
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `a.compareTo(b) <0`，那么 `b.compareTo(a) > 0`
- en: If `b.equals(c)` is true and `a.compareTo(b) <0`, then `a.compareTo(c) <0`
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `b.equals(c)` 为真且 `a.compareTo(b) <0`，那么 `a.compareTo(c) <0`
- en: If `b.equals(c)` is true and `a.compareTo(b) >0`, then `a.compareTo(c) >0`
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `b.equals(c)` 为真且 `a.compareTo(b) >0`，那么 `a.compareTo(c) >0`
- en: Basically, the conditions are the same for a total order where equality is represented
    by the equals method. It basically generalizes the concept of the `<` and `<=`
    operators, which are there for numbers. Of course, the `compareTo` method for
    the `Wrapper` objects are implemented exactly as the `<` and `<=` operators are
    on the primitives inside them.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，对于表示相等性的等价关系，条件是相同的。它基本上概括了 `<` 和 `<=` 操作符的概念，这些操作符用于数字。当然，`Wrapper` 对象的
    `compareTo` 方法实现与它们内部的原始类型上的 `<` 和 `<=` 操作符完全相同。
- en: 'Now, we write the search function to do the search, as per the preceding steps:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们按照前面的步骤编写搜索函数来执行搜索：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that in this case, we have mandated that the objects in the array must
    be comparable so that we can know if an object is greater than or less than another
    object. It does not matter exactly how this relationship is determined; the array
    must be sorted using the same comparison – that the comparison between two consecutive
    elements will make sure the element on the left is smaller than the one on the
    right, as provided by `Comparable`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，我们规定数组中的对象必须是可比较的，这样我们才能知道一个对象是否大于或小于另一个对象。这个关系是如何确定的并不重要；数组必须使用相同的比较方式排序——即两个连续元素之间的比较将确保左边的元素小于右边的元素，正如
    `Comparable` 所提供的。
- en: 'The first `if` condition checks whether the array passed is empty, if so, obviously
    the element to be searched is not found and we return `-1` to represent this.
    Then, we find the `midIndex` and recursively search for the element in either
    the left or the right subarray. Once we have this function, we create another
    wrapper function to run the search without having to mention the start and the
    end positions:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `if` 条件检查传入的数组是否为空，如果是，那么显然要搜索的元素未找到，我们返回 `-1` 来表示这一点。然后，我们找到 `midIndex`
    并递归地在左子数组或右子数组中搜索元素。一旦我们有了这个函数，我们再创建另一个包装函数来运行搜索，而不必提及起始和结束位置：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Complexity of the binary search algorithm
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二分查找算法的复杂度
- en: 'In every step, we are partitioning the total array into two parts, barring
    the one element that we are comparing. In the worst case, that is, the case where
    the element searched is not present in the array, we will have to get down all
    the way to the point where we are dealing with an empty array, in which case we
    return `-1` and stop recursing. We must have had an array of only one element
    in the previous step. For our analysis, we will consider this step as the last
    step. So, let''s have a sorted array of *n* elements and *T(.)* is the time required
    for searching in the array. So, we have the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一步中，我们都在将整个数组划分为两个部分，除了我们正在比较的那个元素。在最坏的情况下，即搜索的元素不在数组中，我们将不得不一直下降到我们正在处理空数组的位置，在这种情况下，我们返回
    `-1` 并停止递归。在前一步中，我们必须只有一个元素的数组。为了我们的分析，我们将这一步视为最后一步。所以，让我们有一个包含 *n* 个元素的已排序数组，*T(.)*
    是在数组中搜索所需的时间。因此，我们有以下：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In general, the two search branches in every step would be of different sizes,
    one potentially being of size one less than that of the other part. But we will
    ignore these small differences, which hardly matter for a large *n*. Hence, we
    will work with the following equation:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，每一步中的两个搜索分支的大小会有所不同，一个可能比另一个部分小一个。但我们将忽略这些小的差异，这对大的 *n* 几乎没有影响。因此，我们将使用以下方程：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s assume that *n* is an integral power of *2* so that *n = 2m* for
    some integer *m*. So, we have this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设 *n* 是 *2* 的整数次幂，即 *n = 2m*，其中 *m* 是某个整数。因此，我们有以下：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now we take another function *S(.)*, such that *S(m) = T(2m)* for all *m*.
    Then, we have:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们取另一个函数 *S(.)*，使得 *S(m) = T(2m)* 对所有 *m* 都成立。然后，我们有：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is the formula for an arithmetic progression. And hence, we have this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是等差数列的公式。因此，我们有：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'So, we have the asymptotic complexity of *T(n)*:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到 *T(n)* 的渐近复杂度：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The function, *T(n)*, grows only as fast as the logarithm of the size of the
    array passed, which is really slow. This makes binary search an extremely efficient
    algorithm.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 *T(n)* 的增长速度仅与传递给数组的数组大小对数相同，这非常慢。这使得二分搜索成为一个极其高效的算法。
- en: 'To sort of field test the algorithms, we run both linear and binary search
    algorithms on an array of a hundred million elements with the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对算法进行某种程度的现场测试，我们使用以下代码在包含一亿个元素的数组上运行线性搜索和二分搜索算法：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: On my computer, the linear search took 282 milliseconds and binary search took
    0 milliseconds. Also, note that the value we are looking for is expected to be
    quite near to the beginning of the array; in case of values near the middle, a
    binary search would have an even higher advantage.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的电脑上，线性搜索耗时282毫秒，二分搜索耗时0毫秒。此外，请注意，我们正在寻找的值预计将非常接近数组的开始部分；在中间附近的值，二分搜索将具有更高的优势。
- en: Sorting
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序
- en: Okay, so we are convinced that if we have a sorted array, it takes a lot less
    time to find an element in it. But how do we get a sorted array? An arbitrary
    array is unlikely to be sorted. The algorithm of getting a sorted array out of
    an arbitrary array while keeping all the elements same, that is, by only rearranging
    the elements of an input array, is called sorting. There are a lot of algorithms
    for sorting. But in this chapter, we will start with a few simple ones that are
    not efficient. In the next chapter, we will explore efficient sorting algorithms.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我们确信，如果我们有一个已排序的数组，在其中查找一个元素所需的时间会少得多。但我们是怎样得到一个已排序的数组呢？从一个任意数组中获取一个已排序的数组，同时保持所有元素不变，即只重新排列输入数组的元素，这个过程被称为排序。有很多排序算法。但在这个章节中，我们将从一些不太高效的简单算法开始。在下一章中，我们将探讨高效的排序算法。
- en: Selection sort
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择排序
- en: 'This is the most natural algorithm for sorting. We choose each position of
    the array and find the element in the array that belongs in that position. The
    functional definition of selection sort is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是排序的最自然算法。我们选择数组的每个位置，并找到属于该位置的数组元素。选择排序的功能定义如下：
- en: Find the minimum element in an array
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数组中查找最小元素
- en: Swap this element with the first element of the array
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将此元素与数组的第一个元素交换
- en: Sort the rest of the array after the first element recursively
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归地对第一个元素之后的数组其余部分进行排序
- en: 'Finding the minimum element has the functional structure as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 查找最小元素的函数结构如下：
- en: Consider the array as a composition of the first element and the rest of the
    array.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数组视为第一个元素和数组其余部分的组合。
- en: Find the index of the minimum element in the rest of the array.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数组的其余部分中查找最小元素的索引。
- en: Compare this element with the first element. If this element is smaller than
    the first element, then it is the minimum element in the entire array. Otherwise,
    the first element is the minimum element.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将此元素与第一个元素进行比较。如果此元素小于第一个元素，那么它是整个数组中的最小元素。否则，第一个元素是最小元素。
- en: Instead of making copies of the array, we represent subarrays by simply storing
    the starting index we want to consider, and then we work on the index recursively.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是复制数组，而是通过简单地存储我们想要考虑的起始索引来表示子数组，然后我们递归地工作在索引上。
- en: 'First, we write a function to find the index of the minimum element in a given
    array, starting from a position:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们编写一个函数来找到给定数组中从某个位置开始的最小元素的索引：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we check whether the start position is the last position in the array,
    in which case we just simply return the start position as there are no more elements:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查起始位置是否是数组的最后一个位置，如果是，我们只需简单地返回起始位置，因为没有更多元素：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We find the index of the minimum element in the array to the right of the current
    start position and compare that element with the current start element. We return
    whichever has the minimum element, as demonstrated in the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们找到当前起始位置右侧数组中最小元素的索引，并将其与当前起始元素进行比较。我们返回具有最小元素的任何一个，如下所示：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `swap` function swaps or interchanges two elements in the array at the
    given positions. This function is pretty straightforward:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`swap`函数在给定的位置交换或交换数组中的两个元素。这个函数相当直接：'
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With the `findMin` and `swap` functions in our repository, we can finally put
    down the `selectionSort` algorithm. We start off by passing the position zero
    as the value of the start parameter:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的仓库中，有了`findMin`和`swap`函数，我们最终可以放下`selectionSort`算法。我们首先通过将起始位置零作为起始参数的值开始：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Firstly, there is no sorting to be done if the array is empty:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果数组为空，则不需要排序：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we just find the index of the minimum element and swap the current position
    with the index of the minimum position. This will put the minimum element in the
    current position:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需找到最小元素的索引，并将当前位置与最小位置的索引进行交换。这将把最小元素放到当前位置：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, we recursively sort the rest of the array:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们递归地对数组的其余部分进行排序：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we can write a wrapper function to just do `selectionSort` without having
    to pass a start index:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写一个包装函数来仅执行`selectionSort`，而无需传递起始索引：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can test our code by creating an arbitrary array and then sorting it using
    our algorithm:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个任意数组并使用我们的算法对其进行排序来测试我们的代码：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And the output would be as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note how all the elements are repositioned in ascending order, which means that
    the array is sorted.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意看所有元素是如何按升序重新排列的，这意味着数组已经排序。
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The form of selection sort shown is not functional in a strict sense because
    we are modifying the contents of an array. A truly functional sort of an array
    will make a copy of the array on every modification. However, this is very expensive.
    On the other hand, thinking of the algorithm in terms of smaller versions of the
    same problem, like we have done, does make the algorithm simpler to understand.
    I tried to hit a sweet spot where I have the simplicity of the recursive algorithm,
    but don't have to keep creating copies of the array.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 所示的选择排序形式在严格意义上不是功能性的，因为我们正在修改数组的元素。一个真正的数组排序将在每次修改时复制数组。然而，这非常昂贵。另一方面，像我们这样做，从相同问题的较小版本来考虑算法，确实使算法更容易理解。我试图找到一个恰到好处的点，在这里我有递归算法的简单性，但不需要不断创建数组的副本。
- en: Complexity of the selection sort algorithm
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择排序算法的复杂度
- en: 'To compute the complexity of the selection sort algorithm, first we have to
    compute the complexity of the `findMin` and `swap` functions. Let''s start with
    the `findMin` function. As with any recursive function, we start with assuming
    that with an array of length *n* (in this case, the effective length of the array,
    starting from the start position), it takes us *T(n)* time to compute the `findMin`
    function. While recursively calling itself, it passes on an effective array of
    length *n-1*. So, we have the following equation:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算选择排序算法的复杂度，首先我们必须计算`findMin`和`swap`函数的复杂度。让我们从`findMin`函数开始。与任何递归函数一样，我们首先假设对于一个长度为*n*（在这种情况下，数组的有效长度，从起始位置开始）的数组，计算`findMin`函数需要我们*T(n)*时间。在递归调用自身时，它传递一个长度为*n-1*的有效数组。因此，我们得到以下方程：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, let's move on to the `swap` function. It has no recursion and no loops,
    so the complexity is constant or *θ(1)*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续到 `swap` 函数。它没有递归也没有循环，因此其复杂度是常数或 *θ(1)*。
- en: 'Finally, we are ready to compute the complexity of the function `selectionSort`.
    Say, for an effective length *n* of an array, the time taken is *T(n)*. It calls
    itself with effective length *n-1*, it also calls `findMin` and `swap` functions,
    which are *θ(n)* and *θ(1)*, respectively. So, we have this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们准备计算函数 `selectionSort` 的复杂度。假设，对于一个数组的有效长度 *n*，所需的时间是 *T(n)*。它以有效长度 *n-1*
    调用自身，还调用了 `findMin` 和 `swap` 函数，分别对应 *θ(n)* 和 *θ(1)*。因此，我们有以下：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Note that some expressions that are *θ (n)* have been written as *θ (n)* itself.
    It should be read as, "*Some function of n that has the asymptotic complexity,
    θ (n)*." It turns out, for computing complexity of *T(n)*, we don''t have to actually
    know the actual expression, we can simply put *Cn* and *D* for functions that
    are *θ (n)* and *θ (1)*, respectively, where *C* and *D* are constants. So, we
    form the following equation:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一些表示为 *θ (n)* 的表达式已经被写成 *θ (n)* 本身。它应该读作，“*n 的某个函数，其渐近复杂度为 θ (n)*。”结果，对于计算
    *T(n)* 的计算复杂度，我们实际上不必知道实际的表达式，我们可以简单地用 *Cn* 和 *D* 分别代表 *θ (n)* 和 *θ (1)* 的函数，其中
    *C* 和 *D* 是常数。因此，我们得到以下方程：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Similarly, *T(n-1) - T(n-2) = C(n-1) + D* and so on. If we stack these equations,
    we get the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，*T(n-1) - T(n-2) = C(n-1) + D* 等等。如果我们堆叠这些方程，我们得到以下：
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Adding both sides, we get this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将两边相加，我们得到如下：
- en: '![Complexity of the selection sort algorithm](img/00028.jpeg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![选择排序算法的复杂度](img/00028.jpeg)'
- en: So, the selection sort has a complexity of *θ(n2)*, where *n* is the size of
    the array being sorted. Now, we will see the next sorting algorithm, which is
    the insertion sort.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，选择排序的复杂度为 *θ(n^2)*，其中 *n* 是正在排序的数组的大小。现在，我们将看到下一个排序算法，即插入排序。
- en: Insertion sort
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入排序
- en: 'In selection sort, we first selected a position and then found the element
    that should sit there. In the insertion sort, we do the opposite; we first select
    an element and then insert the element into position where it should sit. So,
    for every element, we first find out where it should be and then we insert the
    element in the right place. So, we first see how to insert an element into a sorted
    array. The idea is that we are given an array of sorted elements and we are supposed
    to insert another element in the correct position, so that the resulting array
    remains sorted. We will consider a simpler problem. We are given an array that
    is sorted except for the last element. Our job is to insert the last element in
    the correct position. The recursive way to achieve this insertion is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择排序中，我们首先选择一个位置，然后找到应该坐在那里的元素。在插入排序中，我们做相反的操作；我们首先选择一个元素，然后将该元素插入到它应该坐的位置。因此，对于每个元素，我们首先找出它应该在哪里，然后将其插入到正确的位置。因此，我们首先看看如何将一个元素插入到已排序数组中。想法是，我们被给了一个已排序元素的数组，并且我们需要将另一个元素插入到正确的位置，以便结果数组仍然保持排序。我们将考虑一个更简单的问题。我们被给了一个除了最后一个元素之外已排序的数组。我们的任务是插入最后一个元素到正确的位置。实现这种插入的递归方式如下：
- en: If the element to be inserted is bigger than the end element of the sorted array,
    it belongs in the end and the insertion is complete.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果要插入的元素大于已排序数组中的最后一个元素，它应该位于末尾，插入完成。
- en: Otherwise, we swap the last element with the element to be inserted and recursively
    insert this element in the rest of the smaller array in front of it.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，我们将最后一个元素与要插入的元素交换，并递归地将此元素插入到它前面的较小数组中。
- en: 'We do it with the following function. The function takes an array and a position
    that represents this last position:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下函数来完成这个操作。该函数接受一个数组和表示最后一个位置的索引：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If the last position or the `valueIndex` is `0`, there is nothing to be done,
    as the element is already in the correct position, that is, `0`. There is no array
    to the left of `valueIndex` in this case. If not, we compare the last element
    to the previous element. Since the array on the left is presumed to be sorted,
    the previous element is the largest element in the sorted part of the array. If
    the last element is bigger than even this one, there is nothing more to be done.
    If not, we swap the last element with the previous one and run the insertion recursively
    on the array with one less element. The last element has moved to the previous
    position and it must now be compared with the element before that, and so on.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果最后一个位置或`valueIndex`是`0`，则不需要做任何事情，因为元素已经在正确的位置，即`0`。在这种情况下，`valueIndex`左侧没有数组。如果不是，我们比较最后一个元素和前一个元素。由于假设左侧的数组已经排序，前一个元素是数组排序部分中的最大元素。如果最后一个元素甚至比这个元素大，则不需要做更多的事情。如果不是，我们将最后一个元素与前一个元素交换，并在元素数量少一个的数组上递归地运行插入操作。最后一个元素已经移动到前一个位置，它现在必须与前一个元素比较，依此类推。
- en: 'With the insertion function available for sorted arrays, we are now ready to
    write the algorithm for an insertion sort. In every step of the insertion sort,
    we consider a boundary in the array. Everything on the left of the boundary has
    already been sorted. Our job in the current step is to insert the element at the
    boundary index into the left sorted array, which we achieve using the `insertElementSorted`
    function. We implement this sort with the following simple strategy. In any step,
    we do the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在有排序数组可用插入函数的情况下，我们现在可以编写插入排序的算法。在插入排序的每一步中，我们考虑数组中的一个边界。边界左侧的所有内容都已经排序。我们当前步骤的工作是将边界索引处的元素插入到左侧已排序的数组中，我们使用`insertElementSorted`函数来实现这一点。我们使用以下简单的策略来实现这种排序。在任何步骤中，我们执行以下操作：
- en: We first sort the left-hand side of the boundary so that our assumption about
    it being sorted is achieved
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先对边界左侧进行排序，以便实现我们对它已排序的假设
- en: Then we invoke the `insertElementSorted` function to insert the current boundary
    element in the sorted array
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们调用`insertElementSorted`函数将当前边界元素插入到已排序的数组中
- en: 'Of course, when `boundary` is zero, it means that there is no array to be sorted
    and we simply return:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当`boundary`为零时，这意味着没有要排序的数组，我们只需返回：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Complexity of insertion sort
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插入排序的复杂度
- en: 'To compute the complexity of insertion sort, we must first compute it for the
    `insertElementSorted` function. Let the time taken for an array of effective length
    (that is, from *zero to boundary-1*), *n* be *T(n)*. From there, we recursively
    call it with *n-1*. So, we have the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算插入排序的复杂度，我们首先必须计算`insertElementSorted`函数的复杂度。设有效长度（即从`0`到`boundary-1`）的数组所需的时间为*T(n)*。从那里，我们递归地使用*n-1*调用它。所以，我们有以下：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s now assume that the time taken for sorting an array of *n* elements
    is *S(n)*. Apart from the base case, it calls itself with one less argument and
    then calls the `insertElementSorted` function with an array of effective length
    *n-1*. Thus, we have this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设排序*n*个元素的数组所需的时间是*S(n)*。除了基本情况外，它使用一个更少的参数调用自己，然后使用有效长度*n-1*的数组调用`insertElementSorted`函数。因此，我们有以下：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Again, when *n* is large, *T(n) = θ(n)*; hence, it can be approximated by *An*
    where *A* is a constant. So, we have this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，当*n*很大时，*T(n) = θ(n)*；因此，它可以近似为*An*，其中*A*是一个常数。所以，我们有以下：
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Since this is true for all *n*, we have:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这对于所有*n*都成立，所以我们有：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Summing both sides, we get the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 将两边相加，我们得到以下：
- en: '![Complexity of insertion sort](img/00029.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![插入排序的复杂度](img/00029.jpeg)'
- en: Thus, insertion sort has the same asymptotic complexity as selection sort.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，插入排序与选择排序具有相同的渐进复杂度。
- en: Bubble sort
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 冒泡排序
- en: 'Another interesting sorting algorithm is a bubble sort. Unlike the previous
    algorithms, this one works at a very local level. The strategy is as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的排序算法是冒泡排序。与之前的算法不同，这个算法在非常局部层面上工作。策略如下：
- en: Scan through the array, searching pairs of consecutive elements that are ordered
    wrongly. Then find *a j*, such that *array[j+1] < array[j]*.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描数组，寻找顺序错误的连续元素对。然后找到*j*，使得*array[j+1] < array[j]*。
- en: Whenever such a pair is found, swap them and continue searching until the end
    of the array and then back from the beginning again.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当找到这样的对时，交换它们，并继续搜索直到数组的末尾，然后再从开始处再次搜索。
- en: Stop when a scan through the entire array does not even find a single pair.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当扫描整个数组甚至找不到一对时停止。
- en: 'The code that does this is as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的代码如下：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The flag, `sorted`, keeps track of whether any inverted pairs were found during
    a scan. Each iteration of the `while` loop is a scan through the entire array,
    the scan being done inside the `for` loop. In the `for` loop, we are, of course,
    checking each pair of elements, and if an inverted pair is found, we swap them.
    We stop when `sorted` is `true`, that is, when we have not found a single inverted
    pair in the entire array.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 标志`sorted`跟踪在扫描过程中是否找到了任何逆序对。`while`循环的每次迭代都是对整个数组的扫描，这个扫描是在`for`循环内部完成的。在`for`循环中，我们当然是在检查每一对元素，如果找到一个逆序对，我们就交换它们。当`sorted`为`true`时，即当我们整个数组中没有找到任何逆序对时，我们停止。
- en: 'To see that this algorithm will indeed sort the array, we have to check two
    things:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这个算法确实可以排序数组，我们必须检查两件事：
- en: When there are no inverted pairs, the array is sorted. This justifies our stopping
    condition.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当没有逆序对时，数组是有序的。这证明了我们的停止条件。
- en: Note
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is, of course, true because when there are no inverted pairs, we have that
    for all *j< array.length-1*, we have *array[j+1]>=array[j]*. This is the definition
    of an array being in an increasing order, that is, the array being sorted.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这当然是正确的，因为当没有逆序对时，对于所有*j< array.length-1*，我们有*array[j+1]>=array[j]*。这是数组按递增顺序排列的定义，即数组是有序的。
- en: Irrespective of the input, the program will eventually reach the preceding condition
    after a finite number of steps. That is to say that we need the program to finish
    in a finite number of steps. To see this, we need to understand the concept of
    **inversions**. We will explore them in the next section.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论输入如何，程序最终都会在有限步数后达到前面的条件。也就是说，我们需要程序在有限步数内完成。为了理解这一点，我们需要了解**逆序**的概念。我们将在下一节中探讨它们。
- en: Inversions
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逆序
- en: 'Inversion in an array is a pair of elements that are wrongly ordered. The pair
    may be close together or very far apart in the array. For example, take the following
    array:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的逆序是一对顺序错误的元素。这对元素在数组中可能相邻，也可能相隔很远。例如，考虑以下数组：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'How many inversions does the array have? Let us count:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数组有多少个逆序？让我们来数一数：
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this listing, every element is compared with the elements following it. There
    is an inversion when there is a greater-than sign, highlighted by bold characters.
    Counting the bold ones, we see there are 10 inversions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，每个元素都被与它后面的元素比较。当存在一个大于号时，表示逆序，用粗体字符突出显示。数一数粗体字符，我们看到有10个逆序。
- en: 'For any input array, there is a number of inversions. In a sorted array, the
    number of inversions would be zero. Now, think about what happens to the number
    of inversions when a swap is made. A swap interchanges a pair of consecutive elements,
    thus breaking one inversion (the swap happens only when there is an inversion
    between consecutive elements). To see this more clearly, consider the following
    case of a swap between *j* and *j+1* indexes:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何输入数组，都有一个逆序的数量。在一个有序数组中，逆序的数量将是零。现在，考虑当进行交换时逆序数量会发生什么。交换交换了一对连续元素，从而打破了一个逆序（交换仅在连续元素之间存在逆序时发生）。为了更清楚地看到这一点，考虑以下在*j*和*j+1*索引之间进行交换的例子：
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Let's take the *j^(th)* element first. Let it have *x* number of inversions
    with the left part of the array. Since these elements are on the left, all inversions
    of this type are with elements greater than the *j^(th)* element. When the *j^(th)*
    element moves to the *(j+1)^(th)* position, they still remain to the left, and
    the only element added to the left of the *j^(th)* element is the element it is
    swapped with. Hence, no changes to the number of inversion happens to the *j^(th)*
    element, other than the one due to the *(j+1)^(th)* element. The same logic can
    be applied to the inversions with it in the right part of the array, and also
    to both sides of the array for the *(j+1)^(th)* element. Because of the swap,
    one inversion is broken between *j^(th)* and *(j+1)^(th)* elements. Hence, the
    number of inversions reduce by exactly one in each inversion. This means the number
    of swaps in bubble sort would be exactly equal to the number of inversions in
    the input array, which is finite. And since each scan through the array requires
    a swap in the previous scan, the total number of scans is at most one more that
    the number of swaps; this is finite too. This makes sure that the algorithm always
    finishes.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先考虑*j*次元素。假设它与数组左边的部分有*x*个逆序。由于这些元素在左边，所有这种类型的逆序都是与大于*j*次元素的元素进行的。当*j*次元素移动到*(j+1)*次位置时，它们仍然保持在左边，并且*j*次元素左边添加的唯一元素是它与之交换的元素。因此，除了由于*(j+1)*次元素之外，*j*次元素的逆序数量不会发生变化。同样的逻辑可以应用于它与数组右边部分的逆序，以及数组的两边对于*(j+1)*次元素。由于交换，*j*次和*(j+1)*次元素之间断开了一个逆序。因此，每个逆序减少一个逆序。这意味着冒泡排序中的交换次数将正好等于输入数组中的逆序数量，这是有限的。由于每次扫描数组都需要在上一次扫描中进行交换，所以总的扫描次数最多比交换次数多一次；这也是有限的。这确保了算法总是能够完成。
- en: Complexity of the bubble sort algorithm
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 冒泡排序算法的复杂性
- en: To understand the complexity of a bubble sort, we have to count the number of
    steps. Is the number of steps equal to the number of swaps? The answer is, not
    really. In case of asymptotic analysis, we must always count the step that happens
    a maximum number of times. In this case, that step is comparison. How many comparisons
    are there per scan of the array? *n-1* of course. So, now the analysis of complexity
    is reduced to the number of scans we need to sort the array.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解冒泡排序的复杂性，我们必须计算步骤的数量。步骤的数量是否等于交换的数量？答案是，并不完全是。在进行渐进分析时，我们必须始终计算发生次数最多的步骤。在这种情况下，这个步骤就是比较。每次扫描数组时有多少次比较？当然是*n-1*。因此，现在复杂性的分析就简化为排序数组所需的扫描次数。
- en: Let's see what happens to the maximum element after the first scan. Let's say
    the maximum element is at the index *j*. So, it will be compared with the element
    at *j+1*. For simplicity, let's assume that all elements are different. Now, since
    it is the maximum element, the element at the *j+1* position will be less than
    it, and hence it will be swapped. Now the maximum element is at the position,
    *j+1*, and is being compared with the element at position, *j+2*, and the same
    thing happens. It will continue until the maximum element is at the end of the
    array. If the elements are not unique, the same will happen to the rightmost maximum
    element. In the next cycle, the maximum element will already be at the end of
    the array, and we will hit the second maximum (or another maximum element) somewhere
    in the array. Now, since one maximum element is at the end of the array, we can
    think of the rest of the array apart from the last element. In this array, the
    current maximum is the maximum and it will reach the end of the current part of
    the array at the end of the current scan.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看第一次扫描后最大元素发生了什么变化。假设最大元素位于索引*j*。因此，它将与*j+1*位置的元素进行比较。为了简化，我们假设所有元素都是不同的。现在，由于它是最大元素，*j+1*位置的元素将小于它，因此它将被交换。现在最大元素位于*j+1*位置，并与*j+2*位置的元素进行比较，同样的事情发生了。它将继续进行，直到最大元素位于数组的末尾。如果元素不是唯一的，右端的最大元素也会发生相同的事情。在下一轮中，最大元素已经位于数组的末尾，我们将在数组中的某个位置遇到第二个最大值（或另一个最大元素）。现在，由于一个最大元素位于数组的末尾，我们可以将除了最后一个元素之外的其他数组部分视为独立。在这个数组中，当前的最大值是最大值，它将在当前扫描的末尾到达当前部分的末尾。
- en: This shows that at the end of each scan, at least one element reaches the correct
    final position without altering the correct positions of the ones that got there
    before the scan, which means that at the end of *n* scans, all of the elements
    would be in the correct position and the array would be sorted. That is to say
    that after at most *n* scans, the bubble sort would be complete. In each of those
    scans, there are *O(n)* operations. So, the worst case complexity of bubble sort
    is *O(n2).*
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明在每个扫描结束时，至少有一个元素达到了正确的最终位置，而没有改变在扫描之前已经到达那里的元素的正确位置，这意味着在*n*次扫描结束时，所有元素都会处于正确的位置，数组将被排序。也就是说，在最坏的情况下，冒泡排序最多需要*n*次扫描。在每个这样的扫描中，都有*O(n)*个操作。因此，冒泡排序的最坏情况复杂度是*O(n^2)*。
- en: This is not the end of this analysis; we still have to show that there is a
    case that takes that many steps, and only then can we have a theta bound on the
    worst case. We take the case where all the elements are sorted in the opposite
    order, that is, they are in a decreasing order and are all distinct. In such a
    case, every element has an inversion with all the others. This means that each
    one of the *n* elements have an inversion with *n-1* other elements, that is,
    *n(n-1)* inversions in total. But since each inversion would be counted twice,
    once from each of the elements that are members of the inversion, it is actually
    *n(n-1)/2*. Now, note that the maximum number of swaps that can be done in one
    scan is *n-1*, which will happen if every comparison results in a swap because
    there are *n-1* comparisons per scan. So, we will need at least *(n(n-1)/2)/(n-1)
    = n/2* scans to complete all the swaps, each requiring *n-1* comparisons. So,
    the complexity is at least *n(n-1)/2 = Ω(n2)*. Of course then, the worst case
    is at least this much complex because the worst case is, by definition, the most
    complex case.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是分析的终点；我们仍然需要证明存在需要这么多步骤的情况，然后我们才能对最坏情况有一个theta界限。我们考虑所有元素都按相反顺序排序的情况，即它们是递减顺序且都是不同的。在这种情况下，每个元素都与所有其他元素都有一个逆序。这意味着*n*个元素中的每一个都与*n-1*个其他元素有一个逆序，即总共有*n(n-1)*个逆序。但由于每个逆序都会被计算两次，一次是从逆序中的每个元素那里，所以实际上只有*n(n-1)/2*。现在，注意在一个扫描中可以进行的最大交换次数是*n-1*，这会在每次比较都导致交换的情况下发生，因为每个扫描有*n-1*次比较。所以，我们需要至少*(n(n-1)/2)/(n-1)
    = n/2*次扫描来完成所有交换，每次交换需要*n-1*次比较。因此，复杂度至少是*n(n-1)/2 = Ω(n^2)*。当然，由于最坏情况是定义上最复杂的情况，所以最坏情况的复杂度至少是这个程度。
- en: So, the worst case is both *O(n2)* and *Ω(n2)*, that is to say that it is *θ(n2)*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最坏情况既是*O(n^2)*也是*Ω(n^2)*，也就是说它是*θ(n^2)*。
- en: A problem with recursive calls
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归调用的问题
- en: A problem with recursive calls is that they are expensive; a method invocation
    entails considerable overhead on the processor. It is, in general, better to avoid
    invoking methods if you want to improve performance to the last bit. On top of
    that, there is a limit to the depth of function calls that you can go to, before
    the program breaks. This is because a program has a stack to enable method invocation
    semantics, that actually gets a new element containing all variables and the position
    of the current instruction to the stack. This stack does not grow indefinitely,
    but instead is fixed in size; usually, it can hold a few thousand values, which
    means that if your method invocation is deeper than that, it will break and the
    program will exit with an error. This means that our insertion sort will break
    for an array containing more than a few thousand entries. On the other hand, it
    is generally easier to explain an algorithm in a functional form. To balance between
    these two aspects, we need to be able to convert to and from the recursive and
    non-recursive versions of the same algorithm. We will do this step by step from
    the simplest form to the more complicated form.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 递归调用的问题在于它们代价高昂；方法调用在处理器上涉及相当大的开销。一般来说，如果你想将性能提升到极致，最好避免调用方法。此外，函数调用的深度有一个限制，超过这个限制程序就会崩溃。这是因为程序有一个栈来启用方法调用语义，实际上会将包含所有变量和当前指令位置的元素推入栈中。这个栈不会无限增长，而是固定大小；通常，它可以存储几千个值，这意味着如果你的方法调用深度超过这个值，它就会崩溃，程序会因错误而退出。这意味着我们的插入排序会在包含超过几千个条目的数组上崩溃。另一方面，通常在函数形式中解释算法更容易。为了在这两个方面之间取得平衡，我们需要能够将同一算法的递归和非递归版本相互转换。我们将从最简单形式逐步到更复杂形式进行这一转换。
- en: Tail recursive functions
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尾递归函数
- en: 'A recursive function is called a tail recursive function if all the recursive
    calls to itself in the function are the last operations. I say it like there are
    multiple calls and all of them must be the last operations. How is that possible?
    I mean there can be different calls from different conditional branches of the
    code inside the function. However, whenever the function calls itself that must
    be the last operation in that conditional branch of the function. For example,
    take our binary search algorithm again:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数中所有对自身的递归调用都是最后一个操作，则称该递归函数为尾递归函数。我这样说是因为可能有多个调用，并且所有这些调用都必须是最后一个操作。这是怎么可能的呢？我的意思是，可以从函数内部代码的不同条件分支中进行不同的调用。然而，无论何时函数调用自身，都必须是该函数条件分支中的最后一个操作。例如，再次考虑我们的二分搜索算法：
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note that the function calls itself in two different conditional branches. However,
    in each branch, the recursive call is the last operation. There is nothing to
    be done after the call to itself. This is a tail recursive function.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，函数在两个不同的条件分支中调用自身。然而，在每个分支中，递归调用是最后一个操作。在调用自身之后没有其他操作要做。这是一个尾递归函数。
- en: Tail recursive functions can be turned into a loop absolutely mechanically.
    In fact, all functional language compilers do this automatically during compiler
    optimization. The Java compiler, however, does not do this because Java generally
    prefers loops over recursion in the code, at least until very recently. But we
    can do this conversion by ourselves.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 尾递归函数可以绝对机械地转换成循环。实际上，所有函数式语言编译器在编译优化期间都会自动执行这个转换。然而，Java编译器并不这样做，因为Java通常更倾向于在代码中使用循环而不是递归，至少直到最近。但我们可以自己进行这种转换。
- en: 'The idea is that since there are no more operations after the recursive call,
    the program does not have to remember the values of the variables of the calling
    function. So, they can simply be overwritten by the values of the same variables
    of the called function instead, and we just have to process the code of the function
    again. So, the following is the mechanical procedure to achieve this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是，由于递归调用之后没有更多的操作，程序不需要记住调用函数的变量值。因此，它们可以被被调用函数的相同变量的值简单地覆盖，我们只需要再次处理函数的代码。所以，以下是实现这一点的机械步骤：
- en: Wrap the entire content in an infinite `while` loop.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 将整个内容包裹在一个无限`while`循环中。
- en: Replace all recursive calls by updating the values of the parameters to the
    values that are passed in the recursive calls.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有递归调用替换为更新参数的值，这些值是在递归调用中传递的。
- en: 'The following shows this update in the binary search algorithm:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在二分搜索算法中展示了这种更新：
- en: '[PRE42]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note that we updated only those arguments that changed, which is only one update
    per branch in this case. This will produce the exact same result as the earlier
    function, but now it would not cause a stack overflow. This conversion is not
    really required in case of a binary search though, because you need only *lg n*
    steps to search an array of length *n*. So, if your allowed depth of invocation
    is *1000*, then you can search in an array of maximum size of *21000* elements.
    This number is way more than the total number of atoms in the entire universe,
    and hence we will never be able to store an array of that enormous size. But the
    example shows the principle of converting a tail recursion into a loop.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只更新了那些改变的参数，在这种情况下，每个分支只有一个更新。这将产生与之前函数完全相同的结果，但现在它不会导致栈溢出。尽管在二分搜索的情况下这种转换并不是必需的，因为你只需要`lg
    n`步就能搜索长度为`n`的数组。所以，如果你的调用深度允许为`1000`，那么你可以搜索最大大小为`2^1000`的数组。这个数字远远超过整个宇宙中原子总数的总和，因此我们永远无法存储如此巨大的数组。但这个例子展示了将尾递归转换为循环的原则。
- en: 'Another example is the `insertElementSorted` function, used in our insertion
    sort algorithm:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是`insertElementSorted`函数，它用于我们的插入排序算法：
- en: '[PRE43]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Note that there is no operation pending after the recursive call to itself.
    But we need to be a little more careful here. Note that the invocation only happens
    inside a code branch. The else case is implicit here, which is `else { return;
    }`. We need to make it explicit in our code first, as shown below:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在递归调用自身之后没有待执行的操作。但在这里我们需要更加小心。注意，调用只发生在代码分支内部。这里的else情况是隐式的，即`else { return;
    }`。我们首先需要在代码中将其明确化，如下所示：
- en: '[PRE44]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now we can use our old technique to make it non-recursive, that is, to wrap
    it in an infinite loop and replace recursive calls with argument updates:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用我们旧的技巧来使其非递归，也就是说，将其包裹在一个无限循环中，并用参数更新来替换递归调用：
- en: '[PRE45]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This gives the exact same result as the previous recursive version of the function.
    So, the corrected steps would be as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了与之前递归版本的函数完全相同的结果。因此，更正后的步骤如下：
- en: First, make all implicit branches explicit and all implicit returns explicit.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将所有隐式分支和所有隐式返回都明确化。
- en: Wrap the entire content in an infinite while loop.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将整个内容包裹在一个无限while循环中。
- en: Replace all recursive calls by updating the values of the parameters to the
    values that are passed in the recursive calls.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有递归调用替换为更新参数值为递归调用中传递的值。
- en: Non-tail single recursive functions
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非尾单递归函数
- en: 'By single recursion, I mean that the function invokes itself at most once per
    conditional branch of the function. They may be tail-recursive, but they are not
    always so. Consider the example of the recursion of our insertion sort algorithm:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 单递归的意思是函数在每个函数条件分支中最多调用自身一次。它们可能是尾递归的，但并不总是这样。考虑我们插入排序算法的递归示例：
- en: '[PRE46]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Note that the function calls itself only once, so it is a single recursion.
    But since we have a call to `insertElementSorted` after the recursive call to
    itself, it is not a tail recursive function, which means that we cannot use the
    earlier method. Before doing this though, let''s consider a simpler example. Take
    the factorial function:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意函数只调用自身一次，因此它是单递归。但由于我们在递归调用之后有对`insertElementSorted`的调用，所以它不是一个尾递归函数，这意味着我们不能使用之前的方法。在这样做之前，让我们考虑一个更简单的例子。考虑阶乘函数：
- en: '[PRE47]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: First, note that the function is singly recursive, because there is at most
    one recursive call per branch of the code. Also, note that it is not tail recursive
    because you have to do a multiplication after the recursive call.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意函数是单递归的，因为代码的每个分支最多只有一个递归调用。此外，注意它不是尾递归，因为递归调用之后你必须进行乘法操作。
- en: To convert this into a loop, we must first figure out the actual order of the
    numbers being multiplied. The function calls itself until it hits `0`, at which
    point, it returns `1`. So, the multiplication actually starts from `1` and then
    accumulates the higher values.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要将其转换为循环，我们首先必须确定正在乘以的数字的实际顺序。函数调用自身直到遇到`0`，此时返回`1`。因此，乘法实际上是从`1`开始的，然后累积较高的值。
- en: 'Since it accumulates the values on its way up, we need an accumulator (that
    is a variable storing one value) to collect this value in a loop version. The
    steps are as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它在上升过程中累积值，我们需要一个累加器（即存储一个值的变量）来在循环版本中收集这个值。步骤如下：
- en: First, make all implicit branches explicit and all implicit returns explicit.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将所有隐式分支和所有隐式返回都明确化。
- en: Create an accumulator of the same type as the return type of the function. This
    is to store intermediate return values. The starting value of the accumulator
    is the value returned in the base case of the recursion.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个与函数返回类型相同的累加器。这是为了存储中间返回值。累加器的起始值是递归基本情况下返回的值。
- en: Find the starting value of the recursion variable, that is, the one that is
    getting smaller in each recursive invocation. The starting value is the value
    that causes the next recursive call to fall in the base case.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到递归变量的起始值，即每次递归调用中逐渐减小的那个值。起始值是导致下一次递归调用进入基本情况的值。
- en: The exit value of the recursion variable is the same as the one passed to the
    function originally.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归变量的退出值与最初传递给函数的值相同。
- en: Create a loop and make the recursion variable your loop variable. Vary it from
    the start value to the end value calculated earlier in a way to represent how
    the value changes from higher depth to lower depth of recursion. The higher depth
    value comes before the lower depth value.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个循环，并将递归变量作为循环变量。从起始值到之前计算出的结束值，以表示值从递归的较高深度到较低深度的变化。较高深度的值在较低深度值之前。
- en: Remove the recursive call.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除递归调用。
- en: 'What is the initial value of the accumulator `prod`? It is the same as the
    value that is returned in the exit branch of the recursion, that is, `1`. What
    is the highest value being multiplied? It is `x`. So we can now convert it to
    the following loop:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 累加器`prod`的初始值是多少？它与递归退出分支中返回的值相同，即`1`。正在乘以的最高值是什么？它是`x`。因此，我们现在可以将其转换为以下循环：
- en: '[PRE48]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now let''s consider the `insertionSort` algorithm. What is the accumulator?
    It is the same thing that would be the final output, that is, an array of sorted
    elements. What is the starting value? It is the same that is returned in the recursive
    version in the exit branch. This is an array of length zero. What is the final
    value? The array of sorted elements of the length provided to sort. Again, just
    like our recursive version, we represent these partial arrays with, simply, a
    boundary value. So, the code is as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑`insertionSort`算法。什么是累加器？它就是最终输出，即排序后的元素数组。起始值是什么？它与递归版本中退出分支返回的值相同。这是一个长度为零的数组。最终值是什么？提供排序长度的排序后的元素数组。再次，就像我们的递归版本一样，我们用边界值简单地表示这些部分数组。因此，代码如下：
- en: '[PRE49]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note that in this case, the function `return` type is `void`. But what we are
    really returning is the sorted array; we just resorted to modifying the same array
    to avoid creating duplicate arrays.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，函数的`return`类型是`void`。但我们的真正返回的是排序后的数组；我们只是重新排序了同一个数组，以避免创建重复的数组。
- en: The most general case is the multiple recursion, that is, the function calls
    itself multiple times in the same conditional branch of the function. This case
    cannot be done without a stack. In case of a recursive call, we use the method-invocation
    stack. Otherwise, we can even use an external stack. Since we do not have such
    an example in this chapter, we defer its explanation to the next chapter, where
    we will have an example.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最一般的情况是多重递归，即函数在函数的同一条件分支中多次调用自身。这种情况没有栈是无法完成的。在递归调用的情况下，我们使用方法调用栈。否则，我们甚至可以使用外部栈。由于我们本章没有这样的例子，我们将将其解释推迟到下一章，届时我们将有一个例子。
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how to do an efficient search in an ordered array. This
    search is called a binary search. You also learned some methods of obtaining an
    ordered array out of an unordered one. This process is called sorting. We saw
    three basic algorithms of sorting. Although they are not particularly efficient,
    they are simple to understand the concept. You also learned how to convert a recursive
    algorithm to a non-recursive one that uses a loop. In the next chapter, we will
    see efficient sorting algorithms.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在有序数组中进行高效搜索。这种搜索被称为二分搜索。你还学习了从无序数组中获得有序数组的一些方法。这个过程被称为排序。我们看到了三种基本的排序算法。虽然它们并不特别高效，但它们的概念很容易理解。你还学习了如何将递归算法转换为使用循环的非递归算法。在下一章中，我们将看到高效的排序算法。
