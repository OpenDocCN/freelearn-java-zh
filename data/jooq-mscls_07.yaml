- en: '*Chapter 5*: Tackling Different Kinds of SELECT, INSERT, UPDATE, DELETE, and
    MERGE'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章*：处理不同类型的SELECT、INSERT、UPDATE、DELETE和MERGE'
- en: A common scenario for jOOQ beginners originates from having a plain valid SQL
    that should be expressed via the jOOQ DSL API. While the jOOQ DSL API is extremely
    intuitive and easy to learn, the lack of practice may still lead to scenarios
    where we simply cannot find or intuit the proper DSL methods that should be chained
    to express a certain SQL.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ初学者常见的场景来自于有一个应该通过jOOQ DSL API表达的标准有效的SQL。虽然jOOQ DSL API非常直观且易于学习，但缺乏实践仍然可能导致我们无法找到或直观地找到应该链式调用的适当DSL方法来表达特定的SQL。
- en: This chapter addresses this kind of issue via a comprehensive collection of
    popular queries, which gives you the chance to practice jOOQ DSL syntax based
    on the Java-based schema. More precisely, our aim is to express, in jOOQ DSL syntax,
    a carefully harvested list of `SELECT`, `INSERT`, `UPDATE`, `DELETE`, and `MERGE`
    statements that are used in our day-to-day job.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过一系列流行的查询来解决这个问题，这给了你基于Java模式练习jOOQ DSL语法的机遇。更确切地说，我们的目标是使用jOOQ DSL语法表达、收集我们日常工作中使用的`SELECT`、`INSERT`、`UPDATE`、`DELETE`和`MERGE`语句的精心挑选列表。
- en: This way, by the end of this chapter, you should have funneled a significant
    number of SQLs through the jOOQ DSL syntax and tried them out against MySQL, PostgreSQL,
    SQL Server, and Oracle databases in Java applications based on Maven and Gradle.
    Being dialect-agnostic, jOOQ DSL excels at handling tons of dialect-specific issues
    by emulating a valid syntax, therefore, this is also a good chance to taste this
    aspect for these four popular databases.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，到本章结束时，你应该已经通过jOOQ DSL语法过滤了大量的SQL语句，并在基于Maven和Gradle的Java应用程序中针对MySQL、PostgreSQL、SQL
    Server和Oracle数据库进行了尝试。由于jOOQ DSL是无方言的，它擅长通过模拟有效语法来处理大量的方言特定问题，因此这也是尝试这四个流行数据库这一方面的好机会。
- en: Notice that, even if you see some performance tips, our focus is not on finding
    the best SQL or the most optimal SQL for a certain use case. This is not our goal!
    Our goal is to learn the jOOQ DSL syntax at a decent level that allows writing
    almost any `SELECT`, `INSERT`, `UPDATE`, `DELETE`, and `MERGE` statement in a
    productive manner.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使你看到了一些性能提示，我们的重点并不是寻找最佳SQL或针对特定用例的最优SQL。这并不是我们的目标！我们的目标是学习jOOQ DSL语法，达到一个能够以高效方式编写几乎所有`SELECT`、`INSERT`、`UPDATE`、`DELETE`和`MERGE`语句的水平。
- en: 'In this context, our agenda contains the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的议程包括以下内容：
- en: Expressing `SELECT` statements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达`SELECT`语句
- en: Expressing `INSERT` statements
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达`INSERT`语句
- en: Expressing `UPDATE` statements
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达`UPDATE`语句
- en: Expressing `DELETE` statements
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达`DELETE`语句
- en: Expressing `MERGE` statements
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达`MERGE`语句
- en: Let's get started!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter05](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter05).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到，链接为[https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter05](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter05)。
- en: Expressing SELECT statements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达SELECT语句
- en: In this section, we will express/write via jOOQ DSL syntax a wide range of `SELECT`
    statements, including common projections, popular subqueries, scalar and correlated
    subqueries, unions, and row value expressions. We'll start with the commonly used
    projections.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过jOOQ DSL语法表达/编写一系列`SELECT`语句，包括常见的投影、流行的子查询、标量相关子查询、并集和行值表达式。我们将从常用的投影开始。
- en: Expressing commonly used projections
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达常用投影
- en: By *commonly used projections*, we understand the projections written against
    the well-known dummy table, `DUAL`. As you most probably know, the `DUAL` table
    is specific to Oracle; it's mostly unnecessary in MySQL (although jOOQ still renders
    it for MySQL 5.7 compatibility) and doesn't exist in PostgreSQL and SQL Server.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过**常用投影**，我们理解的是针对众所周知的虚拟表`DUAL`的投影。正如你可能知道的，`DUAL`表是Oracle特有的；在MySQL中（尽管jOOQ仍然为了MySQL
    5.7的兼容性而生成它），它通常是不必要的，而在PostgreSQL和SQL Server中则不存在。
- en: 'In this context, even if the SQL standard requires a `FROM` clause, jOOQ never
    requires such a clause and it renders the `DUAL` table whenever it is needed/supported.
    For example, selecting *0* and *1* can be done via the `selectZero()` and `selectOne()`methods
    (these statics are available in `org.jooq.impl.DSL`). The latter (`selectOne()`),
    including some alternatives, is exemplified next:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在此上下文中，即使SQL标准要求一个`FROM`子句，jOOQ也从不要求这样的子句，并在需要/支持时渲染`DUAL`表。例如，选择`*0*`和`*1*`可以通过`selectZero()`和`selectOne()`方法完成（这些静态方法在`org.jooq.impl.DSL`中可用）。下面将举例说明后者（`selectOne()`），包括一些替代方案：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As a parenthesis, the DSL class also expose three helpers for expressing the
    commonly used `0 literal (DSL.zero())`, `1 literal (DSL.one())`, and `2 literal
    (DSL.two())`. So, while selectZero() results in a new DSL subselect for a constant
    0 literal, the zero() represents the 0 literal itself. Selecting ad hoc values
    can be done as follows (since we cannot use plain values in `select()`, we rely
    on the `val()` method introduced in [*Chapter 3*](B16833_03.xhtml#_idTextAnchor040),
    *jOOQ Core Concepts*, to obtain the proper parameters):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，DSL类还公开了三个用于表达常用`0`字面量（`DSL.zero()`）、`1`字面量（`DSL.one()`）和`2`字面量（`DSL.two()`）的辅助器。因此，虽然`selectZero()`会导致一个新的DSL子查询，用于常量`0`字面量，但`zero()`本身代表`0`字面量。选择特定值可以如下进行（由于我们无法在`select()`中使用普通值，我们依赖于在[*第3章*](B16833_03.xhtml#_idTextAnchor040)，*jOOQ核心概念*中引入的`val()`方法来获取适当的参数）：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Or, it can be done via the `values()` table constructor, which allows us to
    express in-memory temporary tables. With jOOQ, the `values()` table constructor
    can be used to create tables that can be used in a `SELECT` statement''s `FROM`
    clause. Notice how we specified the column aliases ("derived column lists") along
    with the table alias (`"t"`) for the `values()` constructor:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以通过`values()`表构造函数来完成，这允许我们表达内存中的临时表。在jOOQ中，`values()`表构造函数可以用来创建可以在`SELECT`语句的`FROM`子句中使用的表。注意我们如何为`values()`构造函数指定列别名（“派生列列表”）以及表别名（`"t"`）：
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is another alternative to `selectOne()`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`selectOne()`的另一个替代方案：
- en: '[PRE18]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can also specify an explicit `FROM` clause to point out some specific tables.
    Here is an example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以指定一个显式的`FROM`子句来指出一些特定的表。以下是一个示例：
- en: '[PRE21]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Of course, the purpose of offering `selectOne()` and the like is not really
    to allow for querying `ctx.selectOne().fetch()`, but to be used in queries where
    the projection doesn''t matter, as in the following example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，提供`selectOne()`及其类似功能的目的并不是真正为了允许查询`ctx.selectOne().fetch()`，而是在投影无关的查询中使用，如下例所示：
- en: '[PRE25]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the code bundled with this book, you can find more examples that are not
    listed here. Take your time to explore the *CommonlyUsedProjections* application.
    Next, let's tackle `SELECT` subqueries or subselects.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书附带代码中，你可以找到更多未在此列出的示例。花些时间探索`CommonlyUsedProjections`应用程序。接下来，让我们解决`SELECT`子查询或子选择。
- en: Expressing SELECT to fetch only the needed data
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达`SELECT`以获取所需的数据
- en: 'Starting with jOOQ DSL may target a simple `SELECT` query of the `SELECT all_columns
    FROM table` or `SELECT * FROM table` type. This kind of query can be written in
    jOOQ as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从jOOQ DSL开始，可能的目标是简单的`SELECT`查询，例如`SELECT all_columns FROM table`或`SELECT *
    FROM table`类型。这种查询可以用jOOQ写成如下形式：
- en: '[PRE31]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Since we rely on the generated Java-based schema (obtained via the jOOQ generator
    as you saw in [*Chapter 2*](B16833_02.xhtml#_idTextAnchor024), *Customizing the
    jOOQ Level of Involvement*), jOOQ can infer the fields (columns) of the `ORDER`
    table and explicitly render them in the generated query. But, if you need to render
    the `*` itself instead of the list of fields, then you can use the handy `asterisk()`
    method, as in the following query:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们依赖于生成的基于Java的模式（如你在[*第2章*](B16833_02.xhtml#_idTextAnchor024)，*自定义jOOQ参与级别*)中看到的，jOOQ可以推断出`ORDER`表的字段（列），并在生成的查询中明确地渲染它们。但是，如果你需要渲染`*`本身而不是字段列表，则可以使用方便的`asterisk()`方法，如下面的查询所示：
- en: '[PRE37]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As Lukas Eder mentioned: "*Perhaps worth stressing more heavily here that the
    asterisk (*`*`*) is not the same thing as the other three ways of querying all
    columns. The asterisk (*`*`*) projects all the columns from the live database
    schema including the ones that jOOQ doesn''t know. The other three approaches
    project all the columns that jOOQ knows but those columns may no longer exist
    in the live database schema. There may be a mismatch, which is especially important
    when mapping to records (for instance, using* `selectFrom()`*, or* `into(recordtype)`*).
    Even so, when using *, and when all the tables in* `from()` *are known to jOOQ,
    jOOQ will try to expand the asterisk in order to access all converters and data
    type bindings, and embeddable records, and other things*."'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如Lukas Eder所提到的："*也许在这里更加强调一下，星号 (*`*`*) 并不等于查询所有列的其他三种方式。星号 (*`*`*) 会从实时数据库模式中投影所有列，包括jOOQ不知道的列。其他三种方法会投影jOOQ知道的列，但这些列可能不再存在于实时数据库模式中。可能存在不匹配，这在映射到记录（例如，使用*
    `selectFrom()`* 或 *`into(recordtype)`*）时尤其重要。即使如此，当使用 *`*`* 并且在 *`from()`* 中的所有表都为jOOQ所知时，jOOQ将尝试展开星号以访问所有转换器和数据类型绑定，以及可嵌入的记录和其他事物*。"
- en: 'Moreover, notice that such queries may fetch more data than needed, and relying
    on `*` instead of a list of columns may come with performance penalties, which
    are discussed in this article: [https://tanelpoder.com/posts/reasons-why-select-star-is-bad-for-sql-performance/](https://tanelpoder.com/posts/reasons-why-select-star-is-bad-for-sql-performance/).
    When I say that *it may fetch more data than needed*, I refer to the scenarios
    that process only a subset of the fetched result set, while the rest of it is
    simply discarded. Fetching data can be an expensive (especially, time-consuming)
    operation, therefore, fetching data just to discard it is a waste of resources
    and it can lead to long-running transactions that affect the application''s scalability.
    This is a common scenario in JPA-based applications (for instance, in Spring Boot,
    `spring.jpa.open-in-view=true` may lead to loading more data than is needed).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，此类查询可能会获取比所需更多的数据，而依赖 `*` 而不是列的列表可能会带来性能惩罚，这在本文中有所讨论：[https://tanelpoder.com/posts/reasons-why-select-star-is-bad-for-sql-performance/](https://tanelpoder.com/posts/reasons-why-select-star-is-bad-for-sql-performance/)。当我提到
    "*可能获取比所需更多的数据*" 时，我指的是仅处理获取结果集的子集的场景，而其余的则被简单地丢弃。获取数据可能是一项昂贵的操作（尤其是耗时操作），因此，只是为了丢弃而获取数据是一种资源浪费，并且可能导致长时间运行的交易，影响应用程序的可扩展性。这在基于JPA的应用程序中是一个常见的场景（例如，在Spring
    Boot中，`spring.jpa.open-in-view=true`可能会导致加载比所需更多的数据）。
- en: 'Among others, Tanel Poder''s article mentions one thing that a lot of beginners
    overlook. By forcing the database to do "*useless, mandatory work*" (you''ll love
    this article for sure: [https://blog.jooq.org/2017/03/08/many-sql-performance-problems-stem-from-unnecessary-mandatory-work/](https://blog.jooq.org/2017/03/08/many-sql-performance-problems-stem-from-unnecessary-mandatory-work/))
    via a `*` projection, it can no longer apply some optimizations to the query,
    for example, join elimination, which is essential for complex queries ([https://tanelpoder.com/posts/reasons-why-select-star-is-bad-for-sql-performance/#some-query-plan-optimizations-not-possible](https://tanelpoder.com/posts/reasons-why-select-star-is-bad-for-sql-performance/#some-query-plan-optimizations-not-possible)).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他方面，Tanel Poder的文章提到一个很多初学者容易忽视的问题。通过强制数据库执行 "*无用的强制工作*"（你一定会喜欢这篇文章：[https://blog.jooq.org/2017/03/08/many-sql-performance-problems-stem-from-unnecessary-mandatory-work/](https://blog.jooq.org/2017/03/08/many-sql-performance-problems-stem-from-unnecessary-mandatory-work/))
    通过 `*` 投影，它将无法应用一些查询优化，例如，连接消除，这对于复杂查询是至关重要的 ([https://tanelpoder.com/posts/reasons-why-select-star-is-bad-for-sql-performance/#some-query-plan-optimizations-not-possible](https://tanelpoder.com/posts/reasons-why-select-star-is-bad-for-sql-performance/#some-query-plan-optimizations-not-possible))。
- en: Fetching a subset of columns
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取列的子集
- en: 'As a rule of thumb, fetching more data than needed is a common cause of persistence
    layer performance penalties. Therefore, if all you need is a subset of columns
    from `ORDER`, then simply enlist them explicitly in `SELECT` as `select(ORDER.ORDER_ID,
    ORDER.ORDER_DATE, ORDER.REQUIRED_DATE, ORDER.SHIPPED_DATE, ORDER.CUSTOMER_NUMBER)`.
    Sometimes, the needed subset of columns is almost equal to (but not equal to)
    the total number of fields/columns. In such cases, instead of enlisting the subset
    of columns as previously, it is more practical to point out the fields/columns
    that should be excluded via the `except()` method. Here is an example of fetching
    all fields/columns from `ORDER` except `ORDER.COMMENTS` and `ORDER.STATUS`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，获取比所需更多的数据是持久层性能惩罚的常见原因。因此，如果你只需要 `ORDER` 表的子集列，那么只需在 `SELECT` 中明确列出它们，例如
    `select(ORDER.ORDER_ID, ORDER.ORDER_DATE, ORDER.REQUIRED_DATE, ORDER.SHIPPED_DATE,
    ORDER.CUSTOMER_NUMBER)`。有时，所需的子集列几乎等于（但不等于）字段/列的总数。在这种情况下，与其像之前那样列出子集列，不如通过 `except()`
    方法指出应排除的字段/列。以下是一个从 `ORDER` 中获取所有字段/列，除了 `ORDER.COMMENTS` 和 `ORDER.STATUS` 的示例：
- en: '[PRE40]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here is another example that applies the SQL `nvl()` function to the `OFFICE.CITY`
    field. Whenever `OFFICE.CITY` is `null`, we fetch the `N/A` string:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，它将 SQL `nvl()` 函数应用于 `OFFICE.CITY` 字段。每当 `OFFICE.CITY` 为 `null` 时，我们获取
    `N/A` 字符串：
- en: '[PRE43]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If you need to attach an alias to a condition, then we first need to wrap this
    condition in a field via the `field()` method. Here is an example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要给一个条件附加别名，那么我们首先需要通过 `field()` 方法将这个条件包装在一个字段中。以下是一个示例：
- en: '[PRE46]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'And, the result set table-like head of this query looks as here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这个查询的结果集表头看起来如下：
- en: '![](img/B16833_Figure_5.1.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16833_Figure_5.1.jpg)'
- en: 'Notice that the `* EXCEPT (...)` syntax is inspired by BigQuery, which also
    has a `* REPLACE (...)` syntax that jOOQ plans to implement. You can track its
    progress here: [https://github.com/jOOQ/jOOQ/issues/11198](https://github.com/jOOQ/jOOQ/issues/11198).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`* EXCEPT (...)` 语法灵感来源于 BigQuery，它也计划实现一个 `* REPLACE (...)` 语法。你可以在这里跟踪其进度：[https://github.com/jOOQ/jOOQ/issues/11198](https://github.com/jOOQ/jOOQ/issues/11198)。
- en: In the code bundled with this book (`SelectOnlyNeededData`), you can see more
    examples of juggling with the `asterisk()` and `except()` methods to materialize
    different scenarios that involve one or more tables.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书附带代码（`SelectOnlyNeededData`）中，你可以看到更多使用 `asterisk()` 和 `except()` 方法进行操作以实现涉及一个或多个表的场景的示例。
- en: Fetching a subset of rows
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取行子集
- en: 'Besides using predicates, fetching only a subset of rows is commonly accomplished
    via the `LIMIT ... OFFSET` clause. Unfortunately, this clause is not part of the
    SQL standard and it is understood only by a limited number of database vendors
    such as MySQL and PostgreSQL. Nevertheless, jOOQ allows us to use `LIMIT ... OFFSET`
    via the `limit()` and `offset()` methods and will handle all aspects of emulating
    a compatible syntax for the used dialect. Here is an example of rendering `LIMIT
    10 OFFSET 5`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用谓词外，通常通过 `LIMIT ... OFFSET` 子句来获取行子集。不幸的是，这个子句不是 SQL 标准的一部分，并且只有有限数量的数据库供应商（如
    MySQL 和 PostgreSQL）理解它。尽管如此，jOOQ 允许我们通过 `limit()` 和 `offset()` 方法使用 `LIMIT ...
    OFFSET`，并将处理所有用于使用方言的兼容语法方面。以下是一个渲染 `LIMIT 10 OFFSET 5` 的示例：
- en: '[PRE49]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Here is the same thing (the same query and result) but expressed via the `limit(Number
    offset, Number numberOfRows)` flavor (pay attention that the offset is the first
    argument – the order of arguments inherited from MySQL):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是相同的事情（相同的查询和结果），但通过 `limit(Number offset, Number numberOfRows)` 风味表达（请注意，偏移量是第一个参数——从
    MySQL 继承的参数顺序）：
- en: '[PRE56]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'And, jOOQ will render the following SQL depending on the database vendor:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，jOOQ 将根据数据库供应商渲染以下 SQL：
- en: '[PRE62]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Commonly, the arguments of `LIMIT` and `OFFSET` are some hard-coded integers.
    But, jOOQ allows us to use `Field` as well. For instance, here we use a scalar
    subquery in `LIMIT` (the same thing can be done in `OFFSET`):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`LIMIT` 和 `OFFSET` 的参数是一些硬编码的整数。但是，jOOQ 允许我们使用 `Field`。例如，在这里我们使用一个标量子查询在
    `LIMIT` 中（同样可以在 `OFFSET` 中做同样的事情）：
- en: '[PRE70]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'As a note from Lukas Eder, "*Starting with version 3.15, jOOQ generates standard
    SQL for* `OFFSET … FETCH` *in PostgreSQL, not the vendor-specific* `LIMIT … OFFSET`
    *anymore. This is to provide native support for* `FETCH NEXT … ROWS WITH TIES`*.
    Maybe, a future jOOQ will also offer the SQL Standard 2011 Oracle''s/SQL Server''s
    syntax:* `OFFSET n ROW[S] FETCH { FIRST | NEXT } m [ PERCENT ] ROW[S] { ONLY |
    WITH TIES }`." Track it here: [https://github.com/jOOQ/jOOQ/issues/2803](https://github.com/jOOQ/jOOQ/issues/2803).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Lukas Eder的笔记，“*从版本3.15开始，jOOQ为PostgreSQL中的`OFFSET … FETCH`生成标准SQL，而不是供应商特定的*`LIMIT
    … OFFSET`*。这是为了提供对*`FETCH NEXT … ROWS WITH TIES`*的原生支持。也许，未来的jOOQ也会提供SQL标准2011中Oracle的/SQL
    Server的语法：*`OFFSET n ROW[S] FETCH { FIRST | NEXT } m [ PERCENT ] ROW[S] { ONLY
    | WITH TIES }`。”跟踪这里：[https://github.com/jOOQ/jOOQ/issues/2803](https://github.com/jOOQ/jOOQ/issues/2803)。
- en: 'Notice that the previous queries use an explicit `ORDER BY` to avoid unpredictable
    results. If we omit `ORDER BY`, then jOOQ will emulate it on our behalf whenever
    it is needed. For instance, `OFFSET` (unlike `TOP`) requires `ORDER BY` in SQL
    Server, and if we omit `ORDER BY`, then jOOQ will render it on our behalf as in
    the following SQL:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，之前的查询使用了显式的`ORDER BY`来避免不可预测的结果。如果我们省略`ORDER BY`，那么jOOQ将在需要时代表我们模拟它。例如，`OFFSET`（与`TOP`不同）在SQL
    Server中需要`ORDER BY`，如果我们省略`ORDER BY`，那么jOOQ将代表我们生成以下SQL：
- en: '[PRE75]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Since we touched on this emulation topic, let's have a note that you should
    be aware of.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们提到了模拟这个话题，让我们提醒一下你应该注意的事项。
- en: Important note
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'One of the coolest things about jOOQ is the capability to emulate the valid
    and optimal SQL syntax when the user database is lacking a specific feature (consider
    reading this article: [https://blog.jooq.org/2018/03/13/top-10-sql-dialect-emulations-implemented-in-jooq/](https://blog.jooq.org/2018/03/13/top-10-sql-dialect-emulations-implemented-in-jooq/)).
    The jOOQ documentation mentions that "*jOOQ API methods which are not annotated
    with the* `org.jooq.Support` *annotation (*`@Support`*), or which are annotated
    with the* `@Support` *annotation, but without any SQL dialects can be safely used
    in all SQL dialects. The aforementioned* `@Support` *annotation does not only
    designate which databases natively support a feature. It also indicates that a
    feature is emulated by jOOQ for some databases lacking this feature*." Moreover,
    whenever jOOQ doesn''t support some vendor-specific functionality/syntax, the
    solution is to use plain SQL templating. This is dissected in a future chapter
    of this book.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ最酷的特性之一是能够在用户数据库缺少特定功能时模拟有效的和最优的SQL语法（建议阅读这篇文章：[https://blog.jooq.org/2018/03/13/top-10-sql-dialect-emulations-implemented-in-jooq/](https://blog.jooq.org/2018/03/13/top-10-sql-dialect-emulations-implemented-in-jooq/))。jOOQ文档提到，“*未使用`org.jooq.Support`注解（*`@Support`*）的jOOQ
    API方法，或者使用`@Support`注解但没有指定任何SQL方言的方法，可以在所有SQL方言中安全使用。上述*`@Support`*注解不仅指定了哪些数据库原生支持某个功能。它还表明，对于缺少此功能的某些数据库，jOOQ会模拟该功能*。”此外，每当jOOQ不支持某些供应商特定的功能/语法时，解决方案是使用纯SQL模板。这一点将在本书的后续章节中详细说明。
- en: 'For more examples, please consider the code bundled with this book. You''ll
    find a collection of 15+ examples, including several corner cases as well. For
    instance, in `EXAMPLE 10.1` and `10.2`, you can see an example of fetching the
    rows in a certain order via the jOOQ `sortAsc()` method (if you are in such a
    position, then I suggest you read this article as well: [https://blog.jooq.org/2014/05/07/how-to-implement-sort-indirection-in-sql/](https://blog.jooq.org/2014/05/07/how-to-implement-sort-indirection-in-sql/)).
    Or, in `EXAMPLE 11`, you can see how to choose at runtime between `WHERE ... IN`
    and `WHERE ... NOT IN` statements via the jOOQ `org.jooq.Comparator` API and a
    Boolean variable. Moreover, in `EXAMPLE 15` and `16`, you can see the usage of
    the `SelectQuery` API for fetching columns from different tables. Take your time
    and practice each of these examples. I''m pretty sure that you''ll learn a lot
    of tricks from them. The application is named `SelectOnlyNeededData`. For now,
    let''s talk about expressing subselects in jOOQ.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 更多示例，请考虑本书附带代码。你将找到 15+ 个示例，包括几个边缘情况。例如，在 `EXAMPLE 10.1` 和 `10.2` 中，你可以看到通过
    jOOQ 的 `sortAsc()` 方法按特定顺序检索行的示例（如果你处于这种位置，我建议你也阅读这篇文章：[https://blog.jooq.org/2014/05/07/how-to-implement-sort-indirection-in-sql/](https://blog.jooq.org/2014/05/07/how-to-implement-sort-indirection-in-sql/))。或者，在
    `EXAMPLE 11` 中，你可以看到如何通过 jOOQ 的 `org.jooq.Comparator` API 和一个布尔变量在运行时选择 `WHERE
    ... IN` 和 `WHERE ... NOT IN` 语句。此外，在 `EXAMPLE 15` 和 `16` 中，你可以看到使用 `SelectQuery`
    API 从不同表中检索列的用法。花时间练习这些示例。我非常确信，你会从中学到很多技巧。应用程序名为 `SelectOnlyNeededData`。现在，让我们来谈谈如何在
    jOOQ 中表达子查询。
- en: Expressing SELECT subqueries (subselects)
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达 SELECT 子查询（子选择）
- en: Roughly speaking, a `SELECT` subquery (or subselect) is represented by a `SELECT`
    statement nested in another `SELECT` statement. Commonly, they appear in the `WHERE`
    or the `FROM` clauses, but it is no surprise to see them in the `HAVING` clause
    or combined with database views.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 大概来说，一个 `SELECT` 子查询（或子选择）是由嵌套在另一个 `SELECT` 语句中的 `SELECT` 语句表示的。通常，它们出现在 `WHERE`
    或 `FROM` 子句中，但它们出现在 `HAVING` 子句或与数据库视图结合使用也不足为奇。
- en: 'For example, let''s take the following plain SQL containing a subselect in
    the `WHERE` clause as part of the predicate:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们以以下包含子查询的 `WHERE` 子句的普通 SQL 语句为例，作为谓语的一部分：
- en: '[PRE79]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'In jOOQ, we can express this query straightforwardly:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 jOOQ 中，我们可以直接表达这个查询：
- en: '[PRE82]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Notice how we have used the `IN` statement via the jOOQ `in()` method. In the
    same manner, you can use other statements supported by jOOQ, such as `NOT IN`
    (`notIn()`), `BETWEEN` (`between()`), `LIKE` (`like()`), and many others. Always
    pay attention to using `NOT IN` and that it's a peculiar behavior regarding `NULL`
    originating from the subquery ([https://www.jooq.org/doc/latest/manual/sql-building/conditional-expressions/in-predicate/](https://www.jooq.org/doc/latest/manual/sql-building/conditional-expressions/in-predicate/)).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何通过 jOOQ 的 `in()` 方法使用 `IN` 语句的。同样地，你可以使用 jOOQ 支持的其他语句，例如 `NOT IN` (`notIn()`),
    `BETWEEN` (`between()`), `LIKE` (`like()`)，以及许多其他语句。始终注意使用 `NOT IN`，并且要注意它来自子查询的关于
    `NULL` 的特殊行为（[https://www.jooq.org/doc/latest/manual/sql-building/conditional-expressions/in-predicate/](https://www.jooq.org/doc/latest/manual/sql-building/conditional-expressions/in-predicate/))。
- en: Almost any SQL statement has a jOOQ equivalent implementation, therefore, take
    your time and scan the jOOQ API to cover it as much as possible. This is the right
    direction in becoming a jOOQ power user.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何 SQL 语句都有一个 jOOQ 等价实现，因此，花时间扫描 jOOQ API 尽可能多地覆盖它。这是成为 jOOQ 高级用户的正确方向。
- en: Important Note
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In subselects of type `SELECT foo...`, `(SELECT buzz)` is a common case to use
    both `DSLContext.select()` and `DSL.select()` as `ctx.select(foo) ... (select(buzz))`.
    The `DSLContext.select()` method is used for the outer `SELECT` in order to obtain
    a reference to a database configured connection, while for the inner or nested
    `SELECT`, we can use `DSL.select()` or `DSLContext.select()`. However, using `DSL.select()`
    for the inner `SELECT` is more convenient because it can be statically imported
    and referenced simply as `select()`. Notice that using `DSL.select()`for both
    types of `SELECT` or only for the inner `SELECT` leads to an exception of type
    *Cannot execute query. No Connection configured*. But, of course, you can still
    execute `DSL.select()` via `DSLContext.fetch(ResultQuery)` and the like.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型为 `SELECT foo...` 的子查询中，`(SELECT buzz)` 是一个常见的案例，可以使用 `DSLContext.select()`
    和 `DSL.select()` 作为 `ctx.select(foo) ... (select(buzz))`。`DSLContext.select()`
    方法用于外部的 `SELECT` 以获取数据库配置连接的引用，而对于内部或嵌套的 `SELECT`，我们可以使用 `DSL.select()` 或 `DSLContext.select()`。然而，对于内部
    `SELECT` 使用 `DSL.select()` 更方便，因为它可以静态导入并简单地作为 `select()` 引用。请注意，使用 `DSL.select()`
    对两种类型的 `SELECT` 或仅对内部 `SELECT` 使用会导致类型为 *Cannot execute query. No Connection configured*
    的异常。但当然，您仍然可以通过 `DSLContext.fetch(ResultQuery)` 等方式执行 `DSL.select()`。
- en: 'Next, let''s have another plain SQL that has a subselect in the `FROM` clause,
    as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看另一个简单的 SQL，它在 `FROM` 子句中有一个子查询，如下所示：
- en: '[PRE87]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'This time, let''s express the subselect via a derived table as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，让我们通过派生表以下列方式表达子查询：
- en: '[PRE94]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Another approach relies on `table(select(…))`. Practically, `table``(Select<R>)`
    is a synonym for `asTable()`. Choose the one that you find more fluent:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法依赖于 `table(select(…))`。实际上，`table(Select<R>)` 是 `asTable()` 的同义词。选择您认为更流畅的一个：
- en: '[PRE100]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Next, we can use this derived table to express the outer `SELECT`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用这个派生表来表示外部的 `SELECT`：
- en: '[PRE101]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Since jOOQ cannot infer the field types of a user-defined derived table, we
    can rely on coercing to fill up the expected types of the `sen` and `avgs` fields
    (for a quick reminder of the *coercing* goal, please revisit [*Chapter 3*](B16833_03.xhtml#_idTextAnchor040),
    *jOOQ Core Concepts*), or `saleTable.field(name, type)`, as here.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 jOOQ 无法推断用户定义的派生表的字段类型，我们可以依靠强制转换来填充 `sen` 和 `avgs` 字段的预期类型（为了快速回顾 *强制转换*
    的目标，请重新阅读 [*第 3 章*](B16833_03.xhtml#_idTextAnchor040)，*jOOQ 核心概念*），或 `saleTable.field(name,
    type)`，就像这里一样。
- en: 'The jOOQ API is so flexible and rich that it allows us to express the same
    SQL in multiple ways. It depends on us to choose the most convenient approach
    in a certain scenario. For example, if we consider that the SQL part `WHERE (employee_number
    = saleTable.sen AND sale < saleTable.avgs)`can be written as `WHERE (employee_number
    = sen AND sale < avgs)`, then we can extract the following fields as local variables:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ API 非常灵活和丰富，它允许我们以多种方式表达相同的 SQL。这取决于我们在特定场景中选择最方便的方法。例如，如果我们认为 SQL 部分 `WHERE
    (employee_number = saleTable.sen AND sale < saleTable.avgs)` 可以写成 `WHERE (employee_number
    = sen AND sale < avgs)`，那么我们可以提取以下字段作为局部变量：
- en: '[PRE108]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'And, we can use them in the derived table and outer `SELECT`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在派生表和外部的 `SELECT` 中使用它们：
- en: '[PRE111]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Or, we can eliminate the explicitly derived table and embed the subselect in
    a fluent style:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以消除显式导出的表，并以流畅的方式嵌入子查询：
- en: '[PRE120]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Notice that we removed the explicit `saleTable` alias as well. As MySQL complains
    (and not only), every derived table requires an alias, but we don't have to worry
    about it. jOOQ knows this and will generate an alias on our behalf (something
    similar to `alias_25088691`). But, if your benchmarks reveal that alias generation
    is not negligible, then it is better to supply an explicit alias. As Lukas Eder
    says, "*However, the generated alias is based deterministically on the SQL string,
    in order to be stable, which is important for execution plan caches (for instance,
    Oracle, SQL Server, irrelevant in MySQL, PostgreSQL)*."
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还移除了显式的 `saleTable` 别名。因为 MySQL 抱怨（并且不仅仅是），每个派生表都需要一个别名，但我们不必担心。jOOQ 会代表我们生成别名（类似于
    `alias_25088691`）。但是，如果您的基准测试表明别名生成不可忽略，那么提供显式别名会更好。正如 Lukas Eder 所说，“*然而，生成的别名是基于
    SQL 字符串的确定性，为了稳定，这对于执行计划缓存（例如，Oracle、SQL Server，在 MySQL 和 PostgreSQL 中无关紧要）很重要。””
- en: Consider more examples in the bundled code. For instance, if you are interested
    in using `SELECT` nested in`INSERT`, `UPDATE`, and `DELETE`, then you can find
    examples in the bundled code. The application is named *SampleSubqueries*. Next,
    let's talk about scalar subqueries.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中考虑更多示例。例如，如果您对在 `INSERT`、`UPDATE` 和 `DELETE` 中嵌套 `SELECT` 感兴趣，那么您可以在捆绑的代码中找到示例。应用程序名为
    *SampleSubqueries*。接下来，让我们谈谈标量子查询。
- en: Expressing scalar subqueries
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达标量子查询
- en: 'A scalar subquery selects only one column/expression and returns only one row.
    It can be used in an SQL query anywhere that a column/expression can be used.
    For example, let''s assume plain SQL that selects the employees with a salary
    greater than or equal to the average salary plus *25,000*:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 标量子查询只选择一个列/表达式，并返回一行。它可以在 SQL 查询的任何位置使用，只要可以使用列/表达式的地方。例如，让我们假设一个简单的 SQL 查询，该查询选择薪水大于或等于平均薪水加
    *25,000* 的员工：
- en: '[PRE127]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'In jOOQ, this query is generated by the following code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在 jOOQ 中，这个查询是通过以下代码生成的：
- en: '[PRE129]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Have you noticed the `...ge(select(...))` construct? In the left-hand of `ge()`
    we have a `Field`, but in the right-hand we have a `Select`. This is possible
    thanks to `ge(Select<? extends Record1<T>> select)`, which is a very handy shortcut
    that saves us from the explicit usage of `field()` as `ge(field(select(...)))`,
    or from `asField()` as `ge(select(...).asField())`. We can also write conditions
    such as `select(...).ge(select(...))`. But, what is the difference between `field()`
    and `asField()`?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到 `...ge(select(...))` 结构了吗？在 `ge()` 的左边我们有一个 `Field`，但在右边我们有一个 `Select`。这是由于
    `ge(Select<? extends Record1<T>> select)` 的存在，这是一个非常方便的快捷方式，可以节省我们显式使用 `field()`
    作为 `ge(field(select(...)))`，或者使用 `asField()` 作为 `ge(select(...).asField())` 的麻烦。我们也可以写出像
    `select(...).ge(select(...))` 这样的条件。但是，`field()` 和 `asField()` 之间有什么区别？
- en: 'Let''s have another example that inserts a new `PRODUCT` (I''ve listed only
    the relevant part):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再举一个例子，这个例子中插入了一个新的 `PRODUCT`（我只列出了相关部分）：
- en: '[PRE134]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'To insert the value of `PRODUCT.MSRP` as the average `Field`. This can be done
    as we did via `field(Select<? extends Record1<T>> s)` or via `asField()`. If we
    go with `asField()`, then we write something like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `PRODUCT.MSRP` 的值作为平均 `Field` 插入。这可以通过我们之前通过 `field(Select<? extends Record1<T>>
    s)` 或通过 `asField()` 做到。如果我们选择 `asField()`，那么我们会写出类似以下的内容：
- en: '[PRE139]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'But, `asField()` returns this result provider as a `Field<?/Object>` object.
    In other words, `asField()` loses type information and so isn''t type-safe. By
    losing type information, `asField()` allows us to accidentally introduce type-safety-related
    errors that cannot be detected until runtime, or even worse, that will produce
    unexpected results. Here, we have typed `array(PRODUCT.MSRP)` instead of `avg(PRODUCT.MSRP)`
    but we have no complaints until runtime:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，`asField()` 方法返回的结果提供者是一个 `Field<?/Object>` 对象。换句话说，`asField()` 丢失了类型信息，因此不是类型安全的。通过丢失类型信息，`asField()`
    允许我们意外地引入类型安全相关的错误，这些错误直到运行时才能检测到，甚至更糟糕的是，会产生意外的结果。在这里，我们使用了 `array(PRODUCT.MSRP)`
    而不是 `avg(PRODUCT.MSRP)`，但我们直到运行时都没有任何抱怨：
- en: '[PRE140]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Of course, you won''t be writing such blabbering, but the idea is that using
    `asField()` in such contexts is prone to other data type incompatibilities that
    might be hard to spot and might produce unexpected results. So, let''s keep `asField()`
    for queries as `SELECT b.*, (SELECT foo FROM a) FROM b`, and let''s focus on `field()`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不会写出这样的废话，但想法是，在这样的上下文中使用 `asField()` 容易出现其他数据类型不兼容的问题，这些问题可能很难发现，并可能产生意外的结果。所以，让我们保留
    `asField()` 用于查询，如 `SELECT b.*, (SELECT foo FROM a) FROM b`，并专注于 `field()`：
- en: '[PRE141]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Do you think this code will compile? The correct answer is no! Your IDE will
    immediately signal a data type incompatibility. While `PRODUCT.MSRP` is `BigDecimal`,
    `(array(PRODUCT.MSRP))` is `Field<BigDecimal[]>`, so `INSERT` is wrong. Replace
    `array()` with `avg()`. Problem solved!
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为这段代码会编译吗？正确的答案是不会！你的 IDE 会立即发出数据类型不兼容的信号。虽然 `PRODUCT.MSRP` 是 `BigDecimal`
    类型，但 `(array(PRODUCT.MSRP))` 是 `Field<BigDecimal[]>` 类型，所以 `INSERT` 是错误的。将 `array()`
    替换为 `avg()`。问题解决！
- en: In the bundled code (`ScalarSubqueries`), you have more examples, including
    using scalar queries nested in `INSERT`, `UPDATE`, and `DELETE`. Next, let's talk
    about correlated subqueries.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码（`ScalarSubqueries`）中，你会有更多示例，包括在 `INSERT`、`UPDATE` 和 `DELETE` 中使用嵌套的标量查询。接下来，让我们谈谈相关子查询。
- en: Expressing correlated subqueries
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达相关子查询
- en: A correlated subquery (or repeating subquery) uses the values of the outer query
    for computing its values. Since it depends on the outer query, a correlated subquery
    can't be executed independently as a standalone subquery. As Lukas Eder mentioned,
    "*In any case, no RDBMS is forced to naively execute a correlated subquery once
    for each row evaluated by the outer query (obviously, if such a thing would happen,
    then this may come with an overhead in performance if the correlated subquery
    must be executed for a significant number of times). Many RDBMS would optimize
    a correlated subquery by applying a transformation to a join or semi-join. Other,
    such as Oracle 11g and later, optimizes correlated subqueries thanks to scalar
    subquery caching*." ([https://blogs.oracle.com/oraclemagazine/on-caching-and-evangelizing-sql](https://blogs.oracle.com/oraclemagazine/on-caching-and-evangelizing-sql))
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 相关子查询（或重复子查询）使用外部查询的值来计算其值。由于它依赖于外部查询，相关子查询不能作为一个独立的子查询独立执行。正如Lukas Eder提到的，“*在任何情况下，没有RDBMS被迫对每个由外部查询评估的行天真地执行一次相关子查询（显然，如果这种情况发生，那么这可能会带来性能开销，如果相关子查询必须执行多次）。许多RDBMS会通过将转换应用于连接或半连接来优化相关子查询。其他，如Oracle
    11g及以后版本，通过标量子查询缓存来优化相关子查询。” ([https://blogs.oracle.com/oraclemagazine/on-caching-and-evangelizing-sql](https://blogs.oracle.com/oraclemagazine/on-caching-and-evangelizing-sql))
- en: 'Let''s consider the following plain SQL representing a correlated scalar subquery:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下表示相关标量子查询的简单SQL：
- en: '[PRE142]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Expressing this query in jOOQ can be done as follows (notice that we want to
    preserve the `s1` and `s2` aliases in the rendered SQL):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在jOOQ中表达这个查询可以这样进行（注意我们希望在渲染的SQL中保留`s1`和`s2`别名）：
- en: '[PRE150]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Did you spot this: `...where(s1.SALE_.eq(select(max(s2.SALE_))`? No `asField()`
    /`field()` required! The query didn''t need to call `asField()`/`field()`, because
    there''s a convenience overload provided by jOOQ as `Field<T>.eq(Select<? extends
    Record1<T>>)`. Yes, I know I already told you about it earlier, but I just wanted
    to enforce it again.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到了这个：`...where(s1.SALE_.eq(select(max(s2.SALE_))`？不需要`asField()` /`field()`！查询不需要调用`asField()`/`field()`，因为jOOQ提供了一个便利的重载，即`Field<T>.eq(Select<?
    extends Record1<T>>)`。是的，我知道我之前已经告诉过你，但我只是想再次强调。
- en: 'However, as you probably intuited, this correlated subquery, which relies on
    repeatedly self-joined tables, can be expressed more efficiently via `GROUP BY`
    as follows (this time, we don''t preserve the aliases):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如你可能直觉到的，这个相关子查询，它依赖于重复自连接的表，可以通过以下`GROUP BY`更有效地表达（这次，我们不保留别名）：
- en: '[PRE160]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: In this case, `GROUP BY` is *much* better, because it eliminates that self-join,
    turning *O(n*2*)* into *O(n).* As Lukas Eder shared, "*With modern SQL, self-joins
    are almost never really needed anymore. Beginners might think that these self-joins
    are the way to go, when they can be quite detrimental,* [https://twitter.com/MarkusWinand/status/1118147557828583424](https://twitter.com/MarkusWinand/status/1118147557828583424)*,
    O(n*2) *in the worst case*." So, before jumping in to write such correlated subqueries,
    try to evaluate some alternatives and compare the execution plans.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`GROUP BY`要好得多，因为它消除了自连接，将*O(n*2*)*转换为*O(n)*。正如Lukas Eder分享的，“*随着现代SQL的发展，自连接几乎不再真正需要。初学者可能会认为这些自连接是可行的，但它们可能会带来很大的损害，*[https://twitter.com/MarkusWinand/status/1118147557828583424](https://twitter.com/MarkusWinand/status/1118147557828583424)*，最坏情况下为O(n*2)*。”所以，在跳入编写这样的相关子查询之前，尝试评估一些替代方案并比较执行计划。
- en: 'Let''s look at another example based on the following plain SQL:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下简单SQL的另一个例子：
- en: '[PRE166]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'So, this query compares the average buy price (or list price) of all products
    with all the sale prices of each product. If this average is greater than any
    of the sale prices of a product, then the product is fetched in the result set.
    In jOOQ, this can be expressed as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个查询比较了所有产品的平均购买价格（或标价）与每个产品的所有销售价格。如果这个平均值大于某个产品的任何销售价格，那么该产品将被检索到结果集中。在jOOQ中，可以这样表达：
- en: '[PRE174]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: In the bundled code, you have a comprehensive list of examples, including examples
    containing `WHERE (NOT) EXISTS`, `ALL`, and `ANY`. As Lukas Eder says, "*It is
    worth mentioning that the name of ALL and ANY is "quantifier" and the comparison
    is called quantified comparison predicate. These are much more elegant than comparing
    with* `MIN()` *or* `MAX()`*, or using* `ORDER BY .. LIMIT 1`*, especially when
    row value expressions are used*." Moreover, you can check out examples of using
    correlated subqueries nested in `INSERT`, `UPDATE`, and `DELETE`. The application
    is named *CorrelatedSubqueries*. Next, let's talk about writing row expressions
    in jOOQ.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，你有一个包含 `WHERE (NOT) EXISTS`，`ALL` 和 `ANY` 等示例的完整列表。正如 Lukas Eder 所说，“*值得指出的是，ALL
    和 ANY 的名字是 '量词'，比较称为量词比较谓词。这些比与 *`MIN()`* 或 *`MAX()`* 比较或使用 *`ORDER BY .. LIMIT
    1`* 更优雅，尤其是在使用行值表达式时*。” 此外，你还可以查看使用嵌套在 `INSERT`，`UPDATE` 和 `DELETE` 中的相关子查询的示例。该应用程序名为
    *CorrelatedSubqueries*。接下来，让我们来谈谈在 jOOQ 中编写行表达式。
- en: Expressing row expressions
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达行表达式
- en: 'Row value expressions are quite handy for writing elegant multi-row predicates.
    jOOQ represents row value expressions via the `org.jooq.Row` interface. Its usage
    is straightforward, as the following plain SQL shows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 行值表达式对于编写优雅的多行谓词非常有用。jOOQ 通过 `org.jooq.Row` 接口表示行值表达式。其用法简单，如下面的普通 SQL 所示：
- en: '[PRE184]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'In jOOQ, this can be expressed via `row()`, as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在 jOOQ 中，这可以通过 `row()` 表达，如下所示：
- en: '[PRE188]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: In the bundled code (`RawValueExpression`), you can practice examples of using
    row value expressions with comparison predicates, `BETWEEN` and `OVERLAPS` predicates
    (jOOQ supports overlapping dates and arbitrary row value expressions of degree
    2 – how cool is that?!), and `NULL`. Next, let's tackle the `UNION` and `UNION
    ALL` operators.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码（`RawValueExpression`）中，你可以练习使用行值表达式与比较谓词、`BETWEEN` 和 `OVERLAPS` 谓词（jOOQ
    支持重叠日期和任意行值表达式的 2 度 – 这有多酷？！）以及 `NULL` 的示例。接下来，让我们来处理 `UNION` 和 `UNION ALL` 操作符。
- en: Expressing the UNION and UNION ALL operators
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达 UNION 和 UNION ALL 操作符
- en: 'The `UNION` and `UNION ALL` operators are useful for combining two or more
    result sets from different `SELECT` statements or `SELECT`s into one result set.
    `UNION` eliminates duplicate rows from the results of the `SELECT` statements,
    while `UNION ALL` doesn''t do this. To work, the number and order of columns must
    correspond in both queries and the data types must be the same or at least compatible.
    Let''s consider the following SQL:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`UNION` 和 `UNION ALL` 操作符用于将来自不同 `SELECT` 语句或 `SELECT` 的两个或多个结果集合并为一个结果集。`UNION`
    从 `SELECT` 语句的结果中消除重复行，而 `UNION ALL` 不做此操作。要正常工作，两个查询中的列数和顺序必须对应，并且数据类型必须相同或至少兼容。让我们考虑以下
    SQL：'
- en: '[PRE192]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'jOOQ renders `UNION` via the `union()` method and `UNION ALL` via the `unionAll()`
    method. The previous SQL is rendered via `union()` as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 通过 `union()` 方法渲染 `UNION`，通过 `unionAll()` 方法渲染 `UNION ALL`。前面的 SQL 通过 `union()`
    渲染如下：
- en: '[PRE199]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: Lukas Eder noted that *"*`UNION` *(*`ALL`*) acts differently with respect to*
    `NULL` *than other operators, meaning that two* `NULL` *values are 'not distinct.'
    So* `SELECT NULL UNION SELECT NULL` *produces only one row, just like* `SELECT
    NULL INTERSECT SELECT NULL`*.**"*
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Lukas Eder 指出，“*`UNION` (*`ALL`*) 在处理 `NULL` 方面与其他操作符不同，这意味着两个 `NULL` 值是 '不区分的'。因此，`SELECT
    NULL UNION SELECT NULL` 只产生一行，就像 `SELECT NULL INTERSECT SELECT NULL`*。”
- en: In the bundled code, you can practice more examples, including `UNION` and `ORDER
    BY`, `UNION` and `LIMIT`, `UNION` and `HAVING`, `UNION` and `SELECT INTO` (MySQL
    and PostgreSQL), `UNION ALL`, and so on. Unfortunately, there is no space here
    to list and dissect these examples, therefore, consider the application named
    *SelectUnions*. Next, let's cover the `INTERSECT` and `EXCEPT` operators.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，你可以练习更多示例，包括 `UNION` 和 `ORDER BY`，`UNION` 和 `LIMIT`，`UNION` 和 `HAVING`，`UNION`
    和 `SELECT INTO`（MySQL 和 PostgreSQL），`UNION ALL` 等。不幸的是，这里没有足够的空间来列出并分析这些示例，因此，请考虑名为
    *SelectUnions* 的应用程序。接下来，让我们来探讨 `INTERSECT` 和 `EXCEPT` 操作符。
- en: Expressing the INTERSECT (ALL) and EXCEPT (ALL) operators
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达 INTERSECT (ALL) 和 EXCEPT (ALL) 操作符
- en: The `INTERSECT` operator produces only the values (rows) that are returned by
    (or common to) both subselects. The `EXCEPT` operator (or `MINUS` in Oracle) produces
    only the values that occur in the first (or left) subselect and don't occur in
    the second (or right) subselect. While `INTERSECT` and `EXCEPT` remove duplicates
    from their results, `INTERSECT ALL` and `EXCEPT ALL` don't do this. Exactly as
    in the case of `UNION`, to work, the number and order of columns must correspond
    in both queries and the data types must be the same or at least compatible.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`INTERSECT`运算符仅产生由（或共同于）两个子查询返回的值（行）。`EXCEPT`运算符（或Oracle中的`MINUS`）仅产生出现在第一个（或左侧）子查询中且不出现在第二个（或右侧）子查询中的值。虽然`INTERSECT`和`EXCEPT`会从其结果中删除重复项，但`INTERSECT
    ALL`和`EXCEPT ALL`不会这样做。与`UNION`的情况一样，要正常工作，两个查询中的列数和顺序必须对应，并且数据类型必须相同或至少兼容。'
- en: 'Let''s consider the following plain SQL:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下纯SQL：
- en: '[PRE210]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'In jOOQ, this can be expressed via `intersect()` as follows (for rendering
    `INTERSECT ALL`, use the `intersectAll()` method):'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在jOOQ中，这可以通过以下`intersect()`方法表达（对于渲染`INTERSECT ALL`，使用`intersectAll()`方法）：
- en: '[PRE213]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'By replacing the SQL `INTERSECT` with `EXCEPT` and, in jOOQ, the `intersect()`
    method with `except()` we can obtain an `EXCEPT` use case (for `EXCEPT ALL`, use
    the `exceptAll()` method). Here is the plain SQL (this time, let''s add an `ORDER
    BY` clause as well):'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将SQL中的`INTERSECT`替换为`EXCEPT`，并在jOOQ中将`intersect()`方法替换为`except()`，我们可以获得一个`EXCEPT`用例（对于`EXCEPT
    ALL`，使用`exceptAll()`方法）。以下是纯SQL（这次，让我们添加一个`ORDER BY`子句）：
- en: '[PRE218]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'And the jOOQ code is as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ的代码如下：
- en: '[PRE222]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: Nevertheless, if your database doesn't support these operators (for example,
    MySQL), then you have to emulate them. There are several ways to accomplish this
    and in the application named *IntersectAndExcept* (for MySQL), you can see a non-exhaustive
    list of solutions that emulate `INTERSECT` (`ALL`) based on `IN` (useful when
    no duplicates or `NULL` are present) and `WHERE EXISTS`, and emulate `EXCEPT`
    (`ALL`) based on `LEFT OUTER JOIN` and `WHERE NOT EXISTS`. Of course, feel free
    to check out the examples from *IntersectAndExcept* for PostgreSQL, SQL Server,
    and Oracle as well. Notice that Oracle 18c (used in our applications) supports
    only `INTERSECT` and `EXCEPT`, while Oracle20c supports all these four operators.
    Next, let's tackle the well-known `SELECT DISTINCT` and more.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你的数据库不支持这些运算符（例如，MySQL），那么你必须模拟它们。有几种方法可以实现这一点，在名为*IntersectAndExcept*的应用程序中（用于MySQL），你可以看到基于`IN`（当没有重复项或`NULL`时很有用）和`WHERE
    EXISTS`模拟`INTERSECT`（`ALL`）的非详尽解决方案列表，并基于`LEFT OUTER JOIN`和`WHERE NOT EXISTS`模拟`EXCEPT`（`ALL`）。当然，你也可以查看*IntersectAndExcept*的MySQL、SQL
    Server和Oracle的示例。注意，Oracle 18c（用于我们的应用程序）仅支持`INTERSECT`和`EXCEPT`，而Oracle20c支持所有这四个运算符。接下来，让我们解决众所周知的`SELECT
    DISTINCT`和更多内容。
- en: Expressing distinctness
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达独特性
- en: 'jOOQ comes with a suite of methods for expressing distinctness in our queries.
    We have the following:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ提供了一套方法来表达查询中的独特性。我们有以下方法：
- en: '`SELECT DISTINCT` via `selectDistinct()`'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SELECT DISTINCT`通过`selectDistinct()`'
- en: '`IS` (`NOT`) `DISTINCT FROM` via `isDistinctFrom()` and `isNotDistinctFrom()`'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IS` (`NOT`) `DISTINCT FROM`通过`isDistinctFrom()`和`isNotDistinctFrom()`'
- en: '`COUNT (DISTINCT...)` via `countDistinct()`'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COUNT (DISTINCT...)`通过`countDistinct()`'
- en: '`AVG`/`SUM`/`MIN`/`MAX (DISTINCT ...)` via `avg`/`sum`/`min`/`maxDistinct()`'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AVG`/`SUM`/`MIN`/`MAX (DISTINCT ...)`通过`avg`/`sum`/`min`/`maxDistinct()`'
- en: PostgreSQL `DISTINCT ON` via `selectDistinct().on()` or `distinctOn()`
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL `DISTINCT ON`通过`selectDistinct().on()`或`distinctOn()`
- en: 'Let''s look at an example of `IS DISTINCT FROM` as follows (in MySQL, `IS DISTINCT
    FROM` is represented by the `<=>` operator):'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下`IS DISTINCT FROM`的示例（在MySQL中，`IS DISTINCT FROM`由`<=>`运算符表示）：
- en: '[PRE227]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'And jOOQ renders this query via the following snippet of code:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ通过以下代码片段呈现此查询：
- en: '[PRE233]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: Depending on the used dialect, jOOQ emulates the correct syntax. While for MySQL,
    jOOQ renders the `<=>` operator, for Oracle, it relies on `DECODE` and `INTERSECT`,
    and for SQL Server, it relies on `INTERSECT`. PostgreSQL supports `IS DISTINCT
    FROM`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 根据使用的方言，jOOQ模拟正确的语法。对于MySQL，jOOQ呈现`<=>`运算符；对于Oracle，它依赖于`DECODE`和`INTERSECT`；对于SQL
    Server，它依赖于`INTERSECT`。PostgreSQL支持`IS DISTINCT FROM`。
- en: 'Next, let''s see an example of PostgreSQL''s `DISTINCT ON`:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看PostgreSQL的`DISTINCT ON`的一个示例：
- en: '[PRE240]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: 'And the jOOQ code is as follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ的代码如下：
- en: '[PRE244]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: It is definitely worth mentioning here that jOOQ emulates this PostgreSQL-specific
    `DISTINCT ON` for MySQL, SQL Server, Oracle, and so on, via the `row_number()`
    window function.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 肯定值得在这里提到的是，jOOQ通过`row_number()`窗口函数模拟了针对MySQL、SQL Server、Oracle等特定于PostgreSQL的`DISTINCT
    ON`。
- en: 'Of course, we can write jOOQ queries that emulate `DISTINCT ON` as well. For
    instance, the following example fetches the employee numbers of the maximum sales
    per fiscal year via jOOQ''s `rowNumber()` and `qualify()`:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以编写模拟 `DISTINCT ON` 的 jOOQ 查询。例如，以下示例通过 jOOQ 的 `rowNumber()` 和 `qualify()`
    获取每个财政年度最大销售额的员工编号：
- en: '[PRE249]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: 'A classical scenario solved via `DISTINCT ON` relies on selecting some distinct
    column(s) while ordering by other column(s). For instance, the following query
    relies on the PostgreSQL `DISTINCT ON` to fetch the distinct employee numbers
    ordered by minimum sales:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `DISTINCT ON` 解决的经典场景依赖于选择一些不同的列（s）同时按其他列排序。例如，以下查询依赖于 PostgreSQL 的 `DISTINCT
    ON` 来获取按最小销售额排序的不同员工编号：
- en: '[PRE257]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: 'Of course, this can be emulated without `DISTINCT ON` as well. Here is an alternative:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也可以在不使用 `DISTINCT ON` 的情况下进行模拟。这里是一个替代方案：
- en: '[PRE264]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: In the bundled code (`SelectDistinctOn`), you can find examples that cover all
    the bullets of the previous list. Take your time to practice them and get familiar
    with jOOQ syntax. Moreover, don't stop at these examples; feel free to experiment
    as much as possible with `SELECT`.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码（`SelectDistinctOn`）中，你可以找到涵盖之前列表中所有条目的示例。花些时间练习它们，熟悉 jOOQ 语法。此外，不要止步于这些示例；请尽可能多地用
    `SELECT` 进行实验。
- en: That's all about `SELECT`. Next, let's start talking about inserts.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `SELECT` 的内容就到这里。接下来，让我们开始讨论插入操作。
- en: Expressing INSERT statements
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达 INSERT 语句
- en: In this section, we will express different kinds of inserts including `INSERT
    ... VALUES`, `INSERT ... SET`, `INSERT ... RETURNING`, and `INSERT ...DEFAULT
    VALUES` via the jOOQ DSL syntax. Let's start with the well-known `INSERT ... VALUES`
    insert, which is supported by most database vendors.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过 jOOQ DSL 语法表达不同类型的插入，包括 `INSERT ... VALUES`、`INSERT ... SET`、`INSERT
    ... RETURNING` 和 `INSERT ...DEFAULT VALUES`。让我们从众所周知的 `INSERT ... VALUES` 插入开始，这是大多数数据库供应商支持的。
- en: Expressing INSERT ... VALUES
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表达 INSERT ... VALUES
- en: jOOQ supports `INSERT ... VALUES` via the `insertInto()` and `values()` methods.
    Optionally, we can use the `columns()` method for separating the name of the table
    in which we insert from the list of fields/columns that we insert. To trigger
    the actual `INSERT` statement, we have to explicitly call `execute()`; pay attention
    to this aspect since jOOQ novices tend to forget this call at the end of the insert/update/delete
    expressions. This method returns the number of rows affected by this `INSERT`
    statement as an integer value (`0`), which means that nothing happened.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 通过 `insertInto()` 和 `values()` 方法支持 `INSERT ... VALUES`。可选地，我们可以使用 `columns()`
    方法来区分我们插入的表名和插入的字段/列列表。为了触发实际的 `INSERT` 语句，我们必须显式调用 `execute()`；请注意这个方面，因为 jOOQ
    新手往往会在插入/更新/删除表达式的末尾忘记这个调用。此方法返回受此 `INSERT` 语句影响的行数作为整数值（`0`），这意味着没有发生任何操作。
- en: 'For example, the following jOOQ type-safe expression will render an `INSERT`
    statement that can be successfully executed against at least MySQL, PostgreSQL,
    SQL Server, and Oracle (the primary key of the `ORDER` table, `ORDER.ORDER_ID`,
    is auto-generated, therefore, it can be omitted):'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下 jOOQ 类型安全的表达式将生成一个可以成功执行至少 MySQL、PostgreSQL、SQL Server 和 Oracle 的 `INSERT`
    语句（`ORDER` 表的主键 `ORDER.ORDER_ID` 是自动生成的，因此可以省略）：
- en: '[PRE271]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: 'Or, using `columns()`, it can be expressed like this:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用 `columns()`，可以这样表达：
- en: '[PRE279]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: 'If the entire list of columns/fields is omitted (for example, for verbosity
    reasons), then the jOOQ expression is non-type-safe and you have to explicitly
    specify a value for each field/column of the table, including for the field/column
    representing an auto-generated primary key and the fields/columns having default
    values, otherwise you''ll get an exception, as *the number of values must match
    the number of fields*. Moreover, you have to pay attention to the order of values;
    jOOQ matches the values to the fields only if you follow the order of arguments
    defined in the constructor of the `Record` class generated for the table in which
    we insert (for example, in this case, the order of arguments from the constructor
    of `OrderRecord`). As Lukas Eder adds, "*The* `Record` *constructor parameter
    order is also derived, like everything else, from the order of columns as declared
    in DDL, which is always the source of truth*." In this context, specifying an
    explicit dummy value for the auto-generated primary key (or other field) can rely
    on the almost universal (and standard SQL) way, SQL `DEFAULT`, or `DSL.default_()`/`DSL.defaultValue()`
    in jOOQ (attempting to use `NULL` instead of SQL `DEFAULT` produces implementation-specific
    behavior):'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略了整个列/字段列表（例如，出于简洁性的原因），那么 jOOQ 表达式是非类型安全的，你必须为表中的每个字段/列显式指定一个值，包括代表自动生成主键的字段/列以及具有默认值的字段/列，否则你会得到一个异常，因为“值的数量必须与字段的数量相匹配”。此外，你必须注意值的顺序；只有当你遵循为我们在其中插入的表生成的
    `Record` 类构造函数中定义的参数顺序时，jOOQ 才会将值与字段匹配（例如，在这个例子中，从 `OrderRecord` 构造函数的参数顺序）。正如卢卡斯·埃德补充说，“*`Record`
    构造函数参数的顺序也像其他所有东西一样，是从 DDL 中声明的列的顺序中派生出来的，这始终是真理的来源*。”在这种情况下，为自动生成的主键（或其他字段）指定显式虚拟值可以依赖于几乎普遍（和标准
    SQL）的方式，SQL `DEFAULT`，或者在 jOOQ 中使用 `DSL.default_()`/`DSL.defaultValue()`（尝试使用
    `NULL` 代替 SQL `DEFAULT` 会导致特定实现的行为）：
- en: '[PRE287]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: 'In PostgreSQL, we can use the `ORDER_SEQ.nextval()` call as well; `ORDER_SEQ`
    is the explicit sequence associated with the `ORDER` table:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PostgreSQL 中，我们还可以使用 `ORDER_SEQ.nextval()` 调用；`ORDER_SEQ` 是与 `ORDER` 表关联的显式序列：
- en: '[PRE293]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: Generally speaking, we can use the explicit or auto-assigned sequence (if the
    primary key is of the (`BIG`)`SERIAL` type) associated with the table and call
    the `nextval()` method. jOOQ defines a `currval()` method as well, representing
    the current value of the sequence.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，我们可以使用与表关联的显式或自动分配的序列（如果主键是 (`BIG`)`SERIAL` 类型），并调用 `nextval()` 方法。jOOQ
    还定义了一个 `currval()` 方法，表示序列的当前值。
- en: 'SQL Server is quite challenging because it cannot insert explicit values for
    the identity column when `IDENTITY_INSERT` is set to `OFF` ([https://github.com/jOOQ/jOOQ/issues/1818](https://github.com/jOOQ/jOOQ/issues/1818)).
    Until jOOQ comes up with an elegant workaround, you can rely on a batch of three
    queries: one query sets `IDENTITY_INSERT` to `ON`, one query is `INSERT`, and
    the last query sets `IDENTITY_INSERT` to `OFF`. But, even so, this is useful only
    for specifying an explicit valid primary key. The SQL `DEFAULT` or `NULL` values,
    or any other dummy values, are not allowed as explicit identity values. SQL Server
    will simply attempt to use the dummy value as the primary key and will end up
    with an error. As Lukas Eder said, "*In some other RDBMS you''d still get an exception
    if the auto-generated value is* `GENERATED ALWAYS AS IDENTITY` *(as opposed to*
    `GENERATED BY DEFAULT AS IDENTITY`*), and you''re trying to insert an explicit
    value*."'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: SQL Server 非常具有挑战性，因为它在将 `IDENTITY_INSERT` 设置为 `OFF` 时无法为标识列插入显式值 ([https://github.com/jOOQ/jOOQ/issues/1818](https://github.com/jOOQ/jOOQ/issues/1818))。在
    jOOQ 提供出优雅的解决方案之前，你可以依赖三个查询的批次：一个查询将 `IDENTITY_INSERT` 设置为 `ON`，一个查询是 `INSERT`，最后一个查询将
    `IDENTITY_INSERT` 设置为 `OFF`。但是，即便如此，这仅适用于指定显式有效的主键。不允许使用 SQL `DEFAULT` 或 `NULL`
    值，或任何其他虚拟值作为显式标识值。SQL Server 将简单地尝试使用虚拟值作为主键，并最终引发错误。正如卢卡斯·埃德所说，“*在其他一些 RDBMS
    中，如果你尝试插入一个显式值，即使自动生成的值是 *`GENERATED ALWAYS AS IDENTITY`*（与 *`GENERATED BY DEFAULT
    AS IDENTITY`* 相反），你仍然会得到一个异常*。”
- en: No matter whether the primary key is of an auto-generated type or not, if you
    specify it explicitly (manually) as a valid value (not a dummy and not a duplicate
    key), then `INSERT` succeeds in all these four databases (of course, in SQL Server,
    in the context of `IDENTITY_INSERT` set to `ON`).
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 无论主键是否为自动生成类型，如果你显式（手动）指定它为有效值（不是虚拟值也不是重复键），那么在这四个数据库中（当然，在 SQL Server 中，在 `IDENTITY_INSERT`
    设置为 `ON` 的上下文中）`INSERT` 操作都会成功。
- en: Important Note
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Omitting the column list was interesting to explain `DEFAULT` and identities/sequences,
    but it's really not recommended to omit the column list in `INSERT`. So, you'd
    better strive to use the column list.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 省略列列表对解释`DEFAULT`和标识符/序列很有趣，但真的不建议在`INSERT`中省略列列表。所以，你最好努力使用列列表。
- en: 'For inserting multiple rows, you can simply add a `values()` call per row in
    fluent style or use a loop to iterate a list of rows (typically, a list of records)
    and reuse the same `values()` call with different values. In the end, don''t forget
    to call `execute()`. This approach (and not only) is available in the bundled
    code. But, starting with jOOQ 3.15.0, this can be done via `valuesOfRecords()`
    or `valuesOfRows()`. For instance, consider a list of records:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 对于插入多行，你可以简单地为每行添加一个`values()`调用，以流畅的方式或使用循环遍历行列表（通常是记录列表）并重复使用相同的`values()`调用，但使用不同的值。最后，别忘了调用`execute()`。这种方法（以及更多）在捆绑代码中可用。但是，从jOOQ
    3.15.0版本开始，这可以通过`valuesOfRecords()`或`valuesOfRows()`来完成。例如，考虑一个记录列表：
- en: '[PRE299]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: 'We can insert this list into the database via `valuesOfRecords()` as follows:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`valuesOfRecords()`方法将此列表插入数据库，如下所示：
- en: '[PRE300]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: 'Here''s an example with a list of rows:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个包含行列表的示例：
- en: '[PRE303]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: 'This time, we can use `valuesOfRows()`:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们可以使用`valuesOfRows()`：
- en: '[PRE307]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: Whenever you need to collect data (for instance, POJOs) into a list or array
    of `RowN`, you can use the built-in `toRowList()` respectively `toRowArray()`
    collectors. You can find examples in the bundled code.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要将数据（例如，POJOs）收集到`RowN`的列表或数组中时，你可以使用内置的`toRowList()`或`toRowArray()`收集器。你可以在捆绑的代码中找到示例。
- en: 'In other thoughts, inserting `Record` can be done in several ways; for a quick
    reminder of jOOQ records, please revisit [*Chapter 3*](B16833_03.xhtml#_idTextAnchor040),
    *jOOQ Core Concepts*. For now, let''s insert the following `SaleRecord` corresponding
    to the `SALE` table:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他想法中，插入`Record`可以通过几种方式完成；为了快速回顾jOOQ记录，请重新阅读[*第3章*](B16833_03.xhtml#_idTextAnchor040)，*jOOQ核心概念*。现在，让我们插入以下与`SALE`表对应的`SaleRecord`：
- en: '[PRE313]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: 'To insert `sr`, we do the following:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 要插入`sr`，我们执行以下操作：
- en: '[PRE319]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: 'Or, we can do the following:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以这样做：
- en: '[PRE325]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: 'Or, we can even do the following:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们甚至可以这样做：
- en: '[PRE328]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: 'Or, we can attach the record to the current configuration via `attach()`:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以通过`attach()`方法将记录附加到当前配置：
- en: '[PRE329]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: 'Trying to insert a POJO requires us to wrap it first in the corresponding `Record`.
    This can be done via the `newRecord()` method, which can load a jOOQ-generated
    record from your POJO or the jOOQ-generated POJO. Here is an example for the jOOQ-generated
    `Sale` POJO:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试插入一个POJO需要我们首先将其包装在相应的`Record`中。这可以通过`newRecord()`方法完成，该方法可以从你的POJO或jOOQ生成的POJO中加载jOOQ生成的记录。以下是对jOOQ生成的`Sale`
    POJO的示例：
- en: '[PRE331]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: '[PRE333]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: 'Another approach relies on the handy `Record.from(POJO)` method, as follows
    (basically, this time you use an explicit instance of `SaleRecord`):'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法依赖于方便的`Record.from(POJO)`方法，如下所示（基本上，这次你使用`SaleRecord`的显式实例）：
- en: '[PRE335]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '`Record.from()` comes in several flavors that allow us to populate `Record`
    from an array or even `Map` of values.'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '`Record.from()`有几种风味，允许我们从数组或甚至值`Map`中填充`Record`。'
- en: 'Whenever you need to reset a `Record` primary key (or another field), call
    the `reset()` method as in the following scenario, which resets the manually assigned
    primary key and allows the database to generate one on our behalf:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要重置`Record`主键（或其他字段）时，可以像以下场景中那样调用`reset()`方法，这会重置手动分配的主键，并允许数据库代为生成一个：
- en: '[PRE338]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[PRE341]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: 'Nevertheless, the `reset()` method resets both the *changed* flag (which tracks
    record changes) and *value* (in this case, the primary key). If you want to reset
    only the value (primary key or another field), then you can rely on the `changed``(Field<?>
    field, boolean changed)` method as here:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`reset()`方法会重置*已更改*标志（跟踪记录更改）和*值*（在这种情况下，主键）。如果你想只重置值（主键或其他字段），那么你可以依赖`changed``(Field<?>
    field, boolean changed)`方法，如下所示：
- en: '[PRE345]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: Well, these were just a handful of examples. Many more, including using UDTs
    (in PostgreSQL and Oracle) and user-defined functions in `INSERT`, are available
    in the bundled code in the application named *InsertValues*. Next, let's talk
    about `INSERT ... SET`.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这些只是一些示例。更多示例，包括在PostgreSQL和Oracle中使用UDTs（用户定义类型）以及在`INSERT`中使用用户定义函数，可以在名为*InsertValues*的应用程序捆绑代码中找到。接下来，让我们谈谈`INSERT
    ... SET`。
- en: Expressing INSERT ... SET
  id: totrans-497
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表达INSERT ... SET
- en: '`INSERT ... SET` is an alternative to `INSERT ... VALUES`, having an `UPDATE`-like
    syntax, and is commonly used in MySQL (but not only so). Practically, instead
    of listing columns and values separately, in `INSERT ... SET`, we write field-value
    pairs via the `set(field, value)` method. This is more readable since we can easily
    identify the value of each field. Let''s look at an example of inserting two rows:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '`INSERT ... SET`是`INSERT ... VALUES`的替代方案，具有类似`UPDATE`的语法，并且在MySQL（但不仅限于此）中常用。实际上，在`INSERT
    ... SET`中，我们通过`set(field, value)`方法写入字段值对，这使得代码更易读，因为我们能轻松地识别每个字段的值。让我们看看插入两行数据的示例：'
- en: '[PRE346]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: '[PRE347]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '[PRE350]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[PRE351]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[PRE352]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: 'This syntax works for `Record` as well:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 此语法也适用于`Record`：
- en: '[PRE359]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: Since `INSERT … SET` and `INSERT … VALUES` are equivalent, jOOQ emulates `INSERT
    … SET` as `INSERT … VALUES` for all databases supported by jOOQ. The complete
    application is named *InsertSet*. Next, let's tackle the `INSERT ... RETURNING`
    syntax.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`INSERT … SET`和`INSERT … VALUES`是等效的，jOOQ将所有由jOOQ支持的数据库中的`INSERT … SET`模拟为`INSERT
    … VALUES`。完整的应用程序命名为*InsertSet*。接下来，让我们来处理`INSERT ... RETURNING`语法。
- en: Expressing INSERT ... RETURNING
  id: totrans-516
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表达INSERT ... RETURNING
- en: The particularity of `INSERT ... RETURNING` relies on the fact that it can return
    what was inserted (fetch back something that we need further). This may resume
    returning the primary key of the inserted row(s) or other fields as well (for
    instance, other sequences, default generated values, and trigger results). PostgreSQL
    has native support for `INSERT ... RETURNING`. Oracle also supports `INSERT ...
    RETURNING`, and jOOQ generates a PL/SQL anonymous block for it (not always). SQL
    Server supports `OUTPUT`, which is almost the same (apart from how trigger-generated
    values are affected). Other databases have poor support, and jOOQ has to emulate
    it on our behalf. In such cases, jOOQ relies on the JDBC `getGeneratedKeys()`
    method to retrieve the inserted primary keys. Moreover, if the generated primary
    keys (or other columns) cannot be retrieved directly, jOOQ may need to execute
    an additional `SELECT` to achieve this goal and this may lead to race conditions
    (for instance, such `SELECT` are needed in MySQL).
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '`INSERT ... RETURNING`的特殊之处在于它可以返回所插入的内容（检索我们需要进一步处理的内容）。这可能包括返回插入行的主键或其他字段（例如，其他序列、默认生成的值和触发器结果）。PostgreSQL原生支持`INSERT
    ... RETURNING`。Oracle也支持`INSERT ... RETURNING`，jOOQ会为其生成PL/SQL匿名块（不一定总是）。SQL Server支持`OUTPUT`，这与它几乎相同（除了触发器生成的值如何受影响）。其他数据库支持较差，jOOQ必须代表我们模拟它。在这种情况下，jOOQ依赖于JDBC的`getGeneratedKeys()`方法来检索插入的主键。此外，如果生成的主键（或其他列）不能直接检索，jOOQ可能需要执行额外的`SELECT`来达到这个目的，这可能导致竞争条件（例如，在MySQL中可能需要这样的`SELECT`）。'
- en: The jOOQ API for `INSERT ... RETURNING` contains the `returningResult()` method
    that comes in different flavors. It comes with different lists of arguments allowing
    us to specify which fields should be returned. If all fields should be returned,
    then simply use it without arguments. If only the primary key should be returned
    (being a popular use case for database auto-generated primary keys such us MySQL's
    `AUTO_INCREMENT` or PostgreSQL's (`BIG`)`SERIAL`, which automatically produces
    a sequence), then simply specify it as `returningResult(pk_field)`. If the primary
    key has multiple fields (a composite primary key), then list all of its fields
    separated by commas.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '`INSERT ... RETURNING`的jOOQ API包含`returningResult()`方法，它有多种形式。它带有不同的参数列表，允许我们指定应返回哪些字段。如果应返回所有字段，则无需参数直接使用它。如果只返回主键（这是一个流行的用例，例如MySQL的`AUTO_INCREMENT`或PostgreSQL的(`BIG`)`SERIAL`，这些会自动生成序列），则只需指定为`returningResult(pk_field)`。如果主键有多个字段（复合主键），则列出所有字段，字段之间用逗号分隔。'
- en: 'Here is an example that returns the primary key of a single insert:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个返回单个插入操作主键的示例：
- en: '[PRE361]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: '[PRE366]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: '[PRE367]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: 'Since there is a single result, we fetch it via the `fetchOne()` method. Fetching
    multiple primary keys can be done via `fetch()`, as follows:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只有一个结果，我们通过`fetchOne()`方法获取它。可以通过`fetch()`方法获取多个主键，如下所示：
- en: '[PRE368]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[PRE370]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[PRE371]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: '[PRE373]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[PRE374]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: 'This time, the returned result contains three primary keys. Returning more/other
    fields can be done as follows (the result looks like an *n-cols x n-rows* table):'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，返回的结果包含三个主键。返回更多/其他字段可以按以下方式完成（结果看起来像一个*n-列 x n-行*的表）：
- en: '[PRE377]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '[PRE379]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[PRE380]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: '[PRE381]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: '[PRE383]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[PRE384]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '[PRE385]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: 'Now, let''s look at a more interesting example. In our database schema, the
    `CUSTOMER` and `CUSTOMERDETAIL` tables are in a one-to-one relationship and share
    the primary key value. In other words, the `CUSTOMER` primary key is at the same
    time the primary key and foreign key in `CUSTOMERDETAIL`; this way, there is no
    need to maintain a separate foreign key. So, we have to use the `CUSTOMER` returned
    primary key for inserting the corresponding row in `CUSTOMERDETAIL`:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个更有趣的例子。在我们的数据库模式中，`CUSTOMER` 和 `CUSTOMERDETAIL` 表是单向一对一关系，并共享主键值。换句话说，`CUSTOMER`
    主键同时是 `CUSTOMERDETAIL` 中的主键和外键；这样，就没有必要维护单独的外键。因此，我们必须使用 `CUSTOMER` 返回的主键来插入 `CUSTOMERDETAIL`
    表中相应的行：
- en: '[PRE386]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '[PRE387]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '[PRE388]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '[PRE389]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: '[PRE391]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: '[PRE392]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: '[PRE393]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: If you are familiar with JPA, then you can recognize an elegant alternative
    to `@MapsId` here.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 JPA，那么你在这里可以认出一个优雅的 `@MapsId` 的替代方案。
- en: The first `INSERT` (inner `INSERT`) will insert a row in `CUSTOMER` and will
    return the generated primary key via `returningResult()`. Next, the second `INSERT`
    (outer `INSERT`) will insert a row in `CUSTOMERDETAIL` using this returned primary
    key as a value for the `CUSTOMERDETAIL.CUSTOMER_NUMBER` primary key.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `INSERT`（内部 `INSERT`）将在 `CUSTOMER` 表中插入一行，并通过 `returningResult()` 返回生成的主键。接下来，第二个
    `INSERT`（外部 `INSERT`）将使用此返回的主键作为 `CUSTOMERDETAIL.CUSTOMER_NUMBER` 主键的值，在 `CUSTOMERDETAIL`
    表中插入一行。
- en: Moreover, the `returningResult()` method can also return expressions such as
    `returningResult(A.concat(B).as("C"))`.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`returningResult()` 方法还可以返回表达式，例如 `returningResult(A.concat(B).as("C"))`。
- en: As usual, take your time and check out the bundled code, which comes with many
    more examples. The application is named *InsertReturning*. Next, let's talk about
    `INSERT ... DEFAULT VALUES`.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，花些时间检查附带代码，其中包含更多示例。应用程序命名为 *InsertReturning*。接下来，让我们谈谈 `INSERT ... DEFAULT
    VALUES`。
- en: Expressing INSERT ... DEFAULT VALUES
  id: totrans-560
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表达 INSERT ... DEFAULT VALUES
- en: 'The straightforward approach for inserting default values is to omit the fields
    having default values from `INSERT`. For example, look at the following code:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 插入默认值的直接方法是省略 `INSERT` 中具有默认值的字段。例如，看看以下代码：
- en: '[PRE394]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: '[PRE395]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: '[PRE397]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '[PRE398]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: '[PRE399]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '[PRE400]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: '[PRE401]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '[PRE402]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: The `PRODUCT` fields that are not listed (`PRODUCT_DESCRIPTION`, `PRODUCT_UID`,
    `SPECS`, and `QUANTITY_IN_STOCK`) will take advantage of implicit default values.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 未列出的 `PRODUCT` 字段（`PRODUCT_DESCRIPTION`、`PRODUCT_UID`、`SPECS` 和 `QUANTITY_IN_STOCK`）将利用隐式默认值。
- en: 'The jOOQ API comes with `defaultValues()`, `defaultValue()`, and `default_()`
    methods for explicitly pointing out the fields that should rely on default values.
    The former is useful for inserting a single row having only default values; if
    you check the database schema, you can notice that the `MANAGER` table has a default
    value for each of its columns:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ API 提供了 `defaultValues()`、`defaultValue()` 和 `default_()` 方法，用于显式指出应该依赖默认值的字段。前者用于插入只有默认值的单行；如果你检查数据库模式，你会注意到
    `MANAGER` 表的每一列都有一个默认值：
- en: '[PRE403]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: 'On the other hand, the `defaultValue()` method (or `default_()`) allows us
    to point to the fields that should rely on default values:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`defaultValue()` 方法（或 `default_()`）允许我们指向应该依赖默认值的字段：
- en: '[PRE404]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: '[PRE405]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '[PRE406]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: '[PRE407]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: '[PRE408]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: '[PRE409]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: '[PRE410]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: '[PRE411]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '[PRE412]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: '[PRE413]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '[PRE414]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: '[PRE415]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '[PRE416]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: '[PRE417]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: '[PRE418]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: '[PRE419]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: 'The non-type-safe version of this example is as follows:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的非类型安全版本如下：
- en: '[PRE420]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '[PRE421]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: '[PRE422]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: '[PRE423]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: '[PRE424]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: '[PRE425]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: '[PRE426]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: '[PRE427]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: '[PRE428]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: '[PRE429]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: '[PRE430]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: '[PRE431]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: '[PRE432]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: '[PRE433]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: '[PRE434]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: '[PRE435]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: 'The same result can be obtained by specifying the types of columns. For example,
    the previous `defaultValue(PRODUCT.QUANTITY_IN_STOCK)` calls can be written as
    follows:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定列的类型也可以得到相同的结果。例如，之前的 `defaultValue(PRODUCT.QUANTITY_IN_STOCK)` 调用可以写成以下形式：
- en: '[PRE436]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: 'Inserting `Record` with default values can be done quite simply, as in the
    following examples:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认值插入 `Record` 可以非常简单，如下面的示例所示：
- en: '[PRE437]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: '[PRE438]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: '[PRE439]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: Using default values is useful to fill up those fields that will be later updated
    (for example, via subsequent updates, trigger-generated values, and so on) or
    if we simply don't have values.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认值对于填充那些稍后将被更新（例如，通过后续更新、触发器生成的值等）的字段或如果我们根本没有值的情况非常有用。
- en: The complete application is named *InsertDefaultValues*. Next, let's talk about
    jOOQ and `UPDATE` statements.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序命名为 *InsertDefaultValues*。接下来，让我们谈谈 jOOQ 和 `UPDATE` 语句。
- en: Expressing UPDATE statements
  id: totrans-616
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达 UPDATE 语句
- en: In this section, we will express different kinds of updates, including `UPDATE
    ... SET`, `UPDATE ... FROM`, and `UPDATE ... RETURNING`, and update using row
    value expressions via the jOOQ DSL syntax. At the time of writing, jOOQ supports
    updates against a single table, while updates against multiple tables represent
    a work in progress task.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将表达不同类型的更新，包括 `UPDATE ... SET`、`UPDATE ... FROM` 和 `UPDATE ... RETURNING`，并通过
    jOOQ DSL 语法使用行值表达式进行更新。在撰写本文时，jOOQ 支持对单个表的更新，而对多个表的更新则是一个正在进行中的任务。
- en: Expressing UPDATE ... SET
  id: totrans-618
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表达 UPDATE ... SET
- en: 'The straightforward `UPDATE ... SET` statement can be expressed in jOOQ via
    the `set(field, value)` method, as in the following example (don''t forget to
    call `execute()` to trigger the update):'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 直接的 `UPDATE ... SET` 语句可以通过 `set(field, value)` 方法在 jOOQ 中表达，如下面的例子所示（不要忘记调用
    `execute()` 来触发更新）：
- en: '[PRE440]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: '[PRE441]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: '[PRE442]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: '[PRE443]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: '[PRE444]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: 'The rendered SQL for MySQL dialect will be as follows:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的针对 MySQL 语言的 SQL 将如下所示：
- en: '[PRE445]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: '[PRE446]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: '[PRE447]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: '[PRE448]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: Looks like a classic `UPDATE`, right? Notice that jOOQ automatically renders
    only the updated columns. If you are coming from JPA, then you know that Hibernate
    JPA renders, by default, all columns and we have to rely on `@DynamicUpdate` to
    obtain the same thing as jOOQ.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来像是一个经典的 `UPDATE`，对吧？注意 jOOQ 自动只渲染更新的列。如果你来自 JPA，那么你知道 Hibernate JPA 默认渲染所有列，而我们必须依赖于
    `@DynamicUpdate` 来获得与 jOOQ 相同的效果。
- en: 'Check out another example for increasing the employee salary by an amount computed
    based on their sales:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 查看一个基于员工销售额计算的增加员工工资的示例：
- en: '[PRE449]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: '[PRE450]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: '[PRE451]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: '[PRE452]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: '[PRE453]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: '[PRE454]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: 'And here is the generated SQL for SQL Server dialect:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是针对 SQL Server 方言生成的 SQL：
- en: '[PRE455]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: '[PRE456]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: '[PRE457]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: '[PRE458]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE458]'
- en: '[PRE459]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: '[PRE460]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: '[PRE461]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: 'Notice that this is an `UPDATE` without a `WHERE` clause and jOOQ will log
    a message as `A statement is executed without WHERE clause`. This is just friendly
    information that you can ignore if you have omitted the `WHERE` clause on purpose.
    But, if you know that this was not done on purpose, then you may want to avoid
    such situations by relying on the jOOQ `withExecuteUpdateWithoutWhere()` setting.
    You can choose from several behaviors including throwing an exception, as in this
    example:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这是一个没有 `WHERE` 子句的 `UPDATE`，jOOQ 会记录一条消息，例如 `A statement is executed without
    WHERE clause`。这只是友好的信息，如果你故意省略了 `WHERE` 子句，你可以忽略它。但是，如果你知道这不是故意为之，那么你可能想通过依赖 jOOQ
    的 `withExecuteUpdateWithoutWhere()` 设置来避免这种情况。你可以从几种行为中选择，包括抛出异常，就像这个例子中那样：
- en: '[PRE462]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: '[PRE463]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: '[PRE464]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: '[PRE465]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: '[PRE466]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: '[PRE467]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: '[PRE468]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: Notice that we use `Configuration.derive()`, not `Configuration.set()`, because
    if the `DSLContext` is injected, `Configuration` is global and shared. Using `Configuration.set()`
    will affect the global settings. If this is the desired behavior, then it is better
    to rely on a separate `@Bean`, as you already saw in this book.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用 `Configuration.derive()`，而不是 `Configuration.set()`，因为如果 `DSLContext`
    被注入，`Configuration` 是全局的和共享的。使用 `Configuration.set()` 将会影响全局设置。如果这是期望的行为，那么最好依赖于一个单独的
    `@Bean`，就像你在本书中已经看到的那样。
- en: This time, whenever we attempt to execute `UPDATE` without the `WHERE` clause,
    `UPDATE` doesn't take any action and jOOQ throws an exception of the `org.jooq.exception.DataAccessException`
    type.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，无论何时我们尝试执行没有 `WHERE` 子句的 `UPDATE`，`UPDATE` 都不会采取任何行动，并且 jOOQ 会抛出一个 `org.jooq.exception.DataAccessException`
    类型的异常。
- en: 'Updating `Record` is also quite simple. Check this out:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 `Record` 也很简单。看看这个例子：
- en: '[PRE469]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: '[PRE470]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: '[PRE471]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: '[PRE472]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: '[PRE473]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: '[PRE474]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: '[PRE475]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: '[PRE476]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: As you'll see in the bundled code, using `DSLContext.newRecord()` is also an
    option.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在捆绑的代码中所看到的，使用 `DSLContext.newRecord()` 也是一个选项。
- en: Expressing UPDATE using row value expressions
  id: totrans-666
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用行值表达式表达 UPDATE
- en: 'Updating using row value expressions is a very handy tool, and jOOQ expresses
    such updates in a very clean and intuitive way. Check out this example:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 使用行值表达式更新是一个非常实用的工具，jOOQ 以非常干净和直观的方式表达这样的更新。看看这个例子：
- en: '[PRE477]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: '[PRE478]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: '[PRE479]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: '[PRE480]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: '[PRE481]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: '[PRE482]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: '[PRE483]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: '[PRE484]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: 'The produced SQL for PostgreSQL is as follows:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的针对 PostgreSQL 的 SQL 如下所示：
- en: '[PRE485]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: '[PRE486]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE486]'
- en: '[PRE487]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE487]'
- en: '[PRE488]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE488]'
- en: '[PRE489]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE489]'
- en: '[PRE490]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE490]'
- en: 'Even if row value expressions are particularly useful for writing subselects,
    as in the previous example, it doesn''t mean that you cannot write the following:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 即使行值表达式特别适用于编写子查询，就像前面的例子中那样，这并不意味着你不能编写以下内容：
- en: '[PRE491]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE491]'
- en: '[PRE492]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE492]'
- en: '[PRE493]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE493]'
- en: '[PRE494]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE494]'
- en: '[PRE495]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE495]'
- en: 'This can be useful for reusing fields with minimum verbosity:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于重用具有最小冗余的字段很有用：
- en: '[PRE496]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE496]'
- en: '[PRE497]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE497]'
- en: '[PRE498]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE498]'
- en: '[PRE499]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE499]'
- en: Next, let's tackle the `UPDATE ... FROM` syntax.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来处理 `UPDATE ... FROM` 语法。
- en: Expressing UPDATE ... FROM
  id: totrans-695
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表达 UPDATE ... FROM
- en: 'Using the `UPDATE ... FROM` syntax, we can join additional tables to an `UPDATE`
    statement. Notice that this `FROM` clause is vendor-specific supported in PostgreSQL
    and SQL Server, but not supported in MySQL and Oracle (however, when you read
    this book, jOOQ may have already emulated this syntax, so check it out). Here
    is an example:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`UPDATE ... FROM`语法，我们可以将额外的表连接到`UPDATE`语句。请注意，这个`FROM`子句在PostgreSQL和SQL Server中是供应商特定的支持，但在MySQL和Oracle中不受支持（然而，当你阅读这本书时，jOOQ可能已经模拟了这个语法，所以请查看）。以下是一个示例：
- en: '[PRE500]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE500]'
- en: '[PRE501]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE501]'
- en: '[PRE502]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE502]'
- en: '[PRE503]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE503]'
- en: '[PRE504]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE504]'
- en: 'And the SQL rendered for PostgreSQL is as follows:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例展示了为PostgreSQL渲染的SQL：
- en: '[PRE505]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE505]'
- en: '[PRE506]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE506]'
- en: '[PRE507]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE507]'
- en: '[PRE508]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE508]'
- en: '[PRE509]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE509]'
- en: Finally, let's tackle the `UPDATE ... RETURNING` syntax.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来处理`UPDATE ... RETURNING`语法。
- en: Expressing UPDATE ... RETURNING
  id: totrans-709
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表达UPDATE ... RETURNING
- en: '`UPDATE ... RETURNING` is like `INSERT ... RETURNING` but for `UPDATE`. This
    is supported natively by PostgreSQL and is emulated by jOOQ for SQL Server and
    Oracle. In jOOQ DSL, we express `UPDATE ... RETURNING` via `returningResult()`
    as in the following example:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '`UPDATE ... RETURNING`类似于`INSERT ... RETURNING`，但用于`UPDATE`。这是PostgreSQL原生支持的，并由jOOQ在SQL
    Server和Oracle中模拟。在jOOQ DSL中，我们通过`returningResult()`来表示`UPDATE ... RETURNING`，如下面的示例所示：'
- en: '[PRE510]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE510]'
- en: '[PRE511]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE511]'
- en: '[PRE512]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE512]'
- en: '[PRE513]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE513]'
- en: '[PRE514]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE514]'
- en: '[PRE515]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE515]'
- en: 'The SQL rendered for PostgreSQL is shown next:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例展示了为PostgreSQL渲染的SQL：
- en: '[PRE516]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE516]'
- en: '[PRE517]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE517]'
- en: '[PRE518]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE518]'
- en: '[PRE519]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE519]'
- en: '[PRE520]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE520]'
- en: '[PRE521]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE521]'
- en: 'We can use `UPDATE ... RETURNING` for logically chaining multiple updates.
    For example, let''s assume that we want to increase the salary of an employee
    with the average of their sales and the credit limit of their customers with the
    returned salary multiplied by two. We can express these two `UPDATE` statements
    fluently via `UPDATE ... RETURNING` as follows:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`UPDATE ... RETURNING`来逻辑上链接多个更新。例如，假设我们想根据员工的平均销售额和客户的信用额度增加员工的薪水，并将返回的薪水乘以两倍。我们可以通过以下方式流畅地表达这两个`UPDATE`语句：
- en: '[PRE522]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE522]'
- en: '[PRE523]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE523]'
- en: '[PRE524]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE524]'
- en: '[PRE525]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE525]'
- en: '[PRE526]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE526]'
- en: '[PRE527]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE527]'
- en: '[PRE528]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE528]'
- en: '[PRE529]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE529]'
- en: '[PRE530]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE530]'
- en: '[PRE531]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE531]'
- en: '[PRE532]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE532]'
- en: '[PRE533]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE533]'
- en: '[PRE534]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE534]'
- en: '[PRE535]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE535]'
- en: However, pay attention to potential race conditions, given that there are two
    round trips hidden in what looks like a single query.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意潜在的竞争条件，因为在看似单个查询中隐藏了两次往返。
- en: Practicing this example and many others can be done via the application named
    *UpdateSamples*. Next, let's tackle the `DELETE` statement.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 通过名为*UpdateSamples*的应用程序练习这个示例和其他许多示例。接下来，让我们来处理`DELETE`语句。
- en: Expressing DELETE statements
  id: totrans-741
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达DELETE语句
- en: 'Expressing `DELETE` statements in jOOQ can be done via the `DSLContext.delete()`
    and `DSLContext.deleteFrom()` API or via `DSLContext.deleteQuery()` and `DSLContext.executeDelete()`,
    respectively. While the first three methods receive an argument of the `Table<R>`
    type, the `executeDelete()`method is useful for deleting a record as `TableRecord<?>`
    or `UpdatableRecord<?>`. As you can see from the following example, `delete()`
    and `deleteFrom()` work exactly the same:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 在jOOQ中表达`DELETE`语句可以通过`DSLContext.delete()`和`DSLContext.deleteFrom()` API，或者通过`DSLContext.deleteQuery()`和`DSLContext.executeDelete()`来实现。虽然前三种方法接收`Table<R>`类型的参数，但`executeDelete()`方法对于将记录作为`TableRecord<?>`或`UpdatableRecord<?>`删除非常有用。正如以下示例所示，`delete()`和`deleteFrom()`的工作方式完全相同：
- en: '[PRE536]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE536]'
- en: '[PRE537]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE537]'
- en: '[PRE538]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE538]'
- en: '[PRE539]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE539]'
- en: '[PRE540]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE540]'
- en: '[PRE541]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE541]'
- en: 'Both of these expressions render this SQL:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个表达式都渲染出以下SQL：
- en: '[PRE542]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE542]'
- en: '[PRE543]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE543]'
- en: 'Combining `DELETE` and row value expressions is useful for deleting via subselects,
    as in the following example:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 将`DELETE`和行值表达式结合使用对于通过子查询删除非常有用，如下面的示例所示：
- en: '[PRE544]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE544]'
- en: '[PRE545]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE545]'
- en: '[PRE546]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE546]'
- en: '[PRE547]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE547]'
- en: '[PRE548]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE548]'
- en: '[PRE549]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE549]'
- en: '[PRE550]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE550]'
- en: One important aspect of `DELETE` resumes to cascading deletion from parent to
    child. Whenever possible, it is a good idea to rely on database support for accomplishing
    `DELETE` cascading tasks. For example, you can use `ON DELETE CASCADE` or a stored
    procedure that implements the cascading deletion logic. As Lukas Eder highlights,
    "*The rule of thumb is to* `CASCADE` *compositions (UML speak) and to* `RESTRICT`
    *or* `NO ACTION`*, or* `SET NULL` *(if supported) aggregations. In other words,
    if the child cannot live without the parent (composition), then delete it with
    the parent. Otherwise, raise an exception (*`RESTRICT`*,* `NO ACTION`*), or set
    the reference to* `NULL`*. jOOQ might support* `DELETE ... CASCADE` *in the future:*
    [https://github.com/jOOQ/jOOQ/issues/7367](https://github.com/jOOQ/jOOQ/issues/7367)."
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '`DELETE`的一个重要方面是从父表到子表的级联删除。在可能的情况下，依靠数据库支持来完成`DELETE`级联任务是一个好主意。例如，你可以使用`ON
    DELETE CASCADE`或实现级联删除逻辑的存储过程。正如Lukas Eder强调的，“一般来说，应该*级联*组合（UML术语）和*限制*或*无操作*，或者*设置为NULL*（如果支持）聚合。换句话说，如果子表不能没有父表（组合）而存在，那么就与父表一起删除它。否则，抛出异常（*限制*、*无操作*），或将引用设置为*NULL*。jOOQ可能在将来支持*DELETE
    ... CASCADE*：[https://github.com/jOOQ/jOOQ/issues/7367](https://github.com/jOOQ/jOOQ/issues/7367)。'
- en: 'However, if none of these approaches are possible, then you can do it via jOOQ
    as well. You can write a chain of separate `DELETE` statements or rely on `DELETE
    ... RETURNING` as in the following examples, which delete `PRODUCTLINE` via cascading
    (`PRODUCTLINE` – `PRODUCTLINEDETAIL` – `PRODUCT` – `ORDERDETAIL`). In order to
    delete `PRODUCTLINE`, we have to delete all its products from `PRODUCT` and the
    corresponding record from `PRODUCTLINEDETAIL`. To delete all products of `PRODUCTLINE`
    from `PRODUCT`, we have to delete all references for these products from `ORDERDETAIL`.
    So, we start deleting from `ORDERDETAIL`, as follows:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果上述任何方法都不可行，那么您也可以通过 jOOQ 来完成。您可以编写一系列单独的 `DELETE` 语句，或者依赖于 `DELETE ...
    RETURNING`，如下面的示例所示，这些示例通过级联（`PRODUCTLINE` – `PRODUCTLINEDETAIL` – `PRODUCT` –
    `ORDERDETAIL`）删除 `PRODUCTLINE`。为了删除 `PRODUCTLINE`，我们必须从 `PRODUCT` 中删除所有其产品，并从
    `PRODUCTLINEDETAIL` 中删除相应的记录。为了从 `PRODUCT` 中删除 `PRODUCTLINE` 的所有产品，我们必须删除这些产品的所有引用从
    `ORDERDETAIL` 中。因此，我们从 `ORDERDETAIL` 开始删除，如下所示：
- en: '[PRE551]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE551]'
- en: '[PRE552]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE552]'
- en: '[PRE553]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE553]'
- en: '[PRE554]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE554]'
- en: '[PRE555]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE555]'
- en: '[PRE556]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE556]'
- en: '[PRE557]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE557]'
- en: '[PRE558]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE558]'
- en: '[PRE559]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE559]'
- en: '[PRE560]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE560]'
- en: '[PRE561]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE561]'
- en: '[PRE562]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE562]'
- en: '[PRE563]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE563]'
- en: '[PRE564]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE564]'
- en: '[PRE565]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE565]'
- en: '[PRE566]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE566]'
- en: This jOOQ fluent expression renders four `DELETE` statements, which you can
    check in the bundled code. The challenge here consists of guaranteeing the roll-back
    functionality if something goes wrong. But, having the jOOQ expression in a Spring
    Boot `@Transactional` method, the roll-back functionality is out of the box. This
    is much better than the JPA cascading via `CascadeType.REMOVE` or `orphanRemoval=true`,
    which are very prone to *N + 1* issues. jOOQ allows us to control both what is
    deleted, and how this takes place.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 jOOQ 流畅表达式生成了四个 `DELETE` 语句，您可以在捆绑的代码中检查。这里的挑战在于确保在出错时能够保证回滚功能。但是，在 Spring
    Boot `@Transactional` 方法中拥有 jOOQ 表达式，回滚功能是现成的。这比通过 `CascadeType.REMOVE` 或 `orphanRemoval=true`
    的 JPA 级联要好得多，这些方法非常容易引发 *N + 1* 问题。jOOQ 允许我们控制要删除的内容以及如何进行删除。
- en: 'In other thoughts, deleting `Record` (`TableRecord` or `UpdatableRecord`) can
    be done via `executeDelete()`, as in the following examples:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他方面，删除 `Record` (`TableRecord` 或 `UpdatableRecord`) 可以通过 `executeDelete()`
    来完成，如下面的示例所示：
- en: '[PRE567]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE567]'
- en: '[PRE568]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE568]'
- en: '[PRE569]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE569]'
- en: '[PRE570]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE570]'
- en: '[PRE571]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE571]'
- en: '[PRE572]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE572]'
- en: '[PRE573]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE573]'
- en: '[PRE574]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE574]'
- en: '[PRE575]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE575]'
- en: Exactly as in the case of `UPDATE`, if we attempt to perform `DELETE` without
    a `WHERE` clause, then jOOQ will inform us in a friendly way via a message. We
    can take control of what should happen in such cases via the `withExecuteDeleteWithoutWhere()`
    setting.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在 `UPDATE` 的情况下，如果我们尝试在没有 `WHERE` 子句的情况下执行 `DELETE`，那么 jOOQ 将通过一条友好的消息通知我们。我们可以通过
    `withExecuteDeleteWithoutWhere()` 设置来控制在这种情况下应该发生什么。
- en: In the bundled code, you can see `withExecuteDeleteWithoutWhere()` next to many
    other examples that have not been listed here. The complete application is named
    *DeleteSamples*. Next, let's talk about `MERGE` statements.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，您可以看到 `withExecuteDeleteWithoutWhere()` 在许多其他未在此列出的示例旁边。整个应用程序被命名为 *DeleteSamples*。接下来，让我们来谈谈
    `MERGE` 语句。
- en: Expressing MERGE statements
  id: totrans-791
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达 MERGE 语句
- en: 'The `MERGE` statement is quite a powerful tool; it allows us to perform `INSERT`/`UPDATE`
    and even `DELETE` on a table known as the *target table* from a table known as
    the *source table*. I strongly suggest you read this article, especially if you
    need a quick reminder of the `MERGE` statement: [https://blog.jooq.org/2020/04/10/the-many-flavours-of-the-arcane-sql-merge-statement/](https://blog.jooq.org/2020/04/10/the-many-flavours-of-the-arcane-sql-merge-statement/).'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: '`MERGE` 语句是一个非常强大的工具；它允许我们从称为 *目标表* 的表执行 `INSERT`/`UPDATE` 以及甚至 `DELETE` 操作，这个表是从称为
    *源表* 的表中来的。我强烈建议您阅读这篇文章，尤其是如果您需要快速回顾 `MERGE` 语句的话：[https://blog.jooq.org/2020/04/10/the-many-flavours-of-the-arcane-sql-merge-statement/](https://blog.jooq.org/2020/04/10/the-many-flavours-of-the-arcane-sql-merge-statement/).'
- en: MySQL and PostgreSQL support a `MERGE` flavor known as `UPSERT` (`INSERT` or
    `UPDATE`) via `ON DUPLICATE KEY UPDATE`, respectively via `ON CONFLICT DO UPDATE`
    clauses. You can find examples of these statements next to the well-known `INSERT
    IGNORE INTO` (MySQL) and `ON CONFLICT DO NOTHING` (PostgreSQL) clauses in the
    code bundled with this book. By the way, we can use all these statements interchangeably
    (for example, we can use `onConflictDoNothing()` with MySQL and `onDuplicateKeyIgnore()`
    with PostgreSQL), since jOOQ will always emulate the correct syntax. We can even
    use them with SQL Server and Oracle, as jOOQ will emulate them via the `MERGE
    INTO` syntax.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 和 PostgreSQL 通过 `ON DUPLICATE KEY UPDATE`（MySQL）和 `ON CONFLICT DO UPDATE`（PostgreSQL）子句分别支持一个名为
    `UPSERT` 的 `MERGE` 风味（`INSERT` 或 `UPDATE`）。您可以在本书捆绑的代码中找到这些语句的示例，这些示例位于众所周知的 `INSERT
    IGNORE INTO`（MySQL）和 `ON CONFLICT DO NOTHING`（PostgreSQL）子句旁边。顺便说一句，我们可以互换使用所有这些语句（例如，我们可以使用
    `onConflictDoNothing()` 与 MySQL，使用 `onDuplicateKeyIgnore()` 与 PostgreSQL），因为 jOOQ
    总是会模拟正确的语法。我们甚至可以使用 SQL Server 和 Oracle，因为 jOOQ 会通过 `MERGE INTO` 语法来模拟它们。
- en: 'SQL Server and Oracle have support for `MERGE INTO` with different additional
    clauses. Here is an example of exploiting the `WHEN MATCHED THEN UPDATE` (jOOQ
    `whenMatchedThenUpdate()`) and `WHEN NOT MATCHED THEN INSERT` (jOOQ `whenNotMatchedThenInsert()`)
    clauses:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: SQL Server 和 Oracle 支持 `MERGE INTO` 与不同的附加子句。以下是一个利用 `WHEN MATCHED THEN UPDATE`（jOOQ
    `whenMatchedThenUpdate()`）和 `WHEN NOT MATCHED THEN INSERT`（jOOQ `whenNotMatchedThenInsert()`）子句的示例：
- en: '[PRE576]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE576]'
- en: '[PRE577]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE577]'
- en: '[PRE578]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE578]'
- en: '[PRE579]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE579]'
- en: '[PRE580]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE580]'
- en: '[PRE581]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE581]'
- en: '[PRE582]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE582]'
- en: '[PRE583]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE583]'
- en: '[PRE584]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE584]'
- en: 'The rendered SQL for the SQL Server dialect is as follows:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: SQL Server 方言的渲染 SQL 如下所示：
- en: '[PRE585]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE585]'
- en: '[PRE586]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE586]'
- en: '[PRE587]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE587]'
- en: '[PRE588]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE588]'
- en: '[PRE589]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE589]'
- en: '[PRE590]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE590]'
- en: '[PRE591]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE591]'
- en: '[PRE592]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE592]'
- en: '[PRE593]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE593]'
- en: 'Now, let''s look at another example using the `WHEN MATCHED THEN DELETE` (jOOQ
    `whenMatchedThenDelete()`) and `WHEN NOT MATCHED THEN INSERT` (jOOQ `whenNotMatchedThenInsert()`)
    clauses:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看另一个使用 `WHEN MATCHED THEN DELETE`（jOOQ `whenMatchedThenDelete()`）和 `WHEN
    NOT MATCHED THEN INSERT`（jOOQ `whenNotMatchedThenInsert()`）子句的示例：
- en: '[PRE594]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE594]'
- en: '[PRE595]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE595]'
- en: '[PRE596]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE596]'
- en: '[PRE597]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE597]'
- en: '[PRE598]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE598]'
- en: '[PRE599]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE599]'
- en: '[PRE600]'
  id: totrans-821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE600]'
- en: '[PRE601]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE601]'
- en: '[PRE602]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE602]'
- en: '[PRE603]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE603]'
- en: '[PRE604]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE604]'
- en: 'This works flawlessly in SQL Server, but it doesn''t work in Oracle because
    Oracle doesn''t support the `WHEN MATCHED THEN DELETE` clause. But, we can easily
    obtain the same result by combining `WHEN MATCHED THEN UPDATE` with `DELETE WHERE`
    (obtained via the jOOQ `thenDelete()`) clause. This works because, in Oracle,
    you can add a `DELETE WHERE` clause, but only together with an `UPDATE`:'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 SQL Server 中工作得非常完美，但在 Oracle 中不起作用，因为 Oracle 不支持 `WHEN MATCHED THEN DELETE`
    子句。但是，我们可以通过将 `WHEN MATCHED THEN UPDATE` 与 `DELETE WHERE`（通过 jOOQ 的 `thenDelete()`
    获得）子句结合起来轻松地获得相同的结果。这是因为，在 Oracle 中，您可以添加 `DELETE WHERE` 子句，但只能与 `UPDATE` 一起使用：
- en: '[PRE605]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE605]'
- en: '[PRE606]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE606]'
- en: '[PRE607]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE607]'
- en: '[PRE608]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE608]'
- en: '[PRE609]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE609]'
- en: '[PRE610]'
  id: totrans-832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE610]'
- en: '[PRE611]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE611]'
- en: '[PRE612]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE612]'
- en: '[PRE613]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE613]'
- en: '[PRE614]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE614]'
- en: '[PRE615]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE615]'
- en: '[PRE616]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE616]'
- en: '[PRE617]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE617]'
- en: '`WHEN MATCHED THEN UPDATE` is obtained via jOOQ''s `whenMatchedAnd()`; this
    is the jOOQ implementation for the `WHEN MATCHED AND <some predicate> THEN` clause,
    but in this case, it is rendered as `WHEN MATCHED THEN UPDATE`.'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: '`WHEN MATCHED THEN UPDATE` 是通过 jOOQ 的 `whenMatchedAnd()` 获得的；这是 jOOQ 对 `WHEN
    MATCHED AND <some predicate> THEN` 子句的实现，但在此情况下，它被表示为 `WHEN MATCHED THEN UPDATE`。'
- en: 'Using the `DELETE WHERE` clause in SQL Server and in Oracle works the same.
    An important aspect of using the `DELETE WHERE` clause consists of which table
    the `DELETE WHERE` clause references. This clause can target the rows before or
    after an update. The following `MERGE` example updates all the rows in the *target
    table* that have a matching row in the *source table*. The `DELETE WHERE` clause
    deletes only those rows that were matched by `UPDATE` (this is `DELETE` after
    `UPDATE`):'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL Server 和 Oracle 中使用 `DELETE WHERE` 子句的效果相同。使用 `DELETE WHERE` 子句的一个重要方面是它引用的是哪个表。此子句可以针对更新前或更新后的行。以下
    `MERGE` 示例更新了目标表中所有在源表中具有匹配行的行。`DELETE WHERE` 子句仅删除那些由 `UPDATE` 匹配的行（这是 `UPDATE`
    之后的 `DELETE`）：
- en: '[PRE618]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE618]'
- en: '[PRE619]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE619]'
- en: '[PRE620]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE620]'
- en: '[PRE621]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE621]'
- en: '[PRE622]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE622]'
- en: '[PRE623]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE623]'
- en: '[PRE624]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE624]'
- en: '[PRE625]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE625]'
- en: 'The following example shows that `DELETE WHERE` can match against values of
    the rows before `UPDATE` as well. This time, `DELETE WHERE` references the *source
    table*, so the status is checked against the source not against the result of
    `UPDATE` (this is `DELETE` before `UPDATE`):'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示 `DELETE WHERE` 可以匹配更新之前的行的值。这次，`DELETE WHERE` 引用了 *源表*，因此状态是针对源而不是针对
    `UPDATE` 的结果进行检查（这是 `UPDATE` 之前的 `DELETE`）：
- en: '[PRE626]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE626]'
- en: '[PRE627]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE627]'
- en: '[PRE628]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE628]'
- en: '[PRE629]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE629]'
- en: '[PRE630]'
  id: totrans-855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE630]'
- en: '[PRE631]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE631]'
- en: '[PRE632]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE632]'
- en: '[PRE633]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE633]'
- en: In the bundled code, you can practice more examples. The application is named
    *MergeSamples*.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，您可以练习更多示例。应用程序命名为 *MergeSamples*。
- en: Summary
  id: totrans-860
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter is a comprehensive resource for examples of expressing popular
    `SELECT`, `INSERT`, `UPDATE`, `DELETE`, and `MERGE` statements in the jOOQ DSL
    syntax relying on the Java-based schema.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是表达 jOOQ DSL 语法中流行的 `SELECT`、`INSERT`、`UPDATE`、`DELETE` 和 `MERGE` 语句的全面资源，依赖于基于
    Java 的模式。
- en: For brevity, we couldn't list all the examples here, but I strongly recommend
    you take each application and practice the examples against your favorite database.
    The main goal is to get you familiar with the jOOQ syntax and to become capable
    of expressing any plain SQL via the jOOQ API in a productive amount of time.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁，我们无法在此列出所有示例，但我强烈建议您针对您最喜欢的数据库对每个应用程序进行练习。主要目标是让您熟悉 jOOQ 语法，并能够在短时间内通过
    jOOQ API 表达任何 plain SQL。
- en: 'In the next chapter, we continue this adventure with a very exciting topic:
    expressing `JOIN` in jOOQ.'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续这个冒险，探讨一个非常激动人心的主题：在 jOOQ 中表达 `JOIN`。
