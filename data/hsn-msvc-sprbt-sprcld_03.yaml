- en: Introduction to Spring Boot
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Spring Boot
- en: In this chapter, we will be introduced to how to build a set of cooperating
    microservices using Spring Boot, focusing on how to develop functionality that
    delivers business value. The challenges that we pointed out in the previous chapter
    will be considered only to some degree, but they will be addressed to their full
    extent in later chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍如何使用Spring Boot构建一套协同工作的微服务，重点是如何开发具有业务价值的功能。我们在上一章中指出的挑战只会考虑一部分，但它们将在后面的章节中得到全面解决。
- en: We will develop microservices that contain business logic based on plain Spring
    Beans and REST APIs using Spring WebFlux, the Swagger/OpenAPI-based documentation
    of the REST APIs, and SpringFox and data persistence, while using Spring Data
    to store data in both SQL and NoSQL databases
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Spring WebFlux、基于Swagger/OpenAPI的REST API文档和SpringFox以及数据持久性，开发包含业务逻辑的微服务，同时使用Spring
    Data将数据存储在SQL和NoSQL数据库中。
- en: Since Spring Boot v2.0 was released in March 2018, it has become much easier
    to develop reactive microservices (refer to [Chapter 1](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml), *Introduction
    to Microservices*, the *Reactive mi**croservices* section for more information).
    Therefore, we will also cover how to create reactive microservices in this chapter,
    including both non-blocking synchronous REST APIs and message-based asynchronous
    services. We will use Spring WebFlux to develop non-blocking synchronous REST
    APIs and Spring Cloud Stream to develop message-based asynchronous services.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Spring Boot v2.0于2018年3日发布以来，开发响应式微服务变得容易多了（参考[第1章](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml)，*微服务介绍*，*响应式微服务*部分以获取更多信息）。因此，我们也将介绍如何在本章创建响应式微服务，包括非阻塞同步REST
    API和基于消息的异步服务。我们将使用Spring WebFlux开发非阻塞同步REST API和Spring Cloud Stream开发基于消息的异步服务。
- en: Finally, we will use Docker to run our microservices as containers. This will
    allow us to start and stop our microservice landscape, including database servers
    and a message broker, with a single command.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用Docker将我们的微服务作为容器运行。这将允许我们用一个命令启动和停止我们的微服务景观，包括数据库服务器和消息代理。
- en: That's a lot of technologies and frameworks, so let's go through each of them
    briefly to see what they are about!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这是很多技术和框架，所以我们简要地看看它们都是关于什么！
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Learning about Spring Boot
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习Spring Boot
- en: Beginning with Spring WebFlux
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Spring WebFlux开始
- en: Exploring SpringFox
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索SpringFox
- en: Understanding Spring Data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Spring Data
- en: Understanding Spring Cloud Stream
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Spring Cloud Stream
- en: Learning about Docker
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习关于Docker的内容
- en: More details about each product will be provided in upcoming chapters.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 关于每个产品的更多详细信息将在接下来的章节中提供。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter does not contain any source code that can be downloaded, nor does
    it require any tools to be installed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不包含可以下载的源代码，也不需要安装任何工具。
- en: Learning about Spring Boot
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习Spring Boot
- en: Spring Boot, and the Spring Framework that Spring Boot is based on, is a great
    framework for developing microservices in Java.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot以及Spring Boot基于的Spring Framework，是用于在Java中开发微服务的好框架。
- en: When the Spring Framework was released in v1.0 back in 2004, it was released
    in order to fix the overly complex **J2EE** standard (short for **Java 2 Platforms,
    Enterprise Edition**) with its infamous and heavyweight deployment descriptors.
    Spring Framework provided a much more lightweight development model based on the
    concept of **dependency injection** (**DI**). Spring Framework also used far more
    lightweight XML configuration files compared to the deployment descriptors in
    J2EE.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当Spring Framework在2004年发布v1.0时，它是为了修复过于复杂的J2EE标准（Java 2 Platforms, Enterprise
    Edition的缩写）而发布的，其臭名昭著的部署描述符非常繁重。Spring Framework提供了一种基于依赖注入（DI）概念的更轻量级开发模型。与J2EE中的部署描述符相比，Spring
    Framework还使用了更轻量的XML配置文件。
- en: 'To make things even worse with the J2EE standard, the heavyweight deployment
    descriptors actually came in two types:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 至于J2EE标准，更糟糕的是，重量级的部署描述符实际上分为两种类型：
- en: Standard deployment descriptors, describing the configuration in a standardized
    way
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准部署描述符，以标准方式描述配置
- en: Vendor-specific deployment descriptors, mapping the configuration to vendor-specific
    features in the vendor's application server
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定于供应商的部署描述符，将配置映射到供应商特定应用服务器中的供应商特定功能
- en: J2EE was renamed in 2006 to **Java EE**, short for **Java Platform, Enterprise
    Edition**, and recently, Oracle submitted Jave EE to the Eclipse foundation. In
    February 2018, Java EE was renamed Jakarta EE.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 2006年，J2EE被重新命名为**Java EE**，即**Java Platform, Enterprise Edition**，最近，Oracle将Jave
    EE提交给了Eclipse基金会。2018年2月，Java EE被重新命名为Jakarta EE。
- en: Over the years, while the Spring Framework gained increasing popularity, the
    functionality in the Spring Framework grew significantly. Slowly, the burden of
    setting up a Spring application using the no-longer-so-lightweight XML configuration
    file became a problem.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，尽管Spring Framework越来越受欢迎，其功能也显著增长。慢慢地，使用不再那么轻量级的XML配置文件来设置Spring应用程序的负担变得成为一个问题。
- en: In 2014, Spring Boot v1.0 was released, addressing these problems!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 2014年，Spring Boot 1.0版本发布，解决了这些问题！
- en: Convention over configuration and fat JAR files
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 约定优于配置和胖JAR文件
- en: Spring Boot targets the fast development of production-ready Spring applications
    by being strongly opinionated about how to set up both core modules from the Spring
    Framework and third-party products, such as libraries that are used for logging
    or connecting to a database. Spring Boot does that by applying a number of conventions
    by default, minimizing the need for configuration. Whenever required, each convention
    can be overridden by writing some configuration, case by case. This design pattern
    is known as **convention over configuration** and minimizes the need for initial
    configuration.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot通过强烈地规定了如何设置Spring Framework的核心模块以及第三方产品，如用于日志记录或连接数据库的库，从而快速开发生产就绪的Spring应用程序。Spring
    Boot通过默认应用一系列约定并最小化配置需求来实现这一点。每当需要时，每个约定都可以通过编写一些配置来个别覆盖。这种设计模式被称为**约定优于配置**，并最小化了初始配置的需求。
- en: Configuration, when required, is in my opinion written best using Java and annotations.
    The good old XML-based configuration files can still be used, although they are
    significantly smaller than before Spring Boot was introduced.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要配置时，我认为最好使用Java和注解来编写配置。虽然它们比Spring Boot出现之前的要小得多，但仍然可以使用那些基于XML的古老配置文件。
- en: Added to the usage of *c**onvention over configuration*, Spring Boot also favors
    a runtime model based on a standalone JAR file, also known as a fat JAR file.
    Before Spring Boot, the most common way to run a Spring application was to deploy
    it as a WAR file on a Java EE web server, such as Apache Tomcat. WAR file deployment
    is still supported by Spring Boot.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用*c**onvention over configuration*之外，Spring Boot还倾向于一个基于独立JAR文件的运行时模型，也称为胖JAR文件。在Spring
    Boot之前，运行Spring应用程序最常见的方式是将它部署为Apache Tomcat等Java EE网络服务器上的WAR文件。Spring Boot仍然支持WAR文件部署。
- en: A fat JAR file contains not only the classes and resource files of the application
    itself, but also all the `.jar` files the application depends on. This means that
    the fat JAR file is the only JAR file required to run the application; that is,
    we only need to transfer one JAR file to an environment where we want to run the
    application instead of transferring the application's JAR file along with all
    the JAR files the application depends on.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一个胖JAR文件不仅包含应用程序自身的类和资源文件，还包括应用程序所依赖的所有`.jar`文件。这意味着胖JAR文件是运行应用程序所需的唯一JAR文件；也就是说，我们只需要将一个JAR文件传输到我们想要运行应用程序的环境中，而不是将应用程序的JAR文件及其依赖的所有JAR文件一起传输。
- en: Starting a fat JAR requires no separately installed Java EE web server, such
    as Apache Tomcat. Instead, it can be started with a simple command such as `java
    -jar app.jar`, making it a perfect choice for running in a Docker container! If
    the Spring Boot application uses HTTP, for example, to expose a REST API, it will
    contain an embedded web server.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 启动胖JAR不需要安装单独的Java EE网络服务器，如Apache Tomcat。相反，可以使用简单的命令如`java -jar app.jar`来启动，这使它成为在Docker容器中运行的理想选择！如果Spring
    Boot应用程序使用HTTP，例如，暴露一个REST API，它将包含一个内嵌的网络服务器。
- en: Code examples for setting up a Spring Boot application
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Spring Boot应用程序的代码示例
- en: To better understand what this means, let's look at some source code examples.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这意味着什么，让我们看看一些源代码示例。
- en: We will only look at some small fragments of code here to point out the main
    features. For a fully working example, you'll have to wait until the next chapter!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们只看一些代码片段来指出主要特性。要看到一个完全可工作的示例，您必须等到下一章！
- en: The magic @SpringBootApplication annotation
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 神奇的@SpringBootApplication注解
- en: 'The convention-based autoconfiguration mechanism can be initiated by annotating
    the application class, that is, the class that contains the static `main` method, 
    with the `@SpringBootApplication` annotation. The following code shows this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 基于约定的自动配置机制可以通过注解应用程序类来启动，即包含静态`main`方法的类，用`@SpringBootApplication`注解。以下代码显示了这一点：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following functionality will be provided by this annotation:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下功能将由此注解提供：
- en: It enables component scanning, that is, looking for Spring components and configuration
    classes in the package of the application class and all its sub-packages.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持组件扫描，即在应用程序类的包及其所有子包中查找Spring组件和配置类。
- en: The application class itself becomes a configuration class.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序类本身成为一个配置类。
- en: It enables autoconfiguration, where Spring Boot looks for JAR files in the classpath
    that it can configure automatically. If you, for example, have Tomcat in the classpath,
    Spring Boot will automatically configure Tomcat as an embedded web server.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持自动配置，其中Spring Boot在类路径中查找可以自动配置的JAR文件。例如，如果你在类路径中有Tomcat，Spring Boot将自动将Tomcat配置为内嵌web服务器。
- en: Component scanning
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件扫描
- en: 'Let''s assume we have the following Spring component in the package of the
    application class (or in one of its sub-packages):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在应用程序类的包（或其子包之一）中有一个Spring组件：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Another component in the application can get the component automatically injected,
    also known as **auto-wiring**, using the `@Autowired` annotation:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中的另一个组件可以自动导入组件，也称为**自动焊接**，使用`@Autowired`注解：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: I prefer using constructor injection (over field and setter injection) to keep
    the state in my components immutable. The immutable state is important if you
    want to be able to run the component in a multithreaded runtime environment.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢使用构造函数注入（而不是字段和设置器注入）来保持组件状态不可变。不可变的州对于希望在多线程运行时环境中运行组件很重要。
- en: 'If we want to use components that are declared in a package outside the applications
    package, for example, a utility component shared by multiple Spring Boot applications,
    we can complement the `@SpringBootApplication` annotation in the application class
    with a `@ComponentScan` annotation:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使用声明在应用程序包之外的包中的组件，例如，被多个Spring Boot应用程序共享的实用组件，我们可以在应用程序类中的`@SpringBootApplication`注解补充一个`@ComponentScan`注解：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can now auto-wire components from the `se.magnus.util` package in the application
    code, for example, a utility component, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在应用程序代码中自动导入`se.magnus.util`包的组件，例如，如下所示的一个实用组件：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This utility component can be auto-wired in an application component like so:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实用组件可以这样在应用程序组件中自动导入：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Java-based configuration
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于Java的配置
- en: If we want to override Spring Boot's default configuration or if we want to
    add our own configuration, we can simply annotate a class with `@Configuration` and
    it will be picked up by the component scanning mechanism we described previously.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要覆盖Spring Boot的默认配置，或者如果我们想要添加自己的配置，我们只需用`@Configuration`注解一个类，它将被我们之前描述的组件扫描机制找到。
- en: 'If we, for example, want to set up a filter in the processing of HTTP requests
    (handled by Spring WebFlux, which is described as follows) that writes a log message
    at the beginning and at the end of the processing of the request, we can configure
    a log-filter, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要在由Spring WebFlux（如下所述）处理的HTTP请求处理中设置一个过滤器，该过滤器在请求处理的开头和结尾分别写入日志消息，我们可以如下配置一个日志过滤器：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can also place the configuration directly in the application class since
    the `@SpringBootApplication` annotation implies the `@Configuration` annotation.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将配置直接放在应用程序类中，因为`@SpringBootApplication`注解隐含了`@Configuration`注解。
- en: Now that we have learned about Spring Boot, let's talk about Spring WebFlux.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Spring Boot，接下来让我们谈谈Spring WebFlux。
- en: Beginning with Spring WebFlux
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Spring WebFlux开始
- en: Spring Boot 2.0 is based on Spring Framework 5.0, which came with built-in support
    for developing reactive applications. Spring Framework uses **Project Reactor **as
    the base implementation of its reactive support, and also comes with a new web
    framework, Spring WebFlux, which supports the development of reactive, that is,
    non-blocking, HTTP clients and services.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 2.0基于Spring Framework 5.0，它提供了内置的支持来开发反应式应用程序。Spring Framework使用**Project
    Reactor**作为其反应式支持的基线实现，并且还带来了一个新的web框架Spring WebFlux，它支持开发反应式的，即非阻塞的HTTP客户端和服务。
- en: 'Spring WebFlux supports two different programming models:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux支持两种不同的编程模型：
- en: An annotation-based imperative style, similar to the already existing web framework,
    Spring Web MVC, but with support for reactive services
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于注解的命令式风格，与已经存在的Web框架Spring Web MVC类似，但支持响应式服务
- en: A new function-oriented model based on routers and handlers
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于路由和处理器的新的函数式模型
- en: In this book, we will use the annotation-based imperative style to demonstrate
    how easy it is to move REST services from Spring Web MVC to Spring WebFlux and
    then start to refactor the services so that they become fully reactive.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用基于注解的命令式风格来展示将REST服务从Spring Web MVC迁移到Spring WebFlux是多么容易，然后开始重构服务，使它们变得完全响应式。
- en: Spring WebFlux also provides a fully reactive HTTP client, `WebClient`, as a
    complement to the existing `RestTemplate` client.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux还提供了一个完全响应式的HTTP客户端，`WebClient`，作为现有`RestTemplate`客户端的补充。
- en: Spring WebFlux supports running on a servlet container (it requires Servlet
    v3.1 or higher), but also supports reactive non-servlet-based embedded web servers
    such as Netty ([https://netty.io/](https://netty.io/)).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux支持在Servlet容器上运行（它需要Servlet v3.1或更高版本），但也支持响应式非Servlet内嵌Web服务器，如Netty([https://netty.io/](https://netty.io/))。
- en: Code examples of setting up a REST service using Spring WebFlux
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring WebFlux设置REST服务的代码示例
- en: Before we can create a REST service based on Spring WebFlux, we need to add Spring
    WebFlux (and the dependencies that Spring WebFlux requires) to the classpath for
    Spring Boot to be detected and configured during startup. Spring Boot provides
    a large number of convenient *starter dependencies* that bring in a specific feature,
    together with the dependencies each feature normally requires. So, let's use the
    starter dependency for Spring WebFlux and then see what a simple REST service
    looks like!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够基于Spring WebFlux创建REST服务之前，需要将Spring WebFlux（及其所需的依赖项）添加到Spring Boot的类路径中，以便在启动时检测并配置。Spring
    Boot提供大量方便的*启动依赖项*，每个依赖项都带来一个特定的特性，以及每个特性通常所需的依赖项。所以，让我们使用Spring WebFlux的启动依赖项，然后看看简单的REST服务长什么样！
- en: Starter dependencies
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动依赖项
- en: 'In this book, we will use Gradle as our build tool, so the Spring WebFlux starter
    dependency will be added to the `build.gradle` file. It looks like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用Gradle作为我们的构建工具，因此Spring WebFlux的启动依赖项将被添加到`build.gradle`文件中。它看起来像这样：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You might be wondering why we don't specify a version number.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们没有指定一个版本号。
- en: We will talk about that when we look at a complete example in  [Chapter 3](d26f4e61-20bf-4f55-b96d-060c7dd6f20c.xhtml),
    *Creating a Set of Cooperating Microservices*!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第3章](d26f4e61-20bf-4f55-b96d-060c7dd6f20c.xhtml)中讨论这一点，*创建一组协作的微服务*！
- en: 'When the microservice is started up, Spring Boot will detect Spring WebFlux
    on the classpath and configure it, as well as other things that are used to start
    up an embedded web server. Netty is used by default, which we can see from the
    log output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当微服务启动时，Spring Boot将检测到类路径中的Spring WebFlux并对其进行配置，以及其他用于启动内嵌Web服务器的所用东西。默认使用Netty，我们可以从日志输出中看到：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we want to switch from Netty to Tomcat as our embedded web server, we can
    override the default configuration by excluding Netty from the starter dependency
    and add the starter dependency for Tomcat:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将Netty更改为Tomcat作为我们的内嵌Web服务器，可以通过从启动依赖项中排除Netty并添加Tomcat的启动依赖项来覆盖默认配置：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After restarting the microservice, we can see that Spring Boot picked Tomcat
    instead:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 重启微服务后，我们可以看到Spring Boot选择了Tomcat：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Property files
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性文件
- en: As you can see from the preceding examples, the web server is started up using
    port `8080`. If you want to change the port, you can override the default value
    using a property file. Spring Boot application property files can either be a
    `.properties` file or a YAML file. By default, they are named `application.properties` and `application.yml`,
    respectively.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的示例中，可以看到Web服务器使用端口`8080`启动。如果你想要更改端口，可以使用属性文件覆盖默认值。Spring Boot应用程序属性文件可以是`.properties`文件或YAML文件。默认情况下，它们分别命名为`application.properties`和`application.yml`。
- en: 'In this book, we will use YAML files so that the HTTP port used by the embedded
    web server can be changed to `7001`. By doing this, we can avoid port collisions
    with other microservices running on the same server. To do this, add the following
    line to the `application.yml` file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用YAML文件，以便内嵌Web服务器所使用的HTTP端口可以更改为`7001`。通过这样做，我们可以避免与其他在同一服务器上运行的微服务发生端口冲突。为此，需要在`application.yml`文件中添加以下行：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Sample RestController
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例RestController
- en: 'Now, with Spring WebFlux and an embedded web server of our choice in place,
    we can write a REST service in the same way as when using Spring MVC, that is,
    as `RestController`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了Spring WebFlux和我们所选择的嵌入式Web服务器，我们可以像使用Spring MVC一样编写REST服务，即使用 `RestController`：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `@GetMapping` annotation on the `listResources()` method will map the Java
    method to an HTTP `GET` API on the `host:8080/myResource` URL. The return value
    of the `List<Resource>` type will be converted into JSON.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`@GetMapping` 注解应用于 `listResources()` 方法，它将Java方法映射到 `host:8080/myResource`
    URL上的HTTP `GET` API。`List<Resource>` 类型的返回值将被转换为JSON。'
- en: Now that we've talked about Spring WebFlux, let's see what SpringFox is about.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们谈论了Spring WebFlux，现在让我们来看看SpringFox是关于什么的。
- en: Exploring SpringFox
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索SpringFox
- en: One very important aspect of developing APIs, for example, RESTful services,
    is how to document them so that they are easy to use. When it comes to RESTful
    services, Swagger is one of the most widely used ways of documenting RESTful services.
    Many leading API gateways have native support for exposing the documentation of RESTful
    services using Swagger.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 开发API的一个非常重要的方面，例如RESTful服务，是如何文档化它们，以便它们易于使用。当涉及到RESTful服务时，Swagger是文档化RESTful服务最广泛使用的方法之一。许多领先的API网关都有内置支持，用于通过Swagger暴露RESTful服务的文档。
- en: In 2015, SmartBear Software donated the Swagger specification to the Linux Foundation
    under the OpenAPI Initiative and created the OpenAPI Specification. The name Swagger
    is still used for the tooling provided by SmartBear Software.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在2015年，SmartBear Software将Swagger规范捐赠给了Linux Foundation旗下的OpenAPI Initiative，并创建了OpenAPI规范。Swagger这个名称仍被用于SmartBear
    Software提供的工具中。
- en: SpringFox is an open-source project, separate from the Spring Framework, that
    can create Swagger-based API documentation at runtime. It does so by examining
    the application at startup, for example, inspecting `WebFlux` and Swagger-based annotations.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: SpringFox是一个开源项目，与Spring Framework分开，它可以在运行时创建基于Swagger的API文档。它通过在应用程序启动时检查来做到这一点，例如，检查
    `WebFlux` 和基于Swagger的注解。
- en: 'We will look at full source code examples in upcoming chapters, but for now
    the following screenshot of this sample API documentation will do:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将查看完整的源代码示例，但现在以下这个示例API文档的屏幕快照就足够了：
- en: '![](img/9c5f6fb1-6de7-4c81-996c-8c69ede17c43.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c5f6fb1-6de7-4c81-996c-8c69ede17c43.png)'
- en: Note the big Execute button, which can be used to actually try out the API,
    not just read its documentation!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意那个大大的执行按钮，它可以用来实际尝试API，而不仅仅是阅读其文档！
- en: SpringFox helped us understand how microservices delved into Spring Framework.
    Now, let's move on to Spring Data.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: SpringFox帮助我们理解了微服务如何深入到Spring Framework中。现在，让我们转向Spring Data。
- en: Understanding Spring Data
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Spring Data
- en: Spring Data comes with a common programming model for persisting data in various
    types of database engine, ranging from traditional relational databases (SQL databases)
    to various types of NoSQL database engine, such as document databases (for example,
    MongoDB), key-value databases (for example, Redis), and graph databases (for example, Neo4J).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data提供了一个用于在不同类型的数据库引擎中持久化数据的常见编程模型，范围从传统的关系数据库（SQL数据库）到各种类型的NoSQL数据库引擎，例如文档数据库（例如，MongoDB）、键值数据库（例如，Redis）和图数据库（例如，Neo4J）。
- en: The Spring Data project is divided into several subprojects and in this book
    we will use Spring Data subprojects for MongoDB and JPA that have been mapped
    to a MySQL database.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data项目分为几个子项目，在这本书中，我们将使用已映射到MySQL数据库的Spring Data MongoDB和JPA子项目。
- en: '**JPA** stands for **Java Persistence API** and is a Java specification about
    how to handle relational data. Please go to [https://jcp.org/aboutJava/communityprocess/mrel/jsr338/index.html](https://jcp.org/aboutJava/communityprocess/mrel/jsr338/index.html)
    for the latest specification, which is JPA 2.2 at the time of writing.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**JPA** 是 **Java Persistence API** 的缩写，是关于如何处理关系数据的一个Java规范。请访问 [https://jcp.org/aboutJava/communityprocess/mrel/jsr338/index.html](https://jcp.org/aboutJava/communityprocess/mrel/jsr338/index.html)
    查看最新的规范，截至撰写本文时是JPA 2.2。'
- en: The two core concepts of the programming model in Spring Data are entities and
    repositories. Entities and repositories generalize how data is stored and accessed
    from the various types of database. They provide a common abstraction but still
    support adding database-specific behavior to the entities and repositories. These
    two core concepts are briefly explained together with some illustrative code examples
    as we proceed through this chapter. Remember that more details will be provided
    in the upcoming chapters!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data编程模型的两个核心概念是实体和仓库。实体和仓库概括了从各种类型的数据库存储和访问数据的方式。它们提供了一个通用的抽象，但仍然支持向实体和仓库添加数据库特定的行为。这两个核心概念将在本章中一起简要解释，并附有一些示例代码。请注意，更多的细节将在接下来的章节中提供！
- en: Even though Spring Data provides a common programming model for different types
    of database, this doesn't mean that you will be able to write portable source
    code, for example, switching the database technology from a SQL database to a
    NoSQL database, without changes needing to be made to the source code!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Spring Data为不同类型的数据库提供了一个共同的编程模型，但这并不意味着您将能够编写可移植的源代码，例如，在不更改源代码的情况下，将数据库技术从SQL数据库更改为NoSQL数据库！
- en: Entity
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体
- en: An entity describes the data that will be stored by Spring Data. Entity classes
    are, in general, annotated with a mix of generic Spring Data annotations and annotations
    that are specific to each database technology.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 实体描述了Spring Data将存储的数据。实体类通常用通用的Spring Data注解和特定于每种数据库技术的注解进行注释。
- en: 'For example, an entity that will be stored in a relational database can be
    annotated with JPA annotations such as the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个将存储在关系型数据库中的实体可以注释如下JPA注解：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If an entity is to be stored in a MongoDB database, annotations from the Spring
    Data MongoDB subproject can be used together with generic Spring Data annotations.
    For example, consider the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个实体要存储在MongoDB数据库中，可以使用Spring Data MongoDB子项目的注解以及通用的Spring Data注解。例如，考虑以下代码：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `@Id` and `@Version` annotations are generic annotations, while the `@Document`
    annotation is specific to the Spring Data MongoDB subproject.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Id`和`@Version`注解是通用的注解，而`@Document`注解是特定于Spring Data MongoDB子项目的。'
- en: This can be revealed by studying the import statements; that is, the import
    statements that contain `mongodb` come from the Spring Data MongoDB subproject.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点可以通过研究导入声明来揭示；也就是说，包含`mongodb`的导入声明来自Spring Data MongoDB子项目。
- en: Repositories
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仓库
- en: Repositories are used to store and access data from different types of database.
    In its most basic form, a repository can be declared as a Java interface, and
    Spring Data will generate its implementation on the fly using opinionated conventions.
    These conventions can be overridden and/or complemented by additional configuration
    and, if required, some Java code. Spring Data also comes with some base Java interfaces,
    for example, `CrudRepository`, to make the definition of a repository even simpler.
    The base interface, `CrudRepository`, provides us with standard methods for create,
    read, update, and delete operations.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库用于存储和访问不同类型的数据库中的数据。在其最基本的形式中，一个仓库可以声明为一个Java接口，Spring Data将使用有偏见的约定实时生成其实现。这些约定可以被覆盖和/或补充额外的配置，如果需要，还一些Java代码。Spring
    Data还提供了一些基础Java接口，例如`CrudRepository`，以使仓库的定义更加简单。基础接口`CrudRepository`为我们提供了创建、读取、更新和删除操作的标准方法。
- en: 'To specify a repository for handling the JPA entity, `ReviewEntity`, we only
    need to declare the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指定一个用于处理JPA实体`ReviewEntity`的仓库，我们只需要声明以下内容：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this example we use a class, `ReviewEntityPK`, to describe a composite primary
    key. It looks as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用一个类`ReviewEntityPK`来描述一个组合主键。它如下所示：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We have also added an extra method, `findByProductId`, which allows us to look
    up `Review` entities based on `productId` – a field that is part of the primary
    key. The naming of the method follows a naming convention defined by Spring Data
    that allows Spring Data to generate the implementation of this method on the fly
    as well.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个额外的方法`findByProductId`，它允许我们根据`productId`——主键的一部分——来查找`Review`实体。该方法的命名遵循Spring
    Data定义的命名约定，允许Spring Data实时生成这个方法的实现。
- en: 'If we want to use the repository, we can simply inject it and then start to
    use it, for example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使用仓库，我们可以简单地注入它，然后开始使用它，例如：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Also added to the `CrudRepository` interface, Spring Data also provides a reactive
    base interface, `ReactiveCrudRepository`, which enables reactive repositories.
    The methods in this interface do not return objects or collections of objects;
    instead, they return `Mono` and `Flux` objects.  `Mono` and `Flux` objects are,
    as we will see in later chapters, reactive streams that are capable of returning
    either `0`..`1` or `0`..`m` entities as they become available on the stream. The
    reactive-based interface can only be used by Spring Data subprojects that support
    reactive database drivers; that is, they are based on non-blocking I/O. The Spring
    Data MongoDB subproject supports reactive repositories, while Spring Data JPA
    does not.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 还添加到了`CrudRepository`接口中，Spring Data还提供了一个反应式基础接口，`ReactiveCrudRepository`，它使反应式仓库成为可能。该接口中的方法不返回对象或对象集合；相反，它们返回`Mono`和`Flux`对象。如我们在后面的章节中将看到的，`Mono`和`Flux`对象是**反应式流**，能够返回`0`..`1`或`0`..`m`个实体，实体随着流变得可用。基于反应式的接口只能由支持反应式数据库驱动器的Spring
    Data子项目使用；也就是说，它们基于非阻塞I/O。Spring Data MongoDB子项目支持反应式仓库，而Spring Data JPA则不支持。
- en: 'Specifying a reactive repository for handling the MongoDB entity, `RecommendationEntity`,
    as described previously, might look something like the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为处理前面描述的MongoDB实体`RecommendationEntity`指定反应式仓库可能会像以下内容一样：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This concludes the section on Spring Data. Now let's see what the Spring Cloud
    Stream is about.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本节关于Spring Data的内容就到这里。现在让我们来看看Spring Cloud Stream是关于什么的。
- en: Understanding Spring Cloud Stream
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Spring Cloud Stream
- en: 'We will not focus on Spring Cloud in this chapter; we will do that from [Chapter
    9](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml), *Adding Service Discovery Using
    Netflix Eureka and Ribbon* to [Chapter 14](42f456c5-d911-494a-a1ba-4631863068b6.xhtml),
    *Understanding Distributed Tracing*. However, we will bring in one of the modules
    that''s part of Spring Cloud: Spring Cloud Stream. Spring Cloud Stream provides
    a streaming abstraction over messaging, based on the publish-and-subscribe integration
    pattern. Spring Cloud Stream currently comes with support for Apache Kafka and
    RabbitMQ out of the box. A number of separate projects exist that provide integration
    with other popular messaging systems. See [https://github.com/spring-cloud?q=binder](https://github.com/spring-cloud?q=binder)
    for more details.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本章不会专注于Spring Cloud；我们将在第[9章](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml)，*使用Netflix
    Eureka和Ribbon添加服务发现*到第[14章](42f456c5-d911-494a-a1ba-4631863068b6.xhtml)，*理解分布式跟踪*中这样做。然而，我们将引入Spring
    Cloud的一个模块：Spring Cloud Stream。Spring Cloud Stream为消息提供了一种流式抽象，基于发布-订阅集成模式。Spring
    Cloud Stream目前内置了对Apache Kafka和RabbitMQ的支持。存在许多独立的项目，为其他流行的消息系统提供集成。有关更多信息，请参见[https://github.com/spring-cloud?q=binder](https://github.com/spring-cloud?q=binder)。
- en: 'The core concepts in Spring Cloud Stream are as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Stream中的核心概念如下：
- en: '**Message:** A data structure that''s used to describe data sent to and received
    from a messaging system.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息**：用于描述发送到和从消息系统接收的数据的数据结构。'
- en: '**Publisher:** Sends messages to the messaging system.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布者**：向消息系统发送消息。'
- en: '**Subscriber**: Receives messages from the messaging system.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订阅者**：从消息系统中接收消息。'
- en: '**Channel:** Used to communicate with the messaging system. Publishers use
    output channels and subscribers use input channels.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通道**：用于与消息系统进行通信。发布者使用输出通道，订阅者使用输入通道。'
- en: '**Binder:** A binder provides the actual integration with a specific messaging
    system, similar to what a JDBC driver does for a specific type of database.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绑定器**：提供与特定消息系统的实际集成，类似于JDBC驱动程序对特定类型的数据库所做的那样。'
- en: The actual messaging system to be used is determined at runtime, depending on
    what is found on the classpath. Spring Cloud Stream comes with opinionated conventions
    on how to handle messaging. These conventions can be overridden by specifying
    a configuration for messaging features such as consumer groups, partitioning,
    persistence, durability, and error handling, such as retries and dead letter queue
    handling.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 实际要使用的消息系统在运行时确定，取决于在类路径中找到的内容。Spring Cloud Stream带有关于如何处理消息的**有见解的约定**。这些约定可以通过指定消息功能的配置来覆盖，如消费者组、分区、持久化、耐用性和错误处理，如重试和死信队列处理。
- en: Code examples for sending and receiving messages with Spring Cloud Stream
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送和接收消息的Spring Cloud Stream代码示例
- en: To better understand how all this fits together, let's look at some source code
    examples.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一切是如何组合在一起的，让我们来看看一些源代码示例。
- en: 'Let''s assume that we have a simple message class such as the following (constructors,
    getters, and setters have been left out for improved readability):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们有一个简单的消息类，如下所示（构造函数、getter和setter已省略，以提高可读性）：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Spring Cloud Stream comes with default input and output channels, `Sink` and `Source`,
    so we don''t need to create our own to get started. To publish a message, we can
    use the following source code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Stream带有默认的输入和输出通道，`Sink`和`Source`，所以我们可以开始使用，而不需要创建自己的。要发布一条消息，我们可以使用以下源代码：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To receive messages, we can use the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了接收消息，我们可以使用以下代码：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To bind to RabbitMQ, we will use a dedicated starter dependency in the build
    file, `build.gradle`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绑定到RabbitMQ，我们将在构建文件中使用专门的启动依赖项`build.gradle`：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For the subscriber to receive messages from the publisher, we need to configure
    the input and output channel to use the same destination. If we use YAML to describe
    our configuration, it might look like the following for the publisher:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让订阅者从发布者那里接收消息，我们需要配置输入和输出通道以使用相同的目的地。如果我们使用YAML来描述我们的配置，它可能如下所示对于发布者：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The configuration for the subscriber is as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅者的配置如下：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We use `default.contentType` to specify that we prefer messages to be serialized
    in JSON format.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`default.contentType`来指定我们更喜欢消息以JSON格式序列化。
- en: Now that we understand the various Spring APIs, let's understand a concept relatively
    newer, Docker, in the next section.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了各种Spring API，让我们在下一节了解一个相对较新的概念，Docker。
- en: Learning about Docker
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习关于Docker
- en: I assume that Docker and the concept of containers need no in-depth presentation.
    Docker the concept of containers as a lightweight alternative to virtual machines
    very popular in 2013\. Containers are actually processed in a Linux host that
    uses Linux **namespaces** to provide between containers of global system resources,
    such as users, processes, filesystems, and networking. Linux control groups (also
    known as **cgroups**) are used to limit the amount of CPU and memory that a container
    is allowed to consume. Compared to a virtual machine that uses a hypervisor to
    run a complete copy of an operating system in each virtual machine, the overhead
    in a container is a fraction of the overhead in a virtual machine. This leads
    to much faster startup times and significantly lower overhead in terms of CPU
    and memory usage. The isolation that's provided for a container is, however, not
    considered to be as secure as the isolation that's provided for a virtual machine.
    With the release of Windows Server 2016, Microsoft supports the use of Docker
    in Windows servers.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设Docker和容器概念不需要深入介绍。Docker在2013年非常流行的容器作为虚拟机的轻量级替代品。实际上，容器是在使用Linux **namespaces**在Linux主机上处理，以提供容器之间全局系统资源，如用户、进程、文件系统、网络。Linux控制组（也称为**cgroups**）用于限制容器允许消耗的CPU和内存量。与在每一个虚拟机中运行操作系统的完整副本的虚拟机相比，容器的开销只是虚拟机开销的一小部分。这导致了更快的启动时间和在CPU和内存使用上显著降低的开销。然而，容器提供的隔离并不被认为是像虚拟机提供的隔离那样安全的。随着Windows
    Server 2016的发布，微软支持在Windows服务器上使用Docker。
- en: Containers are very useful both during development and testing. Being able to
    start up a complete system landscape of cooperating microservices and resource
    managers (for example, database servers, messaging brokers, and so on) with a
    single command for testing is simply amazing.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 容器在开发和测试中都非常有用。能够通过一条命令启动一个完整的微服务合作系统景观（例如，数据库服务器、消息代理等）进行测试，这真是令人惊叹。
- en: For example, we can write scripts in order to automate end-to-end tests of our microservice
    landscape. A test script can start up the microservice landscape, run tests using
    the exposed services, and tear down the landscape. This type of automated test
    script is very useful, both for running locally on a developer PC before pushing
    code to a source code repository, and to be executed as a step in a delivery pipeline.
    A build server can run these types of test in its continuous integration and deployment
    process whenever a developer pushes code to the source repository.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以编写脚本以自动化我们微服务景观的端到端测试。一个测试脚本可以启动微服务景观，使用暴露的服务运行测试，并拆除景观。这种类型的自动化测试脚本非常实用，既可以在开发者在将代码推送到源代码仓库之前在本地的开发机上运行，也可以作为交付管道中的一个步骤执行。构建服务器可以在持续集成和部署过程中，在开发者将代码推送到源代码仓库时运行这些类型的测试。
- en: For production usage, we need a container orchestrator such as Kubernetes. We
    will get back to container orchestrators and Kubernetes later in this book.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产使用，我们需要一个容器编排器，如Kubernetes。我们将在本书的后面回到容器编排器和Kubernetes。
- en: 'For most of the microservices we will look at in this book, a Dockerfile such
    as the following is all that is required to run the microservice as a Docker container:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中我们将要研究的绝大多数微服务，只需要如下的Dockerfile就可以将微服务作为Docker容器运行：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If we want to start and stop many containers with one command, Docker Compose
    is the perfect tool. Docker Compose uses a YAML file to describe the containers
    to be managed. For our microservices, it might look something like the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要用一个命令来启动和停止许多容器，Docker Compose是完美的工具。Docker Compose使用一个YAML文件来描述要管理的容器。对于我们的微服务，它可能看起来像如下这样：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let me explain the preceding source code a little:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我稍微解释一下前面的源代码：
- en: The `build` directive is used to specify which Dockerfile to use for each microservice.
    Docker Compose will use it to build a Docker image and then launch a Docker container
    based on that Docker image.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build`指令用于指定每个微服务使用哪个Dockerfile。Docker Compose会使用它来构建一个Docker镜像，然后基于这个Docker镜像启动一个Docker容器。'
- en: The `ports` directive for the composite service is used to expose port `8080`
    on the server where Docker runs. On a developer's machine, this means that the
    port of the composite service can be reached simply by using `localhost:8080`!
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复合服务中的`ports`指令用于在运行Docker的服务器上暴露端口`8080`。在开发者的机器上，这意味着可以通过使用`localhost:8080`简单地访问复合服务的端口！
- en: 'All the containers in the YAML files can be managed with simple commands such
    as the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: YAML文件中的所有容器都可以用如下简单命令进行管理：
- en: '`docker-compose up -d`: Starts all containers. `-d` means that the containers
    run in the background, not locking the Terminal from where the command was executed.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker-compose up -d`：启动所有容器。`-d`意味着容器在后台运行，不会锁定执行命令的终端。'
- en: '`docker-compose down`: Stops and removes all containers.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker-compose down`：停止并删除所有容器。'
- en: '`docker-compose logs -f --tail=0`: Prints out log messages from all containers. `-f`
    means that the command will not complete, and instead waits for new log messages. `--tail=0`
    means that we don''t want to see any previous log messages, only new ones.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker-compose logs -f --tail=0`：输出所有容器的日志消息。`-f`意味着该命令不会完成，而是等待新的日志消息。`--tail=0`意味着我们不想看到任何之前的日志消息，只想要新的。'
- en: This was a brief introduction to Docker. We will go into more detail about Docker
    in the last few chapters of this book.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对Docker的简要介绍。在本书的最后几章，我们将更详细地介绍Docker。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have been introduced to Spring Boot and complementary open
    source tools that can be used to build cooperating microservices.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Spring Boot以及可以用来构建协作微服务的互补的开源工具。
- en: Spring Boot is used to simplify the development of Spring-based, production-ready
    applications. It is strongly opinionated in terms of how to set up both core modules
    from the Spring Framework and third-party products.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot用于简化基于Spring的生产级应用程序的开发。它强烈地规定了如何设置Spring Framework的核心模块和第三方产品。
- en: Spring WebFlux is a new module in the Spring family and is used to develop reactive,
    that is, non-blocking, REST services. It runs on both lightweight web servers
    such as Netty and on any Servlet 3.1+ compatible web server. It also supports
    the programming model from the older Spring MVC module; it is easy to move REST
    services written for Spring MVC to Spring WebFlux without fully rewriting the
    code.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux是Spring家族中的一个新模块，用于开发反应式的，也就是非阻塞的REST服务。它既可以在Netty这样的轻量级web服务器上运行，也可以在任何Servlet
    3.1+兼容的web服务器上运行。它还支持来自较老的Spring MVC模块的编程模型；无需完全重写代码，就可以轻松地将为Spring MVC编写的REST服务迁移到Spring
    WebFlux。
- en: SpringFox can be used to create Swagger and OpenAPI-based documentation regarding
    REST services. It creates the documentation on the fly at runtime by inspecting
    the annotations for the REST services – both the Spring annotations and some Swagger
    specific annotations – if used.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: SpringFox可以用来创建基于Swagger和OpenAPI的关于REST服务的文档。它通过检查REST服务的注解（既Spring的注解和一些Swagger特定的注解，如果使用的话）在运行时动态创建文档。
- en: Spring Data provides an elegant abstraction for accessing and manipulating persistent
    data using entities and repositories. The programming model is similar, but isn't
    portable between different types of database, for example, relational, document,
    key-value, and graph databases.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data 提供了一种优雅的抽象，用于使用实体和仓库访问和管理持久数据。编程模型相似，但不同类型的数据库（例如，关系型、文档型、键值型和图数据库）之间并不兼容。
- en: Spring Cloud Stream provides a streaming abstraction over messaging, based on
    the publish and subscribe integration pattern. Spring Cloud Stream comes with
    out of the box support for Apache Kafka and RabbitMQ but can be extended to support
    other messaging brokers using custom binders.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Stream 为消息传递提供了基于发布和订阅集成模式的流抽象。Spring Cloud Stream 默认支持 Apache
    Kafka 和 RabbitMQ，但可以通过自定义绑定器扩展支持其他消息代理。
- en: Docker makes the concept of containers as a lightweight alternative to virtual
    machines easy to use. Based on Linux Namespaces and Control Groups, containers
    provide isolation similar to what traditional virtual machines provide, but with
    a significantly lower overhead in terms of CPU and memory usage. Docker is a very
    good tool for development and testing but in most cases requires a container orchestrator
    such as Kubernetes to be used in a production environment.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 使得容器这一轻量级的虚拟机替代方案变得易于使用。基于 Linux 命名空间和控制组，容器提供了与传统虚拟机相似的隔离性，但在 CPU 和内存使用方面有显著的较低开销。Docker
    是一个非常适合开发和测试的工具，但在大多数情况下，在生产环境中使用需要一个容器编排器，如 Kubernetes。
- en: Questions
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the purpose of the `@SpringBootApplication` annotation?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@SpringBootApplication` 注解的目的是什么？'
- en: What are the main differences between the older Spring component for developing
    REST services, Spring Web MVC, and the new Spring WebFlux?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 老版本的用于开发 REST 服务的 Spring 组件 Spring Web MVC 和新版本的 Spring WebFlux 之间的主要区别是什么？
- en: How does SpringFox help a developer document REST APIs?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**SpringFox** 是如何帮助开发者文档化 REST API 的？'
- en: What is the function of a repository in Spring Data and what is the simplest
    possible implementation of a repository?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Spring Data 中，仓库的功能是什么，仓库的最简单可能实现是什么？
- en: What is the purpose of a binder in Spring Cloud Stream?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Spring Cloud Stream 中，绑定的目的是什么？
- en: What is the purpose of Docker Compose?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Docker Compose** 的目的是什么？'
