- en: Chapter 5. Advanced Design Principles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。高级设计原则
- en: This chapter covers advanced design principles that every developer must know
    when designing RESTful services. It also provides pragmatic insights that give
    the developer enough information to build complex applications with REST API.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了每个开发人员在设计RESTful服务时必须了解的高级设计原则。它还提供了务实的见解，为开发人员提供足够的信息来构建具有REST API的复杂应用程序。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Rate-limiting patterns
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速率限制模式
- en: Response pagination
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应分页
- en: Internationalization and localization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国际化和本地化
- en: REST pluggability and extensibility
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST的可插拔性和可扩展性
- en: Additional topics for REST API developers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST API开发人员的其他主题
- en: Different snippets of code are included in the chapter, but the complete samples
    that show these snippets in action are included as part of the book's source code
    download bundle.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含了不同的代码片段，但展示这些片段的完整示例作为书籍源代码下载包的一部分包含在内。
- en: As we have done with the prior chapters, we'll attempt to cover the minimal
    level of detail required to empower the reader with a solid general understanding
    of inherently complex topics, while also providing enough of a technical drill-down
    so that the reader will be able to immediately get to work easily.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的章节一样，我们将尝试覆盖读者所需的最低限度的细节，以便为其提供对本质上复杂的主题的扎实的一般理解，同时还提供足够的技术细节，以便读者能够轻松地立即开始工作。
- en: Rate-limiting patterns
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 速率限制模式
- en: Rate limiting involves restricting the number of requests that can be made by
    a client. A client can be identified based on the access token it uses for the
    request as covered in [Chapter 3](ch03.html "Chapter 3. Security and Traceability"),
    *Security and Traceability*. Another way the client can be identified is the IP
    address of the client.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 速率限制涉及限制客户端可以发出的请求数量。客户端可以根据其用于请求的访问令牌进行识别，如[第3章](ch03.html "第3章。安全性和可追溯性")中所述，*安全性和可追溯性*。另一种客户端可以被识别的方式是客户端的IP地址。
- en: To prevent abuse of the server, APIs must enforce throttling or rate-limiting
    techniques. Based on the client, the rate-limiting application can decide whether
    to allow the request to go through or not.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止滥用服务器，API必须实施节流或速率限制技术。基于客户端，速率限制应用程序可以决定是否允许请求通过。
- en: The server can decide what the natural rate limit per client should be, say
    for example, 500 requests per hour. The client makes a request to the server via
    an API call. The server checks if the request count is within the limit. If the
    request count is within the limit, the request goes through and the count is increased
    for the client. If the client request count exceeds the limit, the server can
    throw a 429 error.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可以决定每个客户端的自然速率限制应该是多少，例如，每小时500个请求。客户端通过API调用向服务器发出请求。服务器检查请求计数是否在限制范围内。如果请求计数在限制范围内，则请求通过并且计数增加给客户端。如果客户端请求计数超过限制，服务器可以抛出429错误。
- en: The server can optionally include a `Retry-After` header, which indicates how
    long the client should wait before it can send the next request.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可以选择包含一个`Retry-After`头部，指示客户端在可以发送下一个请求之前应等待多长时间。
- en: 'Every request from an application can be subjected to two different throttles:
    those with an access token and those without an access token. The quota of requests
    made by an application with an access token can vary from an application without
    an access token.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的每个请求可以受到两种不同的节流的影响：具有访问令牌和没有访问令牌的请求。具有访问令牌的应用程序的请求配额可以与没有访问令牌的应用程序的请求配额不同。
- en: Here are the details of the `HTTP 429 Too Many Requests` error code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`HTTP 429 Too Many Requests`错误代码的详细信息。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**429 Too Many Requests (RFC 6585)**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**429 Too Many Requests (RFC 6585)**'
- en: The user has sent too many requests in a given amount of time. This is intended
    for use with rate-limiting schemes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 用户在一定时间内发送了太多请求。这是为了与速率限制方案一起使用。
- en: 'The response for a `429 Too Many Requests` error may include a `Retry-After`
    header, indicating how long the client needs to wait before making a new request.
    The following is an example code snippet:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`429 Too Many Requests`错误的响应可能包括一个`Retry-After`头部，指示客户端需要等待多长时间才能发出新的请求。以下是一个示例代码片段：'
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding example of an HTTP response sets a `Retry-After` header to 3600
    seconds to indicate when the client can retry later. Additionally, servers can
    send an `X-RateLimit-Remaining` header that can indicate how many requests are
    pending for this client.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的HTTP响应示例设置了`Retry-After`头部为3600秒，以指示客户端可以稍后重试。此外，服务器可以发送一个`X-RateLimit-Remaining`头部，指示此客户端还有多少待处理的请求。
- en: Now that we have some ideas on what rate limiting is and how the rate-limiting
    error and `Retry-After` and `X-RateLimit-Remaining` headers work, let's get down
    to code with JAX-RS.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对速率限制有了一些想法，以及速率限制错误和`Retry-After`和`X-RateLimit-Remaining`头部的工作原理，让我们通过JAX-RS编写代码。
- en: The following code in the *The project's layout* section shows how to implement
    a simple rate-limiting filter in JAX-RS.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*项目的布局*部分中的以下代码显示了如何在JAX-RS中实现一个简单的速率限制过滤器。'
- en: The project's layout
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目的布局
- en: The project's directory layout follows the standard Maven structure, which is
    briefly explained in the following table. This sample produces a WAR file, which
    can be deployed on any Java EE 7-compliant application server such as GlassFish
    4.0.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的目录布局遵循标准的Maven结构，简要解释如下表。此示例生成一个WAR文件，可以部署在任何符合Java EE 7标准的应用服务器上，如GlassFish
    4.0。
- en: This sample demonstrates a simple coffee shop service where clients can query
    for a particular order they placed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例演示了一个简单的咖啡店服务，客户可以查询他们下的特定订单。
- en: '| Source code | Description |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 源代码 | 描述 |'
- en: '| --- | --- |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `src/main/java` | This directory contains all the sources required by the
    coffee shop application |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `src/main/java` | 此目录包含咖啡店应用程序所需的所有源代码 |'
- en: 'The `CoffeeResource` class is a simple JAX-RS resource, shown as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`CoffeeResource`类是一个简单的JAX-RS资源，如下所示：'
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The project has a `CoffeeResource` class that is used to get details about the
    coffee orders. The `getCoffee` method returns a `Coffee` object that contains
    the details of the order.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 项目中有一个`CoffeeResource`类，用于获取有关咖啡订单的详细信息。`getCoffee`方法返回一个包含订单详细信息的`Coffee`对象。
- en: To enforce rate limiting, we will add a `RateLimiter` class that is a simple
    servlet filter as shown in the following diagram.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强制执行速率限制，我们将添加一个`RateLimiter`类，它是一个简单的servlet过滤器，如下图所示。
- en: 'The `RateLimiter` class will check the IP address of the client and check if
    the number of requests that are made by the client exceeds the limit or not. The
    following diagram depicts the rate-limiting functionality covered by the sample
    in detail:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`RateLimiter`类将检查客户端的IP地址，并检查客户端发出的请求是否超过限制。以下图表详细描述了示例中涵盖的速率限制功能：'
- en: '![The project''s layout](img/7963OS_05_01.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![项目布局](img/7963OS_05_01.jpg)'
- en: The preceding diagram shows a client making a `GET` request to [http://api.com/foo](http://api.com/foo).
    The **Rate Limit Filter** checks the access count of the client based on the IP
    address. As the client does not exceed the rate limit, the request is forwarded
    to the server. The server can return a JSON or XML or a text response.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表显示了客户端向[http://api.com/foo](http://api.com/foo)发出`GET`请求。**速率限制过滤器**根据IP地址检查客户端的访问计数。由于客户端未超过速率限制，请求被转发到服务器。服务器可以返回JSON、XML或文本响应。
- en: The following diagram shows the client making a `GET` request to [http://api.com/foo](http://api.com/foo).
    The **Rate Limit Filter** checks the access count of the client based on the IP
    address. Since the client exceeds the rate limit, the request is not forwarded
    to the server, and the Rate Limiter returns an error code of `429 Too Many Requests`
    in the HTTP response.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示客户端向[http://api.com/foo](http://api.com/foo)发出`GET`请求。**速率限制过滤器**根据IP地址检查客户端的访问计数。由于客户端超过了速率限制，请求未转发到服务器，并且速率限制器在HTTP响应中返回`429
    Too Many Requests`错误代码。
- en: '![The project''s layout](img/7963OS_05_02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![项目布局](img/7963OS_05_02.jpg)'
- en: A detailed look at the rate-limiting sample
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对速率限制示例的详细查看
- en: 'To implement a rate limiter with JAX-RS, we need to implement a `Filter` class.
    This is shown in the following code snippet:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用JAX-RS实现速率限制器，我们需要实现一个`Filter`类。如下代码片段所示：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding snippet shows an implementation of the `WebFilter` interface of
    the `javax.servlet.annotation` package. The `@WebFilter` annotation indicates
    that this class is a filter for the application.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段显示了`javax.servlet.annotation`包的`WebFilter`接口的实现。`@WebFilter`注解表示这个类是应用程序的过滤器。
- en: The `@WebFilter` annotation must have at least one `urlPatterns` or `value`
    attribute in the annotation.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`@WebFilter`注解必须在注解中具有至少一个`urlPatterns`或`value`属性。'
- en: The `REQ_LIMIT` constant stands for the number of requests that can be made
    in a time period. The `TIME_LIMIT` constant stands for the time duration for the
    rate limit after which new requests from a client can be accepted.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`REQ_LIMIT`常量代表在一段时间内可以发出的请求数量。`TIME_LIMIT`常量代表速率限制的时间持续时间，之后客户端可以接受新请求。'
- en: For simplicity, we have smaller limit values in the samples. In real-world scenarios,
    the limits could be, for example, 60 requests per minute or 1,000 requests per
    day. If the request count reaches the limit, the `Retry-After` header will indicate
    the time for which the client will have to wait before the server can process
    the next request.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为简单起见，示例中的限制值较小。在实际场景中，限制可以是，例如，每分钟60个请求或每天1,000个请求。如果请求计数达到限制，`Retry-After`头将指示客户端在服务器处理下一个请求之前必须等待的时间。
- en: To keep track of the request count associated with a client, we have created
    a class called `AccessCounter`. Here is the code for the `AccessCounter` class.
    The `AccessCounter` class is a `Singleton` class annotated with `@Singleton`.
    It stores a `ConcurrentHashMap` class that contains IP addresses as the keys and
    data related to the client, known as `AccessData`, as values.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪与客户端关联的请求计数，我们创建了一个名为`AccessCounter`的类。以下是`AccessCounter`类的代码。`AccessCounter`类是一个带有`@Singleton`注解的`Singleton`类。它存储了一个包含IP地址作为键和与客户端相关的数据（称为`AccessData`）作为值的`ConcurrentHashMap`类。
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `AccessData` class is responsible for storing the details for a client,
    such as the number of requests and when the last request was made. It is a simple
    **Plain Old Java Object** (**POJO**), as shown in the following code snippet:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`AccessData`类负责存储客户端的详细信息，例如请求的数量以及上次请求是何时。它是一个简单的**普通旧Java对象**（**POJO**），如下代码片段所示：'
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As shown in the preceding snippet, the `AccessData` class has a field called
    `count` and a field called `lastUpdated`. Whenever a new request arrives, the
    count is incremented, and the `lastUpdated` field is set to the current time.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，`AccessData`类有一个名为`count`的字段和一个名为`lastUpdated`的字段。每当新请求到达时，计数会递增，并且`lastUpdated`字段设置为当前时间。
- en: 'The `doFilter()` method of the `RateLimiter` class is used in the following
    code snippet:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`RateLimiter`类的`doFilter()`方法在以下代码片段中使用：'
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code shows the `doFilter()` method of the `javax.servlet.Filter`
    class, which is overridden in the `RateLimiter` implementation. In this method,
    the IP address of the client is first determined.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码显示了`javax.servlet.Filter`类的`doFilter()`方法，在`RateLimiter`实现中被重写。在这个方法中，首先确定客户端的IP地址。
- en: If the `accessCounter` class contains the IP address, a check is made to see
    if the request limit has exceeded in the `requestLimitExceeded()` method.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`accessCounter`类包含IP地址，则在`requestLimitExceeded()`方法中将检查请求限制是否已超过。
- en: If the rate limit has exceeded, then the `Retry-After` headers are sent in the
    `httpServletResponse` along with a `429 Too Many Requests` error. If there is
    a new request that comes from the same client after some time, and it is greater
    than the `TIME_LIMIT` value, then the counter is reset back to 0, and the request
    from the client can be processed again.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果速率限制已超过，则`Retry-After`标头将与`429 Too Many Requests`错误一起发送到`httpServletResponse`。如果同一客户端发出了新请求，并且大于`TIME_LIMIT`值，则计数器将重置为0，并且可以再次处理来自客户端的请求。
- en: 'The following are the headers for rate limiting that can be sent back in the
    response to the client:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以在响应中发送回客户端的速率限制标头：
- en: '`X-RateLimit-Limit`: The maximum number of requests that the client can make
    during a specific time period'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-RateLimit-Limit`：客户端在特定时间段内可以发出的最大请求数'
- en: '`X-RateLimit-Remaining`: The number of requests remaining in the current rate-limit
    window'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-RateLimit-Remaining`：当前速率限制窗口中剩余的请求数'
- en: A detailed sample is included with this book. After the sample is deployed on
    an application server, the client can make multiple requests to get order details
    for coffees.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 本书附带了一个详细的示例。在将示例部署到应用程序服务器后，客户端可以进行多个请求以获取咖啡订单的详细信息。
- en: 'For the sake of simplicity, we have enforced the rate limit as 3 and the time
    limit as 10 minutes. The following is a sample `curl` request:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们已经将速率限制设置为3，时间限制设置为10分钟。以下是一个示例`curl`请求：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once the rate limit has been crossed, you will see a `429` error:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦超过速率限制，您将看到`429`错误：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This sample showed how to build your custom filters to implement rate limiting.
    Another option is to use an open source project called **Repose**, which is a
    scalable and extensive rate-limiting implementation. Repose is an open source
    HTTP proxy service that provides rate-limiting, client-authentication, versioning,
    and so on. For more details, check [http://openrepose.org/](http://openrepose.org/).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例显示了如何构建自定义过滤器以实现速率限制。另一个选择是使用名为**Repose**的开源项目，它是一个可扩展且广泛的速率限制实现。 Repose是一个开源的HTTP代理服务，提供速率限制、客户端认证、版本控制等功能。有关更多详细信息，请查看[http://openrepose.org/](http://openrepose.org/)。
- en: In the next section, we will discuss the best practices that must be followed
    to avoid reaching rate limits when consuming a REST API.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论在使用REST API时必须遵循的最佳实践。
- en: Best practices to avoid reaching the rate limits
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免达到速率限制的最佳实践
- en: Here are the best practices that can be followed to avoid reaching rate limits
    when consuming a REST API.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在使用REST API时避免达到速率限制的最佳实践。
- en: Caching
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存
- en: Caching API responses on the server side can help avoid reaching the rate limits.
    Setting reasonable expiry time intervals ensures the database is not thrashed
    with queries, and responses can be sent from the cache if the resource has not
    changed. For example, an application that displays tweets fetched from Twitter
    can cache the response from the Twitter API or use the Twitter Streaming API (covered
    in the following section). Ideally, API consumers should not make identical requests
    more than once a minute. This is generally a waste of bandwidth, as in most cases
    the exact same result will be returned.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端缓存API响应可以帮助避免达到速率限制。设置合理的到期时间间隔可确保数据库不会因查询而受到影响，并且如果资源未更改，则可以从缓存发送响应。例如，从Twitter获取的推文的应用程序可以缓存来自Twitter
    API的响应或使用Twitter流API（在下一节中介绍）。理想情况下，API消费者不应该每分钟进行相同的请求。这通常是一种带宽浪费，因为在大多数情况下将返回完全相同的结果。
- en: Not making calls in loops
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要在循环中发出调用
- en: It is a good practice to not make API requests inside loops. The server API
    should be designed to be as verbose as possible and help the clients by sending
    as much detail as possible in the response. This ensures the consumers can fetch
    a collection of objects in one API operation instead of fetching individual objects
    inside a loop.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 不在循环中发出调用是一个好习惯。服务器API应设计得尽可能详细，并通过在响应中发送尽可能多的细节来帮助客户端。这确保了消费者可以在一个API操作中获取一组对象，而不是在循环中获取单个对象。
- en: Logging requests
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录请求
- en: It is a good practice to use logging on the client side to see how many requests
    the client is making. Observing the logs will help the clients analyze as to which
    are the non-redundant queries that add to the rate limits and can be eliminated.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端使用日志记录以查看客户端发出了多少请求是一个好习惯。观察日志将帮助客户端分析哪些是不冗余的查询，这些查询会增加速率限制并且可以被消除。
- en: Avoiding polling
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免轮询
- en: Additionally, consumers should not poll for changes. Instead of polling to see
    if the content has changed, the client can use WebHooks ([http://en.wikipedia.org/wiki/Webhook](http://en.wikipedia.org/wiki/Webhook))
    or Push Notifications ([http://en.wikipedia.org/wiki/Push_technology](http://en.wikipedia.org/wiki/Push_technology))
    to receive a notification. More details on WebHooks will be given in [Chapter
    6](ch06.html "Chapter 6. Emerging Standards and the Future of REST"), *Emerging
    Standards and the Future of REST*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，消费者不应该轮询更改。客户端可以使用WebHooks（[http://en.wikipedia.org/wiki/Webhook](http://en.wikipedia.org/wiki/Webhook)）或推送通知（[http://en.wikipedia.org/wiki/Push_technology](http://en.wikipedia.org/wiki/Push_technology)）来接收通知，而不是轮询以查看内容是否已更改。有关WebHooks的更多详细信息将在[第6章](ch06.html
    "第6章。REST的新兴标准和未来")中给出，*新兴标准和REST的未来*。
- en: Supporting the streaming API
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持流式API
- en: API developers can support a streaming API. This can help the client avoid reaching
    the rate limits. The set of streaming APIs offered by Twitter gives developers
    low latency access to Twitter's global stream of tweet data. A streaming client
    does not need to bear the overhead, associated with polling a REST endpoint and
    will get messages indicating tweets and other events that have occurred.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: API开发人员可以支持流式API。这可以帮助客户端避免达到速率限制。Twitter提供的一组流式API为开发人员提供了低延迟访问Twitter全球推文数据流的机会。流式客户端不需要承担与轮询REST端点相关的开销，并且将收到指示已发生推文和其他事件的消息。
- en: Once applications establish a connection to a streaming endpoint, they are delivered
    a feed of tweets, without worrying about polling or REST API rate limits.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序建立到流式端点的连接，它们将收到推文的订阅，而不必担心轮询或REST API速率限制。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Case study of Twitter REST API rate limits**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**Twitter REST API速率限制案例研究**'
- en: Twitter has a rate limit of 150 requests per hour per unauthenticated client.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter每小时对未经身份验证的客户端的请求限制为150次。
- en: OAuth calls are permitted 350 requests per hour based on the access token in
    the request.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 基于OAuth的调用允许每小时基于请求中的访问令牌进行350次请求。
- en: An application that exceeds the rate limitations of the Search API will receive
    an HTTP 420 response code. The best practice is to watch for this error condition
    and honor the Retry-After header that is returned. The Retry-After header's value
    is the number of seconds the client application should wait before requesting
    data from the Search API again. In case the client sends more than the allowed
    requests per hour, the client gets a 420 Enhance Your Calm error.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 超出搜索API的速率限制的应用程序将收到HTTP 420响应代码。最佳做法是注意此错误条件，并遵守返回的Retry-After头。Retry-After头的值是客户端应该在再次请求数据之前等待的秒数。如果客户端发送的请求超过每小时允许的数量，客户端将收到420
    Enhance Your Calm错误。
- en: Tip
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**420 Enhance Your Calm (Twitter)**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**420 Enhance Your Calm (Twitter)**'
- en: This is not part of the HTTP standard but returned by the Twitter Search and
    Trends API when the client is being rate-limited. Applications should ideally
    implement the `429 Too Many Requests` response code instead.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是HTTP标准的一部分，但在Twitter搜索和趋势API被限制时返回。应用程序最好实现`429 Too Many Requests`响应代码。
- en: Response pagination
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应分页
- en: REST APIs are consumed by other systems from web to mobile clients and hence,
    responses that return multiple items should be paged with a certain number of
    items per page. This is known as Response pagination. Along with the response,
    it is always good to add some additional metadata about the total count of objects,
    the total number of pages, and the links that refer to the next set of results.
    The consumers can specify a page index to query for results and the number of
    results per page.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: REST API被从Web到移动客户端的其他系统使用，因此，返回多个项目的响应应该分页，每页包含一定数量的项目。这就是所谓的响应分页。除了响应之外，最好还添加一些关于对象总数、页面总数和指向下一组结果的链接的附加元数据。消费者可以指定页面索引来查询结果以及每页的结果数。
- en: Implementing and documenting default settings for the number of results per
    page is a recommended practice in case the client does not specify the number
    of results per page. For example, GitHub's REST API sets the default page size
    to 30 records with a maximum of 100, and sets a rate limit on the number of times
    the client can query the API. If the API has a default page size, then the query
    string can just specify the page index.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端未指定每页结果数的情况下，实施和记录每页结果数的默认设置是一种推荐做法。例如，GitHub的REST API将默认页面大小设置为30条记录，最多为100条，并对客户端查询API的次数设置了速率限制。如果API有默认页面大小，那么查询字符串可以只指定页面索引。
- en: The following section covers the different types of pagination techniques that
    can be used. API developers may choose to implement one or more of these techniques
    based on their use cases.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分涵盖了可以使用的不同类型的分页技术。API开发人员可以根据其用例选择实现一个或多个这些技术。
- en: Types of pagination
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分页类型
- en: 'The following are the different techniques of pagination that can be used:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以使用的不同分页技术：
- en: Offset-based pagination
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于偏移量的分页
- en: Time-based pagination
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于时间的分页
- en: Cursor-based pagination
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于游标的分页
- en: Offset-based pagination
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于偏移量的分页
- en: 'Offset-based pagination is the case when the client wants results specified
    by a page number and the number of results per page. For example, if a client
    wants to query all the details of books checked out, or the coffees ordered, they
    can send in a query request as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 基于偏移量的分页是客户端希望按页码和每页结果数指定结果的情况。例如，如果客户端想要查询所有已借阅的书籍的详细信息，或者已订购的咖啡，他们可以发送以下查询请求：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following table details what query parameters the offset-based pagination
    would include:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格详细说明了基于偏移量的分页将包括哪些查询参数：
- en: '| Query parameter | Description |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 查询参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `page` | This specifies which page to return |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `page` | 这指定要返回的页面 |'
- en: '| `limit` | This specifies the number of maximum results per page that can
    be included in the response |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `limit` | 这指定了响应中可以包含的每页最大结果数 |'
- en: Time-based pagination
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于时间的分页
- en: The time-based pagination technique will be used when the client wants to query
    for a set of results between a specific timeframe.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端想要查询特定时间范围内的一组结果时，将使用基于时间的分页技术。
- en: 'For example, to get a list of coffees ordered between a specific timeframe,
    a client can send in a query as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要获取在特定时间范围内订购的咖啡列表，客户端可以发送以下查询：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following table details what query parameters a time-based pagination would
    include:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格详细说明了基于时间的分页将包括哪些查询参数：
- en: '| Query parameter | Description |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 查询参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `until:` | This is a Unix timestamp that points to the end of the time range
    |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `until:` | 这是指向时间范围结束的Unix时间戳 |'
- en: '| `since` | This is a Unix timestamp that points to the beginning of the time
    range |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `since` | 这是指向时间范围开始的Unix时间戳 |'
- en: '| `limit` | This specifies the number of max results per page that can be included
    in the response |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `limit` | 这指定了响应中可以包含的每页最大结果数 |'
- en: Cursor-based pagination
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于游标的分页
- en: The cursor-based pagination is a technique where the results are separated into
    pages by a cursor, and the results can be navigated forwards and backwards using
    the next and previous cursors that are provided in the response.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 基于游标的分页是一种技术，其中结果通过游标分隔成页面，并且可以使用响应中提供的下一个和上一个游标向前和向后导航结果。
- en: The cursor-based pagination API avoids returning duplicate records in cases
    where additional resources are added between pagination requests. This is because
    the cursor parameter is a pointer that indicates where to resume the results from,
    for the subsequent call.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 基于游标的分页 API 避免在分页请求之间添加额外资源的情况下返回重复记录。这是因为游标参数是一个指针，指示从哪里恢复结果，用于后续调用。
- en: Twitter and cursor-based pagination
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Twitter 和基于游标的分页
- en: 'Here is an example of how Twitter uses cursor-based pagination. A query to
    get the IDs of a user who has a large number of followers could be paginated and
    returned in the following format:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Twitter 如何使用基于游标的分页的示例。获取拥有大量关注者的用户的 ID 的查询可以进行分页，并以以下格式返回：
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `next_cursor` value could be passed to the next query to get the next set
    of results:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`next_cursor` 值可以传递给下一个查询，以获取下一组结果：'
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using the `next_cursor` and the `previous_cursor` values, it is easy to navigate
    between the set of results.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `next_cursor` 和 `previous_cursor` 值，可以轻松在结果集之间导航。
- en: Now that we have covered the different pagination techniques, let's go over
    a sample in detail. The following sample shows how to implement a simple offset-based
    pagination technique with JAX-RS.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了不同的分页技术，让我们详细介绍一个示例。以下示例显示了如何使用 JAX-RS 实现简单的基于偏移量的分页技术。
- en: The project's layout
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目的布局
- en: The project's directory layout follows the standard Maven structure, which is
    briefly explained in the following table.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的目录布局遵循标准的 Maven 结构，以下表格简要解释了这一点。
- en: The example used is that of a coffee shop service that can be queried for all
    orders placed so far.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 所使用的示例是咖啡店服务的示例，可以查询到目前为止所有下的订单。
- en: '| Source code | Description |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 源代码 | 描述 |'
- en: '| --- | --- |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `src/main/java` | This directory contains all the sources required by the
    coffee shop application |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `src/main/java` | 此目录包含咖啡店应用程序所需的所有源代码 |'
- en: 'Here is the `CoffeeResource` class:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `CoffeeResource` 类：
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `getCoffeeList()` method takes two `QueryParam` values: `page` and `limit`.
    The `page QueryParam` value corresponds to the page index and `limit` corresponds
    to the number of results per page. The `@DefaultValue` annotation specifies the
    default values that can be used if the query parameters are absent.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`getCoffeeList()` 方法接受两个 `QueryParam` 值：`page` 和 `limit`。`page QueryParam`
    值对应于页面索引，`limit` 对应于每页的结果数。`@DefaultValue` 注释指定了如果查询参数不存在可以使用的默认值。'
- en: Here is the output when the sample is run. The `metadata` element contains details
    of the `totalCount` value that is the total number of records. Additionally, there
    is the `links` attribute of `JSONArray` that contains details such as `self,`
    which is the current page, and `next`, which is the next link to fetch more results.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是运行示例时的输出。`metadata` 元素包含 `totalCount` 值的详细信息，即记录的总数。此外，还有 `JSONArray` 的 `links`
    属性，其中包含诸如 `self`（当前页面）和 `next`（获取更多结果的下一个链接）等详细信息。
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The sample is bundled with this book's downloadable source code bundle.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 示例与本书可下载的源代码包捆绑在一起。
- en: Tip
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is always a good practice to include the default values for the number of
    results per page in REST API for pagination. Also, it is recommended that the
    API developers add metadata on the response, so consumers of the API can fetch
    additional information easily to get the next set of results.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在 REST API 中，为分页包含每页结果数的默认值始终是一个好习惯。此外，建议 API 开发人员在响应中添加元数据，以便 API 的消费者可以轻松获取附加信息，以获取下一组结果。
- en: Internationalization and localization
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 国际化和本地化
- en: 'Often, services need to operate in a global environment and responses need
    to be tailored based on the country and locale. Localization parameters can be
    specified in one of the following fields:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，服务需要在全球环境中运行，并且响应需要根据国家和语言环境进行定制。本地化参数可以在以下字段之一中指定：
- en: HTTP headers
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 头
- en: Query parameters
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询参数
- en: Content of the REST response
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST 响应的内容
- en: Language negotiation is similar to content negotiation; the HTTP header `Accept-Language`
    can take different language codes based on any two-letter initial for ISO-3166
    country codes ([http://www.iso.org/iso/country_codes.htm)](http://www.iso.org/iso/country_codes.htm)).
    The `Content-Language` header is similar to the `Content-Type` header and can
    specify the language for the response.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 语言协商类似于内容协商；HTTP 头 `Accept-Language` 可以根据 ISO-3166 国家代码的任何两字母首字母取不同的语言代码（[http://www.iso.org/iso/country_codes.htm)](http://www.iso.org/iso/country_codes.htm)）。`Content-Language`
    头类似于 `Content-Type` 头，可以指定响应的语言。
- en: 'For example, here is a `Content-Language` header sent in the response to a
    request sent by a client:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是在客户端发送的请求的响应中发送的 `Content-Language` 头：
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding response sets `Content-Language` to `en` as part of the response.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的响应将 `Content-Language` 设置为 `en` 作为响应的一部分。
- en: JAX-RS supports runtime content negotiation using the `javax.ws.rs.core.Variant`
    class and `Request` objects. The `Variant` class may contain a media type, a language,
    and an encoding. The `Variant.VariantListBuilder` class is used to build a list
    of representation variants.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS 支持使用 `javax.ws.rs.core.Variant` 类和 `Request` 对象进行运行时内容协商。`Variant` 类可以包含媒体类型、语言和编码。`Variant.VariantListBuilder`
    类用于构建表示变体的列表。
- en: 'The following code snippet shows how to create a list of resource representation
    variants:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了如何创建资源表示变体的列表：
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code snippet calls the build method of the `VariantListBuilder`
    class with languages `"en"` and `"fr"`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段调用了 `VariantListBuilder` 类的 `build` 方法，语言为 `"en"` 和 `"fr"`。
- en: Query parameters can include locale-specific information so that the server
    can return the information in that language.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 查询参数可以包括特定于语言环境的信息，以便服务器可以以该语言返回信息。
- en: 'The following is an example:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This query shows an example that will include the locale in the query parameter
    to get details of books. Additionally, the content of the REST response can contain
    country-specific details such as currency codes, and other details based on the
    HTTP headers or the query parameters sent in the request.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询显示了一个示例，其中将在查询参数中包含区域设置以获取图书的详细信息。此外，REST响应的内容可以包含特定于国家/地区的细节，如货币代码，以及基于请求中发送的HTTP标头或查询参数的其他细节。
- en: Miscellaneous topics
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他主题
- en: The following sections cover some details on miscellaneous topics such as HATEOAS,
    and Extensibility in REST.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分涵盖了一些杂项主题的细节，如HATEOAS和REST中的可扩展性。
- en: HATEOAS
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HATEOAS
- en: '**Hypermedia as the Engine of Application State** (**HATEOAS**) is a constraint
    of the REST application architecture.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**超媒体作为应用状态的引擎**（**HATEOAS**）是REST应用程序架构的一个约束。'
- en: A hypermedia-driven API gives details about the APIs that are available and
    the corresponding actions that can be taken by the consumer, by providing hypermedia
    links in the response sent by the server.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 超媒体驱动的API通过在服务器发送的响应中提供超媒体链接，提供有关可用API和消费者可以采取的相应操作的详细信息。
- en: 'For example, a book representation for a REST resource that contains data such
    as the name and ISBN would look as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，包含名称和ISBN等数据的REST资源的图书表示如下所示：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A HATEOAS implementation would return the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: HATEOAS实现将返回以下内容：
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding sample, the `links` element has the `rel` and `href` JSON objects.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`links`元素具有`rel`和`href` JSON对象。
- en: The `rel` attribute in this example is a self-referencing hyperlink. More complex
    systems might include other relationships. For example, a book order might have
    a `"rel":"customer"` relationship, linking the book order to its customer. `href`
    is a complete URL that uniquely defines the resource.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`rel`属性是一个自引用的超链接。更复杂的系统可能包括其他关系。例如，图书订单可能具有`"rel":"customer"`关系，将图书订单链接到其客户。`href`是一个完整的URL，唯一定义资源。
- en: The advantage of HATEOAS is that it helps client developers explore the protocol.
    The links give client developers a hint as to what may be the possible next action
    to take. While there is no standard for hypermedia controls, the recommendations
    are to follow the ATOM RFC (4287).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: HATEOAS的优势在于它帮助客户端开发人员探索协议。链接为客户端开发人员提供了关于可能的下一步操作的提示。虽然没有超媒体控件的标准，但建议遵循ATOM
    RFC（4287）。
- en: Note
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: According to the Richardson Maturity Model, HATEOAS is considered the final
    level of REST. This means that each link is presumed to implement the standard
    REST verbs of `GET`, `POST`, `PUT`, and `DELETE`. Adding details using the `links`
    element as shown in the preceding code snippet gives the client the information
    they need to navigate the service and take the next action.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Richardson成熟度模型，HATEOAS被认为是REST的最终级别。这意味着每个链接都被假定实现标准的REST动词`GET`、`POST`、`PUT`和`DELETE`。使用`links`元素添加详细信息，如前面代码片段所示，可以为客户端提供导航服务和采取下一步操作所需的信息。
- en: The PayPal REST API and HATEOAS
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PayPal REST API和HATEOAS
- en: PayPal REST API provides HATEOAS support, so with every response, there is a
    collection of links that can help the consumer decide the next action to take.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: PayPal REST API提供HATEOAS支持，因此每个响应都包含一组链接，可以帮助消费者决定下一步要采取的操作。
- en: 'For example, a sample response from the PayPal REST API includes the JSON objects
    shown in the following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，PayPal REST API的示例响应包括以下代码中显示的JSON对象：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A brief description of the attributes is as follows.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的简要描述如下。
- en: '`href`: This contains information about URLs that can be used for future REST
    API calls'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`href`：这包含可用于未来REST API调用的URL的信息'
- en: '`rel`: This link shows how it is related to the previous REST API calls'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rel`：此链接显示它与先前的REST API调用相关'
- en: '`method`: This shows which method is to be used for the REST API calls'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method`：显示用于REST API调用的方法'
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more details, check [https://developer.paypal.com/docs/integration/direct/paypal-rest-payment-hateoas-links/](https://developer.paypal.com/docs/integration/direct/paypal-rest-payment-hateoas-links/).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多详细信息，请查看[https://developer.paypal.com/docs/integration/direct/paypal-rest-payment-hateoas-links/](https://developer.paypal.com/docs/integration/direct/paypal-rest-payment-hateoas-links/)。
- en: REST and extensibility
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST和可扩展性
- en: RESTful applications are more extensible as well as more maintainable over time.
    RESTful applications based on constraints of the design style are easier to understand
    and work with, mainly due to their simplicity. They are also more predictable,
    since it's all about the resources. Also, RESTful applications are easier to work
    with as opposed to an XML-RPC application, where the consumer needs to parse a
    complex WSDL document to even begin to understand what's happening.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 基于设计风格的约束的RESTful应用程序在时间上更具可扩展性和可维护性。基于设计风格的RESTful应用程序更易于理解和使用，主要是因为它们的简单性。它们也更可预测，因为一切都是关于资源。此外，与需要解析复杂WSDL文档才能开始理解发生了什么的XML-RPC应用程序相比，RESTful应用程序更易于使用。
- en: Additional topics for the REST API
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST API的其他主题
- en: The following section lists additional topics that may be useful for REST developers.
    We have covered topics in earlier chapters, from the designing of RESTful services,
    error handling, validations, authentication, and caching to rate limiting. This
    section focuses on additional utilities to empower the REST API developer with
    better testing and documentation.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分列出了对REST开发人员可能有用的其他主题。我们已经在早期章节中涵盖了从设计RESTful服务、错误处理、验证、身份验证和缓存到速率限制的主题。本节重点介绍了其他实用工具，以赋予REST
    API开发人员更好的测试和文档编制能力。
- en: Testing RESTful services
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试RESTful服务
- en: It is always efficient to have an automated set of tests, which can validate
    responses sent by the server. One such framework to build automated tests for
    RESTful services is REST Assured.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一组自动化测试总是有效的，可以验证服务器发送的响应。用于构建RESTful服务的自动化测试的一个框架是REST Assured。
- en: REST Assured is the Java DSL for easy testing of RESTful services. It supports
    `GET`, `PUT`, `POST`, `HEAD`, `OPTIONS`, and `PATCH`, and can be used to validate
    as well as verify responses that the server sends.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: REST Assured是用于轻松测试RESTful服务的Java DSL。它支持`GET`、`PUT`、`POST`、`HEAD`、`OPTIONS`和`PATCH`，可以用于验证服务器发送的响应。
- en: 'The following is an example of getting a coffee order and verifying the ID
    returned in the response:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个获取咖啡订单并验证响应中返回的ID的示例：
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding snippet, we make a call to get a coffee order and verify that
    the `coffee.id` value is 5.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的片段中，我们调用获取咖啡订单并验证`coffee.id`值为5。
- en: REST Assured supports specifying and validating, for example, parameters, headers,
    cookies, and body easily. It also supports mapping Java objects to and from JSON
    and XML. For more details, you can check [https://code.google.com/p/rest-assured/](https://code.google.com/p/rest-assured/).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: REST Assured支持轻松指定和验证参数、标头、Cookie和主体，也支持将Java对象与JSON和XML相互映射。有关更多详细信息，您可以查看[https://code.google.com/p/rest-assured/](https://code.google.com/p/rest-assured/)。
- en: Documenting RESTful services
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录RESTful服务
- en: It is always a good practice to provide documentation on the RESTful services
    built for the consumers, whether they are from within the same enterprise or whether
    the consumer is an external application or a mobile client. The following section
    covers some frameworks for providing good documentation for RESTful services.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为消费者构建RESTful服务时，无论他们来自同一企业还是来自外部应用程序或移动客户端，提供文档都是一个良好的实践。以下部分涵盖了一些为RESTful服务提供良好文档的框架。
- en: Swagger is a framework implementation for describing, producing, consuming,
    and visualizing RESTful web services. The documentation of methods, parameters,
    and models are tightly integrated into the server code. Swagger is language-agnostic
    and implementations for Scala, Java, and HTML5 are available.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger是一个用于描述、生成、消费和可视化RESTful web服务的框架实现。方法、参数和模型的文档紧密集成到服务器代码中。Swagger是与语言无关的，Scala、Java和HTML5的实现都可用。
- en: 'The tutorial on how to add Swagger to the REST API is found at the following
    URL:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何将Swagger添加到REST API的教程可在以下网址找到：
- en: '[https://github.com/wordnik/swagger-core/wiki/Adding-Swagger-to-your-API](https://github.com/wordnik/swagger-core/wiki/Adding-Swagger-to-your-API)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/wordnik/swagger-core/wiki/Adding-Swagger-to-your-API](https://github.com/wordnik/swagger-core/wiki/Adding-Swagger-to-your-API)'
- en: Recommended reading
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推荐阅读
- en: 'The following links refer to some of the topics that are covered in this chapter,
    and they will be useful to review and get detailed information:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下链接涉及本章涵盖的一些主题，对于审查和获取详细信息将会很有用：
- en: '[https://dev.twitter.com/docs](https://dev.twitter.com/docs): The Twitter API
    documentation'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://dev.twitter.com/docs](https://dev.twitter.com/docs): Twitter API文档'
- en: '[https://dev.twitter.com/console](https://dev.twitter.com/console): The Twitter
    Developer console'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://dev.twitter.com/console](https://dev.twitter.com/console): Twitter开发者控制台'
- en: '[https://dev.twitter.com/docs/rate-limiting/1.1](https://dev.twitter.com/docs/rate-limiting/1.1):
    The Twitter API rate limiting in v1.1'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://dev.twitter.com/docs/rate-limiting/1.1](https://dev.twitter.com/docs/rate-limiting/1.1):
    Twitter API在v1.1中的速率限制'
- en: '[https://dev.twitter.com/docs/misc/cursoring](https://dev.twitter.com/docs/misc/cursoring):
    The Twitter API and cursoring'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://dev.twitter.com/docs/misc/cursoring](https://dev.twitter.com/docs/misc/cursoring):
    Twitter API和游标'
- en: '[https://dev.twitter.com/docs/api/streaming](https://dev.twitter.com/docs/api/streaming):
    The Twitter streaming APIs'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://dev.twitter.com/docs/api/streaming](https://dev.twitter.com/docs/api/streaming):
    Twitter流API'
- en: '[https://developers.facebook.com/docs/reference/ads-api/api-rate-limiting/](https://developers.facebook.com/docs/reference/ads-api/api-rate-limiting/):
    Facebook API rate limiting'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developers.facebook.com/docs/reference/ads-api/api-rate-limiting/](https://developers.facebook.com/docs/reference/ads-api/api-rate-limiting/):
    Facebook API速率限制'
- en: '[https://developer.github.com/v3/rate_limit/](https://developer.github.com/v3/rate_limit/):
    GitHub API rate limiting'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developer.github.com/v3/rate_limit/](https://developer.github.com/v3/rate_limit/):
    GitHub API速率限制'
- en: '[https://developers.facebook.com/docs/opengraph/guides/internationalization/](https://developers.facebook.com/docs/opengraph/guides/internationalization/):
    Facebook localization'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developers.facebook.com/docs/opengraph/guides/internationalization/](https://developers.facebook.com/docs/opengraph/guides/internationalization/):
    Facebook本地化'
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered advanced topics that every RESTful API developer should
    know. In the beginning, we saw the rate-limiting sample that demonstrated how
    to enforce throttling so that the server is not blasted with API calls. We also
    saw how Twitter, GitHub, and Facebook APIs enforce rate limiting. We covered different
    pagination techniques and a basic pagination sample and best practices. Then,
    we moved on to internationalization and other miscellaneous topics. Finally, we
    covered HATEOAS and how it is the next level of REST API, REST, and extensibility
    topics.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了每个RESTful API开发人员都应该了解的高级主题。一开始，我们看到了速率限制示例，演示了如何强制执行节流，以便服务器不会被API调用淹没。我们还看到了Twitter、GitHub和Facebook
    API如何执行速率限制。我们涵盖了不同的分页技术和基本分页示例以及最佳实践。然后，我们转向国际化和其他杂项主题。最后，我们涵盖了HATEOAS以及它如何成为REST
    API、REST和可扩展性主题的下一个级别。
- en: The next chapter will cover other emerging standards such as WebSockets, WebHooks,
    and the role of REST in the future of evolving web standards.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将涵盖其他新兴标准，如WebSockets、WebHooks以及REST在不断发展的Web标准中的作用。
