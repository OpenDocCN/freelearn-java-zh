- en: Chapter 10. Concepts of Graph
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章 图的概念
- en: 'A graph is a generalization of a tree. In a tree, every node has one parent.
    In a graph, a node can have multiple parents. The most common way to think about
    a graph is as a set of vertices and edges. Vertices are like points and edges
    are like lines that connect the points. In the generic notion of a graph, there
    is no restriction on which vertices can be connected by edges. This allows graphs
    to model a versatile category of real-life concepts. The Internet, for example,
    is a graph where the vertices are the web pages and the edges the hyperlinks between
    the pages. A social networking site, such as Facebook, has a graph of profiles
    in which the vertices are the profiles and the edges the friendships between the
    profiles. Each software has a graph of dependencies, called a dependency graph,
    in which the vertices are the different software libraries used and the edges
    the dependencies between the software libraries. There is no end to examples of
    graphs. In this chapter, we will discuss the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 图是树的推广。在树中，每个节点只有一个父节点。在图中，一个节点可以有多个父节点。最常见的方式来思考图是将它视为顶点和边的集合。顶点就像点，边就像连接点的线。在图的一般概念中，没有限制哪些顶点可以通过边连接。这允许图模拟多种现实生活中的概念。例如，互联网是一个图，其中顶点是网页，边是页面之间的超链接。一个社交网络网站，如Facebook，有一个包含个人资料的图，其中顶点是个人资料，边是个人资料之间的友谊。每个软件都有一个依赖图，称为依赖关系图，其中顶点是使用的不同软件库，边是软件库之间的依赖关系。图的例子无穷无尽。在本章中，我们将讨论以下主题：
- en: Different types of graphs
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同类型的图
- en: The ADT graph
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图的ADT（抽象数据类型）
- en: Representation of graphs in memory
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图在内存中的表示
- en: Traversal of a graph
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图的遍历
- en: Cycle detection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环检测
- en: Spanning trees
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拓扑树
- en: Minimum spanning trees
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小生成树
- en: What is a graph?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是图？
- en: 'A graph is a collection of vertices and edges that connect the vertices. *Figure
    1* gives a visual representation of an example of a graph. There are a few features
    to note here, which we will discuss next:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图是由顶点和连接顶点的边组成的一组。*图1*展示了图的一个示例的视觉表示。这里有几个需要注意的特点，我们将在下一节讨论：
- en: '![What is a graph?](img/00070.jpeg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![什么是图？](img/00070.jpeg)'
- en: 'Figure 1: Example of an undirected graph'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：无向图的示例
- en: '**Undirected graph**: An undirected graph is a graph in which the edges have
    no direction, as shown in *Figure 1*.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无向图**：无向图是一种边没有方向的图，如图*图1*所示。'
- en: '**Directed graph**: This is a graph in which the edges have a direction.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有向图**：这是一种边有方向的图。'
- en: '**Path**: A path is a sequence of edges that connects a set of vertices that
    are distinct from one another, except the first and the last vertices as they
    may be the same. For example, in *Figure 1*, the edges **AB**, **BD**, and **DE**
    represent a path. It can also be described as the **ABDE** path, which does not
    repeat its vertices. In the case of a directed graph, the edges must traverse
    only in the specified direction to form the sequence of edges required to make
    a path.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路径**：路径是一系列连接一组彼此不同的顶点的边，除了第一个和最后一个顶点可能相同之外。例如，在*图1*中，边**AB**、**BD**和**DE**代表一个路径。它也可以描述为**ABDE**路径，该路径不重复其顶点。在有向图中，边必须仅按指定的方向遍历，才能形成构成路径所需的边的序列。'
- en: '**Cycle**: A cycle is a path with at least two vertices involved; it starts
    and ends on the same vertex. For example, in *Figure 1*, the path **DCED** is
    a cycle.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环**：环是一个至少涉及两个顶点的路径；它从同一个顶点开始和结束。例如，在*图1*中，路径**DCED**是一个环。'
- en: '**Loop**: A loop is an edge that connects a node to itself. In *Figure 1*,
    vertex **A** has a loop.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环**：环是一个连接节点到自身的边。在*图1*中，顶点**A**有一个环。'
- en: '**Subgraph**: The subgraph of a graph is another type of graph where all the
    edges and vertices are the same as the edges and vertices of the original graph.
    For example, in *Figure 1*, the nodes **A**, **B**, and **C** along with the edges
    **AB** and **BC** represent a subgraph.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子图**：图的子图是另一种类型的图，其中所有的边和顶点都与原始图的边和顶点相同。例如，在*图1*中，节点**A**、**B**和**C**以及边**AB**和**BC**代表一个子图。'
- en: '**Connected graph**: A connected graph is a graph in which there exists a path
    that starts from any arbitrary vertex and ends in any arbitrary, but different
    vertex. The graph in *Figure 1* is not connected. But, the subgraph with vertices
    **H**, **I**, and **J** and the edges **HI**, **IJ**, and **JH** represent a connected
    subgraph:![What is a graph?](img/00071.jpeg)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连通图**：连通图是一个存在从任意顶点开始并结束在任意但不同的顶点的路径的图。*图1*中的图不是连通的。但是，顶点**H**、**I**和**J**以及边**HI**、**IJ**和**JH**表示一个连通子图：![什么是图？](img/00071.jpeg)'
- en: Figure 2\. Example directed graph
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2. 有向图的例子
- en: '**Tree**: A tree is a connected but undirected graph with no cycles and loops.
    *Figure 3* shows an example of a tree. Note that this is slightly different from
    the tree we have studied earlier. This tree does not have any particular root.
    The nodes in this tree do not have any particular parent, and any node can act
    as a root:![What is a graph?](img/00072.jpeg)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**树**：树是一个连通但无向图，没有环或循环。*图3*展示了树的例子。请注意，这与我们之前研究过的树略有不同。这棵树没有特定的根。这棵树中的节点没有特定的父节点，任何节点都可以作为根：![什么是图？](img/00072.jpeg)'
- en: Figure 3\. Example tree
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3. 树的例子
- en: '**Forest**: A forest is an unconnected, undirected graph with no cycles or
    loops. You can think of a forest as a collection of trees. A single tree is also
    a forest. In other words, a forest is a collection of zero or more trees.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**森林**：森林是一个无连接、无向图，没有环或循环。你可以把森林想象成树集合。单独一棵树也是一个森林。换句话说，森林是零棵或多棵树的集合。'
- en: '**Complete graph**: A complete graph is an undirected graph that has the maximum
    number of edges, given a certain number of vertices. It also has constraints as
    per which there can only be one edge between two given vertices, with no loops.
    *Figure 4* shows an example of a complete graph. For a complete graph with the
    set of vertices *V* and the set of edges *E*, *|E| = |V| ( |V| - 1) / 2*. It is
    easy to see why this is the case. Each vertex will have an edge between itself
    and other *|V| - 1* nodes. That makes a total of *|V| ( |V| - 1)* edges. However,
    in this approach, each edge is counted twice, once for each of its two vertices.
    So, the actual number of edges in a complete graph is *|V| ( |V| - 1) / 2*:![What
    is a graph?](img/00073.jpeg)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完全图**：完全图是在给定顶点数的情况下具有最大边数的无向图。它也有约束，即两个给定顶点之间只能有一条边，没有环。*图4*展示了完全图的例子。对于一个顶点集*V*和边集*E*的完全图，*|E|
    = |V| ( |V| - 1) / 2*。很容易看出为什么会这样。每个顶点都会与其他*|V| - 1*个节点之间有一条边。这总共是*|V| ( |V| -
    1)*条边。然而，在这种方法中，每条边都被计算了两次，一次为它的两个顶点之一。因此，完全图中的实际边数是*|V| ( |V| - 1) / 2*：![什么是图？](img/00073.jpeg)'
- en: Figure 4\. A complete graph
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4. 完全图
- en: The graph ADT
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形抽象数据类型
- en: 'We will now define what a data structure representing a graph should do. Later,
    we will discuss the different implementations of this ADT. A graph must support
    the following operations:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将定义表示图的图形抽象数据类型应该做什么。稍后，我们将讨论这个ADT的不同实现。一个图必须支持以下操作：
- en: '**Add Vertex**: This adds a new vertex'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加顶点**：这添加一个新顶点'
- en: '**Remove Vertex**: This removes a vertex'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移除顶点**：这移除一个顶点'
- en: '**Add edge**: This adds a new edge; in our graph, we will allow a maximum of
    one edge between two vertices for simplicity'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加边**：这添加一条新边；在我们的图中，为了简单起见，我们将在两个顶点之间允许最多一条边'
- en: '**Remove edge**: This removes an edge'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移除边**：这移除一条边'
- en: '**Adjacent**: This checks whether the two given vertices are adjacent to each
    other, that is, whether there is an edge between the given nodes'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相邻**：这检查两个给定的顶点是否相邻，即是否存在给定节点之间的边'
- en: '**Neighbors**: This returns a list of vertices that are adjacent to the given
    vertex'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**邻居**：这返回与给定顶点相邻的顶点列表'
- en: '**Get Vertex Value**: This gets the value stored in a vertex'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取顶点值**：这获取存储在顶点中的值'
- en: '**Set Vertex Value**: This stores a value in a vertex'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置顶点值**：这存储一个值在顶点中'
- en: '**Get Edge Value**: This gets the value stored in an edge'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取边值**：这获取存储在边中的值'
- en: '**Set Edge Value**: This sets the value stored in an edge'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置边值**：这设置存储在边中的值'
- en: '**Is undirected**: This returns whether the graph is undirected'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无向图**：这返回图是否为无向图'
- en: '**Get all vertices**: This returns a self-balancing binary search tree containing
    all the vertices'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取所有顶点**：这返回包含所有顶点的自平衡二叉搜索树'
- en: '**Max Vertex ID**: This returns the highest ID of the vertices'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大顶点ID**：这返回顶点的最高ID'
- en: 'Our algorithms will depend on the above operations being available in a graph
    data structure. The following Java interface is a realization of this ADT:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们算法的依赖性将取决于上述操作在图数据结构中可用。以下Java接口是这个ADT的实现：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We identify each vertex by an ID; edges are identified by a source vertex and
    a target vertex. In the case of an undirected graph, the source and target could
    be interchanged. But, in the case of a directed graph, they are noninterchangeable.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过ID标识每个顶点；边通过源顶点和目标顶点来标识。在无向图的情况下，源点和目标点可以互换。但在有向图的情况下，它们是不可互换的。
- en: Now that we have an ADT, we would like to have an implantation. To implement
    a graph data structure, we need to choose a representation in memory.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了ADT，我们希望有一个实现。为了实现图数据结构，我们需要在内存中选择一种表示方式。
- en: Representation of a graph in memory
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图在内存中的表示
- en: 'A graph can be represented mainly in three different ways: adjacency matrix,
    adjacency list, and incidence matrix.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图可以通过三种主要方式表示：邻接矩阵、邻接表和关联矩阵。
- en: Adjacency matrix
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 邻接矩阵
- en: 'An adjacency matrix is a matrix, a table of values, where each value represents
    an edge and both the rows are the columns that represent the vertices. The values
    in a matrix can be the members of the entry. The values of the edges can be stored
    in the matrix itself. There could also be a special value for representing the
    absence of an edge. The following image shows an adjacency matrix for the graph
    in *Figure 1*, where the value of the edge represents the number of edges between
    the corresponding vertices:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 邻接矩阵是一个矩阵，一个值表，其中每个值代表一条边，行和列都代表顶点。矩阵中的值可以是条目成员。边的值可以存储在矩阵本身中。也可以有一个特殊值来表示边的不存在。以下图像显示了*图1*的邻接矩阵，其中边的值表示对应顶点之间的边数：
- en: '![Adjacency matrix](img/00074.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![邻接矩阵](img/00074.jpeg)'
- en: 'The following things can be noted about an adjacency matrix:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 关于邻接矩阵可以注意以下事项：
- en: Rows are used to represent the sources and columns to represent the targets
    of the edges
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行用于表示边的源点，列用于表示边的目标点
- en: In the case of an undirected graph, the source and target are indistinguishable,
    so the adjacency matrix is symmetric
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在无向图的情况下，源点和目标点是不可区分的，因此邻接矩阵是对称的
- en: 'The following code provides an implementation of the graph ADT with the adjacency
    matrix. We use a two-dimensional array to store the matrix. The ID of any vertex
    is directly used as the index of the array. This is true for both the array to
    store the values stored within the vertices and the values stored in the edges,
    or even the existence of the edges. When we remove a vertex, we don''t free its
    space; we do this so that the IDs of the newer vertices don''t get shifted. This
    improves lookup performance but is wasteful in terms of resources:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码提供了一个使用邻接矩阵实现的图ADT。我们使用二维数组来存储矩阵。任何顶点的ID直接用作数组的索引。这适用于存储顶点内部值的数组以及存储在边中的值，甚至边的存在性。当我们删除一个顶点时，我们不释放其空间；我们这样做是为了确保新顶点的ID不会移动。这提高了查找性能，但在资源方面是浪费的：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We create two special objects to signify an edge and a vertex; these objects
    do not yet hold a value. A null reference refers to the edge or vertex that does
    not exist:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个特殊对象来表示边和顶点；这些对象尚未持有值。一个空引用指向不存在边或顶点：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A flag determines whether the graph is undirected:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一个标志位用于确定图是否无向：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Adding a vertex involves creating a new matrix and an array of vertex values
    and copying all the older values into it:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 添加顶点涉及创建一个新的矩阵和一个顶点值数组，并将所有旧值复制到其中：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Since we don''t free any space, removing a vertex simply involves setting values
    to null. Note that removing a vertex has to be accompanied by the removal of all
    the associated edges, which is done in a loop:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有释放任何空间，删除顶点只需将值设置为null。请注意，删除顶点必须伴随着所有相关边的删除，这是通过循环完成的：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Adding an edge involves setting a particular position in the adjacency matrix.
    If the graph is undirected, there will be two updates. This is because the source
    and target could be interchanged and the adjacency matrix is always symmetric:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 添加边涉及在邻接矩阵中设置特定位置。如果图是无向的，将会有两次更新。这是因为源点和目标点可以互换，而邻接矩阵始终是对称的：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following operation is the simplest of all as it involves setting only
    one edge to null. In the case of an undirected graph, there would be a corresponding
    update that would interchange the source and target:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下操作是最简单的，因为它只涉及将一个边设置为null。在无向图的情况下，会有一个相应的更新来交换源和目标：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following is a trivial operation of checking the adjacency matrix:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个检查邻接矩阵的简单操作：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For any given source, find all the edges in the same row of the matrix and
    add them to a linked list that we can return. Note that in a directed graph, it
    traverses the edges only in the forward direction:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何给定的源，找到矩阵中同一行的所有边并将它们添加到一个我们可以返回的链表中。请注意，在有向图中，它只按正向遍历边：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We store all the values of the vertices in a different array:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将顶点的所有值存储在不同的数组中：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The values stored in the edges can be stored in the adjacency matrix itself:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在边中的值可以存储在邻接矩阵本身中：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Complexity of operations in a sparse adjacency matrix graph
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 稀疏邻接矩阵图操作的复杂度
- en: 'Now let''s analyze the complexity of the operations we have already discussed:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来分析我们已讨论的操作的复杂度：
- en: '**Add vertex**: Adding a vertex requires us to create a new two-dimensional
    array with length and w the complexities of the idth *|V|* and then copy the entire
    old content to the new array. Here, *|V|* represents the cardinality of the set
    *V* of the vertices. What is the size of the adjacency matrix then? It''s a square
    matrix whose length or width equals *|V|*, so its size is *|V|*². Hence, adding
    a new edge has this complexity: *θ(|V|*²*)*.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加顶点**: 添加顶点需要我们创建一个新的二维数组，其长度和w的复杂度为idth *|V|*，然后将整个旧内容复制到新数组中。在这里，*|V|*
    代表顶点集合 *V* 的基数。那么邻接矩阵的大小是多少呢？它是一个长度或宽度等于 *|V|* 的方阵，因此其大小是 *|V|*²。因此，添加新边的复杂度是
    *θ(|V|*²*)*。'
- en: '**Remove Vertex**: Removing a vertex involves removing all the edges that correspond
    to the given vertex. The maximum number of edges that can be associated with a
    single vertex is *|V|*, which is the length of a row or column in the adjacency
    matrix. We must set all the values in the row and column containing the vertex
    being deleted, so the number of values that need to be changed is calculated as
    *2|V| - 1*. The "minus one" part comes from the fact that the row and column have
    one edge in common, the edge representing a loop on the node that is being deleted.
    The common edge is counted twice, both in the row and the column. So one of them
    must be stopped. Therefore, the complexity of this operation is *θ(2|V| - 1) =
    θ(|V|)*.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移除顶点**: 移除顶点涉及到移除与给定顶点相对应的所有边。一个顶点可以关联的最大边数是 *|V|*，这是邻接矩阵中行或列的长度。我们必须设置包含要删除的顶点的行和列中的所有值，因此需要更改的值的数量计算为
    *2|V| - 1*。减一的这部分来自于这样一个事实，即行和列有一个共同的边，代表正在删除的节点上的环。这个共同的边在行和列中都计算了两次。因此，其中之一必须停止。因此，这个操作的复杂度是
    *θ(2|V| - 1) = θ(|V|)*。'
- en: '**Add edge and Remove edge**: Adding an edge is as simple as setting a special
    value at a single entry in the adjacency matrix. It has this complexity: *θ(1)*.
    Removing an edge is just setting null at the same position.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加边和移除边**: 添加边就像在邻接矩阵的单个条目中设置一个特殊值一样简单。它具有这种复杂度：*θ(1)*。移除边只是在同一位置设置null。'
- en: '**Adjacent**: This operation involves checking whether an edge exists between
    the given source and target. It checks one entry in the adjacency matrix, hence
    this complexity: *θ(1)*.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相邻**: 这个操作涉及检查给定源和目标之间是否存在边。它检查邻接矩阵中的一个条目，因此具有这种复杂度：*θ(1)*。'
- en: '**Neighbors**: This operation requires reading all the values in the row of
    an adjacency matrix. So it requires reading *|V|* values and possibly adding them
    to a linked list. Therefore, the complexity of this operation is *θ( |V| )*.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**邻居**: 这个操作需要读取邻接矩阵行的所有值。因此，它需要读取 *|V|* 个值，并可能将它们添加到一个链表中。因此，这个操作的复杂度是 *θ(
    |V| )*。'
- en: '**Setting and getting values at vertices and edges**: These operations require
    reading/setting a single value into/from the adjacency matrix. These operations
    are all *θ(1)*.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在顶点和边上设置和获取值**: 这些操作需要将单个值读入或读出邻接矩阵。这些操作都是 *θ(1)*。'
- en: '**Get all vertices**: This involves scanning through all the vertices and inserting
    them in a binary search tree. So this operation is *θ( |V| lg |V|)*.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取所有顶点**: 这涉及到遍历所有顶点并将它们插入到一个二叉搜索树中。因此，这个操作的复杂度是 *θ( |V| lg |V|)*。'
- en: More space-efficient adjacency-matrix-based graph
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更高效的空间邻接矩阵图
- en: The trouble with the above graph implementation is that we are unable to recover
    any space when vertices are deleted. The problem with recovering space is that
    it changes the indexes of the vertices that are added later. To avoid this, we
    can choose to have an ID of a vertex that is separate from its index position
    in the arrays. If we do this, we need to be able to search the index of a vertex
    with the given ID. This mapping can be done with a self-balancing binary search
    tree, which is what we are going to do here.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图实现的问题在于，当我们删除顶点时无法恢复任何空间。恢复空间的问题在于它会改变后来添加的顶点的索引。为了避免这种情况，我们可以选择顶点的 ID 与其在数组中的索引位置分开。如果我们这样做，我们需要能够使用给定的
    ID 搜索顶点的索引。这种映射可以通过一个自平衡的二分搜索树来完成，这正是我们在这里要做的。
- en: 'First, we create a separate class that represents a graph vertex. The idea
    is to allow a comparison to exist on the ID of a vertex. Different graph implementations
    can then extend this class to accommodate additional data in the graph vertex:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个代表图顶点的单独类。想法是允许对顶点的 ID 进行比较。不同的图实现可以扩展这个类以适应图顶点中的额外数据：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With this class available, we can implement our adjacency-matrix-based graph
    implementation with a dense vertex and edge representation:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个类，我们可以实现基于邻接矩阵的图实现，具有密集的顶点和边表示：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'First, we extend the `GraphVertex` class to include an `addition` field that
    stores the index of a vertex in the adjacency matrix as well as in the array meant
    for storing the values of the vertices:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们扩展 `GraphVertex` 类以包括一个 `addition` 字段，该字段存储顶点在邻接矩阵和用于存储顶点值的数组中的索引：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `nextId` variable is used to store the next ID that would be used:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`nextId` 变量用于存储将要使用的下一个 ID：'
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Special values to represent empty vertices and edges:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 用特殊值来表示空顶点和边：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following is the binary search tree that stores the vertices with their
    indexes in the arrays:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的二分搜索树存储了顶点及其在数组中的索引：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The process of adding involves the same operations as before apart from the
    extra operation of generating a new ID and storing an entry in the search tree:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 添加过程涉及与之前相同的操作，除了额外的生成新 ID 并在搜索树中存储条目的操作：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The removal of a vertex now actually involves creating a smaller adjacency
    matrix and copying all the edges, except the ones associated with the vertex that
    is being deleted:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在删除顶点实际上涉及创建一个较小的邻接矩阵并复制所有边，除了与被删除顶点关联的边：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'First, copy all the rows before the one for the vertex being deleted:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，复制被删除顶点所在行之前的全部行：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, copy all the rows after the one for the vertex being deleted:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，复制被删除顶点所在行之后的全部行：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now adjust all the indexes of the vertices added after the one that is deleted.
    We do this by traversing the tree in preorder and updating only when appropriate:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，调整被删除顶点之后添加的所有顶点的索引。我们通过先序遍历树并在适当的时候更新索引来完成此操作：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Adding an edge involves setting an entry in the adjacency matrix. However,
    before doing this, we need to look up the index of the vertex:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 添加边涉及在邻接矩阵中设置一个条目。然而，在这样做之前，我们需要查找顶点的索引：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is the same as adding an edge, other than the fact that we change the
    corresponding entry in the adjacency matrix to null:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这与添加边相同，只是我们将邻接矩阵中相应的条目改为 null：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Checking whether two vertices are adjacent involves looking up a value in the
    adjacency matrix like before. But again, we must first look up the indexes of
    the vertices:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 检查两个顶点是否相邻涉及像之前一样在邻接矩阵中查找一个值。但同样，我们首先必须查找顶点的索引：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Getting the list of neighbors is a little trickier. We don''t have a search
    mechanism that lets us search by index to look up the ID. So instead of reading
    a row in the adjacency matrix, we simply preorder traverse the search tree and
    check whether there is an edge for the vertex in the adjacency matrix. We add
    a vertex only when there is an edge between the source vertex and the vertex in
    question:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 获取邻居列表稍微复杂一些。我们没有一种搜索机制允许我们通过索引来搜索 ID。因此，我们不是读取邻接矩阵中的一行，而是简单地先序遍历搜索树并检查邻接矩阵中是否存在与顶点相关的边。我们只在源顶点和问题顶点之间存在边时添加顶点：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The process of setting and getting values into/from the edges and vertices
    is the same as before, except that we need to look up the index from the ID of
    the vertex before using it:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将值设置到边和顶点中或从边和顶点中获取值的过程与之前相同，除了在使用之前需要从顶点的 ID 中查找索引：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Complexity of operations in a dense adjacency-matrix-based graph
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于密集邻接矩阵的图的运算复杂度
- en: 'The following are the complexities of the operations we just discussed in a
    dense adjacency-matrix-based graph:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们刚刚在基于密集邻接矩阵的图中讨论的运算的复杂度：
- en: '**Add vertex**: Addition still has the same *θ(|V|*²*)* operation for creating
    a new adjacency matrix and copying all the old values. The additional operation
    of inserting a new vertex in the search tree is *θ(lg |V|)*. So the entire operation
    is still *θ(|V|**2**)*.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加顶点**：添加顶点的操作仍然具有相同的 *θ(|V|²*)* 操作，用于创建一个新的邻接矩阵并复制所有旧值。在搜索树中插入新顶点的附加操作是
    *θ(lg |V|)*。因此，整个操作仍然是 *θ(|V|²)*。'
- en: '**Remove vertex**: The removal of a vertex here follows the same operation
    of recreating an adjacency matrix and copying all the old values, which is *θ(|V|*²*)*.
    The operation of removing a vertex from the search tree is *θ(lg |V|)*. So the
    entire operation is *θ(|V|*²*)*.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除顶点**：在这里删除顶点的操作遵循重新创建邻接矩阵并复制所有旧值的相同操作，这是 *θ(|V|²)*。从搜索树中删除顶点的操作是 *θ(lg
    |V|)*。因此，整个操作是 *θ(|V|²)*。'
- en: '**Add edge and remove edge**: The operation of updating an entry in the adjacency
    matrix is still *θ(1)*. However, now we need to have two lookups in the search
    tree to figure out the indexes of the source and target. Both these searches are
    *θ(lg |V|)*. So the entire operation is *θ(lg |V|)*.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加边和删除边**：更新邻接矩阵中的条目的操作仍然是 *θ(1)*。然而，现在我们需要在搜索树中进行两次查找，以确定源和目标索引。这两次查找都是
    *θ(lg |V|)*。因此，整个操作是 *θ(lg |V|)*。'
- en: '**Adjacent**: This is also *θ(lg |V|)* due to the same reason mentioned in
    the preceding bullet point.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相邻**：这也同样是 *θ(lg |V|)*，原因与前面提到的相同点。'
- en: '**Neighbors**: Traversing the search tree is *θ(|V|)*, and for each of the
    vertices thus traversed, we create a constant number of operations. Looking up
    the index of the source vertex is *θ(lg |V|)*. Hence, the entire operation is
    still *θ(|V|)*.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**邻居**：遍历搜索树是 *θ(|V|)*，并且对于遍历的每个顶点，我们创建一个固定数量的操作。查找源顶点的索引是 *θ(lg |V|)*。因此，整个操作仍然是
    *θ(|V|)*。'
- en: '**Setting and getting values at vertices and edges**: These operations require
    a fixed number of lookups (one or two) and then a constant time operation for
    setting or getting the appropriate value. The lookups are *θ(lg |V|)*, so the
    entire operations are also *θ(lg |V|)*.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在顶点和边设置和获取值**：这些操作需要固定数量的查找（一个或两个），然后进行常数时间的设置或获取适当值的操作。查找是 *θ(lg |V|)*，因此整个操作也是
    *θ(lg |V|)*。'
- en: '**Get all** **vertices**: Just like the previous implementation, this operation
    is *θ( |V| lg |V|)*.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取所有顶点**：与之前的实现一样，此操作是 *θ( |V| lg |V|)*。'
- en: Adjacency list
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 邻接表
- en: An adjacency list is a more space-efficient graph representation of sparse graphs.
    A sparse graph is a graph that has a very few edges as compared to the number
    of edges in a complete graph with the same number of vertices. A complete graph
    has *|V| ( |V| - 1) / 2 = θ (|V|* *2* *)* edges, and the memory space required
    to store a graph as an adjacency matrix is also *θ (|V|* *2* *)*. So, in the case
    of a dense (almost complete) graph, it makes sense to store it as an adjacency
    matrix. However, this is not true for a sparse graph.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 邻接表是稀疏图的一种更节省空间的图表示。稀疏图是与具有相同顶点数的完全图相比边数非常少的图。完全图有 *|V| (|V| - 1) / 2 = θ(|V|²)*
    条边，将图作为邻接矩阵存储所需的内存空间也是 *θ(|V|²)*。因此，在密集（几乎完全）图的情况下，将其存储为邻接矩阵是有意义的。然而，对于稀疏图来说，这并不成立。
- en: 'In an adjacency list representation, vertices are stored in an array or some
    other data structure, and edges are stored along with the vertices in some list
    or some other structure. First, we will consider an adjacency-list-based representation
    where the vertices are stored in an array indexed by their IDs, as in the case
    of a sparse adjacency matrix representation. It has the same problem: we cannot
    reduce the size of the array of vertices when a vertex is deleted. However, in
    this case, the list of edges are deleted, and this makes it way more space-efficient
    than what we encountered in an adjacency matrix:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在邻接表表示中，顶点存储在数组或某种其他数据结构中，边与顶点一起存储在某些列表或某种其他结构中。首先，我们将考虑一个基于邻接表的表示，其中顶点按其ID存储在数组中，就像稀疏邻接矩阵表示的情况一样。它存在相同的问题：当删除顶点时，我们无法减小顶点数组的大小。然而，在这种情况下，边列表被删除，这使得它比我们在邻接矩阵中遇到的情况要节省空间得多：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `Edge` class stores the details of the target and the value of an edge
    originating from a vertex. The vertex stores a collection of the associated edges.
    We make the edge comparable based of the ID of the target so that we can store
    them in a binary search tree to easily look it up based on the ID:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`Edge` 类存储了从顶点起源的边的目标和值。顶点存储了与之关联的边的集合。我们根据目标边的 ID 使边可比较，这样我们就可以将它们存储在二叉搜索树中，以便根据
    ID 容易查找：'
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To improve the performance of the `getNeighbors` operation, we store a list
    of neighbors in the node. We store a pointer in the node that corresponds to the
    target of this node in the `targetNode` state variable:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高 `getNeighbors` 操作的性能，我们在节点中存储邻居列表。我们在节点中存储一个指针，该指针对应于 `targetNode` 状态变量中此节点的目标：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `Vertex` class is used to store a vertex along with its associated edges.
    The edges are stored in a red black tree:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vertex` 类用于存储顶点及其关联的边。边存储在红黑树中：'
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The vertices are then stored in an array:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将顶点存储在数组中：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Adding a vertex does not require us to copy any edges; it just ensures that
    the vertices are copied to a newly created array of bigger size:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 添加顶点不需要我们复制任何边；它只是确保顶点被复制到新创建的更大大小的数组中：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Removing a vertex requires that you first set the vertex to null at its position.
    However, you must also remove all the edges from all the other vertices for which
    the deleted vertex was the target:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 删除顶点需要首先将其位置上的顶点设置为 null。然而，您还必须删除所有其他顶点中与被删除顶点作为目标的边：
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We must remove all the edges associated with the vertex being deleted:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须删除与被删除顶点相关联的所有边：
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Adding an edge requires making corresponding entries in the vertices associated
    with it:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 添加边需要在其关联的顶点中创建相应的条目：
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Removing an edge requires removing the corresponding entries in the associated
    vertices:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 删除边需要从关联的顶点中删除相应的条目：
- en: '[PRE37]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Checking adjacency involves looking up the source vertex first and then looking
    up an edge for the target in the corresponding red black tree:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 检查邻接关系涉及首先查找源顶点，然后在相应的红黑树中查找目标边的边：
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We have the list of neighbors precomputed, so we simply return this list:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们预先计算了邻居列表，所以我们只需简单地返回此列表：
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The process of setting and getting the values of a vertex or an edge are self-explanatory:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 设置和获取顶点或边的值的过程是显而易见的：
- en: '[PRE40]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Complexity of operations in an adjacency-list-based graph
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于邻接表的图的操作复杂度
- en: 'The following lists the complexities of the operations we have discussed in
    an adjacency-list-based graph:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出了我们在基于邻接表的图中讨论的操作的复杂度：
- en: '**Add vertex**: Addition of a vertex requires that you create a new array first
    and then copy all the vertices to it. So it is *θ(|V|)*.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加顶点**：添加顶点需要首先创建一个新的数组，然后将所有顶点复制到其中。所以它是 *θ(|V|)*。'
- en: '**Remove Vertex**: The removal process does not change the array of the vertices.
    However, this operation involves checking each vertex to remove the edges which
    has the vertex being deleted as the target. So this operation is *θ(|V|)* as well.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除顶点**：删除过程不会改变顶点的数组。然而，此操作涉及检查每个顶点以删除具有被删除顶点作为目标的边。因此，此操作也是 *θ(|V|)*。'
- en: 'Add edge and remove edge: The first step of this operation is to look up the
    source vertex, which is constant time. The second step is to add or remove an
    edge in a red black tree, so it is *θ(lg |V|)*. So the entire operation of adding/deleting
    an edge is *θ(lg |V|)*.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加边和删除边：此操作的第一个步骤是查找源顶点，这是常数时间。第二个步骤是在红黑树中添加或删除边，所以它是 *θ(lg |V|)*。因此，添加/删除边的整个操作是
    *θ(lg |V|)*。
- en: '**Adjacent**: The first step of this operation is to look up the source vertex,
    which is constant time. The second step is to look up the edge in a red black
    tree, so it is *θ(lg |V|)*. So the entire operation of adding/deleting an edge
    is *θ(lg |V|)*.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相邻**：此操作的第一个步骤是查找源顶点，这是常数时间。第二个步骤是在红黑树中查找边，所以它是 *θ(lg |V|)*。因此，添加/删除边的整个操作是
    *θ(lg |V|)*。'
- en: '**Neighbors**: Since the list of neighbors is precomputed, the complexity is
    the same as that for looking up a vertex, which is constant time.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**邻居**：由于邻居列表是预先计算的，其复杂度与查找顶点相同，即常数时间。'
- en: '**Setting and Getting values at vertices**: These operations require looking
    up the vertex first, which is constant time. The second step is setting/getting
    the value. These operations are *θ(1)*.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在顶点设置和获取值**：这些操作需要首先查找顶点，这是常数时间。第二步是设置/获取值。这些操作是 *θ(1)*。'
- en: '**Setting and Getting values at edges**: These operations require looking up
    the source vertex first and then looking up the particular edge. The first is
    *θ(1)* and the second is *θ(lg |V|)*. At the end, setting or getting the value
    of an edge is *θ(l)*. Hence, the total operation is *θ(lg |V|)*.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在边处设置和获取值**：这些操作需要首先查找源顶点，然后查找特定的边。第一个操作是 *θ(1)*，第二个是 *θ(lg |V|)*。最后，设置或获取边的值是
    *θ(l)*。因此，总操作是 *θ(lg |V|)*。'
- en: '**Get all vertices**: This operation is *θ( |V| lg |V| )*, just like the previous
    implementations.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取所有顶点**：此操作是 *θ( |V| lg |V| )*，就像之前的实现一样。'
- en: Adjacency-list-based graph with dense storage for vertices
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于邻接表且顶点密集存储的图
- en: 'Just as in the case of an adjacency-matrix-based graph, dense storage of vertices
    can be done using a search tree instead of an array. This allows us to recover
    space when we delete a vertex without affecting the IDs of the other vertices.
    Everything else remains the same as the array-based storage of the vertices:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 就像基于邻接矩阵的图一样，可以使用搜索树而不是数组来密集存储顶点。这允许我们在删除顶点时不影响其他顶点的ID来恢复空间。其他所有内容都与基于数组的顶点存储相同：
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `nextId` variable stores the value that would be the ID of the next vertex
    that is inserted:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`nextId` 变量存储下一个要插入的顶点的ID值：'
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We have the `Edge` and `Vertex` class as before:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然有 `Edge` 和 `Vertex` 类：
- en: '[PRE43]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, instead of using an array to store the vertices, use a red black tree:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再使用数组来存储顶点，而是使用红黑树：
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Adding a new vertex means inserting a new one in the red black tree:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新顶点意味着在红黑树中插入一个新的顶点：
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The removal process, as before, involves not only removing the vertex but also
    going through all the other vertices and deleting every edge that has the vertex
    that is being deleted as the target:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，删除过程不仅包括删除顶点，还要遍历所有其他顶点，删除所有以被删除顶点为目标顶点的边：
- en: '[PRE46]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The first step is to find the source and the target node to confirm that they
    exist. After this, add an edge to the collection of edges of the source node.
    If the graph is undirected, add an edge to the collection of edges in the target
    node as well:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是找到源节点和目标节点以确认它们的存在。之后，将边添加到源节点的边集合中。如果图是无向的，也将边添加到目标节点的边集合中：
- en: '[PRE47]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The first step is the same as that of the previous one. After this, the edge
    is removed from the collection of the edges of the source node. If the graph is
    undirected, the edge is also removed from the collection of edges in the target
    node:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步与之前相同。之后，从源节点的边集合中删除边。如果图是无向的，也从目标节点的边集合中删除边：
- en: '[PRE48]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The first step is the same as that of the previous one. After this, the edge
    with the correct target is looked up. If the edge is found, the vertices are adjacent:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步与之前相同。之后，查找具有正确目标顶点的边。如果找到边，则顶点相邻：
- en: '[PRE49]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We just look up the vertex and then return our precomputed list of neighbors:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需查找顶点，然后返回预先计算好的邻居列表：
- en: '[PRE50]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The process of setting and getting values is the same as before, except that
    we need to look up the vertex/vertices in the red black tree instead of the array
    before setting up the values:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 设置和获取值的流程与之前相同，只是在设置值之前，我们需要在红黑树中查找顶点/顶点而不是在数组中：
- en: '[PRE51]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Complexity of the operations of an adjacency-list-based graph with dense storage
    for vertices
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于邻接表且顶点密集存储的图的运算复杂度
- en: 'The complexity of the operations of an adjacency-list-based graph is as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 基于邻接表的图的运算复杂度如下：
- en: '**Add vertex**: Addition of a vertex requires insertion of one in the red black
    tree. So this operation is *θ(lg |V|)*.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加顶点**：添加顶点需要在红黑树中插入一个顶点。因此，此操作是 *θ(lg |V|)*。'
- en: '**Remove Vertex**: The removal process requires deletion of the vertex from
    the red black tree, which is *θ(lg |V|)*. However, this operation involves checking
    each vertex to remove the edges which has the vertex being deleted as the target.
    So this operation is *θ(|V|)* as well.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除顶点**：删除过程需要从红黑树中删除顶点，其复杂度是 *θ(lg |V|)*。然而，此操作涉及检查每个顶点以删除具有被删除顶点作为目标顶点的边。因此，此操作也是
    *θ(|V|)*。'
- en: '**Add edge and remove edge**: The first step of this operation is to look up
    the source vertex, which is *θ(lg |V|)*. The second step is to add or remove an
    edge to/from a red black tree, so this is also *θ(lg |V|)*. Therefore, the entire
    operation of adding/deleting an edge is *θ(lg |V|)*.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加边和删除边**：这个操作的第一个步骤是查找源顶点，这是*θ(lg |V|)*。第二步是向/从红黑树添加或删除边，所以这也是*θ(lg |V|)*。因此，添加/删除边的整个操作是*θ(lg
    |V|)*。'
- en: '**Adjacent**: The first step of this operation is to look up the source vertex,
    which is *θ(lg |V|)*. The second step is to look up the edge in a red black tree,
    which is *θ(lg |V|)* too. Therefore, the entire operation of adding/deleting an
    edge is *θ(lg |V|)*.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相邻**：这个操作的第一个步骤是查找源顶点，这是*θ(lg |V|)*。第二步是在红黑树中查找边，这也是*θ(lg |V|)*。因此，添加/删除边的整个操作是*θ(lg
    |V|)*。'
- en: '**Neighbors**: The list of neighbors is precomputed, so the complexity of this
    operation is the same as that of searching a vertex, which is *θ(lg |V|)*.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**邻居**：邻居列表是预先计算的，所以这个操作的复杂度与搜索顶点的复杂度相同，即*θ(lg |V|)*。'
- en: '**Setting and getting values at vertices**: These operations require you to
    first look up the vertex, which is *θ(lg |V|)*. The second step is to set/get
    the value. These operations are *θ(lg |V|)*.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在顶点上设置和获取值**：这些操作需要你首先查找顶点，这是*θ(lg |V|)*。第二步是设置/获取值。这些操作是*θ(lg |V|)*。'
- en: '**Setting and getting values at edges**: These operations require you to first
    look up the source vertex and then the particular edge. Both of these operations
    are *θ(lg |V|)*. At the end, setting or getting the value of an edge is *θ(l)*.
    Hence, the total operation is *θ(lg |V|)*.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在边上的设置和获取值**：这些操作需要你首先查找源顶点，然后是特定的边。这两个操作都是*θ(lg |V|)*。最后，设置或获取边的值是*θ(l)*。因此，总操作是*θ(lg
    |V|)*。'
- en: '**Get all vertices**: Here too, this operation is *θ( |V| lg |V|)*.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取所有顶点**：这里，这个操作也是*θ( |V| lg |V|)*。'
- en: Traversal of a graph
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图的遍历
- en: The traversal of a graph is the graph's equivalent of the traversal of a tree,
    as discussed in an earlier chapter. Just as in the case of a tree, we can traverse
    either breadth-first or depth-first. However, unlike a tree, a graph can reach
    all the vertices without going through the edges. This makes it necessary to consider
    the traversal of all the edges and vertices separately. Another thing is that
    a graph has no designated root, so we can start from any particular vertex. Finally,
    since a graph may not be connected, we may not be able to traverse all the vertices/edges,
    starting from one single vertex. This is achieved by performing the traversal
    repeatedly, starting each time from any vertex that has not been visited yet already.
    This is a simple extension of the basic breadth-first or depth-first traversal
    that we are going to discuss here.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图的遍历是图遍历的等价物，正如在前面章节中讨论的那样。就像在树的情况下，我们可以进行广度优先或深度优先遍历。然而，与树不同，图可以通过不经过边来访问所有顶点。这使得必须单独考虑遍历所有边和顶点。另一件事是，图没有指定的根，因此我们可以从任何特定的顶点开始。最后，由于图可能不是连通的，我们可能无法从单个顶点开始遍历所有顶点/边。这是通过重复执行遍历来实现的，每次从尚未访问的任何顶点开始。这是对基本广度优先或深度优先遍历的简单扩展，我们将在下面讨论。
- en: 'First, let''s discuss visiting vertices using both the breadth-first and depth-first
    search. It involves maintaining two collections of vertices: one that stores all
    the vertices that are discovered but are yet to be visited/explored and another
    that stores a Boolean array that checks whether a vertex has already been explored/visited.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论使用广度优先搜索和深度优先搜索来访问顶点。这涉及到维护两个顶点集合：一个存储所有已发现但尚未访问/探索的顶点，另一个存储一个布尔数组，用于检查一个顶点是否已经被探索/访问。
- en: 'The collection of vertices that are discovered but yet to be explored can be
    of two types: if it is a stack, we have a depth-first traversal, and if it is
    a queue, we have a breadth-first traversal.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 已发现但尚未探索的顶点集合可以是两种类型之一：如果是栈，我们就有深度优先遍历；如果是队列，我们就有广度优先遍历。
- en: 'To implement both depth-first and breadth-first searches in a single method,
    we need to create a super interface of our `Stack and Queue` interfaces. We will
    need to define three methods in it:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要在单个方法中实现深度优先和广度优先搜索，我们需要创建我们的`Stack`和`Queue`接口的超接口。我们需要在其中定义三个方法：
- en: '[PRE52]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now implement these methods in the `Stack` and `Queue` interfaces as default
    methods to delegate to their appropriate methods:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将这些方法实现为`Stack`和`Queue`接口的默认方法，以便委托给它们适当的方法：
- en: '[PRE53]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This allows us to use the `OrderedStore` interface to hold both a stack and
    a queue. We also create a new functional interface that represents a lambda that
    takes two arguments and does not return anything:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们使用`OrderedStore`接口来同时持有栈和队列。我们还创建了一个新的函数式接口，它代表一个接受两个参数且不返回任何内容的lambda表达式：
- en: '[PRE54]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We implement this search as a default method in the Graph interface itself.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将此搜索作为Graph接口本身的默认方法实现。
- en: '[PRE55]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In the beginning, we only insert the starting vertex to the collection of vertices
    that are not yet explored. Then, we loop until all the vertices that can be discovered
    in the search are processed and there are no more elements in the collection of
    vertices. We avoid processing each vertex from the collection of vertices if it
    has already been processed. Otherwise, we mark it as "being processed" and invoke
    the visitor on it. Finally, we expand this vertex by inserting all its neighbors
    to the collection of elements that have to be processed:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，我们只将起始顶点插入到尚未探索的顶点集合中。然后，我们循环直到处理完所有在搜索中可以发现的顶点，并且顶点集合中没有更多元素。我们避免处理已经处理过的顶点集合中的每个顶点。否则，我们将其标记为“正在处理”并对其调用访问者。最后，我们通过将所有邻居插入到必须处理的元素集合中来扩展此顶点：
- en: '[PRE56]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The process of traversal of edges is also very similar; we can follow either
    the breadth-first or depth-first traversal. In this case, the visitor needs access
    to both the source and target of the edges, which makes it necessary to store
    both of them in the stack or queue we use. For this purpose, we create a class
    named `Edge`. The class is comparable so that edges can be stored in a binary
    search tree for easy search ability:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 边的遍历过程也非常相似；我们可以遵循广度优先或深度优先遍历。在这种情况下，访问者需要访问边的源和目标，这使得有必要将它们都存储在我们使用的栈或队列中。为此，我们创建了一个名为`Edge`的类。该类是可比较的，以便边可以存储在二叉搜索树中以实现易于搜索的能力：
- en: '[PRE58]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now we can implement the process of traversal of edges using the breadth-first
    and depth-first traversal:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用广度优先和深度优先遍历来实现边的遍历过程：
- en: '[PRE59]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Complexity of traversals
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历的复杂性
- en: For each traversal, either all vertices or edges, all edges must be traversed.
    This is true even if you just want to visit the vertices. The actual complexity
    depends on the particular map implementation, so we will use that the complexity
    of the operation `getNeighbors` method is *θ(g(|V|))*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每次遍历，无论是所有顶点还是边，都必须遍历所有边。即使你只想访问顶点，这也是正确的。实际复杂度取决于特定的映射实现，因此我们将使用操作`getNeighbors`方法的复杂度是*θ(g(|V|))*。
- en: If you're visiting either the edges or vertices, ensure that each vertex is
    expanded only once. This operation is done *|V|* times, each of which is *θ(g(|V|))*.
    So the complexity, due to the expansion of the vertex, to find out the neighbors
    is *θ(|V|g(|V|))*. When expanded, they are visited once, and for each edge, we
    have one neighbor. Some of these neighbors have been visited before; however,
    we need to perform constant time to verify this. So each vertex is visited once
    and each neighbor is checked once. This changes the complexity to *θ(|V|g(|V|)
    + |E| )*. Since we have seen an implementation of a graph that has the constant
    time `getNeighbors` method, we can have a traversal in *θ(|V| + |E| )*.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在访问边或顶点，确保每个顶点只扩展一次。这个操作执行了*|V|*次，每次都是*θ(g(|V|))*。因此，由于顶点的扩展，找到邻居的复杂度是*θ(|V|g(|V|))*。当扩展时，它们被访问一次，对于每条边，我们有一个邻居。其中一些邻居之前已经被访问过；然而，我们需要执行常数时间来验证这一点。所以每个顶点只被访问一次，每个邻居只被检查一次。这改变了复杂度到*θ(|V|g(|V|)
    + |E|)*。由于我们已经看到了一个具有常数时间`getNeighbors`方法的图实现，我们可以有一个*θ(|V| + |E|)*的遍历。
- en: Cycle detection
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环检测
- en: One of the uses of a traversal is cycle detection. A connected undirected graph
    without any cycle is a tree. A directed graph without any cycle is called a directed
    acyclic graph (DAG). Cycle detection in graphs can be done in a very similar manner.
    In the case of an undirected graph, if we do a DFS and the same node is visited
    twice as the target of an edge, there is a cycle. Since the edge is undirected,
    we are satisfied if either the source or the target has not been seen before.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历的一个用途是循环检测。没有任何循环的连通无向图是一个树。没有任何循环的有向图称为有向无环图（DAG）。在图中进行循环检测可以非常相似地进行。在无向图的情况下，如果我们进行DFS并且同一个节点作为边的目标被访问两次，则存在循环。由于边是无向的，如果源或目标之前未见过，我们就满意了。
- en: 'In the case of a directed graph, visiting the same node twice is not enough
    if you want to know whether there is a cycle; we should also consider the direction
    of the edges. This means while traversing the edges, we need to know whether we
    can reach the same node we started with. This requires us to remember the entire
    path while doing a DFS. This is why we use a recursive helper method to detect
    a cycle in a directed graph. We create the helper method for the directed cycle
    first. The `checkDirectedCycleFromVertex` method takes the path and binary search
    tree of the vertices. The list of vertices is the one that stores all the vertices,
    and the ones already visited must be removed so that they are not used as the
    starting point of cycle detection later. The list of integers is the path from
    the starting point in a depth-first traversal. If a vertex is repeated in the
    same path, it means a cycle exists:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在有向图的情况下，如果你想知道是否存在循环，仅仅访问相同的节点两次是不够的；我们还应该考虑边的方向。这意味着在遍历边时，我们需要知道我们是否可以到达我们开始的同一个节点。这要求我们在进行DFS时记住整个路径。这就是为什么我们使用递归辅助方法在有向图中检测循环。我们首先创建有向循环的辅助方法。`checkDirectedCycleFromVertex`方法接受路径和顶点的二叉搜索树。顶点列表是存储所有顶点的列表，已访问的顶点必须被移除，这样它们就不会在后续的循环检测中作为起点使用。整数列表是从起点在深度优先遍历中的路径。如果一个顶点在相同的路径中重复出现，这意味着存在一个循环：
- en: '[PRE60]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The head of the list is the deepest vertex in the path; we need to expand this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 列表头部是路径中最深的顶点；我们需要扩展这个：
- en: '[PRE61]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now if any neighbor is already present in the path, a cycle exists, which is
    what we check. If a cycle is found, we throw an instance of a custom exception:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果任何邻居已经存在于路径中，则存在一个循环，这正是我们要检查的。如果找到循环，我们抛出一个自定义异常的实例：
- en: '[PRE62]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now we create the method for detection of cycles in either type of graph. Go
    through all the vertices as there might be unconnected parts of the graph. A directed
    graph may have connected vertices that cannot be reached from a particular starting
    vertex due to the directionality of the edges. However, once a vertex is visited
    in any traversal, it does not need to be visited again. This is taken care of
    by having all the vertices in a binary search tree and removing the ones that
    have been visited already:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为两种类型的图创建检测循环的方法。遍历所有顶点，因为图中可能有未连接的部分。有向图可能有一些顶点由于边的方向性，无法从特定的起始顶点到达。然而，一旦在任何遍历中访问了一个顶点，它就不需要再次访问。这是通过将所有顶点放在二叉搜索树中并删除已访问的顶点来实现的：
- en: '[PRE63]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'First, we get a list of all the vertices. We get it directly by understanding
    how the vertices are stored inside the graphs:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取所有顶点的列表。我们直接通过理解顶点在图中的存储方式来获取它：
- en: '[PRE64]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Complexity of the cycle detection algorithm
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环检测算法的复杂度
- en: First, let's check out the complexity of cycle detection in an undirected graph.
    The complexity of `getAllVertices` is *Ө* *(|V| lg |V|)*. Looking up a vertex
    in the search tree of vertices that have already been visited is *Ө* *( lg |V|
    )*. We do this twice for every edge. We also have to insert a new vertex in the
    `metAlready` search tree and delete a vertex from the `allVertices` search tree;
    the complexity of these operations for each edge is *Ө* *( lg |V| )*. So the total
    complexity is *Ө* *(|E| lg |V| )*.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们检查无向图中循环检测的复杂度。`getAllVertices`的复杂度是*Ө* *(|V| lg |V|)*。在已访问顶点的搜索树中查找一个顶点的复杂度是*Ө*
    *( lg |V| )*。我们为每条边做两次这样的查找。我们还需要在`metAlready`搜索树中插入一个新的顶点，并在`allVertices`搜索树中删除一个顶点；这些操作对于每条边的复杂度是*Ө*
    *( lg |V| )*。因此，总复杂度是*Ө* *(|E| lg |V|)*。
- en: 'Now let''s consider the complexity of cycle detection in a directed graph.
    Here, we traverse each edge once. However, for each edge, we have to look through
    the entire path to know whether the current vertex is seen in the path. The path
    can potentially be of this length: *|V| - 1*. So when we check it for each edge,
    the complexity is *O(|E||V|)*; this is a lot higher than *O(|E|lg |V|)*.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑在有向图中进行循环检测的复杂度。在这里，我们遍历每条边一次。然而，对于每条边，我们必须查看整个路径以确定当前顶点是否在路径中。路径的长度可能是这样的：*|V|
    - 1*。因此，当我们为每条边进行检查时，复杂度是*O(|E||V|)*；这比*O(|E|lg |V|)*要高得多。
- en: Spanning tree and minimum spanning tree
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成树和最小生成树
- en: 'A spanning tree in a connected graph is a subgraph consisting of all the vertices
    and some edges. So, a subgraph is a tree; it is a connected graph with no loops
    or cycles. *Figure 5* shows an example of a spanning tree in a graph:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个连通图中，生成树是一个由所有顶点和一些边组成的子图。因此，子图是一个树；它是一个没有环或循环的连通图。*图5*展示了图中生成树的一个例子：
- en: '![Spanning tree and minimum spanning tree](img/00075.jpeg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![连通图和最小生成树](img/00075.jpeg)'
- en: Figure 5\. A spanning tree of a graph (shown in red)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图5. 图的生成树（用红色表示）
- en: A tree has minimum number of edges required to keep the vertices connected.
    Removing any edge from a tree will disconnect the graph. This can be useful in
    a map of roads that connect different places and has a minimal number of roads.
    With this motivation, we would really be interested in a spanning tree that has
    a minimum total length of roads. This may be important because constructing roads
    is a costly affair. Alternatively, we could design a bus route map for a city
    and have all the important places connected without creating too many routes;
    also, shorter routes are better. Such a spanning tree is called a minimum spanning
    tree. Finding a minimum spanning tree is an important problem. But before we discuss
    the algorithm, let's see some of the properties of a minimum spanning tree.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 树具有保持顶点连接所需的最少边数。从树中移除任何边都会使图断开。这在连接不同地点且道路数量最少的地图中可能很有用。有了这个动机，我们会对具有最小总道路长度的生成树非常感兴趣。这可能很重要，因为建设道路是一笔昂贵的开销。或者，我们可以为城市设计一条公交线路图，将所有重要地点连接起来，而不需要创建太多路线；此外，较短的路线更好。这样的生成树被称为最小生成树。找到最小生成树是一个重要问题。但在我们讨论算法之前，让我们看看最小生成树的一些性质。
- en: For any tree with vertices V and edges E, |V| = |E| + 1
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对于任何具有顶点集V和边集E的树，|V| = |E| + 1
- en: 'First, let''s consider this proposition: removing any edge from a tree will
    create two trees with no connection between them. Let''s assume the opposite.
    We have a graph with two vertices A and B and an edge X between them. Let''s assume
    that even if we remove X, the tree still remains connected. This means a path
    P exists between A and B even if you delete X. This means in the original graph,
    we can walk from A to B through P and use X to come back to A. This means the
    original graph has a cycle. But the original graph was assumed to be a tree, so
    this is impossible. Therefore, my original proposition that removing any edge
    from the tree will create two trees with no connection between them is true.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑这个命题：从树中移除任何一条边将创建两个没有连接的树。让我们假设相反的情况。我们有一个包含两个顶点A和B以及它们之间的一条边X的图。假设即使我们移除X，树仍然保持连通。这意味着即使删除X，A和B之间仍然存在一条路径P。这意味着在原始图中，我们可以通过P从A走到B，并使用X回到A。这意味着原始图有一个环。但是原始图被假设是一个树，所以这是不可能的。因此，我最初关于从树中移除任何边将创建两个没有连接的树的命题是正确的。
- en: Now let's start with a graph G that has a set of edges E and vertices V. If
    we remove all the edges, we would of course be left with only V. These set of
    vertices without edges are actually single vertex trees with no connections between
    themselves.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从一个具有边集E和顶点集V的图G开始。如果我们移除所有边，我们当然只会剩下V。这些没有边的顶点集实际上是单顶点树，它们之间没有连接。
- en: We start with one tree, say G, and remove one edge. Now we have two trees. We
    can now remove another edge, and this will split one of these trees into two so
    we have three trees. This way, after the removal of each edge, we will have one
    more tree. Therefore, after the removal of all the edges, we will have *|E| +
    1* trees (because there was one tree before any edge was removed). These must
    be *|V|* single vertex trees. So, it is either *|V| = |E|+1* or *|E| = |V| - 1*.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个树开始，比如说G，移除一条边。现在我们有两个树。现在我们可以移除另一条边，这将把其中一个树分成两个，所以我们有三个树。这样，在移除每条边之后，我们都会多出一个树。因此，在移除所有边之后，我们将有*|E|
    + 1*个树（因为移除任何边之前有一个树）。这些必须是*|V|*个单顶点树。所以，要么*|V| = |E|+1*，要么*|E| = |V| - 1*。
- en: Any connected undirected graph has a spanning tree
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任何连通的无向图都有一个生成树
- en: 'Let''s take an undirected graph. If there are loops and cycles. First, we simply
    delete all the loops. Consider A and B as two vertices that are neighbors and
    part of a cycle. This means if we walk through the edge from A to B, we can use
    another path: B to A (this is what makes it a cycle). So if we delete the B to
    A edge, we will still have a connected graph. We do this operation for every cycle.
    At the end of these operations, we will have a connected graph with no loops or
    cycles; this is a tree. This tree connects all the vertices, so it is a spanning
    tree.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个无向图。如果有环和环。首先，我们简单地删除所有环。考虑A和B作为两个相邻并构成环的顶点。这意味着如果我们从A到B走边，我们可以使用另一条路径：从B到A（这就是它成为环的原因）。所以如果我们删除从B到A的边，我们仍然会有一个连通图。我们对每个环执行这个操作。在这些操作结束时，我们将有一个没有环或环的连通图；这是一个树。这个树连接了所有顶点，所以它是一个生成树。
- en: Any undirected connected graph with the property |V| = |E| + 1 is a tree
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任何具有属性|V| = |E| + 1的无向连通图是一个树
- en: Now let's check the reverse of the preceding theorem. Suppose there is a connected
    graph where *|V| = |E| + 1*. We assume it is not a tree. This graph must have
    a spanning tree, which is a subgraph, with fewer edges. This spanning tree will
    have the same number of vertices (because we never deleted any vertices) but fewer
    edges. Therefore, if the spanning tree has the set of edges *E* ¹, we have *|
    E* ¹*|| < |E| => | E* ¹*|| + 1 < |E| + 1 => | E* ¹*|| + 1 < |V|*. But this is
    not possible because the new graph is a tree. So the original proposition that
    any undirected connected graph with the property *|V| = |E| +1* is a tree.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查前面定理的逆命题。假设存在一个连通图，其中*|V| = |E| + 1*。我们假设它不是一个树。这个图必须有一个生成树，它是一个子图，边数更少。这个生成树将有相同的顶点数（因为我们从未删除任何顶点），但边数更少。因此，如果生成树有边集*E*
    ¹，那么我们有*| E* ¹*|| < |E| => | E* ¹*|| + 1 < |E| + 1 => | E* ¹*|| + 1 < |V|*。但是这是不可能的，因为新的图是一个树。所以，原始命题是任何具有属性*|V|
    = |E| +1*的无向连通图是一个树。
- en: Cut property
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分割属性
- en: Cut refers to a minimum set of edges that when removed would split a connected
    undirected graph into two separate connected graphs with no connections between
    them. There can be many cuts in a given graph.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 分割指的是一个最小边集，当移除这些边时，会将一个连通的无向图分割成两个没有连接的单独连通图。给定图中可以有多个分割。
- en: 'The cut property can be defined as this: if an edge is an element of a cut
    and has a minimum cost associated with it within the cut, it is part of the minimum
    spanning tree of the graph. To check this out, first note that for any cut of
    an undirected connected graph, a spanning tree will always have exactly one member
    of the cut in it.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 分割属性可以这样定义：如果一个边是分割的一个元素，并且它在分割中具有最小的成本，那么它是图的最小生成树的一部分。为了验证这一点，首先注意，对于任何无向连通图的分割，生成树将始终恰好包含分割中的一个成员。
- en: Let's have a cut X that divides the graph G into subgraphs H and J. Let G have
    a spanning tree called S. Since G is a connected graph and X is a cut, this means
    H and J are connected with each other. If X is empty, it means G was not connected;
    this is not possible. Now we have the Y subset of X where all the members of Y
    are part of the spanning tree S. If Y is empty, the vertices of H and J will be
    disconnected in S, so this is impossible. Now as a contradiction to *|Y| = 1*,
    let's assume *|Y| > 1*. This means there is more than one edge in S, between H
    and J. Let's pick two of them. Let the first is between vertex A in H and vertex
    B in J, and the second one between vertex C in H and vertex D in J. Now since
    the spanning tree S has all the vertices of H and J connected, there is a path
    from A to C and D to B in S outside of Y. So we have a cycle from A to C and C
    to D using one of our selected edges and we have D to B and B to A using the other
    selected edge. This means S has a cycle and hence S is not a tree, which is a
    contradiction. Therefore, *|Y| = 1*. Thus, the spanning tree has exactly one member
    of any cut in an undirected connected graph.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们有一个分割X，它将图G分割成子图H和J。让G有一个称为S的生成树。由于G是一个连通图且X是一个分割，这意味着H和J彼此之间是连通的。如果X为空，则意味着G不是连通的；这是不可能的。现在我们有了X的子集Y，其中Y的所有成员都是生成树S的一部分。如果Y为空，则H和J的顶点在S中将是不连通的，所以这是不可能的。现在，作为对*|Y|
    = 1*的矛盾，我们假设*|Y| > 1*。这意味着在S中有超过一条边在H和J之间。让我们从中选择两条。第一条是在H中的顶点A和J中的顶点B之间，第二条是在H中的顶点C和J中的顶点D之间。现在，由于生成树S将H和J的所有顶点都连接起来，在Y之外S中存在从A到C和从D到B的路径。因此，我们使用我们选择的一条边从A到C和C到D，并使用另一条边从D到B和B到A。这意味着S有一个环，因此S不是一个树，这是矛盾的。因此，*|Y|
    = 1*。因此，生成树在无向连通图中的任何分割中恰好有一个成员。
- en: If S is the minimum spanning tree of G and X is a cut in G dividing G into H
    and J, S has exactly one member for X, as proved in the preceding section. Let
    it be any edge other than the one with minimum cost. Since S is a spanning tree,
    if we remove the edge that is in X, we will have two disconnected subtrees, which
    are spanning trees of H and J. If we insert any other edge from X now, this new
    edge will connect these subtrees back to the single spanning tree. This is because
    all the edges of X are between one vertex in H and another in J. So we can replace
    the edge in S that is a member of X along with the edge in X with minimum cost,
    and we can thus create another spanning tree of G. But the edges of the new tree
    will be the same as in S, except the one that has a lesser cost than the one in
    S. So the sum of the costs of edges of the new spanning tree must be lesser than
    that of S, which is a contradiction as S is a minimum spanning tree. Therefore,
    the minimum spanning tree S must have an edge with the least cost within the cut
    X.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 S 是 G 的最小生成树，且 X 是 G 中的一个分割，将 G 划分为 H 和 J，S 对于 X 有且仅有一个成员，正如前一小节所证明的。让它是除了具有最低成本的那条边之外的任何边。由于
    S 是生成树，如果我们移除 X 中的边，我们将有两个不连通的子树，它们是 H 和 J 的生成树。如果我们现在插入 X 中的任何其他边，这条新边将把这些子树重新连接到单个生成树。这是因为
    X 的所有边都在 H 中的一个顶点和 J 中的另一个顶点之间。因此，我们可以用 X 中的边和具有最低成本的边替换 S 中的 X 成员，从而创建 G 的另一个生成树。但是新树中的边将与
    S 中的边相同，除了成本低于 S 中的那条边。因此，新生成树边的总成本必须低于 S，这与 S 是最小生成树的事实相矛盾。因此，最小生成树 S 必须在分割 X
    中具有成本最低的边。
- en: Minimum spanning tree is unique for a graph that has all the edges whose costs
    are different from one another
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对于所有边的成本都不同的图，最小生成树是唯一的。
- en: 'Let''s assume that we have a connected undirected graph G for which there are
    two different minimum spanning trees, namely S and T. Since S and T are different
    and have the same number of edges (because for a spanning tree, the calculation
    is *|V| = |E| + 1*), there is an edge E in S that is not in T. Let this edge be
    there between the vertices A and B. Now let''s create a partition of the set of
    vertices in G so that there are two partitions: Y and Z. Create this such that
    A belongs to Y, B belongs to Z, and Y and Z are disjointed and together contain
    all the vertices. Let X be the cut that would divide G into two subgraphs with
    vertices in Y and Z. Since A belongs to Y and B belongs to Z, the edge E between
    A and B belongs to X. Since X is a cut and S is a spanning tree, there must be
    exactly one edge in X that is part of S; in this case, it has to be the edge E.
    Now, since T is also a spanning tree and E is not a member of T, there must be
    another member of X that is in T; let it be **f**.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个连通的无向图 G，它有两个不同的最小生成树，即 S 和 T。由于 S 和 T 是不同的，并且具有相同数量的边（因为对于生成树，计算是 *|V|
    = |E| + 1*），在 S 中存在一条边 E，它不在 T 中。让这条边在顶点 A 和 B 之间。现在让我们将 G 的顶点集划分为两个部分：Y 和 Z。创建这样的划分，使得
    A 属于 Y，B 属于 Z，并且 Y 和 Z 是不相交的，并且它们一起包含所有顶点。让 X 是将 G 划分为包含在 Y 和 Z 中的两个子图的分割。由于 A
    属于 Y 且 B 属于 Z，边 E 在 A 和 B 之间属于 X。由于 X 是一个分割，S 是一个生成树，X 中必须恰好有一条边是 S 的部分；在这种情况下，它必须是边
    E。现在，由于 T 也是生成树且 E 不是 T 的成员，X 中必须还有另一个成员在 T 中；让我们称它为 **f**。
- en: If we remove the edge E from S, we will have two different trees, which would
    be joined again if we insert f. This is because f is an edge between the vertices
    in Y and Z, and the two parts are already trees. So now we are left with another
    spanning tree.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从 S 中移除边 E，我们将有两个不同的树，如果插入 f，它们将再次连接。这是因为 f 是 Y 和 Z 之间顶点的边，并且两个部分已经是树。所以现在我们剩下另一个生成树。
- en: All the costs are different; the cost of E is different from the cost of f.
    If the cost of f is lower than that of E, the total cost of the new spanning tree
    is lower than that of S. Although, this is not possible because S is a minimum
    spanning tree. So, the cost of f is higher than that of E.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 所有成本都是不同的；边 E 的成本与边 f 的成本不同。如果 f 的成本低于 E，新的生成树的总成本将低于 S。尽管如此，这是不可能的，因为 S 是最小生成树。因此，f
    的成本必须高于 E。
- en: We can do this for every edge in S that is not in T; S will transform into T
    when no more edges are available. In every step of this process, the total cost
    of edges will increase. This means the total cost of edges in T must be higher
    than that in S. However, this is impossible because S and T are both minimum spanning
    trees. So our original assumption that there can be two different minimum spanning
    trees is wrong. Therefore, each minimum spanning tree is unique in a graph where
    all the costs of the edges are different.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对S中不在T中的每条边都这样做；当没有更多边可用时，S将转换为T。在这个过程中，每一步边的总成本都会增加。这意味着T中边的总成本必须高于S中的总成本。然而，这是不可能的，因为S和T都是最小生成树。因此，我们最初的假设，即可能存在两个不同的最小生成树是错误的。因此，在所有边的成本都不同的图中，每个最小生成树都是唯一的。
- en: Finding the minimum spanning tree
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找最小生成树
- en: 'With the properties we just discussed, we can now define an algorithm for finding
    the minimum spanning tree of a graph. Suppose a set of edges F is already given
    and they are members of the minimum spanning tree G. Now we are trying to find
    another edge that is also a member of the minimum spanning tree. First, we choose
    an edge e whose cost is minimum when compared to the rest of the edges, E and
    F in this case. Since some of the edges are already given, some of the vertices
    are already connected. If the chosen edge e is between two vertices that are already
    connected, we simply reject this edge and find the next edge with minimum cost.
    We do this until we find an edge f between two vertices that are not already connected.
    Our claim is that f is a new member of the minimum spanning tree. To confirm this,
    let''s assume that f is between the vertices A and B. From the description of
    our procedure, A and B are not connected. Let''s make two partitions of the vertices:
    H and J. Let''s have all the vertices that are connected to A, including A in
    H, and all the vertices connected to B, including B in J. The rest of the vertices
    are assigned to the set H. Since H and J are partitions of the vertices in the
    original graph G, we have a cut X in the original graph G that splits the graph
    G in a way that all the vertices in H are placed in one of the subgraphs and all
    the vertices in J in the other. We know that the member of X that has the minimum
    cost is a member of the minimum spanning tree G. Now, of course, f is a member
    of X as it connects A to B. It is also the edge with the minimum cost among all
    the edges in X. This is because all the edges in X are in the remaining edges
    (otherwise some vertices in H and some in J would be connected, which cannot be
    true because of the way we have created the two sets), and f is the minimum cost
    in all the remaining edges. This means f is a new member of the spanning tree.
    Therefore, we use the following steps to build the minimum spanning tree:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们刚才讨论的性质，我们现在可以定义一个寻找图的最小生成树的算法。假设已经给出了一组边F，并且它们是最小生成树G的成员。现在我们正在尝试找到另一条也是最小生成树成员的边。首先，我们选择一条边e，其成本与E和F中的其他边相比是最小的。由于一些边已经给出，一些顶点已经连接。如果选择的边e位于两个已经连接的顶点之间，我们简单地拒绝这条边，并找到下一条成本最小的边。我们这样做，直到找到一条连接两个尚未连接的顶点的边f。我们的断言是f是最小生成树的新成员。为了确认这一点，让我们假设f位于顶点A和B之间。根据我们的程序描述，A和B之间没有连接。让我们将顶点分为两个部分：H和J。让所有连接到A的顶点，包括A本身，都在H中，所有连接到B的顶点，包括B本身，都在J中。其余的顶点分配到集合H中。由于H和J是原始图G中顶点的划分，我们在原始图G中有一个分割X，它以这种方式分割图G，使得H中的所有顶点都放在一个子图中，而J中的所有顶点都放在另一个子图中。我们知道X中的最小成本成员是最小生成树G的成员。现在，当然，f是X的成员，因为它连接了A和B。它也是X中所有边中成本最低的边。这是因为X中的所有边都在剩余的边中（否则H和J中的一些顶点会连接，这是不可能的，因为我们创建了两个集合的方式），而f是所有剩余边中成本最低的。这意味着f是生成树的新成员。因此，我们使用以下步骤来构建最小生成树：
- en: Start with an empty set of edges as the spanning tree.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个空的边集作为生成树开始。
- en: If more edges are remaining and all the vertices are not connected, choose the
    one with the minimum cost.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果还有剩余的边，并且所有顶点都没有连接，则选择成本最低的一条。
- en: If the edge is between two connected vertices, discard it and go back to step
    2.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果边位于两个已连接的顶点之间，则丢弃它并回到步骤2。
- en: Otherwise, add the edge to the set of edges of the minimum spanning tree.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，将边添加到最小生成树的边集中。
- en: Repeat from step 1.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从步骤1重复。
- en: The problem now is how to efficiently know whether the two vertices are connected.
    The solution is a data structure called a union set forest.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，如何有效地知道两个顶点是否连接。解决方案是一个称为并查集森林的数据结构。
- en: Union find
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并查集
- en: The purpose of union find is to be able to tell whether the two given objects
    are members of the same set. This data structure allows you to first specify all
    the members of a universal set and then specify which ones are members of the
    same partition, thus joining the two partitions to make a single partition. It
    represents a collection of partitions of the universal set, and it lets us query
    whether the two members of the universal set are members of the same partition.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 并查集的目的是能够判断两个给定的对象是否属于同一集合。此数据结构允许你首先指定全集的所有成员，然后指定哪些成员属于同一分区，从而将两个分区合并为一个分区。它表示全集的分区集合，并允许我们查询全集的两个成员是否属于同一分区。
- en: A tree is kept in an opposite pointer form, that is, the child knows its parent;
    however, the parent does not have any pointers to the children. The idea is to
    have connected values in the same tree. Each tree in a forest has a representative
    node that is its root. If two nodes have the same representative roots, they are
    in the same partition; otherwise, they are not.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 树以相反的指针形式保持，即子节点知道其父节点；然而，父节点没有指向子节点的任何指针。其想法是在同一棵树中保持连接的值。森林中的每一棵树都有一个代表节点，即其根节点。如果两个节点有相同的代表根节点，它们在同一分区中；否则，它们不在同一分区中。
- en: 'This data structure has three important operations:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据结构有三个重要的操作：
- en: Add a new object to the universal set.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向全集添加一个新对象。
- en: '**Union two objects**: This will result in the partitions those objects belong
    to joining together to make a single partition.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Union两个对象**：这将导致这些对象所属的分区合并为一个分区。'
- en: '**Find**: This will return the representative object of the partition that
    the object passed belongs to. If the result of the find operations of two different
    objects is the same, the object would belong to the same partition.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Find**：这将返回对象所属分区的代表对象。如果两个不同对象的find操作的结果相同，则对象将属于同一分区。'
- en: 'The following is an implementation of a `Union` find that can hold comparable
    objects:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个可以存储可比较对象的`Union`并查集的实现：
- en: '[PRE65]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Each node holds a reference to its parent. If there is no parent, that is,
    if the node is the root of its tree, the parent is null. All nodes also store
    its rank, which is the height of the tree rooted by itself:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点都持有对其父节点的引用。如果没有父节点，即如果节点是其树的根，则父节点为null。所有节点还存储其秩，即以自身为根的树的身高：
- en: '[PRE66]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'All the nodes are stored in a red black tree so they have a logarithmic search:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 所有节点都存储在红黑树中，因此它们具有对数搜索：
- en: '[PRE67]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Additionally, we want to keep a count of the number of partitions available:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还想保持可用分区的数量计数：
- en: '[PRE68]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `add` operation adds a new object to the universal set, which is implemented
    using a red black tree:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`操作向全集添加一个新对象，该操作使用红黑树实现：'
- en: '[PRE69]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This is an internal method that traverses the parents one by one until it finds
    the root of the tree that the object passed belongs to:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个内部方法，逐个遍历父节点，直到找到对象所属的树的根：
- en: '[PRE70]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '![Union find](img/00076.jpeg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![并查集](img/00076.jpeg)'
- en: Figure 6\. Union operation in a union find forest. The partitions it represents
    are shown on the side.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图6\. 并查集森林中的并操作。它所表示的分区在旁边显示。
- en: 'The union operation merges two trees. This is achieved by setting one of the
    roots of the two trees as the parent of the root of the other tree. When merging
    two trees of unequal height, the root of the taller tree is set as the parent
    of the root of the shorter tree; otherwise, any one of the two is chosen as the
    root. The rank of the root increases only when two equal trees are merged. When
    unequal trees are merged, the height of the merged tree is the same as the height
    of the taller tree. *Figure 6* shows the union operation:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 并操作合并两棵树。这是通过将两棵树的其中一个根设置为另一棵树的根的父节点来实现的。当合并高度不等的两棵树时，较矮树的根被设置为较高树根的父节点；否则，可以选择两个中的任何一个作为根。当合并两个高度相等的树时，根的秩只增加。当合并不等高的树时，合并树的身高与较高树的身高相同。*图6*显示了并操作：
- en: '[PRE71]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The `find` operation involves looking up the node related to the object first
    and then finding the root node. The object contained in the root node is returned:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`操作首先查找与对象相关的节点，然后找到根节点。返回根节点中包含的对象：'
- en: '[PRE72]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Complexity of operations in UnionFind
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并查集操作的复杂度
- en: First, let's consider the complexity of finding the root node of any node; this
    is an internal operation. The complexity of this operation is *θ(h)*, where *h*
    is the height of the tree. Now what is the upper bound of the height of the tree?
    Let *f(h)* be the minimum number of nodes in a tree of height *h*. Trees are always
    created by merging two smaller trees. If the trees being merged have unequal heights,
    the height of the merged tree is the same as the taller of the two initial trees,
    and now it has more nodes than the original taller tree. This is not the way to
    create the worst tree, which is the tree with minimum nodes with the same height.
    The worst tree must be created by merging two equal trees, both of which are worst
    trees themselves. After you merge them, the height of the merged tree is one more
    than the height of either of the trees being merged. So, for creating a worst
    tree of height *h+1*, we must merge two worst trees of height h. The operation
    to do this is *f(h+1) = 2 f(h)*. So, if *f(0) = C*, where *C* is some constant,
    *f(1) = 2C, f(2)=4C, …, f(h) = 2* ^h *C*. Therefore, if the number of nodes is
    *n*, then *n ≥ f(h) = 2* ^h *C => lg n ≥ lg (2* ^h *C) = h + lg C => h ≤ lg n
    – lg C => h = O(lg n)*. This means the complexity of finding the root of a given
    node is also *O(lg n)*.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑找到任何节点的根节点的复杂度；这是一个内部操作。这个操作的复杂度是 *θ(h)*，其中 *h* 是树的高度。现在，树的高度有什么上界？设
    *f(h)* 为高度为 *h* 的树中的最小节点数。树总是通过合并两个较小的树来创建的。如果被合并的树的高度不相等，合并后的树的高度与两个初始树中较高的那个相同，并且现在它比原始较高的树有更多的节点。这不是创建最坏树的方法，最坏树必须通过合并两个具有相同高度的最小节点数的树来创建。合并后，合并后的树的高度比被合并的两个树中的任何一个都要高。所以，为了创建高度为
    *h+1* 的最坏树，我们必须合并两个高度为 *h* 的最坏树。执行这个操作的公式是 *f(h+1) = 2 f(h)*。因此，如果 *f(0) = C*，其中
    *C* 是某个常数，*f(1) = 2C, f(2)=4C, …, f(h) = 2* ^h *C*。因此，如果节点数为 *n*，那么 *n ≥ f(h)
    = 2* ^h *C => lg n ≥ lg (2* ^h *C) = h + lg C => h ≤ lg n – lg C => h = O(lg n)*。这意味着找到给定节点根的复杂度也是
    *O(lg n)*。
- en: Adding a new object involves inserting a new node in the red black tree, so
    the complexity is *θ(lg n)*.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新对象涉及在红黑树中插入新节点，因此复杂度是 *θ(lg n)*。
- en: '**Find**: This operation involves looking up the node that corresponds to the
    object first. This is a search operation in the red black tree; hence it is *θ(lg
    n)*. After this, it involves looking up the root of this node, which is *O(lg
    n)*. And at the end, we return the object in the node, which is constant time.
    Hence, the complexity of the entire find operation is *θ(lg n)*.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查找**：这个操作首先涉及查找对应于对象的节点。这是在红黑树中的搜索操作；因此它是 *θ(lg n)*。之后，它涉及查找这个节点的根，这是 *O(lg
    n)*。最后，我们返回节点中的对象，这是常数时间。因此，整个查找操作的复杂度是 *θ(lg n)*。'
- en: Union involves three operations. The first is to search the nodes for the objects,
    which is *θ(lg n)*. The second is to find the roots of each of the trees associated
    with the nodes, which is also *O(lg n)*. And finally, it involves the merging
    of the trees, which is a constant time operation. So the complexity of the entire
    operation is *θ(lg n)*.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并查集涉及三个操作。第一个是搜索节点中的对象，这是 *θ(lg n)*。第二个是找到与每个节点关联的树的根，这也是 *O(lg n)*。最后，它涉及到树的合并，这是一个常数时间操作。因此，整个操作的复杂度是
    *θ(lg n)*。
- en: Implementation of the minimum spanning tree algorithm
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小生成树算法的实现
- en: 'Now we can implement our minimum spanning tree algorithm. First, we create
    a class that we will use for the implantation. The `CostEdge` class represents
    an edge along with its cost. The `compareTo` method is overridden to compare the
    costs instead of IDs:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以实现我们的最小生成树算法。首先，我们创建一个我们将用于实现的类。`CostEdge` 类表示一个边及其成本。`compareTo` 方法被重写以比较成本而不是
    ID：
- en: '[PRE73]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The argument `costFinder` is a lambda that returns the cost of an edge from
    the value that is stored in it. `edgeQueue` is a priority queue that lets us consider
    the edges in the order of their costs. We can dequeue the edge with the minimum
    cost every time, as our algorithm requires. The purpose of `unionFind` is to keep
    track of which vertices are connected after some edges are already chosen. First,
    we traverse through all the edges and enqueue them to the priority queue, then
    we traverse through all the vertices to add them to `unionFind`. After this, as
    described in our algorithm, we pick the edges in the order of their costs and
    add them only when they are not between the vertices that are already connected.
    The `unionFind` keeps track of which vertices are connected. The edges of the
    spanning tree are returned in a linked list:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`costFinder` 参数是一个返回边成本的lambda函数。`edgeQueue` 是一个优先队列，允许我们按照边的成本顺序考虑它们。我们可以每次都出队成本最低的边，正如我们的算法所要求的。`unionFind`
    的目的是跟踪在已经选择了一些边之后哪些顶点是连通的。首先，我们遍历所有边并将它们入队到优先队列，然后我们遍历所有顶点并将它们添加到 `unionFind`
    中。之后，正如我们的算法所描述的，我们按照边的成本顺序选择边，并且只有在它们不在已经连通的顶点之间时才添加它们。`unionFind` 跟踪哪些顶点是连通的。生成树的边以链表的形式返回：'
- en: '[PRE74]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Complexity of the minimum spanning tree algorithm
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小生成树算法的复杂度
- en: Visiting all the edges and adding them to the priority queue can be as low as
    *Ө* *(|V| + |E| + |E| lg |E|)* because traversing through the edges is *Ө* *(|V|
    + |E| )* and adding all of them to the priority queue is *Ө* *(|E| lg |E|)*. Since
    a connected graph has *|E| ≥|V| -1*, *Ө* *(|V| + |E| + |E| lg |E|) =* *Ө* *(|E|
    lg |E|)*. Inserting all the vertices to the union find is done through *Ө* *(|V|
    lg |V|)* because adding each vertex has the complexity *Ө* *(lg |V|)*.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 访问所有边并将它们添加到优先队列的复杂度可以低至 *Ө* *(|V| + |E| + |E| lg |E|)*，因为遍历边的复杂度是 *Ө* *(|V|
    + |E|)*，将所有边添加到优先队列的复杂度是 *Ө* *(|E| lg |E|)*。由于连通图有 *|E| ≥|V| -1*，*Ө* *(|V| + |E|
    + |E| lg |E|) =* *Ө* *(|E| lg |E|)*。将所有顶点插入并查集的操作通过 *Ө* *(|V| lg |V|)* 完成，因为添加每个顶点的复杂度是
    *Ө* *(lg |V|)*。
- en: Now let's consider the core of the algorithm. For each edge, dequeueing the
    minimum edge is *Ө* *(lg |E|)*, finding each of the source and the target in `unionFind`
    is *Ө* *(lg |V|)*, adding to the linked list is constant time, and doing a union
    on `union find` is *Ө* *(lg |V|)*. So, for each edge, the complexity is *Ө* *(lg
    |V| + lg |E|)*. This is *Ө* *(lg |E|)* for each edge, as *|E| ≥|V| -1*. Therefore,
    the complexity of the core part is *Ө* *(|V| lg |E|)* because we stop after *|V|
    - 1* number of edges are added and all the vertices are already connected.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来考虑算法的核心。对于每条边，出队最小边的复杂度是 *Ө* *(lg |E|)*，在 `unionFind` 中查找每个源点和目标点的复杂度是
    *Ө* *(lg |V|)*，添加到链表是常数时间，在 `unionFind` 上执行并集操作是 *Ө* *(lg |V|)*。因此，对于每条边，复杂度是
    *Ө* *(lg |V| + lg |E|)*。由于 *|E| ≥|V| -1*，这相当于每条边的 *Ө* *(lg |E|)*。因此，核心部分的复杂度是
    *Ө* *(|V| lg |E|)*，因为我们停止在添加了 *|V| - 1* 条边之后，并且所有顶点都已经连通。
- en: Adding the complexity of all the preceding steps, we get the total complexity
    of the minimum spanning tree algorithm as *Ө* *(|E| lg |E|) +* *Ө* *(lg |V|) +*
    *Ө* *(|V| lg |E|) =* *Ө* *(|E| lg |E| + |V| lg* *|V|) =* *Ө* *(|E| lg |E| )* as
    *|E| ≥|V| -1*.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有先前步骤的复杂度相加，我们得到最小生成树算法的总复杂度为 *Ө* *(|E| lg |E|) +* *Ө* *(lg |V|) +* *Ө* *(|V|
    lg |E|) =* *Ө* *(|E| lg |E| + |V| lg* *|V|) =* *Ө* *(|E| lg |E|)*，因为 *|E| ≥|V|
    -1*。
- en: This algorithm is called Kruskal's algorithm, invented by Joseph Kruskal. Kruskal's
    algorithm works with the complexity *Ө* *(|V| lg |E| )* if a sorted list of edges
    is already available. Since we have checked until all the edges are processed,
    if a graph is passed that is not connected, it will give a set of minimum spanning
    trees, one for each connected subgraph.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法被称为克鲁斯卡尔算法，由约瑟夫·克鲁斯卡尔发明。如果已经有一个排序好的边列表，克鲁斯卡尔算法的复杂度是 *Ө* *(|V| lg |E|)*。由于我们已经检查到所有边都处理完毕，如果传递一个不连通的图，它将给出一个最小生成树的集合，每个连通子图一个。
- en: Summary
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw what a graph is and some real-world scenarios where
    they can be applicable. We saw a few ways of implementing a graph data structure
    in memory. We then studied ways to traverse a graph, in both BFT and DFT. We used
    traversals to detect cycles in a graph. Finally, we saw what spanning trees are,
    what minimum spanning trees are, and how to find them in a graph.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了什么是图，以及它们在现实世界中的适用场景。我们看到了在内存中实现图数据结构的一些方法。然后我们研究了在BFT和DFT中遍历图的方法。我们使用遍历来检测图中的环。最后，我们看到了什么是生成树，什么是最小生成树，以及如何在图中找到它们。
- en: In the next chapter, we will drift a bit to explore a simple and elegant way
    of implementing some concurrent programming, called reactive programming.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将稍微偏离一下，探索一种简单而优雅的实现某些并发编程的方法，称为响应式编程。
