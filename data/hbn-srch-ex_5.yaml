- en: Chapter 5. Advanced Querying
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：高级查询
- en: In this chapter, we will elaborate on the basic search query concepts that we
    covered earlier, in light of the new mapping knowledge that we just picked up.
    We will now look at a number of techniques for making search queries more flexible
    and powerful.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细阐述我们在前面章节中介绍的基本搜索查询概念，并融入我们刚刚学到的新的映射知识。现在，我们将探讨使搜索查询更具灵活性和强大性的多种技术。
- en: We will see how to dynamically filter results at the Lucene level, before the
    database is even touched. We will also avoid database calls by using projection-based
    queries, to retrieve properties directly from Lucene. We will use faceted search,
    to recognize and isolate subsets of data within search results. Finally, we will
    cover some miscellaneous query tools, such as query-time boosting and placing
    time limits on a query.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何在数据库甚至还没有被触碰的情况下，在Lucene层面动态地过滤结果。我们还将通过使用基于投影的查询，避免数据库调用，直接从Lucene检索属性。我们将使用面向面的搜索，以识别和隔离搜索结果中的数据子集。最后，我们将介绍一些杂项查询工具，如查询时的提升和为查询设置时间限制。
- en: Filtering
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤
- en: 'The process of building a query revolves around finding matches. However, sometimes
    you want to narrow the search results on the basis of a criteria that explicitly
    did *not* match. For example, let''s say we want to limit our VAPORware Marketplace
    search to only those apps that are supported on a particular device:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 构建查询的过程围绕着寻找匹配项。然而，有时你希望根据一个明确没有匹配的准则来缩小搜索结果。例如，假设我们想要限制我们的VAPORware Marketplace搜索，只支持特定设备上的那些应用：
- en: Adding a keyword or phrase to an existing query doesn't help, because that would
    just make the query more inclusive.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向现有查询添加关键词或短语是没有帮助的，因为这只会使查询更加包容。
- en: We could turn the existing query into a boolean query, with an extra `must`
    clause, but then the DSL starts to become harder to maintain. Also, if you need
    to use complex logic to narrow your results, then the DSL may not offer enough
    flexibility.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将现有的查询转换为一个布尔查询，增加一个额外的`must`子句，但这样DSL开始变得难以维护。此外，如果你需要使用复杂的逻辑来缩小你的结果集，那么DSL可能提供不了足够的灵活性。
- en: A Hibernate Search `FullTextQuery` object inherits from the Hibernate ORM `Query`
    (or its JPA counterpart) class. So, we can narrow results using core Hibernate
    tools like `ResultTransformer`. However, this requires making additional database
    calls, which can impact performance.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Hibernate Search的`FullTextQuery`对象继承自Hibernate ORM的`Query`（或其JPA对应物）类。因此，我们可以使用像`ResultTransformer`这样的核心Hibernate工具来缩小结果集。然而，这需要进行额外的数据库调用，这可能会影响性能。
- en: Hibernate Search offers a more elegant and efficient **filter** approach. Through
    this mechanism, filter logic for various scenarios is encapsulated in separate
    classes. Those filter classes may be dynamically enabled or disabled at runtime,
    alone or in any combination. When a query is filtered, unwanted results are never
    fetched from Lucene in the first place. This reduces the weight of any follow-up
    database access.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate Search提供了一种更优雅和高效的**过滤器**方法。通过这种机制，各种场景的过滤逻辑被封装在单独的类中。这些过滤器类可以在运行时动态地启用或禁用，也可以以任何组合方式使用。当查询被过滤时，不需要从Lucene获取不想要的结果。这减少了后续数据库访问的负担。
- en: Creating a filter factory
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个过滤器工厂
- en: To filter our search results by supported devices, the first step is creating
    a class to store the filtering logic. This should be an instance of `org.apache.lucene.search.Filter`.
    For simple hardcoded logic, you might just create your own subclass.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过支持设备来过滤我们的搜索结果，第一步是创建一个存储过滤逻辑的类。这应该是`org.apache.lucene.search.Filter`的实例。对于简单的硬编码逻辑，你可能只需创建你自己的子类。
- en: 'However, if we instead generate filters dynamically with a filter factory,
    then we can accept parameters (for example, device name) and customize the filter
    at runtime:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们通过过滤器工厂动态地生成过滤器，那么我们就可以接受参数（例如，设备名称）并在运行时定制过滤器：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `@Factory` annotation is applied to the method responsible for producing
    the Lucene filter object. In this case, we annotate the aptly named `getFilter`
    method.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Factory`注解应用于负责生成Lucene过滤器对象的方法。在这个例子中，我们注解了恰当地命名为`getFilter`的方法。'
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Unfortunately, building a Lucene `Filter` object requires us to work more closely
    with the raw Lucene API, rather the convenient DSL wrapper provided by Hibernate
    Search. The full Lucene API is very involved, and covering it completely would
    require an entirely separate book. However, even this shallow dive is deep enough
    to give us the tools for writing really useful filters.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，构建Lucene `Filter`对象要求我们更紧密地与原始Lucene API合作，而不是Hibernate Search提供的方便的DSL包装器。Lucene完整API非常复杂，要完全覆盖它需要一本完全不同的书。然而，即使这种浅尝辄止也足够深入地为我们提供编写真正有用过滤器的工具。
- en: This example builds a filter by wrapping a Lucene query, and then applying a
    second wrapper to facilitate filter caching. A specific type of query used is
    `org.apache.lucene.search.PhraseQuery`, which is equivalent to the DSL phrase
    query that we explored in [Chapter 3](ch03.html "Chapter 3. Performing Queries"),
    *Performing Queries*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子通过包装一个Lucene查询来构建过滤器，然后应用第二个包装器以促进过滤器缓存。使用特定类型的查询是`org.apache.lucene.search.PhraseQuery`，它相当于我们在[第3章](ch03.html
    "第3章：执行查询")，*执行查询*中探讨的DSL短语查询。
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We are examining the phrase query in this example, because it is one of the
    most useful types for a building a filter. However, there are 15 Lucene query
    types in total. You can explore the JavaDocs at [http://lucene.apache.org/core/old_versioned_docs/versions/3_0_3/api/all/org/apache/lucene/search/Query.html](http://lucene.apache.org/core/old_versioned_docs/versions/3_0_3/api/all/org/apache/lucene/search/Query.html).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个例子中研究短语查询，因为它是一种非常有用的过滤器构建类型。然而，总共有15种Lucene查询类型。你可以探索[http://lucene.apache.org/core/old_versioned_docs/versions/3_0_3/api/all/org/apache/lucene/search/Query.html](http://lucene.apache.org/core/old_versioned_docs/versions/3_0_3/api/all/org/apache/lucene/search/Query.html)上的JavaDocs。
- en: Let's review some of the things we know about how data is stored in a Lucene
    index. By default, an analyzer tokenizes strings, and indexes them as individual
    terms. The default analyzer also converts the string data into lowercase. The
    Hibernate Search DSL normally hides all of this detail, so developers don't have
    to think about it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下关于数据在Lucene索引中是如何存储的一些知识。默认情况下，分析器对字符串进行分词，并将它们作为单独的词项进行索引。默认分析器还将字符串数据转换为小写。Hibernate
    Search DSL通常隐藏所有这些细节，因此开发人员不必考虑它们。
- en: However, you do need to account for these things when using the Lucene API directly.
    Therefore, our `setDeviceName` setter method manually converts the `deviceName`
    property to lower case, to avoid a mismatch with Lucene. The `getFilter` method
    then manually tokenizes this property into separate terms, likewise to match what
    Lucene has indexed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你直接使用Lucene API时，确实需要考虑这些事情。因此，我们的`setDeviceName`设置器方法手动将`deviceName`属性转换为小写，以避免与Lucene不匹配。`getFilter`方法随后手动将此属性拆分为单独的词项，同样是为了与Lucene索引的匹配。
- en: Each tokenized term is used to construct a Lucene `Term` object, which consists
    of the data and the relevant field name (that is, `supportedDevices.name` in this
    case). These terms are added to the `PhraseQuery` object one by one, in the exact
    order that they appear in the phrase. The query object is then wrapped up as a
    filter and returned.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每个分词词项都用于构造一个Lucene `Term`对象，该对象包含数据和相关字段名（即在这个案例中的`supportedDevices.name`）。这些词项一个接一个地添加到`PhraseQuery`对象中，按照它们在短语中出现的确切顺序。然后将查询对象包装成过滤器并返回。
- en: Adding a filter key
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加过滤器键
- en: By default, Hibernate Search caches filter instances for better performance.
    Therefore, each instance requires that a unique key be referenced by in the cache.
    In this example, the most logical key would be the device name for which each
    instance is filtering.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Hibernate Search为更好的性能缓存过滤器实例。因此，每个实例需要引用缓存中的唯一键。在这个例子中，最逻辑的键将是每个实例过滤的设备名称。
- en: 'First, we add a new method to our filter factory, annotated with `@Key` to
    indicate that it is responsible for generating the unique key. This method returns
    a subclass of `FilterKey`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在过滤器工厂中添加一个新方法，用`@Key`注解表示它负责生成唯一键。这个方法返回`FilterKey`的一个子类：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Custom `FilterKey` subclasses must implement the methods `equals` and `hashCode`.
    Typically, when the actual wrapped data may be expressed as a string, you can
    delegate to the corresponding methods on the `String` class:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义`FilterKey`子类必须实现`equals`和`hashCode`方法。通常，当实际包装的数据可以表示为字符串时，你可以委派给`String`类相应的`equals`和`hashCode`方法：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Establishing a filter definition
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建立过滤器定义
- en: 'To make this filter available for our app searches, we will create a filter
    definition in the `App` entity class:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个过滤器对我们应用的搜索可用，我们将在`App`实体类中创建一个过滤器定义：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `@FullTextFilterDef` annotation links the entity class with a given filter
    or filter-factory class, specified by the `impl` element. The `name` element is
    a string by which Hibernate Search queries can reference the filter, as we'll
    see in the next subsection.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`@FullTextFilterDef`注解将实体类与给定的过滤器或过滤器工厂类关联，由`impl`元素指定。`name`元素是一个字符串，Hibernate
    Search查询可以用它来引用过滤器，正如我们在下一小节中看到的。'
- en: An `entity` class may have any number of defined filters. The plural `@FullTextFilterDefs`
    annotation supports this, by wrapping a comma-separated list of one or more singular
    `@FullTextFilterDef` annotations.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`entity`类可以有任意数量的定义过滤器。复数形式的`@FullTextFilterDefs`注解支持这一点，通过包裹一个由逗号分隔的一个或多个单数形式的`@FullTextFilterDef`注解列表。
- en: Enabling the filter for a query
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为查询启用过滤器
- en: 'Last but not least, we enable the filter definition for a Hibernate Search
    query, using the `FullTextQuery` object''s `enableFullTextFilter` method:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，我们使用`FullTextQuery`对象的`enableFullTextFilter`方法为Hibernate Search查询启用过滤器定义：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This method's `string` parameter is matched to a filter definition on one of
    the entity classes involved in the query. In this case, it's the `deviceName`
    filter defined on `App`. When Hibernate Search finds this match, it will automatically
    invoke the corresponding filter factory to get a `Filter` object.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的`string`参数与查询中涉及的实体类之一的过滤器定义相匹配。在这个例子中，是`App`上定义的`deviceName`过滤器。当Hibernate
    Search找到这个匹配项时，它会自动调用相应的过滤器工厂来获取一个`Filter`对象。
- en: Our filter factory uses a parameter, also called `deviceName` for consistency
    (although it's a different variable). Before Hibernate Search can invoke the factory
    method, this parameter must be set, by passing the parameter name and value to
    `setParameter`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的过滤器工厂使用一个参数，也称为`deviceName`以保持一致性（尽管它是一个不同的变量）。在Hibernate Search可以调用工厂方法之前，这个参数必须被设置，通过将参数名和值传递给`setParameter`。
- en: 'The filter is enabled within an `if` block, so that we can skip this when no
    device was selected (that is, the **All Devices** option). If you examine the
    downloadable code bundle for this chapter''s version of the VAPORware Marketplace
    application, you will see that the HTML file has been modified to add a drop-down
    menu for device selection:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器是在`if`块中启用的，这样在没有选择设备时（也就是，*所有设备*选项），我们可以跳过这一步。如果你检查本章版本VAPORware Marketplace应用的可下载代码包，你会看到HTML文件已经被修改为添加了设备选择的下拉菜单：
- en: '![Enabling the filter for a query](img/9205_05_01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![为查询启用过滤器](img/9205_05_01.jpg)'
- en: Projection
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 投影
- en: In the first couple of chapters, our example application fetched all the matching
    entities in one big database call. We introduced pagination in [Chapter 3](ch03.html
    "Chapter 3. Performing Queries"), *Performing Queries*, to at least limit the
    database calls to a fixed number of rows. However, since we're already searching
    data in a Lucene index to begin with, is it really necessary to go to the database
    at all?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们的示例应用程序在一次大的数据库调用中获取所有匹配的实体。我们在[第3章](ch03.html "Chapter 3. Performing
    Queries")，*执行查询*中引入了分页，以至少限制数据库调用到的行数。然而，由于我们最初已经在Lucene索引中搜索数据，真的有必要去数据库吗？
- en: Hibernate Search offers **projections** as a technique for eliminating, or at
    least reducing, database access. A projection-based search returns only specific
    fields pulled from Lucene, rather than returning a full entity object from the
    database. You can then go to the database and fetch full objects if necessary,
    but the fields available in Lucene may be sufficient by themselves.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 休眠搜索提供了**投影**作为一种减少或至少消除数据库访问的技术。基于投影的搜索只返回从Lucene中提取的特定字段，而不是从数据库中返回完整的实体对象。然后你可以去数据库获取完整的对象（如果需要），但Lucene中可用的字段本身可能就足够了。
- en: This chapter's version of the VAPORware Marketplace application modifies the
    search results page so that it now uses a projection-based query. The previous
    versions of the page received `App` entities all at once, and hid each app's pop-up
    window until its **Full Detail** button was clicked. Now, the page receives only
    enough fields to build the summary view. Each **Full Detail** button triggers
    an AJAX call for that app. Only then is the database called, and only to fetch
    data for that one app.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的VAPORware Marketplace应用程序版本的搜索结果页面修改为现在使用基于查询的投影。之前的版本页面一次性收到`App`实体，并在点击每个应用的**完整详情**按钮之前隐藏每个应用的弹出窗口。现在，页面只接收足够构建摘要视图的字段。每个**完整详情**按钮触发对该应用的AJAX调用。只有在那时才调用数据库，并且仅为了获取那一个应用的数据。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Exhaustive descriptions of how to make AJAX calls from JavaScript and how to
    write RESTful web services to respond to those calls, ventures pretty far beyond
    the scope of this Hibernate Search book.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从JavaScript中进行AJAX调用以及编写响应这些调用的RESTful网络服务的详尽描述，已经超出了本Hibernate Search书籍的范围。
- en: That being said, all of the JavaScript is contained on the search results JSP,
    within the `showAppDetails` function. All of the corresponding server-side Java
    code resides in the `com.packtpub.hibernatesearch.rest` package, and is heavily
    commented. There are endless online primers and tutorials for writing RESTful
    services, and the documentation for the particular framework used here is at [http://jersey.java.net/nonav/documentation/latest](http://jersey.java.net/nonav/documentation/latest).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这里，所有的JavaScript都包含在搜索结果的JSP中，在`showAppDetails`函数内。所有相应的服务器端Java代码都位于`com.packtpub.hibernatesearch.rest`包中，并且非常注释。网络上
    endless online primers and tutorials for writing RESTful services, and the documentation
    for the particular framework used here is at [http://jersey.java.net/nonav/documentation/latest](http://jersey.java.net/nonav/documentation/latest).
- en: Making a query projection-based
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个基于查询的查询投影
- en: 'To change `FullTextQuery` to be projection-based, invoke the `setProjection`
    method on that object. Our search servlet class now contains the following line:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`FullTextQuery`更改为基于投影的查询，请对该对象调用`setProjection`方法。现在我们的搜索servlet类包含以下内容：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The method accepts the names of one or more fields to pull from the Lucene indexes
    associated with this query.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受一个或多个字段名称，从与该查询关联的Lucene索引中提取这些字段。
- en: Converting projection results to an object form
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将投影结果转换为对象形式
- en: If we stopped right here, then the query object's `list()` method would no longer
    return a list of `App` objects! By default, projection-based queries return a
    list of object arrays (that is, `Object[]`) instead of entity objects. These arrays
    are often referred to as **tuples**.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们到此为止，那么查询对象的`list()`方法将不再返回`App`对象的列表！默认情况下，基于投影的查询返回对象数组列表（即`Object[]`）而不是实体对象。这些数组通常被称为**元组**。
- en: The elements in each tuple contain values for the projected fields, in the order
    they were declared. For example, here `listItem[0]` would contain the value of
    a result's ID, `field.listItem[1]` would contain the name, `value.listItem[2]`
    would contain the description, and so on.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 每个元组中的元素包含投影字段的值，按它们声明的顺序排列。例如，这里`listItem[0]`将包含结果的ID值，`field.listItem[1]`将包含名称，`value.listItem[2]`将包含描述，依此类推。
- en: 'In some cases, it''s easy enough to work with the tuple as-is. However, you
    can automatically convert tuples into an object form by attaching a Hibernate
    ORM result transformer to the query. Doing so changes the query''s return type
    yet again, from `List<Object[]>` to a list of the desired object type:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，直接使用元组是很简单的。然而，您可以通过将Hibernate ORM结果转换器附加到查询来自动将元组转换为对象形式。这样做再次改变了查询的返回类型，从`List<Object[]>`变为所需对象类型的列表：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can create your own custom transformer class inheriting from `ResultTransformer`,
    implementing whatever complex logic you need. However, in most cases, the subclasses
    provided by Hibernate ORM out of the box are more than enough.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建自己的自定义转换器类，继承自`ResultTransformer`，实现您需要的任何复杂逻辑。然而，在大多数情况下，Hibernate ORM提供的开箱即用的子类已经足够了。
- en: Here, we are using the `AliasToBeanResultTransformer` subclass, and initializing
    it with our `App` entity class. This matches up the projected fields with the
    entity class properties having the same names, and sets each property with the
    corresponding field value.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用`AliasToBeanResultTransformer`子类，并用我们的`App`实体类对其进行初始化。这将与投影字段匹配，并将每个属性的值设置为相应的字段值。
- en: Only a subset of properties of `App` are available. It is okay to leave the
    other properties uninitialized, since the search results JSP doesn't need them
    when building its summary list. Also, the resulting `App` objects won't actually
    be attached to a Hibernate session. However, we've been detaching our results
    before sending them to the JSP anyway.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 只有`App`的一部分属性是可用的。保留其他属性未初始化是可以的，因为搜索结果的JSP在构建其摘要列表时不需要它们。另外，生成的`App`对象实际上不会附加到Hibernate会话。然而，我们在此之前已经将我们的结果分离，然后再发送给JSP。
- en: Making Lucene fields available for projection
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使Lucene字段可用于投影
- en: By default, Lucene indexes are optimized with the assumption that they will
    not be used for projection-based queries. Therefore, projection requires that
    you make some small mapping changes and bear a couple of caveats in mind.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Lucene索引是为假设它们不会用于基于投影的查询而优化的。因此，投影需要你做一些小的映射更改，并记住几个注意事项。
- en: 'First and foremost, the field data must be stored by Lucene in a manner that
    can be easily retrieved. The normal indexing process optimizes data for complex
    queries, not for retrieval in its original form. To store a field''s value in
    a form that can be restored by a projection, you add a `store` element to the
    `@Field` annotation:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，字段数据必须以可以轻松检索的方式存储在Lucene中。正常的索引过程优化数据以支持复杂查询，而不是以原始形式检索。为了以可以被投影恢复的形式存储字段的值，你需要在`@Field`注解中添加一个`store`元素：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This element takes an enum with three possible values:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个元素取三个可能值的枚举：
- en: '`Store.NO` is the default. It causes the field to be indexed for searching,
    but not retrievable in its original form through projection.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Store.NO`是默认值。它使字段被索引用于搜索，但不能通过投影以原始形式检索。'
- en: '`Store.YES` causes the field to be included as-is in the Lucene index. This
    increases the size of the index, but makes projections possible.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Store.YES`使字段以原样包含在Lucene索引中。这增加了索引的大小，但使投影变得可能。'
- en: '`Store.COMPRESS` is an attempt at compromise. It also stores the field as-is,
    but applies compression to reduce the overall index size. Be aware that this is
    more processor-intensive, and is not available for a field that also uses the
    `@NumericField` annotation.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Store.COMPRESS`是对妥协的尝试。它也将字段存储原样，但应用压缩以减少整体索引大小。请注意，这更占用处理器资源，并且不适用于同时使用`@NumericField`注解的字段。'
- en: Secondly, a field must use a bi-directional field bridge. All of the default
    bridges built-in to Hibernate Search already support this. However, if you create
    your own custom bridge type (see [Chapter 4](ch04.html "Chapter 4. Advanced Mapping"),
    *Advanced Mapping*), it must be based on `TwoWayStringBridge` or `TwoWayFieldBridge`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，一个字段必须使用双向字段桥。Hibernate Search中所有内置的默认桥都支持这一点。然而，如果你创建自己的自定义桥类型（请参阅[第4章](ch04.html
    "第4章高级映射")，*高级映射*），它必须基于`TwoWayStringBridge`或`TwoWayFieldBridge`。
- en: Last but not least, projection is only effective for basic properties on the
    entity class itself. It is not meant for fetching associated entities or embedded
    objects. If you do try to reference an association, then you will only get one
    instance rather than the full collection that you were probably expecting.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，投影仅适用于实体类本身的基属性。它不是用来获取关联实体或内嵌对象的。如果你尝试引用一个关联，那么你只能得到一个实例，而不是你可能期望的完整集合。
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you need to work with the associated or embedded objects, then you might
    take the approach used by our example application. Lucene projection fetches the
    basic properties for all search results, including the entity object's primary
    key. When we later need to work with an entity object's associations, we use that
    primary key to retrieve only the necessary rows through a database call.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要与关联或内嵌对象一起工作，那么你可能需要采用我们示例应用程序所使用的方法。Lucene投影检索所有搜索结果的基本属性，包括实体对象的的主键。当我们后来需要与实体对象的关联一起工作时，我们通过数据库调用使用那个主键只检索必要的行。
- en: Faceted search
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分面搜索
- en: Lucene filters are a powerful tool for narrowing the scope of a query to some
    particular subset. However, filters work on predefined subsets. You must already
    know what it is that you are seeking.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Lucene过滤器是缩小查询范围到特定子集的强大工具。然而，过滤器对预定义的子集起作用。你必须已经知道你在寻找什么。
- en: 'Sometimes you need to dynamically identify subsets. For example, let''s give
    our `App` entity a `category` property representing its genre:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要动态地识别子集。例如，让我们给我们的`App`实体一个表示其类别的`category`属性：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When we perform a keyword search for apps, we might want to know which categories
    are represented in the results and how many results fall under each category.
    We might also want to know which price ranges were found. All of this information
    can help guide users in narrowing their queries more effectively.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为应用执行关键字搜索时，我们可能想知道哪些类别在结果中有所体现以及每个类别下有多少结果。我们还可能想知道发现了哪些价格范围。所有这些信息都有助于用户更有效地缩小查询。
- en: Discrete facets
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 离散切片
- en: 'The process of dynamically identifying dimensions and then filtering by them
    is called **faceted search**. The Hibernate Search query DSL has a flow for this,
    starting with a `QueryBuilder` object''s `facet` method:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 动态识别维度然后通过它们进行过滤的过程称为**切片搜索**。Hibernate Search 查询 DSL 有一个流程为此，从 `QueryBuilder`
    对象的 `facet` 方法开始：
- en: '![Discrete facets](img/9205_05_02.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![离散切片](img/9205_05_02.jpg)'
- en: Discrete faceting request flow (dotted gray arrows represent optional paths)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 离散切片请求流程（虚线灰色箭头表示可选路径）
- en: The `name` method takes some descriptive identifier for this facet (for example,
    `categoryFacet`), so that it can be referenced by queries later. The familiar
    `onField` clause declares the field by which to group results (for example, `category`).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`name` 方法需要一个描述性标识符作为此切片的名称（例如，`categoryFacet`），以便后来可以通过查询引用它。熟悉的 `onField`
    子句声明了按结果分组的字段（例如，`category`）。'
- en: The `discrete` clause indicates that we are grouping by single values, as opposed
    to ranges of values. We'll explore range facets in the next section.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`discrete` 子句表示我们是按单个值分组，而不是按值的范围分组。我们将在下一节探讨范围切片。'
- en: 'The `createFacetingRequest` method completes this process and returns a `FacetingRequest`
    object. However, there are three optional methods that you can call first, in
    any combination:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`createFacetingRequest` 方法完成此过程并返回一个 `FacetingRequest` 对象。然而，还有三个可选的方法，你可以先调用它们中的任何一个，可以任意组合：'
- en: '`includeZeroCounts`: It causes Hibernate Search to return all possible facets,
    even those which do not have any hits in the current search results. By default,
    facets with no hits are quietly ignored.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`includeZeroCounts`：它导致 Hibernate Search 返回所有可能的切片，甚至在当前搜索结果中没有任何点击的那些。默认情况下，没有点击的切片会被悄悄忽略。'
- en: '`maxFacetCount`: It limits the number of facets to be returned.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxFacetCount`：它限制返回的切片数量。'
- en: '`orderedBy`: It specifies the sort order of the facets found. The three options
    relevant to discrete facets are:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orderedBy`：它指定了找到的切片的排序顺序。与离散切片相关的三个选项是：'
- en: '`COUNT_ASC`: Facets are sorted in an ascending order by the number of associated
    search results. The facets with the lowest number of hits are listed first.'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COUNT_ASC`: 按相关搜索结果的数量升序排列切片。数量最少点击的切片将被首先列出。'
- en: '`COUNT_DESC`: This is the exact opposite of `COUNT_ASC`. Facets are listed
    from the highest hit count to the lowest.'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COUNT_DESC`：这与 `COUNT_ASC` 正好相反。切片从点击量最高到最低依次列出。'
- en: '`FIELD_VALUE`: Facets are sorted in an alphabetical order by the value of the
    relevant field. For example, the "business" category would come before the "games"
    category.'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FIELD_VALUE`：按相关字段的值字母顺序排序切片。例如，"business" 类别会在 "games" 类别之前。'
- en: 'This chapter''s version of the VAPORware Marketplace now includes the following
    code for setting up a faceted search on the `app` category:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 本章版本的 VAPORware Marketplace 现在包括以下设置 `app` 类别切片搜索的代码：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now that the faceting request is enabled, we can run the search query and retrieve
    the facet information using the `categoryFacet` name that we just declared:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在切片请求已启用，我们可以运行搜索查询并使用我们刚刚声明的 `categoryFacet` 名称检索切片信息：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `Facet` class includes a `getValue` method, which returns the value of the
    field for a particular group. For example, if some of the matching apps are in
    the "business" category, then one of the facets will have the string "business"
    as its value. The `getCount` method reports how many search results are associated
    with that facet.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Facet` 类包括一个 `getValue` 方法，该方法返回特定组的字段值。例如，如果一些匹配的应用程序属于 "business" 类别，那么其中一个切片将具有字符串
    "business" 作为其值。`getCount` 方法报告与该切片关联多少搜索结果。'
- en: 'Using these two methods, our search servlet can iterate through all of the
    category facets, and build a collection to be used for display in the search results
    JSP:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个方法，我们的搜索servlet可以遍历所有类别切片，并构建一个集合，用于在搜索结果JSP中显示：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If the search servlet receives a request with a `selectedCategory` CGI parameter,
    then the user chooses to narrow results to a specific category. So if this string
    matches the value of a facet being iterated, then that facet is "selected" for
    the `FullTextQuery` object. The query can then be re-run, and it will then return
    only apps belonging to that category.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果搜索servlet接收到带有`selectedCategory` CGI参数的请求，那么用户选择将结果缩小到特定类别。所以如果这个字符串与正在迭代的面元值匹配，那么该面元就为`FullTextQuery`对象“选中”。然后可以重新运行查询，它将只返回属于该类别的应用程序。
- en: Range facets
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 范围面元
- en: Facets are not limited to single discrete values. A facet may also be created
    from a range of values. For example, we might want to group apps by a price range—search
    results priced below one dollar, between one and five dollars, or above five dollars.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 面元不仅仅限于单一的离散值。一个面元也可以由一个值范围创建。例如，我们可能想根据价格范围对应用程序进行分组——搜索结果中的价格低于一美元、在一到五美元之间，或者高于五美元。
- en: 'The Hibernate Search DSL for range faceting takes the elements of the discrete
    faceting flow and combines them with elements from the range query that we saw
    in [Chapter 3](ch03.html "Chapter 3. Performing Queries"), *Performing Queries*:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate Search DSL的范围面元需要将离散面元流程的元素与我们在[第3章](ch03.html "第3章. 执行查询") *执行查询*
    中看到的范围查询的元素结合起来：
- en: '![Range facets](img/9205_05_03.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![范围面元](img/9205_05_03.jpg)'
- en: Range faceting request flow (dotted gray arrows represent optional paths)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 范围面元请求流程（虚线灰色箭头代表可选路径）
- en: You can define a range as being above, below, or between two values (that is,
    `from` – `to`). These options may be used in combination to define as many range
    subsets as you wish.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以定义一个范围为大于、小于或介于两个值之间（即`from` – `to`）。这些选项可以组合使用以定义尽可能多的范围子集。
- en: As with regular range queries, the optional `excludeLimit` method exclude its
    boundary value from the range. In other words, `above(5)` means "greater than
    or equal to 5", whereas `above(5).excludeLimit()` means "greater than 5, *period*".
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规范围查询一样，可选的`excludeLimit`方法将其边界值从范围内排除。换句话说，`above(5)`意味着“大于或等于5”，而`above(5).excludeLimit()`意味着“大于5，*期终*”。
- en: The optional `includeZeroCounts`, `maxFacetCount`, and `orderBy` methods operate
    in the same manner as with discrete faceting. However, range faceting offers an
    extra choice for sorting order. `FacetSortOrder.RANGE_DEFINITION_ODER` causes
    facets to be returned in the order they were defined (note that the "`r`" is missing
    in "`oder`").
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的`includeZeroCounts`、`maxFacetCount`和`orderBy`方法与离散面元的方式相同。然而，范围面元提供了一个额外的排序顺序选择。`FacetSortOrder.RANGE_DEFINITION_ODER`使得面元按照它们被定义的顺序返回（注意“`oder`”中缺少了“`r`”）。
- en: 'Along the discrete faceting request for `category`, the example code for this
    chapter also includes the following code snippet to enable range faceting for
    `price`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在针对`category`的离散面元请求中，本章的示例代码还包括以下代码段以启用`price`的范围面元：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you take a look at the source code for `search.jsp`, it now includes both
    the category and price range facets found during each search. These two faceting
    types may be used in combination to narrow the search results, with the currently-selected
    facets highlighted in bold. When **all** is selected for either type, that particular
    facet is removed and the search results widen again.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`search.jsp`的源代码，现在包括了在每次搜索中找到的类别和价格范围面元。这两种面元类型可以组合使用以缩小搜索结果，当前选中的面元以粗体突出显示。当**所有**选中任一类型时，该特定面元被移除，搜索结果再次扩大。
- en: '![Range facets](img/9205_05_04.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![范围面元](img/9205_05_04.jpg)'
- en: Query-time boosting
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询时的提升
- en: In [Chapter 3](ch03.html "Chapter 3. Performing Queries"), *Performing Queries*,
    we saw how to boost a field's relevance at index time, on either a fixed or a
    dynamic basis. It is also possible to dynamically change the weight at query time.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章. 执行查询") *执行查询* 中，我们看到了如何在索引时间固定或动态地提升字段的的相关性。在查询时间动态改变权重也是可能的。
- en: 'All query types in the Hibernate Search DSL include the `onField` and `andField`
    methods. For each query type, these two clauses also support a `boostedTo` method,
    taking a `weight` factor as a `float` parameter. Whatever the index-time weight
    of that field might be, adding a `boostedTo` clause multiplies it by the indicated
    number:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate Search DSL中的所有查询类型都包括`onField`和`andField`方法。对于每个查询类型，这两个子句也支持一个`boostedTo`方法，它接受一个`weight`因子作为`float`参数。无论该字段索引时的权重可能是什么，添加一个`boostedTo`子句就会将它乘以指示的数字：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this chapter's version of the VAPORware Marketplace application, query-time
    boosting is now added to the "exact phrase" use case. When users wraps their search
    string in double quotes to search by phrase rather than by keywords, we want to
    give the `App` entity's name and description field even more weight than normal.
    The highlighted changes double the index-time weight of those two fields, but
    only for the exact phrase query rather than for all query types.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的VAPORware Marketplace应用程序版本中，查询时的提升现在添加到了“确切短语”用例中。当用户用双引号括起他们的搜索字符串以通过短语而不是关键词进行搜索时，我们想要给`App`实体的名称和描述字段比正常情况下更多的权重。高亮显示的更改将这两个字段在索引时的权重加倍，但只针对确切短语查询，而不是所有查询类型。
- en: Placing time limits on a query
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置查询的超时
- en: The example application we have been working with has a limited set of test
    data, only a dozen apps, and a handful of devices. So, as long as your computer
    has a reasonable amount of processor and memory resources, the search queries
    should run almost instantaneously.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在工作的这个示例应用程序有一个有限的测试数据集，只有十几款应用程序和几款设备。因此，只要你的计算机有合理的处理器和内存资源，搜索查询应该几乎立即运行。
- en: However, an application with real data might involve searching across millions
    of entities, and there may be a risk of your queries taking too long. As a matter
    of user experience if nothing else, you will probably want to limit the execution
    of your queries to some reasonable period of time.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个带有真实数据的应用程序可能涉及跨数百万个实体的搜索，你的查询可能存在运行时间过长的风险。从用户体验的角度来看，如果你不限制查询的执行时间，可能会导致应用程序响应缓慢。
- en: 'Hibernate Search offers two approaches for time boxing a query. One is through
    the `FullTextQuery` object''s `limitExecutionTime` method:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate Search提供了两种时间盒查询的方法。一种是通过`FullTextQuery`对象的`limitExecutionTime`方法：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This method causes the query to gracefully halt after a specified period of
    time, and return all of the results that it had found up until that point. The
    first parameter is the number of time units, and the second parameter is the type
    of time unit (for example, microsecond, millisecond, second, and so on). The preceding
    code snippet will try to stop the query after two seconds of searching.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法会在指定的时间后优雅地停止查询，并返回它找到的所有结果直到那个点。第一个参数是时间单位数，第二个参数是时间单位类型（例如，微秒、毫秒、秒等）。前面的代码片段将尝试在搜索两秒后停止查询。
- en: Tip
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: After this query runs, you can determine whether or not it was interrupted by
    calling the object's `hasPartialResults()` method. This Boolean method returns
    `true` if the query timed out before reaching its natural conclusion.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 查询运行后，你可以通过调用对象的`hasPartialResults()`方法来确定是否被中断。这个布尔方法如果在查询在自然结束之前超时就返回`true`。
- en: 'The second approach, using the `setTimeout()` method, is similar in concept
    and in the parameters taken:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法，使用`setTimeout()`函数，在概念上和接受的参数上与第一种相似：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: However, this method is for situations where the search should fail completely
    upon timeout, rather than proceeding as if it didn't happen. The preceding query
    object will throw a `QueryTimeoutException` exception after running for two full
    seconds, and will not return any results that were found during that time.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个方法适用于搜索在超时后应该完全失败，而不是像没发生过一样继续进行的情况。在前面的查询对象在运行两秒后会抛出`QueryTimeoutException`异常，并且不会返回在这段时间内找到的任何结果。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be aware that with both of these approaches, Hibernate Search does the best
    it can to respect the specified period of time. It may actually take a bit more
    time for the query to halt.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这两种方法中，Hibernate Search都会尽其所能尊重指定的一段时间。实际上，查询停止可能会需要一点额外的时间。
- en: Also, these timeout settings only affect Lucene access. Once your query has
    finished searching Lucene and starts pulling actual entities from the database,
    timeout control is in the hands of Hibernate ORM rather than Hibernate Search.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，这些超时设置只影响Lucene访问。一旦你的查询完成了对Lucene的搜索并开始从数据库中提取实际实体，超时控制就由Hibernate ORM而不是Hibernate
    Search来处理。
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored more advanced techniques for narrowing search results,
    improving the quality of match relevance, and increasing performance.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一章，我们探讨了更多高级的技术来缩小搜索结果，提高匹配的相关性，以及提高性能。
- en: We can now use Lucene filters to hone in on a fixed subset of matches. We have
    also seen how to use faceted search to dynamically identify subsets within results.
    Through projection-based queries, we can reduce or even eliminate the need for
    actual database calls. We now know how to adjust the relevance of fields at query
    time rather than at index time only. Last but not least, we are now able to set
    time limits on our queries and gracefully handle situations where a search runs
    too long.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用Lucene过滤器来缩小匹配结果的一个固定子集。我们也看到了如何使用面向面的搜索在结果中动态识别子集。通过基于投影的查询，我们可以减少甚至消除实际数据库调用的需要。现在我们知道如何在查询时而非仅在索引时调整字段的相关性。最后但同样重要的是，我们现在能够为我们的查询设置时间限制，并优雅地处理搜索运行时间过长的情形。
- en: In the next chapter, we will turn toward administration and maintenance, learning
    how to configure Hibernate Search and Lucene for optimal performance.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将转向管理和维护的内容，学习如何配置Hibernate Search和Lucene以实现最佳性能。
