- en: Chapter 8. JSF 2.2 – HTML5 and Upload
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. JSF 2.2 – HTML5和上传
- en: This chapter can be read in two parts. The first part will present the JSF 2.2
    support for HTML5, while the second part discusses the new **upload** component
    of JSF 2.2\. Apparently, these two parts are not related, but as you will see,
    the upload component of JSF 2.2 can be spiced up with HTML5 features and the new
    pass-through attributes can be very helpful to extend the upload component of
    JSF 2.2 with HTML5 upload component facilities.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章可以分为两部分来阅读。第一部分将介绍JSF 2.2对HTML5的支持，而第二部分将讨论JSF 2.2的新**上传**组件。显然，这两部分并不相关，但正如您将看到的，JSF
    2.2的上传组件可以通过HTML5特性和新的透传属性来增强，这些新的透传属性对于扩展JSF 2.2的上传组件以支持HTML5上传组件功能非常有帮助。
- en: Working with HTML5 and JSF 2.2
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HTML5和JSF 2.2一起工作
- en: 'Everybody involved in web application development is enthusiastic to explore
    and use HTML5, which comes with a suite of new components and features, such as
    `<audio>`, `<video>`, `<keygen>`, and so on. Starting with version 2.2, JSF developers
    can interact with HTML5 using the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 所有参与网络应用开发的人都热衷于探索和使用HTML5，它带来了一系列新的组件和特性，如`<audio>`、`<video>`、`<keygen>`等。从版本2.2开始，JSF开发者可以使用以下方式与HTML5交互：
- en: Pass-through attributes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 透传属性
- en: Pass-through elements (HTML-friendly markup)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 透传元素（HTML友好标记）
- en: Note
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although pass-through elements and pass-through attributes are inspired by HTML5,
    they are JSF elements that might be used with other HTML versions as well.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然透传元素和透传属性受到HTML5的启发，但它们是JSF元素，也可以与其他HTML版本一起使用。
- en: These mechanisms are the alternative to writing custom render kits. This is
    a great solution, because HTML5 is in the developing stage, which means that writing
    and adapting render kits to constant HTML5 changes can be a real challenge.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这些机制是编写自定义渲染套件的替代方案。这是一个很好的解决方案，因为HTML5处于发展阶段，这意味着编写和调整渲染套件以适应持续的HTML5变化可能是一个真正的挑战。
- en: If you want to use HTML5 with JSF 2.0, then you need to write custom render
    kits for supporting the new components and attributes.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在JSF 2.0中使用HTML5，那么您需要编写自定义渲染套件以支持新的组件和属性。
- en: Pass-through attributes
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 透传属性
- en: Starting with JSF 2.2, we have attributes that are processed by JSF components
    on the server side and **pass-through attributes** that are processed at runtime
    on the client side.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从JSF 2.2开始，我们有在服务器端由JSF组件处理的属性和在运行时在客户端处理的**透传属性**。
- en: A handy HTML5 element that can be used for exemplifying pass-through attributes
    is the `<input>` element. Among the new supported features, we have new values
    for `type` attribute (such as, `email`, `tel`, `color`, and `reset`) and the new
    attribute, `placeholder` (a text used as a hint in empty fields).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个方便的HTML5元素，可以用来展示透传属性的是`<input>`元素。在新的支持特性中，我们有`type`属性的新值（例如，`email`、`tel`、`color`和`reset`）以及新的属性`placeholder`（用作空字段提示的文本）。
- en: 'In pure HTML5, such an element can be as shown in the following code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯HTML5中，这样的元素可以如下所示：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The same thing can be obtained with pass-through attributes in five different
    ways:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过五种不同的方式使用透传属性获得相同的结果：
- en: 'Place the pass-through attributes in the new namespace `http://xmlns.jcp.org/jsf/passthrough`
    (any JSF developer is familiar with namespaces and prefixed elements. There is
    no trick to use this namespace or prefixed attributes). Let''s see how to obtain
    the preceding HTML5 element using JSF pass-through attributes, as follows:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将透传属性放置在新命名空间`http://xmlns.jcp.org/jsf/passthrough`中（任何JSF开发者都熟悉命名空间和前缀元素。使用此命名空间或前缀属性没有技巧）。让我们看看如何使用JSF透传属性获取前面的HTML5元素，如下所示：
- en: '[PRE1]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When this book was written, there was still a debate about which is the proper
    prefix for this namespace. Initially, `p` was chosen, but this is recognized as
    the prefix of PrimeFaces; therefore, another prefix had to be used. So, when you
    read this book, feel free to replace `f5` (used here) with the one that wins this
    debate and becomes more popular.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当这本书被编写时，关于此命名空间的适当前缀仍存在争议。最初选择了`p`，但这个前缀被认为是PrimeFaces的前缀；因此，必须使用另一个前缀。所以，当您阅读这本书时，请随意将这里使用的`f5`（此处使用）替换为赢得这场辩论并变得更受欢迎的前缀。
- en: 'Use `<f:passThroughAttribute>` nested in `<h:inputText>`, as follows:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用嵌套在`<h:inputText>`中的`<f:passThroughAttribute>`，如下所示：
- en: '[PRE2]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Pass-through attributes might come from a managed bean also. Place them in
    a `Map<String, String>`, where the map key is the attribute name and the map value
    is the attribute value, as follows:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 透传属性也可能来自一个管理 Bean。将它们放在一个 `Map<String, String>` 中，其中映射键是属性名称，映射值是属性值，如下所示：
- en: '[PRE3]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Further, use `<f:passThroughAttributes>` tag, as shown in the following code:'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，使用以下代码中的 `<f:passThroughAttributes>` 标签：
- en: '[PRE4]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Using Expression Language 3 (part of Java EE 7), multiple attributes can also
    be directly defined, as follows (practically, you define a `Map<String, String>`
    via EL 3):'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用表达式语言 3（Java EE 7 的一部分），也可以直接定义多个属性，如下所示（实际上，您可以通过 EL 3 定义一个 `Map<String,
    String>`）：
- en: '[PRE5]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The complete example is available in the code bundle of this chapter and is
    named `ch8_1`.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完整的示例可以在本章的代码包中找到，名称为 `ch8_1`。
- en: 'Pass-through attributes can be added programmatically. For example, you can
    generate an HTML5 input element and add it into a form, as follows:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 透传属性可以通过编程方式添加。例如，您可以生成一个 HTML5 输入元素并将其添加到表单中，如下所示：
- en: '[PRE6]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The complete example is available on the code bundle of this chapter and is
    named `ch8_1_2`.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完整的示例可以在本章的代码包中找到，名称为 `ch8_1_2`。
- en: Pass-through elements
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 透传元素
- en: 'JSF developers hide HTML code behind JSF components. For web designers, the
    JSF code may look pretty strange, but the generated HTML is more familiar. In
    order to alter the generated HTML, web designers have to modify the JSF code,
    which can be difficult for them. But JSF 2.2 comes with friendly markup for HTML5,
    known as **pass-through elements**. Using this feature, web designers can write
    pure HTML code and JSF developers can come over and link the HTML elements to
    the server side by adding/replacing the necessary attributes. JSF recognizes such
    attributes if they are in the [http://xmlns.jcp.org/jsf](http://xmlns.jcp.org/jsf)
    namespace. For example, we can write a JSF page without any JSF tag, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 开发者将 HTML 代码隐藏在 JSF 组件后面。对于网页设计师来说，JSF 代码可能看起来相当奇怪，但生成的 HTML 更熟悉。为了更改生成的
    HTML，网页设计师必须修改 JSF 代码，这对他们来说可能很困难。但 JSF 2.2 提供了友好的 HTML5 标记，称为 **透传元素**。使用此功能，网页设计师可以编写纯
    HTML 代码，JSF 开发者可以添加/替换必要的属性，并将 HTML 元素链接到服务器端。如果这些属性位于 [http://xmlns.jcp.org/jsf](http://xmlns.jcp.org/jsf)
    命名空间中，JSF 会识别这些属性。例如，我们可以编写一个没有任何 JSF 标签的 JSF 页面，如下所示：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: JSF scans the HTML elements for attributes in the namespace [http://xmlns.jcp.org/jsf](http://xmlns.jcp.org/jsf).
    For such elements, JSF will determine the element type and will add the corresponding
    JSF component instead (`<h:head>` for `<head>` and `<h:inputText>` for `<input>`).
    JSF will add the components in the component tree, which will be rendered as HTML
    code to the client. This JSF component will be linked to the particular element
    and will receive the attributes as "normal" attributes or as pass-through attributes,
    depending on their origins. The correspondence between JSF components and HTML
    elements is available at [http://docs.oracle.com/javaee/7/api/javax/faces/view/facelets/TagDecorator.html](http://docs.oracle.com/javaee/7/api/javax/faces/view/facelets/TagDecorator.html).
    For HTML elements that don't have a direct correspondent (for example `<div>`
    and `<span>`), JSF will create a special component, component-family, such as
    `javax.faces.Panel`, and render-type `javax.faces.passthrough.Element` as detailed
    at [http://docs.oracle.com/javaee/7/javaserverfaces/2.2/vdldocs/facelets/jsf/element.html](http://docs.oracle.com/javaee/7/javaserverfaces/2.2/vdldocs/facelets/jsf/element.html).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 会扫描 HTML 元素中命名空间 [http://xmlns.jcp.org/jsf](http://xmlns.jcp.org/jsf) 的属性。对于这样的元素，JSF
    将确定元素类型，并将相应的 JSF 组件添加进去（例如，对于 `<head>` 使用 `<h:head>`，对于 `<input>` 使用 `<h:inputText>`）。JSF
    将这些组件添加到组件树中，并将它们作为 HTML 代码渲染到客户端。这个 JSF 组件将与特定元素关联，并接收作为“正常”属性或透传属性传递的属性，具体取决于它们的来源。JSF
    组件与 HTML 元素之间的对应关系可以在 [http://docs.oracle.com/javaee/7/api/javax/faces/view/facelets/TagDecorator.html](http://docs.oracle.com/javaee/7/api/javax/faces/view/facelets/TagDecorator.html)
    找到。对于没有直接对应元素的 HTML 元素（例如 `<div>` 和 `<span>`），JSF 将创建一个特殊的组件，组件家族，如 `javax.faces.Panel`，以及渲染类型
    `javax.faces.passthrough.Element`，具体请参阅 [http://docs.oracle.com/javaee/7/javaserverfaces/2.2/vdldocs/facelets/jsf/element.html](http://docs.oracle.com/javaee/7/javaserverfaces/2.2/vdldocs/facelets/jsf/element.html)。
- en: The complete example is available in the code bundle of this chapter and is
    named `ch8_1_3`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例可以在本章的代码包中找到，名称为 `ch8_1_3`。
- en: 'Since JSF replaces the HTML elements with JSF components, we can use these
    components at full capacity, meaning that we can use them as in JSF. For example,
    we can use validators, converters, and `<f:param>`, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JSF 用 JSF 组件替换了 HTML 元素，我们可以充分利用这些组件，这意味着我们可以像在 JSF 中一样使用它们。例如，我们可以使用验证器、转换器和
    `<f:param>`，如下所示：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The complete example is available in the code bundle of this chapter and is
    named `ch8_1_4`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例可在本章的代码包中找到，名称为 `ch8_1_4`。
- en: JSF 2.2 – HTML5 and Bean Validation 1.1 (Java EE 7)
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSF 2.2 – HTML5 和 Bean Validation 1.1（Java EE 7）
- en: 'The Bean Validation 1.1 (see [http://docs.oracle.com/javaee/7/tutorial/doc/partbeanvalidation.htm](http://docs.oracle.com/javaee/7/tutorial/doc/partbeanvalidation.htm))
    can be the perfect choice for validating user inputs in a JSF 2.2/HTML5 application.
    For example, we can validate the submitted name and surname in `PlayersBean`,
    as follows—we don''t accept null values, empty values, or values shorter than
    three characters:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Bean Validation 1.1（见 [http://docs.oracle.com/javaee/7/tutorial/doc/partbeanvalidation.htm](http://docs.oracle.com/javaee/7/tutorial/doc/partbeanvalidation.htm)）可以是
    JSF 2.2/HTML5 应用程序中验证用户输入的完美选择。例如，我们可以在 `PlayersBean` 中验证提交的名字和姓氏，如下所示——我们不接受空值、空值或小于三个字符的值：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'JSF can interpret empty string submitted values as `null` if you set the following
    context parameter in `web.xml`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将以下上下文参数在 `web.xml` 中设置，JSF 可以将提交的空字符串值解释为 `null`：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So in this case, there is no need to use the `<f:validator>` or `validator`
    attribute. Check out the complete application named `ch8_2`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这种情况下，没有必要使用 `<f:validator>` 或 `validator` 属性。查看完整的名为 `ch8_2` 的应用程序。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: OmniFaces provides an HTML5 render kit that extends support for HTML5 specific
    attributes. You may want to check it out at [http://showcase.omnifaces.org/](http://showcase.omnifaces.org/).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: OmniFaces 提供了一个扩展 HTML5 特定属性支持的 HTML5 渲染器。你可能想查看 [http://showcase.omnifaces.org/](http://showcase.omnifaces.org/)。
- en: JSF 2.2 upload feature
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSF 2.2 上传功能
- en: JSF developers have waited a long time for a built-in upload component. Until
    JSF 2.2, the workarounds consisted of using JSF extensions, such as PrimeFaces,
    RichFaces, and third-party libraries such as Apache Commons FileUpload.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 开发者已经期待了很长时间一个内置的上传组件。直到 JSF 2.2，解决方案包括使用 JSF 扩展，如 PrimeFaces、RichFaces
    和第三方库，如 Apache Commons FileUpload。
- en: 'JSF 2.2 comes with an input component dedicated for upload tasks (that renders
    an HTML `input` element of type `file`). This component is represented by the
    `<h:inputFile>` tag and it can be used as any other JSF component. The entire
    list of supported attributes is available at [http://docs.oracle.com/javaee/7/javaserverfaces/2.2/vdldocs/facelets/h/inputFile.html](http://docs.oracle.com/javaee/7/javaserverfaces/2.2/vdldocs/facelets/h/inputFile.html),
    but the most important ones are as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 2.2 包含一个专门用于上传任务的输入组件（它渲染一个类型为 `file` 的 HTML `input` 元素）。这个组件由 `<h:inputFile>`
    标签表示，它可以像任何其他 JSF 组件一样使用。支持的所有属性列表可在 [http://docs.oracle.com/javaee/7/javaserverfaces/2.2/vdldocs/facelets/h/inputFile.html](http://docs.oracle.com/javaee/7/javaserverfaces/2.2/vdldocs/facelets/h/inputFile.html)
    找到，但最重要的如下：
- en: '`value`: This represents the file to be uploaded as a `javax.servlet.http.Part`
    object.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`: 这代表要上传的文件，作为一个 `javax.servlet.http.Part` 对象。'
- en: '`required`: This is a Boolean value. If it is `true`, the user must provide
    a value to submit.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`required`: 这是一个布尔值。如果它是 `true`，则用户必须提供一个值才能提交。'
- en: '`validator`: This indicates a validator for this component.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validator`: 这表示该组件的验证器。'
- en: '`converter`: This indicates a converter for this component.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`converter`: 这表示该组件的转换器。'
- en: '`valueChangeListener`: This indicates a method that will be called when the
    component''s value is changed.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`valueChangeListener`: 这表示当组件的值改变时将被调用的方法。'
- en: 'The `<h:inputFile>` component is based on Servlet 3.0, which is part of Java
    EE since version 6\. Servlet 3.0 provides an upload mechanism based on the `javax.servlet.http.Part`
    interface and the `@MultipartConfig` annotation. A simple Servlet 3.0 for upload
    files looks like the following code—keep in mind this servlet because we will
    use it in the last section of this chapter:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`<h:inputFile>` 组件基于 Servlet 3.0，它是从 Java EE 6 版本开始成为 Java EE 的一部分。Servlet
    3.0 提供了一个基于 `javax.servlet.http.Part` 接口和 `@MultipartConfig` 注解的上传机制。一个简单的 Servlet
    3.0 上传文件代码如下——请记住这个 servlet，因为我们将在本章的最后部分使用它：'
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you take a quick look over the JSF 2.2 `FacesServlet` source code, you will
    notice that it was annotated with `@MultipartConfig` especially for handling multipart
    data.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你快速查看 JSF 2.2 `FacesServlet` 的源代码，你会注意到它被特别注解了 `@MultipartConfig`，以处理多部分数据。
- en: If you are not familiar with uploading files using Servlet 3.0, then you can
    try the tutorial at [http://docs.oracle.com/javaee/6/tutorial/doc/glrbb.html](http://docs.oracle.com/javaee/6/tutorial/doc/glrbb.html).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉使用Servlet 3.0上传文件，那么你可以尝试在[http://docs.oracle.com/javaee/6/tutorial/doc/glrbb.html](http://docs.oracle.com/javaee/6/tutorial/doc/glrbb.html)上的教程。
- en: 'On the client side, you can use a `<form>` tag and an HTML5 input of type `file`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，你可以使用`<form>`标签和HTML5的`file`类型输入：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Basically, JSF 2.2 upload component is just a wrapper of this example.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，JSF 2.2上传组件只是这个例子的包装。
- en: A simple JSF 2.2 upload example
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的JSF 2.2上传示例
- en: 'In this section, we will cover the fundamental steps of a JSF 2.2 upload application.
    Even if this is a simple example, you will see that further examples are based
    on this one. So in order to use the `<h:inputFile>` component, you need to focus
    on the client side and on the server side:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍JSF 2.2上传应用程序的基本步骤。即使这是一个简单的例子，你也会看到后续的例子都是基于这个例子。因此，为了使用`<h:inputFile>`组件，你需要关注客户端和服务器端：
- en: 'On the client side, we need to perform the following steps:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，我们需要执行以下步骤：
- en: 'First, the `<h:form>` encoding must be set to multipart/form-data, which will
    help the browser to build the `POST` request accordingly, as shown in the following
    code:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，`<h:form>`的编码必须设置为`multipart/form-data`，这将帮助浏览器相应地构建`POST`请求，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Second, the `<h:inputFile>` must be configured to respect your needs, Here,
    we provide a simple case, as follows:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二，`<h:inputFile>`必须配置为满足你的需求，在此，我们提供了一个简单的案例，如下所示：
- en: '[PRE14]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Further, you need a button (or a link) to start the upload process, as follows:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，你需要一个按钮（或链接）来启动上传过程，如下所示：
- en: '[PRE15]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Optionally, you can add some tags for handling upload messages, as shown in
    the following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，你可以添加一些标签来处理上传消息，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'On the server side, we need to perform the following steps:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，我们需要执行以下步骤：
- en: 'Usually, the `value` attribute of `<h:inputFile>` contains an EL expression
    of type `#{`*upload_bean.part_object*`}`. If you replace *upload_bean* with `uploadBean`
    and *part_object* with `file`, you will obtain `#{uploadBean.file}`. The `file`
    object is used to store the uploaded data as an instance of `javax.servlet.http.Part`
    in the `UploadBean` bean. All you have to do is to define the `file` property
    in the same manner as any other property, as shown in the following code:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，`<h:inputFile>`的`value`属性包含一个类型为`#{`*upload_bean.part_object*`}`的EL表达式。如果你将*upload_bean*替换为`uploadBean`，将*part_object*替换为`file`，你将获得`#{uploadBean.file}`。`file`对象用于在`UploadBean`
    bean中将上传的数据存储为`javax.servlet.http.Part`实例。你所要做的就是以与其他属性相同的方式定义`file`属性，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The uploaded data can be read through the `getInputStream` method of `Part`.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以通过`Part`的`getInputStream`方法读取上传的数据。
- en: 'When the button labeled **Upload** is clicked, the `upload` method is called.
    When this method is called, the `file` object is already populated with the uploaded
    bytes; therefore, you can obtain the data as a stream (use the `getInputStream`
    method) and process it accordingly. For example, you can use the `Scanner` API
    to extract the data into a `String`, as follows:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当点击标记为**上传**的按钮时，会调用`upload`方法。当这个方法被调用时，`file`对象已经填充了上传的字节；因此，你可以将数据作为流（使用`getInputStream`方法）获取并相应地处理它。例如，你可以使用`Scanner`
    API将数据提取到`String`中，如下所示：
- en: '[PRE18]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The complete application is available in the code bundle of this chapter and
    is named `ch8_3`. In this case, the uploaded data is converted into string and
    displayed in a log; therefore, try to upload readable information, such as plain
    text files.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序包含在本章的代码包中，命名为`ch8_3`。在这种情况下，上传的数据被转换为字符串并在日志中显示；因此，尝试上传可读的信息，如纯文本文件。
- en: Using multiple <h:inputFile> elements
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用多个`<h:inputFile>`元素
- en: 'If you ask yourself whether you can use more than one `<h:inputFile>` element
    in a `<h:form>` form, the answer is yes. Specify an ID for each `<h:inputFile>`
    element and associate it with a unique `Part` instance. In order to use two `<h:inputFile>`
    elements, the `<h:form>` form will change to the following code—you can easily
    extrapolate this example for three, four, or more `<h:inputFile>` elements:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你问自己是否可以在`<h:form>`表单中使用多个`<h:inputFile>`元素，答案是肯定的。为每个`<h:inputFile>`元素指定一个ID，并将其与一个唯一的`Part`实例关联。为了使用两个`<h:inputFile>`元素，`<h:form>`表单将变为以下代码——你可以轻松地扩展这个例子以适应三个、四个或更多的`<h:inputFile>`元素：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, on the server side, you need two `Part` instances, defined as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在服务器端，你需要两个`Part`实例，定义如下：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the `upload` method, you need to process both `Part` instances:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在`upload`方法中，你需要处理两个`Part`实例：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Done! The complete application is available in the code bundle of this chapter
    and is named `ch8_4`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！完整的应用程序包含在本章的代码包中，命名为`ch8_4`。
- en: Extracting info about a file to be uploaded
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取要上传的文件信息
- en: 'Filename, size, and content type are the most common types of information needed
    when uploading a file. In JSF, this information is available on both the client
    side and the server side. Let''s consider the following `<h:inputFile>` element:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名、大小和内容类型是在上传文件时最常见的信息类型。在JSF中，这些信息在客户端和服务器端都是可用的。让我们考虑以下`<h:inputFile>`元素：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now you will see how to extract the information about the file selected for
    upload.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你会看到如何提取上传选择的文件的信息。
- en: 'On the client side, we need to perform either of the following steps:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，我们需要执行以下步骤之一：
- en: 'Extracting the filename, size (in bytes), and the content type on the client
    side can be accomplished in a JavaScript function, as follows:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端，可以通过JavaScript函数提取文件名、大小（以字节为单位）和内容类型，如下所示：
- en: '[PRE23]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Another approach is to use EL in a JSF page, as follows (of course, this works
    after the file is uploaded):'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种方法是使用JSF页面中的EL，如下所示（当然，文件上传后这才会工作）：
- en: '[PRE24]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'On the server side, we need to perform either of the following steps:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，我们需要执行以下步骤之一：
- en: 'Extracting the filename, size (in bytes), and the content type on server side
    can be accomplished through several methods of the `Part` interface, as follows:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器端，可以通过`Part`接口的几个方法提取文件名、大小（以字节为单位）和内容类型，如下所示：
- en: '[PRE25]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the string returned by this method represents the entire path instead of
    the filename, then you have to isolate the filename as a substring of this string.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果这个方法返回的字符串代表整个路径而不是文件名，那么你必须将文件名作为这个字符串的子字符串来隔离。
- en: 'The filename can be obtained from the `content-disposition` header as well
    using the following code:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件名也可以通过以下代码从`content-disposition`头中获取：
- en: '[PRE26]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'An example of the `content-disposition` header can be seen in the following
    screenshot:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了`content-disposition`头的示例：
- en: '![Extracting info about a file to be uploaded](img/6466EN_08_01.jpg)'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![提取要上传的文件信息](img/6466EN_08_01.jpg)'
- en: This is very easy to understand if you inspect the `POST` request (you can do
    this with Firebug or any other specialized tool). In the preceding screenshot,
    you can see the relevant chunk of request that is depicted in the `getFileNameFromContentDisposition`
    method.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查`POST`请求（你可以使用Firebug或其他专用工具来做这件事），这将非常容易理解。在上面的截图中，你可以看到`getFileNameFromContentDisposition`方法中描述的相关请求片段。
- en: The complete application is available in the code bundle of this chapter and
    is named `ch8_5`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序包含在本章的代码包中，命名为`ch8_5`。
- en: Writing uploaded data to a disk
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将上传数据写入磁盘
- en: 'In the previous examples, the uploaded data was converted to `String` and displayed
    on a console. Normally, when you upload a file, you want to save its content on
    a disk in a specific location (let''s say, the `D:\files` folder). For this, you
    can use `FileOutputStream`, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，上传的数据被转换为`String`并在控制台上显示。通常，当你上传文件时，你希望将其内容保存到磁盘上的特定位置（比如说，`D:\files`文件夹）。为此，你可以使用`FileOutputStream`，如下所示：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want buffered I/O, then add `BufferedInputStream` and `BufferedOutputStream`
    into your code.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要缓冲I/O，那么在你的代码中添加`BufferedInputStream`和`BufferedOutputStream`。
- en: The complete application is available in the code bundle of this chapter and
    is named `ch8_6`. If you prefer to obtain the filename from the `content-disposition`
    header, you better check the application `ch8_7`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序包含在本章的代码包中，命名为`ch8_6`。如果你更喜欢从`content-disposition`头中获取文件名，那么最好检查应用程序`ch8_7`。
- en: 'Another approach consists of using the `Part.write` method. In this case, you
    have to indicate the location where the file should be saved through the `<multipart-config>`
    tag ([http://docs.oracle.com/javaee/7/tutorial/doc/servlets011.htm](http://docs.oracle.com/javaee/7/tutorial/doc/servlets011.htm)).
    Moreover, you can set the maximum file size, request size, and the file size threshold;
    these configurations should be added in `web.xml`, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是通过使用`Part.write`方法。在这种情况下，你必须通过`<multipart-config>`标签（[http://docs.oracle.com/javaee/7/tutorial/doc/servlets011.htm](http://docs.oracle.com/javaee/7/tutorial/doc/servlets011.htm)）指定文件应该保存的位置。此外，你可以设置最大文件大小、请求大小和文件大小阈值；这些配置应该添加到`web.xml`中，如下所示：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you don't specify a location, the default one will be used. The default location
    is "".
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有指定位置，将使用默认位置。默认位置是""。
- en: 'The uploaded file will be saved in the indicated location under the name passed
    to the `Part.write` method, as shown in the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 上传的文件将被保存在`Part.write`方法传递的名称下指定的位置，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The complete application is available in the code bundle of this chapter and
    is named `ch8_8`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序包含在本章的代码包中，并命名为`ch8_8`。
- en: Upload validator
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上传验证器
- en: 'In most cases, you need to restrict the user upload based on certain constraints.
    Commonly, you will limit the filename length, file size, and file content type.
    For example, you may want to reject the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你需要根据某些约束来限制用户上传。通常，你会限制文件名长度、文件大小和文件内容类型。例如，你可能想拒绝以下内容：
- en: Files that have names bigger than 25 characters
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件名超过25个字符的文件
- en: Files that are not PNG or JPG images
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不是PNG或JPG图像的文件
- en: Files that are bigger than 1 MB in size
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大于1 MB大小的文件
- en: 'For this, you can write a JSF validator, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个，你可以编写一个JSF验证器，如下所示：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, add the validator to the `<h:inputFile>` element, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将验证器添加到`<h:inputFile>`元素中，如下所示：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, only the files that meet our constraints will be uploaded. For each rejected
    file, you will see an info message that will signal if the filename or its size
    is too big, or whether the file is a PNG or JPG image.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只有符合我们约束条件的文件才会被上传。对于每个被拒绝的文件，你将看到一个信息消息，它会指示文件名或其大小是否过大，或者文件是否是PNG或JPG图像。
- en: The complete application is available in the code bundle of this chapter and
    is named `ch8_9`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序包含在本章的代码包中，并命名为`ch8_9`。
- en: Ajaxify the upload
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AJAX化上传
- en: 'A JSF upload can take advantages of the AJAX mechanism by combining the `<h:inputFile>`
    tag with `<f:ajax>` or the `<h:commandButton>` tag (upload initialization) with
    `<f:ajax>`. In the first case, a common ajaxified upload will look like the following
    code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: JSF上传可以通过结合`<h:inputFile>`标签与`<f:ajax>`或`<h:commandButton>`标签（上传初始化）与`<f:ajax>`来利用AJAX机制。在第一种情况下，一个常见的AJAX化上传将类似于以下代码：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The render attribute should contain the IDs of components to re-render after
    upload. In JSF 2.2.0, you need to use `@all` instead of IDs because there is a
    bug associated that was fixed in the later versions. For example, in JSF 2.2.5
    everything works as expected.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染属性应该包含上传后需要重新渲染的组件的ID。在JSF 2.2.0中，你需要使用`@all`而不是ID，因为后续版本中修复了一个相关的错误。例如，在JSF
    2.2.5中，一切如预期工作。
- en: The complete application is available in the code bundle of this chapter and
    is named `ch8_10`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序包含在本章的代码包中，并命名为`ch8_10`。
- en: 'In the second case, place `<f:ajax>` in `<h:commandButton>`, as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，将`<f:ajax>`放置在`<h:commandButton>`中，如下所示：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The complete application is available in the code bundle of this chapter and
    is named `ch8_11`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序包含在本章的代码包中，并命名为`ch8_11`。
- en: Uploading images with preview
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带预览上传图像
- en: 'A nice feature of the upload components is that they allow us to preview images
    before they are uploaded. In the following screenshot, you can see what we will
    develop next:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 上传组件的一个不错特性是它们允许我们在上传之前预览图像。在下面的屏幕截图中，你可以看到我们将要开发的内容：
- en: '![Uploading images with preview](img/6466EN_08_02.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![带预览上传图像](img/6466EN_08_02.jpg)'
- en: So when the user browses an image, you need to proceed with a behind the scene
    auto AJAX upload, which should cause the user to see the image preview immediately
    after he/she chooses the image from the local machine. The `POST` request generated
    by AJAX will populate the server-side `Part` object (let's call it `file`). When
    AJAX completes, you need to re-render a component capable of displaying an image,
    such as `<h:graphicImage>`. This component will call a servlet using a `GET` request.
    The managed bean responsible with upload should be session scoped; therefore,
    the servlet will be able to extract the bean instance from the session and use
    the `file` object representing the image. Now, the servlet can pass the image
    bytes directly to the response output stream, or create a thumbnail of the image
    and send a small number of bytes. Further, when the user clicks the button that
    initializes the upload, you need to write the file object on the disk.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当用户浏览图像时，你需要进行后台自动 AJAX 上传，这样用户在选择本地机器上的图像后可以立即看到图像预览。由 AJAX 生成的 `POST` 请求将填充服务器端的
    `Part` 对象（我们可以称之为 `file`）。当 AJAX 完成时，你需要重新渲染一个能够显示图像的组件，例如 `<h:graphicImage>`。该组件将使用
    `GET` 请求调用一个 servlet。负责上传的管理 Bean 应该是会话作用域的；因此，servlet 能够从会话中提取 Bean 实例并使用代表图像的
    `file` 对象。现在，servlet 可以直接将图像字节传递给响应输出流，或者创建图像的缩略图并发送少量字节。此外，当用户点击初始化上传的按钮时，你需要将文件对象写入磁盘。
- en: This is the main idea. Next, you will implement it and spice it up with some
    validation capabilities, a cancel button, and some image information displayed
    next to the preview.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是主要思想。接下来，你将实现它，并添加一些验证功能、一个取消按钮，以及一些显示在预览旁边的图像信息。
- en: 'In order to achieve this, you need to perform the following steps:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，你需要执行以下步骤：
- en: 'Write an auto upload based on AJAX, as follows:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据以下内容编写基于 AJAX 的自动上传：
- en: '[PRE34]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'AJAX will call the `validateFile` method. This server-side method is capable
    of validating the filename, length, size, and the content type. The `validateFile`
    method is defined as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AJAX 将调用 `validateFile` 方法。这个服务器端方法能够验证文件名、长度、大小和内容类型。`validateFile` 方法定义如下：
- en: '[PRE35]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If the constraints are violated, then the `resetFile` method is called. This
    is a simple method that resets the file object to its initial state. Moreover,
    it calls the `delete` method, which deletes the underlying storage for the file
    item (including temporary files on the disk).The `resetFile` method is defined
    as follows:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果违反了约束，则调用 `resetFile` 方法。这是一个简单的将文件对象重置到其初始状态的方法。此外，它调用 `delete` 方法，该方法删除文件项的底层存储（包括磁盘上的临时文件）。`resetFile`
    方法定义如下：
- en: '[PRE36]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When the AJAX request is complete, it will re-render the components with IDs:
    `previewImgId`, `imgNameId`, and `uploadMessagesId`. The following code reveals
    the components having the `previewImgId` and `imgNameId` IDs—here the `uploadMessagesId`
    ID corresponds to a `<h:messages>` component:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 AJAX 请求完成时，它将重新渲染具有以下 ID 的组件：`previewImgId`、`imgNameId` 和 `uploadMessagesId`。以下代码揭示了具有
    `previewImgId` 和 `imgNameId` ID 的组件——这里 `uploadMessagesId` ID 对应于一个 `<h:messages>`
    组件：
- en: '[PRE37]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The value of `<h:graphicImage>` accesses `PreviewServlet`. This servlet can
    serve the image for preview through the response output stream. In order to avoid
    the caching mechanism, you need to provide a URL with a random part (the request
    content length can be a convenient choice). This technique will load the correct
    image every time, instead of loading the same image for all requests. The relevant
    part of the servlet is as follows:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<h:graphicImage>` 的值访问 `PreviewServlet`。这个 servlet 可以通过响应输出流提供图像以供预览。为了避免缓存机制，你需要提供一个带有随机部分的
    URL（请求内容长度可能是一个方便的选择）。这种技术将每次都加载正确的图像，而不是为所有请求加载相同的图像。servlet 的相关部分如下：'
- en: '[PRE38]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The preceding code will send all bytes of the uploaded image to the response
    output stream. A common technique consists of scaling down the image to obtain
    a thumbnail that contains a smaller number of bytes. In Java, scaling an image
    can be accomplished in many ways, but a quick approach can be seen in the following
    code:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述代码将发送上传图像的所有字节到响应输出流。一种常见的技术是将图像缩小以获得包含较少字节的缩略图。在 Java 中，可以通过多种方式缩放图像，但以下代码提供了一个快速的方法：
- en: '[PRE39]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Further, you add two buttons: one button labeled **Upload** and another one
    labeled **Cancel**. The first one will initialize the upload, and the second one
    will cancel the upload, as shown in the following code:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，您还需要添加两个按钮：一个标有**上传**的按钮，另一个标有**取消**的按钮。第一个按钮将初始化上传，第二个按钮将取消上传，如下面的代码所示：
- en: '[PRE40]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When the button labeled **Upload** is clicked, the `saveFileToDisk` method
    will save the uploaded data to the disk, as shown in the following code:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当点击标有**上传**的按钮时，`saveFileToDisk`方法将保存上传的数据到磁盘，如下面的代码所示：
- en: '[PRE41]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Done! The complete application, without thumbnail, is available in the code
    bundle of this chapter and is named `ch8_13`. The complete application, with thumbnail,
    is named `ch8_12`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！完整的应用程序（无缩略图），可在本章的代码包中找到，命名为`ch8_13`。带有缩略图的完整应用程序命名为`ch8_12`。
- en: 'The validation process can be eliminated from the server side and can be accomplished
    on the client side also. Such an example can be found in the code bundle of this
    chapter and is named `ch8_14`. The JavaScript code is pretty straightforward,
    as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 验证过程可以从服务器端消除，也可以在客户端完成。这样的例子可以在本章的代码包中找到，命名为`ch8_14`。JavaScript代码相当简单，如下所示：
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Uploading multiple files
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上传多个文件
- en: 'By default, JSF 2.2 does not provide support for uploading multiple files,
    but with some adjustments, we can easily achieve this goal. In order to have multiple
    file uploads, you need to focus on two aspects, which are listed as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，JSF 2.2不提供上传多个文件的支持，但通过一些调整，我们可以轻松实现这个目标。为了实现多文件上传，您需要关注两个方面，如下列所示：
- en: Making multiple file selections possible
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使多文件选择成为可能
- en: Uploading all the selected files
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上传所有选定的文件
- en: 'Regarding the first task, the multiple selection can be activated using an
    HTML5 input file attribute (`multiple`) and the JSF 2.2 pass-through attribute
    feature. When this attribute is present and its value is set to `multiple`, the
    file chooser can select multiple files. So, this task requires some minimal adjustments:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 关于第一个任务，可以通过使用HTML5输入文件属性（`multiple`）和JSF 2.2的透传属性功能来激活多重选择。当此属性存在且其值设置为`multiple`时，文件选择器可以选择多个文件。因此，这个任务需要一些最小的调整：
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The second task is a little bit tricky, because when multiple files are selected,
    JSF will overwrite the previous `Part` instance with each file in the uploaded
    set. This is normal, since you use an object of type `Part`, but you need a collection
    of `Part` instances. Fixing this issue requires us to focus on the renderer of
    the file component. This renderer is named `FileRenderer` (an extension of `TextRenderer`),
    and the `decode` method implementation is the key for our issue (the bold code
    is very important for us), as shown in the following code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个任务有点棘手，因为当选择多个文件时，JSF会使用上传集中的每个文件覆盖先前的`Part`实例。这是正常的，因为您使用的是`Part`类型的对象，但您需要一个`Part`实例的集合。解决这个问题需要我们关注文件组件的渲染器。这个渲染器被命名为`FileRenderer`（`TextRenderer`的扩展），而`decode`方法的实现是我们问题的关键（粗体代码对我们非常重要），如下面的代码所示：
- en: '[PRE44]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The highlighted code causes the override `Part` issue, but you can easily modify
    it to submit a list of `Part` instances instead of one `Part`, as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的代码会导致覆盖`Part`问题，但您可以轻松地修改它，以提交一个`Part`实例的列表而不是一个`Part`实例，如下所示：
- en: '[PRE45]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Of course, in order to modify this code, you need to create a custom file renderer
    and configure it properly in `faces-config.xml`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，为了修改此代码，您需要创建一个自定义文件渲染器，并在`faces-config.xml`中正确配置它。
- en: 'Afterwards, you can define a list of `Part` instances in your bean using the
    following code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您可以使用以下代码在您的bean中定义一个`Part`实例的列表：
- en: '[PRE46]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Each entry in the list is a file; therefore, you can write them on the disk
    by iterating the list using the following code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的每个条目都是一个文件；因此，您可以通过以下代码迭代列表来将它们写入磁盘：
- en: '[PRE47]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The complete application is available in the code bundle of this chapter and
    is named `ch8_15`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序可在本章的代码包中找到，命名为`ch8_15`。
- en: Upload and the indeterminate progress bar
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上传和不确定的进度条
- en: When users upload small files, the process happens pretty fast; however, when
    large files are involved, it may take several seconds, or even minutes, to end.
    In this case, it is a good practice to implement a progress bar that indicates
    the upload status. The simplest progress bar is known as an indeterminate progress
    bar, because it shows that the process is running, but it doesn't provide information
    for estimating the time left or the amount of processed bytes.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户上传小文件时，这个过程发生得相当快；然而，当涉及到大文件时，可能需要几秒钟，甚至几分钟才能完成。在这种情况下，实现一个指示上传状态的进度条是一个好习惯。最简单的进度条被称为不确定进度条，因为它表明过程正在运行，但它不提供估计剩余时间或已处理字节数的信息。
- en: 'In order to implement a progress bar, you need to develop an AJAX-based upload.
    The JSF AJAX mechanism allows us to determine when the AJAX request begins and
    when it completes. This can be achieved on the client side; therefore, an indeterminate
    progress bar can be easily implemented using the following code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现进度条，您需要开发一个基于AJAX的上传。JSF AJAX机制允许我们确定AJAX请求何时开始和何时完成。这可以在客户端实现；因此，可以使用以下代码轻松实现不确定进度条：
- en: '[PRE48]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'A possible output is as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的输出如下：
- en: '![Upload and the indeterminate progress bar](img/6466EN_08_03.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![上传和不确定进度条](img/6466EN_08_03.jpg)'
- en: The complete application is available in the code bundle of this chapter and
    is named `ch8_16`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序包含在本章的代码包中，命名为`ch8_16`。
- en: Upload and the determinate progress bar
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上传和确定进度条
- en: A determinate progress bar is much more complicated. Usually, such a progress
    bar is based on a listener capable to monitor the transferred bytes (if you have
    worked with Apache Commons' `FileUpload`, you must have had the chance to implement
    such a listener). In JSF 2.2, `FacesServlet` was annotated with `@MultipartConfig`
    for dealing multipart data (upload files), but there is no progress listener interface
    for it. Moreover, `FacesServlet` is declared `final`; therefore, we cannot extend
    it.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 确定进度条要复杂得多。通常，这样的进度条基于一个能够监控传输字节的监听器（如果您使用过Apache Commons的`FileUpload`，您肯定有机会实现这样的监听器）。在JSF
    2.2中，`FacesServlet`被注解为`@MultipartConfig`以处理多部分数据（上传文件），但它没有进度监听器接口。此外，`FacesServlet`被声明为`final`；因此，我们无法扩展它。
- en: Well, the possible approaches are pretty limited by these aspects. In order
    to implement a server-side progress bar, we need to implement the upload component
    in a separate class (servlet) and provide a listener. Alternatively, on the client
    side, we need a custom `POST` request that tricks `FacesServlet` that the request
    is formatted by `jsf.js`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，可能的解决方案受到这些方面的限制。为了在服务器端实现进度条，我们需要在单独的类（servlet）中实现上传组件并提供一个监听器。或者，在客户端，我们需要一个自定义的`POST`请求来欺骗`FacesServlet`，使其认为请求是通过`jsf.js`格式化的。
- en: In this section, you will see a workaround based on HTML5 XMLHttpRequest Level
    2 (can upload/download streams as `Blob`, `File`, and `FormData`), HTML5 progress
    events (for upload it returns total transferred bytes and uploaded bytes), HTML5
    progress bar, and a custom Servlet 3.0\. If you are not familiar with these HTML5
    features, then you have to check out some dedicated documentation.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将看到基于HTML5 XMLHttpRequest Level 2（可以上传/下载`Blob`、`File`和`FormData`流）的解决方案，HTML5进度事件（对于上传，它返回已传输的总字节数和已上传的字节数），HTML5进度条，以及自定义Servlet
    3.0。如果您不熟悉这些HTML5特性，那么您必须查阅一些专门的文档。
- en: 'After you get familiar with these HTML5 features, it will be very easy to understand
    the following client-side code. First we have the following JavaScript code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在熟悉了这些HTML5特性之后，理解以下客户端代码将会非常容易。首先，我们有以下JavaScript代码：
- en: '[PRE49]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Further, we have the upload component that uses the preceding JavaScript code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还有使用前面JavaScript代码的上传组件：
- en: '[PRE50]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'A possible output can be seen in the following screenshot:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了可能的输出：
- en: '![Upload and the determinate progress bar](img/6466EN_08_04.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![上传和确定进度条](img/6466EN_08_04.jpg)'
- en: The servlet behind this solution is `UploadServlet` that was presented earlier.
    The complete application is available in the code bundle of this chapter and is
    named `ch8_17`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此解决方案背后的servlet是之前提到的`UploadServlet`。完整的应用程序包含在本章的代码包中，命名为`ch8_17`。
- en: Note
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For multiple file uploads and progress bars, you can extend this example, or
    choose a built-in solution, such as PrimeFaces Upload, RichFaces Upload, or jQuery
    Upload Plugin.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多个文件上传和进度条，您可以扩展此示例，或者选择内置解决方案，例如PrimeFaces Upload、RichFaces Upload或jQuery
    Upload插件。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you saw how to exploit HTML5 through JSF 2.2 using the pass-through
    attribute and the pass-through elements techniques. Moreover, in the second part
    of this chapter, you saw how to work with the new JSF 2.2 upload component (simple
    upload, multiple file uploads, upload images with preview, and indeterminate/determinate
    progress bars for upload).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了如何通过JSF 2.2使用pass-through属性和pass-through元素技术来利用HTML5。此外，在本章的第二部分，您还看到了如何使用新的JSF
    2.2上传组件（简单上传、多文件上传、上传带预览的图片以及上传的不可确定/确定进度条）。
- en: See you in the next chapter, where we will go further with a great feature of
    JSF 2.2, that is, stateless views.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎您在下一章中继续学习，我们将进一步探讨JSF 2.2的一个伟大特性，即无状态视图。
