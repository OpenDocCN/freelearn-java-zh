- en: Hibernate Performance Tuning and Caching
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hibernate性能调优和缓存
- en: In the previous chapter, we learned how to access a database in our application
    using JDBC. We learned how to optimally design our database, transaction management,
    and connection pooling, to get the best performance from our application. We also
    learned how to prevent SQL injection by using a prepared statement in JDBC. We
    saw how we can remove traditional boilerplate code for managing transactions,
    exceptions, and commits by using JDBC templates.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用JDBC在我们的应用程序中访问数据库。我们学习了如何优化设计我们的数据库、事务管理和连接池，以获得应用程序的最佳性能。我们还学习了如何通过使用JDBC中的准备语句来防止SQL注入。我们看到了如何通过使用JDBC模板来消除传统的管理事务、异常和提交的样板代码。
- en: In this chapter, we will move toward some advanced ways of accessing the database
    using **object-relational mapping** (**ORM**) frameworks, such as Hibernate. We
    will learn how we can improve database access in an optimal way by using ORM.
    With Spring Data, we can further remove the boilerplate code of implementing the
    **Data Access Object** (**DAO**) interface.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向一些高级的访问数据库的方式迈进，使用**对象关系映射**（**ORM**）框架，比如Hibernate。我们将学习如何通过使用ORM以最佳的方式改进数据库访问。通过Spring
    Data，我们可以进一步消除实现**数据访问对象**（**DAO**）接口的样板代码。
- en: 'The following are the topics we will go through in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将学习以下主题：
- en: Introduction to Spring Hibernate and Spring Data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Hibernate和Spring Data简介
- en: Spring Hibernate configuration
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Hibernate配置
- en: Common Hibernate traps
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的Hibernate陷阱
- en: Hibernate performance tuning
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hibernate性能调优
- en: Introduction to Spring Hibernate and Spring Data
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Hibernate和Spring Data简介
- en: 'As we saw in previous chapters, **Java Database Connectivity** (**JDBC**) exposes
    an API that hides the database vendor-specific communication. However, it suffers
    from the following limitations:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的章节中看到的，**Java数据库连接**（**JDBC**）暴露了一个API，隐藏了特定于数据库供应商的通信。然而，它存在以下限制：
- en: JDBC development is very much verbose, even for trivial tasks
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使对于琐碎的任务，JDBC开发也非常冗长
- en: JDBC batching requires a specific API and is not transparent
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDBC批处理需要特定的API，不是透明的
- en: JDBC does not provide built-in support for explicit locking and optimistic concurrency
    control
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDBC不提供内置支持显式锁定和乐观并发控制
- en: There is a need to handle transactions explicitly, with lots of duplicate code
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要显式处理事务，并且有很多重复的代码
- en: Joined queries require additional processing to transform the `ResultSet` into
    domain models, or **data transfer objects** (**DTO**)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接查询需要额外的处理来将`ResultSet`转换为领域模型，或者**数据传输对象**（**DTO**）
- en: Almost all limitations of JDBC are covered by ORM frameworks. ORM frameworks
    provide for object mapping, lazy loading, eager loading, managing resources, cascading,
    error handling, and other services at the data access layer. One of the ORM frameworks
    is Hibernate. **Spring Data** is a layer implemented by the Spring Framework to
    provide boilerplate code and ease the access to different kinds of persistence
    stores used in applications. Let's see an overview of Spring Hibernate and Spring
    Data in the following sections.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有JDBC的限制都被ORM框架所覆盖。ORM框架提供对象映射、延迟加载、急切加载、资源管理、级联、错误处理和其他数据访问层的服务。其中一个ORM框架是Hibernate。**Spring
    Data**是由Spring框架实现的一层，用于提供样板代码并简化应用程序中使用的不同类型的持久性存储的访问。让我们在接下来的章节中看一下Spring Hibernate和Spring
    Data的概述。
- en: Spring Hibernate
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Hibernate
- en: Hibernate evolved from the frustration of EJB's complexities and performance
    issues. Hibernate provided a way to abstract SQL and allowed developers to focus
    on persisting objects. Hibernate, as an ORM framework, helps to map objects to
    tables in relational databases. Hibernate had its own standards when introduced,
    and code became tightly coupled with its standard implementation. So, to make
    persistence generic and vendors agnostic, **Java Community Process** (**JCP**)
    developed a standardized API specification, known as the **Java Persistence API**
    (**JPA**). All ORM frameworks started following this standard, and so does Hibernate.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate起源于EJB的复杂性和性能问题。Hibernate提供了一种抽象SQL的方式，并允许开发人员专注于持久化对象。作为ORM框架，Hibernate帮助将对象映射到关系数据库中的表。Hibernate在引入时有自己的标准，代码与其标准实现紧密耦合。因此，为了使持久性通用化并且与供应商无关，**Java社区进程**（**JCP**）制定了一个名为**Java持久化API**（**JPA**）的标准化API规范。所有ORM框架都开始遵循这一标准，Hibernate也是如此。
- en: Spring doesn't implement its own ORM; however, it supports any ORM framework,
    such as Hibernate, iBatis, JDO, and so on. With the ORM solution, we can easily
    persist and access data in the form of **Plain Old Java Object** (**POJO**) objects
    from relational databases. The Spring ORM module is an extension of the Spring
    JDBC DAO module. Spring also provides ORM templates, such as the JDBC-based templates
    we saw in [Chapter 5](a133d0e3-ad9e-49c9-aa2d-df9703b4e84a.xhtml), *Understanding
    Spring Database Interactions*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Spring并没有实现自己的ORM；但是，它支持任何ORM框架，比如Hibernate、iBatis、JDO等。通过ORM解决方案，我们可以轻松地将数据持久化并以**普通的Java对象**（**POJO**）的形式从关系数据库中访问。Spring的ORM模块是Spring
    JDBC DAO模块的扩展。Spring还提供了ORM模板，比如我们在[第5章](a133d0e3-ad9e-49c9-aa2d-df9703b4e84a.xhtml)中看到的基于JDBC的模板，*理解Spring数据库交互*。
- en: Spring Data
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Data
- en: As we know, in the last couple of years, unstructured and non-relational databases
    (known as NoSQL) have become popular. With the Spring JPA, talking to relational
    databases became easy; so, how can we talk to non-relational databases? Spring
    developed a module called Spring Data to provide a common approach to talk to
    a wide variety of data stores.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，在过去几年中，非结构化和非关系型数据库（称为NoSQL）变得流行。通过Spring JPA，与关系数据库交流变得容易；那么，我们如何与非关系型数据库交流？Spring开发了一个名为Spring
    Data的模块，以提供一种通用的方法来与各种数据存储进行交流。
- en: As each persistence store has different ways to connect and retrieve/update
    data, Spring Data provides a common approach to accessing data from each different
    store.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每种持久性存储都有不同的连接和检索/更新数据的方式，Spring Data提供了一种通用的方法来从每个不同的存储中访问数据。
- en: 'The following are the features of Spring Data:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data的特点如下：
- en: Easy integration with multiple data stores, through various repositories. Spring
    Data provides generic interfaces for each data store in the form of repositories.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过各种存储库轻松集成多个数据存储。Spring Data为每个数据存储提供了通用接口，以存储库的形式。
- en: The ability to parse and form queries based on repository method names provided
    the convention is followed. This reduces the amount of code to be written to fetch
    data.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据存储库方法名称提供的约定解析和形成查询的能力。这减少了需要编写的代码量来获取数据。
- en: Basic auditing support, such as created by and updated by a user.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的审计支持，例如由用户创建和更新。
- en: Fully integrated with the Spring core module.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Spring核心模块完全集成。
- en: Integrated with the Spring MVC to expose **REpresentational State Transfer**
    (**REST**) controllers through the Spring Data REST module.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Spring MVC集成，通过Spring Data REST模块公开**REpresentational State Transfer** (**REST**)控制器。
- en: 'The following is a small sample of the Spring Data repository. We don''t need
    to implement this method to write a query and fetch an account by ID; it will
    be done by Spring Data internally:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Spring Data存储库的一个小示例。我们不需要实现此方法来编写查询并按ID获取帐户；Spring Data将在内部完成：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Spring Hibernate configuration
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Hibernate配置
- en: We know that Hibernate is a persistence framework that provides relationship
    mapping between objects and database tables and that it has rich features to improve
    performance and the optimal use of resources such as caching, eager and lazy loading,
    event listeners, and so on.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道Hibernate是一个持久性框架，它提供了对象和数据库表之间的关系映射，并且具有丰富的功能来提高性能和资源的最佳使用，如缓存、急切和延迟加载、事件监听器等。
- en: The Spring Framework provides full support to integrate many persistence ORM
    frameworks, and so does Hibernate. Here, we will see Spring with JPA, using Hibernate
    as a persistence provider. Also, we will see Spring Data with the JPA repository
    using Hibernate.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架提供了完整的支持，以集成许多持久性ORM框架，Hibernate也是如此。在这里，我们将看到Spring与JPA，使用Hibernate作为持久性提供程序。此外，我们将看到Spring
    Data与使用Hibernate的JPA存储库。
- en: Spring with JPA using Hibernate
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Hibernate的Spring与JPA
- en: As we know, JPA is not an implementation; it is the specification for persistence.
    The Hibernate framework follows all of the specifications, and it also has its
    own additional features. Using the JPA specification in an application enables
    us to easily switch the persistence provider later if needed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，JPA不是一个实现；它是持久性的规范。Hibernate框架遵循所有规范，并且还具有其自己的附加功能。在应用程序中使用JPA规范使我们可以在需要时轻松切换持久性提供程序。
- en: 'To use Hibernate on its own requires `SessionFactory`, and to use Hibernate
    with JPA requires `EntityManager`. We are going to use JPA, and the following
    is the Spring Java-based Hibernate JPA configuration:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要单独使用Hibernate需要`SessionFactory`，要使用Hibernate与JPA需要`EntityManager`。我们将使用JPA，以下是基于Spring的Hibernate
    JPA配置：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding configuration, we configured `EntityManager` using the `LocalContainerEntityManagerFactoryBean`
    class. We set `DataSource` to provide information on where to find our database.
    As we are using JPA, which is the specification followed by a different vendor,
    we specified which vendor we are using in our application by setting `HibernateJpaVendorAdapter`
    and setting vendor-specific additional properties.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配置中，我们使用`LocalContainerEntityManagerFactoryBean`类配置了`EntityManager`。我们设置了`DataSource`来提供数据库的位置信息。由于我们使用的是JPA，这是一个由不同供应商遵循的规范，我们通过设置`HibernateJpaVendorAdapter`和设置特定供应商的附加属性来指定我们在应用程序中使用的供应商。
- en: Now that we have configured the JPA-based ORM framework in our application,
    let's see how to create a DAO in our application when using ORM.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经在应用程序中配置了基于JPA的ORM框架，让我们看看在使用ORM时如何在应用程序中创建DAO。
- en: 'The following is the `AbstractJpaDAO` class, having the basic common method
    required for all of our DAOs:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`AbstractJpaDAO`类，具有所有DAO所需的基本公共方法：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following is the `AccountDAO` class, which manages the `Account` entity-related
    method:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`AccountDAO`类，管理与`Account`实体相关的方法：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding examples of DAO implementation are pretty basic, and is what
    we generally do in our applications. In case DAO throws an exception such as `PersistenceException`,
    and instead of showing an exception to the user, we would want to show the right,
    human-readable message to the end users. To provide a readable message when an
    exception occurs, Spring provides a translator which we need to define in our
    configuration class as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的DAO实现示例非常基本，这通常是我们在应用程序中做的。如果DAO抛出诸如`PersistenceException`之类的异常，而不是向用户显示异常，我们希望向最终用户显示正确的可读消息。为了在发生异常时提供可读的消息，Spring提供了一个翻译器，我们需要在我们的配置类中定义如下：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `BeanPostProcessor` command works when we annotate our DAOs with the `@Repository`
    annotation. The `PersistenceExceptionTranslationPostProcessor` bean will act as
    an advisor for the beans, which are annotated with the `@Repository` annotation.
    Remember that we learned about advises in [Chapter 3](6ad6974a-b108-4e80-b13c-cbc5916d1969.xhtml),
    *Tuning Aspect-Oriented Programming*. When advised, it will re-throw Spring-specific
    unchecked data access exceptions caught in the code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用`@Repository`注解我们的DAO时，`BeanPostProcessor`命令会起作用。`PersistenceExceptionTranslationPostProcessor`
    bean将作为对使用`@Repository`注解的bean的顾问。请记住，我们在[第3章](6ad6974a-b108-4e80-b13c-cbc5916d1969.xhtml)中学习了关于建议的内容，*调整面向方面的编程*。在受到建议时，它将重新抛出在代码中捕获的Spring特定的未检查数据访问异常。
- en: So, this was the basic configuration of Spring JPA using Hibernate. Now, let's
    see the Spring Data configuration.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是使用Hibernate的Spring JPA的基本配置。现在，让我们看看Spring Data配置。
- en: Spring Data configuration
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Data配置
- en: 'As we learned in the introduction, Spring Data provides a common approach to
    connect different data stores. Spring Data provides basic abstraction through
    the `Repository` interface. The `Repository` interface is the core interface of
    Spring Data. Basic repositories provided by Spring Data are as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在介绍中学到的，Spring Data 提供了连接不同数据存储的通用方法。Spring Data 通过 `Repository` 接口提供基本的抽象。Spring
    Data 提供的基本存储库如下：
- en: '`CrudRepository` provides basic CRUD operations'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CrudRepository` 提供基本的 CRUD 操作'
- en: '`PagingAndSortingRepository` provides methods to do the pagination and sorting
    of records'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PagingAndSortingRepository` 提供了对记录进行分页和排序的方法'
- en: '`JpaRepository` provides JPA-related methods, such as flush and insert/update/delete
    in a batch, and so on'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JpaRepository` 提供了与 JPA 相关的方法，如批量刷新和插入/更新/删除等'
- en: '`Repository`, in Spring Data, eliminates the implementation of DAOs and templates
    such as `HibernateTemplate` or `JdbcTemplate`. Spring Data is so abstract that
    we don''t even need to write any method implementation for basic CRUD operations;
    we just need to define interfaces based on `Repository` and define proper naming
    conventions for methods. Spring Data will take care of creating a query based
    on a method name, and execute it to a database.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spring Data 中，`Repository` 消除了 DAO 和模板的实现，如 `HibernateTemplate` 或 `JdbcTemplate`。Spring
    Data 是如此抽象，以至于我们甚至不需要为基本的 CRUD 操作编写任何方法实现；我们只需要基于 `Repository` 定义接口，并为方法定义适当的命名约定。Spring
    Data 将负责根据方法名创建查询，并将其执行到数据库中。
- en: 'The Java configuration for Spring Data remains the same as what we saw for
    the Spring JPA, using Hibernate, except for the addition of defining repositories.
    The following is a snippet of declaring repositories to the configuration:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data 的 Java 配置与我们在使用 Hibernate 的 Spring JPA 中看到的相同，只是添加了定义存储库。以下是声明存储库到配置的片段：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this chapter, we are not going to dive too deeply into Hibernate and Spring
    Data-specific development. However, we will dive into the problems faced when
    not using Hibernate or JPA optimally and with the right configuration in our application,
    and solutions to the problems, with the best practices to achieve high performance.
    Let's look at the common Hibernate problems we face when using it in our applications.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不会深入探讨 Hibernate 和 Spring Data 特定的开发。但是，我们将深入探讨在我们的应用程序中不适当使用 Hibernate
    或 JPA 以及正确配置时所面临的问题，并提供解决问题的解决方案，以及实现高性能的最佳实践。让我们看看在我们的应用程序中使用 Hibernate 时常见的问题。
- en: Common Hibernate traps
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的 Hibernate 陷阱
- en: The JPA and Hibernate ORM are the most popular frameworks used in most Java
    applications to interact with a relational database. Their popularity increased
    because they use the mapping between the object-oriented domain and underlying
    relational database to abstract the database interactions and make it very easy
    to implement simple CRUD operations.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: JPA 和 Hibernate ORM 是大多数 Java 应用中使用的最流行的框架，用于与关系数据库交互。它们的流行度增加是因为它们使用面向对象域和底层关系数据库之间的映射来抽象数据库交互，并且非常容易实现简单的
    CRUD 操作。
- en: Under this abstraction, Hibernate uses a lot of optimizations and hides all
    database interactions behind its API. Oftentimes, don't even know when Hibernate
    will execute an SQL statement. Because of this abstraction, it becomes hard to
    find inefficiencies and potential performance problems. Let's see the common Hibernate
    problems that we face in our applications.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种抽象下，Hibernate 使用了许多优化，并将所有数据库交互隐藏在其 API 后面。通常情况下，我们甚至不知道 Hibernate 何时会执行
    SQL 语句。由于这种抽象，很难找到低效和潜在性能问题。让我们看看我们应用中常见的 Hibernate 问题。
- en: Hibernate n + 1 problem
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hibernate n + 1 问题
- en: When using JPA and Hibernate, the fetch type adds a good amount of impact to
    an application's performance. We should always fetch as much data as we need to
    fulfill a given business requirement. To do so, we set the associated entities `FetchType` as
    `LAZY`. When we set these associated entities fetch type as `LAZY`*,* we implement
    a nested select in our applications, because we are not aware how these associations
    are fetched under the abstraction provided by ORM frameworks. Nested selects are
    nothing but two queries, where one is the outer, or main, query (which fetches
    the result from a table) and the other is executed for each row as a result of
    the main query (to fetch the corresponding or related data from other table/s).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 JPA 和 Hibernate 时，获取类型对应用程序的性能产生了很大影响。我们应该始终获取我们需要满足给定业务需求的数据。为此，我们将关联实体的
    `FetchType` 设置为 `LAZY`。当我们将这些关联实体的获取类型设置为 `LAZY` 时，我们在我们的应用程序中实现了嵌套查询，因为我们不知道在
    ORM 框架提供的抽象下这些关联是如何获取的。嵌套查询只是两个查询，其中一个是外部或主查询（从表中获取结果），另一个是针对主查询的每一行结果执行的（从其他表中获取相应或相关数据）。
- en: 'The following example shows how we unintentionally implement something that
    does nested select:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了我们无意中实现了嵌套查询的情况：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Mostly, a developer tends to write code like the preceding example, and won't
    realize how an ORM framework like Hibernate could be fetching data internally.
    Here, ORM frameworks like Hibernate execute one query to get the `account`, and
    a second query to get transactions for that `account`. Two queries are fine, and
    won't impact the performance much. These two queries are for one association in
    an entity.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，开发人员倾向于编写像前面的示例一样的代码，并且不会意识到像 Hibernate 这样的 ORM 框架可能在内部获取数据。在这里，像 Hibernate
    这样的 ORM 框架执行一个查询来获取 `account`，并执行第二个查询来获取该 `account` 的交易。两个查询是可以接受的，并且不会对性能产生太大影响。这两个查询是针对实体中的一个关联。
- en: 'Let''s suppose that we have five associations in the `Account` entity: `Transactions`,
    `UserProfile`, `Payee`, and so on. When we try to fetch each association from
    the `Account` entity, the framework executes one query for each association, resulting
    in 1 + 5 = 6 queries. Six queries won''t impact much, right? These queries are
    for one user, so what if the number of concurrent users of our application is
    100? Then we will have 100 * (1 + 5) = 600 queries. Now, that is something that
    would impact the performance. This 1 + 5 queries while fetching `Account` is called
    the **n + 1** problem in Hibernate. We will see some approaches to avoiding this
    problem in the *Hibernate performance tuning* section of this chapter.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在`Account`实体中有五个关联：`Transactions`，`UserProfile`，`Payee`等等。当我们尝试从`Account`实体中获取每个关联时，框架会为每个关联执行一个查询，导致1
    + 5 = 6个查询。六个查询不会有太大影响，对吧？这些查询是针对一个用户的，那么如果我们的应用程序的并发用户数量是100呢？那么我们将有100 * (1
    + 5) = 600个查询。现在，这将对性能产生影响。在获取`Account`时的这1 + 5个查询被称为Hibernate中的**n + 1**问题。在本章的*Hibernate性能调优*部分，我们将看到一些避免这个问题的方法。
- en: The open session in view anti-pattern
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在视图中打开会话的反模式
- en: We saw in the preceding section that in order to defer fetching until the associated
    entity is needed, we set the fetch type of the associated entities as `LAZY`.
    When we try to access these associated entities in our presentation layer (if
    they are not initialized in our business (service) layer), an exception is thrown
    by Hibernate, called `LazyInitializationException`. When the service layer method
    completes its execution, Hibernate commits the transaction and closes the session.
    So, by the time the view is rendered, the active session is not available to fetch
    the associated entities.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的部分中看到，为了推迟获取直到需要关联实体时，我们将关联实体的获取类型设置为`LAZY`。当我们在呈现层尝试访问这些关联实体时（如果它们在我们的业务（服务）层中没有被初始化），Hibernate会抛出一个异常，称为`LazyInitializationException`。当服务层方法完成执行时，Hibernate提交事务并关闭会话。因此，在呈现视图时，活动会话不可用于获取关联实体。
- en: To avoid `LazyInitializationException`, one of the solutions is an open session
    in view. This means that we keep the Hibernate session open in view so that the
    presentation layer can fetch the required associated entities, and then close
    the session.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免`LazyInitializationException`，其中一个解决方案是在视图中保持一个开放的会话。这意味着我们在视图中保持Hibernate会话处于打开状态，以便呈现层可以获取所需的关联实体，然后关闭会话。
- en: 'In order to enable this solution, we need to add a web filter to our application.
    If we are using Hibernate on its own, we need to add `filter`, `OpenSessionInViewFilter`;
    if we are using JPA, then we need to add `filter` `OpenEntityManagerInViewFilter`.
    As we are using JPA with Hibernate in this chapter, the following is the snippet
    to add `filter`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用这个解决方案，我们需要向我们的应用程序添加一个web过滤器。如果我们只使用Hibernate，我们需要添加`filter`，`OpenSessionInViewFilter`；如果我们使用JPA，那么我们需要添加`filter`
    `OpenEntityManagerInViewFilter`。由于在本章中我们使用的是JPA与Hibernate，以下是添加`filter`的片段：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The solution provided by the **Open Session in View **(**OSIV**) pattern to
    avoid the exception might not look terrible at first glance; however, there are
    problems with using the OSIV solution. Let''s go over some issues with the OSIV
    solution:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放会话在视图**（**OSIV**）模式提供的解决方案乍看起来可能不那么糟糕；然而，使用OSIV解决方案存在一些问题。让我们来看看OSIV解决方案的一些问题：'
- en: The service layer opens the transaction when its method is invoked and closes
    it when the method execution completes. Afterward, there is no explicit open transaction.
    Every additional query executed from the view layer will be executed in auto-commit
    mode. Auto-commit mode could be dangerous from a security and database point of
    view. Due to the auto-commit mode, the database needs to flush all of the transaction
    logs to disk immediately, causing high I/O operations.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务层在其方法被调用时打开事务，并在方法执行完成时关闭它。之后，就没有显式的打开事务了。从视图层执行的每个额外查询都将在自动提交模式下执行。自动提交模式在安全和数据库方面可能是危险的。由于自动提交模式，数据库需要立即将所有事务日志刷新到磁盘，导致高I/O操作。
- en: It will violate the single responsibility of SOLID principles, or separation
    of concern because database statements are executed by both the service layer
    and the presentation layer.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将违反SOLID原则中的单一责任，或者关注点分离，因为数据库语句由服务层和呈现层都执行。
- en: 'It will lead to the n + 1 problem that we saw in the preceding *Hibernate n
    + 1 problem* section, though Hibernate offers some solutions that can cope with
    this scenario: `@BatchSize` and `FetchMode.SUBSELECT`, however, would apply to
    all of the business requirements, whether we want to or not.'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将导致我们在前面*Hibernate n + 1问题*部分看到的n + 1问题，尽管Hibernate提供了一些解决方案来应对这种情况：`@BatchSize`和`FetchMode.SUBSELECT`，但是，这些解决方案将适用于所有的业务需求，不管我们是否想要。
- en: The database connection is held until the presentation layer completes rendering.
    This increases the overall database connection time and impacts transaction throughput.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库连接保持到呈现层完成渲染。这会增加整体数据库连接时间并影响事务吞吐量。
- en: If an exception occurs in the fetching session or executing queries in the database,
    it will occur while rendering the view, so it will not be feasible to render a
    clean error page to the user.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在获取会话或在数据库中执行查询时发生异常，它将发生在呈现视图时，因此不可行地向用户呈现一个干净的错误页面。
- en: Unknown Id.generator exception
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未知的Id.generator异常
- en: Most of the time, we will want to use database sequencing for our table primary
    key. In order to do so, we know that we need to add the `generator` attribute
    in the `@GeneratedValue` annotation on our entity. The `@GeneratedValue` annotation
    allows us to define a strategy for our primary key.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，我们希望为我们的表主键使用数据库序列。为了做到这一点，我们知道我们需要在我们的实体上的`@GeneratedValue`注解中添加`generator`属性。`@GeneratedValue`注解允许我们为我们的主键定义一个策略。
- en: 'The following is the code snippet that we add in our entity to set database
    sequencing for our primary key:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们在实体中添加的代码片段，用于为我们的主键设置数据库序列：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we thought that `accountSequence` was the database sequence name provided
    to the `generator`; however, when the application runs, it gives an exception.
    To solve this exception, we annotate our entity with `@SequenceGenerator` and
    give the name as `accountSequence`, and the database sequence name that Hibernate
    needs to use. The following shows how to set the `@SequenceGenerator` annotation:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们认为`accountSequence`是提供给`generator`的数据库序列名称；然而，当应用程序运行时，它会产生异常。为了解决这个异常，我们使用`@SequenceGenerator`注解我们的实体，并给出名称为`accountSequence`，以及Hibernate需要使用的数据库序列名称。以下是如何设置`@SequenceGenerator`注解的示例：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We saw common problems faced during implementation. Now, let's see how to tune
    Hibernate to achieve high performance.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了在实现过程中遇到的常见问题。现在，让我们看看如何调优Hibernate以实现高性能。
- en: Hibernate performance tuning
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hibernate性能调优
- en: In the preceding section, we saw common Hibernate traps or issues. These issues
    don't necessarily mean faults in Hibernate; sometimes, they are from incorrect
    usage of the framework, and in some cases, limitations of the ORM framework itself.
    In the following sections, we will see how to improve performance in Hibernate.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们看到了常见的Hibernate陷阱或问题。这些问题并不一定意味着Hibernate的错误；有时是由于框架的错误使用，有时是ORM框架本身的限制。在接下来的部分中，我们将看到如何提高Hibernate的性能。
- en: Approaches to avoid the n + 1 problem
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免n + 1问题的方法
- en: We already saw the n + 1 problem in the *Hibernate n + 1 problem* section. Too
    many queries will slow down our application's overall performance. So, in order
    to avoid these additional queries with lazy loading, let's see what options are
    available.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在*Hibernate n + 1问题*部分看到了n + 1问题。太多的查询会减慢我们应用的整体性能。因此，为了避免懒加载导致的额外查询，让我们看看有哪些可用的选项。
- en: Fetch join using JPQL
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JPQL进行Fetch join
- en: 'Normally, we call the `findById` method of DAO to fetch the outer or parent
    entity and then call the getter methods of associations. Doing so leads to n +
    1 queries because the framework will execute additional queries for each association.
    Instead, we can write a JPQL query using the `createQuery` method of `EntityManager`.
    In this query, we can join our associated entity, which we want to fetch along
    with the outer entity by using `JOIN FETCH`. The following is an example of how
    to get `JOIN FETCH` entities:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们调用DAO的`findById`方法来获取外部或父实体，然后调用关联的getter方法。这样做会导致n + 1查询，因为框架会为每个关联执行额外的查询。相反，我们可以使用`EntityManager`的`createQuery`方法编写一个JPQL查询。在这个查询中，我们可以使用`JOIN
    FETCH`来连接我们想要与外部实体一起获取的关联实体。以下是如何获取`JOIN FETCH`实体的示例：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following is the log that states that only one query is executed:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是记录表明只执行了一个查询的日志：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`JOIN FETCH` tells `entityManager` to load the selected entity, as well as
    the associated entity, in the same query.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`JOIN FETCH`告诉`entityManager`在同一个查询中加载所选实体以及关联的实体。'
- en: The advantage of this approach is that Hibernate fetches everything within one
    query. From a performance point of view, this option is good, because everything
    is fetched in a single query instead of multiple queries. This reduces the round-trips
    to the database for each separate query.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是Hibernate在一个查询中获取所有内容。从性能的角度来看，这个选项很好，因为所有内容都在一个查询中获取，而不是多个查询。这减少了每个单独查询对数据库的往返。
- en: The disadvantage of this approach is that we need to write additional code to
    execute the query. It's not an issue until we have a few associations or relations
    to fetch. But, it gets worse if the entity has many associations and we need to
    fetch different associations for each different use case. So, in order to fulfill
    each different use case, we need to write different queries with required associations.
    Too many different queries for each use case would be quite messy, and also difficult
    to maintain.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是我们需要编写额外的代码来执行查询。如果实体有许多关联，并且我们需要为每个不同的用例获取不同的关联，那么情况就会变得更糟。因此，为了满足每个不同的用例，我们需要编写不同的查询，带有所需的关联。对于每个用例编写太多不同的查询会变得非常混乱，也很难维护。
- en: This option would be a good approach if the number of queries requiring different
    join fetchcombinations was low.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要不同的连接获取组合的查询数量较少，这个选项将是一个很好的方法。
- en: Join fetch in Criteria API
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Criteria API中的连接获取
- en: 'This approach is the same as `JOIN FETCH` in JPQL; however, this time, we are
    using the Criteria API of Hibernate. The following is an example of how to use
    `JOIN FETCH` in the Criteria API:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法和JPQL中的`JOIN FETCH`一样；但是这次我们使用的是Hibernate的Criteria API。以下是如何在Criteria API中使用`JOIN
    FETCH`的示例：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This option has the same advantages and disadvantages as JPQL. Most of the time,
    when we write a query using the Criteria API, it is use case-specific. So, this
    option might not be a huge problem in those cases, and it would be a good approach
    to reduce the amount of queries performed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选项和JPQL一样有优点和缺点。大多数情况下，当我们使用Criteria API编写查询时，它是特定于用例的。因此，在这些情况下，这个选项可能不是一个很大的问题，它是减少执行的查询数量的一个很好的方法。
- en: Named entity graph
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名实体图
- en: Then named entity graph is a new feature, introduced in JPA 2.1\. In this approach,
    we can define a graph of entities that need to be queried from the database. We
    can define the entity graph on our entity class by using the `@NamedEntityGraph`
    annotation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后命名实体图是JPA 2.1中引入的一个新特性。在这种方法中，我们可以定义需要从数据库查询的实体图。我们可以通过使用`@NamedEntityGraph`注解在我们的实体类上定义实体图。
- en: 'The following is an example of how to define a graph using `@NamedEntityGraph`
    on the entity class:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何在实体类上使用`@NamedEntityGraph`定义图的示例：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'An entity graph definition is independent of the query and defines which attributes
    to be fetched from the database. An entity graph can be used as a load or a fetch graph.
    If a load graph is used, all attributes that are not specified in the entity graph
    definition will keep following their default `FetchType.` If a fetch graph is
    used, only the attributes specified by the entity graph definition will be treated
    as `FetchType.EAGER`, and all other attributes will be treated as `LAZY`. The
    following is an example of how to use a named entity graph as a `fetchgraph`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 实体图定义独立于查询，并定义从数据库中获取哪些属性。实体图可以用作加载或提取图。如果使用加载图，则未在实体图定义中指定的所有属性将继续遵循其默认的`FetchType.`如果使用提取图，则只有实体图定义指定的属性将被视为`FetchType.EAGER`，而所有其他属性将被视为`LAZY`。以下是如何将命名实体图用作`fetchgraph`的示例：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We are not going to go into detail on named entity graphs in this book. This
    is one of the best approaches to resolve the n + 1 issue with Hibernate. This
    is an improved version of `JOIN FETCH`. An advantage on top of `JOIN FETCH` is
    that it will be reused for different use cases. The only disadvantage of this
    approach is that we must annotate the named entity graph for each combination
    of associations that we want to fetch in a single query. So, this can get quite
    messy if we have too many different combinations to set.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不打算在本书中详细介绍命名实体图。这是解决Hibernate中n + 1问题的最佳方法之一。这是`JOIN FETCH`的改进版本。与`JOIN FETCH`相比的优势是它将被用于不同的用例。这种方法的唯一缺点是我们必须为我们想要在单个查询中获取的每种关联组合注释命名实体图。因此，如果我们有太多不同的组合要设置，这可能会变得非常混乱。
- en: Dynamic entity graph
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态实体图
- en: 'A dynamic entity graph is similar to a named entity graph, with the difference
    that we can define it dynamically through the Java API. The following is an example
    of how to define an entity graph using the Java API:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 动态实体图类似于命名实体图，不同之处在于我们可以通过Java API动态定义它。以下是使用Java API定义实体图的示例：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So, if we have lots of use case-specific entity graphs, this approach will be
    an advantage over named entity graph where adding an annotation on our entity
    for each use case makes code unreadable. We can keep all use case-specific entity
    graphs in our business logic. With this approach, the disadvantage is that we
    need write more code and in order to make code reusable, we need to write more
    of the methods for each related business logic.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们有大量特定于用例的实体图，这种方法将优于命名实体图，在这种方法中，为每个用例在我们的实体上添加注释会使代码难以阅读。我们可以将所有特定于用例的实体图保留在我们的业务逻辑中。使用这种方法的缺点是我们需要编写更多的代码，并且为了使代码可重用，我们需要为每个相关的业务逻辑编写更多的方法。
- en: Finding performance issues with Hibernate statistics
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Hibernate统计信息查找性能问题
- en: Most of the time, we face slow responses on the production system, while our
    local or test system works just fine. Most of these cases are because of slow
    database queries. In a local instance, we don't know the exact volume of requests
    and volume of data that we have in production. So, how do we find out which query
    is causing the problem, without adding logs to our application code? The answer
    is the Hibernate `generate_statistics` configuration.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，我们在生产系统上面临缓慢的响应，而我们的本地或测试系统运行良好。这些情况大多是由于数据库查询缓慢引起的。在本地实例中，我们不知道我们在生产中有多少请求和数据量。那么，我们如何找出哪个查询导致问题，而不向我们的应用程序代码添加日志？答案是Hibernate
    `generate_statistics`配置。
- en: We need to set the Hibernate property `generate_statistics` to true, as this
    property is false by default. This property impacts the overall performance, as
    it logs all database activities. So, enable this property only when you want to
    analyze slow queries. This property will generate summarized multiline logs, showing
    how much overall time is spent on database interaction.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将Hibernate属性`generate_statistics`设置为true，因为默认情况下此属性为false。此属性会影响整体性能，因为它记录所有数据库活动。因此，只有在要分析缓慢查询时才启用此属性。此属性将生成总结的多行日志，显示在数据库交互上花费了多少总时间。
- en: If we want to log the execution of each query, we need to enable `org.hibernate.stat`
    to the `DEBUG` level in log configuration; similarly, if we want to log SQL queries
    (with times), we need to enable `org.hibernate.SQL` to the `DEBUG` level.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要记录每个查询的执行，我们需要在日志配置中将`org.hibernate.stat`启用为`DEBUG`级别；同样，如果我们想要记录SQL查询（带时间），我们需要将`org.hibernate.SQL`启用为`DEBUG`级别。
- en: 'The following is an example of a printed log:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是打印日志的示例：
- en: '![](img/b8713ce6-c5b1-47e8-bd83-65dc3a0024f0.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8713ce6-c5b1-47e8-bd83-65dc3a0024f0.png)'
- en: Hibernate generate_statistics logs
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate生成统计日志
- en: An overall statistics information log shows the number of JDBC connections used,
    statements, caches, and performed flushes. We always need to check the number
    of statements first to see if there is an n + 1 issue.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 总体统计信息日志显示了使用的JDBC连接数、语句、缓存和执行的刷新次数。我们总是需要首先检查语句的数量，以查看是否存在n + 1问题。
- en: Using query-specific fetching
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用特定于查询的获取
- en: 'It is always recommended to select only those columns which are required for
    our use case. If you are using the `CriteriaQuery`, use projections to select
    required columns. Fetching the entire entity would degrade the application''s
    performance when the table has too many columns, so the database needs to go through
    each block of the stored page to retrieve them, and we might not even need all
    of those columns in our use case. Also, if we are using an entity instead of the
    DTO class, persistence context has to manage the entities and also fetches associated/child
    entities when required. This adds an overhead. Instead of fetching  the entire
    entity, fetch only the required columns:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 始终建议仅选择我们用例所需的列。如果使用`CriteriaQuery`，请使用投影选择所需的列。当表具有太多列时，获取整个实体会降低应用程序的性能，因此数据库需要浏览存储页面的每个块来检索它们，而且我们在用例中可能并不需要所有这些列。此外，如果我们使用实体而不是DTO类，持久性上下文必须管理实体，并在需要时获取关联/子实体。这会增加额外开销。而不是获取整个实体，只获取所需的列：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Fetch a specific column as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式获取特定列：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The better way to use query-specific fetching is to use DTO projection. Our
    entities are managed by a persistence context. So, it would be easier to fetch
    `ResultSet` to the entity, in case we want to update it. We set the new values
    to the setter methods, and Hibernate will take care of the SQL statements to update
    it. This easiness comes with the price of performance since Hibernate needs to
    do dirty checks on all managed entities to find out if it needs to save any changes
    to the database. DTO are the POJO classes which are the same as our entities,
    however, it's not managed by persistence.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特定查询获取的更好方法是使用DTO投影。我们的实体由持久性上下文管理。因此，如果我们想要更新它，将`ResultSet`获取到实体会更容易。我们将新值设置给setter方法，Hibernate将负责更新它的SQL语句。这种便利性是以性能为代价的，因为Hibernate需要对所有受管理的实体进行脏检查，以找出是否需要将任何更改保存到数据库。DTO是POJO类，与我们的实体相同，但不受持久性管理。
- en: 'We can fetch specific columns in JPQL by using the constructor expression,
    as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用构造函数表达式在JPQL中获取特定列，如下所示：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Similarly, we can do the same thing by using `CriteriaQuery` and `JPAMetamodel`,
    as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以通过使用`CriteriaQuery`和`JPAMetamodel`来做同样的事情，如下所示：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Caching and its best practices
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存及其最佳实践
- en: 'We already saw how caching works in Spring in [Chapter 3](6ad6974a-b108-4e80-b13c-cbc5916d1969.xhtml),
    *Tuning Aspect-Oriented Programming*. Here, we will see how caching works in Hibernate,
    and what different types of caching are available in Hibernate. In Hibernate,
    there are three different types of caching, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了Spring中缓存是如何工作的，在[第3章](6ad6974a-b108-4e80-b13c-cbc5916d1969.xhtml)中，*调整面向方面的编程*。在这里，我们将看到Hibernate中缓存是如何工作的，以及Hibernate中有哪些不同类型的缓存。在Hibernate中，有三种不同类型的缓存，如下所示：
- en: First level cache
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一级缓存
- en: Second level cache
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二级缓存
- en: Query cache
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询缓存
- en: Let's understand how each cache mechanism works in Hibernate.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解Hibernate中每种缓存机制是如何工作的。
- en: First level cache
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一级缓存
- en: In the first level cache, Hibernate caches entities in session objects. The
    Hibernate first level cache is enabled by default, and we cannot disable it. Still,
    Hibernate provides methods through which we can delete particular objects from
    the cache, or completely clear the cache from a session object.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在一级缓存中，Hibernate在会话对象中缓存实体。Hibernate一级缓存默认启用，我们无法禁用它。但是，Hibernate提供了方法，通过这些方法我们可以从缓存中删除特定对象，或者完全清除会话对象中的缓存。
- en: 'As Hibernate does a first level cache in a session object, any object cached
    will not be visible to another session. When the session is closed, the cache
    is cleared. We are not going to go into detail on this caching mechanism, as it
    is available by default, and there is no way to tune or disable it. There are
    certain methods to know for this level of cache, as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Hibernate在会话对象中进行一级缓存，任何缓存的对象对另一个会话是不可见的。当会话关闭时，缓存被清除。我们不打算详细介绍这种缓存机制，因为它默认可用，没有办法调整或禁用它。有一些方法可以了解这个级别的缓存，如下所示：
- en: Use the session's `evict()` method to delete a single object from the Hibernate
    first level cache
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用会话的`evict()`方法从Hibernate一级缓存中删除单个对象
- en: Use the session's `clear()` method to clear the cache completely
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用会话的`clear()`方法完全清除缓存
- en: Use the session's `contains()` method to check whether an object is present
    in the Hibernate cache
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用会话的`contains()`方法检查对象是否存在于Hibernate缓存中
- en: Second level cache
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二级缓存
- en: 'One benefit of database abstraction layers, such as ORM frameworks, is their
    ability to transparently cache data:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库抽象层（例如ORM框架）的一个好处是它们能够透明地缓存数据：
- en: '![](img/2dae2d40-0d0d-4fef-b6dd-23bcd4e3a988.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2dae2d40-0d0d-4fef-b6dd-23bcd4e3a988.jpg)'
- en: Caching at the database and application level
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库和应用程序级别进行缓存
- en: The application cache is not an option for many large enterprise applications.
    With the application cache, we help to reduce many round-trips to get required
    data from the database cache. The application-level cache stores entire objects,
    which are retrieved based on hash table keys. Here, we are not going to talk about
    the application level cache; we are going to talk about the second level cache.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多大型企业应用程序来说，应用程序缓存并不是一个选项。通过应用程序缓存，我们可以减少从数据库缓存中获取所需数据的往返次数。应用程序级缓存存储整个对象，这些对象是根据哈希表键检索的。在这里，我们不打算讨论应用程序级缓存；我们将讨论二级缓存。
- en: 'In Hibernate, unlike with the first level cache, the second level cache is
    `SessionFactory` scoped; hence, it is shared by all sessions created within the
    same session factory. When the second level is enabled and the entity is looked
    up, the following applies:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在Hibernate中，与一级缓存不同，二级缓存是`SessionFactory`范围的；因此，它由同一会话工厂内创建的所有会话共享。当启用二级缓存并查找实体时，以下内容适用：
- en: It will first be checked in the first level cache if the instance is available,
    and then returned.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果实例可用，它将首先在一级缓存中进行检查，然后返回。
- en: If the instance is not present in the first level, it will try to find it in
    the second level cache, and, if found, it is assembled and returned.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一级缓存中不存在实例，它将尝试在二级缓存中查找，如果找到，则组装并返回。
- en: If the instance is not found in the second level cache, it will make the trip
    to the database and fetch the data. The data is then assembled and returned.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在二级缓存中找不到实例，它将前往数据库并获取数据。然后将数据组装并返回。
- en: 'Hibernate doesn''t do any caching by itself. It provides the interface `org.hibernate.cache.spi.RegionFactory`,
    and cache providers do the implementation of this interface. Here, we will talk
    about the Ehcache provider, which is mature and the most widely used cache. In
    order to enable second level caching, we need to add the following two lines to
    our persistence properties:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate本身不进行任何缓存。它提供了接口`org.hibernate.cache.spi.RegionFactory`，缓存提供程序对此接口进行实现。在这里，我们将讨论成熟且最广泛使用的缓存提供程序Ehcache。为了启用二级缓存，我们需要将以下两行添加到我们的持久性属性中：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once the level two cache is enabled, we need to define which entities we want
    to cache; we need to annotate those entities with `@org.hibernate.annotations.Cache`,
    as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 启用二级缓存后，我们需要定义要缓存的实体；我们需要使用`@org.hibernate.annotations.Cache`对这些实体进行注释，如下所示：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Hibernate uses a separate cache region to store the states of instances of
    an entity. The region name is the fully qualified class name. There are different
    concurrency strategies provided by Hibernate, which we can use based on our requirements.
    The following are the different concurrency strategies:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate使用单独的缓存区域来存储实体实例的状态。区域名称是完全限定的类名。Hibernate提供了不同的并发策略，我们可以根据需求使用。以下是不同的并发策略：
- en: '`READ_ONLY`: Used only for entities that are never modified; in the case of
    modification, an exception is thrown. It is used for some static reference data
    that doesn''t change.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`READ_ONLY`：仅用于从不修改的实体；在修改时会抛出异常。用于一些静态参考数据，不会更改。'
- en: '`NONSTRICT_READ_WRITE`: The cache is updated when the transaction affecting
    the cached data is committed. While the cache is updated, there is a chance to
    obtain stale data from the cache. This strategy is suitable for those requirements
    that can tolerate eventual consistency. This strategy is useful for data that
    is rarely updated.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NONSTRICT_READ_WRITE`：在影响缓存数据的事务提交时更新缓存。在更新缓存时，有可能从缓存中获取陈旧的数据。此策略适用于可以容忍最终一致性的要求。此策略适用于很少更新的数据。'
- en: '`READ_WRITE`: To avoid obtaining stale data while the cache is updated, this
    strategy uses soft locks. When a cached entity is updated, the entity in the cache
    is locked and is released after the transaction is committed. All concurrent transactions
    will retrieve the corresponding data directly from the database.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`READ_WRITE`：为了在更新缓存时避免获取陈旧数据，此策略使用软锁。当缓存的实体被更新时，缓存中的实体被锁定，并在事务提交后释放。所有并发事务将直接从数据库中检索相应的数据。'
- en: '`TRANSACTIONAL`: The transaction strategy is mainly used in distributed caches
    in the JTA environment.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TRANSACTIONAL`：事务策略主要用于JTA环境中的分布式缓存。'
- en: 'If there is no expiration and eviction policy defined, the cache could grow
    indefinitely and eventually consume all of the memory. We need to set these policies,
    and it depends on cache providers. Here, we are using Ehcache, and the following
    is the method to define expiration and eviction policies in `ehcache.xml`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未定义过期和驱逐策略，缓存可能会无限增长，并最终消耗所有内存。我们需要设置这些策略，这取决于缓存提供程序。在这里，我们使用Ehcache，并且以下是在`ehcache.xml`中定义过期和驱逐策略的方法：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Many of us think that the cache stores entire objects. However, it doesn''t
    store entire objects, but rather, it stores them in a disassembled state:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们中的许多人认为缓存存储整个对象。但是，它并不存储整个对象，而是以分解状态存储它们：
- en: The primary key is not stored, because it is the cache key
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主键不存储，因为它是缓存键
- en: Transient properties are not stored
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 瞬态属性不存储
- en: Collection associations are not stored by default
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下不存储集合关联
- en: All property values, except for associations, are stored in their original forms
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除关联之外的所有属性值都以其原始形式存储
- en: Foreign keys for `@ToOne` associations are stored only with IDs
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ToOne`关联的外键仅存储ID'
- en: Query cache
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询缓存
- en: 'The query cache can be enabled by adding the following Hibernate property:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过添加以下Hibernate属性来启用查询缓存：
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once the query cache is enabled, we can specify which query we want to cache,
    as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 启用查询缓存后，我们可以指定要缓存的查询，如下所示：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we execute the same query again which is cached by query cache, the following
    is the log printed with `DEBUG` mode:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次执行已被查询缓存缓存的相同查询，则在`DEBUG`模式下打印以下日志：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Performing updates and deletes in bulk
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 批量执行更新和删除
- en: As we know, ORM frameworks, like Hibernate, execute two or more queries when
    we update or delete any entity. If we were updating or deleting a few entities,
    this would be fine, but think of a scenario where we want to update or delete
    100 entities. Hibernate will execute 100 `SELECT` queries to fetch the entities,
    and another 100 queries to update or delete the entities.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，ORM框架（如Hibernate）在更新或删除实体时会执行两个或更多查询。如果我们要更新或删除少量实体，这是可以接受的，但是想象一下我们要更新或删除100个实体的情况。Hibernate将执行100个`SELECT`查询来获取实体，然后执行另外100个查询来更新或删除实体。
- en: We know that in order to achieve better performance for any application, a lower
    number of database statements need to be executed. If we perform the same update
    or delete using JPQL or native SQL, it can be done in a single statement. Hibernate
    provides a lot of benefits as an ORM framework and can help us keep a focus on
    business logic, rather than database operations. In scenarios where Hibernate
    could be costly such as bulk update and delete, we should use the native database
    queries to avoid overhead and achieve better performance.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现任何应用程序的更好性能，需要执行更少的数据库语句。如果我们使用JPQL或本地SQL执行相同的更新或删除操作，可以在单个语句中完成。Hibernate作为ORM框架提供了许多好处，可以帮助我们专注于业务逻辑，而不是数据库操作。在Hibernate可能昂贵的情况下，例如批量更新和删除，我们应该使用本地数据库查询来避免开销并实现更好的性能。
- en: 'The following is a way that we can execute the native query to `UPDATE` all
    of the user''s emails in the bank inbox as `read`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们可以执行本机查询以将银行收件箱中所有用户的电子邮件更新为“已读”的方法：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We can measure the performance difference using the Hibernate method and native
    query to update bulk data, simply by logging `System.currentTimeMillis()`. There
    should be a significant increase in performance, with the native query 10 times
    faster than the Hibernate approach.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过记录`System.currentTimeMillis()`来测量使用Hibernate方法和本机查询更新大量数据的性能差异。本机查询的性能应该显著提高，比Hibernate方法快10倍。
- en: 'The native query will definitely improve bulk operation performance, but at
    the same time, it comes with issues with the first level cache, and won''t trigger
    any entity life cycle events. As we know, Hibernate stores all entities that we
    use within a session in the first level cache. It has benefits for write-behind
    optimizations and avoids duplicate select statement executions for the same entity
    in the same session. But, with the native query, Hibernate doesn''t know which
    entities were updated or removed and updates the first level cache accordingly.
    It will keep using an outdated version of the entity in the cache if we fetch
    the entity before executing the native query in the same session. The following
    is an example of an issue with the first level cache, using the native query:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 本地查询肯定会提高批量操作的性能，但与此同时，它会带来一级缓存的问题，并且不会触发任何实体生命周期事件。众所周知，Hibernate将我们在会话中使用的所有实体存储在一级缓存中。这对于写后优化很有好处，并且避免在同一会话中为相同的实体执行重复的选择语句。但是，对于本地查询，Hibernate不知道哪些实体已更新或删除，并相应地更新一级缓存。如果我们在同一会话中在执行本地查询之前获取实体，则它将继续在缓存中使用实体的过时版本。以下是使用本地查询时一级缓存的问题示例：
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A solution to this problem is to update the first level cache manually, by
    detaching the entity before native query execution and attaching it back after
    native query execution. To do so, perform the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是在本地查询执行之前手动更新一级缓存，通过在本地查询执行之前分离实体，然后在本地查询执行后重新附加它。为此，请执行以下操作：
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Call the `flush()` and `detach()` methods before performing the native query.
    The `flush()` method tells Hibernate to write the changed entities from the first
    level cache to the database. This is to make sure that we don't lose any updates.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行本地查询之前，请调用`flush()`和`detach()`方法。`flush()`方法告诉Hibernate将一级缓存中的更改实体写入数据库。这是为了确保我们不会丢失任何更新。
- en: Hibernate programming practices
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hibernate编程实践
- en: Until now, we saw problems with Hibernate when it is not used optimally, and
    how to use Hibernate to achieve better performance. The following are the best
    practices to follow (in terms of caching, and in general) to achieve better performance
    when using JPA and Hibernate.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到了当Hibernate没有被最佳利用时出现的问题，以及如何使用Hibernate来实现更好的性能。以下是在使用JPA和Hibernate时遵循的最佳实践（在缓存和一般情况下）以实现更好的性能。
- en: Caching
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存
- en: 'The following are some programming tips in relation to the different caching
    levels in Hibernate:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于Hibernate不同缓存级别的一些编程提示：
- en: Make sure to use the same version of `hibernate-ehcache` as the version of Hibernate.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保使用与Hibernate版本相同的`hibernate-ehcache`版本。
- en: Since Hibernate caches all of the objects into the session first level cache,
    when running bulk queries or batch updates, it's necessary to clear the cache
    at certain intervals to avoid memory issues.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于Hibernate将所有对象缓存到会话的一级缓存中，因此在运行批量查询或批量更新时，有必要定期清除缓存以避免内存问题。
- en: When caching an entity using the second level cache, collections inside of the
    entity are not cached by default. In order to cache the collections, annotate
    the collections within the entity with `@Cacheable` and `@org.hibernate.annotations.Cache(usage
    = CacheConcurrencyStrategy.READ_WRITE)`. Each collection is stored in a separate
    region in the second level cache, where the region name is the fully qualified
    name of the entity class, plus the name of the collection property. Define the
    expiration and eviction policy separately for each collection that's cached.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用二级缓存缓存实体时，默认情况下不会缓存实体内的集合。为了缓存集合，需要在实体内用`@Cacheable`和`@org.hibernate.annotations.Cache(usage
    = CacheConcurrencyStrategy.READ_WRITE)`注释集合。每个集合都存储在二级缓存中的单独区域中，区域名称是实体类的完全限定名称加上集合属性的名称。为每个缓存的集合单独定义过期和驱逐策略。
- en: 'When DML statements are executed using JPQL, the cache for those entities will
    be updated/evicted by Hibernate; however, when using the native query, the entire
    second level cache will be evicted, unless the following detail is added to native
    query execution when using Hibernate with JPA:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用JPQL执行DML语句时，Hibernate将更新/驱逐这些实体的缓存；然而，当使用本地查询时，整个二级缓存将被驱逐，除非在使用Hibernate与JPA时添加以下细节到本地查询执行中：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the case of query caching, there will be one cache entry for each combination
    of query and parameter values, so queries, where different combinations of parameter
    values are expected, are not good for caching.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在查询缓存的情况下，每个查询和参数值的组合将有一个缓存条目，因此对于预期有不同参数值组合的查询，不适合缓存。
- en: In the case of query caching, a query that fetches the entity classes for which
    there are frequent changes in the database is not a good candidate for caching,
    because the cache will be invalidated when any entity involved in the query is changed.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在查询缓存的情况下，对于从数据库中频繁更改的实体类进行抓取的查询不适合缓存，因为当涉及查询的任何实体发生更改时，缓存将被作废。
- en: All query cache results are stored in the `org.hibernate.cache.internal.StandardQueryCache`
    region. We can specify the expiration and eviction policies for this region. Also,
    if required, we can set a different region for a particular query to cache by
    using the query hint `org.hibernate.cacheRegion`.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有查询缓存结果都存储在`org.hibernate.cache.internal.StandardQueryCache`区域。我们可以为这个区域指定过期和驱逐策略。此外，如果需要，我们可以使用查询提示`org.hibernate.cacheRegion`为特定查询设置不同的缓存区域。
- en: Hibernate keeps last update timestamps in a region named `org.hibernate.cache.spi.UpdateTimestampsCache`
    for all query cached tables. Hibernate uses this to verify that cached query results
    are not stale. It is best to turn off automatic eviction and expiration for this
    cache region, because entries in this cache must not be evicted/expired, as long
    as there are cached query results in cache results regions.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hibernate在名为`org.hibernate.cache.spi.UpdateTimestampsCache`的区域中保留了所有查询缓存表的最后更新时间戳。Hibernate使用这个来验证缓存的查询结果是否过时。最好关闭此缓存区域的自动驱逐和过期，因为只要缓存结果区域中有缓存的查询结果，这个缓存中的条目就不应该被驱逐/过期。
- en: Miscellaneous
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 杂项
- en: 'The following are general Hibernate best practices for achieving better performance
    in your application:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实现应用程序更好性能的一般Hibernate最佳实践：
- en: Avoid enabling `generate_statistics` on the production system; rather, analyze
    issues by enabling `generate_statistics` on a staging or a replica of the production
    system.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在生产系统上启用`generate_statistics`；而是通过在生产系统的暂存或副本上启用`generate_statistics`来分析问题。
- en: Hibernate always updates all database columns, even though we update one or
    a few columns only. All of the columns in the `UPDATE` statement would take more
    time than a few columns. In order to achieve high performance and avoid using
    all of the columns in an `UPDATE` statement, only include the columns that are
    actually modified and use the `@DynamicUpdate` annotation on an entity. This annotation
    tells Hibernate to generate a new SQL statement for each update operation, with
    only modified columns.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hibernate始终更新所有数据库列，即使我们只更新一个或几个列。`UPDATE`语句中的所有列将比少数列花费更多时间。为了实现高性能并避免在`UPDATE`语句中使用所有列，只包括实际修改的列，并在实体上使用`@DynamicUpdate`注释。此注释告诉Hibernate为每个更新操作生成一个新的SQL语句，仅包含修改的列。
- en: Set the default `FetchType` as `LAZY` for all associations, and use query-specific
    fetching, using `JOIN FETCH`, named entity graphs, or dynamic entity graphs, to
    avoid the n + 1 issue and improve performance.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将默认的`FetchType`设置为`LAZY`以用于所有关联，并使用特定于查询的获取，使用`JOIN FETCH`，命名实体图或动态实体图，以避免n
    + 1问题并提高性能。
- en: Always use bind parameters to avoid SQL injections and improve performance.
    When used with bind parameters, Hibernate and the database optimizes queries if
    the same query is executed multiple times.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终使用绑定参数以避免SQL注入并提高性能。与绑定参数一起使用时，如果多次执行相同的查询，Hibernate和数据库会优化查询。
- en: Perform `UPDATE` or `DELETE` in a huge list in bulk, instead of performing them
    one-by-one. We already discussed this in the *Performing updates and deletes in
    bulk* section.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大型列表中执行`UPDATE`或`DELETE`，而不是逐个执行它们。我们已经在*在大量中执行更新和删除*部分中讨论过这一点。
- en: Never use entities for read-only operations; rather, use different projections
    provided by JPA and Hibernate. One that we already saw was the DTO projection.
    For read-only requirements, changing the entity to a constructor expression in
    `SELECT` is very easy, and high performance will be achieved.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要对只读操作使用实体；而是使用JPA和Hibernate提供的不同投影。我们已经看到的一个是DTO投影。对于只读需求，将实体更改为`SELECT`中的构造函数表达式非常容易，并且将实现高性能。
- en: 'With the introduction of the Stream API in Java 8.0, many people used its features
    to process huge data retrieved from a database. Stream is designed to work on
    huge data. But there are certain things that a database can do better than the
    Stream API. Don''t use the Stream API for the following requirements:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着Java 8.0中Stream API的引入，许多人使用其功能来处理从数据库检索的大量数据。Stream旨在处理大量数据。但是数据库可以做一些事情比Stream
    API更好。不要对以下要求使用Stream API：
- en: 'Filter data: The database can filter data more efficiently than the Stream
    API, which we can do using the `WHERE` clause'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤数据：数据库可以更有效地过滤数据，而我们可以使用`WHERE`子句来实现
- en: 'Limiting data: The database provides more efficient results than the Stream
    API when we want to limit the number of data to be retrieved'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制数据：当我们想要限制要检索的数据的数量时，数据库提供比Stream API更有效的结果
- en: 'Sort data: The database can sort more efficiently than the Stream API by using
    the `ORDER BY` clause'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序数据：数据库可以通过使用`ORDER BY`子句更有效地进行排序，而不是Stream API
- en: 'Use order instead of sorting, especially for huge associated entities of data.
    Sorting is Hibernate-specific, and not a JPA specification:'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用排序而不是排序，特别是对于大量关联数据的实体。排序是Hibernate特定的，不是JPA规范：
- en: Hibernate sorts using the Java Comparator in memory. However, the same desired
    order of data can be retrieved from the database by using the `@OrderBy` annotation
    on associated entities.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hibernate使用Java比较器在内存中进行排序。但是，可以使用关联实体上的`@OrderBy`注释从数据库中检索相同所需顺序的数据。
- en: If the column name is not specified, `@OrderBy` will be done on the primary
    key.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果未指定列名，则将在主键上执行`@OrderBy`。
- en: Multiple columns can be specified in `@OrderBy`, comma-separated.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在`@OrderBy`中指定多个列，以逗号分隔。
- en: 'The database handles `@OrderBy` more efficiently than implementing sorting
    in Java. The following is a code snippet, as an example:'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库比在Java中实现排序更有效地处理`@OrderBy`。以下是一个代码片段，作为示例：
- en: '[PRE30]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Hibernate regularly performs dirty checks on all entities that are associated
    with the current `PersistenceContext`, to detect required database updates. For
    entities that never update, such as read-only database views or tables, performing
    dirty checks is an overhead. Annotate these entities with `@Immutable`, and Hibernate
    will ignore them in all dirty checks, improving performance.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hibernate定期对与当前`PersistenceContext`关联的所有实体执行脏检查，以检测所需的数据库更新。对于从不更新的实体，例如只读数据库视图或表，执行脏检查是一种开销。使用`@Immutable`对这些实体进行注释，Hibernate将在所有脏检查中忽略它们，从而提高性能。
- en: 'Never define unidirectional one-to-many relationships; always define bidirectional
    relationships. If a unidirectional one-to-many relationship is defined, Hibernate
    will need an extra table to store the references of both of the tables, just like
    in many-to-many relationships. There would be many extra SQL statements executed
    in the case of a unidirectional approach, which would not be good for performance.
    For better performance, annotate `@JoinColumn` on the owning side of the entity,
    and use the `mappedby` attribute on the other side of the entity. This will reduce
    the number of SQL statements, improving performance. Adding and removing an entity
    from a relationship needs to be handled everywhere explicitly; hence, it is recommended
    to write helper methods in the parent entity, as follows:'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要定义单向的一对多关系；总是定义双向关系。如果定义了单向的一对多关系，Hibernate将需要一个额外的表来存储两个表的引用，就像在多对多关系中一样。在单向方法的情况下，会执行许多额外的SQL语句，这对性能不利。为了获得更好的性能，在实体的拥有方上注释`@JoinColumn`，并在实体的另一侧使用`mappedby`属性。这将减少SQL语句的数量，提高性能。需要明确处理从关系中添加和删除实体；因此，建议在父实体中编写辅助方法，如下所示：
- en: '[PRE31]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started this chapter with a basic configuration of the ORM framework, Hibernate,
    using JPA and Spring Data. We focused on common ORM problems faced in production.
    In this chapter, we learned optimal solutions to the common problems faced while
    working on Hibernate for database operations and for achieving high performance.
     We learned useful tips for the best practices to follow when working on ORM-based
    frameworks to achieve high performance from the development stage, instead of
    resolving problems when facing them in the production system.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从基本配置ORM框架Hibernate开始了本章，使用JPA和Spring Data。我们关注了在生产中遇到的常见ORM问题。在本章中，我们学习了在使用Hibernate进行数据库操作和实现高性能时所面临的常见问题的最佳解决方案。我们学习了在基于ORM的框架上工作时要遵循的最佳实践，以在开发阶段就实现高性能，而不是在生产系统中面对问题时解决它们。
- en: In line with optimization and high performance, the next chapter provides information
    on Spring messaging optimization. As you know, messaging framework enterprise
    applications connect multiple clients and provide reliability, asynchronous communications,
    and loose coupling. Frameworks are built to provide various benefits; however,
    we face issues if we don't use them optimally. Similarly, there are certain parameters
    related to queue configuration and scalability that will maximize throughput in
    the Spring messaging framework of our enterprise application if used effectively.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 与优化和高性能一致，下一章提供了关于Spring消息优化的信息。正如您所知，消息框架企业应用程序连接多个客户端，并提供可靠性、异步通信和松散耦合。框架被构建为提供各种好处；然而，如果我们不以最佳方式使用它们，就会面临问题。同样，如果有效使用与队列配置和可伸缩性相关的某些参数，将最大化我们企业应用程序的Spring消息框架的吞吐量。
