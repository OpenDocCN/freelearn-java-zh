- en: 13\. Functional Programming with Lambda Expressions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13. 使用Lambda表达式进行函数式编程
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter discusses how Java doubles up as a functional programming language.
    It also details the manner in which lambda expressions are used to perform pattern
    matching in Java. It accomplishes this, first, by explaining, in general terms,
    the difference between **Object-Oriented Programming** (**OOP**) and **Functional
    Programming** (**FP**). You will then learn the basic definition of a pure function,
    as well as the difference between functional and normal interfaces. And, finally,
    you practice employing lambda expressions as callbacks to events and using them
    to filter data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了Java如何成为函数式编程语言。它还详细说明了在Java中如何使用lambda表达式进行模式匹配。它首先通过一般性地解释面向对象编程（OOP）和函数式编程（FP）之间的区别来实现这一点。然后，你将学习纯函数的基本定义，以及函数式接口和普通接口之间的区别。最后，你将练习使用lambda表达式作为回调事件，并使用它们来过滤数据。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: While Java has been around for over 20 years now, and **Functional Programming**
    (**FP**) has been around for even longer than Java, it's not been until recently
    that the topic of FP has caught traction in the Java community. This is probably
    due to Java being an inherently imperative programming language; when learning
    Java, you learn OOP.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Java已经存在了20多年，而函数式编程（FP）甚至比Java还要长，但直到最近，FP这个话题才在Java社区中引起关注。这可能是由于Java本质上是一种命令式编程语言；当学习Java时，你学习的是面向对象编程（OOP）。
- en: However, the movements in the mainstream programming community have, in the
    past few years, shifted more toward FP. These days, you can see it on every platform—from
    the web to mobile to servers. FP concepts are everywhere.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在过去的几年里，主流编程社区的动向已经更多地转向了FP。如今，你可以在每个平台上看到这一点——从网络到移动再到服务器。FP概念无处不在。
- en: Background
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景
- en: FP has been around for a very long time even though it is a relatively new topic
    in Java. In fact, it has been around even longer than the first personal computer;
    it has its origins in the lambda calculus study that Alonzo Church created in
    the 1930s.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在Java中是一个相对较新的话题，但函数式编程（FP）已经存在很长时间了。事实上，它甚至比第一台个人电脑还要早；它的起源可以追溯到20世纪30年代Alonzo
    Church创建的lambda演算研究。
- en: The name "lambda" comes from the Greek symbol, which was the symbol Church decided
    to use when describing the rules and mathematical functions for his lambda calculus.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: “lambda”这个名字来源于希腊符号，这是丘奇在描述他的lambda演算的规则和数学函数时决定使用的符号。
- en: The lambda identity function is, quite simply, a function returning the input
    parameter—that is, the identity. In a more normal mathematical script.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: lambda身份函数非常简单，就是一个返回输入参数的函数——即，身份。在一个更正常的数学脚本中。
- en: As you can see, lambda calculus is a simple approach to use for expressing mathematical
    equations. However, it doesn't necessarily have to be mathematical. In its truest
    form, it's a function with one argument and a body where the arithmetic happens.
    In lambda calculus, the function is a first-class citizen – meaning it can be
    treated like any other variable. You can even combine multiple lambdas if you
    require multiple attributes in your function.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，lambda演算是一种用于表达数学方程的简单方法。然而，它不一定是数学性的。在其最纯粹的形式中，它是一个具有一个参数和发生算术运算的体的函数。在lambda演算中，函数是一等公民——这意味着它可以像任何其他变量一样被对待。如果你需要在函数中具有多个属性，你甚至可以组合多个lambda。
- en: Functional Programming
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程
- en: 'FP boils down to two things: side effects and determinism. These concepts form
    the basis of what we call FP, and they are also the easiest things for newcomers
    to grasp in this paradigm because they don''t introduce new, complex patterns.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程（FP）归结为两件事：副作用和确定性。这些概念构成了我们所说的FP的基础，它们也是新来者在这个范式中最容易掌握的两个概念，因为它们没有引入新的、复杂的模式。
- en: Side Effects
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 副作用
- en: When writing a program, we often strive to get some form of side effect – a
    program without side effects is a very dull program, as nothing would happen.
    However, side effects are also a common headache when trying to test a program
    reliably as its state may change unpredictably.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写程序时，我们常常努力获得某种形式的副作用——一个没有副作用的程序是一个非常无聊的程序，因为什么都不会发生。然而，当试图可靠地测试程序时，副作用也是一个常见的头痛问题，因为其状态可能会不可预测地改变。
- en: 'A very useful class in Java is the `Math` class; it contains all sorts of mathematical
    helpers and is likely to be used in all Java applications, either directly or
    indirectly. Here is an example of printing a pseudo-random number to the console:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Java 中一个非常实用的类是 `Math` 类；它包含各种数学辅助工具，并且很可能会在所有 Java 应用程序中直接或间接地被使用。以下是一个将伪随机数打印到控制台的示例：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we dig into the code of `Math.java` and review the details of the `random()`
    function, we will notice that it uses an object, `randomNumberGenerator`, that
    doesn''t belong exclusively to the `random()` function:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们深入研究 `Math.java` 的代码并回顾 `random()` 函数的细节，我们会注意到它使用了一个不属于 `random()` 函数的
    `randomNumberGenerator` 对象：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It also calls `nextDouble()` on the `randomNumberGenerator` object. This is
    what we refer to as a side effect; the `random` function reaches outside its own
    home, or body, and performs changes on other variables or classes. These variables,
    in turn, can be by other functions or objects that may or may not produce their
    own side effects. This behavior is a red flag when you are trying to implement
    a program in FP fashion because it's unpredictable. It can also be more difficult
    to make it safe to use in a multithreaded environment.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 它还调用了 `randomNumberGenerator` 对象的 `nextDouble()` 方法。这就是我们所说的副作用；`random` 函数超出其自身的范围，或主体，并对其他变量或类进行更改。这些变量反过来又可能被其他函数或对象调用，这些函数或对象可能会也可能不会产生自己的副作用。当你试图以
    FP 风格实现程序时，这种行为是一个红旗，因为它不可预测。它也可能更难在多线程环境中安全使用。
- en: Note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `Math.random()` function, by design, delivers an unpredictable result. However,
    as an example, it serves us well to highlight the concept of side effects. The
    `random` function is also safe to use in multithreaded environments (for the most
    part)—Sun and Oracle have done their homework!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.random()` 函数按照设计提供不可预测的结果。然而，作为一个例子，它很好地为我们突出了副作用的概念。`random` 函数在多线程环境中（大部分情况下）也是安全的——Sun
    和 Oracle 已经完成了他们的作业！'
- en: As the `Math.random()` function produces different results for the same arguments,
    it's defined as a non-deterministic function.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Math.random()` 函数对于相同的参数会产生不同的结果，因此它被定义为非确定性函数。
- en: Deterministic Functions
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定性函数
- en: 'A deterministic function is defined as a function that will always produce
    the same result for the same arguments, no matter how many times, or when, you
    execute the function:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 确定性函数被定义为对于相同的参数，无论执行多少次或何时执行，都会始终产生相同结果的函数：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this example, `Math.random()` is called twice, and will always print two
    different values to the terminal. No matter how many times you call `Math.random()`,
    it will always give different results – as, by design, it''s not deterministic:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Math.random()` 被调用了两次，并且总是会打印出两个不同的值到终端。无论你调用多少次 `Math.random()`，它总是会给出不同的结果——因为按照设计，它不是确定性的：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Running this simple code, we can see that the `Math.toRadians()` function will
    give the same result for both functions, and doesn''t seem to change anything
    else in the program. This is a hint that it is deterministic – let''s dig into
    the function and review it:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段简单的代码，我们可以看到 `Math.toRadians()` 函数对两个函数都会给出相同的结果，并且似乎不会改变程序中的其他任何东西。这是一个提示，表明它是确定性的——让我们深入研究这个函数并回顾它：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The function, as expected, will not change anything from the outside world and
    will always produce the same result. This means that we can consider it as a deterministic
    function. However, it does read a constant that lives outside of the function's
    scope; this is something of an edge case of what we can call a **pure function**.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，该函数不会从外部世界改变任何东西，并且总是产生相同的结果。这意味着我们可以将其视为确定性函数。然而，它确实读取一个存在于函数作用域之外的常量；这是我们所说的**纯函数**的一个边缘情况。
- en: Pure Functions
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯函数
- en: The purest of functions can be considered black boxes, meaning that what happens
    inside the function is not really of any interest to the programmer. They are
    only interested in what is put into the box, and what comes out of it as a result—that's
    because there will always be a result of a pure function.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最纯的函数可以被认为是黑盒，这意味着函数内部发生的事情对程序员来说并不真正感兴趣。他们只对放入盒子的内容以及作为结果从盒子里出来的内容感兴趣——因为纯函数总是会有一个结果。
- en: The pure function takes arguments and produces a result based on these arguments.
    The pure function will never change the state of the outside world or rely on
    it. Everything that is required by the function should be available inside it,
    or as an input to it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数接受参数并根据这些参数产生结果。纯函数永远不会改变外部世界的状态或依赖它。函数所需的所有内容都应该在函数内部可用，或者作为输入传递给它。
- en: 'Exercise 1: Writing Pure Functions'
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1：编写纯函数
- en: 'A grocery store has a system for managing their stock; however, the company
    that built their software has gone bankrupt and has lost all the source code for
    their system. This is a system that only allows customers to buy one thing at
    a time. Because their customers want to buy two things at a time, never more or
    less, they have asked you to implement a function that takes the price of two
    products and returns the sum of those two prices. They want you to implement this
    without causing any side effects or incompatibilities with their current system.
    You''ll implement this as a pure function:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一家杂货店有一个管理系统来管理他们的库存；然而，构建他们软件的公司已经破产，并且丢失了他们系统的所有源代码。这是一个只允许客户一次购买一件东西的系统。因为他们的客户希望一次购买两件东西，不多也不少，所以他们要求你实现一个函数，该函数接受两种产品的价格并返回这两个价格的总额。他们希望你在不造成任何副作用或与当前系统不兼容的情况下实现这一点。你将作为一个纯函数来实现它：
- en: If IntelliJ is already started but no project is open, then select `Create New
    Project`. If IntelliJ already has a project open, then select `File` -> `New`
    -> `Project` from the menu.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 IntelliJ 已经启动但没有打开项目，那么请选择 `创建新项目`。如果 IntelliJ 已经打开了一个项目，那么请从菜单中选择 `文件` ->
    `新建` -> `项目`。
- en: In `New Project` dialog, select the `Java project`. Then, click on `Next`.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `新建项目` 对话框中，选择 `Java 项目`。然后，点击 `下一步`。
- en: Check the box to create the project from a template. Select `Command Line App`.
    Then, click on `Next`.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开复选框以从模板创建项目。选择 `命令行应用程序`。然后，点击 `下一步`。
- en: Give the new project the name `Exercise1`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给新项目命名为 `Exercise1`。
- en: IntelliJ will give you a default project location; if you wish to select one,
    you can enter it here.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IntelliJ 会为你提供一个默认的项目位置；如果你希望选择一个，可以在这里输入。
- en: Set the package name to `com.packt.java.chapter13`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将包名设置为 `com.packt.java.chapter13`。
- en: 'Click on `Finish`. IntelliJ will create your project, called `Exercise1`, with
    the standard folder structure. IntelliJ will also create the main entry point
    for your application, called `Main.java`; it will look like the following code
    snippet:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`完成`。IntelliJ 将创建你的项目，命名为 `Exercise1`，并使用标准的文件夹结构。IntelliJ 还将创建你的应用程序的主入口点，命名为
    `Main.java`；它将类似于以下代码片段：
- en: '[PRE5]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Rename `Main.java` to `Exercise1.java`.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Main.java` 重命名为 `Exercise1.java`。
- en: 'Create a new function in the `Main` class, placing it under the `main(String[]
    args)` function. Call the new function `sum` and let it return an integer value.
    This function should take two integers as input. For the simplicity of the code,
    we''ll make the function a `static` utility function:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 类中创建一个新的函数，将其放置在 `main(String[] args)` 函数之下。将新函数命名为 `sum` 并让它返回一个整数值。这个函数应该接受两个整数作为输入。为了代码的简洁性，我们将这个函数做成一个
    `static` 工具函数：
- en: '[PRE6]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'All this function should do is return the sum of the two arguments—`price1`
    and `price2`:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数应该做的只是返回两个参数——`price1` 和 `price2` 的总和：
- en: '[PRE7]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Call this new method a few times using the same parameters in your `main` function:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `main` 函数中使用相同的参数调用这个新方法几次：
- en: '[PRE8]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now run your program and observe the output.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行你的程序并观察输出。
- en: Note
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 备注
- en: The `System.out.println()` method is considered by many as an impure function
    because it manipulates the terminal – which is, of course, "the outside world"
    because, at some point in the call stack, the function will reach outside of its
    body to manipulate an `OutputStream` instance.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`System.out.println()` 方法被许多人视为不纯函数，因为它操作终端——当然，这是“外部世界”，因为在调用堆栈的某个点上，函数将超出其范围来操作一个
    `OutputStream` 实例。'
- en: The function you just wrote takes two arguments and produces a whole new output,
    without modifying anything outside the function's scope. With this, you've successfully
    taken the first step toward writing applications in a more functional way.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚才编写的函数接受两个参数并产生一个全新的输出，而不修改函数范围之外的内容。通过这一点，你已经成功迈出了编写更函数式应用程序的第一步。
- en: Another important consideration when writing functional programs is how to handle
    the state in your application. In OOP, we attack the problem of handling state
    in large applications by using the divide-and-conquer strategy. Here, each object
    in the application contains a little piece of the state of the entire application.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写函数式程序时，另一个重要的考虑因素是如何处理应用程序中的状态。在面向对象编程（OOP）中，我们通过使用分而治之的策略来解决大型应用程序中状态处理的问题。在这里，应用程序中的每个对象都包含整个应用程序状态的一小部分。
- en: 'An implicit attribute of this type of state handling is the ownership and mutability
    of the state. Each object often has a private state that is accessible using a
    public interface—the object''s method. If, for example, we review the `ParseException.java`
    class from the OpenJDK source code, we''ll find this pattern as well:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型状态处理的隐含属性是状态的拥有权和可变性。每个对象通常都有一个私有状态，可以通过公共接口——对象的方法来访问——即对象的方法。例如，如果我们回顾OpenJDK源代码中的`ParseException.java`类，我们也会找到这个模式：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we can see one private member variable called `errorOffset`. This member
    variable is writeable from the constructor and is accessible for other objects
    via the `getErrorOffest()` method. We can also imagine a class that has another
    method that changes the `errorOffset` value—that is, a setter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到一个名为`errorOffset`的私有成员变量。这个成员变量可以从构造函数中写入，并且可以通过`getErrorOffest()`方法被其他对象访问。我们还可以想象一个具有另一个更改`errorOffset`值的方法的类——即一个setter。
- en: One possible problem with this approach to state handling is multithreaded applications.
    If two or more threads were to either read or write to this member variable, we
    would usually see unpredictable changes. These changes can, of course, be mended
    in Java by using synchronization. However, synchronization comes at a cost; it's
    complicated to plan access accurately and, often, we end up with race conditions.
    It's also quite an expensive procedure in any language that supports it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种状态处理方法可能存在的一个问题是多线程应用程序。如果有两个或更多线程要读取或写入这个成员变量，我们通常会看到不可预测的变化。当然，在Java中，我们可以通过使用同步来修复这些变化。然而，同步是有代价的；准确规划访问很复杂，而且我们经常遇到竞态条件。在任何支持它的语言中，这也是一个相当昂贵的程序。
- en: Note
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Using synchronization is quite popular and is a safe way to build multithreaded
    applications. However, one of the downsides of synchronization—apart from it being
    very expensive—is that it effectively makes our application behave as a single-threaded
    application, as all threads accessing the synchronized data must wait their turn
    to handle the data.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用同步非常流行，并且是构建多线程应用程序的一种安全方式。然而，同步的一个缺点——除了它非常昂贵之外——是它实际上使我们的应用程序表现得像一个单线程应用程序，因为所有访问同步数据的线程都必须等待它们的轮次来处理数据。
- en: In FP, we try to avoid using synchronization by instead saying that our state
    should always be immutable—effectively negating the need for synchronization.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在FP中，我们试图避免使用同步，而是说我们的状态应该是始终不可变的——有效地消除了同步的需要。
- en: Immutability of State
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态不可变性
- en: 'When the state is immutable, it essentially means that it cannot change, ever.
    There is a common way of writing this rule in FP that goes something like this:
    replace your data rather than editing it in place.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当状态是不可变的时候，本质上意味着它永远不能改变。在FP中，有一种常见的写法来描述这个规则，大致是这样的：替换你的数据而不是就地编辑它。
- en: As we discussed in *Chapter 3*, *Object-Oriented Programming*, one of the core
    concepts of OOP is inheritance; that is, the ability to create child classes that
    build upon, or inherit, the functionality already present in parent classes, but
    also add new functionality to the child classes. In FP, this becomes relatively
    tricky because we're targeting data that should never change.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在第3章*面向对象编程*中讨论的，OOP的一个核心概念是继承；即创建子类的能力，这些子类基于或继承父类中已经存在的功能，但也可以向子类添加新功能。在函数式编程（FP）中，这变得相对复杂，因为我们针对的是永远不会改变的数据。
- en: 'The easiest way of making data unchangeable in Java is by using the `final`
    keyword. There are three ways of using the `final` keyword in Java: locking variables
    for change, making methods impossible to override, and making classes impossible
    to extend. When building immutable data structures in Java, it''s often not enough
    with just one of these methods; we need to use two or sometimes even all three.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中使数据不可变的最简单方法是通过使用`final`关键字。在Java中有三种使用`final`关键字的方法：锁定变量以更改，使方法无法被覆盖，以及使类无法扩展。当在Java中构建不可变数据结构时，仅仅使用这些方法中的任何一个通常是不够的；我们需要使用两个或有时甚至所有三个。
- en: 'Exercise 2: Creating an Immutable Class'
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2：创建一个不可变类
- en: 'A local carpenter has set up shop on your street and has asked you to build
    the storage mechanism for a simple shopping cart application, which they will
    use internally for people ordering furniture. The application should be able to
    safely handle multiple people editing it at the same time from different threads.
    The salespeople will take orders on the phone and the carpenters will be editing
    the price in hours spent and material used. The shopping cart must be immutable.
    To do this, perform the following steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一个当地木匠在你的街道上开设了商店，并要求你为他们构建一个简单的购物车应用程序的存储机制，他们将内部使用这个应用程序来处理订购家具的人。该应用程序应该能够安全地处理来自不同线程的多人同时编辑。销售人员将通过电话接收订单，木匠将编辑花费的小时数和使用的材料。购物车必须是不可变的。为此，执行以下步骤：
- en: In the `Project` pane in IntelliJ, right-click on the folder named `src`.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在IntelliJ的`Project`面板中，右键单击名为`src`的文件夹。
- en: Choose `New` -> `Java Class` in the menu and enter `Exercise2`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在菜单中选择`New` -> `Java Class`，并输入`Exercise2`。
- en: 'Define the `main` method in your new class:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的新类中定义`main`方法：
- en: '[PRE10]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create a new inner class called `ShoppingCart`, and then make it `final` to
    ensure that it cannot be extended or its behavior changed. Your code should now
    look something like this:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的内部类`ShoppingCart`，并将其设置为`final`以确保它不能被扩展或改变其行为。你的代码现在可能看起来像这样：
- en: '[PRE11]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We also need items to put into this cart, so create a simple data object for
    `ShoppingItem`, give it a name and price attribute, and then make the class immutable.
    We''ll later use this class to instantiate a few different objects to test the
    mutability of our `ShoppingCart` class:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要将项目放入这个购物车中，因此为`ShoppingItem`创建一个简单的数据对象，给它一个名称和价格属性，然后使这个类不可变。我们稍后会使用这个类来实例化几个不同的对象，以测试我们`ShoppingCart`类的可变性：
- en: '[PRE12]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add a list in which we will keep all the items for this immutable shopping
    cart. Make sure that you declare the list with the `final` keyword, keeping it
    unchangeable:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个列表，我们将在这个不可变购物车中保存所有项目。确保使用`final`关键字声明这个列表，使其不可更改：
- en: '[PRE13]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now we have a way to create items for our customers to purchase, and we also
    have a bag for our customers to put their selected items in. However, we lack
    a way for our customers to add items to the shopping cart.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们有了一种为我们的客户创建购买项目的方法，我们也为我们的客户提供了一个放置所选项目的袋子。然而，我们缺少一种让我们的客户能够将项目添加到购物车中的方法。
- en: 'In the object-oriented approach to solving this problem, we could add a method
    called `addItem(ShoppingItem shoppingItem)`:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在面向对象的方法中解决这个问题时，我们可以添加一个名为`addItem(ShoppingItem shoppingItem)`的方法：
- en: '[PRE14]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Looking at this solution from an FP approach, we can already see that it will
    modify the collection. This is something that we're desperately trying to avoid
    as multiple people will be working on this shopping cart at the same time. In
    this case, using the `final` keyword has no impact since the contents of a final
    list can still change. One basic approach to solving this in a functional way
    is to return a new `ShoppingCart` when adding an item.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从函数式编程的角度来看这个解决方案，我们可以看到它将修改集合。这是我们极力避免的事情，因为多人将同时在这个购物车上工作。在这种情况下，使用`final`关键字没有影响，因为final列表的内容仍然可以改变。解决这个问题的基本方法之一是在添加项目时返回一个新的`ShoppingCart`对象。
- en: 'Add a new constructor to the `ShoppingCart` class and let it take a list as
    an argument. Then, pass this list to `mShoppingList` of the `ShoppingCart` class
    and make it unmodifiable with the `Collections.unmodifiableList()` method:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`ShoppingCart`类添加一个新的构造函数，并让它接受一个列表作为参数。然后，将这个列表传递给`ShoppingCart`类的`mShoppingList`，并使用`Collections.unmodifiableList()`方法使其不可修改：
- en: '[PRE15]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Rewrite the `addItem(ShoppingItem item)` method and let it return a new `ShoppingCart`
    item instead of `void`. Copy the list of the previous `ShoppingCart` items into
    a temporary list and add another item to it. Then, pass this temporary list to
    the constructor and return the newly created `ShoppingCart` object:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`addItem(ShoppingItem item)`方法，让它返回一个新的`ShoppingCart`项目而不是`void`。将上一个`ShoppingCart`项目的列表复制到一个临时列表中，并添加另一个项目。然后，将这个临时列表传递给构造函数，并返回新创建的`ShoppingCart`对象：
- en: '[PRE16]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this code, we can see that the constructor now accepts a list of `ShoppingItem`
    classes; we can also see that the list is directly saved as an unmodifiable list.
    This is a special type of list in Java—one that throws an exception whenever you
    attempt to modify it in any way, either directly or through its iterator.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此代码中，我们可以看到构造函数现在接受`ShoppingItem`类的一个列表；我们还可以看到列表被直接保存为一个不可修改的列表。这是Java中的一种特殊列表——在您尝试以任何方式直接或通过其迭代器修改它时，它会抛出异常。
- en: We can also see that the `addItem(ShoppingItem item)` function now returns a
    new `ShoppingCart`, with a whole new list, but with the items from the previous
    shopping list shared between the two `ShoppingCart` instances. This is an acceptable
    solution even for a multithreaded environment as the `ShoppingItem` classes are
    final and, therefore, may never change their state.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还可以看到，`addItem(ShoppingItem item)`函数现在返回一个新的`ShoppingCart`，包含全新的列表，但两个`ShoppingCart`实例之间共享了之前的购物列表中的项目。这对于多线程环境来说是一个可接受的解决方案，因为`ShoppingItem`类是最终的，因此它们的状态可能永远不会改变。
- en: Note
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Java 8 introduced the Stream API, which was a whole new way of working with
    collections, that is, a more FP-based approach. You can read more about the Stream
    API in *Chapter 15*, *Processing Data with Streams*. In this chapter, we'll focus
    on solutions that don't use the Stream API.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Java 8引入了Stream API，这是一种全新的处理集合的方式，即更基于函数式编程的方法。您可以在第15章“使用Stream处理数据”中了解更多关于Stream
    API的信息。在本章中，我们将关注不使用Stream API的解决方案。
- en: 'Now you need to use this new `ShoppingCart` in a program. Edit your `main`
    method, and then let it create an empty `ShoppingCart` first. Then, add a new
    shopping item to that cart, storing the newly created `ShoppingCart` in another
    variable. Finally, add another `ShoppingItem` to the second `ShoppingCart`, again
    storing the new `ShoppingCart` in a new variable:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您需要在程序中使用这个新的`ShoppingCart`。编辑您的`main`方法，然后先创建一个空的`ShoppingCart`。然后，向该购物车添加一个新的购物项，并将新创建的`ShoppingCart`存储在另一个变量中。最后，向第二个`ShoppingCart`添加另一个`ShoppingItem`，再次将新的`ShoppingCart`存储在新的变量中：
- en: '[PRE17]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Place a breakpoint on the last line and debug your code. You'll notice the carts
    that are created when calling `addItem` maintain their own unmodifiable list of
    `ShoppingItem`, but the immutable `ShoppingItem` are shared across the lists.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一行设置断点并调试您的代码。您会注意到在调用`addItem`时创建的购物车维护着自己的不可修改的`ShoppingItem`列表，但不可变的`ShoppingItem`在列表之间是共享的。
- en: The `Collections.unmodifiableList()` method and other similar methods (such
    as `Set`, `Map`, and `SortedList`) are not providing any immutability to the list
    itself. They produce a view of the list that prohibits any change. However, anyone
    with a reference to the actual list will still be able to change the data.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collections.unmodifiableList()`方法和其他类似方法（如`Set`、`Map`和`SortedList`）并没有为列表本身提供任何不可变性。它们产生了一个禁止任何更改的列表视图。然而，任何拥有实际列表引用的人仍然能够更改数据。'
- en: In this exercise the lists are safe as the `main` method doesn't keep any reference
    to the lists, so no one outside can change it. However, this is not the recommended
    path when attempting to implement a program using a functional approach; don't
    trust anyone to follow rules unless they strictly must. Since Java 9, there are
    now real immutable collections that are available.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，列表是安全的，因为`main`方法没有保留任何对列表的引用，所以没有人可以从外部更改它。然而，当尝试使用函数式方法实现程序时，这不是推荐的方法；除非他们必须严格遵循规则，否则不要相信任何人。自Java
    9以来，现在有真正的不可变集合可用。
- en: 'Activity 1: Modifying Immutable Lists'
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动一：修改不可变列表
- en: 'Add a new behavior to your `ShoppingCart`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 向您的`ShoppingCart`添加一个新的行为：
- en: Create a `removeItem(ShoppingItem)` function.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`removeItem(ShoppingItem)`函数。
- en: Create a function that takes multiple `ShoppingItem` as arguments, either as
    a list or as variable arguments.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，该函数接受多个`ShoppingItem`作为参数，可以是列表或可变参数。
- en: Modify your `ShoppingCart` to take multiple items of each `ShoppingItem`—for
    example, four chairs and one table. Additionally, modify the `addItem(ShoppingItem)`
    and `removeItem(ShoppingItem)` functions.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改您的`ShoppingCart`以接受每个`ShoppingItem`的多个项目——例如，四把椅子和一张桌子。此外，修改`addItem(ShoppingItem)`和`removeItem(ShoppingItem)`函数。
- en: Note
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 561.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第561页找到。
- en: Immutable Collections
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变集合
- en: 'Using `Collections.unmodifiableList` is a quick way to provide an unmodifiable
    version of an existing list. Another option available since Java 9 is to use the
    immutable collections with factory methods. These factory methods allow you to
    create three different immutable collection types: `List`, `Set`, and `Map`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Collections.unmodifiableList` 是提供现有列表不可修改版本的一种快速方法。自 Java 9 以来，另一个选项是使用具有工厂方法的不可变集合。这些工厂方法允许您创建三种不同的不可变集合类型：`List`、`Set`
    和 `Map`。
- en: Note
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are a few libraries that provide more optimized immutable collections;
    one popular example is Guava with its `ImmutableArrayList` and other types.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个库提供了更优化的不可变集合；一个流行的例子是 Guava，它有 `ImmutableArrayList` 和其他类型。
- en: 'If we were to use the `List` factory methods instead of the `Collections` class
    in our shopping cart, it could look something like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `List` 工厂方法而不是 `Collections` 类来处理购物车，它可能看起来像这样：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we can see that there's very little difference to what we had before.
    Instead of using `Collections.unmodifiableList()` to create an unmodifiable view
    of the list, we create an immutable copy of this list with `List.copyOf()`. The
    difference in our example is invisible for the user. However, at the bottom, they're
    based on different implementations—the `UnmodifiableCollection` and `ImmutableCollections`
    classes, respectively.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到与我们之前所拥有的几乎没有区别。我们不是使用 `Collections.unmodifiableList()` 来创建列表的不修改视图，而是使用
    `List.copyOf()` 创建此列表的不可变副本。在我们的例子中，对用户来说这种差异是看不见的。然而，在底层，它们基于不同的实现——分别是 `UnmodifiableCollection`
    和 `ImmutableCollections` 类。
- en: 'Exercise 3: Overriding the String Method'
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3：重写 String 方法
- en: 'In this exercise, we''ll make a small technical proof of the difference between
    `UnmodifiableCollection` and `ImmutableCollection` classes. For this example,
    we''ll need to override the `toString()` method for the `ShoppingItem` and `ShoppingCart`
    classes:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将做一个小的技术证明，说明 `UnmodifiableCollection` 和 `ImmutableCollection` 类之间的差异。为此，我们需要重写
    `ShoppingItem` 和 `ShoppingCart` 类的 `toString()` 方法：
- en: 'Add the `toString()` method to the `ShoppingItem` class, and then let it return
    the name:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `toString()` 方法添加到 `ShoppingItem` 类中，然后让它返回名称：
- en: '[PRE19]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the `toString()` method to the `ShoppingCart` class. Then, let it return
    a concatenated string for all the `ShoppingItem` in the list:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `toString()` 方法添加到 `ShoppingCart` 类中。然后，让它返回列表中所有 `ShoppingItem` 的连接字符串：
- en: '[PRE20]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we have a simple way of printing the contents of a `ShoppingCart` using
    the `toString()` method. To demonstrate the difference, replace the code in the
    `main` method. Add a few books to a standard list, and then copy this list into
    an unmodifiable version and an immutable version. Print the two copies:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有一个简单的方法来使用 `toString()` 方法打印 `ShoppingCart` 的内容。为了展示差异，替换 `main` 方法中的代码。向标准列表中添加几本书，然后将此列表复制到一个不可修改的版本和一个不可变版本。打印这两个副本：
- en: '[PRE21]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now remove the first item, the `Java Fundamentals` book, from the original
    `books` list and print the two copies again:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在从原始的 `books` 列表中移除第一个项目，即《Java基础知识》这本书，然后再次打印这两个副本：
- en: '[PRE22]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This simple example provides proof of the difference between an unmodifiable
    view and an immutable copy. In the unmodifiable version, the list can still be
    changed, and the unmodifiable view will pick up on that change, whereas the immutable
    version will ignore that change because it contains a new list of items.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子提供了不可修改视图和不可变副本之间差异的证明。在不可修改版本中，列表仍然可以被更改，并且不可修改视图将捕捉到这种更改，而不可变版本将忽略这种更改，因为它包含了一个新的项目列表。
- en: Functional Interfaces
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能接口
- en: Functional interfaces are declared as standard Java interfaces, except they're
    only allowed to contain one abstract function, but can contain any number of default
    or static functions.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 功能接口被声明为标准的 Java 接口，除了它们只能包含一个抽象函数，但可以包含任意数量的默认或静态函数。
- en: The `Comparator` interface is one of the older interfaces of Java. It has been
    with us since version 1.2 and has seen many several over the years. However, the
    biggest change yet is probably the move to become a functional interface in Java
    8.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`Comparator` 接口是 Java 中较老的接口之一。它自 1.2 版本以来一直伴随着我们，并且多年来经历了许多变化。然而，迄今为止最大的变化可能是
    Java 8 中将其转变为功能接口。'
- en: 'Reviewing the changes on the `Comparator` interface in Java 8, you''ll notice
    some interesting changes. First, the interface has grown from 4 lines of code
    to 80 lines, excluding package declaration and comments. Then, you''ll notice
    that there''s a new annotation at the top:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾 Java 8 中 `Comparator` 接口的变化，你会注意到一些有趣的变化。首先，接口从 4 行代码增长到 80 行，不包括包声明和注释。然后，你会注意到顶部有一个新的注解：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This annotation marks that this is now a functional interface. Its main purpose
    is to tell the reader that this interface is intended to follow the functional
    interfaces specification as defined in Java 8\. If it fails to follow those guidelines,
    the Java compiler should print an error.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个注解标记表明这是一个功能接口。它的主要目的是告诉读者，这个接口的目的是遵循 Java 8 中定义的功能接口规范。如果它未能遵循这些指南，Java 编译器应该打印出一个错误。
- en: After the two original abstract function declarations, you'll find no less than
    seven default functions. These default functions were introduced in Java 8 to
    add new functionality to interfaces without breaking backward compatibility. The
    default functions are always public and will always contain a code block. They
    can return a value, but this is not required by the specification.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个原始的抽象函数声明之后，你会发现至少有七个默认函数。这些默认函数是在 Java 8 中引入的，目的是在不破坏向后兼容性的情况下向接口添加新功能。默认函数始终是公共的，并且总是包含一个代码块。它们可以返回一个值，但这不是规范所要求的。
- en: Finally, we'll find a total of nine `static` functions. Since Java 8, the functional
    interface can contain any number of `static` methods, they work very much like
    the static methods found in normal classes. You will explore more details about
    building and using functional interfaces in a later chapter in this book.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将找到总共九个 `static` 函数。自从 Java 8 以来，函数式接口可以包含任意数量的 `static` 方法，它们与普通类中找到的静态方法非常相似。你将在本书的后续章节中了解更多关于构建和使用函数式接口的细节。
- en: Lambda Expressions
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda 表达式
- en: Along with the functional improvements in Java 8, there also came `Lambda` expressions.
    One of the primary improvements with lambdas is the code readability—most of the
    boilerplate code for interfaces is now gone.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Java 8 中功能性的改进，也出现了 `Lambda` 表达式。Lambda 的一大主要改进是代码可读性——接口的大多数样板代码现在都不见了。
- en: 'A very commonly used interface is the **Runnable interface**; it''s used in
    multithreaded applications to perform any type of task in the background, such
    as downloading a large file from a network. In Java 7 and earlier versions, you''d
    often see the Runnable interface used as an anonymous instance:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常用的接口是 **Runnable 接口**；它在多线程应用程序中用于在后台执行任何类型的任务，例如从网络下载大文件。在 Java 7 及更早版本中，你经常看到
    Runnable 接口被用作匿名实例：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Since Java 8, the preceding five lines of code can now be simplified by using
    a lambda expression instead:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 Java 8 以来，前面的五行代码现在可以通过使用 lambda 表达式来简化：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, the code becomes much more readable when we remove a lot of
    the boilerplate code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当我们移除大量样板代码时，代码的可读性变得更高。
- en: 'The lambda expression consists of two main components: the arguments and the
    body. Additionally, between these two components, there is always an arrow operator
    (which is also known as a lambda operator). The body also contains the optional
    return value. The parentheses contain the optional arguments for the lambda expression.
    Because it''s an FP component, though, you''ll want to use arguments:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式由两个主要部分组成：参数和主体。此外，在这两个部分之间，始终有一个箭头操作符（也称为 lambda 操作符）。主体还包含可选的返回值。括号包含
    lambda 表达式的可选参数。尽管它是一个函数式编程组件，但你仍然会想使用参数：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can also omit the type of the arguments as those will be inferred by the
    functional interface that the lambda expression implements:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以省略参数的类型，因为它们将由 lambda 表达式实现的函数式接口推断出来：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you have only one argument, you can omit the parentheses:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只有一个参数，你可以省略括号：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'However, if you have no arguments in your lambda, then you must include the
    parentheses:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你的 lambda 没有参数，那么你必须包含括号：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then there is the function body; if you have many lines of code in your lambda
    logic, you must use the curly brackets to enclose the body:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是函数主体；如果你在 lambda 逻辑中有许多行代码，你必须使用花括号来包围主体：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'However, if you only have one single line of code, you can omit the curly brackets
    and immediately return the value:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你只有一行代码，你可以省略花括号，并立即返回值：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, you can also omit the `return` keyword if all you have is a single
    line of code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你只有一行代码，也可以省略 `return` 关键字：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we were to write the lambda calculus identity function in Java, assuming
    we have a functional interface called `Identity`, it would look something like
    this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要在 Java 中编写 lambda 算法的恒等函数，假设我们有一个名为 `Identity` 的函数式接口，它看起来可能像这样：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: One commonly used interface is the `Comparator` interface, which is used in
    almost any object you wish to order, specifically in a collection of some form.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常用的接口是 `Comparator` 接口，它用于几乎任何需要排序的对象，特别是在某些形式的集合中。
- en: 'Exercise 4: Listing Spare Tires'
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4：列出备用轮胎
- en: A racing team has contacted you to organize their stock of spare tires because
    it's in a mess. They've asked you to write an application that will show the list
    of available tires in order of size, starting with the biggest tire.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一支赛车队联系了你，希望你能组织他们的备用轮胎库存，因为它们现在一团糟。他们要求你编写一个应用程序，以按大小顺序显示可用的轮胎列表，从最大的轮胎开始。
- en: 'To do this, you''ll build a lambda function that implements the `Comparator`
    functional interface. For reference, this is the base view of the `Comparator`
    interface, excluding the default and static functions:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，你需要构建一个实现 `Comparator` 函数式接口的 lambda 函数。为了参考，这是 `Comparator` 接口的基本视图，不包括默认和静态函数：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the `Project` pane in IntelliJ, right-click on the folder named `src`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 IntelliJ 的 `Project` 面板中，右键单击名为 `src` 的文件夹。
- en: Choose `New` -> `Java Class` in the menu, and then enter `Exercise4`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在菜单中选择 `New` -> `Java Class`，然后输入 `Exercise4`。
- en: 'Define the `main` method in your new class:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的新类中定义 `main` 方法：
- en: '[PRE35]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create a new inner class called `Tire`. It should have a size variable that
    is the diameter of the tire in inches. Make sure that the class and size are declared
    as `final` to adhere to the FP guidelines:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Tire` 的新内部类。它应该有一个名为 `size` 的变量，表示轮胎的直径（单位为英寸）。确保将类和大小声明为 `final` 以符合
    FP 指南：
- en: '[PRE36]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Create the `Tire` constructor, taking one argument—the `size`—and passing that
    to the member variable. Additionally, override the `toString()` method to print
    the size of the tire:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `Tire` 构造函数，接受一个参数——`size`，并将其传递给成员变量。此外，重写 `toString()` 方法以打印轮胎的大小：
- en: '[PRE37]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create a list of tires that need to be sorted into your `main` method:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `main` 方法中创建一个需要排序的轮胎列表：
- en: '[PRE38]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Create the actual lambda expression, using the `Comparator` functional interface,
    that you will use to sort the immutable list of tires. It should take two arguments,
    and return the difference in size. Remember that the lambda expression infers
    a lot of the structure; you won''t need to specify the types or return a keyword
    in this simple example. The lambda expression is a first-class citizen, so it''s
    fine to store it in a variable for later use:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建实际的 lambda 表达式，使用 `Comparator` 函数式接口，这将用于对不可变轮胎列表进行排序。它应该接受两个参数，并返回大小差异。记住，lambda
    表达式推断了很多结构；在这个简单的例子中，你不需要指定类型或返回关键字。lambda 表达式是一等公民，因此可以将其存储在变量中以供以后使用：
- en: '[PRE39]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You can, of course, also apply the lambda expression as an anonymous instance—that
    way, you can save a few lines of code while keeping the code very readable.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然，你也可以将 lambda 表达式作为匿名实例应用——这样，你可以节省几行代码，同时保持代码的可读性。
- en: 'Apply the lambda expression in the `sort` method. The `List.sort()` method
    modifies the content of the list, so you need to copy your immutable list of tires
    before sorting it:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `sort` 方法中应用 lambda 表达式。`List.sort()` 方法会修改列表的内容，因此排序之前需要复制你的不可变轮胎列表：
- en: '[PRE40]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, print the result:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打印结果：
- en: '[PRE41]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To make this program functional, you could move the sorting intelligence to
    a pure function that takes a list as an argument, then performs the sorting on
    a copy of that list and returns the immutable sorted list. This way, you will
    avoid keeping a reference of the mutable list in your main program:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使这个程序具有函数式特性，可以将排序智能移动到一个纯函数，该函数接受一个列表作为参数，然后在列表的副本上进行排序，并返回不可变的排序列表。这样，你将避免在主程序中保留可变列表的引用：
- en: '[PRE42]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You've just created your first lambda expression, based on an already present
    `Functional` interface, and you've then used it to sort a list of tires. There
    are lots of functional interfaces available since Java 8, and you've probably
    already been using most of them; we'll explore this in more detail later in the
    book.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚创建了一个基于现有 `Functional` 接口的第一个 lambda 表达式，然后使用它对轮胎列表进行排序。自从 Java 8 以来，有很多函数式接口可用，你可能已经使用过其中大部分；我们将在本书的后面更详细地探讨这一点。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: It shouldn't matter the order in which different threads act on your data, and
    you should be able to easily add functionality that doesn't affect older parts
    of your application. Following these FP concepts allows you to build code that
    can easily be used in multithreaded applications, as well as to build code that
    can be tested very easily for problems and regression bugs. It also often makes
    your code much more readable.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 不同线程对你的数据执行操作的顺序不应该很重要，你应该能够轻松地添加不会影响应用程序旧部分的功能。遵循这些FP概念可以使你构建的代码容易在多线程应用程序中使用，以及构建可以非常容易地测试问题的回归错误。这通常也使你的代码更加易于阅读。
- en: Using the core concepts of FP that you've learned about in this chapter—pure
    functions and immutability—can lead to performance issues in some cases, specifically
    when modifying large datasets. There are ways to get around these, as we'll explore
    in later chapters.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你在本章中学到的FP（函数式编程）的核心概念——纯函数和不可变性——在某些情况下可能会导致性能问题，特别是在修改大型数据集时。我们将在后面的章节中探讨解决这些问题的方法。
- en: Because Java was designed for an OOP approach, it can be a bit daunting to get
    into FP at first, but if you "go functional" in only certain parts of your code,
    the transition from OOP may become easier.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Java是为面向对象的方法设计的，因此一开始进入FP（函数式编程）可能会有些令人畏惧，但如果你只在代码的某些部分“采用函数式”，那么从OOP（面向对象编程）的过渡可能会变得更容易。
- en: In the next chapter, we'll focus on how to navigate larger datasets and repeat
    code without using loops.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将关注如何在不使用循环的情况下导航更大的数据集并重复代码。
