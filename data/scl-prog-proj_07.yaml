- en: Online Shopping - REST API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在线购物 - REST API
- en: In this chapter, we will explain how to develop a REST API using Play Framework.
    **API** is an acronym for **Application Programming Interface**. The **REST**
    acronym stands for **Representational State Transfer**. Basically, we will provide
    an interface for our application, so that other programs can interact with it.
    REST is an architectural pattern that will guide us in designing our API.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释如何使用Play框架开发REST API。**API**是**应用程序编程接口**的缩写。**REST**的缩写代表**表示性状态转移**。基本上，我们将为我们的应用程序提供一个接口，以便其他程序可以与之交互。REST是一种架构模式，它将指导我们设计我们的API。
- en: Typically, a program calling our API will be a user interface running in a browser,
    which we will implement in the next chapter. It could also be another backend
    application, which could be from another program, and so on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，调用我们的API的程序将是一个在浏览器中运行的用户界面，我们将在下一章中实现它。它也可能是另一个后端应用程序，这可能来自另一个程序，等等。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: REST principles
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST原则
- en: Implementing the API with persistence
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现具有持久性的API
- en: Swagger
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swagger
- en: Deploying on Heroku
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Heroku上部署
- en: The REST API
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST API
- en: 'The objective of the REST API is to interact with the shopping cart from the
    user interface in the browser. The main interactions are as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: REST API的目标是从浏览器中的用户界面与购物车进行交互。主要交互如下：
- en: Creating the cart
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建购物车
- en: Adding, removing, and updating products in the cart
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在购物车中添加、删除和更新产品
- en: We will design our API by following REST architecture principles which was defined
    in 2000, by Roy Fielding.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循2000年由Roy Fielding定义的REST架构原则来设计我们的API。
- en: A formal description of the REST API can be found in *Fielding Dissertation,
    CHAPTER 5, Representational State Transfer (REST)*, at [http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm](http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在*Fielding论文，第5章，表示性状态转移（REST）*中找到REST API的正式描述，[http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm](http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm)。
- en: 'The main principles of the architecture are as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 架构的主要原则如下：
- en: It is based on client-server architecture, which means that a server can serve
    multiple clients.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它基于客户端-服务器架构，这意味着服务器可以为多个客户端提供服务。
- en: It should be stateless—the server should not keep any context between client
    calls. The context should be kept by the client. All of the information required
    for the processing on the server should be part of the message sent.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该是无状态的——服务器不应该在客户端调用之间保持任何上下文。上下文应由客户端保持。服务器上处理所需的所有信息都应包含在发送的消息中。
- en: As no context is kept on the server, it should be possible to cache responses
    at the server level.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于服务器上没有保持上下文，因此可以在服务器级别缓存响应。
- en: Each resource on the system should be identified uniquely. Since our resources
    are web resources, we use a **Uniform Resource Identifier (URI)** for that purpose.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统上的每个资源都应该具有唯一的标识。由于我们的资源是网络资源，我们为此目的使用**统一资源标识符（URI）**。
- en: 'Keeping all of the preceding in mind, let''s design our API. In [Chapter 6](3faf4d15-9055-4617-af6b-d0b6cc17bc71.xhtml), *Online
    Shopping – Persistence*, two tables where defined:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到上述所有内容，让我们设计我们的API。在[第6章](3faf4d15-9055-4617-af6b-d0b6cc17bc71.xhtml)“在线购物——持久性”中，定义了两个表：
- en: The cart
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购物车
- en: The product
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品
- en: Intuitively, in this chapter, we will keep these two objects to design our API.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地，在本章中，我们将保持这两个对象来设计我们的API。
- en: 'For the cart, we would like to perform the following actions:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于购物车，我们希望执行以下操作：
- en: Add a product
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加产品
- en: Delete a product
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除产品
- en: Update the quantity of a product
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新产品数量
- en: Get a list of products in the cart
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取购物车中的产品列表
- en: 'For the product, we would like to perform the following actions:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于产品，我们希望执行以下操作：
- en: List the products
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出产品
- en: Add a product
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加产品
- en: Writing the tests
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试
- en: First, let's write the tests. We will create one test per API call, to cover
    all the cases. By doing so, we are going to define the URI for each case. All
    of the test implementations will be grouped in a test class; let's call it `APISpec`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们编写测试。我们将为每个API调用创建一个测试，以覆盖所有情况。通过这样做，我们将为每个情况定义URI。所有测试实现都将分组在一个测试类中；让我们称它为`APISpec`。
- en: 'We can create the class and define the URLs of our API; at this point, the `APISpec` class
    should be as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建类并定义API的URL；在这个时候，`APISpec`类应该如下所示：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As in `DatabaseSpec`, we extend the ScalaTest integration class, `PlaySpec`,
    as well as a Play server, `GuiceOneServerPerSuite`, and define all of the URLs
    required. We defined the `wsClient` value, a helper from Play, to define a web
    service client.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与`DatabaseSpec`一样，我们扩展了ScalaTest集成类`PlaySpec`以及一个Play服务器`GuiceOneServerPerSuite`，并定义了所有所需的URL。我们定义了`wsClient`值，这是一个来自Play的帮助器，用于定义一个Web服务客户端。
- en: 'We will start with a test of the product API, and, more precisely, with the
    list of products. The test is as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个产品API的测试开始，更具体地说，是从产品列表开始。测试如下：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`WSClient` is a convenient class to perform a REST call; we just need to set
    the URL and call the HTTP method.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`WSClient`是一个方便的类，用于执行REST调用；我们只需要设置URL并调用HTTP方法。'
- en: 'Let''s define the `add a product` case, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义`添加产品`的情况，如下所示：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: First, we define the new product to insert. Notice that we are using a string
    representation of the new product, using the JSON format. We could have defined
    it as an object, but that will be covered later in this chapter. To add something
    to the database, we are using the `HTTP POST` method.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义要插入的新产品。请注意，我们正在使用JSON格式的字符串表示新产品的形式。我们本来可以将其定义为对象，但这一点将在本章后面进行说明。为了向数据库添加内容，我们使用`HTTP
    POST`方法。
- en: 'We are now done with the product section. Now, we need to add new tests for
    listing all of the products in a cart, adding a product to the cart, deleting
    a product from the cart, and updating the quantity of a product in the cart. The
    corresponding unit tests are as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在完成了产品部分。现在，我们需要添加新的测试，用于列出购物车中的所有产品、向购物车添加产品、从购物车中删除产品以及更新购物车中产品的数量。相应的单元测试如下：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have defined basic tests for all of the functions. When we run `ApiSpec`,
    all of the tests will fail with the error `404 was not equal to 200`. This is
    expected, as no route has been defined in Play.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为所有函数定义了基本测试。当我们运行`ApiSpec`时，所有测试都将因为错误`404 was not equal to 200`而失败。这是预期的，因为在Play中没有定义任何路由。
- en: Defining the routes
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义路由
- en: 'We define all of the URLs of our API in the `config/routes` file. In this file,
    we define the mapping between the URL and the code. In our example, the file looks
    as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`config/routes`文件中定义了我们API的所有URL。在这个文件中，我们定义了URL和代码之间的映射。在我们的例子中，文件如下所示：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For more clarity, we squeezed the `controllers.WebServices` package to `W`,
    to fit the page width.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清晰，我们将`controllers.WebServices`包压缩为`W`，以适应页面宽度。
- en: For each line, if it starts with `#`, the line is a comment; otherwise, the
    first column defines the HTTP action to perform, followed by the context URL.
    Finally, the last column is the method to call with the parameters, if any.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一行，如果它以`#`开头，则该行是注释；否则，第一列定义要执行的HTTP操作，后面跟着上下文URL。最后，最后一列是带有参数（如果有）要调用的方法。
- en: At the URL level, you can use the wildcard, `:`, to define a variable in the
    path; this variable can be used in the method call. For example, the `id` variable
    is defined in the `cart/products/:id` path, and then used in the `controllers.Cart.deleteProduct(id)`
    method call.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在URL级别，你可以使用通配符`:`来在路径中定义一个变量；这个变量可以在方法调用中使用。例如，`id`变量在`cart/products/:id`路径中定义，然后在`controllers.Cart.deleteProduct(id)`方法调用中使用。
- en: We have now defined the route that Play is going to create; the next step is
    to define the methods defined in this routing file.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经定义了Play将要创建的路由；下一步是定义这个路由文件中定义的方法。
- en: 'To do so, create a new file, named `WebServices`, in the `controllers` folder.
    In this file, the implementation is as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，在`controllers`文件夹中创建一个名为`WebServices`的新文件。在这个文件中，实现如下：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We have defined all of the methods, but instead of coding the details of all
    of the implementations, we will set it to `play.mvc.Results.TODO`. At that point,
    we can try to run the test, to make sure that we do not have any compilation errors.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了所有方法，但不是编写所有实现的详细信息，我们将它设置为`play.mvc.Results.TODO`。在那个点上，我们可以尝试运行测试，以确保我们没有任何编译错误。
- en: Running the test
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行测试
- en: When running the test, `APISpec`, you should not get 404 errors anymore. However,
    the tests should now fail with the error 501 was not equal to 200.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行测试`APISpec`时，你不再应该遇到404错误。然而，现在测试应该会因为错误`501 was not equal to 200`而失败。
- en: This is expected. The server can now find the URL mapping for our REST calls,
    but in our code, all methods are implemented with `play.mvc.Results.TODO`. This
    special return value makes the server return the HTTP status error code 501.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是预期的。服务器现在可以找到我们REST调用的URL映射，但在我们的代码中，所有方法都是用`play.mvc.Results.TODO`实现的。这个特殊的返回值使服务器返回HTTP状态错误代码501。
- en: What have we achieved? Well, Play is serving all of the URLs of our API. For
    each of them, it calls the associated method, and returns an error code instead
    of the real implementation!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们取得了什么成果？嗯，Play正在为我们API的所有URL提供服务。对于每一个，它调用相关的方法，并返回一个错误代码而不是实际的实现！
- en: Checking the API
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查API
- en: At this point, it might be interesting to introduce external tools to check
    the API.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，引入外部工具来检查API可能很有趣。
- en: Indeed, these tools are widely used and can make your life easier, especially
    when you want to explain it to someone or perform multiple calls on a different
    server.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，这些工具被广泛使用，可以使你的生活更轻松，特别是当你想向某人解释它或在不同的服务器上执行多个调用时。
- en: 'These tools are as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具如下：
- en: '**Paw**: This is a paid tool and only works on macOS. You can look upon it
    at [https://paw.cloud/](https://paw.cloud/).'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Paw**：这是一个付费工具，仅适用于macOS。您可以在[https://paw.cloud/](https://paw.cloud/)查看它。'
- en: '**Postman**: This is a free and multiplatform application. Postman is a Google
    Chrome extension. You can look upon it at [https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=en](https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=en).'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**邮差**：这是一个免费的多平台应用程序。邮差是一个谷歌Chrome扩展。您可以在[https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=en](https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=en)查看它。'
- en: 'Once one of these tools installed, start the project in IntelliJ, and then
    browse to, for example, `http://localhost:9000/cart/products`. You should receive
    the error 501 Not Implemented:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了这些工具之一，就在IntelliJ中启动项目，然后浏览到，例如，`http://localhost:9000/cart/products`。你应该会收到错误501
    Not Implemented：
- en: '![](img/e33a3eec-e74b-4a1a-a570-de1cd9fae4ac.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e33a3eec-e74b-4a1a-a570-de1cd9fae4ac.png)'
- en: Observe the error in the TODO section
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 观察TODO部分中的错误
- en: All of the defined URLs will have the same behavior.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的定义URL都将具有相同的行为。
- en: The advantage of this tool is that you can see all of the details of the request
    and the response. It is very useful to understand the HTTP protocol with all of
    the headers, URL parameters, and so on.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具的优势在于你可以看到请求和响应的所有细节。这对于理解带有所有头信息、URL参数等的HTTP协议非常有用。
- en: Implementing the API with persistence
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用持久性实现API
- en: In this chapter, we created the route for the API without an implementation.
    In the previous chapter, [Chapter 6](3faf4d15-9055-4617-af6b-d0b6cc17bc71.xhtml), *Online
    Shopping – Persistence*, we created the database to persist the carts. It is now
    time to bind the API with the persistence.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们创建了没有实现的API路由。在前一章，[第6章](3faf4d15-9055-4617-af6b-d0b6cc17bc71.xhtml)，“在线购物
    – 持久性”中，我们创建了数据库以持久化购物车。现在是时候将API与持久性绑定在一起了。
- en: Completing the product tests
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成产品测试
- en: 'We want to check not only the HTTP status but the content received back; for
    example, for the list of products, we would like to make sure that we are receiving
    all of the default products:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅想检查HTTP状态，还想检查返回的内容；例如，对于产品列表，我们想确保我们收到了所有默认产品：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this test, we look at the body of the response and make sure that the three
    default products are present.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们查看响应体并确保存在三个默认产品。
- en: 'Similarly, to check the `add a product` function, we first add the product,
    and then call the list of products:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，为了检查“添加产品”功能，我们首先添加产品，然后调用产品列表：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Implementing the product API
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现产品API
- en: All of the tests are ready, so let's implement the API for all the methods.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试都已准备就绪，因此让我们为所有方法实现API。
- en: Product list
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品列表
- en: The first method that we are going to implement is the list of products. As
    you will remember from [Chapter 6](3faf4d15-9055-4617-af6b-d0b6cc17bc71.xhtml), *Online
    Shopping – Persistence*, we created a list of default products upon the creation
    of the application. Hence, our first task will be to get these products and send
    them back as JSON objects.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的第一种方法是产品列表。正如你从[第6章](3faf4d15-9055-4617-af6b-d0b6cc17bc71.xhtml)，“在线购物
    – 持久性”中记得的那样，我们在创建应用程序时创建了一个默认产品列表。因此，我们的第一个任务将是获取这些产品并将它们作为JSON对象发送回去。
- en: 'As we have already written a data access layer, the extraction from the database
    is pretty simple. Indeed, we just need to call the `all()` method from the product
    DAO instance, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经编写了数据访问层，从数据库中提取数据相当简单。实际上，我们只需要从产品 DAO 实例调用 `all()` 方法，如下所示：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `productDao.all()` method returns all of the products from the database
    as `Future[Seq[Product]]`. We can reuse what we learned in the previous chapter
    and use the `for` comprehension to extract, in the `products` variable, the sequence
    of products from `Future`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`productDao.all()` 方法返回数据库中的所有产品作为 `Future[Seq[Product]]`。我们可以重复使用上一章学到的知识，并使用
    `for` 理解从 `Future` 中提取 `products` 变量中的产品序列。'
- en: From the `products` variable, thanks to `.mkstring(",")`, we return a string
    with all of the products, separated by commas.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `.mkstring(",")`，我们从 `products` 变量返回一个包含所有产品的字符串，产品之间用逗号分隔。
- en: But we are not quite done yet. We mentioned that we would like to return a JSON
    representation of this sequence of products. Therefore, we need some mechanism
    to transform our case class instances into JSON.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们还没有完成。我们提到过，我们希望返回这个产品序列的 JSON 表示形式。因此，我们需要某种机制将我们的案例类实例转换为 JSON。
- en: We could improve the code and create it manually, but there are many good libraries
    that can help us to do it. It would be better to use one of them and reduce the
    boilerplate code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以改进代码并手动创建它，但有许多优秀的库可以帮助我们完成这项工作。最好使用其中之一，并减少样板代码。
- en: Encoding JSON with Circe
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Circe 编码 JSON
- en: There are many Scala libraries to manipulate JSON, so why did we choose Circe?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多 Scala 库可以操作 JSON，那么我们为什么选择 Circe 呢？
- en: Circe is a very clean JSON framework with good performance, but the real reason
    we have chosen it is that Circe provides a complete documentation, with an explanation
    of all of the principles used to play with JSON. Circe uses Cats underneath, which
    we used in [Chapter 3](f7fa24eb-8f31-4201-ba7c-c1e32518df8b.xhtml), *Handling
    Errors*. Cats is a library from Typelevel. Typelevel is a community that is extremely
    kind to newcomers in functional programming. It provides lots of great documentation;
    you can check it out at [https://typelevel.org/](https://typelevel.org/). In fact,
    if you wish to dig deeper into functional programming, this is the place to start!
    The downside of Circe is the number of transitive dependencies; hence, it is fine
    to use it in a server application, but it might be a little heavy if you want
    a smaller footprint.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Circe 是一个非常干净的 JSON 框架，性能良好，但我们真正选择它的原因是 Circe 提供了完整的文档，其中解释了所有用于处理 JSON 的原则。Circe
    在底层使用 Cats，我们在[第 3 章](f7fa24eb-8f31-4201-ba7c-c1e32518df8b.xhtml)中使用了它，*处理错误*。Cats
    是来自 Typelevel 的库。Typelevel 是一个对函数式编程新入门者非常友好的社区。它提供了大量的优秀文档；您可以在[https://typelevel.org/](https://typelevel.org/)查看。实际上，如果您想深入了解函数式编程，这个地方是开始的地方！Circe
    的缺点是它的传递依赖项数量较多；因此，在服务器应用程序中使用它是可以的，但如果您想要更小的占用空间，它可能有点重。
- en: 'In order to integrate Circe with Play, we can use the integration done by Jilen
    at [https://github.com/jilen](https://github.com/jilen). We have already added
    the dependency to our template, but for reference, the following needs to be added
    to `libraryDependencies`, in `build.sbt`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 Circe 与 Play 集成，我们可以使用 Jilen 在[https://github.com/jilen](https://github.com/jilen)完成的集成。我们已经将依赖项添加到模板中，但为了参考，以下需要在
    `build.sbt` 中的 `libraryDependencies` 中添加：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, we need to add the `Circe` trait to our controller, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要将 `Circe` 特质添加到我们的控制器中，如下所示：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will import the required classes, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将导入所需的类，如下所示：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We are almost there; we need to replace `.mkstring(",")` with `.asJson`. That's it!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了；我们需要将 `.mkstring(",")` 替换为 `.asJson`。就这样！
- en: 'The final code is as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的代码如下：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now we can run `APISpec`; we should have your first working test for the API!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行 `APISpec`；我们应该有您为 API 编写的第一个工作测试了！
- en: Action definition
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作定义
- en: In the previous code, the `for` comprehension retrieves the products from the
    database and converts them to JSON. We are already familiar with this kind of
    syntax, but what about `Action.async` and `Ok()`?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`for` 理解从数据库中检索产品并将它们转换为 JSON。我们已经熟悉这种语法，但 `Action.async` 和 `Ok()` 呢？
- en: In Play, all of the `Action` elements are asynchronous. The expected return
    of an `Action` is a status, which represents the HTTP status code (`OK() = 200
    OK`, `Created() = 201 CREATED`, and so on).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Play 中，所有的 `Action` 元素都是异步的。`Action` 的预期返回值是一个状态，它表示 HTTP 状态码（`OK() = 200
    OK`，`Created() = 201 CREATED` 等）。
- en: As you may have noticed, the return type of the `for` comprehension is a status
    wrapped in `Future`. The `Action.async` helper function allows us to create an
    asynchronous `Action` from this `Future`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，`for`推导式的返回类型是包裹在`Future`中的状态。`Action.async`辅助函数允许我们从这个`Future`创建一个异步的`Action`。
- en: Adding a product
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加产品
- en: The next method to implement is the ability to add a product to the database.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个要实现的方法是将产品添加到数据库中的能力。
- en: If you are annoyed by the errors shown by IntelliJ when you start a new implementation,
    you can add a dummy return status.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你被启动新实现时IntelliJ显示的错误所烦恼，你可以添加一个虚拟返回状态。
- en: 'First, we will return a dummy status to avoid IntelliJ errors:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将返回一个虚拟状态以避免IntelliJ错误：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we will complete the implementation, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将完成实现，如下所示：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We expect to receive the new product details as a JSON payload in the body.
    Therefore, in the first line, we get the body as text; if it is not defined, we
    replace it with an empty string.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望在请求体中作为JSON有效载荷接收新产品详情。因此，在第一行，我们将请求体作为文本获取；如果它未定义，我们将其替换为空字符串。
- en: Circe provides a method, named `decode`, which takes a string as a parameter
    and transforms it into an object. The type parameter (`[Product]`, in our case)
    defines the class of the target object.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Circe提供了一个名为`decode`的方法，它接受一个字符串作为参数并将其转换为对象。类型参数（在我们的例子中是`[Product]`）定义了目标对象的类。
- en: This `decode` method returns an `Either` instance. If there is an error, it
    will be `Left`, and if the decoding works, it will be `Right`. We can pattern
    match on this `Either` value to return `Ok`; or, in the case of an error, to return
    a `BadRequest` status.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`decode`方法返回一个`Either`实例。如果有错误，它将是`Left`，如果解码工作正常，它将是`Right`。我们可以对这个`Either`值进行模式匹配以返回`Ok`；或者在错误的情况下返回`BadRequest`状态。
- en: When the decoding works, we call `productDao.insert` to store the new product
    in the database. If anything goes wrong during the insert, the `.recover` block
    will return an internal server error.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当解码工作正常时，我们调用`productDao.insert`将新产品存储到数据库中。如果在插入过程中发生任何错误，`.recover`块将返回内部服务器错误。
- en: Completing the cart test
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成购物车测试
- en: The first thing that we would like to do is test the list of products in the
    customer's cart. But how do we make sure that the customer can only see their
    cart and not somebody else's?
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先想做的事情是测试客户购物车中的产品列表。但我们如何确保客户只能看到他们的购物车，而不是别人的？
- en: Logging in
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录
- en: To solve this problem, we are going to add a `login` endpoint on the API. This
    endpoint will create a session cookie and will keep the session ID in it. This
    way, the session ID will be passed every time a request is sent to the server.
    The server will then be able to associate a session ID with a specific customer.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将在API上添加一个`login`端点。这个端点将创建一个会话cookie，并将会话ID存储在其中。这样，每次向服务器发送请求时，都会传递会话ID。然后服务器将能够将一个会话ID与一个特定的客户关联起来。
- en: Unit test
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: When the client calls the login URL, the server responds with a `Set-Cookie`
    header. In this header, the encrypted session data can be obtained by using the `PLAY_SESSION`
    key.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端调用登录URL时，服务器响应一个`Set-Cookie`头。在这个头中，可以通过使用`PLAY_SESSION`键来获取加密的会话数据。
- en: 'The following is the unit test for the new `login` endpoint:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对新`login`端点的单元测试：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The test sends a `POST` request to the `login` endpoint. For now, we send a
    dummy payload, `myID`, which represents a user identifier. Once posted, we map
    the returned response to get the `Set-Cookie` header. This `header` contains multiple
    values, separated by semicolons. We are not interested in the other values; hence,
    we need to process this `header` to get only the `PLAY_SESSION` cookie. To do
    so, we split on the semicolon and keep only the element starting with the `PLAY_SESSION` key.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 测试向`login`端点发送`POST`请求。目前，我们发送一个虚拟有效载荷`myID`，它代表一个用户标识符。一旦发布，我们将返回的响应映射以获取`Set-Cookie`头。这个`header`包含多个值，由分号分隔。我们不对其他值感兴趣；因此，我们需要处理这个`header`以获取只有以`PLAY_SESSION`键开始的元素。
- en: We assign this transformed response to a value: `cookieFuture`. We then wait
    for `Future` to complete; then, the response is split on `=`, and only the key
    is kept and checked.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将转换后的响应分配给一个值：`cookieFuture`。然后我们等待`Future`完成；然后，响应在`=`上分割，只保留键并检查。
- en: You can run the test now; it should fail, with a 404 Not Found error.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以运行测试；它应该失败，显示404 Not Found错误。
- en: Implementation
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: 'First, we need to add the new endpoint to the `routes` file, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将新端点添加到`routes`文件中，如下所示：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With this new entry, Play reacts to the `POST` action and calls the `login`
    method of the `Webservices` class.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个新条目，Play会对`POST`动作做出反应，并调用`Webservices`类的`login`方法。
- en: 'The implementation of this `login` method is as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`login`方法的实现如下：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If a body with the username is present, the `OK` status is returned, with a
    new session cookie. The username is added in the cookie, with the `user` key,
    and can be retrieved on a subsequent request.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在具有用户名的主体，则返回`OK`状态，并带有新的会话cookie。用户名被添加到cookie中，使用`user`键，可以在后续请求中检索。
- en: Run `APISpec` again; the login test should now be green.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行`APISpec`；现在登录测试应该是绿色的。
- en: Passing the cookie
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传递cookie
- en: 'From now on, every time we interact with the cart, we will have to pass the
    cookie with the session ID to bind our user with the cart. The test to get the
    list of products in the cart is as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，每次我们与购物车交互时，都必须传递带有会话ID的cookie来绑定我们的用户与购物车。获取购物车产品列表的测试如下：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: First, we call the `login` endpoint to build the session cookie; then, the cookie
    is passed in the second call. In order to check the number of products in the
    cart, we use Circe to transform the JSON response to a sequence of a cart.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用`login`端点来构建会话cookie；然后，在第二次调用中传递cookie。为了检查购物车中的产品数量，我们使用Circe将JSON响应转换为购物车序列。
- en: 'Since the session cookie has to be used by all of the subsequent tests, we
    can move the code to get the cookie from a `lazy val`, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于会话cookie必须被所有后续测试使用，我们可以将获取cookie的代码移动到`lazy val`中，如下所示：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `lazy` keyword indicates that the code will be evaluated as late as possible,
    upon the first usage of the value.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`lazy`关键字表示代码将在首次使用值时尽可能晚地评估。'
- en: 'Then, we can refactor our test to use it, as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以重构我们的测试以使用它，如下所示：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Check the addition of a product to the cart, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 检查添加产品到购物车的操作，如下所示：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We must be able to remove a product from the cart, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须能够从购物车中删除产品，如下所示：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The last test is to update the quantity of a product in the cart, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个测试是更新购物车中产品的数量，如下所示：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As the test is now defined, let's implement the endpoints.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于测试现在已定义，让我们实现端点。
- en: Listing products in cart
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出购物车中的产品
- en: Something is missing from the implementation; indeed, we do not have a `cartDao`
    instance in our `WebService` class.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 实现中似乎缺少了某些内容；实际上，在我们的`WebService`类中我们没有`cartDao`实例。
- en: 'To add it, just add it as a new parameter; as all of the parameters are injected,
    Play will automatically do it for you. The `WebService` class definition becomes
    the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加它，只需将其作为新参数添加；由于所有参数都是注入的，Play会自动为您完成。`WebService`类定义变为以下代码：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The implementation to get all of the products is as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 获取所有产品的实现如下：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `addCartProduct` implementation is as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`addCartProduct`的实现如下：'
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It appears that the code is the same in the `.recover` partial function of `addCartProduct`
    and `listCartProducts`; in order to avoid code duplication, we could extract it
    as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来，`addCartProduct`和`listCartProducts`的`.recover`部分函数中的代码是相同的；为了避免代码重复，我们可以提取如下：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can refractor the list of products and add a product to use the new variable.
    The delete product action is as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重构产品列表并添加产品以使用新变量。删除产品动作如下：
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, the update product action is as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新产品动作如下：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Congratulations; all of the tests are now passing!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜；现在所有测试都通过了！
- en: Swagger
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swagger
- en: An API needs to be documented to be usable. Indeed, when you want to use an
    API, you will not want to read a complete manual beforehand. It is better to have
    a self-explanatory and intuitive API.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一个API需要被文档化才能使用。确实，当你想使用API时，你不想事先阅读完整的手册。更好的是有一个自我解释和直观的API。
- en: 'To help with the documentation and testing part, there is a useful framework:
    Swagger.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助文档和测试部分，有一个有用的框架：Swagger。
- en: Swagger not only helps to write the documentation; it also allows you to test
    the API directly while reading the documentation. In order to visualize the documentation
    with the Swagger UI, you must first declare a specification file, in JSON or YAML
    format. This specification file defines all of the URLs and data models that constitute
    your API.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger不仅有助于编写文档；它还允许你在阅读文档的同时直接测试API。为了使用Swagger UI可视化文档，你必须首先声明一个规范文件，可以是JSON或YAML格式。这个规范文件定义了构成你的API的所有URL和数据模型。
- en: 'There are multiple ways to use Swagger, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Swagger有多种方式，如下所示：
- en: You can write the specification of your API using the Swagger Editor, and Swagger
    will generate a skeleton of the code for you
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 Swagger 编辑器编写您 API 的规范，Swagger 将为您生成代码框架
- en: You can add the Swagger specification directly in the `route.conf` file
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以直接在 `route.conf` 文件中添加 Swagger 规范
- en: You can add annotations in your code to generate the Swagger `specification`
    file
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在代码中添加注解来生成 Swagger `specification` 文件
- en: For our project, we are going to generate the Swagger `specification` file by
    using annotations in our code.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的项目，我们将通过在代码中使用注解来生成 Swagger `specification` 文件。
- en: The advantage of doing it this way is that all of the associated documentation
    will be in one place. It makes it easier to keep the documentation in sync, especially
    when code gets refactored. Many Swagger options are configurable, simply by adding
    annotations.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的优点是所有相关的文档都将集中在一个地方。这使得保持文档与代码同步变得更容易，尤其是在代码重构时。许多 Swagger 选项可以通过添加注解进行配置。
- en: Installing Swagger
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Swagger
- en: The installation is already done, thanks to the Gitter8 template we used to
    generate this project, so the following details are just for reference.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 安装已经完成，多亏了我们用来生成此项目的 Gitter8 模板，所以以下细节仅供参考。
- en: 'The integration that we use is based on the `swagger-api/swagger-play` GitHub
    repository; please refer to it for any updates. We have to add a reference to
    the library in `build.sbt`. The `libraryDependencies` variable must contain the
    following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的集成基于 `swagger-api/swagger-play` GitHub 仓库；请参考它以获取任何更新。我们必须在 `build.sbt`
    文件中添加对库的引用。`libraryDependencies` 变量必须包含以下代码：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, the module must be enabled by adding the following to `application.conf`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，必须通过将以下内容添加到 `application.conf` 文件中来启用模块：
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'From here, we can publish the JSON definition by adding the following route
    in the `routes` file:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以在 `routes` 文件中添加以下路由来发布 JSON 定义：
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We would like to serve the API documentation directly from our server. In order
    to do that, we need to add the `swagger-ui` dependency to `libraryDependencies`,
    in `built.sbt`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望直接从我们的服务器提供 API 文档。为了做到这一点，我们需要在 `built.sbt` 文件中将 `swagger-ui` 依赖项添加到 `libraryDependencies`：
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To get the `swagger-ui` exposed in Play, the `routes` file needs to be updated
    with the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 Play 中暴露 `swagger-ui`，需要更新 `routes` 文件，如下所示：
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The Swagger UI uses JavaScript with inline code. By default, the security policy
    of Play forbids inline code. Also, we would like to allow requests from the localhost
    and from Heroku where it will be deployed. Hence, the following code needs to
    be added to `application.conf`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger UI 使用内联代码的 JavaScript。默认情况下，Play 的安全策略禁止内联代码。此外，我们希望允许来自本地主机和 Heroku（它将被部署的地方）的请求。因此，需要在
    `application.conf` 文件中添加以下代码：
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: OK, the plumbing is done. It is time to add the definition of our project.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，管道安装已完成。现在是添加我们项目定义的时候了。
- en: Declaring endpoints
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明端点
- en: 'Now that Swagger is installed in our project, we need to provide some information
    about our API. First, we need to add the following to `application.conf`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们项目中已经安装了 Swagger，我们需要提供一些关于我们 API 的信息。首先，我们需要将以下内容添加到 `application.conf`
    文件中：
- en: '[PRE36]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, we need to declare our controller. For this, we will add the `@Api` annotation
    to the controller named `Application`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要声明我们的控制器。为此，我们将向名为 `Application` 的控制器添加 `@Api` 注解：
- en: '[PRE37]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Running the application
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: At this point, we can run Play to see the result.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以运行 Play 来查看结果。
- en: 'In the sbt shell tab of IntelliJ enter `run` followed by *Enter* as in the
    following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IntelliJ 的 sbt 命令行标签中输入 `run` 然后按 *Enter*，如下所示：
- en: '![](img/12909458-8bd0-4898-a145-cc6c2fd224ab.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/12909458-8bd0-4898-a145-cc6c2fd224ab.png)'
- en: 'The console should print:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台应该打印：
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You can now safely browse `http://localhost:9000/docs/swagger-ui/index.html?url=/v1/swagger.json`,
    Play is going to compile all the files and after a while, the Swagger UI will
    appear, as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以安全地浏览 `http://localhost:9000/docs/swagger-ui/index.html?url=/v1/swagger.json`，Play
    将编译所有文件，过一会儿，Swagger UI 将出现，如下所示：
- en: '![](img/446f17d7-d741-4c0a-8c2e-2e1f2ee8d1e7.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/446f17d7-d741-4c0a-8c2e-2e1f2ee8d1e7.png)'
- en: 'Click on the Product and Cart API link. All of the endpoints are shown, as
    follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 点击产品与购物车 API 链接。所有端点如下所示：
- en: '![](img/59f5552e-74f6-4d5c-a953-3024c64e925d.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/59f5552e-74f6-4d5c-a953-3024c64e925d.png)'
- en: This looks good, but we have to add some information about our API. For example,
    if you click on the `login` endpoint, there is no way to test it with a body containing
    the username.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来不错，但我们必须添加一些关于我们 API 的信息。例如，如果您点击 `login` 端点，就无法测试包含用户名的正文。
- en: Login
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录
- en: 'To test the `login` endpoint, go to the `WebService` class and add the following
    annotations, just before the `login` definition:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试 `login` 端点，转到 `WebService` 类并在 `login` 定义之前添加以下注释：
- en: '[PRE39]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `ApiOperation` object adds a description of the operation and defines the
    content type of the body sent. In this case, we are not sending JSON, but just
    a plain string. The `ApiImplicitParams` object defines the body sent to the server.
    The `ApiResponses` object informs the user about the possible statuses that can
    be returned in the response. The `login` documentation is now as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApiOperation` 对象添加了操作的描述并定义了发送到主体的内容类型。在这种情况下，我们不是发送 JSON，而只是一个纯字符串。`ApiImplicitParams`
    对象定义了发送到服务器的主体。`ApiResponses` 对象通知用户响应中可能返回的可能状态。`login` 文档现在如下所示：'
- en: '![](img/bed6f262-12cc-493b-9995-7afc35a8b8e1.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bed6f262-12cc-493b-9995-7afc35a8b8e1.png)'
- en: 'If you click on Try it out, you can type in a name and submit it by clicking
    on Execute:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击 Try it out，你可以输入一个名称并通过点击 Execute 来提交：
- en: '![](img/90489ceb-8e83-4aa5-9fd9-036b0d1d8aac.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90489ceb-8e83-4aa5-9fd9-036b0d1d8aac.png)'
- en: 'The call should return a successful status code 200, as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 调用应该返回成功的状态码 200，如下所示：
- en: '![](img/e13ea24d-7701-4a16-941f-0544af074fab.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e13ea24d-7701-4a16-941f-0544af074fab.png)'
- en: List of products
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品列表
- en: 'Now, we can add some annotations to the list of products, as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在产品列表上添加一些注释，如下所示：
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When we use Swagger to call `GET /v1/products`, the result of the execution
    is a JSON representation of all of the products, as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 Swagger 调用 `GET /v1/products` 时，执行结果是所有产品的 JSON 表示，如下所示：
- en: '![](img/b5a8c1a5-e02d-4fcc-aace-70169ba6a582.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5a8c1a5-e02d-4fcc-aace-70169ba6a582.png)'
- en: 'For `addProduct`, the following are the annotations that we need to add:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `addProduct`，我们需要添加以下注释：
- en: '[PRE41]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Thanks to the `dataType = "models.Product"` declaration, the Model section
    in Swagger shows a JSON model that corresponds to the `Product` case class:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了 `dataType = "models.Product"` 声明，Swagger 中的模型部分显示了与 `Product` 案例类相对应的 JSON
    模型：
- en: '![](img/09d78e29-18ca-460d-9aaa-3553833e5ec2.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09d78e29-18ca-460d-9aaa-3553833e5ec2.png)'
- en: Cart endpoints
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 购物车端点
- en: 'Now, let''s document the cart section with the list of products in the cart:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用购物车中的产品列表来记录购物车部分：
- en: '[PRE42]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If we call `listCartProducts`, we receive an empty array. To test it with some
    products, complete the declaration of `addCartProduct` with the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用 `listCartProducts`，我们会收到一个空数组。为了测试它，用一些产品完成 `addCartProduct` 的声明，如下所示：
- en: '[PRE43]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In Swagger, we can now add a new product to the cart, as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swagger 中，我们现在可以添加一个新的产品到购物车，如下所示：
- en: '![](img/e151c5a8-68a0-41bc-9b6f-9cf6d182a416.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e151c5a8-68a0-41bc-9b6f-9cf6d182a416.png)'
- en: 'Then, the list of products will return the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，产品列表将返回以下内容：
- en: '![](img/b7a14505-5dfe-4e07-a490-e7a60f0e62a8.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b7a14505-5dfe-4e07-a490-e7a60f0e62a8.png)'
- en: 'After that, we can try to update a product. Add the following annotations to
    `updateCartProduct`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以尝试更新一个产品。向 `updateCartProduct` 添加以下注释：
- en: '[PRE44]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, use Swagger to update the quantity, as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用 Swagger 更新数量，如下所示：
- en: '![](img/931138c7-a9e3-48e5-a02d-61594cd31862.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/931138c7-a9e3-48e5-a02d-61594cd31862.png)'
- en: 'After the update, the list of products returns, as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后，产品列表返回，如下所示：
- en: '![](img/5b020352-a2b9-40a9-ad02-ccb92a2293a9.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b020352-a2b9-40a9-ad02-ccb92a2293a9.png)'
- en: 'Perfect; the last operation to document is `deleteCartProduct`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '完美；最后要记录的操作是 `deleteCartProduct`:'
- en: '[PRE45]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We now have complete Swagger documentation for our API, and users can test it
    directly from their browsers.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了我们 API 的完整 Swagger 文档，用户可以直接从他们的浏览器中测试它。
- en: Deploying on Heroku
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Heroku 上部署
- en: 'The API is now finished. We can deploy it to Heroku, to make it available on
    the internet. As we already set up Heroku in the previous chapter, there is just
    one command to achieve our deployment. From the command line in the root of your
    project, enter the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: API 现在已经完成。我们可以将其部署到 Heroku，使其在互联网上可用。由于我们已经在上一章中设置了 Heroku，所以只需一个命令就可以完成部署。从项目根目录的命令行中，输入以下命令：
- en: '[PRE46]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Once the deployment has finished, you can browse to [https://shopping-fs.herokuapp.com/docs/swagger-ui/index.html?url=/v1/swagger.json](https://shopping-fs.herokuapp.com/docs/swagger-ui/index.html?url=/v1/swagger.json).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 部署完成后，你可以浏览到 [https://shopping-fs.herokuapp.com/docs/swagger-ui/index.html?url=/v1/swagger.json](https://shopping-fs.herokuapp.com/docs/swagger-ui/index.html?url=/v1/swagger.json)。
- en: Congratulations! You can now test the API online.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在可以在线测试 API 了。
- en: Summary
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to design and implement a REST API, while respecting
    the REST architectural principles.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何设计和实现一个 REST API，同时遵守 REST 架构原则。
- en: We created tests to check the API from a client's perspective. We implemented
    all of the methods by using the DAO that we wrote in the last chapter. All of
    the calls are asynchronous because we used `Future`, which guarantees that our
    server can handle a lot of concurrent requests.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了测试来从客户端的角度检查 API。我们通过使用上一章中编写的 DAO 实现了所有的方法。所有的调用都是异步的，因为我们使用了 `Future`，这保证了我们的服务器可以处理大量的并发请求。
- en: You also learned how to use the excellent Circe library to encode and decode
    JSON from Scala. Finally, we added a web interface to document and test the API,
    using Swagger.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学会了如何使用优秀的 Circe 库在 Scala 中进行 JSON 的编码和解码。最后，我们添加了一个 Web 界面来文档化和测试 API，使用了
    Swagger。
- en: In the next chapter, we are going to use this API to create a web interface
    based on Scala.js.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用这个 API 来创建一个基于 Scala.js 的 Web 界面。
