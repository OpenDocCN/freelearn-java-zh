- en: Chapter 10. Web Services with JAX-WS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章。使用 JAX-WS 的网络服务
- en: The Java EE specification includes the JAX-WS API as one of its technologies.
    JAX-WS is the standard way to develop **Simple Object Access Protocol** (**SOAP**)
    web services on the Java platform. It stands for **Java API for XML Web Services**.
    JAX-WS is a high-level API; invoking web services via JAX-WS is done via remote
    procedure calls. JAX-WS is a very natural API for Java developers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 规范将 JAX-WS API 作为其技术之一。JAX-WS 是在 Java 平台上开发 **简单对象访问协议** (**SOAP**)
    网络服务的标准方式。它代表 **Java API for XML Web Services**。JAX-WS 是一个高级 API；通过 JAX-WS 调用网络服务是通过远程过程调用完成的。JAX-WS
    是 Java 开发者非常自然的 API。
- en: Web services are application programming interfaces that can be invoked remotely.
    Web services can be invoked from clients written in any programming language.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务是可以远程调用的应用程序编程接口。网络服务可以从任何编程语言编写的客户端调用。
- en: 'Some of the topics we will cover include:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖的一些主题包括：
- en: Developing web services with the JAX-WS API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JAX-WS API 开发网络服务
- en: Developing web service clients with the JAX-WS API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JAX-WS API 开发网络服务客户端
- en: Adding attachments to web service calls
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网络服务调用中添加附件
- en: Exposing EJBs as web services
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 EJB 作为网络服务公开
- en: Securing web services
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护网络服务
- en: Developing web services with the JAX-WS API
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JAX-WS API 开发网络服务
- en: 'JAX-WS is a high-level API that simplifies development of SOAP-based web services.
    Developing a web service via JAX-WS consists of writing a class with public methods
    to be exposed as web services. The class needs to be decorated with the `@WebService`
    annotation. All public methods in the class are automatically exposed as web services,
    they can optionally be decorated with the `@WebMethod` annotation. The following
    example illustrates this process:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-WS 是一个高级 API，它简化了基于 SOAP 的网络服务的开发。通过 JAX-WS 开发网络服务包括编写一个具有公开方法的类，这些方法将被公开为网络服务。该类需要使用
    `@WebService` 注解进行装饰。类中的所有公开方法都将自动公开为网络服务，它们可以选择使用 `@WebMethod` 注解进行装饰。以下示例说明了这个过程：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding class exposes its two methods as web services. The `add()` method
    simply adds the two `int` primitives it receives as parameters and returns the
    result. The `subtract()` method subtracts its two parameters and returns the result.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类将其两个方法公开为网络服务。`add()` 方法简单地将它接收的两个 `int` 基本参数相加并返回结果。`subtract()` 方法从其两个参数中减去并返回结果。
- en: We indicate that the class implements a web service by decorating it with the
    `@WebService` annotation. Any methods that we would like exposed as web services
    can be decorated with the `@WebMethod` annotation; however, this isn't necessary,
    as all public methods are automatically exposed as web services.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用 `@WebService` 注解来装饰类，表明该类实现了网络服务。任何我们希望公开为网络服务的方法都可以使用 `@WebMethod` 注解进行装饰；然而，这不是必需的，因为所有公开方法都自动公开为网络服务。
- en: To deploy our web service, we need to package it in a `.war` file. Before Java
    EE 6, all valid `.war` files were required to contain a `web.xml` deployment descriptor
    in their `WEB-INF` directory. As we have already covered in previous chapters,
    this deployment descriptor is optional when working with Java EE 6 (and later)
    and is not required to deploy a web service under this environment.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了部署我们的网络服务，我们需要将其打包成 `.war` 文件。在 Java EE 6 之前，所有有效的 `.war` 文件都必须在其 `WEB-INF`
    目录中包含一个 `web.xml` 部署描述符。正如我们在前面的章节中已经讨论过的，在 Java EE 6（及以后）中，这个部署描述符是可选的，并且在这个环境中部署网络服务时不需要。
- en: 'If we choose to add a `web.xml` deployment descriptor, nothing needs to be
    added to the `.war` file''s `web.xml` in order to successfully deploy our web
    service. Simply having an empty `<web-app>` element in the deployment descriptor
    will be enough to successfully deploy our WAR file, as shown in the following
    code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择添加 `web.xml` 部署描述符，为了成功部署我们的网络服务，不需要在 `.war` 文件的 `web.xml` 中添加任何内容。只需在部署描述符中有一个空的
    `<web-app>` 元素就足够成功部署我们的 WAR 文件，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After compiling, packaging, and deploying the code, we can verify that it was
    successfully deployed by logging into the GlassFish admin web console and expanding
    the **Applications** node on the left-hand side. We should see our newly deployed
    web service listed under this node, as shown in the following screenshot:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 编译、打包和部署代码后，我们可以通过登录 GlassFish 管理员 Web 控制台并展开左侧的 **应用程序** 节点来验证它是否成功部署。我们应该在这个节点下看到我们新部署的网络服务，如下面的截图所示：
- en: '![Developing web services with the JAX-WS API](img/6886EN_10_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![使用 JAX-WS API 开发网络服务](img/6886EN_10_01.jpg)'
- en: 'In the preceding screenshot, notice that there is a **View Endpoint** link
    at the bottom right of the page. Clicking on that button takes us to the **Web
    Service Endpoint Information** page shown in the following screenshot, which has
    some information about our web service:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，请注意页面右下角有一个 **查看端点** 链接。点击该按钮将带我们到以下截图所示的 **Web 服务端点信息** 页面，其中包含有关我们的
    Web 服务的某些信息：
- en: '![Developing web services with the JAX-WS API](img/6886EN_10_02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![使用 JAX-WS API 开发 Web 服务](img/6886EN_10_02.jpg)'
- en: 'Notice that there is a link labeled **Tester:** in the preceding screenshot;
    clicking on this link takes us to an automatically generated page that allows
    us to test our web service. This page looks like the following screenshot:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前面的截图中的链接标签为 **Tester:**；点击此链接将带我们到一个自动生成的页面，允许我们测试我们的 Web 服务。此页面看起来如下面的截图所示：
- en: '![Developing web services with the JAX-WS API](img/6886EN_10_03.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![使用 JAX-WS API 开发 Web 服务](img/6886EN_10_03.jpg)'
- en: 'To test methods, we can simply enter some parameters in the text fields and
    click on the appropriate button. For example, entering the values `2` and `3`
    in the text fields corresponding to the `add` method and clicking on the **add**
    button would result in the following output:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试方法，我们只需在文本框中输入一些参数，然后点击相应的按钮。例如，在 `add` 方法的文本框中输入值 `2` 和 `3`，然后点击 **add**
    按钮将产生以下输出：
- en: '![Developing web services with the JAX-WS API](img/6886EN_10_04.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![使用 JAX-WS API 开发 Web 服务](img/6886EN_10_04.jpg)'
- en: 'JAX-WS uses the SOAP protocol behind the scenes to exchange information between
    web service clients and servers. By scrolling down the preceding page, we can
    see the SOAP request and response generated by our test, as shown in the following
    screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-WS 在幕后使用 SOAP 协议在 Web 服务客户端和服务器之间交换信息。通过向下滚动前面的页面，我们可以看到我们的测试生成的 SOAP 请求和响应，如下面的截图所示：
- en: '![Developing web services with the JAX-WS API](img/6886EN_10_05.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![使用 JAX-WS API 开发 Web 服务](img/6886EN_10_05.jpg)'
- en: As application developers, we don't need to concern ourselves too much with
    these SOAP requests, since they are automatically taken care of by the JAX-WS
    API.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 作为应用程序开发者，我们不需要过多关注这些 SOAP 请求，因为它们由 JAX-WS API 自动处理。
- en: Web service clients need a **Web Services Definition Language** (**WSDL**) file
    in order to generate executable code that they can use to invoke the web service.
    WSDL is a standard XML-based interface definition language that defines the functionality
    of a web service.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Web 服务客户端需要一个 **Web 服务定义语言** (**WSDL**) 文件，以便生成可执行代码，他们可以使用这些代码来调用 Web 服务。WSDL
    是一种基于 XML 的标准接口定义语言，它定义了 Web 服务的功能。
- en: 'WSDL files are typically placed in a web server and accessed by the client
    via its URL. When deploying web services developed using JAX-WS, a WSDL file is
    automatically generated for us. We can see it, along with its URL, by clicking
    on the **View WSDL** link on the **Web Service Endpoint Information** page, as
    shown in the following screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: WSDL 文件通常放置在 Web 服务器上，并通过其 URL 由客户端访问。当部署使用 JAX-WS 开发的 Web 服务时，会自动为我们生成一个 WSDL
    文件。我们可以通过点击 **Web 服务端点信息** 页面上的 **查看 WSDL** 链接来查看它及其 URL，如下面的截图所示：
- en: '![Developing web services with the JAX-WS API](img/6886EN_10_06.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![使用 JAX-WS API 开发 Web 服务](img/6886EN_10_06.jpg)'
- en: Notice the WSDL URL in the browser's location text field. We will need this
    URL when developing a client for our web service.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意浏览器位置文本框中的 WSDL URL。在为我们 Web 服务开发客户端时，我们需要这个 URL。
- en: Developing a web service client
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发 Web 服务客户端
- en: As mentioned earlier, executable code needs to be generated from the WSDL of
    a web service. A web service client will then invoke this executable code to access
    the web service.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，需要从 Web 服务的 WSDL 生成可执行代码。然后，Web 服务客户端将调用此可执行代码来访问 Web 服务。
- en: GlassFish includes a utility to generate Java code from a WSDL. The name of
    the utility is `wsimport`. It can be found under `[glassfish installation directory]/glassfish/bin/`.
    The only required argument for `wsimport` is the URL of the WSDL, which corresponds
    to the web service, for example, `wsimport` `http://localhost:8080/calculatorservice/CalculatorService?wsdl`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: GlassFish 包含一个用于从 WSDL 生成 Java 代码的实用工具。该实用工具的名称是 `wsimport`。它可以在 `[glassfish
    安装目录]/glassfish/bin/` 下找到。`wsimport` 的唯一必需参数是 WSDL 的 URL，它对应于 Web 服务，例如，`wsimport`
    `http://localhost:8080/calculatorservice/CalculatorService?wsdl`。
- en: 'The command in the preceding screenshot will generate the following compiled
    Java classes that allow client applications to access our web service:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个屏幕截图中的命令将生成以下编译后的Java类，允许客户端应用程序访问我们的Web服务：
- en: '`Add.class`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Add.class`'
- en: '`AddResponse.class`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddResponse.class`'
- en: '`Calculator.class`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Calculator.class`'
- en: '`CalculatorService.class`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CalculatorService.class`'
- en: '`ObjectFactory.class`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ObjectFactory.class`'
- en: '`package-info.class`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package-info.class`'
- en: '`Subtract.class`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Subtract.class`'
- en: '`SubtractResponse.class`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SubtractResponse.class`'
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Keeping the Generated Source Code**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**保留生成的源代码**'
- en: By default, the source code for the generated class files is automatically deleted;
    it can be kept by passing the `-keep` parameter to `wsimport`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，生成的类文件的源代码会自动删除；可以通过传递`-keep`参数给`wsimport`来保留它。
- en: These classes need to be added to the client's CLASSPATH in order for them to
    be accessible to the client's code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类需要添加到客户端的CLASSPATH中，以便客户端代码可以访问它们。
- en: 'In addition to the command-line tool, GlassFish includes a custom ANT task
    to generate code from a WSDL. The following ANT build script illustrates its usage:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 除了命令行工具之外，GlassFish还包括一个自定义的ANT任务，可以从WSDL生成代码。以下ANT构建脚本说明了其用法：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding example is a very minimal ANT build script that only illustrates
    how to set up the custom `<wsimport>` ANT target. In reality, the ANT build script
    for the project would have several other targets for compilation, building a `.war`
    file, and so on.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例是一个非常简单的ANT构建脚本，它仅说明了如何设置自定义的`<wsimport>` ANT目标。实际上，项目的ANT构建脚本会有几个其他目标，用于编译、构建`.war`文件等。
- en: 'Since `<wsimport>` is a custom ANT target and it is not standard, we need to
    add a `<taskdef>` element to our ANT build script. We need to set the `name` and
    `classname` attributes as illustrated in the example. Additionally, we need to
    add the following `.jar` files to the task''s CLASSPATH via nested `<classpath>`
    elements:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`<wsimport>`是一个自定义的ANT目标，并且它不是标准的，我们需要在我们的ANT构建脚本中添加一个`<taskdef>`元素。我们需要设置`name`和`classname`属性，如示例所示。此外，我们还需要通过嵌套的`<classpath>`元素将以下`.jar`文件添加到任务的CLASSPATH中：
- en: '`webservices-osgi.jar`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`webservices-osgi.jar`'
- en: '`jaxb-osgi.jar`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jaxb-osgi.jar`'
- en: '`javaee.jar`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javaee.jar`'
- en: The `webservices-osgi.jar` and `jaxb-osgi.jar` files can be found under the
    `[glassfish installation directory]/glassfish/modules` directory. The `javaee.jar`
    file contains all the Java EE APIs and can be found under `[glassfish installation
    directory]/glassfish/lib`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`webservices-osgi.jar`和`jaxb-osgi.jar`文件可以在`[glassfish安装目录]/glassfish/modules`目录下找到。`javaee.jar`文件包含所有Java
    EE API，可以在`[glassfish安装目录]/glassfish/lib`下找到。'
- en: Once we set up the custom `<wsimport>` task via the `<taskdef>` element, we
    are ready to use it. We need to indicate the WSDL location via its `wsdl` attribute.
    Once this task executes, the Java code that is required to access the web service
    defined by the WSDL is generated.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们通过`<taskdef>`元素设置了自定义的`<wsimport>`任务，我们就可以使用它了。我们需要通过其`wsdl`属性来指定WSDL的位置。一旦这个任务执行，就会生成访问由WSDL定义的Web服务所需的Java代码。
- en: JDK 1.6 comes bundled with JAX-WS 2.1\. If we are using this version of the
    JDK, we need to tell ANT to use the JAX-WS 2.2 API included with GlassFish. This
    can be done easily by setting the `xendorsed` attribute of the custom `wsimport`
    ANT task to `true`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 1.6捆绑了JAX-WS 2.1。如果我们使用这个版本的JDK，我们需要告诉ANT使用GlassFish中包含的JAX-WS 2.2 API。这可以通过将自定义`wsimport`
    ANT任务的`xendorsed`属性设置为`true`轻松完成。
- en: Readers using Maven to build their projects can take advantage of Maven's `AntRun`
    plugin to execute the `wsimport` ANT target when building their code. This approach
    is illustrated in the following `pom.xml` file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Maven构建项目的读者可以利用Maven的`AntRun`插件在构建代码时执行`wsimport` ANT目标。这种方法在以下`pom.xml`文件中得到了说明。
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Nested in the `pom.xml` file's `<configuration>` tag, corresponding to the `AntRun`
    plugin, we place any ANT tasks we need to execute. Unsurprisingly, the body of
    this tag in our example looks nearly identical to the ANT build file we just discussed.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pom.xml`文件的`<configuration>`标签内部，对应于`AntRun`插件，我们放置任何需要执行的ANT任务。不出所料，我们示例中这个标签的正文几乎与刚刚讨论的ANT构建文件相同。
- en: 'Now that we know how to build our code with ANT or Maven, we can develop a
    simple client to access our web service, using the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何使用ANT或Maven构建我们的代码，我们可以开发一个简单的客户端来访问我们的Web服务，使用以下代码：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `@WebServiceRef` annotation injects an instance of the web service into
    our client application. Its `wsdlLocation` attribute contains the URL of the WSDL
    that corresponds to the web service we are invoking.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`@WebServiceRef` 注解将Web服务的实例注入到我们的客户端应用程序中。它的 `wsdlLocation` 属性包含我们正在调用的Web服务的WSDL的URL。'
- en: Notice that the web service class is an instance of a class called `CalculatorService`.
    This class was created when we invoked the `wsimport` utility. The `wsimport`
    utility always generates a class whose name is the name of the class we implemented
    plus the `Service` suffix. We use this service class to obtain an instance of
    the web service class we developed. In our example, we do this by invoking the
    `getCalculatorPort()` method on the `CalculatorService` instance. In general,
    the method invoked to get an instance of our web service class follows the pattern
    `getNamePort()`, where `Name` is the name of the class we wrote to implement the
    web service. Once we get an instance of our web service class, we can simply invoke
    its methods like with any regular Java object.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Web服务类是名为 `CalculatorService` 的类的实例。这个类是在我们调用 `wsimport` 工具时创建的。`wsimport`
    工具总是生成一个类，其名称是我们实现的类的名称加上 `Service` 后缀。我们使用这个服务类来获取我们开发的Web服务类的实例。在我们的例子中，我们通过在
    `CalculatorService` 实例上调用 `getCalculatorPort()` 方法来实现这一点。一般来说，获取我们Web服务类实例的方法遵循
    `getNamePort()` 的模式，其中 `Name` 是我们编写的实现Web服务的类的名称。一旦我们获取了Web服务类的实例，我们就可以像使用任何常规Java对象一样调用它的方法。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Strictly speaking, the `getNamePort()` method of the service class returns an
    instance of a class that implements an interface generated by `wsimport`. This
    interface is given the name of our web service class and declares all of the methods
    we declared to be web services. For all practical purposes, the object returned
    is equivalent to our web service class.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，服务类的 `getNamePort()` 方法返回一个实现由 `wsimport` 生成的接口的类的实例。这个接口被赋予我们的Web服务类的名称，并声明了我们声明的所有作为Web服务的方法。对于所有实际用途，返回的对象与我们的Web服务类等效。
- en: 'Recall from our previous discussion that in order for resource injection to
    work in a standalone client (that does not get deployed to GlassFish), we need
    to execute it through the `appclient` utility. Assuming we packaged our client
    in a `.jar` file called `calculatorserviceclient.jar`, the command to execute
    would be the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们之前的讨论，为了在独立客户端（未部署到GlassFish）中使资源注入工作，我们需要通过 `appclient` 工具执行它。假设我们将客户端打包在一个名为
    `calculatorserviceclient.jar` 的 `.jar` 文件中，执行命令如下：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After entering the preceding command in the command line, we should see the
    following output of our client on the console:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行中输入前面的命令后，我们应该在控制台上看到客户端的以下输出：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, we passed primitive types as parameters and return values.
    Of course, it is also possible to pass objects both as parameters and as return
    values. Unfortunately, not all standard Java classes or primitive types can be
    used as method parameters or return values when invoking web services. The reason
    for this is that behind the scenes, method parameters and return types get mapped
    to XML definitions, and not all types can be properly mapped.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们传递了原始类型作为参数和返回值。当然，也可以将对象作为参数和返回值传递。不幸的是，并非所有标准Java类或原始类型都可以在调用Web服务时用作方法参数或返回值。这是因为幕后，方法参数和返回类型会被映射到XML定义，并且并非所有类型都可以正确映射。
- en: 'Valid types that can be used in JAX-WS web service calls are listed as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在JAX-WS Web服务调用中使用的有效类型如下所示：
- en: '`java.awt.Image`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.awt.Image`'
- en: '`java.lang.Object`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Object`'
- en: '`Java.lang.String`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Java.lang.String`'
- en: '`java.math.BigDecimal`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.math.BigDecimal`'
- en: '`java.math.BigInteger`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.math.BigInteger`'
- en: '`java.net.URI`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.net.URI`'
- en: '`java.util.Calendar`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.Calendar`'
- en: '`java.util.Date`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.Date`'
- en: '`java.util.UUID`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.UUID`'
- en: '`javax.activation.DataHandler`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javax.activation.DataHandler`'
- en: '`javax.xml.datatype.Duration`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javax.xml.datatype.Duration`'
- en: '`javax.xml.datatype.XMLGregorianCalendar`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javax.xml.datatype.XMLGregorianCalendar`'
- en: '`javax.xml.namespace.QName`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javax.xml.namespace.QName`'
- en: '`javax.xml.transform.Source`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javax.xml.transform.Source`'
- en: 'Additionally, the following primitive types can be used:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下原始类型也可以使用：
- en: '`boolean`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean`'
- en: '`byte`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte`'
- en: '`byte[]`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte[]`'
- en: '`double`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double`'
- en: '`float`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`'
- en: '`int`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`'
- en: '`long`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long`'
- en: '`short`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`short`'
- en: We can also use our own custom classes as method parameters and/or return values
    for web service methods, but member variables of our classes must be one of the
    types listed in the preceding list.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将我们自己的自定义类用作方法参数和/或返回值，但我们的类的成员变量必须是前面列表中列出的类型之一。
- en: Additionally, arrays can be used both as method parameters or return values,
    however, when executing `wsimport`, these arrays get converted to `Lists`, generating
    a mismatch between the method signature in the web service and the method call
    invoked in the client. For this reason, it is preferred to use `Lists` as method
    parameters and/or return values, since this is also valid and does not create
    a mismatch between the client and the server.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，数组可以作为方法参数或返回值使用，然而，在执行`wsimport`时，这些数组被转换为`Lists`，导致Web服务中的方法签名与客户端调用的方法调用之间产生不匹配。因此，更倾向于使用`Lists`作为方法参数和/或返回值，因为这同样是有效的，并且不会在客户端和服务器之间产生不匹配。
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: JAX-WS internally uses the **Java Architecture for XML Binding** (**JAXB**)
    to create SOAP messages from method calls. The types we are allowed to use for
    method calls and return values are the ones that JAXB supports. You can get more
    information on JAXB at [https://jaxb.dev.java.net/](https://jaxb.dev.java.net/).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-WS内部使用**Java Architecture for XML Binding**（**JAXB**）从方法调用创建SOAP消息。我们允许用于方法调用和返回值的类型是JAXB支持的类型。您可以在[https://jaxb.dev.java.net/](https://jaxb.dev.java.net/)上获取有关JAXB的更多信息。
- en: Sending attachments to web services
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向Web服务发送附件
- en: 'In addition to sending and accepting the data types discussed in the previous
    sections, web service methods can send and accept file attachments. The following
    example illustrates how to do this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 除了发送和接受前面各节中讨论的数据类型外，Web服务方法还可以发送和接受文件附件。以下示例说明了如何做到这一点：
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In order to write a web service method that receives one or more attachments,
    all we need to do is to add a parameter of type `javax.activation.DataHandler`
    for each attachment the method will receive. In the preceding example code, the
    `attachFile()` method takes a single parameter of this type and simply writes
    it to the filesystem.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写一个接收一个或多个附件的Web服务方法，我们只需要为方法将接收的每个附件添加一个类型为`javax.activation.DataHandler`的参数。在前面的示例代码中，`attachFile()`方法接受一个此类参数并将其简单地写入文件系统。
- en: Just like with any standard web service, the preceding code needs to be packaged
    in a WAR file and deployed. Once deployed, a WSDL will automatically be generated.
    We then need to execute the `wsimport` utility to generate the code that our web
    service client can use to access the web service. As previously discussed, the
    `wsimport` utility can be invoked directly from the command line or via a custom
    ANT target.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何标准Web服务一样，前面的代码需要打包成WAR文件并部署。一旦部署，WSDL将自动生成。然后我们需要执行`wsimport`实用程序来生成我们的Web服务客户端可以用来访问Web服务的代码。正如之前讨论的，`wsimport`实用程序可以直接从命令行或通过自定义ANT目标调用。
- en: 'Once we have executed `wsimport` to generate code to access the web service,
    we can write and compile our client code as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们执行了`wsimport`来生成访问Web服务的代码，我们可以编写和编译我们的客户端代码如下：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A web service client that needs to send one or more attachments to the web service
    first obtains an instance of the web service as usual. It then creates an instance
    of `java.io.File`, passing the location of the file to attach as its constructor's
    parameter.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 需要向Web服务发送一个或多个附件的Web服务客户端首先像往常一样获取Web服务的实例。然后，它创建一个`java.io.File`实例，将附件文件的路径作为其构造函数的参数。
- en: Once we have an instance of `java.io.File` containing the file we wish to attach,
    we then need to convert the file to a byte array and pass this byte array to the
    web service method that expects an attachment.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个包含我们希望附加的文件的`java.io.File`实例，我们接下来需要将文件转换为字节数组，并将这个字节数组传递给期望附件的Web服务方法。
- en: Notice that the parameter type used when the client invokes a method expecting
    an attachment is different from the parameter type of the method in the web server
    code. The method in the web server code expects an instance of `javax.activation.DataHandler`
    for each attachment. However, the code generated by `wsimport` expects an array
    of bytes for each attachment. These arrays of bytes are converted to the right
    type (`javax.activation.DataHandler`) behind the scenes by the code generated
    by `wsimport`. We as application developers don't need to concern ourselves with
    the details of why this happens. We just need to keep in mind that when sending
    attachments to a web service method, the parameter types will be different in
    the web service code and in the client invocation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当客户端调用期望附件的方法时使用的参数类型与在 Web 服务器代码中该方法使用的参数类型不同。Web 服务器代码中的方法期望每个附件都是一个 `javax.activation.DataHandler`
    实例。然而，由 `wsimport` 生成的代码期望每个附件都是一个字节数组。这些字节数组在 `wsimport` 生成的代码背后被转换为正确的类型（`javax.activation.DataHandler`）。作为应用程序开发者，我们不需要关心为什么会出现这种情况的细节。我们只需要记住，当向
    Web 服务方法发送附件时，Web 服务代码和客户端调用中的参数类型将不同。
- en: Exposing EJBs as web services
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 EJB 作为 Web 服务公开
- en: 'In addition to creating web services as described in the previous section,
    public methods of stateless session beans can easily be exposed as web services.
    The following example illustrates how to do this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在上一节中描述的创建 Web 服务之外，无状态会话 Bean 的公共方法可以很容易地公开为 Web 服务。以下示例说明了如何做到这一点：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we can see, the only thing we need to do to expose a stateless session bean's
    public methods is decorate its class declaration with the `@WebService` annotation.
    Since the class is a stateless session bean, it also needs to be decorated with
    the `@Stateless` annotation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，要公开无状态会话 Bean 的公共方法，我们只需要用 `@WebService` 注解装饰其类声明。由于该类是一个无状态会话 Bean，它还需要用
    `@Stateless` 注解进行装饰。
- en: 'Just like regular stateless session beans, the ones whose methods are exposed
    as web services need to be deployed in a `.jar` file. Once deployed, we can see
    the new web service under the **Applications** node in the GlassFish administration
    web console. Clicking on the application''s node, we can see some details in the
    GlassFish console, as shown in the following screenshot:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如常规无状态会话 Bean 一样，那些方法被公开为 Web 服务的需要部署在一个 `.jar` 文件中。一旦部署，我们可以在 GlassFish 管理员
    Web 控制台的 **应用程序** 节点下看到新的 Web 服务。点击应用程序节点，我们可以在 GlassFish 控制台中看到一些详细信息，如下面的屏幕截图所示：
- en: '![Exposing EJBs as web services](img/6886EN_10_07.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![将 EJB 作为 Web 服务公开](img/6886EN_10_07.jpg)'
- en: Notice that the value in the **Type** column for our new web service is **StatelessSessionBean**.
    This allows us to see at a glance that the web service is implemented as an **Enterprise
    JavaBean** (**EJB**).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们新 Web 服务的 **类型** 列表中的值是 **StatelessSessionBean**。这使我们能够一眼看出该 Web 服务是以 **企业
    JavaBean**（**EJB**）的形式实现的。
- en: Just like standard web services, EJB web services automatically generate a WSDL
    to be used by its clients upon deployment; it can be accessed the same way by
    clicking on the **View EndPoint** link.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如标准 Web 服务一样，EJB Web 服务在部署时自动生成一个 WSDL，供其客户端使用；可以通过点击 **查看端点** 链接来访问它。
- en: EJB web service clients
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EJB Web 服务客户端
- en: 'The following class illustrates the procedure to be followed to access EJB
    web service methods from a client application:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类说明了从客户端应用程序访问 EJB Web 服务方法的步骤：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we can see, nothing special needs to be done when accessing an EJB web service
    from a client. The procedure is the same as with standard web services.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，当从客户端访问 EJB Web 服务时，不需要做任何特殊的事情。过程与标准 Web 服务相同。
- en: 'Since the preceding example is a standalone application, it needs to be executed
    via the `appclient` application as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前面的示例是一个独立的应用程序，它需要通过以下方式通过 `appclient` 应用程序执行：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding command results in the following output:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令的结果如下：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Securing web services
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护 Web 服务
- en: 'Just like with regular web applications, web services can be secured so that
    only authorized users can access them. This can be accomplished by modifying the
    web service''s `web.xml` deployment descriptor, as shown in the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如常规 Web 应用程序一样，Web 服务可以被安全地设置，以便只有授权用户才能访问它们。这可以通过修改 Web 服务的 `web.xml` 部署描述符来实现，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this example, we modify our calculator service so that only authorized users
    can access it. Notice that the modifications needed to secure the web service
    are no different from the modifications needed to secure any regular web application.
    The URL pattern to be used for the `<url-pattern>` element can be obtained by
    clicking on the **View WSDL** link corresponding to our service. In our example,
    the URL for the link is:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们修改了我们的计算器服务，使其只能被授权用户访问。请注意，为了保护 Web 服务所需的修改与保护任何常规 Web 应用程序所需的修改没有区别。用于
    `<url-pattern>` 元素的 URL 模式可以通过点击对应于我们服务的 **查看 WSDL** 链接来获取。在我们的例子中，链接的 URL 是：
- en: '`http://localhost:8080/calculatorservice/CalculatorService?wsdl`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/calculatorservice/CalculatorService?wsdl`'
- en: The value to be used for `<url-pattern>` is the value right after the context
    root (`/CalculatorService` in our example) and before the question mark, followed
    by a slash and an asterisk.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 用于 `<url-pattern>` 的值是紧接在上下文根（在我们的例子中是 `/CalculatorService`）之后，并在问号之前，后面跟着一个斜杠和一个星号。
- en: Note
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that the preceding `web.xml` deployment descriptor only secures HTTP
    `POST` requests. The reason for this is that `wsimport` uses a `GET` request to
    obtain the WSDL and generate the appropriate code. If `GET` requests are secured,
    `wsimport` will fail, since it will be denied access to the WSDL.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的 `web.xml` 部署描述符仅保护 HTTP `POST` 请求。这样做的原因是 `wsimport` 使用 `GET` 请求获取 WSDL
    并生成相应的代码。如果 `GET` 请求受到保护，`wsimport` 将会失败，因为它将无法访问 WSDL。
- en: 'The following code illustrates how a standalone client can access a secured
    web service:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了一个独立客户端如何访问受保护的 Web 服务：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding code is a modified version of the `Calculator` service standalone
    client we saw earlier in the chapter. This version was modified to access the
    secure version of the service. As can be seen in the code, all we need to do to
    access the secured version of the server is put a username and a password in the
    request context. The username and password must be valid for the realm used to
    authenticate the web service.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是我们在本章前面看到的 `Calculator` 服务独立客户端的修改版本。这个版本被修改为访问服务的安全版本。从代码中可以看出，要访问受保护的服务版本，我们只需要在请求上下文中放入一个用户名和一个密码。用户名和密码必须是对用于验证
    Web 服务的域有效的。
- en: We can add the username and password to the request context by casting our web
    service endpoint class to `javax.xml.ws.BindingProvider` and calling its `getRequestContext()`
    method. This method returns a `java.util.Map` instance. We can then simply add
    the username and password by calling the `put` method of `Map` and using the constants
    `USERNAME_PROPERTY` and `PASSWORD_PROPERTY` defined in `BindingProvider` as keys,
    and the corresponding `String` objects as values.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将我们的 Web 服务端点类转换为 `javax.xml.ws.BindingProvider` 并调用其 `getRequestContext()`
    方法来将用户名和密码添加到请求上下文中。此方法返回一个 `java.util.Map` 实例。然后我们可以简单地通过调用 `Map` 的 `put` 方法，并使用在
    `BindingProvider` 中定义的常量 `USERNAME_PROPERTY` 和 `PASSWORD_PROPERTY` 作为键，相应的 `String`
    对象作为值来添加用户名和密码。
- en: Securing EJB web services
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护 EJB Web 服务
- en: 'Just like standard web services, EJBs exposed as web services can be secured
    so that only authorized clients can access them. This can be accomplished by configuring
    the EJB via the `glassfish-ejb-jar.xml` file as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 就像标准 Web 服务一样，作为 Web 服务公开的 EJB 可以被保护，以便只有授权客户端可以访问它们。这可以通过通过以下方式配置 EJB 实现：通过
    `glassfish-ejb-jar.xml` 文件：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As seen in the preceding deployment descriptor, security is set up differently
    for EJBs exposed as web services rather than with standard EJBs. For EJBs exposed
    as web services, the security configuration is done inside the `<webservice-endpoint>`
    element of the `glassfish-ejb-jar.xml` file.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的部署描述符所示，将 EJB 作为 Web 服务公开与使用标准 EJB 相比，其安全设置不同。对于作为 Web 服务公开的 EJB，安全配置是在
    `glassfish-ejb-jar.xml` 文件的 `<webservice-endpoint>` 元素内部完成的。
- en: The `<port-component-name>` element must be set to the name of the EJB we are
    exposing as a web service. This name is defined in the `<ejb-name>` element for
    the EJB.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`<port-component-name>` 元素必须设置为我们要公开为 Web 服务的 EJB 的名称。此名称在 EJB 的 `<ejb-name>`
    元素中定义。'
- en: The `<login-config>` element is very similar to the corresponding element in
    a web application's `web.xml` deployment descriptor. The `<login-config>` element
    must contain an authorization method, defined by its `<auth-method>` subelement,
    and a realm to use for authentication. The realm is defined by the `<realm>` subelement.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`<login-config>` 元素与网络应用程序的 `web.xml` 部署描述符中相应的元素非常相似。`<login-config>` 元素必须包含一个授权方法，由其
    `<auth-method>` 子元素定义，以及用于身份验证的领域。领域由 `<realm>` 子元素定义。'
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Do not use the `@RolesAllowed` annotation for EJBs intended to be exposed as
    web services. This annotation is intended for when the EJB methods are accessed
    through its remote or local interface. If an EJB or one or more of its methods
    are decorated with this annotation, then invoking the method will fail with a
    security exception.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 不要为打算公开为网络服务的 EJB 使用 `@RolesAllowed` 注解。此注解旨在 EJB 方法通过其远程或本地接口访问时使用。如果一个 EJB
    或其一个或多个方法被此注解装饰，那么调用该方法将因安全异常而失败。
- en: Once we configure an EJB web service for authentication, we package it in a
    `.jar` file, and then deploy it as usual. The EJB web service is now ready to
    be accessed by clients.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们为身份验证配置了 EJB 网络服务，我们就将其打包成 `.jar` 文件，然后像往常一样部署它。现在，EJB 网络服务已经准备好供客户端访问了。
- en: 'The following code example illustrates how an EJB web service client can access
    a secure EJB web service:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例说明了 EJB 网络服务客户端如何访问安全的 EJB 网络服务：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we can see in the previous example, the procedure for accessing an EJB exposed
    as a web service is identical to accessing a standard web service. The implementation
    of the web service is irrelevant to the client.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，访问作为网络服务公开的 EJB 的过程与访问标准网络服务相同。网络服务的实现与客户端无关。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered how to develop web services and web service clients
    via the JAX-WS API. We explained how to incorporate web service code generation
    for web service clients when using ANT or Maven as a build tool. We also covered
    the valid types that can be used for remote method calls via JAX-WS. Additionally,
    we discussed how to send attachments to a web service. We also covered how to
    expose EJB methods as web services. Lastly, we covered how to secure web services
    so that they are not accessible to unauthorized clients.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何通过 JAX-WS API 开发网络服务和网络服务客户端。我们解释了在使用 ANT 或 Maven 作为构建工具时，如何将网络服务客户端的代码生成集成到网络服务中。我们还涵盖了可以通过
    JAX-WS 进行远程方法调用的有效类型。此外，我们还讨论了如何向网络服务发送附件。我们还介绍了如何将 EJB 方法公开为网络服务。最后，我们介绍了如何确保网络服务不被未经授权的客户端访问。
- en: In the next chapter, we will cover RESTful web services with JAX-RS.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍使用 JAX-RS 的 RESTful 网络服务。
