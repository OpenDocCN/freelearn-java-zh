- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Building the Case for TDD
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建TDD的案例
- en: Before we dive into what **test-driven development** (**TDD**) is and how to
    use it, we’re going to need to understand why we need it. Every seasoned developer
    knows that bad code is easier to write than good code. Even good code seems to
    get worse over time. Why?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨**测试驱动开发**（**TDD**）是什么以及如何使用它之前，我们需要了解为什么我们需要它。每个经验丰富的开发者都知道，编写糟糕的代码比编写好的代码容易。即使是好的代码似乎随着时间的推移也会变得更糟。为什么？
- en: In this chapter, we will review the technical failures that make source code
    difficult to work with. We’ll consider the effect that bad code has on both the
    team and the business bottom line. By the end of the chapter, we’ll have a clear
    picture of the anti-patterns we need to avoid in our code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾那些使源代码难以工作的技术失败。我们将考虑糟糕代码对团队和业务底线的影响。到本章结束时，我们将清楚地了解我们需要在我们的代码中避免的反模式。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主要主题：
- en: Writing code badly
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恶劣的代码编写
- en: Recognizing bad code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别糟糕的代码
- en: Decreasing team performance
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 降低团队绩效
- en: Diminishing business outcomes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 降低业务成果
- en: Writing code badly
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恶劣的代码编写
- en: As every developer knows, it seems a lot easier to write bad code than to engineer
    good code. We can define good code as being easy to understand and safe to change.
    Bad code is therefore the opposite of this, where it is very difficult to read
    the code and understand what problem it is supposed to be solving. We fear changing
    bad code – we know that we are likely to break something.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每个开发者都知道，编写糟糕的代码似乎比编写好的代码容易得多。我们可以将好的代码定义为易于理解和安全更改的代码。因此，糟糕的代码是这种代码的对立面，它非常难以阅读代码并理解它试图解决的问题。我们害怕更改糟糕的代码——我们知道我们很可能会破坏某些东西。
- en: My own troubles with bad code go all the way back to my first program of note.
    This was a program written for a school competition, which aimed to assist realtors
    to help their customers find the perfect house. Written on the 8-bit Research
    Machines 380Z computer at school, this was 1981’s answer to Rightmove.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我对糟糕代码的困扰可以追溯到我的第一个有意义的程序。这是一个为学校竞赛编写的程序，旨在帮助房地产经纪人帮助客户找到理想的房子。在学校使用的8位Research
    Machines 380Z计算机上编写，这是1981年对Rightmove的回应。
- en: In those pre-web days, it existed as a simple desktop application with a green-screen
    text-based user interface. It did not have to handle millions, never mind billions,
    of users. Nor did it have to handle millions of houses. It didn’t even have a
    nice user interface.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在那些互联网之前的年代，它作为一个简单的桌面应用程序存在，具有基于文本的绿色屏幕用户界面。它不需要处理数百万，更不用说数十亿的用户。它也不需要处理数百万的房屋。它甚至没有友好的用户界面。
- en: As a piece of code, it was a couple of thousand lines of *Microsoft Disk BASIC
    9* code. There was no code structure to speak of, just thousands of lines resplendent
    with uneven line numbers and festooned with global variables. To add an even greater
    element of challenge, BASIC limited every variable to a two-letter name. This
    made every name in the code utterly incomprehensible. The source code was intentionally
    written to have as few spaces in it as possible in order to save memory. When
    you only had 32KB of RAM to fit all of the program code, the data, and the operating
    system in, every byte mattered.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一段代码，它是由几千行*Microsoft Disk BASIC 9*代码组成的。没有可说的代码结构，只有数千行带有不均匀行号和装饰着全局变量的代码。为了增加更大的挑战元素，BASIC将每个变量限制为两个字母的名称。这使得代码中的每个名称都完全无法理解。源代码被有意写成尽可能少的空格，以节省内存。当你只有32KB的RAM来适应整个程序代码、数据和操作系统时，每个字节都很重要。
- en: The program only offered its user basic features. The user interface was of
    its time, using only text-based forms. It predated graphical operating systems
    by a decade. The program also had to implement its own data storage system, using
    files on 5.25-inch floppy disks. Again, affordable database components were of
    the future. The main feature of the program in question was that users could search
    for houses within certain price ranges and feature sets. They could filter by
    terms such as the number of bedrooms or price range.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序仅向用户提供基本功能。用户界面是那个时代的，仅使用基于文本的表单。它比图形操作系统早了十年。程序还必须实现自己的数据存储系统，使用5.25英寸软盘上的文件。再次强调，可负担的数据库组件是未来的事情。该程序的主要功能是用户可以在特定的价格范围和功能集中搜索房屋。他们可以通过卧室数量或价格范围等术语进行筛选。
- en: 'However, the code itself really was a mess. See for yourself – here is a photograph
    of the original listing:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，代码本身真的非常混乱。请看以下原始列表的照片：
- en: '![Figure 1.1 – The estate agent code listing](img/Figure_1.1_B18384.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – 房地产中介代码列表](img/Figure_1.1_B18384.jpg)'
- en: Figure 1.1 – The estate agent code listing
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 房地产中介代码列表
- en: This horror is the original paper listing of one of the development versions.
    It is, as you can see, completely unreadable. It’s not just you. Nobody would
    be able to read it easily. I can’t and I wrote it. I would go as far as to say
    it is a mess, *my mess*, crafted by me, one keystroke at a time.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这种恐怖是其中一个开发版本的原始论文列表。正如你所见，它完全无法阅读。这不仅仅是你的问题。没有人能够轻易阅读它。我无法阅读，而且是我写的。我甚至可以说它是一团糟，*我的混乱*，是我一点一点敲击键盘创作的。
- en: This kind of code is a nightmare to work with. It fails our definition of good
    code. It is not at all easy to read that listing and understand what the code
    is supposed to be doing. It is not safe to change that code. If we attempted to,
    we would find that we could never be certain about whether we have broken some
    feature or not. We would also have to manually retest the entire application.
    This would be time-consuming.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这类代码与工作噩梦无异。它不符合我们对于好代码的定义。阅读这样的列表并理解代码本应做什么并不容易。更改这样的代码是不安全的。如果我们尝试更改，我们会发现我们永远无法确定是否破坏了某些功能。我们还得手动重新测试整个应用程序。这将非常耗时。
- en: Speaking of testing, I never thoroughly tested that code. It was all manually
    tested without even following a formal test plan. At best, I would have run a
    handful of **happy path** manual tests. These were the kind of tests that would
    confirm that you could add or delete a house, and that some representative searches
    worked, but that was all. There was no way I ever tested every path through that
    code. I just guessed that it would work.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到测试，我从未彻底测试过那段代码。一切都是手动测试，甚至没有遵循正式的测试计划。最多，我可能只进行了一小部分**快乐路径**的手动测试。这些测试旨在确认你可以添加或删除房屋，以及一些代表性的搜索功能正常工作，但仅此而已。我根本无法测试通过那段代码的每一条路径。我只是猜测它应该会工作。
- en: If the data handling had failed, I would not have known what had happened. I
    never tried it. Did every possible search combination work? Who knew? I certainly
    had no idea. I had even less patience to go through all that tedious manual testing.
    It worked, enough to win an award of sorts, but it was still bad code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据处理失败，我就不知道发生了什么。我从未尝试过。每个可能的搜索组合都工作了吗？谁知道呢？我当然不知道。我甚至没有足够的耐心去完成所有那些繁琐的手动测试。它工作得足够好，足以赢得某种奖项，但代码仍然很糟糕。
- en: Understanding why bad code is written
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解为什么编写糟糕的代码
- en: In my case, it was simply down to a lack of knowledge. I did not know how to
    write good code. But there are also other reasons unrelated to skill. Nobody ever
    sets out to write bad code intentionally. Developers do the best job they can
    with the tools available and to the best of their ability at that time.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，这仅仅是知识不足。我不知道如何编写好的代码。但还有其他与技能无关的原因。没有人会故意编写糟糕的代码。开发者会尽他们所能，利用当时可用的工具，尽他们当时的能力去工作。
- en: 'Even with the right skills, several common issues can result in bad code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 即使拥有正确的技能，一些常见问题也可能导致编写糟糕的代码：
- en: A lack of time to refine the code due to project deadlines
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于项目截止日期，没有时间对代码进行精炼
- en: Working with legacy code whose structure prevents new code from being added
    cleanly
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与结构阻止新代码干净添加的遗留代码一起工作
- en: Adding a short-term fix for an urgent production fault and then never reworking
    it
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为紧急的生产故障添加短期修复，然后从未重新修改
- en: Unfamiliarity with the subject area of the code
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对代码主题领域的不熟悉
- en: Unfamiliarity with the local idioms and development styles
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对当地习语和发展风格的不熟悉
- en: Inappropriately using idioms from a different programming language
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不恰当地使用来自不同编程语言的习语
- en: 'Now that we’ve seen an example of code that is difficult to work with, and
    understood how it came about, let’s turn to the obvious next question: how can
    we recognize bad code?'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了一个难以使用的代码示例，并了解了它是如何产生的，让我们转向下一个明显的问题：我们如何识别糟糕的代码？
- en: Recognizing bad code
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别糟糕的代码
- en: Admitting that our code is difficult to work with is one thing, but to move
    past that and write good code, we need to understand *why* code is bad. Let’s
    identify the technical issues.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 承认我们的代码难以使用是一回事，但要想超越这一点并编写好的代码，我们需要了解代码为什么是糟糕的。让我们确定技术问题。
- en: Bad variable names
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 糟糕的变量名
- en: Good code is self-describing and safe to change. Bad code is not.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 好的代码是自我描述的，并且可以安全地更改。糟糕的代码则不是。
- en: Names are the most critical factor in deciding whether code will be easy to
    work with or not. Good names tell the reader clearly what to expect. Bad names
    do not. Variables should be named according to what they contain. They should
    answer “*why would I want to use this data? What will it* *tell me?*”
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 名称是决定代码是否易于工作最关键的因素。好的名称清楚地告诉读者可以期待什么。不好的名称则不然。变量应该根据它们包含的内容来命名。它们应该回答“*我为什么要使用这些数据？它会告诉我什么？*”
- en: A string variable that has been named `string` is badly named. All we know is
    that it is a string. This does not tell us what is in the variable or why we would
    want to use it. If that string represented a surname, then by simply calling it
    `surname`, we would have helped future readers of our code understand our intentions
    much better. They would be able to easily see that this variable holds a surname
    and should not be used for any other purpose.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个被命名为`string`的字符串变量命名不当。我们只知道它是一个字符串。这并没有告诉我们变量中有什么，或者我们为什么要使用它。如果那个字符串代表姓氏，那么通过简单地称之为`surname`，我们就帮助未来的代码读者更好地理解我们的意图。他们可以轻松地看到这个变量存储的是姓氏，并且不应该用于其他任何目的。
- en: 'The two-letter variable names we saw in the listing in *Figure 1**.1* represented
    a limitation of the BASIC language. It was not possible to do better at the time,
    but as we could see, they were not helpful. It is much harder to understand what
    `sn` means than `surname`, if that’s what the variable stores. To carry that even
    further, if we decide to hold a surname in a variable named `x`, we have made
    things really difficult for readers of our code. They now have two problems to
    solve:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*图1*.1中看到的两位字母变量名代表了BASIC语言的局限性。在当时，我们无法做得更好，但正如我们所见，它们并不有帮助。如果变量存储的是姓氏，那么理解`sn`的含义比`surname`要困难得多。更进一步，如果我们决定用一个名为`x`的变量来存储姓氏，那么我们给代码的读者带来了真正的困难。他们现在有两个问题要解决：
- en: They have to reverse-engineer the code to work out that `x` is used to hold
    a surname
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们必须逆向工程代码，以确定`x`是用来存储姓氏的。
- en: They have to mentally map `x` with the concept of surname every time that they
    use it
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次他们使用`x`时，都必须在心理上将`x`与姓氏的概念相对应。
- en: 'It is so much easier when we use descriptive names for all our data, such as
    local variables, method parameters, and object fields. In terms of more general
    guidelines, the following Google style guide is a good source: [https://google.github.io/styleguide/javaguide.html#s5-naming](https://google.github.io/styleguide/javaguide.html#s5-naming).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为所有数据使用描述性名称时，比如局部变量、方法参数和对象字段，事情就简单多了。在更一般的指导方针方面，以下Google风格指南是一个很好的资源：[https://google.github.io/styleguide/javaguide.html#s5-naming](https://google.github.io/styleguide/javaguide.html#s5-naming)。
- en: Best practice for naming variables
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 变量命名的最佳实践
- en: Describe the data contained, not the data type.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 描述包含的数据，而不是数据类型。
- en: We now have a better idea of how to go about naming variables. Now, let’s look
    at how to name functions, methods, and classes properly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对如何命名变量有了更好的了解。现在，让我们看看如何正确地命名函数、方法和类。
- en: Bad function, method, and class names
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不良的函数、方法和类名
- en: The names of functions, methods, and classes all follow a similar pattern. In
    good code, function names tell us why we should call that function. They describe
    what they will do for us as users of that function. The focus is on the outcome
    – what will have happened by the time the function returns. We do not describe
    how that function is implemented. This is important. It allows us to change our
    implementation of that function later if that becomes advantageous, and the name
    will still describe the outcome clearly.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 函数、方法和类的命名都遵循类似的模式。在优秀的代码中，函数名告诉我们为什么我们应该调用该函数。它们描述了它们将为我们这些函数的用户做什么。重点是结果——函数返回时会发生什么。我们不描述该函数是如何实现的。这是很重要的。它允许我们在以后如果这样做变得有利时更改该函数的实现，并且名称仍然清楚地描述了结果。
- en: A function named `calculateTotalPrice` is clear about what it is going to do
    for us. It will calculate the total price. It won’t have any surprising side effects.
    It won’t try and do anything else. It will do what it says it will. If we abbreviate
    that name to `ctp`, then it becomes much less clear. If we call it `func1`, then
    it tells us absolutely nothing at all that is useful.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为`calculateTotalPrice`的函数清楚地说明了它将为我们做什么。它将计算总价。它不会有任何意外的副作用。它不会尝试做任何其他事情。它将做它所说的。如果我们把那个名字缩写为`ctp`，那么它就变得不那么清晰了。如果我们称之为`func1`，那么它告诉我们没有任何有用的信息。
- en: Bad names force us to reverse-engineer every decision made every time we read
    the code. We have to pore through the code to try and find out what it is used
    for. We should not have to do this. Names should be abstractions. A good name
    will speed up our ability to understand code by condensing a bigger-picture understanding
    into a few words.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 恶劣的命名迫使我们每次阅读代码时都要重新设计每个决策。我们必须仔细阅读代码，试图找出它的用途。我们不应该不得不这样做。名字应该是抽象的。一个好的名字将通过将更大的理解浓缩成几个词来加快我们理解代码的能力。
- en: You can think of the function name as a heading. The code inside the function
    is the body of text. It works just the same way that the text you’re reading now
    has a heading, *Recognizing bad code*, which gives us a general idea of the content
    in the paragraphs that follow. From reading the heading, we expect the paragraphs
    to be about recognizing bad code, nothing more and nothing less.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将函数名视为标题。函数内的代码是文本的主体。它的工作方式与你现在阅读的文本中的标题“识别糟糕的代码”相同，这给我们一个关于后续段落内容的一般概念。从标题中，我们期望段落是关于识别糟糕的代码，没有更多也没有更少。
- en: We want to be able to skim-read our software through its *headings* – the function,
    method, class, and variable names – so that we can focus on what we want to do
    now, rather than relearning what was done in the past.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够通过其标题——函数、方法、类和变量名——快速浏览我们的软件，这样我们就可以专注于我们现在想做的事情，而不是重新学习过去做过的事情。
- en: Method names are treated identically to function names. They both describe an
    action to be taken. Similarly, you can apply the same rules for function names
    to method names.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 方法名与函数名处理方式相同。它们都描述了要执行的操作。同样，你可以将适用于函数名的相同规则应用于方法名。
- en: Best practice for method and function names
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 方法名和函数名的最佳实践
- en: Describe the outcome, not the implementation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 描述结果，而不是实现过程。
- en: Again, class names follow descriptive rules. A class often represents a single
    concept, so its name should describe that concept. If a class represents the user
    profile data in our system, then a class name of `UserProfile` will help readers
    of our code to understand that.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，类名遵循描述性规则。一个类通常代表一个单一的概念，因此其名称应该描述该概念。如果类代表我们系统中的用户配置文件数据，那么`UserProfile`这个类名将帮助我们的代码读者理解这一点。
- en: A name’s length depends on namespacing
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个名字的长度取决于命名空间
- en: 'One further tip applies to all names with regard to their length. The name
    should be fully descriptive but its length depends on a few factors. We can choose
    shorter names when one of the following applies:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于名字长度的进一步提示，适用于所有名字。名字应该是完全描述性的，但其长度取决于几个因素。当以下情况之一适用时，我们可以选择较短的名称：
- en: The named variable has a small scope of only a few lines
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名变量有一个小的作用域，只有几行
- en: The class name itself provides the bulk of the description
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类名本身提供了大部分的描述
- en: The name exists within some other namespace, such as a class name
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名字存在于某个其他命名空间中，例如类名
- en: Let’s look at a code example for each case to make this clear.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过每个情况的代码示例来使这一点更加清晰。
- en: 'The following code calculates the total of a list of values, using a short
    variable name, `total`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用简短的变量名`total`计算一系列值的总和：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This works well because it is clear that `total` represents the total of all
    values. We do not need a name that is any longer given the context around it in
    the code. Perhaps an even better example lies in the `v` loop variable. It has
    a one-line scope, and within that scope, it is quite clear that `v` represents
    the current value within the loop. We could use a longer name such as `currentValue`
    instead. However, does this add any clarity? Not really.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，因为很明显`total`代表所有值的总和。考虑到代码中的上下文，我们不需要一个更长的名字。也许一个更好的例子在于`v`循环变量。它有一个单行的作用域，在这个作用域内，很明显`v`代表循环中的当前值。我们可以使用一个更长的名字，如`currentValue`。然而，这增加了任何清晰度吗？实际上并没有。
- en: 'In the following method, we have a parameter with the short name `gc`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下方法中，我们有一个名为`gc`的短参数名：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The reason we can choose such a short name is that the `GraphicsContext` class
    carries most of the description already. If this were a more general-purpose class,
    such as `String`, for example, then this short name technique would be unhelpful.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择如此简短的名字的原因是`GraphicsContext`类已经包含了大部分的描述。如果这是一个更通用的类，例如`String`，那么这种简短的名字技术将不会很有帮助。
- en: 'In this final code example, we are using the short method name of `draw()`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后的代码示例中，我们使用了简短的方法名`draw()`：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The class name here is highly descriptive. The `ProfileImage` class name we’ve
    used in our system is one that is commonly used to describe the avatar or photograph
    that shows on a user’s profile page. The `draw()` method is responsible for writing
    the image data to a `WebResponse` object. We could choose a longer method name,
    such as `drawProfileImage()`, but that simply repeats information that has already
    been made clear given the name of the class. Details such as this are what give
    Java its reputation for being verbose, which I feel is unfair; it is often us
    Java programmers who are verbose, rather than Java itself.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里类的名字非常具有描述性。我们系统中使用的 `ProfileImage` 类名通常用来描述用户个人资料页面上的头像或照片。`draw()` 方法负责将图像数据写入
    `WebResponse` 对象。我们可以选择一个更长的方法名，比如 `drawProfileImage()`，但这只是重复了已经由类名明确的信息。这样的细节正是赋予了
    Java 详尽声誉的原因，我觉得这是不公平的；往往是 Java 程序员而不是 Java 本身过于详尽。
- en: We’ve seen how properly naming things makes our code easier to understand. Let’s
    take a look at the next big problem that we see in bad code – using constructs
    that make logic errors more likely.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，合理地命名事物可以使我们的代码更容易理解。让我们看看在糟糕的代码中我们看到的下一个大问题——使用那些使逻辑错误更可能发生的结构。
- en: Error-prone constructs
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容易出错的构造
- en: Another tell-tale sign of bad code is that it uses error-prone constructs and
    designs. There are always several ways of doing the same thing in code. Some of
    them provide more scope to introduce mistakes than others. It therefore makes
    sense to choose ways of coding that actively avoid errors.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个坏代码的明显迹象是它使用了容易出错的构造和设计。在代码中做同样的事情总是有几种不同的方法。其中一些方法比其他方法更容易引入错误。因此，选择能够积极避免错误的编码方式是有意义的。
- en: 'Let’s compare two different versions of a function to calculate a total value
    and analyze where errors might creep in:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较两个不同的函数版本，用于计算总和值，并分析错误可能出现的地点：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The previous listing is a simple method that will take a list of integers and
    return their total. It’s the sort of code that has been around since **Java 1.0.2**.
    It works, yet it is error prone. In order for this code to be correct, we need
    to get several things right:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的列表是一个简单的函数，它将接受一个整数列表并返回它们的总和。这种代码自 **Java 1.0.2** 以来一直存在。它工作，但容易出错。为了使这段代码正确，我们需要做几件事情正确：
- en: Making sure that `total` is initialized to `0` and not some other value
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保将 `total` 初始化为 `0` 而不是其他值
- en: Making sure that our `i` loop index is initialized to `0`
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保我们的 `i` 循环索引初始化为 `0`
- en: Making sure that we use `<` and not `<=` or `==` in our loop comparison
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保我们在循环比较中使用 `<` 而不是 `<=` 或 `==`
- en: Making sure that we increment the `i` loop index by exactly one
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保我们将 `i` 循环索引递增正好一次
- en: Making sure that we add the value from the current index in the list to `total`
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保我们将列表当前索引的值添加到 `total`
- en: Experienced programmers do tend to get all this right first time. My point is
    that there is a *possibility* of getting any or all of these things wrong. I’ve
    seen mistakes made where `<=` has been used instead of `<` and the code fails
    with an `ArrayIndexOutOfBounds` exception as a result. Another easy mistake is
    to use `=` in the line that adds to the total value instead of `+=`. This has
    the effect of returning only the last value, not the total. I have even made that
    mistake as a pure *typo* – I honestly thought I had typed the right thing but
    I was typing quickly and I hadn’t.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 经验丰富的程序员确实往往一开始就能把这些事情都做对。我的观点是，出错的可能性是存在的。我见过错误，比如使用了 `<=` 而不是 `<`，结果代码因为 `ArrayIndexOutOfBounds`
    异常而失败。另一个容易犯的错误是在累加总值的行中使用 `=` 而不是 `+=`。这只会返回最后一个值，而不是总和。我甚至犯过这样的错误，纯粹是因为打字错误——我确实以为我打对了，但我打得太快了，没有注意到。
- en: 'It is clearly much better for us to *avoid* these kinds of errors entirely.
    If an error cannot happen, then it will not happen. This is a process I call *designing
    out errors*. It is a fundamental clean-code practice. To see how we could do this
    to our previous example, let’s look at the following code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，完全避免这类错误对我们来说要好得多。如果一个错误不可能发生，那么它就不会发生。这是一个我称之为 *设计出错误* 的过程。这是一个基本的代码整洁实践。为了了解我们如何将这个实践应用到之前的例子中，让我们看看以下代码：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code does the same thing, yet it is inherently safer. We have no `total`
    variable, so we cannot initialize that incorrectly, nor can we forget to add values
    to it. We have no loop and so no loop index variable. We cannot use the wrong
    comparison for the loop end and so cannot get an `ArrayIndexOutOfBounds` exception.
    There is simply far less that can go wrong in this implementation of the code.
    It generally makes the code clearer to read as well. This, in turn, helps with
    onboarding new developers, code reviews, adding new features, and pair programming.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码做的是同样的事情，但本质上更安全。我们没有 `total` 变量，所以不能错误地初始化它，也不能忘记向它添加值。我们没有循环，所以没有循环索引变量。我们不能为循环结束使用错误的比较，因此不能得到
    `ArrayIndexOutOfBounds` 异常。在这个代码实现中，出错的可能性大大减少。这通常也使得代码更容易阅读。这反过来又有助于新开发者的入职、代码审查、添加新功能和结对编程。
- en: Whenever we have a choice to use code with fewer parts that could go wrong,
    we should choose that approach. We can make life easier for ourselves and our
    colleagues by choosing to keep our code as error-free and simple as possible.
    We can use more robust constructs to give bugs fewer places to hide.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们有选择使用更少部分且可能出错的地方时，我们应该选择那种方法。通过选择使我们的代码尽可能无错误和简单，我们可以让自己和我们的同事的生活变得更轻松。我们可以使用更健壮的结构来给错误更少的地方隐藏。
- en: 'It is worth mentioning that both versions of the code have an integer overflow
    bug. If we add integers together whose total is beyond the allowable range of
    -2147483648 to 2147483647, then the code will produce the wrong result. The point
    still stands, however: the later version has fewer places where things can go
    wrong. *Structurally*, it is simpler code.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，代码的两个版本都存在整数溢出错误。如果我们相加的整数总和超出了允许的范围 -2147483648 到 2147483647，那么代码将产生错误的结果。然而，这个观点仍然成立：较晚的版本有更少的地方可能出错。*结构上*，这是一段更简单的代码。
- en: 'Now that we have seen how to avoid the kinds of errors that are typical of
    bad code, let’s turn to other problem areas: coupling and cohesion.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何避免典型于糟糕代码的错误类型，让我们转向其他问题领域：耦合和内聚。
- en: Coupling and cohesion
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 耦合与内聚
- en: If we have a number of Java classes, **coupling** describes the relationship
    between those classes, while **cohesion** describes the relationships between
    the methods inside each one.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有许多 Java 类，**耦合**描述了这些类之间的关系，而**内聚**描述了每个类内部方法之间的关系。
- en: Our software designs become easier to work with once we get the amounts of coupling
    and cohesion right. We will learn techniques to help us do this in [*Chapter 7*](B18384_07.xhtml#_idTextAnchor128),
    *Driving Design–TDD and SOLID*. For now, let’s understand the problems that we
    will face when we get this wrong, starting with the problem of low cohesion.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们正确地处理耦合和内聚的数量时，我们的软件设计将更容易使用。我们将在[*第 7 章*](B18384_07.xhtml#_idTextAnchor128)中学习帮助我们做到这一点的技术，*驱动设计-TDD
    和 SOLID*。现在，让我们了解当我们做错时我们将面临的问题，从低内聚的问题开始。
- en: Low cohesion inside a class
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类内部的低内聚
- en: '**Low cohesion** describes code that has many different ideas all lumped together
    in it in a single place. The following UML class diagram shows an example of a
    class with low cohesion among its methods:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**低内聚**描述的是代码中许多不同的想法都聚集在同一个地方。下面的 UML 类图展示了具有低内聚方法的类的示例：'
- en: '![Figure 1.2 – Low cohesion](img/Figure_1.2_B18384.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 低内聚](img/Figure_1.2_B18384.jpg)'
- en: Figure 1.2 – Low cohesion
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 低内聚
- en: 'The code in this class attempts to combine too many responsibilities. They
    are not all obviously related – we are writing to a database, sending out welcome
    emails, and rendering web pages. This large variety of responsibilities makes
    our class harder to understand and harder to change. Consider the different reasons
    we may need to change this class:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类中的代码试图结合太多的职责。它们并不都是明显相关的——我们正在向数据库写入，发送欢迎邮件，并渲染网页。这种大量的职责使得我们的类更难以理解，也更难以更改。考虑我们可能需要更改此类的不同原因：
- en: Changes to the database technology
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库技术的变更
- en: Changes to the web view layout
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网页视图布局的变更
- en: Changes to the web template engine technology
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网页模板引擎技术的变更
- en: Changes to the email template engine technology
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邮件模板引擎技术的变更
- en: Changes to the news feed generation algorithm
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新闻生成算法的变更
- en: There are many reasons why we would need to change the code in this class. It
    is always better to give classes a more precise focus, so that there are fewer
    reasons to change them. Ideally, any given piece of code should only have one
    reason to be changed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有许多原因需要更改这个类中的代码。始终给类一个更精确的焦点会更好，这样就有更少的理由去更改它们。理想情况下，任何给定的代码片段只应该有一个需要更改的理由。
- en: Understanding code with low cohesion is hard. We are forced to understand many
    different ideas at once. Internally, the code is very interconnected. Changing
    one method often forces a change in others because of this. Using the class is
    difficult, as we need to construct it with all its dependencies. In our example,
    we have a mixture of templating engines, a database, and code for creating a web
    page. This also makes the class very difficult to test. We need to set up all
    these things before we can run test methods against that class. Reuse is limited
    with a class like this. The class is very tightly bound to the mix of features
    that are rolled into it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 理解低内聚的代码很困难。我们被迫同时理解许多不同的想法。在内部，代码非常相互连接。改变一个方法通常会导致其他方法的改变，因为这种相互连接。使用这个类很困难，因为我们需要构建它时包含所有的依赖项。在我们的例子中，我们有一个模板引擎、数据库和创建网页的代码的混合。这也使得这个类非常难以测试。在我们可以对这个类运行测试方法之前，我们需要设置所有这些事情。这样的类重用性有限。这个类与它所包含的功能组合非常紧密地绑定在一起。
- en: High coupling between classes
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类之间的高耦合
- en: 'High coupling describes where one class needs to connect to several others
    before it can be used. This makes it difficult to use in isolation. We need those
    supporting classes to be set up and working correctly before we can use our class.
    For the same reason, we cannot fully understand that class without understanding
    the many interactions it has. As an example, the following UML class diagram shows
    classes with a high degree of coupling between each other:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 高耦合描述的是在某个类可以使用之前，需要连接到几个其他类的情况。这使得它在独立使用时变得困难。在我们能够使用我们的类之前，我们需要确保那些支持类已经设置并正确工作。同样地，如果不理解它所具有的许多交互，我们就无法完全理解那个类。例如，以下UML类图显示了彼此之间具有高度耦合的类：
- en: '![Figure 1.3 – High coupling](img/Figure_1.3_B18384.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3 – 高耦合](img/Figure_1.3_B18384.jpg)'
- en: Figure 1.3 – High coupling
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – 高耦合
- en: 'In this fictitious example of a sales tracking system, several of the classes
    need to interact with each other. The `User` class in the middle couples to four
    other classes: `Inventory`, `EmailService`, `SalesAppointment`, and `SalesReport`.
    This makes it harder to use and test than a class that couples to fewer other
    classes. Is the coupling here too high? Maybe not, but we can imagine other designs
    that would reduce it. The main thing is to be aware of the degree of coupling
    that classes have in our designs. As soon as we spot classes with many connections
    to others, we know we are going to have a problem understanding, maintaining,
    and testing them.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个虚构的销售跟踪系统示例中，有几个类需要相互交互。中间的`User`类与四个其他类耦合：`Inventory`、`EmailService`、`SalesAppointment`和`SalesReport`。这使得它比与其他类耦合较少的类更难以使用和测试。这里的耦合是否过高？也许不是，但我们可以想象出其他可以减少耦合的设计。最重要的是要意识到我们设计中类的耦合程度。一旦我们注意到与其他类有许多连接的类，我们就知道我们将面临理解、维护和测试它们的问题。
- en: We’ve seen how the technical elements of high coupling and low cohesion make
    our code difficult to work with, but there is a social aspect to bad code as well.
    Let’s consider the effect bad code has on the development team.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了高耦合和低内聚的技术元素是如何使我们的代码难以工作的，但糟糕的代码也有一个社会方面。让我们考虑一下糟糕的代码对开发团队的影响。
- en: Decreasing team performance
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 降低团队绩效
- en: A good way to look at bad code is code lacking the technical practices that
    help other developers understand what it is doing.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 评估糟糕代码的一个好方法就是代码缺乏帮助其他开发者理解其功能的那些技术实践。
- en: When you’re coding solo, it doesn’t matter so much. Bad code will just slow
    you down and feel a little demoralizing at times. It does not affect anybody else.
    However, most professionals code in development teams, which is a whole different
    ball game. Bad code really slows a team down.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当你单独编码时，这并不那么重要。糟糕的代码只会让你慢下来，有时会让人感到有点泄气。它不会影响任何人。然而，大多数专业人士是在开发团队中编码的，这是一个完全不同的游戏。糟糕的代码真的会拖慢团队的速度。
- en: 'The following two studies are interesting as far as this is concerned:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这一点，以下两项研究很有趣：
- en: '[https://dl.acm.org/doi/abs/10.1145/3194164.3194178](https://dl.acm.org/doi/abs/10.1145/3194164.3194178)'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://dl.acm.org/doi/abs/10.1145/3194164.3194178](https://dl.acm.org/doi/abs/10.1145/3194164.3194178)'
- en: '[https://www.sciencedirect.com/science/article/abs/pii/S0164121219301335](https://www.sciencedirect.com/science/article/abs/pii/S0164121219301335)'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.sciencedirect.com/science/article/abs/pii/S0164121219301335](https://www.sciencedirect.com/science/article/abs/pii/S0164121219301335)'
- en: The first study shows that developers waste up to 23% of their time on bad code.
    The second study shows that in 25% of cases of working with bad code, developers
    are forced to increase the amount of bad code still further. In these two studies,
    the term **technical debt** is used, rather than referring to bad code. There
    is a difference in intention between the two terms. Technical debt is code that
    is shipped with known technical deficiencies in order to meet a deadline. It is
    tracked and managed with the intention that it will later be replaced. Bad code
    might have the same defects, but it lacks the redeeming quality of intentionality.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第一项研究表明，开发者将高达23%的时间浪费在糟糕的代码上。第二项研究表明，在25%的与糟糕代码合作的情况下，开发者被迫进一步增加糟糕代码的数量。在这两项研究中，使用了**技术债务**这个术语，而不是直接指代糟糕的代码。这两个术语在意图上有所不同。技术债务是指为了满足截止日期而发布的已知技术缺陷的代码。它被跟踪和管理，目的是将来替换它。糟糕的代码可能存在相同的缺陷，但它缺乏有意性的救赎品质。
- en: It is all too easy to check in code that has been easy to write but will be
    hard to read. When I do that, I have effectively placed a tax on the team. The
    next developer to pull my changes will have to figure out what on earth they need
    to do and my bad code will have made that much harder.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 检入易于编写但难以阅读的代码真是太容易了。当我这样做的时候，我实际上对团队征收了一项税。下一个拉取我更改的开发者将不得不弄清楚他们到底需要做什么，而我糟糕的代码会让这一切变得更加困难。
- en: We’ve all been there. We start a piece of work, download the latest code, and
    then just stare at our screens for ages. We see variable names that make no sense,
    mixed up with tangled code that really does not explain itself very well at all.
    It’s frustrating for us personally, but it has a real cost in a programming business.
    Every minute we spend not understanding code is a minute where money is being
    spent on us achieving nothing. It’s not what we dreamed of when we signed up to
    be a developer.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都经历过这种情况。我们开始一项工作，下载最新的代码，然后只是长时间地盯着屏幕。我们看到一些没有意义的变量名，与纠缠不清的代码混合在一起，这些代码根本无法很好地解释自己。这对我们个人来说很令人沮丧，但在编程业务中，这确实有实际的成本。我们每浪费一分钟不理解代码，就意味着我们在浪费时间，而没有任何成果。这不是我们签上成为开发者时梦寐以求的事情。
- en: Bad code disrupts every future developer who has to read the code, even us,
    the original authors. We forget what we previously meant. Bad code means more
    time spent by developers fixing mistakes, instead of adding value. It means more
    time is lost on fixing bugs in production that should have been easily preventable.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕的代码会干扰每一个必须阅读代码的未来开发者，甚至包括我们，原始的作者。我们忘记了我们之前的意思。糟糕的代码意味着开发者花费更多的时间修复错误，而不是增加价值。这意味着在生产环境中修复本应轻易预防的错误的更多时间被浪费了。
- en: Worse still, this problem compounds. It is like interest on a bank loan. If
    we leave bad code in place, the next feature will involve adding workarounds for
    the bad code. You may see extra conditionals appear, giving the code yet more
    execution paths and creating more places for bugs to hide. Future features build
    on top of the original bad code and all of its workarounds. It creates code where
    most of what we read is simply working around what never worked well in the first
    place.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，这个问题会加剧。它就像银行贷款的利息。如果我们留下糟糕的代码，下一个功能将涉及为糟糕的代码添加解决方案。你可能会看到额外的条件出现，给代码带来更多的执行路径，并为错误隐藏创造更多的地方。未来的功能建立在原始糟糕代码及其所有解决方案之上。它创建的代码中，我们阅读的大部分内容仅仅是围绕一开始就不好用的东西进行工作。
- en: Code of this kind drains the motivation out of developers. The team starts spending
    more time working around problems than they spend adding value to the code. None
    of this is *fun* for the typical developer. It’s not fun for anybody on the team.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的代码耗尽了开发者的动力。团队开始花更多的时间解决问题，而不是在代码中增加价值。对典型的开发者来说，这一切都不是**有趣**的。对团队中的任何人都不是有趣的事情。
- en: Project managers lose track of the project status. Stakeholders lose confidence
    in the team’s ability to deliver. Costs overrun. Deadlines slip. Features get
    quietly cut, just to claw back a little slack in the schedule. Onboarding new
    developers becomes painful, to the point of awkwardness, whenever they see the
    awful code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 项目经理们失去了对项目进度的掌控。利益相关者对团队交付能力失去了信心。成本超支。截止日期推迟。功能被悄悄削减，只是为了在日程安排上稍微松一口气。每当新开发者看到糟糕的代码时，入职过程变得痛苦，甚至尴尬。
- en: Bad code leaves the whole team unable to perform to the level they are capable
    of. This, in turn, does not make for a happy development team. Beyond unhappy
    developers, it also negatively impacts business outcomes. Let’s understand those
    consequences.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕的代码让整个团队无法发挥他们应有的水平。这反过来又不会让开发团队感到快乐。除了不快乐的开发者之外，它还会对商业成果产生负面影响。让我们了解这些后果。
- en: Diminishing business outcomes
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下降的商业成果
- en: It’s not just the development team who suffers from the effects of bad code.
    It’s bad for the entire business.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 受到糟糕代码影响的不仅仅是开发团队。这对整个企业都是有害的。
- en: Our poor users end up paying for software that doesn’t work, or at least that
    doesn’t work properly. There are many ways that bad code can mess up a user’s
    day, whether as a result of lost data, unresponsive user interfaces, or any kind
    of intermittent fault. Each one of these can be caused by something as trivial
    as setting a variable at the wrong time or an off-by-one error in a conditional
    somewhere.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可怜的用户最终为不工作的软件付费，或者至少是工作不正常的软件付费。糟糕的代码有无数种方式可以破坏用户的一天，无论是由于数据丢失、无响应的用户界面，还是任何类型的间歇性故障。这些中的每一个都可能是由一些微不足道的事情引起的，比如在错误的时间设置变量，或者在某个条件中的错误计算。
- en: The users see neither any of that nor the thousands of lines of code that we
    got right. They just see their missed payment, their lost document that took 2
    hours to type, or that fantastic *last-chance* ticket deal that simply never happened.
    Users have little patience for things like this. Defects of this kind can easily
    lose us a valuable customer.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 用户看不到任何这些，也看不到我们正确编写的数千行代码。他们只看到他们错过的付款，他们丢失的耗时两小时打出的文档，或者那个绝妙的*最后机会*票务交易，它根本就没有发生。用户对这类事情几乎没有耐心。这种类型的缺陷很容易让我们失去一个宝贵的客户。
- en: If we are lucky, users will fill out a bug report. If we are really lucky, they
    will let us know what they were doing at the time and provide us with the right
    steps to reproduce the fault. But most users will just hit delete on our app.
    They’ll cancel future subscriptions and ask for refunds. They’ll go to review
    sites and let the world know just how useless our app and company are.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们很幸运，用户会填写一个错误报告。如果我们非常幸运，他们会告诉我们当时在做什么，并为我们提供重现错误的正确步骤。但大多数用户只是在我们应用的错误上点击删除。他们会取消未来的订阅并要求退款。他们会去评论网站，让全世界都知道我们的应用和公司是多么的无用。
- en: At this point, it isn’t merely bad code; it is a commercial liability. The failures
    and honest human errors in our code base are long forgotten. Instead, we were
    just a competitor business that came and went in a blaze of negativity.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个时候，这不仅仅是糟糕的代码；它已经成为一种商业责任。我们代码库中的失败和诚实的人类错误已经被人遗忘。相反，我们只是在一个充满负面情绪的竞争中来去的企业。
- en: Decreased revenue leads to decreased market share, a reduced **Net Promoter
    Score®™** (**NPS**), disappointed shareholders, and all the other things that
    make your C-suite lose sleep at night. Our bad code has become a problem at the
    business level.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 收入下降导致市场份额下降，**净推荐者得分®™**（NPS）降低，股东失望，以及所有让您的C级管理层在夜晚失眠的其他事情。我们的糟糕代码已经成为企业层面的问题。
- en: This isn’t hypothetical. There have been several incidents where software failures
    have cost the business. Security breaches for Equifax, Target, and even the Ashley
    Madison site all resulted in losses. The Ariane rocket resulted in the loss of
    both spacecraft and satellite payload, a total cost of billions of dollars! Even
    minor incidents resulting in downtime for e-commerce systems can soon have costs
    mounting, while consumer trust crashes down.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是假设。已经发生了几起软件故障导致企业损失的事件。Equifax、Target以及甚至Ashley Madison网站的网络安全漏洞都导致了损失。Ariane火箭导致航天器和卫星有效载荷损失，总成本数十亿美元！即使是导致电子商务系统停机的轻微事件，也会很快导致成本上升，而消费者信任也会崩溃。
- en: In each case, the failures may have been small errors in comparatively few lines
    of code. Certainly, they will have been avoidable in some way. We know that humans
    make mistakes, and that all software is built by humans, yet a little extra help
    may have been all it would have taken to stop these disasters from unfolding.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，失败可能只是相对较少的代码行中的小错误。当然，它们在某种程度上是可以避免的。我们知道人类会犯错误，而且所有软件都是由人类编写的，但可能只需要一点额外的帮助就能阻止这些灾难的发生。
- en: 'The advantage of finding failures early is shown in the following diagram:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 早期发现失败的优势在以下图表中体现：
- en: '![Figure 1.4 – Costs of defect discovery](img/Figure_1.4_B18384.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4 – 缺陷发现成本](img/Figure_1.4_B18384.jpg)'
- en: Figure 1.4 – Costs of defect discovery
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – 缺陷发现成本
- en: 'In the previous figure, the cost of the repair of a defect gets higher the
    later it is found:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，缺陷修复的成本随着发现时间的延迟而增加：
- en: 'Found by a failing test before code:'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码之前通过失败的测试发现的：
- en: The cheapest and fastest way to discover a defect is by writing a test for a
    feature before we write the production code. If we write the production code that
    we expect should make the test pass, but instead the test fails, we know there
    is a problem in our code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 发现缺陷最便宜、最快的方法是在编写生产代码之前为特性编写测试。如果我们编写了预期会使测试通过的生产代码，但测试却失败了，我们就知道我们的代码中存在问题。
- en: 'Found by a failing test after code:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码之后通过失败的测试发现的：
- en: If we write the production code for a feature, and then write a test afterward,
    we may find defects in our production code. This happens a little later in the
    development cycle. We will have wasted a little more time before discovering the
    defect.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为特性编写了生产代码，然后编写测试，我们可能会在我们的生产代码中发现缺陷。这发生在开发周期稍晚的时候。在发现缺陷之前，我们会浪费更多的时间。
- en: 'Found during manual QA:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在手动QA过程中发现：
- en: Many teams include **Quality Assurance (QA)** engineers. After code has been
    written by a developer, the QA engineer will manually test the code. If a defect
    is found here, this means significant time has passed since the developer first
    wrote the code. Rework will have to be done.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 许多团队包括**质量保证（QA）**工程师。在开发者编写代码之后，QA工程师将手动测试代码。如果在这里发现缺陷，这意味着自开发者首次编写代码以来已经过去了很长时间。需要进行返工。
- en: 'Found by the end user once code is in production:'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码在生产环境中被最终用户发现：
- en: This is as bad as it gets. The code has been shipped to production and end users
    are using it. An end user finds a bug. The bug has to be reported, triaged, a
    fix scheduled for development, then retested by QA then redeployed to production.
    This is the slowest and most expensive path to discovering a defect.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最糟糕的情况。代码已经部署到生产环境中，最终用户正在使用它。一个最终用户发现了一个错误。错误必须被报告、分类，然后为开发安排修复，之后由QA重新测试，最后重新部署到生产环境。这是发现缺陷最慢且最昂贵的方法。
- en: The earlier we find the fault, the less time and money we will have to spend
    on correcting it. The ideal is to have a failing test before we even write a line
    of code. This approach also helps us design our code. The later we leave it to
    find a mistake, the more trouble it causes for everyone.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们越早发现故障，我们纠正它所需的时间和金钱就越少。理想的情况是在我们甚至写下一行代码之前就有一个失败的测试。这种方法也有助于我们设计代码。我们越晚留出时间来发现错误，它给每个人带来的麻烦就越大。
- en: We’ve seen how low-quality code gives rise to defects and is bad for business.
    The earlier we detect failures, the better it is for us. Leaving defects in production
    code is both difficult and expensive to fix, and negatively affects our business
    reputation.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到低质量代码如何导致缺陷，对业务不利。我们越早检测到失败，对我们越好。将缺陷留在生产代码中既困难又昂贵，还会对我们的商业声誉产生负面影响。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We can now recognize bad code from its technical signs and appreciate the problems
    that it causes for both development teams and business outcomes.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以从其技术特征中识别出糟糕的代码，并欣赏它给开发团队和业务结果带来的问题。
- en: What we need is a technique to help us avoid these problems. In the next chapter,
    we’ll take a look at how TDD helps us deliver clean, correct code that is a true
    business asset.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种技术来帮助我们避免这些问题。在下一章中，我们将探讨TDD如何帮助我们交付干净、正确的代码，这是真正的商业资产。
- en: Questions and answers
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题和答案
- en: Isn’t it enough to have working code?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有工作代码就足够了吗？
- en: Sadly not. Code that meets user needs is an entry-level step with professional
    software. We also need code that we *know* works, and that the team can easily
    understand and modify.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾不是。满足用户需求的代码是专业软件的入门级步骤。我们还需要我们知道可以正常工作的代码，以及团队可以轻松理解和修改的代码。
- en: Users don’t see the code. Why does it matter to them?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户看不到代码。为什么这对他们很重要？
- en: This is true. However, users expect things to work reliably, and they expect
    our software to be updated and improved continuously. This is only possible when
    the developers can work safely with the existing code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是真的。然而，用户期望事物能够可靠地工作，他们期望我们的软件能够持续更新和改进。这只有在开发者能够安全地使用现有代码时才可能实现。
- en: Is it easier to write good code or bad code?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写好代码更容易还是写坏代码更容易？
- en: It is much harder to write good code, unfortunately. Good code does more than
    simply work correctly. It must also be easy to read, easy to change, and safe
    for our colleagues to work with. That’s why techniques such as TDD have an important
    role to play. We need all the help we can get to write clean code that helps our
    colleagues.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 很不幸，编写好的代码要困难得多。好的代码不仅仅是工作正确，它还必须易于阅读、易于修改，并且对同事来说是安全的。这就是为什么TDD等技术扮演着重要的角色。我们需要尽可能多的帮助来编写有助于同事的整洁代码。
- en: Further reading
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'More about the loss of the Ariane rocket: [https://www.esa.int/Newsroom/Press_Releases/Ariane_501_-_Presentation_of_Inquiry_Board_report](https://www.esa.int/Newsroom/Press_Releases/Ariane_501_-_Presentation_of_Inquiry_Board_report)'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于阿丽亚娜火箭损失的信息：[https://www.esa.int/Newsroom/Press_Releases/Ariane_501_-_Presentation_of_Inquiry_Board_report](https://www.esa.int/Newsroom/Press_Releases/Ariane_501_-_Presentation_of_Inquiry_Board_report)
