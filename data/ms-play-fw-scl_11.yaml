- en: Chapter 11. Web Services and Authentication
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。网络服务和身份验证
- en: The internet is vast and constantly expanding. A lot of day-to-day tasks can
    be dealt with in a simpler manner—bill payments, checking reviews of a product,
    booking movie tickets, and so on. In addition to this, most electronic devices
    can now be connected to the Internet, such as mobile phones, watches, surveillance
    systems, and security systems. These can communicate with each other and they
    need not all be of the same brand. Applications can utilize user-specific information
    and provide features with better customization. Most importantly, we can decide
    if we wish to share our information with the application by authenticating it
    or not.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网浩瀚且不断扩展。许多日常任务都可以以更简单的方式进行——账单支付、检查产品评论、预订电影票等。除此之外，大多数电子设备现在都可以连接到互联网，例如手机、手表、监控系统和安全系统。这些设备可以相互通信，而且它们不必都是同一品牌。应用程序可以利用用户特定的信息并提供更定制化的功能。最重要的是，我们可以通过验证来决定是否愿意与应用程序共享我们的信息。
- en: 'In this chapter, we will cover Play Framework''s support for the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍Play框架对以下内容的支持：
- en: Calling web services
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用网络服务
- en: OpenID and OAuth authentication
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenID和OAuth身份验证
- en: Calling web services
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用网络服务
- en: Suppose we need to book a flight ticket online. We can do this by using either
    the website of the flight's brand (such as Lufthansa, Emirates, and so on), or
    a travel booking website (such as ClearTrip, MakeMyTrip, and so on). How is it
    that we can do the same task from two or more different websites?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要在线预订机票。我们可以通过使用飞行品牌的网站（如汉莎航空、阿联酋航空等）或旅行预订网站（如ClearTrip、MakeMyTrip等）来完成这项任务。我们如何从两个或更多不同的网站完成相同的任务呢？
- en: The website of the flight's brand provides some APIs with which the travel booking
    websites work. These API can be freely available or charged by a contract, which
    is for the provider and the other third-party involved to decide. These APIs are
    also called web services.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 飞行品牌的网站提供了一些API，这些API是旅行预订网站工作的。这些API可以是免费提供的，也可以通过合同收费，由提供者和其他第三方决定。这些API也被称为网络服务。
- en: A web service is more or less a method that is called over the Internet. Only
    the provider is fully aware of the internal working of these sites. Those who
    use the web service are only aware of the purpose and its possible outcome.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务基本上是一种通过互联网调用的方法。只有提供者完全了解这些网站的内部运作。使用网络服务的人只知道其目的和可能的后果。
- en: Many applications require/prefer to use third-party APIs to complete common
    tasks for various reasons, such as common norms in the business domain, easier
    means to provide secure authorization, or to avoid the overhead of maintenance,
    and so on.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序出于各种原因需要/更喜欢使用第三方API来完成常见任务，例如业务领域的通用规范、提供安全授权的更简单方式，或避免维护开销等。
- en: 'The Play Framework has a web service API specifically to meet such requirements.
    The web service API can be used by including it as a dependency:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Play框架有一个专门满足此类需求的网络服务API。可以通过将其作为依赖项包含来使用网络服务API：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A common use case is to send an e-mail with the link for account verification
    and/or resetting the password using a transactional e-mail API service, such as
    Mailgun, SendGrid, and so on.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的用例是使用事务性电子邮件API服务（如Mailgun、SendGrid等）发送带有账户验证和/或重置密码链接的电子邮件。
- en: 'Let''s assume that our application has such a requirement, and we have an `Email`
    object that handles all these kind of transactions. We need one method to send
    e-mails that makes actual calls to the e-mailing API service, and then other methods
    that internally call send. Using the Play web service API, we could define `Email`
    as:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的应用程序有这样的需求，并且我们有一个处理所有这些交易的`Email`对象。我们需要一个发送电子邮件的方法，它实际上会调用电子邮件API服务，然后是其他内部调用发送的方法。使用Play网络服务API，我们可以将`Email`定义为：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The web service API is exposed through the `WS` object, which provides methods
    to query web services as an HTTP client. In the preceding code snippet, we have
    used the web service API to make a post request. Other available methods to trigger
    a request and fetch a response or response stream are:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务API通过`WS`对象公开，该对象提供了作为HTTP客户端查询网络服务的方法。在前面的代码片段中，我们使用了网络服务API来发起一个POST请求。其他可用的方法来触发请求并获取响应或响应流包括：
- en: '`get` or `getStream`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`或`getStream`'
- en: '`put` or `putAndRetrieveStream`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`put`或`putAndRetrieveStream`'
- en: '`post` or `postAndRetrieveStream`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post`或`postAndRetrieveStream`'
- en: '`delete`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete`'
- en: '`head`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`head`'
- en: The result of any of these calls is of the `Future[WSResponse]` type, so we
    can safely say that the web service API is asynchronous.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些调用中的任何结果都是 `Future[WSResponse]` 类型，因此我们可以安全地说，网络服务 API 是异步的。
- en: 'It is not restricted to REST services. For example, let''s say we use a SOAP
    service to fetch the currencies of all countries:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 它不仅限于 REST 服务。例如，假设我们使用 SOAP 服务来获取所有国家的货币：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'An HTTP request can be built using `WS.url()`, which returns an instance of
    `WSRequestHolder`. The `WSRequestHolder` trait has methods to add headers, authentication,
    request parameters, data, and so on. Here is another example of commonly used
    methods:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `WS.url()` 构建一个 HTTP 请求，它返回一个 `WSRequestHolder` 实例。`WSRequestHolder` 特性有添加头部、身份验证、请求参数、数据等方法。以下是一个常用方法的另一个示例：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Although in this example we have used Basic authentication, the web service
    API supports most of the commonly used authentication schemes, which you can find
    at the following links:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这个例子中我们使用了基本身份验证，但网络服务 API 支持大多数常用的身份验证方案，您可以在以下链接中找到：
- en: '**Basic**: [http://en.wikipedia.org/wiki/Basic_access_authentication](http://en.wikipedia.org/wiki/Basic_access_authentication)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本**: [http://en.wikipedia.org/wiki/Basic_access_authentication](http://en.wikipedia.org/wiki/Basic_access_authentication)'
- en: '**Digest**: [http://en.wikipedia.org/wiki/Digest_access_authentication](http://en.wikipedia.org/wiki/Digest_access_authentication)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摘要**: [http://en.wikipedia.org/wiki/Digest_access_authentication](http://en.wikipedia.org/wiki/Digest_access_authentication)'
- en: '**Simple and** **Protected GSSAPI Negotiation Mechanism (SPNEGO)**: [http://en.wikipedia.org/wiki/SPNEGO](http://en.wikipedia.org/wiki/SPNEGO)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单且受保护的 GSSAPI 协商机制 (SPNEGO)**: [http://en.wikipedia.org/wiki/SPNEGO](http://en.wikipedia.org/wiki/SPNEGO)'
- en: '**NT LAN** **Manager (NTLM)**: [http://en.wikipedia.org/wiki/NT_LAN_Manager](http://en.wikipedia.org/wiki/NT_LAN_Manager)'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NT LAN 管理器 (NTLM)**: [http://en.wikipedia.org/wiki/NT_LAN_Manager](http://en.wikipedia.org/wiki/NT_LAN_Manager)'
- en: '**Kerberos**: [http://en.wikipedia.org/wiki/Kerberos_(protocol)](http://en.wikipedia.org/wiki/Kerberos_(protocol))'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kerberos**: [http://en.wikipedia.org/wiki/Kerberos_(protocol)](http://en.wikipedia.org/wiki/Kerberos_(protocol))'
- en: 'All the methods available through the `WS` object simply call the relevant
    methods of the available `WSAPI` trait''s implementation. The web service API
    provided by default utilizes Ning''s AysncHttpClient (refer to [https://github.com/AsyncHttpClient/async-http-client](https://github.com/AsyncHttpClient/async-http-client)).
    If we wish to use any other HTTP client, we need to implement the `WSAPI` trait
    and bind it through a plugin. When we add the `ws` Play library, it adds `play.api.libs.ws.ning.NingWSPlugin`
    to our application, which is defined as:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `WS` 对象可用的所有方法只是调用可用的 `WSAPI` 特性的实现中的相关方法。默认提供的网络服务 API 使用 Ning 的 AysncHttpClient（请参阅
    [https://github.com/AsyncHttpClient/async-http-client](https://github.com/AsyncHttpClient/async-http-client)）。如果我们想使用任何其他
    HTTP 客户端，我们需要实现 `WSAPI` 特性并通过插件绑定它。当我们添加 `ws` Play 库时，它将 `play.api.libs.ws.ning.NingWSPlugin`
    添加到我们的应用程序中，该插件定义为：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In a Play app, using SSL with WS requires a few changes in the configuration,
    and it is documented at [https://www.playframework.com/documentation/2.3.x/WsSSL](https://www.playframework.com/documentation/2.3.x/WsSSL).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Play 应用中，使用 SSL 与 WS 需要对配置进行一些更改，并在 [https://www.playframework.com/documentation/2.3.x/WsSSL](https://www.playframework.com/documentation/2.3.x/WsSSL)
    中有文档说明。
- en: Since a huge number of applications rely on a user's data from various sources,
    Play provides an API for OpenID and OAuth. We will discuss these in the following
    sections.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大量应用程序依赖于来自各种来源的用户数据，Play 提供了 OpenID 和 OAuth 的 API。我们将在以下章节中讨论这些内容。
- en: OpenID
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenID
- en: OpenID is an authentication protocol, wherein OpenID Providers validate the
    identity of a user for third-party applications. An OpenID Provider is any service/application
    that provides an OpenID to users. Yahoo, AOL, and others are a few examples of
    these. Applications that require a user's OpenID to complete transactions are
    known as OpenID Consumers.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: OpenID 是一种身份验证协议，其中 OpenID 提供商验证第三方应用程序中用户的身份。OpenID 提供商是任何向用户提供 OpenID 的服务/应用程序。Yahoo、AOL
    等是这些服务/应用程序的几个例子。需要用户 OpenID 来完成交易的应用程序被称为 OpenID 消费者。
- en: 'The flow of control in an OpenID Consumer is as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: OpenID 消费者中的控制流程如下：
- en: The user is directed to the login page of the supported/selected OpenID Provider.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户将被引导到支持的/选定的 OpenID 提供商的登录页面。
- en: Once the user completes logging in, the OpenID Provider informs the user about
    user-related data requested by the OpenID Consumer.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦用户完成登录，OpenID 提供商会告知用户 OpenID 消费者请求的用户相关数据。
- en: If the user agrees to share the information, he or she is redirected to the
    page requested by him or her on the consumer application. The information is added
    to the request URL. The information is termed as attribute properties and this
    is documented at [http://openid.net/specs/openid-attribute-properties-list-1_0-01.html](http://openid.net/specs/openid-attribute-properties-list-1_0-01.html).
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户同意共享信息，则会被重定向到消费者应用程序中请求的页面。信息被添加到请求 URL 中。这些信息被称为属性属性，相关文档位于 [http://openid.net/specs/openid-attribute-properties-list-1_0-01.html](http://openid.net/specs/openid-attribute-properties-list-1_0-01.html)。
- en: Play provides an API to simplify OpenID transactions, which is documented at
    [https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.libs.openid.OpenID$](https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.libs.openid.OpenID$).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Play 提供了一个 API 来简化 OpenID 交易，相关文档位于 [https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.libs.openid.OpenID$](https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.libs.openid.OpenID$)。
- en: 'Two critical methods are as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个关键方法如下：
- en: '`redirectURL`: This is used for verifying the user, requesting specific user
    information and redirecting it to the callback page'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redirectURL`：此参数用于验证用户、请求特定用户信息并将其重定向到回调页面'
- en: '`verifiedId`: This is used to extract user information from a verified OpenID
    callback request'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`verifiedId`：此参数用于从已验证的 OpenID 回调请求中提取用户信息'
- en: 'Let''s build an application that uses OpenID from the provider, Yahoo. We can
    define the controller as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个使用提供者 Yahoo 的 OpenID 的应用程序。我们可以定义控制器如下：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code snippet, the `login` method redirects the user to the
    Yahoo login page (refer to [https://me.yahoo.com](https://me.yahoo.com)). Once
    the user logs in, he or she is asked if the user's profile can be shared by the
    application. If the user agrees, it redirects to `routes.Application.index.absoluteURL()`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`login` 方法将用户重定向到 Yahoo 登录页面（参考 [https://me.yahoo.com](https://me.yahoo.com)）。一旦用户登录，系统会询问用户是否允许应用程序共享其个人资料。如果用户同意，则会重定向到
    `routes.Application.index.absoluteURL()`。
- en: The `index` method expects data shared by the OpenID Provider (Yahoo, in our
    case) on a successful login. If it is not available, the user is redirected to
    the `login` method.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`index` 方法期望在登录成功时由 OpenID 提供商（在我们的例子中是 Yahoo）共享的数据。如果数据不可用，用户将被重定向到 `login`
    方法。'
- en: The third parameter for `OpenID.redirectURL` is a sequence of tuples which indicates
    the information required by the application (required attributes). The second
    element in each tuple label of the attribute property is requested using OpenID
    Attribute Exchange—it enables the transport of personal identity information.
    The first element in each tuple is the label with which the value for the attribute
    property should be mapped by the OpenID Provider in the callback request's `queryString`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenID.redirectURL` 的第三个参数是一个元组序列，它指示应用程序所需的信息（所需属性）。每个元组的第二个元素是使用 OpenID
    属性交换请求的属性属性的标签——它使得个人身份信息的传输成为可能。每个元组的第一个元素是 OpenID 提供者在回调请求的 `queryString` 中映射属性属性值的标签。'
- en: For example, the `http://openid.net/schema/namePerson/first` property represents
    the attribute property by its first name. On successful login, the value of this
    property and the label provided by the consumer are added to the `queryString`
    in the callback. So, `openid.ext1.value.name=firstName` is added to the login
    callback.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`http://openid.net/schema/namePerson/first` 属性通过其名字表示属性属性。在登录成功后，此属性的值和消费者提供的标签会被添加到回调中的
    `queryString`。因此，`openid.ext1.value.name=firstName` 会被添加到登录回调中。
- en: OAuth
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth
- en: 'According to [http://oauth.net/core/1.0/](http://oauth.net/core/1.0/), the
    definition of OAuth is as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 [http://oauth.net/core/1.0/](http://oauth.net/core/1.0/)，OAuth 的定义如下：
- en: '*"OAuth authentication is the process in which Users grant access to their
    Protected Resources without sharing their credentials with the Consumer. OAuth
    uses Tokens generated by the Service Provider instead of the User''s credentials
    in Protected Resources requests. The process uses two Token types:*'
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “OAuth 认证是用户在不与消费者共享其凭据的情况下授予其受保护资源访问权限的过程。OAuth 使用服务提供商生成的令牌，而不是在受保护资源请求中使用用户的凭据。此过程使用两种令牌类型：”
- en: ''
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Request Token: Used by the Consumer to ask the User to authorize access to
    the Protected Resources. The User-authorized Request Token is exchanged for an
    Access Token, MUST only be used once, and MUST NOT be used for any other purpose.
    It is RECOMMENDED that Request Tokens have a limited lifetime.*'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*请求令牌：由消费者用于请求用户授权访问受保护资源。用户授权的请求令牌被交换为访问令牌，必须只使用一次，并且不得用于其他任何目的。建议请求令牌有有限的有效期。*'
- en: ''
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Access Token: Used by the Consumer to access the Protected Resources on behalf
    of the User. Access Tokens MAY limit access to certain Protected Resources, and
    MAY have a limited lifetime. Service Providers SHOULD allow Users to revoke Access
    Tokens. Only the Access Token SHALL be used to access the Protect Resources.*'
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*访问令牌：由消费者代表用户访问受保护资源。访问令牌可以限制对某些受保护资源的访问，并且可能有有限的有效期。服务提供商应允许用户撤销访问令牌。仅访问令牌应用于访问受保护资源。*'
- en: ''
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*OAuth Authentication is done in three steps:*'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*OAuth认证分为三个步骤：*'
- en: ''
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The Consumer obtains an unauthorized Request Token.*'
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*消费者获取一个未经授权的请求令牌。*'
- en: ''
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The User authorizes the Request Token.*'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*用户授权请求令牌。*'
- en: ''
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The Consumer exchanges the Request Token for an Access Token."*'
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*消费者将请求令牌交换为访问令牌。"*'
- en: Exactly what and how much of it is accessible is decided solely by the service
    provider.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 具体可以访问什么以及可以访问多少由服务提供商决定。
- en: 'There are three versions of OAuth: 1.0, 1.0a, and 2.0\. The first one (1.0)
    has some security issues and is not used anymore by service providers.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth有三个版本：1.0、1.0a和2.0。第一个版本（1.0）存在一些安全问题，并且服务提供商不再使用。
- en: Play provides an API for using 1.0 and 1.0a and not for 2.0, since using this
    is a lot simpler. The API is documented at [https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.libs.oauth.package](https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.libs.oauth.package).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Play提供了用于1.0和1.0a版本的API，而不是用于2.0，因为使用这个版本要简单得多。API文档位于[https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.libs.oauth.package](https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.libs.oauth.package)。
- en: Let's build an app to that utilizes a Twitter account to log in using Play's
    OAuth API.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个应用程序，该程序利用Twitter账户通过Play的OAuth API进行登录。
- en: 'Initially, we''ll need to register the app at [https://apps.twitter.com/](https://apps.twitter.com/)
    using a Twitter account so that we have a valid consumer key and secret combination.
    After this, we can define the action as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们需要使用Twitter账户在[https://apps.twitter.com/](https://apps.twitter.com/)注册应用程序，以便我们有一个有效的消费者密钥和密钥组合。之后，我们可以定义如下动作：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'OAuth is a Play helper class and has this signature:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth是Play的一个辅助类，具有以下签名：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The parameter determines the version of OpenID. If it's set to `true`, it uses
    OpenID 1.0 or else, 1.0.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 参数确定OpenID的版本。如果设置为`true`，则使用OpenID 1.0，否则使用1.0。
- en: 'It provides these three methods:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了这三个方法：
- en: '`redirectURL`: This fetches the URL string where a user should be redirected
    to authorize the application through the provider'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redirectURL`: 这将获取用户应重定向到的URL字符串，以便通过提供者授权应用程序'
- en: '`retrieveRequestToken`: This fetches the request token from the provider'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retrieveRequestToken`: 这从提供者那里获取请求令牌'
- en: '`retrieveAccessToken`: This exchanges the request token for an access token'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retrieveAccessToken`: 这将请求令牌交换为访问令牌'
- en: In the preceding action definition, we only use the provider to login; we cannot
    get any user details unless we do not exchange the authorized request token for
    an access token. To get the access token, we need the request token and `oauth_verifier`,
    which is provided by the service provider when granting the request token.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的动作定义中，我们只使用提供者进行登录；除非我们用访问令牌交换授权的请求令牌，否则我们无法获取任何用户详情。要获取访问令牌，我们需要请求令牌和`oauth_verifier`，这是服务提供商在授予请求令牌时提供的。
- en: 'Using the Play OAuth API, redirecting after obtaining a request token adds
    `oauth_verifier` to the request query string. So, we should redirect to an action
    that attempts to obtain the access token and then store it, so that it is easily
    accessible for future requests. In this example, it''s stored in the Session:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Play OAuth API，在获取请求令牌后进行重定向会将`oauth_verifier`添加到请求查询字符串中。因此，我们应该重定向到一个尝试获取访问令牌并随后存储它的动作，以便它对未来的请求易于访问。在这个例子中，它被存储在会话中：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: On successful login and authorization by the user, we fetch the status on a
    user's timeline and display it as JSON using the welcome action.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户成功登录和授权后，我们通过welcome动作获取用户时间轴上的状态并将其作为JSON显示。
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is no built-in support in Play for authentication using OAuth 2.0, CAS,
    SAML, or any other protocol. However, developers can choose to use a third-party
    plugin or library that suits their requirements. Some of them are Silhouette ([http://silhouette.mohiva.com/v2.0](http://silhouette.mohiva.com/v2.0)),
    deadbolt-2 ([https://github.com/schaloner/deadbolt-2](https://github.com/schaloner/deadbolt-2)),
    play-pac4j ([https://github.com/pac4j/play-pac4j](https://github.com/pac4j/play-pac4j)),
    and so on.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Play中没有内置对使用OAuth 2.0、CAS、SAML或任何其他协议进行身份验证的支持。然而，开发者可以选择使用符合他们要求的第三方插件或库。其中一些包括Silhouette
    ([http://silhouette.mohiva.com/v2.0](http://silhouette.mohiva.com/v2.0))、deadbolt-2
    ([https://github.com/schaloner/deadbolt-2](https://github.com/schaloner/deadbolt-2))、play-pac4j
    ([https://github.com/pac4j/play-pac4j](https://github.com/pac4j/play-pac4j)))等等。
- en: Summary
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the WS (web service) plugin and the API exposed
    through it. We have also seen how to access a user's data from service providers
    using OpenID and OAuth 1.0a (since most service providers use either 1.0a or 2.0),
    with the help of the OpenID and OAuth APIs in Play.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了WS（Web服务）插件以及通过它暴露的API。我们还看到了如何使用OpenID和OAuth 1.0a（因为大多数服务提供商使用1.0a或2.0）从服务提供商访问用户数据，借助Play中的OpenID和OAuth
    API。
- en: In the next chapter, we will see how some of the modules provided by Play work
    and how we can build a custom module using them.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解Play提供的某些模块是如何工作的，以及我们如何使用它们来构建自定义模块。
