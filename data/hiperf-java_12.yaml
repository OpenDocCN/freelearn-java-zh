- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Frameworks for Optimization
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化框架
- en: Optimization frameworks are libraries, tools, and guidelines designed to help
    developers enhance the performance of their Java applications. Examples include
    streamlining processes, reducing resource utilization, and reducing processor
    burdens. That is the focus of this chapter. We will start by looking at asynchronous
    input and output, its importance, and associated libraries and frameworks. The
    chapter then explores buffered input and output to include use cases and performance
    impacts. You can learn how both asynchronous and buffered input/output operations
    can improve efficiency and reduce latency. The benefits of batch operations, and
    related frameworks and APIs, will be explored. We will review techniques to optimize
    batch operations, minimizing resource utilization and maximizing data flow.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 优化框架是旨在帮助开发者提升其Java应用程序性能的库、工具和指南。例如，包括流程简化、资源利用率降低和处理器负担减轻。这正是本章的重点。我们将首先探讨异步输入和输出，其重要性以及相关的库和框架。本章接着探讨缓冲输入和输出，包括用例和性能影响。您可以了解异步和缓冲输入/输出操作如何提高效率并减少延迟。我们将探讨批量操作的好处以及相关的框架和API。我们将回顾优化批量操作的技术，以最小化资源利用并最大化数据流。
- en: The chapter introduces microservices and covers specific frameworks that can
    be used with microservices. These frameworks, along with those for cloud-native
    applications, will be explored, as these advanced architectures are pervasive
    in modern software development. We will highlight how those frameworks can be
    implemented to optimize the performance of our Java applications. To conclude
    the chapter, we will review several case studies and performance analyses, providing
    practical context to use the chapter’s featured frameworks in real-world scenarios.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '本章介绍了微服务，并涵盖了可以与微服务一起使用的特定框架。这些框架以及云原生应用程序框架将被探讨，因为这些高级架构在现代软件开发中普遍存在。我们将强调如何实现这些框架以优化我们的Java应用程序的性能。为了结束本章，我们将回顾几个案例研究和性能分析，提供实际情境，以便在现实场景中使用本章的特色框架。 '
- en: By the end of this chapter, you should have a foundational understanding of
    key frameworks to optimize Java applications. The case studies should help deepen
    your understanding of how these frameworks can impact application performance.
    You should also be comfortable creating and implementing optimization strategies,
    based on the frameworks presented in this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您应该对优化Java应用程序的关键框架有基础的了解。案例研究应该有助于加深您对这些框架如何影响应用程序性能的理解。您还应该能够根据本章介绍的框架创建和实施优化策略。
- en: 'This chapter covers the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主要主题：
- en: Asynchronous input/output
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步输入/输出
- en: Buffered input/output
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲输入/输出
- en: Batch operations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 批量操作
- en: Frameworks for microservices
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务框架
- en: Frameworks for cloud-native applications
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云原生应用程序框架
- en: Case studies and performance analysis
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 案例研究和性能分析
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the examples and instructions in this chapter, you will need the ability
    to load, edit, and run Java code. If you have not set up your development environment,
    refer to [*Chapter 1*](B21942_01.xhtml#_idTextAnchor014), *Peeking Inside the
    Java Virtual* *Machine (JVM)*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章中的示例和说明，您需要具备加载、编辑和运行Java代码的能力。如果您尚未设置您的开发环境，请参阅[*第1章*](B21942_01.xhtml#_idTextAnchor014)，*Java虚拟机（JVM）内部窥视*。
- en: 'The finished code for this chapter can be found here: [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter12](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter12).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码可以在以下位置找到：[https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter12](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter12)。
- en: Asynchronous input/output
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步输入/输出
- en: '**Asynchronous** refers to uncoordinated (unsynchronized) communication operations.
    In the context of input/output operations, data does not have to be transmitted
    in a steady stream. This is a technique that we can use in Java to allow our programs
    to handle input and output operations without blocking the main thread’s execution.
    While it may not always be necessary to employ this technique, it can offer great
    performance advantages when dealing with systems that rely on high responsiveness
    and performance.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步**指的是非协调（非同步）的通信操作。在输入/输出操作的上下文中，数据不必以稳定的流传输。这是一种我们可以在 Java 中使用的技巧，允许我们的程序在不阻塞主线程执行的情况下处理输入和输出操作。虽然不一定总是需要采用这种技术，但它可以提供处理依赖于高响应性和性能的系统时的巨大性能优势。'
- en: For brevity, let’s refer to **asynchronous input/output** using the **AIO**
    acronym. With AIO, we can initiate processes and then have them run independently,
    which allows our main application to continue running other processes. Consider
    the **synchronous** alternative, where the main application must wait for one
    operation to complete before running another one. The synchronous approach can
    result in latency, longer response times, and other inefficiencies.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，让我们用 **AIO** 这个缩写来指代 **异步输入/输出**。使用 AIO，我们可以启动进程，然后让它们独立运行，这允许我们的主应用程序继续运行其他进程。考虑
    **同步**的替代方案，其中主应用程序必须在运行另一个操作之前等待一个操作完成。同步方法可能导致延迟、更长的响应时间和其他低效。
- en: Now that you have a foundational understanding of asynchronous input/output,
    let’s examine the advantages and best practices of using this technique to improve
    Java application performance.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经对异步输入/输出有了基础的了解，让我们来探讨使用这种技术来提高 Java 应用程序性能的优点和最佳实践。
- en: Advantages and best practices
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优点和最佳实践
- en: There are several advantages to AIO, and they are best leveraged when following
    industry best practices. First, we will review the advantages, followed by the
    best practices.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: AIO 有几个优点，并且最好在遵循行业最佳实践的情况下利用它们。首先，我们将回顾优点，然后是最佳实践。
- en: Advantages
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优点
- en: 'Here are three advantages to implementing AIO in our Java applications:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Java 应用程序中实现 AIO 有三个优点：
- en: '**Efficiency**: AIO implementation can result in resource efficiency because
    we can use threads for processing, instead of waiting on input/output operations.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率**：AIO 实现可以带来资源效率，因为我们可以使用线程进行处理，而不是等待输入/输出操作。'
- en: '**Responsiveness**: When we decouple input/output operations from the main
    thread execution, we increase the application’s overall responsiveness. With AIO,
    the main application can remain responsive to input (i.e., user interactions)
    while other input/output operations are occurring.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应性**：当我们解耦输入/输出操作与主线程执行时，我们提高了应用程序的整体响应性。使用 AIO，主应用程序可以保持对输入（即用户交互）的响应，同时其他输入/输出操作正在进行。'
- en: '**Scalability**: If your application needs to be scalable, you will most certainly
    want to consider implementing AIO, which is essential for building scalable applications.
    AIO helps us manage multiple simultaneous connections without the need for additional
    threads. This significantly reduces overhead.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可伸缩性**：如果您的应用程序需要可伸缩性，您肯定会想考虑实现 AIO，这对于构建可伸缩的应用程序至关重要。AIO 帮助我们管理多个同时连接，而无需额外的线程。这显著减少了开销。'
- en: Keeping these advantages in mind, let’s review the best practices to optimize
    them in Java.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑到这些优势的情况下，让我们回顾一下在 Java 中优化它们的最佳实践。
- en: Best practices
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Here are several best practices to help guide your use of AIO:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些最佳实践来帮助指导您对 AIO 的使用：
- en: '**Error handling**: Your AIO implementation strategy should include robust
    error handling to catch and handle exceptions.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误处理**：您的 AIO 实现策略应包括强大的错误处理机制，以捕获和处理异常。'
- en: '**Handlers**: The use of **callback handlers** to react to input/output events
    is advisable to help you keep your code organized and maintainable.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理程序**：建议使用 **回调处理程序**来响应输入/输出事件，以帮助您保持代码的整洁和可维护性。'
- en: '**Resource management**: As with most programming, you should ensure that all
    resources used in your application (i.e., network sockets) are closed after their
    associated operation concludes. This will help prevent resource/memory leaks.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源管理**：与大多数编程一样，您应确保在您的应用程序中使用的所有资源（例如，网络套接字）在相关操作完成后关闭。这将有助于防止资源/内存泄漏。'
- en: We have established that implementing AIO is an approach that can positively
    impact the performance of our applications. In the next section, we will look
    at how to implement AIO in Java.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定实现AIO是一种可以积极影响我们应用程序性能的方法。在下一节中，我们将探讨如何在Java中实现AIO。
- en: Implementing AIO
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现AIO
- en: 'The Java platform includes a **New Input/Output** (**NIO**) library that includes
    the following capabilities:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Java平台包括一个**新输入/输出**（**NIO**）库，它包括以下功能：
- en: '`AsynchronousFileChannel`: This class enables us to read and write from and
    to files without blocking other tasks.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsynchronousFileChannel`：这个类使我们能够从文件中读取和写入数据，而不会阻塞其他任务。'
- en: '`AsynchronousServerSocketChannel` and `AsynchronousSocketChannel`: These classes
    are used to handle asynchronous network operations, which helps make our applications
    scalable.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsynchronousServerSocketChannel`和`AsynchronousSocketChannel`：这些类用于处理异步网络操作，这有助于使我们的应用程序可伸缩。'
- en: '**Channels** and **buffers**: Java’s NIO library relies heavily on channels
    and buffers. Channels are the connections to components that perform input/output
    operations, such as network sockets. Buffers handle the data.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通道**和**缓冲区**：Java的NIO库在通道和缓冲区上有着重度的依赖。通道是执行输入/输出操作的组件的连接，例如网络套接字。缓冲区处理数据。'
- en: 'There are several AIO-related frameworks and libraries available to us, in
    addition to Java NIO. Here are two examples:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Java NIO之外，我们还有几个与AIO相关的框架和库可供选择。以下有两个例子：
- en: '**Akka**: This is a toolkit consisting of libraries to help us build resilient
    Java applications, with a focus on distributed and current systems.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Akka**：这是一个由库组成的工具包，帮助我们构建具有弹性的Java应用程序，重点是分布式和当前系统。'
- en: '**Netty**: This is a framework for high-performance applications that makes
    it easy for developers to create network applications. It supports both AIO and
    event-driven communication models.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Netty**：这是一个用于高性能应用的框架，它使得开发者能够轻松地创建网络应用。它支持异步IO和事件驱动通信模型。'
- en: Let’s look at AIO in code. The following example application demonstrates the
    `AsynchronousFileChannel` class to conduct an asynchronous file read operation.
    As you will see, the application employs a callback mechanism to handle the read
    operation’s completion.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看代码中的AIO。以下示例应用程序演示了`AsynchronousFileChannel`类来执行异步文件读取操作。正如你所看到的，该应用程序使用回调机制来处理读取操作的完成。
- en: 'Our application starts with a series of `import` statements required by it.
    As you can see, we are leveraging Java’s NIO library:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序从一系列它所需的`import`语句开始。正如你所看到的，我们正在利用Java的NIO库：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next is our `main()` class:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们的`main()`类：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we can see from the preceding code, we open the `ch12.txt` file using `AsychnronousFileChannel`.
    We open it asynchronously using `AsynchronousFileChannel.open()`, specify the
    path, and set the read-only open option. Next, we use a `ByteBuffer` to hold the
    data we read from the file. This is a non-blocking method, which immediately returns
    a `Future` object that represents the pending result. We simulate processing other
    tasks during the read operation and print a message from the main thread. Lastly,
    we implemented a while loop to determine whether the read operation was completed
    using `isDone()`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中我们可以看出，我们使用`AsynchronousFileChannel`打开`ch12.txt`文件。我们使用`AsynchronousFileChannel.open()`异步打开它，指定路径，并设置只读打开选项。接下来，我们使用`ByteBuffer`来保存我们从文件中读取的数据。这是一个非阻塞方法，它立即返回一个表示待处理结果的`Future`对象。我们在读取操作期间模拟处理其他任务，并从主线程打印一条消息。最后，我们实现了一个while循环，使用`isDone()`来确定读取操作是否完成。
- en: Implementing AIO in our Java applications can help us achieve high performance
    and increased responsiveness and scalability. Next, we will examine buffered input/output.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Java应用程序中实现AIO可以帮助我们实现高性能、增加响应性和可伸缩性。接下来，我们将研究缓冲输入/输出。
- en: Buffered input/output
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓冲输入/输出
- en: The buffered approach to input/output, commonly referred to as **buffered input/output**,
    can be implemented to reduce the number of input/output operations required. This
    approach is accomplished using temporary storage, known as a **buffer**. Buffers
    temporarily hold data during the transfer process. The goal of this approach is
    to minimize direct interactions with hardware and data streams. Java delivers
    on this promise by accumulating data in a buffer before processing it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 输入/输出的缓冲方法，通常称为**缓冲输入/输出**，可以实现以减少所需的输入/输出操作的数量。这种方法是通过使用称为**缓冲区**的临时存储来实现的。缓冲区在传输过程中暂时持有数据。这种方法的目标是最大限度地减少与硬件和数据流的直接交互。Java通过在处理之前在缓冲区中累积数据来实现这一承诺。
- en: Now that you have a foundational understanding of buffered input/output, let’s
    examine the advantages and best practices of using this technique to improve Java
    application performance.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对缓冲输入/输出有了基础的了解，让我们来探讨使用这种技术来提高Java应用程序性能的优点和最佳实践。
- en: Advantages and best practices
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优点和最佳实践
- en: There are several advantages to buffered input/output, and they are best leveraged
    when following industry best practices. Next, we will review the advantages followed
    by best practices.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲输入/输出有几个优点，并且最好在遵循行业最佳实践的情况下利用它们。接下来，我们将回顾优点和最佳实践。
- en: Advantages
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优点
- en: 'Here are three advantages to implementing buffered input/output in our Java
    applications:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Java应用程序中实现缓冲输入/输出的三个优点如下：
- en: '**Data handling**: Buffered input/output can increase the efficiency of data
    handling because it allows for data to be temporarily stored during read and write
    operations. This is especially beneficial when working with data streams and large
    files.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据处理**：缓冲输入/输出可以提高数据处理效率，因为它允许在读写操作期间临时存储数据。这对于处理数据流和大文件特别有益。'
- en: '**Flexibility**: We can use buffered classes to encapsulate our input and output
    streams. This makes them more adaptable for varied uses.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：我们可以使用缓冲类来封装我们的输入和输出流。这使得它们更适合各种用途。'
- en: '**Performance**: Buffered input/output aims to reduce the number of input/output
    operations, thereby reducing interaction overhead and ultimately increasing the
    overall application performance.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：缓冲输入/输出的目标是减少输入/输出操作的次数，从而减少交互开销，最终提高整体应用程序性能。'
- en: Keeping these advantages in mind, let’s review the best practices for optimizing
    them in Java.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这些优点，让我们回顾一下在Java中优化它们的最佳实践。
- en: Best practices
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Here are several best practices to help guide your use of buffered input/output:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些最佳实践可以帮助指导你使用缓冲输入/输出：
- en: '**Buffer size**: Testing should be conducted to determine what the most optimal
    buffer size is. Each use case is different and depends on the data, application,
    and hardware.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓冲区大小**：应进行测试以确定最合适的缓冲区大小。每个用例都不同，取决于数据、应用程序和硬件。'
- en: '**Error handling**: It is always good practice to add robust error handling
    to your applications. This is especially pertinent for situations where input/output
    operations could fail due to external issues (e.g., file access permissions or
    network issues).'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误处理**：在应用程序中添加健壮的错误处理总是一个好的做法。这在输入/输出操作可能因外部问题（例如文件访问权限或网络问题）而失败的情况下尤为重要。'
- en: '**Resource management**: Closing buffered streams will free up system resources
    and help avoid memory leaks.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源管理**：关闭缓冲流将释放系统资源并有助于避免内存泄漏。'
- en: We have established that implementing buffered input/output is an approach that
    can positively impact the performance of our applications. In the next section,
    we will look at how to implement buffered input/output in Java.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定实现缓冲输入/输出是一种可以积极影响我们应用程序性能的方法。在下一节中，我们将探讨如何在Java中实现缓冲输入/输出。
- en: Implementing buffered input/output
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现缓冲输入/输出
- en: 'The Java platform includes several classes in the `java.io` library with the
    following capabilities:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Java平台在`java.io`库中包含了几种具有以下功能的类：
- en: '`BufferedInputStream`: This class is used to read binary data from a stream.
    The data is stored in a buffer, permitting efficient data retrieval.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BufferedInputStream`: 这个类用于从流中读取二进制数据。数据存储在缓冲区中，允许高效的数据检索。'
- en: '`BufferedOutputStream`: This class writes bytes to a stream, collecting the
    data in a buffer, and then writes to the output device.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BufferedOutputStream`: 这个类将字节写入流，收集数据到缓冲区，然后写入输出设备。'
- en: '`BufferedReader`: This class reads from an input stream and buffers the data.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BufferedReader`: 这个类从输入流中读取数据并缓冲数据。'
- en: '`BufferedWriter`: This class writes data to an output stream, buffering the
    data to enable efficient writing operations from the buffer.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BufferedWriter`: 这个类将数据写入输出流，缓冲数据以实现从缓冲区进行高效写入操作。'
- en: 'Let’s look at buffered input/output in code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看代码中的缓冲输入/输出：
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see in the example code, we use `BufferedReader` and `BufferedWriter`
    to read and write to a file. The `readLine` method is used to efficiently read
    lines from the input file, and `BufferedWriter` can quickly write to a file with
    minimal input/output operations.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在示例代码中所看到的，我们使用`BufferedReader`和`BufferedWriter`来读取和写入文件。`readLine`方法用于高效地从输入文件中读取行，而`BufferedWriter`可以快速写入文件，输入/输出操作最少。
- en: By leveraging the buffered input/output classes covered in this section, and
    following the provided best practices, we can significantly increase the performance
    of our Java applications, especially those that have frequent read/write operations.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用本节中涵盖的缓冲输入/输出类，并遵循提供最佳实践，我们可以显著提高Java应用程序的性能，尤其是那些有频繁读写操作的应用程序。
- en: Batch operations
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 批量操作
- en: The concept of **batch operations** suggests that we process a lot of data at
    once or combine multiple tasks into a single operation. This type of processing,
    as opposed to doing things individually, can result in tremendous efficiencies
    and reduce overhead. Implementing batch operations is usually a good method of
    improving performance, especially with large-scale data operations, file processing,
    and database interactions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**批量操作**的概念意味着我们一次性处理大量数据或将多个任务组合成一个单一操作。与逐个处理事情相比，这种处理方式可以带来巨大的效率，并减少开销。实现批量操作通常是提高性能的好方法，尤其是在大规模数据操作、文件处理和数据库交互中。'
- en: Batch operations in practice involve executing a series of jobs, usually with
    large datasets treated as groups. These groupings are based on natural or logical
    groupings, with the goal of reducing the computational overhead associated with
    the repetitive starting and stopping processes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 实际中的批量操作涉及执行一系列作业，通常将大型数据集作为组来处理。这些分组基于自然或逻辑分组，目的是减少与重复启动和停止过程相关的计算开销。
- en: Advantages and best practices
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优势和最佳实践
- en: There are several advantages to batch operations, and they are best leveraged
    when following industry best practices. Next, we will review the advantages followed
    by best practices.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 批量操作有多个优势，并且最好在遵循行业最佳实践的情况下利用它们。接下来，我们将回顾优势，然后是最佳实践。
- en: Advantages
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优势
- en: 'Here are three advantages to implementing batch operations in our Java applications:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Java应用程序中实现批量操作有以下三个优势：
- en: '**Performance**: Batch operations represent a tremendous increase in performance.
    Given the scenario where 100 files need to be processed if handled individually,
    100 operations would be required. Handling these 100 files with a batch operation
    would run faster because there would be a significant reduction in system calls.
    Network latency would also be improved.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：批量操作代表了性能的巨大提升。考虑到需要处理100个文件的场景，如果逐个处理，则需要100个操作。使用批量操作处理这100个文件会更快，因为系统调用会显著减少。网络延迟也会得到改善。'
- en: '**Resource usage**: Implementing batch operations reduces overhead and maximizes
    resource utilization.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源使用**：实现批量操作可以减少开销并最大化资源利用率。'
- en: '**Scalability**: Batch operations make it easier for our systems to process
    large datasets. This approach is inherently scalable.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：批量操作使得我们的系统更容易处理大量数据集。这种方法本身具有可扩展性。'
- en: Keeping these advantages in mind, let’s review the best practices to optimize
    them in Java.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些优势，让我们回顾一下最佳实践，以在Java中优化它们。
- en: Best practices
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Here are several best practices to help guide your use of batch operations:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些最佳实践，可以帮助指导你使用批量操作：
- en: '**Batch size**: There is a balance between having a batch size that is too
    small and one that is too big. If it is too small, you are not likely to gain
    the performance benefits, and if it is too large, your application may run into
    memory issues. Determining the right size requires testing and is influenced by
    the type of processing and the type of data involved.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**批量大小**：在批量大小过小和过大之间需要找到一个平衡点。如果太小，你不太可能获得性能上的好处；如果太大，你的应用程序可能会遇到内存问题。确定正确的大小需要测试，并受处理类型和数据类型的影响。'
- en: '**Error handling**: As part of your error handling of batch operations, be
    sure to account for each part of the batch operations if one part fails.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误处理**：作为批量操作错误处理的一部分，确保在某个部分失败时考虑到批量操作的每个部分。'
- en: '**Monitoring**: As with all major systems, the importance of logging and monitoring
    those logs cannot be overstated.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控**：与所有主要系统一样，记录和监控这些日志的重要性不容小觑。'
- en: Now, let’s see how to implement batch operations in Java.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在Java中实现批量操作。
- en: Implementing batch operations
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现批量操作
- en: 'The Java platform includes the following APIs and frameworks to help us implement
    batch operations:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Java平台包括以下API和框架，帮助我们实现批量操作：
- en: '**Java batch**: The **Java Specification Request** (**JSR**) specification
    352 provides a standard approach to batch processing implementation. It includes
    definitions and steps.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 批处理**：**Java 规范请求**（**JSR**）规范 352 提供了一种标准的批处理实现方法。它包括定义和步骤。'
- en: '**JDBC batch processing**: **Java Database Connectivity** (**JDBC**) batch
    processing is used to handle batch **Structured Query Language** (**SQL**) statements.
    We will demonstrate this in the following section.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JDBC 批处理**：**Java 数据库连接**（**JDBC**）批处理用于处理批量的**结构化查询语言**（**SQL**）语句。我们将在下一节中演示这一点。'
- en: '**Spring batch**: This is a framework that provides a host of batch processing
    capabilities to include job processing statistics, resource optimization, and
    transaction management.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring batch**：这是一个提供大量批处理功能的框架，包括作业处理统计、资源优化和事务管理。'
- en: Let’s look at an example using JDBC batch processing. The following sample program
    demonstrates how to use JDBC batch processing to efficiently insert multiple records
    into a database. Note that the database is simulated.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用 JDBC 批处理来查看一个示例。以下示例程序演示了如何使用 JDBC 批处理高效地将多条记录插入到数据库中。请注意，数据库是模拟的。
- en: 'Our example starts with the `import` statements:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例从`import`语句开始：
- en: '[PRE3]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we create our class and `main()` method. This section includes connecting
    to and logging into the simulated database:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建我们的类和`main()`方法。本节包括连接到并登录到模拟数据库：
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following statement is the SQL statement we plan to use in our batch operation.
    Following that statement, we use encase our batch operations in a `try`-`catch`
    block:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们计划在批处理操作中使用的 SQL 语句。在该语句之后，我们使用`try`-`catch`块来封装我们的批处理操作：
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Our simple example program grouped multiple `INSERT` statements into a batch,
    and they were executed in a single request to the simulated database.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的简单示例程序将多个`INSERT`语句分组到一个批次中，并且它们在一个对模拟数据库的单个请求中执行。
- en: Incorporating batch operations in our Java applications, if applicable, can
    significantly enhance application performance. It can also increase scalability
    and system maintainability.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果适用，在我们的 Java 应用程序中结合批处理操作可以显著提高应用程序性能。它还可以增加可扩展性和系统可维护性。
- en: Frameworks for microservices
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务框架
- en: '**Microservices** are a software architectural approach that consists of loosely
    coupled modules (microservices) that comprise an entire application. The benefits
    of microservices include the ability to have teams working on individual ones
    simultaneously, the ability to update one independent of an entire application,
    increased scalability, and more efficient maintainability. This section focuses
    on optimization frameworks for microservices.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**微服务**是一种软件架构方法，它由松散耦合的模块（微服务）组成，这些模块构成了整个应用程序。微服务的优点包括能够同时让团队在单个微服务上工作，能够独立于整个应用程序进行更新，提高了可扩展性，以及更高效的维护性。本节重点介绍微服务的优化框架。'
- en: Now that you have a foundational understanding of frameworks for microservices,
    let’s examine the advantages and best practices of using this technique to improve
    Java application performance.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对微服务框架有了基础的了解，让我们来探讨使用这种技术来提高 Java 应用程序性能的优点和最佳实践。
- en: Advantages and best practices
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优点和最佳实践
- en: There are several advantages to implementing frameworks for microservices, and
    they are best leveraged when following industry best practices. Next, we will
    review the advantages followed by best practices.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 实施微服务框架有多个优点，并且最好在遵循行业最佳实践时加以利用。接下来，我们将回顾这些优点以及最佳实践。
- en: Advantages
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优点
- en: 'Here are three advantages to implementing frameworks for microservices in our
    Java applications:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Java 应用程序中实施微服务框架有三个优点：
- en: '**Fault isolation**: One of the key advantages of using microservices is to
    isolate faults. This is possible because each microservice is loosely coupled
    with another one. This means a fault in one microservice will not necessarily
    impact others.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**故障隔离**：使用微服务的一个关键优点是隔离故障。这是可能的，因为每个微服务都与另一个微服务松散耦合。这意味着一个微服务的故障不会必然影响其他微服务。'
- en: '**Flexibility**: Adopting the microservice framework provides greater agility
    and flexibility when developing and maintaining systems.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：采用微服务框架在开发和维护系统时提供了更大的敏捷性和灵活性。'
- en: '**Scalability**: Microservices’ distributed nature enables great scalability;
    they are inherently scalable.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：微服务的分布式特性使得它们具有极大的可扩展性；它们天生就是可扩展的。'
- en: Keeping these advantages in mind, let’s review the best practices to optimize
    them in Java.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些优势，让我们回顾一下最佳实践，以优化 Java 中的这些实践。
- en: Best practices
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Here are several best practices to help guide your use of frameworks for microservices:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些最佳实践，可以帮助指导您使用微服务框架：
- en: '**API design**: When designing and developing APIs, it is important to thoroughly
    vet their stability and backward compatibility.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API 设计**: 在设计和开发 API 时，重要的是要彻底审查其稳定性和向后兼容性。'
- en: '**Configuration management**: A formal version control system should be used
    so that there is consistency across all microservices.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置管理**: 应使用正式的版本控制系统，以确保所有微服务之间的一致性。'
- en: '**Monitoring**: It is imperative to create a robust logging system and for
    those logs to be monitored. This can help identify issues before they become critical.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控**: 创建一个强大的日志系统并对其日志进行监控是至关重要的。这有助于在问题变得关键之前识别它们。'
- en: We have established that implementing frameworks for microservices is an approach
    that can positively impact the performance of our applications. In the next section,
    we will look at how to implement a framework for microservices in Java.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定，实现微服务框架是一种可以积极影响我们应用程序性能的方法。在下一节中，我们将探讨如何在 Java 中实现微服务框架。
- en: Implementing microservices frameworks
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现微服务框架
- en: 'Systems designed with a microservice architecture essentially consist of individual
    services (microservices) that are standalone applications, based on a business
    function. Each microservice has its own data. There are several frameworks available
    to implement microservices in Java. Here are four of them:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 采用微服务架构设计的系统本质上由独立的应用程序（微服务）组成，这些应用程序基于业务功能。每个微服务都有自己的数据。有几种框架可用于在 Java 中实现微服务。以下是四种：
- en: '**Helidon**: This framework is provided by Oracle and helps us create applications
    using the microservices architecture. This is a modern framework, and the API
    offers many options.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Helidon**: 这个框架由 Oracle 提供，帮助我们使用微服务架构创建应用程序。这是一个现代框架，API 提供了许多选项。'
- en: '**Micronaut**: This is a modern and robust JVM-based framework that includes
    features such as dependency injection and container management.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Micronaut**: 这是一个现代且健壮的基于 JVM 的框架，包括依赖注入和容器管理等功能。'
- en: '**Quarkus**: If you use Kubernetes for containerization, Quarkus is a good
    option to create microservices applications.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Quarkus**: 如果您使用 Kubernetes 进行容器化，Quarkus 是创建微服务应用程序的好选择。'
- en: '**Spring boot**: This is the most used framework to implement microservices
    in Java. It is easy to set up, configure, and use.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring Boot**: 这是在 Java 中实现微服务最常用的框架。它易于设置、配置和使用。'
- en: 'Let’s look at a simple microservice application using Micronaut. We will use
    a three-step approach:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的 Micronaut 微服务应用程序。我们将采用三步法：
- en: 'The first step is to set up our project. This can be done with the Micronaut
    **command-line interface** (**CLI**) or a supported **Integrated Development**
    **Environment** (**IDE**), such as IntelliJ IDEA. Using the CLI, here is what
    the setup code might look like:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是设置我们的项目。这可以通过 Micronaut **命令行界面**（**CLI**）或支持的 **集成开发环境**（**IDE**），如 IntelliJ
    IDEA 完成。使用 CLI，设置代码可能如下所示：
- en: '[PRE6]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we need to create a controller to handle HTTP requests. Here is how that
    can be done:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个控制器来处理 HTTP 请求。以下是实现方式：
- en: '[PRE7]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The third and final step is to simply run the application. Note that the following
    example refers to the **Gradle Wrapper**:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三步和最后一步是简单地运行应用程序。请注意，以下示例指的是 **Gradle Wrapper**：
- en: '[PRE8]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Examining the code further, we can see that we use the `@Controller` annotation
    to identify our class as a controller, whose base URI is `/ch12`. When the application
    is run, the service will be located at `http://localhost:8080/ch12`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步检查代码，我们可以看到我们使用 `@Controller` 注解来标识我们的类为控制器，其基本 URI 为 `/ch12`。当应用程序运行时，服务将位于
    `http://localhost:8080/ch12`。
- en: Microservices frameworks such as Helidon, Micronaut, Quarkus, and Spring Boot
    provide us with a multitude of capabilities to create Java applications using
    the microservices architecture.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如 Helidon、Micronaut、Quarkus 和 Spring Boot 这样的微服务框架为我们提供了创建使用微服务架构的 Java 应用程序的多项功能。
- en: Frameworks for cloud-native applications
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云原生应用程序框架
- en: Developing **cloud-native applications** is a strategic decision, typically
    based on the desire to exploit the scalability, resiliency, security, and flexibility
    inherent in cloud computing.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 开发**云原生应用**是一个战略决策，通常基于利用云计算固有的可扩展性、弹性、安全性和灵活性。
- en: Cloud-native
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生
- en: In the context of software development, cloud-native refers to the use of cloud
    computing to create applications from the ground up and deploy them.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发背景下，云原生指的是从头开始使用云计算创建应用并将其部署。
- en: There are several frameworks available to us that support cloud-native application
    development in Java. Cloud-native applications are built from start to finish
    using the cloud environment. These applications are typically built as microservices,
    which are packaged into containers, orchestrated, and managed using **DevOps**-accepted
    processes.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有多个框架可供选择，支持Java的云原生应用开发。云原生应用从头到尾在云环境中构建。这些应用通常构建为微服务，它们被打包进容器中，通过**DevOps**接受的过程进行编排和管理。
- en: Now that you have a foundational understanding of cloud-native applications,
    let’s examine the advantages and best practices of using this technique to improve
    Java application performance.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经对云原生应用有了基础的理解，让我们来探讨使用这种技术来提高Java应用性能的优点和最佳实践。
- en: Advantages and best practices
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优势和最佳实践
- en: There are several advantages to cloud-native frameworks, and they are best leveraged
    when following industry best practices. Next, we will review the advantages followed
    by the best practices.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生框架有几个优点，并且当遵循行业最佳实践时，它们可以得到最佳利用。接下来，我们将回顾这些优点和最佳实践。
- en: Advantages
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优点
- en: 'Here are three advantages to implementing cloud-native frameworks in our Java
    applications:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Java应用中实施云原生框架有三个优点：
- en: '**Efficiencies**: One of the greatest advantages of using cloud-native frameworks
    for our Java applications is the great efficiencies that are introduced, due to
    automation, development consistency, and testing.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率**：使用云原生框架为我们Java应用带来的最大优点之一是由于自动化、开发一致性和测试而引入的巨大效率。'
- en: '**Fault tolerance**: Because cloud-native applications are written as microservices,
    a fault in one service will not necessarily impact others.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容错性**：由于云原生应用是以微服务编写的，一个服务的故障不会必然影响到其他服务。'
- en: '**Scalability**: The microservices architecture is inherently scalable, as
    is the cloud environment. This empowers us to build highly scalable Java applications.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：微服务架构本身是可扩展的，云环境也是如此。这使得我们能够构建高度可扩展的Java应用。'
- en: Keeping these advantages in mind, let’s review the best practices to optimize
    them in Java.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些优势，让我们回顾一下在Java中优化它们的最佳实践。
- en: Best practices
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Here are several best practices to help guide your use of frameworks for cloud-native
    applications:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些最佳实践，以帮助指导您使用框架开发云原生应用：
- en: '**Containerization**: Applications should be packaged along with their dependencies
    in containers. This will help ensure that there is consistency with each service,
    regardless of the runtime environment.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器化**：应用应与其依赖项一起打包到容器中。这将有助于确保每个服务的一致性，无论运行环境如何。'
- en: '**Continuous Integration/Continuous Delivery (CI/CD)**: Adopting the CI/CD
    approach with automated deployment and testing can significantly increase the
    speed of development and minimize errors inherent in non-automated processes.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续集成/持续交付（CI/CD）**：采用CI/CD方法，实现自动部署和测试，可以显著提高开发速度并最小化非自动化流程中固有的错误。'
- en: '**Monitoring**: Creating robust logs and continuously monitoring them can help
    identify potential issues before they come to fruition.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控**：创建健壮的日志并持续监控它们可以帮助在问题成真之前识别潜在的问题。'
- en: We have established that implementing cloud-native frameworks is an approach
    that can positively impact the performance of our applications. In the next section,
    we will look at how to implement them in Java.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定实施云原生框架是一种可以积极影响我们应用性能的方法。在下一节中，我们将探讨如何在Java中实施它们。
- en: Implementing a cloud-native application
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施云原生应用
- en: 'There are several frameworks available to us to help develop cloud-native applications
    in Java. Here are three popular frameworks:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有多个框架可供选择，以帮助我们用Java开发云原生应用。以下是三个流行的框架：
- en: '**Eclipse MicroProfile**: This is a portable API designed for Java enterprise
    application optimization, specific to microservice architectures. It has many
    capabilities, including health checks, metrics, and fault tolerance.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Eclipse MicroProfile**：这是一个为 Java 企业应用程序优化而设计的可移植 API，适用于微服务架构。它具有许多功能，包括健康检查、指标和容错。'
- en: '**Quarkus**: This framework uses a **container-first** philosophy and works
    best with Kubernetes.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Quarkus**：这个框架采用**容器优先**的哲学，与 Kubernetes 配合最佳。'
- en: '**Spring Cloud**: Part of the Spring environment (i.e., Spring Boot), this
    is a set of development tools to build common software patterns, such as configurations
    and service discovery, specific to the cloud environment.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring Cloud**：这是 Spring 环境的一部分（即 Spring Boot），是一套针对云环境构建常见软件模式（如配置和服务发现）的开发工具。'
- en: 'Let’s look at a simple cloud-native application using Eclipse MicroProfile:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的使用 Eclipse MicroProfile 的云原生应用程序：
- en: '[PRE9]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code snippet demonstrates how MicroProfile can be used to inject
    configuration properties (e.g., a username). This very simple example underscores
    the benefit of using this type of framework to effectively handle configuration
    and other microservices-related concerns.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段展示了如何使用 MicroProfile 注入配置属性（例如，用户名）。这个非常简单的例子强调了使用此类框架有效处理配置和其他微服务相关问题的优势。
- en: Case studies and performance analysis
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究和性能分析
- en: So far in this chapter, we have argued that implementing optimization frameworks
    can greatly increase the performance and scalability of our Java applications.
    This section reviews two case studies and explores performance analysis to help
    determine the impact framework adoption has on our Java applications.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已论证实施优化框架可以极大地提高我们 Java 应用程序的性能和可伸缩性。本节回顾了两个案例研究，并探讨了性能分析，以帮助确定框架采用对我们
    Java 应用程序的影响。
- en: Case studies
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究
- en: Reviewing case studies based on plausible real-world situations can help demonstrate
    the advantages of adopting optimization frameworks. Here are two case studies.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通过审查基于合理现实情况的案例研究，可以帮助展示采用优化框架的优势。以下有两个案例研究。
- en: Case study 1
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 案例研究 1
- en: '**Name**: A microservices-based e-commerce application'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**名称**：基于微服务的电子商务应用程序'
- en: '**Background**: The Reinstate LLC company is a large e-commerce retailer that
    recently transitioned to a microservices architecture from its previous monolithic
    architecture. They used Spring Boot and Spring Cloud to improve scalability, reliability,
    and maintainability.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**背景**：Reinstate LLC 公司是一家大型电子商务零售商，最近从其之前的单体架构过渡到微服务架构。他们使用 Spring Boot 和
    Spring Cloud 来提高可伸缩性、可靠性和可维护性。'
- en: '**Opportunity**: Reinstate LLC had difficulty scaling its monolithic system
    during peak times. They also noted that their development cycles were too long
    and attributed it to the interconnected nature of their application’s components.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**机会**：Reinstate LLC 在高峰时段难以扩展其单体系统。他们还注意到，他们的开发周期过长，并将其归因于应用程序组件之间的相互关联性。'
- en: '**Solution**: Each application component was refactored into a microservice,
    based on a business function or logic. These microservices included customer profiles,
    inventory management, order management, and cart management. Spring Boot was used
    to create individual microservices, and Spring Cloud was used for service discovery,
    load balancing, and configuration management.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：每个应用程序组件都被重构为基于业务功能或逻辑的微服务。这些微服务包括客户资料、库存管理、订单管理和购物车管理。Spring Boot
    用于创建单个微服务，Spring Cloud 用于服务发现、负载均衡和配置管理。'
- en: '**Result**: After implementing the microservices architecture, Reinstate LLC
    experienced a 65% reduction in downtime and a 42% improvement in response time.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**结果**：在实施微服务架构后，Reinstate LLC 经历了 65% 的停机时间减少和 42% 的响应时间提升。'
- en: Case study 2
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 案例研究 2
- en: '**Name**: Financial services’ batch processing.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**名称**：金融服务批量处理。'
- en: '**Background**: CashNow, a financial services company, wanted to process large
    volumes of transactions each data while ensuring high accuracy and reliability,
    using batch processing.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**背景**：CashNow，一家金融服务公司，希望每天处理大量交易，同时确保高精度和可靠性，使用批量处理。'
- en: '**Opportunity**: CashNow’s existing system was inefficient and commonly experienced
    transaction delays. This wreaked havoc on its reporting and end-of-day reconciliation
    process.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**机会**：CashNow 的现有系统效率低下，经常出现交易延迟。这对它的报告和每日结算流程造成了破坏。'
- en: '**Solution**: CashNow implemented Spring Batch to help them manage and optimize
    their batch processing. This framework empowered them to implement job processing,
    processing chunks, and error handling.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：CashNow实施了Spring Batch来帮助他们管理和优化批量处理。这个框架使他们能够实现作业处理、处理块和错误处理。'
- en: '**Result**: CashNow noted a 92% reduction in batch processing time as well
    as a significant decrease in errors. This change helped them streamline their
    daily processes to include end-of-day reconciliation and reporting.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**结果**：CashNow注意到批量处理时间减少了92%，同时错误率也显著下降。这一变化帮助他们简化了日常流程，包括日终核对和报告。'
- en: Performance analysis
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能分析
- en: Implementing optimization frameworks is only one part of the solution. Once
    they are implemented, we want to ensure they result in improvements. We also want
    to make sure the changes work the way we intend them to. This is typically accomplished
    by observing metrics over time.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 实施优化框架只是解决方案的一部分。一旦实施，我们希望确保它们带来改进。我们还希望确保这些更改按我们的意图工作。这通常是通过观察随时间变化的指标来实现的。
- en: A common performance analysis approach involves profiling tools (see [*Chapter
    14*](B21942_14.xhtml#_idTextAnchor250), *Profiling Tools*) and monitoring tools.
    Examples include **JProfiler** and **VisualVM**. Using robust profiling and monitoring
    tools can help us identify potential bottlenecks, such as memory leaks and slow
    database queries.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的性能分析方法包括性能分析工具（见[*第14章*](B21942_14.xhtml#_idTextAnchor250)，*性能分析工具*）和监控工具。例如，**JProfiler**和**VisualVM**。使用强大的性能分析工具和监控工具可以帮助我们识别潜在的瓶颈，例如内存泄漏和缓慢的数据库查询。
- en: The case studies and performance analysis presented in this section underscore
    the importance of implementing optimization frameworks in our Java applications
    to help increase performance, scalability, and maintainability.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中展示的案例研究和性能分析强调了在我们的Java应用程序中实施优化框架的重要性，以帮助提高性能、可扩展性和可维护性。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter explored various optimization frameworks and techniques to help
    increase the performance of our Java applications, support scalability, make our
    code more maintainable, and provide efficient development cycles. We covered asynchronous
    input/output, buffered input/output, batch operations, frameworks for microservices,
    and frameworks for cloud-native applications. We concluded the chapter with a
    review of two realistic case studies and an overview of performance analysis.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了各种优化框架和技术，以帮助提高我们的Java应用程序的性能，支持可扩展性，使我们的代码更具可维护性，并提供高效的开发周期。我们涵盖了异步输入/输出、缓冲输入/输出、批量操作、微服务框架和云原生应用程序框架。我们以两个现实案例研究和性能分析概述结束本章。
- en: Hopefully, the comprehensive overview provided in this chapter will help you
    further optimize your Java applications. The frameworks and techniques covered
    in this chapter can help you enhance the performance of your applications and
    increase scalability, consistency, reliability, and maintainability.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 希望本章提供的全面概述能帮助您进一步优化Java应用程序。本章涵盖的框架和技术可以帮助您提高应用程序的性能，增加可扩展性、一致性、可靠性和可维护性。
- en: In the next chapter ([*Chapter 13*](B21942_13.xhtml#_idTextAnchor227), *Performance-Focused
    Libraries*), we will explore several open source Java libraries designed to provide
    high performance. These fully optimized libraries can be leveraged to our advantage.
    Notable libraries covered include **Java Microbenchmark Harness** (**JHM**), which
    is part of the OpenJDK project; Netty to work with network protocols, which can
    be used to reduce latency; and FasterXML Jackson, which is a suite of data processing
    tools.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章（[*第13章*](B21942_13.xhtml#_idTextAnchor227)，*面向性能的库*）中，我们将探讨几个开源Java库，这些库旨在提供高性能。这些完全优化的库可以为我们带来优势。涵盖的知名库包括**Java
    Microbenchmark Harness**（**JMH**），它是OpenJDK项目的一部分；Netty，用于处理网络协议，可以用来减少延迟；以及FasterXML
    Jackson，这是一个数据处理工具套件。
