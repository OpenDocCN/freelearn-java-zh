- en: Taking RabbitMQ to Production
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 将RabbitMQ投入生产
- en: At this point, **Complete Car **(**CC**) is running a single instance of RabbitMQ
    in production. Now CC also needs to ensure that the service is highly available.
    Creating clusters of nodes ensures that information is reachable even if systems
    go down. This chapter covers how to set up RabbitMQ clusters, including coverage
    of broker clustering, classic mirrored queues, and quorum queues. CC is also looking
    for a new elegant solution for log aggregation, where all logs are published to
    a centralized RabbitMQ node through the federation plugin, so this chapter will
    cover this topic as well.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，**完整汽车**（**CC**）在生产中运行单个RabbitMQ实例。现在CC还需要确保服务具有高可用性。创建节点集群确保即使系统出现故障，信息仍然可访问。本章将介绍如何设置RabbitMQ集群，包括代理集群、经典镜像队列和法定多数队列的介绍。CC还在寻找一个新的优雅的日志聚合解决方案，其中所有日志都通过联邦插件发布到集中的RabbitMQ节点，因此本章也将涵盖这一主题。
- en: 'To achieve CC''s goal of nearly constant uptime, the topics in this chapter
    will include the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现CC几乎不间断运行的目标，本章将包括以下内容：
- en: Adding nodes to the cluster
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向集群添加节点
- en: Discovering the types of RabbitMQ queues
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现RabbitMQ队列的类型
- en: Using federated brokers and log aggregation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用联邦代理和日志聚合
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files of this chapter can be found on GitHub at [https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter06](https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter06).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到，地址为[https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter06](https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter06)。
- en: Adding nodes to the cluster
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向集群添加节点
- en: Things have been running smoothly for CC, but developers want to ensure that
    the system can survive a crash. A crash is always possible, even when using RabbitMQ.
    Power outages happen, sudden packet losses may corrupt updates, and administrators
    can improperly configure the system by accident. There is still a chance that,
    due to a glitch or error, an entire instance could be lost. Steps must be taken
    to address any issues that could lead to data loss, negative customer experience,
    or even the dreaded 2 a.m. phone call to the team.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CC来说，一切运行顺利，但开发者们希望确保系统能够承受崩溃。即使在使用RabbitMQ的情况下，崩溃总是可能的。停电可能发生，突然的数据包丢失可能会损坏更新，管理员可能由于意外错误而错误地配置系统。由于故障或错误，整个实例可能会丢失。必须采取措施解决可能导致数据丢失、负面客户体验，甚至可怕的凌晨2点给团队打电话的问题。
- en: The good news is that RabbitMQ provides the features needed to deal with potential
    crashes and other catastrophes right out of the box. RabbitMQ can be configured
    to run in an active-active deployment environment, meaning that two or more nodes
    actively run the same kind of service simultaneously. Several brokers can be engaged
    in a cluster to act as a single highly available **Advanced Message Queuing Protocol** (**AMQP**)
    service.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，RabbitMQ提供了处理潜在崩溃和其他灾难所需的特性，无需额外配置。RabbitMQ可以配置为在活动-活动部署环境中运行，这意味着两个或多个节点可以同时运行相同类型的服务。几个代理可以参与集群，作为单个高可用的**高级消息队列协议**（**AMQP**）服务。
- en: There is no need to resort to manual failover when using active-active deployment.
    No operation is needed if a broker goes down, sparing the team that 2 a.m. phone
    call. Depending on the number of active nodes in the high-availability cluster,
    a cluster can sustain several failures.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用活动-活动部署时，无需手动故障转移。如果代理发生故障，无需任何操作，从而避免了凌晨2点的电话。根据高可用性集群中活动节点的数量，集群可以承受多次故障。
- en: To avoid complications resulting from an unreachable broker, CC decides to start
    by rolling out a second RabbitMQ instance (named rmq-prod-2), clustering it with
    the one already used in production.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免因无法访问代理而引起的复杂情况，CC决定首先启动第二个RabbitMQ实例（命名为rmq-prod-2），并将其与生产中已使用的实例进行集群化。
- en: 'A RabbitMQ cluster is a logical grouping of one or several nodes, each sharing
    users, virtual hosts, queues, exchanges, and so on. The system architecture changes
    only inside the cluster, as seen in the following diagram:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ集群是由一个或多个节点组成的逻辑分组，每个节点共享用户、虚拟主机、队列、交换机等。系统架构仅在集群内部发生变化，如下所示：
- en: '![](img/4f35e1a1-09c1-4582-8569-3d7f1e9425c4.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f35e1a1-09c1-4582-8569-3d7f1e9425c4.png)'
- en: 'Fig 6.1: A high-availability cluster of many RabbitMQ brokers'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：由多个RabbitMQ代理组成的高可用性集群
- en: More nodes are added into the RabbitMQ cluster. CC informs the team when the
    second instance of RabbitMQ is ready to be clustered with the existing one. To
    make this happen, the Erlang clustering feature will be used with RabbitMQ to
    allow local or remote communication between several Erlang nodes. Erlang clustering
    uses a security cookie as the mechanism for cross-node authentication. To avoid
    errors, the developers have made sure that the content of `/var/lib/rabbitmq/.erlang.cookie`
    is the same in each instance.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 更多的节点被添加到 RabbitMQ 集群中。当第二个 RabbitMQ 实例准备与现有的一个进行集群时，CC 会通知团队。为了实现这一点，将使用 RabbitMQ
    的 Erlang 集群功能，以允许多个 Erlang 节点之间的本地或远程通信。Erlang 集群使用安全cookie作为跨节点认证的机制。为了避免错误，开发人员已确保
    `/var/lib/rabbitmq/.erlang.cookie` 文件在每个实例中的内容相同。
- en: Note that a cluster will not work if a firewall blocks the RabbitMQ instances
    from communicating with each other. If that happens, open the specific ports used
    by AMQP (defaulting to `5672`) so that the cluster will work. Get more information
    at, [http://www.rabbitmq.com/clustering.html#firewall](http://www.rabbitmq.com/clustering.html#firewall).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果防火墙阻止 RabbitMQ 实例相互通信，则集群将无法工作。如果发生这种情况，请打开 AMQP（默认为 `5672`）所使用的特定端口，以便集群可以工作。更多信息请参阅[http://www.rabbitmq.com/clustering.html#firewall](http://www.rabbitmq.com/clustering.html#firewall)。
- en: There is no need to configure any users or virtual hosts on the second node
    as done in [Chapter 1](4f4722d3-131f-4c38-9ea0-4c03e8545175.xhtml), *A Rabbit
    Springs to Life*. Just join the cluster and the configuration will automatically
    synchronize with the existing RabbitMQ instance, including users, virtual hosts,
    exchanges, queues, and policies.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二节点上无需配置任何用户或虚拟主机，如[第 1 章](4f4722d3-131f-4c38-9ea0-4c03e8545175.xhtml)“Rabbit
    春天苏醒”中所述。只需加入集群，配置将自动与现有的 RabbitMQ 实例同步，包括用户、虚拟主机、交换机、队列和策略。
- en: Keep in mind that a node completely resets when it joins a cluster. RabbitMQ
    deletes all configuration and data before synchronizing with the other nodes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，节点在加入集群时会完全重置。RabbitMQ 在与其他节点同步之前会删除所有配置和数据。
- en: 'To join a node to a cluster, first stop RabbitMQ, then join the cluster, and
    finally restart the RabbitMQ application:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要将节点加入集群，首先停止 RabbitMQ，然后加入集群，最后重新启动 RabbitMQ 应用程序：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Make sure the same major version of Erlang is used by all the RabbitMQ nodes
    or the `join_cluster` command might fail. It is possible to run a cluster with
    mixed Erlang versions, but there can be incompatibilities that will affect cluster
    stability.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 确保所有 RabbitMQ 节点使用相同的 Erlang 主版本，否则 `join_cluster` 命令可能会失败。虽然可以运行包含不同 Erlang
    版本的集群，但可能会出现不兼容性，从而影响集群的稳定性。
- en: RabbitMQ also requires the use of the same major/minor version across nodes
    up to and including 3.7.x. It is possible to run different patch versions (for
    example, 3.7.X and 3.7.Y) most of the time, except when indicated otherwise in
    the release notes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ 还要求节点之间使用相同的 3.7.x 及以下主/次版本。大多数情况下，可以运行不同的补丁版本（例如，3.7.X 和 3.7.Y），除非发布说明中另有说明。
- en: Feature flags is a mechanism new to RabbitMQ version 3.8\. These flags define
    a RabbitMQ node's ability to become a part of a cluster. Feature flags control
    which features are considered enabled or available on all cluster nodes, so nodes
    using the subsystem must have the same dependencies. Read more at [https://www.rabbitmq.com/feature-flags.html](https://www.rabbitmq.com/feature-flags.html).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 功能标志是 RabbitMQ 3.8 版本引入的新机制。这些标志定义了 RabbitMQ 节点成为集群一部分的能力。功能标志控制哪些功能在所有集群节点上被视为启用或可用，因此使用子系统的节点必须具有相同的依赖项。更多信息请参阅[https://www.rabbitmq.com/feature-flags.html](https://www.rabbitmq.com/feature-flags.html)。
- en: 'After running the preceding commands, check to see whether the cluster is active
    by running the `cluster_status` command on any node:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行前面的命令后，通过在任何节点上运行 `cluster_status` 命令来检查集群是否活跃：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice how two lists of nodes are given in the status message. In this case,
    the nodes are the list of configured nodes in the cluster. The list named `running_nodes`
    contains those that are actually active. Configured nodes are persistent, meaning
    they will survive broker restarts since each broker automatically re-engages with
    the cluster.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意状态消息中给出了两个节点列表。在这种情况下，节点是集群中配置的节点列表。名为 `running_nodes` 的列表包含那些实际活跃的节点。配置的节点是持久的，这意味着它们将能够在代理重启后存活，因为每个代理都会自动重新加入集群。
- en: Confirm that the new node will synchronize with the cluster by connecting to
    the management console on another node (rmq-prod-2). Use the cc-admin user to
    log in and go to the Queues view.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过连接到另一个节点（rmq-prod-2）上的管理控制台来确认新节点将同步到集群。使用cc-admin用户登录并转到队列视图。
- en: 'The configuration should be synchronized as shown in the following screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 配置应同步，如下截图所示：
- en: '![](img/8cdb6780-a35f-4970-b496-94435efaa7b4.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8cdb6780-a35f-4970-b496-94435efaa7b4.png)'
- en: 'Fig 6.2: All configurations are synchronized after joining the cluster'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：加入集群后，所有配置都同步
- en: 'To add more nodes, let each new node join another node in the cluster. The
    Overview tab in the management console of the first node shows all the nodes that
    are in the cluster, which are automatically discovered, as shown in the following
    screenshot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加更多节点，让每个新节点加入集群中的另一个节点。第一个节点管理控制台中的概览选项卡显示了集群中的所有节点，这些节点是自动发现的，如下截图所示：
- en: '![](img/41c7dd44-7b0f-46f6-bbe1-df5bea88519e.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/41c7dd44-7b0f-46f6-bbe1-df5bea88519e.png)'
- en: 'Fig 6.3: The management console overview shows all cluster members'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：管理控制台概览显示了所有集群成员
- en: 'As shown, all members of the cluster are listed along with basic statistics
    and ports. The different values shown in the **Info** column are as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，集群的所有成员都列出了，包括基本统计信息和端口。**信息**列中显示的不同值如下：
- en: 'basic: Describes the `rates_mode`, which tells how the queues report statistics.
    This can be one of `basic` (the default), `detailed`, or `none`.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: basic：描述`rates_mode`，它告诉队列如何报告统计信息。这可以是`basic`（默认）、`detailed`或`none`之一。
- en: 'disc: Means that the node persists data to the filesystem, which is the default
    behavior. It is also possible to start a node in **RAM** mode, where all message
    data is stored in memory, which can speed up systems provided that they have enough
    memory.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'disc: 表示节点将数据持久化到文件系统，这是默认行为。也可以以**RAM**模式启动节点，其中所有消息数据都存储在内存中，如果系统有足够的内存，这可以加快系统速度。'
- en: '7: Shows the number of plugins that are enabled.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7：显示已启用的插件数量。
- en: 'allocated: Describes the memory calculation strategy.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'allocated: 描述内存计算策略。'
- en: Nodes can be removed ([http://www.rabbitmq.com/clustering.html#breakup](http://www.rabbitmq.com/clustering.html#breakup))
    from the cluster through `rabbitmqctl`, the command-line tool for managing a RabbitMQ
    server node.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`rabbitmqctl`（管理RabbitMQ服务器节点的命令行工具）从集群中移除节点（[http://www.rabbitmq.com/clustering.html#breakup](http://www.rabbitmq.com/clustering.html#breakup)）。
- en: All CC applications are currently connecting to one single RabbitMQ node. This
    needs to be modified. Applications should try to connect to one node first and
    fail over to another node if the original attempt fails. Read on to see how that
    is done.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 目前所有CC应用程序都连接到单个RabbitMQ节点。这需要修改。应用程序应首先尝试连接到一个节点，如果原始尝试失败，则切换到另一个节点。继续阅读以了解如何实现。
- en: Connecting to the cluster
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到集群
- en: All CC applications currently connect to a single RabbitMQ node, which needs
    to be modified to benefit from the advantages of the cluster. All applications
    connecting to RabbitMQ need to be modified. The applications should try to connect
    to one node first, failing over to another if the original attempt fails. This
    is the only required change; the applications will interact with the broker as
    they did before.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 目前所有CC应用程序都连接到单个RabbitMQ节点，需要修改以利用集群的优势。所有连接到RabbitMQ的应用程序都需要修改。应用程序应首先尝试连接到一个节点，如果原始尝试失败，则切换到另一个节点。这是唯一需要更改的地方；应用程序将与代理交互，就像以前一样。
- en: 'First, modify the main application connection Ruby code as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，修改主应用程序连接Ruby代码如下：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Basically, the list of broker addresses is passed. With this in place, the RabbitMQ
    Ruby client will connect to the first responsive node in the address list and
    will try each of the provided broker addresses until it can establish a connection
    or eventually fails. In the case of failure, the overall reconnect mechanism that's
    already in place will kick in and the addresses will once again be attempted for
    connection.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，传递了代理地址列表。有了这个，RabbitMQ Ruby客户端将连接到地址列表中的第一个响应节点，并尝试提供的每个代理地址，直到建立连接或最终失败。在失败的情况下，已经存在的整体重连机制将启动，并将再次尝试连接地址。
- en: It is possible to manually synchronize a mirrored queue using the `rabbitmqctl
    sync_queue <queue_name>` command. Cancel the synchronization with `rabbitmqctl
    cancel_sync_queue <queue_name>`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`rabbitmqctl sync_queue <queue_name>`命令手动同步镜像队列。使用`rabbitmqctl cancel_sync_queue
    <queue_name>`取消同步。
- en: 'At this point, there is only one more step to perform to ensure the high availability
    of the queue data: enabling a way to spread the data to the other node(s). The
    options available are **classic mirrored queues** and **quorum queues**. But first,
    some partition handling strategies.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，还有一步要执行以确保队列数据的高可用性：启用一种将数据传播到其他节点的方式。可用的选项是**经典镜像队列**和**仲裁队列**。但首先，需要了解一些分区处理策略。
- en: Partition handling strategies
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分区处理策略
- en: Adding even more nodes to the cluster is of course possible. However, this brings
    a new challenge in the form of network connectivity. Split-brains and early message
    confirmation are common issues when using more than one node. Split-brains occur
    in distributed systems when a portion of the network becomes unreachable from
    another portion, creating network partitions (called a **netsplit**). To avoid
    this situation, set a partition handling strategy. In RabbitMQ, this is set through
    the `cluster_partition_handling` parameter in the configuration file – [https://www.rabbitmq.com/partitions.html#automatic-handling](https://www.rabbitmq.com/partitions.html#automatic-handling).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，向集群中添加更多节点是可能的。然而，这会带来一个新的挑战，即网络连接问题。当使用多个节点时，脑裂和早期消息确认是常见问题。在分布式系统中，当网络的一部分无法从另一部分访问时，就会发生脑裂，这会创建网络分区（称为**netsplit**）。为了避免这种情况，设置分区处理策略。在RabbitMQ中，这通过配置文件中的`cluster_partition_handling`参数来设置——[https://www.rabbitmq.com/partitions.html#automatic-handling](https://www.rabbitmq.com/partitions.html#automatic-handling)。
- en: The **pause-minority** strategy terminates nodes in the minority partition.
    This is the default way to resolve split-brains in many distributed networks.
    The **pause-if-all-down** feature only pauses a node if none are reachable. This
    is inadvisable as it creates large discrepancies between the data in each partition.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**pause-minority**策略终止少数分区中的节点。这是许多分布式网络解决脑裂问题的默认方式。**pause-if-all-down**功能仅在没有任何节点可访问时暂停节点。这不可取，因为它会在每个分区的数据之间造成很大的差异。'
- en: Once nodes become available in the **pause-if-all-down** setting, two more options
    are available to specify how to reconnect the network. Simply ignore another partition
    or auto-heal the cluster. The nodes the system cannot pause must also be specified.
    In the **pause-minority** strategy, the partitions reconnect when available.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在**pause-if-all-down**设置中可用节点，还有两个选项可以指定如何重新连接网络。简单地忽略另一个分区或自动修复集群。系统无法暂停的节点也必须指定。在**pause-minority**策略中，分区在可用时重新连接。
- en: RabbitMQ ensures synchronization across clusters. Clients can reach their exchanges
    and queues over any node; however, the messages themselves are not carried over.
    The next section covers how that can be done.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ确保跨集群的同步。客户端可以通过任何节点访问其交换机和队列；然而，消息本身并不会在节点间传递。下一节将介绍如何实现这一点。
- en: Discovering the types of RabbitMQ queues
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现RabbitMQ队列的类型
- en: Queues in RabbitMQ can be durable or transient. Classic mirrored queues are
    recommended for transient message handling, while quorum queues are a good alternative
    for durable queues.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ中的队列可以是持久的或临时的。对于临时消息处理，建议使用经典镜像队列，而仲裁队列是持久队列的良好替代方案。
- en: Durable queue metadata is stored on disk while a transient queue stores it in
    memory, when possible. Another queue type, lazy queues, writes the contents to
    disk as early as possible for both durable and transient messages.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 持久队列元数据存储在磁盘上，而临时队列在可能的情况下存储在内存中。另一种队列类型，懒队列，尽可能早地将持久和临时消息的内容写入磁盘。
- en: Due to technical limitations in classic mirrored queues, it is difficult to
    make guarantees on how failures are handled. The RabbitMQ documentation ([https://www.rabbitmq.com/ha.html](https://www.rabbitmq.com/ha.html))
    recommends that users get familiar with quorum queues and consider them instead
    of classic mirrored queues where possible.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于经典镜像队列的技术限制，很难对如何处理故障做出保证。RabbitMQ文档([https://www.rabbitmq.com/ha.html](https://www.rabbitmq.com/ha.html))建议用户熟悉仲裁队列，并在可能的情况下考虑它们而不是经典镜像队列。
- en: Mirroring queues
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 队列镜像
- en: In the case of CC, the data in the queues needs to be highly available. Mirrored
    queues provide this type of security. Queue mirroring uses a master-mirror design
    pattern. All message queuing and dequeuing actions happen with the master, and
    the mirrors receive the updates periodically from the master. If a master becomes
    unavailable, RabbitMQ promotes a mirror to a master; usually, the oldest mirror
    becomes the new master, as long as it is synchronized.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在CC的情况下，队列中的数据需要高度可用。镜像队列提供了这种安全性。队列镜像使用主镜像设计模式。所有消息入队和出队操作都在主节点上进行，镜像节点定期从主节点接收更新。如果主节点不可用，RabbitMQ会将一个镜像节点提升为主节点；通常，最老的镜像节点成为新的主节点，只要它保持同步。
- en: It is also possible to set up a master-master system by sending data to a different
    cluster in addition to the original. This provides a useful backup for hardware
    updates and extreme cases of failure. It can also help speed up interaction in
    different geographic regions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过将数据发送到原始集群之外的不同集群来设置主主系统。这为硬件更新和极端故障情况提供了有用的备份。它还可以帮助加快不同地理区域之间的交互。
- en: Telling the cluster how to mirror queues must in our case be done via the `Q_TTL_DLX`
    policy since only one policy at a time is allowed in a queue or exchange. The
    first step is to clear the policy created in [Chapter 4](bece97d2-6653-459f-bbdc-6e47f343c1d3.xhtml),
    *Tweaking Message Delivery,* then applying a new policy combining the `Q_TTL_DLX`
    policy with one created for queue mirroring.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，必须通过`Q_TTL_DLX`策略来告诉集群如何镜像队列，因为在一个队列或交换中一次只能允许一个策略。第一步是清除在[第4章](bece97d2-6653-459f-bbdc-6e47f343c1d3.xhtml)，*调整消息投递*中创建的策略，然后应用一个新的策略，该策略结合了`Q_TTL_DLX`策略和为队列镜像创建的策略。
- en: 'Run the following commands to change the `Q_TTL_DLX` policy and tell RabbitMQ
    how to mirror queues. Start by clearing the policy:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以更改`Q_TTL_DLX`策略并告诉RabbitMQ如何镜像队列。首先清除策略：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Alternatively, add the policy from the management console, as shown in the
    following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以从管理控制台添加策略，如下面的截图所示：
- en: '![](img/0c6e86cc-eba3-4ca7-8762-804519431010.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c6e86cc-eba3-4ca7-8762-804519431010.png)'
- en: 'Fig 6.4: Policy added via the RabbitMQ management console'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：通过RabbitMQ管理控制台添加的策略
- en: High availability mode has been added to the existing TTL and DLX policy rules.
    The all value for ha-mode tells RabbitMQ to mirror queues across all nodes in
    the cluster, which is exactly what CC wants in their two-node cluster. The other
    options are exactly and nodes, allowing developers to specify the number of nodes
    when using the exact option and a list of node names when using the nodes option
    through the ha-params parameters.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 已将高可用性模式添加到现有的TTL和DLX策略规则中。ha-mode的all值告诉RabbitMQ在集群的所有节点上镜像队列，这正是CC在他们的双节点集群中想要的。其他选项是exact和nodes，允许开发者在使用exact选项时指定节点数，在使用nodes选项时通过ha-params参数指定节点名称列表。
- en: The ha-sync-mode parameter is used to specify the synchronization mode for the
    mirrored queue. This parameter can be set to manual or automatic. In manual mode,
    a newly mirrored queue will not receive any existing messages but will eventually
    become consistent with the master queue as consumers retrieve messages. This reduces
    overhead at the cost of losing information. Automatic mode sends messages to each
    queue, meaning a small hit to the system performance.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ha-sync-mode参数用于指定镜像队列的同步模式。此参数可以设置为手动或自动。在手动模式下，新镜像队列不会接收任何现有消息，但最终会随着消费者检索消息而与主队列保持一致。这减少了开销，但以丢失信息为代价。自动模式将消息发送到每个队列，意味着对系统性能有轻微的影响。
- en: CC decides to use immediate queue synchronization so that any existing messages
    become visible across all nodes nearly instantaneously. CC is fine with the initial
    unresponsiveness this creates since performance is not critical for user messages.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: CC决定使用即时队列同步，以便任何现有消息几乎瞬间在所有节点上可见。CC对由此产生的初始无响应性表示可以接受，因为性能对于用户消息不是关键。
- en: 'Navigate to the Queues tab in the management console after running the preceding
    command. Observe that the HA_Q_TTL_DLX policy has been applied to the intended
    queues:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行上述命令后，导航到管理控制台中的队列标签页。观察到的HA_Q_TTL_DLX策略已应用于目标队列：
- en: '![](img/a7c157a8-f91e-493b-a1cb-8d6574d9db2d.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7c157a8-f91e-493b-a1cb-8d6574d9db2d.png)'
- en: 'Fig 6.5: Mirrored queues with the high availability policies applied'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：应用了高可用性策略的镜像队列
- en: 'Notice how the mirrored queues have a **+1** next to them. This denotes the
    fact that the queues are mirrored to another node in the cluster. The master (rabbit@rmq-prod-1)
    and the mirror nodes (rabbit@rmq-prod-2) are clearly defined in the Details section
    of each queue in the management console as well, as seen in the following screenshot:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意镜像队列旁边有一个**+1**。这表示队列已镜像到集群中的另一个节点。在管理控制台的每个队列的详细信息部分也清楚地定义了主节点（rabbit@rmq-prod-1）和镜像节点（rabbit@rmq-prod-2），如下面的截图所示：
- en: '![](img/7ecc5ce1-9149-4f2e-afa5-558f7ca32c7a.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7ecc5ce1-9149-4f2e-afa5-558f7ca32c7a.png)'
- en: 'Fig 6.6: Master and mirror nodes are detailed'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6：主节点和镜像节点细节
- en: At this point, the RabbitMQ brokers are clustered and taxi order request queues
    are mirrored. Client applications can benefit from this highly available deployment
    and connect to different nodes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，RabbitMQ代理已集群化，出租车订单请求队列已镜像。客户端应用程序可以从中受益于这种高可用性部署并连接到不同的节点。
- en: '**Setting the Master Queue Location**: Every queue has a primary replica known
    as the queue master. This queue is the first to receive messages before synchronization.
    It is possible to influence how this is set using the x-queue-master-locator parameter
    in the Queues tab of the management console or when creating a queue programmatically.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**设置主队列位置**：每个队列都有一个主副本，称为队列主。在同步之前，该队列是第一个接收消息的。可以通过在管理控制台的队列选项卡中使用x-queue-master-locator参数或在程序创建队列时来影响其设置。'
- en: Quorum queues are a new type of queue, often recommended over classic mirrored
    queues.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 仲裁队列是一种新型队列，通常比经典镜像队列更受推荐。
- en: Quorum queues
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仲裁队列
- en: As an alternative to durable mirrored queues, quorum queues ensure that the
    cluster is up to date by agreeing on the contents of a queue. In doing so, quorum
    queues avoid losing data, which could occur with mirrored queues when messages
    are confirmed too early. Quorum queues are available as of RabbitMQ 3.8.0\. As
    detailed in the RabbitMQ documentation ([https://www.rabbitmq.com/quorum-queues.html](https://www.rabbitmq.com/quorum-queues.html)),
    some transient features are not available when using quorum queues.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 作为持久镜像队列的替代方案，仲裁队列通过就队列内容达成一致来确保集群是最新的。在此过程中，仲裁队列避免了数据丢失，这在镜像队列中可能会在消息过早确认时发生。仲裁队列自RabbitMQ
    3.8.0版本起可用。如RabbitMQ文档（[https://www.rabbitmq.com/quorum-queues.html](https://www.rabbitmq.com/quorum-queues.html)）中详细说明，当使用仲裁队列时，某些临时功能不可用。
- en: A quorum queue has a leader that roughly serves the same purpose as it did for
    the classic mirrored queue master. All communication is routed to the queue leader,
    which means the queue leader locality has an effect on the latency and bandwidth
    requirement of the messages; however, the effect should be lower than it was in
    classic mirrored queues.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 队列仲裁队列有一个领导者，其作用大致与经典镜像队列主相同。所有通信都路由到队列领导者，这意味着队列领导者的本地性会影响消息的延迟和带宽需求；然而，这种影响应该低于经典镜像队列。
- en: In quorum queues, the leader and replication are consensus-driven, which means
    they agree on the state of the queue and its contents. While mirrored queues may
    confirm messages too early and lose data, quorum queues will only confirm when
    the majority of its nodes are available, which thereby avoids data loss.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在仲裁队列中，领导者和复制是由共识驱动的，这意味着它们就队列的状态及其内容达成一致。虽然镜像队列可能会过早确认消息并丢失数据，但仲裁队列只有在大多数节点可用时才会确认，从而避免了数据丢失。
- en: 'Declare a quorum queue using the following command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令声明仲裁队列：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These queues must be durable and instantiated by setting the `x-queue-type`
    header to `quorum`. If the majority of nodes agree on the contents of a queue,
    the data is valid. Otherwise, the system attempts to bring all queues up to date.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些队列必须是持久的，并且通过将`x-queue-type`报头设置为`quorum`来实例化。如果大多数节点就队列内容达成一致，则数据有效。否则，系统会尝试将所有队列更新到最新状态。
- en: Quorum queues have support for the handling of poison messages, which are messages
    that are never consumed completely or positively acknowledged.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 仲裁队列支持处理毒消息，这些消息永远不会被完全消费或确认。
- en: The number of unsuccessful delivery attempts can be tracked and displayed in
    the `x-delivery-count` header. A poison message can be dead-lettered when it has
    been returned more times than configured.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 可以跟踪并显示在`x-delivery-count`报头中的未成功投递尝试次数。当消息被返回的次数超过配置值时，可以将其作为毒消息进行死信处理。
- en: Lazy queues are another queue type worth exploring, so read on.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 懒队列是另一种值得探索的队列类型，所以请继续阅读。
- en: Lazy queues
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 懒队列
- en: Queues can become long for various reasons including consumer maintenance or
    the arrival of large batches of messages. While RabbitMQ can support millions
    of messages, keeping queues as short as possible is recommended by most experts.
    Messages are stored in memory by default. RabbitMQ then flushes messages (page
    out) to free up the RAM usage when the queue becomes too long for the underlying
    instance to handle. Storing messages in RAM enables faster delivery of messages
    to consumers than storing them to disk.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于消费者维护或大量消息批次的到达等原因，队列可能会变得很长。虽然RabbitMQ可以支持数百万条消息，但大多数专家建议尽可能保持队列尽可能短。默认情况下，消息存储在内存中。当队列变得太长以至于底层实例无法处理时，RabbitMQ会将消息（页面输出）刷新以释放RAM使用。在RAM中存储消息比将它们存储到磁盘上能更快地将消息传递给消费者。
- en: The page out function usually takes time and often stops the queue from processing
    messages, which deteriorates the queue speed. For this reason, queues that contain
    a lot of messages can have a negative impact on the broker's performance. Additionally,
    it takes a lot of time to rebuild the index after a cluster is restarted and to
    sync messages between nodes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 页面输出功能通常需要时间，并且经常停止队列处理消息，这会降低队列速度。因此，包含大量消息的队列可能会对经纪人的性能产生负面影响。此外，在集群重启后重建索引需要花费大量时间，以及在不同节点之间同步消息也需要花费大量时间。
- en: Beginning with RabbitMQ version 3.6, a policy called lazy queues was added to
    enable the storage of messages to disk automatically in order to minimize RAM
    usage. Lazy queues can be enabled by setting the mode via the `queue.declare`
    arguments or by applying a policy to all queues.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从RabbitMQ版本3.6开始，添加了一个名为lazy queues的策略，以自动将消息存储到磁盘，从而最小化RAM使用。可以通过设置`queue.declare`参数或应用策略到所有队列来启用lazy
    queues。
- en: Persistent messages can be written to the disk as they enter the broker and
    be kept in RAM at the same time.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 持久消息可以在进入经纪人时写入磁盘，并同时保存在RAM中。
- en: Different queue types have been shown, and it's time to look into how CC should
    handle log aggregation from all clusters.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 已经展示了不同的队列类型，现在是时候看看CC应该如何处理来自所有集群的日志聚合了。
- en: Using federated brokers and log aggregation
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用联邦经纪人和日志聚合
- en: The way a cluster of two RabbitMQ brokers is created is really similar to what
    is typically done when making a relational database highly available. The database
    remains a centralized resource offering high guarantees of availability. Still,
    RabbitMQ is not a one-trick rabbit when it comes to high availability.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 创建两个RabbitMQ经纪人集群的方式实际上与在创建一个高度可用的关系数据库时通常所做的是非常相似的。数据库仍然是一个集中的资源，提供高可用性保证。然而，当涉及到高可用性时，RabbitMQ并非只有一项绝技。
- en: 'To form a picture of a RabbitMQ system, the following two plugins allow broker
    connection:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要形成一个RabbitMQ系统的图像，以下两个插件允许经纪人连接：
- en: '**Shovel**: Connects queues and exchanges between different brokers'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Shovel**: 在不同经纪人之间连接队列和交易所'
- en: '**Federation**: Forms cross-broker connections for queues to queues, or exchanges
    to exchanges'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**联邦**: 为队列到队列或交易所到交易所形成跨经纪人连接'
- en: Both plugins ensure the reliable delivery of messages across brokers by routing
    them as instructed or offering a safe place for them to remain until they can
    be dealt with. Neither requires the brokers to be clustered, which simplifies
    setup and management. Moreover, both plugins work fine over WAN connections, which
    isn't the case in a clustering scenario.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个插件通过按指令路由消息或提供一个安全的地方让它们在可以处理之前保持不变，确保了消息在经纪人之间可靠地传递。它们都不需要经纪人集群，这简化了设置和管理。此外，这两个插件在WAN连接上也能正常工作，这在集群场景中是不常见的。
- en: Configure the destination node in a federation manually. The upstream nodes
    are configured automatically. On the other hand, shovels must have each source
    node configured manually to send to a destination node, which itself doesn't require
    any configuration.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 手动配置联邦中的目标节点。上游节点会自动配置。另一方面，铲子必须手动配置每个源节点以发送到目标节点，而目标节点本身不需要任何配置。
- en: The CC team is requesting a good way to process logs, and they quickly realize
    that the federation plugin suits the process well.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: CC团队正在寻求一种处理日志的好方法，他们很快意识到联邦插件非常适合这个过程。
- en: Handling log processing
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理日志处理
- en: CC's system is growing and growing, and so is the team of taxi drivers and developers.
    The team that is in charge of analytics has been looking for an elegant solution
    to aggregate logs from different applications in order to roll out new statistics,
    both for internal and end-user consumption. Fortunately, RabbitMQ can be used
    for application log processing thanks to its high performance.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: CC的系统正在不断增长，出租车司机和开发者的团队也在不断扩大。负责分析的那个团队一直在寻找一个优雅的解决方案来聚合来自不同应用的日志，以便推出新的统计数据，供内部和最终用户使用。幸运的是，由于RabbitMQ的高性能，它可以用于应用日志处理。
- en: 'In this topology, all applications will write to a local RabbitMQ node, which
    will act as a store-and-forward broker, pushing all logs to a centralized RabbitMQ
    node as shown in the following diagram:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个拓扑中，所有应用都将写入本地RabbitMQ节点，该节点将充当存储和转发代理，将所有日志推送到中心RabbitMQ节点，如下面的图所示：
- en: '![](img/0e4ea0d7-dc9c-4cd4-bd9d-79f54c14dedd.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0e4ea0d7-dc9c-4cd4-bd9d-79f54c14dedd.png)'
- en: 'Fig 6.7: A topology that federates log messages to a central broker'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7：将日志消息联邦到一个中心代理的拓扑
- en: 'If this central node is down, the log entries will remain locally accumulated
    until it comes back up. Messages flow through an exchange in one location (called
    the **upstream**) to be replicated to exchanges in other locations (the **downstream**),
    as seen in the following diagram:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个中心节点宕机，日志条目将保留在本地累积，直到它恢复。消息通过一个位置（称为**上游**）的交换流动，以复制到其他位置的交换（**下游**），如下面的图所示：
- en: '![](img/b8e50b47-c62f-43b2-805b-433ad9bcc1ff.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b8e50b47-c62f-43b2-805b-433ad9bcc1ff.png)'
- en: 'Fig 6.8: Exchange federation message flow'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8：交换联邦消息流
- en: Obviously, the assumption here is that the local RabbitMQ nodes are extremely
    stable. The experience with running RabbitMQ in the past few months will help
    with this approach. Moreover, logs are considered important but not critical data
    for CC, so a best-effort approach is acceptable. Knowing this, the team chooses
    to use the federation plugin, as it's the one that supports federation to queue
    connectivity (with the shovel plugin, messages would have to be accumulated in
    a local queue on each node).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这里的假设是本地RabbitMQ节点非常稳定。过去几个月运行RabbitMQ的经验将有助于这种方法。此外，日志被认为对CC来说很重要，但不是关键数据，因此尽力而为的方法是可以接受的。了解这一点后，团队选择使用联邦插件，因为它支持联邦到队列连接（如果使用铲子插件，消息将需要在每个节点的本地队列中累积）。
- en: Remember, all queues that were mirrored in the previous section were queues
    that matched the `taxi-inbox\.\d+` regex pattern. All log queues mentioned now
    are left out of the equation. That's how the CC team wants it, as they don't want
    to mirror such highly trafficked queues. What could be done in order for CC to
    enjoy the same guarantees for log aggregation? Enter the notion of messaging topologies.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，上一节中镜像的所有队列都是匹配`taxi-inbox\.\d+`正则表达式的队列。现在提到的所有日志队列都被排除在外。这就是CC团队想要的，因为他们不希望镜像这样高流量的队列。为了使CC能够享受相同的日志聚合保证，可以做什么呢？引入消息拓扑的概念。
- en: More information on the shovel plugin can be found at [http://www.rabbitmq.com/shovel.html](http://www.rabbitmq.com/shovel.html).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于铲子插件的信息可以在[http://www.rabbitmq.com/shovel.html](http://www.rabbitmq.com/shovel.html)找到。
- en: 'The federation plugin needs to be installed on all RabbitMQ nodes that will
    engage in the topology by running the following commands on each node:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 需要在所有将参与拓扑的RabbitMQ节点上安装联邦插件，通过在每个节点上运行以下命令：
- en: '[PRE5]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Moreover, unlike with clustering, each node needs to be manually set up to have
    the desired user and virtual host configured. As discussed in [Chapter 1](4f4722d3-131f-4c38-9ea0-4c03e8545175.xhtml),
    *A Rabbit Springs to Life*, it is time to run the necessary command. Next, the
    `apps-log` exchange federation itself must be configured. This involves multiple
    steps (detailed shortly) that are all run on the central broker, the one toward
    which all logs will converge, the downstream.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，与集群不同，每个节点都需要手动设置以配置所需的用户和虚拟主机。如[第1章](4f4722d3-131f-4c38-9ea0-4c03e8545175.xhtml)“Rabbit
    Springs to Life”中讨论的那样，现在是运行必要命令的时候了。接下来，必须配置`apps-log`交换联邦本身。这涉及到多个步骤（稍后详细介绍），所有这些步骤都在中心代理上运行，即所有日志将汇聚的下游代理。
- en: First, the upstreams are configured, which are the RabbitMQ nodes that will
    send data to the central broker. Three upstreams are needed since there are three
    servers that will send logs, `app-prod-1`, `app-prod-2`, and `app-prod-3`; however,
    in the interest of brevity, only two nodes will be shown in the following example.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，配置上游，这些是向中心代理发送数据的RabbitMQ节点。需要三个上游，因为有三个服务器将发送日志，`app-prod-1`、`app-prod-2`和`app-prod-3`；然而，为了简洁起见，以下示例中只显示两个节点。
- en: 'An upstream can be added via `rabbitmqctl`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`rabbitmqctl`添加上游：
- en: '[PRE6]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Alternatively, the policy can be added via the management console:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以通过管理控制台添加策略：
- en: '![](img/492e034a-7261-4b8d-bd87-4ee399fe4e3b.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/492e034a-7261-4b8d-bd87-4ee399fe4e3b.png)'
- en: 'Fig 6.9: Add a federation upstream named app-prod-logs to the downstream broker'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9：将名为app-prod-logs的联盟上游添加到下游代理
- en: 'Once an upstream has been specified in the downstream, a policy that controls
    the federation can be added to the downstream server as well. The app-prod-logs
    federation is added just like any other policy ([https://www.rabbitmq.com/parameters.html#policies](https://www.rabbitmq.com/parameters.html#policies)) by
    using the terminal:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在下游指定了上游，就可以将控制联盟的策略添加到下游服务器。app-prod-logs联盟的添加就像任何其他策略一样（[https://www.rabbitmq.com/parameters.html#policies](https://www.rabbitmq.com/parameters.html#policies)），通过使用终端：
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The policy can also be added through the management console:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 策略也可以通过管理控制台添加：
- en: '![](img/1049fad9-ee30-4263-8790-44fd71eee88e.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1049fad9-ee30-4263-8790-44fd71eee88e.png)'
- en: 'Fig 6.10: Federation policy added to the downstream server'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10：将联盟策略添加到下游服务器
- en: The CC team does this by applying a policy that matches the exchange names.
    The pattern argument is a regular expression used to match queue (or exchange)
    names. In CC's case, the federation policy is applied to all exchanges with names
    beginning with `app-prod`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: CC团队通过应用匹配交换名称的策略来完成此操作。模式参数是一个用于匹配队列（或交换）名称的正则表达式。在CC的情况下，联盟策略应用于所有以`app-prod`开头的交换。
- en: A policy can apply to an upstream set or to a single exchange or queue upstream.
    In this example, `federation-upstream-set` is applied to all upstreams.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 策略可以应用于上游集、单个交换或队列上游。在这个例子中，`federation-upstream-set`应用于所有上游。
- en: If it is certain that there will never be more than one logical group of upstreams,
    the creation of an upstream set is skipped in favor of using the implicit set
    named `all`, which automatically contains all the upstreams in a virtual host.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果确定永远不会存在超过一个逻辑上游组，则可以跳过创建上游集，转而使用名为`all`的隐式集，该集自动包含虚拟主机中的所有上游。
- en: In this case, it is good to make sure that the user that the federation plugin
    will use in the central broker to interact with the federated exchange is also
    configured.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，确保联盟插件将在中心代理中用于与联盟交换进行交互的用户也已配置。
- en: 'Browse to the **Federation Upstreams** tab in the Admin section of the management
    console, which will show that the upstream has been correctly configured, as shown
    in the following screenshot:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览到管理控制台管理部分中的**联盟上游**选项卡，它将显示上游已正确配置，如下面的屏幕截图所示：
- en: '![](img/36c5915b-6424-4c89-90c1-0f61ed9f410b.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/36c5915b-6424-4c89-90c1-0f61ed9f410b.png)'
- en: 'Fig 6.11: Upstream nodes are configured in a federation'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11：在联盟中配置上游节点
- en: 'Switching to **Federation Status** shows an empty screen as it''s inactive.
    Why is that? After all, the topology was just created. The reason is that no exchange
    or queue is actively engaged in the topology yet. Because of its dynamic nature,
    the federation is inactive. Creating the app-logs exchange on both the upstream
    and the downstream servers and binding the app-logs exchange to queues is the
    next step before returning to the Federation Status tab. It is here noted that
    the federation is now running links for the app-logs exchange from the two upstream
    nodes of the configured set. See the following screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到**联盟状态**会显示一个空屏幕，因为它尚未激活。为什么会这样？毕竟，拓扑刚刚创建。原因是还没有任何交换或队列在拓扑中活跃。由于其动态特性，联盟处于非活动状态。在返回到联盟状态选项卡之前，下一步是在上游和下游服务器上创建app-logs交换并将其绑定到队列。这里需要注意的是，联盟现在正在从配置集的两个上游节点为app-logs交换运行链接。请参阅以下屏幕截图：
- en: '![](img/44088094-165a-49eb-8770-b0ca2dcfb5f4.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/44088094-165a-49eb-8770-b0ca2dcfb5f4.png)'
- en: 'Fig 6.12: Running upstream links for a federated exchange'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12：运行联盟交换的上游链接
- en: It's possible to get the status of the federation from the command line by running
    `sudo rabbitmqctl eval rabbit_federation_status:status()` on the downstream node.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在下游节点上运行 `sudo rabbitmqctl eval rabbit_federation_status:status()` 命令从命令行获取联盟的状态。
- en: 'The Connections and Channels tabs of the management console now show that the
    downstream node is connected to the upstream node over the AMQP protocol, as seen
    in the following screenshot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 管理控制台中的连接和通道选项卡现在显示下游节点通过AMQP协议连接到上游节点，如下面的屏幕截图所示：
- en: '![](img/b5739316-b32d-44c0-88d7-1ce4267bd0c8.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b5739316-b32d-44c0-88d7-1ce4267bd0c8.png)'
- en: 'Fig 6.13: Federation link in the Connections tab'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13：连接选项卡中的联盟链接
- en: Except for the setup of the topology itself, there's nothing magical about the
    federation. It's been built on top of AMQP, and thus benefits from the same advantages
    offered by the protocol. Hence, if the RabbitMQ instances are firewalled, no special
    port other than the one used by AMQP (`5672` by default) needs to be opened.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 除了拓扑结构的设置本身，联盟没有神秘之处。它是建立在AMQP之上的，因此能够从该协议提供的相同优势中受益。因此，如果RabbitMQ实例被防火墙隔离，除了默认情况下AMQP使用的端口（`5672`）之外，不需要打开任何特殊端口。
- en: Read more about the federation plugin at [http://www.rabbitmq.com/federation.html](http://www.rabbitmq.com/federation.html)
    and [http://www.rabbitmq.com/federation-reference.html](http://www.rabbitmq.com/federation-reference.html).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于联盟插件的详细信息，请参阅[http://www.rabbitmq.com/federation.html](http://www.rabbitmq.com/federation.html)和[http://www.rabbitmq.com/federation-reference.html](http://www.rabbitmq.com/federation-reference.html)。
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The CC example has provided information on how to create a basic message queue
    architecture, add valuable features to meet user demand, and keep a system running
    flawlessly. This chapter covered how RabbitMQ delivers powerful features through
    clustering and federation and how these features increase the availability and
    overall resilience of the messaging infrastructure. Quorum, classic mirrored,
    and lazy queues were also explored.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: CC示例提供了有关如何创建基本消息队列架构、添加满足用户需求的有价值功能以及使系统无故障运行的信息。本章介绍了RabbitMQ如何通过集群和联盟提供强大的功能，以及这些功能如何提高消息基础设施的可用性和整体弹性。还探讨了法定人数、经典镜像和懒队列。
- en: Along the way, information and guidance on best practices for a reliable, resilient
    system were offered. The next chapter highlights these recommendations and provides
    key takeaways from CC's journey through RabbitMQ. It also explores monitoring
    of RabbitMQ.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，提供了有关构建可靠、弹性系统的最佳实践的信息和指导。下一章强调了这些建议，并从CC通过RabbitMQ的旅程中总结了关键要点。它还探讨了RabbitMQ的监控。
