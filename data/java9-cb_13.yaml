- en: The Read-Evaluate-Print Loop (REPL) Using JShell
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JShell 的 Read-Evaluate-Print Loop (REPL)
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Getting familiar with REPL
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉 REPL
- en: Navigating JShell and its commands
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航 JShell 及其命令
- en: Evaluating code snippets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估代码片段
- en: Object-oriented programming in JShell
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JShell 中的面向对象编程
- en: Saving and restoring the JShell command history
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存和恢复 JShell 命令历史
- en: Using the JShell Java API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JShell Java API
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: '**REPL** stands for the **Read-Evaluate-Print Loop** and, as the name states,
    it reads the command entered on the command line, evaluates it, prints the result
    of evaluation, and continues this process on any command entered.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**REPL** 代表 **Read-Evaluate-Print Loop**，正如其名，它读取命令行上输入的命令，评估它，打印评估结果，并在任何输入的命令上继续此过程。'
- en: All the major languages, such as Ruby, Scala, Python, JavaScript, and Groovy,
    among others, have REPL tools. Java was missing the much-needed REPL. If we had
    to try out some sample code, say using `SimpleDateFormat` to parse a string, we
    had to write a complete program with all the ceremonies, including creating a
    class, adding a main method, and then the single line of code we want to experiment.
    Then, we have to compile and run the code. These ceremonies make it harder to
    experiment and learn the features of the language.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 所有主要的语言，如 Ruby、Scala、Python、JavaScript 和 Groovy 等，都有 REPL 工具。Java 缺少这个非常需要的
    REPL。如果我们想尝试一些示例代码，比如使用 `SimpleDateFormat` 解析一个字符串，我们必须编写一个完整的程序，包括创建一个类、添加一个主方法，然后是我们想要实验的单行代码。然后，我们必须编译并运行代码。这些仪式使得实验和学习语言特性变得更加困难。
- en: With a REPL, you can type only the line of code that you are interested in experimenting
    with and you would have immediate feedback on whether the expression is syntactically
    correct and gives the desired results. REPL is a very powerful tool, especially
    for people coming to the language for the first time. Suppose you want to show
    how to print *Hello World* in Java; for this, you'd have to start writing the
    class definition, then the `public static void main(String [] args)` method, and
    by the end of it, you would have explained or tried to explain a lot of concepts
    that would otherwise be difficult for a newbie to comprehend.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 REPL，你只需输入你想要实验的代码行，你将立即得到关于表达式是否语法正确以及是否给出预期结果的反馈。REPL 是一个非常强大的工具，特别是对于第一次接触这门语言的人来说。假设你想展示如何在
    Java 中打印 *Hello World*；为此，你必须开始编写类定义，然后是 `public static void main(String [] args)`
    方法，到结束时，你会解释或尝试解释很多新手难以理解的概念。
- en: Anyways, with Java 9, Java developers can now stop cribbing about the absence
    of a REPL tool. A new REPL called JShell is being bundled with the JDK installation.
    So, we can now proudly write *Hello World* as our first *Hello World* code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，随着 Java 9 的推出，Java 开发者现在可以停止抱怨缺少 REPL 工具了。一个新的名为 JShell 的 REPL 正被捆绑到 JDK
    安装中。因此，我们现在可以自豪地写出我们的第一个 *Hello World* 代码。
- en: In this chapter, we will explore the features of JShell and write code that
    will truly amaze us and appreciate the power of REPL. We will also see how we
    can create our own REPLs using the JShell Java API.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索 JShell 的特性，并编写一些真正令人惊叹的代码，以欣赏 REPL 的力量。我们还将看到如何使用 JShell Java API
    创建我们自己的 REPL。
- en: Getting familiar with REPL
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熟悉 REPL
- en: In this recipe, we will look at a few basic operations to help us get familiarize
    us with the JShell tool.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将查看一些基本操作，帮助我们熟悉 JShell 工具。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you have the latest JDK 9 version installed, which has JShell.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经安装了最新的 JDK 9 版本，其中包含 JShell。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: By now, you should have `%JAVA_HOME%/bin` (on Windows) or `$JAVA_HOME/bin` (on
    Linux) added to your `PATH` variable. If not, then please visit the recipe, *Installing
    JDK 9 on Windows and setting up the PATH variable* and *Installing JDK 9 on Linux
    (Ubuntu, x64) and configuring the PATH variable* in [Chapter 1](5cd0711b-a2f8-4129-9ec2-e80e4a0cf8db.xhtml),
    *Installation and a Sneak Peek into Java 9*.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经将 `%JAVA_HOME%/bin`（在 Windows 上）或 `$JAVA_HOME/bin`（在 Linux 上）添加到你的
    `PATH` 变量中。如果没有，请访问[第 1 章](5cd0711b-a2f8-4129-9ec2-e80e4a0cf8db.xhtml)中的食谱，*在
    Windows 上安装 JDK 9 并设置 PATH 变量* 和 *在 Linux (Ubuntu, x64) 上安装 JDK 9 并配置 PATH 变量*。
- en: In your command prompt, type `jshell` and press enter.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的命令提示符中，输入 `jshell` 并按回车键。
- en: 'You will see a message and then a `jshell>` prompt:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到一个消息，然后是一个 `jshell>` 提示符：
- en: '![](img/cc3a1d23-a727-417e-a8b2-aefca185d2f2.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cc3a1d23-a727-417e-a8b2-aefca185d2f2.png)'
- en: 'Forward slash(`/`)**,** followed by the JShell-supported commands, help you
    in interacting with JShell. Just like we try `/help intro` to get the following:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前缀斜杠(`/`)**，**后跟 JShell 支持的命令，帮助您与 JShell 交互。就像我们尝试 `/help intro` 来获取以下内容：
- en: '![](img/dd485fd1-e0a1-4960-a09f-ac1af706f7c9.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dd485fd1-e0a1-4960-a09f-ac1af706f7c9.png)'
- en: 'Let''s print a `Hello World` message:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打印一个 `Hello World` 消息：
- en: '![](img/273d1001-c971-4b6e-9633-5783bfc91063.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/273d1001-c971-4b6e-9633-5783bfc91063.png)'
- en: 'Let''s print a customized `Hello World` message:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打印一个定制的 `Hello World` 消息：
- en: '![](img/debc42a8-b265-4d9b-b85d-ac668fe4c662.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/debc42a8-b265-4d9b-b85d-ac668fe4c662.png)'
- en: You can navigate through the executed commands using the up and down arrow keys.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用上箭头键和下箭头键在已执行的命令之间导航。
- en: How it works...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The code snippets entered at the `jshell` prompt are wrapped with just enough
    code to execute them. So, variable, method and class declarations get wrapped
    within a class and expressions get wrapped within a method which is in turn wrapped
    within the class. Other things such as imports and class definitions remain as
    is because they are top-level entities that is, wrapping a class definition within
    another class is not required as a class definition is a top level entity and
    can exist by itself. Similarly, in Java, import statements can occur by themselves
    and they occur outside of a class declaration and hence need not be wrapped inside
    a class.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `jshell` 提示符中输入的代码片段被包裹在仅足够执行它们的代码中。因此，变量、方法和类声明被包裹在一个类中，表达式被包裹在一个方法中，而这个方法又反过来被包裹在类中。其他如导入和类定义等事物保持原样，因为它们是顶级实体，即不需要在另一个类中包裹类定义，因为类定义是一个顶级实体，可以独立存在。同样，在
    Java 中，导入语句可以独立存在，并且它们出现在类声明之外，因此不需要在类中包裹。
- en: In the subsequent recipes, we will see how to define a method, import additional
    packages, define classes, and so on.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在随后的菜谱中，我们将看到如何定义方法、导入额外的包、定义类等等。
- en: In the preceding recipe, we saw `$1 ==> "Hello World"`. If we have some value
    without any variable associated with it, then `jshell` gives it a variable name,
    such as `$1`, `$2`, and so on.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的菜谱中，我们看到了 `$1 ==> "Hello World"`。如果我们有一些没有与任何变量关联的值，那么 `jshell` 会给它一个变量名，例如
    `$1`、`$2` 等等。
- en: Navigating JShell and its commands
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 JShell 中导航及其命令
- en: In order to leverage a tool, we need to be familiar with how to use it, the
    commands it provides, and the various shortcut keys that we can use to be productive.
    In this recipe, we will look at the different ways we can navigate through JShell
    and also at the different keyboard shortcuts it provides to be productive while
    using it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用一个工具，我们需要熟悉如何使用它、它提供的命令以及我们可以使用的各种快捷键，以便提高生产力。在这个菜谱中，我们将查看我们可以通过不同的方式在 JShell
    中导航，以及它提供的不同键盘快捷键，以便在使用时提高生产力。
- en: How to do it...
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Spawn the JShell by typing `jshell` in the command prompt, and you will be greeted
    with a welcome message containing the instructions to get started.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在命令提示符中输入 `jshell` 来启动 JShell，您将看到一个包含开始指令的欢迎消息。
- en: 'Type `/help intro` to get a brief introduction to JShell:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `/help intro` 获取 JShell 的简要介绍：
- en: '![](img/b4668e7b-a5d3-47e4-907e-638d7e06c3e5.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b4668e7b-a5d3-47e4-907e-638d7e06c3e5.png)'
- en: 'Type `/help` to get a list of the supported commands:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `/help` 获取支持的命令列表：
- en: '![](img/f5e02b24-9f26-4c14-8e43-6c097e9042fa.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f5e02b24-9f26-4c14-8e43-6c097e9042fa.png)'
- en: 'To get more information about a command, type `/help <command>`. For example,
    to get information about `/edit`, type `/help /edit`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取有关命令的更多信息，请输入 `/help <command>`。例如，要获取有关 `/edit` 的信息，请输入 `/help /edit`：
- en: '![](img/363a77a7-4b4b-4646-8e0d-aca0ba82888c.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/363a77a7-4b4b-4646-8e0d-aca0ba82888c.png)'
- en: 'There is autocompletion support in JShell. This makes Java developers feel
    at home. You can invoke autocompletion using the *Tab* key:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JShell 中有自动完成支持。这使得 Java 开发者感到宾至如归。您可以使用 *Tab* 键调用自动完成：
- en: '![](img/8b2030c3-d41d-4221-9754-f7bbcef3ca11.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8b2030c3-d41d-4221-9754-f7bbcef3ca11.png)'
- en: You can use `/!` to execute a previously executed command and `/line_number`
    to re-execute an expression at the line number.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用 `/!` 来执行之前执行过的命令，以及使用 `/line_number` 在指定行号重新执行表达式。
- en: To navigate the cursor through the command line, use *Ctrl* + *A* to reach the
    beginning of the line and *Ctrl* + *E* to reach the end of the line.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要通过命令行导航光标，请使用 *Ctrl* + *A* 来到达行的开头，以及 *Ctrl* + *E* 来到达行的末尾。
- en: Evaluating code snippets
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估代码片段
- en: 'In this recipe, we will look at executing the following code snippets:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将查看执行以下代码片段：
- en: Import statements
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入语句
- en: Class declarations
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类声明
- en: Interface declarations
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口声明
- en: Method declarations
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法声明
- en: Field declarations
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段声明
- en: Statements
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语句
- en: How to do it...
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open the command prompt and launch JShell.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令提示符并启动JShell。
- en: 'By default, JShell imports a few libraries. We can check that by issuing the `/imports`
    command:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，JShell导入了一些库。我们可以通过发出`/imports`命令来检查这一点：
- en: '![](img/5bf0109e-27f8-464a-9f52-b1a3953dbaac.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5bf0109e-27f8-464a-9f52-b1a3953dbaac.png)'
- en: Let's import `java.text.SimpleDateForm` by issuing the `import java.text.SimpleDateFormat`
    command. This imports the `SimpleDateFormat` class.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过发出`import java.text.SimpleDateFormat`命令来导入`java.text.SimpleDateForm`。这将导入`SimpleDateFormat`类。
- en: 'Let''s declare an `Employee` class. We will issue one statement in each line
    so that it''s an incomplete statement, and we''ll proceed in the same way as we
    do in any ordinary editor. The following illustration will clarify this:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们声明一个`Employee`类。我们将每行发出一个语句，使其成为一个不完整的语句，然后以与任何普通编辑器相同的方式进行操作。以下插图将阐明这一点：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![](img/5fbba3f1-7cff-4244-9d67-088ab47122fc.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5fbba3f1-7cff-4244-9d67-088ab47122fc.png)'
- en: 'Let''s declare an `Employability` interface, which defines a method, `employable()`,
    as shown in the following code snippet:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们声明一个`Employability`接口，该接口定义了一个方法`employable()`，如下面的代码片段所示：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding interface when created via the `jshell` is shown below:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`jshell`创建的上述接口如下所示：
- en: '![](img/b5b02234-5755-4dc9-bae9-0408b426d4e6.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b5b02234-5755-4dc9-bae9-0408b426d4e6.png)'
- en: 'Let''s declare a `newEmployee(String empId)` method, which constructs an `Employee`
    object with the given `empId`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们声明一个`newEmployee(String empId)`方法，该方法使用给定的`empId`构建一个`Employee`对象：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding method defined in JShell is shown below:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在JShell中定义的方法：
- en: '![](img/51e480a9-dc9b-45c2-a229-baaf6286a1a4.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/51e480a9-dc9b-45c2-a229-baaf6286a1a4.png)'
- en: 'We will use the method defined in the previous step to create a statement declaring
    an `Employee` variable:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用上一步中定义的方法来创建一个声明`Employee`变量的语句：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The above statement and its output when executed from within JShell are shown
    below. The snippet `e.get + Tab` key generates auto-completion as supported by
    the IDEs.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语句及其在JShell中执行时的输出如下所示。`e.get + Tab`键生成由IDEs支持的自动完成。
- en: '![](img/a7fa1073-34f1-41bf-ab4a-82c1d59188f2.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a7fa1073-34f1-41bf-ab4a-82c1d59188f2.png)'
- en: There's more...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We can invoke an undefined method. Take a look at the following example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调用一个未定义的方法。请看以下示例：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![](img/556ab767-952d-4ac1-b43b-c25a036c583e.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/556ab767-952d-4ac1-b43b-c25a036c583e.png)'
- en: 'However, the method cannot be invoked before the method being used has been
    defined:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在定义被使用的方法之前，不能调用该方法：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](img/e4b66e3f-6e06-41da-8873-0dc2013be06b.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e4b66e3f-6e06-41da-8873-0dc2013be06b.png)'
- en: We can invoke `newMethod()` only after we have defined `undefinedMethod()`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能在定义了`undefinedMethod()`之后调用`newMethod()`。
- en: Object-oriented programming in JShell
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JShell中的面向对象编程
- en: In this recipe, we will make use of predefined Java class definition files and
    import them into JShell. Then, we will play around with those classes in the JShell.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用预定义的Java类定义文件并将它们导入JShell。然后，我们将在JShell中玩转这些类。
- en: How to do it...
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The class definition files we will use in this recipe are available at the location, `chp13/4_oo_programming`,
    in the code downloads for this book.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在本食谱中使用位于代码下载中`chp13/4_oo_programming`位置的类定义文件。
- en: 'There are three class definition files: `Engine.java`, `Dimensions.java`, and
    `Car.java`.'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有三个类定义文件：`Engine.java`、`Dimensions.java`和`Car.java`。
- en: Navigate to the directory where these three class definition files are available.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到包含这三个类定义文件的目录。
- en: The `/open` command allows loading the code from within a file.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/open`命令允许从文件中加载代码。'
- en: We will load the `Engine` class definition and create an `Engine` object.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将加载`Engine`类的定义并创建一个`Engine`对象。
- en: '![](img/a66a4725-1fd9-4d3f-87f7-5b2dd87c70cb.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a66a4725-1fd9-4d3f-87f7-5b2dd87c70cb.png)'
- en: 'Next, we will load the `Dimensions` class definition and create a `Dimensions`
    object:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将加载`Dimensions`类的定义并创建一个`Dimensions`对象：
- en: '![](img/700d6bd9-7540-4dcf-a742-3fa3a211421d.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/700d6bd9-7540-4dcf-a742-3fa3a211421d.png)'
- en: 'Finally, we will load the `Car` class definition and create a `Car` object:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将加载`Car`类的定义并创建一个`Car`对象：
- en: '![](img/472eb927-a529-4017-9a11-37a051b3d48a.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/472eb927-a529-4017-9a11-37a051b3d48a.png)'
- en: Saving and restoring the JShell command history
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存和恢复JShell命令历史
- en: We will want to try out some code snippets in `jshell` as a means to explain
    Java programming to someone who is new to it. Moreover, some form of record of
    what code snippets were executed will be useful for the person who is learning
    the language.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试在`jshell`中运行一些代码片段，作为向初学者解释Java编程的手段。此外，记录执行过的代码片段对于学习语言的人来说将是有用的。
- en: In this recipe, we will execute a few code snippets and save them into a file.
    We will then load the code snippets from the saved file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将执行一些代码片段并将它们保存到文件中。然后我们将从保存的文件中加载代码片段。
- en: How to do it...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s execute a series of code snippets, as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们执行一系列代码片段，如下所示：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![](img/eb5891bd-fa29-478e-afef-6d46e85fc22c.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eb5891bd-fa29-478e-afef-6d46e85fc22c.png)'
- en: Save the code snippets executed into a file called `history` using the `/save
    history` command.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`/save history`命令将执行过的代码片段保存到名为`history`的文件中。
- en: Exit the shell using `/exit` and list the files in the directory by using `dir`
    or `ls`, depending on the OS. There will be a `history` file in the listing.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`/exit`退出shell，然后根据操作系统使用`dir`或`ls`列出目录中的文件。列表中会有一个`history`文件。
- en: Open `jshell` and check for the history of code snippets executed using `/list`.
    You will see that there are no code snippets executed.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`jshell`并使用`/list`检查执行过的代码片段的历史记录。您将看到没有执行过的代码片段。
- en: 'Load the `history` file using `/open history` and then check for the history
    of the code snippets executed using `/list`. You will see all the previous code
    snippets being executed and added to the history:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`/open history`加载`history`文件，然后使用`/list`检查执行过的代码片段的历史记录。您将看到所有之前执行并添加到历史记录中的代码片段：
- en: '![](img/94763af0-658f-4657-8a2f-423ad1538e03.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/94763af0-658f-4657-8a2f-423ad1538e03.png)'
- en: Using the JShell Java API
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JShell Java API
- en: JDK 9 provides the Java API for creating tools such as `jshell` for evaluating
    Java code snippets. This Java API is present in the `jdk.jshell` module ([http://cr.openjdk.java.net/~rfield/arch/doc/jdk/jshell/package-summary.html](http://cr.openjdk.java.net/~rfield/arch/doc/jdk/jshell/package-summary.html)).
    So, if you want to use the API in your application, then you need to declare a
    dependency on the `jdk.jshell` module.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 9提供了用于创建工具（如用于评估Java代码片段的`jshell`）的Java API。这个Java API存在于`jdk.jshell`模块中([http://cr.openjdk.java.net/~rfield/arch/doc/jdk/jshell/package-summary.html](http://cr.openjdk.java.net/~rfield/arch/doc/jdk/jshell/package-summary.html))。因此，如果您想在您的应用程序中使用此API，那么您需要声明对`jdk.jshell`模块的依赖。
- en: In this recipe, we will use the JShell JDK API to evaluate simple code snippets,
    and you'll also see different APIs to get the state of JShell. The idea is not
    to recreate JShell but to show how to make use of its JDK API.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用JShell JDK API评估简单的代码片段，您还将看到不同的API来获取JShell的状态。我们的想法不是重新创建JShell，而是展示如何利用其JDK
    API。
- en: For this recipe, we will not be using JShell; instead, we will follow the usual
    way of compiling using `javac` and running using `java`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们不会使用JShell；相反，我们将遵循使用`javac`编译和使用`java`运行的传统方式。
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Our module will depend on the `jdk.jshell` module. So, the module definition
    will look like the following:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的这个模块将依赖于`jdk.jshell`模块。因此，模块定义将如下所示：
- en: '[PRE7]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s create an instance of the `jdk.jshell.JShell` class by using its `create()`
    method or the builder API in `jdk.jshell.JShell.Builder`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用`jdk.jshell.JShell`类的`create()`方法或`jdk.jshell.JShell.Builder`中的构建器API来创建一个实例：
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s read the code snippet from `System.in` using `java.util.Scanner`:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用`java.util.Scanner`从`System.in`读取代码片段：
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will use the `jdk.jshell.JShell#eval(String snippet)` method to evaluate
    the input. Evaluation will result in a list of `jdk.jshell.SnippetEvent`, which
    contains the status and output of evaluation. The TODO in the preceding code snippet
    will be replaced by the following lines:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`jdk.jshell.JShell#eval(String snippet)`方法来评估输入。评估将产生一个包含评估状态和输出的`jdk.jshell.SnippetEvent`列表。前一个代码片段中的TODO将被以下行替换：
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After the evaluation is completed, we will print the snippets processed by using
    the `jdk.jshell.JShell.snippets()` method, which will return `Stream` of `Snippet`
    processed.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估完成后，我们将使用`jdk.jshell.JShell.snippets()`方法打印处理过的代码片段，该方法将返回处理过的`Snippet`的`Stream`。
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Similarly, we can print the active method and variables as follows:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们可以按如下方式打印活动方法和变量：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Before the application exits, we close the `JShell` instance by invoking its
    `close()` method:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序退出之前，我们通过调用其`close()`方法来关闭`JShell`实例：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The code for this recipe can be found at the location, `chp13/6_jshell_api`.
    You can run the sample by using the `run.bat` or `run.sh` scripts available in
    the same directory. The sample execution and output is shown here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱的代码可以在以下位置找到，`chp13/6_jshell_api`。您可以通过使用同一目录中可用的`run.bat`或`run.sh`脚本运行示例。示例执行和输出如下所示：
- en: '![](img/ec75236a-c45f-471a-b7ca-18de3ba63d98.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec75236a-c45f-471a-b7ca-18de3ba63d98.png)'
- en: How it works...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The central class in the API is the `jdk.jshell.JShell` class. This class is
    the evaluation state engine, whose state is modified with every evaluation of
    the snippet. As we saw earlier, the snippets are evaluated using the `eval(String
    snippet)` method. We can even drop the previously evaluated snippet using the
    `drop(Snippet snippet)` method. Both these methods result in a change of the internal
    state maintained by `jdk.jshell.JShell`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: API中的核心类是`jdk.jshell.JShell`类。这个类是评估状态引擎，其状态在每次评估片段时都会被修改。正如我们之前看到的，片段是通过`eval(String
    snippet)`方法进行评估的。我们甚至可以使用`drop(Snippet snippet)`方法丢弃之前评估的片段。这两个方法都会导致`jdk.jshell.JShell`维护的内部状态发生变化。
- en: 'The code snippets passed to the `JShell` evaluation engine are categorized
    as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`JShell`评估引擎的代码片段被分类如下：
- en: '**Erroneous**: Syntactically incorrect input'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误**: 语法不正确的输入'
- en: '**Expressions**: An input which might or might not result in some output'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表达式**: 可能或可能不产生某些输出的输入'
- en: '**Import**: An import statement'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导入**: 一个导入语句'
- en: '**Method**: A method declaration'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法**: 方法声明'
- en: '**Statement**: A statement'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语句**: 一个语句'
- en: '**Type declaration**: A type, that is, class/interface declaration'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型声明**: 一个类型，即类/接口声明'
- en: '**Variable declaration**: A variable declaration'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变量声明**: 一个变量声明'
- en: All these categories are captured in the `jdk.jshell.Snippet.Kind` enum.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些类别都被捕获在`jdk.jshell.Snippet.Kind`枚举中。
- en: We also saw different APIs to get the evaluated snippets, created methods, variable
    declarations, and other specific snippet types executed. Each snippet type is
    backed by a class extending the `jdk.jshell.Snippet` class.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了不同的API来获取评估的片段、创建的方法、变量声明和其他特定片段类型的执行。每种片段类型都由扩展`jdk.jshell.Snippet`类的类支持。
