- en: Chapter 8. Domain Specific Languages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章。领域特定语言
- en: In the previous chapter, we covered the core concepts of functional programming
    such as pure functions, immutability, and higher-order functions. We introduced
    some of the design patterns that are prevalent in large functional programs. Finally,
    we covered two popular functional programming libraries called Cats and Doobie
    and used them to write some interesting programs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了函数式编程的核心概念，如纯函数、不可变性和高阶函数。我们介绍了一些在大型函数式程序中普遍存在的模式。最后，我们介绍了两个流行的函数式编程库
    Cats 和 Doobie，并使用它们编写了一些有趣的程序。
- en: In this chapter, we will cover how Scala makes it possible to write powerful
    DSLs by providing a few interesting language features. We'll have a brief look
    at what DSLs are in general terms. We'll also cover a DSL that you'll very likely
    be using if you're going to work with Scala professionally. Finally, you will
    implement your own DSL.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍 Scala 如何通过提供一些有趣的语言特性来编写强大的 DSLs。我们将简要地看看 DSLs 的一般概念。我们还将介绍一个你如果打算专业地使用
    Scala 的话很可能要使用的 DSL。最后，你将实现你自己的 DSL。
- en: This chapter demonstrates how Scala makes it possible to write powerful Domain
    Specific Languages (DSLs) by providing a few interesting language features.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了 Scala 如何通过提供一些有趣的语言特性，使得编写强大的领域特定语言（DSLs）成为可能。
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Identify the use of Domain Specific Languages (DSLs)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别领域特定语言（DSLs）的使用
- en: Use the DSL `ScalaTest`, a popular testing library for Scala
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 DSL `ScalaTest`，一个流行的 Scala 测试库
- en: Design your own DSLs in Scala
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Scala 中设计你自己的 DSLs
- en: Recognize the additional libraries and tools that will be useful beyond this
    book
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别本书之外将有用的额外库和工具
- en: DSLs and Types of DSLs
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DSLs 和 DSL 类型
- en: A domain specific language is, as the name suggests, a language that's specialized
    for a specific domain. Contrast that with a language like Scala, which is a general-purpose
    language in the sense that it's applicable across a broad range of domains.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 领域特定语言，正如其名所示，是一种针对特定领域专门化的语言。与之相对的是像 Scala 这样的语言，它是一种通用语言，因为它适用于广泛的领域。
- en: 'By restricting the domain, you''d hope to make a language that''s less comprehensive
    but better suited to solving a specific set of problems within a domain. A well-constructed
    DSL will make it easy to solve problems within a domain and make it hard for the
    user to make mistakes. DSLs come in many different shapes and sizes, but you can
    roughly separate them into two groups: external DSLs and internal DSLs.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通过限制领域，你希望创建一个不那么全面但更适合解决领域内特定问题集的语言。一个构建良好的 DSL 将使解决领域内的问题变得容易，并使用户难以出错。DSLs
    形态各异，大小不一，但你可以大致将它们分为两组：外部 DSLs 和内部 DSLs。
- en: External DSLs
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部 DSLs
- en: External DSLs are written "outside" of the host language (the language that's
    used to implement the DSL is called the host language). That means you'll have
    to parse the text, evaluate it, and so on, just as if you were creating a general-purpose
    programming language. We won't be creating an external DSL, so we won't cover
    the topic much further.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 外部 DSLs 是在宿主语言之外编写的（用于实现 DSL 的语言称为宿主语言）。这意味着你将不得不解析文本、评估它等等，就像你正在创建一种通用编程语言一样。我们不会创建外部
    DSL，因此我们不会进一步深入探讨这个主题。
- en: 'One example of an external DSL is `DOT`, which is used to describe graphs.
    Here''s an example of a simple `DOT` program, which produces the graph you see
    here:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 外部领域特定语言的一个例子是 `DOT`，它用于描述图。下面是一个简单的 `DOT` 程序示例，它生成了你在这里看到的图：
- en: '![External DSLs](img/8_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![外部领域特定语言](img/8_01.jpg)'
- en: 'Here is the code that can be written to implement the graph above:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是实现上述图的代码：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: So, `DOT` is specialized for the domain of describing graphs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`DOT` 专门用于描述图的领域。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on `DOT`, please refer to [https://en.wikipedia.org/wiki/DOT_(graph_description_language)](https://en.wikipedia.org/wiki/DOT_(graph_description_language)).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `DOT` 的更多信息，请参阅 [https://en.wikipedia.org/wiki/DOT_(graph_description_language)](https://en.wikipedia.org/wiki/DOT_(graph_description_language))。
- en: Internal DSLs
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内部 DSLs
- en: 'Internal DSLs are embedded in the host language and can be separated into two
    groups:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 内部 DSLs 嵌入在宿主语言中，可以分为两组：
- en: '**Shallow:** Operations directly use the host language''s operations (for example,
    `+` uses Scala''s `+`).'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浅显的：**操作直接使用宿主语言的操作（例如，`+` 使用 Scala 的 `+`）。'
- en: '**Deep:** You build up your abstract syntax tree (AST) and evaluate it just
    as you would with an external DSL.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深**：您构建抽象语法树 (AST) 并像使用外部 DSL 一样评估它。'
- en: We'll be writing an internal shallow DSL in this chapter, which is also, in
    my experience, the most common type of DSL you'll encounter when you're using
    various Scala libraries.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将编写一个内部浅 DSL，这在我的经验中，也是你在使用各种 Scala 库时最常遇到的一种 DSL 类型。
- en: '`ScalaTest` is a very popular testing library for Scala. It has a set of different
    DSLs for writing your test specifications. We''ll look at `ScalaTest` in depth
    in the next section.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScalaTest` 是一个非常流行的 Scala 测试库。它提供了一套不同的 DSLs 用于编写测试规范。我们将在下一节深入探讨 `ScalaTest`。'
- en: You now have a very basic understanding of what DSLs are and how they can be
    grouped into internal/external and shallow/deep. In the next section, we'll look
    at `ScalaTest` and how that library uses DSLs to make it easy to write test specifications.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你对 DSLs 是什么以及它们如何被分组为内部/外部和浅/深有了非常基本的了解。在下一节中，我们将探讨 `ScalaTest` 以及该库如何使用
    DSLs 使编写测试规范变得容易。
- en: ScalaTest – A Popular DSL
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ScalaTest – 一个流行的 DSL
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`ScalaTest` was introduced in [Chapter 1](ch01.html "Chapter 1. Setting up
    the Development Environment"), *Setting up the Development Environment*, but as
    we''ll use it extensively in this lecture, we''ll do a little recap here and make
    sure that everyone has a working `ScalaTest` environment.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScalaTest` 在 [第 1 章](ch01.html "第 1 章。设置开发环境") 中介绍，*设置开发环境*，但由于我们将在本次讲座中广泛使用它，我们在这里稍作回顾，并确保每个人都拥有一个可工作的
    `ScalaTest` 环境。'
- en: In this section, we'll have a look at a popular library for testing your Scala
    programs, `ScalaTest`, and see how the library uses DSLs to allow its users to
    write readable tests in various styles.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一个用于测试 Scala 程序的流行库，`ScalaTest`，并了解该库如何使用 DSLs 允许用户以各种风格编写可读的测试。
- en: The purpose of looking at `ScalaTest` is twofold. First off, `ScalaTest` is
    a widely used testing library for Scala projects, so you're likely to end up using
    it when you're using Scala professionally. Secondly, it's a good example of how
    to use DSLs to make your code more readable.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 研究 `ScalaTest` 的目的是双重的。首先，`ScalaTest` 是 Scala 项目的广泛使用的测试库，因此当你使用 Scala 进行专业开发时，你很可能会用到它。其次，它是一个很好的示例，展示了如何使用
    DSLs 使代码更易读。
- en: 'By the end of this section, you should be able to:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 到本节结束时，你应该能够：
- en: Identify how to use `ScalaTest` in your own projects
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别如何在您的项目中使用 `ScalaTest`
- en: Identify the various styles that `ScalaTest` offers and be able to pick the
    one that's relevant to your project
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别 `ScalaTest` 提供的各种风格，并能够选择与你项目相关的风格
- en: Write `ScalaTest` tests using the `F``latSpec` style
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `FlatSpec` 风格编写 `ScalaTest` 测试
- en: Adding ScalaTest to Your Project
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 ScalaTest 添加到您的项目中
- en: '`ScalaTest` is a Scala library like any other, so you simply add it as a library
    dependency to your project. As we''re using SBT in this book, we''ll use that
    as an example here. Create a new SBT project with the following `build.sbt` file:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScalaTest` 与其他 Scala 库一样，您只需将其作为项目依赖项添加即可。由于我们在本书中使用 SBT，因此我们将使用它作为示例。创建一个新的
    SBT 项目，包含以下 `build.sbt` 文件：'
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information, refer to the installation section ([http://www.scalatest.org/install](http://www.scalatest.org/install))
    from the documentation if you want to see how to use it outside of SBT.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解如何在外部使用它的更多信息，请参阅文档中的安装部分 ([http://www.scalatest.org/install](http://www.scalatest.org/install))。
- en: 'Create a simple test and place it in your `src/test/scala/com/example/ExampleSpec.scala`
    project:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个简单的测试并将其放置在你的 `src/test/scala/com/example/ExampleSpec.scala` 项目中：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To verify that your setup is correct, start an SBT session in the root of your
    project and run the following command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证您的设置是否正确，在项目根目录中启动一个 SBT 会话，并运行以下命令：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should see output similar to the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下类似的输出：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As we''ll be writing a few tests using `ScalaTest` in the following section,
    it''s important that you have a correctly configured SBT project that you can
    use for the exercises. Follow these steps:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在下一节中使用 `ScalaTest` 编写一些测试，因此确保你有一个正确配置的 SBT 项目，你可以用它来进行练习非常重要。请按照以下步骤操作：
- en: Create a new SBT project using the previous `build.sbt` definition.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用之前的 `build.sbt` 定义创建一个新的 SBT 项目。
- en: Create a new test file at `src/test/scala/com/example/ExampleSpec.scala` with
    the previous contents.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/test/scala/com/example/ExampleSpec.scala` 创建一个新的测试文件，并包含之前的内容。
- en: Run the tests using the `sbt test` command and make sure that it has detected
    the tests and that they pass.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `sbt test` 命令运行测试，并确保它已经检测到测试并且它们通过。
- en: You've seen how to add `ScalaTest` to your Scala project and how to run the
    tests using SBT. You should now have a correctly configured Scala project that
    you can use for the remainder of the exercises in this chapter. In the next section,
    we'll have a look at the various styles of tests you can write using `ScalaTest`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何将 `ScalaTest` 添加到你的 Scala 项目中，以及如何使用 SBT 运行测试。你现在应该有一个正确配置的 Scala 项目，你可以用它来完成本章剩余的练习。在下一节中，我们将探讨你可以使用
    `ScalaTest` 编写的各种测试风格。
- en: Overview of ScalaTest Styles
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ScalaTest 风格概述
- en: ScalaTest offers a selection of different styles that you can use when you're
    writing your tests. What style to use depends on your team's experience and preference.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ScalaTest 提供了不同的风格供你在编写测试时使用。使用哪种风格取决于你团队的经验和偏好。
- en: 'In this section, we''ll have a look at some of the different styles so you
    can get a feeling for what style you prefer:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看一些不同的风格，以便你可以了解你更喜欢哪种风格：
- en: '**FunSuite** is a simple style that will be familiar to most people:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FunSuite** 是一个简单且大多数人都会熟悉的风格：'
- en: '[PRE5]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**FlatSpec** is very similar to `FunSuite` but it focuses more on Behavior-Driven
    Design (BDD) by forcing you to name your tests in a manner that reads more like
    a specification:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FlatSpec** 与 `FunSuite` 非常相似，但它通过强迫你以更像规格的方式命名测试来更多地关注行为驱动设计（BDD）：'
- en: '[PRE6]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**FunSpec** is a good general-purpose style for writing specification-style
    tests:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FunSpec** 是编写规格式测试的一个很好的通用风格：'
- en: '[PRE7]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**FreeSpec** focuses on specification-style testing but doesn''t enforce any
    structure upon your tests:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FreeSpec** 专注于规格式测试，但不对你的测试施加任何结构：'
- en: '[PRE8]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**PropSpec** is for if you want to write tests exclusively in terms of property
    checks:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PropSpec** 是如果你只想用属性检查来编写测试的话：'
- en: '[PRE9]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**FeatureSpec** is primarily intended for acceptance testing:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FeatureSpec** 主要用于验收测试：'
- en: '[PRE10]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Example: `FunSuite`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：`FunSuite`
- en: 'Let''s have a look at the test case we created in the previous section:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看上一节中创建的测试用例：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There are two internal DSLs in action here. The first one is used to write your
    test specifications in the readable form of `"X" should "Y" in { <code> }`. This
    style is made available by extending `FlatSpec`. The other DSL is used to write
    your assertions in the form of `<expression> should be <expression>`, which is
    made available by extending `Matchers`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个内部 DSLs 在使用中。第一个用于以可读的形式 `"X" should "Y" in { <code> }"` 编写你的测试规格。这种风格是通过扩展
    `FlatSpec` 来提供的。另一个 DSL 用于以 `<expression> should be <expression>` 的形式编写你的断言，这是通过扩展
    `Matchers` 来提供的。
- en: The DSLs are implemented as a combination of classes and extension methods,
    but we'll look into that in greater detail when we implement our own little DSL
    in the next section.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: DSLs 是通过类和扩展方法的组合来实现的，但当我们实现自己的小 DSL 时，我们将在下一节中更详细地探讨这一点。
- en: 'Activity: Implementing ScalaTest Styles'
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动：实现 ScalaTest 风格
- en: The best way to get a feeling for the different styles is to use them. Select
    three of the styles from the previous list and convert the following test to those
    styles.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的方法是使用它们来感受不同的风格。从上一列表中选择三种风格，并将以下测试转换为这些风格。
- en: Continue using the Scala project you created in the previous activity.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续使用你在上一活动中创建的 Scala 项目。
- en: Create a file for each style you've selected. If you picked `FunSpec`, then
    create a `FunSpecExample.scala` file.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你选择的每个风格创建一个文件。如果你选择了 `FunSpec`，那么创建一个 `FunSpecExample.scala` 文件。
- en: 'For each style, convert the following test into a test that uses that style:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每种风格，将以下测试转换为使用该风格的测试：
- en: '[PRE12]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You've seen the different styles that `ScalaTest` offers and have a rough feeling
    for the difference between them.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了 `ScalaTest` 提供的不同风格，并且对它们之间的区别有了大致的了解。
- en: '`ScalaTest` is a testing library that uses DSLs to make it possible to write
    very readable tests. We have seen how you can add it to your own Scala projects,
    we got an overview of the different styles that it supports, and we have written
    a few tests using different styles. In the next section, we''ll look at the Scala
    features that Scala provides which make it possible to write DSLs in Scala.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScalaTest` 是一个使用 DSLs（领域特定语言）来使编写可读性很高的测试成为可能的测试库。我们已经看到了如何将其添加到自己的 Scala
    项目中，我们概述了它支持的不同风格，并且我们已经使用不同的风格编写了一些测试。在下一节中，我们将探讨 Scala 提供的使编写 Scala 中的 DSLs
    成为可能的功能。'
- en: Language Features for Writing DSLs
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 DSLs 的语言特性
- en: 'In this section, we''ll look at the Scala features that make it easy to write
    small DSLs:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨Scala的特性，这些特性使得编写小型DSL变得容易：
- en: Flexible syntax for method invocation
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法调用的灵活语法
- en: By-name parameters
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按名参数
- en: Extension methods and `Value` classes
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展方法和`Value`类
- en: We'll use all of these features in the next section when we create our own DSL
    in Scala.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我们的Scala DSL时，我们将在下一节中使用所有这些特性。
- en: Flexible Syntax for Method Invocation
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法调用的灵活语法
- en: Scala has a flexible syntax for method invocations that makes it possible to,
    in some cases, omit the dot ( `.`) and parentheses ( `()`) when invoking methods.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Scala具有灵活的方法调用语法，在某些情况下，调用方法时可以省略点（`.`）和括号（`()`）。
- en: 'The rules are as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 规则是这样的：
- en: For methods that are of arity-`0`, meaning they don't take any parameters, the
    parentheses can be omitted and you can use the postfix notation.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于阶数为`0`的方法，意味着它们不接受任何参数，可以省略括号并使用后缀表示法。
- en: For methods with an arity of `1` or more, meaning they take one or more parameters,
    it's possible to write the method using infix notation.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于阶数为`1`或更多的方法，意味着它们接受一个或多个参数，可以编写使用中缀表示法的方法。
- en: 'Here''s an example of using infix notation when invoking `filter`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个在调用`filter`时使用中缀表示法的示例：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: And here's an example of omitting the parentheses when invoking `toUpperCase:`
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个在调用`toUpperCase`时省略括号的示例：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This allows you to write code that reads more like prose, which is a nice option
    to have when you're creating your DSL.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你编写看起来更像散文的代码，当你创建自己的DSL时，这是一个很好的选项。
- en: By-Name Parameters
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按名参数
- en: 'By-name parameters make it possible to specify that a parameter that''s passed
    to a function shouldn''t be evaluated until it''s actually used:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 按名参数使得可以指定传递给函数的参数不应在实际上使用之前进行评估：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that both the `condition` and `body` parameter types have a `=>` prepended.
    That's how you specify that a parameter is a by-name parameter.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`condition`和`body`参数类型前面都带有`=>`。这就是指定一个参数为按名参数的方式。
- en: We'll use by-name parameters to enable the user to write the `… in { … code
    … }` blocks for the tests cases when we're writing our own DSL later in this chapter.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本章后面编写自己的DSL时，我们将使用按名参数来允许用户为测试用例编写`… in { … code … }`块。
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's important to note that by-name parameters are evaluated every time they're
    referenced.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，按名参数每次被引用时都会被评估。
- en: Extension Methods and Value Classes
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展方法和值类
- en: Extension methods are a technique for adding new methods to already existing
    Scala classes. `Value` Classes is a Scala feature that, among other things, makes
    it possible to create extension methods without incurring any allocation overhead.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法是一种向已存在的Scala类添加新方法的技术。`Value`类是Scala的一个特性，它使得在不产生任何分配开销的情况下创建扩展方法成为可能。
- en: Here's an example of a `Value` class that adds an extension method to `String:`
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个添加扩展方法到`String`的`Value`类的示例：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With this definition, there will be an implicit conversion from `String` to
    `StringExtension`, which allows you to invoke `repeat` on a string as if it had
    always been there (note the use of the postfix notation):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个定义，将会有从`String`到`StringExtension`的隐式转换，这使得你可以在字符串上调用`repeat`，就像它一直存在一样（注意后缀表示法的使用）：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We'll use extension methods and Value classes to add the `should` method to
    `String` when we're writing our own DSL later in this chapter.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本章后面编写自己的DSL时，我们将使用扩展方法和值类来为`String`添加`should`方法。
- en: We've seen how Scala's features make it possible to write nice internal DSLs
    in Scala. We'll now see how to write a custom DSL.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了Scala的特性如何使得在Scala中编写内部领域特定语言（DSL）成为可能。现在我们将看到如何编写自定义的DSL。
- en: Writing a Small DSL
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写小型DSL
- en: In this section, we'll reimplement some `FlatSpec` `ScalaTest` DSLs in order
    to see how to implement DSLs in Scala.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重新实现一些`FlatSpec` `ScalaTest` DSL，以便了解如何在Scala中实现DSL。
- en: First, we'll have a look at a simple way to model test cases in Scala using
    case classes. Then, we'll have a look at how to create a little DSL for creating
    those test cases.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将看看在Scala中使用案例类来建模测试用例的简单方法。然后，我们将看看如何创建一个用于创建这些测试用例的小型DSL。
- en: Modeling Test Cases
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建模测试用例
- en: 'Before we can create a DSL, we need to have something to create a DSL for.
    In our case, we want to create a DSL for specifying tests, so let''s have a look
    at how we could model tests using case classes in Scala:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够创建DSL之前，我们需要有一个为它创建的东西。在我们的例子中，我们想要创建一个用于指定测试的DSL，因此让我们看看我们如何使用Scala中的案例类来建模测试：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We''ll create an algebraic data type that represents the result of running
    a test case. The result can either be a failure that contains a message regarding
    the failure, or a `TestSuccess` that simply indicates that the test passed:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个代数数据类型，它表示运行测试用例的结果。结果可以是包含有关失败信息的失败，或者是一个简单的`TestSuccess`，表示测试通过：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Then, we define two simple case classes. `TestDescription` contains the description
    of a test case, whereas `TestCase` has such a description and a `run` function
    that can be used to invoke the test case.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义两个简单的案例类。`TestDescription`包含测试用例的描述，而`TestCase`具有这样的描述和一个`run`函数，可以用来调用测试用例。
- en: 'With this simple model, we can describe a test case like the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个简单的模型，我们可以描述一个测试用例，如下所示：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, `TestResult.wrap` is a method with the signature `def wrap(body: => Unit):
    () => TestResult`.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '这里，`TestResult.wrap`是一个具有签名`def wrap(body: => Unit): () => TestResult`的方法。'
- en: Now, this looks nothing like the nice test cases we wrote in the previous section
    using the `FlatSpec` DSL, so let's have a look at how we can create a DSL that
    creates a `TestCase` like the previous one.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这看起来与我们在上一节中使用`FlatSpec` DSL编写的良好测试用例完全不同，所以让我们看看我们如何创建一个创建类似之前`TestCase`的DSL。
- en: DSL for TestCase
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`TestCase` DSL'
- en: 'We''ll start by looking at the part of the DSL that makes it possible to write
    the test specification, that is, the part of the DSL shown here:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查看DSL中允许编写测试规范的部分，即DSL中显示的部分：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'From the last section, it should be clear that this is using an extension method
    `should` on `String` that''s invoked using infix notation. So, we''ll add an extension
    method to `String` to create `TestDescription` using the little DSL from before:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一节中，应该很清楚这是使用`String`上的后缀方法`should`，使用中缀表示法调用的。所以，我们将向`String`添加一个扩展方法，使用之前的小型DSL来创建`TestDescription`：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With this implicit value class in scope, we can create a `TestDescription`
    using the following syntax:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在作用域内有这个隐式值类的情况下，我们可以使用以下语法创建一个`TestDescription`：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This reduces our `TestCase` creation to the following.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这将我们的`TestCase`创建简化为以下内容。
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is slightly better, but far from ideal. Let''s continue. Now, let''s focus
    on the remaining part of the DSL, the part that makes it possible to write the
    actual test case. It''s the part of the DSL shown here:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这稍微好一些，但远非理想。让我们继续。现在，让我们专注于DSL的剩余部分，即允许编写实际测试用例的部分。这是DSL中显示的部分：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Again, in the previous section, we saw that we could write such expressions
    in Scala using infix notation and by-name parameters. Now, to allow the creation
    of `TestCase` instances using the DSL, we''ll have to add a method to `TestDescription`
    as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，在上一节中，我们看到了我们可以在Scala中使用中缀表示法和按名参数来编写这样的表达式。现在，为了允许使用DSL创建`TestCase`实例，我们必须向`TestDescription`添加一个方法，如下所示：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With this method, we can now write our test case using the following syntax:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个方法，我们现在可以使用以下语法来编写我们的测试用例：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: And, with that, we're done with creating our little DSL for writing test case
    specifications.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们就完成了创建我们的小型领域特定语言（DSL）来编写测试用例规范的过程。
- en: We're not trying to create a full-featured testing library here, but it would
    be fun to be able to run the tests, so let's have a look at how to implement a
    test runner.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里并不是试图创建一个功能齐全的测试库，但能够运行测试会很有趣，所以让我们看看如何实现测试运行器。
- en: As we've modeled our test cases using Scala classes, it's quite simple to create
    a test runner that runs the tests and prints a nice little report.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经使用Scala类来模拟测试用例，因此创建一个运行测试并打印出一份简洁报告的测试运行器相当简单。
- en: 'You''ve seen how to use some of Scala''s features to very easily write a DSL
    to create test cases. By using the flexible syntax for method invocation, by-name
    parameters, and extension methods (through Value classes), you''ve managed to
    create an internal DSL that makes it possible to convert this expression:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何使用Scala的一些特性来非常容易地编写一个用于创建测试用例的DSL。通过使用方法调用的灵活语法、按名参数和扩展方法（通过值类），你成功地创建了一个内部DSL，使得可以将以下表达式：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Into the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为以下：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Activity: Creating a DSL to Specify Assertions'
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动：创建一个用于指定断言的DSL
- en: 'Our DSL makes it possible to write `TestCase` instances easily. However, the
    assertions in our test cases don''t look very nice. Create a DSL to specify assertions.
    It should support the following syntax:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的DSL使得编写`TestCase`实例变得容易。然而，我们测试用例中的断言看起来并不美观。创建一个用于指定断言的DSL。它应该支持以下语法：
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Hint**:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**：'
- en: 'Start by modeling assertions using case classes:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过使用案例类来模拟断言：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can see the final result in the code for this chapter in `dsl/src/main/scala/com/example/Assertion.scala`
    and the usage in `dsl/src/main/scala/com/example/Assertion.scala/Main.scala.`
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本章的 `dsl/src/main/scala/com/example/Assertion.scala` 代码中看到最终结果，并在 `dsl/src/main/scala/com/example/Assertion.scala/Main.scala`
    中查看其用法。
- en: 'The full code should look like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码应如下所示：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Beyond This Book
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 除此之外
- en: This section will help you get a better overview of the Scala ecosystem and
    help guide your self-study after the book has ended, so you can continue to improve
    your Scala skills.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将帮助您更好地了解 Scala 生态系统，并在本书结束后指导您自学，以便您可以继续提高您的 Scala 技能。
- en: Various Scala Libraries
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 各种 Scala 库
- en: The purpose of this topic is to briefly introduce a couple of different Scala
    libraries for solving problems in different domains so that you can study the
    ones that are interesting to you after the book.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 本主题的目的是简要介绍几个不同的 Scala 库，用于解决不同领域的问题，以便您可以在本书之后研究那些对您感兴趣的内容。
- en: Akka
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Akka
- en: The first library we'll look at is one of the most popular libraries in the
    Scala ecosystem. It has been around for a long time—the first public release of
    the library was in 2010—and it's used in production by a large number of big organizations.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一个库是 Scala 生态系统中最受欢迎的库之一。它已经存在很长时间了——该库的第一个公开发布是在 2010 年——并且被许多大型组织在生产环境中使用。
- en: 'Its main abstractions are `Actor` and `Streams`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 它的主要抽象是 `Actor` 和 `Streams`：
- en: '`Actors` are a way to model concurrency without resorting to locks. You might
    have heard about them before if you''ve read about the programming language `Erlang`.
    An Actor is an entity that can receive and react to messages, spawn new `actors`,
    and send messages to other `actors`. Thus, you model your programs as a set of
    `actors` that communicate to each other by sending messages.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Actor` 是一种不依赖锁来模拟并发的途径。如果您阅读过关于编程语言 `Erlang` 的内容，您可能已经听说过它们。Actor 是一个可以接收并响应消息、生成新的
    `actors` 并向其他 `actors` 发送消息的实体。因此，您将程序建模为一组通过发送消息相互通信的 `actors`。'
- en: Note
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find more information about `Actors` here: [https://doc.akka.io/docs/akka/current/guide/actors-intro.html?language=scala](https://doc.akka.io/docs/akka/current/guide/actors-intro.html?language=scala)'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以在以下链接中找到有关 `Actors` 的更多信息：[https://doc.akka.io/docs/akka/current/guide/actors-intro.html?language=scala](https://doc.akka.io/docs/akka/current/guide/actors-intro.html?language=scala)
- en: If you have to deal with streaming data, you can use Akka `Streams` to model
    your programs as transformations over data flowing from sources into sinks.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您必须处理流式数据，可以使用 Akka `Streams` 将您的程序建模为从源到汇流的数据转换。
- en: Note
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can read more about `Streams` here: [https://doc.akka.io/docs/akka/current/stream/stream-introduction.html?language=scala](https://doc.akka.io/docs/akka/current/stream/stream-introduction.html?language=scala).'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以在以下链接中了解更多关于 `Streams` 的信息：[https://doc.akka.io/docs/akka/current/stream/stream-introduction.html?language=scala](https://doc.akka.io/docs/akka/current/stream/stream-introduction.html?language=scala)。
- en: If you want to build a distributed system in Scala, it is highly recommended
    to use Akka.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想在 Scala 中构建分布式系统，强烈建议使用 Akka。
- en: Note
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can read more about Akka on its website: [https://akka.io/](https://akka.io/).'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以在其网站上了解更多关于 Akka 的信息：[https://akka.io/](https://akka.io/)。
- en: Apache Spark
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Apache Spark
- en: Apache Spark is a library for processing large Scala datasets. Apache Spark
    was initially developed at UC Berkeley in 2009, and in 2013 it was donated to
    the Apache Software Foundation and is now a Top-Level Apache Project with more
    than 1,000 contributors.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Spark 是一个用于处理大型 Scala 数据集的库。Apache Spark 最初于 2009 年在加州大学伯克利分校开发，2013
    年捐赠给 Apache 软件基金会，现在是一个拥有超过 1000 位贡献者的顶级 Apache 项目。
- en: 'You can write Spark programs in Java, Scala, Python, and R. You can write your
    own custom data analytics programs using the Spark API, or you can use one of
    the high-level APIs: Spark SQL for SQL and structured data processing, MLlib for
    machine learning, GraphX for graph processing, and Spark Streaming.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 Java、Scala、Python 和 R 编写 Spark 程序。您可以使用 Spark API 编写自己的自定义数据分析程序，或者您可以使用高级
    API 之一：Spark SQL 用于 SQL 和结构化数据处理，MLlib 用于机器学习，GraphX 用于图处理，以及 Spark Streaming。
- en: If you're interested in big data processing, take a look at Spark.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对大数据处理感兴趣，请查看 Spark。
- en: Note
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can read more about Spark on its website: [https://spark.apache.org/](https://spark.apache.org/).'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在其网站上了解更多关于 Spark 的信息：[https://spark.apache.org/](https://spark.apache.org/)。
- en: Shapeless
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Shapeless
- en: Shapeless is a type class and dependent type-based generic programming library
    for Scala. It was initially written in 2011 by Miles Sabin and is now used by
    many companies to write type-safe code. It is also used internally by many libraries.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Shapeless是一个Scala的类型类和依赖类型基于的泛型编程库。它最初由Miles Sabin于2011年编写，现在被许多公司用来编写类型安全的代码。它也被许多库内部使用。
- en: One of the major features of Shapeless is that it enables automatic derivation
    of type classes.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Shapeless的一个主要特性是它使得自动推导类型类成为可能。
- en: 'Using Shapeless, you can get the compiler to type-check things that you might
    not have thought possible. Some examples are:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Shapeless，您可以让编译器检查那些您可能认为不可能检查的事情。一些例子包括：
- en: Heterogeneous lists, that is, lists where each element can be of different types
    and where the Scala compiler keeps track of the types
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异构列表，即每个元素可以是不同类型的列表，Scala编译器跟踪这些类型
- en: Have the compiler check that collections are of a given length
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让编译器检查集合的长度是否符合要求
- en: 'In this section, we''ve seen three different Scala libraries that can be used
    to solve problems in the following domains:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了三个不同的Scala库，这些库可以用于解决以下领域的问题：
- en: Distributed programming
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式编程
- en: Big data processing
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大数据处理
- en: Generic programming
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型编程
- en: Uncovered Language Features
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 揭示未覆盖的语言特性
- en: 'The purpose of this topic is to briefly introduce you to some of the language
    features that we haven''t covered, and show you where to go if you want to learn
    more about these topics. These features are:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 本主题的目的是简要向您介绍一些我们没有覆盖的语言特性，并告诉您如果想要了解更多关于这些主题的信息，应该去哪里。这些特性包括：
- en: Macros
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏
- en: Reflection
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射
- en: Macros
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 宏
- en: Macros are a programming language feature that makes it possible to write functions
    that take the AST of their arguments as input and produce a new AST, effectively
    allowing you to write programs that generate other programs.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 宏是一种编程语言特性，它使得编写以其参数的AST（抽象语法树）作为输入并产生新AST的函数成为可能，从而有效地允许您编写生成其他程序的程序。
- en: Macros come in many shapes and sizes. In this section, we'll have a look at
    how to use macros in Scala. Experimental support for Scala macros was shipped
    with Scala 2.10, and, since then, they have been improved with every release.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 宏有多种形状和大小。在本节中，我们将探讨如何在Scala中使用宏。Scala 2.10中包含了Scala宏的实验性支持，并且从那时起，它们在每次发布中都得到了改进。
- en: Note
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the official documentation for macros on the Scala documentation
    website here: [https://docs.scala-lang.org/overviews/macros/overview.html.](https://docs.scala-lang.org/overviews/macros/overview.html.)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Scala文档网站上找到关于宏的官方文档，链接如下：[https://docs.scala-lang.org/overviews/macros/overview.html.](https://docs.scala-lang.org/overviews/macros/overview.html.)
- en: Def Macros
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义宏
- en: 'Def macros are macros that are defined as Scala functions which reference a
    macro implementation. Let''s have a look at a very simple macro that takes a `String`
    and returns an uppercase version of that string:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 定义宏是定义为Scala函数的宏，这些函数引用宏实现。让我们看看一个非常简单的宏，它接受一个`String`并返回该字符串的大写版本：
- en: '[PRE33]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `uppercase` method is how the macro is exposed to the users of the macro.
    The actual macro implementation is `uppercaseImpl`, which has two parameter lists.
    The first parameter contains a single argument, the `Context`, which contains
    information collected by the compiler at the call site of the macro. The second
    parameter contains the Scala abstract syntax trees of the expression of type `String`
    that the macro was invoked with. Let''s see how to invoke this macro:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`uppercase`方法是宏向宏的用户公开的方式。实际的宏实现是`uppercaseImpl`，它有两个参数列表。第一个参数包含一个参数，即`Context`，它包含编译器在宏调用点的收集信息。第二个参数包含宏被调用时使用的类型为`String`的表达式的Scala抽象语法树。让我们看看如何调用这个宏：'
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This looks very much like a normal Scala method invocation; however, the uppercasing
    of the argument happens at compile time.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来非常像正常的Scala方法调用；然而，参数的大写操作是在编译时发生的。
- en: Note that the macro as implemented here only works with `String` literals; if
    you invoke it with anything else, you'll crash the compiler.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里实现的宏只与`String`字面量一起工作；如果您用其他任何东西调用它，您将使编译器崩溃。
- en: Implicit Macros
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隐式宏
- en: 'Implicit macros make it possible to reference a macro in the implementation
    of an implicit method. One use case of this is to write macros that can generate
    an instance of a given type class, given any type `T`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式宏使得在隐式方法的实现中引用宏成为可能。这种用法的一个例子是编写可以生成给定类型类实例的宏，给定任何类型`T`：
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, instead of writing individual type class instances for all of your types,
    like the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，而不是为所有类型编写单独的类型类实例，如下所示：
- en: '[PRE36]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You could instead define an implicit macro that can generate an instance of
    the type class for any given type `T`, as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义一个隐式宏，它可以生成任何给定类型`T`的类型类实例，如下所示：
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Quasiquotes
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Quasiquotes
- en: 'It is possible for you to use Scala''s powerful String Interpolation feature
    to make it to write ASTs inside of Strings, so you don''t have to construct the
    ASTs by hand. That is, you can write the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用Scala强大的字符串插值功能，在字符串内部编写AST，这样你就不必手动构建AST。也就是说，你可以编写以下内容：
- en: '[PRE38]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Instead of writing the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是编写以下内容：
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Reflection
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反射
- en: You have very likely used reflection in other programming languages, such as
    Java or Python. Reflection makes it possible for a program to inspect and sometimes
    modify itself. You can think of macros as compile-time reflection and of the reflections
    we'll look at now as runtime reflection.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你很可能在其他编程语言中使用了反射，例如Java或Python。反射使得程序能够检查并有时修改自身。你可以将宏视为编译时反射，而我们将要查看的反射则是运行时反射。
- en: 'With runtime reflection, you can:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用运行时反射，你可以：
- en: Inspect the types of objects
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查对象的类型
- en: Instantiate new objects
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例化新对象
- en: Access or invoke members of an object
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问或调用对象的成员
- en: 'Let''s have a look at an example of how to inspect types at runtime:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何检查运行时类型的示例：
- en: '[PRE40]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This example uses `scala.reflect.runtime.universe` to implement a method that,
    for a given object of type `T,` will get the `TypeTag` for that type. Given the
    `TypeTag,` we can access `Type` through `tpe` and then get the list of the members
    of the type through `decls`. The example then filters out any member whose name
    is shorter than five ``characters and prints their `name` and `type`.``
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用`scala.reflect.runtime.universe`实现了一个方法，对于给定类型`T`的对象，该方法将获取该类型的`TypeTag`。有了`TypeTag`，我们可以通过`tpe`访问`Type`，然后通过`decls`获取类型的成员列表。示例随后过滤掉任何名称少于五个字符的成员，并打印它们的`name`和`type`。
- en: '`Note`'
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`注意`'
- en: '`Reflection can in some cases incur a non-negligible runtime overhead. If you''re
    using it in performance-sensitive places, make sure to benchmark the results.`'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`反射在某些情况下可能会产生不可忽视的运行时开销。如果你在性能敏感的地方使用它，请确保对结果进行基准测试。`'
- en: '`In this subsection, we''ve briefly covered two interesting Scala language
    features and provided multiple links for further study of these features so that
    you can improve your Scala skills after this book.`'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`在本小节中，我们简要介绍了两个有趣的Scala语言特性，并提供了多个链接，以便你在本书之后进一步学习这些特性，从而提高你的Scala技能。`'
- en: '`Resources to Keep You Updated`'
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`资源更新`'
- en: '`In this subsection, we''ll have a look at how you can keep up to date with
    the development of the Scala programming language, as well as its ecosystem.`'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`在本小节中，我们将探讨如何保持对Scala编程语言及其生态系统发展的最新了解。`'
- en: '`Scala Improvement Process`'
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Scala改进过程`'
- en: '`The Scala Improvement Process (SIP) and Scala Platform Process (SPP) are how
    changes are made to the Scala Programming Language and The Scala Standard Library,
    respectively. If you want to make a change to either, you can make a proposal
    for the change, which will then be reviewed and potentially accepted.`'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scala改进过程（SIP）和Scala平台过程（SPP）分别是Scala编程语言和Scala标准库变更的方式。如果你想对其中任何一个进行更改，你可以提出一个更改提案，该提案将被审查并可能被接受。`'
- en: '`Note`'
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`注意`'
- en: '`You can find a list of all the current SIPs here: [https://docs.scala-lang.org/sips/all.html](https://docs.scala-lang.org/sips/all.html).`'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`你可以在以下位置找到所有当前SIPs的列表：[https://docs.scala-lang.org/sips/all.html](https://docs.scala-lang.org/sips/all.html)。`'
- en: '`Scala Times`'
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Scala Times`'
- en: '`The Scala Times is a weekly newsletter that features interesting blog posts
    about Scala and gives a short recap of the various Scala libraries that have been
    released in the previous week.`'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scala Times是一份每周通讯，其中包含关于Scala的有趣博客文章，并对上周发布的各种Scala库进行了简要回顾。`'
- en: '`Note`'
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`注意`'
- en: '`You can read more about it and subscribe to the newsletter here: [http://scalatimes.com/](http://scalatimes.com/)`'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`你可以在这里了解更多信息并订阅通讯：[http://scalatimes.com/](http://scalatimes.com/)`'
- en: '``# Summary    In this chapter, we covered how Scala makes it possible to write
    powerful Domain Specific Languages (DSLs) by providing a few interesting language
    features. We had a brief look at what DSLs are in general terms. We have also
    covered a DSL that you''ll very likely be using if you''re going to work with
    Scala professionally. Finally, we have implemented our own DSL.    We now come
    to the end of this book. In this book, we covered all the professional concepts
    of the Scala language, from setting up the development environment to writing
    your own custom DSLs. We covered the object-oriented and functional programming
    aspects of the Scala language. We also covered some useful libraries that are
    used in Scala, such as `Cats` and `Doobie`. Finally, we covered the additional
    resources and tools that will help you to stay up to date in the industry.``'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '``# 摘要    在本章中，我们介绍了Scala如何通过提供一些有趣的语言特性，使得编写强大的领域特定语言（DSLs）成为可能。我们简要地看了看在一般意义上DSL是什么。我们还介绍了一个你如果打算在Scala专业领域工作，很可能要使用的DSL。最后，我们实现了我们自己的DSL。    现在我们来到了这本书的结尾。在这本书中，我们涵盖了Scala语言的所有专业概念，从设置开发环境到编写你自己的自定义DSLs。我们介绍了Scala语言中的面向对象和函数式编程方面。我们还介绍了一些在Scala中使用的有用库，例如`Cats`和`Doobie`。最后，我们介绍了可以帮助你保持行业前沿的额外资源和工具。``'
