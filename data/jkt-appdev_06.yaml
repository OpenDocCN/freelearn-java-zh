- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Jakarta Faces
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jakarta Faces
- en: In this chapter, we will cover `web.xml` has been optional since Java EE 6 means
    that in many cases we can write complete web applications without having to write
    a single line of XML.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍自Java EE 6以来`web.xml`已变为可选，这意味着在许多情况下，我们可以不写一行XML代码就编写完整的Web应用程序。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Introduction to Jakarta Faces
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jakarta Faces简介
- en: Developing our first Faces application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发我们的第一个Faces应用程序
- en: Custom data validation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义数据验证
- en: Customizing default messages
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义默认消息
- en: Note
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Example source code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch06_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch06_src).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例源代码可以在GitHub上找到，地址为[https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch06_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch06_src)。
- en: Introduction to Jakarta Faces
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jakarta Faces简介
- en: In this section, we will give a general overview of what developing web applications
    with Jakarta Faces entails, providing some background information necessary before
    digging into the nitty gritty of Jakarta Faces.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将概述使用Jakarta Faces开发Web应用程序涉及的内容，并提供在深入研究Jakarta Faces的细节之前必要的背景信息。
- en: Facelets
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Facelets
- en: '**Facelets** is the default Jakarta Faces view technology. Facelets are written
    using standard **Extensible Hypertext Markup Language** (**XHTML**), using Jakarta
    Faces-specific XML namespaces that provide Jakarta Faces-specific tags we can
    use to develop the user interface of our web applications.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**Facelets**是Jakarta Faces的默认视图技术。Facelets使用标准的**可扩展超文本标记语言**（**XHTML**）编写，使用Jakarta
    Faces特定的XML命名空间，这些命名空间提供了我们可以用来开发Web应用程序用户界面的Jakarta Faces特定标签。'
- en: Optional faces-config.xml
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选的`faces-config.xml`
- en: In most cases, configuring a Jakarta Faces application is not necessary, as
    it follows a convention over configuration approach.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，配置Jakarta Faces应用程序是不必要的，因为它遵循约定优于配置的方法。
- en: For some specific cases, when overriding Jakarta Faces’ default error messages
    for example, we still need to configure Jakarta Faces via a `faces-config.xml`
    configuration file.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些特定情况，例如覆盖Jakarta Faces的默认错误消息时，我们仍然需要通过`faces-config.xml`配置文件来配置Jakarta
    Faces。
- en: Standard resource locations
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准资源位置
- en: '**Resources** are artifacts a page or Jakarta Faces component needs to render
    properly. Resource examples are CSS stylesheets, JavaScript files, and images.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**资源**是页面或Jakarta Faces组件需要正确渲染的工件。资源示例包括CSS样式表、JavaScript文件和图像。'
- en: When working with Jakarta Faces, resources can be placed in a subdirectory in
    a folder called `resources` either at the root of the WAR file or in its `META-INF`
    directory. By convention, Jakarta Faces components know they can retrieve resources
    from one of these two locations.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Jakarta Faces时，资源可以放置在名为`resources`的文件夹中的子目录中，这个文件夹位于WAR文件的根目录或其`META-INF`目录中。按照惯例，Jakarta
    Faces组件知道它们可以从这两个位置之一检索资源。
- en: In order to avoid cluttering the resources directory, resources are typically
    placed in a subdirectory. This subdirectory is referred to from the `library`
    attribute of Faces components.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免资源目录杂乱，资源通常放置在子目录中。这个子目录通过Faces组件的`library`属性进行引用。
- en: For example, we could place a CSS stylesheet called `styles.css` in `/resources/css/styles.css`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在`/resources/css/styles.css`中放置一个名为`styles.css`的CSS样式表。
- en: 'In our Faces pages, we could retrieve this CSS file using the `<h:outputStylesheet>`
    tag, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Faces页面中，我们可以使用以下`<h:outputStylesheet>`标签检索此CSS文件：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The value of the `library` attribute must match the subdirectory where our stylesheet
    is located.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`library`属性的值必须与我们的样式表所在的子目录相匹配。'
- en: 'Similarly, we could have a JavaScript file at `/resources/scripts/somescript.js`
    and an image at `/resources/images/logo.png`, and we could access these resources
    as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以在`/resources/scripts/somescript.js`中有一个JavaScript文件，以及一个图像在`/resources/images/logo.png`中，我们可以按照以下方式访问这些资源：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that in each case, the value of the `library` attribute matches the corresponding
    subdirectory name in the `resources` directory, and the value of the name attribute
    matches the resource’s filename.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在每种情况下，`library`属性的值都与`resources`目录中相应的子目录名称相匹配，而`name`属性的值与资源的文件名相匹配。
- en: Developing our first Faces application
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发我们的第一个Faces应用程序
- en: To illustrate basic Jakarta Faces concepts, we will develop a simple application
    consisting of two Facelet pages and a single **Contexts and Dependency Injection**
    (**CDI**) named bean.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明基本的 Jakarta Faces 概念，我们将开发一个由两个 Facelet 页面和一个名为 **Contexts and Dependency
    Injection** (**CDI**) 的命名 bean 组成的简单应用程序。
- en: Facelets
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Facelets
- en: 'As we mentioned in this chapter’s introduction, the default view technology
    for Jakarta Faces is called Facelets. Facelets need to be written using standard
    XML. The most popular way of developing Facelet pages is to use XHTML in conjunction
    with Jakarta Faces-specific XML namespaces. The following example shows what a
    typical Facelet page looks like:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章引言中提到的，Jakarta Faces 的默认视图技术被称为 Facelets。Facelets 需要使用标准的 XML 编写。开发 Facelet
    页面最流行的方式是结合使用 XHTML 和 Jakarta Faces 特定的 XML 命名空间。以下示例展示了典型的 Facelet 页面看起来是什么样子：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Figure 6**.1* illustrates how our Facelets page renders in the browser after
    deploying our code and entering some data.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6**.1* 展示了在部署我们的代码并输入一些数据后，我们的 Facelets 页面如何在浏览器中渲染。'
- en: '![Figure 6.1 – Rendered Facelets page](img/B21231_6_01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 渲染后的 Facelets 页面](img/B21231_6_01.jpg)'
- en: Figure 6.1 – Rendered Facelets page
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 渲染后的 Facelets 页面
- en: Pretty much any Facelet page will include the two namespaces illustrated in
    the example. The first namespace (`) is for tags that render HTML components.
    By convention, the prefix **h**` **(for HTML) is used when using this tag library.**
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何 Facelet 页面都会包含示例中展示的两个命名空间。第一个命名空间（`）用于渲染 HTML 组件的标签。按照惯例，当使用这个标签库时，前缀
    **h**` **(代表 HTML) 被使用。**
- en: '**The second namespace (**`) is the core Faces tag library. By convention,
    the prefix **f**` **(for Faces) is used when using this tag library.**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**第二个命名空间（`）是核心的 Faces 标签库。按照惯例，当使用这个标签库时，前缀 **f**` **(代表 Faces) 被使用。**'
- en: '**The first Faces-specific tags we see in the preceding example are the `<h:head>`
    and the `<h:body>` tags. These tags are analogous to the standard HTML `<head>`
    and `<body>` tags and are rendered as such when the page is displayed in the browser.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**在前面的示例中，我们首先看到的 Faces 特定标签是 `<h:head>` 和 `<h:body>` 标签。这些标签类似于标准的 HTML `<head>`
    和 `<body>` 标签，当页面在浏览器中显示时，它们会被渲染成这样。'
- en: The `<h:outputStylesheet>` tag is used to load a CSS stylesheet from a well-known
    location (Jakarta Faces standardizes the locations of resources, such as CSS stylesheets
    and javascript files, as previously discussed in this chapter). The value of the
    `library` attribute must correspond to the directory where the CSS file resides
    (this directory must be in the `resources` directory). The `name` attribute must
    correspond to the name of the CSS stylesheet we wish to load.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`<h:outputStylesheet>` 标签用于从一个已知位置（Jakarta Faces 标准化了资源的位置，如 CSS 样式表和 JavaScript
    文件，如本章之前所述）加载 CSS 样式表。`library` 属性的值必须对应于 CSS 文件所在的目录（这个目录必须在 `resources` 目录中）。`name`
    属性必须对应于我们希望加载的 CSS 样式表的名称。'
- en: The next tag we see is the `<h:form>` tag. This tag generates an HTML form when
    the page is rendered. As can be seen in the example, unlike regular HTML, there
    is no need to specify an `action` or a `method` attribute for this tag. As a matter
    of fact, there is no `action` attribute or `method` attribute for this tag. The
    `action` attribute for the rendered HTML form will be generated automatically,
    and the `method` attribute will always be `"post"`. The `id` attribute of `<h:form>`
    is optional; however, it is a good idea to always add it since it makes debugging
    Faces applications easier.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们看到的是 `<h:form>` 标签。当页面渲染时，这个标签会生成一个 HTML 表单。如示例所示，与常规 HTML 不同，这个标签不需要指定
    `action` 或 `method` 属性。实际上，这个标签没有 `action` 属性或 `method` 属性。渲染的 HTML 表单的 `action`
    属性将自动生成，而 `method` 属性始终是 `"post"`。`<h:form>` 的 `id` 属性是可选的；然而，始终添加它是一个好主意，因为它使得调试
    Faces 应用程序变得更加容易。
- en: The following tag we see is the `<h:messages>` tag. As its name implies, this
    tag is used to display any messages. As we will see shortly, Faces can automatically
    generate validation messages; they will be displayed inside this tag. Additionally,
    arbitrary messages can be added programmatically via the `addMessage()` method
    defined in `jakarta.faces.context.FacesContext`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来看到的标签是 `<h:messages>` 标签。正如其名称所暗示的，这个标签用于显示任何消息。正如我们很快就会看到的，Faces 可以自动生成验证消息；它们将显示在这个标签内。此外，可以通过
    `jakarta.faces.context.FacesContext` 中定义的 `addMessage()` 方法程序化地添加任意消息。
- en: The next Jakarta Faces tag we see is `<h:panelGrid>`. This tag is roughly equivalent
    to an HTML table, but it works a bit differently. Instead of declaring rows (`<tr>`)
    and cells (`<td>`), the `<h:panelGrid>` tag has a `columns` attribute. The value
    of this attribute indicates the number of columns in the table rendered by this
    tag. As we place components inside this tag, they will be placed in a row until
    the number of columns defined in the `columns` attribute is reached, then the
    next component will be placed in the next row. In the example, the value of the
    `columns` attribute is `2`, therefore the first two tags will be placed in the
    first row, the next two will be placed in the second row, and so forth.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来看到的下一个Jakarta Faces标签是`<h:panelGrid>`。这个标签大致相当于HTML表格，但它的工作方式略有不同。`<h:panelGrid>`标签有一个`columns`属性，而不是声明行（`<tr>`）和单元格（`<td>`）。此属性的值表示由此标签渲染的表格中的列数。当我们在这个标签内放置组件时，它们将放置在一行中，直到达到`columns`属性中定义的列数，然后下一个组件将被放置在下一行中。在示例中，`columns`属性的值是`2`，因此前两个标签将放置在第一行，接下来的两个将放置在第二行，依此类推。
- en: Note
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Using HTML tables for page layout was a popular practice in the early days of
    web development. This practice fell out of favor with the advent of CSS. Most
    modern Facelets pages use CSS for layout, but we thought it was worth pointing
    out the layout capabilities provided by Jakarta Faces.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web开发的早期，使用HTML表格进行页面布局是一种流行的做法。随着CSS的出现，这种做法逐渐不再受欢迎。大多数现代Facelets页面使用CSS进行布局，但我们认为指出Jakarta
    Faces提供的布局功能是值得的。
- en: Another interesting attribute of `<h:panelGrid>` is the `columnClasses` attribute.
    This attribute assigns a CSS class to each column in the rendered table. In the
    example, two CSS classes (separated by a comma) are used as the value for this
    attribute. This has the effect of assigning the first CSS class to the first column
    and the second one to the second column. Had there been three or more columns,
    the third one would have gotten the first CSS class, the fourth one the second
    one, and so on, alternating between the first one and the second one.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`<h:panelGrid>`的另一个有趣属性是`columnClasses`属性。此属性将CSS类分配给渲染的表格中的每一列。在示例中，使用了两个CSS类（由逗号分隔）作为此属性的值。这会产生将第一个CSS类分配给第一列，第二个分配给第二列的效果。如果有三列或更多列，第三列将获得第一个CSS类，第四列获得第二个，依此类推，交替进行。'
- en: Viewing generated HTML markup
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 查看生成的HTML标记
- en: We can view the generated HTML markup of our Facelets page by right-clicking
    on the browser window and selecting **View** **Page Source**.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在浏览器窗口上右键单击并选择**查看** **页面源代码**来查看我们Facelets页面的生成HTML标记。
- en: 'To clarify how this works, the next code snippet illustrates a portion of the
    source of the HTML markup generated by the preceding page:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了阐明其工作原理，下面的代码片段展示了前一个页面生成的HTML标记源代码的一部分：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice how each `<td>` tag has an alternating CSS tag of `"rightAlign"` or `"leftAlign"`,
    we achieved this by assigning the value `"rightAlign,leftAlign"` to the `columnClasses`
    attribute of `<h:panelGrid>`. We should note that the CSS classes we are using
    in our example are defined in the CSS stylesheet we loaded via `<h:outputStylesheet>`,
    which we discussed earlier. The values of all the `name` and `id` attributes of
    the generated HTML tags are a combination of the ID we gave to the `<h:form>`
    component, plus the ID of each individual component. Notice that we didn’t assign
    an ID to the `<h:commandButton>` component near the end of the page, so the Faces
    runtime assigned one automatically and used it to populate the `name` attribute
    of the generated submit button.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到每个`<td>`标签都有一个交替的CSS标签`"rightAlign"`或`"leftAlign"`，我们通过将值`"rightAlign,leftAlign"`分配给`<h:panelGrid>`的`columnClasses`属性来实现这一点。我们应该注意，我们示例中使用的CSS类是在我们之前讨论的通过`<h:outputStylesheet>`加载的CSS样式表中定义的。生成的HTML标签的所有`name`和`id`属性的值是赋予`<h:form>`组件的ID和每个单独组件的ID的组合。注意，我们在页面末尾附近的`<h:commandButton>`组件没有分配ID，因此Faces运行时自动分配了一个ID，并使用它来填充生成的提交按钮的`name`属性。
- en: At this point in the example, we start adding components inside `<h:panelGrid>`.
    These components will be rendered inside the table rendered by `<h:panelGrid>`.
    As we mentioned before, the number of columns in the rendered table is defined
    by the `columns` attribute of `<h:panelGrid>`. Therefore, we don’t need to worry
    about columns (or rows) we just start adding components and they will be placed
    in the right place.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例的这个阶段，我们开始在 `<h:panelGrid>` 内部添加组件。这些组件将被渲染在由 `<h:panelGrid>` 渲染的表格内。正如我们之前提到的，渲染表格的列数由
    `<h:panelGrid>` 的 `columns` 属性定义。因此，我们不需要担心列（或行），我们只需开始添加组件，它们将被放置在正确的位置。
- en: The next tag we see is the `<h:outputLabel>` tag. This tag is rendered as an
    HTML `label` element. Labels are associated with other components via the `for`
    attribute, whose value must match the ID of the component that the label is for.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来看到的标签是 `<h:outputLabel>` 标签。此标签被渲染为 HTML `label` 元素。标签通过 `for` 属性与其他组件相关联，其值必须与标签所针对的组件的
    ID 匹配。
- en: Next, we see the `<h:inputText>` tag. This tag generates a text field on the
    rendered page; its `label` attribute is used for any validation messages. It lets
    the user know what field the message refers to.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到 `<h:inputText>` 标签。此标签在渲染的页面上生成一个文本字段；其 `label` 属性用于任何验证消息。它让用户知道信息所指的字段。
- en: Note
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Although it is not required for the value of the `label` attribute of `<h:inputText>`
    to match the label displayed on the page, it is highly recommended. If there is
    an error, this will let the user know exactly what field the error message is
    referring to.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `<h:inputText>` 标签的 `label` 属性值与页面显示的标签匹配不是必需的，但强烈建议这样做。如果出现错误，这将使用户确切知道错误信息所指的具体字段。
- en: Of particular interest is the tag’s `value` attribute. What we see as the value
    for this attribute is a `firstName` in a named bean called `customer`. When a
    user enters a value for this text field and submits the form, the corresponding
    property in the named bean is updated with this value. The tag’s `required` attribute
    is optional and valid values for it are `true` and `false`. If this attribute
    is set to `true`, the container will not let the user submit the form until the
    user enters some data for the text field. If the user attempts to submit the form
    without entering a required value, the page will be reloaded and an error message
    will be displayed inside the `<h:messages>` tag, as illustrated in *Figure 6**.2*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 特别值得注意的是该标签的 `value` 属性。我们看到的这个属性的值是在名为 `customer` 的命名 Bean 中的 `firstName`。当用户为此文本字段输入一个值并提交表单时，命名
    Bean 中相应的属性将使用此值进行更新。该标签的 `required` 属性是可选的，其有效值是 `true` 和 `false`。如果将此属性设置为 `true`，容器将不允许用户在为文本字段输入一些数据之前提交表单。如果用户尝试不输入必需的值提交表单，页面将被重新加载，并在
    `<h:messages>` 标签内显示错误信息，如图 *图 6**.2* 所示。
- en: '![Figure 6.2 – Required field data validation](img/B21231_6_02.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – 必填字段数据验证](img/B21231_6_02.jpg)'
- en: Figure 6.2 – Required field data validation
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 必填字段数据验证
- en: '*Figure 6**.2* illustrates the default error message shown when the user attempts
    to save the form in the example without entering a value for the customer’s first
    name. The first part of the message (`label` attribute of the corresponding `<h:inputTextField>`
    tag. The text of the message can be customized, as well as its style (font, color,
    etc.). We will cover how to do this later in this chapter.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6**.2* 展示了当用户尝试在示例中保存表单而没有输入客户姓氏的值时显示的默认错误信息。信息的开头部分（对应 `<h:inputTextField>`
    标签的 `label` 属性）。信息的文本可以自定义，以及其样式（字体、颜色等）。我们将在本章后面介绍如何做到这一点。'
- en: Project stages
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目阶段
- en: Having an `<h:messages>` tag on every Jakarta Faces page is a good idea. Without
    it, the user might not see validation messages and will have no idea why the form
    submission is not going through. By default, Jakarta Faces validation messages
    do not generate any output in the application server log. A common mistake new
    Jakarta Faces developers make is failing to add an `<h:messages>` tag to their
    pages. Without it, if validation fails, then navigation seems to fail for no reason
    (the same page is rendered if navigation fails, and without an `<h:messages>`
    tag, no error messages are displayed in the browser).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个Jakarta Faces页面上都有一个`<h:messages>`标签是个好主意。如果没有它，用户可能看不到验证消息，并且不知道为什么表单提交没有成功。默认情况下，Jakarta
    Faces验证消息不会在应用程序服务器日志中生成任何输出。新Jakarta Faces开发者常犯的一个错误是未能将`<h:messages>`标签添加到他们的页面上。如果没有它，如果验证失败，则导航似乎没有原因失败（如果导航失败，则渲染相同的页面，如果没有`<h:messages>`标签，浏览器中不会显示错误消息）。
- en: To avoid this situation, we can take advantage of Jakarta Faces **project stages**.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，我们可以利用Jakarta Faces的**项目阶段**。
- en: 'The following project stages are defined in Jakarta Faces:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jakarta Faces中定义了以下项目阶段：
- en: Production
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产
- en: Development
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发
- en: UnitTest
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: SystemTest
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统测试
- en: We can define the project stage as an initialization parameter to the Faces
    servlet in `web.xml` or as a custom `web.xml` are needed between environments.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将项目阶段定义为`web.xml`中Faces servlet的初始化参数，或者作为自定义`web.xml`在环境之间需要。
- en: How you set up a custom JNDI resource is dependent on your application server.
    Consult your application server documentation for details. For example, if we
    are using `GlassFish` to deploy our application, we can set up a custom JNDI resource
    by logging in to the web console, navigating to **JNDI** | **Custom Resources**,
    and then clicking the **New...** button, which allows us to add our custom JNDI
    resource, as illustrated in *Figure 6**.3*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如何设置自定义JNDI资源取决于你的应用程序服务器。请查阅你的应用程序服务器文档以获取详细信息。例如，如果我们使用`GlassFish`来部署我们的应用程序，我们可以通过登录到Web控制台，导航到**JNDI**
    | **自定义资源**，然后点击**新建...**按钮来设置自定义JNDI资源，如图*图6**.3*所示。
- en: '![Figure 6.3 – Defining Jakarta Faces project stage in GlassFish as a JNDI
    resource](img/B21231_6_03.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – 将GlassFish中的Jakarta Faces项目阶段定义为JNDI资源](img/B21231_6_03.jpg)'
- en: Figure 6.3 – Defining Jakarta Faces project stage in GlassFish as a JNDI resource
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 将GlassFish中的Jakarta Faces项目阶段定义为JNDI资源
- en: 'To define the Jakarta Faces project stage, we need to enter the following information:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义Jakarta Faces项目阶段，我们需要输入以下信息：
- en: '| **JNDI Name** | `jakarta.faces.PROJECT_STAGE` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| **JNDI名称** | `jakarta.faces.PROJECT_STAGE` |'
- en: '| **Resource Type** | `java.lang.String` |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| **资源类型** | `java.lang.String` |'
- en: Table 6.1 – Setting the Jakarta Faces project stage in GlassFish
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.1 – 在GlassFish中设置Jakarta Faces项目阶段
- en: 'After entering the two preceding values, the **Factory Class** field will be
    automatically populated with the following value:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 输入前两个值后，**工厂类**字段将自动填充以下值：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After entering the values, we need to add a new property with a name of `value`
    and a value corresponding to the project stage we wish to use (**Development**,
    our example).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 输入值后，我们需要添加一个名为`value`的新属性，其值对应我们希望使用的项目阶段（**开发**，本例中）。
- en: Once we add our custom JNDI resource, we need to update our `web.xml` configuration
    file to read it, this step is the same across Jakarta EE implementations.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们添加了自定义的JNDI资源，我们需要更新我们的`web.xml`配置文件以读取它，这一步骤在Jakarta EE实现中是相同的。
- en: 'The following example `web.xml` configuration file illustrates how to do the
    Jakarta Faces project stage so that our application can use it successfully:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例`web.xml`配置文件说明了如何设置Jakarta Faces项目阶段，以便我们的应用程序可以成功使用它：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `<resource-ref>` tag in `web.xml` allows us to access JNDI resources defined
    in our application server. In our case, we want to access the project stage of
    our Faces application.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`web.xml`中的`<resource-ref>`标签允许我们访问在应用程序服务器中定义的JNDI资源。在我们的情况下，我们想要访问我们的Faces应用程序的项目阶段。'
- en: '`<res-ref-name>` gives our JNDI resource a name our code can use to look up
    our JNDI resource. Our Jakarta Faces implementation will look for a JNDI resource
    named `faces/ProjectStage`, and, if one is found, will use it to determine our
    project stage.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`<res-ref-name>`为我们JNDI资源提供了一个名称，我们的代码可以使用它来查找我们的JNDI资源。我们的Jakarta Faces实现将寻找一个名为`faces/ProjectStage`的JNDI资源，如果找到了，就会使用它来确定我们的项目阶段。'
- en: '`<res-type>` allows us to specify the type of the resource we are looking for,
    as arbitrary Java objects can be looked up via JNDI. When setting the Jakarta
    Faces project stage, the value of this tag must always be `java.lang.String`.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`<res-type>` 允许我们指定我们正在寻找的资源类型，因为可以通过 JNDI 查询任意 Java 对象。当设置 Jakarta Faces 项目阶段时，此标签的值必须始终为
    `java.lang.String`。'
- en: We specify the name of the resource in the application server JNDI tree via
    the `<mapped-name>` tag. By convention, this value must always be `jakarta.faces.PROJECT_STAGE`
    when setting up the Jakarta Faces project stage via JNDI.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 `<mapped-name>` 标签指定应用程序服务器 JNDI 树中的资源名称。按照惯例，当通过 JNDI 设置 Jakarta Faces
    项目阶段时，此值必须始终为 `jakarta.faces.PROJECT_STAGE`。
- en: 'Setting the project stage allows us to perform some logic only if we are running
    in a specific stage. For instance, in one of our named beans, we could have code
    that looks like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 设置项目阶段允许我们在特定阶段运行时执行一些逻辑。例如，在我们的一个命名 Bean 中，我们可能有如下代码：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we can see, project stages allow us to modify our code’s behavior for different
    environments. More importantly, setting the project stage allows Jakarta Faces
    to behave differently based on the project stage setting. In this context, setting
    the project stage to development results in additional debugging information to
    be displayed on the rendered page. Therefore, if we forget to add an `<h:messages>`
    tag to our page; our project stage is Development, and validation fails, a validation
    error will be displayed on the page even if we omit the `<h:messages>` component.
    This is illustrated in *Figure 6**.4*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，项目阶段允许我们根据不同的环境修改代码的行为。更重要的是，设置项目阶段允许 Jakarta Faces 根据项目阶段设置表现出不同的行为。在这种情况下，将项目阶段设置为开发会导致在渲染的页面上显示额外的调试信息。因此，如果我们忘记在我们的页面上添加
    `<h:messages>` 标签；我们的项目阶段是开发，并且验证失败，即使我们省略了 `<h:messages>` 组件，页面上也会显示验证错误。这如图
    *图 6**.4* 所示。
- en: "![Figure  \uFEFF\uFEFF6.4\uFEFF – Debugging information displayed when the\
    \ project stage is in Development](img/B21231_6_04.jpg)"
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – 当项目阶段处于开发状态时显示的调试信息](img/B21231_6_04.jpg)'
- en: Figure 6.4 – Debugging information displayed when the project stage is in Development
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 当项目阶段处于开发状态时显示的调试信息
- en: In the default Production stage, this error message is not displayed on the
    page, leaving us confused as to why our page navigation doesn’t seem to be working.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认的生产阶段，此错误消息不会在页面上显示，这让我们困惑，为什么我们的页面导航似乎不起作用。
- en: Validation
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证
- en: Notice that each `<h:inputField>` tag has a nested `<f:validateLength>` tag.
    As its name implies, this tag validates that the entered value for the text field
    is between a minimum and maximum length. Minimum and maximum values are defined
    by the tag’s `minimum` and `maximum` attributes. `<f:validateLength>` is one of
    the standard validators included with Jakarta Faces. Just like with the `required`
    attribute of `<h:inputText>`, Jakarta Faces will automatically display a default
    error message when a user attempts to submit a form with a value that does not
    validate, as illustrated in *Figure 6**.5*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到每个 `<h:inputField>` 标签都有一个嵌套的 `<f:validateLength>` 标签。正如其名称所暗示的，此标签验证输入文本字段的值是否在最小和最大长度之间。最小和最大值由标签的
    `minimum` 和 `maximum` 属性定义。`<f:validateLength>` 是 Jakarta Faces 包含的标准验证器之一。就像
    `<h:inputText>` 的 `required` 属性一样，当用户尝试提交一个包含无效值的表单时，Jakarta Faces 将自动显示默认错误消息，如图
    *图 6**.5* 所示。
- en: "![Figure \uFEFF\uFEFF6.5 – Length validation](img/B21231_6_05.jpg)"
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 – 长度验证](img/B21231_6_05.jpg)'
- en: Figure 6.5 – Length validation
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – 长度验证
- en: The default message text and CSS style for any Jakarta Faces validation message
    can be overridden; we will cover how to do this later in this chapter.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 可以覆盖任何 Jakarta Faces 验证消息的默认文本和 CSS 样式；我们将在本章后面介绍如何做到这一点。
- en: 'In addition to `<f:validateLength>`, Jakarta Faces includes other standard
    validators, which are listed in the following table:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `<f:validateLength>` 之外，Jakarta Faces 还包括其他标准验证器，这些验证器列在以下表中：
- en: '| **Validation Tag** | **Description** |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| **验证标签** | **描述** |'
- en: '| --- | --- |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `<``f:validateBean>` | Bean validation allows us to validate named bean values
    by using annotations in our named beans without having to add validators to our
    Jakarta Faces tags. This tag allows us to fine-tune Bean Validation if necessary.
    |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `<f:validateBean>` | 通过在命名 Bean 中使用注解进行验证，Bean 验证允许我们验证命名 Bean 的值，而无需向我们的
    Jakarta Faces 标签添加验证器。如果需要，此标签允许我们微调 Bean 验证。 |'
- en: '| `<``f:validateDoubleRange>` | Validates that the input is a valid `Double`
    value between the two values specified by the tag’s `minimum` and `maximum` attributes,
    inclusive |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `<f:validateDoubleRange>` | 验证输入是一个有效的 `Double` 值，在标签的 `minimum` 和 `maximum`
    属性指定的两个值之间，包括这两个值 |'
- en: '| `<``f:validateLength>` | Validates that the input’s length is between the
    values specified by the tag’s `minimum` and `maximum` values, inclusive |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `<f:validateLength>` | 验证输入的长度在标签的 `minimum` 和 `maximum` 值之间，包括这两个值 |'
- en: '| `<``f:validateLongRange>` | Validates that the input is a valid `Double`
    value between the values specified by the tag’s `minimum` and `maximum` attributes,
    inclusive |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `<f:validateLongRange>` | 验证输入是一个有效的 `Double` 值，在标签的 `minimum` 和 `maximum`
    属性指定的值之间，包括这两个值 |'
- en: '| `<``f:validateRegex>` | Validates that the input matches a regular expression
    pattern specified in the tag’s `pattern` attribute |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `<f:validateRegex>` | 验证输入与标签的 `pattern` 属性中指定的正则表达式模式匹配 |'
- en: '| `<``f:validateRequired>` | Validates that the input is not empty. This tag
    is equivalent to setting the `required` attribute to `true` in the parent input
    field |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `<f:validateRequired>` | 验证输入不为空。此标签等同于在父输入字段中将 `required` 属性设置为 `true` |'
- en: Table 6.2 – Jakarta Faces validation tags
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.2 – Jakarta Faces 验证标签
- en: Notice that in the description for `<f:validateBean>`, we briefly mentioned
    **Bean Validation**. The Bean Validation API aims to standardize JavaBean validation.
    JavaBeans are used by several other APIs that previously had to implement their
    own validation logic. Jakarta Faces leverages Bean Validation to help validate
    named bean properties.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 `<f:validateBean>` 的描述中，我们简要提到了 **Bean Validation**。Bean Validation API
    旨在标准化 JavaBean 验证。JavaBeans 被几个其他 API 使用，这些 API 之前必须实现自己的验证逻辑。Jakarta Faces 利用
    Bean Validation 来帮助验证命名 bean 属性。
- en: If we wish to take advantage of Bean Validation, all we need to do is annotate
    the desired field with the appropriate Bean Validation annotation, without having
    to explicitly use a Jakarta Faces validator.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想利用 Bean Validation，我们只需要用适当的 Bean Validation 注解标注所需的字段，而无需显式使用 Jakarta
    Faces 验证器。
- en: Note
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For the complete list of Bean Validation annotations, refer to the `jakarta.validation.constraints`
    package in the Jakarta EE 10 API documentation at [https://jakarta.ee/specifications/platform/10/apidocs/](https://jakarta.ee/specifications/platform/10/apidocs/).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Bean Validation 注解的完整列表，请参阅 Jakarta EE 10 API 文档中的 `jakarta.validation.constraints`
    包，网址为 [https://jakarta.ee/specifications/platform/10/apidocs/](https://jakarta.ee/specifications/platform/10/apidocs/)。
- en: Grouping components
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件分组
- en: '`<h:panelGroup>` is the next new tag in the example. Typically, `<h:panelGroup>`
    is used to group several components together so that they occupy a single cell
    in `<h:panelGrid>`. This can be accomplished by adding components inside `<h:panelGroup>`
    and adding `<h:panelGroup>` to `<h:panelGrid>`. As can be seen in the example,
    this particular instance of `<h:panelGroup>` has no child components. In this
    particular case, the purpose of `<h:panelGroup>` is to have an empty cell and
    make the next component, `<h:commandButton>`, align with all other input fields
    in the form.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`<h:panelGroup>` 是示例中的下一个新标签。通常，`<h:panelGroup>` 用于将多个组件组合在一起，以便它们在 `<h:panelGrid>`
    中占用单个单元格。这可以通过在 `<h:panelGroup>` 内添加组件并将 `<h:panelGroup>` 添加到 `<h:panelGrid>`
    中来实现。如示例所示，这个 `<h:panelGroup>` 实例没有子组件。在这种情况下，`<h:panelGroup>` 的目的是有一个空单元格，并使下一个组件
    `<h:commandButton>` 与表单中的所有其他输入字段对齐。'
- en: Form submission
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表单提交
- en: '`<h:commandButton>` renders an HTML submit button in the browser. Just like
    with standard HTML, its purpose is to submit the form. Its `value` attribute simply
    sets the button’s label. This tag’s `action` attribute is used for navigation,
    the next page to show is based on the value of this attribute. The `action` attribute
    can have a string constant or a **method binding expression**, meaning that it
    can point to a method in a named bean that returns a string.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`<h:commandButton>` 在浏览器中渲染一个 HTML 提交按钮。就像标准 HTML 一样，它的目的是提交表单。它的 `value` 属性简单地设置按钮的标签。此标签的
    `action` 属性用于导航，要显示的下一页基于此属性的值。`action` 属性可以是一个字符串常量或一个 **方法绑定表达式**，这意味着它可以指向一个返回字符串的命名
    bean 中的方法。'
- en: If the base name of a page in our application matches the value of the `action`
    attribute of a `<h:commandButton>` tag, then we navigate to this page when clicking
    the button. In our example, our confirmation page is called `confirmation.xhtml`,
    therefore by convention, this page will be shown when the button is clicked, since
    the value of its `action` attribute (`"confirmation"`) matches the base name of
    the page.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们应用程序中页面的基本名称与`<h:commandButton>`标签的`action`属性的值相匹配，那么点击按钮时我们将导航到该页面。在我们的示例中，我们的确认页面名为`confirmation.xhtml`，因此按照惯例，当点击按钮时，将显示此页面，因为其`action`属性的值（`"confirmation"`）与页面的基本名称相匹配。
- en: Note
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Even though the label for the button reads **Save**, in our simple example,
    clicking on the button won’t actually save any data.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管按钮的标签读作**保存**，但在我们的简单示例中，点击按钮实际上不会保存任何数据。
- en: Named beans
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名bean
- en: 'Jakarta Faces includes tight integration with `@Named` annotation at the class
    level. Here is the named bean for our example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta Faces与类级别的`@Named`注解紧密集成。以下是我们的示例中的命名bean：
- en: '[PRE7]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `@Named` class annotation designates this bean as a CDI named bean. This
    annotation has an optional `value` attribute we can use to give our bean a logical
    name to use in our Jakarta Faces pages. However, by convention, the value of this
    attribute is the same as the class name (`Customer`, in our case), with its first
    character switched to lowercase. In our example, we let this default behavior
    take place, therefore we access our bean’s properties via the `customer` logical
    name. Notice the `value` attribute of any of the input fields in our example page
    to see this logical name in action.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Named`类注解指定此bean为CDI命名bean。此注解有一个可选的`value`属性，我们可以使用它为我们的bean提供一个逻辑名称，以便在Jakarta
    Faces页面中使用。然而，按照惯例，此属性的值与类名（在我们的例子中是`Customer`）相同，其第一个字符被转换为小写。在我们的示例中，我们允许这种默认行为发生，因此我们通过`customer`逻辑名称访问我们的bean属性。注意，在我们的示例页面中任何输入字段的`value`属性，以查看此逻辑名称的实际应用。'
- en: Notice that, other than the `@Named` and `@RequestScoped` annotations, there
    is nothing special about this bean. It is a standard JavaBean with private properties
    and corresponding getter and setter methods. The `@RequestScoped` annotation specifies
    that the bean should live through a single request. The different scopes available
    to CDI named beans are covered in the next section.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，除了`@Named`和`@RequestScoped`注解之外，此bean没有特殊之处。它是一个标准的JavaBean，具有私有属性和相应的getter和setter方法。`@RequestScoped`注解指定bean应该在一个请求中存活。CDI命名bean可用的不同作用域将在下一节中介绍。
- en: Named bean scopes
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名bean作用域
- en: Named beans always have a scope. A named bean scope defines the lifespan of
    the application. The named bean scope is defined by a class-level annotation.
    The following table lists all valid named bean scopes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 命名bean始终有一个作用域。命名bean作用域定义了应用程序的生命周期。命名bean作用域由类级别的注解定义。以下表格列出了所有有效的命名bean作用域。
- en: '| **Named Bean** **Scope Annnotation** | **Description** |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| **命名bean** **作用域注解** | **描述** |'
- en: '| --- | --- |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `@``ApplicationScoped` | The same instance of application-scoped named beans
    is available to all of our application’s clients. If one client modifies the value
    of an application-scoped named bean, the change is reflected across clients. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `@``ApplicationScoped` | 应用程序作用域的命名bean的同一实例对所有我们的应用程序客户端都是可用的。如果一个客户端修改了应用程序作用域的命名bean的值，则更改将在客户端之间反映出来。
    |'
- en: '| `@``SessionScoped` | An instance of each session-scoped named bean is assigned
    to each of our application’s clients. A session-scoped named bean can be used
    to hold client-specific data across requests. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `@``SessionScoped` | 每个会话作用域的命名bean实例都被分配给我们的应用程序的每个客户端。会话作用域的命名bean可以用来在请求之间保持客户端特定的数据。
    |'
- en: '| `@``RequestScoped` | Request-scoped named beans only live through a single
    HTTP request. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `@``RequestScoped` | 请求作用域的命名bean只存在于单个HTTP请求中。 |'
- en: '| `@``Dependent` | Dependent-scoped named beans are assigned the same scope
    as the bean they are injected into. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `@``Dependent` | 依赖作用域的命名bean被分配给它们注入的bean的作用域。 |'
- en: '| `@``ConversationScoped` | The conversation scope can span multiple requests
    but is typically shorter than the session scope. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `@``ConversationScoped` | 对话作用域可以跨越多个请求，但通常比会话作用域短。 |'
- en: '| `@``ClientWindowScoped` | Client Window scoped beans are kept in memory until
    the current web browser window or tab is closed. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `@``ClientWindowScoped` | 客户端窗口作用域的bean将保留在内存中，直到当前的网络浏览器窗口或标签页被关闭。 |'
- en: Table 6.3 – CDI scope annotations
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.3 – CDI作用域注解
- en: Named bean scopes allow us to dictate the life cycle of CDI named beans. By
    using one of the named bean scopes listed in the preceding table, we can control
    when our named beans are created and destroyed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 命名bean作用域允许我们指定CDI命名bean的生命周期。通过使用前面表格中列出的命名bean作用域之一，我们可以控制我们的命名bean何时创建和销毁。
- en: Static navigation
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态导航
- en: As can be seen in our input page, when clicking on the `customer_data_entry.xhtml`
    page, our application will navigate to a page called `confirmation.xhtml`. This
    happens because we are taking advantage of the convention over configuration capabilities
    of Jakarta Faces, in which if the value of the `action` attribute of a command
    button or link matches the base name of another page, then this navigation takes
    us to this page. This behavior is known as static navigation. Jakarta Faces also
    supports dynamic navigation, in which the landing page can be determined based
    on some business logic, we discuss dynamic navigation in the next section.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们的输入页面所示，当点击`customer_data_entry.xhtml`页面时，我们的应用程序将导航到一个名为`confirmation.xhtml`的页面。这是因为我们正在利用Jakarta
    Faces的约定优于配置功能，其中如果命令按钮或链接的`action`属性值与另一个页面的基本名称匹配，则此导航将带我们到该页面。这种行为被称为静态导航。Jakarta
    Faces还支持动态导航，其中着陆页面可以根据某些业务逻辑确定，我们将在下一节讨论动态导航。
- en: Same page reloading when clicking on a button or Link that should navigate to
    another page?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮或链接时是否会导致同一页面重新加载，而该按钮或链接应该导航到另一个页面？
- en: If navigation does not seem to be working properly, chances are there is a typo
    in the value of this attribute. Remember that by convention, Jakarta Faces will
    look for a page whose base name matches the value of the `action` attribute of
    a command button or link.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果导航看起来没有正常工作，那么很可能是这个属性的值有拼写错误。记住，按照惯例，Jakarta Faces会寻找一个与命令按钮或链接的`action`属性值匹配的基本名称的页面。
- en: 'The source for `confirmation.xhtml` looks like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`confirmation.xhtml`的源代码如下：'
- en: '[PRE8]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `<h:outputText>` we see on the confirmation page is the only tag we haven’t
    covered before. This tag simply displays the value of its value attribute to the
    rendered page, its `value` attribute can be a simple string or a value binding
    expression. Since the value binding expressions in our `<h:outputText>` tags are
    the same expressions used in the previous page for the `<h:inputText>` tags, their
    values will correspond to the data the user entered. We can see how the page is
    rendered in *Figure 6**.6*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在确认页面上看到的`<h:outputText>`是我们之前没有覆盖的唯一标签。这个标签简单地将其`value`属性的值显示到渲染的页面上，其`value`属性可以是简单的字符串或值绑定表达式。由于我们`<h:outputText>`标签中的值绑定表达式与之前页面中`<h:inputText>`标签使用的相同表达式，它们的值将对应于用户输入的数据。我们可以在*图6.6*中看到页面的渲染方式。
- en: "![Figure \uFEFF\uFEFF6.6 – Example confirmation page](img/B21231_6_06.jpg)"
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图6.6 – 示例确认页面](img/B21231_6_06.jpg)'
- en: Figure 6.6 – Example confirmation page
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 – 示例确认页面
- en: In traditional (i.e. non-Jakarta Faces) Java web applications, we define URL
    patterns to be processed by specific servlets. Specifically for Jakarta Faces,
    the suffix `.faces` is commonly used. Another commonly used URL mapping for Faces
    is the `/faces` prefix. Under certain conditions, modern application servers automatically
    add all both mappings to the `faces` servlet. If these conditions are met, we
    don’t have to specify any URL mappings at all.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的（即非Jakarta Faces）Java Web应用程序中，我们定义URL模式，以便由特定的servlet处理。对于Jakarta Faces来说，通常使用`.faces`后缀。另一个常用的Faces
    URL映射是`/faces`前缀。在特定条件下，现代应用程序服务器会自动将所有这些映射添加到`faces` servlet中。如果满足这些条件，我们根本不需要指定任何URL映射。
- en: 'If any of the following conditions is met, then the `FacesServlet` will be
    automatically mapped:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以下任何条件成立，则`FacesServlet`将被自动映射：
- en: There is a `faces-config.xml` file in the `WEB-INF` directory of our web application
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们Web应用程序的`WEB-INF`目录中有一个`faces-config.xml`文件
- en: There is a `faces-config.xml` file in the `META-INF` directory of one of the
    dependencies of our web application
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们Web应用程序的一个依赖项的`META-INF`目录中有一个`faces-config.xml`文件
- en: There is a filename ending in `.faces-config.xml` in the `META-INF` directory
    of one of the dependencies of our web application
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们Web应用程序的一个依赖项的`META-INF`目录中有一个以`.faces-config.xml`结尾的文件名
- en: We declare a context parameter named `jakarta.faces.CONFIG_FILES` in our `web.xml`
    or a `web-fragment.xml` in one of the dependencies
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在`web.xml`或我们Web应用程序依赖项中的一个`web-fragment.xml`中声明了一个名为`jakarta.faces.CONFIG_FILES`的上下文参数
- en: We pass a non-empty set of classes when invoking the `onStartup()` method of
    `ServletContextInitializer`
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用`ServletContextInitializer`的`onStartup()`方法时，我们传递一个非空类集。
- en: 'When none of these conditions are met, we need to explicitly map the Jakarta
    Faces servlet in our `web.xml` deployment descriptor, as illustrated here:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些条件都不满足时，我们需要在`web.xml`部署描述符中显式映射Jakarta Faces servlet，如图所示：
- en: '[PRE9]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The URL we used for the pages in our application was the name of our Facelets
    pages prefixed by `/faces`. We specify this in our `<servlet-mapping>` tag in
    our `web.xml` configuration file.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在应用程序中的页面使用的URL是Facelets页面的名称，前面加上`/faces`。我们在`web.xml`配置文件中的`<servlet-mapping>`标签中指定这一点。
- en: Dynamic navigation
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态导航
- en: In some cases, we may not know ahead of time what the next page in the application
    workflow would be, we need to run some business logic to determine what page to
    display next. For example, we may want to navigate to a confirmation page if everything
    went as expected when submitting our data, or we may want to navigate to an error
    page, or even back to the input page if there was an error processing the data.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能事先不知道应用程序工作流程中的下一页是什么，我们需要运行一些业务逻辑来确定显示下一页。例如，当提交数据时，如果一切如预期进行，我们可能希望导航到确认页面，或者我们可能希望导航到错误页面，甚至在处理数据时出现错误，我们可能希望导航回输入页面。
- en: 'The following example illustrates how we can implement dynamic navigation in
    Jakarta Faces:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了我们如何在Jakarta Faces中实现动态导航：
- en: '[PRE10]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To achieve dynamic navigation, we need to modify the action attribute of our
    command button to be a Jakarta Expression Language method expression, that is,
    an expression that maps to a method in one of our CDI named beans. For dynamic
    navigation, the method in the expression must take no arguments and return a string.
    In our example, we are using a method called `saveCustomer()` in a CDI named bean
    named `customerController`, therefore our expression is `#{customerController.saveCustomer}`.
    We’ll take a look at the implementation of our `saveCustomer()` method next:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现动态导航，我们需要修改命令按钮的动作属性，使其成为一个Jakarta表达式语言方法表达式，即映射到我们CDI命名bean中某个方法的表达式。对于动态导航，表达式中的方法必须不接受任何参数并返回一个字符串。在我们的示例中，我们正在使用名为`customerController`的CDI命名bean中的`saveCustomer()`方法，因此我们的表达式是`#{customerController.saveCustomer}`。我们将在下一节中查看`saveCustomer()`方法的实现：
- en: '[PRE11]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Our example application adheres to the Model-View-Controller design pattern.
    Our CDI named bean serves as a controller and decides what page to navigate to
    when the user submits the form. If everything goes well, we navigate to the confirmation
    page as usual. If there is a problem (an exception is caught), we navigate back
    to the input page (named `index.xhtml`) and display an error message to the user.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例应用程序遵循模型-视图-控制器设计模式。我们的CDI命名bean充当控制器，并在用户提交表单时决定导航到哪个页面。如果一切顺利，我们将像往常一样导航到确认页面。如果出现问题（捕获到异常），我们将导航回输入页面（命名为`index.xhtml`）并向用户显示错误消息。
- en: For illustration purposes, our `saveCustomer()` method simply saves the string
    representation of the `Customer` object to a file in the filesystem to force an
    exception and allow us to illustrate dynamic navigation. Our code flips the read-only
    attribute of the file in question (makes it read-only if it is writeable, and
    vice versa), then attempts to write to the file. When attempting to write to the
    file when it is read-only, an exception is thrown and we navigate back to the
    input page, as illustrated in *Figure 6**.7*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明目的，我们的`saveCustomer()`方法简单地将`Customer`对象字符串表示保存到文件系统中，以强制抛出异常并允许我们展示动态导航。我们的代码翻转了相关文件的只读属性（如果它是可写的，则使其只读，反之亦然），然后尝试写入文件。当尝试在文件为只读时写入文件时，将抛出异常，并像图*6**.7*所示的那样导航回输入页面。
- en: "![Figure \uFEFF\uFEFF6.7\uFEFF – Dynamic navigation](img/B21231_6_07.jpg)"
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图6.7 – 动态导航](img/B21231_6_07.jpg)'
- en: Figure 6.7 – Dynamic navigation
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 – 动态导航
- en: Sometimes we need to provide custom business logic validation or implement validation
    rules not included with the standard Jakarta Faces validators. In cases like this,
    we can take advantage of Jakarta Faces custom validation functionality.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要提供自定义的业务逻辑验证或实现标准Jakarta Faces验证器中未包含的验证规则。在这种情况下，我们可以利用Jakarta Faces自定义验证功能。
- en: Custom data validation
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义数据验证
- en: 'In addition to providing standard validators for our use, Jakarta Faces allows
    us to create custom validators. This can be done in one of two ways: by creating
    a custom validator class or by adding validation methods to our named beans.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为我们提供标准验证器之外，Jakarta Faces 允许我们创建自定义验证器。这可以通过两种方式之一完成：创建一个自定义验证器类或将验证方法添加到我们的命名豆中。
- en: Creating custom validators
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义验证器
- en: In addition to the standard validators, Jakarta Faces allows us to create custom
    validators by creating a Java class implementing the `jakarta.faces.validator.Validator`
    interface.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准验证器之外，Jakarta Faces 允许我们通过创建一个实现 `jakarta.faces.validator.Validator` 接口的
    Java 类来创建自定义验证器。
- en: 'The following class implements an email validator, which we will use to validate
    the email text input field in our customer data entry screen:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类实现了一个电子邮件验证器，我们将使用它来验证客户数据输入屏幕中的电子邮件文本输入字段：
- en: '[PRE12]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `@FacesValidator` annotation registers our class as a Jakarta Faces custom
    validator class. The value of its `value` attribute is the logical name that Facelets’
    pages use to refer to it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`@FacesValidator` 注解将我们的类注册为 Jakarta Faces 自定义验证器类。其 `value` 属性的值是 Facelets
    页面用来引用它的逻辑名称。'
- en: As can be seen in the example, the only method we need to implement when implementing
    the `Validator` interface is a method called `validate()`. This method takes three
    parameters, an instance of `jakarta.faces.context.FacesContext`, an instance of
    `jakarta.faces.component.UIComponent` and an object. Typically, application developers
    only need to be concerned with the last two. The second parameter is the component
    whose data we are validating and the third parameter is the actual value. In our
    example validator, we cast `uiComponent` to `jakarta.faces.component.html.HtmlInputText`.
    This way, we get access to its `getLabel()` method, which we can use as part of
    the error message.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例所示，在实现 `Validator` 接口时，我们只需要实现一个名为 `validate()` 的方法。该方法接受三个参数，分别是 `jakarta.faces.context.FacesContext`
    的一个实例、一个 `jakarta.faces.component.UIComponent` 的实例和一个对象。通常，应用程序开发者只需关注后两个参数。第二个参数是我们正在验证数据的组件，第三个参数是实际值。在我们的示例验证器中，我们将
    `uiComponent` 强制转换为 `jakarta.faces.component.html.HtmlInputText`。这样，我们可以访问其 `getLabel()`
    方法，我们可以将其用作错误消息的一部分。
- en: If the entered value is not a valid email address format, a new instance of
    `jakarta.faces.application.FacesMessage` is created, passing the error message
    to be displayed in the browser as its constructor parameter. We then throw a new
    `jakarta.faces.validator.ValidatorException`. The error message is then displayed
    in the browser. How it gets there is done behind the scenes by the Jakarta Faces
    API.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入的值不是有效的电子邮件地址格式，则创建一个新的 `jakarta.faces.application.FacesMessage` 实例，将要在浏览器中显示的错误消息作为其构造函数参数传递。然后我们抛出一个新的
    `jakarta.faces.validator.ValidatorException`。错误消息随后在浏览器中显示。它是如何到达那里的由 Jakarta
    Faces API 在幕后完成。
- en: Apache Commons Validator
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Commons Validator
- en: Our custom validator uses **Apache Commons Validator** to do the actual validation.
    This library includes many common validations, such as dates, credit card numbers,
    ISBN numbers, and emails. When implementing a custom validator, it is worth investigating
    if this library already has a validator that we can use.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自定义验证器使用 **Apache Commons Validator** 来执行实际的验证。这个库包括许多常见的验证，如日期、信用卡号码、ISBN
    号码和电子邮件。在实现自定义验证器时，值得调查这个库是否已经有一个我们可以使用的验证器。
- en: 'In order to use our validator on our page, we need to use the `<f:validator>`
    tag in our Facelets pages, nested inside the field we wish to validate. The following
    code snippet illustrates the changes we had to make to our email input field to
    incorporate our custom validator.:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的页面上使用我们的验证器，我们需要在我们的 Facelets 页面上使用 `<f:validator>` 标签，将其嵌套在我们希望验证的字段内部。以下代码片段说明了我们为了将我们的自定义验证器集成到电子邮件输入字段中而必须做出的更改：
- en: '[PRE13]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In order to validate our email input field, we added an `<f:validator>` tag
    nested inside its markup. Notice that the value of the `validatorId` attribute
    of `<f:validator>` matches the value we used in the `@FacesValidator` annotation
    in our custom email validator.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证我们的电子邮件输入字段，我们在其标记内部添加了一个嵌套的 `<f:validator>` 标签。请注意，`<f:validator>` 的 `validatorId`
    属性的值与我们自定义电子邮件验证器中使用的 `@FacesValidator` 注解中的值相匹配。
- en: After writing our custom validator and modifying our page to take advantage
    of it, we can see our validator in action, as illustrated in *Figure 6**.8*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写我们的自定义验证器并修改我们的页面以利用它之后，我们可以看到我们的验证器在 *图 6.8* 中的实际应用。
- en: "![Figure \uFEFF\uFEFF6.8 – Custom Jakarta Faces validator in action](img/B21231_6_08.jpg)"
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.8 – 自定义 Jakarta Faces 验证器在行动](img/B21231_6_08.jpg)'
- en: Figure 6.8 – Custom Jakarta Faces validator in action
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 – 自定义Jakarta Faces验证器在实际中的应用
- en: Now that we’ve seen how to write custom validators, we will focus our attention
    to the other way we can implement custom validation in Jakarta Faces, by writing
    validator methods.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何编写自定义验证器，我们将关注另一种在Jakarta Faces中实现自定义验证的方法，即通过编写验证方法。
- en: Validator methods
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证方法
- en: 'Another way we can implement custom validation is by adding validation methods
    to one or more of the application’s named beans. The following Java class illustrates
    the use of validator methods for Faces validation:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过向应用程序的一个或多个命名Bean中添加验证方法来实现自定义验证。以下Java类展示了如何使用验证方法进行Faces验证：
- en: '[PRE14]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, the class contains only the validator method, but that does
    not always have to be the case. We can give our validator method any name we want,
    but its return value must be void, and it must take the three parameters illustrated
    in the example, in that order. In other words, except for the method name, the
    signature of a validator method must be identical to the signature of the `validate()`
    method defined in the `jakarta.faces.validator.Validator` interface.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，该类只包含验证方法，但这并不总是必须的。我们可以给我们的验证方法取任何我们想要的名称，但它的返回值必须是void，并且它必须按照示例中的顺序接受三个参数。换句话说，除了方法名外，验证方法的签名必须与`jakarta.faces.validator.Validator`接口中定义的`validate()`方法的签名相同。
- en: As we can see, the body of the preceding validator method is nearly identical
    to the body of our custom validator’s `validate()` method. We check the value
    entered by the user to make sure it contains only alphabetic characters and/or
    spaces. If it doesn’t, then we throw a `ValidatorException` passing an instance
    of `FacesMessage` containing an appropriate error message string.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，前面验证方法的主体几乎与我们的自定义验证器的`validate()`方法的主体相同。我们检查用户输入的值，以确保它只包含字母字符和/或空格。如果不满足条件，则抛出一个包含适当错误消息字符串的`ValidatorException`。
- en: StringUtils
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: StringUtils
- en: In the example, we used `org.apache.commons.lang3.StringUtils` to perform the
    actual validation logic. In addition to the method used in the example, this class
    contains several methods for verifying that a `string` is numeric or alphanumeric.
    This class, part of the Apache Commons Lang library, is very useful when writing
    custom validators.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们使用了`org.apache.commons.lang3.StringUtils`来执行实际的验证逻辑。除了示例中使用的该方法外，此类还包含几个用于验证`string`是否为数字或字母数字的方法。这个类是Apache
    Commons Lang库的一部分，在编写自定义验证器时非常有用。
- en: Since every validator method must be in a named bean, we need to make sure the
    class containing our validator method is annotated with the `@Named` annotation,
    as illustrated in our example.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个验证方法都必须在命名Bean中，我们需要确保包含我们的验证方法的类被`@Named`注解标注，正如我们在示例中所展示的那样。
- en: 'The last thing we need to do to use our validator method is to bind it to our
    component via the tag’s `validator` attribute:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是将我们的验证方法绑定到我们的组件上，通过标签的`validator`属性：
- en: '[PRE15]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Since neither the first name nor the last name fields should accept anything
    other than alphabetic characters or spaces, we added our custom validator method
    to both of these fields.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于姓名字段和姓氏字段都不应接受除字母字符和空格之外的内容，我们将我们的自定义验证方法添加到了这两个字段。
- en: Notice that the value of the validator attribute of the `<h:inputText>` tag
    is an expression written in the Jakarta expression language, it uses the default
    named bean name for the bean containing our validation method. `alphaValidator`
    is the name of our bean, and `validateAlpha` is the name of our validator method.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`<h:inputText>`标签的验证器属性值是一个用Jakarta表达式语言编写的表达式，它使用包含我们的验证方法的Bean的默认命名Bean名称。`alphaValidator`是我们Bean的名称，而`validateAlpha`是我们验证方法的名称。
- en: After modifying our page to use our custom validator, we can now see it in action,
    as seen in *Figure 6**.9*.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改我们的页面以使用我们的自定义验证器后，我们现在可以看到它在**图6.9**中的实际应用。
- en: "![Figure \uFEFF\uFEFF6.9 – Custom validation via validator methods](img/B21231_6_09.jpg)"
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图6.9 – 通过验证方法进行自定义验证](img/B21231_6_09.jpg)'
- en: Figure 6.9 – Custom validation via validator methods
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 – 通过验证方法进行自定义验证
- en: Notice how for the **First Name** field, both our custom validator message and
    the standard length validator were executed.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到对于**姓名**字段，我们的自定义验证消息和标准长度验证器都已被执行。
- en: Implementing validator methods has the advantage of not having the overhead
    of creating a whole class just for a single validator method (our example does
    just that, but in many cases, validator methods are added to an existing named
    bean containing other methods). However, the disadvantage is that each component
    can only be validated by a single validator method. When using validator classes,
    several `<f:validator>` tags can be nested inside the tag to be validated, therefore
    multiple validations, both custom and standard, can be done on the field.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 实现验证方法的优势在于不需要为单个验证方法创建整个类（我们的示例就是这样做的，但在许多情况下，验证方法被添加到包含其他方法的现有命名bean中）。然而，缺点是每个组件只能由单个验证方法进行验证。当使用验证类时，可以在要验证的标签内部嵌套多个`<f:validator>`标签，因此可以在字段上执行多个验证，包括自定义和标准验证。
- en: Now that we’ve seen how to create our own custom validation, we’ll see how we
    can customize our Jakarta Faces validation messages, we’ll see how we can change
    how they are formatted (font, color, etc.), and how to customize error message
    text for standard Jakarta Faces validators.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何创建自己的自定义验证，我们将看到如何自定义Jakarta Faces验证消息，我们将看到如何更改它们的格式（字体、颜色等），以及如何为标准Jakarta
    Faces验证器自定义错误消息文本。
- en: Customizing default messages
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义默认消息
- en: As we mentioned earlier, it is possible to customize the style (font, color,
    text, etc.) of Jakarta Faces default validation messages. Additionally, it is
    possible to modify the text of the default Jakarta Faces validation messages.
    In the following sections, we will explain how to modify error message formatting
    and text.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，可以自定义Jakarta Faces默认验证消息的样式（字体、颜色、文本等）。此外，还可以修改默认Jakarta Faces验证消息的文本。在接下来的几节中，我们将解释如何修改错误消息的格式和文本。
- en: Customizing message styles
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义消息样式
- en: Customizing message styles can be done with `<h:message>` `style` or `styleClass`
    attributes. The `style` attribute is used when we want to declare the CSS style
    inline. The `styleClass` attribute is used when we want to use a predefined style
    in a CSS style sheet or inside a `<style>` tag on our page.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`<h:message>`标签的`style`或`styleClass`属性来自定义消息样式。当我们要声明内联CSS样式时使用`style`属性。当我们要在CSS样式表中或在我们页面的`<style>`标签中使用预定义样式时使用`styleClass`属性。
- en: The following `markup` illustrates using the `styleClass` attribute to alter
    the style of error messages. It is a modified version of the input page we saw
    in the previous section.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`markup`展示了如何使用`styleClass`属性来改变错误消息的样式。这是我们在上一节中看到的输入页面的修改版本。
- en: '[PRE16]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The only difference between this page and the previous one is the use of the
    `styleClass` attribute of the `<h:messages>` tag. As we mentioned earlier, the
    value of the `styleClass` attribute must match the name of a CSS style defined
    in a cascading stylesheet that our page has access to.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一页相比，唯一的区别是使用了`<h:messages>`标签的`styleClass`属性。正如我们之前提到的，`styleClass`属性的值必须与页面可访问的级联样式表中定义的CSS样式的名称相匹配。
- en: 'In our case, we defined a CSS style for messages as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们定义了如下CSS样式用于消息：
- en: '[PRE17]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Then used this style as the value of the `styleClass` attribute of our `<``h:messages>`
    tag.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将此样式作为我们`<h:messages>`标签的`styleClass`属性的值。
- en: '*Figure 6**.10* illustrates how the validation error messages look after implementing
    this change.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6**.10*展示了在实施此更改后验证错误消息的外观。'
- en: "![Figure \uFEFF\uFEFF6.10\uFEFF – Custom styles for validation messages](img/B21231_6_10.jpg)"
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图6.10 – 验证消息的自定义样式](img/B21231_6_10.jpg)'
- en: Figure 6.10 – Custom styles for validation messages
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10 – 验证消息的自定义样式
- en: In this particular case, we just set the color of the error message text to
    red, but we are only limited by CSS capabilities in setting the style of the error
    messages.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的情况下，我们只是将错误消息文本的颜色设置为红色，但我们只能通过CSS的能力来设置错误消息的样式。
- en: Note
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Pretty much any standard Jakarta Faces component has both a `style` and a `styleClass`
    attribute that can be used to alter its style. The former is used for predefined
    CSS styles, the latter is used for inline CSS.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何标准的Jakarta Faces组件都包含一个`style`属性和一个`styleClass`属性，可以用来改变其样式。前者用于预定义的CSS样式，后者用于内联CSS。
- en: Customizing message text
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义消息文本
- en: 'Sometimes it is desirable to override the text of Jakarta Faces default validation
    messages. Default validation messages are defined in a resource bundle called
    `Messages.properties`. This file can typically be found inside one of the Faces
    JAR files included with your application server. For example, `GlassFish` includes
    it inside a JAR file called `jakarta.faces.jar` file under `[glassfish installation
    directory]/glassfish/modules`. The file contains several messages; we are only
    interested in validation errors at this point. The default validation error messages
    are defined as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 有时可能需要覆盖Jakarta Faces默认验证消息的文本。默认验证消息定义在名为`Messages.properties`的资源包中。此文件通常位于应用程序服务器包含的Faces
    JAR文件之一中。例如，`GlassFish`将其包含在名为`jakarta.faces.jar`的JAR文件中，位于`[glassfish安装目录]/glassfish/modules`下。该文件包含多个消息；在此阶段，我们只对验证错误感兴趣。默认验证错误消息定义如下：
- en: '[PRE18]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In order to override the default error messages, we need to create our own
    resource bundle using the same keys used in the default one, but altering the
    values to suit our needs. Here is a very simple customized resource bundle for
    our application. For example, to overwrite the message for minimum length validation,
    we would add the following property to our custom resource bundle:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了覆盖默认的错误消息，我们需要创建自己的资源包，使用与默认资源包相同的键，但更改值以适应我们的需求。以下是我们应用程序的一个非常简单的自定义资源包示例。例如，要覆盖最小长度验证的消息，我们将在我们的自定义资源包中添加以下属性：
- en: '[PRE19]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this resource bundle, we override the error message for when the value entered
    for a field validated by the `<f:validateLength>` tag is less than the allowed
    minimum. In order to let our application know that we have a custom resource bundle
    for message properties, we need to modify the application’s `faces-config.xml`
    file:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在此资源包中，我们覆盖了当使用`<f:validateLength>`标签验证的字段输入的值小于允许的最小值时的错误消息。为了让我们的应用程序知道我们有一个包含消息属性的自定义资源包，我们需要修改应用程序的`faces-config.xml`文件：
- en: '[PRE20]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we can see, the only thing we need to do to the application’s `faces-config.xml`
    file is to add a `<message-bundle>` element indicating the name and location of
    the resource bundle containing our custom messages.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们只需要对应用程序的`faces-config.xml`文件进行修改，添加一个`<message-bundle>`元素，指示包含我们的自定义消息的资源包的名称和位置。
- en: After adding our custom message resource bundle and modifying the application’s
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加我们的自定义消息资源包并修改应用程序的
- en: '`faces-config.xml` file, we can see our custom validation message in action,
    as illustrated in *Figure 6**.11*.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`faces-config.xml` 文件，我们可以看到我们的自定义验证消息正在发挥作用，如图 *图6**.11* 所示。'
- en: "![Figure \uFEFF\uFEFF6.11 – Custom validation error message](img/B21231_6_11.jpg)"
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图6.11 – 自定义验证错误消息](img/B21231_6_11.jpg)'
- en: Figure 6.11 – Custom validation error message
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11 – 自定义验证错误消息
- en: If we haven’t overridden a validation message, the default will still be displayed.
    In our resource bundle, we only overrode the minimum length validation error message,
    therefore our custom error message is shown for the **First Name** text field.
    Since we didn’t override the error message for the other standard Jakarta Faces
    validators, the default error message is shown for each one of them. The email
    validator is the custom validator we developed previously in this chapter, since
    it is a custom validator its error message is not affected.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有覆盖验证消息，默认消息仍然会显示。在我们的资源包中，我们只覆盖了最小长度验证错误消息，因此我们的自定义错误消息会显示在**姓名**文本字段中。由于我们没有覆盖其他标准Jakarta
    Faces验证器的错误消息，因此每个验证器都会显示默认错误消息。电子邮件验证器是我们在本章中先前开发的自定义验证器，因为它是一个自定义验证器，其错误消息不受影响。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered how to develop web-based applications using Jakarta
    Faces, the standard component framework for the Jakarta EE.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何使用Jakarta Faces开发基于Web的应用程序，Jakarta Faces是Jakarta EE的标准组件框架。
- en: In this chapter, we covered how to write a simple application by creating pages
    using Facelets as the view technology and CDI named beans. We saw how to implement
    static and dynamic navigation with Jakarta Faces. We also covered how to validate
    user input by using Faces standard validators and by creating our own custom validators
    or by writing validator methods. Additionally, we covered how to customize standard
    Faces error messages, both the message text and the message style (font, color,
    etc).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何通过使用 Facelets 作为视图技术以及 CDI 命名豆来创建简单应用程序。我们看到了如何使用 Jakarta Faces
    实现静态和动态导航。我们还介绍了如何通过使用 Faces 标准验证器、创建我们自己的自定义验证器或编写验证器方法来验证用户输入。此外，我们还介绍了如何自定义标准
    Faces 错误消息，包括消息文本和消息样式（字体、颜色等）。
- en: Jakarta Faces’ tight integration with CDI allows us to efficiently develop web-based
    interfaces for our Jakarta EE applications.**
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta Faces 与 CDI 的紧密集成使我们能够高效地为我们的 Jakarta EE 应用程序开发基于 Web 的界面。
