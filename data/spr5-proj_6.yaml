- en: Creating an Online Bookstore
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个在线书店
- en: It is always beneficial to develop any web application in a layered fashion.
    A prominent n-tier (or sometimes 3-tier) solution is the layered architecture,
    which has been widely adopted as the standard pattern for designing most applications.
    It is not a new concept, and we have been using it for a long time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 以分层方式开发任何Web应用程序总是有益的。一个突出的n层（或有时3层）解决方案是分层架构，它已被广泛采用作为设计大多数应用程序的标准模式。这并不是一个新概念，我们已经使用了很长时间。
- en: 'A layered architecture separates the whole application into various layers
    of concerns, which are logically different from each other:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 分层架构将整个应用程序划分为各种关注层，这些层在逻辑上是相互不同的：
- en: '**Presentation layer**: This layer contains the artifacts that are responsible
    for building a user interface or displaying the output to the end user'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表示层**：这一层包含负责构建用户界面或向最终用户显示输出的工件'
- en: '**Application layer**: This layer contains business logic and interacts with
    the presentation and persistence layers to makeup the flow of the application'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用层**：这一层包含业务逻辑，并与表示层和持久层交互，以构成应用程序的流程'
- en: '**Persistence layer**: This layer stores the data in data stores such as databases,
    the filesystem, and external sources, and also retrieves it'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久层**：这一层将数据存储在数据库、文件系统和外源等数据存储中，并检索它'
- en: There are numerous advantages of a layered architecture, such as increased reusability,
    flexibility, and consistency, because the layers are logically separated. Applications
    built with a layered architecture are self-contained in nature and can be executed
    independently of other applications. They are referred to as **monolithic applications**.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 分层架构有许多优势，如可重用性、灵活性和一致性增加，因为层在逻辑上是分离的。使用分层架构构建的应用程序本质上是自包含的，并且可以独立于其他应用程序执行。它们被称为**单体应用程序**。
- en: Since the beginning of this book, we have been creating a monolithic application
    to showcase and explore various concepts. Though logically separated as an n-tier
    architecture, monolithic applications face a maintenance nightmare once their
    size and complexity reach a certain level over a period of time. Such applications
    hold all the features and functionalities in one single package, which is wrapped
    as a single deployable unit.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 自本书开始以来，我们一直在创建一个单体应用程序来展示和探索各种概念。尽管在逻辑上被分离为n层架构，但随着时间的推移，单体应用程序在规模和复杂性达到一定程度后，将面临维护噩梦。这样的应用程序将所有功能和功能都包含在一个单一包中，该包被封装为单个可部署单元。
- en: '**Microservices**, on the other hand, are a different architectural approach,
    adopted by organizations such as Google, Amazon, Netflix, and many others, with
    the aim of meeting modern business needs and developing an application that is
    inherently complex in nature. The microservice architecture helps to solve the
    various problems that arise with monolithic applications.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**微服务**是一种不同的架构方法，由谷歌、亚马逊、Netflix和其他许多组织采用，旨在满足现代商业需求并开发本质上复杂的应用程序。微服务架构有助于解决单体应用程序出现的各种问题。
- en: 'The concept of microservices is not new; it has come to the fore to overcome
    the limitations of previous architectures. In this chapter, we will closely observe
    the evolution of microservice architecture by developing an online bookstore application
    along with following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的概念并不新鲜；它已经崭露头角，以克服先前架构的限制。在本章中，我们将通过开发一个在线书店应用程序并探讨以下主题来密切观察微服务架构的演变：
- en: Introduction to microservice architecture
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构简介
- en: Principles and characteristics of microservice architecture
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构的原则和特性
- en: Various approaches to designing a microservice frontend
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计微服务前端的各种方法
- en: Defining the structure of the database
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义数据库结构
- en: Exploring various Spring Cloud and Netflix OSS components to design microservices
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索各种Spring Cloud和Netflix OSS组件以设计微服务
- en: Making a microservice application secure
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作一个安全的微服务应用程序
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All the code used in this chapter can be downloaded from the following GitHub
    link: [https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter06](https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter06).
    The code can be executed on any operating system, although it has only been tested
    on Windows.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的所有代码都可以从以下GitHub链接下载：[https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter06](https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter06)。代码可以在任何操作系统上执行，尽管它只在Windows上进行了测试。
- en: Microservices introduction
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务介绍
- en: Microservices have emerged as a promising architecture pattern that is widely
    accepted as a solution to modern trends in business. Enterprises use various channels,
    such as mobile platforms, analytics with big data, and social media interaction,
    as elements to grow the business and find new customers at a rapid pace. With
    all these artifacts, organizations are trying to design innovations that will
    help them to gain a strong market share, which is a quite a difficult goal to
    achieve with conventional delivery methodologies.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务已成为一种有希望的架构模式，被广泛接受作为解决现代商业趋势的方案。企业使用各种渠道，如移动平台、大数据分析和社交媒体互动，作为增长业务和快速寻找新客户的元素。有了所有这些元素，组织正在尝试设计创新，以帮助他们获得强大的市场份额，这是一个使用传统交付方法相当难以实现的目标。
- en: In the past, enterprises developed single monolithic and accumulated applications
    for their business needs. Today, this has changed, as the goal has shifted to
    developing a smart solution with a short turnaround time that focuses on a specific
    business need.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，企业为满足其业务需求开发了单一的单体和累积应用程序。如今，这种状况已经改变，因为目标已经转向开发一个具有短周转时间、专注于特定业务需求的智能解决方案。
- en: A good example is a traveling company that executes their business with a single
    monolithic application. What if they want to improve the customer experience by
    suggesting new traveling ideas based on user searches or, more specifically, their
    old trips, any special occasion or festival season, user preferences, or interests?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子是，一家旅游公司使用单一的单体应用程序来执行其业务。如果他们想通过根据用户搜索或更具体地说，根据他们的旧旅行、任何特殊场合或节日季节、用户偏好或兴趣来建议新的旅行想法来改善客户体验，会怎样呢？
- en: 'There are many scenarios where organizations wish to implement independent
    solutions for each of these use cases and plug them into core business logic,
    instead of keeping everything together as a single application, which means they
    have to keep updating and testing the whole application for any future business
    changes, as shown in the following diagram:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多场景中，组织希望为这些用例中的每一个实施独立解决方案，并将它们集成到核心业务逻辑中，而不是将所有内容作为一个单一应用程序来维护，这意味着他们必须不断更新和测试整个应用程序以应对未来的业务变化，如下面的图示所示：
- en: '![](img/80eb0165-de74-49f6-9c80-63bcdb00abe1.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/80eb0165-de74-49f6-9c80-63bcdb00abe1.png)'
- en: Instead of putting all these independent functionalities together with the core
    business logic, they can be plugged in independently. This approach is more flexible
    in terms of allowing new changes with a lower adoption cost. Additionally, they
    can be tested independently and more effectively. Any further changes can be accommodated
    with ease.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是将这些独立的功能与核心业务逻辑一起集成，它们可以独立插入。这种方法在允许以较低采用成本进行新更改方面更加灵活。此外，它们可以独立且更有效地进行测试。任何进一步的更改都可以轻松适应。
- en: Such business scenarios expect an architecture that can adopt changes with minimal
    impact and cost, which makes it more agile. This is why the microservice approach
    has been developed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的业务场景需要一个能够以最小的影响和成本适应变化的架构，这使得它更加敏捷。这就是为什么开发微服务方法的原因。
- en: Microservice architectures focus on designing an application in small parts,
    each of which is concerned with a specific function, instead of making the whole
    application a black box in a monolithic architecture.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构专注于以小部分设计应用程序，每个部分都关注特定的功能，而不是将整个应用程序作为一个单体架构中的黑盒。
- en: In the last few years, the revolution in technological paradigms has completely
    changed the way we develop an application. This includes the frontend layer, with
    various popular frameworks for responsive capabilities and flexibility, such as
    Angular, React, Backbone, and Bootstrap, which completely change the user front.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，技术范式的革命彻底改变了我们开发应用程序的方式。这包括前端层，有各种流行的框架，如Angular、React、Backbone和Bootstrap，它们完全改变了用户界面。
- en: With the introduction of cloud-aware and container mechanisms, the approach
    to designing and implementing the middle layer has been influenced. It also includes
    a change in the way we design persistence from using a relational database to
    NoSQL, which solved specific architectural concerns.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 随着云意识和容器机制的出现，设计和实现中间层的方法受到了影响。这还包括了从使用关系型数据库到NoSQL的设计方式的改变，从而解决了特定的架构问题。
- en: Microservice architecture
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务架构
- en: As time passes, architectural styles have improved significantly. Various architecture
    patterns, such as mainframes, client-server, n-tier, and **service-oriented architecture** (**SOA**),
    have been popular at various points in history. However, these architectural were
    all involved in developing some sort of monolithic application, either directly
    or indirectly.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，架构风格已经显著改进。各种架构模式，如主机、客户端-服务器、多层和**面向服务的架构**（**SOA**），在历史上的不同时期都曾流行。然而，这些架构都涉及开发某种类型的单体应用程序，无论是直接还是间接。
- en: As the revolution happened in the technology stack, microservice architecture
    has come to the fore as a result of improvements in all previous architectures.
    The aim is to provide agility, reduce the turnaround time for adopting new changes,
    achieve scalable performance, and take full advantage of modern tools and frameworks.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 随着技术栈的革命发生，微服务架构由于所有先前架构的改进而变得突出。目标是提供敏捷性，减少采用新更改的周转时间，实现可扩展的性能，并充分利用现代工具和框架。
- en: 'Microservice architecture breaks an application into small, independent subsystems.
    They also can be referred to as a system of systems, as shown in the following
    diagram:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构将应用程序分解成小的、独立的子系统。它们也可以被称为系统中的系统，如下面的图所示：
- en: '![](img/7272ea49-c82b-48e0-b2b1-b3bdc8460292.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7272ea49-c82b-48e0-b2b1-b3bdc8460292.png)'
- en: Though the components are stored in different logical layers in a monolithic
    architecture, they are packaged in a single application structure. On the other
    hand, the microservice system is a set of independent subsystems, each packaged
    in their own project structure and deployed as independent units. You can consider
    a microservice architecture as a jigsaw puzzle where each microservice is a building
    block of a whole application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在单体架构中，组件存储在不同的逻辑层中，但它们被封装在单个应用程序结构中。另一方面，微服务系统是一组独立的子系统，每个子系统都封装在自己的项目结构中，并以独立单元的形式部署。你可以将微服务架构视为一个拼图，其中每个微服务都是整个应用程序的构建块。
- en: In short, in a monolithic system, the components are logically different but
    part of single physical application, whereas in a microservice architecture, the
    subsystems are actual physical applications that form a giant logical application.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，在单体系统中，组件在逻辑上是不同的，但属于单个物理应用程序的一部分，而在微服务架构中，子系统是实际的物理应用程序，它们形成一个巨大的逻辑应用程序。
- en: The microservice architecture is widely used now as a set of standards to refactor
    monolithic applications. Emerging from a hexagonal pattern, a microservice architecture
    promotes the encapsulation of a business function into an individual independent
    unit that is isolated from other functionality.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构现在广泛用作一组标准，用于重构单体应用程序。它起源于六边形模式，微服务架构促进了将业务功能封装到单个独立的单元中，该单元与其他功能隔离。
- en: 'A **Hexagonal Architecture** puts input and output on the edges of a hexagon
    and keeps **Business Logic** at the center. This arrangement isolates the application
    from outside concerns, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**六边形架构**将输入和输出放在六边形的边缘，并将**业务逻辑**保持在中心。这种安排将应用程序与外部关注点隔离开来，如下所示：'
- en: '![](img/7e48881f-2c05-4aca-b911-3accc56e4bdc.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7e48881f-2c05-4aca-b911-3accc56e4bdc.png)'
- en: The inside part consists of **Business Logic**, whereas the outside consist
    of the UI, messaging, **REST**, database, and others. The outside parts can be
    swapped without affecting the core application functions. Each business function
    can be designed with the hexagonal model, which then interacts with others with
    a standard communication mechanism.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 内部部分由**业务逻辑**组成，而外部部分包括UI、消息传递、**REST**、数据库和其他内容。外部部分可以互换，而不会影响核心应用程序功能。每个业务功能都可以使用六边形模型进行设计，然后通过标准通信机制与其他部分交互。
- en: Let's look at the hexagonal pattern by taking an example. Consider you are developing
    an EMI calculator application that calculates the principal and interest amount
    based on total loan amount, interest rate, and tenure. This application keeps
    the provision of scanning the user input to calculate the loan data. The logic
    for taking user input is closely associated with the EMI calculator application.
    After a period of time, another application needs to use the EMI calculator application.
    In this case, the input mechanism needs to be updated.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来观察六边形模式。假设你正在开发一个EMI计算器应用程序，该应用程序根据总贷款金额、利率和期限计算本金和利息金额。该应用程序保留扫描用户输入以计算贷款数据的功能。获取用户输入的逻辑与EMI计算器应用程序紧密相关。经过一段时间后，另一个应用程序需要使用EMI计算器应用程序。在这种情况下，输入机制需要更新。
- en: 'To overcome this problem, the hexagonal pattern suggests isolating the EMI
    calculating logic from the input receiving mechanism by defining some sort of
    standard interface. This way, the EMI calculator is completely unaware of where
    the inputs come from. In this scenario, the interface for receiving input is referred
    to as a **Port**, while its implementation is known as an **Adapter**, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这个问题，六边形模式建议通过定义某种标准接口来隔离EMI计算逻辑和输入接收机制。这样，EMI计算器完全不知道输入来自哪里。在这种情况下，接收输入的接口被称为**端口**，而其实施被称为**适配器**，如下所示：
- en: '![](img/8b0e6111-8fe2-4bae-82dd-f40fa0546866.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8b0e6111-8fe2-4bae-82dd-f40fa0546866.png)'
- en: The hexagonal pattern is also referred to as the **Port **and** Adapter **pattern.
    The concept of the microservice architecture is derived from the hexagonal pattern,
    in which each hexagonal structure represents a self-contained and loosely coupled
    service (subsystem). Adding more hexagonal models is equivalent to adding more
    independent services.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 六边形模式也被称为**端口**和**适配器**模式。微服务架构的概念源于六边形模式，其中每个六边形结构代表一个自包含且松散耦合的服务（子系统）。添加更多的六边形模型相当于添加更多的独立服务。
- en: That is why the microservice concept is logically compared with a honeycomb,
    in which multiple hexagons form a large and solid structure. Similarly, individual
    services (equivalent to individual hexagonal structures) form a larger application.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，微服务概念在逻辑上被比作蜂巢，其中多个六边形结构形成一个庞大而坚固的结构。同样，单个服务（相当于单个六边形结构）组成一个更大的应用程序。
- en: Microservice principles
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务原则
- en: Although there is no straight definition or standard for defining microservices,
    there are certain qualities, criteria, and principles that must be considered
    while designing microservice applications. Let's take a look at some of them in
    this section.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有直接的定义或标准来定义微服务，但在设计微服务应用程序时，必须考虑某些质量、标准和原则。让我们在本节中查看其中的一些。
- en: High cohesion with a single responsibility
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一责任的高内聚
- en: '**High cohesion** means a module or unit should execute a single business function.
    In the microservice architecture, an individual service should perform a single
    responsibility for a given application context. Sharing a single responsibility
    between multiple services should not be allowed. Also, a single service should
    not handle multiple responsibilities, in order to make the whole system truly
    modular.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**高内聚**意味着一个模块或单元应该执行单一的业务功能。在微服务架构中，单个服务应该为特定的应用程序上下文承担单一责任。不允许多个服务之间共享单一责任。此外，单个服务也不应处理多个责任，以便使整个系统真正模块化。'
- en: This is one of the striking differences between the monolithic and microservice
    architectures. The components are logically separated but are still part of a
    single application and share some common responsibilities in the former, but they
    are designed as independent small applications in the latter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是单体架构和微服务架构之间显著的不同之一。组件在逻辑上是分离的，但仍然是单个应用程序的一部分，并且在前者中共享一些共同的责任，但在后者中设计为独立的小型应用程序。
- en: While designing microservices, the goal should be the scope of the business
    function executed by the microservice instead of making it smaller. The term **micro**
    is sometimes misleading, suggesting you should make the service as small as possible.
    The scope should be given the highest priority, instead of the size of the service.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计微服务时，目标应该是微服务执行的业务功能的范围，而不是使其更小。术语**微**有时具有误导性，暗示你应该使服务尽可能小。应该优先考虑范围，而不是服务的大小。
- en: Service autonomy
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务自治
- en: While building a microservice application, the prime goal is to make each member
    (service) a standalone and independent building block. To make sure each service
    runs with optimal performance and provides reliable output, they must take full
    control over the underlying resources they use.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建微服务应用程序时，主要目标是使每个成员（服务）成为一个独立且独立的构建块。为了确保每个服务以最佳性能运行并提供可靠的输出，它们必须完全控制它们使用的底层资源。
- en: This can be achieved with the service autonomy principle. It recommends each
    service should be designed with autonomy in mind. By doing so, the control and
    ownership a service has over its own execution environment will be more effective,
    which would otherwise be difficult to achieve with shared resources in a monolithic
    architecture. This will greatly help in dealing with the scalability of the application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过服务自治原则来实现。它建议每个服务都应该以自治为设计目标。通过这样做，服务对其执行环境的控制和所有权将更加有效，这在单体架构中共享资源时是难以实现的。这将极大地帮助处理应用程序的可伸缩性。
- en: Loose coupling
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 松耦合
- en: An application should be designed with microservice architecture in such a way
    that each unit (service) should have (ideally) zero or the bare minimum impact
    on other components or services. If any sort of interaction or communication is
    required between services, they also should be loosely coupled in nature. This
    is the reason synchronous calls with RESTful APIs or asynchronous calls with a
    messaging framework are preferable.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 应该以微服务架构的方式设计应用程序，使得每个单元（服务）应该对其他组件或服务的影响（理想情况下）为零或最小。如果服务之间需要任何形式的交互或通信，它们也应该在本质上松耦合。这就是为什么同步调用RESTful
    API或异步调用消息框架更可取的原因。
- en: Hide implementation through encapsulation
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过封装隐藏实现
- en: Microservices must isolate underlying implementation details from the outside world
    and define a standard interface to interact with it. This will not only reduce
    complexity, but also enhance the ability to adopt new changes easily, making the
    whole system more flexible and robust.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务必须将底层实现细节与外部世界隔离，并定义一个标准接口来与之交互。这不仅会降低复杂性，还会增强轻松适应新变化的能力，使整个系统更加灵活和健壮。
- en: Domain-driven design
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域驱动设计
- en: '**Domain-driven design** (**DDD**) is a way to design a system with respect
    to the actual domain models used in the application. The architectural style of
    DDD is used to develop an application in independent units, each representing
    a specific domain model. It also suggests the way to behave and communicate between
    domain models. An ideal DDD has all the qualities required to develop a modular
    application. Due to this, it is an ideal candidate for consideration while implementing
    microservice architecture.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**领域驱动设计**（**DDD**）是一种根据应用程序中使用的实际领域模型来设计系统的方式。DDD的架构风格用于以独立单元开发应用程序，每个单元代表一个特定的领域模型。它还建议了领域模型之间行为和通信的方式。理想的DDD具有开发模块化应用程序所需的所有品质。因此，它是实施微服务架构的理想候选方案。'
- en: Microservice characteristics
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务特点
- en: 'Here are some characteristics of a microservice architecture:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是微服务架构的一些特点：
- en: It is a way of designing an application as a group of small services, each executed
    in its own procedure.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一种将应用程序设计为一组小服务的方式，每个服务在自己的流程中执行。
- en: Microservices can interact with each other internally, mostly through the HTTP
    API or some time-messaging mechanism such as AMQP or JMS.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务可以通过HTTP API或某些时间消息机制（如AMQP或JMS）等内部交互。
- en: Each microservice is built to execute a specific business requirement. In other
    words, they are aligned to specific business needs or capabilities.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个微服务都是构建来执行特定的业务需求的。换句话说，它们与特定的业务需求或能力对齐。
- en: Microservices can be deployed independently with an automated mechanism.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务可以独立部署，并使用自动化机制。
- en: Some sort of common or central process is required to manage microservices,
    which may or may not use the same technology stack as the individual microservices.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要某种形式的通用或中心化流程来管理微服务，这些微服务可能或可能不使用与单个微服务相同的技术栈。
- en: Microservices manage their life cycle independently of others.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务独立管理它们的生命周期。
- en: Changes to one microservice do not impact on others as they run independently.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对一个微服务的更改不会影响其他微服务，因为它们是独立运行的。
- en: Microservices with Spring Cloud
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于Spring Cloud的微服务
- en: Generally, microservices are designed to be deployed in a distributed system.
    There are certain common patterns across distributed environments. Spring Cloud
    provides a predefined implementation of patterns that we can use to build a microservice
    application quickly. They are considered Spring Cloud sub-projects. We are going
    to take a brief look at a few of them, and we will also see how to use them while
    developing our online bookstore application.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，微服务被设计为部署在分布式系统中。在分布式环境中存在一些常见的模式。Spring Cloud 提供了一系列预定义的模式实现，我们可以使用它们快速构建微服务应用程序。它们被认为是
    Spring Cloud 的子项目。我们将简要地看看其中的一些，同时也会看到如何在开发我们的在线书店应用程序时使用它们。
- en: Configuration management
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置管理
- en: Configurations are part of any application, and in the Spring world they are
    in the form of the properties file, generally bundled with the application code.
    It is a tedious job to deploy the entire service any time there's a configuration
    change. What if a configuration can be managed outside of the application? This
    is a good idea because managing configurations externally allows us to reflect
    changes without deploying or even restarting a service. This is exactly what configuration
    management does. Configurations are allowed on the fly.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 配置是任何应用程序的一部分，在 Spring 世界中，它们通常以属性文件的形式存在，通常与应用程序代码捆绑在一起。每次配置更改时部署整个服务是一项繁琐的工作。如果配置可以在应用程序外部进行管理会怎样？这是一个好主意，因为外部管理配置允许我们在不部署甚至重启服务的情况下反映更改。这正是配置管理所做的。配置可以即时进行。
- en: Service discovery
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务发现
- en: As we have seen, microservice applications are a collection of self-contained
    and independently deployable services that are running on the same or different
    physical machines, or on the cloud. Each service can be considered as an individual
    process that performs a specific responsibility.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，微服务应用程序是一组自包含且独立部署的服务，它们运行在相同的或不同的物理机器上，或在云上。每个服务都可以被视为一个执行特定职责的独立进程。
- en: Though they are separated in terms of executing different business functions,
    they are interconnected as a part of the whole application, and hence some sort
    of communication mechanism, with well-defined standards, is required.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它们在执行不同的业务功能方面是分离的，但作为整个应用程序的一部分，它们是相互关联的，因此需要某种通信机制，并且要有明确的标准。
- en: For interprocess communication, as well as accessing a particular service, we
    need to know the location in terms of the port and IP of the service. Traditional
    monolithic applications are generally deployed and accessible with a static port
    and IP address. Also, they are deployed in a single package so that all the components/services
    are accessible with the same port and IP. The likelihood of changing the port
    and IP is also very low.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于进程间通信以及访问特定服务，我们需要知道服务的端口和 IP 地址。传统的单体应用程序通常使用静态端口和 IP 地址进行部署和访问。此外，它们通常在一个单独的包中部署，这样所有组件/服务都可以使用相同的端口和
    IP 地址进行访问。端口和 IP 地址更改的可能性也非常低。
- en: In contrast, microservice applications are distributed in nature and may be
    deployed on different machines or in the cloud. Additionally, more instances of
    the services may be added to improve the scalability of the system. In future,
    new services may be added dynamically. Due to this, the locations of microservices
    are dynamic.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，微服务应用程序在本质上具有分布式特性，可能部署在不同的机器或云中。此外，可以通过添加更多服务实例来提高系统的可伸缩性。在未来，可能会动态地添加新服务。因此，微服务的位置是动态的。
- en: Spring Cloud provides a **service discovery** functionality, which is actually
    used to locate the services in the distributed environment. Spring Cloud provides
    a Netflix Eureka-based discovery service out of the box. Alternatively, we can
    use Consul, Cloud Foundry, or Apache ZooKeeper with Spring Cloud as service discovery
    support.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud 提供了一个**服务发现**功能，实际上用于在分布式环境中定位服务。Spring Cloud 默认提供基于 Netflix Eureka
    的发现服务。或者，我们也可以使用 Consul、Cloud Foundry 或 Apache ZooKeeper 与 Spring Cloud 结合作为服务发现支持。
- en: Circuit breakers
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熔断器
- en: Though microservices are designed to handle a single responsibility, they sometimes
    rely on other services to perform a set of actions owned by others. In this dependency
    channel, if one service goes down, the error will propagate to other services
    on the same channel. To avoid it, Spring Cloud provides a Netflix Hystrix-based
    fault tolerance solution, which is an implementation of the circuit breaker pattern.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管微服务被设计来处理单一职责，但它们有时需要依赖其他服务来执行属于他人的操作集。在这个依赖通道中，如果某个服务宕机，错误将会传播到同一通道上的其他服务。为了避免这种情况，Spring
    Cloud 提供了一个基于 Netflix Hystrix 的容错解决方案，这是电路断路器模式的一种实现。
- en: Routing
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由
- en: Since the location of microservices can be changed dynamically, a routing mechanism
    is required to send the request to the specific service endpoint. Spring Cloud
    provides a simple and effective way to route APIs with advanced cross-cutting
    capabilities such as security, monitoring, filtering, and authentication through
    Zuul—another tool from Netflix, which is a server-side load balancer that's used
    for routing purposes as well. Zuul can also be used as a micro proxy, which routes
    the application using the proxy URL that was configured.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微服务的位置可以动态更改，因此需要一个路由机制来将请求发送到特定的服务端点。Spring Cloud 通过 Zuul——来自 Netflix 的另一个工具，它是一个用于路由目的的服务器端负载均衡器——提供了一个简单而有效的方法来路由具有高级横切能力（如安全、监控、过滤和身份验证）的
    API。Zuul 还可以用作微代理，它使用配置的代理 URL 来路由应用程序。
- en: Another component used for routing is Spring Cloud Gateway, which is natively
    developed by Spring. It is built on Spring Framework 5 and may provide a better
    developer experience as it's closely integrated with Spring.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用于路由的组件是 Spring Cloud Gateway，它是 Spring 本地开发的。它基于 Spring Framework 5 构建，并且由于其与
    Spring 的紧密集成，可能为开发者提供更好的体验。
- en: Spring Cloud Security
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud 安全
- en: Though microservices are accessed with standard interfaces, they need authentication
    and authorization in some use cases. Securing a microservice system is more complex
    than securing a monolithic system. Spring supports authentication with microservices
    through Spring Cloud Security with the Auth2 protocol to propagate the security
    context across the microservices in a distributed environment.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管微服务通过标准接口访问，但在某些用例中它们需要身份验证和授权。保护微服务系统比保护单体系统更复杂。Spring 通过 Spring Cloud Security
    和 Auth2 协议支持微服务的身份验证，以在分布式环境中传播安全上下文。
- en: Distributed tracing service
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式跟踪服务
- en: In the microservice architecture, the application flow may pass through a chain
    of multiple service calls to execute a single business use case. Manually tracing
    the activities with the logs of multiple microservices is not an efficient solution.
    We may not get exactly what we want out of it. It is important to understand what
    is happening between the series of service call. This is quite helpful in debugging
    if an issue arises. Spring Cloud provides an effective way to trace the application
    flow in a distributed system through **Spring Cloud Sleuth**. It collects the
    call tracking data, which can be exported to **Zipkin**—another tool for visualizing
    the call trace.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，应用程序流程可能需要通过多个服务调用的链来执行单个业务用例。手动使用多个微服务的日志跟踪活动并不是一个有效的解决方案。我们可能无法从中得到我们想要的结果。理解一系列服务调用之间发生的事情非常重要。如果出现问题时，这非常有帮助。Spring
    Cloud 通过 **Spring Cloud Sleuth** 提供了一种有效的方法来跟踪分布式系统中的应用程序流程。它收集调用跟踪数据，这些数据可以导出到
    **Zipkin**——另一个用于可视化调用跟踪的工具。
- en: Spring Cloud Stream
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud Stream
- en: To handle the high volumes of data streams, we may need to work with message
    broker implementations such as RabbitMQ or Apache Kafka. Spring Cloud provides
    an easy integration of a message broker with a high-level abstraction through
    Spring Cloud Stream. So, instead of actually implementing the message broker,
    Spring Cloud Stream will handle the messages and pass them to the actual broker
    client at runtime, based on its configuration. This makes the code portable and
    loosely coupled with any message broker implementation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理大量数据流，我们可能需要与消息代理实现（如 RabbitMQ 或 Apache Kafka）合作。Spring Cloud 通过 Spring
    Cloud Stream 提供了与消息代理的高层抽象的简单集成。因此，我们不必实际实现消息代理，Spring Cloud Stream 将在运行时根据其配置处理消息并将它们传递给实际的代理客户端。这使得代码可移植，并且与任何消息代理实现松散耦合。
- en: Developing an online bookstore application
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发在线书店应用程序
- en: Now that we've looked at the microservice architecture, let's now do a practical exercise
    to understand the concept in more detail. We will follow the microservice pattern
    to develop a simple online bookstore application.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了微服务架构，让我们现在进行一个实际练习，以更详细地了解这个概念。我们将遵循微服务模式来开发一个简单的在线书店应用程序。
- en: Application architecture
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序架构
- en: We need to start by designing the application's architecture first. While designing
    microservice-based applications, first we need to think of a single monolithic
    application and then derive various parts or components that are independent of
    each other and can be thought of as possible candidates for being individual microservices.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要首先设计应用程序的架构。在设计基于微服务的应用程序时，我们首先需要考虑一个单体应用程序，然后推导出各种相互独立的部分或组件，这些部分或组件可以被视为可能的独立微服务候选。
- en: 'We will break the application into small parts based on the criteria we looked
    at in the previous sections, such as single responsibility, service autonomy,
    loose coupling, encapsulation, and DDD, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根据前几节中提到的标准，如单一职责、服务自治、松耦合、封装和DDD，将应用程序分解成小部分，具体如下：
- en: User management
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户管理
- en: Order management
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单管理
- en: Catalog management
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录管理
- en: Inventory management
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库存管理
- en: 'They are considered independent domains or business functions. We will create
    individual microservices for each of them with the following high-level architecture:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 它们被认为是独立的领域或业务功能。我们将为每个领域创建独立的微服务，并采用以下高级架构：
- en: '![](img/e4f061d5-1704-48f2-9542-48f117b862d6.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e4f061d5-1704-48f2-9542-48f117b862d6.png)'
- en: Database design
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库设计
- en: While decomposing the application to adopt the microservice architecture, we
    need to rethink database design as well. In a distributed environment, there are
    multiple options for database design.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在将应用程序分解以采用微服务架构时，我们还需要重新思考数据库设计。在分布式环境中，数据库设计有多种选择。
- en: Single monolithic database for all microservices
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所有微服务的单一单体数据库
- en: 'In this approach, though the microservices are independently designed as a
    separate subsystem, they still share a single monolithic database, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，尽管微服务被独立设计为单独的子系统，但它们仍然共享一个单一的单体数据库，如下所示：
- en: '![](img/1cfdb862-0c96-49ab-b189-d552314e7e2e.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1cfdb862-0c96-49ab-b189-d552314e7e2e.png)'
- en: Each microservice has its own set of tables, but all are part of a single database
    schema. The clear benefit of this option is simplicity, as a single database can
    be operated with ease. Also, transactions can be carried out in a more consistent
    way.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务都有自己的表集，但它们都是单一数据库模式的一部分。这种选择的明显优势在于简单性，因为单个数据库可以轻松操作。此外，事务可以以更一致的方式进行。
- en: However, according to best practices, microservice should be independently deployable
    to get better scaling optimization. Another benefit of being independently deployable
    is the quick adoption of changes. As soon as multiple services depend on a single
    monolithic data store, this flexibility is reduced to take full advantage of the
    distributed environment, such as high cohesion and loose coupling.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，根据最佳实践，微服务应该是独立可部署的，以获得更好的扩展优化。独立可部署的另一个好处是快速采用变化。一旦多个服务依赖于单个单体数据存储，这种灵活性就会降低，无法充分利用分布式环境，如高内聚和松耦合。
- en: Also, multiple teams generally work on the application side. They also need
    to face coupling with other teams while dealing with database changes. This will
    slow down the development and eventually add a delay in delivery. So, this is
    not an ideal scenario.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，多个团队通常在应用程序方面工作。在处理数据库变更时，他们还需要面对与其他团队的耦合。这将减缓开发速度，并最终导致交付延迟。因此，这不是一个理想的场景。
- en: Separate service to handle database interaction
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分离的服务来处理数据库交互
- en: 'In this scenario, instead of sharing a common database with all services, a
    separate service will be developed that will interact with the database only.
    All other services will talk to this service for any database operations instead
    of directly connecting with the database, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，我们不会与所有服务共享一个公共数据库，而是一个单独的服务将仅与数据库交互。所有其他服务都将通过这个服务进行任何数据库操作，而不是直接连接到数据库，如下所示：
- en: '![](img/02ad11c0-408e-45f7-a251-6a0a9b7d861b.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/02ad11c0-408e-45f7-a251-6a0a9b7d861b.png)'
- en: Though the dependency of managing database-related actions is shifted to a separate
    service, it is still kind of a monolithic approach and has all the limitations
    of the first option. So, this is also not an optimized way to design the database
    for a microservice architecture.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然管理数据库相关操作的依赖关系已转移到单独的服务中，但这仍然是一种类似单体式的方法，并且具有第一个选项的所有局限性。因此，这也不是为微服务架构设计数据库的优化方式。
- en: Each microservice has its own database
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个微服务都有自己的数据库
- en: 'This option has a separate database for each individual service, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项为每个独立服务提供单独的数据库，如下所示：
- en: '![](img/c8262572-6f27-411d-8f99-e3d003a07825.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c8262572-6f27-411d-8f99-e3d003a07825.png)'
- en: Instead of a single shared database across services, each service's database
    is an integral part of that service and cannot be accessed by other services directly.
    Another flexibility in this option is that each service is allowed to choose the
    type of data store that is the best fit for its capabilities. For example, if
    you have a search service, to perform the search in the system, you can use **Elasticsearch**
    as a data store.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与服务之间共享单个数据库不同，每个服务的数据库是该服务的一个组成部分，并且不能被其他服务直接访问。这种选择的一个灵活性在于，每个服务都可以选择最适合其能力的数据存储类型。例如，如果你有一个搜索服务，要在系统中执行搜索，你可以使用**Elasticsearch**作为数据存储。
- en: 'This model has two further options:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此模型有两个进一步的选择：
- en: '**Individual database schema per service:** Still use a single database server,
    but have a separate schema for each microservice. This option makes ownership
    cleaner, and it is an ideal option for most cases.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每个服务独立的数据库架构**：仍然使用单个数据库服务器，但为每个微服务有一个独立的架构。此选项使所有权更清晰，并且对于大多数情况来说是一个理想的选项。'
- en: '**Individual database server per service:** Design separate database servers
    for each microservice. This option can be considered for services that require
    high throughput.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每个服务独立的数据库服务器**：为每个微服务设计独立的数据库服务器。对于需要高吞吐量的服务，可以考虑此选项。'
- en: For simplicity, we will use MySQL to store the data. As per the system architecture,
    there will be a separate database schema for each microservice.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们将使用MySQL来存储数据。根据系统架构，每个微服务将有一个独立的数据库架构。
- en: User schema
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户架构
- en: 'This schema contains the tables that store user-related data. The **user**
    table holds user-specific data, which will be used for authentication, while the
    **delivery_address** table contains delivery address information:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此架构包含存储用户相关数据的表。**用户**表包含特定于用户的数据，这些数据将用于身份验证，而**配送地址**表包含配送地址信息：
- en: '![](img/7c432a3d-4f22-4b60-b66c-871a24a7dec1.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7c432a3d-4f22-4b60-b66c-871a24a7dec1.png)'
- en: There is a *one-to-many *relationship between the **user** and **delivery_address**
    tables.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户**表和**配送地址**表之间存在**一对一**的关系。'
- en: Order schema
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订单架构
- en: 'This schema contains two tables, **order** and **order_item**. The relationship
    between them is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此架构包含两个表，**订单**和**订单项**。它们之间的关系如下：
- en: '![](img/8d60f603-f7e3-46ba-9840-8ca9911869a1.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8d60f603-f7e3-46ba-9840-8ca9911869a1.png)'
- en: The **order** table holds the generic details of each order, such as orderId,
    userId, order date, total amount, and shipping address. The **order_item** table
    saves individual item details.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**订单**表包含每个订单的通用详细信息，如orderId、userId、订单日期、总金额和配送地址。**订单项**表保存单个项目的详细信息。'
- en: Catalog schema
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目录架构
- en: 'This schema contains the product details. Since this is an online bookstore
    application, the **book** table contains details of the book. The **category**
    and **publisher** tables contain details about categories and publishers respectively.
    The relationship between these tables is as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此架构包含产品详情。由于这是一个在线书店应用程序，**书籍**表包含书籍的详细信息。**类别**和**出版社**表分别包含关于类别和出版社的详细信息。这些表之间的关系如下：
- en: '![](img/1d912f18-69b8-4c08-8648-9a8aef0d02bc.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1d912f18-69b8-4c08-8648-9a8aef0d02bc.png)'
- en: The **book** table has a *many-to-one* relationship to the **category** and
    **publisher** tables.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**书籍**表与**类别**和**出版社**表之间存在**多对一**的关系。'
- en: Inventory schema
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库存架构
- en: 'Every store has an inventory. This schema stores the inventory containing information
    about the books. There are two tables that store this information. The **inventory**
    table contains the current stock of the product (books in our case), while the **inventory_history**
    table shows the history of adding new books into the system:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 每个商店都有一个库存。此架构存储包含关于书籍信息的库存。有两个表存储此信息。**库存**表包含产品的当前库存（在我们的例子中是书籍），而**库存历史**表显示了将新书添加到系统中的历史记录：
- en: '![](img/3076c017-f24e-4e23-ac82-11822265584d.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3076c017-f24e-4e23-ac82-11822265584d.png)'
- en: There is no relation between these tables.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些表之间没有关系。
- en: Creating microservices with Spring Boot
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Boot创建微服务
- en: We are going to develop an online bookstore application with an architecture
    of small and independently deployable microservices that can be developed by individual
    teams. They are expected to be developed with a quick turnaround time. This is
    what Spring Boot is designed for. It is a tool used to create production-grade
    Spring-based enterprise applications with a little configuration in no time.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个在线书店应用程序，该应用程序具有小型且可独立部署的微服务架构，这些微服务可以由各个团队开发。预计它们将以快速的开发周期完成。这正是Spring
    Boot的设计目的。它是一个用于在短时间内创建生产级Spring企业应用程序的工具，配置简单。
- en: We will first develop individual services with Spring Boot to develop them quickly.
    Spring Cloud also has solid integration capabilities with Spring Boot. While developing
    microservices, Spring Boot takes care of all the low-level things and allows us
    to concentrate on the business logic.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用Spring Boot开发单个服务以快速开发它们。Spring Cloud也与Spring Boot具有坚实的集成能力。在开发微服务时，Spring
    Boot负责所有底层事情，使我们能够专注于业务逻辑。
- en: 'First, we will create Spring Boot applications for specific functionalities.
    Once they are created, we will then add microservice-specific capabilities to
    each of them:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将为特定功能创建Spring Boot应用程序。一旦创建，我们将在每个应用程序中添加微服务特定的功能：
- en: '`user-service`: This service is intended to execute various operations related
    to users, such as registration, login, and user interaction'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user-service`: 此服务旨在执行与用户相关的各种操作，例如注册、登录和用户交互'
- en: '`inventory-service`: This service performs various inventory operations performed
    by admin only'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inventory-service`: 此服务仅由管理员执行各种库存操作'
- en: '`catalog-service`: This service is responsible for managing catalog information
    such as adding books, categories, and publisher details'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog-service`: 此服务负责管理目录信息，例如添加书籍、类别和出版社详情'
- en: '`order-service`: This service handles orders placed by a user'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`order-service`: 此服务处理用户下订单'
- en: 'While creating an application with either the spring-io initializer or **Spring
    Tool Suite** (**STS**, an Eclipse-based IDE provided by Spring), initially we
    will add following dependencies:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用spring-io初始化器或**Spring Tool Suite**（**STS**，由Spring提供的基于Eclipse的IDE）创建应用程序时，最初我们将添加以下依赖项：
- en: '**DevTools**: Used to improve the development time experience by adding auto-deploy/restart
    capabilities as a Maven dependency.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DevTools**: 通过添加自动部署/重启功能作为Maven依赖项来提高开发时间体验。'
- en: '**JPA**: This will add a JPA-specific starter dependency, which is used to
    add JPA capabilities. We are going to use JPA (Hibernate implementation) to interact
    with the database.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JPA**: 这将添加一个特定于JPA的启动依赖项，用于添加JPA功能。我们将使用JPA（Hibernate实现）与数据库交互。'
- en: '**MySQL**: This will add a MySQL connector JAR to connect to the database.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MySQL**: 这将添加一个MySQL连接器JAR以连接到数据库。'
- en: '**Web**: This is used to add Spring MVC capabilities to the application. We
    will use a REST controller to access individual microservice applications.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web**: 这用于向应用程序添加Spring MVC功能。我们将使用REST控制器来访问单个微服务应用程序。'
- en: Adding microservice-specific capabilities
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加微服务特定功能
- en: We have created various Spring Boot applications for each individual functionality.
    They all are accessible (by default) on port `8080` one by one. However, they
    are not ready to be executed as microservices. Now we will add microservice-specific
    capabilities by adding a dependencies entry in the `pom.xml` file of each individual
    Spring Boot application.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个单独的功能创建了各种Spring Boot应用程序。它们默认情况下都可以逐个访问（在端口`8080`上）。然而，它们还没有准备好作为微服务执行。现在，我们将通过在每个Spring
    Boot应用程序的`pom.xml`文件中添加依赖项条目来添加微服务特定的功能。
- en: 'Add the following entry in the `dependencies` section of `pom.xml`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pom.xml`的`dependencies`部分添加以下条目：
- en: '[PRE0]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You also need to add an entry for the current version of Spring Cloud next
    to the `<java-version>` entry as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要在`<java-version>`条目旁边添加当前版本的Spring Cloud条目，如下所示：
- en: '[PRE1]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following entry after the `dependencies` section is complete in `pom.xml`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pom.xml`的`dependencies`部分完成后添加以下条目：
- en: '[PRE2]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Make these changes in all four Spring Boot applications that we have developed.
    After applying these changes, they will no longer run independently as Spring
    Boot applications because we are now moving towards a microservice architecture.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开发的四个 Spring Boot 应用程序中都要进行这些更改。应用这些更改后，它们将不再作为独立的 Spring Boot 应用程序运行，因为我们现在正朝着微服务架构迈进。
- en: Develop a service discovery server
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发服务发现服务器
- en: The real challenge in a microservice architecture is to access particular services
    because they are dynamically created and destroyed, so their location keeps changing.
    Additionally, we also need some sort of inter-service communication to fulfill
    certain business use cases that span the microservices. Also, multiple instances
    of each microservice can be created to scale up the application's performance.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，真正的挑战是访问特定的服务，因为它们是动态创建和销毁的，所以它们的位置不断变化。此外，我们还需要某种类型的服务间通信，以满足跨越微服务的某些业务用例。此外，每个微服务的多个实例可以创建以扩展应用程序的性能。
- en: In this situation, there must be a mechanism for locating the microservices.
    Spring Cloud provides a Netflix Eureka-based service discovery component for this
    purpose. Microservices can register themselves with the discovery server so that
    they can be accessed and interacted with by other services. Eureka Server is basically
    used for discovery, self-registration, and load balancing.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，必须有一种机制来定位微服务。Spring Cloud 提供了一个基于 Netflix Eureka 的服务发现组件来实现这一目的。微服务可以自行注册到发现服务器，以便其他服务可以访问和与之交互。Eureka
    服务器基本上用于发现、自我注册和负载均衡。
- en: 'Next up is to create a Eureka-based service that acts as a **service discovery
    server**. Creating a Eureka-based discovery service is similar to creating Spring
    Boot application with just a few configuration changes. Create a new Spring starter
    project with the following data:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来需要创建一个基于 Eureka 的服务，该服务充当**服务发现服务器**。创建基于 Eureka 的发现服务类似于仅通过少量配置更改创建 Spring
    Boot 应用程序。使用以下数据创建一个新的 Spring Starter 项目：
- en: '![](img/d4906690-2cc9-49f8-aac4-c10aabbf09bf.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d4906690-2cc9-49f8-aac4-c10aabbf09bf.png)'
- en: 'On next screen, select Eureka Server under the Cloud Discovery option as a
    dependency and click Finish. Once the project is created, open the `bootstrap`
    class and add the code highlighted in bold as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一屏幕上，选择“云发现”选项下的 Eureka 服务器作为依赖项，然后点击完成。一旦项目创建完成，打开 `bootstrap` 类，并按照以下方式添加突出显示的代码：
- en: '[PRE3]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'By default, the Eureka Server option is not enabled. The `@EnableEurekaServer`
    annotation is used to make it active for this application. That means this application
    will run as a Eureka discovery server. Next, we will add certain properties in
    the `application.properties` file as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Eureka 服务器选项未启用。使用 `@EnableEurekaServer` 注解使其对应用程序生效。这意味着该应用程序将作为一个 Eureka
    发现服务器运行。接下来，我们将在 `application.properties` 文件中添加某些属性，如下所示：
- en: '[PRE4]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By default, the current Eureka server is also a Eureka client and will try to
    register itself as a Eureka client with the Eureka server. Since we want this
    application to behave as a server only, we need to explicitly set the `eureka.client.registerWithEureka`
    property to `false`. By default, Eureka server is accessible through port `8080`
    and it can be changed with the `server.port` property.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当前的 Eureka 服务器也是一个 Eureka 客户端，并会尝试将自己注册为 Eureka 服务器上的 Eureka 客户端。由于我们希望这个应用程序仅作为服务器运行，我们需要显式设置
    `eureka.client.registerWithEureka` 属性为 `false`。默认情况下，Eureka 服务器通过端口 `8080` 可访问，并且可以使用
    `server.port` 属性进行更改。
- en: 'Each Eureka client will fetch registry details from Eureka server. In our case,
    we do not want to fetch the registry details, so, we explicitly set the `eureka.client.fetch-registry`
    property to `false`. Now run the application, and Eureka Server is accessible
    through `http://localhost:8761`. It will show the server details and all registered
    service details, as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Eureka 客户端将从 Eureka 服务器获取注册详情。在我们的案例中，我们不想获取注册详情，因此，我们显式设置 `eureka.client.fetch-registry`
    属性为 `false`。现在运行应用程序，Eureka 服务器可通过 `http://localhost:8761` 访问。它将显示服务器详情和所有注册的服务详情，如下所示：
- en: '![](img/9936ba3b-c502-41cc-8bb9-9a57b39229e4.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9936ba3b-c502-41cc-8bb9-9a57b39229e4.png)'
- en: Currently, no services are registered with our Eureka discovery server, so it
    shows nothing in the Instances currently registered with Eureka section.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的 Eureka 发现服务器上尚未注册任何服务，因此在“当前注册到 Eureka 的实例”部分中显示无内容。
- en: Eureka Server can be started in standalone or clustered mode. For simplicity,
    we have chosen standalone mode.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Eureka 服务器可以以独立模式或集群模式启动。为了简单起见，我们选择了独立模式。
- en: 'Next up is to register the four microservices that we have developed with the
    Eureka discovery server. We have already added microservice-specific dependencies
    to them. Now, we need to add the Eureka client configurations. Because of the
    way we have configured Eureka server, we need to configure the Eureka client in
    each of the service''s `bootstrap` classes. For example, the Eureka client configuration
    for the user service''s bootstrap class is highlighted in bold as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将我们开发的四个微服务注册到 Eureka 发现服务器。我们已经为它们添加了微服务特定的依赖项。现在，我们需要添加 Eureka 客户端配置。由于我们配置了
    Eureka 服务器的方式，我们需要在每个服务的 `bootstrap` 类中配置 Eureka 客户端。例如，用户服务 `bootstrap` 类的 Eureka
    客户端配置如下以粗体突出显示：
- en: '[PRE5]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `@EnableDiscoveryClient` annotation will enable client configuration. Additionally,
    we need to add the following properties in the `application.properties` file:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`@EnableDiscoveryClient` 注解将启用客户端配置。此外，我们还需要在 `application.properties` 文件中添加以下属性：'
- en: '[PRE6]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `spring.application.name` property will be used to register the application
    with a specific name. Add client configurations and start other services, and
    you will see them registered with Eureka server as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`spring.application.name` 属性将用于将应用程序注册为具有特定名称。添加客户端配置并启动其他服务，你将看到它们如下注册到 Eureka
    服务器：'
- en: '![](img/a7f7bb03-bb50-42a1-8161-f6f5f4c0d7bd.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a7f7bb03-bb50-42a1-8161-f6f5f4c0d7bd.png)'
- en: Another annotation, `@EnableEurekaClient`, can also be used for Eureka client
    configuration. The difference between `@EnableDiscoveryClient` and `@EnableEurekaClient`
    is that the former is more Spring-aware and works with discovery implementations
    other than Eureka, such as Consul and ZooKeeper; the latter is specific to Eureka
    only. So, if Eureka is present in the classpath, there is no difference between
    them.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个注解 `@EnableEurekaClient` 也可以用于 Eureka 客户端配置。`@EnableDiscoveryClient` 和 `@EnableEurekaClient`
    之间的区别在于前者更具有 Spring 意识，并且与 Eureka 之外的发现实现（如 Consul 和 ZooKeeper）一起工作；后者仅针对 Eureka。因此，如果类路径中有
    Eureka，它们之间没有区别。
- en: Spring Cloud Eureka consists of client and server components. All the microservices
    are registered in the server registry, whereas each individual service behaves
    as a client. Any service that wants to discover other services should also be
    Eureka client-aware. The registration in the server happens with client identity
    (with its name) and URL (with its port).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Eureka 由客户端和服务器组件组成。所有微服务都注册在服务器注册表中，而每个单独的服务都表现为客户端。任何想要发现其他服务的服务也应该对
    Eureka 客户端有意识。注册在服务器上发生时，使用客户端标识（及其名称）和 URL（及其端口）。
- en: 'The flow of communication between client and server happens as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端与服务器之间的通信流程如下：
- en: On starting the microservice, it reaches out to the server component and provides
    metadata for registration.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在启动微服务时，它将联系服务器组件并提供注册所需的元数据。
- en: Eureka server validates the metadata and does the registration.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Eureka 服务器验证元数据并进行注册。
- en: After registration, the microservice endpoint sends the ping to the server registry
    every 30 seconds (by default) to mark its presence.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册后，微服务端点每 30 秒（默认值）向服务器注册表发送 ping 请求以标记其存在。
- en: The server will continuously verify the ping requests, and if no request comes
    for a certain period of time, it will remove the service from the registry automatically.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器将不断验证 ping 请求，如果在一定时间内没有请求，它将自动从注册表中删除该服务。
- en: The server shares the registry information with all Eureka-aware clients, and
    they store it in the local cache. This information is then used by a microservice
    client to locate other clients in the distributed environment.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器将注册信息与所有 Eureka 意识的客户端共享，并将它们存储在本地缓存中。然后，微服务客户端使用这些信息在分布式环境中定位其他客户端。
- en: The server pushes the updates of registry information to all clients every 30
    seconds (by default).
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器每 30 秒（默认值）将注册信息的更新推送到所有客户端。
- en: Microservices registered with a server can be grouped into a zone. In this case,
    the zone information can be supplied at registration.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务器上注册的微服务可以被分组到一个区域中。在这种情况下，区域信息可以在注册时提供。
- en: When any microservice sends a request for another microservice, Eureka server
    will try to search service instances running in the same zone to reduce the latency.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当任何微服务向另一个微服务发送请求时，Eureka 服务器将尝试在同一区域内搜索运行的服务实例以减少延迟。
- en: The interaction between the Eureka client and server happens through REST and
    JSON.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Eureka 客户端与服务器之间的交互通过 REST 和 JSON 进行。
- en: Designing an API gateway
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计 API 网关
- en: 'In typical microservice applications, it is quite possible that more than a
    hundred microservices are interacting with each other. There are certain common
    features that are required to be implemented for all these microservices:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的微服务应用中，可能存在超过一百个微服务相互交互的情况。对于所有这些微服务，需要实现一些共同的特性：
- en: '**Security**: We may need to check that authentication and authorization, or
    any other security policies required to make calls to microservices'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：我们可能需要检查认证和授权，或任何其他用于调用微服务的安全策略'
- en: '**Restrict call rate**: This allows only a certain number of calls for a specific
    microservice in a given time'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限制调用频率**：在给定时间内，只允许特定微服务进行一定数量的调用'
- en: '**Fault toleration**: If any service fails to respond, this sends an appropriate
    error signal'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容错**：如果任何服务无法响应，则发送适当的错误信号'
- en: '**Monitor**: This is used to monitor for specific events or values passed across
    the microservices'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控**：用于监控微服务间传递的特定事件或值'
- en: '**Service aggregation**: This provides an aggregate response from multiple
    microservices in a single response, specifically in a bandwidth-restricted environment'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务聚合**：在单个响应中提供多个微服务的聚合响应，特别是在带宽受限的环境中'
- en: '**Routing**: Based on certain criteria (if call forwarding is required, for
    example), route all the calls from a specific user to a particular region to a
    specific service'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由**：基于某些标准（例如，如果需要调用转发），将特定用户的所有调用路由到特定区域的服务'
- en: '**Load balancing**: This maintains the flow of calls to balance the load on
    the service instance'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载均衡**：维护调用流以平衡服务实例的负载'
- en: Apart from this, we may want to restrict some of the services to end users and
    keep them private. To achieve these goals, we need some sort of API gateway, which
    will intercept all the calls from end users and all inter-service communication. So,
    instead of microservices talking with each other directly through REST calls,
    they will now interact with each other through an API gateway, which will provide
    all the features previously listed. Since all the calls are routed from the API
    gateway, it can also be used for debugging and analytic purposes.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，我们可能还想限制一些服务对最终用户的访问并保持其私有。为了实现这些目标，我们需要某种形式的API网关，它将拦截来自最终用户的所有调用以及所有服务间通信。因此，微服务现在将通过API网关直接通过REST调用相互交互，该网关将提供之前列出的所有功能。由于所有调用都通过API网关路由，它也可以用于调试和分析目的。
- en: Spring Cloud provides API gateway support through another Netflix implementation
    called **Zuul**. Next up, let's see how to set up Zuul.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud通过另一个名为**Zuul**的Netflix实现提供API网关支持。接下来，我们将看看如何设置Zuul。
- en: Setting up Zuul as an API gateway
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Zuul作为API网关
- en: We will create a Zuul proxy server as an independent Spring Boot service and
    register it with the Eureka discovery server. Create a new Spring starter project
    in Spring STS with Zuul, Eureka Discovery, and DevTool as dependencies.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个Zuul代理服务器作为一个独立的Spring Boot服务，并将其注册到Eureka发现服务器。在Spring STS中创建一个新的Spring启动项目，并添加Zuul、Eureka发现和DevTool作为依赖项。
- en: 'Once created, open the `bootstrap` class and update it as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，打开`bootstrap`类并按照以下方式更新：
- en: '[PRE7]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `@EnableZuulProxy` annotation will make this service a Zuul server. We
    also need to register it with the Eureka discovery server with the `@EnableDiscoveryClient`
    annotation. Every service registered with the Eureka name server needs a name
    (and a port). Add these details for the Zuul server in the `application.properties`
    file as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`@EnableZuulProxy`注解将使此服务成为Zuul服务器。我们还需要使用`@EnableDiscoveryClient`注解将其注册到Eureka发现服务器。每个注册到Eureka名称服务器的服务都需要一个名称（以及一个端口）。在`application.properties`文件中添加以下详细信息以设置Zuul服务器：'
- en: '[PRE8]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now the API gateway server is ready and configured, but we did not specify what
    to do when intercepting requests. Zuul provides request handling support through
    various filters. They are categories in pre, post, routing, and error filters,
    each targeted for specific service call life cycles. Since Zuul is a Spring Boot-based
    service, we can customize the API gateway programmatically. Additionally, for
    any special requirement, Zuul supports developing custom filters. We will see
    how to add custom filters and examine how requests can be intercepted with it
    in a short while.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在API网关服务器已经准备好并配置好了，但我们没有指定在拦截请求时应该做什么。Zuul通过各种过滤器提供请求处理支持。它们被分类为预、后、路由和错误过滤器，每个都针对特定的服务调用生命周期。由于Zuul是基于Spring
    Boot的服务，我们可以通过编程方式自定义API网关。此外，对于任何特殊需求，Zuul支持开发自定义过滤器。我们将很快看到如何添加自定义过滤器，并检查如何使用它拦截请求。
- en: The Zuul API gateway server is also referred to as an Edge server.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Zuul API网关服务器也被称为边缘服务器。
- en: Designing the UI
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计UI
- en: As we have seen, the microservice architecture is the best fit for modern applications
    that are big and distributed in nature. This type of architecture helps split
    the team that's working on a single monolithic application into a set of small
    and independent teams, focusing on one single module or functionality.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，微服务架构最适合现代大型且本质上分布式的应用。这种架构有助于将单一单体应用的团队拆分为一组小型且独立的团队，专注于单个模块或功能。
- en: 'A microservice pattern has its own benefits, such as managing scalability and
    complexity, and easily adopting new changes in a short time frame. We have explored
    how Spring Cloud components help build a distributed application in the Spring
    Framework. So far, we have only talked about the middle and backend layers. This
    section is dedicated to an interesting topic: how to design a microservice frontend.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务模式有其自身的优势，例如管理可伸缩性和复杂性，以及在短时间内轻松采用新变化。我们已经探讨了Spring Cloud组件如何帮助在Spring框架中构建分布式应用。到目前为止，我们只讨论了中间和后端层。本节专门讨论一个有趣的话题：如何设计微服务前端。
- en: 'Unlike monolithic architectures, the frontend of a microservice application
    can be designed with different approaches, as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 与单体架构不同，微服务应用的前端可以采用不同的方法，如下所示：
- en: Monolithic front
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单体前端
- en: Micro front
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微前端
- en: Composite or modular front
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合或模块化前端
- en: Monolithic front
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单体前端
- en: 'Though the microservice pattern divides the monolithic backend into multiple
    independent services, this may not be straightforward for the frontend. In the
    monolithic front approach, we keep the whole user interface in a single big frontend
    application that will talk to corresponding services through REST calls to perform
    tasks or to show data to the end user, as per the following diagram:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然微服务模式将单体后端划分为多个独立的服务，但对于前端来说这可能并不简单。在单体前端方法中，我们将整个用户界面保持在单个大型前端应用程序中，该应用程序将通过REST调用与对应的服务通信以执行任务或向最终用户展示数据，如下所示：
- en: '![](img/c86ced6f-0e67-4947-a5ac-6a7c40309ecb.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c86ced6f-0e67-4947-a5ac-6a7c40309ecb.png)'
- en: The clear benefits of this approach are an easy implementation and UI consistency
    across the application because everything is in a single place. On the downside,
    there may be a good amount of conflict regarding library versions, styling, and
    so on, as multiple teams are working on a single UI application.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的明显优势是实现简单和整个应用中的UI一致性，因为所有内容都在一个地方。缺点是，由于多个团队正在单个UI应用上工作，可能会出现大量关于库版本、样式等问题上的冲突。
- en: Since everything is under one roof, it becomes harder to adopt changes as the
    application grows. Over a period of time, when business demand increases, it eventually
    becomes harder to maintain the application's UI as multiple teams spend most of
    their time solving problems.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有内容都在一个屋檐下，随着应用的扩展，采用变化变得更加困难。在一段时间内，当业务需求增加时，维护应用的UI变得更加困难，因为多个团队大部分时间都在解决问题。
- en: Choose this approach only when you are sure that the application is divided
    into just a few microservices with limited scope for growth in the future.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当你确信应用仅被划分为几个具有有限未来增长范围的微服务时，才选择这种方法。
- en: Micro front
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微前端
- en: 'In this approach, each microservice has its own UI limited to the functionality
    it performs. So, along with the backend, the frontend is also decomposed as per
    the scope of the individual microservices, as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，每个微服务都有自己的UI，限于其执行的功能。因此，除了后端之外，前端也根据单个微服务的范围进行分解，如下所示：
- en: '![](img/107ebd29-6907-433e-b8c9-80b55929a67d.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/107ebd29-6907-433e-b8c9-80b55929a67d.png)'
- en: 'This approach eliminates all the limitations of the monolithic frontend but
    then introduces certain new challenges. Though microservices are split as self-contained
    and independent executable units, and the final frontend should be presented with
    a single interface. In the micro front approach, the challenge is to combine the
    UIs of individual microservices in a single format. There are a number of ways
    of doing this. Though they overcome the limitations of the first approach, they
    introduce certain other issues:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法消除了单体前端的所有限制，但同时也引入了一些新的挑战。尽管微服务被分割成自包含和独立的可执行单元，并且最终的前端应该以单个接口呈现。在微前端方法中，挑战在于将单个微服务的UI组合成单一格式。有几种实现方式。尽管它们克服了第一种方法的限制，但同时也引入了一些其他问题：
- en: '**Synchronize the UI across the microservices:** In this way, just copy and
    paste the UI of all services to each other and use the API gateway. Though this
    seems simple, it produces huge maintenance issues.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在微服务之间同步UI：**通过这种方式，只需将所有服务的UI复制粘贴到对方，并使用API网关。尽管这似乎很简单，但它会产生巨大的维护问题。'
- en: '**IFrame:** Use a separate layout where the output of individual microservices
    can be clubbed with IFrame. However, this approach is also not brilliant because
    IFrame has its own limitations.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IFrame：**使用一个单独的布局，其中可以结合单个微服务的输出和IFrame。然而，这种方法也不完美，因为IFrame有其自身的限制。'
- en: '**HTML fragments:** You can write your own JavaScript code and glue the content
    of the microservices through HTML fragments. However, there are some limitations,
    and also lots of custom script you have to write on your own. Also, there may
    be a chance of services'' scripts and styles clashing.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTML片段：**你可以编写自己的JavaScript代码，并通过HTML片段粘合微服务的内 容。然而，存在一些限制，并且你还需要自己编写大量的自定义脚本。此外，还可能存在服务脚本和样式的冲突。'
- en: Composite front
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复合前端
- en: 'This approach is a micro font approach with the right solution to aggregate
    the microservice output. The layout will be created with a single UI application,
    whereas the business UI of individual microservices will be plugged in from of
    web components, as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法是一种微前端方法，具有正确聚合微服务输出的解决方案。布局将通过单个UI应用程序创建，而各个微服务的业务UI将通过Web组件插入，如下所示：
- en: '![](img/73dda3ad-a484-4091-910a-a683ad891fa5.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73dda3ad-a484-4091-910a-a683ad891fa5.png)'
- en: Each microservice is responsible for producing a small UI area on the page.
    Composite UIs can be easily designed by creating a component in popular frontend
    frameworks such as Angular and React. On top of this, a framework such as *single-spa*
    ([https://single-spa.js.org](https://single-spa.js.org)) is designed to show aggregate
    output. It is basically a JavaScript library that shows a composite output of
    microservices as a single-page application running in a browser. Single-spa allows
    the coexistence of microservices developed in different frameworks.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务负责在页面上生成一个小UI区域。可以通过在流行的前端框架（如Angular和React）中创建组件来轻松设计复合UI。在此基础上，*single-spa*（[https://single-spa.js.org](https://single-spa.js.org)）框架被设计用来展示聚合输出。它基本上是一个JavaScript库，将微服务的复合输出作为一个在浏览器中运行的单一页面应用程序显示。Single-spa允许不同框架开发的微服务共存。
- en: This means that you can develop one microservice in Angular, a second in React,
    a third with Vue, and so on. This brings great flexibility and fulfills the aim
    of the microservice architecture being developed completely independently from
    the backend to the UI. As an enhanced version of the second approach, the composite
    font approach not only overcomes the limitation of the monolithic front approach
    but also suggests the right way to develop the front layer in a microservice architecture.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以用Angular开发一个微服务，用React开发第二个，用Vue开发第三个，以此类推。这带来了极大的灵活性，并实现了微服务架构完全独立于后端到UI的开发目标。作为第二种方法的增强版本，复合前端方法不仅克服了单体前端方法的限制，而且还提出了在微服务架构中开发前端层的正确方式。
- en: Other Spring Cloud and Netflix OSS components
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他Spring Cloud和Netflix OSS组件
- en: Spring Cloud provides a wrapper on top of various Netflix components that are
    used in microservice applications extensively. We have already explored the Eureka
    discovery server and Zuul. In this section, we will explore a few more Netflix
    OSS components, along with other Spring Cloud features.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud在微服务应用中广泛使用的各种Netflix组件之上提供了一个包装器。我们已经探讨了Eureka发现服务器和Zuul。在本节中，我们将探讨更多Netflix
    OSS组件，以及Spring Cloud的其他功能。
- en: Dynamic configuration in Spring Cloud
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud中的动态配置
- en: As we know, the microservice architecture consists of a number of small and
    independently deployable microservices that handle end-user calls and interact
    with each other. Based on the project's needs, they may run in various environments,
    such as development, testing, staging, production, and so on. To improve the scaling
    capabilities of an application, there may be multiple instances of microservices
    configured to work with the load balancer.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，微服务架构由许多小型且可独立部署的微服务组成，它们处理最终用户调用并相互交互。根据项目需求，它们可能运行在各种环境中，如开发、测试、预发布、生产等。为了提高应用程序的扩展能力，可能配置了多个微服务实例与负载均衡器一起工作。
- en: Each microservice possesses a set of configurations, including database configurations,
    interaction with other services, message broker configurations, and custom configurations.
    Handling microservice configurations between various environments is one of the
    most challenging parts of a microservice architecture.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务都有一组配置，包括数据库配置、与其他服务的交互、消息代理配置和自定义配置。在各个环境之间处理微服务配置是微服务架构中最具挑战性的部分之一。
- en: Maintaining each microservices configuration manually would be too complex and
    difficult for the operations team. The best possible solution is to separate the
    configuration out from each microservice and maintain them all in one central
    place. This way, the dependency of environments on configuration can be handled
    more effectively.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 手动维护每个微服务的配置对于运维团队来说太复杂且困难。最佳解决方案是将配置从每个微服务中分离出来，并将它们全部维护在一个中央位置。这样，可以更有效地处理环境对配置的依赖。
- en: 'Spring Cloud provides a component called **Spring Cloud Config**, which is
    used to externalize the microservice configuration. It uses a Git repository to
    store all the configurations in one place, as shown in the following diagram:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud提供了一个名为**Spring Cloud Config**的组件，用于外部化微服务配置。它使用Git仓库将所有配置存储在一个地方，如下面的图所示：
- en: '![](img/ad89b25b-5d72-4f41-8b14-386b396e11b6.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ad89b25b-5d72-4f41-8b14-386b396e11b6.png)'
- en: We will create a separate service for central configuration with the Spring
    Cloud Config feature. The next few sections explain how to do this.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Spring Cloud Config功能创建一个用于集中配置的独立服务。接下来的几节将解释如何做到这一点。
- en: Step 1 – creating a Spring Boot service for the configuration server
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1步 – 创建配置服务器的Spring Boot服务
- en: 'This is the most straightforward way of creating a component as a Spring Boot
    application. Create an application with STS and select the DevTool and Config
    server dependencies. Once the project is created, you can see the dependency in
    `pom.xml` that is responsible for adding Spring Cloud Config capabilities to the
    Spring Boot application, as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将组件作为Spring Boot应用程序创建的最直接方法。使用STS创建一个应用程序，并选择DevTool和Config server依赖项。一旦项目创建完成，你可以在`pom.xml`中看到负责将Spring
    Cloud Config功能添加到Spring Boot应用程序的依赖项，如下所示：
- en: '[PRE9]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next up, let''s enable the Spring Cloud Config feature. Open the main `bootstrap`
    class and add the `@EnableConfigServer` annotation, which is used to enable external
    configuration:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们启用Spring Cloud Config功能。打开主`bootstrap`类，并添加`@EnableConfigServer`注解，用于启用外部配置：
- en: '[PRE10]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Since the configuration server will also be registered with the naming server
    (Eureka server), we need to define certain properties in the `application.properties`
    file as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 由于配置服务器也将注册到命名服务器（Eureka服务器），我们需要在`application.properties`文件中定义某些属性，如下所示：
- en: '[PRE11]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Next up, let's install and configure Git.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们安装和配置Git。
- en: Step 2 – configuring Spring Cloud Config with a Git repository
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2步 – 使用Git仓库配置Spring Cloud Config
- en: 'The Spring Cloud Config server is ready. Now, we need to do the necessary configuration
    for Git repository integration. First, install the latest version of Git ([https://git-scm.com/downloads](https://git-scm.com/downloads))
    on your local machine and make sure it is available on a path. Create a directory
    on your local machine and initialize the Git repository with the following command:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Config服务器已准备就绪。现在，我们需要为Git仓库集成进行必要的配置。首先，在你的本地机器上安装Git的最新版本([https://git-scm.com/downloads](https://git-scm.com/downloads))，并确保它在某个路径上可用。在你的本地机器上创建一个目录，并使用以下命令初始化Git仓库：
- en: '[PRE12]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will create an empty Git repository on the local machine. Next, add a
    properties file that holds the configuration details. Since the configuration
    server can hold configuration details for multiple microservices in Git, we need
    to follow a certain naming convention for the property file, as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在本地机器上创建一个空的 Git 仓库。接下来，添加一个包含配置细节的属性文件。由于配置服务器可以在 Git 中为多个微服务存储配置细节，因此我们需要遵循一定的命名约定来命名属性文件，如下所示：
- en: '[PRE13]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As we have seen, microservices' IDs (or names) are defined with the `spring.application.name`
    property in the `application.properties` file. So, we need to create a property
    file with this name in the Git repository. For example, if the microservice name
    is `catalog-service`, then you need to create a `catalog-service.properties` file
    and store all the configurations for that microservice.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，微服务的 ID（或名称）是在 `application.properties` 文件中通过 `spring.application.name`
    属性定义的。因此，我们需要在 Git 仓库中创建一个具有该名称的属性文件。例如，如果微服务名称是 `catalog-service`，那么你需要创建一个 `catalog-service.properties`
    文件，并存储该微服务的所有配置。
- en: 'For different environments, you can create a property file with an active profile
    appended after the microservice name. For example, the name of the property file
    for the development environment would be `catalog-service-dev.properties`. Once
    you have created the files, add the configuration details and commit them to the
    Git repository with the following command:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不同的环境，你可以在微服务名称后附加一个活动配置文件来创建一个属性文件。例如，开发环境的属性文件名称将是 `catalog-service-dev.properties`。一旦创建了文件，添加配置细节并将它们通过以下命令提交到
    Git 仓库：
- en: '[PRE14]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The Git repository is now ready, so we need to point the configuration server
    to it. Open the `application.properties` file of the configuration server as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Git 仓库现在已准备就绪，因此我们需要将配置服务器指向它。按照以下方式打开配置服务器的 `application.properties` 文件：
- en: '[PRE15]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Since this is the local Git repository, the location of the repository folder
    is given with `file://` to point it to the local filesystem. The configuration
    server also allows configuration with a remote Git repository. In this case, you
    need to give the Git clone URL something like `https://github.com/<<accoun-tname>>/<<repo-name>>.git`
    for the `spring.cloud.config.server.git.uri` property.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个本地 Git 仓库，因此使用 `file://` 来指定仓库文件夹的位置，以便指向本地文件系统。配置服务器还允许使用远程 Git 仓库进行配置。在这种情况下，你需要为
    `spring.cloud.config.server.git.uri` 属性提供一个类似 `https://github.com/<<accoun-tname>>/<<repo-name>>.git`
    的 Git 克隆 URL。
- en: 'We will add some sample configurations and see how they can be reflected in
    the corresponding microservice. Create a`service.properties` file and add the
    following property:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一些示例配置，并查看它们如何反映在相应的微服务中。创建一个 `service.properties` 文件，并添加以下属性：
- en: '[PRE16]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Step 3 – making each microservice Spring Cloud Config-aware using the Spring
    Cloud Config Client component
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 步 - 使用 Spring Cloud Config Client 组件使每个微服务 Spring Cloud Config 兼容
- en: The last step is to make the necessary changes to the microservice (configuration
    client) so that the configuration will be propagated by the configuration server
    once it is updated in the Git repository. The important point at this moment is
    to create a new property file called `bootstrap.properties` and copy all the properties
    from the `application.properties` file, or you can directly rename `application.properties`
    to `bootstrap.properties`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是对微服务（配置客户端）进行必要的更改，以便在 Git 仓库中更新配置后，配置服务器将传播配置。此时的重要点是创建一个名为 `bootstrap.properties`
    的新属性文件，并将所有属性从 `application.properties` 文件复制过来，或者你可以直接将 `application.properties`
    重命名为 `bootstrap.properties`。
- en: 'The reason is that Spring will process the `bootstrap.properties` file first,
    even before the bootstrap application and configuration server linked with it
    for configuration updates. You need to add a specific property in the `bootstrap.application`
    file, which will be used to connect the microservice with the configuration server,
    as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是 Spring 会首先处理 `bootstrap.properties` 文件，甚至在与它链接的引导应用程序和配置服务器进行配置更新之前。你需要在
    `bootstrap.application` 文件中添加一个特定的属性，该属性将用于将微服务与配置服务器连接，如下所示：
- en: '[PRE17]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The configuration server is accessible at `http://localhost:8901`. The microservice
    will fetch the configuration details with this URL. Next, we will access the configuration
    that we declared in the Git repository in the microservice with the REST controller,
    as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 配置服务器可通过 `http://localhost:8901` 访问。微服务将使用此 URL 获取配置细节。接下来，我们将通过 REST 控制器在微服务中访问我们在
    Git 仓库中声明的配置，如下所示：
- en: '[PRE18]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this controller, we are accessing the configuration with `catalog.sample.data`
    with the `@Value` annotation. This annotation is used to read the properties defined
    in the local `application.properties` file. The magic is that we haven't defined
    any such property for the category service, but it will connect to the configuration
    server and fetch this property value from the Git repository internally.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个控制器中，我们使用 `@Value` 注解通过 `catalog.sample.data` 访问配置。这个注解用于读取在本地 `application.properties`
    文件中定义的属性。神奇的是，我们没有为分类服务定义任何这样的属性，但它将连接到配置服务器并从 Git 仓库内部获取这个属性值。
- en: 'The `@RefreshScope` annotation will be used to fetch the latest configuration
    value whenever any change happens in the Git repository. You need to declare `@RefreshScope`
    for the component where you are reading the configuration value. When you start
    the `catalog-service` microservice, it will try to read the configuration from
    the configuration server, and you can verify it from the log as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`@RefreshScope` 注解将在 Git 仓库中任何变更发生时用于获取最新的配置值。您需要为读取配置值的组件声明 `@RefreshScope`。当您启动
    `catalog-service` 微服务时，它将尝试从配置服务器读取配置，您可以从以下日志中验证它：'
- en: '[PRE19]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: On startup, the `catalog-service` microservice will fetch the configuration
    from Git through the configuration server. This can be verified with the `http://localhost:8792/api/test/getSampleData` REST
    URL. When we make changes in the configuration and commit them to Git, they must
    be propagated to the microservice. This will not be done automatically, and you
    need to manually refresh it with Actuator—a tool provided by Spring Boot to monitor
    and manage applications. We will use the `/refresh` endpoint of Actuator to refresh
    the microservice with the latest configuration changes.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动时，`catalog-service` 微服务将通过配置服务器从 Git 获取配置。这可以通过 `http://localhost:8792/api/test/getSampleData`
    REST URL 进行验证。当我们对配置进行更改并将其提交到 Git 时，它们必须传播到微服务。这不会自动完成，您需要使用 Spring Boot 提供的监控和管理应用程序的工具
    Actuator 手动刷新。我们将使用 Actuator 的 `/refresh` 端点来刷新微服务，以获取最新的配置更改。
- en: 'Staring with Spring Boot 2.0, certain endpoints of Actuator (including `/refresh`)
    are not enabled by default. To enable them, you need to add the following property
    in the `bootstrap.properties` file of the `catalog-service` microservice:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Spring Boot 2.0 开始，Actuator 的某些端点（包括 `/refresh`）默认未启用。要启用它们，您需要将以下属性添加到 `catalog-service`
    微服务的 `bootstrap.properties` 文件中：
- en: '[PRE20]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, all endpoints are available, and configuration propagation can be done
    through a POST request to `http://localhost:8792/actuator/refresh`. Since this
    is a POST call, you need to use a REST client such as Postman. Once the refresh
    is completed, you will see the following output:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有端点都可用，可以通过向 `http://localhost:8792/actuator/refresh` 发送 POST 请求来完成配置传播。由于这是一个
    POST 调用，您需要使用 Postman 等REST客户端。刷新完成后，您将看到以下输出：
- en: '[PRE21]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is how configuration can be applied on the fly without restarting the
    microservice. The whole process can be performed in a series of actions in the
    following order:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何在无需重新启动微服务的情况下即时应用配置的方法。整个过程可以按以下顺序执行一系列操作：
- en: Update the files in the Git repository
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 Git 仓库中的文件
- en: Do the Git commit
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 Git 提交
- en: Execute the refresh operation, and you will see the changes reflected in the
    corresponding microservice
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行刷新操作，您将看到相应的微服务中反映了更改
- en: This is a great feature of managing configuration in one central place, and
    it can be applied to specific microservices with ease. However, not all properties
    can be applied this way. For example, application name and database-specific properties
    cannot be applied at runtime through Spring Cloud Config. However, custom configurations
    can be applied dynamically.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这是管理配置的一个很好的特性，它可以轻松地应用于特定的微服务。然而，并非所有属性都可以这样应用。例如，应用程序名称和特定于数据库的属性不能通过 Spring
    Cloud Config 在运行时应用。但是，可以动态地应用自定义配置。
- en: Making RESTful calls across microservices with Feign
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Feign 在微服务之间进行 RESTful 调用
- en: In microservice architecture, generally microservices interact with each other
    through HTTP REST web service calls. Typically, `RestTemplate` is used as a client
    to make REST API call programmatically in Spring-based applications. However,
    it requires a good amount of code to make a simple REST call. To make this simple,
    Spring Cloud provides Feign, another REST client that makes REST communication
    alot simpler than `RestTemplate`. Let's see how Feign makes calls to other services
    easy.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，通常微服务通过HTTP REST Web服务调用来相互交互。通常，`RestTemplate`在基于Spring的应用程序中用作客户端，以编程方式执行REST
    API调用。然而，它需要大量的代码来执行简单的REST调用。为了简化这一点，Spring Cloud提供了Feign，这是另一个REST客户端，它使REST通信比`RestTemplate`简单得多。让我们看看Feign如何使调用其他服务变得容易。
- en: 'For example, `inventory-service` needs to talk with the `catalog-service` microservice to
    fetch book details. In this case, `inventory-service` will make a REST call to
    fetch a `Book` object for a given `bookId`. This would typically happen with the `RestTemplate`
    client as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`inventory-service`需要与`catalog-service`微服务通信以获取书籍详情。在这种情况下，`inventory-service`将发出REST调用以获取给定`bookId`的`Book`对象。这通常使用以下`RestTemplate`客户端发生：
- en: '[PRE22]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We are using `RestTemplate` to call the `catalog-service` microservice to fetch
    the book details for the given `bookId`. Spring Cloud inherits another component,
    called **Feign**, from Netflix, which can be used as a declarative REST client
    with great simplification. It is easily integrated with Ribbon, which can be used
    as a client-side load-balancer; we will talk about this in the next section. To
    use Feign, you need to add the following starter dependency:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用`RestTemplate`调用`catalog-service`微服务以获取给定`bookId`的书籍详情。Spring Cloud从Netflix继承了另一个组件，称为**Feign**，它可以作为一个声明式的REST客户端，极大地简化了操作。它很容易与Ribbon集成，Ribbon可以用作客户端负载均衡器；我们将在下一节中讨论这一点。要使用Feign，您需要添加以下启动器依赖项：
- en: '[PRE23]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, let''s enable Feign. Open the `bootstrap` class and add a `@EnableDiscoveryClient`
    annotation to scan the Feign client, as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们启用Feign。打开`bootstrap`类，并添加一个`@EnableDiscoveryClient`注解来扫描Feign客户端，如下所示：
- en: '[PRE24]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we will use Feign to invoke the service. We need to create a Feign proxy
    to talk to other services, just like we use the JPA repository to interact with
    the database. A Feign proxy can be created with Java as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用Feign来调用服务。我们需要创建一个Feign代理来与其他服务通信，就像我们使用JPA仓库与数据库交互一样。以下是如何使用Java创建Feign代理：
- en: '[PRE25]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `@FeignClient` annotation is used to define the Feign proxy. The `name`
    attribute points to the name of the target microservice declared in the Eureka
    naming server (specified with the `spring.application.name` property in the `application.properties`
    or `bootstrap.properties` file) we want to talk to. `url` is the address at which
    the target microservice is accessible. The `path` attribute is used to add the
    path prefix used by all method-level mapping.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`@FeignClient`注解用于定义Feign代理。`name`属性指向Eureka命名服务器中声明的目标微服务的名称（在`application.properties`或`bootstrap.properties`文件中使用`spring.application.name`属性指定）。`url`是目标微服务可访问的地址。`path`属性用于添加所有方法级映射使用的路径前缀。'
- en: 'We have created the interface method with the same method signature that we
    created in the REST controller. We will use this proxy in the REST controller
    as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了与在REST控制器中创建的方法签名相同的接口方法。我们将在REST控制器中使用此代理如下：
- en: '[PRE26]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The instance of `CatalogServiceProxy` is injected by Spring through the `@Autowired`
    annotation. You can see how simple it is to make a RESTful web service. All the
    details are shifted from the controller to the Feign proxy. You will get the same
    output as `RestTemplate`, but the code is decoupled and simplified.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`CatalogServiceProxy`的实例通过`@Autowired`注解由Spring注入。您可以看到制作RESTful Web服务是多么简单。所有细节都从控制器转移到Feign代理。您将获得与`RestTemplate`相同的输出，但代码是解耦和简化的。'
- en: Assume the scenario where you are making more than a dozen REST calls to the `catalog-service` microservice.
    In this case, the Feign proxy helps us to manage all the code in one place. Other
    component classes do not need to know the underlying details.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在对`catalog-service`微服务进行超过一打的REST调用。在这种情况下，Feign代理帮助我们在一个地方管理所有代码。其他组件类不需要了解底层细节。
- en: Load balancing with Ribbon
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ribbon进行负载均衡
- en: In the last section, we saw how `inventory-service` can call `catalog-service`
    to fetch book details through Feign. However, in a distributed environment, it
    is quite possible that multiple instances of microservices are created to handle
    the enormous application load.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了`inventory-service`如何通过Feign调用`catalog-service`来获取书籍详情。然而，在分布式环境中，创建多个微服务实例来处理巨大的应用负载是完全可能的。
- en: In a multi-instance environment, a mechanism is required to balance and divide
    a load of input requests seamlessly to send them to available instances. The system
    becomes fault tolerant. It also increases throughput, reduces response time, and
    optimizes resource utilization by avoiding single instances being overloaded.
    This will make the system more reliable and highly available.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在多实例环境中，需要一个机制来无缝地平衡和分配输入请求的负载，将它们发送到可用的实例。系统变得容错。它还通过避免单个实例过载来提高吞吐量、减少响应时间并优化资源利用率，从而使系统更加可靠和高度可用。
- en: Netflix provides a component called Ribbon, which works as a client-side load
    balancer that provides lots of flexibility and control while making HTTP and TCP
    calls. The term **client-side** refers to an individual microservice as Ribbon
    can be used to balance the flow of calls a microservice makes to other services.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix提供了一个名为Ribbon的组件，它在执行HTTP和TCP调用时充当客户端负载均衡器，提供了许多灵活性和控制。术语**客户端**指的是单个微服务，因为Ribbon可以用来平衡微服务对其他服务的调用流量。
- en: Eureka can be easily integrated with Ribbon; however, we can configure Ribbon
    without Eureka. We will see how to configure Ribbon with and without Eureka.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Eureka可以轻松地与Ribbon集成；然而，我们可以配置Ribbon而不使用Eureka。我们将看到如何配置带有和没有Eureka的Ribbon。
- en: Configuring Ribbon without Eureka
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Ribbon而不使用Eureka
- en: 'We are going to configure Ribbon while making calls from `inventory-service`
    to `catalog-service`, so if you have configured Eureka server, just remove it
    for the time being while we learn how Ribbon works without Eureka. The very first
    thing is to add the Ribbon starter dependency. Since we want to handle the call
    initiated from `inventory-service`, and add the dependency in `inventory-service`
    as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在从`inventory-service`到`catalog-service`的调用中配置Ribbon，所以如果你已经配置了Eureka服务器，那么在了解Ribbon如何在没有Eureka的情况下工作之前，暂时将其移除。首要的事情是添加Ribbon启动器依赖项。由于我们想要处理从`inventory-service`发起的调用，因此需要在`inventory-service`中添加以下依赖项：
- en: '[PRE27]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the previous section, we configured the Feign client to handle REST calls.
    We will use Ribbon along with the Feign client. Open the proxy class that we created
    in the previous section and add the Ribbon configuration as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们配置了Feign客户端来处理REST调用。我们将使用Ribbon与Feign客户端一起使用。打开我们在上一节中创建的代理类，并添加以下Ribbon配置：
- en: '[PRE28]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `@RibbonClient` annotation is used to declare the Ribbon configuration
    with the `name` attribute pointing to the application on which we want to implement
    load balancing. The URL that we have configured with `FeignClient` is now removed
    and can be defined in the `application.properties` file as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`@RibbonClient`注解用于声明Ribbon配置，其中`name`属性指向我们想要实现负载均衡的应用程序。我们使用`FeignClient`配置的URL现在被移除，并可以在`application.properties`文件中如下定义：'
- en: '[PRE29]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The property name will start with the name of the application that we have used
    with the `@RibbonClient` annotation. We need to define comma-separated URLs, each
    pointing to an individual instance of the `catalog-service` microservice. As per
    this configuration, the Ribbon client will handle the call from `invoice-service`
    to `catalog-service`, which has two instances running on ports `8792` and `8799`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 属性名将以我们使用`@RibbonClient`注解的应用程序名称开头。我们需要定义以逗号分隔的URL，每个URL都指向`catalog-service`微服务的单个实例。根据此配置，Ribbon客户端将处理来自`invoice-service`到`catalog-service`的调用，该服务在端口`8792`和`8799`上运行两个实例。
- en: 'We will make the call to the Feign client on `inventory-service`, which eventually
    triggers the call to `catalog-service`. We will observe that the requests are
    divided into two instances of the `catalog-service` microservice. To verify which
    instance the request comes from, we will add the current server port in `BookDTO`,
    which will be shown in the response. The current server port can be obtained as
    follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对`inventory-service`上的Feign客户端进行调用，这最终会触发对`catalog-service`的调用。我们将观察到请求被分配到`catalog-service`微服务的两个实例。为了验证请求来自哪个实例，我们将在`BookDTO`中添加当前服务器端口，这将在响应中显示。当前服务器端口可以按以下方式获取：
- en: '[PRE30]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Spring injects the instance of the `Environment` class, which can be used to
    get current environment details. The current port is accessible with the `local.server.port` property.
    Next up, we will run two instances of the `catalog-service` microservice on these
    ports.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Spring注入了`Environment`类的实例，可以用来获取当前环境详情。当前端口号可以通过`local.server.port`属性访问。接下来，我们将在这两个端口上运行两个`catalog-service`微服务实例。
- en: 'To start the Spring Boot application on a specific port, you need to right-click
    on the microservice project, select Run As | Run Configurations, and add the port
    in the Arguments tab with the -Dserver.port argument. You can also append the
    port in Name so that it can be easily identified as follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 要在特定端口上启动Spring Boot应用程序，您需要右键单击微服务项目，选择Run As | Run Configurations，并在Arguments选项卡中添加带有`-Dserver.port`参数的端口号。您还可以在Name中追加端口号，以便它可以很容易地被识别，如下所示：
- en: '![](img/f40a1aed-d764-49c7-8917-ea345252b22e.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f40a1aed-d764-49c7-8917-ea345252b22e.png)'
- en: 'To add another instance, you need to right-click on the same instance of `catalog-service`
    created in the previous window, select Duplicate, and follow the same steps. The
    second time, use port `8799` as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加另一个实例，您需要在之前窗口中创建的`catalog-service`实例上右键单击，选择Duplicate，并遵循相同的步骤。第二次，使用端口`8799`，如下所示：
- en: '![](img/2f2b1602-77fb-4fc1-b903-eea34d132573.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2f2b1602-77fb-4fc1-b903-eea34d132573.png)'
- en: Run these two instances along with `inventory-service`. When you access `http://localhost:8793/api/inventory/get-inventory/3`,
    you will see the port is `8792` in the first request and `8799` in the second
    request. This is how the request is routed to a specific instance turn by turn.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 与`inventory-service`一起运行这两个实例。当您访问`http://localhost:8793/api/inventory/get-inventory/3`时，您将看到第一次请求的端口号是`8792`，第二次请求的端口号是`8799`。这就是请求逐个路由到特定实例的方式。
- en: Configuring Ribbon with Eureka
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Eureka配置Ribbon
- en: 'The problem in the first approach is that we still have to define the instance
    URLs manually. With Eureka, we can use its ability to resolve the microservice
    name dynamically and no more hardcore URLs are required. With Eureka, things are
    more straightforward. The Ribbon and Feign configuration will be changed as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法的问题在于我们仍然需要手动定义实例URL。使用Eureka，我们可以利用其动态解析微服务名称的能力，不再需要硬编码的URL。使用Eureka后，事情变得更加简单直接。Ribbon和Feign的配置将按以下方式更改：
- en: '[PRE31]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'No more `url` attributes are required for the `@FeignClient` annotation. Also,
    you can remove the `catalog-service.ribbon.listOfServers` property from the `application.properties`
    file of the `inventory-service` microservice. Start two instances of `catalog-service`
    along with `inventory-service` and make sure Eureka is running before you do.
    You will see two instances of `catalog-service` running in the Eureka console,
    as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`@FeignClient`注解不再需要`url`属性。您还可以从`inventory-service`微服务的`application.properties`文件中删除`catalog-service.ribbon.listOfServers`属性。启动两个`catalog-service`实例以及`inventory-service`实例，并在进行之前确保Eureka正在运行。您将在Eureka控制台中看到两个`catalog-service`实例正在运行，如下所示：
- en: '![](img/b591341b-b3d4-4f6e-ba89-4a2ee6feeaf1.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b591341b-b3d4-4f6e-ba89-4a2ee6feeaf1.png)'
- en: When you go to `http://localhost:8793/api/inventory/get-inventory/3`, you will
    get the same behavior. Once the request reaches the instance on port `8792`, the
    second is on `8799`, and the third is also on `8792`. This is how Ribbon is configured
    with Feign to achieve load balancing. You can try creating a few more instances
    and check the behavior. Also, if any of the instances are down, Ribbon will stop
    sending requests to them, which makes the system fault tolerant.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 当您访问`http://localhost:8793/api/inventory/get-inventory/3`时，您将得到相同的行为。一旦请求到达端口为`8792`的实例，第二个实例在`8799`，第三个实例也在`8792`。这就是Ribbon与Feign配合配置以实现负载均衡的方式。您可以尝试创建更多实例并检查其行为。此外，如果任何实例出现故障，Ribbon将停止向它们发送请求，这使得系统具有容错性。
- en: Load balancing using RestTemplate
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RestTemplate进行负载均衡
- en: 'Spring Cloud also supports the implementation of load balancing using `RestTemplate`.
    In this case, you need to expose the `RestTemplate` instance with load balancing
    capabilities instead of using it directly, as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud也支持使用`RestTemplate`实现负载均衡的实现。在这种情况下，您需要暴露具有负载均衡能力的`RestTemplate`实例，而不是直接使用它，如下所示：
- en: '[PRE32]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the previous case, the `@LoadBalanced` annotation will do the magic of balancing
    the load between the instances of other services to which we make a REST call.
    You need to inject this object in your controller and make the call with it.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，`@LoadBalanced`注解将执行在REST调用中我们调用的其他服务实例之间平衡负载的魔法。您需要在控制器中注入此对象并使用它进行调用。
- en: Configuring the API gateway
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置API网关
- en: In previous sections, we saw how to define Zuul as an API gateway. In subsequent
    sections, we explored other Netflix components, such as Feign and Ribbon, to make
    RESTful calls for inter-service communication. However, the interaction that we
    created happened directly between services. Though we have configured an API gateway
    with Zuul, we have not used it as a central point of the request flow. In this
    section, we will make the necessary configuration changes so that every request
    passes through our API gateway.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了如何定义Zuul作为API网关。在随后的章节中，我们探讨了其他Netflix组件，如Feign和Ribbon，以进行RESTful调用以实现服务间通信。然而，我们创建的交互是直接在服务之间发生的。尽管我们已经配置了Zuul作为API网关，但我们还没有将其用作请求流的中心点。在本节中，我们将进行必要的配置更改，以便每个请求都通过我们的API网关。
- en: 'The very first thing we will learn is to implement a custom filter and configure
    it to the API gateway to trace the request and print it in the log. For simplicity,
    we will capture a few details about the current request. Open the Spring Boot
    application that we created for Zuul and add a filter class as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先学习如何实现一个自定义过滤器，并将其配置到API网关中，以跟踪请求并在日志中打印它。为了简单起见，我们将捕获当前请求的一些细节。打开我们为Zuul创建的Spring
    Boot应用程序，并添加一个过滤器类，如下所示：
- en: '[PRE33]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For any custom filter, you need to extend an abstract class, `ZuulFilter`,
    which is provided by Netflix. There are certain abstract methods that we need
    to provide the implementation, as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何自定义过滤器，您需要扩展Netflix提供的抽象类`ZuulFilter`。我们需要提供某些抽象方法的实现，如下所示：
- en: '`shouldFilter()`: We apply this filter or not based on the return value of
    this method.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shouldFilter()`: 我们根据此方法的返回值来决定是否应用此过滤器。'
- en: '`filterType()`: As we have seen, Zuul supports various filters type such as `pre`,
    `post`, `error`*,* and so on. The `pre` filter will be executed after the request
    reaches Zuul and before it is routed to other microservices. Similarly, the `post`
    filter will be executed once the response returns from other microservices, and
    the `error` filter type will be triggered when an error happens in between.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filterType()`: 如我们所见，Zuul支持各种过滤器类型，如`pre`、`post`、`error`*等。`pre`过滤器将在请求到达Zuul之后和路由到其他微服务之前执行。同样，`post`过滤器将在响应从其他微服务返回后执行，而`error`过滤器类型将在请求过程中发生错误时触发。'
- en: '`filterOrder()`: We can define as many filters as we want. This method defines
    their order of priority.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filterOrder()`: 我们可以定义任意数量的过滤器。此方法定义了它们的优先级顺序。'
- en: '`run()`: This method is the placeholder where you can write your filter logic.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run()`: 此方法是一个占位符，您可以在其中编写您的过滤器逻辑。'
- en: 'We use will another filter that will be triggered once the response comes back,
    filter type `post`, as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用另一个过滤器，该过滤器在响应返回时触发，过滤器类型为`post`，如下所示：
- en: '[PRE34]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, let''s see how to access microservices through our API gateway. We have
    exposed a REST API for `inventory-service` as `http://localhost:8793/api/inventory/get-inventory/3`,
    and we will now update this URL to route the request from the API gateway. The
    pattern for the API gateway URL would be as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何通过我们的API网关访问微服务。我们已经为`inventory-service`公开了一个REST API，地址为`http://localhost:8793/api/inventory/get-inventory/3`，现在我们将更新此URL以通过API网关路由请求。API网关URL的模式如下：
- en: '[PRE35]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The Zuul API gateway will use the Eureka naming server to connect to the desired
    microservice. The service name in the previous pattern is the name (with the `spring.application.name` property
    in the `application.properties` or `bootstrap.properties` file) of the service
    registered in the Eureka naming server. The API gateway is accessible with `http://localhost:8781`,
    so to access the `inventory-service` URL with the API gateway, the new URL would
    be `http://localhost:8781/inventory-service/api/inventory/get-inventory/3`. You
    will get the request details in the Zuul log as follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: Zuul API网关将使用Eureka命名服务器连接到所需的微服务。在之前的模式中，服务名称是注册在Eureka命名服务器中的服务的名称（在`application.properties`或`bootstrap.properties`文件中的`spring.application.name`属性）。API网关可通过`http://localhost:8781`访问，因此要使用API网关访问`inventory-service`
    URL，新的URL将是`http://localhost:8781/inventory-service/api/inventory/get-inventory/3`。您将在Zuul日志中获取以下请求详情：
- en: '[PRE36]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This is how we can trace the request with various filters with the Zuul API
    gateway. However, the call is forwarded from `inventory-service` to `catalog-service`
    with Feign, which is still bypassing the API gateway and making a direct call
    to the microservice. Now, let''s see how to configure Feign so that the call is
    routed through the Zuul API gateway. The original Feign proxy was as follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何通过Zuul API网关使用各种过滤器跟踪请求。然而，调用是通过Feign从`inventory-service`转发到`catalog-service`的，这仍然绕过了API网关，直接调用微服务。现在，让我们看看如何配置Feign，以便调用通过Zuul
    API网关路由。原始的Feign代理如下：
- en: '[PRE37]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The updated Feign proxy interface would be as follows:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的Feign代理接口如下：
- en: '[PRE38]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The change happened in the service name of the `@FeignClient` annotation. Previously,
    it was directly pointing to `catalog-service`, but now it is pointing to the Zuul
    API gateway service. `zuul-api-gateway` is the name of the Zuul API gateway service
    defined with the `spring.application.name` property in the `application.properties`
    file.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 变化发生在`@FeignClient`注解的服务名称中。之前，它直接指向`catalog-service`，但现在它指向了Zuul API网关服务。`zuul-api-gateway`是使用`application.properties`文件中的`spring.application.name`属性定义的Zuul
    API网关服务的名称。
- en: Run the URL again, and you will see the logs are printed twice. The loges are
    printed first, when the request reaches `inventory-service`, and second when the
    request is routed from `inventory-service` to `catalog-service` through Feign.
    This is how Zuul is configured to trace every request made across the microservices.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行URL，你会看到日志打印了两次。日志首先在请求到达`inventory-service`时打印，然后在请求通过Feign从`inventory-service`路由到`catalog-service`时再次打印。这就是Zuul是如何配置来跟踪微服务之间发出的每个请求的。
- en: Securing an application
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护应用程序
- en: In a typical monolithic application, when the user logs in, an HTTP session
    will be created to hold user-specific information, which will be then used until
    the session expires. The session will be maintained by a common security component
    on the server side and all the requests are passed through it. So, it is straightforward
    to handle user authentication and authorization in a monolithic application.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的单体应用程序中，当用户登录时，将创建一个HTTP会话来保存用户特定的信息，然后直到会话过期都会使用这些信息。会话将由服务器端的一个通用安全组件维护，并且所有请求都通过它传递。因此，在单体应用程序中处理用户身份验证和授权是直接的。
- en: If we want to follow the same pattern for microservice architecture, we need
    to implement a security component at every microservice level as well as in a
    central place (the gateway API) from where all the requests are routed. This is
    because microservices interact over the network, so the approach of applying security
    constraints is different.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要遵循相同的模式来构建微服务架构，我们需要在每个微服务级别以及中央位置（网关API）实现安全组件，所有请求都从这里路由。这是因为微服务通过网络进行交互，所以应用安全约束的方法是不同的。
- en: Using Spring Security is a standard practice to meet the security needs of Spring-based
    Java applications. For microservices, Spring Cloud Security (another component
    from Spring Cloud) provides a one-stop solution to integrate Spring Security features
    with various components of the microservice architecture, such as the gateway
    proxy, a configuration server, load balancers, and so on.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring Security是满足基于Spring的Java应用程序安全需求的标准做法。对于微服务，Spring Cloud Security（Spring
    Cloud的另一个组件）提供了一个一站式解决方案，将Spring Security功能与微服务架构的各种组件（如网关代理、配置服务器、负载均衡器等）集成。
- en: In a microservice environment, security concerns can be addressed through widely
    used standard security protocols such as OAuth2 and OpenID Connect. In [Chapter
    4](e36170b7-dbc6-4a4c-b7ba-e4830cd71efd.xhtml), *Building a Central Authentication
    Server*, we talked about OAuth2 in detail. Now, we will see how it can be used
    to meet security needs in a microservice architecture.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务环境中，可以通过广泛使用的标准安全协议，如OAuth2和OpenID Connect来解决安全担忧。在[第4章](e36170b7-dbc6-4a4c-b7ba-e4830cd71efd.xhtml)，*构建中央认证服务器*中，我们详细讨论了OAuth2。现在，我们将看看它如何被用来满足微服务架构中的安全需求。
- en: 'Let''s see how the OAuth security system works in a microservice architecture.
    The high-level flow of authorization looks as follows:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看OAuth安全系统在微服务架构中是如何工作的。授权的高级流程如下：
- en: '![](img/2ea779af-d78b-45a3-816f-835331fe7f9a.png)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ea779af-d78b-45a3-816f-835331fe7f9a.png)'
- en: 'To understand the series of actions, let''s take a use case of an order being
    placed by a user of the online bookstore. The whole process happens in the following
    steps:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这一系列操作，让我们以在线书店用户下单的情况为例。整个过程如下几个步骤：
- en: A user tries to access the order page through the Zuul proxy server (API gateway)
    and does not have a session or an access token.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户尝试通过Zuul代理服务器（API网关）访问订单页面，但没有会话或访问令牌。
- en: The Zuul proxy then redirects a user to an authorization server with pre-configured
    parameters such as grant type, client ID, token URL, and authorization URL.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Zuul代理随后将用户重定向到一个预配置了参数的授权服务器，例如授权类型、客户端ID、令牌URL和授权URL。
- en: If the user does not log in, the authorization server redirects to the login
    page.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户未登录，授权服务器将重定向到登录页面。
- en: Once the user does log in with valid credentials, the authorization server generates
    a token and sends it back to the API gateway.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦用户使用有效的凭据登录，授权服务器将生成一个令牌并将其发送回API网关。
- en: On receiving the token, the API gateway (the Zuul proxy server) propagates the
    token downstream to the microservices it is proxying.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在收到令牌后，API网关（Zuul代理服务器）将令牌向下传播到它所代理的微服务。
- en: For restricted resources, the system will check whether a valid token exists.
    If not, the user will be redirected to the login page (or the token will be refreshed
    based on the grant type configured in the system).
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于受限制的资源，系统将检查是否存在有效的令牌。如果没有，用户将被重定向到登录页面（或者根据系统配置的授权类型刷新令牌）。
- en: 'The authentication server will be implemented as a separate microservice and
    registered in the Eureka discovery server. It can be created as a Spring Boot
    application with security-specific starter dependencies as follows:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 授权服务器将被实现为一个独立的微服务并在Eureka发现服务器中注册。它可以作为一个带有安全特定`starter`依赖的Spring Boot应用程序创建，如下所示：
- en: '[PRE39]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Spring Cloud Security has different starters for OAuth and standard Spring
    Security for the microservice architecture. Next, we will add the required configurations
    to make this application an authorization server, as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Security为OAuth和标准Spring Security提供了不同的启动器，用于微服务架构。接下来，我们将添加必要的配置，使该应用程序成为一个授权服务器，如下所示：
- en: '[PRE40]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `@EnableAuthorizationServer` annotation is used to declare the component
    as an authorization server. OAuth can be done with various third-party clients,
    and Spring Security provides support for Google, Facebook, Okta, and GitHub out
    of the box. In our case, we will define a custom authorization server.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@EnableAuthorizationServer`注解来声明该组件为授权服务器。OAuth可以通过各种第三方客户端完成，Spring Security提供了对Google、Facebook、Okta和GitHub的原生支持。在我们的案例中，我们将定义一个自定义授权服务器。
- en: The `configure(ClientDetailsServiceConfigurer clients)` method of this class
    is used to define configuration for the custom authorization client. It initializes
    the client with various configurations, such as `ClientId`, secret (a kind of
    client password), possible authorization grant types you want the client to support,
    various scopes that can be used to fine-tune access control, and user authority
    and `resourceId`.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的`configure(ClientDetailsServiceConfigurer clients)`方法用于定义自定义授权客户端的配置。它使用各种配置初始化客户端，例如`ClientId`、秘密（一种客户端密码）、客户端想要支持的可能的授权授予类型、可以用于微调访问控制的各个范围，以及用户权限和`resourceId`。
- en: 'Spring OAuth is flexible enough to allow various mechanisms to generate the
    access token, and JWT is one of them. The `tokenStore()` and `tokenService()`
    methods are used to apply the required configuration for JWT. The `configure(AuthorizationServerEndpointsConfigurer
    endpoints)` method is used to configure tokens, along with the authentication
    manager. The `AuthenticationManager` object is injected from the `WebSecurityConfig`
    class as follows:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: Spring OAuth足够灵活，允许使用各种机制生成访问令牌，JWT就是其中之一。`tokenStore()`和`tokenService()`方法用于应用JWT所需的配置。`configure(AuthorizationServerEndpointsConfigurer
    endpoints)`方法用于配置令牌，以及认证管理器。`AuthenticationManager`对象如下从`WebSecurityConfig`类注入：
- en: '[PRE41]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This class is responsible for configuring various endpoints, static resources,
    and the login page, along with the authentication mechanism. This is all about
    authorization server configuration. As we know, all requests are routed through
    the Zuul proxy server (an API Gateway), so we must configure it to route the requests
    for restricted resources to the authorization server.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类负责配置各种端点、静态资源以及登录页面，还包括认证机制。这全部关于授权服务器配置。正如我们所知，所有请求都是通过 Zuul 代理服务器（一个 API
    网关）路由的，因此我们必须配置它将受限资源的请求路由到授权服务器。
- en: The authorization server provides an access token that will be routed along
    with the request (in the header). When other microservices read it, they will
    verify the access token with the authorization server to allow the user to access
    restricted resources. In short, access tokens will be routed to various microservices.
    This requires some sort of SSO implementation, and with Spring Cloud Security,
    we can do it.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 授权服务器提供了一个访问令牌，该令牌将与请求一起路由（在头部）。当其他微服务读取它时，它们将使用授权服务器验证访问令牌，以允许用户访问受限资源。简而言之，访问令牌将被路由到各种微服务。这需要某种形式的单点登录（SSO）实现，而使用
    Spring Cloud Security，我们可以做到这一点。
- en: 'Additionally, particular functionality (for example, placing an order) initiated
    by a user will eventually involve interaction with other microservices along with
    the Zuul proxy server, so they are considered resource servers in OAuth terminology.
    First, add the `@EnableOAuth2Sso` annotation to a `bootstrap` class of the Zuul
    proxy application, as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由用户发起的特定功能（例如，下订单）最终将涉及与其他微服务和 Zuul 代理服务器的交互，因此在 OAuth 术语中，它们被视为资源服务器。首先，将
    `@EnableOAuth2Sso` 注解添加到 Zuul 代理应用程序的 `bootstrap` 类中，如下所示：
- en: '[PRE42]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This annotation allows the Zuul proxy server to forward the access token generated
    by the authorization server downstream to other services involved in processing
    the request. The resource server configuration for the Zuul proxy server, as well
    as other microservices, should be as follows:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这个注解允许 Zuul 代理服务器将授权服务器生成的访问令牌向下传递给其他参与请求处理的微服务。Zuul 代理服务器以及其他微服务的资源服务器配置应如下所示：
- en: '[PRE43]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `@EnableResourceServer` annotation will enable the component as a resource
    server. `resourceId` should be the same as we configured in the authorization
    server. Also, we are using the same JWT token configuration that we set in the
    authorization server. The `configure` method is used to set the configuration
    for individual microservice endpoints.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`@EnableResourceServer` 注解将使组件作为一个资源服务器。`resourceId` 应该与我们配置在授权服务器中的一致。我们还在授权服务器中使用了相同的
    JWT 令牌配置。`configure` 方法用于设置单个微服务端点的配置。'
- en: 'We also need to set certain properties in the `application.properties` file,
    which will be used by the resource server to interact with the authorization server
    as follows:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在 `application.properties` 文件中设置某些属性，这些属性将由资源服务器用于与授权服务器交互，如下所示：
- en: '[PRE44]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The authorization server is configured to access `localhost:9999`. The resource
    server configuration, along with previous properties, need to be placed with every
    microservice that we want to access securely through OAuth.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 授权服务器配置为访问 `localhost:9999`。资源服务器配置，连同之前的属性，需要放置在我们想要通过 OAuth 安全访问的每个微服务中。
- en: Summary
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Unlike other chapters and applications that we have seen so far in this book,
    this chapter introduced a new type of application development in a distributed
    environment. The term **microservice** has existed since 2011\. It has emerged
    as an enhancement of previous architectures.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中迄今为止看到的其他章节和应用不同，这一章介绍了在分布式环境中的一种新的应用程序开发类型。**微服务**这个术语自 2011 年以来就已经存在。它作为之前架构的增强而出现。
- en: With the introduction of Spring Cloud, developers can provide an implementation
    of various common patterns in a distributed environment. Starting with Spring
    Boot, creating a microservice application just takes a few configurations.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Spring Cloud 的引入，开发者可以在分布式环境中提供各种常见模式的实现。从 Spring Boot 开始，创建一个微服务应用程序只需进行少量配置。
- en: At the beginning of this chapter, we have explored what a microservice is and
    how it differs from the monolithic architecture, followed by various principles
    and criteria that need to be adhered to if you want to develop a microservice
    system. We then explored various Spring Cloud components and other Netflix OSS
    components in brief.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们探讨了什么是微服务以及它与单体架构的区别，随后介绍了在开发微服务系统时需要遵守的各种原则和标准。然后，我们简要探讨了各种Spring
    Cloud组件和其他Netflix OSS组件。
- en: We have also learned how to create a microservice application by building a
    real-life example—an online bookstore application. We started with the application's
    architecture and the database design. We looked at creating microservices as Spring
    Boot applications with the required configurations.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过构建一个真实世界的示例——在线书店应用程序，学习了如何创建微服务应用程序。我们从应用程序的架构和数据库设计开始。我们研究了如何以Spring
    Boot应用程序的形式创建微服务，并配置了所需的配置。
- en: We then saw practical examples of how to build various Netflix OSS and Spring
    Cloud components, such as a Eureka discovery server, a Zuul proxy server, a Feign
    client, Ribbon, and Spring Cloud Config. These components are the building blocks
    for developing a distributed application. We also saw various options and approaches
    to building a microservice frontend. Finally, we secured the application with
    Spring Cloud Security.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后看到了构建各种Netflix OSS和Spring Cloud组件的实际示例，例如Eureka发现服务器、Zuul代理服务器、Feign客户端、Ribbon和Spring
    Cloud Config。这些组件是开发分布式应用程序的构建块。我们还看到了构建微服务前端的各种选项和方法。最后，我们使用Spring Cloud Security确保了应用程序的安全性。
- en: Java was the only de facto programming language for building Spring-based applications
    for quite a long time. However, the team at Pivotal (the company behind Spring)
    has started to support other functional programming languages, such as Scala.
    Starting with version 5, Spring announced support for Kotlin, a JVM-based language
    mainly used for Android applications. In the next chapter, we will dive into an
    altogether new way of building Spring applications with Kotlin.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: Java长期以来一直是构建基于Spring的应用程序的唯一事实上的编程语言。然而，Spring背后的公司Pivotal的团队已经开始支持其他函数式编程语言，例如Scala。从版本5开始，Spring宣布支持Kotlin，这是一种主要用于Android应用程序的基于JVM的语言。在下一章中，我们将深入探讨使用Kotlin构建Spring应用程序的全新方式。
