- en: Web- and Client-Server Communication
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web和客户端-服务器通信
- en: Web development is one of the greatest ways to use Java EE. Actually, since
    before J2EE times, we could use JSP and servlets, and that's how web development
    using Java began.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Web开发是使用Java EE的最好方式之一。实际上，自从J2EE时代之前，我们就可以使用JSP和servlets，这就是Java Web开发的开始。
- en: This chapter will show some advanced features for web development that will
    make your application faster and better—for you and for your client!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将展示一些用于Web开发的先进特性，这将使你的应用程序更快、更好——对你和你的客户来说都是如此！
- en: 'This chapter covers the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下菜谱：
- en: Using servlet for request and response management
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用servlet进行请求和响应管理
- en: Building UI with template features using JSF
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模板功能构建UI的JSF
- en: Improving response performance with Server Push
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务器推送提高响应性能
- en: Using servlets for request and response management
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用servlet进行请求和响应管理
- en: Servlets are the core place to deal with requests and responses using Java EE.
    If you are still not familiar with it, know that even a JSP is nothing more than
    a way to build a servlet once the page is called.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Servlets是使用Java EE处理请求和响应的核心地方。如果你还不熟悉它，知道即使是JSP也只是当页面被调用时构建servlet的一种方式。
- en: 'This recipe will show you three features you can use when using servlets:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将展示你在使用servlets时可以使用的三个特性：
- en: Load on startup
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动时加载
- en: Parameterized servlets
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数化servlets
- en: Asynchronous servlets
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步servlets
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Start by adding the dependency to your project:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将依赖项添加到你的项目中：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The load on startup servlet
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动时加载的servlet
- en: 'Let''s start with our servlet that will load on the server''s start up:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的servlet开始，这个servlet将在服务器启动时加载：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A servlet with init params
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有初始化参数的servlet
- en: 'Now we add a servlet with some parameters for its own initialization:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们添加一个带有一些初始化参数的servlet：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The asynchronous servlet
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步servlet
- en: 'And then we implement our asynchronous servlet:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们实现我们的异步servlet：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And finally, we need a simple web page to try all those servlets:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个简单的网页来尝试所有这些servlet：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The load on startup servlet
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动时加载的servlet
- en: If you want your servlet to be initialized when the server starts, then this
    is what you need. Usually you will use it to load some cache, start a background
    process, log some information, or whatever you need to do when the server has
    just started and can't wait until somebody calls the servlet.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望你的servlet在服务器启动时初始化，那么这就是你需要的东西。通常你会用它来加载一些缓存，启动一个后台进程，记录一些信息，或者你需要在服务器刚刚启动且不能等待有人调用servlet时需要做的任何事情。
- en: 'The key points of this kind of servlet are:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这种servlet的关键点如下：
- en: 'The `loadOnStartup` param: Accepts any number of servlets. This number defines
    the order used by the server to run all the servlets that will run in the startup.
    So if you have more than one servlet running this way, remember to define the
    right order (if there is any). If there''s no number defined or a negative one,
    the server will choose the default order.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loadOnStartup`参数：接受任意数量的servlet。这个数字定义了服务器在启动时运行所有servlet的顺序。所以如果你有多个servlet以这种方式运行，记得要定义正确的顺序（如果有）。如果没有定义数字或负数，服务器将选择默认顺序。'
- en: 'The `init` method: Remember to override the `init` method with the operation
    you would like to do at the start up time, otherwise your servlet will do nothing.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init`方法：记得在启动时使用你想要执行的操作覆盖`init`方法，否则你的servlet将不会做任何事情。'
- en: A servlet with init params
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有初始化参数的servlet
- en: 'Sometimes you need to define some parameters for your servlet that goes beyond
    local variables – `initParams` is the place to do it:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要为你的servlet定义一些参数，这些参数超出了局部变量的范围——`initParams`就是做这件事的地方：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `@WebInitParam` annotation will handle them for you and those parameters
    will be available for the server through the `ServletConfig` object.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`@WebInitParam`注解会为你处理它们，并且这些参数将通过`ServletConfig`对象在服务器上可用。'
- en: Asynchronous servlet
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步servlet
- en: 'Let''s split our `AsyncServlet` class into pieces so we can understand it:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把我们的`AsyncServlet`类拆分成几个部分，这样我们就可以理解它：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we defined our servlet for accepting async behavior by using the `asyncSupported` param:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过使用`asyncSupported`参数定义了我们的servlet以接受异步行为：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We used the request being processed to start a new async context.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了正在处理的请求来启动一个新的异步上下文。
- en: 'Then we start our async process:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们开始我们的异步过程：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And here we print our output to see the response and finish the async process:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们打印输出以查看响应并完成异步过程：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: See also
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: To get the full source code of this recipe, check [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter04/ch04-servlet](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter04/ch04-servlet)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取本食谱的完整源代码，请检查[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter04/ch04-servlet](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter04/ch04-servlet)
- en: Building UI with template's features using JSF
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模板功能构建UI的JSF
- en: The **JavaServer Faces** (**JSF**) is a powerful Java EE API for building outstanding
    UIs, using both client and server features.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaServer Faces**（**JSF**）是一个强大的Java EE API，用于构建出色的UI，同时使用客户端和服务器功能。'
- en: It goes much further than when you are using JSP, as you are not only using
    Java code inside HTML code, but actually really referencing code injected in the
    server context.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用JSP相比，它走得更远，因为您不仅在使用HTML代码中使用Java代码，而且实际上是在引用注入到服务器上下文中的代码。
- en: This recipe will show you how to use the Facelet's template feature to get more
    flexibility and reusability from your layout template.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将向您展示如何使用Facelet的模板功能，从布局模板中获得更多灵活性和可重用性。
- en: Getting ready
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Start by adding the dependency to your project:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先向您的项目添加依赖项：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How to do it...
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s first create our page layout with a header, content section, and footer:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先创建我们的页面布局，包括页眉、内容区域和页脚：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Define the default header section:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义默认页眉区域：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The default content section:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认内容区域：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The default footer section:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认页脚区域：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And then a simple page using our default template:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后使用我们的默认模板创建一个简单的页面：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let''s create another page and override just the content section:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建另一个页面，并仅覆盖内容区域：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As this code is calling `UserBean`, let''s define it:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于此代码正在调用`UserBean`，让我们定义它：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Also, don''t forget to include the `beans.xml` file inside the `WEB-INF` folder;
    otherwise, this bean will not work as expected:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，别忘了在`WEB-INF`文件夹中包含`beans.xml`文件；否则，此Bean将无法按预期工作：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you want to try this code, run it in a Java EE compatible server and access
    the following URLs:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想尝试此代码，请在Java EE兼容的服务器上运行它，并访问以下URL：
- en: '`http://localhost:8080/ch04-jsf/`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/ch04-jsf/`'
- en: '`http://localhost:8080/ch04-jsf/user.xhtml`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/ch04-jsf/user.xhtml`'
- en: How it works...
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The explanation is as simple as possible: the `layout.xhtml` is our template.
    As long as you name each section (in our case its header, content, and footer),
    whatever JSF page that uses it will inherit its layout.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 解释尽可能简单：`layout.xhtml`是我们的模板。只要您为每个区域命名（在我们的例子中是页眉、内容和页脚），任何使用它的JSF页面都将继承其布局。
- en: 'Any page using this layout and wanting to customize some of those defined sections,
    should just describe the desired section like we did in the `user.xhtml` file:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 任何使用此布局并希望自定义其中一些定义区域的页面，只需像我们在`user.xhtml`文件中所做的那样描述所需的区域：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: See also
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: To get the full source code of this recipe, check [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter04/ch04-jsf](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter04/ch04-jsf)
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取本食谱的完整源代码，请检查[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter04/ch04-jsf](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter04/ch04-jsf)
- en: Improving the response performance with Server Push
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过服务器推送提高响应性能
- en: One of the main features of HTTP/2.0 is the Server Push. When it is available,
    that means, being supported by the protocol, the server, and the browser client—it
    lets the server send ("push") data to the client before it asks for it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2.0的一个主要特性是服务器推送。当它可用时，这意味着，协议、服务器和浏览器客户端都支持它——它允许服务器在客户端请求之前发送（推送）数据到客户端。
- en: It is one of the most wanted features in JSF 2.3 and probably the one that demands
    less effort to use if your application is based on JSF—just migrate to a Java
    EE 8 compatible server and then you are done.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是JSF 2.3中最受欢迎的特性之一，如果您基于JSF的应用程序，它可能也是使用起来最不费力的一项——只需迁移到Java EE 8兼容的服务器，然后您就完成了。
- en: This recipe will show you how to use it in your application and will even let
    you compare the performance between HTTP/1.0 and HTTP/2.0 in the same scenario.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将向您展示如何在您的应用程序中使用它，并允许您在同一场景下比较HTTP/1.0和HTTP/2.0的性能。
- en: Getting ready
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Start by adding the dependency to your project:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先向您的项目添加依赖项：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'This recipe has only this single servlet:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱只有一个单独的servlet：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And we creat a simple page to call both HTTP/1.0 and HTTP/2.0 cases:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个简单的页面来调用HTTP/1.0和HTTP/2.0的情况：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And try it on a Java EE 8 compatible server using this URL:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在Java EE 8兼容的服务器上使用此URL尝试它：
- en: '`https://localhost:8181/ch04-serverpush`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://localhost:8181/ch04-serverpush`'
- en: How it works...
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The image loaded in this recipe was shared in 25 pieces. When there's no HTTP/2.0
    available, the server will wait for 25 requests made by `img src` (from HTML)
    and then reply to each one of them with the proper image.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中加载的图片被分成了25份。当没有HTTP/2.0可用时，服务器将等待由`img src`（来自HTML）发出的25个请求，然后对每个请求回复相应的图片。
- en: 'With HTTP/2.0, the server can push them all beforehand. The "magic" is done
    here:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTTP/2.0，服务器可以事先推送它们。这里的“魔法”就在这里：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To check if your images are loaded using Server Push or not, open the developer
    console of your browser, go to network monitoring, and then load the page. One
    of the pieces of information about each image should be who sent it to the browser.
    If there's something like Push or ServerPush, you are using it!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查你的图片是否是通过服务器推送加载的，请打开浏览器中的开发者控制台，转到网络监控，然后加载页面。每个图片的相关信息之一应该是谁将它发送到浏览器。如果有类似Push或ServerPush的内容，说明你正在使用它！
- en: There's more...
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Server Push will only work under SSL. In other words, if you are using GlassFish
    5 and try to run this recipe, your URL should be something like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器推送仅在SSL下工作。换句话说，如果你正在使用GlassFish 5并尝试运行这个菜谱，你的URL应该是这样的：
- en: '`https://localhost:8181/ch04-serverpush`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://localhost:8181/ch04-serverpush`'
- en: 'If you miss it, the code will still work, but using HTTP/1.0\. means that when
    the code asks for `newPushBuilder,` it will return null (not available):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你错过了它，代码仍然可以工作，但使用HTTP/1.0意味着当代码请求`newPushBuilder`时，它将返回null（不可用）：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: See also
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: To get the full source code of this recipe, check [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter04/ch04-serverpush](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter04/ch04-serverpush)
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取这个菜谱的完整源代码，请检查[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter04/ch04-serverpush](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter04/ch04-serverpush)
