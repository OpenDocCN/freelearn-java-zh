- en: Chapter 7. Explanation of ImageJ Constructs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. ImageJ结构的解释
- en: 'In the previous chapter, we developed macros to ease our processing and measurements.
    We used some techniques and constructs that are particular for the macro language
    in ImageJ. In this chapter, we will look at the following topics, in preparation
    to develop our own plugins:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们开发了宏以简化我们的处理和测量。我们使用了ImageJ宏语言特有的技术和结构。在本章中，我们将探讨以下主题，为开发我们自己的插件做准备：
- en: Frameworks for macros and plugins
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏和插件的框架
- en: Special classes in ImageJ
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ImageJ中的特殊类
- en: Built-in functions for macros
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏的内建函数
- en: API functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API函数
- en: Setting up the NetBeans IDE for development
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置NetBeans IDE进行开发
- en: Setting up for development using Maven
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Maven进行开发设置
- en: Frameworks for macros and plugins
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宏和插件的框架
- en: We will look at some tools that ImageJ offers developers to deal with images
    and their processing. In the previous chapter, we looked at macros to perform
    common image-processing steps. This was already an improvement over the processing
    of time series one frame at a time, but ImageJ supports more tools and constructs
    that allow you to expand these basic tools further. In this chapter, we will look
    at some of these constructs as a preparation for the upcoming chapters, where
    we will look at plugins and their implementation.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看ImageJ为开发者提供的处理图像及其处理的一些工具。在前一章中，我们查看宏以执行常见的图像处理步骤。这已经比逐帧处理时间序列有了改进，但ImageJ支持更多工具和结构，允许您进一步扩展这些基本工具。在本章中，我们将查看一些这些结构，为即将到来的章节做准备，在这些章节中，我们将查看插件及其实现。
- en: 'ImageJ has two ways to process in a more automated fashion: macros and plugins.
    Besides the macros described in the previous chapter, ImageJ also supports other
    Java-based scripting languages such as Beanshell and JavaScript, as well as the
    scripting languages Python and Ruby, among others. The plugins can be split into
    two groups as well: plugins based on the original ImageJ (that is, ImageJ1.x plugins)
    and those based on the next development of ImageJ called **ImageJ2** (ImageJ2
    plugins). The ImageJ2 development is designed to be backward compatible with ImageJ1.x,
    although this may change in the future. In this chapter, we will look at some
    of the constructs available when creating scripts and plugins. We will start by
    looking at the scripting languages supported by ImageJ.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ImageJ有两种更自动化的处理方式：宏和插件。除了前一章中描述的宏之外，ImageJ还支持其他基于Java的脚本语言，如Beanshell和JavaScript，以及其他如Python和Ruby等脚本语言。插件也可以分为两组：基于原始ImageJ的插件（即ImageJ1.x插件）和基于ImageJ下一个发展阶段**ImageJ2**（ImageJ2插件）的插件。ImageJ2的开发旨在与ImageJ1.x向后兼容，尽管这可能在将来发生变化。在本章中，我们将探讨在创建脚本和插件时可用的一些结构。我们将首先查看ImageJ支持的脚本语言。
- en: Macros and scripting languages
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 宏和脚本语言
- en: 'As we saw in the previous chapter, we can easily create an ImageJ macro by
    starting the macro recorder and performing different steps for image processing
    and measurements. We set the type to Macro in the recorder. We can do the same
    thing for two other scripting languages that ImageJ supports: **BeanShell** and
    **JavaScript**. BeanShell scripts are a type of macros, but have access to the
    full ImageJ and Java API. This means, besides the commands available in macros,
    you can also use classes and interfaces from Java, providing much more options
    in processing. The advantage of the BeanShell scripting language is that it is
    an interpreted language (it does not have to be compiled before it can be run)
    and requires only an interpreter that has a small footprint. This makes it easy
    to create fast solutions and prototyping for plugins. In the following sections,
    I will examine some of the concepts in the BeanShell scripting language. Note
    that similar results can be achieved in the JavaScript language within ImageJ,
    where the only difference is small changes in syntax.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一章中看到的，我们可以通过启动宏记录器并执行不同的图像处理和测量步骤来轻松创建一个ImageJ宏。我们在记录器中将类型设置为宏。我们还可以为ImageJ支持的另外两种脚本语言做同样的事情：**Beanshell**和**JavaScript**。Beanshell脚本是一种宏类型，但可以访问完整的ImageJ和Java
    API。这意味着，除了宏中可用的命令之外，您还可以使用Java中的类和接口，这为处理提供了更多的选项。Beanshell脚本语言的优势在于它是一种解释型语言（在运行之前不需要编译）并且只需要一个占用空间小的解释器。这使得创建快速解决方案和插件原型变得容易。在接下来的章节中，我将检查Beanshell脚本语言中的一些概念。请注意，在ImageJ的JavaScript语言中也可以实现类似的结果，唯一的区别是语法上的微小变化。
- en: BeanShell scripting
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Beanshell脚本
- en: 'BeanShell scripting allows you to create a script with all the advantages of
    a macro, but with the added benefit of having access to the Java API. You can
    use Java code almost directly as is. However, there are a few small differences.
    BeanShell scripts have weak typing. This means, you do not need to declare the
    variable type, and you can change the type of a variable on-the-fly. In all other
    ways, it is comparable to developing Java code. If you wish to use a class or
    interface from the Java API, you need to import it first using the following line
    of code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: BeanShell 脚本允许你创建一个具有宏所有优点的脚本，同时还能访问 Java API。你可以几乎直接使用 Java 代码。然而，也有一些细微的差别。BeanShell
    脚本具有弱类型。这意味着，你不需要声明变量类型，并且可以在运行时更改变量的类型。在其他所有方面，它与开发 Java 代码相当。如果你希望使用 Java API
    中的类或接口，你需要首先使用以下代码行导入它：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This import statement tells the script interpreter that it needs to load the
    `KeyListener` class from the `java.awt.event` package. This will allow you to
    monitor key presses. The `KeyListener` class is an interface that can be attached
    to an instance of a script. The class will generate an event when a key is pressed,
    resulting in a call to the `keyPressed()` method, which has to be overwritten
    by the script. Using the `keyPressed()` method, you can perform a specific task
    when a certain key is pressed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个导入语句告诉脚本解释器它需要从 `java.awt.event` 包中加载 `KeyListener` 类。这将允许你监控按键。`KeyListener`
    类是一个接口，可以附加到脚本的一个实例上。当按键时，该类将生成一个事件，导致调用 `keyPressed()` 方法，该方法必须由脚本重写。使用 `keyPressed()`
    方法，你可以在按下特定键时执行特定任务。
- en: 'The BeanShell scripting language also supports importing existing scripts into
    a new script. This way, you can daisy-chain multiple scripts. Daisy-chaining scripts
    means you use one script''s output as input for the next script and so on. The
    advantage of this type of processing is that each script becomes a module that
    can be reused and combined in different ways to achieve different results. To
    import an existing script into your script, use the following syntax:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: BeanShell 脚本语言还支持将现有脚本导入到新脚本中。这样，你可以将多个脚本串联起来。串联脚本意味着你使用一个脚本的输出作为下一个脚本的输入，依此类推。这种处理方式的优势在于，每个脚本都成为一个可以重用并以不同方式组合以实现不同结果的模块。要将现有脚本导入到你的脚本中，请使用以下语法：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will load the BeanShell script called `some_script.bsh` and give you access
    to its methods. A simple BeanShell script may consist of a series of basic ImageJ
    commands, but can also contain classes, functions, and even graphical user interfaces.
    We will now look at a few constructs used in the BeanShell scripting language
    that deal with ImageJ, images, and selections.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这将加载名为 `some_script.bsh` 的 BeanShell 脚本，并为你提供访问其方法的能力。一个简单的 BeanShell 脚本可能包含一系列基本的
    ImageJ 命令，但也可以包含类、函数，甚至图形用户界面。现在，我们将探讨在 BeanShell 脚本语言中用于处理 ImageJ、图像和选择的几个结构。
- en: ImageJ main class
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ImageJ 主类
- en: 'To access the main ImageJ window, we can use the `IJ` class to get the current
    instance of ImageJ. We can use this instance to gain access to some parameters
    that are provided by the ImageJ class:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问主 ImageJ 窗口，我们可以使用 `IJ` 类来获取 ImageJ 的当前实例。我们可以使用这个实例来访问 ImageJ 类提供的一些参数：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this short example, we created a variable of type `ImageJ` and stored a reference
    to the current instance of the `ImageJ` window in this variable, called `ij`.
    Next, we extracted the content of the ImageJ status line and stored it in a variable
    called `status`. Finally, we set the text of the status line to `Now we modified
    the status line text!`. Of course, this example is neither directly useful nor
    complete, but it shows you how to get access to the main `ImageJ` interface and
    modify a component of the interface.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的示例中，我们创建了一个 `ImageJ` 类型的变量，并将 `ImageJ` 窗口的当前实例的引用存储在这个变量中，称为 `ij`。接下来，我们提取了
    ImageJ 状态行的内容，并将其存储在一个名为 `status` 的变量中。最后，我们将状态行的文本设置为 `Now we modified the status
    line text!`。当然，这个示例既不直接有用也不完整，但它展示了如何获取主 `ImageJ` 接口并修改接口的一个组件。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'I used two different ways of declaring and instantiating a variable: the `ij`
    variable was first declared and then instantiated, while the `status` variable
    was declared and instantiated in one line. The former would be required if your
    variable requires an extended scope (that is, across a loop or an entire class).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了两种不同的声明和实例化变量的方式：`ij` 变量首先声明然后实例化，而 `status` 变量则在同一行中声明和实例化。如果变量需要扩展的作用域（即，跨越一个循环或整个类），则前者是必需的。
- en: 'It is also possible to use the `IJ` class to execute commands that are part
    of the ImageJ menu structure using the `run()` method or methods such as `openImage()`
    to load images:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用`IJ`类通过`run()`方法或如`openImage()`等方法来执行ImageJ菜单结构中的命令：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The second line shows you how to zoom in once using the `run()` method from
    the `IJ` class. The third line shows you how to open an image using the `openImage()`
    method, which stores a reference to the image in a variable named `imp` in this
    example. To gain access to an image from within a BeanShell script, we can use
    the `openImage()`, as described earlier, to open an image. Alternatively, we could
    use the current active image (if there is an opened image):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行显示了如何使用`IJ`类的`run()`方法进行一次缩放。第三行显示了如何使用`openImage()`方法打开一个图像，在这个例子中，它将图像的引用存储在名为`imp`的变量中。要从BeanShell脚本内部访问图像，我们可以使用前面描述的`openImage()`来打开图像。或者，我们也可以使用当前的活动图像（如果已打开图像）：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that in Fiji, which uses the ImageJ2 release candidate, it is required
    that you add the import statement before using the `IJ` class' methods. In ImageJ1.x,
    these packages are auto-loaded and the import statement is optional. To make sure
    your scripts are future proof, it is best practice to include the import statements.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在Fiji中，它使用ImageJ2候选版本，在使用`IJ`类的方法之前，需要添加导入语句。在ImageJ1.x中，这些包是自动加载的，导入语句是可选的。为了确保您的脚本具有未来性，包含导入语句是最佳实践。
- en: Functions to process images
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 图像处理函数
- en: 'Using the ImageJ class, you have access to the currently active image as well
    as to the methods to open images. There are also methods that allow you to process
    images on a pixel level using the `ImageProcessor` class. This class provides
    methods that can modify the image at the pixel level: either a single pixel or
    a group of pixels. The following snippet shows you how to use the `ImageProcessor`
    class to change the value of a specific pixel:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ImageJ类，您可以访问当前的活动图像以及打开图像的方法。还有允许您使用`ImageProcessor`类在像素级别处理图像的方法。此类提供了可以在像素级别修改图像的方法：单个像素或一组像素。以下代码片段显示了如何使用`ImageProcessor`类更改特定像素的值：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, we opened the **Blobs** sample image and got `ImageProcessor`.
    We then inverted the LUT (the **Blobs** image uses an inverted LUT when opened)
    and put the inverted image back in the `imp` object. Finally, we set the value
    for the pixel at the coordinates (x = `64`, y = `128`) to a value of `255`. In
    this example, you will see a white pixel in one of the blobs at the location (`64,128`).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们打开了**Blobs**样本图像并获得了`ImageProcessor`。然后我们反转了LUT（当打开时**Blobs**图像使用反转的LUT）并将反转的图像放回`imp`对象中。最后，我们将坐标（x
    = `64`，y = `128`）处的像素值设置为`255`。在这个例子中，您将在一个位于（`64,128`）位置的blob中看到一个白色像素。
- en: 'If the active image is an 8-bit image (as is the case for the **Blobs** image),
    this would result in a white pixel. In a 16-bit image this operation would result
    in a dark-gray pixel. If you want to know if the current image is a gray scale
    image and how many bits per pixel (8, 16, 24, or 32) it has, you could include
    the following commands:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果活动图像是8位图像（例如**Blobs**图像），这将导致一个白色像素。在16位图像中，此操作将导致一个深灰色像素。如果您想了解当前图像是否是灰度图像以及它有多少位每像素（8、16、24或32），您可以包含以下命令：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will allow you to determine exactly what kind of image you are dealing
    with. If `bGray` is `true`, the image is an 8,16, or 32 float grayscale image
    or a 24-bit image with identical values for the pixels in the red, green, and
    blue channels. The `bitDepth` value will tell you which level it is. The distinction
    is small, but significant. A 24-bit image that contains color information is not
    the same as a 24-bit image that is gray. The latter can be converted to an 8-bit
    image without loss of information, while the former cannot be converted to an
    8-bit image without losing the color information.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许您确切地确定您正在处理什么类型的图像。如果`bGray`为`true`，则图像是8、16或32位浮点灰度图像或具有红色、绿色和蓝色通道像素值相同的24位图像。`bitDepth`值将告诉您它是哪个级别。这种区别很小，但很重要。包含颜色信息的24位图像与灰度的24位图像不同。后者可以在不丢失信息的情况下转换为8位图像，而前者则不能在不丢失颜色信息的情况下转换为8位图像。
- en: Functions for selections
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 选择函数
- en: 'To gain access to selections in the ROI Manager, BeanShell scripts allow you
    to get an instance of the ROI Manager, which can then be used to extract the ROIs
    and use them for processing. The following code snippet takes the ROIs from the
    ROI Manager and enlarges them by `2` pixels:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问ROI管理器中的选择，BeanShell脚本允许您获取ROI管理器的实例，然后可以使用它提取ROI并用于处理。以下代码片段从ROI管理器中获取ROI并将它们放大`2`像素：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This snippet shows you some basic scripting to deal with ROIs. We first retrieved
    an instance of the ROI Manager, which allows us to get the ROIs as an array for
    processing. In the loop, we selected each ROI and used the enlarge command to
    increase the size of the ROI by `2` pixels in the *X* and *Y* directions. Finally,
    we added the enlarged ROIs to the ROI Manager so that we could use them later
    on if we would like to. This code can be used almost verbatim as Java code. The
    first error you would receive if you tried to compile it is contained in the following
    line:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段展示了处理感兴趣区域（ROI）的一些基本脚本。我们首先检索ROI管理器的实例，这允许我们将ROI作为数组进行处理。在循环中，我们选择每个ROI并使用放大命令在*X*和*Y*方向上增加ROI的大小`2`像素。最后，我们将放大的ROI添加到ROI管理器中，以便我们稍后可以使用它们。此代码几乎可以原样用作Java代码。如果您尝试编译它，您会收到的第一个错误包含在以下行中：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This works perfectly fine in a BeanShell script, but in an ImageJ plugin, it
    will generate an error as the type of the `imp` variable is not declared. Also,
    the for loop does not declare the type for the index `i` iterator, which will
    also generate a compiler error.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这在BeanShell脚本中运行得非常好，但在ImageJ插件中，它将生成一个错误，因为`imp`变量的类型未声明。此外，for循环没有为索引`i`迭代器声明类型，这也会生成编译器错误。
- en: Saving and running your scripts
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存和运行您的脚本
- en: 'Once we have created a testable version, we can save it and try running it.
    Macros are stored with either the `.ijm` or the `.txt` extension. The `.ijm` extension
    is preferable, as it allows the distinction between regular (non-script) text
    files and macro files. Script files have their own extensions: `.bsh` for BeanShell
    and `.js` for JavaScript.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了可测试的版本，我们就可以保存它并尝试运行。宏以`.ijm`或`.txt`扩展名存储。`.ijm`扩展名更可取，因为它允许区分常规（非脚本）文本文件和宏文件。脚本文件有自己的扩展名：BeanShell的`.bsh`和JavaScript的`.js`。
- en: When saving the script, the naming has to adhere to the limitations of the filesystem.
    Otherwise, there are no specific restrictions for the name. The location to store
    the scripts by default is the `scripts` or `macros` folder in the ImageJ installation
    folder, which I will refer to as `$IJ_HOME`. If you wish to run scripts from the
    command line, it is best to avoid using spaces in the filename to avoid unexpected
    behavior (that is, if you forget to escape the space character).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本时，命名必须遵守文件系统的限制。否则，对名称没有具体限制。默认情况下，存储脚本的目录是ImageJ安装文件夹中的`scripts`或`macros`文件夹，我将称之为`$IJ_HOME`。如果您想从命令行运行脚本，最好避免在文件名中使用空格，以避免出现意外行为（即，如果您忘记转义空格字符）。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For Fiji, the `$IJ_HOME` folder is called `Fiji.app` and can be placed at any
    location in the filesystem. It is recommended that you store this folder in your
    user account's folder, where you have read and write access. On OSX systems, the
    default location for Fiji is `/Applications/Fiji.app` when using the package installer.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Fiji，`$IJ_HOME`文件夹被称为`Fiji.app`，可以放置在文件系统的任何位置。建议您将此文件夹存储在您的用户账户文件夹中，您有读写权限。在OSX系统上，使用包安装器时，Fiji的默认位置是`/Applications/Fiji.app`。
- en: As described about ImageJ macros in the previous chapter, BeanShell and JavaScript
    scripts can be installed and executed in similar ways. When using Fiji, you can
    open the scripts in the code editor to run them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，关于ImageJ宏的描述，BeanShell和JavaScript脚本可以以类似的方式安装和执行。当使用Fiji时，您可以在代码编辑器中打开脚本以运行它们。
- en: Plugins for ImageJ
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ImageJ插件
- en: As we saw in the previous sections on the BeanShell scripting language, ImageJ
    provides an easy interface that has access to the full Java API. This also holds
    true for plugins. Besides the core ImageJ API, plugins can also access the full
    Java API by importing classes or interfaces in their source files. With the current
    developments within the ImageJ community, there is a new implementation of the
    ImageJ core code being developed, called ImageJ2\. In the following sections,
    I will briefly give an overview of some of the changes that will influence the
    development of plugins. This involves introducing some constructs that are used
    commonly in larger projects, specifically Git and Maven. Note that knowledge of
    these constructs is not essential to create plugins, but they will help in creating
    more consistent and reproducible code. These constructs are also not specific
    for ImageJ2, but the ImageJ2 project was built up around those concepts. However,
    I will start by introducing some classes that are specific for ImageJ and deal
    with handling images and selections.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在前几节关于BeanShell脚本语言的讨论中看到的，ImageJ提供了一个易于访问的接口，可以访问完整的Java API。这一点同样适用于插件。除了核心的ImageJ
    API之外，插件还可以通过在其源文件中导入类或接口来访问完整的Java API。随着ImageJ社区的发展，正在开发一个新的ImageJ核心代码实现，称为ImageJ2。在接下来的几节中，我将简要概述一些将影响插件开发的变更。这包括引入一些在大型项目中常用到的结构，特别是Git和Maven。请注意，了解这些结构对于创建插件不是必需的，但它们将有助于创建更一致和可重复的代码。这些结构也不是ImageJ2特有的，但ImageJ2项目是基于这些概念构建的。然而，我将首先介绍一些特定于ImageJ的类，它们用于处理图像和选择。
- en: ImageJ main class
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ImageJ主类
- en: 'The main ImageJ class refers to the class that gives access to the ImageJ application.
    We already saw this class in the BeanShell sections earlier. The class is called
    IJ, which is a static utility class. As shown earlier, this class allows access
    to the current image as well as other functions. The use of this class is the
    same as shown earlier, except when writing plugins, you need to explicitly declare
    the variable type. For instance, when we wish to create a new hyperstack with
    two 16-bit channels and 10 frames and a size of 512 X 512 pixels, we could use
    the following code snippet:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的ImageJ类指的是提供访问ImageJ应用程序的类。我们之前在BeanShell部分已经看到了这个类。这个类被称为IJ，它是一个静态实用类。如前所述，这个类允许访问当前图像以及其他功能。这个类的使用方法与之前相同，只是在编写插件时，需要显式声明变量类型。例如，当我们希望创建一个包含两个16位通道、10帧和512
    X 512像素大小的新的超堆栈时，我们可以使用以下代码片段：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note that we need to specify that the `imp` variable is of type `ImagePlus`,
    which differs from the scripting languages that we saw earlier. Another useful
    method of the `IJ` class is the `log()` logging method. This method prints a string
    to a log window, and displays the log window if it is not open yet. This function
    is useful for presenting intermediate results or status updates when processing
    large datasets. To use it, we can just call the method and supply the string we
    wish to print:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们需要指定`imp`变量是`ImagePlus`类型，这与我们之前看到的脚本语言不同。`IJ`类另一个有用的方法是`log()`日志方法。此方法将字符串打印到日志窗口，并在尚未打开的情况下显示日志窗口。此功能在处理大型数据集时用于展示中间结果或状态更新很有用。要使用它，我们只需调用该方法并传入我们希望打印的字符串：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This assumes there is a variable called `nFiles`, which stores the number of
    files that need to be processed. The log message will tell us how many files were
    processed, depending on the number of files selected when the plugin was executed.
    There are also methods to open images or get the active image, which are identical
    to the examples used in the scripting section (with the only difference that the
    type needs to be declared explicitly in a plugin).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这假设存在一个名为`nFiles`的变量，它存储需要处理的文件数量。日志消息将告诉我们处理了多少文件，这取决于在插件执行时选择的文件数量。还有打开图像或获取活动图像的方法，这些方法与脚本部分中使用的示例相同（唯一的区别是需要在插件中显式声明类型）。
- en: WindowManager
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 窗口管理器
- en: 'The `WindowManager` class is a utility class in ImageJ that keeps track of
    all the windows (including images, results, and log windows), and provides methods
    that allow the selection of specific windows. Some of the most useful methods
    are `getImageTitles()`, `getImage()`, and `getCurrentImage()`. The `getImageTitles`
    method returns a `String` array with all the titles of open images. This function
    is useful to populate a list of files to allow the user to select a specific image
    for processing. The following example code will show this functionality and how
    it can be used within a program:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`WindowManager`类是ImageJ中的一个实用类，它跟踪所有窗口（包括图像、结果和日志窗口），并提供允许选择特定窗口的方法。其中一些最有用的方法是`getImageTitles()`、`getImage()`和`getCurrentImage()`。`getImageTitles`方法返回一个包含所有打开图像标题的`String`数组。此功能非常有用，可以填充文件列表，以便用户选择要处理的特定图像。以下示例代码将展示此功能以及如何在程序中使用它：'
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is a very user-friendly way of allowing the user to select the image for
    processing. Normally, ImageJ uses the last open images (the active image) by default.
    When the user has selected an image based on the title of the image, we can use
    the `getImage` method to activate that image for further processing:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常用户友好的方式，允许用户选择要处理的图像。通常，ImageJ默认使用最后打开的图像（活动图像）。当用户根据图像标题选择了一个图像时，我们可以使用`getImage`方法激活该图像以进行进一步处理：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This allows the rest of the program to use the specified image for processing.
    This code will be revisited in the chapter on plugins with user interfaces.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许程序的其他部分使用指定的图像进行处理。这段代码将在关于具有用户界面的插件的章节中再次讨论。
- en: ImagePlus
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ImagePlus
- en: 'The main class for images is the `ImagePlus` class, which is the main class
    to deal with images in ImageJ. We already briefly saw the call in the code section
    earlier. When invoking the `ImagePlus` class, we gain access to several get methods
    that help with extracting information from the image. We also apply changes to
    the image using set methods:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图像的主要类是`ImagePlus`类，它是ImageJ中处理图像的主要类。我们已经在之前的代码部分中简要地看到了它的调用。当调用`ImagePlus`类时，我们可以访问几个帮助从图像中提取信息的方法。我们还可以使用设置方法对图像进行更改：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This snippet shows a few methods that allow you to retrieve aspects of the image
    as well as set a region in the current image. Another important method that can
    be accessed using the `ImagePlus` class is the `ImageProcessor` class, as shown
    in the first line of the code snippet. The next section will deal with this class.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段展示了几个允许您检索图像的各个方面以及设置当前图像中的区域的方法。另一个可以通过`ImagePlus`类访问的重要方法是`ImageProcessor`类，如代码片段的第一行所示。下一节将讨论这个类。
- en: ImageProcessor
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ImageProcessor
- en: 'The `ImageProcessor` class is a class that allows you to work with the pixel
    array of an image. There are four different subclasses of the `ImageProcessor`
    class, which are linked to the different image types: `ByteProcessor` for 8-bit
    and binary images, `ShortProcessor` for 16-bit images, `FloatProcessor` for 32-bit
    float images, and `ColorProcessor` for RGBα images. Some of the methods that are
    accessible from an `ImageProcessor` instance include `autoThreshold()`, `crop()`,
    `getPixel()`, and `getIntArray()`. These functions allow you to set a threshold
    on an image, crop the image, retrieve the pixel value at a specified location
    or get all the pixel values as an array, respectively.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageProcessor`类是一个允许您处理图像像素数组的类。`ImageProcessor`类有四个不同的子类，分别与不同的图像类型相关联：`ByteProcessor`用于8位和二进制图像，`ShortProcessor`用于16位图像，`FloatProcessor`用于32位浮点图像，以及`ColorProcessor`用于RGBα图像。从`ImageProcessor`实例可访问的一些方法包括`autoThreshold()`、`crop()`、`getPixel()`和`getIntArray()`。这些函数允许您在图像上设置阈值，裁剪图像，在指定位置检索像素值或以数组形式获取所有像素值。'
- en: RoiManager
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RoiManager
- en: 'The `RoiManager` class gives the user access to the ROI Manager and all its
    functions. This class is essential to retrieve and manipulate the regions that
    were set either manually or programmatically. The `getRoisAsArray()` method allows
    the user to retrieve all the regions in the ROI Manager as an array, which enables
    the user to loop over all the regions for measurements or modifications to the
    regions. The following code is an example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`RoiManager`类使用户能够访问ROI管理器和所有其功能。这个类对于检索和操作手动或程序设置的区域是必不可少的。`getRoisAsArray()`方法允许用户以数组的形式检索ROI管理器中的所有区域，这使得用户能够遍历所有区域进行测量或修改区域。以下代码是一个示例：'
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It is recommended that you use the `getInstance()` method to get a reference
    to the ROI Manager. If it returns a null value, you could use the constructor
    to create a new instance. After using the `getRoisAsArray()` method, you get an
    array of type `Roi`, which contains a list of regions.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您使用 `getInstance()` 方法来获取 ROI 管理器的引用。如果它返回一个 null 值，您可以使用构造函数来创建一个新的实例。在使用
    `getRoisAsArray()` 方法后，您将得到一个类型为 `Roi` 的数组，其中包含一系列区域。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can also merge the declaration and instantiating of the `regions` variable
    to a single statement. I prefer to declare my variables at the beginning of a
    method or class and instantiate them when I have the data available. Declaring
    a variable before instantiating it would be essential if you need the scope of
    the variable to extend beyond the point where it is instantiated or assigned.
    When a variable is used inside and outside of a loop, but the value is only assigned
    within the loop, the declaration needs to be placed outside of the loop and the
    assignment within the loop.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将 `regions` 变量的声明和实例化合并为一条单独的语句。我更喜欢在方法或类的开头声明变量，并在有数据可用时实例化它们。在实例化或分配之前声明变量对于需要变量作用域扩展到实例化或分配点的范围之外的情况是必要的。当一个变量在循环内外使用，但值仅在循环内分配时，声明需要放在循环之外，分配在循环内。
- en: The Roi class
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Roi 类
- en: The `Roi` class is a generic class that encompasses all the region types that
    ImageJ supports. You can use this class to retrieve relevant properties of a region,
    such as the bounding box of the region using the `getBounds()` method. It is also
    possible to change the size using the `grow()` method. The `Roi` class has several
    subclasses that are linked to the different region types available in ImageJ.
    Some of these subclasses have additional methods that are specific for area regions.
    For instance, the `PolygonRoi` subclass has methods to retrieve the coordinates
    of the polygon, `getXCoordinates()` and `getYCoordinates()`, which return an `int`
    array of coordinates.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Roi` 类是一个泛型类，它包含 ImageJ 支持的所有区域类型。您可以使用此类检索区域的相关属性，例如使用 `getBounds()` 方法获取区域的边界框。您还可以使用
    `grow()` 方法更改大小。`Roi` 类有几个子类，它们与 ImageJ 中可用的不同区域类型相关联。其中一些子类具有针对面积区域特定的额外方法。例如，`PolygonRoi`
    子类有获取多边形坐标的方法，`getXCoordinates()` 和 `getYCoordinates()`，它们返回坐标的 `int` 数组。'
- en: The Application Programming Interface
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序编程接口
- en: As with many programming languages, ImageJ has a well-documented **Application
    Programming Interface** (**API**). It describes all of the classes, methods, and
    fields that are accessible for programming. The API reference can be found on
    the ImageJ website at [http://javadoc.imagej.net/ImageJ1](http://javadoc.imagej.net/ImageJ1)
    (ImageJ1.x), [http://javadoc.imagej.net/ImageJ](http://javadoc.imagej.net/ImageJ)
    (ImageJ2), and [http://javadoc.imagej.net/Fiji](http://javadoc.imagej.net/Fiji)
    (Fiji). The API documentation is an efficient way to find classes and methods
    that can be used to extract relevant information. The classes mentioned in the
    previous sections can be found using the API page. You can also find a complete
    list of methods and fields that are available, including the return types of the
    methods. In the section on setting up an IDE to develop plugins, I will also briefly
    explain how to set up the generation of Javadoc. Javadoc is a method that parses
    your source code and extracts specially formatted comments to build up a documentation
    manual. This can be done for the ImageJ source code, which results in an API that
    can be accessed offline. I will also show you how to write your own Javadoc documentation
    and then generate an API for your own code in the chapter on plugin development.
    This is not essential for small projects, but can be very helpful for large projects
    with complex code that uses many classes and methods.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 就像许多编程语言一样，ImageJ有一个很好的**应用程序编程接口**（**API**）文档。它描述了所有可编程访问的类、方法和字段。API参考可以在ImageJ网站上找到，网址为[http://javadoc.imagej.net/ImageJ1](http://javadoc.imagej.net/ImageJ1)（ImageJ1.x）、[http://javadoc.imagej.net/ImageJ](http://javadoc.imagej.net/ImageJ)（ImageJ2）和[http://javadoc.imagej.net/Fiji](http://javadoc.imagej.net/Fiji)（Fiji）。API文档是查找可用于提取相关信息的类和方法的有效方式。前几节中提到的类可以通过API页面找到。您还可以找到方法字段的全列表，包括方法的返回类型。在设置用于开发插件的IDE的章节中，我还会简要解释如何设置Javadoc的生成。Javadoc是一种解析您的源代码并提取特殊格式注释以构建文档手册的方法。这可以应用于ImageJ源代码，从而生成一个可以离线访问的API。我还会向您展示如何编写自己的Javadoc文档，然后在插件开发章节中生成您自己的代码的API。这对于小型项目不是必需的，但对于具有复杂代码的大型项目非常有帮助，这些代码使用了大量类和方法。
- en: Setting up NetBeans IDE
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置NetBeans IDE
- en: We will now look at how to set up an **Integrated Development Environment**
    (**IDE**) that can be used to develop ImageJ as well as plugins for ImageJ. There
    are many IDEs available for Java. While this section will show you how to set
    up a specific IDE called NetBeans, many of these settings and configurations can
    be replicated in your preferred IDE.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将探讨如何设置一个**集成开发环境**（**IDE**），它可以用来开发ImageJ以及ImageJ的插件。Java有很多可用的IDE。虽然本节将向您展示如何设置一个名为NetBeans的特定IDE，但许多这些设置和配置可以在您首选的IDE中复制。
- en: The setup I will describe is for the NetBeans IDE, which is developed by the
    same company that manages the Java language. It can be downloaded in different
    variants, including a variant for Java development, webpage development, and C++
    development. If you only wish to develop plugins for ImageJ, the Java SE (Standard
    Edition) or Java EE (Enterprise Edition) downloads should be fine. The enterprise
    edition is similar to the standard edition, but it has additional APIs for multilevel
    and scalable applications as well as secure network applications. It is possible
    to extend the basic Java edition and add modules for web development or C++ coding
    later on using the **Plugins Manager** (**Tools** | **Plugins**).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我将要描述的设置是针对NetBeans IDE的，它是由管理Java语言的公司开发的。它可以下载不同的版本，包括用于Java开发、网页开发和C++开发的版本。如果你只想为ImageJ开发插件，Java
    SE（标准版）或Java EE（企业版）的下载应该就足够了。企业版与标准版类似，但它提供了用于多级和可扩展应用程序以及安全网络应用程序的额外API。可以使用**插件管理器**（**工具**
    | **插件**）在以后扩展基本Java版本并添加用于网页开发或C++编码的模块。
- en: For the upcoming sections, I will assume that the Java SE was installed. However,
    to set up the environment, it should not make a difference. It can be downloaded
    from [https://netbeans.org/downloads/](https://netbeans.org/downloads/). After
    downloading, it can be installed using the standard method for your platform.
    For Windows systems, there is an installer that can be run by double-clicking.
    For OS X, there is DMG with a package file that can be used for installation.
    For Linux systems, there is a shell script installer, and some distributions may
    supply it from their repositories. It is recommended that you use the version
    from the NetBeans website, as it is more recent than the version in many of the
    repositories.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于即将到来的部分，我将假设Java SE已经安装。然而，为了设置环境，这并不会造成差异。它可以从[https://netbeans.org/downloads/](https://netbeans.org/downloads/)下载。下载后，可以使用您平台的标准方法进行安装。对于Windows系统，有一个可以通过双击运行的安装程序。对于OS
    X，有一个包含包文件的DMG文件，可用于安装。对于Linux系统，有一个shell脚本安装程序，某些发行版可能从它们的仓库中提供。建议您使用NetBeans网站上的版本，因为它比许多仓库中的版本更新。
- en: The following sections will describe how to develop ImageJ1.x plugins without
    using project tools. This method only requires a single download and functions
    as a standalone development platform. If you wish to develop plugins using the
    Maven platform for ImageJ1.x and ImageJ2, the following sections can be skipped,
    and you can continue to the *Developing plugins using Maven* section.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的章节将描述如何在不使用项目工具的情况下开发ImageJ1.x插件。这种方法只需要下载一次，并作为一个独立开发平台运行。如果您希望使用Maven平台为ImageJ1.x和ImageJ2开发插件，可以跳过以下章节，继续到**使用Maven开发插件**部分。
- en: Gathering all components
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 收集所有组件
- en: After the installation has completed, you should be able to launch the NetBeans
    application. When you launch it for the first time, there will be a start page
    that allows you to take a tour of the software and watch a quick tutorial project.
    You can examine the settings and adjust them to your liking.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您应该能够启动NetBeans应用程序。第一次启动时，将有一个起始页面，允许您浏览软件并观看快速教程项目。您可以检查设置并根据您的喜好进行调整。
- en: Next, we need to download the source code for ImageJ. The source code can be
    downloaded from the ImageJ website at [http://imagej.nih.gov/ij/download/src/](http://imagej.nih.gov/ij/download/src/),
    where you will find a list of different versions, from version 1.20 up to the
    most recent version (1.50a). Which version you download is not critical. However,
    it is best to use the most recent version with the recent bug fixes and functionality
    added. After the download has finished, the archive can be extracted, resulting
    in a folder named `source`. For the following sections, I will assume that the
    content of the `source` folder was extracted to the `ij/src` folder within the
    Documents folder of your user profile. This folder location will be referred to
    as the `source` folder in the next sections.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要下载ImageJ的源代码。源代码可以从ImageJ网站[http://imagej.nih.gov/ij/download/src/](http://imagej.nih.gov/ij/download/src/)下载，在那里您将找到从版本1.20到最新版本（1.50a）的不同版本列表。您下载哪个版本并不重要。然而，最好使用带有最新错误修复和新增功能的最新版本。下载完成后，可以将存档提取出来，生成一个名为`source`的文件夹。在接下来的章节中，我将假设`source`文件夹的内容已提取到用户配置文件中的Documents文件夹内的`ij/src`文件夹中。这个文件夹位置将在接下来的章节中被称为`source`文件夹。
- en: Setting up a project
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置项目
- en: The setup of the project described here follows the description given at [http://rsb.info.nih.gov/ij/developer/NBTutorial.html](http://rsb.info.nih.gov/ij/developer/NBTutorial.html),
    but with a few adjustments. First, the method to create a project does not work
    properly when using NetBeans version 8.0\. The steps described here will accomplish
    the same result but with a few key changes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的项目设置遵循[http://rsb.info.nih.gov/ij/developer/NBTutorial.html](http://rsb.info.nih.gov/ij/developer/NBTutorial.html)中给出的描述，但做了一些调整。首先，当使用NetBeans
    8.0版本时，创建项目的该方法不能正常工作。这里描述的步骤将实现相同的结果，但有一些关键更改。
- en: The first step is to set up a new project for ImageJ in NetBeans.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是在NetBeans中为ImageJ设置一个新的项目。
- en: To do so, go to **File** | **New Project…**, which will open the following dialog:![Setting
    up a project](img/Insert_image_4909_07_01.jpg)
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要这样做，请转到**文件** | **新建项目…**，这将打开以下对话框：![设置项目](img/Insert_image_4909_07_01.jpg)
- en: In the dialog, select the **Java** category and select **Java Free-Form Project**,
    as shown in the figure. Then, click on **Next >**.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对话框中，选择**Java**类别，并选择**Java Free-Form Project**，如图所示。然后，点击**下一步 >**。
- en: In the next step, we have to select the folder that contains the source. **Click
    on Browse…** and select the `src` folder that contains the extracted source code.
    If the copying was done properly, the remaining fields will be completed automatically
    with the correct information:![Setting up a project](img/Insert_image_4909_07_02.jpg)
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，我们必须选择包含源代码的文件夹。**点击浏览…**并选择包含提取源代码的`src`文件夹。如果复制操作正确完成，剩余字段将自动填写正确的信息：![设置项目](img/Insert_image_4909_07_02.jpg)
- en: We can now click on **Next >** to proceed to **Build and Run Actions** and then
    click on **Next** again without modifying the fields.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以点击**下一步 >**以继续到**构建和运行操作**，然后再次点击**下一步**而不修改字段。
- en: In the next step, we have to set the locations that will contain our source
    code for ImageJ and for our plugins.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，我们必须设置包含我们的ImageJ源代码和插件源代码的位置。
- en: To do so, add the `ij/src/ij` and `ij/src/plugins` folders in the **Source Package
    Folders** field. You can remove the first entry marked with a period from the
    source package folders. I have set the source level to JDK 1.7, which forces NetBeans
    to use a newer version of Java compared to the definition in the build instructions
    of the ImageJ source code:![Setting up a project](img/Insert_image_4909_07_03.jpg)
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要这样做，请在**源包文件夹**字段中添加`ij/src/ij`和`ij/src/plugins`文件夹。您可以从源包文件夹中删除带有点的第一个条目。我已经将源级别设置为JDK
    1.7，这将强制NetBeans使用比ImageJ源代码构建说明中定义的新版本Java：![设置项目](img/Insert_image_4909_07_03.jpg)
- en: 'Click on **Finish** to complete the setup process:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**完成**以完成设置过程：
- en: Tip
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The last two steps can be kept to default settings.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个步骤可以保持默认设置。
- en: 'The project will now be created, and the main window of NetBeans will show
    the new project in the **Projects** tab on the left-hand side. The project name
    (`ImageJ`) has two package sources below it: one for ImageJ source code (`ij`)
    and one for the plugin source code (`plugins`).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 项目现在将被创建，NetBeans的主窗口将在左侧的**项目**选项卡中显示新项目。项目名称（`ImageJ`）下面有两个包源：一个用于ImageJ源代码（`ij`）和一个用于插件源代码（`plugins`）。
- en: 'The **Files** tab will show an overview of the files associated with the project:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件**选项卡将显示与项目相关的文件概览：'
- en: '![Setting up a project](img/Insert_image_4909_07_04.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![设置项目](img/Insert_image_4909_07_04.jpg)'
- en: The next section will look at the configuration required building build ImageJ.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将查看构建ImageJ所需的配置。
- en: Building ImageJ
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建ImageJ
- en: 'We will now set up the environment to build ImageJ. This will allow us to create
    a functional ImageJ program from which we will be able to execute our plugins
    and macros. The first step is to modify the build instructions that will be used
    when building the ImageJ project. To do so, select the **Projects** tab and double-click
    on the `build.xml` file at the bottom of the ImageJ project to open the build
    file. This is a standard XML file that can be edited using the XML syntax. To
    disable sections of code, you can use either a comment tag (`<!-- -->`) around
    that section or delete it completely. The comment method is advised if you wish
    to restore the file to the original state. The first line that needs to be disabled
    is line 12 (I''m using comments to disable it):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将设置环境以构建ImageJ。这将使我们能够创建一个功能性的ImageJ程序，通过该程序我们可以执行我们的插件和宏。第一步是修改构建ImageJ项目时将使用的构建说明。为此，选择**项目**选项卡，双击ImageJ项目底部的`build.xml`文件以打开构建文件。这是一个标准的XML文件，可以使用XML语法进行编辑。要禁用代码部分，您可以使用该部分的注释标签（`<!--
    -->`）或完全删除它。如果您希望将文件恢复到原始状态，建议使用注释方法。需要禁用的第一行是第12行（我正在使用注释来禁用它）：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Save the file after making the change. Next, we will remove the two `.source`
    files from the `plugins` folder, but not the `.class` files. We can now start
    building ImageJ, by clicking on **Run** | **Build Project (ImageJ)** or pressing
    *F11*. There may be a few red warnings in the **Build output** window, but these
    can be ignored for now. At the end of the output, it should say **BUILD SUCCESSFUL**.
    We will now add the newly created ImageJ build to the project. To do so, go to
    **File** | **Project Properties (ImageJ)** and then to the **Java Sources Classpath**
    category. First, select **ij[ij]** as the source package folder and click on the
    **Add JAR/Folder** button. Browse to the `src` folder, select the `ij.jar` file,
    and press the **Choose** button. Repeat this for the `plugins [plugins]` source
    package folder, and then press **OK** to finish. We are now ready to set up the
    configuration to develop plugins.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后保存文件。接下来，我们将从`plugins`文件夹中删除两个`.source`文件，但不要删除`.class`文件。现在我们可以通过点击**运行**
    | **构建项目（ImageJ）**或按*F11*来开始构建ImageJ。在**构建输出**窗口中可能会有一些红色警告，但现在可以忽略它们。输出结束时，应该显示**构建成功**。现在我们将新创建的ImageJ构建添加到项目中。为此，请转到**文件**
    | **项目属性（ImageJ）**，然后转到**Java源文件类路径**类别。首先，选择**ij[ij]**作为源包文件夹，然后点击**添加JAR/文件夹**按钮。浏览到`src`文件夹，选择`ij.jar`文件，然后按**选择**按钮。对于`plugins
    [plugins]`源包文件夹重复此操作，然后按**确定**完成。我们现在已准备好设置开发插件的配置。
- en: Creating a plugin
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建插件
- en: 'We will now create a very basic plugin to prepare everything to compile and
    debug plugins using NetBeans. First, switch to the **Files** tab and right-click
    on the plugins folder. Then, go to **New** | **Java Class** from the context menu.
    In the dialog that opens, set the **Class Name** to `Plugin_Frame` (or something
    else, but always include an underscore in the name!). It is advised that you create
    a package for the new class instead of the default package (I''m using **Template**
    as an example). Click on **Finish** to create the new Java source file:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个非常基础的插件，为使用NetBeans编译和调试插件做准备。首先，切换到**文件**选项卡，在插件文件夹上右键单击。然后，从上下文菜单中选择**新建**
    | **Java类**。在打开的对话框中，将**类名**设置为`Plugin_Frame`（或其它名称，但名称中始终包含一个下划线！）。建议为新的类创建一个包而不是默认包（我使用**Template**作为示例）。点击**完成**以创建新的Java源文件：
- en: '![Creating a plugin](img/Insert_image_4909_07_05.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![创建插件](img/Insert_image_4909_07_05.jpg)'
- en: 'Next, we will place the following code in the newly created source file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将以下代码放入新创建的源文件中：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will create a plugin that inverts the LUT of the currently active image.
    Next, save the source file, and we will compile the code that we just added to
    our source file. To compile the source code, go to **Run** | **Compile File**
    or press *F9*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个插件，该插件将当前活动图像的LUT反转。接下来，保存源文件，我们将编译我们刚刚添加到源文件中的代码。要编译源代码，请转到**运行** | **编译文件**或按*F9*。
- en: 'A window will pop up to ask whether you wish to generate an ide-file-targets.xml
    file, so click on **Generate**. A new file will open that contains the build instructions
    for your plugin:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将会弹出一个窗口询问是否希望生成一个ide-file-targets.xml文件，因此请点击**生成**。将打开一个新文件，其中包含您插件的构建说明：
- en: '![Creating a plugin](img/Insert_image_4909_07_06.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![创建插件](img/Insert_image_4909_07_06.jpg)'
- en: 'In the `ide-file-targets.xml` file, we will modify two lines. First, we will
    change line 9 to the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ide-file-targets.xml`文件中，我们将修改两行。首先，我们将第9行更改为以下内容：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will replace `${build.classes.dir}` with `plugins`. Next, we will comment
    line 8 (or delete it):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用`plugins`替换`${build.classes.dir}`。接下来，我们将注释掉第8行（或删除它）：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, save the modified file and select your plugin file again. We will compile
    the file again by going to **Run** | **Compile File** or by pressing *F9*. In
    the output view, it should show that the build was successful. Next, we are going
    to set up the debugging for plugins. Select **Debug** | **Debug Project (ImageJ)**
    at which point a dialog will pop up asking for the output to be set. Click on
    **Set Output** and then on **OK** to accept the default values. Go to **Debug**
    | **Debug Project (ImageJ)** again, and NetBeans will ask to generate an `ide-targets.xml`
    file. Click on **Generate** to create the file and leave the file unaltered. For
    the final time, go to **Debug** | **Debug Project (ImageJ)**. This time, ImageJ
    will launch, and your plugin can be found in the **Plugins** menu. To start your
    plugin, select **Plugins** | **Template** | **Plugin Frame Plugin**, and your
    plugin should become visible.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，保存修改后的文件并再次选择你的插件文件。我们将通过转到**运行** | **编译文件**或按*F9*来再次编译文件。在输出视图中，应该显示构建成功。接下来，我们将设置插件的调试。选择**调试**
    | **调试项目（ImageJ）**，此时将弹出一个对话框，要求设置输出。点击**设置输出**然后点击**确定**以接受默认值。再次转到**调试** | **调试项目（ImageJ）**。这次，ImageJ将启动，你的插件可以在**插件**菜单中找到。要启动你的插件，选择**插件**
    | **模板** | **插件框架插件**，你的插件应该会变得可见。
- en: Whenever you want to test or change your code, remember to close the ImageJ
    instance that was created when you select debug. Every time you select **Debug
    Project (ImageJ)**, a new ImageJ window will open. This will make it very difficult
    to keep track of which code you are actually debugging.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你想测试或更改你的代码时，记得关闭你在选择调试时创建的 ImageJ 实例。每次你选择**调试项目（ImageJ）**时，都会打开一个新的 ImageJ
    窗口。这将使跟踪你实际调试的代码变得非常困难。
- en: Creating documentation
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建文档
- en: The Java language has a nicely integrated way of creating documentation using
    specially formatted comments within the source files. When applied consistently
    in your source files, it can be very easy to create an API document. In the next
    section, we will look at how to set up the basics for documentation.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Java 语言有一个很好的集成方式，通过在源文件中使用特殊格式的注释来创建文档。当在源文件中一致应用时，可以非常容易地创建 API 文档。在下一节中，我们将探讨如何设置文档的基础。
- en: ImageJ Javadoc
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ImageJ Javadoc
- en: We will first generate the Javadoc for the ImageJ project. To do so, we will
    select the ImageJ project and go to **Run** | **Generate Javadoc (ImageJ)**. The
    Javadoc will be generated for the ImageJ project in a folder named `api`, which
    can be found in the `/ij` folder. It contains a list of HTML files and style files.
    To view the documentation, just view the `index.html` file in a web browser, and
    you will see the ImageJ API documentation. This view is very similar to the API
    that we saw online in the section on the API, and the information is identical.
    It is usually not necessary to generate Javadoc for the ImageJ project multiple
    times, unless you modify the documentation. In the next section, we will look
    at creating some Javadoc comments for your own plugins.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先为 ImageJ 项目生成 Javadoc。为此，我们将选择 ImageJ 项目并转到**运行** | **生成 Javadoc（ImageJ）**。Javadoc
    将在名为 `api` 的文件夹中为 ImageJ 项目生成，该文件夹位于 `/ij` 文件夹中。它包含一个 HTML 文件和样式文件的列表。要查看文档，只需在网页浏览器中查看
    `index.html` 文件，你将看到 ImageJ API 文档。这个视图与我们在 API 部分看到的在线 API 非常相似，信息是相同的。通常不需要多次为
    ImageJ 项目生成 Javadoc，除非你修改了文档。在下一节中，我们将探讨为你的插件创建一些 Javadoc 注释。
- en: Plugin Javadoc
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插件 Javadoc
- en: To generate Javadoc for your plugins, you need to add some specially formatted
    comments to your code. There is a lot of documentation about Javadoc online, so
    the information presented here will be very basic, but should provide a useful
    starting point. To start with, you first need to decide how much documentation
    is required. You can make well-crafted documents with a lot of detail, but if
    your code is very simple, it would cost much more time to write the documentation
    than to develop the code. That being said, it will be helpful to have some documentation
    to be able to identify the function that a method serves after some time has passed.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要为你的插件生成 Javadoc，你需要在代码中添加一些特殊格式的注释。网上有很多关于 Javadoc 的文档，所以这里提供的信息将非常基础，但应该是一个有用的起点。首先，你需要决定需要多少文档。你可以制作出很多细节的精心制作的文档，但如果你的代码非常简单，编写文档所需的时间将比开发代码所需的时间多得多。话虽如此，拥有一些文档将有助于在一段时间后识别方法所执行的功能。
- en: Let's look at an example of documentation for a simple method that has input
    parameters and an output parameter.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单方法的文档示例，该方法具有输入参数和输出参数。
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is the basic method definition of a function to measure some properties
    of a collection of regions within an image, and it returns an array of measurements.
    To include the documentation, we will precede the function definition with the
    following section:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是测量图像中区域集合的一些属性的基本函数定义，它返回一个测量值数组。为了包含文档，我们将在函数定义之前添加以下部分：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: A Javadoc section needs to start with a forward slice followed by two asterisks.
    When you press enter after the Javadoc opening tag, NetBeans will generate the
    code for the input parameters (`@param`) and the return value (`@return`) automatically.
    The only thing you have to add is the actual meaning of the parameters.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Javadoc 部分需要以一个前缀和两个星号开始。在 Javadoc 开头标签后按回车键，NetBeans 将自动生成输入参数（`@param`）和返回值（`@return`）的代码。你唯一需要添加的是参数的实际含义。
- en: 'Once your code has been documented, you will have to instruct NetBeans to build
    the Javadoc code. To do this, make the following adjustments to the `build.xml`
    file by replacing the existing `javadoc` section (it should be at the end of the
    file) with the following instructions:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的代码已经编写了文档，你必须指示 NetBeans 构建文档化的 Javadoc 代码。为此，通过替换文件末尾现有的 `javadoc` 部分（它应该在文件末尾）来调整
    `build.xml` 文件，如下所示：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will build the ImageJ and your plugins documentation in a folder named
    `plugins_api`, located one level above your source data. If you created a package
    for your plugins, you also need to create a `package-info.java` file that contains
    the information about the package. To create this info file, right-click on your
    package in the **Projects** view and go to **New** | **Java Package Info…** from
    the context menu. Alternatively, you can also go to **New** | **Other…** in the
    menu. In the dialog that opens, just click on **OK** to accept the default values.
    The file will be generated, and you can add your package documentation right above
    the package line in the usual way. You need to create this info file for every
    package that you create.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在名为 `plugins_api` 的文件夹中构建 ImageJ 和你的插件文档，该文件夹位于你的源数据之上的一级目录。如果你为你的插件创建了一个包，你还需要创建一个包含包信息的
    `package-info.java` 文件。要创建此信息文件，在 **项目** 视图中右键单击你的包，并从上下文菜单中选择 **新建** | **Java
    包信息…**。或者，你还可以在菜单中选择 **新建** | **其他…**。在打开的对话框中，只需单击 **确定** 以接受默认值。文件将被生成，你可以在包行上方以通常的方式添加你的包文档。你需要为创建的每个包创建此信息文件。
- en: After the documentation is compiled, you can view it by opening the `plugins_api/index.html`
    file in a browser. The ImageJ documentation will be shown first in the overview
    panel in the top-left corner. At the bottom will be your package(s). By clicking
    on them, you will see all the classes that are defined within the package. When
    you click on a class, the documentation that you supplied will be shown and can
    be browsed.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 文档编译完成后，你可以在浏览器中打开 `plugins_api/index.html` 文件来查看它。ImageJ 文档将首先在左上角的概览面板中显示。底部将显示你的包（s）。通过单击它们，你将看到包内定义的所有类。当你单击一个类时，你提供的文档将显示并可供浏览。
- en: Developing plugins using Maven
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Maven 开发插件
- en: In the previous sections, I discussed how to set up NetBeans for the development
    of ImageJ and plugins in a standalone configuration. However, as the design of
    ImageJ is being expanded, there was a need to create a more modular approach.
    This approach involves a more project-based building of different modules into
    a single program. The advantage of such a modular approach makes for a very flexible
    application that can be expanded in the future. The disadvantage is that it requires
    a little more overhead to make sure that all dependencies are met for a fully
    functional program. This is where Apache Maven comes in. Maven is a toolset to
    describe how to build a project into a finished program and which dependencies
    are required.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几节中，我讨论了如何为 ImageJ 和独立配置中的插件开发设置 NetBeans。然而，随着 ImageJ 设计的扩展，需要创建一个更模块化的方法。这种方法涉及将不同的模块构建成一个单一程序。这种模块化方法的优点是创建了一个非常灵活的应用程序，可以在未来进行扩展。缺点是它需要更多的开销来确保所有依赖项都满足以实现完全功能化的程序。这正是
    Apache Maven 发挥作用的地方。Maven 是一套工具，用于描述如何将项目构建成最终程序以及所需的依赖项。
- en: It does this using a special file called the **Project Object Model** (**POM**),
    which is an XML file. This file is stored in the root of your project and is called
    `pom.xml`. The content of the file describes some aspects of the project, such
    as a unique set of identifiers, and a list of dependencies that are required by
    the project. When you tell Maven to parse the POM file, it will collect all the
    required resources and compile the source code, run specified tests, and finally
    package the program in a JAR file. Maven is aimed at taking a clear project description
    and performing all the required tasks necessary to create the final package automatically
    without the developer needing to specify each step manually. This is what the
    previous sections described using the Ant mechanism to build code. First, let's
    look at how the POM is constructed in Maven, and how it's used to build a project.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用一个名为 **项目对象模型** (**POM**) 的特殊文件来完成这项工作，这是一个 XML 文件。该文件存储在项目的根目录中，并命名为 `pom.xml`。文件内容描述了项目的一些方面，例如一组唯一的标识符，以及项目所需依赖项的列表。当你告诉
    Maven 解析 POM 文件时，它将收集所有必需的资源并编译源代码，运行指定的测试，最后将程序打包成 JAR 文件。Maven 的目标是明确地描述项目，并自动执行创建最终包所需的所有必要任务，而无需开发者手动指定每一步。这正是前几节使用
    Ant 机制构建代码所描述的内容。首先，让我们看看 Maven 中 POM 的构建方式以及它是如何用于构建项目的。
- en: Construction of the POM
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: POM 的构建
- en: 'The POM file describes the structure of a project. It describes the location
    of the source code (by default, this is `/src/main/java`) and the build directory
    where the compiled program is stored (by default, this is `/target`). The minimal
    POM file contains the following structure:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: POM 文件描述了项目的结构。它描述了源代码的位置（默认情况下，这是 `/src/main/java`）和编译程序存储的构建目录（默认情况下，这是 `/target`）。最简
    POM 文件包含以下结构：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This minimal POM file will inherit all the defaults from the `Super POM` file.
    This means, everything that is not explicitly named in the POM; the default values
    will be used. This includes values such as the location of the source files, the
    `build` directory, the build file type (`.jar` by default), and other options
    such as the repositories used to download sources. For an ImageJ1.x plugin, the
    following POM is the minimal description:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最简 POM 文件将继承来自 `Super POM` 文件的所有默认值。这意味着，在 POM 中未明确命名的所有内容；将使用默认值。这包括诸如源文件的位置、`build`
    目录、构建文件类型（默认为 `.jar`）以及其他选项，例如用于下载源文件的仓库。对于 ImageJ1.x 插件，以下 POM 是最简描述：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This describes the project using ImageJ as the parent project. This is necessary
    because the plugin we want to develop requires the ImageJ to be built. Next, we
    specified the `artifactId` using the name of our plugin; in this case, I used
    the generic name `Plugin_Name`. In the `properties` field, we stated the main
    class of the project, which is the name of the plugin.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分描述了使用 ImageJ 作为父项目来描述项目。这是必要的，因为我们要开发的插件需要构建 ImageJ。接下来，我们使用我们的插件名称指定了 `artifactId`；在这种情况下，我使用了通用的名称
    `Plugin_Name`。在 `properties` 字段中，我们声明了项目的主类，即插件的名称。
- en: Note
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the `<version>` tag within the `<parent>` tag will control which version
    of ImageJ1.x will be retrieved. Using version 7.0.0 will retrieve version 1.49q,
    while 13.2.0 will retrieve version 1.50a.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`<parent>` 标签内的 `<version>` 标签将控制要检索哪个版本的 ImageJ1.x。使用版本 7.0.0 将检索 1.49q
    版本，而 13.2.0 将检索 1.50a 版本。
- en: Next, we described the dependencies that are required for the plugin, which
    is ImageJ for a plugin. Finally, we described the build process, stating that
    we want a JAR file. The manifest should include the `main` class described by
    the main-class field in the properties object. This method does not require any
    downloading of source code. The next section will explain how to set up a plugin
    for ImageJ1.x using a POM in NetBeans.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们描述了插件所需的依赖项，对于一个插件来说，是 ImageJ。最后，我们描述了构建过程，指出我们想要一个 JAR 文件。清单应该包括属性对象中
    main-class 字段所描述的 `main` 类。此方法不需要下载任何源代码。下一节将解释如何使用 NetBeans 中的 POM 设置 ImageJ1.x
    插件。
- en: Creating a Maven plugin project
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 Maven 插件项目
- en: 'Using a Maven project to develop a plugin is very simple and only requires
    a few basic steps. In many cases, you can use the default values from the POM
    model, and you will only need to specify the name of your plugin(s), a version
    number, and an artifact name. We will start by creating a new Maven project using
    NetBeans by going to **File** | **New Project** from the menu. From the categories
    list, we will select **Maven**, and from the **Projects** list, we will select
    **POM Project** and click on **Next >**:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Maven 项目开发插件非常简单，只需要几个基本步骤。在许多情况下，您可以使用 POM 模型的默认值，并且您只需要指定您插件（s）的名称、版本号和工件名称。我们将通过从菜单中选择
    **文件** | **新建项目** 来使用 NetBeans 创建一个新的 Maven 项目。从类别列表中，我们将选择 **Maven**，然后从 **项目**
    列表中，我们将选择 **POM 项目** 并点击 **下一步 >**：
- en: '![Creating a Maven plugin project](img/Insert_image_4909_07_07.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![创建 Maven 插件项目](img/Insert_image_4909_07_07.jpg)'
- en: 'In the next window, we can set the main properties of our plugin. For this
    example, I will create a dummy plugin that I will call `Awesome_Plugin`. I will
    place it in the NetBeans workspace folder, which is the default folder that is
    created when you install NetBeans:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个窗口中，我们可以设置插件的主要属性。对于这个例子，我将创建一个名为 `Awesome_Plugin` 的虚拟插件。我将将其放置在 NetBeans
    工作空间文件夹中，这是在安装 NetBeans 时创建的默认文件夹：
- en: '![Creating a Maven plugin project](img/Insert_image_4909_07_08.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![创建 Maven 插件项目](img/Insert_image_4909_07_08.jpg)'
- en: 'I added **Group ID** and a version number, but these can be changed later on
    quite easily. After pressing **Finish**, the project will be created and added
    to your project view (if you cannot see your project view, select **Window** |
    **Projects** from the menu). If you expand the project, you will notice that there
    are three folders, with the most important one, at the moment, being **Project
    Files**. This folder contains the `pom.xml` file that we will edit next. You can
    open the POM file for editing by expanding the project files folder in the project
    or by right-clicking on the project root and selecting **Open POM** from the context
    menu. The POM file will now look as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我添加了 **组 ID** 和一个版本号，但这些都很容易稍后更改。按下 **完成** 后，项目将被创建并添加到您的项目视图中（如果您看不到项目视图，请从菜单中选择
    **窗口** | **项目**）。如果您展开项目，您会注意到有三个文件夹，其中目前最重要的文件夹是 **项目文件**。此文件夹包含我们将要编辑的 `pom.xml`
    文件。您可以通过展开项目文件文件夹或在项目根目录上右键单击并从上下文菜单中选择 **打开 POM** 来打开 POM 文件进行编辑。POM 文件现在将如下所示：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, NetBeans added a few more properties to the `<project>` tag,
    identifying the XML schema that was used for this POM file. It also set the `<properties>`
    tag with a tag stating the source file encoding that will be used (UTF-8). It
    also states which packaging will be used. For plugins, we need to change this
    to JAR. There are two ways to change a parameter in the POM file. The first one
    is to modify the `pom.xml` file directly by adding or modifying tags. The other
    option is to select **Properties** from the context menu by right-clicking on
    the project. This will provide a form that contains many of the fields that are
    placed in the `pom.xml` file. For the remainder of this section, I will assume
    we edit the `pom.xml` file directly, as this allows for more flexibility and gives
    access to more tags than the properties dialog provides.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，NetBeans 向 `<project>` 标签添加了一些额外的属性，以标识用于此 POM 文件的 XML 架构。它还设置了 `<properties>`
    标签，其中包含将要使用的源文件编码（UTF-8）。它还说明了将要使用的打包方式。对于插件，我们需要将其更改为 JAR。在 POM 文件中更改参数有两种方式。第一种是通过直接修改
    `pom.xml` 文件来添加或修改标签。另一种选项是通过右键单击项目并从上下文菜单中选择 **属性**。这将提供一个表单，其中包含放置在 `pom.xml`
    文件中的许多字段。在本节的剩余部分，我将假设我们直接编辑 `pom.xml` 文件，因为这提供了更多的灵活性，并且可以访问比属性对话框提供的更多标签。
- en: 'In order to state that we require ImageJ to be present for our plugin, we will
    include the `<parent>` tag and its contents, as shown earlier. Next, we will take
    the `<dependencies>` tag and its contents and add them to the `pom.xml` file.
    When we now save the `pom.xml` file, you may notice that the folder structure
    in the project view changes. There are now only two folders called `Dependencies`
    and `Project Files`. You may also notice that the **Dependencies** folder contains
    two files: `ij-1.50a.jar` and `tools.jar`. These files are `required` to launch
    ImageJ. The former file is the actual ImageJ program, while the latter is a jar
    file that ImageJ requires to run.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明我们的插件需要 ImageJ 存在，我们将包括 `<parent>` 标签及其内容，如前所述。接下来，我们将 `<dependencies>`
    标签及其内容添加到 `pom.xml` 文件中。当我们现在保存 `pom.xml` 文件时，你可能会注意到项目视图中的文件夹结构发生了变化。现在只有两个名为
    `Dependencies` 和 `Project Files` 的文件夹。你也可能注意到，**Dependencies** 文件夹包含两个文件：`ij-1.50a.jar`
    和 `tools.jar`。这些文件是启动 ImageJ 所必需的。前者是实际的 ImageJ 程序，而后者是 ImageJ 运行所需的 jar 文件。
- en: 'If we try to build or run our project at this stage, we will get an error from
    NetBeans. It is complaining that the project is missing a file to build. This
    is not surprising as we haven''t stated which file we want to build. Also, we
    haven''t defined a main class yet to run, so we first need to fix this issue.
    To state where our main class will be, we will add the `<main-class>` tag to the
    `<properties>` tag:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这个阶段尝试构建或运行我们的项目，NetBeans 将会报错。它抱怨项目缺少构建所需的文件。这并不奇怪，因为我们还没有说明我们想要构建哪个文件。此外，我们还没有定义一个主类来运行，所以我们需要首先解决这个问题。为了说明我们的主类所在的位置，我们将
    `<main-class>` 标签添加到 `<properties>` 标签中：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now that we have stated where our main class will be found, we need to specify
    how to build the project. We will do this using the `<build>` tag, as shown in
    the minimal `ImageJ POM` earlier. The line within the `<manifest>` tag describes
    that we wish to use the main class defined in the properties described by the
    `<main-class>` tag:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经说明了主类所在的位置，我们需要指定如何构建项目。我们将使用 `<build>` 标签来完成，如前面所示的简化 `ImageJ POM` 所示。`<manifest>`
    标签内的行描述了我们希望使用由 `<main-class>` 标签描述的属性中定义的主类：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After saving the POM file, we can try to build the plugin again, but we will
    still get an error. This is because we are still missing the actual source code.
    We have created a project description, but we haven''t created a source file yet.
    We will now add a source file to our project, which must have the same name as
    the value of the `<artifactId>` tag. To add the source file, right-click on the
    project in the project view and select **New** | **Java Class**. This will open
    the **New Java Class** dialog:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 保存 POM 文件后，我们可以尝试再次构建插件，但仍然会出错。这是因为我们仍然缺少实际的源代码。我们已经创建了一个项目描述，但还没有创建源文件。现在我们将向我们的项目中添加一个源文件，该文件必须与
    `<artifactId>` 标签的值同名。要添加源文件，在项目视图中右键单击项目，然后选择 **新建** | **Java 类**。这将打开 **新建 Java
    类** 对话框：
- en: '![Creating a Maven plugin project](img/Insert_image_4909_07_09.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![创建 Maven 插件项目](img/Insert_image_4909_07_09.jpg)'
- en: The filename needs to be set to `Awesome_Plugin` for this example, as this is
    the `artifactId` that we used up to now. The folder where we wish to place the
    file needs to be specified as `/src/main/java`, as this is the default location
    used in POM projects. Since I did not change this value, we need to specify it
    here as well. If you change the location of the source folder, you need to specify
    it in the new Java class and POM files. After clicking on **Finish**, the file
    will be created and displayed in your project inside a new folder. The `Source
    Packages` folder has been added and contains a package called `<default package>`,
    which contains your source file called `Awesome_Plugin.java`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，文件名需要设置为 `Awesome_Plugin`，因为这是我们迄今为止使用的 `artifactId`。我们希望放置文件的文件夹需要指定为
    `/src/main/java`，因为这是 POM 项目中使用的默认位置。由于我没有更改此值，因此我们还需要在这里指定它。如果你更改了源文件夹的位置，你需要在新的
    Java 类和 POM 文件中指定它。点击 **完成** 后，文件将被创建并显示在你的项目中的一个新文件夹中。已添加 `Source Packages` 文件夹，其中包含一个名为
    `<default package>` 的包，该包包含你的源文件 `Awesome_Plugin.java`。
- en: Note
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you wish to place the plugin in a specified package, you can add a package
    declaration to your source file and ask NetBeans to move the file to the correct
    folder. The latter can be done after we add the package statement. We can then
    press *Alt* + *Enter* while the cursor is on the package statement and select
    **Move class to correct folder** from the context menu. This example assumes that
    we kept the default package.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望将插件放置在指定的包中，你可以在源文件中添加一个包声明，并要求NetBeans将文件移动到正确的文件夹。这可以在我们添加包声明之后完成。然后，当光标位于包声明上时，我们可以按*Alt*
    + *Enter*，从上下文菜单中选择**将类移动到正确文件夹**。本例假设我们保留了默认包。
- en: 'When we now build the project, we will see that the build is successful, meaning
    that everything is set up correctly for building. However, when we try to run
    the project, we will need to supply the main class:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在构建项目时，我们将看到构建成功，这意味着构建的设置是正确的。然而，当我们尝试运行项目时，我们需要提供主类：
- en: '![Creating a Maven plugin project](img/Insert_image_4909_07_10.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![创建Maven插件项目](img/Insert_image_4909_07_10.jpg)'
- en: 'The problem now is that we don''t have a main class at this stage. The source
    code only has a class declaration, but we haven''t added any code or a main method.
    To fix this, we need to add a main method to the source file:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，我们在这个阶段还没有主类。源代码中只有类声明，但我们还没有添加任何代码或主方法。为了解决这个问题，我们需要在源文件中添加一个主方法：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is a standard main method that is common to Java programs. This method
    is not required for ImageJ plugins. The standard entry point for plugins is usually
    the run method (`Plugin` and `PlugInFilter`) or the constructor (`PlugInFrame`).
    This main method is only for the purpose of the Maven build process and to make
    sure that ImageJ is started by instantiating a new ImageJ object.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在Java程序中常见的标准主方法。对于ImageJ插件来说，这个方法不是必需的。插件的标准入口通常是run方法（`Plugin`和`PlugInFilter`）或构造函数（`PlugInFrame`）。这个主方法仅用于Maven构建过程，并确保通过实例化一个新的ImageJ对象来启动ImageJ。
- en: 'The first line gets a reference to the plugin class that we created. In the
    next line, we extracted the full path, including the class file. This URL will
    have the following format: `file:/path/to/Awesome_Plugin.class`. In the next line,
    we removed the `file:` and the `Awesome_Plugin` parts from the beginning and end
    of the URL, respectively, using the `lastIndexOf()` method. The `clazz.getName()`
    call will return a string that will have the following format:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行获取我们创建的插件类的引用。在下一行，我们提取了包括类文件在内的完整路径。这个URL将具有以下格式：`file:/path/to/Awesome_Plugin.class`。在下一行，我们使用`lastIndexOf()`方法从URL的开始和结束部分分别移除了`file:`和`Awesome_Plugin`部分。`clazz.getName()`调用将返回一个字符串，其格式如下：
- en: '`class Awesome_Plugin`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class Awesome_Plugin`'
- en: '`class package.name.Awesome_Plugin`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class package.name.Awesome_Plugin`'
- en: The second format would be used if you used a package for your plugin, while
    the first format is used when you omit the package statement from your plugin.
    Using the `lastIndexOf()` method, we can include the package folders in the path
    as well, resulting in an error-free compilation and the correct placement of the
    plugin in the **Plugins** menu. We will then add the folder that contains the
    class to the `plugins.dir` property. Finally, we will start ImageJ by invoking
    a new instance using the `new` keyword.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为你的插件使用了包，则将使用第二种格式，而当你从插件中省略包声明时，将使用第一种格式。使用`lastIndexOf()`方法，我们可以在路径中包含包文件夹，从而实现无错误的编译和插件在**插件**菜单中的正确放置。然后，我们将包含类的文件夹添加到`plugins.dir`属性中。最后，我们将通过使用`new`关键字调用新实例来启动ImageJ。
- en: 'At this stage, we have the minimal code to run and debug our plugin. When we
    run the project now, ImageJ should open, and the plugin should be visible in the
    **Plugins** menu. We can select it, but it may generate an error when we select
    the plugin from the menu:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们有足够的代码来运行和调试我们的插件。当我们现在运行项目时，ImageJ应该打开，插件应该在**插件**菜单中可见。我们可以选择它，但当我们从菜单中选择插件时可能会生成错误：
- en: '![Creating a Maven plugin project](img/Insert_image_4909_07_11.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![创建Maven插件项目](img/Insert_image_4909_07_11.jpg)'
- en: 'This would occur if you used a package definition in your class file (in my
    example, I used the `analysis.tools` package). You can solve this by adding the
    following line to the end of your main method:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这将发生在你在类文件中使用了包定义的情况下（在我的例子中，我使用了`analysis.tools`包）。你可以通过在主方法的末尾添加以下行来解决此问题：
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will run the plugin immediately after ImageJ has started. If you defined
    the class without a package statement, you would not encounter this problem. It
    is, therefore, easier to start by developing plugins using the source files without
    a package statement. In the upcoming chapters, we will look at what we need to
    do to make a functional plugin.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在ImageJ启动后立即运行插件。如果您没有在类中定义包声明，您就不会遇到这个问题。因此，从开发不带包声明的源文件插件开始更容易。在接下来的章节中，我们将探讨要使插件功能化需要做什么。
- en: Creating an ImageJ2 plugin
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建ImageJ2插件
- en: 'The steps to create a Maven project for an ImageJ2 plugin is very similar to
    the steps taken in the previous section. Only a small change is required in the
    POM file within the `<dependencies>` tag:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 创建ImageJ2插件的步骤与上一节中采取的步骤非常相似。只需在`<dependencies>`标签内的POM文件中进行微小更改：
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'By changing the value of the `<artifactId>` tag from `ij` to `imagej`, we specify
    that we wish to implement an ImageJ2 instance. When we **Save and Build** the
    project, we will see that the `imagej-2.0.0-rc-41.jar` file has replaced the earlier
    `ij-1.50a.jar` file. We would also need the repository for the ImageJ2 project:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`<artifactId>`标签的值从`ij`更改为`imagej`，我们指定我们希望实现一个ImageJ2实例。当我们**保存并构建**项目时，我们会看到`imagej-2.0.0-rc-41.jar`文件已替换了早期的`ij-1.50a.jar`文件。我们还需要ImageJ2项目的仓库：
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The final change that is required is within the plugin source code. We need
    to use different import statements and change the way ImageJ is launched:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 需要进行的最后一个更改是在插件源代码中。我们需要使用不同的导入语句并更改启动ImageJ的方式：
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The syntax of ImageJ2 used in plugins is also different compared to ImageJ1.x,
    which is a topic we will discuss in the following chapters.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在插件中使用的ImageJ2语法与ImageJ1.x不同，这是我们将在下一章讨论的主题。
- en: Pros and cons of using an IDE
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用IDE的优缺点
- en: Using an IDE such as NetBeans has some benefits to help you write code. There
    are options to autocorrect coding errors and the possibility to automatically
    import dependencies. The disadvantages are not very big, but working with an IDE
    has a lot of overhead in terms of preparations and setting up. No matter how complete
    the IDE is, it can still not tell you how to solve a problem. Also, in some cases,
    it can be faster to just type the code directly using the script editor supplied
    with Fiji. The IDE is also not well suited to develop ImageJ macros, because macros
    in ImageJ are not compiled and are, therefore, not easy to integrate in the workflow
    of the IDE.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NetBeans等IDE有一些好处，可以帮助您编写代码。有自动纠正编码错误和自动导入依赖项的选项。缺点不是很大，但使用IDE在准备和设置方面有很多开销。无论IDE多么完善，它仍然不能告诉您如何解决问题。此外，在某些情况下，直接使用Fiji提供的脚本编辑器输入代码可能更快。IDE也不太适合开发ImageJ宏，因为ImageJ中的宏不编译，因此不易集成到IDE的工作流程中。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the framework of macros and plugins that are available
    in ImageJ. We looked at some of the constructs that the ImageJ API exposes for
    use in scripting and plugins. Finally, we described how to set up an IDE to develop
    ImageJ and plugins using it as standalone project or as a Maven-based project.
    You also saw how to generate documentation using the Javadoc utility.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了ImageJ中可用的宏和插件框架。我们查看了一些ImageJ API公开的结构，用于脚本和插件。最后，我们描述了如何设置IDE以开发ImageJ和插件，无论是作为独立项目还是基于Maven的项目。您还看到了如何使用Javadoc工具生成文档。
- en: In the next chapter, we will look at some plugins that are available and how
    they provide a solution to image-processing problems.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一些可用的插件以及它们如何解决图像处理问题。
