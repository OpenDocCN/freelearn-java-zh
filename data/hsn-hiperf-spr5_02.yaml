- en: Spring Best Practices and Bean Wiring Configurations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring最佳实践和Bean配置
- en: In the previous chapter, we learned how Spring Framework implements the **Inversion
    of Control** (**IoC**) principle. Spring IoC is the mechanism to achieve loose
    coupling between object dependencies. A Spring IoC container is the program that
    injects dependencies into an object and makes it ready for our use. Spring IoC
    is also known as dependency injection. In Spring, the objects of your application
    are managed by the Spring IoC container and are also known as **beans**. A bean
    is an object that is instantiated, assembled, and managed by a Spring IoC container.
    So, a Spring container is responsible for creating the beans in your application
    and coordinating the relationships between those objects via dependency injection.
    But, it is the developer's responsibility to tell Spring which beans to create
    and how to configure them together. When it comes to conveying a bean wiring configuration,
    Spring is very flexible, offering different writing configurations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了Spring框架如何实现**控制反转**（**IoC**）原则。Spring IoC是实现对象依赖关系的松耦合的机制。Spring
    IoC容器是将依赖注入到对象中并使其准备好供我们使用的程序。Spring IoC也被称为依赖注入。在Spring中，您的应用程序的对象由Spring IoC容器管理，也被称为**bean**。Bean是由Spring
    IoC容器实例化、组装和管理的对象。因此，Spring容器负责在您的应用程序中创建bean，并通过依赖注入协调这些对象之间的关系。但是，开发人员有责任告诉Spring要创建哪些bean以及如何配置它们。在传达bean的装配配置时，Spring非常灵活，提供不同的配置方式。
- en: In this chapter, we first start exploring different bean wiring configurations.
    This includes a configuration with Java, XML, and annotations, and also learning
    different best practices of bean wiring configuration. We will also understand
    the performance assessment with different configurations, as well as dependency
    injection pitfalls.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先开始探索不同的bean装配配置。这包括使用Java、XML和注解进行配置，以及学习bean装配配置的不同最佳实践。我们还将了解不同配置的性能评估，以及依赖注入的缺陷。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Dependency injection configurations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入配置
- en: Performance assessment with different configurations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同配置的性能评估
- en: Dependency injection pitfalls
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入的缺陷
- en: Dependency injection configurations
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入配置
- en: In any application, objects collaborate with other objects to perform some useful
    task. This relationship between one object and another in any application creates
    a dependency, and such dependencies between objects create tight-coupled programming
    in the application. Spring provides us with a mechanism to convert tight-coupled
    programming to loosely-coupled programming. This mechanism is called **dependency
    injection** (**DI**). DI is a concept or design pattern that describes how to
    create loosely-coupled classes where objects are designed in a manner where they
    receive instances of the objects from other pieces of code, instead of constructing
    them internally. This means that objects are given their dependencies at runtime,
    rather than compile time. So, with DI, we can get a decoupled structure that offers
    us simplified testing, greater reusability, and improved maintainability.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何应用程序中，对象与其他对象协作执行一些有用的任务。在任何应用程序中，一个对象与另一个对象之间的关系会创建依赖关系，这种对象之间的依赖关系会在应用程序中创建紧耦合的编程。Spring为我们提供了一种机制，将紧耦合的编程转换为松耦合的编程。这种机制称为**依赖注入**（**DI**）。DI是一种描述如何创建松耦合类的概念或设计模式，其中对象以一种方式设计，它们从其他代码片段接收对象的实例，而不是在内部构造它们。这意味着对象在运行时获得它们的依赖关系，而不是在编译时。因此，通过DI，我们可以获得一个解耦的结构，为我们提供了简化的测试、更大的可重用性和更好的可维护性。
- en: In the following section, we will learn about different types of DI configurations,
    which you can use in any of the configurations in your application, as per business
    requirement.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将学习不同类型的DI配置，您可以根据业务需求在应用程序的任何配置中使用这些配置。
- en: Types of DI patterns
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入模式的类型
- en: 'In Spring, the following types of DI are performed:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring中，进行以下类型的DI：
- en: Constructor-based DI
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于构造函数的依赖注入
- en: Setter-based DI
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于setter的依赖注入
- en: Field-based DI
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于字段的依赖注入
- en: We will learn more about these in the next sections.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中了解更多相关内容。
- en: Constructor-based DI
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于构造函数的依赖注入
- en: '**Constructor-based DI** is a design pattern to resolve the dependencies of
    a dependent object. In a constructor-based DI, a constructor is used to inject
    a dependent object. It is accomplished when the container invokes a constructor
    with a number of arguments.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于构造函数的依赖注入**是一种设计模式，用于解决依赖对象的依赖关系。在基于构造函数的依赖注入中，使用构造函数来注入依赖对象。当容器调用带有一定数量参数的构造函数时，就完成了这个过程。'
- en: 'Let''s look at the following example for a constructor-based DI. In the following
    code, we show how to use a constructor for injecting a `CustomerService` object
    in a `BankingService` class:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个基于构造函数的DI的例子。在以下代码中，我们展示了如何在`BankingService`类中使用构造函数来注入`CustomerService`对象：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following is the content of another dependent class file, `CustomerServiceImpl.java`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是另一个依赖类文件`CustomerServiceImpl.java`的内容：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The content for the `CustomerService.java` interface is as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomerService.java`接口的内容如下：'
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Advantages of the constructor-based DI
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数DI的优势
- en: 'The following are the advantages of a constructor-based DI in your Spring application:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在Spring应用程序中使用基于构造函数的DI的优势：
- en: It's suitable for mandatory dependencies. In a constructor-based DI, you can
    be sure that the object is ready to be used the moment it is constructed.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于必需的依赖关系。在基于构造函数的依赖注入中，您可以确保对象在构造时已经准备好供使用。
- en: The code structure is very compact and clear to understand.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码结构非常紧凑且易于理解。
- en: When you need an immutable object then, through constructor-based dependency,
    you can ensure you get the immutable nature of the object.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您需要一个不可变对象时，通过基于构造函数的依赖，您可以确保获得对象的不可变性。
- en: Disadvantages of the constructor-based DI
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数DI的缺点
- en: The only disadvantage of the constructor-based injection is that it may cause
    **circular dependency** between objects. Circular dependency means two objects
    depend on each other. For resolving that, we should use a setter injection instead
    of a constructor injection.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数注入的唯一缺点是可能会导致对象之间的**循环依赖**。循环依赖意味着两个对象彼此依赖。为了解决这个问题，我们应该使用设置器注入而不是构造函数注入。
- en: Let's see a different type of DI in Spring, which is a setter-based injection.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一种在Spring中不同类型的DI，即基于设置器的注入。
- en: Setter-based DI
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置器DI
- en: In a constructor-based DI, we saw a dependent object injecting through a constructor
    argument. In a setter-based DI, the dependent object is provided by a setter method
    in the dependent class. Setter-based DI is accomplished by calling setter methods
    on beans after invoking `no-args` constructors through the container.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于构造函数的DI中，我们看到一个依赖对象通过构造函数参数注入。在基于设置器的DI中，依赖对象是由依赖类中的设置器方法提供的。通过在容器中调用`no-args`构造函数后，在bean上调用设置器方法来实现设置器DI。
- en: 'In the following code, we show how to use a setter method for injecting a `CustomerService`
    object in the `BankingService` class:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们展示了如何在`BankingService`类中使用一个设置器方法来注入`CustomerService`对象：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Advantages of the setter-based DI
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置器DI的优势
- en: 'The following are the advantages of the setter-based DI in your Spring application:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在您的Spring应用程序中设置器DI的优势：
- en: It's more readable than the constructor injection.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它比构造函数注入更可读。
- en: This is useful for non-mandatory dependencies.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这对于非强制性的依赖是有用的。
- en: It solves the circular dependency problem in the application.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它解决了应用程序中的循环依赖问题。
- en: It helps us to inject the dependency only when it is required.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它帮助我们只在需要时注入依赖关系。
- en: It's possible to reinject dependencies. It is not possible in a constructor-based
    injection.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以重新注入依赖关系。这在基于构造函数的注入中是不可能的。
- en: Disadvantages of the setter-based DI
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置器DI的缺点
- en: 'Although the setter-based DI has higher priority than the constructor-based
    DI, the following are the disadvantages of the former:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管基于设置器的DI优先级高于基于构造函数的DI，但前者的缺点如下：
- en: There is no guarantee in a setter-based DI that the dependency will be injected.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设置器DI中，不能保证依赖关系会被注入。
- en: One can use a setter-based DI to override another dependency. This can cause
    security issues in a Spring application.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用设置器DI来覆盖另一个依赖关系。这可能会在Spring应用程序中引起安全问题。
- en: Field-based DI
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于字段的DI
- en: In the preceding sections, we saw how we can use constructor-based and setter-based
    dependencies in our application. In the following example, we will see field-based
    DI. Actually, field-based DI is easy to use, and it has clean code compared to
    the other two types of injection method; however, it has several serious trade-offs,
    and should generally be avoided.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了如何在我们的应用程序中使用基于构造函数和基于设置器的依赖关系。在下面的示例中，我们将看到基于字段的DI。实际上，基于字段的DI易于使用，并且与其他两种注入方法相比，代码更清晰；然而，它也有一些严重的折衷，通常应该避免使用。
- en: 'Let''s look at the following example of a field-based DI. In the following
    code, we will see how to use a field for injecting a `CustomerService` object
    in the `BankingService` class:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下基于字段的DI的以下示例。在下面的代码中，我们将看到如何在`BankingService`类中使用字段来注入`CustomerService`对象：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we discussed, this type of DI has the benefit of removing clutter code over
    setter-or constructor-based dependencies, but it has many drawbacks, such as dependencies
    are invisible from the outside. In constructor-based and setter-based dependencies,
    classes clearly expose these dependencies using the `public` interface or setter
    method. In a field-based DI, the class is inherently hiding the dependencies from
    the outside world. Another difficulty is that field injection cannot be used to
    assign dependencies to final/immutable fields, as these fields must be instantiated
    at class instantiation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们讨论过的，这种类型的DI有利于消除基于设置器或构造函数的依赖的混乱代码，但它也有许多缺点，比如依赖关系对外部是不可见的。在基于构造函数和基于设置器的依赖关系中，类明确地使用`public`接口或设置器方法来暴露这些依赖关系。在基于字段的DI中，类本质上是在对外部世界隐藏依赖关系。另一个困难是字段注入不能用于为final/不可变字段分配依赖关系，因为这些字段必须在类实例化时实例化。
- en: Generally, Spring discourages the use of the field-based dependency.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，Spring不鼓励使用基于字段的依赖。
- en: 'Here is a diagram with the different types of DI that we have learned about
    so far:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们迄今为止学到的不同类型的DI的图表：
- en: '![](img/bea0510f-e8d3-431c-b814-6f80cd876106.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bea0510f-e8d3-431c-b814-6f80cd876106.jpg)'
- en: Constructor versus setter injection
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数与设置器注入
- en: 'As we can see, Spring supports three types of DI methods; however, field-based
    dependency is not recommended by Spring. So, constructor-based and setter-based
    DI are standard ways to injecting beans in your application. The selection of
    constructor or setter methods depends on your application requirements. In this
    table, we will see the different use cases of constructor and setter injection,
    and some best practices that will help us decide when to use setter injection
    over constructor injection, and vice versa:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，Spring支持三种DI方法；然而，Spring不推荐使用基于字段的依赖。因此，基于构造函数和基于设置器的DI是在应用程序中注入bean的标准方式。构造函数或设置器方法的选择取决于您的应用程序要求。在这个表中，我们将看到构造函数和设置器注入的不同用例，以及一些最佳实践，这将帮助我们决定何时使用设置器注入而不是构造函数注入，反之亦然：
- en: '| **Constructor injection** | **Setter injection** |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **构造函数注入** | **设置器注入** |'
- en: '| Best choice when the dependency is mandatory. | The suitable choice when
    the dependency is not mandatory. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 依赖关系是强制性时的最佳选择。 | 依赖关系不是强制性时的合适选择。 |'
- en: '| Constructor injection makes the bean class object immutable. | Setter injection
    makes the bean class object mutable. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: 构造函数注入使得bean类对象是不可变的。| 设置器注入使得bean类对象是可变的。
- en: '| Constructor injection cannot override setter injected values. | Setter injection
    overrides the constructor injection when we use both constructor and setter injection
    for the same property. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 构造函数注入无法覆盖setter注入的值。 | 当我们同时为同一属性使用构造函数和setter注入时，setter注入会覆盖构造函数注入。 |'
- en: '| Partial dependencies are not possible with constructor injection because
    we must pass all the arguments in the constructor, otherwise, it gives an error.
    | Partial dependency is possible with setter injection. Suppose we have three
    dependencies, such as `int`, `string`, and `long`, then with the help of a setter
    injection, we can inject only the required dependency; other dependencies will
    be taken as a default value of those primitives. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 部分依赖在构造函数注入中是不可能的，因为我们必须在构造函数中传递所有参数，否则会出错。 | 部分依赖在setter注入中是可能的。假设我们有三个依赖，比如`int`，`string`和`long`，那么借助setter注入，我们可以只注入所需的依赖；其他依赖将被视为这些原始类型的默认值。
    |'
- en: '| Creates a circular dependency between objects. | Resolves circular dependency
    issue in your application. In case of circular dependency, it is better to use
    a setter instead of constructor injection. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 在对象之间创建循环依赖。 | 解决应用程序中的循环依赖问题。在循环依赖的情况下，最好使用setter而不是构造函数注入。 |'
- en: Configuring the DI with Spring
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring配置DI
- en: 'In this section, we will learn different types of processes to configure the
    DI. The following diagram is a high-level view of how the configuration process
    works in Spring:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习不同类型的配置DI的过程。以下图表是配置过程在Spring中如何工作的高级视图：
- en: '![](img/e100f5df-acc2-4ed3-aed8-c99f18d498a0.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e100f5df-acc2-4ed3-aed8-c99f18d498a0.jpg)'
- en: As per the preceding diagram, the Spring container is responsible for creating
    the bean in your application and building relationships between those beans via
    the DI pattern; however, as we discussed earlier, it's the developer's responsibility
    to tell the Spring container, through the metadata, how to create beans and how
    to wire them together.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的图表，Spring容器负责在您的应用程序中创建bean，并通过DI模式建立这些bean之间的关系；但是，正如我们之前讨论的，开发人员有责任通过元数据告诉Spring容器如何创建bean以及如何将它们连接在一起。
- en: 'The following are three techniques to configure the metadata of your application:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是配置应用程序元数据的三种技术：
- en: 'XML-based configuration: An explicit configuration'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于XML的配置：显式配置
- en: 'Java-based configuration: An explicit configuration'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Java的配置：显式配置
- en: 'Annotation-based configuration: An implicit configuration'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于注解的配置：隐式配置
- en: In Spring Framework, the preceding three types of configuration mechanisms are
    available, but you must use one of the configuration processes to wire your bean.
    In the next section, we will see each of the configuration techniques in detail
    with examples, and also see which technique in each situation or condition is
    more suitable than others; however, you can use any technique or approach that
    suits you best.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring框架中，有前述三种配置机制可用，但您必须使用其中一种配置过程来连接您的bean。在下一节中，我们将详细了解每种配置技术的示例，并看到在每种情况或条件下哪种技术更适合；但是，您可以使用最适合您的任何技术或方法。
- en: Let's now see the DI pattern with an XML-based configuration in detail.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们详细了解基于XML的配置中的DI模式。
- en: XML-based configuration
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于XML的配置
- en: The **XML-based configuration** has been the primary configuration technique
    since Spring started. In this section, we will see the same example as we discussed
    in the DI pattern, and see how the `CustomerService` object is injected in the
    `BankingService` class through an XML-based configuration.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于XML的配置**自Spring开始以来一直是主要的配置技术。在本节中，我们将看到与DI模式中讨论的相同示例，并看到如何通过基于XML的配置在`BankingService`类中注入`CustomerService`对象。'
- en: For an XML-based configuration, we need to create an `applicationContext.xml`
    file with a `<beans>` element. The Spring container must be able to manage one
    or more beans in the application. Beans are described using the `<bean>` element
    inside a top-level `<beans>` element.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于XML的配置，我们需要创建一个带有`<beans>`元素的`applicationContext.xml`文件。Spring容器必须能够管理应用程序中的一个或多个bean。使用顶级`<beans>`元素内部的`<bean>`元素来描述bean。
- en: 'Following is the `applicationContext.xml` file:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`applicationContext.xml`文件的内容：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding XML file is the basic structure of XML-based configuration metadata
    where we need to define our bean configuration. As we learned earlier, our bean
    configuration pattern may be constructor-based or setter-based, depending on the
    application requirement. Now, we will see how we can configure a bean using both
    design patterns, one by one.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的XML文件是基于XML的配置元数据的基本结构，我们需要在其中定义我们的bean配置。正如我们之前学到的，我们的bean配置模式可能是基于构造函数或基于setter的，具体取决于应用程序的要求。现在，我们将逐个看看如何使用这两种设计模式配置bean。
- en: 'The following is the example of a constructor-based DI with an XML-based configuration:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是基于XML的构造函数DI的示例：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the previous example, we have injected the `CustomerService` object in the
    `BankingServices` class with a constructor DI pattern. The `ref` attribute of
    the `</constructor-arg>` element is used to pass the reference of the `CustomerServiceImpl`
    object.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用构造函数DI模式在`BankingServices`类中注入了`CustomerService`对象。`</constructor-arg>`元素的`ref`属性用于传递`CustomerServiceImpl`对象的引用。
- en: 'The following is the example of a setter-based DI with an XML-based configuration:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是基于XML的setter注入DI的示例：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `ref` attribute of the `</property>` element is used to pass the reference
    of the `CustomerServiceImpl` object to the setter method.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`</property>`元素的`ref`属性用于将`CustomerServiceImpl`对象的引用传递给setter方法。'
- en: 'The following is the content of the `MainApp.java` file:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`MainApp.java`文件的内容：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Java-based configuration
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于Java的配置
- en: 'In the previous section, we saw how to configure a bean using XML-based configuration.
    In this section, we will see the Java-based configuration. The same as XML, Java-based
    configuration also injects dependency explicitly. The following example defines
    the Spring bean and its dependencies:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了如何使用基于XML的配置来配置bean。在本节中，我们将看到基于Java的配置。与XML相同，基于Java的配置也是显式地注入依赖关系。以下示例定义了Spring
    bean及其依赖关系：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the Java-based configuration, we must annotate the class with `@Configuration`,
    and the declaration of the bean can be achieved with the `@Bean` annotation. The
    previous example of a Java-based configuration is equivalent to an XML-based configuration,
    as per the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于Java的配置中，我们必须使用`@Configuration`对类进行注解，并且可以使用`@Bean`注解来声明bean。前面的基于Java的配置示例等同于基于XML的配置，如下所示：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The previous `AppConfig` class is annotated with the `@Configuration` annotation,
    which describes that it is a configuration class of the application that contains
    the details on bean definitions. The method is annotated with the `@Bean` annotation
    to describe that it is responsible for instantiating, configuring, and initializing
    a new bean is to be managed by the Spring IoC container. In the Spring container,
    each bean has a unique ID. Whichever method is annotated with `@Bean` then, by
    default, that method name will be the bean ID; however, you can also override
    that default behavior using the `name` attribute of the `@Bean` annotation, as
    follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的`AppConfig`类使用了`@Configuration`注解，描述了它是应用程序的配置类，包含有关bean定义的详细信息。该方法使用`@Bean`注解进行注解，以描述它负责实例化、配置和初始化一个新的bean，由Spring
    IoC容器进行管理。在Spring容器中，每个bean都有一个唯一的ID。无论哪个方法使用了`@Bean`注解，那么默认情况下该方法名称将是bean的ID；但是，您也可以使用`@Bean`注解的`name`属性来覆盖该默认行为，如下所示：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The Spring application context will load the `AppConfig` file and create beans
    for the application.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Spring应用程序上下文将加载`AppConfig`文件并为应用程序创建bean。
- en: 'The following is the `MainApp.java` file:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`MainApp.java`文件：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Annotation-based configuration
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于注解的配置
- en: In the previous section, we saw the two bean configuration techniques, Java-based
    and XML-based. Both the techniques inject dependency explicitly. In Java-based,
    we use the `@Bean` annotated method in the `AppConfig` Java file whereas, in XML-based,
    we use the `<bean>` element tag in the XML configuration file. **Annotation-based
    configuration** is another way of creating a bean, where we can move the bean
    configuration into the component class itself using annotations on the relevant
    class, method, or field declaration. Here, we will look at how we can configure
    a bean through annotation, and the different annotations available in Spring Framework.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了两种bean配置技术，即基于Java和基于XML的。这两种技术都是显式地注入依赖关系。在基于Java的配置中，我们在`AppConfig`
    Java文件中使用`@Bean`注解的方法，而在基于XML的配置中，我们在XML配置文件中使用`<bean>`元素标签。**基于注解的配置**是另一种创建bean的方式，我们可以通过在相关类、方法或字段声明上使用注解，将bean配置移到组件类本身。在这里，我们将看看如何通过注解配置bean，以及Spring
    Framework中提供的不同注解。
- en: Annotation-based configuration is turned off by default in Spring, so first,
    you have to turn it on by entering the `<context:annotation-config/>` element
    into the Spring XML file shown as follows. After adding it, you are ready to use
    annotations in your code.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Spring中默认情况下关闭了基于注解的配置，因此首先，您必须通过在Spring XML文件中输入`<context:annotation-config/>`元素来打开它。添加后，您就可以在代码中使用注解了。
- en: 'The changes required to be made in `applicationContext.xml` (as we have used
    it the earlier section) are highlighted as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在`applicationContext.xml`中需要进行的更改（因为我们在之前的部分中使用了它）如下所示：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: An XML-based configuration will override annotations because an XML-based configuration
    will be injected after annotations.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 基于XML的配置将覆盖注解，因为基于XML的配置将在注解之后进行注入。
- en: The previous XML-based configuration shows that once you configure the `<context:annotation-config/>`
    element, it indicates start of annotating your code. Spring should automatically
    scan the package defined in `<context:component-scan base-package=".." />` and
    identify beans and wire them based on the pattern. Let's understand a few of the
    important annotations, and how they work.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的基于XML的配置显示，一旦配置了`<context:annotation-config/>`元素，就表示开始对代码进行注解。Spring应该自动扫描在`<context:component-scan
    base-package=".." />`中定义的包，并根据模式识别bean并进行连线。让我们了解一些重要的注解以及它们的工作原理。
- en: The @Autowired annotation
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@Autowired注解'
- en: The `@Autowired` annotation injects object dependency implicitly. We can use
    the `@Autowired` annotation on a constructor-setter-and field-based dependency
    pattern. The `@Autowired` annotation indicates that auto wiring should be performed
    for this bean.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Autowired`注解隐式地注入对象依赖。我们可以在基于构造函数、setter和字段的依赖模式上使用`@Autowired`注解。`@Autowired`注解表示应该为此bean执行自动装配。'
- en: 'Let''s look at an example of using the `@Autowired` annotation on a constructor-based
    dependency:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个在基于构造函数的依赖注入上使用`@Autowired`注解的例子：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the previous example, we have `BankingService` that has a dependency of `CustomerService`.
    Its constructor is annotated with `@Autowired`, indicating that Spring instantiates
    the `BankingService` bean using an annotated constructor and passes the `CustomerService`
    bean as a dependency of the `BankingService` bean.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们有一个`BankingService`，它依赖于`CustomerService`。它的构造函数使用`@Autowired`进行注解，表示Spring使用带注解的构造函数实例化`BankingService`
    bean，并将`CustomerService` bean作为`BankingService` bean的依赖项。
- en: Since Spring 4.3, the `@Autowired` annotation became optional on classes with
    a single constructor. In the preceding example, Spring would still inject an instance
    of the `CustomerService` class if you skipped the `@Autowired` annotation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 自Spring 4.3以来，对于只有一个构造函数的类，`@Autowired`注解变得可选。在前面的例子中，如果您跳过了`@Autowired`注解，Spring仍然会注入`CustomerService`类的实例。
- en: 'Let''s look at an example of using the `@Autowired` annotation on a setter-based
    dependency:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个在基于setter的依赖注入上使用`@Autowired`注解的例子：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the previous example, we saw that the setter method `setCustomerService`
    is annotated with the `@Autowired` annotation. Here, the annotation resolves the
    dependency by type. The `@Autowire` annotation can be used on any traditional
    setter method.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们看到setter方法`setCustomerService`被`@Autowired`注解标记。在这里，注解通过类型解析依赖关系。`@Autowire`注解可以用于任何传统的setter方法。
- en: 'Let''s look at an example of using the `@Autowired` annotation on a field-based
    dependency:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个在基于字段的依赖上使用`@Autowired`注解的例子：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As per the preceding example, we can see that the `@Autowire` annotation can
    be added on public and private properties as well. Spring uses the reflection
    API to inject the dependencies when added on the property, and that is the reason
    private properties can also be annotated.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的例子，我们可以看到`@Autowire`注解可以添加在公共和私有属性上。Spring在属性上添加时使用反射API来注入依赖项，这就是私有属性也可以被注解的原因。
- en: '@Autowired with required = false'
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@Autowired with required = false'
- en: 'By default, the `@Autowired` annotation implies that the dependency is required.
    This means an exception will be thrown when a dependency is not resolved. You
    can override that default behavior using the `(required=false)` option with `@Autowired`.
    Let''s see the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`@Autowired`注解意味着依赖是必需的。这意味着在未解析依赖项时将抛出异常。您可以使用`@Autowired`的`(required=false)`选项覆盖默认行为。让我们看下面的代码：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the previous code, if we set the `required` value as `false`, then at the
    time of bean wiring, Spring will leave the bean unwired if the dependency is not
    resolved. As per Spring's best practices, we should avoid setting `required` as
    `false` until it is absolutely required.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，如果我们将`required`值设置为`false`，那么在bean连线时，如果依赖项未解析，Spring将保留bean未连接。根据Spring的最佳实践，我们应该避免将`required`设置为`false`，除非绝对需要。
- en: The @Primary annotation
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@Primary注解'
- en: 'By default, in Spring Framework, DI is done by type, which means that when
    there are multiple dependencies with the same type, the `NoUniqueBeanDefinitionException`
    exception will be thrown. It indicates that the Spring container is unable to
    select a bean for DI because of more than one eligible candidate. In that case,
    we can use the `@Primary` annotation and take control of the selection process.
    Let''s see the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring框架中，默认情况下，DI是按类型完成的，这意味着当存在多个具有相同类型的依赖项时，将抛出`NoUniqueBeanDefinitionException`异常。这表明Spring容器无法选择要注入的bean，因为有多个合格的候选项。在这种情况下，我们可以使用`@Primary`注解并控制选择过程。让我们看下面的代码：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the case of the previous example, there are two customer services available:
    `BankingService` and `AccountService`. Due to the `@Primary` annotation, components
    can only use `BankingService` to wire dependencies on `CustomerService`.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，有两个客户服务可用：`BankingService`和`AccountService`。由于`@Primary`注解，组件只能使用`BankingService`来连线`CustomerService`的依赖项。
- en: The @Qualifier annotation
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@Qualifier注解'
- en: 'Handling multiple autowire candidates with `@Primary` is more effective when
    only one primary candidate can be determined for multiple autowire candidates.
    The `@Qualifier` annotation gives you more control over the selection process.
    It allows you to give a reference associated with a specific bean type. That reference
    can be used to qualify the dependency that needs to be autowired. Let''s look
    at the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@Primary`处理多个自动装配候选项在只能确定一个主要候选项的情况下更有效。`@Qualifier`注解在选择过程中给予更多控制。它允许您给出与特定bean类型相关联的引用。该引用可用于限定需要自动装配的依赖项。让我们看下面的代码：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the previous example, there are two customer services available: `BankingService` and
    `AccountService`; however, due to `@Qualifier("bankingservice")` being used in
    the `SomeService` class, `BankingService` will be selected for auto wiring.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，有两个客户服务可用：`BankingService`和`AccountService`；但是，由于在`SomeService`类中使用了`@Qualifier("bankingservice")`，`BankingService`将被选中进行自动连线。
- en: Automatic bean detection with stereotype annotations
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原型注解自动检测bean
- en: In the previous section, we learned about the `@Autowired` annotation that handles
    only wiring. You still have to define the beans themselves so the container is
    aware of them and can inject them for you. Spring Framework provides us with some
    special annotations. These annotations are used to create Spring beans automatically
    in the application context. So, there is no need to configure the bean explicitly
    either using XML-based or Java-based configuration.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们了解了`@Autowired`注解只处理连线。您仍然必须定义bean本身，以便容器知道它们并为您注入它们。Spring框架为我们提供了一些特殊的注解。这些注解用于在应用程序上下文中自动创建Spring
    bean。因此，无需使用基于XML或基于Java的配置显式配置bean。
- en: 'The following are the stereotype annotations in Spring:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Spring中的原型注解：
- en: '`@Component`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '@Component'
- en: '`@Service`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '@Service'
- en: '`@Repository`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '@Repository'
- en: '`@Controller`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '@Controller'
- en: 'Let''s look at the following `CustomerService` implementation class. Its implementation
    is annotated with `@Component`. Please refer to the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下`CustomerService`实现类。它的实现被注解为`@Component`。请参考以下代码：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the previous code, the `CustomerServiceImpl` class is annotated with the
    `@Component` annotation. This means the class that is marked with the `@Component`
    annotation is considered the bean, and the component-scanning mechanism of Spring
    scans that class, creates a bean of this class, and pulls it into the application
    context. So, no need to configure that class explicitly as the bean is either
    using XML or Java. Spring automatically creates the bean of the `CustomerServiceImpl`
    class because it is annotated with `@Component`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`CustomerServiceImpl`类被`@Component`注解标记。这意味着被标记为`@Component`注解的类被视为bean，并且Spring的组件扫描机制扫描该类，创建该类的bean，并将其拉入应用程序上下文。因此，无需显式配置该类作为bean，因为bean是使用XML或Java自动创建的。Spring自动创建`CustomerServiceImpl`类的bean，因为它被`@Component`注解标记。
- en: In Spring, `@Service`, `@Repository`, and `@Controller` are meta annotations
    for the `@Component` annotation. Technically, all annotations are the same and
    provide the same result, such as creating a bean in Spring context; but we should
    use more specific annotations at different layers of the application because it
    specifies the intent better, and additional behavior might rely on it in the future.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring中，`@Service`、`@Repository`和`@Controller`是`@Component`注解的元注解。从技术上讲，所有注解都是相同的，并提供相同的结果，例如在Spring上下文中创建一个bean；但是我们应该在应用程序的不同层次使用更具体的注解，因为它更好地指定了意图，并且将来可能会依赖于其他行为。
- en: 'The following diagram describes the stereotype annotation with an appropriate
    layer:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了具有适当层的原型注解：
- en: '![](img/0e80ec68-52cd-4858-ab10-860971c21d6e.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e80ec68-52cd-4858-ab10-860971c21d6e.jpg)'
- en: 'As per the previous example, `@Component` is good enough to create a bean of
    `CustomerService`. But `CustomerService` is a service layer class, so as per bean
    configuration best practices, we should use `@Services` instead of the generic
    annotation `@Component`. Let''s look at the following code for the same class
    annotated with the `@Service` annotation:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的例子，`@Component`足以创建`CustomerService`的bean。但是`CustomerService`是一个服务层类，因此根据bean配置最佳实践，我们应该使用`@Services`而不是通用的`@Component`注解。让我们看一下相同类的以下代码，该类使用了`@Service`注解：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s see another example of the `@Repository` annotation:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个`@Repository`注解的另一个例子：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the previous example, the class is annotated with the `@Repository` annotation
    because the `CustomerRepository` interface is working at the **Data Access Object**
    (**DAO**) layer of the application. As per bean configuration best practices,
    we have used the `@Repository` annotation instead of the `@Component` annotation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，该类被注解为`@Repository`，因为`CustomerRepository`接口在应用程序的**数据访问对象**（**DAO**）层中起作用。根据bean配置最佳实践，我们使用了`@Repository`注解而不是`@Component`注解。
- en: 'In a real-life scenario, you might face very rare situations where you will
    need to use the `@Component` annotation. Mostly, you will be using the `@Controller`, `@Service`,
    and `@Repository` annotations. `@Component` should be used when your class does
    not fall into either of three categories: service, controller, DAO.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实场景中，您可能会很少遇到需要使用`@Component`注解的情况。大多数情况下，您将使用`@Controller`、`@Service`和`@Repository`注解。当您的类不属于服务、控制器、DAO三类时，应该使用`@Component`。
- en: The @ComponentScan annotation
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@ComponentScan注解'
- en: 'Spring needs to know which packages contain Spring beans, otherwise, you would
    have to register each bean individually. That''s what `@ComponentScan` is used
    for. In Spring, component scanning is not enabled by default. We need to enable
    it with the `@ComponentScan` annotation. This annotation is used with the `@Configuration`
    annotation to allow Spring to know the packages to scan for annotated components
    and to create beans from them. Let''s look at the following simple example of
    `@ComponentScan`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Spring需要知道哪些包包含Spring bean，否则，您将需要逐个注册每个bean。这就是`@ComponentScan`的用途。在Spring中，默认情况下不启用组件扫描。我们需要使用`@ComponentScan`注解来启用它。此注解与`@Configuration`注解一起使用，以便Spring知道要扫描的包，并从中创建bean。让我们看一个简单的`@ComponentScan`的例子：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the `@ComponentScan` annotation, if the `basePackages` attribute is not
    defined, then scanning will occur from the package of the class that declares
    this annotation. In the preceding example, Spring will scan all classes of `com.packt.springhighperformance.ch2.bankingapp.model`,
    and the subpackage of that package. The `basePackages` attribute can accept an
    array of strings, which means that we can define multiple base packages to scan
    component classes in the application. Let''s look at an example of how we can
    declare multiple packages in the `basePackage` attribute:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在`@ComponentScan`注解中，如果未定义`basePackages`属性，则扫描将从声明此注解的类的包中进行。在前面的例子中，Spring将扫描`com.packt.springhighperformance.ch2.bankingapp.model`的所有类，以及该包的子包。`basePackages`属性可以接受一个字符串数组，这意味着我们可以定义多个基本包来扫描应用程序中的组件类。让我们看一个如何在`basePackage`属性中声明多个包的例子：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The @Lazy annotation
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@Lazy注解'
- en: By default, all autowired dependencies are created and initialized at startup,
    meaning the Spring IoC container creates all beans at the time of application
    startup; however, we can control this pre-initialization of beans at startup by
    using the `@Lazy` annotation.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有自动装配的依赖项都会在启动时创建和初始化，这意味着Spring IoC容器会在应用程序启动时创建所有bean；但是，我们可以使用`@Lazy`注解来控制这种预初始化的bean。
- en: The `@Lazy` annotation may be used on any class directly or indirectly annotated
    with `@Component`, or on methods annotated with `@Bean`. When we use the `@Lazy`
    annotation, that means the bean will be created and initialized only when it is
    first requested.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Lazy`注解可以用于任何直接或间接使用`@Component`注解的类，或者用于使用`@Bean`注解的方法。当我们使用`@Lazy`注解时，这意味着只有在首次请求时才会创建和初始化bean。'
- en: We know that annotation requires less code because we don't need to write the
    code to inject the dependency explicitly. It helps us reduce the development time,
    as well. Though annotation offers lots of advantages, it has its drawback, as
    well.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道注解需要的代码较少，因为我们不需要显式编写代码来注入依赖项。它还有助于减少开发时间。尽管注解提供了许多优点，但它也有缺点。
- en: 'Disadvantages of annotation are as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注解的缺点如下：
- en: Less documentation than explicit wiring
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比显式连线文档少
- en: If we have a lot of dependency in a program, then it's hard to find it by using
    the `autowire` attribute of bean
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果程序中有很多依赖项，那么使用bean的`autowire`属性来查找它是很困难的。
- en: Annotation makes the process of debugging hard
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注解使调试过程变得困难
- en: It might give unexpected results in case of ambiguity
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在存在歧义的情况下可能会产生意外结果
- en: Annotation can be overridden by explicit configuration, such as Java or XML
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注解可以被显式配置（如Java或XML）覆盖
- en: Spring bean scopes
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring bean作用域
- en: In the previous section, we learned various DI patterns, and saw how to create
    beans in a Spring container. We also learned various DI configuration such as
    XML, Java, and annotation. In this section, we will learn more details about bean
    life and scope available in a Spring container. The Spring container allows us
    to control the bean at configuration level. This is a very flexible way to define
    object scope at configuration level, instead of at the Java-class level. In Spring,
    the bean is controlled through the `scope` attribute that defines what kind of
    object has to be created and returned. When you describe `<bean>`, you have the
    option of defining `scope` for that bean. The bean `scope` describes the life
    cycle and visibility of that bean in the context of where it used. In this section,
    we will see the different types of bean `scope` in Spring Framework.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们学习了各种DI模式，以及如何在Spring容器中创建bean。我们还学习了各种DI配置，如XML、Java和注解。在本节中，我们将更详细地了解Spring容器中可用的bean生命周期和范围。Spring容器允许我们在配置级别控制bean。这是一种非常灵活的方式，可以在配置级别定义对象范围，而不是在Java类级别。在Spring中，通过定义`scope`属性来控制bean的行为，该属性定义了要创建和返回的对象类型。当您描述`<bean>`时，可以为该bean定义`scope`。bean
    `scope`描述了bean在使用的上下文中的生命周期和可见性。在本节中，我们将看到Spring Framework中不同类型的bean `scope`。
- en: 'Here is an example of defining bean `scope` at XML-based configuration:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在基于XML的配置中定义bean `scope`的示例：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here is an example of defining bean `scope` using the `@Scope` annotation:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`@Scope`注解定义bean `scope`的示例：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can also use a constant instead of the string value in the following manner:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以以以下方式使用常量而不是字符串值：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Following are bean scopes available in Spring Framework:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Spring Framework中可用的bean范围：
- en: 'The `singleton` bean `scope`: As we saw in the previous example of bean configuration
    in XML-based, if `scope` is not defined in the configuration, then the Spring
    container considers `scope` as `singleton`. The Spring IoC container creates exactly
    only one single instance of the object, even if there are multiple references
    to a bean. Spring stores all `singleton` bean instances in a cache, and all subsequent
    requests of that named bean return the cached object. This is needed to understand
    that the Spring bean `singleton` `scope` is a little different from the typical
    `singleton` design pattern that we are using in Java. In Spring `singleton`, `scope`
    creates one object of that bean per one Spring container, meaning if there are
    multiple Spring containers in single JVM then multiple instances of that bean
    will be created.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`singleton` bean `scope`：正如我们在之前的XML配置的bean示例中看到的，如果在配置中未定义`scope`，那么Spring容器将`scope`视为`singleton`。Spring
    IoC容器仅创建对象的一个单一实例，即使有多个对bean的引用。Spring将所有`singleton` bean实例存储在缓存中，对该命名bean的所有后续请求都返回缓存对象。需要理解的是，Spring
    bean `singleton` `scope`与我们在Java中使用的典型`singleton`设计模式有些不同。在Spring `singleton`
    `scope`中，每个Spring容器创建一个bean对象，这意味着如果单个JVM中有多个Spring容器，则将创建该bean的多个实例。'
- en: 'The `prototype` bean `scope`: When `scope` is set to `prototype`, the Spring
    IoC container creates a new bean instance of object every time a bean is requested.
    Prototype-scoped beans are mostly used for stateful beans.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prototype` bean `scope`：当`scope`设置为`prototype`时，Spring IoC容器在每次请求bean时都会创建对象的新bean实例。通常使用原型作用域的bean用于有状态的bean。'
- en: As a rule, use `prototype` `scope` for all stateful beans, and the `singleton`
    `scope` for stateless beans.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于所有有状态的bean使用`prototype` `scope`，对于无状态的bean使用`singleton` `scope`。
- en: 'The `request` bean `scope`: The `request` bean `scope` is only available in
    a web-aware application context. The `request` `scope` creates a bean instance
    for each HTTP request. The bean is discarded as soon as the request processing
    is done.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request` bean `scope`：`request` bean `scope`仅在Web应用程序上下文中可用。`request` `scope`为每个HTTP请求创建一个bean实例。一旦请求处理完成，bean就会被丢弃。'
- en: 'The `session` bean `scope`: The `session` bean `scope` is only available in
    a web-aware application context. The `session` `scope` creates a bean instance
    for every HTTP session.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`session` bean `scope`：`session` bean `scope`仅在Web应用程序上下文中可用。`session` `scope`为每个HTTP会话创建一个bean实例。'
- en: 'The `application` bean `scope`: The `application` bean `scope` is only available
    in a web-aware application context. The `application` `scope` creates a bean instance
    per web application.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application` bean `scope`：`application` bean `scope`仅在Web应用程序上下文中可用。`application`
    `scope`为每个Web应用程序创建一个bean实例。'
- en: Performance assessment with different configurations
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用不同配置进行性能评估
- en: In this section, we will learn how different types of bean configuration impact
    application performance, and also we will see the best practices of bean configuration.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习不同类型的bean配置如何影响应用程序性能，还将看到bean配置的最佳实践。
- en: 'Let''s see how the `@ComponentScan` annotation configuration impacts the startup
    time of a Spring application:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`@ComponentScan`注解配置如何影响Spring应用程序的启动时间：
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As per the preceding configuration, Spring will scan all the packages of `com`
    and `org` and, because of that, the startup time of the application will be increased.
    So, we should scan only those packages that have annotated classes, as non-annotated
    classes will take time to scan. We should use only one `@ComponentScan` and list
    all packages, as shown here:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的配置，Spring将扫描`com`和`org`的所有包，因此应用程序的启动时间将增加。因此，我们应该只扫描那些具有注释类的包，因为未注释的类将花费时间进行扫描。我们应该只使用一个`@ComponentScan`，并列出所有包，如下所示：
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding configuration is considered as a best practice of defining the
    `@ComponentScan` annotation. We should specify which of those packages as `basePackage`
    attribute have annotated classes. It will reduce the startup time of the application.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的配置被认为是定义`@ComponentScan`注解的最佳实践。我们应该指定哪些包作为`basePackage`属性具有注释类。这将减少应用程序的启动时间。
- en: Lazy loading versus preloading
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟加载与预加载
- en: '**Lazy loading** ensures that beans are loaded on the fly when requested, and
    **preloading** ensures the beans are loaded before they are used. The Spring IoC
    container uses preloading by default. So, loading all classes at the start even
    if they''re not used would not be a wise decision because some Java instances
    would be highly resource-consuming. We should use the required methodology based
    on the application requirement.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**延迟加载**确保在请求时动态加载bean，而**预加载**确保在使用之前加载bean。Spring IoC容器默认使用预加载。因此，在启动时加载所有类，即使它们没有被使用，也不是一个明智的决定，因为一些Java实例会消耗大量资源。我们应该根据应用程序的需求使用所需的方法。'
- en: If we need to load our application as fast as possible, then go for lazy loading.
    If we need our application to run as fast as possible and serve a client request
    faster, then go for preloading.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要尽可能快地加载我们的应用程序，那么选择延迟加载。如果我们需要尽可能快地运行我们的应用程序并更快地响应客户端请求，那么选择预加载。
- en: Singleton versus prototype bean
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例与原型bean
- en: In Spring, by default, all beans defined are `singleton`; however, we can change
    the default behavior and make our bean `prototype`. When the bean `scope` is set
    to `prototype`, the Spring IoC container creates a new bean instance of an object
    every time a bean is requested. Prototype beans incur a hit on performance during
    creation, so when a `prototype` bean uses resources, such as network and database
    connection, it should be avoided completely; alternatively, design the action
    carefully.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring中，默认情况下，所有定义的bean都是`singleton`；但是，我们可以更改默认行为并使我们的bean成为`prototype`。当bean的`scope`设置为`prototype`时，Spring
    IoC容器在每次请求bean时创建一个新的bean实例。原型bean在创建时会对性能造成影响，因此当一个`prototype` bean使用资源（如网络和数据库连接）时，应完全避免；或者谨慎设计操作。
- en: Spring bean configuration best practices
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring bean配置最佳实践
- en: 'In this section, we will see some of the best practices for configuring a bean
    in Spring:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到Spring配置bean的一些最佳实践：
- en: 'Use ID as bean identifiers:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ID作为bean标识符：
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding example, we identified the bean using `id` or `name`. We should
    use `id` to pick the bean instead of `name`. Usually, it does neither increase
    readability nor benefit any performance but it's just an industry standard practice
    which we need to follow.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用`id`或`name`来标识bean。我们应该使用`id`来选择bean而不是`name`。通常，它既不增加可读性也不提高性能，但这只是一个行业标准实践，我们需要遵循。
- en: 'Prefer `type` over `index` for constructor argument matching. The constructor
    argument with `index` attribute is shown as follows:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构造函数参数匹配时，优先使用`type`而不是`index`。带有`index`属性的构造函数参数如下所示：
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The constructor argument with the `type` attribute is shown as follows:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数参数带有`type`属性，如下所示：
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As per the previous example, we can use `index` or `type` as a constructor argument.
    It is better to use the `type` attribute instead of `index` in a constructor argument
    because it is more readable and less error-prone. But sometimes, type-based arguments
    might create an ambiguity problem when a constructor has more than one argument
    of the same `type`. In that case, we need to use `index` or a name-based argument.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的例子，我们可以使用`index`或`type`作为构造函数参数。在构造函数参数中最好使用`type`属性而不是`index`，因为它更易读且更少出错。但有时，基于类型的参数可能会在构造函数有多个相同类型的参数时创建歧义问题。在这种情况下，我们需要使用`index`或基于名称的参数。
- en: 'Use dependency check at the development phase: In bean definition, we should
    use the `dependency-check` attribute. It ensures that the container performs explicit
    dependency validation. It is useful when all or some of the properties of a bean
    must be set explicitly, or through auto wiring.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发阶段使用依赖检查：在bean定义中，我们应该使用`dependency-check`属性。它确保容器执行显式的依赖验证。当一个bean的所有或部分属性必须显式设置或通过自动装配时，它是有用的。
- en: 'Do not specify version numbers in Spring schema references: in Spring configuration
    files, we specify the schema reference for different Spring modules. In schema
    references, we mention the XML namespace and its version number. Specifying the
    version number is not mandatory in the configuration file, so you can skip it.
    In fact, you should skip it all the time. Consider it as a best practice to follow.
    Spring automatically picks the highest version from the project dependencies (`jars`).
    A typical Spring configuration file looks like this:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在Spring模式引用中指定版本号：在Spring配置文件中，我们指定不同Spring模块的模式引用。在模式引用中，我们提到XML命名空间及其版本号。在配置文件中指定版本号不是强制性的，因此您可以跳过它。事实上，您应该始终跳过它。将其视为一种最佳实践。Spring会自动从项目依赖项（`jars`）中选择最高版本。典型的Spring配置文件如下所示：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As per best practices, this can be written like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 根据最佳实践，可以这样编写：
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add a header comment to each configuration file; it is preferred to add a configuration
    file header that describes the beans defined in the configuration files. The code
    of the `description` tag is as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个配置文件添加一个头部注释；最好添加一个描述配置文件中定义的bean的配置文件头部。`description`标签的代码如下：
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The advantages of the `description` tag is that some tools may catch up the
    description from this tag to help you in other places.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`description`标签的优点是一些工具可以从这个标签中获取描述，以帮助您在其他地方使用。'
- en: DI pitfalls
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DI陷阱
- en: 'As we know, there are three DI patterns in the Spring application: constructor-setter-and
    field-based. Each type has different advantages and disadvantages. Only field-based
    DI is an incorrect approach and not even recommended by Spring.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，在Spring应用程序中有三种DI模式：构造函数、setter和基于字段。每种类型都有不同的优缺点。只有基于字段的DI是一种错误的方法，甚至Spring也不推荐使用。
- en: 'Following is an example of a field-based injection:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是基于字段的注入的示例：
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As per Spring bean best practices, we should not use field-based dependency
    in our Spring application. The main reason is that it is impossible to test without
    Spring context. As we cannot supply the dependency from outside, it will not be
    possible to instantiate the object independently. As per my opinion, this is the
    only problem with field-based injections.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Spring bean最佳实践，我们不应该在Spring应用程序中使用基于字段的依赖。主要原因是没有Spring上下文无法进行测试。由于我们无法从外部提供依赖，因此无法独立实例化对象。在我看来，这是基于字段的注入唯一的问题。
- en: As we learned in an earlier section, constructor-based dependency is more suitable
    for mandatory fields, and we can ensure the immutable nature of the object is
    obtained; however, the main drawback of a constructor-based dependency is that
    it creates circular dependency in your application, and as per Spring documentation, *it
    is generally recommended to not rely on circular dependency between your beans*.
    So, now we have questions like, *Why not rely on circular dependency?* and *What
    will happen if we have a circular dependency in our application?* So, the answer
    to these questions is that it may create two significant and unfortunately silent
    pitfalls. Let's discuss them.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的部分中学到的，基于构造函数的依赖更适合于必填字段，并且我们可以确保对象的不可变性；然而，基于构造函数的依赖的主要缺点是它在应用程序中创建循环依赖，并且根据Spring文档，*通常建议不要依赖bean之间的循环依赖*。因此，现在我们有类似的问题，*为什么不依赖循环依赖？*和*如果我们的应用程序中有循环依赖会发生什么？*。因此，对这些问题的答案是它可能会产生两个重大且不幸的潜在问题。让我们讨论一下。
- en: First pitfall
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一个潜在问题
- en: 'When you call the `ListableBeanFactory.getBeansOfType()` method, you cannot
    be sure which beans will be returned. Let''s look at the code of the `getBeansOfType()`
    method in the `DefaultListableBeanFactory.java` class:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用`ListableBeanFactory.getBeansOfType()`方法时，您无法确定将返回哪些bean。让我们看一下`DefaultListableBeanFactory.java`类中`getBeansOfType()`方法的代码：
- en: '[PRE38]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding code, you can see that the `getBeansOfType()` method silently
    skips beans under creation, and only returns those already existing. So, when
    you have circular dependency between beans, use of the `getBeansOfType()` method
    during container startup is not recommended. This is because, as per the preceding
    code, if you are not using `DEBUG` or `TRACE` logging-level, then there will be
    zero information in your log that Spring skipped a particular bean which is under
    creation.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，您可以看到`getBeansOfType()`方法在创建中默默地跳过bean，并且只返回那些已经存在的。因此，当bean之间存在循环依赖时，在容器启动期间不建议使用`getBeansOfType()`方法。这是因为，根据上面的代码，如果您没有使用`DEBUG`或`TRACE`日志级别，那么您的日志中将没有任何信息表明Spring跳过了正在创建的特定bean。
- en: 'Let''s see the preceding pitfall with the following example. As per the following
    diagram, we have three beans, `Account`, `Customer`, and `Bank`, and a circular
    dependency between them:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看前面的潜在问题以及以下示例。根据以下图表，我们有三个bean，`Account`、`Customer`和`Bank`，它们之间存在循环依赖：
- en: '![](img/b0560f4b-859f-43c4-9123-049775d2d115.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b0560f4b-859f-43c4-9123-049775d2d115.jpg)'
- en: 'As per the preceding diagram, the following is the `Account`, `Customer`, and
    `Bank` class:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的图表，以下是`Account`、`Customer`和`Bank`类：
- en: '[PRE39]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Following is the `Main` class:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Main`类：
- en: '[PRE40]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Following is the log where we can show how Spring internally loads beans and
    resolves classes:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是日志，我们可以展示Spring如何内部加载bean并解析类：
- en: '[PRE41]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Spring Framework first loads `Account` and tries to instantiate a bean; however,
    when running `getBeansOfType(Customer.class)`, it discovers `Customer`, so proceeds
    with loading and instantiating that one. Inside `Customer`, we can immediately
    spot the problem: when `Customer` asks for `beanFactory.getBeansOfType(Account.class)`,
    it gets no results (`[]`). Spring will silently ignore `Account` because it''s
    currently under creation. You can see here that after `Bank` is loaded, everything
    is as expected.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Framework首先加载`Account`并尝试实例化一个bean；然而，在运行`getBeansOfType(Customer.class)`时，它发现了`Customer`，因此继续加载和实例化那个。在`Customer`内部，我们可以立即发现问题：当`Customer`要求`beanFactory.getBeansOfType(Account.class)`时，它得不到结果(`[]`)。Spring会默默地忽略`Account`，因为它当前正在创建。您可以在这里看到，在加载`Bank`之后，一切都如预期那样。
- en: Here now we can understand that, we cannot predict the output of the `getBeansOfType()`
    method when we have a circular dependency. However, we can avoid it with using
    DI properly. In circular dependency, `getBeansOfType()` gives different results,
    based on factors and we have no any control over it.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以理解，在有循环依赖时，我们无法预测`getBeansOfType()`方法的输出。然而，我们可以通过正确使用DI来避免它。在循环依赖中，`getBeansOfType()`根据因素给出不同的结果，我们对此没有任何控制。
- en: Second pitfall (with AOP)
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二个潜在问题（带AOP）
- en: We will learn AOP in detail in the following chapter. Right now, we are not
    covering this pitfall in detail. I just want you to understand that if you have
    `Aspect` on a bean, then make sure there is no circular dependency between beans;
    otherwise, Spring will create two instances of that bean, one without `Aspect`
    and the other with a proper aspect, without informing you.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中详细学习AOP。现在，我们不会详细介绍这个潜在问题。我只是想让你明白，如果你在一个bean上有`Aspect`，那么请确保bean之间没有循环依赖；否则，Spring将创建该bean的两个实例，一个没有`Aspect`，另一个有适当的方面，而不通知您。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about DI, which is the key feature of Spring Framework.
    DI helps us to make our code loosely coupled and testable. We learned various
    DI patterns, including constructor-setter-and field-based. We can use any of the
    DI patterns in our application based on our requirement, as each type has its
    own advantages and disadvantages.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了DI，这是Spring Framework的关键特性。DI帮助我们使我们的代码松散耦合和可测试。我们学习了各种DI模式，包括基于构造函数、setter和字段的模式。根据我们的需求，我们可以在我们的应用程序中使用任何DI模式，因为每种类型都有其自己的优缺点。
- en: We also learned how we can configure DI explicitly and implicitly. We can inject
    dependency explicitly with the use of XML-based and Java-based configuration.
    Annotation is used to inject dependency implicitly. Spring provides us with a
    special type of annotation called **stereotype annotation**. Spring will automatically
    register the class which annotated with stereotypes annotation. This makes the
    class available for DI in other classes and this become vital to building out
    our applications.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何显式和隐式地配置DI。我们可以使用基于XML和基于Java的配置显式地注入依赖关系。注解用于隐式地注入依赖关系。Spring为我们提供了一种特殊类型的注解，称为**原型注解**。Spring将自动注册用原型注解注释的类。这使得该类可以在其他类中进行DI，并且对于构建我们的应用程序至关重要。
- en: In the next chapter, we will be looking at the Spring AOP module. AOP is a powerful
    programming model that helps us to implement the reusable code.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一下Spring AOP模块。AOP是一个强大的编程模型，可以帮助我们实现可重用的代码。
