- en: Improving Resilience Using Resilience4j
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Resilience4j 提高弹性
- en: 'In this chapter, we will learn how to use Resilience4j to make our microservices
    more resilient, that is, how to mitigate and recover from errors. As we already
    discussed in [Chapter 1](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml), *Introduction
    to Microservices*, in the *Circuit breaker* section, and [Chapter 8](9878a36a-5760-41a4-a132-1a2387b61037.xhtml),
    *Introduction to Spring Cloud,* the *Resilience4j for improved resilience* section,
    a circuit breaker can be used to minimize the damage that a slow or not-responding
    downstream microservice can cause in a large-scale system landscape of synchronously
    communicating microservices. We will see how the circuit breaker in Resilience4j
    can be used together with a timeout and retry mechanism to prevent two—in my experience—of
    the most common error situations:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用 Resilience4j 使我们的微服务更具弹性，也就是说，如何减轻和恢复错误。正如我们在第[1](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml)章*微服务介绍*，"断路器"部分，和第[8](9878a36a-5760-41a4-a132-1a2387b61037.xhtml)章*Spring
    Cloud 介绍*，"Resilience4j 以提高弹性"部分，所讨论的，断路器可以用来自动减少一个慢速或无响应的后端微服务在一个大规模的同步微服务景观中所造成的损害。我们将看到
    Resilience4j 中的断路器如何与超时和重试机制一起使用，以防止我经验中最为常见的两个错误情况：
- en: Microservices that start to respond slowly or not at all
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应缓慢或根本不响应的微服务
- en: Requests that randomly fail from time to time, for example, due to temporary
    network problems
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求偶尔会因临时网络问题而失败
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introducing the Resilience4j circuit breaker and retry mechanism
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Resilience4j 断路器和重试机制
- en: Adding a circuit breaker and retry mechanism to the source code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向源代码添加**断路器**和**重试机制**
- en: Trying out the circuit breaker and retry mechanism
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用**断路器**和**重试机制**
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the commands that are described in this book are run on a MacBook Pro using
    macOS Mojave but should be straightforward to modify if you want to run them on
    another platform such as Linux or Windows.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中描述的所有命令都是在 MacBook Pro 上使用 macOS Mojave 运行的，但如果你想在其他平台（如 Linux 或 Windows）上运行它们，应该是非常直接的。
- en: No new tools need to be installed in this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中不需要安装任何新工具。
- en: The source code for this chapter can be found in this book's GitHub repository: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter13](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter13).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在本书的 GitHub 仓库中找到：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter13](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter13)。
- en: 'To be able to run the commands that are described in this book, download the
    source code to a folder and set up an environment variable, `$BOOK_HOME`, that
    points to that folder. Some sample commands are as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够运行本书中描述的命令，将源代码下载到一个文件夹中，并设置一个环境变量`$BOOK_HOME`，该变量指向该文件夹。一些示例命令如下：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Java source code is written for Java 8 and tested on Java 12\. This chapter
    uses Spring Cloud 2.1.0, SR1 (also known as the **Greenwich** release), Spring
    Boot 2.1.4, and Spring 5.1.6, that is, the latest available version of the Spring
    components at the time of writing this chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Java 源代码是为 Java 8 编写的，并在 Java 12 上进行了测试。本章使用 Spring Cloud 2.1.0, SR1（也被称为**Greenwich**版本），Spring
    Boot 2.1.4 和 Spring 5.1.6，即在撰写本章时可用的 Spring 组件的最新版本。
- en: The `openjdk:12.0.2` base Docker image is used in all the Dockerfiles.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Dockerfile 中都使用了`openjdk:12.0.2`基础 Docker 镜像。
- en: 'The source code contains the following Gradle projects:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码包含以下 Gradle 项目：
- en: '`api`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`api`'
- en: '`util`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`util`'
- en: '`microservices/product-service`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/product-service`'
- en: '`microservices/review-service`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/review-service`'
- en: '`microservices/recommendation-service`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/recommendation-service`'
- en: '`microservices/product-composite-service`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/product-composite-service`'
- en: '`spring-cloud/eureka-server`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-cloud/eureka-server`'
- en: '`spring-cloud/gateway`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-cloud/gateway`'
- en: '`spring-cloud/authorization-server`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-cloud/authorization-server`'
- en: '`spring-cloud/config-server`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-cloud/config-server`'
- en: The configuration files can be found in the config repository, `config-repo`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件可以在 config 仓库中找到，`config-repo`。
- en: All the source code examples in this chapter come from the source code in `$BOOK_HOME/Chapter13` but
    in several cases have been edited to remove irrelevant parts of the source code,
    such as comments, imports, and log statements.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有源代码示例均来自`$BOOK_HOME/Chapter13`中的源代码，但在某些情况下，去除了源代码中不相关部分，例如注释、导入和日志语句。
- en: If you want to see the changes that were applied to the source code in this
    chapter, that is, see what it took to add resilience using Resilience4j, you can
    compare it with the source code for [Chapter 12](a250774a-03a1-41b1-b935-cbeb9624b6e3.xhtml),
    *Centralized Configuration*. You can use your favorite `diff` tool and compare
    the two folders, `$BOOK_HOME/Chapter12` and `$BOOK_HOME/Chapter13`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看本章中应用于源代码的变化，即了解使用Resilience4j添加弹性所需的内容，你可以与[第12章](a250774a-03a1-41b1-b935-cbeb9624b6e3.xhtml)的*集中配置*源代码进行比较。你可以使用你喜欢的`diff`工具，比较两个文件夹，`$BOOK_HOME/Chapter12`和`$BOOK_HOME/Chapter13`。
- en: Introducing the Resilience4j circuit breaker and retry mechanism
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Resilience4j电路断路器和重试机制
- en: 'Retries and circuit breakers are potentially useful in any synchronous communication
    between two software components, for example, microservices. Resilience4j can
    be used by all our microservices except for the edge server since Spring Cloud
    Gateway currently only supports the older circuit breaker, Netflix Hystrix. In
    this chapter, we will apply a circuit breaker and a retry mechanism in one place, in
    calls to the `product` service from the `product-composite` service. This is illustrated
    in the following diagram:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 重试和电路断路器在两个软件组件之间的任何同步通信中都有潜在的用处，例如微服务。由于Spring Cloud Gateway目前只支持较旧的断路器Netflix
    Hystrix，我们的所有微服务都可以使用Resilience4j，除了边缘服务器。在本章中，我们将在一个地方应用电路断路器和重试机制，即从`product-composite`服务调用`product`服务。以下图表说明了这一点：
- en: '![](img/1242dd3a-010d-4a6d-8ce2-edc8fd88c290.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1242dd3a-010d-4a6d-8ce2-edc8fd88c290.png)'
- en: Note that the synchronous calls to the discovery and config servers from the
    other microservices are not shown in the preceding diagram (to make it easier
    to read).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的图表中没有显示其他微服务对发现和配置服务器的同步调用（为了更容易阅读）。
- en: Work is ongoing as this chapter was written to add an abstraction layer for
    circuit breakers in Spring Cloud, something Spring Cloud Gateway will probably
    be able to benefit from. For details, see [https://spring.io/blog/2019/04/16/introducing-spring-cloud-circuit-breaker](https://spring.io/blog/2019/04/16/introducing-spring-cloud-circuit-breaker).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本章的写作，一直在进行的工作是为Spring Cloud添加一个电路断路器的抽象层，这对Spring Cloud Gateway可能是有益的。详情请参阅[https://spring.io/blog/2019/04/16/introducing-spring-cloud-circuit-breaker](https://spring.io/blog/2019/04/16/introducing-spring-cloud-circuit-breaker)。
- en: Introducing the circuit breaker
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍电路断路器
- en: 'Let''s quickly revisit the state diagram for a circuit breaker from [Chapter
    8](9878a36a-5760-41a4-a132-1a2387b61037.xhtml), *Introduction to Spring Cloud*,
    in the *Resilience4j for improved resilience* section:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下来自[第8章](9878a36a-5760-41a4-a132-1a2387b61037.xhtml)的*Spring Cloud简介*中的*Resilience4j改进弹性*部分的电路断路器状态图：
- en: '![](img/87b2c812-ab46-45fe-a6d7-0f06a030d556.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87b2c812-ab46-45fe-a6d7-0f06a030d556.png)'
- en: 'The key features of a circuit breaker are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 电路断路器的键特性如下：
- en: If a circuit breaker detects too many faults, it will open its circuit, that
    is, not allow new calls.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果电路断路器检测到太多故障，它将打开其电路，即不允许新的调用。
- en: When the circuit is open, a circuit breaker will perform fast failure logic.
    This means that it doesn't wait for a new fault, for example, a timeout, to happen
    on subsequent calls. Instead, it directly redirects the call to a **fallback**
    **method**. The fallback method can apply various business logic to produce the
    best effort response. For example, a fallback method can return data from a local
    cache or simply return an immediate error message. This will prevent a microservice
    from getting unresponsive if the services it depends on stop responding normally.
    This is specifically useful under high load.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当电路处于断开状态时，电路断路器将执行快速失败逻辑。这意味着它不是等待新的故障发生，例如超时，在后续调用中发生。相反，它直接将调用重定向到一个**回退**
    **方法**。回退方法可以应用各种业务逻辑以产生最佳努力响应。例如，回退方法可以从本地缓存返回数据，或者简单地返回一个立即的错误消息。这可以防止微服务在它依赖的服务停止正常响应时变得无响应。在高负载下，这特别有用。
- en: After a while, the circuit breaker will be half-open*,* allowing new calls to
    see whether the issue that caused the failures is gone. If new failures are detected
    by the circuit breaker, it will open the circuit again and go back to the fast
    failure logic. Otherwise, it will close the circuit and go back to normal operation.
    This makes a microservice resilient to faults, a capability that is indispensable
    in a system landscape of microservices that communicate synchronously with each
    other!
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过了一段时间后，断路器将变为半开放*状态*，允许新的调用查看导致失败的问题是否已解决。如果断路器检测到新的失败，它将再次打开电路并回到快速失败逻辑。否则，它将关闭电路并恢复正常操作。这使得微服务能够抵抗故障，而在与其他微服务同步通信的系统架构中，这种能力是不可或缺的！
- en: 'Resilience4j exposes information about circuit breakers at runtime in a number
    of ways:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Resilience4j以多种方式在运行时暴露有关断路器的信息：
- en: The current state of a circuit breaker can be monitored using the microservice's actuator `health`
    endpoint, `/actuator/health`.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过微服务的actuator“health”端点监控断路器的当前状态，即`/actuator/health`。
- en: The circuit breaker also publishes events on an `actuator` endpoint, for example,
    state transitions, `/actuator/circuitbreakerevents`.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断路器还会在“actuator”端点上发布事件，例如，状态转换、`/actuator/circuitbreakerevents`。
- en: Finally, circuit breakers are integrated with Spring Boot's metrics system and
    can use it to publish metrics to monitoring tools such as Prometheus.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，断路器与Spring Boot的度量系统集成，并可以使用它将指标发布到监控工具，例如Prometheus。
- en: We will try out the `health` and `event` endpoints in this chapter. In [Chapter
    20](5e6cce2d-d426-4f55-95c9-52b596769a57.xhtml), *Monitoring Microservices*, we
    will see Prometheus in action and how it can collect metrics that are exposed
    by Spring Boot, for example, metrics from our circuit breaker.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将尝试使用`health`和`event`端点。在[第20章](5e6cce2d-d426-4f55-95c9-52b596769a57.xhtml)“微服务监控”中，我们将看到Prometheus的实际应用情况，以及它如何收集由Spring
    Boot暴露出来的指标，例如，我们的断路器中的指标。
- en: 'To control the logic in a circuit breaker, Resilience4J can be configured using
    standard Spring Boot configuration files. We will use the following configuration
    parameters:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制断路器中的逻辑，Resilience4J可以使用标准Spring Boot配置文件进行配置。我们将使用以下配置参数：
- en: '`ringBufferSizeInClosedState`: Number of calls in a closed state, which are
    used to determine whether the circuit shall be opened.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ringBufferSizeInClosedState`：在关闭状态中的调用次数，用于确定电路是否应打开。'
- en: '`failureRateThreshold`: The threshold, in percent, for failed calls that will
    cause the circuit to be opened.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`failureRateThreshold`：导致电路打开的失败调用百分比阈值。'
- en: '`waitInterval`: Specifies how long the circuit stays in an open state, that
    is, before it transitions to the half-open state.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`waitInterval`：指定电路保持开放状态的时间长度，即，在过渡到半开放状态之前。'
- en: '`ringBufferSizeInHalfOpenState`: The number of calls in the half-open state
    that are used to determine whether the circuit shall be opened again or go back
    to the normal, closed state.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ringBufferSizeInHalfOpenState`：在半开放状态下用于确定电路是否应再次打开或回到正常、关闭状态的调用次数。'
- en: '`automaticTransitionFromOpenToHalfOpenEnabled`: Determines whether the circuit
    automatically will transition to half-open once the wait period is over or wait
    for the first call after the waiting period until it transitions to the half-open
    state.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`automaticTransitionFromOpenToHalfOpenEnabled`：确定电路在等待期结束后是否自动变为半开放状态，或者在等待期间等待第一个调用直到变为半开放状态。'
- en: '`ignoreExceptions`: Can be used to specify exceptions that should not be counted
    as faults. Expected business exceptions such as not found or invalid input are
    typical exceptions that the circuit breaker should ignore, that is, users that
    search for non-existing data or enter invalid input should not cause the circuit
    to open.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignoreExceptions`：可以用来指定不应被计为错误的异常。例如，找不到或输入无效的业务异常通常是断路器应该忽略的异常，即，搜索不存在的数据或输入无效输入的用户不应该导致电路打开。'
- en: Resilience4j keeps track of successful and failed calls when in the closed and
    half-open state using a ring buffer, hence the parameter names `ringBufferSizeInClosedState`
    and `ringBufferSizeInHalfOpenState`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Resilience4j在关闭状态和半开放状态下使用环形缓冲区跟踪成功和失败的调用，因此有了参数名`ringBufferSizeInClosedState`和`ringBufferSizeInHalfOpenState`。
- en: 'In this chapter, we will use the following settings:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将使用以下设置：
- en: '`ringBufferSizeInClosedState = 5` and `failureRateThreshold = 50%`, meaning
    that if three or more of the last five calls are faults, then the circuit will
    open.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ringBufferSizeInClosedState = 5`和`failureRateThreshold = 50%`，意味着如果最后五个调用中有三个或更多是故障，那么电路将打开。'
- en: '`waitInterval = 10000` and `automaticTransitionFromOpenToHalfOpenEnabled =
    true`, meaning that the circuit breaker will keep the circuit open for 10 seconds
    and then transition to the half-open state.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`waitInterval = 10000`和`automaticTransitionFromOpenToHalfOpenEnabled = true`，意味着断路器将保持电路开启10秒，然后过渡到半开状态。'
- en: '`ringBufferSizeInHalfOpenState = 3`, meaning that the circuit breaker will
    decide whether the circuit shall be opened or closed based on the three first
    calls after the circuit has transitioned to the half-open state. Since the `failureRateThreshold` parameters
    are set to 50%, the circuit will be open again if two or all three calls fail.
    Otherwise, the circuit will be closed.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ringBufferSizeInHalfOpenState = 3`，意味着断路器将基于断路器过渡到半开状态后的三个首次调用来决定是否打开或关闭电路。由于`failureRateThreshold`参数设置为50%，如果两个或所有三个调用失败，电路将再次打开。否则，电路将关闭。'
- en: '`ignoreExceptions = InvalidInputException` and `NotFoundException`, meaning
    that our two business exceptions will not be counted as faults in the circuit
    breaker.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignoreExceptions = InvalidInputException`和`NotFoundException`，意味着我们的两个业务异常在断路器中不会被视为故障。'
- en: Introducing the retry mechanism
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入重试机制
- en: The **retry** mechanism is very useful for random and infrequent faults, such
    as temporary network glitches. The retry mechanism can simply retry a failed request
    a number of times with a configurable delay between the attempts. One very important
    restriction on the use of the retry mechanism is that the services that it retries
    must be **idempotent**, that is, calling the service one or many times with the
    same request parameters gives the same result. For example, reading information
    is idempotent but creating information is typically not. You don't want a retry
    mechanism to accidentally create two orders just because the response from the
    first order's creation got lost in the network.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 重试机制对于随机和偶尔出现的故障非常有用，例如暂时的网络问题。重试机制可以简单地尝试失败请求多次，每次尝试之间有可配置的延迟。使用重试机制的一个非常重要的限制是，它重试的服务必须是**幂等的**，也就是说，用相同的请求参数调用服务一次或多次会得到相同的结果。例如，读取信息是幂等的，但创建信息通常不是。你不希望重试机制因为第一次创建订单的响应在网络中丢失而意外地创建两个订单。
- en: 'Resilience4j exposes retry information in the same way as it does for circuit
    breakers when it comes to events and metrics but does not provide any health information.
    Retry events are accessible on the `actuator` endpoint, `/actuator/retryevents`. To
    control the retry logic, Resilience4J can be configured using standard Spring
    Boot configuration files. We will use the following configuration parameters:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到事件和指标时，Resilience4j以与断路器相同的方式暴露重试信息，但不提供任何健康信息。重试事件可以在`actuator`端点，`/actuator/retryevents`上访问。为了控制重试逻辑，可以使用标准的Spring
    Boot配置文件配置Resilience4J。我们将使用以下配置参数：
- en: '`maxRetryAttempts`: Number of retries before giving up, including the first
    call'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxRetryAttempts`: 包括第一次调用在内的重试次数上限'
- en: '`waitDuration`: Wait time before the next retry attempt'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`waitDuration`: 下次重试尝试之前的等待时间'
- en: '`retryExceptions`: A list of exceptions that shall trigger a retry'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retryExceptions`: 需要触发重试的异常列表'
- en: 'In this chapter, we will use the following values:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用以下值：
- en: '`maxRetryAttempts = 3`: We will make a maximum of two retry attempts.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxRetryAttempts = 3`: 我们将最多尝试两次重试。'
- en: '`waitDuration= 1000`: We will wait one second between retries.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`waitDuration= 1000`: 我们将在重试之间等待一秒钟。'
- en: '`retryExceptions = InternalServerError`: We will only trigger retries on `InternalServerError`
    exceptions, that is, when HTTP requests respond with a 500 status code.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retryExceptions = InternalServerError`: 我们只会在遇到`InternalServerError`异常时触发重试，也就是说，当HTTP请求响应码为500时。'
- en: Be careful when configuring retry and circuit breaker settings so that, for
    example, the circuit breaker doesn't open the circuit before the intended number
    of retries have been completed!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 配置重试和断路器设置时要小心，例如，确保断路器在预期的重试次数完成之前不要打开电路！
- en: Adding a circuit breaker and retry mechanism to the source code
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在源代码中添加断路器和重试机制
- en: 'Before we add a circuit breaker and a retry mechanism to the source code, we
    will add code that makes it possible to force an error to occur—either a delay
    and/or a random fault. Next, we will add a circuit breaker to handle slow or not
    responding APIs, as well as a retry mechanism that can handle faults that happens
    randomly. Adding these features from Resilience4j follows the traditional Spring
    Boot way:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在向源代码中添加断路器和重试机制之前，我们将添加代码，使其能够强制发生错误——要么是延迟，要么是随机故障。然后，我们将添加一个断路器来处理慢速或无响应的API，以及一个可以处理随机发生故障的重试机制。从Resilience4j添加这些功能遵循传统的Spring
    Boot方式：
- en: Add a starter dependency for Resilience4j in the build file.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建文件中添加一个针对Resilience4j的启动依赖。
- en: Add annotations in the source code where the circuit breaker and retry mechanism
    shall be applied.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在源代码中添加注解，以在断路器和重试机制应适用的位置使用。
- en: Add configuration that controls the behavior of the circuit breaker and retry mechanism.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加控制断路器和重试机制行为的配置。
- en: Once we have the circuit breaker and retry mechanism in place, we will extend
    our test script, `test-em-all.bash`, with the tests of the circuit breaker.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们实施了断路器和重试机制，我们将扩展我们的测试脚本`test-em-all.bash`，以包含断路器的测试。
- en: Adding programmable delays and random errors
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加可编程延迟和随机错误
- en: 'To be able to test our circuit breaker and retry mechanism, we need a way to
    control when errors happen. A simple way to achieve this is by adding optional
    query parameters in the API in order to retrieve a product and a composite product.
    The composite product API will simply pass on the parameters to the product API.
    The following query parameters have been added to the two APIs:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够测试我们的断路器和重试机制，我们需要一种控制错误发生时间的方法。实现这一目标的一种简单方法是在API中添加可选的查询参数，以检索产品和组合产品。组合产品API将参数传递给产品API。以下查询参数已添加到两个API中：
- en: '`delay`: Causes the `getProduct` API on the `product` microservice to delay
    its response. The parameter is specified in seconds. For example, if the parameter
    is set to `3`, it will cause a delay of three seconds before the response is returned.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delay`：导致`product` 微服务的`getProduct` API延迟其响应。参数以秒为单位指定。例如，如果参数设置为`3`，它将在返回响应之前造成三秒的延迟。'
- en: '`faultPercentage`: Causes the `getProduct` API on the `product` microservice to
    throw an exception randomly with the probability specified by the query parameter,
    from 0 to 100%. For example, if the parameter is set to `25`, it will cause every
    fourth call to the API, on average, to fail with an exception. It will return
    an HTTP error 500 internal server error in these cases.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`faultPercentage`：导致`product` 微服务的`getProduct` API以查询参数指定的概率随机抛出异常，从0到100%。例如，如果参数设置为`25`，它将使平均每四次API调用中的第四次失败并抛出异常。在这些情况下，它将返回HTTP错误500内部服务器错误。'
- en: Changes in the API definitions
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API定义的更改
- en: 'The two query parameters that we introduced previously, `delay` and `faultPercentage`,
    have been defined in the `api` project in the following two Java interfaces:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前引入的两个查询参数`delay`和`faultPercentage`，已在`api`项目中的以下两个Java接口中定义：
- en: '`se.magnus.api.composite.product.ProductCompositeService`:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.api.composite.product.ProductCompositeService`：'
- en: '[PRE1]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`se.magnus.api.core.product.ProductService`:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.api.core.product.ProductService`：'
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Changes in the product composite microservice
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品组合微服务的更改
- en: 'The `product-composite` microservice simply passes the parameters to the product
    API. The service implementation receives the API request and passes on the parameters
    to the integration component that makes the call to the product API:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`product-composite` 微服务只是将参数传递给产品API。服务实现接收到API请求，并将参数传递给调用产品API的集成组件：'
- en: 'The call to the `se.magnus.microservices.composite.product.services.ProductCompositeServiceImpl` class:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`se.magnus.microservices.composite.product.services.ProductCompositeServiceImpl` 类的调用：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The call to the `se.magnus.microservices.composite.product.services.ProductCompositeIntegration` class:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`se.magnus.microservices.composite.product.services.ProductCompositeIntegration` 类的调用：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Changes in the product microservice
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品微服务的更改
- en: 'The `product` microservice implements actual delay and random error generator
    in `se.magnus.microservices.core.product.services.ProductServiceImpl` as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`product` 微服务在`se.magnus.microservices.core.product.services.ProductServiceImpl`中实现实际延迟和随机错误生成器，如下所示：'
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The delay function, `simulateDelay()`, uses the `Thread.sleep()` function to
    simulate a delay:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟函数`simulateDelay()`使用`Thread.sleep()`函数来模拟延迟：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The random error generator, `throwErrorIfBadLuck()`, creates a random number
    between `1` and `100` and throws an exception if it is higher or equal to the
    specified fault percentage:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 随机错误生成器`throwErrorIfBadLuck()`创建一个在`1`和`100`之间的随机数，如果它等于或大于指定的故障百分比，则抛出异常：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Adding a circuit breaker
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加断路器
- en: As we mentioned previously, we need to add dependencies, annotations, and configuration.
    We also need to add some code for handling timeouts and fallback logic. We will
    see how to do this in the following sections.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，我们需要添加依赖项、注解和配置。我们还需要添加一些处理超时和回退逻辑的代码。我们将在接下来的章节中看到如何进行操作。
- en: Adding dependencies to the build file
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向构建文件添加依赖项
- en: 'To add a circuit breaker, we have to add dependencies to the appropriate Resilience4j
    libraries in the build file, `build.gradle`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要在电路中添加断路器，我们必须在构建文件`build.gradle`中添加对适当Resilience4j库的依赖：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Adding the circuit breaker and timeout logic
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加断路器和超时逻辑
- en: 'The circuit breaker can be applied by annotating the method it is expected
    to protect with `@CircuitBreaker(name="nnn")`, which in this case is the `getProduct()`
    method in the `se.magnus.microservices.composite.product.services.ProductCompositeIntegration`
    class. The circuit breaker is triggered by an exception, not by a timeout itself.
    To be able to trigger the circuit breaker after a timeout, we have to add code
    that generates an exception after a timeout. Using `WebClient`, which is based
    on Project Reactor, allows us to do that conveniently by using its `timeout(Duration)`
    method. The source code looks as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器可以通过在期望其保护的方法上使用`@CircuitBreaker(name="nnn")`注解来应用，这里是指`se.magnus.microservices.composite.product.services.ProductCompositeIntegration`类中的`getProduct()`方法。断路器是由异常触发的，而不是由超时本身触发的。为了能够在超时后触发断路器，我们必须添加在超时后生成异常的代码。使用基于Project
    Reactor的`WebClient`，我们可以通过使用其`timeout(Duration)`方法方便地做到这一点。源代码如下所示：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The name of the circuit breaker, `"product"`, is used to identify the configuration
    that we will go through. The timeout parameter, `productServiceTimeoutSec`, is
    injected into the constructor as a configurable parameter value:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器的名称`"product"`用于标识我们将要通过的配置。超时参数`productServiceTimeoutSec`作为可配置参数值注入到构造函数中：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To activate the circuit breaker, the annotated method must be invoked as a
    Spring Bean. In our case, it''s the integration class that''s injected by Spring
    into the service implementation class and therefore used as a Spring Bean:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活断路器，必须作为Spring Bean调用注解方法。在我们的情况下，是Spring将集成类注入到服务实现类中，因此作为Spring Bean使用：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Adding fast fail fallback logic
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加快速失败回退逻辑
- en: To be able to apply fallback logic when the circuit breaker is open, that is,
    when a request fast fails, we can catch an exception, `CircuitBreakerOpenException`,
    that is thrown by the circuit breaker when it is open and call a fallback method.
    This has to be done outside of the circuit breaker, that is, in the caller. In
    our case, it is the `product-composite` service's implementation that calls the
    integration class.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在断路器打开时应用回退逻辑，即在请求快速失败时，我们可以捕获断路器打开时抛出的`CircuitBreakerOpenException`异常，并调用回退方法。这必须在断路器之外完成，即在调用者中。在我们的情况下，是`product-composite`服务的实现调用集成类。
- en: 'Here, we use the `onErrorReturn` method to call the `getProductFallbackValue()` method
    when we catch `CircuitBreakerOpenException`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`onErrorReturn`方法在捕获`CircuitBreakerOpenException`时调用`getProductFallbackValue()`方法：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The fallback logic can be based on `productId` lookup information on the product
    from alternative sources, for example, an internal cache. In our case, we return
    a hardcoded value unless `productId` is `13`; otherwise, we throw a not found
    exception:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 回退逻辑可以根据从替代来源获取的产品`productId`查找信息，例如，内部缓存。在我们的情况下，除非`productId`是`13`，否则我们返回一个硬编码的值；否则，我们抛出一个未找到异常：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Adding configuration
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加配置
- en: 'Finally, the configuration of the circuit breaker is added to the `product-composite.yml` file
    in the config repository, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，断路器的配置添加到配置存储库中的`product-composite.yml`文件中，如下所示：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Most of the values in the configuration have already been described in *Introducing
    the circuit breaker* section, except for the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 配置中的大多数值已经在*介绍断路器*部分中描述过，除了以下内容：
- en: '`app.product-service.timeoutSec`: Used to configure the timeout we introduced
    previously. This is set to two seconds.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.product-service.timeoutSec`：用于配置我们之前引入的超时。这个设置为两秒。'
- en: '`registerHealthIndicator`: Determines whether the circuit breaker shall display
    information in the `health` endpoint or not. This is set to `true`.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registerHealthIndicator`：决定熔断器是否在`health`端点显示信息。这设置为`true`。'
- en: Adding a retry mechanism
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加重试机制
- en: In the same way as for the circuit breaker, a retry mechanism is set up by adding
    dependencies, annotations, and configuration. The dependencies were added previously,
    so we only need to add the annotation and set up some configuration. We, however,
    also need to add some error handling logic due to retry-specific exceptions that
    the retry mechanism throws.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 与熔断器类似，通过添加依赖项、注解和配置来设置重试机制。依赖项已经在之前添加，所以我们只需要添加注解并设置一些配置。然而，由于重试机制会抛出特定的异常，我们还需要添加一些错误处理逻辑。
- en: Adding the retry annotation
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加重试注解
- en: 'The retry mechanism can be applied to a method by annotating it with `@Retry(name="nnn")`,
    where `nnn` is the name of the configuration entry to be used for this method.
    See the *Adding configuration* section for details on the configuration. The method,
    in our case, is the same as it is for the circuit breaker, that is, `getProduct()` in
    the `se.magnus.microservices.composite.product.services.ProductCompositeIntegration` class:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 重试机制可以通过注解`@Retry(name="nnn")`应用于方法，其中`nnn`是用于此方法的配置条目的名称。关于配置的详细信息，请参见*添加配置*部分。在我们这个案例中，与熔断器相同，是`se.magnus.microservices.composite.product.services.ProductCompositeIntegration`类中的`getProduct()`方法：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Handling retry-specific exceptions
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理重试特定异常
- en: Exceptions that are thrown by a method annotated with `@Retry` can be wrapped
    by the retry mechanism with a `RetryExceptionWrapper` exception. To be able to
    handle the actual exception that the method threw, for example, to apply a fallback
    method when `CircuitBreakerOpenException` is thrown, the caller needs to add logic
    that unwraps `RetryExceptionWrapper` exceptions and replaces them with the actual
    exception.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`@Retry`注解的方法抛出的异常可以被重试机制用`RetryExceptionWrapper`异常包装。为了能够处理方法抛出的实际异常，例如在抛出`CircuitBreakerOpenException`时应用备用方法，调用者需要添加解包`RetryExceptionWrapper`异常并将它们替换为实际异常的逻辑。
- en: 'In our case, it is the `getCompositeProduct` method in the `ProductCompositeServiceImpl`
    class that makes the call using the Project Reactor API for `Mono` objects. The
    `Mono` API has a convenient method, `onErrorMap`, that can be used to unwrap `RetryExceptionWrapper`
    exceptions. It is used in the `getCompositeProduct` method like so:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，是`ProductCompositeServiceImpl`类中的`getCompositeProduct`方法使用Project Reactor
    API对`Mono`对象进行调用。`Mono` API有一个方便的方法`onErrorMap`，可以用来解包`RetryExceptionWrapper`异常。它被用在`getCompositeProduct`方法中，如下所示：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Adding configuration
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加配置
- en: 'Configuration for the retry mechanism is added in the same way as it is for
    the circuit breaker, that is, in the `product-composite.yml` file in the config
    repository, like so:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 重试机制的配置是以与熔断器相同的方式添加的，即在配置存储库中的`product-composite.yml`文件中，如下所示：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The actual values were discussed in *Introducing the retry mechanism* section.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 实际值在*介绍重试机制*部分进行了讨论。
- en: Adding automated tests
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加自动化测试
- en: 'Automated tests for the circuit breaker have been added to the `test-em-all.bash` test
    script in a separate function, `testCircuitBreaker()`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 已经向`test-em-all.bash`测试脚本中的单独函数`testCircuitBreaker()`添加了电路 breaker 的自动化测试：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To be able to perform some of the required verifications, we need to have access
    to the `actuator` endpoints of the `product-composite` microservice, which are
    not exposed through the edge server. Therefore, we will access the `actuator`
    endpoints through a separate Docker container that will be attached to the internal
    network that was set up by Docker Compose for our microservices.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够进行一些必要的验证，我们需要访问`product-composite`微服务的`actuator`端点，这些端点不会通过边缘服务器暴露。因此，我们将通过一个独立的Docker容器访问`actuator`端点，这个容器将连接到由Docker
    Compose为我们的微服务设置的内部网络。
- en: 'By default, the name of the network is based on the name of the folder where
    the Docker Compose file is placed. To avoid that uncertain dependency, an explicit
    network name, `my-network`, is defined in the `docker-compose` files. All container
    definitions have been updated to specify that they shall attach to the `my-network` network.
    The following is an example from `docker-compose.yml`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，网络名称基于放置Docker Compose文件的文件夹名称。为了避免这种不确定的依赖关系，在`docker-compose`文件中定义了一个显式的网络名称`my-network`。所有容器定义都已更新，以指定它们应附加到`my-network`网络。以下是来自`docker-compose.yml`的一个例子：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Since the container is attached to the internal network, it can access the `actuator`
    endpoints of the product composite without going through the edge server. We will
    use Alpine as our Docker image and use `wget` instead of `curl` since `curl` isn''t
    included in the Alpine distribution by default. For example, to be able to find
    out the state of the circuit breaker named `product` in the `product-composite`
    microservice, we can run the following command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于容器附属于内部网络，它可以直接访问产品组合的`actuator`端点，而不需要通过边缘服务器。我们将使用Alpine作为Docker镜像，并使用`wget`而不是`curl`，因为`curl`默认不包括在Alpine发行版中。例如，为了能够找出名为`product`的电路
    breaker在`product-composite`微服务中的状态，我们可以运行以下命令：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The command is expected to return a value of `CLOSED`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 命令预期返回值为`CLOSED`。
- en: Since we have created the Docker container with the `--rm` flag, it will be
    stopped and destroyed by the Docker engine after the `wget` command completes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用`--rm`标志创建了Docker容器，`wget`命令完成后，Docker引擎将停止并销毁它。
- en: 'The test starts by doing exactly this, that is, verifying that the circuit
    breaker is closed before the tests are executed:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 测试开始执行正好这一点，即在执行测试之前验证断路器是否关闭：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, the test will force the circuit breaker to open up by running three commands
    in a row, all of which will fail on a slow response from the `product` service:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，测试将依次运行三个命令，迫使断路器打开，所有这些命令都将因为`product`服务响应缓慢而失败：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**Quick repetition of the configuration**: The timeout of the `product` service
    is set to two seconds so that a delay of three seconds will cause a timeout. The
    circuit breaker is configured to evaluate the last five last calls when closed.
    The tests in the script that precede the circuit breaker-specific tests have already
    performed a couple of successful calls. The failure threshold is set to 50%, that
    is, three calls with a three-second delay is enough to open the circuit.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速重复配置**：`product`服务的超时设置为两秒，因此三秒的延迟将导致超时。当电路断开时，断路器配置为评估最后五个调用。脚本中先于断路器特定测试的测试已经执行了几次成功的调用。失败阈值设置为50%，即，三次带有三秒延迟的调用足以打开电路。'
- en: 'With the circuit open, we expect a fast failure, that is, we won''t need to
    wait for the timeout before we get a response. We also expect the `fallback` method
    to be called to return a best-effort response. This should also apply for a normal
    call, that is, without requesting a delay. This is verified with the following
    code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在电路断开的情况下，我们期望快速失败，也就是说，我们不需要等待超时就能得到响应。我们还期望调用回退方法返回尽力而为的响应。这也适用于正常调用，即，没有请求延迟。以下代码验证了这一点：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can also verify that the simulated not found error logic works as expected
    in the fallback method, that is, the fallback method returns `404`, `NOT_FOUND`
    for product ID `13`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以验证模拟未找到错误逻辑在回退方法中按预期工作，即回退方法返回`404`、`NOT_FOUND`对于产品ID `13`：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As configured, the circuit breaker will change its state to half-open after
    `10` seconds. To be able to verify that, the test waits for `10` seconds:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如配置所示，断路器在`10`秒后会将其状态更改为半打开。为了能够验证这一点，测试等待`10`秒：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After verifying the expected state (half-closed), the test runs three normal
    requests to make the circuit breaker go back to its normal state, which is also
    verified:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证预期状态（半关闭）后，测试运行三个正常请求，使断路器回到正常状态，这也得到了验证：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Quick repetition of the configuration:** The circuit breaker is configured
    to evaluate the first three calls when in the half-open state. Therefore, we need
    to run three requests where more than 50% are successful before the circuit is
    closed.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速重复配置：**断路器在半打开状态下配置为评估前三个调用。因此，我们需要运行三个请求，其中超过50%的成功率，然后电路才会关闭。'
- en: 'The test wraps up by using the `/actuator/circuitbreakerevents` actuator API,
    which is exposed by the circuit breaker to reveal internal events. It can, for
    example, be used to find out what state transitions the circuit breaker has performed.
    We expect the last three state transitions to be as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通过使用由断路器暴露出的`/actuator/circuitbreakerevents`actuator API结束，该API用于揭示内部事件。例如，它可以用来找出断路器执行了哪些状态转换。我们期望最后三个状态转换如下：
- en: 'First state transitions: Closed to open'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先状态转换：从关闭到开放
- en: 'Next state transitions: Open to half-closed'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个状态转换：从开放到半关闭
- en: 'Last state transitions: Half-closed to closed'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后状态转换：从半关闭到关闭
- en: 'This is verified by the following code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这由以下代码验证：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `jq` expression, `circuitBreakerEvents[-1]`, means the last entry in the
    array of circuit breaker events, `[-2]`, is the second to last event, while `[-3
    ]` is the third to last event. Together, they are the three latest events, that
    is, the ones we are interested in. By default, Resilience4j keeps the last 100
    events per circuit breaker. This can be customized using the `eventConsumerBufferSize` configuration
    parameter.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`jq`表达式`circuitBreakerEvents[-1]`意味着数组中的最后一个事件`[-2]`是倒数第二个事件，而`[-3 ]`是倒数第三个事件。它们一起是三个最新的事件，即我们感兴趣的事件。默认情况下，Resilience4j为每个断路器保持最后100个事件。这可以通过`eventConsumerBufferSize`配置参数进行自定义。'
- en: We added quite a lot of steps to the test script, but with this, we can automatically
    verify that the expected basic behavior of our circuit breaker is in place. In
    the next section, we will try it out!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在测试脚本中添加了许多步骤，但有了这个，我们可以自动验证我们断路器预期的基本行为是否到位。在下一节，我们将尝试它！
- en: Trying out the circuit breaker and retry mechanism
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试断路器和重试机制
- en: 'Now, it''s time to try out the circuit breaker and retry mechanism. We will
    start, as usual, by building the Docker images and running the test script, `test-em-all.bash`.
    After that, we will run through the tests we described previously manually to
    ensure that we understand what''s going on! We will perform the following manual
    tests:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是尝试断路器和重试机制的时候了。我们将像往常一样开始，构建Docker镜像并运行测试脚本`test-em-all.bash`。之后，我们将手动运行我们之前描述的测试，以确保我们了解发生了什么！我们将执行以下手动测试：
- en: Happy days tests of the circuit breaker, that is, to verify that the circuit
    is closed under normal operations
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断路器的快乐日测试，也就是说，验证在正常操作中断路器是关闭的
- en: Negative tests of the circuit breaker, that is, to verify that the circuit opens
    up when things start to go wrong
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断路器的负面测试，也就是说，当事情开始出错时，验证断路器是否会打开
- en: Going back to normal operation, that is, to verify that the circuit goes back
    to its closed state once the problems are resolved
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恢复正常操作，也就是说，一旦问题解决，验证断路器是否回到了关闭状态
- en: Trying out the retry mechanism with random errors
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试带有随机错误的的重试机制
- en: Building and running the automated tests
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和运行自动化测试
- en: 'In order to build and run the automated tests, we need to do the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建和运行自动化测试，我们需要做以下工作：
- en: 'First, build the Docker images with the following commands:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下命令构建Docker镜像：
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, start the system landscape in Docker and run the usual tests with the
    following command:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在Docker中启动系统架构并使用以下命令运行常规测试：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When the test script prints out `Start Circuit Breaker tests!`, the tests we
    described previously are executed!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试脚本打印出`Start Circuit Breaker tests!`时，我们之前描述的测试被执行！
- en: Verifying that the circuit is closed under normal operations
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证在正常操作中断路器是关闭的
- en: 'Before we can call the API, we need an access token. Run the following commands
    to acquire an access token:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够调用API之前，我们需要一个访问令牌。运行以下命令以获取访问令牌：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Try a normal request and verify that it returns the HTTP response code `200`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一个正常请求并验证它返回HTTP响应代码`200`：
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `-w "%{http_code}\n"` switch is used to print the HTTP return status. As
    long as the command returns `200`, we are not interested in the response body,
    and so we suppress it with the switch, that is, `-o /dev/null`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`-w "%{http_code}\n"`选项用于打印HTTP返回状态。只要命令返回`200`，我们就对响应体不感兴趣，因此使用该选项抑制它，即`-o
    /dev/null`。'
- en: 'Verify that the circuit breaker is closed using the `health` API:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`health`API验证断路器是否关闭：
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We expect it to respond with `CLOSED`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望它响应`CLOSED`。
- en: Forcing the circuit breaker to open when things go wrong
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当事情出错时强制打开断路器
- en: 'Now, it''s time to make things go wrong! By that, I mean it''s time to try
    out some negative tests in order to verify that the circuit opens up when things
    start to go wrong. Call the API three times and direct the `product` service to
    cause a timeout on every call, that is, delay the response with `3` seconds. This
    should be enough to trip the circuit breaker:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是让事情变糟的时候了！我的意思是，是时候尝试一些负测试，以验证当事情开始出错时电路是否会打开。调用API三次，并将`product`服务导致超时，即每次调用延迟`3`秒的响应。这应该足以触发断路器：
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We expect a response such as the following each time:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望每次都得到如下响应：
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The circuit breaker is now open, so if you make a fourth attempt (within `waitInterval`,
    that is, `10` seconds), you will see a fast fail and the `fallback` method in
    action. You will get a response back immediately, instead of an error message
    once the timeout kicks in after `2` seconds:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器现在打开了，所以如果你在`waitInterval`内尝试第四次（即`10`秒），你会看到快速失败的响应和回退方法的行动。你将立即得到响应，而不是在`2`秒超时触发后得到错误消息：
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The response will come from the fallback method. This can be recognized by looking
    at the value in the name field, that is, `Fallback product2`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 响应将来自回退方法。这可以通过查看name字段中的值来识别，即`Fallback product2`。
- en: Fast fail and fallback methods are key capabilities of a circuit breaker!
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 快速失败和回退方法是断路器的关键能力！
- en: Given our configuration with a wait time set to only 10 seconds requires you
    to be rather quick to be able to see fast fail and fallback methods in action!
    Once in a half-open state, you can always submit three new requests that cause
    a timeout, forcing the circuit breaker back to the open state, and then quickly
    try the fourth request. Then, you should get a fast fail response from the fallback
    method! You can also increase the wait time to a minute or two, but it can be
    rather boring to wait that amount of time before the circuit switches to the half-open
    state.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我们的配置中设置的等待时间仅为10秒，这要求你必须非常迅速，才能看到快速失败和回退方法在行动中！处于半开启状态时，你总是可以提交三个新的请求导致超时，迫使断路器回到开启状态，然后迅速尝试第四个请求。然后，你应该从回退方法中得到一个快速失败的响应！你也可以将等待时间增加到一两分钟，但等待这么长时间才能看到电路切换到半开启状态可能会相当无聊。
- en: 'Wait 10 seconds, for the circuit breaker to transition to half-open and then
    run the following command to verify that the circuit now is in a half-open state:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 等待10秒钟，让断路器切换到半开启状态，然后运行以下命令验证电路现在是否处于半开启状态：
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Expect it to respond with `HALF_OPEN`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 预期它会响应`HALF_OPEN`。
- en: Closing the circuit breaker again
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 再次关闭断路器
- en: Once the circuit breaker is in a half-open state, it waits for three calls to
    see whether it should open the circuit again or go back to normal, that is, close
    it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦断路器处于半开启状态，它等待三个调用以确定它应该再次打开电路还是恢复正常，即关闭它。
- en: 'Let''s submit three normal requests to close the circuit breaker:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提交三个普通请求来关闭断路器：
- en: '[PRE37]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'They should all response with `200`. Verify that the circuit is closed again
    by using the `health` API:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都应该响应`200`。通过使用`health` API验证电路是否再次关闭：
- en: '[PRE38]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We expect it to respond with `CLOSED`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望它响应为`CLOSED`。
- en: 'Wrap this up by listing the last three state transitions using the following
    command:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下命令列出最后三个状态转换：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Expect it to respond with the following command:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 预期它会响应以下命令：
- en: '[PRE40]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This response tells us that we have taken our circuit breaker through a full
    lap of its state diagram:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个响应告诉我们，我们已经将我们的断路器带遍了它的状态图：
- en: From closed to open when an error starts to prevent requests from succeeding
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当错误开始阻止请求成功时，从关闭状态变为开启状态
- en: From open to half-open to see whether the error is gone
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从开启状态变为半开启状态，以查看错误是否消失
- en: From half-open to closed when the error is gone, that is, when we are back to
    normal operation
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当错误消失时，即当我们恢复正常操作时，从半开启状态变为关闭状态
- en: Trying out retries caused by random errors
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试由随机错误引起的重试
- en: Let's simulate that there is a – hopefully temporary – random issue with our
    `product` service or the communication with it.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们模拟我们的`product`服务或与其通信存在一个-希望是暂时的-随机问题。
- en: 'We can do this by using the `faultPercent` parameter. If we set it to `25`,
    we expect every fourth request to fail. We hope that the retry mechanism will
    kick in to help us by automatically retrying the request. One way of noticing
    that the retry mechanism has kicked in is to measure the response time of the
    `curl` command. A normal response should take no more than 100 ms. Since we have
    configured the retry mechanism to wait one second (see the `waitDuration` parameter
    in the configuration of the preceding retry mechanism), we expect the response
    time to increase with one second per retry attempt. To force a random error to
    occur, run the following command a couple of times:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`faultPercent`参数来实现。如果我们将其设置为`25`，我们期望每个第四个请求都会失败。我们希望重试机制会自动重试请求来帮助我们。注意到重试机制已经启动的一个方法是测量`curl`命令的响应时间。正常响应应该不会超过100毫秒。由于我们配置了重试机制等待一秒钟（参见前面的重试机制中的`waitDuration`参数），我们期望每次重试尝试的响应时间会增加一秒钟。要强制发生随机错误，多次运行以下命令：
- en: '[PRE41]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The command should respond with `200`, indicating that the request succeeded.
    A response time prefixed with `real`, for example, `real 0m0.078s` means that
    the response time was 0.078 s or 78 ms. A normal response, that is, without any
    retries, should look as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 命令应当返回`200`状态码，表示请求成功。响应时间前缀为`real`的，例如`real 0m0.078s`，意味着响应时间为0.078秒或78毫秒。正常的响应，即没有进行任何重试的响应，应该如下所示：
- en: '[PRE42]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'A response after one retry should look as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一次重试后的响应应该如下所示：
- en: '[PRE43]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The HTTP status code 200 indicates that the request has succeeded, even though
    it required one retry before succeeding!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP状态码200表示请求已经成功，即使它需要重试一次才能成功！
- en: 'After you have noticed a response time of one second, that is, the request
    required one retry to succeed, run the following command to see the last two retry
    events:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在你注意到响应时间为一秒之后，即请求需要重试一次才能成功时，运行以下命令来查看最后的两次重试事件：
- en: '[PRE44]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You should be able to see the failed request and the next successful attempt.
    The `creationTime` timestamps are expected to differ by one second. Expect a response
    such as the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够看到失败的请求和下一次成功的尝试。`creationTime`时间戳预计会相差一秒钟。期待如下的响应：
- en: '[PRE45]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If you are really unlucky, you will get two faults in a row, and then you will
    get a response time of two seconds instead of one. If you repeat the preceding
    command, you will be able to see that the `numberOfAttempts` field is counted
    for each retry attempt, which is set to `2` in this case: `"numberOfAttempts":
    2`. If calls continue to fail, the circuit breaker will kick in and open its circuit,
    that is, subsequent calls will fast fail and the fallback method will be applied!'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你真的非常倒霉，你会连续得到两个错误，然后你的响应时间会变成两秒而不是一秒。如果你重复执行前面的命令，你可以看到`numberOfAttempts`字段对每次重试尝试进行计数，在本例中设置为`2`：`"numberOfAttempts":
    2`。如果调用继续失败，熔断器将启动并打开其电路，即后续的调用将会快速失败并应用回退方法！'
- en: '**That''s it!**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**就是这么简单！**'
- en: Feel free to elaborate with the parameters in the configuration to learn about
    the circuit breaker and retry mechanisms better!
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 随意发挥配置中的参数，以更好地了解熔断器和重试机制！
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have seen Resilience4j and its circuit breaker and retry
    mechanism in action.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了Resilience4j及其熔断器和重试机制的实际应用。
- en: A circuit breaker can, using fast fail and `fallback` methods when it is open,
    prevent a microservice from becoming unresponsive if the synchronous services
    it depends on stop responding normally. A circuit breaker can also make a microservice
    resilient by allowing requests when it is half-open to see whether the failing
    service operates normally again and close the circuit if so.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当熔断器打开时，使用快速失败和`fallback`方法，可以防止微服务在它依赖的正常响应的同步服务停止响应时变得无响应。熔断器还可以通过在半开状态下允许请求来使微服务具有弹性，以查看失败的服务是否再次正常运行并关闭电路。
- en: A retry mechanism can retry requests that randomly fail from time to time, for
    example, due to temporary network problems. It is very important to only apply
    retry requests on idempotent services, that is, services that can handle that
    the same request is sent two or more times.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 重试机制可以使微服务具有弹性，通过重试偶尔由于临时网络问题而失败的请求。非常重要的一点是，只有对幂等性服务应用重试请求，也就是说，可以处理相同请求发送两次或多次的服务。
- en: Circuit breakers and retry mechanisms are implemented by following Spring Boot
    conventions, that is, declaring dependencies, and adding annotations and configuration.
    Resilience4j exposes information about its circuit breakers and retry mechanisms
    at runtime, using `actuator` endpoints for health, events, and metrics for circuit
    breakers and events and metrics for retries.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器和重试机制遵循Spring Boot约定实现，即声明依赖项，并添加注解和配置。Resilience4j在运行时通过`actuator`端点暴露有关其断路器和重试机制的信息，包括断路器和事件以及重试的事件和度量指标。
- en: We have seen the usage of both endpoints for health and events in this chapter,
    but we will have to wait until [Chapter 20](5e6cce2d-d426-4f55-95c9-52b596769a57.xhtml),
    *Monitoring Microservices*, before we use any of the metrics.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了健康和事件端点的使用，但我们必须等到[第20章](5e6cce2d-d426-4f55-95c9-52b596769a57.xhtml)，*监控微服务*，我们才能使用任何度量指标。
- en: In the next chapter, we will cover the last part of using Spring Cloud, where
    we will learn how to trace call chains through a set of cooperating microservices
    using Spring Cloud Sleuth and Zipkin. Head over to [Chapter 14](42f456c5-d911-494a-a1ba-4631863068b6.xhtml),
    *Understanding Distributed Tracing*, to get started!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将涵盖使用Spring Cloud的最后部分，届时我们将学习如何使用Spring Cloud Sleuth和Zipkin通过一组协作的微服务跟踪调用链。前往[第14章](42f456c5-d911-494a-a1ba-4631863068b6.xhtml)，*理解分布式跟踪*，开始学习吧！
- en: Questions
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the states of a circuit breaker and how are they used?
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断路器有哪些状态，它们是如何使用的？
- en: How can we handle timeout errors in the circuit breaker?
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何处理断路器中的超时错误？
- en: How can we apply fallback logic when a circuit breaker fast fails?
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当断路器快速失败时，我们如何应用回退逻辑？
- en: How can a retry mechanism and a circuit breaker interfere with each other?
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重试机制和断路器如何相互干扰？
- en: Provide an example of a service that you can't apply a retry mechanism for.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个无法应用重试机制的服务示例。
