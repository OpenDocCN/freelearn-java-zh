- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Custom Authorization
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义授权
- en: In this chapter, we will write some custom implementations for `Spring Security`’s
    key authorization APIs. Once we have done this, we will use our understanding
    of the custom implementations to understand how `Spring Security`’s authorization
    architecture works.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为 `Spring Security` 的关键授权 API 编写一些自定义实现。一旦我们完成这项工作，我们将利用我们对自定义实现的理解来了解
    `Spring Security` 的授权架构是如何工作的。
- en: 'Throughout this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Gaining an understanding of how authorization works
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解授权是如何工作的
- en: Writing a custom `SecurityMetaDataSource` backed by a database instead of `requestMatchers()`
    methods
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个基于数据库而不是 `requestMatchers()` 方法的自定义 `SecurityMetaDataSource`
- en: Creating custom **Spring Expression Language** (**SpEL**) expressions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义的 **Spring 表达式语言**（**SpEL**）表达式
- en: Implementing a custom `PermissionEvaluator` object that allows our permissions
    to be encapsulated
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个自定义的 `PermissionEvaluator` 对象，以便封装我们的权限
- en: Declaring a custom `AuthorizationManager`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个自定义的 `AuthorizationManager`
- en: 'This chapter’s code in action link is here: [https://packt.link/e630f](https://packt.link/e630f).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章代码示例链接在此：[https://packt.link/e630f](https://packt.link/e630f)。
- en: Authorizing the Requests
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权请求
- en: As in the authentication process, `Spring Security` provides an `o.s.s.web.access.intercept.FilterSecurityInterceptor`
    servlet filter, which is responsible for coming up with a decision as to whether
    a particular request will be accepted or denied. At the point the filter is invoked,
    the principal has already been authenticated, so the system knows that a valid
    user has logged in; remember that we implemented the `List<GrantedAuthority>`
    `getAuthorities()` method, which returns a list of authorities for the principal,
    in [*Chapter 3*](B21757_03.xhtml#_idTextAnchor068), *Custom Authentication*. In
    general, the authorization process will use the information from this method (defined
    by the `Authentication` interface) to determine, for a particular request, whether
    or not the request should be allowed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在认证过程中一样，`Spring Security` 提供了一个 `o.s.s.web.access.intercept.FilterSecurityInterceptor`
    Servlet 过滤器，该过滤器负责决定是否接受或拒绝特定的请求。当过滤器被调用时，主体已经经过认证，因此系统知道一个有效的用户已经登录；记住我们在 [*第3章*](B21757_03.xhtml#_idTextAnchor068)，*自定义认证*
    中实现了 `List<GrantedAuthority>` 的 `getAuthorities()` 方法，该方法返回主体的权限列表。一般来说，授权过程将使用此方法（由
    `Authentication` 接口定义）的信息来确定，对于特定的请求，是否允许请求。
- en: This method serves as a means for an `AuthorizationManager` instance to acquire
    a precise String representation of the `GrantedAuthority`. By providing a representation
    as a String, most `AuthorizationManager` implementations can easily `read` the
    `GrantedAuthority`. If a `GrantedAuthority` cannot be accurately represented as
    a String, it is considered `complex`, and the `getAuthority()` method must return
    `null`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法作为 `AuthorizationManager` 实例获取 `GrantedAuthority` 精确字符串表示的一种方式。通过提供字符串表示，大多数
    `AuthorizationManager` 实现可以轻松地 `读取` `GrantedAuthority`。如果 `GrantedAuthority` 不能准确地表示为字符串，则被视为
    `复杂`，并且 `getAuthority()` 方法必须返回 `null`。
- en: A prime example of a complex `GrantedAuthority` would be an implementation storing
    a list of operations and authority thresholds related to various customer account
    numbers. Trying to represent this intricate `GrantedAuthority` as a String would
    pose considerable challenges. Consequently, the `getAuthority()` method should
    return `null`. This signals to any `AuthorizationManager` that it needs to support
    the specific `GrantedAuthority` implementation to comprehend its contents.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个复杂的 `GrantedAuthority` 的主要例子是存储与各种客户账户号码相关的操作和权限阈值的实现。试图将这个复杂的 `GrantedAuthority`
    表示为字符串将带来相当大的挑战。因此，`getAuthority()` 方法应该返回 `null`。这向任何 `AuthorizationManager`
    发出信号，它需要支持特定的 `GrantedAuthority` 实现来理解其内容。
- en: '`Spring Security` features a concrete `GrantedAuthority` implementation named
    `SimpleGrantedAuthority`. This implementation enables the conversion of any user-specified
    String into a `GrantedAuthority`. All `AuthenticationProvider` instances integrated
    into the security architecture utilize `SimpleGrantedAuthority` to populate the
    `Authentication` object.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spring Security` 具有一个名为 `SimpleGrantedAuthority` 的具体 `GrantedAuthority` 实现名。此实现允许将任何用户指定的字符串转换为
    `GrantedAuthority`。所有集成到安全架构中的 `AuthenticationProvider` 实例都使用 `SimpleGrantedAuthority`
    来填充 `Authentication` 对象。'
- en: By default, role-based authorization rules involve the prefix `ROLE_`. Therefore,
    if an authorization rule mandates a security context to possess the role of `USER`,
    `Spring Security` will automatically seek a `GrantedAuthority#getAuthority` that
    returns `ROLE_USER`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，基于角色的授权规则涉及前缀 `ROLE_`。因此，如果授权规则要求安全上下文具有 `USER` 角色，`Spring Security` 将自动寻找返回
    `ROLE_USER` 的 `GrantedAuthority#getAuthority`。
- en: Remember that authorization is a binary decision—a user either has access to
    a secured resource or does not. There is no ambiguity when it comes to authorization.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，授权是一个二元决策——用户要么可以访问受保护资源，要么不能。在授权方面没有歧义。
- en: A smart object-oriented design is pervasive within the `Spring Security` framework,
    and authorization decision management is no exception.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Spring Security` 框架中，智能面向对象设计无处不在，授权决策管理也不例外。
- en: 'In `Spring Security`, the `o.s.s.access.AccessDecisionManager` interface specifies
    two simple and logical methods that fit sensibly into the processing decision
    flow of requests, as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Spring Security` 中，`o.s.s.access.AccessDecisionManager` 接口定义了两个简单且逻辑上合理的函数，这些函数合理地融入了请求处理决策流程中，具体如下：
- en: '`supports`: This logical operation actually comprises two methods that allow
    the `AccessDecisionManager` implementation to report whether or not it supports
    the current request.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`supports`：这个逻辑操作实际上包含两个方法，允许 `AccessDecisionManager` 实现报告它是否支持当前请求。'
- en: '`decide`: This allows the `AccessDecisionManager` implementation to verify,
    based on the request context and security configuration, whether or not access
    should be allowed and the request accepted. The `Decide` method actually has no
    return value, and instead reports the denial of a request by throwing an exception
    to indicate rejection.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decide`：此方法允许 `AccessDecisionManager` 实现根据请求上下文和安全配置验证是否允许访问并接受请求。实际上，`Decide`
    方法没有返回值，而是通过抛出异常来报告请求被拒绝。'
- en: Specific types of exceptions can further dictate the action to be taken by the
    application to resolve authorization decisions. The `o.s.s.access.AccessDeniedException`
    interface is the most common exception thrown in the area of authorization and
    merits special handling by the filter chain.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 特定的异常类型可以进一步指导应用程序采取哪些行动来解决授权决策。`o.s.s.access.AccessDeniedException` 接口是在授权领域中最常见的异常，并且值得过滤器链进行特殊处理。
- en: The implementation of `AccessDecisionManager` is completely configurable using
    standard Spring bean binding and references. The default `AccessDecisionManager`
    implementation provides an access granting mechanism based on `AccessDecisionVoter`
    and vote aggregation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`AccessDecisionManager` 的实现完全可以通过标准的 Spring Bean 绑定和引用进行配置。默认的 `AccessDecisionManager`
    实现提供了一个基于 `AccessDecisionVoter` 和投票聚合的访问授权机制。'
- en: 'A voter is an actor in the authorization sequence whose job is to evaluate
    any or all of the following things:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 投票者是在授权序列中的参与者，其任务是评估以下任何一项或所有内容：
- en: The context of the request for a secured resource (such as a URL requesting
    an IP address)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受保护资源的请求上下文（例如，请求 IP 地址的 URL）
- en: The credentials (if any) presented by the user
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户提供的凭证（如果有）
- en: The secured resource being accessed
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被访问的安全资源
- en: The configuration parameters of the system, and the resource itself
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统的配置参数以及资源本身
- en: After demonstrating the process of authorizing requests, we will delve into
    the management of invocations.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在演示了请求授权的过程之后，我们将深入探讨调用管理。
- en: Handling of Invocations
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用处理
- en: '`Spring Security` offers interceptors that are responsible for governing access
    to secure objects, be it method invocations or web requests. `AuthorizationManager`
    instances play a crucial role in making pre-invocation decisions regarding whether
    the invocation is permitted to proceed. Additionally, these instances contribute
    to post-invocation decisions, determining whether a particular value may be returned.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spring Security` 提供了拦截器，负责管理对安全对象的访问，无论是方法调用还是网络请求。`AuthorizationManager`
    实例在做出调用前的决策中起着至关重要的作用，决定调用是否被允许继续进行。此外，这些实例还参与调用后的决策，确定是否可以返回特定的值。'
- en: The AuthorizationManager class
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`AuthorizationManager` 类'
- en: '`AuthorizationManager` takes precedence over both `AccessDecisionManager` and
    `AccessDecisionVoter`. Applications that customize either an `AccessDecisionManager`
    or an `AccessDecisionVoter` are advised to transition using `AuthorizationManager`.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthorizationManager` 优先于 `AccessDecisionManager` 和 `AccessDecisionVoter`。建议自定义
    `AccessDecisionManager` 或 `AccessDecisionVoter` 的应用程序使用 `AuthorizationManager`
    进行过渡。'
- en: '`Spring Security`’s request-based, method-based, and message-based authorization
    components invoke `AuthorizationManager` instances, assigning them the responsibility
    of making definitive access control decisions.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spring Security` 的基于请求、方法和消息的授权组件调用 `AuthorizationManager` 实例，将做出最终访问控制决策的责任分配给它们。'
- en: The `check` method of `AuthorizationManager` receives all the pertinent information
    necessary to render an authorization decision. Specifically, passing the secure
    object allows the examination of arguments within the actual invocation of the
    secure object. For instance, if the secure object is a `MethodInvocation`, querying
    it for any client argument becomes straightforward. Subsequently, security logic
    can be implemented in the `AuthorizationManager` to ensure that the principal
    is authorized to operate on that customer. Implementations are expected to return
    a positive `AuthorizationDecision` if access is granted, a negative `AuthorizationDecision`
    if access is denied, and a null `AuthorizationDecision` when abstaining from making
    a decision.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthorizationManager` 的 `check` 方法接收做出授权决策所需的所有相关信息。具体来说，传递安全对象允许检查安全对象实际调用中的参数。例如，如果安全对象是一个
    `MethodInvocation`，查询它以获取任何客户端参数变得简单。随后，可以在 `AuthorizationManager` 中实现安全逻辑，以确保主体有权操作该客户。预期实现将在授予访问权限时返回正面的
    `AuthorizationDecision`，在拒绝访问时返回负面的 `AuthorizationDecision`，在放弃做出决策时返回 null `AuthorizationDecision`。'
- en: The verify function invokes `check` and throws an `AccessDeniedException` if
    a negative `AuthorizationDecision` is reached.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: verify 函数在达到负面的 `AuthorizationDecision` 时调用 `check` 并抛出 `AccessDeniedException`。
- en: Delegate-based AuthorizationManager Implementations
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于 Delegating 的 AuthorizationManager 实现
- en: Although users have the flexibility to implement their own `AuthorizationManager`
    to govern all facets of authorization, `Spring Security` comes with a delegating
    `AuthorizationManager` designed to work in tandem with individual `AuthorizationManagers`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管用户有灵活性来实现自己的 `AuthorizationManager` 以管理授权的所有方面，但 `Spring Security` 提供了一个委托的
    `AuthorizationManager`，旨在与单个 `AuthorizationManager` 协同工作。
- en: The `RequestMatcherDelegatingAuthorizationManager` aligns the request with the
    most suitable delegate `AuthorizationManager`. For method security, `AuthorizationManagerBeforeMethodInterceptor`
    and `AuthorizationManagerAfterMethodInterceptor` can be employed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`RequestMatcherDelegatingAuthorizationManager` 将请求与最合适的委托 `AuthorizationManager`
    对齐。对于方法安全，可以使用 `AuthorizationManagerBeforeMethodInterceptor` 和 `AuthorizationManagerAfterMethodInterceptor`。'
- en: 'The relevant classes for `AuthorizationManager` implementations are outlined
    for reference in *Figure 13**.1*:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `AuthorizationManager` 实现的相关类，在 *图 13.1* 中进行了概述供参考。1*：
- en: '![Figure 13.1 – Implementations of AuthorizationManager](img/B21757_13_1.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1 – AuthorizationManager 的实现](img/B21757_13_1.jpg)'
- en: Figure 13.1 – Implementations of AuthorizationManager
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – AuthorizationManager 的实现
- en: With this approach, a collection of `AuthorizationManager` implementations can
    be consulted for an authorization decision.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法，可以咨询一组 `AuthorizationManager` 实现来做出授权决策。
- en: In the following subsections, we will take a deeper look at some authorization
    managers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的小节中，我们将更深入地探讨一些授权管理器。
- en: AuthorityAuthorizationManager
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AuthorityAuthorizationManager
- en: The predominant `AuthorizationManager` provided by `Spring Security` is the
    `AuthorityAuthorizationManager`. It is configured with a specific set of authorities
    to check for in the current `Authentication`. If the `Authentication` contains
    any of the configured authorities, it will yield a positive `AuthorizationDecision`;
    otherwise, it will result in a negative `AuthorizationDecision`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spring Security` 提供的主要 `AuthorizationManager` 是 `AuthorityAuthorizationManager`。它配置了特定的一组权限，用于在当前的
    `Authentication` 中进行检查。如果 `Authentication` 包含任何配置的权限，它将产生一个正面的 `AuthorizationDecision`；否则，将导致一个负面的
    `AuthorizationDecision`。'
- en: AuthenticatedAuthorizationManager
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AuthenticatedAuthorizationManager
- en: Another manager available is the `AuthenticatedAuthorizationManager`. It proves
    useful in distinguishing between *anonymous*, *fully-authenticated*, and *remember-me*
    authenticated users. Some websites grant limited access under *remember-me* authentication
    but necessitate users to confirm their identity by logging in for complete access.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可用的管理器是`AuthenticatedAuthorizationManager`。它在区分*匿名*、*完全认证*和*记住我*认证用户方面非常有用。一些网站在*记住我*认证下提供有限的访问权限，但需要用户通过登录来确认身份以获得完全访问权限。
- en: AuthorizationManagers
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`AuthorizationManagers`'
- en: '`AuthorizationManagers` also offer useful static factories for combining individual
    `AuthorizationManagers` into more intricate expressions.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthorizationManagers`还提供了将单个`AuthorizationManagers`组合成更复杂表达式的有用静态工厂。'
- en: Custom AuthorizationManagers
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义`AuthorizationManagers`
- en: Certainly, you have the option to implement a custom `AuthorizationManager`,
    allowing for the inclusion of virtually any access control logic. It may be tailored
    to your application, related to business logic, or involve security administration
    logic. For instance, you can create an implementation capable of querying Open
    Policy Agent or your own authorization database.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以选择实现自定义的`AuthorizationManager`，以便包含几乎任何访问控制逻辑。它可以针对你的应用程序定制，与业务逻辑相关，或涉及安全管理逻辑。例如，你可以创建一个能够查询Open
    Policy Agent或你自己的授权数据库的实现。
- en: After delving into the management of invocations, we will proceed to examine
    the customization of `AccessDecisionManager` and `AccessDecisionVoter`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究调用管理之后，我们将继续探讨`AccessDecisionManager`和`AccessDecisionVoter`的定制化。
- en: Modifying AccessDecisionManager and AccessDecisionVoter
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改`AccessDecisionManager`和`AccessDecisionVoter`
- en: Before the introduction of `AuthorizationManager`, `Spring Security` introduced
    `AccessDecisionManager` and `AccessDecisionVoter`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AuthorizationManager`引入之前，`Spring Security`引入了`AccessDecisionManager`和`AccessDecisionVoter`。
- en: In certain scenarios, such as when migrating an older application, it might
    be preferable to incorporate an `AuthorizationManager` that invokes an `AccessDecisionManager`
    or `AccessDecisionVoter`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些场景下，例如在迁移旧应用程序时，可能更倾向于使用调用`AccessDecisionManager`或`AccessDecisionVoter`的`AuthorizationManager`。
- en: 'To invoke an existing `AccessDecisionManager`, you can use:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用现有的`AccessDecisionManager`，你可以使用：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Subsequently, integrate it into your `SecurityFilterChain`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将其集成到你的`SecurityFilterChain`中。
- en: 'Alternatively, if you wish to only invoke an `AccessDecisionVoter`, you can
    use:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你只想调用`AccessDecisionVoter`，你可以使用：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Afterward, integrate it into your `SecurityFilterChain`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将其集成到你的`SecurityFilterChain`中。
- en: Legacy Authorization Components
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旧版授权组件
- en: In this section, we will take a closer look at certain authorization components
    that existed in `Spring Security` but have been deprecated with the introduction
    of `Spring` `Security 6`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更详细地研究`Spring Security`中存在但随`Spring` `Security 6`引入而弃用的某些授权组件。
- en: The AccessDecisionManager
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`AccessDecisionManager`'
- en: 'The `AbstractSecurityInterceptor` invokes the `AccessDecisionManager`, which
    is tasked with making conclusive access control decisions. The `AccessDecisionManager`
    interface encompasses three methods:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractSecurityInterceptor`会调用`AccessDecisionManager`，该组件负责做出最终的访问控制决策。`AccessDecisionManager`接口包含三个方法：'
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `decide` method of the `AccessDecisionManager` receives all the pertinent
    information required to make an authorization decision. Specifically, passing
    the secure object allows the inspection of arguments within the actual invocation
    of the secure object. For instance, if the secure object is a `MethodInvocation`,
    you can inquire about any `Customer` argument in the `MethodInvocation` and then
    implement security logic in the `AccessDecisionManager` to verify whether the
    principal is authorized to operate on that customer. Implementations are expected
    to throw an `AccessDeniedException` if access is denied.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`AccessDecisionManager`的`decide`方法接收做出授权决策所需的所有相关信息。具体来说，传递安全对象允许检查实际调用安全对象内的参数。例如，如果安全对象是`MethodInvocation`，你可以查询`MethodInvocation`中的任何`Customer`参数，然后在`AccessDecisionManager`中实现安全逻辑以验证主体是否有权对该客户进行操作。如果拒绝访问，实现应抛出`AccessDeniedException`。'
- en: The `supports(ConfigAttribute`) method is invoked by the `AbstractSecurityInterceptor`
    during startup to determine whether the `AccessDecisionManager` can handle the
    provided `ConfigAttribute`. The `supports(Class clazz)` method is called by a
    security interceptor implementation to ensure that the configured `AccessDecisionManager`
    supports the type of secure object presented by the security interceptor.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`supports(ConfigAttribute)` 方法在启动时由 `AbstractSecurityInterceptor` 调用，以确定 `AccessDecisionManager`
    是否可以处理提供的 `ConfigAttribute`。`supports(Class clazz)` 方法由安全拦截器实现调用，以确保配置的 `AccessDecisionManager`
    支持安全拦截器提供的安全对象的类型。'
- en: AccessDecisionManager Implementations Based on Voting
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于投票的 `AccessDecisionManager` 实现
- en: Although users have the flexibility to implement their own `AccessDecisionManager`
    to oversee all aspects of authorization, `Spring Security` provides various `AccessDecisionManager`
    implementations grounded in a voting mechanism. The relevant classes are explained
    in the **Voting** **Decision Manager**.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管用户有灵活性来实现自己的 `AccessDecisionManager` 以监督授权的所有方面，但 `Spring Security` 提供了基于投票机制的多种
    `AccessDecisionManager` 实现。相关类在 **投票决策管理器** 中解释。
- en: 'The `AccessDecisionManager` interface is illustrated in the following figure:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了 `AccessDecisionManager` 接口：
- en: '![Figure 13.2 – Voting Decision Manager](img/B21757_13_2.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.2 – 投票决策管理器](img/B21757_13_2.jpg)'
- en: Figure 13.2 – Voting Decision Manager
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 – 投票决策管理器
- en: Through this approach, a sequence of `AccessDecisionVoter` implementations is
    consulted for an authorization decision. The `AccessDecisionManager` subsequently
    determines whether or not to throw an `AccessDeniedException` based on its evaluation
    of the votes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方法，将咨询一系列 `AccessDecisionVoter` 实现以进行授权决策。`AccessDecisionManager` 随后根据其对投票的评估决定是否抛出
    `AccessDeniedException`。
- en: '`Spring Security` provides three concrete `AccessDecisionManager` implementations
    to aggregate votes. The `ConsensusBased` implementation allows or denies access
    based on the consensus of non-abstain votes. Configurable properties govern behavior
    in case of vote equality or if all votes abstain. The `AffirmativeBased` implementation
    grants access if one or more `ACCESS_GRANTED` votes are received (ignoring deny
    votes as long as there is at least one grant vote). Similar to `ConsensusBased`,
    it has a parameter controlling behavior if all voters abstain. The `UnanimousBased`
    implementation requires unanimous `ACCESS_GRANTED` votes for access, disregarding
    abstains. It denies access with any `ACCESS_DENIED` vote. Like the others, it
    has a parameter governing behavior if all voters abstain.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spring Security` 提供了三个具体的 `AccessDecisionManager` 实现来汇总投票。`ConsensusBased`
    实现基于非弃权投票的共识允许或拒绝访问。可配置属性在投票相等或所有投票者弃权的情况下控制行为。`AffirmativeBased` 实现如果收到一个或多个
    `ACCESS_GRANTED` 投票（只要至少有一个授予投票，就忽略拒绝投票），则授予访问权限。类似于 `ConsensusBased`，它有一个参数控制所有投票者弃权时的行为。`UnanimousBased`
    实现要求一致同意的 `ACCESS_GRANTED` 投票才能访问，忽略弃权。它对任何 `ACCESS_DENIED` 投票拒绝访问。与其他类似，它有一个参数控制所有投票者弃权时的行为。'
- en: Custom `AccessDecisionManager` instances can be implemented to customize vote
    tallying. For instance, votes from a specific `AccessDecisionVoter` might carry
    additional weight, and a deny vote from a particular voter could have a veto effect.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 可以实现自定义的 `AccessDecisionManager` 实例以自定义投票计数。例如，来自特定 `AccessDecisionVoter` 的投票可能具有额外的权重，而来自特定投票者的拒绝投票可能具有否决效果。
- en: RoleVoter
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RoleVoter
- en: The `RoleVoter`, the most commonly utilized `AccessDecisionVoter` provided by
    `Spring Security`, interprets configuration attributes as role names and votes
    to grant access if the user has been assigned that role.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`RoleVoter` 是 `Spring Security` 提供的最常用的 `AccessDecisionVoter`，它将配置属性解释为角色名称，并在用户被分配该角色时投票授予访问权限。'
- en: It casts a vote if any `ConfigAttribute` starts with the `ROLE_` prefix. Access
    is granted if there is a `GrantedAuthority` that returns a String representation
    (via the `getAuthority()` method) exactly matching one or more `ConfigAttribute`
    instances, starting with the `ROLE_` prefix. If there is no precise match for
    any `ConfigAttribute` starting with `ROLE_`, `RoleVoter` votes to deny access.
    If no `ConfigAttribute` starts with `ROLE_`, the voter abstains.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何 `ConfigAttribute` 以 `ROLE_` 前缀开头，则会投一票。如果存在返回字符串表示形式（通过 `getAuthority()`
    方法）与一个或多个以 `ROLE_` 前缀开头的 `ConfigAttribute` 实例完全匹配的 `GrantedAuthority`，则授予访问权限。如果没有任何以
    `ROLE_` 开头的 `ConfigAttribute` 与之精确匹配，`RoleVoter` 将投票拒绝访问。如果没有任何 `ConfigAttribute`
    以 `ROLE_` 开头，投票者将弃权。
- en: AuthenticatedVoter
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AuthenticatedVoter
- en: Another implicit voter is the `AuthenticatedVoter`, useful for distinguishing
    between *anonymous*, *fully-authenticated*, and *remember-me* authenticated users.
    Many websites allow limited access under *remember-me* authentication but necessitate
    user confirmation of identity by logging in for full access.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个隐式投票者是 `AuthenticatedVoter`，用于区分 *匿名*、*完全认证* 和 *记住我* 认证用户。许多网站在 *记住我* 认证下允许有限的访问，但需要用户通过登录来确认身份以获得完全访问。
- en: The processing of the `IS_AUTHENTICATED_ANONYMOUSLY` attribute for granting
    anonymous access is handled by the `AuthenticatedVoter`, as seen in previous examples.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为授予匿名访问而处理的 `IS_AUTHENTICATED_ANONYMOUSLY` 属性由 `AuthenticatedVoter` 处理，如前例所示。
- en: Custom Voters
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义投票者
- en: Implementing a custom `AccessDecisionVoter` enables the inclusion of virtually
    any access control logic. It may be tailored to your application, related to business
    logic, or involve security administration logic. For instance, a blog article
    on the Spring website outlines using a voter to deny real-time access to users
    with suspended accounts.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 实现自定义的 `AccessDecisionVoter` 可以使几乎任何访问控制逻辑得以包含。它可以根据您的应用程序定制，与业务逻辑相关，或涉及安全管理逻辑。例如，Spring
    网站上的一篇博客文章概述了使用投票者拒绝为被暂停账户的用户提供实时访问。
- en: Expression-based request authorization
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于表达式的请求授权
- en: As you might expect, `Voter` implementation, `o.s.s.web.access.expression.WebExpressionVoter`,
    which understands how to evaluate the SpEL expressions. The `WebExpressionVoter`
    class relies on an implementation of the `SecurityExpressionHandler` interface
    for this purpose. The `SecurityExpressionHandler` interface is responsible both
    for evaluating the expressions and for supplying the security-specific methods
    that are referenced in the expressions. The default implementation of this interface
    exposes methods defined in the `o.s.s.web.access.expression.WebSecurityExpressionRoot`
    class.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能预料的，`Voter` 实现 `o.s.s.web.access.expression.WebExpressionVoter`，它理解如何评估
    SpEL 表达式。`WebExpressionVoter` 类依赖于 `SecurityExpressionHandler` 接口来实现这一目的。`SecurityExpressionHandler`
    接口负责评估表达式，并为表达式中所引用的安全特定方法提供支持。该接口的默认实现公开了在 `o.s.s.web.access.expression.WebSecurityExpressionRoot`
    类中定义的方法。
- en: 'The flow and relationship between these classes are shown in the following
    diagram:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类之间的流程和关系如下所示：
- en: '![Figure 13.3 – Relationship between WebSecurityExpressionRoot and AccessDecisionManager](img/B21757_13_3.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.3 – `WebSecurityExpressionRoot` 和 `AccessDecisionManager` 之间的关系](img/B21757_13_3.jpg)'
- en: Figure 13.3 – Relationship between WebSecurityExpressionRoot and AccessDecisionManager
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3 – `WebSecurityExpressionRoot` 和 `AccessDecisionManager` 之间的关系
- en: Now that we know how request authorization works, let’s solidify our understanding
    by making a few custom implementations of some key interfaces.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了请求授权的工作原理，让我们通过实现一些关键接口的几个自定义实现来巩固我们的理解。
- en: The real power of `Spring Security`’s authorization is demonstrated by how adaptable
    it is to custom requirements. Let’s explore a few scenarios that will help reinforce
    our understanding of the overall architecture.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spring Security` 的授权功能通过其如何适应自定义需求来展示其实力。让我们探讨一些场景，这将有助于加强我们对整体架构的理解。'
- en: Dynamically defining access control to URLs
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态定义对 URL 的访问控制
- en: '`Spring Security` provides several methods for mapping `ConfigAttribute` objects
    to a resource. For example, the `requestMatchers()` method ensures it is simple
    for developers to restrict access to specific HTTP requests in their web applications.
    Behind the scenes, an implementation of `o.s.s.acess.SecurityMetadataSource` is
    populated with these mappings and queried to determine what is required in order
    to be authorized to make any given HTTP request.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spring Security` 提供了多种方法将 `ConfigAttribute` 对象映射到资源。例如，`requestMatchers()`
    方法确保开发人员可以轻松地限制其 Web 应用程序中特定 HTTP 请求的访问。在幕后，`o.s.s.acess.SecurityMetadataSource`
    的一个实现被填充了这些映射，并查询以确定要授权进行任何给定 HTTP 请求所需的内容。'
- en: While the `requestMatchers()` method is very simple, there may be times when
    it would be desirable to provide a custom mechanism for determining the URL mappings.
    An example of this might be if an application needs to be able to dynamically
    provide access control rules. Let’s demonstrate what it would take to move our
    URL authorization configuration into a database.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `requestMatchers()` 方法非常简单，但有时可能希望提供一种自定义机制来确定 URL 映射。一个例子可能是如果应用程序需要能够动态提供访问控制规则。让我们演示一下将我们的
    URL 授权配置移动到数据库需要做些什么。
- en: Configuring the RequestConfigMappingService
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 RequestConfigMappingService
- en: 'The first step is to be able to obtain the necessary information from the database.
    This will replace the logic that reads in the `requestMatchers()` methods from
    our security bean configuration. In order to do this, the chapter’s sample code
    contains `JpaRequestConfigMappingService`, which will obtain a mapping of an `Ant
    Pattern` and an expression from the database represented as `RequestConfigMapping`.
    The rather simple implementation is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是能够从数据库中获取必要的信息。这将替换从我们的安全配置 Bean 中读取 `requestMatchers()` 方法的逻辑。为了做到这一点，本章的示例代码包含
    `JpaRequestConfigMappingService`，它将从数据库中获取表示为 `RequestConfigMapping` 的 `Ant Pattern`
    和表达式的映射。相当简单的实现如下：
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It is important to notice that, just as with the `requestMatchers()` methods,
    order matters. Therefore, we ensure the results are sorted by the `sort_order`
    column. The service creates an `AntRequestMatcher` and associates it with `SecurityConfig`,
    an instance of `ConfigAttribute`. This will provide a mapping of the HTTP request
    to `ConfigAttribute` objects that can be used by `Spring Security` to secure our
    URLs.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，就像 `requestMatchers()` 方法一样，顺序很重要。因此，我们确保结果按 `sort_order` 列排序。该服务创建一个
    `AntRequestMatcher` 并将其与 `SecurityConfig` 关联，`SecurityConfig` 是 `ConfigAttribute`
    的一个实例。这将提供 HTTP 请求到 `ConfigAttribute` 对象的映射，这些对象可以被 `Spring Security` 用于保护我们的
    URL。
- en: 'We need to create a domain object to use for **Jakarta Persistence** (**JPA**)
    to map to, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个用于映射到 **Jakarta Persistence** （**JPA**）的域对象，如下所示：
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, we need to create a Spring Data repository object, as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要创建一个 Spring Data 存储库对象，如下所示：
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In order for the new service to work, we will need to initialize our database
    with the schema and the access control mappings, just as with the service implementation.
    The `security_filter_metadata` table schema can be auto-generated by `spring-data-jpa`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使新的服务能够工作，我们需要像服务实现一样初始化我们的数据库，包括模式和访问控制映射。`security_filter_metadata` 表模式可以由
    `spring-data-jpa` 自动生成。
- en: 'We can then use the same `requestMatchers()` mappings from our `SecurityConfig.java`
    file to produce the `data.sql` file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用来自 `SecurityConfig.java` 文件的相同 `requestMatchers()` 映射来生成 `data.sql`
    文件：
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once the `RequestConfigMappingService` is configured, we’ll explore the implementation
    of a custom `SecurityMetadataSource`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置了 `RequestConfigMappingService`，我们将探讨自定义 `SecurityMetadataSource` 的实现。
- en: Custom SecurityMetadataSource implementation
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义 SecurityMetadataSource 实现
- en: 'In order for `Spring Security` to be aware of our URL mappings, we need to
    provide a custom `FilterInvocationSecurityMetadataSource` implementation. The
    `FilterInvocationSecurityMetadataSource` package extends the `SecurityMetadataSource`
    interface which, given a particular HTTP request, is what provides `Spring Security`
    with the information necessary for determining whether access should be granted.
    Let’s take a look at how we can utilize our `RequestConfigMappingService` interface
    to implement a `SecurityMetadataSource` interface:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 `Spring Security` 了解我们的 URL 映射，我们需要提供一个自定义的 `FilterInvocationSecurityMetadataSource`
    实现。`FilterInvocationSecurityMetadataSource` 包扩展了 `SecurityMetadataSource` 接口，该接口在给定特定的
    HTTP 请求时，为 `Spring Security` 提供了确定是否应授予访问权限所需的信息。让我们看看我们如何利用我们的 `RequestConfigMappingService`
    接口来实现 `SecurityMetadataSource` 接口：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We are able to use our `RequestConfigMappingService` interface to create a map
    of `RequestMatcher` objects that map to `ConfigAttribute` objects. We then delegate
    to an instance of `ExpressionBasedFilterInvocationSecurityMetadataSource` to do
    all the work. For simplicity, the current implementation would require restarting
    the application to pick up changes. However, with a few minor changes, we could
    avoid this inconvenience.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们的 `RequestConfigMappingService` 接口来创建一个映射到 `ConfigAttribute` 对象的 `RequestMatcher`
    对象的映射。然后，我们将工作委托给 `ExpressionBasedFilterInvocationSecurityMetadataSource` 的一个实例来完成。为了简化，当前的实现将需要重新启动应用程序以获取更改。然而，通过一些小的修改，我们可以避免这种不便。
- en: Registering a custom SecurityMetadataSource
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册自定义 SecurityMetadataSource
- en: 'Now, all that is left is for us to configure `FilterInvocationServiceSecurityMetadataSource`.
    The only problem is that `Spring Security` does not support configuring a custom
    `FilterInvocationServiceSecurityMetadataSource` interface directly. This is not
    too difficult, so we will register this `SecurityMetadataSource` with our `FilterSecurityInterceptor`
    in our `SecurityConfig` file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们剩下的工作就是配置 `FilterInvocationServiceSecurityMetadataSource`。唯一的问题是 `Spring
    Security` 不支持直接配置自定义的 `FilterInvocationServiceSecurityMetadataSource` 接口。这并不太难，所以我们将在这个
    `SecurityConfig` 文件中注册这个 `SecurityMetadataSource` 到我们的 `FilterSecurityInterceptor`：
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This sets up our custom `SecurityMetadataSource` interface with the `FilterSecurityInterceptor`
    object as the default metadata source.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了我们的自定义 `SecurityMetadataSource` 接口，使用 `FilterSecurityInterceptor` 对象作为默认的元数据源。
- en: Now that the database is being used to map our security configuration, we can
    remove the `requestMatchers()` method from our `SecurityConfig.java` file.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据库正在用于映射我们的安全配置，我们可以从我们的 `SecurityConfig.java` 文件中移除 `requestMatchers()`
    方法。
- en: You should now be able to start the application and test to ensure that our
    URLs are secure, as they should be. Our users will not notice a difference, but
    we know that our URL mappings are persisted in a database now.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能够启动应用程序并测试以确保我们的 URL 是安全的，就像它们应该的那样。我们的用户不会注意到任何区别，但我们知道我们的 URL 映射现在保存在数据库中了。
- en: Important note
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: 'Your code should now look like this: `calendar13.01-calendar`.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码现在应该看起来像这样：`calendar13.01-calendar`。
- en: Creating a custom expression
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义表达式
- en: The `o.s.s.access.expression.SecurityExpresssionHandler` interface is how `Spring
    Security` abstracts how the Spring expressions are created and initialized. Just
    as with the `SecurityMetadataSource` interface, there is an implementation for
    creating expressions for web requests and creating expressions for securing methods.
    In this section, we will explore how we can easily add new expressions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`o.s.s.access.expression.SecurityExpresssionHandler` 接口是 `Spring Security`
    抽象创建和初始化 Spring 表达式的方式。就像 `SecurityMetadataSource` 接口一样，有一个用于创建 Web 请求表达式的实现，以及一个用于创建方法安全表达式的实现。在本节中，我们将探讨如何轻松地添加新的表达式。'
- en: Configuring a custom SecurityExpressionRoot
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置自定义的 SecurityExpressionRoot
- en: Let’s assume that we want to support a custom `Web Expression` named `isLocal`
    that will return `true` if the host is `localhost` and `false` otherwise. This
    new method could be used to provide additional security for our SQL console by
    ensuring that it is only accessed from the same machine that the web application
    is deployed from.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要支持一个名为 `isLocal` 的自定义 `Web Expression`，当主机是 `localhost` 时返回 `true`，否则返回
    `false`。这个新方法可以用来为我们的 SQL 控制台提供额外的安全保护，确保它只从部署 Web 应用程序的同台机器访问。
- en: This is an artificial example that does not add any security benefits since
    the host comes from the headers of the HTTP request. This means a malicious user
    could inject a header stating that the host is `localhost` even if they are requesting
    to an external domain.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个没有增加任何安全效益的人工示例，因为主机来自 HTTP 请求的头部。这意味着恶意用户可以注入一个头部，声称主机是 `localhost`，即使他们请求的是外部域名。
- en: All of the expressions that we have seen are available because the `SecurityExpressionHandler`
    interface makes them available via an instance of `o.s.s.access.expression.SecurityExpressionRoot`.
    If you open this object, you will find the methods and properties we use in Spring
    expressions (that is, `hasRole`, `hasPermission`, and so on), which are common
    in both web and method security. A subclass provides the methods that are specific
    to the web and method expressions. For example, `o.s.s.web.access.expression.WebSecurityExpressionRoot`
    provides the `hasIpAddress` method for web requests.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所看到的所有表达式都因为 `SecurityExpressionHandler` 接口通过一个 `o.s.s.access.expression.SecurityExpressionRoot`
    的实例使它们可用。如果你打开这个对象，你会找到我们在 Spring 表达式中使用的那些方法和属性（即 `hasRole`、`hasPermission` 等），它们在
    Web 和方法安全中都很常见。一个子类提供了特定于 Web 和方法表达式的那些方法。例如，`o.s.s.web.access.expression.WebSecurityExpressionRoot`
    为 Web 请求提供了 `hasIpAddress` 方法。
- en: 'To create a custom web `SecurityExpressionhandler`, we will first need to create
    a subclass of `WebSecurityExpressionRoot` that defines our `isLocal` method, as
    follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个自定义的 Web `SecurityExpressionhandler`，我们首先需要创建一个 `WebSecurityExpressionRoot`
    的子类，定义我们的 `isLocal` 方法，如下所示：
- en: '[PRE9]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Important note
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: It is important to note that `getServerName()` returns the value that is provided
    in the `Host` header value. This means that a malicious user can inject a different
    value into the header to bypass constraints. However, most application servers
    and proxies can enforce the value of the `Host` header. Please read the appropriate
    documentation before leveraging such an approach to ensure that malicious users
    do not inject a `Host` header value to bypass such a constraint.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，`getServerName()`返回的是`Host`头中提供的值。这意味着恶意用户可以将不同的值注入到头中，以绕过约束。然而，大多数应用程序服务器和代理可以强制执行`Host`头的值。在利用这种方法之前，请阅读适当的文档，以确保恶意用户不会注入`Host`头值以绕过此类约束。
- en: Configuring a custom SecurityExpressionHandler
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置和使用CustomWebSecurityExpressionHandler
- en: 'In order for our new method to become available, we need to create a custom
    `SecurityExpressionHandler` interface that utilizes our new root object. This
    is as simple as extending `WebSecurityExpressionHandler`, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的新方法可用，我们需要创建一个自定义的`SecurityExpressionHandler`接口，该接口利用我们的新根对象。这就像扩展`WebSecurityExpressionHandler`一样简单，如下所示：
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We perform the same steps that the superclass does, except that we use `CustomWebSecurityExpressionRoot`,
    which contains the new method.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行与超类相同的步骤，只是我们使用包含新方法的`CustomWebSecurityExpressionRoot`。
- en: The `CustomWebSecurityExpressionRoot` becomes the root of our SpEL expression.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomWebSecurityExpressionRoot`成为我们SpEL表达式的根。'
- en: Important note
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'For further details, refer to the SpEL documentation within the Spring Reference
    documentation: [https://docs.spring.io/spring-framework/reference/core/expressions.xhtml](https://docs.spring.io/spring-framework/reference/core/expressions.xhtml).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更多详细信息，请参阅Spring参考文档中的SpEL文档：[https://docs.spring.io/spring-framework/reference/core/expressions.xhtml](https://docs.spring.io/spring-framework/reference/core/expressions.xhtml)。
- en: Configuring and using CustomWebSecurityExpressionHandler
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置和使用自定义SecurityExpressionHandler
- en: 'We now need to configure `CustomWebSecurityExpressionHandler`. Fortunately,
    this can be done easily using the `Spring Security` namespace configuration support.
    Add the following configuration to the `SecurityConfig.java` file:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要配置`CustomWebSecurityExpressionHandler`。幸运的是，这可以通过使用`Spring Security`命名空间配置支持轻松完成。将以下配置添加到`SecurityConfig.java`文件中：
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, let’s update our initialization SQL query to use the new expression. Update
    the `data.sql` file so that it requires the user to be `ROLE_ADMIN` and requested
    from the local machine. You will notice that we are able to write local instead
    of `isLocal`, since SpEL supports Java Bean conventions:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更新我们的初始化SQL查询以使用新的表达式。更新`data.sql`文件，使其要求用户必须是`ROLE_ADMIN`，并且请求来自本地机器。您会注意到，我们可以写`local`而不是`isLocal`，因为SpEL支持Java
    Bean约定：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Restart the application and access the H2 console using `localhost:8080/admin/h2`
    and `admin1@example.com/admin1` to see the admin console.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动应用程序，并使用`localhost:8080/admin/h2`和`admin1@example.com/admin1`访问H2控制台，以查看管理控制台。
- en: If the H2 console is accessed using `127.0.0.1:8080/admin/h2` and `admin1@example.com/admin1`,
    the **Access Denied** page will be displayed.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`127.0.0.1:8080/admin/h2`和`admin1@example.com/admin1`访问H2控制台，将显示**访问被拒绝**页面。
- en: Important note
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Your code should now look like this: `calendar13.02-calendar`.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应该看起来像这样：`calendar13.02-calendar`。
- en: Alternative to a CustomWebSecurityExpressionHandler
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`CustomWebSecurityExpressionHandler`的替代方案'
- en: Following an examination of the `CustomWebSecurityExpressionHandler` usage,
    we will investigate alternative approaches by employing a custom `PermissionEvaluator`
    to enhance the security of our `CalendarService`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查`CustomWebSecurityExpressionHandler`的使用后，我们将通过使用自定义`PermissionEvaluator`来增强`CalendarService`的安全性，来研究替代方法。
- en: How does method security work?
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法安全性是如何工作的？
- en: The access decision mechanism for method security—whether or not a given request
    is allowed—is conceptually the same as the access decision logic for web request
    access. `AccessDecisionManager` polls a set of `AccessDecisionVoter` instances,
    each of which can provide a decision to grant or deny access or abstain from voting.
    The specific implementation of `AccessDecisionManager` aggregates the voter decisions
    and arrives at an overall decision to allow for the method invocation.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 方法安全性的访问决策机制——是否允许给定的请求——在概念上与网络请求访问的访问决策逻辑相同。`AccessDecisionManager`轮询一组`AccessDecisionVoter`实例，每个实例都可以提供一个决定授予或拒绝访问或弃权。`AccessDecisionManager`的具体实现聚合投票者的决策，并得出一个允许方法调用的总体决策。
- en: Web request access decision-making is less complicated, due to the fact that
    the availability of servlet filters makes the interception (and summary rejection)
    of securable requests relatively straightforward. As method invocation can happen
    from anywhere, including areas of code that are not directly configured by `Spring
    Security`, the `Spring Security` designers chose to use a Spring-managed **Aspect-****O****riented
    Programming** (**AOP**) approach to recognize, evaluate, and secure method invocations.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于servlet过滤器使得可安全请求的拦截（和拒绝）相对简单，因此Web请求访问决策较为简单。由于方法调用可能发生在任何地方，包括不是由`Spring
    Security`直接配置的代码区域，`Spring Security`的设计者选择使用Spring管理的**面向切面编程（Aspect-Oriented
    Programming**，**AOP**）方法来识别、评估和确保方法调用。
- en: 'The following high-level flow illustrates the main players involved in authorization
    decisions for method invocation:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的高级流程图说明了在方法调用授权决策中涉及的主要参与者：
- en: '![Figure 13.4 – Main classes involved in authorization decisions for method
    invocation](img/B21757_13_4.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图13.4 – 方法调用授权决策中涉及的主要类](img/B21757_13_4.jpg)'
- en: Figure 13.4 – Main classes involved in authorization decisions for method invocation
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4 – 方法调用授权决策中涉及的主要类
- en: We can see that `Spring Security`’s `o.s.s.access.intercept.aopalliance.MethodSecurityInterceptor`
    is invoked by the standard Spring AOP runtime to intercept method calls of interest.
    From here, the logic of whether or not to allow a method call is relatively straightforward,
    as per the previous flow diagram.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`Spring Security` 的 `o.s.s.access.intercept.aopalliance.MethodSecurityInterceptor`
    是由标准的Spring AOP运行时调用来拦截感兴趣的方法调用的。从这里，是否允许方法调用的逻辑相对简单，如前所述的流程图。
- en: At this point, we might wonder about the performance of the method security
    feature. Obviously, `MethodSecurityInterceptor` can’t be invoked for every method
    call in the application—so how do annotations on methods or classes result in
    AOP interception?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可能会对方法安全特性的性能产生疑问。显然，`MethodSecurityInterceptor` 不能对应用中的每个方法调用进行调用——那么方法或类上的注解是如何导致AOP拦截的呢？
- en: First of all, AOP proxying isn’t invoked for all Spring-managed beans by default.
    Instead, if `@EnableMethodSecurity` is defined in the `Spring Security` configuration,
    a standard Spring AOP `o.s.beans.factory.config.BeanPostProcessor` will be registered
    that will introspect the AOP configuration to see whether any AOP advisors indicate
    that proxying (and the interception) is required. This workflow is standard Spring
    AOP handling (known as `Spring Security`. All registered `BeanPostProcessor` instances
    run upon initialization of the Spring `ApplicationContext`; after all, Spring
    bean configurations have occurred.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，默认情况下，AOP代理不会对所有Spring管理的bean进行调用。相反，如果在`Spring Security`配置中定义了`@EnableMethodSecurity`，则会注册一个标准的Spring
    AOP `o.s.beans.factory.config.BeanPostProcessor`，该处理器将检查AOP配置以查看是否有任何AOP顾问指示需要进行代理（和拦截）。这个工作流程是标准的Spring
    AOP处理（称为`Spring Security`。所有注册的`BeanPostProcessor`实例都在Spring `ApplicationContext`初始化时运行；毕竟，Spring的bean配置已经发生。
- en: The AOP auto-proxy functionality queries all registered `PointcutAdvisor` instances,
    to see if there are AOP pointcuts that resolve method invocations that should
    have AOP advice applied. `Spring Security` implements the `o.s.s.access.intercept.aopalliance.MethodSecurityMetadataSourceAdvisor`
    class, which examines any and all configured method security annotations and sets
    up appropriate AOP interception. Take note that only interfaces or classes with
    declared method security annotations will be proxied for AOP!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: AOP自动代理功能查询所有注册的`PointcutAdvisor`实例，以查看是否有AOP切入点可以解析应该应用AOP建议的方法调用。`Spring Security`实现了`o.s.s.access.intercept.aopalliance.MethodSecurityMetadataSourceAdvisor`类，该类检查所有配置的方法安全注解并设置适当的AOP拦截。请注意，只有声明了方法安全注解的接口或类才会被代理以进行AOP！
- en: Important note
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: Be aware that it is strongly encouraged to declare AOP rules (and other security
    annotations) on interfaces, and not on implementation classes. The use of classes,
    while available using CGLIB proxying with Spring, may unexpectedly change the
    behavior of your application, and is generally less semantically correct than
    security declarations (through AOP) on interfaces. `MethodSecurityMetadataSourceAdvisor`
    delegates the decision to affect methods with the AOP advice to an `o.s.s.access.method.MethodSecurityMetadataSource`
    instance. The different forms of method security annotation each have their own
    `MethodSecurityMetadataSource` implementation, which is used to introspect each
    method, class in turn, and add AOP advice to be executed at runtime.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，强烈建议在接口上声明AOP规则（和其他安全注解），而不是在实现类上。虽然可以使用Spring的CGLIB代理来使用类，但这可能会意外地改变应用程序的行为，并且通常不如在接口上通过AOP进行的安全声明（通过AOP）语义正确。`MethodSecurityMetadataSourceAdvisor`将影响方法的AOP建议决策委托给一个`o.s.s.access.method.MethodSecurityMetadataSource`实例。方法安全注解的不同形式各自有自己的`MethodSecurityMetadataSource`实现，它用于依次检查每个方法、类，并在运行时添加要执行的AOP建议。
- en: 'The following diagram illustrates how this process occurs:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示说明了这个过程是如何发生的：
- en: '![Figure 13.5 – AOP interceptors for method security](img/B21757_13_5.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图13.5 – 方法安全AOP拦截器](img/B21757_13_5.jpg)'
- en: Figure 13.5 – AOP interceptors for method security
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5 – 方法安全AOP拦截器
- en: Depending on the number of Spring beans configured in your application and the
    number of secured method annotations you have, adding method security proxying
    may increase the time required to initialize your `ApplicationContext`. Once your
    Spring context is initialized, however, there is a negligible performance impact
    on individual proxied beans.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您应用程序中配置的Spring bean数量和受保护方法注解的数量，添加方法安全代理可能会增加初始化`ApplicationContext`所需的时间。然而，一旦Spring上下文初始化完成，对单个代理bean的性能影响可以忽略不计。
- en: Now that we have an understanding of how we can use AOP to apply `Spring Security`,
    let’s strengthen our grasp of `Spring Security` authorization by creating a custom
    `PermissionEvaluator`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何使用AOP来应用`Spring Security`，让我们通过创建一个自定义的`PermissionEvaluator`来加强我们对`Spring
    Security`授权的理解。
- en: Creating a custom PermissionEvaluator
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建自定义PermissionEvaluator
- en: In the previous chapter, we demonstrated that we could use `Spring Security`’s
    built-in `PermissionEvaluator` implementation, `AclPermissionEvaluator`, to restrict
    access to our application. While powerful, this can often be more complicated
    than necessary. We have also discovered how `SpEL` can formulate complex expressions
    that are able to secure our application. While simple, one of the downsides of
    using complex expressions is that the logic is not centralized. Fortunately, we
    can easily create a custom `PermissionEvaluator` that is able to centralize our
    authorization logic and still avoid the complexity of using ACLs.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们展示了我们可以使用`Spring Security`的内置`PermissionEvaluator`实现，即`AclPermissionEvaluator`，来限制对我们的应用程序的访问。虽然功能强大，但这通常比必要的复杂。我们还发现了`SpEL`如何制定复杂的表达式，这些表达式能够保护我们的应用程序。虽然简单，但使用复杂表达式的缺点之一是逻辑没有集中化。幸运的是，我们可以轻松地创建一个自定义的`PermissionEvaluator`，它能够集中我们的授权逻辑，同时避免使用ACLs的复杂性。
- en: The CalendarPermissionEvaluator Class
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`CalendarPermissionEvaluator`类'
- en: 'A simplified version of our custom `PermissionEvaluator` that does not contain
    any validation can be seen as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示的是我们自定义的`PermissionEvaluator`的简化版本，它不包含任何验证：
- en: '[PRE13]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The logic is fairly similar to the Spring expressions that we have already used,
    except that it differentiates read and write access. If the current user’s username
    matches the owner’s email of the `Event` object, then both read and write access
    is granted. If the current user’s email matches the attendee’s email, then read
    access is granted. Otherwise, access is denied.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑与我们已经使用的Spring表达式相当相似，只是它区分了读和写访问。如果当前用户的用户名与`Event`对象的拥有者的电子邮件匹配，则授予读和写访问权限。如果当前用户的电子邮件与与会者的电子邮件匹配，则授予读访问权限。否则，拒绝访问。
- en: Important note
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It should be noted that a single `PermissionEvaluator` is used for every domain
    object. So, in a real-world situation, we must perform `instanceof` checks first.
    For example, if we were also securing our `CalendarUser` objects, these could
    be passed into this same instance. For a full example of these minor changes,
    refer to the sample code included in the book.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 应当注意，每个域对象都使用单个 `PermissionEvaluator`。因此，在实际情况下，我们首先必须执行 `instanceof` 检查。例如，如果我们还正在保护我们的
    `CalendarUser` 对象，这些对象可以传递到这个相同的实例中。有关这些细微变化的完整示例，请参阅书中包含的示例代码。
- en: Configuring CalendarPermissionEvaluator
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 CalendarPermissionEvaluator
- en: 'We can then leverage the `CustomAuthorizationConfig.java` configuration that
    is provided with this chapter to provide an `ExpressionHandler` that uses our
    `CalendarPermissionEvaluator`, like so:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以利用本章提供的 `CustomAuthorizationConfig.java` 配置来提供一个使用我们的 `CalendarPermissionEvaluator`
    的 `ExpressionHandler`，如下所示：
- en: '[PRE14]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The configuration should look similar to the configuration from [*Chapter 12*](B21757_12.xhtml#_idTextAnchor375),
    *Access Control Lists*, except that we now use our `CalendarPermissionEvalulator`
    class instead of `AclPermissionEvaluator`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 配置应类似于 [*第 12 章*](B21757_12.xhtml#_idTextAnchor375) *访问控制列表* 中的配置，但我们现在使用我们的
    `CalendarPermissionEvalulator` 类而不是 `AclPermissionEvaluator`。
- en: Securing our CalendarService
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保护我们的 CalendarService
- en: 'Lastly, we can secure our `CalendarService getEvent(int eventId)` method with
    a `@PostAuthorize` annotation. You will notice that this step is exactly the same
    as what we did in [*Chapter 1*](B21757_01.xhtml#_idTextAnchor015), *Anatomy of
    an Unsafe Application*, and we have only changed the implementation of `PermissionEvaluator`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用 `@PostAuthorize` 注解保护我们的 `CalendarService getEvent(int eventId)` 方法。您将注意到这一步与我们之前在
    [*第 1 章*](B21757_01.xhtml#_idTextAnchor015) *不安全应用程序的解剖结构* 中所做的完全相同，我们只是更改了 `PermissionEvaluator`
    的实现：
- en: '[PRE15]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you have not done so already, restart the application, log in with the username/password
    `admin1@example.com/admin1`, and visit the `events/101`) using the link on the
    **Welcome** page. The **Access Denied** page will be displayed.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请重新启动应用程序，使用用户名/密码 `admin1@example.com/admin1` 登录，并使用 **欢迎** 页面上的链接访问
    `events/101`。将显示 **访问被拒绝** 页面。
- en: Important note
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Your code should now look like this: `calendar13.03-calendar`.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应该看起来像这样：`calendar13.03-calendar`。
- en: However, we would like `ROLE_ADMIN` users to be able to access all events.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们希望 `ROLE_ADMIN` 用户能够访问所有事件。
- en: Benefits of a custom PermissionEvaluator
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义 PermissionEvaluator 的好处
- en: 'With only a single method being protected, it would be trivial to update the
    annotation to check whether the user has the role of `ROLE_ADMIN` or has permission.
    However, if we had protected all of our service methods that use an event, it
    would have become quite cumbersome. Instead, we could just update our `CalendarPermissionEvaluator`.
    Make the following changes:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个方法受到保护，更新注解以检查用户是否具有 `ROLE_ADMIN` 角色或具有权限将非常简单。然而，如果我们已经保护了所有使用事件的业务方法，这会变得相当繁琐。相反，我们只需更新我们的
    `CalendarPermissionEvaluator`。进行以下更改：
- en: '[PRE16]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, restart the application and repeat the previous exercise. This time, the
    **Conference Call Event** will display successfully.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新启动应用程序并重复之前的练习。这次，**会议通话事件**将成功显示。
- en: You can see that the ability to encapsulate our authorization logic can be extremely
    beneficial. However, sometimes, it may be useful to extend the expressions themselves.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，封装我们的授权逻辑的能力可以非常有益。然而，有时，扩展表达式本身可能是有用的。
- en: Important note
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Your code should now look like this: `calendar13.04-calendar`.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应该看起来像这样：`calendar13.04-calendar`。
- en: Removing the CustomWebSecurityExpressionHandler class
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除 CustomWebSecurityExpressionHandler 类
- en: There is a much simpler way of defining custom **Web Expressions**.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 定义自定义 **Web 表达式** 有一种更简单的方法。
- en: 'In our previous example, you can remove the following classes: `CustomWebSecurity`
    **ExpressionHandler** and `CustomWebSecurityExpressionRoot`.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的示例中，您可以删除以下类：`CustomWebSecurity` **ExpressionHandler** 和 `CustomWebSecurityExpressionRoot`。
- en: 'Declare a Spring bean containing the custom `Web Expression`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个包含自定义 `Web 表达式` 的 Spring bean：
- en: '[PRE17]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the `CustomAuthorizationConfig` class, add the following bean:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `CustomAuthorizationConfig` 类中，添加以下 bean：
- en: '[PRE18]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can then remove the following declaration to the `CustomWebSecurityExpressionHandler`
    inside the `SecurityConfig` class:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以删除以下声明到 `SecurityConfig` 类中的 `CustomWebSecurityExpressionHandler`：
- en: '[PRE19]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, let’s update our initialization SQL query to adapt the syntax of the new
    expression. Update the `data.sql` as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更新我们的初始化SQL查询以适应新表达式的语法。更新`data.sql`如下：
- en: '[PRE20]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Restart the application and test the application access with the user `admin1@example.com/admin1`
    for both URLs:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动应用程序，并使用用户`admin1@example.com/admin1`测试两个URL的应用程序访问：
- en: '`http://127.0.0.1:8080/admin/h2`: Access should be `denied`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://127.0.0.1:8080/admin/h2`：访问应该被`拒绝`'
- en: '`http://localhost:8080/admin/h2`: Access should be `allowed`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/admin/h2`：访问应该被`允许`'
- en: Important note
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Your code should now look like this: `calendar13.05-calendar`.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应该看起来像这样：`calendar13.05-calendar`。
- en: Declaring a custom AuthorizationManager
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明自定义的AuthorizationManager
- en: '`Spring Security 6` has deprecated the usage of the `AccessDecissionManager`
    and `AccessDecisionVoter`.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spring Security 6`已弃用`AccessDecissionManager`和`AccessDecisionVoter`的使用。'
- en: The recommended approach is to implement a custom `AuthorizationManager`, as
    explained in the introduction of this chapter. To achieve this goal, you can follow
    the next steps.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 建议的方法是实现一个自定义的`AuthorizationManager`，正如本章引言中所述。为了实现这一目标，您可以遵循以下步骤。
- en: 'First, we will create a custom implementation of the `AuthorizationManager`
    that checks for the allowed permissions based on the `security_filter_metadata`
    table definition:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个自定义的`AuthorizationManager`实现，该实现根据`security_filter_metadata`表的定义检查允许的权限：
- en: '[PRE21]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, we will inject the `AuthorizationManager` into the `SecurityFilterChain`
    bean, as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将按照以下方式将`AuthorizationManager`注入到`SecurityFilterChain`bean中：
- en: '[PRE22]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will update the `CustomAuthorizationConfig` configuration by replacing the
    bean of type `DefaultWebSecurityExpressionHandler` with another one of type `DefaultHttpSecurityExpressionHandler`,
    as we have chosen to use `http.authorizeHttpRequest()` instead of `http.authorizeRequests()`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过用`DefaultHttpSecurityExpressionHandler`类型的bean替换`DefaultWebSecurityExpressionHandler`类型的bean来更新`CustomAuthorizationConfig`配置，因为我们选择了使用`http.authorizeHttpRequest()`而不是`http.authorizeRequests()`：
- en: '[PRE23]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can remove the `FilterInvocationServiceSecurityMetadataSource` and restart
    your application. You should have the same results as the previous example.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以删除`FilterInvocationServiceSecurityMetadataSource`并重新启动应用程序。您应该得到与上一个示例相同的结果。
- en: Important note
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Your code should now look like this: `calendar13.06-calendar`.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应该看起来像这样：`calendar13.06-calendar`。
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: After reading this chapter, you should have a firm understanding of how `Spring
    Security` authorization works for HTTP requests and methods. With this knowledge,
    and the provided concrete examples, you should also know how to extend authorization
    to meet your needs. Specifically, in this chapter, we covered the `Spring Security`
    authorization architecture for both HTTP requests and methods. We also demonstrated
    how to configure secured URLs from a database.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章后，您应该对`Spring Security`如何为HTTP请求和方法进行授权有一个牢固的理解。有了这些知识和提供的具体示例，您还应该知道如何扩展授权以满足您的需求。具体来说，在本章中，我们涵盖了HTTP请求和方法的`Spring
    Security`授权架构。我们还演示了如何从数据库配置受保护的URL。
- en: We also saw how to create a custom `AuthorizationManager`, `PermissionEvaluator`
    object, and custom `Spring` `Security` expression.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了如何创建自定义的`AuthorizationManager`、`PermissionEvaluator`对象和自定义的`Spring` `Security`表达式。
- en: In the next chapter, we will explore how `Spring Security` performs session
    management. We will also gain an understanding of how it can be used to restrict
    access to our application.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨`Spring Security`如何执行会话管理。我们还将了解如何使用它来限制对应用程序的访问。
- en: 'Part 5: Advanced Security Features and Deployment Optimization'
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5部分：高级安全功能和部署优化
- en: This part commences with an explanation of session fixation attacks and Spring
    Security’s defense mechanisms against them. It proceeds to explore methods for
    managing logged-in users and limiting the number of concurrent sessions per user.
    The association of a user to `HttpSession` by Spring Security and techniques for
    customizing this behavior are also detailed.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分首先解释了会话固定攻击以及Spring Security针对它们的防御机制。然后，它探讨了管理已登录用户和限制每个用户并发会话数量的方法。Spring
    Security将用户与`HttpSession`关联以及自定义此行为的技术也被详细说明。
- en: Then, we delve into common security vulnerabilities such as **Cross-Site Scripting**
    (**XSS**), **Cross-Site Request Forgery** (**CSRF**), synchronizer tokens, and
    clickjacking, along with strategies to mitigate these risks effectively.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将深入研究常见的网络安全漏洞，如**跨站脚本攻击**（**XSS**）、**跨站请求伪造**（**CSRF**）、同步令牌和点击劫持，以及有效缓解这些风险的战略。
- en: Following this, we present a migration path to Spring Security 6, highlighting
    notable configuration changes, class and package migrations, and significant new
    features, including support for Java 17 and enhanced authentication mechanisms
    with OAuth 2.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们展示了迁移到Spring Security 6的路径，突出了显著的配置更改、类和包迁移以及重要的新功能，包括对Java 17的支持以及使用OAuth
    2增强的认证机制。
- en: Subsequently, we explore microservices-based architectures and examine the role
    of OAuth 2 with **JSON Web Tokens** (**JWTs**) in securing microservices within
    a Spring-based application. Additionally, we discuss the implementation of **Single
    Sign-On** (**SSO**) using the **Central Authentication** **Service** (**CAS**).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，我们探讨基于微服务的架构，并检查OAuth 2与**JSON Web令牌**（JWTs）在Spring应用程序中保护微服务的作用。此外，我们讨论了使用**中央认证服务**（CAS）实现**单点登录**（SSO）的实施。
- en: Concluding this part, we delve into the process of building native images using
    GraalVM, offering insights into enhancing performance and security within Spring
    Security applications.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分的结尾，我们深入探讨了使用GraalVM构建本地图像的过程，提供了在Spring Security应用程序中提高性能和安全的见解。
- en: 'This part has the following chapters:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 14*](B21757_14.xhtml#_idTextAnchor445), *Session Management*'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B21757_14.xhtml#_idTextAnchor445), *会话管理*'
- en: '[*Chapter 15*](B21757_15.xhtml#_idTextAnchor479), *Additional Spring Security
    Features*'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第15章*](B21757_15.xhtml#_idTextAnchor479), *额外的Spring Security功能*'
- en: '[*Chapter 16*](B21757_16.xhtml#_idTextAnchor512), *Migration to Spring Security
    6*'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第16章*](B21757_16.xhtml#_idTextAnchor512), *迁移到Spring Security 6*'
- en: '[*Chapter 17*](B21757_17.xhtml#_idTextAnchor537), *Microservice Security with
    OAuth 2 and JSON Web Tokens*'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第17章*](B21757_17.xhtml#_idTextAnchor537), *使用OAuth 2和JSON Web令牌的微服务安全*'
- en: '[*Chapter 18*](B21757_18.xhtml#_idTextAnchor591), *Single Sign-On with the
    Central Authentication Service*'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第18章*](B21757_18.xhtml#_idTextAnchor591), *使用中央认证服务进行单点登录*'
- en: '[*Chapter 19*](B21757_19.xhtml#_idTextAnchor625), *Build GraalVM Native Images*'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第19章*](B21757_19.xhtml#_idTextAnchor625), *构建GraalVM本地图像*'
