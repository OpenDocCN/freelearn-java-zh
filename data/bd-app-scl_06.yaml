- en: Chapter 6.  Persistence with Slick
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 使用Slick的持续改进
- en: In the previous chapters, you learned to bootstrap your application using Activator,
    we developed our web application using Scala and Play framework, and we added
    Reactive microservices calls using RxScala for data flow computations. We performed
    unit tests and controller testing using the BDD and Play frameworks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了如何使用Activator启动你的应用程序，我们使用Scala和Play框架开发了我们的Web应用程序，并使用RxScala添加了响应式微服务调用以进行数据流计算。我们使用BDD和Play框架进行了单元测试和控制器测试。
- en: In this chapter, you will learn how to achieve relational database persistence.
    So far, we have our application up and running. However, we are using in-memory
    persistence with HashMap. Now we will upgrade our application to use proper persistence.
    In order to achieve this, we will use a reactive database persistence framework
    called Slick.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何实现关系型数据库持久化。到目前为止，我们的应用程序已经运行起来。然而，我们正在使用HashMap进行内存持久化。现在我们将升级我们的应用程序以使用适当的持久化。为了实现这一点，我们将使用一个名为Slick的响应式数据库持久化框架。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Principles of database persistence with Slick
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Slick进行数据库持久化的原则
- en: Working with Functional Relational Mapping in our application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的应用程序中处理功能关系映射
- en: Creating Queries with SQL support
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SQL支持创建查询
- en: Improving code with Async database operations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异步数据库操作改进代码
- en: We will do some refactoring in our application. Step-by-step, we will create
    all the tables and persistence classes that we need to have Slick working with
    our Play framework application. Tests will be refactored as well in order to test
    the application logic, and skip the database persistence part.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的应用程序中进行一些重构。逐步地，我们将创建所有必要的表和持久化类，以便Slick能够与我们的Play框架应用程序一起工作。测试也将进行重构，以便测试应用程序逻辑，并跳过数据库持久化部分。
- en: Introducing the Slick framework
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Slick框架
- en: '**Scala Language Integrated Connection Kit** (**Slick**) is a Scala modern
    framework, which allows working with data using abstractions that are very similar
    to Scala collections. You can write database queries in both SQL and Scala code.
    Writing Scala code instead of SQL is better, because we leverage the compiler,
    and hence, this approach is less error-prone. Also, it becomes easier to maintain
    the code, since the compiler will help you by pointing out where the code breaks,
    if it happens.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**Scala语言集成连接套件**（**Slick**）是一个Scala现代框架，它允许使用与Scala集合非常相似的抽象来处理数据。你可以使用SQL和Scala代码编写数据库查询。用Scala代码代替SQL更好，因为我们利用了编译器，因此这种方法更不容易出错。此外，代码的维护也变得更简单，因为编译器会帮助你指出代码出错的地方，如果发生这种情况。'
- en: Slick is a **Functional Relational Mapping** (**FRM**) library. Those of you
    who come from a Java background, and are familiar with **Object Relational Mapping**
    (**ORM**) frameworks such as Hibernate, will see that Slick has similar concepts.
    Basically, you create a Scala class, which will explicitly map to a relational
    table. Slick FRM ideas are inspired by Microsoft's LINQ framework.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Slick是一个**功能关系映射**（**FRM**）库。那些来自Java背景并且熟悉Hibernate等**对象关系映射**（**ORM**）框架的人会发现Slick有类似的概念。基本上，你创建一个Scala类，该类将明确映射到一个关系型表。Slick
    FRM理念受到了微软的LINQ框架的启发。
- en: 'Slick is reactive by design, and works in an asynchronous non-blocking IO model.
    Using Slick you have the following advantages:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Slick在设计上就是反应式的，并且使用异步非阻塞I/O模型工作。使用Slick，你将拥有以下优势：
- en: '**Resilience**: A common issue is that a heavy load on the DB and application
    creates more threads, and makes the situation worse. Slick can fix this problem,
    because it queues database operations in the DB.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：一个常见问题是数据库和应用程序的负载过重会创建更多的线程，从而使情况变得更糟。Slick可以解决这个问题，因为它在数据库中排队等待数据库操作。'
- en: '**Efficient Resources utilization**: Slick can be tuned for parallelism in
    terms of the number of active jobs and suspended database sessions. Slick also
    has a clean demarcation between I/O and CPU-intensive code.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高效资源利用**：Slick可以根据活动作业和挂起的数据库会话的数量进行并行调整。Slick还有清晰的I/O和CPU密集型代码之间的界限。'
- en: MySQL setup
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MySQL设置
- en: 'We will use Slick with MySQL 5.6\. However, Slick supports other relational
    databases like Oracle, SQL Server, DB2, and Postgres. First of all, we need to
    install MySQL in our machine. Open the console, and perform the following steps
    (for Ubuntu Linux, other OS (Windows/Mac), and distros, check out [http://dev.mysql.com/downloads/mysql/](http://dev.mysql.com/downloads/mysql/)):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Slick和MySQL 5.6。然而，Slick支持其他关系型数据库，如Oracle、SQL Server、DB2和Postgres。首先，我们需要在我们的机器上安装MySQL。打开控制台，执行以下步骤（对于Ubuntu
    Linux、其他操作系统（Windows/Mac）和发行版，请参阅[http://dev.mysql.com/downloads/mysql/](http://dev.mysql.com/downloads/mysql/)）：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After installation with `apt-get`, when you run the other two commands, you
    should see an output like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`apt-get`安装后，当你运行其他两个命令时，你应该看到如下输出：
- en: '![MySQL setup](img/image00290.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![MySQL设置](img/image00290.jpeg)'
- en: MySQL Installation
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL安装
- en: Once the installation is done and the MySQL server is up and running, we can
    move on and create the database. In order to get this, we will need to open the
    MySQL console. For development reasons, I did not put a password for root. However,
    for production, it is strongly recommended that you do use a strong password.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，MySQL服务器启动并运行，我们可以继续创建数据库。为了实现这一点，我们需要打开MySQL控制台。出于开发目的，我没有为root用户设置密码。然而，对于生产环境，强烈建议您使用强密码。
- en: 'Execute the following command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will give output as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下输出：
- en: '![MySQL setup](img/image00291.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![MySQL设置](img/image00291.jpeg)'
- en: MySQL Console
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL控制台
- en: 'Once you enter the MySQL console, you can create the database. We will create
    a database named `RWS_DB` using the following command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入MySQL控制台，你就可以创建数据库。我们将使用以下命令创建一个名为`RWS_DB`的数据库：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You will see the following result:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下结果：
- en: '![MySQL setup](img/image00292.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![MySQL设置](img/image00292.jpeg)'
- en: You can type `$ SHOW DATABASES;` in order to get a list of all the available
    databases in MySQL. All set, we have our database up and running.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以输入`$ SHOW DATABASES;`来获取MySQL中所有可用数据库的列表。一切准备就绪，我们的数据库已经启动并运行。
- en: Configuring Slick in our Play framework app
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的Play框架应用程序中配置Slick
- en: First, we need to add dependencies to the `build.sbt` file. We will need to
    remove or comment a library called `JDBC` and add the `play-slick` libraries and
    MySQL java driver.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要向`build.sbt`文件中添加依赖项。我们需要移除或注释掉名为`JDBC`的库，并添加`play-slick`库和MySQL Java驱动。
- en: 'This is done as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以这样完成：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see in the preceding code, we comment out the `JDBC` library, and
    add three new dependencies:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们注释掉了`JDBC`库，并添加了三个新的依赖项：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can go to the console and run the commands `$ activator`, `$ reload`, and
    `$ compile` in order to get SBT to download all the new dependencies.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以进入控制台并运行命令`$ activator`、`$ reload`和`$ compile`，以便让SBT下载所有新的依赖项。
- en: Configure the database connection
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置数据库连接
- en: 'Slick needs to be configured to access the MySQL database that we created.
    Under the folder `ReactiveWebStore/conf`, we need to edit the `application.conf`
    file and add the database connection URL and settings as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Slick需要配置以访问我们创建的MySQL数据库。在`ReactiveWebStore/conf`文件夹下，我们需要编辑`application.conf`文件，并添加以下数据库连接URL和设置：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: FPM Mapping
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FPM映射
- en: The next step is to create FPM mapping between our Scala code and MySQL tables
    under `ReactiveWebStore/app`, we will create a new package called `dao`. DAO stands
    for **Database Access Object** (**DAO**), and is a well-known OO pattern. So we
    will create some DAO classes here. First we will define a base trait, which will
    define the behavior and code capability for each of our `dao` packages.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在`ReactiveWebStore/app`下的Scala代码和MySQL表之间创建FPM映射，我们将在`dao`下创建一个新的包。DAO代表**数据库访问对象**（**DAO**），这是一个众所周知的面向对象模式。因此，我们将在这里创建一些DAO类。首先，我们将定义一个基特质，它将为每个`dao`包定义行为和代码能力。
- en: 'We will start with `BaseDao.scala`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`BaseDao.scala`开始：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will have three `dao` packages: `ProductDao`, `ImageDao`, and `ReviewDao`.
    Each `dao` will be able to perform  an operation, but over a different MySQL table.
    According to the trait we just defined, we will be able to do the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将拥有三个`dao`包：`ProductDao`、`ImageDao`和`ReviewDao`。每个`dao`都将能够执行操作，但针对不同的MySQL表。根据我们刚刚定义的特质，我们将能够执行以下操作：
- en: '**findAll**: Find all data for a specific table'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查找所有**：查找特定表中的所有数据'
- en: '**remove**: Delete an item in a table by ID'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除**：通过ID删除表中的项'
- en: '**insert**: Add new data to a table'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入**：向表中添加新数据'
- en: '**update**: Update data in a table'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新**：更新表中的数据'
- en: '**findbyId**: Get a specific record in a table, filtered by ID'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过ID查找**：通过ID获取表中的特定记录'
- en: '**toTable**: Return the table FRM mapping for that `dao`.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**toTable**: 返回该 `dao` 的表 FRM 映射。'
- en: ProductDao
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ProductDao
- en: 'We will start with having a look at `ProductDao.scala`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从查看 `ProductDao.scala` 开始：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is the `dao` implementation for `Product`. We have lots of new concepts
    here, so let's take a look at each step, one at a time. As you can see, a trait
    called `IProductDao` which extends from `BaseDao` using generics to specify the
    model `Product`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Product` 的 `dao` 实现。这里有很多新的概念，所以让我们一步一步地看看每个步骤。正如你所看到的，有一个名为 `IProductDao`
    的特质，它通过泛型从 `BaseDao` 扩展，以指定模型 `Product`。
- en: 'This trait is important for dependency injection using Guice. We will have
    two `dao` implementations for each model: one implementation using Slick and MySQL,
    and the other using our previous `inMemory` database for testing purpose.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特质对于使用 Guice 进行依赖注入非常重要。对于每个模型，我们将有两个 `dao` 实现：一个使用 Slick 和 MySQL，另一个使用我们之前的
    `inMemory` 数据库进行测试。
- en: There is a class there called `ProductDao` which is the `dao` implementation
    using Slick. We need Guice to inject a class here, called `DatabaseConfigProvider`,
    which will be used to perform the database operations. `ProductDao` also needs
    to extend `HasDatabaseConfigProvider[JdbcProfile]` to work with the database.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 那里有一个名为 `ProductDao` 的类，它是使用 Slick 的 `dao` 实现。我们需要 Guice 注入一个类，称为 `DatabaseConfigProvider`，它将用于执行数据库操作。`ProductDao`
    还需要扩展 `HasDatabaseConfigProvider[JdbcProfile]` 以与数据库一起工作。
- en: 'We also need to import the `driver` api via the following command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要通过以下命令导入 `driver` api：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The next step is to create FRM mapping with a class called `ProductTable`, which
    extends table passing the model, which in our case is a product. You also need
    to announce the name of the MySQL table. In order to get the table name, we use
    a companion object, which we need to create around our models. We do it this way
    in order to avoid duplicating the MySQL table name everywhere.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用名为 `ProductTable` 的类创建 FRM 映射，它扩展了表，传递了模型，在我们的例子中是一个产品。你还需要宣布 MySQL 表的名称。为了获取表名，我们使用一个伴随对象，我们需要在我们的模型周围创建它。我们这样做是为了避免在所有地方重复
    MySQL 表名。
- en: In the `ProductTable` table, you can see some functions such as `id`, `name`,
    `price`, and `details`. These are the exact name of the fields of `model.Product`.
    However, we have to add the mapping to the MySQL table on the right side. We do
    it using a function called `column` where we pass the type and the exact MySQL
    field name.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ProductTable` 表中，你可以看到一些函数，如 `id`、`name`、`price` 和 `details`。这些都是 `model.Product`
    字段的准确名称。然而，我们必须在右侧添加到 MySQL 表的映射。我们使用一个名为 `column` 的函数来完成，我们传递类型和确切的 MySQL 字段名称。
- en: Finally, we need to run a special projection function called `*` to pass all
    the fields on the model, which are being mapped to the relational database.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要运行一个特殊的投影函数 `*` 来传递模型上的所有字段，这些字段被映射到关系数据库中。
- en: Now we can move to the `dao` operations. As you can see, all the functions use
    `db.run` to perform data access. This is great because, as you can realize, they
    return a Future so the `dao` won't be blocking, and you can do something else,
    for instance, more database operations, pre-optimizations, and validations.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以转向 `dao` 操作。正如你所看到的，所有函数都使用 `db.run` 来执行数据访问。这很好，因为，正如你所意识到的，它们返回一个 Future，所以
    `dao` 不会阻塞，你可以做其他事情，例如，更多的数据库操作，预优化和验证。
- en: 'Once we have a `ProductTable` table, we can create a Slick `TableQuery` with
    it to perform database operations as if they are Scala functions. In order to
    list all the available products, we just use this command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了 `ProductTable` 表，我们可以使用它创建一个 Slick `TableQuery` 来执行数据库操作，就像它们是 Scala
    函数一样。为了列出所有可用的产品，我们只需使用这个命令：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It is as simple as that. This code will return a `Future [Seq[Products]]`.
    We can also filter by ID using this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么简单。这段代码将返回一个 `Future [Seq[Products]]`。我们也可以通过 ID 进行过滤：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So, `first _.id` is the `id` on the database, and `id` is the one that comes
    by parameter. After getting the result, you can see that we called another function
    called `headOption`, which makes sure that we get the result as an option. This
    is a great pattern to rely on, since the data might not be there on the table,
    and we avoid getting `NoSuchElementException`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`first _.id` 是数据库中的 `id`，而 `id` 是通过参数传入的。在获取结果后，你可以看到我们调用了另一个名为 `headOption`
    的函数，确保我们得到的结果是一个选项。这是一个值得信赖的模式，因为数据可能不在表中，我们避免了得到 `NoSuchElementException`。
- en: 'Removing a product is fairly trivial as well. We just use the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 移除产品也是相当简单的。我们只需使用以下方法：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This preceding code returns `Future[Int]`, counting the number of items that
    were deleted. If the record ID is not found in the database, the result will be
    `0`. We expect it to be always `1`, since we are going to delete by ID. However,
    the API is generic, and if, let's say, you delete by name or another field, you
    might have multiple deletes. That's why it is an `Int` and not a Boolean.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码返回 `Future[Int]`，计算被删除的项目数量。如果记录 ID 在数据库中找不到，结果将是 `0`。我们期望它总是 `1`，因为我们将要按
    ID 删除。然而，API 是通用的，如果你比如说按名称或其他字段删除，可能会有多个删除。这就是为什么它是一个 `Int` 而不是一个布尔值。
- en: 'Inserting data is easy too; we just give the following command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 插入数据也很简单；我们只需给出以下命令：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, it is a very simple `map` function as if we were adding an element
    to a list. This code returns unit, which means nothing. However, we still have
    a Future, so this code is not blocking.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一个非常简单的 `map` 函数，就像我们向列表中添加一个元素一样。此代码返回 `unit`，这意味着没有返回值。然而，我们仍然有一个 Future，所以这段代码不是阻塞的。
- en: To perform an update, there is a little bit more code, but it is still simple
    at the end of the day.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行更新操作，代码稍微多一点，但最终仍然很简单。
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: First we need to apply a filter to select the records that we will update. We
    pass the ID, because we just want to update a single record. Then we need to apply
    a `map` function to pick the fields that we want to update;  finally, we perform
    the update, passing the new values to the `update` function.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要应用一个过滤器来选择我们将要更新的记录。我们传递 ID，因为我们只想更新单个记录。然后我们需要应用一个 `map` 函数来选择我们想要更新的字段；最后，我们执行更新，将新值传递给
    `update` 函数。
- en: Let's take a look at the companion object for the product model.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看产品模型的伴生对象。
- en: 'Here is the code for `Models.Product.scala`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `Models.Product.scala` 的代码：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, this is a simple helper companion object to hold the MySQL table
    name.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一个简单的辅助伴生对象，用于存储 MySQL 表名。
- en: ReviewDAO
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ReviewDAO
- en: We are done with `ProductDao`, and now we need to move to the review model and
    create `dao` for reviews. We will perform steps similar to the ones we did for
    the product.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了 `ProductDao`，现在我们需要转向评论模型并创建评论的 `dao`。我们将执行与产品类似的步骤。
- en: '`ReviewDao.scala` is as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReviewDao.scala` 的代码如下：'
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code, we have the elements that we saw in `ProductDao`. There
    is an interface for `dao` called `IReviewDao`, which extends `BaseDao` using the
    review model. We have the `ReviewDao` implementation with the `ReviewTable` FRM
    mapping. We also have a companion object for the review model.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有我们在 `ProductDao` 中看到的元素。有一个名为 `dao` 的接口，称为 `IReviewDao`，它使用评论模型扩展了
    `BaseDao`。我们有 `ReviewDao` 实现，使用 `ReviewTable` FRM 映射。我们还有一个评论模型的伴生对象。
- en: '`Review.scala` is as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`Review.scala` 的代码如下：'
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ImageDao
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ImageDao
- en: Now we need to move to our last `dao`, `ImageDao`. Like `ProductDao` and `ReviewDao`,
    we will go through the same ideas and concepts as implementation too.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要转向我们的最后一个 `dao`，`ImageDao`。像 `ProductDao` 和 `ReviewDao` 一样，我们将通过实现过程来探讨相同的思想和概念。
- en: 'We will now look at `ImageDao.scala`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将查看 `ImageDao.scala`：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We also need to have a companion object helper for the image.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为图片有一个伴生对象辅助器。
- en: '`Image.scala` is as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`Image.scala` 的代码如下：'
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Slick evolutions
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Slick evolutions
- en: Slick won't create the table for us, unless we create an evolution. Slick keeps
    track of the database state and creates and applies SQL commands for us. Evolutions
    need be located at `ReactiveWebStore/conf/evolutions/default`, where `default`
    is the name of the database we configured in `application.conf`. Evolutions need
    to be named in a sequential way so that we can preserve order and Slick can keep
    track of the changes. Right now, we will create an evolution for `ProductDao`,
    because we need a product table.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Slick 不会为我们创建表，除非我们创建一个演变。Slick 跟踪数据库状态，并为我们创建和执行 SQL 命令。演变需要位于 `ReactiveWebStore/conf/evolutions/default`，其中
    `default` 是我们在 `application.conf` 中配置的数据库名称。演变需要按顺序命名，以便我们可以保持顺序，Slick 可以跟踪更改。现在，我们将为
    `ProductDao` 创建一个演变，因为我们需要一个产品表。
- en: 'The code will be as follows with the name `1.sql`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与 `1.sql` 命名的代码：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We need evolutions for th review and image as well. So we need to create `2.sql`
    for the image and `3.sql` for the review.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要对评论和图片进行演变。因此，我们需要为图片创建 `2.sql`，为评论创建 `3.sql`。
- en: 'The code will be as follows for `2.sql`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与 `2.sql` 命名的代码：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The code will be as follows with the name `3.sql`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与 `3.sql` 命名的代码：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Refactoring services
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构服务
- en: We need to change the default base trait for our `dao` packages to return Futures
    now.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将我们的`dao`包的默认基础特质更改为现在返回Futures。
- en: 'Let''s start with `BaseServices.scala`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`BaseServices.scala`开始：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This last implementation reflects what's happening in the `dao` packages. Now
    we can move to the services implementation, and proceed with our refactoring.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的实现反映了`dao`包中发生的事情。现在我们可以转到服务实现，并继续我们的重构。
- en: 'Next we see `ProductService.scala`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们看到`ProductService.scala`：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There are a couple of changes here. First, we inject an `IProductDao`, and let
    Guice figure out the right injection that we need to be able to test with our
    old `in-memory` HashMap implementation, which will be covered later in this chapter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些更改。首先，我们注入一个`IProductDao`，让Guice确定我们需要的正确注入，以便能够使用我们稍后在本章中将要介绍的旧的`in-memory`
    HashMap实现进行测试。
- en: The changes involve new function signatures, using `Awaits`, and using `Seq`
    instead of `List`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 变更涉及新的函数签名，使用`Awaits`，以及使用`Seq`而不是`List`。
- en: Let's move to on `ReviewService.scala` now.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转到`ReviewService.scala`。
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding code, we have the same kind of changes that we made for the
    product. Let's move to `ImageService.scala`, which is our last service.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述代码中，我们有与产品相同的更改。让我们转到`ImageService.scala`，这是我们最后一个服务。
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We have refactored all services to use the new `dao` packages implementation.
    Now the next step is the move to the controllers.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经重构了所有服务以使用新的`dao`包实现。下一步是将控制器迁移过来。
- en: Refactoring controllers
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构控制器
- en: 'Now we have all the `dao` packages implemented with the respective database
    evolutions. However, our services expected a different contract, since we were
    using an in-memory database before. Let''s refactor the product controller:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了所有`dao`包与相应的数据库演变。然而，我们的服务期望一个不同的契约，因为我们之前使用的是内存数据库。让我们重构产品控制器：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'There are two big changes in the preceding code despite the new function signatures.
    First, we use a utility function called `get` from a class called `Awaits`. This
    is needed so that we wait for the result to come back from the database. Second,
    when we flash the result, we no longer show the `id`, we just display a text message.
    Let''s take a look at the `Awaits` implementation in `Utils.Awaits.scala`, which
    is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有新的函数签名，前述代码中有两个大的变化。首先，我们从一个名为`Awaits`的类中使用一个名为`get`的实用函数。这是必要的，以便我们等待结果从数据库返回。其次，当我们闪现结果时，我们不再显示`id`，我们只显示一条文本消息。让我们看看`Utils.Awaits.scala`中的`Awaits`实现，如下所示：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`Awaits` is just a simple utility class that waits for a period of time to
    get a Future result. We need to add some tweaks in `ReviewController` and `ImageController`
    as well.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Awaits`只是一个简单的实用类，它等待一段时间以获取Future结果。我们还需要在`ReviewController`和`ImageController`中添加一些调整。'
- en: 'We will first explore `ReviewController.scala`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先探索`ReviewController.scala`：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: For `ReviewController`, we have made the same changes that we did for the product,
    that is, the use of `Awaits` and labels on flash returns.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`ReviewController`，我们进行了与产品相同的更改，即使用`Awaits`和闪现返回的标签。
- en: 'Let''s move on to the final controller: `ImageController.scala.`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到最后的控制器：`ImageController.scala`。
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Configuring DAO packages in Guice
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Guice中配置DAO包
- en: 'We need to configure the injections for the three new `dao` packages that we
    created. So we to need to add three lines in the file `Module.scala`. Please open
    the file in your IDE, and add the following content:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要配置我们创建的三个新`dao`包的注入。因此，我们需要在`Module.scala`文件中添加三行。请打开您的IDE中的文件，并添加以下内容：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The whole file, `Module.scala`, should look like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 整个文件，`Module.scala`，应该看起来像这样：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Refactoring tests
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构测试
- en: As you might expect, most tests are no longer working. We will need to perform
    some refactoring here as well. We will refactor our former `dao` to make it generic,
    and it will be used in integration tests (end-to-end tests).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所料，大多数测试现在不再工作。我们在这里也需要进行一些重构。我们将重构我们之前的`dao`使其通用，它将被用于集成测试（端到端测试）。
- en: Since we will create a generic dao system in memory for end-to-end testing purposes,
    we need to change our models a little bit. First, we need to create a base trait
    for all the models. This is needed so we can treat our models as equals.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将为了端到端测试的目的在内存中创建一个通用的dao系统，我们需要稍微改变我们的模型。首先，我们需要为所有模型创建一个基础特质。这是必要的，这样我们就可以将我们的模型视为相等。
- en: 'Let''s have a look at `models.BaseModel.scala`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`models.BaseModel.scala`：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We also need to make all our models implement this new trait. So we will need
    to change the Scala code for the product, image, and review. This is very trivial:
    we just add a getter and a setter for the `id` field. You can also use `scala.bean.BeanProperty`
    instead of writing one by yourself.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要让所有模型实现这个新特质。因此，我们需要更改产品、图片和评论的 Scala 代码。这非常简单：我们只需为 `id` 字段添加一个获取器和设置器。您也可以使用
    `scala.bean.BeanProperty` 而不是自己编写。
- en: 'Your `models.Product.scala` file should look something like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `models.Product.scala` 文件应该看起来像这样：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see in the preceding code, we extend the `BaseModel` method, and
    implement `getId` and `setId`. We need to do the same for the review and image
    models.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们扩展了 `BaseModel` 方法，并实现了 `getId` 和 `setId`。我们需要为评论和图片模型做同样的操作。
- en: 'Your `models.Review.scala` file should look like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `models.Review.scala` 文件应该看起来像这样：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now we move on to the last model. We need to implement it in `Image.scala`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们转到最后一个模型。我们需要在 `Image.scala` 中实现它。
- en: 'Your `models.Image.scala` file should look like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `models.Image.scala` 文件应该看起来像这样：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Generic mocks
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用模拟
- en: Now we have all that we need to create a generic mock implementation and mock
    all the `dao` packages. Under the location `ReactiveWebStore/test/`, we will create
    a package called mocks, and create a call, `GenericMockedDao`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了创建通用模拟实现并模拟所有 `dao` 包所需的一切。在 `ReactiveWebStore/test/` 位置下，我们将创建一个名为 `mocks`
    的包，并创建一个名为 `GenericMockedDao` 的调用。
- en: 'Your `GenericMockedDao.scala` file should look like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `GenericMockedDao.scala` 文件应该看起来像这样：
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'So the `GenericMockedDao` call expects the `Generic` parameter, which could
    be any class extending from `BaseModel`. Then we use an in-memory HashMap implementation
    and a counter to simulate database operations. We run all the operations inside
    Futures, so we don''t break the new signature the code is expecting. Now we can
    create three `MockedDaos` for each model we need: product, review, and image.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`GenericMockedDao` 调用期望 `Generic` 参数，这可以是任何继承自 `BaseModel` 的类。然后我们使用内存中的
    HashMap 实现和一个计数器来模拟数据库操作。我们在 Futures 中运行所有操作，这样我们就不破坏代码期望的新签名。现在我们可以为每个需要的模型创建三个
    `MockedDaos`：产品、评论和图片。
- en: 'Your `mocks.ProductMockedDao.scala` file should look like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `mocks.ProductMockedDao.scala` 文件应该看起来像这样：
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see here, we implement the `IProdutDao` trait, and we delegate all
    operations to `genericMockedDao`. Since everything is in-memory, we don't need
    to implement the `toTable` function. We need to do the same for the review and
    image.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如此可见，我们实现了 `IProdutDao` 特质，并将所有操作委托给 `genericMockedDao`。由于所有内容都在内存中，我们不需要实现
    `toTable` 函数。评论和图片也需要做同样的操作。
- en: 'Your `mocks.ReviewMockedDao.scala` file should look like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `mocks.ReviewMockedDao.scala` 文件应该看起来像这样：
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Exactly like product, we delegate all operations to `GenericMockedDao`. Now
    let's move to the last one, the image, and then we can fix the tests.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 就像产品一样，我们将所有操作委托给 `GenericMockedDao`。现在让我们转到最后一个，图片，然后我们可以修复测试。
- en: 'Your `mocks.ImageMockedDao.scala` file should look like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `mocks.ImageMockedDao.scala` 文件应该看起来像这样：
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Okay, we have all the mocks that we need for now. We can move on to fix the
    test specs. We need to fix services tests and controller test. Services tests
    will use mocks. Controllers tests, however, will use the real database implementation.
    We need to use other utility classes for controller tests. Located in the test
    source folder, we need to create a package called `utils`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们现在有了所有需要的模拟。我们可以继续修复测试规范。我们需要修复服务测试和控制器测试。服务测试将使用模拟。然而，控制器测试将使用真实的数据库实现。我们需要为控制器测试使用其他实用工具类。位于测试源文件夹中，我们需要创建一个名为
    `utils` 的包。
- en: 'Your `utils.DBCleaner.scala` file should look like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `utils.DBCleaner.scala` 文件应该看起来像这样：
- en: '[PRE40]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`DBCleaner` will connect to the real database and perform delete statements
    to clean up all table data. After deleting all data in the tables, we also reset
    the sequence in the database; otherwise, our tests will not have the predictability
    we need to do assertions.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`DBCleaner` 将连接到真实数据库并执行删除语句以清理所有表数据。在删除表中的所有数据后，我们还需要重置数据库中的序列；否则，我们的测试将不会有我们进行断言所需的可预测性。'
- en: As you can see in `db.run`, we can use `DBIO.seq`, which allows us to execute
    multiple instructions on the database. Here we are not using Scala code. We are
    using pure SQL statements, since we need to use very specific MySQL functions
    to reset the sequences.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如 `db.run` 中所示，我们可以使用 `DBIO.seq`，它允许我们在数据库上执行多个指令。这里我们不是使用 Scala 代码。我们使用纯 SQL
    语句，因为我们需要使用非常特定的 MySQL 函数来重置序列。
- en: If you need, you could use all these functions in your application. This is
    useful if you need to use a specific database function, if you have a very complex
    query, or sometimes, because there is a performance issue.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，您可以在您的应用程序中使用所有这些功能。如果您需要使用特定的数据库功能，如果您有一个非常复杂的查询，或者有时，因为存在性能问题，这很有用。
- en: Most fixes we do now center around using `Awaits` to wait for the Future result,
    and also using our new mocks. For the controller test, we need to call the `DBCleaner`
    function as well.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在所做的大多数修复都集中在使用 `Awaits` 等待 Future 结果，以及使用我们新的模拟。对于控制器测试，我们需要调用 `DBCleaner`
    函数。
- en: Service tests
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务测试
- en: Now we will create tests for services to test them. So let's get started.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为服务创建测试以测试它们。让我们开始吧。
- en: 'Your `ProductServiceTestSpec.scala` file should look like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `ProductServiceTestSpec.scala` 文件应如下所示：
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As you can see in the preceding code, most fixes center around the new signatures
    and the fact we are using Futures and need to use the `Awaits` utility and mocks.
    We test the service without the database call via this code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，大多数修复都集中在新的签名以及我们正在使用 Futures 并需要使用 `Awaits` 工具和模拟的事实。我们通过以下代码测试服务而不进行数据库调用：
- en: '[PRE42]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We can move on to the next service, which will be the review.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续到下一个服务，这将是我们将要审查的服务。
- en: 'Your `ReviewServiceTestSpec.scala` file should look like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `ReviewServiceTestSpec.scala` 文件应如下所示：
- en: '[PRE43]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: That was the review spec service test code. We apply the same changes as we
    did for product. Now we need to move on to the last service test, which will be
    the image.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是审查规范服务测试代码。我们应用与产品相同的更改。现在我们需要继续到最后一个服务测试，即图像测试。
- en: 'Your `ImageServiceTestSpec.scala` file should look like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `ImageServiceTestSpec.scala` 文件应如下所示：
- en: '[PRE44]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We have fixed all the services tests. Now we need to fix the controller tests.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经修复了所有服务测试。现在我们需要修复控制器测试。
- en: Controller tests
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器测试
- en: Now let's fix the controller tests. The first one will be the product controller.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们修复控制器测试。第一个将是产品控制器。
- en: 'Your `ProductControllerTestSpec.scala` file should look like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `ProductControllerTestSpec.scala` 文件应如下所示：
- en: '[PRE45]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The Controller product test needs to call the `DBCleaner` function at the beginning
    of the test to make sure that the database is in a well-known state; additionally,
    and after running all the tests, we need to clean up the database just to be safe.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器产品测试需要在测试开始时调用 `DBCleaner` 函数以确保数据库处于已知状态；此外，在运行所有测试后，我们还需要清理数据库以确保安全。
- en: We will now apply the same changes for the review and image controller tests.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将应用相同的更改以进行审查和图像控制器测试。
- en: 'Your `ReviewControllerTestSpec` file should look like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `ReviewControllerTestSpec` 文件应如下所示：
- en: '[PRE46]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Alright, we have the tests for the review controller fixed. Now we can move
    to the last controller test for the image.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经修复了审查控制器测试。现在我们可以移动到最后一个控制器测试，即图像测试。
- en: 'Your `ImageControllerTestSpec.scala` file should look like this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `ImageControllerTestSpec.scala` 文件应如下所示：
- en: '[PRE47]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: All right, all the controller tests are fixed now. We can run all the tests
    to double check whether everything is OK.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所有的控制器测试现在都已修复。我们可以运行所有测试以再次检查是否一切正常。
- en: 'Run the following command:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE48]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You get output as shown in the following screenshot:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到以下截图所示的输出：
- en: '![Controller tests](img/image00293.jpeg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![控制器测试](img/image00293.jpeg)'
- en: If you have problems running the application (covered in the next section),
    apply the evolution, and then you can run the tests again. Tests might take some
    time, depending on your hardware.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在运行应用程序时遇到问题（下一节将介绍），请应用进化，然后您可以再次运行测试。测试可能需要一些时间，具体取决于您的硬件。
- en: Running the application
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: Now it is time to run the application using `$ activator run`. Open your web
    browser, and go to `http://localhost:9000/`. Once you do that, Play will detect
    that the application needs evolutions, and will apply the three evolutions we
    have (`1.sql`, `2.sql`, and `3.sql`). However, you will need to click on the button
    to apply the evolution.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候使用 `$ activator run` 运行应用程序了。打开您的网络浏览器，并转到 `http://localhost:9000/`。一旦这样做，Play
    将检测到应用程序需要进化，并将应用我们拥有的三个进化（`1.sql`、`2.sql` 和 `3.sql`）。然而，您需要点击按钮来应用进化。
- en: '![Running the application](img/image00294.jpeg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![运行应用程序](img/image00294.jpeg)'
- en: After you click on the red button, **Apply this script now!**, Slick will create
    the tables, and redirect you to the application.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在您点击红色按钮后，**立即应用此脚本**，Slick 将创建表格，并将您重定向到应用程序。
- en: '![Running the application](img/image00295.jpeg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![运行应用程序](img/image00295.jpeg)'
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With this, we reach the end of the chapter. You learned how to perform database
    persistence using Slick. You also learned how to do FRM mapping, and we refactored
    our application and tests so they work with reactive persistence and the Play
    framework. We then explained how to access the database using Scala code, and
    perform operations using SQL.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就到达了本章的结尾。你学习了如何使用 Slick 来执行数据库持久化。你还学习了如何进行 FRM 映射，并且我们对应用程序和测试进行了重构，以便它们能够与反应式持久化和
    Play 框架一起工作。然后我们解释了如何使用 Scala 代码访问数据库，并使用 SQL 执行操作。
- en: In the following chapter, we will see more about reports, and we will use our
    database to generate reports based on our Play framework application.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解更多关于报告的内容，并且我们将使用我们的数据库来根据我们的 Play 框架应用程序生成报告。
