- en: Chapter 2. Building Microservices with Spring Boot
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。使用Spring Boot构建微服务
- en: Developing microservices is not so tedious anymore thanks to the powerful Spring
    Boot framework. Spring Boot is a framework to develop production-ready microservices
    in Java.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 开发微服务不再那么乏味，这要归功于强大的Spring Boot框架。Spring Boot是一个用于开发Java生产就绪微服务的框架。
- en: This chapter will move from the microservices theory explained in the previous
    chapter to hands-on practice by reviewing code samples. This chapter will introduce
    the Spring Boot framework and explain how Spring Boot can help build RESTful microservices
    in line with the principles and characteristics discussed in the previous chapter.
    Finally, some of the features offered by Spring Boot to make microservices production-ready
    will be reviewed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从上一章中解释的微服务理论转移到实际操作，通过审查代码示例来介绍Spring Boot框架，并解释Spring Boot如何帮助构建符合上一章讨论的原则和特征的RESTful微服务。最后，将回顾Spring
    Boot提供的一些功能，使微服务达到生产就绪状态。
- en: 'By the end of this chapter, you will have learned about:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将学到：
- en: Setting up the latest Spring development environment
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置最新的Spring开发环境
- en: Developing RESTful services using the Spring framework
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring框架开发RESTful服务
- en: Using Spring Boot to build fully qualified microservices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Boot构建完全合格的微服务
- en: Useful Spring Boot features to build production-ready microservices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Boot构建生产就绪的微服务的有用功能
- en: Setting up a development environment
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立开发环境
- en: 'To crystalize microservices concepts, a couple of microservices will be built.
    For this, it is assumed that the following components are installed:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确微服务的概念，将构建一对微服务。为此，假定已安装以下组件：
- en: '**JDK 1.8**: [http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JDK 1.8**：[http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html)'
- en: '**Spring Tool Suite 3.7.2** (**STS**): [https://spring.io/tools/sts/all](https://spring.io/tools/sts/all)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring Tool Suite 3.7.2**（**STS**）：[https://spring.io/tools/sts/all](https://spring.io/tools/sts/all)'
- en: '**Maven 3.3.1**: [https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Maven 3.3.1**：[https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi)'
- en: Alternately, other IDEs such as IntelliJ IDEA, NetBeans, or Eclipse could be
    used. Similarly, alternate build tools such as Gradle can be used. It is assumed
    that the Maven repository, class path, and other path variables are set properly
    to run STS and Maven projects.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用其他IDE，如IntelliJ IDEA、NetBeans或Eclipse。同样，也可以使用其他构建工具，如Gradle。假设Maven仓库、类路径和其他路径变量已正确设置以运行STS和Maven项目。
- en: 'This chapter is based on the following versions of Spring libraries:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章基于以下版本的Spring库：
- en: Spring Framework `4.2.6.RELEASE`
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring框架`4.2.6.RELEASE`
- en: Spring Boot `1.3.5.RELEASE`
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot`1.3.5.RELEASE`
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Detailed steps to download the code bundle are mentioned in the Preface of this
    book. Have a look.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下载代码包的详细步骤在本书的前言中有提到。看一看。
- en: The code bundle for the book is also hosted on GitHub at [https://github.com/PacktPublishing/Spring-Microservices](https://github.com/PacktPublishing/Spring-Microservices).
    We also have other code bundles from our rich catalog of books and videos available
    at [https://github.com/PacktPublishing/](https://github.com/PacktPublishing/).
    Check them out!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的代码包也托管在GitHub上，网址为[https://github.com/PacktPublishing/Spring-Microservices](https://github.com/PacktPublishing/Spring-Microservices)。我们还有其他丰富的书籍和视频代码包可供使用，网址为[https://github.com/PacktPublishing/](https://github.com/PacktPublishing/)。去看看吧！
- en: Developing a RESTful service – the legacy approach
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发RESTful服务-传统方法
- en: This example will review the traditional RESTful service development before
    jumping deep into Spring Boot.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究Spring Boot之前，本示例将回顾传统的RESTful服务开发。
- en: STS will be used to develop this REST/JSON service.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: STS将用于开发此REST/JSON服务。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The full source code of this example is available as the `legacyrest` project
    in the code files of this book.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的完整源代码可在本书的代码文件中的`legacyrest`项目中找到。
- en: 'The following are the steps to develop the first RESTful service:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是开发第一个RESTful服务的步骤：
- en: Start STS and set a workspace of choice for this project.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动STS并为该项目设置一个工作区。
- en: Navigate to **File** | **New** | **Project**.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**File** | **New** | **Project**。
- en: Select **Spring Legacy Project** as shown in the following screenshot and click
    on **Next**:![Developing a RESTful service – the legacy approach](img/B05447_02_01.jpg)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Spring Legacy Project**，如下截图所示，然后点击**Next**：![开发RESTful服务-传统方法](img/B05447_02_01.jpg)
- en: Select **Spring MVC Project** as shown in the following diagram and click on
    **Next**:![Developing a RESTful service – the legacy approach](img/B05447_02_02.jpg)
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Spring MVC Project**，如下图所示，然后点击**Next**：![开发RESTful服务-传统方法](img/B05447_02_02.jpg)
- en: Select a top-level package name of choice. This example uses `org.rvslab.chapter2.legacyrest`
    as the top-level package.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个顶级包名称。本示例使用`org.rvslab.chapter2.legacyrest`作为顶级包。
- en: Then, click on **Finish**.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击**Finish**。
- en: This will create a project in the STS workspace with the name `legacyrest`.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在STS工作区中创建一个名为`legacyrest`的项目。
- en: Before proceeding further, `pom.xml` needs editing.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，需要编辑`pom.xml`。
- en: 'Change the Spring version to `4.2.6.RELEASE`, as follows:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Spring版本更改为`4.2.6.RELEASE`，如下所示：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Add **Jackson** dependencies in the `pom.xml` file for JSON-to-POJO and POJO-to-JSON
    conversions. Note that the `2.*.*` version is used to ensure compatibility with
    Spring 4.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`pom.xml`文件中添加**Jackson**依赖项，用于JSON到POJO和POJO到JSON的转换。请注意，使用`2.*.*`版本以确保与Spring
    4的兼容性。
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Some Java code needs to be added. In **Java Resources**, under **legacyrest**,
    expand the package and open the default **HomeController.java** file:![Developing
    a RESTful service – the legacy approach](img/B05447_02_03.jpg)
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要添加一些Java代码。在**Java Resources**下的**legacyrest**中，展开包并打开默认的**HomeController.java**文件：![开发RESTful服务-传统方法](img/B05447_02_03.jpg)
- en: 'The default implementation is targeted more towards the MVC project. Rewriting
    `HomeController.java` to return a JSON value in response to the REST call will
    do the trick. The resulting `HomeController.java` file will look similar to the
    following:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认实现更加面向MVC项目。重写`HomeController.java`以响应REST调用返回JSON值将会奏效。生成的`HomeController.java`文件将类似于以下内容：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Examining the code, there are now two classes:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 检查代码，现在有两个类：
- en: '`Greet`: This is a simple Java class with getters and setters to represent
    a data object. There is only one attribute in the `Greet` class, which is `message`.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Greet`：这是一个简单的Java类，具有用于表示数据对象的getter和setter。`Greet`类中只有一个属性，即`message`。'
- en: '`HomeController.java`: This is nothing but a Spring controller REST endpoint
    to handle HTTP requests.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HomeController.java`：这只是一个Spring控制器REST端点，用于处理HTTP请求。'
- en: 'Note that the annotation used in `HomeController` is `@RestController`, which
    automatically injects `@Controller` and `@ResponseBody` and has the same effect
    as the following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`HomeController`中使用的注释是`@RestController`，它会自动注入`@Controller`和`@ResponseBody`，并具有与以下代码相同的效果：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The project can now be run by right-clicking on **legacyrest**, navigating to
    **Run As** | **Run On Server**, and then selecting the default server (**Pivotal
    tc Server Developer Edition v3.1**) that comes along with STS.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目现在可以通过右键单击**legacyrest**，导航到**Run As** | **Run On Server**，然后选择默认服务器（**Pivotal
    tc Server Developer Edition v3.1**）来运行。
- en: This should automatically start the server and deploy the web application on
    the TC server.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会自动启动服务器并在TC服务器上部署Web应用程序。
- en: 'If the server started properly, the following message will appear in the console:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器正常启动，控制台将显示以下消息：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If everything is fine, STS will open a browser window to `http://localhost:8080/legacyrest/`
    and display the JSON object as shown in the browser. Right-click on and navigate
    to **legacyrest** | **Properties** | **Web Project Settings** and review **Context
    Root** to identify the context root of the web application:![Developing a RESTful
    service – the legacy approach](img/B05447_02_04.jpg)
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切正常，STS将打开一个浏览器窗口到`http://localhost:8080/legacyrest/`，并在浏览器中显示JSON对象。右键单击并导航到**legacyrest**
    | **Properties** | **Web Project Settings**，并查看**Context Root**以识别Web应用程序的上下文根：![开发RESTful服务-传统方法](img/B05447_02_04.jpg)
- en: The alternate build option is to use Maven. Right-click on the project and navigate
    to **Run As** | **Maven install**. This will generate `chapter2-1.0.0-BUILD-SNAPSHOT.war`
    under the target folder. This war is deployable in any servlet container such
    as Tomcat, JBoss, and so on.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个构建选项是使用Maven。右键单击项目，导航到**Run As** | **Maven install**。这将在目标文件夹下生成`chapter2-1.0.0-BUILD-SNAPSHOT.war`。这个war文件可以部署在任何Servlet容器中，如Tomcat、JBoss等。
- en: Moving from traditional web applications to microservices
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从传统的Web应用程序转向微服务
- en: Carefully examining the preceding RESTful service will reveal whether this really
    constitutes a microservice. At first glance, the preceding RESTful service is
    a fully qualified interoperable REST/JSON service. However, it is not fully autonomous
    in nature. This is primarily because the service relies on an underlying application
    server or web container. In the preceding example, a war was explicitly created
    and deployed on a Tomcat server.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细检查前面的RESTful服务将会揭示这是否真的构成了微服务。乍一看，前面的RESTful服务是一个完全合格的可互操作的REST/JSON服务。然而，它在本质上并不是完全自治的。这主要是因为该服务依赖于底层的应用服务器或Web容器。在前面的例子中，一个war文件被明确创建并部署在Tomcat服务器上。
- en: This is a traditional approach to developing RESTful services as a web application.
    However, from the microservices point of view, one needs a mechanism to develop
    services as executables, self-contained JAR files with an embedded HTTP listener.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种传统的开发RESTful服务的方法，作为Web应用程序。然而，从微服务的角度来看，人们需要一种机制来开发可执行的服务，即带有嵌入式HTTP监听器的自包含JAR文件。
- en: Spring Boot is a tool that allows easy development of such kinds of services.
    Dropwizard and WildFly Swarm are alternate server-less RESTful stacks.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot是一个工具，可以方便地开发这种类型的服务。Dropwizard和WildFly Swarm是替代的无服务器RESTful堆栈。
- en: Using Spring Boot to build RESTful microservices
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Boot构建RESTful微服务
- en: Spring Boot is a utility framework from the Spring team to bootstrap Spring-based
    applications and microservices quickly and easily. The framework uses an opinionated
    approach over configurations for decision making, thereby reducing the effort
    required in writing a lot of boilerplate code and configurations. Using the 80-20
    principle, developers should be able to kickstart a variety of Spring applications
    with many default values. Spring Boot further presents opportunities for the developers
    to customize applications by overriding the autoconfigured values.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot是Spring团队的一个实用框架，可以快速轻松地启动基于Spring的应用程序和微服务。该框架在决策制定方面采用了一种有见地的方法，从而减少了编写大量样板代码和配置所需的工作量。使用80-20原则，开发人员应该能够使用许多默认值快速启动各种Spring应用程序。Spring
    Boot进一步为开发人员提供了定制应用程序的机会，通过覆盖自动配置的值。
- en: Spring Boot not only increases the speed of development but also provides a
    set of production-ready ops features such as health checks and metrics collection.
    As Spring Boot masks many configuration parameters and abstracts many lower-level
    implementations, it minimizes the chance of error to a certain extent. Spring
    Boot recognizes the nature of the application based on the libraries available
    in the class path and runs the autoconfiguration classes packaged in these libraries.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot不仅提高了开发速度，还提供了一套生产就绪的运维功能，如健康检查和指标收集。由于Spring Boot掩盖了许多配置参数并抽象了许多底层实现，它在一定程度上减少了错误的机会。Spring
    Boot根据类路径中可用的库识别应用程序的性质，并运行打包在这些库中的自动配置类。
- en: 'Often, many developers mistakenly see Spring Boot as a code generator, but
    in reality, it is not. Spring Boot only autoconfigures build files—for example,
    POM files in the case of Maven. It also sets properties, such as data source properties,
    based on certain opinionated defaults. Take a look at the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发人员错误地将Spring Boot视为代码生成器，但实际上并非如此。Spring Boot只自动配置构建文件，例如Maven的POM文件。它还根据某些默认值设置属性，例如数据源属性。看一下以下代码：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For instance, in the preceding case, Spring Boot understands that the project
    is set to use the Spring Data JPA and HSQL databases. It automatically configures
    the driver class and other connection parameters.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在前面的案例中，Spring Boot知道项目设置为使用Spring Data JPA和HSQL数据库。它会自动配置驱动程序类和其他连接参数。
- en: One of the great outcomes of Spring Boot is that it almost eliminates the need
    to have traditional XML configurations. Spring Boot also enables microservices'
    development by packaging all the required runtime dependencies in a fat executable
    JAR file.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot的一个伟大成果之一是几乎消除了传统的XML配置的需求。Spring Boot还通过将所有所需的运行时依赖项打包到一个大的可执行JAR文件中来实现微服务的开发。
- en: Getting started with Spring Boot
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Spring Boot
- en: 'There are different ways that Spring Boot-based application development can
    be started:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot基于应用程序开发的不同方式有很多：
- en: Using the Spring Boot CLI as a command-line tool
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Boot CLI作为命令行工具
- en: Using IDEs such as STS to provide Spring Boot, which are supported out of the
    box
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用STS等IDE提供Spring Boot，这些都是默认支持的
- en: Using the Spring Initializr project at [http://start.spring.io](http://start.spring.io)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Initializr项目在[http://start.spring.io](http://start.spring.io)
- en: All these three options will be explored in this chapter, developing a variety
    of sample services.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨这三种选项，开发各种示例服务。
- en: Developing the Spring Boot microservice using the CLI
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CLI开发Spring Boot微服务
- en: 'The easiest way to develop and demonstrate Spring Boot''s capabilities is using
    the Spring Boot CLI, a command-line tool. Perform the following steps:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 开发和演示Spring Boot功能的最简单方法是使用Spring Boot CLI，一个命令行工具。执行以下步骤：
- en: Install the Spring Boot command-line tool by downloading the `spring-boot-cli-1.3.5.RELEASE-bin.zip`
    file from [http://repo.spring.io/release/org/springframework/boot/spring-boot-cli/1.3.5.RELEASE/spring-boot-cli-1.3.5.RELEASE-bin.zip](http://repo.spring.io/release/org/springframework/boot/spring-boot-cli/1.3.5.RELEASE/spring-boot-cli-1.3.5.RELEASE-bin.zip).
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从[http://repo.spring.io/release/org/springframework/boot/spring-boot-cli/1.3.5.RELEASE/spring-boot-cli-1.3.5.RELEASE-bin.zip](http://repo.spring.io/release/org/springframework/boot/spring-boot-cli/1.3.5.RELEASE/spring-boot-cli-1.3.5.RELEASE-bin.zip)下载`spring-boot-cli-1.3.5.RELEASE-bin.zip`文件来安装Spring
    Boot命令行工具。
- en: Unzip the file into a directory of your choice. Open a terminal window and change
    the terminal prompt to the `bin` folder.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件解压缩到您选择的目录中。打开终端窗口，并将终端提示更改为`bin`文件夹。
- en: Ensure that the `bin` folder is added to the system path so that Spring Boot
    can be run from any location.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将`bin`文件夹添加到系统路径中，以便可以从任何位置运行Spring Boot。
- en: 'Verify the installation with the following command. If successful, the Spring
    CLI version will be printed in the console:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令验证安装。如果成功，Spring CLI版本将打印在控制台上：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As the next step, a quick REST service will be developed in Groovy, which is
    supported out of the box in Spring Boot. To do so, copy and paste the following
    code using any editor of choice and save it as `myfirstapp.groovy` in any folder:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为下一步，将在Groovy中开发一个快速的REST服务，Spring Boot默认支持。为此，使用任何编辑器复制并粘贴以下代码，并将其保存为`myfirstapp.groovy`在任何文件夹中：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In order to run this Groovy application, go to the folder where `myfirstapp.groovy`
    is saved and execute the following command. The last few lines of the server start-up
    log will be similar to the following:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行这个Groovy应用程序，转到保存`myfirstapp.groovy`的文件夹，并执行以下命令。服务器启动日志的最后几行将类似于以下内容：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Open a browser window and go to `http://localhost:8080`; the browser will display
    the following message:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器窗口，转到`http://localhost:8080`；浏览器将显示以下消息：
- en: '**Hello World!**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**你好，世界！**'
- en: There is no war file created, and no Tomcat server was run. Spring Boot automatically
    picked up Tomcat as the webserver and embedded it into the application. This is
    a very basic, minimal microservice. The `@RestController` annotation, used in
    the previous code, will be examined in detail in the next example.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 没有创建war文件，也没有运行Tomcat服务器。Spring Boot自动选择了Tomcat作为Web服务器，并将其嵌入到应用程序中。这是一个非常基本的、最小的微服务。在前面的代码中使用的`@RestController`注解将在下一个示例中进行详细讨论。
- en: Developing the Spring Boot Java microservice using STS
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用STS开发Spring Boot Java微服务
- en: In this section, developing another Java-based REST/JSON Spring Boot service
    using STS will be demonstrated.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，将演示使用STS开发另一个基于Java的REST/JSON Spring Boot服务。
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The full source code of this example is available as the `chapter2.bootrest`
    project in the code files of this book.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例的完整源代码可作为本书的代码文件中的`chapter2.bootrest`项目获得。
- en: Open STS, right-click within the **Project Explorer** window, navigate to **New**
    | **Project**, and select **Spring Starter Project**, as shown in the following
    screenshot, and click on **Next**:![Developing the Spring Boot Java microservice
    using STS](img/B05447_02_05.jpg)
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开STS，在**Project Explorer**窗口中右键单击，导航到**New** | **Project**，然后选择**Spring Starter
    Project**，如下图所示，并单击**Next**：![使用STS开发Spring Boot Java微服务](img/B05447_02_05.jpg)
- en: Spring Starter Project is a basic template wizard that provides a number of
    other starter libraries to select from.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Starter Project是一个基本模板向导，提供了许多其他启动库供选择。
- en: Type the project name as `chapter2.bootrest` or any other name of your choice.
    It is important to choose the packaging as JAR. In traditional web applications,
    a war file is created and then deployed to a servlet container, whereas Spring
    Boot packages all the dependencies to a self-contained, autonomous JAR file with
    an embedded HTTP listener.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目名称命名为`chapter2.bootrest`或者您选择的其他名称。选择打包方式为JAR非常重要。在传统的web应用中，会创建war文件然后部署到servlet容器，而Spring
    Boot会将所有依赖项打包到一个独立的、自包含的JAR文件中，并带有嵌入式HTTP监听器。
- en: Select 1.8 under **Java Version**. Java 1.8 is recommended for Spring 4 applications.
    Change the other Maven properties such as **Group**, **Artifact**, and **Package**,
    as shown in the following screenshot:![Developing the Spring Boot Java microservice
    using STS](img/B05447_02_06.jpg)
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Java版本**下选择1.8。建议Spring 4应用程序使用Java 1.8。更改其他Maven属性，如**Group**、**Artifact**和**Package**，如下图所示：![使用STS开发Spring
    Boot Java微服务](img/B05447_02_06.jpg)
- en: Once completed, click on **Next**.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，点击**下一步**。
- en: The wizard will show the library options. In this case, as the REST service
    is developed, select **Web** under **Web**. This is an interesting step that tells
    Spring Boot that a Spring MVC web application is being developed so that Spring
    Boot can include the necessary libraries, including Tomcat as the HTTP listener
    and other configurations, as required:![Developing the Spring Boot Java microservice
    using STS](img/B05447_02_07.jpg)
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向导将显示库选项。在这种情况下，由于正在开发REST服务，选择**Web**下的**Web**。这是一个有趣的步骤，告诉Spring Boot正在开发一个Spring
    MVC web应用程序，以便Spring Boot可以包含必要的库，包括Tomcat作为HTTP监听器和其他所需的配置：![使用STS开发Spring Boot
    Java微服务](img/B05447_02_07.jpg)
- en: Click on **Finish**.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**完成**。
- en: 'This will generate a project named `chapter2.bootrest` in **Project Explorer**
    in STS:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在STS的**项目资源管理器**中生成一个名为`chapter2.bootrest`的项目：
- en: '![Developing the Spring Boot Java microservice using STS](img/B05447_02_08.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![使用STS开发Spring Boot Java微服务](img/B05447_02_08.jpg)'
- en: 'Take a moment to examine the generated application. Files that are of interest
    are:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 花一点时间检查生成的应用程序。感兴趣的文件包括：
- en: '`pom.xml`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pom.xml`'
- en: '`Application.java`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Application.java`'
- en: '`Application.properties`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Application.properties`'
- en: '`ApplicationTests.java`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ApplicationTests.java`'
- en: Examining the POM file
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查POM文件
- en: 'The parent element is one of the interesting aspects in the `pom.xml` file.
    Take a look at the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 父元素是`pom.xml`文件中的一个有趣的方面。看一下以下内容：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `spring-boot-starter-parent` pattern is a **bill of materials** (**BOM**),
    a pattern used by Maven's dependency management. BOM is a special kind of POM
    file used to manage different library versions required for a project. The advantage
    of using the `spring-boot-starter-parent` POM file is that developers need not
    worry about finding the right compatible versions of different libraries such
    as Spring, Jersey, JUnit, Logback, Hibernate, Jackson, and so on. For instance,
    in our first legacy example, a specific version of the Jackson library was added
    to work with Spring 4\. In this example, these are taken care of by the `spring-boot-starter-parent`
    pattern.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`spring-boot-starter-parent`模式是Maven依赖管理使用的**材料清单**（**BOM**）模式。BOM是一种特殊的POM文件，用于管理项目所需的不同库版本。使用`spring-boot-starter-parent`
    POM文件的优势在于开发人员无需担心找到不同库的兼容版本，比如Spring、Jersey、JUnit、Logback、Hibernate、Jackson等等。例如，在我们的第一个传统示例中，需要添加一个特定版本的Jackson库来与Spring
    4一起使用。在这个示例中，这些都由`spring-boot-starter-parent`模式处理。'
- en: The starter POM file has a list of Boot dependencies, sensible resource filtering,
    and sensible plug-in configurations required for the Maven builds.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: starter POM文件具有一系列Boot依赖项、合理的资源过滤和Maven构建所需的合理插件配置。
- en: Tip
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Refer to [https://github.com/spring-projects/spring-boot/blob/1.3.x/spring-boot-dependencies/pom.xml](https://github.com/spring-projects/spring-boot/blob/1.3.x/spring-boot-dependencies/pom.xml)
    to take a look at the different dependencies provided in the starter parent (version
    1.3.x). All these dependencies can be overridden if required.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 参考[https://github.com/spring-projects/spring-boot/blob/1.3.x/spring-boot-dependencies/pom.xml](https://github.com/spring-projects/spring-boot/blob/1.3.x/spring-boot-dependencies/pom.xml)查看starter
    parent（版本1.3.x）中提供的不同依赖项。如果需要，所有这些依赖项都可以被覆盖。
- en: 'The starter POM file itself does not add JAR dependencies to the project. Instead,
    it will only add library versions. Subsequently, when dependencies are added to
    the POM file, they refer to the library versions from this POM file. A snapshot
    of some of the properties are as shown as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: starter POM文件本身不会向项目添加JAR依赖项，而是只会添加库版本。随后，当依赖项添加到POM文件中时，它们会引用该POM文件中的库版本。以下是一些属性的快照：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Reviewing the dependency section, one can see that this is a clean and neat
    POM file with only two dependencies, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 审查依赖部分，可以看到这是一个干净整洁的POM文件，只有两个依赖，如下所示：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As web is selected, `spring-boot-starter-web` adds all dependencies required
    for a Spring MVC project. It also includes dependencies to Tomcat as an embedded
    HTTP listener. This provides an effective way to get all the dependencies required
    as a single bundle. Individual dependencies could be replaced with other libraries,
    for example replacing Tomcat with Jetty.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 选择web后，`spring-boot-starter-web`会添加Spring MVC项目所需的所有依赖项。它还包括对Tomcat的依赖，作为嵌入式HTTP监听器。这提供了一种有效的方式来获取所有所需的依赖项作为一个单独的捆绑包。可以用其他库替换单个依赖项，例如用Jetty替换Tomcat。
- en: Similar to web, Spring Boot comes up with a number of `spring-boot-starter-*`
    libraries, such as `amqp`, `aop`, `batch`, `data-jpa`, `thymeleaf`, and so on.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与web类似，Spring Boot提供了许多`spring-boot-starter-*`库，比如`amqp`，`aop`，`batch`，`data-jpa`，`thymeleaf`等等。
- en: 'The last thing to be reviewed in the `pom.xml` file is the Java 8 property.
    By default, the parent POM file adds Java 6\. It is recommended to override the
    Java version to 8 for Spring:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`pom.xml`文件中最后需要审查的是Java 8属性。默认情况下，父POM文件会添加Java 6。建议将Java版本覆盖为8用于Spring：'
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Examining Application.java
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查Application.java
- en: 'Spring Boot, by default, generated a `org.rvslab.chapter2.Application.java`
    class under `src/main/java` to bootstrap, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot默认在`src/main/java`下生成了一个`org.rvslab.chapter2.Application.java`类来引导，如下所示：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There is only a `main` method in `Application`, which will be invoked at startup
    as per the Java convention. The `main` method bootstraps the Spring Boot application
    by calling the `run` method on `SpringApplication`. `Application.class` is passed
    as a parameter to tell Spring Boot that this is the primary component.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`Application`中只有一个`main`方法，按照Java约定，在启动时将被调用。`main`方法通过在`SpringApplication`上调用`run`方法来引导Spring
    Boot应用程序。将`Application.class`作为参数传递，告诉Spring Boot这是主要组件。'
- en: 'More importantly, the magic is done by the `@SpringBootApplication` annotation.
    The `@SpringBootApplication` annotation is a top-level annotation that encapsulates
    three other annotations, as shown in the following code snippet:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，这是由`@SpringBootApplication`注解完成的。`@SpringBootApplication`注解是一个顶级注解，封装了另外三个注解，如下面的代码片段所示：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `@Configuration` annotation hints that the contained class declares one
    or more `@Bean` definitions. The `@Configuration` annotation is meta-annotated
    with `@Component`; therefore, it is a candidate for component scanning.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Configuration`注解提示包含的类声明一个或多个`@Bean`定义。`@Configuration`注解是元注解`@Component`的提示；因此，它是组件扫描的候选对象。'
- en: The `@EnableAutoConfiguration` annotation tells Spring Boot to automatically
    configure the Spring application based on the dependencies available in the class
    path.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`@EnableAutoConfiguration`注解告诉Spring Boot根据类路径中可用的依赖项自动配置Spring应用程序。'
- en: Examining application.properties
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查application.properties
- en: A default `application.properties` file is placed under `src/main/resources`.
    It is an important file to configure any required properties for the Spring Boot
    application. At the moment, this file is kept empty and will be revisited with
    some test cases later in this chapter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的`application.properties`文件放置在`src/main/resources`下。这是一个重要的文件，用于配置Spring Boot应用程序的任何必需属性。目前，这个文件是空的，将在本章的后面一些测试用例中重新访问。
- en: Examining ApplicationTests.java
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查ApplicationTests.java
- en: The last file to be examined is `ApplicationTests.java` under `src/test/java`.
    This is a placeholder to write test cases against the Spring Boot application.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查的最后一个文件是`src/test/java`下的`ApplicationTests.java`。这是一个占位符，用于针对Spring Boot应用程序编写测试用例。
- en: 'To implement the first RESTful service, add a REST endpoint, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现第一个RESTful服务，添加一个REST端点，如下所示：
- en: 'One can edit `Application.java` under `src/main/java` and add a RESTful service
    implementation. The RESTful service is exactly the same as what was done in the
    previous project. Append the following code at the end of the `Application.java`
    file:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以编辑`src/main/java`下的`Application.java`，并添加一个RESTful服务实现。RESTful服务与之前的项目中所做的完全相同。在`Application.java`文件的末尾添加以下代码：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To run, navigate to **Run As** | **Spring Boot App**. Tomcat will be started
    on the `8080` port:![Examining ApplicationTests.java](img/B05447_02_09.jpg)
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行，导航到**Run As** | **Spring Boot App**。Tomcat将在`8080`端口上启动：![检查ApplicationTests.java](img/B05447_02_09.jpg)
- en: 'We can notice from the log that:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从日志中注意到：
- en: Spring Boot get its own process ID (in this case, it is `41130`)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot获得了自己的进程ID（在本例中为`41130`）
- en: Spring Boot is automatically started with the Tomcat server at the localhost,
    port `8080`.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot会自动在本地主机的Tomcat服务器上启动，端口为`8080`。
- en: Next, open a browser and point to `http://localhost:8080`. This will show the
    JSON response as shown in the following screenshot:![Examining ApplicationTests.java](img/B05447_02_10.jpg)
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开浏览器，指向`http://localhost:8080`。这将显示JSON响应，如下面的截图所示：![检查ApplicationTests.java](img/B05447_02_10.jpg)
- en: 'A key difference between the legacy service and this one is that the Spring
    Boot service is self-contained. To make this clearer, run the Spring Boot application
    outside STS. Open a terminal window, go to the project folder, and run Maven,
    as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 传统服务和这个服务之间的一个关键区别是，Spring Boot服务是自包含的。为了更清楚地说明这一点，可以在STS之外运行Spring Boot应用程序。打开一个终端窗口，转到项目文件夹，并运行Maven，如下所示：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This will generate a fat JAR file under the target folder of the project. Running
    the application from the command line shows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在项目的目标文件夹下生成一个fat JAR文件。从命令行运行应用程序会显示：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As one can see, `bootrest-0.0.1-SNAPSHOT.jar` is self-contained and could be
    run as a standalone application. At this point, the JAR is as thin as 13 MB. Even
    though the application is no more than just "Hello World", the Spring Boot service
    just developed, practically follows the principles of microservices.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正如大家所看到的，`bootrest-0.0.1-SNAPSHOT.jar`是自包含的，可以作为独立的应用程序运行。在这一点上，JAR文件只有13MB。尽管应用程序不过是一个简单的“Hello
    World”，但刚刚开发的Spring Boot服务实际上遵循了微服务的原则。
- en: Testing the Spring Boot microservice
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试Spring Boot微服务
- en: 'There are multiple ways to test REST/JSON Spring Boot microservices. The easiest
    way is to use a web browser or a curl command pointing to the URL, as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以测试REST/JSON Spring Boot微服务。最简单的方法是使用Web浏览器或指向URL的curl命令，如下所示：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There are number of tools available to test RESTful services, such as Postman,
    Advanced REST client, SOAP UI, Paw, and so on.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多工具可用于测试RESTful服务，例如Postman、Advanced REST client、SOAP UI、Paw等。
- en: In this example, to test the service, the default test class generated by Spring
    Boot will be used.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，为了测试服务，将使用Spring Boot生成的默认测试类。
- en: 'Adding a new test case to `ApplicatonTests.java` results in:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ApplicatonTests.java`中添加一个新的测试用例会导致：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that `@WebIntegrationTest` is added and `@WebAppConfiguration` removed
    at the class level. The `@WebIntegrationTest` annotation is a handy annotation
    that ensures that the tests are fired against a fully up-and-running server. Alternately,
    a combination of `@WebAppConfiguration` and `@IntegrationTest` will give the same
    result.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在类级别添加了`@WebIntegrationTest`，并删除了`@WebAppConfiguration`。`@WebIntegrationTest`注解是一个方便的注解，可以确保测试针对一个完全运行的服务器。或者，`@WebAppConfiguration`和`@IntegrationTest`的组合将产生相同的结果。
- en: Also note that `RestTemplate` is used to call the RESTful service. `RestTemplate`
    is a utility class that abstracts the lower-level details of the HTTP client.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，`RestTemplate`用于调用RESTful服务。`RestTemplate`是一个实用程序类，它抽象了HTTP客户端的底层细节。
- en: To test this, one can open a terminal window, go to the project folder, and
    run `mvn install`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这一点，可以打开一个终端窗口，转到项目文件夹，并运行`mvn install`。
- en: Developing the Spring Boot microservice using Spring Initializr – the HATEOAS
    example
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Initializr开发Spring Boot微服务–HATEOAS示例
- en: In the next example, Spring Initializr will be used to create a Spring Boot
    project. Spring Initializr is a drop-in replacement for the STS project wizard
    and provides a web UI to configure and generate a Spring Boot project. One of
    the advantages of Spring Initializr is that it can generate a project through
    the website that then can be imported into any IDE.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，将使用Spring Initializr创建一个Spring Boot项目。Spring Initializr是STS项目向导的一个可插拔替代品，并提供了一个Web
    UI来配置和生成Spring Boot项目。Spring Initializr的一个优点是它可以通过网站生成一个项目，然后可以导入到任何IDE中。
- en: In this example, the concept of **HATEOAS** (short for **Hypertext As The Engine
    Of Application State**) for REST-based services and the **HAL** (**Hypertext Application
    Language**) browser will be examined.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，将研究基于REST的服务的**HATEOAS**（**应用程序状态的超文本作为引擎**）概念和**HAL**（**超文本应用语言**）浏览器。
- en: HATEOAS is a REST service pattern in which navigation links are provided as
    part of the payload metadata. The client application determines the state and
    follows the transition URLs provided as part of the state. This methodology is
    particularly useful in responsive mobile and web applications in which the client
    downloads additional data based on user navigation patterns.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: HATEOAS是一种REST服务模式，其中导航链接作为有效负载元数据的一部分提供。客户端应用程序确定状态并遵循作为状态的一部分提供的过渡URL。这种方法在响应式移动和Web应用程序中特别有用，其中客户端根据用户导航模式下载附加数据。
- en: The HAL browser is a handy API browser for `hal+json` data. HAL is a format
    based on JSON that establishes conventions to represent hyperlinks between resources.
    HAL helps APIs be more explorable and discoverable.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: HAL浏览器是一个方便的API浏览器，用于浏览`hal+json`数据。HAL是一种基于JSON的格式，它建立了表示资源之间超链接的约定。HAL有助于使API更具可探索性和可发现性。
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The full source code of this example is available as the `chapter2.boothateoas`
    project in the code files of this book.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的完整源代码可在本书的代码文件中的`chapter2.boothateoas`项目中找到。
- en: 'Here are the concrete steps to develop a HATEOAS sample using Spring Initilizr:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用Spring Initilizr开发HATEOAS示例的具体步骤：
- en: In order to use Spring Initilizr, go to [https://start.spring.io](https://start.spring.io):![Developing
    the Spring Boot microservice using Spring Initializr – the HATEOAS example](img/B05447_02_11.jpg)
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用Spring Initilizr，转到[https://start.spring.io](https://start.spring.io)：![使用Spring
    Initializr开发Spring Boot微服务–HATEOAS示例](img/B05447_02_11.jpg)
- en: Fill the details, such as whether it is a Maven project, Spring Boot version,
    group, and artifact ID, as shown earlier, and click on **Switch to the full version**
    link under the **Generate Project** button. Select **Web**, **HATEOAS**, and **Rest
    Repositories HAL Browser**. Make sure that the Java version is 8 and the package
    type is selected as **JAR**:![Developing the Spring Boot microservice using Spring
    Initializr – the HATEOAS example](img/B05447_02_12.jpg)
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写详细信息，例如是否为Maven项目，Spring Boot版本，组和artifact ID，如前所示，并点击**切换到完整版本**链接下的**生成项目**按钮。选择**Web**，**HATEOAS**和**Rest
    Repositories HAL Browser**。确保Java版本为8，并且包类型选择为**JAR**：![使用Spring Initializr开发Spring
    Boot微服务–HATEOAS示例](img/B05447_02_12.jpg)
- en: Once selected, hit the **Generate Project** button. This will generate a Maven
    project and download the project as a ZIP file into the download directory of
    the browser.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择后，点击**生成项目**按钮。这将生成一个Maven项目，并将项目下载为ZIP文件到浏览器的下载目录中。
- en: Unzip the file and save it to a directory of your choice.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压文件并将其保存到您选择的目录中。
- en: Open STS, go to the **File** menu and click on **Import**:![Developing the Spring
    Boot microservice using Spring Initializr – the HATEOAS example](img/B05447_02_13.jpg)
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开STS，转到**文件**菜单，点击**导入**：![使用Spring Initializr开发Spring Boot微服务–HATEOAS示例](img/B05447_02_13.jpg)
- en: Navigate to **Maven** | **Existing Maven Projects** and click on **Next**.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**Maven** | **现有Maven项目**，然后点击**下一步**。
- en: Click on **Browse** next to **Root Directory** and select the unzipped folder.
    Click on **Finish**. This will load the generated Maven project into STS' **Project
    Explorer**.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**根目录**旁边的**浏览**，选择解压的文件夹。点击**完成**。这将把生成的Maven项目加载到STS的**项目资源管理器**中。
- en: 'Edit the `Application.java` file to add a new REST endpoint, as follows:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`Application.java`文件，添加一个新的REST端点，如下所示：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Note that this is the same `GreetingController` class as in the previous example.
    However, a method was added this time named `greeting`. In this new method, an
    additional optional request parameter is defined and defaulted to `HATEOAS`. The
    following code adds a link to the resulting JSON code. In this case, it adds the
    link to the same API:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，这与上一个示例中的`GreetingController`类相同。但是，这次添加了一个名为`greeting`的方法。在这个新方法中，定义了一个额外的可选请求参数，并将其默认为`HATEOAS`。以下代码将链接添加到生成的JSON代码中。在这种情况下，它将链接添加到相同的API中：
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In order to do this, we need to extend the `Greet` class from `ResourceSupport`,
    as shown here. The rest of the code remains the same:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要将`Greet`类从`ResourceSupport`扩展，如下所示。其余的代码保持不变：
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `add` method is a method in `ResourceSupport`. The `linkTo` and `methodOn`
    methods are static methods of `ControllerLinkBuilder`, a utility class for creating
    links on controller classes. The `methodOn` method will do a dummy method invocation,
    and `linkTo` will create a link to the controller class. In this case, we will
    use `withSelfRel` to point it to itself.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`add`方法是`ResourceSupport`中的一个方法。`linkTo`和`methodOn`方法是`ControllerLinkBuilder`的静态方法，用于在控制器类上创建链接的实用程序类。`methodOn`方法将执行一个虚拟方法调用，而`linkTo`将创建一个指向控制器类的链接。在这种情况下，我们将使用`withSelfRel`将其指向自身。'
- en: This will essentially produce a link, `/greeting?name=HATEOAS`, by default.
    A client can read the link and initiate another call.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将基本上生成一个默认的链接`/greeting?name=HATEOAS`。客户端可以读取链接并发起另一个调用。
- en: Run this as a Spring Boot app. Once the server startup is complete, point the
    browser to `http://localhost:8080`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其作为Spring Boot应用程序运行。一旦服务器启动完成，将浏览器指向`http://localhost:8080`。
- en: This will open the HAL browser window. In the **Explorer** field, type `/greeting?name=World!`
    and click on the **Go** button. If everything is fine, the HAL browser will show
    the response details as shown in the following screenshot:![Developing the Spring
    Boot microservice using Spring Initializr – the HATEOAS example](img/B05447_02_14.jpg)
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将打开HAL浏览器窗口。在**Explorer**字段中，输入`/greeting?name=World!`并单击**Go**按钮。如果一切正常，HAL浏览器将显示响应详细信息，如下面的屏幕截图所示：![使用Spring
    Initializr开发Spring Boot微服务 - HATEOAS示例](img/B05447_02_14.jpg)
- en: As shown in the screenshot, the **Response Body** section has the result with
    a link with `href` pointing back to the same service. This is because we pointed
    the reference to itself. Also, review the **Links** section. The little green
    box against **self** is the navigable link.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如屏幕截图所示，**响应主体**部分显示了一个带有`href`指向同一服务的链接。这是因为我们将引用指向自身。还要查看**链接**部分。**self**旁边的小绿色框是可导航链接。
- en: It does not make much sense in this simple example, but this could be handy
    in larger applications with many related entities. Using the links provided, the
    client can easily navigate back and forth between these entities with ease.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中并没有太多意义，但在有许多相关实体的大型应用程序中可能会很方便。使用提供的链接，客户端可以轻松地在这些实体之间来回导航。
- en: What's next?
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: A number of basic Spring Boot examples have been reviewed so far. The rest of
    this chapter will examine some of the Spring Boot features that are important
    from a microservices development perspective. In the upcoming sections, we will
    take a look at how to work with dynamically configurable properties, change the
    default embedded web server, add security to the microservices, and implement
    cross-origin behavior when dealing with microservices.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，已经审查了许多基本的Spring Boot示例。本章的其余部分将从微服务开发的角度考虑一些重要的Spring Boot功能。在接下来的几节中，我们将看看如何处理动态可配置属性，更改默认的嵌入式Web服务器，为微服务添加安全性，并在处理微服务时实现跨源行为。
- en: Note
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The full source code of this example is available as the `chapter2.boot-advanced`
    project in the code files of this book.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的完整源代码可作为本书的代码文件中的`chapter2.boot-advanced`项目获得。
- en: The Spring Boot configuration
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot配置
- en: In this section, the focus will be on the configuration aspects of Spring Boot.
    The `chapter2.bootrest` project, already developed, will be modified in this section
    to showcase configuration capabilities. Copy and paste `chapter2.bootrest` and
    rename the project as `chapter2.boot-advanced`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，重点将放在Spring Boot的配置方面。已经开发的`chapter2.bootrest`项目将在本节中进行修改，以展示配置功能。复制并粘贴`chapter2.bootrest`并将项目重命名为`chapter2.boot-advanced`。
- en: Understanding the Spring Boot autoconfiguration
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解Spring Boot自动配置
- en: Spring Boot uses convention over configuration by scanning the dependent libraries
    available in the class path. For each `spring-boot-starter-*` dependency in the
    POM file, Spring Boot executes a default `AutoConfiguration` class. `AutoConfiguration`
    classes use the `*AutoConfiguration` lexical pattern, where `*` represents the
    library. For example, the autoconfiguration of JPA repositories is done through
    `JpaRepositoriesAutoConfiguration`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot使用约定优于配置，通过扫描类路径中可用的依赖库。对于POM文件中的每个`spring-boot-starter-*`依赖项，Spring
    Boot执行默认的`AutoConfiguration`类。`AutoConfiguration`类使用`*AutoConfiguration`词法模式，其中`*`表示库。例如，JPA存储库的自动配置是通过`JpaRepositoriesAutoConfiguration`完成的。
- en: 'Run the application with `--debug` to see the autoconfiguration report. The
    following command shows the autoconfiguration report for the `chapter2.boot-advanced`
    project:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`--debug`运行应用程序以查看自动配置报告。以下命令显示了`chapter2.boot-advanced`项目的自动配置报告：
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here are some examples of the autoconfiguration classes:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些自动配置类的示例：
- en: '`ServerPropertiesAutoConfiguration`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServerPropertiesAutoConfiguration`'
- en: '`RepositoryRestMvcAutoConfiguration`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RepositoryRestMvcAutoConfiguration`'
- en: '`JpaRepositoriesAutoConfiguration`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JpaRepositoriesAutoConfiguration`'
- en: '`JmsAutoConfiguration`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JmsAutoConfiguration`'
- en: 'It is possible to exclude the autoconfiguration of certain libraries if the
    application has special requirements and you want to get full control of the configurations.
    The following is an example of excluding `DataSourceAutoConfiguration`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序有特殊要求，并且您想完全控制配置，可以排除某些库的自动配置。以下是一个排除`DataSourceAutoConfiguration`的示例：
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Overriding default configuration values
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖默认配置值
- en: 'It is also possible to override default configuration values using the `application.properties`
    file. STS provides an easy-to-autocomplete, contextual help on `application.properties`,
    as shown in the following screenshot:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用`application.properties`文件覆盖默认配置值。STS提供了一个易于自动完成的上下文帮助`application.properties`，如下面的屏幕截图所示：
- en: '![Overriding default configuration values](img/B05447_02_15.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![覆盖默认配置值](img/B05447_02_15.jpg)'
- en: In the preceding screenshot, `server.port` is edited to be set as `9090`. Running
    this application again will start the server on port `9090`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，`server.port`被编辑为设置为`9090`。再次运行此应用程序将在端口`9090`上启动服务器。
- en: Changing the location of the configuration file
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改配置文件的位置
- en: 'In order to align with the Twelve-Factor app, configuration parameters need
    to be externalized from the code. Spring Boot externalizes all configurations
    into `application.properties`. However, it is still part of the application''s
    build. Furthermore, properties can be read from outside the package by setting
    the following properties:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与十二要素应用程序保持一致，配置参数需要从代码中外部化。Spring Boot将所有配置外部化到`application.properties`中。然而，它仍然是应用程序构建的一部分。此外，可以通过设置以下属性从包外部读取属性：
- en: '[PRE25]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, `spring.config.location` could be a local file location.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`spring.config.location`可以是本地文件位置。
- en: 'The following command starts the Spring Boot application with an externally
    provided configuration file:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令使用外部提供的配置文件启动Spring Boot应用程序：
- en: '[PRE26]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Reading custom properties
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取自定义属性
- en: At startup, `SpringApplication` loads all the properties and adds them to the
    Spring `Environment` class. Add a custom property to the `application.properties`
    file. In this case, the custom property is named `bootrest.customproperty`. Autowire
    the Spring `Environment` class into the `GreetingController` class. Edit the `GreetingController`
    class to read the custom property from `Environment` and add a log statement to
    print the custom property to the console.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动时，`SpringApplication`加载所有属性并将它们添加到Spring `Environment`类中。在`application.properties`文件中添加自定义属性。在这种情况下，自定义属性的名称为`bootrest.customproperty`。将Spring
    `Environment`类自动装配到`GreetingController`类中。编辑`GreetingController`类以从`Environment`中读取自定义属性，并添加日志语句以将自定义属性打印到控制台。
- en: 'Perform the following steps to do this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成此操作：
- en: 'Add the following property to the `application.properties` file:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`application.properties`文件中添加以下属性：
- en: '[PRE27]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, edit the `GreetingController` class as follows:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，编辑`GreetingController`类如下：
- en: '[PRE28]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Rerun the application. The log statement prints the custom variable in the
    console, as follows:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行应用程序。日志语句将在控制台中打印自定义变量，如下所示：
- en: '[PRE29]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using a .yaml file for configuration
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用.yaml文件进行配置
- en: As an alternate to `application.properties`, one may use a `.yaml` file. YAML
    provides a JSON-like structured configuration compared to the flat properties
    file.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`application.properties`的替代，可以使用`.yaml`文件。与平面属性文件相比，YAML提供了类似JSON的结构化配置。
- en: 'To see this in action, simply replace `application.properties` with `application.yaml`
    and add the following property:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此操作，请简单地将`application.properties`替换为`application.yaml`并添加以下属性：
- en: '[PRE30]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Rerun the application to see the port printed in the console.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行应用程序以查看端口在控制台中打印。
- en: Using multiple configuration profiles
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用多个配置文件。
- en: Furthermore, it is possible to have different profiles such as development,
    testing, staging, production, and so on. These are logical names. Using these,
    one can configure different values for the same properties for different environments.
    This is quite handy when running the Spring Boot application against different
    environments. In such cases, there is no rebuild required when moving from one
    environment to another.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可以有不同的配置文件，如开发、测试、暂存、生产等。这些是逻辑名称。使用这些，可以为不同的环境配置相同属性的不同值。当在不同环境中运行Spring
    Boot应用程序时，这非常方便。在这种情况下，从一个环境切换到另一个环境时不需要重新构建。
- en: 'Update the `.yaml` file as follows. The Spring Boot group profiles properties
    based on the dotted separator:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`.yaml`文件如下。Spring Boot根据点分隔符对配置文件进行分组：
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run the Spring Boot application as follows to see the use of profiles:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式运行Spring Boot应用程序以查看配置文件的使用：
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Active profiles can be specified programmatically using the `@ActiveProfiles`
    annotation, which is especially useful when running test cases, as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`@ActiveProfiles`注解以编程方式指定活动配置文件，这在运行测试用例时特别有用，如下所示：
- en: '[PRE33]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Other options to read properties
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取属性的其他选项
- en: 'The properties can be loaded in a number of ways, such as the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 可以以多种方式加载属性，例如以下方式：
- en: Command-line parameters `(-Dhost.port =9090`)
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行参数`(-Dhost.port =9090)`
- en: Operating system environment variables
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统环境变量
- en: JNDI (`java:comp/env`)
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JNDI (`java:comp/env`)
- en: Changing the default embedded web server
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改默认的嵌入式Web服务器
- en: 'Embedded HTTP listeners can easily be customized as follows. By default, Spring
    Boot supports Tomcat, Jetty, and Undertow. In the following example, Tomcat is
    replaced with Undertow:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式HTTP监听器可以轻松自定义如下。默认情况下，Spring Boot支持Tomcat、Jetty和Undertow。在以下示例中，Tomcat被替换为Undertow：
- en: '[PRE34]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Implementing Spring Boot security
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Spring Boot安全
- en: It is important to secure microservices. In this section, some basic measures
    to secure Spring Boot microservices will be reviewed using `chapter2.bootrest`
    to demonstrate the security features.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 保护微服务非常重要。在本节中，将审查一些保护Spring Boot微服务的基本措施，使用`chapter2.bootrest`来演示安全功能。
- en: Securing microservices with basic security
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用基本安全保护微服务
- en: 'Adding basic authentication to Spring Boot is pretty simple. Add the following
    dependency to `pom.xml`. This will include the necessary Spring security library
    files:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 向Spring Boot添加基本身份验证非常简单。将以下依赖项添加到`pom.xml`中。这将包括必要的Spring安全库文件：
- en: '[PRE35]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Open `Application.java` and add `@EnableGlobalMethodSecurity` to the `Application`
    class. This annotation will enable method-level security:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Application.java`并在`Application`类中添加`@EnableGlobalMethodSecurity`。此注解将启用方法级安全性：
- en: '[PRE36]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The default basic authentication assumes the user as being `user`. The default
    password will be printed in the console at startup. Alternately, the username
    and password can be added in `application.properties`, as shown here:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的基本身份验证假定用户为`user`。默认密码将在启动时打印在控制台上。或者，可以在`application.properties`中添加用户名和密码，如下所示：
- en: '[PRE37]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add a new test case in `ApplicationTests` to test the secure service results,
    as in the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ApplicationTests`中添加一个新的测试用例，测试安全服务的结果，如下所示：
- en: '[PRE38]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As shown in the code, a new `Authorization` request header with Base64 encoding
    the username-password string is created.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码所示，创建一个新的`Authorization`请求头，使用Base64编码用户名密码字符串。
- en: 'Rerun the application using Maven. Note that the new test case passed, but
    the old test case failed with an exception. The earlier test case now runs without
    credentials, and as a result, the server rejected the request with the following
    message:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Maven重新运行应用程序。请注意，新的测试用例通过了，但旧的测试用例出现了异常。早期的测试用例现在在没有凭据的情况下运行，结果服务器拒绝了请求，并显示以下消息：
- en: '[PRE39]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Securing a microservice with OAuth2
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用OAuth2保护微服务
- en: In this section, we will take a look at the basic Spring Boot configuration
    for OAuth2\. When a client application requires access to a protected resource,
    the client sends a request to an authorization server. The authorization server
    validates the request and provides an access token. This access token is validated
    for every client-to-server request. The request and response sent back and forth
    depends on the grant type.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一下OAuth2的基本Spring Boot配置。当客户端应用程序需要访问受保护的资源时，客户端向授权服务器发送请求。授权服务器验证请求并提供访问令牌。这个访问令牌对每个客户端到服务器的请求进行验证。来回发送的请求和响应取决于授权类型。
- en: Tip
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Read more about OAuth and grant types at [http://oauth.net](http://oauth.net).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在[http://oauth.net](http://oauth.net)阅读有关OAuth和授权类型的更多信息。
- en: 'The resource owner password credentials grant approach will be used in this
    example:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中将使用资源所有者密码凭据授权方法：
- en: '![Securing a microservice with OAuth2](img/B05447_02_16.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![使用OAuth2保护微服务](img/B05447_02_16.jpg)'
- en: In this case, as shown in the preceding diagram, the resource owner provides
    the client with a username and password. The client then sends a token request
    to the authorization server by providing the credential information. The authorization
    server authorizes the client and returns with an access token. On every subsequent
    request, the server validates the client token.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如前图所示，资源所有者提供客户端用户名和密码。然后客户端通过提供凭据信息向授权服务器发送令牌请求。授权服务器授权客户端并返回访问令牌。在每个后续请求中，服务器验证客户端令牌。
- en: 'To implement OAuth2 in our example, perform the following steps:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的示例中实现OAuth2，请执行以下步骤：
- en: 'As a first step, update `pom.xml` with the OAuth2 dependency, as follows:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，按照以下步骤更新`pom.xml`以添加OAuth2依赖：
- en: '[PRE40]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Next, add two new annotations, `@EnableAuthorizationServer` and `@EnableResourceServer`,
    to the `Application.java` file. The `@EnableAuthorizationServer` annotation creates
    an authorization server with an in-memory repository to store client tokens and
    provide clients with a username, password, client ID, and secret. The `@EnableResourceServer`
    annotation is used to access the tokens. This enables a spring security filter
    that is authenticated via an incoming OAuth2 token.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`Application.java`文件中添加两个新的注释`@EnableAuthorizationServer`和`@EnableResourceServer`。`@EnableAuthorizationServer`注释创建一个授权服务器，其中包含一个内存存储库，用于存储客户端令牌并为客户端提供用户名、密码、客户端ID和密钥。`@EnableResourceServer`注释用于访问令牌。这将启用一个通过传入的OAuth2令牌进行身份验证的Spring安全过滤器。
- en: 'In our example, both the authorization server and resource server are the same.
    However, in practice, these two will run separately. Take a look at the following
    code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，授权服务器和资源服务器是相同的。然而，在实践中，这两者将分开运行。看一下以下代码：
- en: '[PRE41]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Add the following properties to the `application.properties` file:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下属性添加到`application.properties`文件中：
- en: '[PRE42]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, add another test case to test OAuth2, as follows:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加另一个测试用例来测试OAuth2，如下所示：
- en: '[PRE43]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As shown in the preceding code, a special REST template, `OAuth2RestTemplate`,
    is created by passing the resource details encapsulated in a resource details
    object. This REST template handles the OAuth2 processes underneath. The access
    token URI is the endpoint for the token access.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，通过传递封装在资源详细信息对象中的资源详细信息来创建一个特殊的REST模板`OAuth2RestTemplate`。这个REST模板在OAuth2过程中处理访问令牌。访问令牌URI是令牌访问的端点。
- en: Rerun the application using `mvn install`. The first two test cases will fail,
    and the new one will succeed. This is because the server only accepts OAuth2-enabled
    requests.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`mvn install`重新运行应用程序。前两个测试用例将失败，而新的测试用例将成功。这是因为服务器只接受启用了OAuth2的请求。
- en: These are quick configurations provided by Spring Boot out of the box but are
    not good enough to be production grade. We may need to customize `ResourceServerConfigurer`
    and `AuthorizationServerConfigurer` to make them production-ready. This notwithstanding,
    the approach remains the same.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是Spring Boot开箱即用提供的快速配置，但不足以达到生产级别。我们可能需要定制`ResourceServerConfigurer`和`AuthorizationServerConfigurer`使其达到生产就绪。尽管如此，方法仍然是一样的。
- en: Enabling cross-origin access for microservices
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为微服务启用跨源访问
- en: Browsers are generally restricted when client-side web applications running
    from one origin request data from another origin. Enabling cross-origin access
    is generally termed as **CORS** (**Cross-Origin Resource Sharing**).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当来自一个来源的客户端端网页应用程序从另一个来源请求数据时，通常会受到限制。启用跨源访问通常被称为**CORS**（**跨源资源共享**）。
- en: '![Enabling cross-origin access for microservices](img/B05447_02_17.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![为微服务启用跨源访问](img/B05447_02_17.jpg)'
- en: This example shows how to enable cross-origin requests. With microservices,
    as each service runs with its own origin, it will easily get into the issue of
    a client-side web application consuming data from multiple origins. For instance,
    a scenario where a browser client accessing Customer from the Customer microservice
    and Order History from the Order microservices is very common in the microservices
    world.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例显示了如何启用跨源请求。对于微服务来说，由于每个服务都有自己的来源，很容易出现客户端端网页应用程序从多个来源消费数据的问题。例如，浏览器客户端访问来自Customer微服务的Customer和来自Order微服务的Order
    History的情况在微服务世界中非常常见。
- en: 'Spring Boot provides a simple declarative approach to enabling cross-origin
    requests. The following example shows how to enable a microservice to enable cross-origin
    requests:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot提供了一种简单的声明性方法来启用跨源请求。以下示例显示了如何启用微服务以启用跨源请求：
- en: '[PRE44]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'By default, all the origins and headers are accepted. We can further customize
    the cross-origin annotations by giving access to specific origins, as follows.
    The `@CrossOrigin` annotation enables a method or class to accept cross-origin
    requests:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有的来源和标头都被接受。我们可以通过给予特定来源访问的方式进一步定制跨源注释。`@CrossOrigin`注释使方法或类能够接受跨源请求：
- en: '[PRE45]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Global CORS can be enabled using the `WebMvcConfigurer` bean and customizing
    the `addCorsMappings(CorsRegistry registry)` method.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`WebMvcConfigurer` bean并定制`addCorsMappings(CorsRegistry registry)`方法来启用全局CORS。
- en: Implementing Spring Boot messaging
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Spring Boot消息传递
- en: 'In an ideal case, all microservice interactions are expected to happen asynchronously
    using publish-subscribe semantics. Spring Boot provides a hassle-free mechanism
    to configure messaging solutions:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想情况下，所有微服务之间的交互都应该使用发布-订阅语义进行异步处理。Spring Boot提供了一种无忧的机制来配置消息传递解决方案：
- en: '![Implementing Spring Boot messaging](img/B05447_02_18.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![实现Spring Boot消息传递](img/B05447_02_18.jpg)'
- en: 'In this example, we will create a Spring Boot application with a sender and
    receiver, both connected though an external queue. Perform the following steps:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个带有发送者和接收者的Spring Boot应用程序，它们都通过一个外部队列连接。执行以下步骤：
- en: Note
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The full source code of this example is available as the `chapter2.bootmessaging`
    project in the code files of this book.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的完整源代码可以在本书的代码文件中的`chapter2.bootmessaging`项目中找到。
- en: Create a new project using STS to demonstrate this capability. In this example,
    instead of selecting **Web**, select **AMQP** under **I/O**:![Implementing Spring
    Boot messaging](img/B05447_02_19.jpg)
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用STS创建一个新项目来演示这个功能。在这个例子中，不要选择**Web**，而是在**I/O**下选择**AMQP**：![实现Spring Boot消息传递](img/B05447_02_19.jpg)
- en: Rabbit MQ will also be needed for this example. Download and install the latest
    version of Rabbit MQ from [https://www.rabbitmq.com/download.html](https://www.rabbitmq.com/download.html).
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个例子也需要Rabbit MQ。从[https://www.rabbitmq.com/download.html](https://www.rabbitmq.com/download.html)下载并安装最新版本的Rabbit
    MQ。
- en: Rabbit MQ 3.5.6 is used in this book.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中使用的是Rabbit MQ 3.5.6。
- en: 'Follow the installation steps documented on the site. Once ready, start the
    RabbitMQ server via the following command:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照网站上记录的安装步骤进行操作。准备就绪后，通过以下命令启动RabbitMQ服务器：
- en: '[PRE46]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Make the configuration changes to the `application.properties` file to reflect
    the RabbitMQ configuration. The following configuration uses the default port,
    username, and password of RabbitMQ:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`application.properties`文件进行配置更改，以反映RabbitMQ的配置。以下配置使用RabbitMQ的默认端口、用户名和密码：
- en: '[PRE47]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Add a message sender component and a queue named `TestQ` of the `org.springframework.amqp.core.Queue`
    type to the `Application.java` file under `src/main/java`. `RabbitMessagingTemplate`
    is a convenient way to send messages, which will abstract all the messaging semantics.
    Spring Boot provides all boilerplate configurations to send messages:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/main/java`目录下的`Application.java`文件中添加一个消息发送组件和一个`org.springframework.amqp.core.Queue`类型的名为`TestQ`的队列。`RabbitMessagingTemplate`是发送消息的一种便捷方式，它将抽象出所有的消息语义。Spring
    Boot提供了所有的样板配置来发送消息：
- en: '[PRE48]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To receive the message, all that needs to be used is a `@RabbitListener` annotation.
    Spring Boot autoconfigures all the required boilerplate configurations:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要接收消息，只需要使用`@RabbitListener`注解。Spring Boot会自动配置所有必需的样板配置：
- en: '[PRE49]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The last piece of this exercise is to wire the sender to our main application
    and implement the `run` method of `CommandLineRunner` to initiate the message
    sending. When the application is initialized, it invokes the `run` method of `CommandLineRunner`,
    as follows:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个练习的最后一部分是将发送者连接到我们的主应用程序，并实现`CommandLineRunner`的`run`方法来启动消息发送。当应用程序初始化时，它会调用`CommandLineRunner`的`run`方法，如下所示：
- en: '[PRE50]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Run the application as a Spring Boot application and verify the output. The
    following message will be printed in the console:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用程序作为Spring Boot应用程序运行并验证输出。以下消息将打印在控制台上：
- en: '[PRE51]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Developing a comprehensive microservice example
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发全面的微服务示例
- en: So far, the examples we have considered are no more than just a simple "Hello
    world." Putting together what we have learned, this section demonstrates an end-to-end
    Customer Profile microservice implementation. The Customer Profile microservices
    will demonstrate interaction between different microservices. It also demonstrates
    microservices with business logic and primitive data stores.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们考虑的例子不过是一个简单的“Hello world”。结合我们所学到的知识，本节演示了一个端到端的Customer Profile微服务实现。Customer
    Profile微服务将展示不同微服务之间的交互。它还演示了具有业务逻辑和基本数据存储的微服务。
- en: 'In this example, two microservices, the Customer Profile and Customer Notification
    services, will be developed:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，将开发两个微服务，Customer Profile和Customer Notification服务：
- en: '![Developing a comprehensive microservice example](img/B05447_02_20.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![开发全面的微服务示例](img/B05447_02_20.jpg)'
- en: As shown in the diagram, the Customer Profile microservice exposes methods to
    **create, read, update, and delete** (**CRUD**) a customer and a registration
    service to register a customer. The registration process applies certain business
    logic, saves the customer profile, and sends a message to the Customer Notification
    microservice. The Customer Notification microservice accepts the message sent
    by the registration service and sends an e-mail message to the customer using
    an SMTP server. Asynchronous messaging is used to integrate Customer Profile with
    the Customer Notification service.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，Customer Profile微服务公开了用于**创建、读取、更新和删除**（CRUD）客户以及用于注册客户的注册服务的方法。注册过程应用了某些业务逻辑，保存了客户资料，并向Customer
    Notification微服务发送了一条消息。Customer Notification微服务接受了注册服务发送的消息，并使用SMTP服务器向客户发送了一封电子邮件。异步消息传递用于将Customer
    Profile与Customer Notification服务集成起来。
- en: 'The Customer microservices class domain model diagram is as shown here:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: Customer微服务类的领域模型图如下所示：
- en: '![Developing a comprehensive microservice example](img/B05447_02_21.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![开发全面的微服务示例](img/B05447_02_21.jpg)'
- en: '`CustomerController` in the diagram is the REST endpoint, which invokes a component
    class, `CustomerComponent`. The component class/bean handles all the business
    logic. `CustomerRepository` is a Spring data JPA repository defined to handle
    the persistence of the `Customer` entity.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomerController`在图中是REST端点，调用一个组件类`CustomerComponent`。组件类/bean处理所有业务逻辑。`CustomerRepository`是一个Spring
    data JPA repository，用于处理`Customer`实体的持久化。'
- en: Note
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The full source code of this example is available as the `chapter2.bootcustomer`
    and `chapter2.bootcustomernotification` projects in the code files of this book.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的完整源代码可作为本书代码文件中的`chapter2.bootcustomer`和`chapter2.bootcustomernotification`项目获得。
- en: Create a new Spring Boot project and call it `chapter2.bootcustomer`, the same
    way as earlier. Select the options as in the following screenshot in the starter
    module selection screen:![Developing a comprehensive microservice example](img/B05447_02_22.jpg)
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Spring Boot项目，并将其命名为`chapter2.bootcustomer`，与之前的方式相同。在启动模块选择屏幕中选择如下屏幕截图中的选项：![开发全面的微服务示例](img/B05447_02_22.jpg)
- en: This will create a web project with JPA, the REST repository, and H2 as a database.
    H2 is a tiny in-memory embedded database with which it is easy to demonstrate
    database features. In the real world, it is recommended to use an appropriate
    enterprise-grade database. This example uses JPA to define persistence entities
    and the REST repository to expose REST-based repository services.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个带有JPA、REST存储库和H2作为数据库的Web项目。H2是一个微型的内存嵌入式数据库，可以轻松演示数据库功能。在现实世界中，建议使用适当的企业级数据库。此示例使用JPA定义持久性实体和REST存储库来公开基于REST的存储库服务。
- en: 'The project structure will be similar to the following screenshot:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 项目结构将类似于以下屏幕截图：
- en: '![Developing a comprehensive microservice example](img/B05447_02_24.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![开发全面的微服务示例](img/B05447_02_24.jpg)'
- en: 'Start building the application by adding an Entity class named `Customer`.
    For simplicity, there are only three fields added to the `Customer` Entity class:
    the autogenerated `id` field, `name`, and `email`. Take a look at the following
    code:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加名为`Customer`的实体类来开始构建应用程序。为简单起见，`Customer`实体类只添加了三个字段：自动生成的`id`字段，`name`和`email`。看一下以下代码：
- en: '[PRE52]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Add a repository class to handle the persistence handling of Customer. `CustomerRepository`
    extends the standard JPA repository. This means that all CRUD methods and default
    finder methods are automatically implemented by the Spring Data JPA repository,
    as follows:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个存储库类来处理客户的持久化处理。`CustomerRepository`扩展了标准的JPA存储库。这意味着所有CRUD方法和默认查找方法都由Spring
    Data JPA存储库自动实现，如下所示：
- en: '[PRE53]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this example, we added a new method to the repository class, `findByName`,
    which essentially searches the customer based on the customer name and returns
    a `Customer` object if there is a matching name.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们向存储库类添加了一个新的方法`findByName`，它基本上根据客户名称搜索客户，并在有匹配名称时返回`Customer`对象。
- en: The `@RepositoryRestResource` annotation enables the repository access through
    RESTful services. This will also enable HATEOAS and HAL by default. As for CRUD
    methods there is no additional business logic required, we will leave it as it
    is without controller or component classes. Using HATEOAS will help us navigate
    through Customer Repository methods effortlessly.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@RepositoryRestResource`注解通过RESTful服务启用存储库访问。这也将默认启用HATEOAS和HAL。由于CRUD方法不需要额外的业务逻辑，我们将其保留为没有控制器或组件类的状态。使用HATEOAS将帮助我们轻松地浏览客户存储库方法。'
- en: Note that there is no configuration added anywhere to point to any database.
    As H2 libraries are in the class path, all the configuration is done by default
    by Spring Boot based on the H2 autoconfiguration.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，没有在任何地方添加配置来指向任何数据库。由于H2库在类路径中，所有配置都是由Spring Boot根据H2自动配置默认完成的。
- en: 'Update the `Application.java` file by adding `CommandLineRunner` to initialize
    the repository with some customer records, as follows:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加`CommandLineRunner`来初始化存储库并插入一些客户记录，更新`Application.java`文件，如下所示：
- en: '[PRE54]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`CommandLineRunner`, defined as a bean, indicates that it should run when it
    is contained in `SpringApplication`. This will insert six sample customer records
    into the database at startup.'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CommandLineRunner`被定义为一个bean，表示当它包含在`SpringApplication`中时应该运行。这将在启动时向数据库插入六个样本客户记录。'
- en: At this point, run the application as Spring Boot App. Open the HAL browser
    and point the browser to `http://localhost:8080`.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，将应用程序作为Spring Boot应用程序运行。打开HAL浏览器，并将浏览器指向`http://localhost:8080`。
- en: In the **Explorer** section, point to `http://localhost:8080/customers` and
    click on **Go**. This will list all the customers in the **Response Body** section
    of the HAL browser.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**资源管理器**部分，指向`http://localhost:8080/customers`，然后点击**Go**。这将在HAL浏览器的**响应主体**部分列出所有客户。
- en: In the **Explorer** section, enter `http://localhost:8080/customers?size=2&page=1&sort=name`
    and click on **Go**. This will automatically execute paging and sorting on the
    repository and return the result.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**资源管理器**部分，输入`http://localhost:8080/customers?size=2&page=1&sort=name`，然后点击**Go**。这将自动在存储库上执行分页和排序，并返回结果。
- en: As the page size is set to `2` and the first page is requested, it will come
    back with two records in a sorted order.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 由于页面大小设置为`2`，并且请求了第一页，它将以排序顺序返回两条记录。
- en: Review the **Links** section. As shown in the following screenshot, it will
    facilitate navigating **first**, **next**, **prev**, and **last**. These are done
    using the HATEOAS links automatically generated by the repository browser:![Developing
    a comprehensive microservice example](img/B05447_02_23.jpg)
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看**链接**部分。如下屏幕截图所示，它将方便地导航**first**，**next**，**prev**和**last**。这些是通过存储库浏览器自动生成的HATEOAS链接完成的：![开发全面的微服务示例](img/B05447_02_23.jpg)
- en: Also, one can explore the details of a customer by selecting the appropriate
    link, such as `http://localhost:8080/customers/2`.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还可以通过选择适当的链接，如`http://localhost:8080/customers/2`，来探索客户的详细信息。
- en: 'As the next step, add a controller class, `CustomerController`, to handle service
    endpoints. There is only one endpoint in this class, `/register`, which is used
    to register a customer. If successful, it returns the `Customer` object as the
    response, as follows:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为下一步，添加一个控制器类`CustomerController`来处理服务端点。在这个类中只有一个端点`/register`，用于注册客户。如果成功，它将返回`Customer`对象作为响应，如下所示：
- en: '[PRE55]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'A `CustomerRegistrar` component is added to handle the business logic. In this
    case, there is only minimal business logic added to the component. In this component
    class, while registering a customer, we will just check whether the customer name
    already exists in the database or not. If it does not exist, then we will insert
    a new record, and otherwise, we will send an error message back, as follows:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加了一个`CustomerRegistrar`组件来处理业务逻辑。在这种情况下，组件中只添加了最少的业务逻辑。在这个组件类中，注册客户时，我们只会检查数据库中是否已经存在客户名称。如果不存在，我们将插入一个新记录，否则，我们将发送一个错误消息，如下所示：
- en: '[PRE56]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Restart the Boot application and test using the HAL browser via the URL `http://localhost:8080`.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动Boot应用程序，并通过URL `http://localhost:8080` 使用HAL浏览器进行测试。
- en: Point the **Explorer** field to `http://localhost:8080/customers`. Review the
    results in the **Links** section:![Developing a comprehensive microservice example](img/B05447_02_25.jpg)
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Explorer**字段指向`http://localhost:8080/customers`。在**Links**部分查看结果：![开发全面的微服务示例](img/B05447_02_25.jpg)
- en: Click on the **NON-GET** option against **self**. This will open a form to create
    a new customer:![Developing a comprehensive microservice example](img/B05447_02_26.jpg)
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**self**旁边的**NON-GET**选项。这将打开一个表单来创建一个新的客户：![开发全面的微服务示例](img/B05447_02_26.jpg)
- en: Fill the form and change the **Action** as shown in the diagram. Click on the
    **Make Request** button. This will call the register service and register the
    customer. Try giving a duplicate name to test the negative case.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写表格，并按照图中所示更改**操作**。点击**发出请求**按钮。这将调用注册服务并注册客户。尝试给出重复的名称以测试负面情况。
- en: Let's complete the last part in the example by integrating the Customer Notification
    service to notify the customer. When registration is successful, send an e-mail
    to the customer by asynchronously calling the Customer Notification microservice.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过将客户通知服务集成到通知客户的示例的最后部分来完成示例。当注册成功时，通过异步调用客户通知微服务向客户发送电子邮件。
- en: 'First update `CustomerRegistrar` to call the second service. This is done through
    messaging. In this case, we injected a `Sender` component to send a notification
    to the customer by passing the customer''s e-mail address to the sender, as follows:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先更新`CustomerRegistrar`以调用第二个服务。这是通过消息传递完成的。在这种情况下，我们注入了一个`Sender`组件，通过将客户的电子邮件地址传递给发送者，向客户发送通知，如下所示：
- en: '[PRE57]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The sender component will be based on RabbitMQ and AMQP. In this example, `RabbitMessagingTemplate`
    is used as explored in the last messaging example; take a look at the following:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送者组件将基于RabbitMQ和AMQP。在本例中，`RabbitMessagingTemplate`被用作上一个消息示例中所探讨的方式；请看以下内容：
- en: '[PRE58]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `@Lazy` annotation is a useful one and it helps to increase the boot startup
    time. These beans will be initialized only when the need arises.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Lazy`注解是一个有用的注解，它有助于增加启动时间。这些bean只有在需要时才会被初始化。'
- en: 'We will also update the `application.property` file to include Rabbit MQ-related
    properties, as follows:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将更新`application.property`文件，以包括与Rabbit MQ相关的属性，如下所示：
- en: '[PRE59]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We are ready to send the message. To consume the message and send e-mails, we
    will create a notification service. For this, let's create another Spring Boot
    service, `chapter2.bootcustomernotification`. Make sure that the **AMQP** and
    **Mail** starter libraries are selected when creating the Spring Boot service.
    Both **AMQP** and **Mail** are under **I/O**.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们准备发送消息。为了消费消息并发送电子邮件，我们将创建一个通知服务。为此，让我们创建另一个Spring Boot服务，`chapter2.bootcustomernotification`。在创建Spring
    Boot服务时，请确保选择了**AMQP**和**Mail**启动器库。**AMQP**和**Mail**都在**I/O**下。
- en: The package structure of the `chapter2.bootcustomernotification` project is
    as shown here:![Developing a comprehensive microservice example](img/B05447_02_27.jpg)
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`chapter2.bootcustomernotification`项目的包结构如下所示：![开发全面的微服务示例](img/B05447_02_27.jpg)'
- en: 'Add a `Receiver` class. The `Receiver` class waits for a message on customer.
    This will receive a message sent by the Customer Profile service. On the arrival
    of a message, it sends an e-mail, as follows:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`Receiver`类。`Receiver`类等待客户端的消息。这将接收客户资料服务发送的消息。在收到消息时，它会发送一封电子邮件，如下所示：
- en: '[PRE60]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Add another component to send an e-mail to the customer. We will use `JavaMailSender`
    to send an e-mail via the following code:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个组件来向客户发送电子邮件。我们将使用`JavaMailSender`通过以下代码发送电子邮件：
- en: '[PRE61]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Behind the scenes, Spring Boot automatically configures all the parameters required
    by `JavaMailSender`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，Spring Boot会自动配置`JavaMailSender`所需的所有参数。
- en: To test SMTP, a test setup for SMTP is required to ensure that the mails are
    going out. In this example, FakeSMTP will be used. You can download FakeSMTP from
    [http://nilhcem.github.io/FakeSMTP](http://nilhcem.github.io/FakeSMTP).
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试SMTP，需要一个SMTP的测试设置来确保邮件发送出去。在本例中，将使用FakeSMTP。您可以从[http://nilhcem.github.io/FakeSMTP](http://nilhcem.github.io/FakeSMTP)下载FakeSMTP。
- en: 'Once you download `fakeSMTP-2.0.jar`, run the SMTP server by executing the
    following command:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载`fakeSMTP-2.0.jar`后，通过执行以下命令运行SMTP服务器：
- en: '[PRE62]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This will open a GUI to monitor e-mail messages. Click on the **Start Server**
    button next to the listening port textbox.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开一个GUI来监视电子邮件消息。点击监听端口文本框旁边的**启动服务器**按钮。
- en: 'Update `application.properties` with the following configuration parameters
    to connect to RabbitMQ as well as to the mail server:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下配置参数更新`application.properties`以连接到RabbitMQ以及邮件服务器：
- en: '[PRE63]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We are ready to test our microservices end to end. Start both the Spring Boot
    apps. Open the browser and repeat the customer creation steps through the HAL
    browser. In this case, immediately after submitting the request, we will be able
    to see the e-mail in the SMTP GUI.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们准备测试我们的微服务端到端。启动两个Spring Boot应用程序。打开浏览器，并通过HAL浏览器重复客户端创建步骤。在这种情况下，提交请求后，我们将能够在SMTP
    GUI中看到电子邮件。
- en: 'Internally, the Customer Profile service asynchronously calls the Customer
    Notification service, which, in turn, sends the e-mail message to the SMTP server:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，客户资料服务异步调用客户通知服务，后者又将电子邮件消息发送到SMTP服务器：
- en: '![Developing a comprehensive microservice example](img/B05447_02_28.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![开发一个全面的微服务示例](img/B05447_02_28.jpg)'
- en: Spring Boot actuators
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot actuator
- en: The previous sections explored most of the Spring Boot features required to
    develop a microservice. In this section, some of the production-ready operational
    aspects of Spring Boot will be explored.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的部分探讨了开发微服务所需的大部分Spring Boot功能。在本节中，将探讨Spring Boot的一些适用于生产的操作方面。
- en: 'Spring Boot actuators provide an excellent out-of-the-box mechanism to monitor
    and manage Spring Boot applications in production:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot actuator提供了一个出色的开箱即用的机制，用于监控和管理生产中的Spring Boot应用程序：
- en: Note
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The full source code of this example is available as the `chapter2.bootactuator`
    project in the code files of this book.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的完整源代码可在本书的代码文件中的`chapter2.bootactuator`项目中找到。
- en: Create another **Spring Starter Project** and name it `chapter2.bootactuator`.
    This time, select **Web** and **Actuators** under **Ops**. Similar to the `chapter2.bootrest`
    project, add a `GreeterController` endpoint with the `greet` method.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个**Spring Starter Project**，命名为`chapter2.bootactuator`。这次，在**Ops**下选择**Web**和**Actuators**。与`chapter2.bootrest`项目类似，添加一个带有`greet`方法的`GreeterController`端点。
- en: Start the application as Spring Boot app.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动应用程序作为Spring Boot应用程序。
- en: Point the browser to `localhost:8080/actuator`. This will open the HAL browser.
    Then, review the **Links** section.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将浏览器指向`localhost:8080/actuator`。这将打开HAL浏览器。然后，查看**Links**部分。
- en: 'A number of links are available under the **Links** section. These are automatically
    exposed by the Spring Boot actuator:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Links**部分下有许多链接可用。这些链接是由Spring Boot actuator自动公开的：
- en: '![Spring Boot actuators](img/B05447_02_29.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![Spring Boot actuator](img/B05447_02_29.jpg)'
- en: 'Some of the important links are listed as follows:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 一些重要的链接列举如下：
- en: '`dump`: This performs a thread dump and displays the result'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dump`：执行线程转储并显示结果'
- en: '`mappings`: This lists all the HTTP request mappings'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mappings`：列出所有HTTP请求映射'
- en: '`info`: This displays information about the application'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info`：显示有关应用程序的信息'
- en: '`health`: This displays the application''s health conditions'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`health`：显示应用程序的健康状况'
- en: '`autoconfig`: This displays the autoconfiguration report'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`autoconfig`：显示自动配置报告'
- en: '`metrics`: This shows different metrics collected from the application'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metrics`：显示从应用程序收集的不同指标'
- en: Monitoring using JConsole
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JConsole进行监控
- en: 'Alternately, we can use the JMX console to see the Spring Boot information.
    Connect to the remote Spring Boot instance from JConsole. The Boot information
    will be shown as follows:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用JMX控制台查看Spring Boot信息。从JConsole连接到远程Spring Boot实例。Boot信息将显示如下：
- en: '![Monitoring using JConsole](img/B05447_02_30.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![使用JConsole进行监控](img/B05447_02_30.jpg)'
- en: Monitoring using SSH
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用SSH进行监控
- en: 'Spring Boot provides remote access to the Boot application using SSH. The following
    command connects to the Spring Boot application from a terminal window:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot提供了使用SSH远程访问Boot应用程序的功能。以下命令从终端窗口连接到Spring Boot应用程序：
- en: '[PRE64]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The password can be customized by adding the `shell.auth.simple.user.password`
    property in the `application.properties` file. The updated `application.properties`
    file will look similar to the following:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在`application.properties`文件中添加`shell.auth.simple.user.password`属性来自定义密码。更新后的`application.properties`文件将类似于以下内容：
- en: '[PRE65]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'When connected with the preceding command, similar actuator information can
    be accessed. Here is an example of the metrics information accessed through the
    CLI:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的命令连接时，可以访问类似的actuator信息。以下是通过CLI访问的指标信息示例：
- en: '`help`: This lists out all the options available'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`help`：列出所有可用选项'
- en: '`dashboard`: This is one interesting feature that shows a lot of system-level
    information'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dashboard`：这是一个显示大量系统级信息的有趣功能'
- en: Configuring application information
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置应用程序信息
- en: 'The following properties can be set in `application.properties` to customize
    application-related information. After adding, restart the server and visit the
    `/info` endpoint of the actuator to take a look at the updated information, as
    follows:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在`application.properties`中设置以下属性来自定义与应用程序相关的信息。添加后，重新启动服务器并访问actuator的`/info`端点以查看更新后的信息，如下所示：
- en: '[PRE66]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Adding a custom health module
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加自定义健康模块
- en: Adding a new custom module to the Spring Boot application is not so complex.
    To demonstrate this feature, assume that if a service gets more than two transactions
    in a minute, then the server status will be set as Out of Service.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 向Spring Boot应用程序添加新的自定义模块并不复杂。为了演示这一特性，假设如果一个服务在一分钟内获得超过两个事务，那么服务器状态将被设置为服务外。
- en: 'In order to customize this, we have to implement the `HealthIndicator` interface
    and override the `health` method. The following is a quick and dirty implementation
    to do the job:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自定义这一点，我们必须实现`HealthIndicator`接口并重写`health`方法。以下是一个快速而简单的实现来完成这项工作：
- en: '[PRE67]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The preceding class is a simple POJO class that maintains the transaction counts
    in the window. The `isWeak` method checks whether the transaction in a particular
    window reached its threshold. The `isExpired` method checks whether the current
    window is expired or not. The `increment` method simply increases the counter
    value.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 上述类是一个简单的POJO类，用于在窗口中维护事务计数。`isWeak`方法检查特定窗口中的事务是否达到了其阈值。`isExpired`方法检查当前窗口是否已过期。`increment`方法简单地增加计数器值。
- en: 'For the next step, implement our custom health indicator class, `TPSHealth`.
    This is done by extending `HealthIndicator`, as follows:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，实现我们的自定义健康指示器类`TPSHealth`。通过扩展`HealthIndicator`来完成：
- en: '[PRE68]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `health` method checks whether the counter is weak or not. A weak counter
    means the service is handling more transactions than it can handle. If it is weak,
    it marks the instance as Out of Service.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`health`方法检查计数器是否弱。弱计数器意味着服务处理的事务比其可以处理的要多。如果它是弱的，它将把实例标记为服务外。'
- en: 'Finally, we will autowire `TPSHealth` into the `GreetingController` class and
    then call `health.updateTx()` in the `greet` method, as follows:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将把`TPSHealth`自动装配到`GreetingController`类中，然后在`greet`方法中调用`health.updateTx()`，如下所示：
- en: '[PRE69]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Go to the `/health` end point in the HAL browser and take a look at the status
    of the server.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 转到HAL浏览器中的`/health`端点，并查看服务器的状态。
- en: Now, open another browser, point to `http://localhost:8080`, and fire the service
    twice or thrice. Go back to the `/health` endpoint and refresh to see the status.
    It should be changed to Out of Service.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开另一个浏览器，指向`http://localhost:8080`，并多次调用服务。返回`/health`端点并刷新以查看状态。它应该更改为服务外。
- en: In this example, as there is no action taken other than collecting the health
    status, even though the status is Out of Service, new service calls will still
    go through. However, in the real world, a program should read the `/health` endpoint
    and block further requests from going to this instance.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，除了收集健康状态之外，没有采取其他行动，即使状态为服务外，新的服务调用仍将继续。但是，在现实世界中，程序应读取`/health`端点并阻止进一步的请求发送到此实例。
- en: Building custom metrics
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建自定义指标
- en: 'Similar to health, customization of the metrics is also possible. The following
    example shows how to add counter service and gauge service, just for demonstration
    purposes:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于健康状况，还可以自定义指标。以下示例显示了如何添加计数器服务和计量器服务，仅用于演示目的：
- en: '[PRE70]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Add the following methods in the greet method:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在问候方法中添加以下方法：
- en: '[PRE71]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Restart the server and go to `/metrics` to see the new gauge and counter added
    already reflected there.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动服务器，转到`/metrics`以查看已添加的新计量器和计数器是否已反映在其中。
- en: Documenting microservices
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录微服务
- en: The traditional approach of API documentation is either by writing service specification
    documents or using static service registries. With a large number of microservices,
    it would be hard to keep the documentation of APIs in sync.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的API文档方法是编写服务规范文档或使用静态服务注册表。对于大量的微服务，很难保持API文档的同步。
- en: Microservices can be documented in many ways. This section will explore how
    microservices can be documented using the popular Swagger framework. The following
    example will use Springfox libraries to generate REST API documentation. Springfox
    is a set of Java- and Spring-friendly libraries.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务可以用许多方式记录。本节将探讨如何使用流行的Swagger框架记录微服务。以下示例将使用Springfox库生成REST API文档。Springfox是一组Java和Spring友好的库。
- en: Create a new **Spring Starter Project** and select **Web** in the library selection
    window. Name the project `chapter2.swagger`.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的**Spring Starter Project**，并在库选择窗口中选择**Web**。将项目命名为`chapter2.swagger`。
- en: Note
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The full source code of this example is available as the `chapter2.swagger`
    project in the code files of this book.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的完整源代码可在本书的代码文件中的`chapter2.swagger`项目中找到。
- en: 'As Springfox libraries are not part of the Spring suite, edit `pom.xml` and
    add Springfox Swagger library dependencies. Add the following dependencies to
    the project:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Springfox库不是Spring套件的一部分，请编辑`pom.xml`并添加Springfox Swagger库依赖项。将以下依赖项添加到项目中：
- en: '[PRE72]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Create a REST service similar to the services created earlier, but also add
    the `@EnableSwagger2` annotation, as follows:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个类似于之前创建的服务的REST服务，但还要添加`@EnableSwagger2`注释，如下所示：
- en: '[PRE73]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This is all that''s required for a basic Swagger documentation. Start the application
    and point the browser to `http://localhost:8080/swagger-ui.html`. This will open
    the Swagger API documentation page:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是基本的Swagger文档所需的全部内容。启动应用程序，并将浏览器指向`http://localhost:8080/swagger-ui.html`。这将打开Swagger
    API文档页面：
- en: '![Documenting microservices](img/B05447_02_31.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![记录微服务](img/B05447_02_31.jpg)'
- en: As shown in the diagram, the Swagger lists out the possible operations on **Greet
    Controller**. Click on the **GET** operation. This expands the **GET** row, which
    provides an option to try out the operation.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，Swagger列出了**问候控制器**上可能的操作。单击**GET**操作。这将展开**GET**行，提供尝试操作的选项。
- en: Summary
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about Spring Boot and its key features to build
    production-ready applications.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了Spring Boot及其构建生产就绪应用程序的关键功能。
- en: We explored the previous-generation web applications and then how Spring Boot
    makes developers' lives easier to develop fully qualified microservices. We also
    discussed the asynchronous message-based interaction between services. Further,
    we explored how to achieve some of the key capabilities required for microservices,
    such as security, HATEOAS, cross-origin, configurations, and so on with practical
    examples. We also took a look at how Spring Boot actuators help the operations
    teams and also how we can customize it to our needs. Finally, documenting microservices
    APIs was also explored.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了上一代Web应用程序，以及Spring Boot如何使开发人员更容易开发完全合格的微服务。我们还讨论了服务之间的异步基于消息的交互。此外，我们探讨了如何通过实际示例实现微服务所需的一些关键功能，例如安全性、HATEOAS、跨源、配置等。我们还看了Spring
    Boot执行器如何帮助运营团队，以及如何根据需要自定义它。最后，还探讨了记录微服务API。
- en: In the next chapter, we will take a deeper look at some of the practical issues
    that may arise when implementing microservices. We will also discuss a capability
    model that essentially helps organizations when dealing with large microservices
    implementations.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地研究在实施微服务时可能出现的一些实际问题。我们还将讨论一个能力模型，该模型在处理大型微服务实施时对组织有所帮助。
