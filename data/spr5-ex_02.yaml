- en: Starting in the Spring World – the CMS Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入Spring世界 - CMS应用程序
- en: Now, we'll create our first application; at this point, we have learned the
    Spring concepts, and we are ready to put them into practice. At the beginning
    of this chapter, we'll introduce the Spring dependencies to create a web application,
    also we know that Spring Initializr is a fantastic project that enables developers
    to create Spring skeleton projects, with as many dependencies as they want. In
    this chapter, we will learn how to put up our first Spring application on IDE
    and command line, expose our first endpoint, understand how this works under the
    hood, and get to know the main annotations of Spring REST support. We will figure
    out how to create a service layer for the **CMS** (**Content Management System**)
    application and understand how Dependency Injection works in a Spring container.
    We will meet the Spring stereotypes and implement our first Spring bean. At the
    end of this chapter, we will explain how to create a view layer and integrate
    that with AngularJS.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建我们的第一个应用程序；在这个阶段，我们已经学习了Spring的概念，并且我们准备好将它们付诸实践。在本章的开始，我们将介绍Spring依赖项以创建一个Web应用程序，我们还知道Spring
    Initializr是一个出色的项目，它允许开发者创建具有所需依赖项的Spring骨架项目。在本章中，我们将学习如何在IDE和命令行上搭建我们的第一个Spring应用程序，公开我们的第一个端点，了解其内部工作原理，并了解Spring
    REST支持的主要注解。我们将弄清楚如何为**CMS**（**内容管理系统**）应用程序创建服务层，并理解依赖注入在Spring容器中的工作方式。我们将遇到Spring的典型用法并实现我们的第一个Spring
    Bean。在本章的结尾，我们将解释如何创建视图层并将其与AngularJS集成。
- en: 'In this chapter, the following topics will be covered:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将涵盖以下主题：
- en: Creating the project structure
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建项目结构
- en: Running the first Spring application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行第一个Spring应用程序
- en: Introducing the REST support
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍REST支持
- en: Understanding the Dependency Injection in Spring
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Spring中的依赖注入
- en: Creating the CMS application structure
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建CMS应用程序结构
- en: Now we will create our first application with the Spring Framework; we will
    create a basic structure for the CMS application with Spring Initializr. This
    page helps to bootstrap our application, it's a kind of guide which allows us
    to configure the dependencies on Maven or Gradle. We can also choose the language
    and version of Spring Boot.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用Spring框架创建我们的第一个应用程序；我们将使用Spring Initializr为CMS应用程序创建一个基本结构。这个页面帮助我们启动应用程序，它是一种指南，允许我们在Maven或Gradle上配置依赖项。我们还可以选择Spring
    Boot的语言和版本。
- en: 'The page looks like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 页面看起来像这样：
- en: '![](img/3f669b75-6156-4855-a09b-3e2751a0039f.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3f669b75-6156-4855-a09b-3e2751a0039f.png)'
- en: In the Project Metadata section, we can put the coordinates for Maven projects;
    there is a group field which refers to the `groupId` tag, and we have artifacts
    which refer to the `artifactId`. This is all for the Maven coordinates.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目元数据部分，我们可以为Maven项目添加坐标；有一个`group`字段，它引用了`groupId`标签，我们还有`artifacts`字段，它引用了`artifactId`。这些都是Maven坐标。
- en: The dependencies section enables the configuration of the Spring dependencies,
    the field has the autocomplete feature and helps developers to put in the correct
    dependency.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖关系部分允许配置Spring依赖项，该字段具有自动完成功能，并帮助开发者输入正确的依赖项。
- en: The CMS project
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CMS项目
- en: 'Before we start to code and learn amazing things, let''s understand a little
    bit about the CMS project, the main purpose of this project is to help companies
    manage the CMS content for different topics. There are three main entities in
    this project:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编码和学习令人惊叹的事情之前，让我们了解一下CMS项目，该项目的主要目的是帮助公司管理不同主题的CMS内容。在这个项目中，有三个主要实体：
- en: The `News` class is the most important, it will store the content of the news.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`News`类是最重要的，它将存储新闻的内容。'
- en: It has a *category* which makes the search easier, and we can also group news
    by category, and of course, we can group by the user who has created the news.
    The news should be approved by other users to make sure it follows the company
    rules.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个*类别*，这使得搜索更容易，我们还可以按类别对新闻进行分组，当然，我们也可以按创建新闻的用户进行分组。新闻应由其他用户批准，以确保其遵循公司规则。
- en: The news has some *tags* as well, as we can see the application is pretty standard,
    the business rules are easy as well; this is intentional because we keep the focus
    on the new things we will learn.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新闻也有一些*标签*，正如我们所见，应用程序相当标准，业务规则也很简单；这是故意的，因为我们保持对我们将要学习的新内容的关注。
- en: Now we know how Spring Initializr ([https://start.spring.io](https://start.spring.io))
    works and the business rules we need to follow, we are ready to create the project.
    Let's do it right now.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了Spring Initializr ([https://start.spring.io](https://start.spring.io))是如何工作的以及我们需要遵循的业务规则，我们准备好创建项目了。让我们现在就动手吧。
- en: Project metadata section
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目元数据部分
- en: 'Insert `spring-five` in the Group field and `cms` in the Artifact field. If
    you want to customize it, no problem, this is a kind of informative project configuration:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在“分组”字段中插入`spring-five`，在“工件”字段中插入`cms`。如果您想自定义它，没问题，这是一种信息性项目配置：
- en: '![](img/16170417-ad87-4e20-b0a0-083079714775.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/16170417-ad87-4e20-b0a0-083079714775.png)'
- en: The dependencies section
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖项部分
- en: 'Type the `MVC` word in the Search for Dependencies field. The Web module will
    appear as an option, the Web module contains the full-stack web development with
    Embedded Tomcat and Spring MVC, select it. Also, we need to put `Thymeleaf` dependencies
    in this module. It is a template engine and will be useful for the view features
    at the end of this chapter. Type `Thymeleaf`, it includes the Thymeleaf templating
    engine, and includes integration with Spring. The module will appear, and then
    select it as well. Now we can see Web and Thymeleaf in the Selected Dependencies
    pane:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在“搜索依赖项”字段中输入“MVC”一词。Web模块将作为选项出现，Web模块包含嵌入式Tomcat和Spring MVC的全栈Web开发，选择它。我们还需要在这个模块中放置`Thymeleaf`依赖项。它是一个模板引擎，将在本章末尾的视图功能中很有用。输入`Thymeleaf`，它包括Thymeleaf模板引擎，并包含与Spring的集成。模块将出现，然后选择它。现在我们可以在“已选依赖项”面板中看到Web和Thymeleaf：
- en: '![](img/4cd71b3c-c099-4c9b-840b-9ab81ef0b774.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4cd71b3c-c099-4c9b-840b-9ab81ef0b774.png)'
- en: Generating the project
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成项目
- en: 'After we have finished the project definition and chosen the project dependencies,
    we are ready to download the project. It can be done using the Generate Project
    button, click on it. The project will be downloaded. At this stage, the project
    is ready to start our work:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成项目定义并选择项目依赖项后，我们准备好下载项目。可以通过点击“生成项目”按钮来完成，点击它。项目将被下载。在这个阶段，项目已准备好开始我们的工作：
- en: '![](img/884468bd-0dd5-4d53-bb5a-a6db1af4c06a.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/884468bd-0dd5-4d53-bb5a-a6db1af4c06a.png)'
- en: The zip file will be generated with the name `cms.zip` (the Artifact field input
    information) and the location of the downloaded file depends on the browser configuration.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩文件将以`cms.zip`（工件字段输入信息）命名，下载文件的位置取决于浏览器配置。
- en: '>Before opening the project, we must uncompress the artifact generated by **Spring
    Initializr** to the desired location. The command should be:  **`unzip -d <target_destination>
    /<path_to_file>/cms.zip`**. Follow the example: `unzip -d /home/john /home/john/Downloads/cms.zip.`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '>在打开项目之前，我们必须将**Spring Initializr**生成的工件解压缩到目标位置。命令应该是：**`unzip -d <目标位置> /<文件路径>/cms.zip`**。请参考以下示例：`unzip
    -d /home/john /home/john/Downloads/cms.zip.`'
- en: Now, we can open the project in our IDE. Let's open it and take a look at the
    basic structure of the project.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在我们的IDE中打开项目。让我们打开它并查看项目的基本结构。
- en: Running the application
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: Before we run the application, let's have a walk through our project structure.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行应用程序之前，让我们了解一下我们的项目结构。
- en: 'Open the project on IntelliJ IDEA using the Import Project or Open options
    (both are similar), the following page will be displayed:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用IntelliJ IDEA的导入项目或打开选项（两者类似）打开项目，以下页面将显示：
- en: '![](img/5474f4e4-22e9-458b-9f7c-c61a9667268a.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5474f4e4-22e9-458b-9f7c-c61a9667268a.png)'
- en: Then we can open or import the `pom.xml` file.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以打开或导入`pom.xml`文件。
- en: 'The following project structure should be displayed:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 应该显示以下项目结构：
- en: '![](img/f15ef257-c577-43a0-b97f-2b6a76bca580.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f15ef257-c577-43a0-b97f-2b6a76bca580.png)'
- en: Open the `pom.xml,` we have three dependencies, `spring-boot-starter-thymeleaf`, `spring-boot-starter-web`, `spring-boot-starter-test`,
    and an interesting plugin, `spring-boot-maven-plugin`**.**
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`pom.xml`，我们有三个依赖项，`spring-boot-starter-thymeleaf`、`spring-boot-starter-web`、`spring-boot-starter-test`，以及一个有趣的插件`spring-boot-maven-plugin`**。**
- en: These `starter` dependencies are a shortcut for developers because they provide
    full dependencies for the module. For instance, on the `spring-boot-starter-web,`
    there is `web-mvc`, `jackson-databind`, `hibernate-validator-web`, and some others;
    these dependencies must be on the classpath to run the web applications, and starters
    make this task considerably easier.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`starter`依赖项是开发者的快捷方式，因为它们为模块提供了完整的依赖项。例如，在`spring-boot-starter-web`中，有`web-mvc`、`jackson-databind`、`hibernate-validator-web`以及其他一些依赖项；这些依赖项必须在类路径上才能运行Web应用程序，而starters使这项任务变得容易得多。
- en: 'Let''s analyze our `pom.xml`, the file should look like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析我们的 `pom.xml` 文件，该文件应该看起来像这样：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Also, we have a `spring-boot-maven-plugin`, this awesome plugin provides Spring
    Boot support for Maven. It enables you to package the application in a Fat-JAR,
    and the plugin supports the run, start, and stop goals, as well interacting with
    our applications.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们有一个 `spring-boot-maven-plugin`，这个出色的插件为 Maven 提供了 Spring Boot 支持。它允许你将应用程序打包成
    Fat-JAR，该插件支持运行、启动和停止目标，以及与我们的应用程序交互。
- en: '**Fat-JAR**: a JAR which contains all project class files and resources packed
    together with all its dependencies.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**Fat-JAR**：一个包含所有项目类文件和资源，以及所有依赖项打包在一起的 JAR 文件。'
- en: For now, that is enough on Maven configurations; let's take a look at the Java
    files.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关于 Maven 配置的内容就到这里；让我们看看 Java 文件。
- en: 'The Spring Initializr created one class for us, in general, the name of this
    class is artifact name plus `Application`, in our case `CmsApplication`, this
    class should look like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Initializr 为我们创建了一个类，通常，这个类的名字是构件名称加上 `Application`，在我们的例子中是 `CmsApplication`，这个类应该看起来像这样：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Looking under the hood
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看内部结构
- en: 'We have some interesting things here, let''s understand them. The `@SpringBootApplication`
    is the essential annotation for the Spring Boot application; it''s a kind of alias
    for `@Configuration`, `@EnableAutoConfiguration`, and `@Component` annotations.
    Let''s dig in:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里有一些有趣的事情，让我们来理解它们。`@SpringBootApplication` 是 Spring Boot 应用程序的基本注解；它是 `@Configuration`、`@EnableAutoConfiguration`
    和 `@Component` 注解的一种别名。让我们深入探讨：
- en: The first annotation, `@Configuration` indicates that the class can produce
    a beans definitions for the Spring container. This is an interesting annotation to
    work with external dependencies such as `DataSources`; this is the most common
    use case for this annotation.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个注解 `@Configuration` 表示该类可以为 Spring 容器生成 bean 定义。这是一个与外部依赖项（如 `DataSources`）一起工作的有趣注解；这是此注解最常见的使用场景。
- en: The second annotation, `@EnableAutoConfiguration` means that with the Spring
    `ApplicationContext` container, it will try to help us configure the default beans
    for the specific context. For instance, when we create the web MVC application
    with Spring Boot, we will probably need a web server container to run it. In a
    default configuration, the Spring container, together with `@EnableAutoConfiguration`,
    will configure a bean Tomcat-embedded container for us. This annotation is very
    helpful for developers.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个注解 `@EnableAutoConfiguration` 表示，在 Spring `ApplicationContext` 容器中，它将尝试帮助我们为特定上下文配置默认的
    bean。例如，当我们使用 Spring Boot 创建 Web MVC 应用程序时，我们可能需要一个 Web 服务器容器来运行它。在默认配置中，Spring
    容器，连同 `@EnableAutoConfiguration`，将为我们配置一个 Tomcat 内嵌容器 bean。这个注解对开发者非常有帮助。
- en: The `@Component` is a stereotype, the container understands which class is considered
    for auto-detection and needs to instantiate it.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Component` 是一种模式，容器理解哪个类被认为是自动检测的，并需要实例化它。'
- en: The `SpringApplication` class is responsible for bootstrapping the Spring application
    from the main method, it will create an `ApplicationContext` instance, take care
    of configurations provided by the configuration files, and finally, it will load
    the singleton beans that are defined by annotations.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpringApplication` 类负责从主方法启动 Spring 应用程序，它将创建一个 `ApplicationContext` 实例，处理由配置文件提供的配置，最后，它将加载由注解定义的单例
    bean。'
- en: '**Stereotype Annotations** denote a conceptual division in an architecture
    layer. They help the developers understand the purpose of the class and the layer
    which the beans represent, for example, `@Repository` means the data access layer.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式注解**表示架构层中的一个概念性划分。它们帮助开发者理解类的目的和 beans 所代表的层，例如，`@Repository` 表示数据访问层。'
- en: Running the application
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: We will run the application in IntelliJ IDEA and command line. It is an important
    task to learn because we are working in different development environments; sometimes
    the configurations of the application are a little bit complicated, and we are
    not able to run it with IDEs, or sometimes the companies have different IDEs as
    standard, so we will learn about two different ways.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 IntelliJ IDEA 和命令行中运行应用程序。学习这项任务非常重要，因为我们工作在不同的开发环境中；有时应用程序的配置稍微有些复杂，我们无法使用
    IDE 运行它，或者有时公司有不同的 IDE 作为标准，因此我们将学习两种不同的方法。
- en: IntelliJ IDEA
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IntelliJ IDEA
- en: In general, the IntelliJ IDEA recognizes the main class annotated with `@SpringBootApplication`
    and creates a run configuration for us, but it depends on the version of the tool,
    let's do it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，IntelliJ IDEA会识别带有`@SpringBootApplication`注解的主类，并为我们创建一个运行配置，但这取决于工具的版本，让我们来做这件事。
- en: Command line
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行
- en: The command line is a more generic tool to run the project. Also, this task
    is easy, thanks to the Spring Boot Maven plugin. There are two ways to run, and
    we will cover both.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行是一个更通用的运行项目工具。也多亏了Spring Boot Maven插件，这个任务变得简单。有两种运行方式，我们将介绍两种。
- en: Command line via the Maven goal
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过Maven goal执行命令行
- en: 'The first one is a goal of the Spring Boot Maven plugin, and it is straightforward;
    open the terminal then go to the root project folder, pay attention as this is
    the same folder where we have the `pom.xml,` and execute the following command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是一个Spring Boot Maven插件的goal，它很简单；打开终端，然后转到根项目文件夹，注意，这个文件夹与我们的`pom.xml`文件在同一个文件夹中，执行以下命令：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The Maven will now compile the project and run the main class, the class `CmsApplication`,
    and we should see this output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Maven现在将编译项目并运行主类`CmsApplication`，我们应该看到以下输出：
- en: '![](img/53c46844-611f-4cd1-87ce-ff858913473b.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53c46844-611f-4cd1-87ce-ff858913473b.png)'
- en: Command line via the JAR file
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过JAR文件执行命令行
- en: 'To run it through the Java file, we need to compile and package it, and then
    we can run the project with the Java command line. To compile and package it,
    we can use the pretty standard Maven command like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过Java文件运行它，我们需要编译和打包它，然后我们可以使用Java命令行运行项目。要编译和打包它，我们可以使用相当标准的Maven命令，如下所示：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After the project is compiled and packaged as a Fat-JAR, we can execute the
    JAR file, go to the target folder and check the files from this folder, probably
    the result will look like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目编译和打包为Fat-JAR之后，我们可以执行JAR文件，转到目标文件夹并检查此文件夹中的文件，可能的结果如下所示：
- en: '![](img/8523a88d-85c2-483b-a54c-e00dc3f41ebe.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8523a88d-85c2-483b-a54c-e00dc3f41ebe.png)'
- en: 'We have two main files in our target folder, the `cms-0.0.1-SNAPSHOT.jar` and
    the `cms-0.0.1-SNAPSHOT.jar.original`, the file with the `.original` extension
    is not executable. It is the original artifact resulting from the compilation,
    and the other is our executable file. It is what we are looking for, let''s execute
    it, type the following command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的目标文件夹中有两个主要文件，`cms-0.0.1-SNAPSHOT.jar`和`cms-0.0.1-SNAPSHOT.jar.original`，带有`.original`扩展名的文件是不可执行的。它是编译产生的原始工件，另一个是我们的可执行文件。这是我们正在寻找的，让我们执行它，输入以下命令：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The result should be as displayed. The application is up and running:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该如显示的那样。应用程序正在运行：
- en: '![](img/c11c8613-b841-4cc9-af00-52666e07a797.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c11c8613-b841-4cc9-af00-52666e07a797.png)'
- en: That is it for this part, in the next section, we will create the first **REST**
    (**Representational State Transfer**) resources and understand how the REST endpoints
    work.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分就到这里，在下一节中，我们将创建第一个**REST**（**表示状态传输**）资源，并了解REST端点是如何工作的。
- en: Creating the REST resources
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建REST资源
- en: Now, we have an application up and running in this section, and we will add
    some REST endpoints and model some initial classes for the CMS application, the
    REST endpoints will be useful for the AngularJS integration.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在这一节中，我们已经有一个应用程序正在运行，我们将添加一些REST端点并为CMS应用程序建模一些初始类，这些REST端点将有助于AngularJS集成。
- en: One of the required characteristics for the APIs is the documentation, and a
    popular tool to help us with these tasks is Swagger. The Spring Framework supports
    Swagger, and we can do it with a couple of annotations. The project's Spring Fox
    is the correct tool to do this, and we will take a look at the tool in this chapter.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于APIs的一个必需特性是文档，而帮助我们完成这些任务的流行工具之一是Swagger。Spring框架支持Swagger，我们可以通过几个注解来实现它。项目的Spring
    Fox是完成这项任务的正确工具，我们将在本章中查看这个工具。
- en: Let's do this.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们这样做。
- en: Models
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型
- en: Before we start to create our class, we will add the `Lombok` dependency in
    our project. It is a fantastic library which provides some interesting things
    such as `GET`/`SET` at compilation time, the `Val` keyword to make variables final,
    `@Data` to make a class with some default methods like getters/setters, `equals`,
    and `hashCode`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建我们的类之前，我们将在项目中添加`Lombok`依赖。这是一个非常棒的库，它在编译时提供了一些有趣的功能，如`GET`/`SET`，`Val`关键字使变量成为final，`@Data`使一个类具有一些默认方法，如getters/setters，`equals`和`hashCode`。
- en: Adding Lombok dependency
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Lombok依赖
- en: 'Put the following dependency in a `pom.xml` file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pom.xml`文件中添加以下依赖项：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `provided` scope instructs Maven not to include this dependency in the JAR
    file because we need it at compile time. We do not need it at runtime. Wait for
    Maven to download the dependency, that is all for now.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`provided` 范围指示 Maven 不要将此依赖项包含在 JAR 文件中，因为我们需要在编译时使用它。我们不需要在运行时使用它。等待 Maven
    下载依赖项，这就是现在所有的事情。'
- en: 'Also, we can use the Reimport All Maven Projects provided by IntelliJ IDEA,
    located in the Maven Projects tab, as shown here:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以使用 IntelliJ IDEA 提供的“重新导入所有 Maven 项目”，它位于 Maven 项目选项卡中，如下所示：
- en: '![](img/d2001438-30ed-4cc8-9935-c76d35795176.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2001438-30ed-4cc8-9935-c76d35795176.png)'
- en: Creating the models
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模型
- en: Now, we will create our models, which are Java classes annotated with `@Data`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建我们的模型，这些模型是带有 `@Data` 注解的 Java 类。
- en: Tag
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标签
- en: 'This class represents a tag in our system. There isn''t necessarily any repository
    for it because it will be persisted together with our `News` entity:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类代表我们系统中的一个标签。不一定有它的存储库，因为它将与我们的 `News` 实体一起持久化：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Category
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类别
- en: 'A category model for our CMS application can be used to group the news. Also,
    the other important thing is that this makes our news categorized to make the
    search task easy. Take a look at the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 CMS 应用程序的一个类别模型可以用来分组新闻。另外，另一个重要的事情是，这使得我们的新闻被分类，使得搜索任务变得容易。看看下面的代码：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: User
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户
- en: 'It represents a user in our domain model. We have two different profiles, the
    author who acts as a news writer, and another one is a reviewer who must review
    the news registered at the portal. Take a look at the following example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 它代表我们领域模型中的一个用户。我们有两个不同的配置文件，一个是作为新闻作者的作者，另一个是必须审核在门户网站上注册的新闻的审稿人。看看下面的例子：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: News
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新闻
- en: 'This class represents news in our domain, for now, it does not have any behaviors.
    Only properties and getters/setters are exposed; in the future, we will add some
    behaviors:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类代表我们领域中的新闻，目前它没有任何行为。只暴露了属性和获取/设置方法；在未来，我们将添加一些行为：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `Review` class can be found at GitHub: ([https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter02/src/main/java/springfive/cms/domain/models](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter02/src/main/java/springfive/cms/domain/models)).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`Review` 类可以在 GitHub 上找到：([https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter02/src/main/java/springfive/cms/domain/models](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter02/src/main/java/springfive/cms/domain/models)).'
- en: As we can see, they are simple Java classes which represent our CMS application
    domain. It is the heart of our application, and all the domain logic will reside
    in these classes. It is an important characteristic.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，它们是简单的 Java 类，代表我们的 CMS 应用程序领域。它是我们应用程序的核心，所有的领域逻辑都将驻留在这些类中。这是一个重要的特征。
- en: Hello REST resources
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嗨，这是 REST 资源
- en: 'We have created the models, and we can start to think about our REST resources.
    We will create three main resources:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了模型，现在我们可以开始考虑我们的 REST 资源。我们将创建三个主要资源：
- en: '`CategoryResource` which will be responsible for the `Category` class.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CategoryResource` 将负责 `Category` 类。'
- en: The second one is `UserResource`. It will manage the interactions between the
    `User` class and the REST APIs.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个是 `UserResource`。它将负责管理 `User` 类和 REST API 之间的交互。
- en: The last one, and more important as well, will be the `NewsResource` which will
    be responsible for managing news entities, such as reviews.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个，同样重要的是，将是 `NewsResource`，它将负责管理新闻实体，如评论。
- en: Creating the CategoryResource class
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 CategoryResource 类
- en: We will create our first REST resource, let's get started with the `CategoryResource`
    class which is responsible for managing our `Category` class. The implementation
    of this entity will be simple, and we will create CRUD endpoints such as create,
    retrieve, update, and delete. We have two important things we must keep in mind
    when we create the APIs. The first one is the correct HTTP verb such as `POST`,
    `GET`, `PUT` and `DELETE`. It is essential for the REST APIs to have the correct
    HTTP verb as it provides us with intrinsic knowledge about the API. It is a pattern
    for anything that interacts with our APIs. Another thing is the status codes,
    and it is the same as the first one we must follow, this is the pattern the developers
    will easily recognize. The *Richardson Maturity Model* can help us create amazing
    REST APIs, and this model introduces some levels to measure the REST APIs, it's
    a kind of thermometer.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建我们的第一个REST资源，让我们从负责管理我们的`Category`类的`CategoryResource`类开始。这个实体的实现将很简单，我们将创建创建、检索、更新和删除等CRUD端点。当我们创建API时，我们必须牢记两件重要的事情。第一件是正确的HTTP动词，如`POST`、`GET`、`PUT`和`DELETE`。对于REST
    API来说，拥有正确的HTTP动词是至关重要的，因为它为我们提供了关于API的内在知识。这是一个与我们的API交互的任何事物的模式。另一件事是状态码，它与第一件事相同，我们必须遵循这个模式，这是开发者容易识别的模式。《理查森成熟度模型》可以帮助我们创建出色的REST
    API，这个模型引入了一些级别来衡量REST API，它就像一个温度计。
- en: 'Firstly, we will create the skeleton for our APIs. Think about what features
    you need in your application. In the next section, we will explain how to add
    a service layer in our REST APIs. For now, let''s build a `CategoryResource` class,
    our implementation could look like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将为我们的API创建一个骨架。想想你的应用程序需要哪些功能。在下一节中，我们将解释如何在REST API中添加服务层。现在，让我们构建一个`CategoryResource`类，我们的实现可能看起来像这样：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `CategoryRequest` can be found at GitHub ([https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter02/src/main/java/springfive/cms/domain/vo](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter02/src/main/java/springfive/cms/domain/vo)).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`CategoryRequest`可以在GitHub上找到（[https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter02/src/main/java/springfive/cms/domain/vo](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter02/src/main/java/springfive/cms/domain/vo))。'
- en: We have some important concepts here. The first one is `@RestController`. It
    instructs the Spring Framework that the `CategoryResource` class will expose REST
    endpoints over the Web-MVC module. This annotation will configure some things
    in a framework, such as `HttpMessageConverters` to handle HTTP requests and responses
    such as XML or JSON. Of course, we need the correct libraries on the classpath,
    to handle JSON and XML. Also, add some headers to the request such as `Accept`
    and `Content-Type`. This annotation was introduced in version 4.0\. It is a kind
    of syntactic sugar annotation because it's annotated with `@Controller` and `@ResponseBody`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里有一些重要的概念。第一个是`@RestController`。它指示Spring框架，`CategoryResource`类将通过Web-MVC模块公开REST端点。这个注解将在框架中配置一些事情，例如`HttpMessageConverters`来处理HTTP请求和响应，如XML或JSON。当然，我们需要在类路径上添加正确的库来处理JSON和XML。还需要添加一些请求头，如`Accept`和`Content-Type`。这个注解是在4.0版本中引入的。它是一种语法糖注解，因为它被`@Controller`和`@ResponseBody`注解。
- en: The second is the `@RequestMapping` annotation, and this important annotation
    is responsible for the HTTP request and response in our class. The usage is quite
    simple in this code when we use it on the class level, it will propagate for all
    methods, and the methods use it as a relative. The `@RequestMapping` annotation
    has different use cases. It allows us to configure the HTTP verb, params, and
    headers.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是`@RequestMapping`注解，这个重要的注解负责我们类中的HTTP请求和响应。在这个代码中，当我们使用它在类级别时，它将传播到所有方法，并且方法使用它作为相对路径。`@RequestMapping`注解有不同的使用场景。它允许我们配置HTTP动词、参数和头信息。
- en: Finally, we have `@GetMapping`, `@PostMapping`, `@DeleteMapping`, and `@PutMapping`, these
    annotations are a kind of shortcut to configure the `@RequestMapping` with the
    correct HTTP verbs; an advantage is that these annotations make the code more
    readable.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`@GetMapping`、`@PostMapping`、`@DeleteMapping`和`@PutMapping`，这些注解是配置`@RequestMapping`与正确HTTP动词的一种快捷方式；一个优点是这些注解使代码更易于阅读。
- en: Except for the `removeCategory`, all the methods return the `ResponseEntity`
    class which enables us to handle the correct HTTP status codes in the next section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`removeCategory`方法外，所有方法都返回`ResponseEntity`类，这使得我们能够在下一节中处理正确的HTTP状态码。
- en: UserResource
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户资源
- en: The `UserResource` class is the same as `CategoryResource`, except that it uses
    the `User` class. We can find the whole code on the GitHub ([https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter02](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter02)).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserResource`类与`CategoryResource`类相同，只是它使用`User`类。我们可以在GitHub上找到整个代码（[https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter02](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter02)）。'
- en: NewsResource
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NewsResource
- en: 'The `NewsResource` class is essential, this endpoint enables users to review
    news previously registered, and it also provides an endpoint to return the updated
    news. This is an important feature because we are interested only in the relevant
    news. Irrelevant news cannot be shown on the portal. The resource class should
    look like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewsResource`类是必不可少的，这个端点允许用户审查之前注册的新闻，并且它还提供了一个端点来返回更新的新闻。这是一个重要的功能，因为我们只对相关的新闻感兴趣。不相关的新闻不能在门户上显示。资源类应如下所示：'
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `NewsRequest` class can be found at [GitHub](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter02/src/main/java/springfive/cms/domain/vo).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewsRequest`类可以在GitHub上找到（[https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter02/src/main/java/springfive/cms/domain/vo](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter02/src/main/java/springfive/cms/domain/vo)）。'
- en: Pay attention to the HTTP verbs and the HTTP status code, as we need to follow
    the correct semantics.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意HTTP动词和HTTP状态码，因为我们需要遵循正确的语义。
- en: Adding service layer
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加服务层
- en: Now, we have the skeleton for the REST layer ready, and in this section, we
    will start to create a service layer for our application. We will show how the
    Dependency Injection works under the hood, learn the stereotype annotations on
    Spring Framework and also start to think about our persistence storage, which
    will be presented in the next section.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好了REST层的框架，在本节中，我们将开始为我们的应用程序创建服务层。我们将展示依赖注入是如何在底层工作的，学习Spring框架上的
    stereotypes 注解，并开始考虑我们的持久化存储，这将在下一节中介绍。
- en: Changes in the model
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型中的变化
- en: We need to make some changes to our model, specifically in the `News` class.
    In our business rules, we need to keep our information safe, then we need to review
    all the news. We will add some methods to add a new review done by a user, and
    also we will add a method to check if the news was reviewed by all mandatory reviewers.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对我们的模型进行一些更改，特别是对`News`类。在我们的业务规则中，我们需要保护我们的信息安全，然后我们需要审查所有新闻。我们将添加一些方法来添加用户完成的新审查，并且我们还将添加一个方法来检查新闻是否被所有强制性的审查员审查过。
- en: Adding a new review
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加新的审查
- en: 'For this feature, we need to create a method in our `News` class, the method
    will return a `Review` and should look like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个功能，我们需要在我们的`News`类中创建一个方法，该方法将返回一个`Review`，其外观应如下所示：
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We do not need to check if the user, who performs the review action, is a mandatory
    reviewer at all.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要检查执行审查动作的用户是否是强制性的审查员。
- en: Keeping the news safely
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全地保存新闻
- en: 'Also, we need to check if the news is fully revised by all mandatory reviewers.
    It is quite simple, we are using Java 8, and it provides the amazing `Stream` interface,
    which makes the collections interactions easier than before. Let''s do this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要检查新闻是否被所有强制性的审查员完全修订。这相当简单，我们使用Java 8，它提供了惊人的`Stream`接口，这使得集合交互比以前更容易。让我们这样做：
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Thanks, Java 8, we appreciate it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢，Java 8，我们很感激。
- en: Before starting the service layer
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在开始服务层之前
- en: Our application needs to have a persistence storage where our records can be
    loaded, even if the application goes down. We will create the fake implementation
    for our repositories.   In [C](827e9516-ff3d-44d7-8a16-95579684f453.xhtml)hapter
    3, *Persistence with Spring Data and Reactive* *Fashion*, we will introduce the
    Spring Data projects which help developers create amazing repositories with a
    fantastic DSL. For now, we will create some Spring beans to store our elements
    in memory, let's do that.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序需要一个持久化存储，以便即使在应用程序关闭的情况下，我们的记录也可以被加载。我们将为我们的存储库创建一个模拟实现。在[第3章](827e9516-ff3d-44d7-8a16-95579684f453.xhtml)“使用Spring
    Data和响应式*时尚*进行持久化”中，我们将介绍Spring Data项目，这些项目帮助开发者使用出色的DSL创建惊人的存储库。现在，我们将创建一些Spring
    bean来在内存中存储我们的元素，让我们来做这件事。
- en: CategoryService
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CategoryService
- en: Let's start with our simplest service, the `CategoryService` class, the behaviors
    expected of this class are CRUD operations. Then, we need a representation of
    our persistence storage or repository implementation, for now, we are using the
    ephemeral storage and `ArrayList` with our categories. In the next chapter, we
    will add the real persistence for our CMS application.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的服务开始，即`CategoryService`类，这个类预期的行为是CRUD操作。然后，我们需要表示我们的持久化存储或仓库实现，目前，我们使用临时存储和`ArrayList`来存储我们的类别。在下一章中，我们将为我们的CMS应用程序添加真正的持久化。
- en: 'Let''s create our first Spring service. The implementation is in the following
    snippet:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的第一个Spring服务。实现如下所示：
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There is some new stuff here. This class will be detected and instantiated by
    the Spring container because it has a `@Service` annotation. As we can see, there
    is nothing special in that class. It does not necessarily extend any class or
    implement an interface. We received the `CategoryRepository` on a constructor,
    this class will be provided by the Spring container because we instruct the container
    to produce this, but in Spring 5 it is not necessary to use `@Autowired` anymore
    in the constructor. It works because we had the only one constructor in that class
    and Spring will detect it. Also, we have a couple of methods which represent the
    CRUD behaviors, and it is simple to understand.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些新内容。这个类将由Spring容器检测并实例化，因为它有一个`@Service`注解。正如我们所见，这个类中没有什么特别之处。它不一定扩展任何类或实现任何接口。我们在构造函数中收到了`CategoryRepository`，这个类将由Spring容器提供，因为我们指示容器生成这个类，但在Spring
    5中，在构造函数中不再需要使用`@Autowired`。它之所以能工作，是因为这个类中只有一个构造函数，Spring会检测到它。此外，我们还有一些表示CRUD行为的方法，这些方法很容易理解。
- en: UserService
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UserService
- en: 'The `UserService` class is quite similar to the `CategoryService`, but the
    rules are about the `User` entity, for this entity we do not have anything special.
    We have the `@Service` annotation, and we received the `UserRepository` constructor
    as well. It is quite simple and easy to understand. We will show the `UserService` implementation,
    and it must be like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserService`类与`CategoryService`非常相似，但规则是关于`User`实体的，对于这个实体我们没有特别之处。我们有`@Service`注解，并且我们也收到了`UserRepository`构造函数。它相当简单且易于理解。我们将展示`UserService`实现，它必须是这样的：'
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Pay attention to the class declaration with `@Service` annotation. This is a
    very common implementation in the Spring ecosystem. Also, we can find `@Component`,
    `@Repository` annotations. `@Service` and `@Component` are common for the service
    layer, and there is no difference in behaviors. The `@Repository` changes the
    behaviors a little bit because the frameworks will translate some exceptions on
    the data access layer.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意带有`@Service`注解的类声明。这在Spring生态系统中是一个非常常见的实现。我们还可以找到`@Component`、`@Repository`注解。`@Service`和`@Component`在服务层中很常见，它们的行为没有区别。`@Repository`会稍微改变一些行为，因为框架会在数据访问层转换一些异常。
- en: NewsService
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NewsService
- en: This is an interesting service which will be responsible for managing the state
    of our news. It will interact like a *glue* to call the domain models, in this
    case, the `News` entity. The service is pretty similar to the others. We received
    the `NewsRepository` class, a dependency and kept the repository to maintain the
    states, let's do that.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有趣的服务，它将负责管理我们的新闻状态。它将像胶水一样与领域模型交互，在这种情况下，是`News`实体。这个服务与其他服务非常相似。我们收到了`NewsRepository`类，一个依赖项，并保留仓库以维护状态，让我们这样做。
- en: The `@Service` annotation is present again. This is pretty much standard for
    Spring applications. Also, we can change to the `@Component` annotation, but it
    does not make any difference to our application.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Service`注解再次出现。这对于Spring应用程序来说几乎是标准的。我们还可以将其更改为`@Component`注解，但这对我们应用程序没有任何影响。'
- en: Configuring Swagger for our APIs
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的API配置Swagger
- en: Swagger is the de facto tool for document web APIs, and the tool allows developers
    to model APIs, create an interactive way to play with the APIs, and also provides
    an easy way to generate the client implementation in a wide range of languages.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger是文档化Web API的事实上工具，该工具允许开发者对API进行建模，以交互式的方式与API进行交互，并提供了一种简单的方法来生成各种语言的客户端实现。
- en: The API documentation is an excellent way to engage developers to use our APIs.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: API文档是吸引开发者使用我们的API的绝佳方式。
- en: Adding dependencies to pom.xml
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将依赖项添加到pom.xml
- en: Before we start the configuration, we need to add the required dependencies.
    These dependencies included Spring Fox in our project and offered many annotations
    to configure Swagger properly. Let's add these dependencies.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始配置之前，我们需要添加所需的依赖项。这些依赖项包括我们的项目中的 Spring Fox，并提供了许多注解来正确配置 Swagger。让我们添加这些依赖项。
- en: 'The new dependencies are in the `pom.xml` file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 新的依赖项位于 `pom.xml` 文件中：
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first dependency is the core of Swagger with annotations and related kinds
    of stuff. Spring Fox Swagger UI dependency provides a rich interface in HTML which
    permits developers to interact with the APIs.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个依赖项是 Swagger 的核心，包括注解和相关内容。Spring Fox Swagger UI 依赖项提供了一个丰富的 HTML 接口，允许开发者与
    API 交互。
- en: Configuring Swagger
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Swagger
- en: The dependencies are added, now we can configure the infrastructure for Swagger.
    The configuration is pretty simple. We will create a class with `@Configuration`
    to produce the Swagger configuration for the Spring container. Let's do it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项已添加，现在我们可以配置 Swagger 的基础设施。配置相当简单。我们将创建一个带有 `@Configuration` 的类来为 Spring
    容器生成 Swagger 配置。让我们来做这件事。
- en: 'Take a look at the following Swagger configuration:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下 Swagger 配置：
- en: '[PRE17]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `@Configuration` instructs the Spring to generate a bean definition for
    Swagger. The annotation, `@EnableSwagger2` adds support for Swagger. `@EnableSwagger2`
    should be accompanied by `@Configuration`, it is mandatory.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Configuration` 指示 Spring 为 Swagger 生成一个 bean 定义。注解 `@EnableSwagger2` 添加了对
    Swagger 的支持。`@EnableSwagger2` 应与 `@Configuration` 一起使用，这是强制性的。'
- en: The `Docket` class is a builder to create an API definition, and it provides
    sensible defaults and convenience methods for configuration of the Spring Swagger
    MVC Framework.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`Docket` 类是一个用于创建 API 定义构建器，它为 Spring Swagger MVC 框架的配置提供了合理的默认值和便捷方法。'
- en: The invocation of method `.apis(RequestHandlerSelectors.withClassAnnotation(RestController.class))`
    instructs the framework to handle classes annotated with `@RestController`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `.apis(RequestHandlerSelectors.withClassAnnotation(RestController.class))`
    的调用指示框架处理带有 `@RestController` 注解的类。
- en: There are many methods to customize the API documentation, for example, there
    is a method to add authentication headers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以自定义 API 文档，例如，有一个方法可以添加认证头。
- en: That is the Swagger configuration, in the next section, we will create a first
    documented API.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Swagger 配置，在下一节中，我们将创建第一个文档化的 API。
- en: First documented API
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一个文档化的 API
- en: We will start with the `CategoryResource` class, because it is simple to understand,
    and we need to keep the focus on the technology stuff. We will add a couple of
    annotations, and the magic will happen, let's do magic.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 `CategoryResource` 类开始，因为它容易理解，并且我们需要保持对技术内容的关注。我们将添加一些注解，然后魔法就会发生，让我们来做魔法。
- en: 'The `CategoryResource` class should look like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`CategoryResource` 类应该看起来像这样：'
- en: '[PRE18]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There are a lot of new annotations to understand. The `@Api` is the root annotation
    which configures this class as a Swagger resource. There are many configurations,
    but we will use the tags and description, as they are enough.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多新的注解需要理解。`@Api` 是根注解，它将此类配置为 Swagger 资源。有许多配置，但我们将使用标签和描述，因为它们已经足够了。
- en: The `@ApiOperation` describes an operation in our API, in general against the
    requested path. The `value` attribute is regarding as the summary field on Swagger,
    it is a brief of the operation, and `notes` is a description of an operation (more
    detailed content).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ApiOperation` 描述了我们的 API 中的操作，通常是对请求路径的操作。`value` 属性被视为 Swagger 上的摘要字段，它是操作的简述，而
    `notes` 是操作的描述（更详细的内容）。'
- en: The last one is the `@ApiResponse` which enables developers to describe the
    responses of an operation. Usually, they want to configure the status codes and
    message to describe the result of an operation.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个是 `@ApiResponse`，它允许开发者描述操作的响应。通常，他们想要配置状态码和消息来描述操作的结果。
- en: Before you run the application, we should compile the source code.  It can be
    done using the Maven command line using the `mvn clean install,` or via IDE using
    the Run Application.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行应用程序之前，我们应该编译源代码。这可以通过使用 Maven 命令行执行 `mvn clean install` 或通过 IDE 使用运行应用程序来完成。
- en: 'Now, we have configured the Swagger integration, we can check the API documentation
    on the web browser. To do it, we need to navigate to `http://localhost:8080/swagger-ui.html` and
    this page should be displayed:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经配置了 Swagger 集成，我们可以在网页浏览器中检查 API 文档。为此，我们需要导航到 `http://localhost:8080/swagger-ui.html`
    并显示此页面：
- en: '![](img/593d1a81-a87d-4346-80ae-31c132c2fb09.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/593d1a81-a87d-4346-80ae-31c132c2fb09.png)'
- en: 'We can see APIs endpoints configured in our CMS application. Now, we will take
    a look at category which we have configured previously, click on the Show/Hide
    link. The output should be:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到配置在我们 CMS 应用程序中的 API 端点。现在，我们将查看我们之前配置的分类，点击“显示/隐藏”链接。输出应该是：
- en: '![](img/d5a127ca-5b9a-49f7-960a-b608ac3f0022.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d5a127ca-5b9a-49f7-960a-b608ac3f0022.png)'
- en: 'As we can see, there are five operations in our Category API, the operation
    has a path and a summary to help understand the purpose. We can click on the requested
    operation and see detailed information about the operation. Let''s do it, click
    on List categories to see detailed documentation. The page looks like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在我们的分类 API 中有五个操作，每个操作都有一个路径和摘要来帮助理解其目的。我们可以点击请求的操作并查看关于该操作的详细信息。让我们来做吧，点击“列出分类”来查看详细文档。页面看起来像这样：
- en: '![](img/13866a16-49b0-441c-aa8b-a7943c54b35c.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/13866a16-49b0-441c-aa8b-a7943c54b35c.png)'
- en: Outstanding job. Now we have an amazing API with excellent documentation. Well
    done.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 干得漂亮。现在我们有一个出色的 API，拥有优秀的文档。做得好。
- en: Let's continue creating our CMS application.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建我们的 CMS 应用程序。
- en: Integrate with AngularJS
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成到 AngularJS
- en: The AngularJS Framework has been becoming a trend for a few years, the community
    is super active, the project was created by Google.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 几年来，AngularJS 框架已经成为一种趋势，社区非常活跃，该项目由 Google 创建。
- en: The main idea of the framework is to help developers handle the complexities
    of the frontend layer, especially in the HTML part. The HTML markup language is
    static. It is a great tool to create static documents, but today it is not a requirement
    for modern web applications. These applications need to be dynamic. The UX teams
    around the world, work hard to create amazing applications, with different effects,
    these guys try to keep the applications more comfortable for the users.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 框架的主要思想是帮助开发者处理前端层的复杂性，尤其是在 HTML 部分。HTML 标记语言是静态的。它是一个创建静态文档的伟大工具，但今天它不再是现代网络应用程序的要求。这些应用程序需要是动态的。世界各地的
    UX 团队努力创造令人惊叹的应用程序，具有不同的效果，这些人试图让应用程序对用户更加舒适。
- en: AngularJS adds the possibility of extending the HTML with some additional attributes
    and tags. In this section, we will add some interesting behaviors on the frontend
    application. Let's do it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 增加了扩展 HTML 的可能性，添加一些额外的属性和标签。在本节中，我们将在前端应用程序中添加一些有趣的行为。让我们来做。
- en: AngularJS concepts
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AngularJS 概念
- en: In our CMS application, we will work with some Angular components. We will use `Controllers` which
    will interact with our HTML and handle the behavior of some pages, such as those
    that show error messages. The `Services` is responsible for handling the infrastructure
    code such as interacting with our CMS API. This book is not intended to be an
    AngularJS guide. However, we will take a look at some interesting concepts to
    develop our application.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 CMS 应用程序中，我们将使用一些 Angular 组件。我们将使用 `Controllers`，它们将与我们的 HTML 交互并处理一些页面的行为，例如显示错误消息的页面。`Services`
    负责处理基础设施代码，例如与我们的 CMS API 交互。本书的目的不是成为 AngularJS 指南。然而，我们将探讨一些有趣的概念来开发我们的应用程序。
- en: 'The AngularJS common tags are:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 的常用标签包括：
- en: '`ng-app`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-app`'
- en: '`ng-controller`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-controller`'
- en: '`ng-click`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-click`'
- en: '`ng-hide`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-hide`'
- en: '`ng-show`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-show`'
- en: These tags are included in the AngularJS Framework. There are many more tags
    created and maintained by the community. There is, for example, a library to work
    with HTML forms, we will use it to add dynamic behaviors in our CMS Portal.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标签包含在 AngularJS 框架中。社区还创建了和维护了许多其他标签。例如，有一个用于处理 HTML 表单的库，我们将使用它来在我们的 CMS
    门户中添加动态行为。
- en: Controllers
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器
- en: Controllers are part of the framework to handle the business logic of the application.
    They should be used to control the flow of data in an application. The controller
    is attached to the DOM via the `ng-controller` directive.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器是框架的一部分，用于处理应用程序的业务逻辑。它们应该用于控制应用程序中的数据流。控制器通过 `ng-controller` 指令附加到 DOM。
- en: To add some actions to our view, we need to create functions on controllers,
    the way to do this is by creating functions and adding them to the `$scope` object.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要向我们的视图添加一些操作，我们需要在控制器上创建函数，方法是创建函数并将它们添加到 `$scope` 对象中。
- en: The controllers cannot be used to carry out DOM manipulations, format data and
    filter data, it is considered best practice in the AngularJS world.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器不能用来执行 DOM 操作、格式化数据和过滤数据，在 AngularJS 世界中被认为是最佳实践。
- en: Usually, the controllers inject the service objects to delegate handling the
    business logic. We will understand services in the next section.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，控制器会注入服务对象以委托处理业务逻辑。我们将在下一节中了解服务。
- en: Services
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务
- en: Services are the objects to handle business logic in our application. In some
    cases, they can be used to handle state. The services objects are a singleton
    which means we have only one instance in our entire application.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是我们应用中处理业务逻辑的对象。在某些情况下，它们可以用来处理状态。服务对象是单例的，这意味着我们整个应用程序中只有一个实例。
- en: In our application, the services are responsible for interacting with our CMS
    APIs built on Spring Boot. Let's do that.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，服务负责与基于Spring Boot构建的CMS API交互。让我们来做这件事。
- en: Creating the application entry point
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用程序入口点
- en: The Spring Boot Framework allows us to serve static files. These files should
    be in the classpath in one of these folders, `/static`, `/public`, `/resources`, or
    `/META-INF/resources`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot框架允许我们提供静态文件。这些文件应位于以下这些文件夹中的classpath中，`/static`、`/public`、`/resources`或`/META-INF/resources`。
- en: 'We will use the `/static` folder, in this folder, we will put our AngularJS
    application. There are some standards to modularize the AngularJS application
    folder structure which depends on the application size and requirements. We will
    use the most simple style to keep the attention on Spring integration. Look at
    the project structure:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`/static`文件夹，在这个文件夹中，我们将放置我们的AngularJS应用程序。对于模块化AngularJS应用程序文件夹结构有一些标准，这取决于应用程序的大小和需求。我们将使用最简单的风格以保持对Spring集成的关注。看看项目结构：
- en: '![](img/37d2683d-a4f2-4759-a86c-38c95369a7ae.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/37d2683d-a4f2-4759-a86c-38c95369a7ae.png)'
- en: There are some assets to start and run an AngularJS application. We will use
    the Content Delivery Network (CDN) to load the AngularJS Framework, the Angular
    UI-Router which helps to handle routing on our web application, and the Bootstrap
    Framework which helps to develop our pages.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些资产可以启动和运行AngularJS应用程序。我们将使用内容分发网络（CDN）来加载AngularJS框架、Angular UI-Router，它帮助我们处理Web应用程序的路由，以及Bootstrap框架，它帮助我们开发页面。
- en: Content Delivery Network is distributed proxy servers around the world. It makes
    the content more high availability and improves performance because it will be
    hosted nearer the end user. The detailed explanation can be found at CloudFare
    Page ([https://www.cloudflare.com/learning/cdn/what-is-a-cdn/](https://www.cloudflare.com/learning/cdn/what-is-a-cdn/)).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 内容分发网络是全球分布式的代理服务器。它使内容具有更高的可用性并提高性能，因为它将更靠近终端用户托管。详细的解释可以在CloudFare页面找到([https://www.cloudflare.com/learning/cdn/what-is-a-cdn/](https://www.cloudflare.com/learning/cdn/what-is-a-cdn/))。
- en: 'Then we can start to configure our AngularJS application. Let''s start with
    our entry point, `index.html`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以开始配置我们的AngularJS应用程序。让我们从我们的入口点`index.html`开始：
- en: '[PRE19]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There are some important things here. Let's understand them.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些重要的事情。让我们来理解它们。
- en: The `ng-app` tag is a directive which is used to bootstrap the AngularJS application.
    This tag is the root element of the application and is usually placed on the `<body>`
    or `<html>` tags.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`ng-app`标签是一个指令，用于引导AngularJS应用程序。这个标签是应用程序的根元素，通常放置在`<body>`或`<html>`标签上。'
- en: 'The `ui-view` tag instructs the Angular UI-Router about which portion of the
    HTML document will be handled by the application states, in other words, the designated
    part has the dynamic behaviors and change depends on the routing system. Look
    at the following code snippet:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`ui-view`标签指示Angular UI-Router关于HTML文档的哪个部分将由应用程序状态处理，换句话说，指定的部分具有动态行为，其变化取决于路由系统。看看下面的代码片段：'
- en: '[PRE20]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This part of the code can be found at `index.hml` file.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分代码可以在`index.hml`文件中找到。
- en: 'Following the `ui-view`, we have our JavaScript files, the first one is the
    AngularJS Framework, in this version the file is minified. Look at our JavaScript
    files, the files were created in the `/static/app/components` folder. Take a look
    at the image here:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ui-view`之后，我们有我们的JavaScript文件，第一个是AngularJS框架，在这个版本中文件被压缩。看看我们的JavaScript文件，这些文件是在`/static/app/components`文件夹中创建的。看看这里的图片：
- en: '![](img/0cdc6303-e961-493a-a1f9-f44de184e3ef.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0cdc6303-e961-493a-a1f9-f44de184e3ef.png)'
- en: The second one is the UI-Router which helps us to manage our routes. Finally,
    we have our JavaScript files which configure the AngularJS application, our controllers,
    and the services to interact with our CMS APIs.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是UI-Router，它帮助我们管理我们的路由。最后，我们有我们的JavaScript文件，这些文件配置了AngularJS应用程序、我们的控制器以及与我们的CMS
    API交互的服务。
- en: Also, we have some Bootstrap classes to align fields and make design easier.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还有一些引导类，用于对齐字段并使设计更容易。
- en: Creating the Category Controller
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建分类控制器
- en: Now, we need to create our controllers. We will start with the simplest to make
    the example more easy to understand. The `CategoryController` has the responsibility
    of controlling the data of the `Category` entity. There are two controllers, one
    enables us to create a category, and another lists all categories stored in the
    database.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建我们的控制器。我们将从最简单的开始，使示例更容易理解。《CategoryController》负责控制`Category`实体的数据。有两个控制器，一个使我们能够创建一个分类，另一个列出存储在数据库中的所有分类。
- en: 'The `category-controller.js` should be like this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`category-controller.js` 应该是这样的：'
- en: '[PRE21]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We have created an AngularJS module. It helps us to keep the functions organized.
    It acts as a kind of namespace for us. The `.controller` function is a constructor
    to create our controller's instances. We received some parameters, the AngularJS
    framework will inject these objects for us.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个 AngularJS 模块。它帮助我们保持函数的有序。它充当我们的一种命名空间。`.controller` 函数是一个构造函数，用于创建我们控制器的实例。我们收到了一些参数，AngularJS
    框架将为我们注入这些对象。
- en: Creating the Category Service
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建分类服务
- en: The `CategoryService` objects is a singleton object because it is an AngularJS
    service. The service will interact with our CMS APIs powered by the Spring Boot
    application.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`CategoryService` 对象是一个单例对象，因为它是一个 AngularJS 服务。该服务将与我们的由 Spring Boot 应用程序提供的
    CMS API 进行交互。'
- en: We will use the `$http` service. It makes the HTTP communications easier.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `$http` 服务。它使 HTTP 通信更容易。
- en: 'Let''s write the `CategoryService`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写`CategoryService`：
- en: '[PRE22]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Well done, now we have implemented the `CategoryService`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 做得好，现在我们已经实现了 `CategoryService`。
- en: The `.service` function is a constructor to create a service instance, the `angular`
    acts under the hood. There is an injection on a constructor, for the service we
    need an `$http` service to make HTTP calls against our APIs. There are a couple
    of HTTP methods here. Pay attention to the correct method to keep the HTTP semantics.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`.service` 函数是一个构造函数，用于创建服务实例，`angular` 在幕后工作。构造函数上有注入，对于服务，我们需要一个 `$http`
    服务来对我们的 API 进行 HTTP 调用。这里有几个 HTTP 方法。请注意正确的方法以保持 HTTP 语义。'
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created our first Spring application. We saw Spring Initializr,
    the amazing tool that helps developers create the application skeleton.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了我们的第一个 Spring 应用程序。我们看到了 Spring Initializr，这是一个帮助开发者创建应用程序骨架的神奇工具。
- en: We looked at how Spring works under the hood and how the framework got configured
    with a couple of annotations. Now, we have a basic knowledge of the Spring Bootstrap
    functions, and we can understand the Dependency Injection and component scan features
    present in the framework.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了 Spring 在幕后是如何工作的，以及框架是如何通过几个注解进行配置的。现在，我们对 Spring 引导函数有了基本的了解，我们可以理解框架中存在的依赖注入和组件扫描功能。
- en: This knowledge is the basis for the next chapters, and now we are ready to start
    to work with more advanced features, such as persistence. Here we go. See you
    in the next chapter.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这项知识是下一章的基础，现在我们准备开始使用更高级的功能，例如持久性。让我们开始吧。下一章再见。
