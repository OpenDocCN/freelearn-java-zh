- en: Preparing Your Code for Java 9
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 Java 9 准备你的代码
- en: In the last chapter, we looked at several patterns and best practices to use
    when building Java 9 modular applications. They are an extremely handy set of
    rules to remember when building new applications. But it's not always that developers
    have the opportunity to work on greenfield projects where they have the freedom
    to think about and build application architecture from scratch. What if there's
    already a lot of code built using Java 8 or earlier? How do we migrate such code
    to Java 9?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章，我们探讨了在构建 Java 9 模块化应用程序时可以使用的一些模式和最佳实践。它们是一套极其实用的规则，当构建新应用程序时值得记住。但是，开发者并不总是有机会在绿地项目中工作，在这些项目中他们有自由从头开始思考和构建应用程序架构。如果已经有很多使用
    Java 8 或更早版本构建的代码怎么办？我们如何将这些代码迁移到 Java 9？
- en: 'In this chapter, we''ll be covering:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Working on legacy code and getting it ready to be run in Java 9
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理遗留代码并使其准备好在 Java 9 中运行
- en: Compiling legacy code in Java 9 and executing pre-Java 9 compiled code in the
    Java 9 runtime
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Java 9 中编译遗留代码并在 Java 9 运行时执行 Java 9 之前的编译代码
- en: Classpath behaviors in Java 9 and the unnamed module
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 9 中的类路径行为和未命名的模块
- en: Handling errors and non-standard API access and using the jdeps tool
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理错误和非标准 API 访问以及使用 jdeps 工具
- en: Using override switches to work around tricky code and APIs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用覆盖开关来处理棘手的代码和 API
- en: Beginning Java 9 migration
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始 Java 9 迁移
- en: You probably have some Java 8 (or earlier) code on your hands. And you are probably
    wondering what you'll need to do to get this to work with Java 9\. When the Java
    9 specification was going through the **Java Community Process** (**JCP**), there
    was some concerns in the developer community about just this. Will the legacy
    Java code work as-is in Java 9? If there are changes to be made, how much time
    and effort would they consume? Fortunately, Java has a great track record of maintaining
    backward compatibility, and that continues even with such major changes that have
    been brought into the language with the new modularity features. However, since
    Java 9 is one of the biggest overhauls to the Java internals, there might be some
    work that needs to be done. The amount of work depends primarily on two factors--the
    nature of migration you are trying to perform and the way the code itself is written.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能有一些 Java 8（或更早）的代码。你可能想知道你需要做什么才能让它与 Java 9 一起工作。当 Java 9 规范正在通过**Java 社区过程**（**JCP**）时，开发社区对此有一些担忧。遗留的
    Java 代码在 Java 9 中是否可以按原样工作？如果需要做出更改，它们将消耗多少时间和精力？幸运的是，Java 在维护向后兼容性方面有着出色的记录，即使在引入语言的新模块化特性这样的重大变化中也是如此。然而，由于
    Java 9 是对 Java 内部结构最大的重整之一，可能需要进行一些工作。工作的量主要取决于两个因素——你试图执行的迁移性质以及代码本身的编写方式。
- en: 'Now what do I mean by *nature of migration*? When tackling Java 9 migration,
    it''s useful to think about the effort in stages. At a high level, you could move
    your existing pre-Java 9 code through the following two stages:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我所说的“迁移性质”是什么意思？当处理 Java 9 迁移时，将努力分为几个阶段是有用的。从高层次来看，你可以将现有的 Java 9 之前的代码通过以下两个阶段进行迁移：
- en: Getting your code to compile and execute in Java 9 as-is.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让你的代码在 Java 9 中编译和执行。
- en: Refactoring the structure of your code to use the modularity features.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对你的代码结构进行重构以使用模块化特性。
- en: '**Step 1** involves using the `javac` and the `java` commands on your existing
    code base just like you have done all along, but with the new Java 9 version of
    the compiler and runtime. In this phase you''d like to make as little changes
    to the code as possible! **Step 2** involves refactoring or rewriting your code
    to use modularity features, including the things we''ve learned so far in this
    book--breaking down the code base into modular units, creating `module-info.java`
    for each of those modules and then establishing relationships between the modules.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**第一步**涉及使用与之前相同的`javac`和`java`命令处理现有的代码库，但使用新的 Java 9 版本的编译器和运行时。在这个阶段，你希望尽可能少地更改代码！**第二步**涉及重构或重写你的代码以使用模块化特性，包括我们在本书中学到的内容——将代码库分解成模块单元，为每个模块创建`module-info.java`，然后在这些模块之间建立关系。'
- en: Are both these steps necessary for migrating to Java 9? Well, **Step 1** is.
    For any application that you plan to run and use in the foreseeable future, it's
    worth getting it to at least work with the new Java 9 runtime. That way, you are
    ready for whenever Java 8 becomes *end-of-lifed* in the future. This type of migration
    should be relatively easy, except for a few things to look out for that we'll
    cover in this chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个步骤对于迁移到 Java 9 是否都是必要的？嗯，**第一步**是必要的。对于你计划在未来运行和使用的任何应用程序，至少让它与新 Java 9 运行时兼容是值得的。这样，你就可以随时准备应对
    Java 8 在未来成为 *生命终结* 的情况。这种类型的迁移应该相对简单，除了我们将在本章中介绍的一些需要注意的事项。
- en: After you've done that, and your applications now work with Java 9 compiler
    and runtime, you do have an option of refactoring your code to use all the cool
    new modular features you've learned. But that may not always be valuable. If you
    have code that you don't plan to modify or enhance over time, and you just need
    to *maintain* it to run the business, you aren't going to get a lot of value by
    refactoring it to use Java 9 modules.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在你完成这些之后，并且你的应用程序现在可以与 Java 9 编译器和运行时一起工作，你确实有一个选择，可以将你的代码重构为使用你已学到的所有酷炫的新模块化功能。但这可能并不总是有价值的。如果你有计划在未来不修改或增强的代码，并且你只需要
    *维护* 它以运行业务，那么通过重构它来使用 Java 9 模块，你不会得到很多价值。
- en: However, if you anticipate making changes and actively working on the code base,
    there is benefit to refactoring the code to use modules. The next chapter deals
    with migrating code that involves using the rich JPMS features we now get with
    Java 9.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你预计会进行更改并积极地对代码库进行工作，将代码重构为使用模块是有好处的。下一章将处理涉及使用我们现在通过 Java 9 获得的丰富 JPMS
    功能的代码迁移。
- en: We'll be covering **Step 1** in this chapter. **Step 2** is covered in [Chapter
    11](part0172.html#5410O0-ed2405f4162b4f86b565edd6b6d679fb), *Migrating Your Code
    to Java 9*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中介绍 **第一步**。**第二步**在 [第 11 章](part0172.html#5410O0-ed2405f4162b4f86b565edd6b6d679fb)
    中介绍，*将您的代码迁移到 Java 9*。
- en: Introducing the sample Java 8 application
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍示例 Java 8 应用程序
- en: We will be using a sample Java 8 code base to try migrating to Java 9\. It's
    a command-line `shopping bag` utility. When you run the application, it prompts
    you to add items to your shopping bag. Once you've added all the items and you
    are done, you type `end`. The application then displays a consolidated shopping
    list of items that you've added. The application is intentionally simple, but
    it gives us a good starting point to work through the migration.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个示例 Java 8 代码库来尝试迁移到 Java 9。它是一个命令行 `购物袋` 工具。当你运行应用程序时，它会提示你将项目添加到你的购物袋中。一旦你添加了所有项目并且完成，你输入
    `end`。应用程序随后显示你已添加的项目的综合购物清单。应用程序故意很简单，但它为我们提供了一个很好的起点，以便在迁移过程中进行工作。
- en: 'Here''s a screenshot of the application in action:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是应用程序运行时的截图：
- en: '![](img/00084.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/00084.jpeg)'
- en: 'The application consists of three classes in three different packages:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序由三个不同包中的三个类组成：
- en: 'The `ShoppingBag` class: It contains a method to add items to a shopping bag,
    and one to pretty print the contents of the bag. The class uses the `Bag` data
    structure from the Apache Commons Collections library. Think of this data structure
    as something similar to a `Set`, but with duplicates allowed:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ShoppingBag` 类：它包含一个将项目添加到购物袋的方法，以及一个用于打印袋子内容的格式化方法。该类使用 Apache Commons Collections
    库中的 `Bag` 数据结构。将这种数据结构想象成类似于 `Set`，但允许重复：'
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `UserInputUtil` class: It contains a method to prompt the user for an input.
    It also contains a public `close` method to close the input stream when done:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserInputUtil` 类：它包含一个提示用户输入的方法。它还包含一个公开的 `close` 方法，用于完成输入流时关闭：'
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `App` class: Putting it all together. This class has the `main` method.
    It uses the `UserInputUtil` to prompt the user to enter items into the shopping
    bag. It adds each item to a `ShoppingBag` instance, and it then prints the bag
    when done:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`App` 类：将所有内容整合在一起。这个类包含 `main` 方法。它使用 `UserInputUtil` 来提示用户将项目输入到购物袋中。它将每个项目添加到
    `ShoppingBag` 实例中，完成后打印出袋子：'
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In addition to the application code, there's a `lib` folder with the Apache
    Commons Collection library JAR file--`commons-collections4-4.1.jar`. The code
    depends on this library JAR file. We'll need to add this JAR file to the classpath
    when compiling and running the code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 除了应用程序代码外，还有一个 `lib` 文件夹，其中包含 Apache Commons Collections 库的 JAR 文件--`commons-collections4-4.1.jar`。代码依赖于这个库
    JAR 文件。在编译和运行代码时，我们需要将这个 JAR 文件添加到类路径中。
- en: I recommend looking at the included source code at the location -`10-migrating-application/01-legacy-app`and
    getting familiar with it. We'll be using this application as we work through the
    migration process.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议查看位于`-10-migrating-application/01-legacy-app`的包含源代码的位置，并熟悉它。在迁移过程中，我们将使用这个应用程序。
- en: Using the Java 9 compiler and runtime
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Java 9编译器和运行时
- en: Let's get started with the first step--compiling and running an old code base
    using the Java 9 compiler and runtime. It'll be great if things work as-is. If
    changes are required, we'd like to make as few of them as possible.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一步开始——使用Java 9编译器和运行时编译和运行旧代码库。如果一切按预期进行，那就太好了。如果需要更改，我们希望尽可能少地更改。
- en: 'First, make sure you are using Java 9 using the following command. If you have
    a different version, you''ll need to switch, as covered in [Chapter 2](part0033.html#VF2I0-ed2405f4162b4f86b565edd6b6d679fb),
    *Creating Your First Java Module*:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请确保您正在使用Java 9，可以使用以下命令进行确认。如果您使用的是不同版本，您需要切换版本，这已在[第2章](part0033.html#VF2I0-ed2405f4162b4f86b565edd6b6d679fb)“创建您的第一个Java模块”中介绍过：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'From the project folder, create a new out directory for our compiled classes
    and run the following Java compiler command to compile all the `.java` files:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从项目文件夹中，为我们的编译类创建一个新的`out`目录，并运行以下Java编译器命令来编译所有的`.java`文件：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding `javac` command, we are adding the commons collections JAR
    file to the classpath using the `-cp` option, specifying the output directory
    for the compiled classes using the `-d` option and then specifying all the `.java`
    files in the following directories recursively using `$(find . -name '*.java')`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`javac`命令中，我们使用`-cp`选项将公共集合JAR文件添加到classpath中，使用`-d`选项指定编译类的输出目录，然后使用`$(find
    . -name '*.java')`递归地指定以下目录中的所有`.java`文件。
- en: 'The compilation step should go through fine without any errors. Great! Let''s
    try to run it:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 编译步骤应该顺利通过，没有任何错误。太好了！让我们尝试运行它：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding `java` command, we are specifying two paths in the classpath
    `-cp` option--the `out` directory that contains the compiled classes and the common
    collections JAR file. Following that is the fully qualified class name of the
    class with the `main` method.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`java`命令中，我们在classpath的`-cp`选项中指定了两个路径——包含编译类的`out`目录和公共集合JAR文件。接下来是包含`main`方法的类的完全限定类名。
- en: Notice that we are still using classpath and not the concept of module path.
    Java 9 still works with classpath, and with the same `-cp` option as did the previous
    Java versions. More on that shortly.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们仍在使用classpath而不是模块路径的概念。Java 9仍然与classpath一起工作，并且与之前Java版本相同的`-cp`选项。关于这一点，稍后会有更多介绍。
- en: 'Running the command should result in success, with the prompt being displayed
    as expected. And there you have it! A Java 8 application has compiled and executed
    using Java 9, and not a single line of code needed to be changed! As much as I''d
    love to tell you that all legacy code will work just as easily as this, it is
    unfortunately not true. There are some cases that need more effort. However, the
    good thing is that in the majority of the cases, this process *should* be this
    effortless. We''ll look at some of the cases where you might run into problems,
    and how to address them in the next section. But first, knowing what we now know
    about Java 9, isn''t it surprising that everything worked well? If you think about
    it, both the compilation and execution should have failed! Why? Here are a couple
    of reasons:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令应该会成功，提示符会按预期显示。这就是了！一个Java 8应用程序已经使用Java 9编译和执行，而且不需要更改任何一行代码！尽管我很想告诉您，所有遗留代码都将像这样轻松地工作，但不幸的是，事实并非如此。有些情况需要更多的努力。然而，好消息是，在大多数情况下，这个过程*应该*是如此轻松。我们将在下一节中查看您可能会遇到问题的某些情况，以及如何解决这些问题。但首先，鉴于我们现在对Java
    9的了解，一切工作得如此顺利，这不是很令人惊讶吗？如果您仔细想想，编译和执行都应该失败！为什么？以下是一些原因：
- en: We learned that Java 9 is moving to a module system and that *everything*, be
    it the application code or the platform, should be in a module! Our Java 8 code
    is obviously not in a predefined module. That's fine in Java 8, but shouldn't
    that have caused an error in Java 9?
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们了解到Java 9正在转向模块系统，并且*所有*东西，无论是应用程序代码还是平台，都应该在一个模块中！我们的Java 8代码显然不在预定义的模块中。这在Java
    8中是可以的，但在Java 9中不应该导致错误吗？
- en: Notice that `App.java` is using the Java logging API. We've learned in [Chapter
    4](part0058.html#1NA0K0-ed2405f4162b4f86b565edd6b6d679fb), *Introducing the Modular
    JDK* that the logging APIs have been bundled into a separate platform module called
    `java.logging` . And all code that accesses any module that's not `java.base` should require it
    explicitly. That's clearly not happening in the code here, because this is Java
    8 code, and there's no `module-info.java` module definition to begin with.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意到`App.java`正在使用Java日志API。我们在[第4章](part0058.html#1NA0K0-ed2405f4162b4f86b565edd6b6d679fb)，*介绍模块化JDK*中了解到，日志API已经被打包到一个名为`java.logging`的独立平台模块中。并且访问任何不是`java.base`的模块的所有代码都应该明确要求它。显然，这里的代码并没有这样做，因为这是Java
    8代码，而且一开始就没有`module-info.java`模块定义。
- en: This begs the question--how did compiling and executing this code in Java 9
    still work? It all works thanks to some special features introduced in the language
    to support this very process--executing legacy code in Java 9\. The specific feature
    that's working for us here is called the **unnamed module**.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这引发了一个问题——为什么在Java 9中编译和执行这段代码仍然可以工作？这一切都得益于语言中引入的一些特殊功能，以支持这个过程——在Java 9中执行遗留代码。这里为我们工作的特定功能被称为**未命名模块**。
- en: The unnamed module
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未命名模块
- en: Well, we weren't wrong. All code in Java 9 *needs* to be in modules. And all
    modules need to have the right readability and accessibility relationships for
    applications to work. But that might be problematic! Because, as with every new
    Java release, there are thousands of developers trying to run their legacy Java
    code bases using the new Java version. If we were to expect each legacy Java code
    base to be wrapped into modules before it can even run in Java 9, which would
    introduce a significant cost of effort in the developer community. Thankfully,
    there's a way out. When you are using Java 9 to compile or run legacy module-less
    Java code in the classpath, you *don't* have to manually create module wrappers
    yourself. The platform automatically creates a single module that comprises of
    everything you have in your classpath. This module doesn't have a name and so,
    is referred to as the *unnamed module*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们并没有错。Java 9中的所有代码*都需要*在模块中。所有模块都需要有正确的可读性和可访问性关系，以便应用程序能够正常工作。但这可能是个问题！因为，就像每个新的Java版本一样，有成千上万的开发者试图使用新的Java版本运行他们的遗留Java代码库。如果我们期望每个遗留Java代码库在Java
    9中运行之前都封装到模块中，这将给开发者社区带来巨大的努力成本。幸运的是，有一个解决办法。当你使用Java 9编译或运行类路径中的遗留无模块Java代码时，你*不需要*手动创建模块包装器。平台会自动创建一个包含你类路径中所有内容的单个模块。这个模块没有名字，因此被称为*未命名模块*。
- en: 'With all the Java 9 code we''ve compiled and executed so far, we''ve not been
    using the classpath at all. Here''s a schematic of the modules in our Java 9 application
    as we''ve been running it so far:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们编译和执行的所有Java 9代码都没有使用类路径。以下是到目前为止我们运行Java 9应用程序中的模块示意图：
- en: '![](img/00085.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00085.jpeg)'
- en: 'We''ve so far had the whole runtime work with built-in platform modules in
    the JRE along with your application modules from the module path. These together
    form the complete set of observable modules. Now what happens if you throw in
    the classpath in there? When running with the classpath option, here''s how the
    picture looks like:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，整个运行时都使用JRE中的内置平台模块以及来自模块路径的应用程序模块一起工作。这些共同构成了可观察模块的完整集合。那么，如果你在其中有类路径会发生什么呢？在带有类路径选项运行时，画面如下所示：
- en: '![](img/00086.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00086.jpeg)'
- en: 'And here''s where we would have violated the *all-code-needs-to-be-in-modules*
    rule. Thanks to the automatic module feature, we haven''t. The Java 9 platform
    automatically wraps all the classes and JARs in the classpath into one unnamed
    module:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正是在这里，我们本应违反了*所有代码都需要在模块中*的规则。幸亏有了自动模块功能，我们并没有这样做。Java 9平台自动将类路径中的所有类和JAR文件封装到一个未命名的模块中：
- en: '![](img/00087.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00087.jpeg)'
- en: 'This is exactly what''s happening to the shopping bag application. All the
    application code, including the common collections jar is a part of the single
    unnamed module. OK, that addresses one of the concerns. How about the second one?
    How did the code get access to the Java logging API? Shouldn''t the unnamed module
    declare requires `java.logging`? But how could it? The unnamed module doesn''t
    have a `module-info.java` file anyway! Because the platform cannot really tell
    for sure what the classpath code needs, the unnamed module is automatically given
    readability access to *all* observable modules. In other words, it mimics the
    *free-for-all* behavior of code in the classpath pre-Java 9--it `requires` everything,
    because that''s the only way the platform can maximize the chances of any legacy
    code working as-is in Java 9\. If you were to draw a module graph, it would look
    like the unnamed module has readability relationship to every module in the set
    of observable modules, as represented in the following diagram:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是购物袋应用程序所发生的情况。所有应用程序代码，包括公共集合jar文件，都是单个未命名模块的一部分。好的，这解决了其中一个担忧。第二个问题呢？代码是如何访问Java日志API的？未命名的模块不应该声明`requires
    java.logging`吗？但是它怎么能够做到呢？未命名的模块根本就没有`module-info.java`文件！因为平台无法真正确定类路径代码需要什么，所以未命名的模块自动获得了对所有可观察模块的可读性访问。换句话说，它模仿了Java
    9之前类路径中代码的“自由forall”行为——它`requires`一切，因为这是平台最大化任何遗留代码在Java 9中按原样工作的唯一方式。如果你要绘制一个模块图，它将看起来像未命名的模块与可观察模块集中的每个模块都有可读性关系，如下面的图所示：
- en: '![](img/00088.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00088.jpeg)'
- en: This diagram is very messy, so we'll not draw this again. From now on, we'll
    just simplify all the readability edges coming out of the automatic module into
    a single arrow to keep things legible.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图非常混乱，所以我们不会再绘制这个图。从现在开始，我们将把来自自动模块的所有可读性边缘简化为单个箭头，以保持内容的可读性。
- en: 'The automatic module feature was built into the platform specifically for migration
    purposes, and as you can see, it''s the reason why our Java 8 code was able to
    compile and run in Java 9 without any errors. To summarize:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 自动模块功能是专门为了迁移目的而构建到平台中的，正如你所见，这也是我们的Java 8代码能够在Java 9中编译和运行而没有任何错误的原因。总结一下：
- en: Every time you supply the `-classpath` option to compile or execute code in
    Java 9, the platform creates an unnamed module. All classes and jars in the supplied
    classpath are bundled into this unnamed module.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次你在Java 9中提供`-classpath`选项来编译或执行代码时，平台都会创建一个未命名的模块。提供的类路径中的所有类和jar文件都被捆绑到这个未命名的模块中。
- en: The unnamed module automatically *reads* every observable module. Thus, not
    only does it read all the Java 9 platform modules, it also reads all your application
    and library modules in the module path (if you've supplied the module path argument
    to the command, in addition to the classpath.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未命名的模块自动*读取*每个可观察模块。因此，它不仅读取所有Java 9平台模块，还读取你在模块路径中的所有应用程序和库模块（如果你在命令中提供了模块路径参数，除了类路径）。
- en: Every time you use the Java compiler without any module path options, you runs
    the compiler in what's referred to as a *single module mode*. In this mode, like
    we've seen, we are dealing with the single unnamed module. The code is expected
    to be organized into the traditional package-based directory structure, and there
    are no module folders.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你使用Java编译器而不提供任何模块路径选项时，你就是在所谓的*单模块模式*下运行编译器。在这种模式下，就像我们所看到的，我们正在处理单个未命名的模块。代码应该被组织成传统的基于包的目录结构，并且没有模块文件夹。
- en: Handling non-standard access
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理非标准访问
- en: Wait! There's a catch! The unnamed module reads all Java platform modules and
    because of that, I mentioned it mimics the *free-for-all* behavior of the pre-Java
    9 platform. But that's not exactly true. Pre-Java 9, the entire platform, and
    all the classes in it were accessible to your application code. With Java 9 platform
    modularization, there are several internal types in platform modules that are
    not exported, thus making them encapsulated. It's a good thing that the unnamed
    module automatically reads all platform modules by default, but is that enough?
    Not really, because it just enables the code in the classpath to access only the
    types *exported* from the modules. But what if your legacy code uses a type that
    is now encapsulated in a platform module in Java 9? Just having the unnamed module
    read all the platform modules is not enough, because the encapsulated types would
    still not be available. The same problem exists for code that accesses types that
    are removed. Yes, there are certain types in JDK 8 and earlier that are no longer
    available in Java 9\. And any legacy code that uses such types will fail to compile
    and run in Java 9.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 等等！有一个陷阱！未命名的模块读取所有 Java 平台模块，因此我提到它模仿了预 Java 9 平台的“自由放任”行为。但这并不完全正确。在 Java
    9 之前，整个平台及其中的所有类都对应用程序代码是可访问的。随着 Java 9 平台模块化，平台模块中有几个内部类型没有被导出，因此它们是封装的。自动读取所有平台模块是一个好事，但这足够吗？并不真正如此，因为它只是允许类路径中的代码访问模块中导出的类型。但如果你遗留的代码使用了现在封装在
    Java 9 平台模块中的类型怎么办？仅仅让未命名的模块读取所有平台模块是不够的，因为封装的类型仍然不可用。对于访问已删除类型的代码也存在相同的问题。是的，在
    JDK 8 及更早版本中，某些类型在 Java 9 中不再可用。并且任何使用这些类型的遗留代码在 Java 9 中将无法编译和运行。
- en: 'The code at `10-migrating-application/02-non-standard-api` is an example of
    a code with such access of internal types. The class `App.java` uses two types:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`10-migrating-application/02-non-standard-api` 中的代码是一个具有此类内部类型访问的代码示例。`App.java`
    类使用了两种类型：'
- en: '`Base64Encoder` that was available in previous versions of Java, but now with
    Java 9, has been completely removed'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Base64Encoder`，在 Java 的先前版本中可用，但现在随着 Java 9 的推出，已被完全移除'
- en: '`CalendarUtils`, which is encapsulated as an internal type in the`java.base` module
    in Java 9'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CalendarUtils`，在 Java 9 的 `java.base` 模块中作为内部类型封装'
- en: Even if you were creating a new Java 9 module, there's no platform module that
    your code can require to access it. The type is not exported from the module and
    so is effectively sealed. Thus, even the unnamed module would not be able to access
    them.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你正在创建一个新的 Java 9 模块，也没有平台模块可以让你的代码要求访问它。该类型没有从模块中导出，因此实际上是密封的。因此，即使是未命名的模块也无法访问它们。
- en: 'Here''s the sample code. The code itself is completely non-functional as it
    is just an attempt to try using these two types:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例代码。代码本身完全无效，因为它只是尝试使用这两种类型：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Switch to Java 8 compiler and compile the code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到 Java 8 编译器并编译代码：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that while the compilation goes through, you do see warnings!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然编译过程顺利，但你确实看到了警告！
- en: '![](img/00089.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00089.jpeg)'
- en: For quite a while now, developers have been warned about such usages of internal
    types! For someone working on such code, it should not come as a surprise that
    these APIs don't work in Java 9.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 很长一段时间以来，开发者们都被警告过这种内部类型的用法！对于正在编写这种代码的人来说，这些 API 在 Java 9 中不起作用并不应该令人惊讶。
- en: 'Let''s switch to Java 9 and compile this code. Use the following command on
    macOS or Linux:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们切换到 Java 9 并编译此代码。在 macOS 或 Linux 上使用以下命令：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: On Windows, follow the steps outlined in [Chapter 2](part0033.html#VF2I0-ed2405f4162b4f86b565edd6b6d679fb),
    *Creating Your First Java Module*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，按照 [第 2 章](part0033.html#VF2I0-ed2405f4162b4f86b565edd6b6d679fb)
    中概述的步骤，*创建您的第一个 Java 模块*。
- en: 'After switching the Java version to 9, run the compile command on this code.
    This time, you don''t get warnings. You get errors and the code doesn''t compile:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Java 版本切换到 9 后，运行此代码的编译命令。这次，你不会收到警告。你会得到错误，代码无法编译：
- en: '![](img/00090.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00090.jpeg)'
- en: 'Notice that there are two different errors, one for each type:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到有两个不同的错误，每个类型一个：
- en: The error for `CalendarUtils` indicates that the type is now encapsulated (that
    is, not exported) from `java.base`.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CalendarUtils` 的错误表明该类型现在已被封装（即未导出）从 `java.base`。'
- en: The error for `BASE64Encoder` mentions that the compiler just doesn't find it.
    The type has been removed from Java 9.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BASE64Encoder` 的错误提到编译器找不到它。该类型已被从 Java 9 中移除。'
- en: When compiling and running legacy code in Java 9, these are two of the most
    likely errors you could get because of the modularity changes. Fixing either of
    these errors requires changing your code. You'll have to either find an equivalent
    class or API in the new platform that does what you need. Or find an external
    library that has the APIs you need. What's tricky is that the problematic code
    may not necessarily be in your application code. It could be in a library or a
    framework that you use. Even in that case, your application won't compile or run
    in Java 9, until you remove the dependency or the library is updated.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Java 9中编译和运行遗留代码时，由于模块化变更，你可能会遇到这两种最有可能的错误。修复这些错误之一需要更改你的代码。你可能需要在新平台上找到一个等效的类或API来完成你需要的功能。或者找到一个包含所需API的外部库。棘手的是，有问题的代码可能不一定在你的应用程序代码中。它可能在你使用的库或框架中。即使在那种情况下，你的应用程序在Java
    9中也不会编译或运行，直到你移除依赖项或库被更新。
- en: There is some help that the platform provides to help you identify such problems
    with your application and its dependencies. It's a tool called `jdeps`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 平台提供了一些帮助，以帮助你识别应用程序及其依赖项中存在的问题。这是一个名为`jdeps`的工具。
- en: '`jdeps` was first shipped with Java 8 to help developers identify and fix internal
    API access. With Java 9, it''s much more helpful and detailed.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`jdeps`最初与Java 8一起发布，以帮助开发者识别和修复内部API访问问题。在Java 9中，它变得更加有用和详细。'
- en: The jdeps tool
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jdeps工具
- en: The **Java Dependency Analysis Tool** (**jdeps**) is a utility that can statically
    examine your application and library classes to identify if there are any uses
    of the JDK internal APIs that no longer work with Java 9\. You can run `jdeps`
    on your compiled class files or JARs, and have it list out all such references.
    For each reference, `jdeps` will highlight usages of internal types that are no
    longer available for your code to use. It even suggests replacement APIs if they
    are available.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java依赖分析工具**（**jdeps**）是一个实用工具，可以静态地检查你的应用程序和库类，以确定是否有任何不再与Java 9兼容的JDK内部API的使用。你可以在编译好的类文件或JAR上运行`jdeps`，并让它列出所有此类引用。对于每个引用，`jdeps`将突出显示不再可用于你的代码使用的内部类型的使用。如果可用，它甚至会建议替代API。'
- en: 'The command syntax looks like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 命令语法如下：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you have a bunch of classes compiled and you want to run `jdeps` on them,
    you can even provide a classpath parameter:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一堆编译好的类，并想在它们上运行`jdeps`，你可以甚至提供classpath参数：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s try this with the `02-non-standard-api` project. We''ve already compiled
    the project (albeit with warnings) with the Java 8 compiler, and the classes now
    exist in the out directory. Running `jdeps` on them yields the following output:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用`02-non-standard-api`项目来试一试。我们已经用Java 8编译器编译了这个项目（尽管有警告），现在类已经存在于out目录中。对它们运行`jdeps`会得到以下输出：
- en: '![](img/00091.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00091.jpeg)'
- en: '`sun.misc.BASE64Encoder` is indicated as a *JDK removed internal API* while
    `sun.util.calendar.CalendarUtils` is indicated as a JDK internal API from `java.base`.
    In the case of `BASE64Encoder`, the tool provides a helpful suggestion to use
    an alternative API (`java.util.Base64`) that has been available in Java since
    version 1.8.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`sun.misc.BASE64Encoder`被标记为*JDK已移除的内部API*，而`sun.util.calendar.CalendarUtils`被标记为来自`java.base`的JDK内部API。在`BASE64Encoder`的情况下，工具提供了一个有用的建议，即使用自Java
    1.8版本以来就可用作为替代的API（`java.util.Base64`）。'
- en: '`jdeps` can also be run on JARs as previously mentioned. If we were to run
    the tool on the included `01-app-migration` project for example, we''ll get no
    output. Which is a good thing because that means there are no JDK internals being
    used, and the JAR is good to use for Java 9:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`jdeps`也可以在JAR上运行。如果我们运行包含的`01-app-migration`项目上的工具，我们将得到没有输出。这是一个好事，因为这表明没有使用JDK内部API，JAR可以用于Java
    9。
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`jdeps` is a *static* code analysis tool, with emphasis on the word *static*.
    It looks at the code to identify illegal API use. It cannot identify dynamic runtime
    use through reflection, for example. Thus, there is a chance that `jdeps` gives
    you the all-clear for a code base, but when you run it, you might still end up
    with an `IllegalAccessException` because the code uses reflection to access an
    internal type that''s no longer available.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`jdeps`是一个*静态*代码分析工具，重点在于单词*静态*。它查看代码以识别非法API使用。它不能通过反射识别动态运行时使用。因此，有可能`jdeps`给你的代码库给出了全部放行的信号，但当你运行它时，你可能会遇到`IllegalAccessException`，因为代码使用了反射来访问不再可用的内部类型。'
- en: To summarize, `jdeps -jdkinternals` is a great tool to use to check your pre-compiled
    application and library classes and verify any incompatibilities with Java 9\.
    It is especially helpful that the tool recommends alternative options to use when
    possible.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`jdeps -jdkinternals`是一个检查预编译的应用程序和库类并验证与Java 9任何不兼容性的优秀工具。特别有用的是，该工具在可能的情况下推荐使用替代选项。
- en: Overriding module behavior
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖模块行为
- en: '`jdeps` is great at identifying internal API access and suggesting fixes. They
    come in handy when fixing your own application code that contains such problems.
    But what if `jdeps` reports problems with some code in a library or a framework
    you are using? In such cases, you have lesser control over the code. Even if the
    framework itself is open source, the scale and complexity of the library may not
    make it feasible for you to implement the fix yourself. This does present a very
    clear risk for applications moving to Java 9--your app won''t run in Java 9 until
    all your libraries are updated to work in Java 9\. It''s very likely that most
    library developers have either already heeded to the scores of warnings in Java
    8 and fixed their code, or they will soon, because of their code breaking in Java
    9\. But if they don''t, this could mean that your migration plans are at the mercy
    of the library authors.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`jdeps`在识别内部API访问和提出修复建议方面非常出色。当修复包含此类问题的自己的应用程序代码时，它们非常有用。但是，如果`jdeps`报告了你正在使用的库或框架中某些代码的问题呢？在这种情况下，你对代码的控制较少。即使框架本身是开源的，库的规模和复杂性可能不会使你能够自己实施修复。这确实为迁移到Java
    9的应用程序带来了一个非常明显的问题——直到你的所有库都更新到可以在Java 9中工作，你的应用程序才会在Java 9中运行。很可能大多数库开发者已经注意到了Java
    8中的大量警告并修复了他们的代码，或者他们很快就会这样做，因为他们的代码在Java 9中会中断。但是，如果他们不这样做，这可能意味着你的迁移计划将取决于库的作者。'
- en: Thankfully, the platform comes with some override features to get around this
    problem. The override features we'll look at here apply not just to legacy Java
    code being compiled in Java 9, they also work on Java 9 modules. But since they
    are primarily designed to assist migration, they should be used in the context
    of migration only, and other uses should ideally be avoided.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，平台提供了一些覆盖功能来解决这个问题。我们在这里要查看的覆盖功能不仅适用于在Java 9中编译的遗留Java代码，它们也适用于Java 9模块。但是，由于它们主要是为了帮助迁移而设计的，因此它们应该仅在迁移的上下文中使用，其他用途理想情况下应避免。
- en: What are these override features? Remember that a Java 9 module has a *module
    definition* that specifies what it `requires` and what it `exports`. These individual
    module definitions that are specified in the `module-info.java` file at development
    time essentially control the accessibility relationship between modules during
    compilation and runtime. However, it turns out, both the compiler and runtime
    has override options for these module relationships that allow you to change what
    any given module `requires` or `exports` by specifying command-line arguments.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些覆盖功能是什么？请记住，Java 9模块有一个*模块定义*，它指定了它`requires`什么和它`exports`什么。这些在开发时在`module-info.java`文件中指定的单个模块定义实际上控制了模块在编译和运行时的可访问性关系。然而，结果却是，编译器和运行时都有覆盖这些模块关系的选项，允许你通过指定命令行参数来更改任何给定模块`requires`或`exports`的内容。
- en: 'There are three command line flags to `javac` and `java` to override specific
    module configurations:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个命令行标志用于`javac`和`java`来覆盖特定的模块配置：
- en: '`add-reads`: The `--add-reads` option allows you to specify additional readability
    relationships that may not already be available for a module as per the module
    configuration. The syntax is:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add-reads`：`--add-reads`选项允许你指定可能尚未在模块配置中可用的附加可读性关系。语法是：'
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Adding this option to the `javac` and `java` command line creates a new readability
    relationship only for that command execution you use the argument for. For example,
    let''s say you have modules `moduleA` and `moduleB`, and you want to have `moduleA`
    read `moduleB`. You can either edit the `module-info.java` file in `moduleA` and
    add the line requires `moduleB;`, or add the following argument to the compiler
    and runtime, as shown in this following truncated command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将此选项添加到`javac`和`java`命令行中，只为使用该参数的命令执行创建一个新的可读性关系。例如，假设你有模块`moduleA`和`moduleB`，你想要`moduleA`读取`moduleB`。你可以编辑`moduleA`中的`module-info.java`文件并添加行`requires
    moduleB;`，或者添加以下参数到编译器和运行时，如下所示的这个截断命令：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`add-exports`: The `--add-exports` option allows you to add additional exported
    packages from a module, thereby breaking or overriding encapsulation. The syntax
    is:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add-exports`：`--add-exports`选项允许你从模块添加额外的导出包，从而打破或覆盖封装。语法是：'
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For example, if `moduleA` needs package `pack.internal` from `moduleB`, but
    `moduleB` does not export the package, you can add the following override to have
    `moduleB` export the required package for `moduleA`, as shown in this truncated
    command:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，如果`moduleA`需要从`moduleB`获取`pack.internal`包，但`moduleB`没有导出该包，你可以添加以下覆盖，使`moduleB`为`moduleA`导出所需的包，如以下截断命令所示：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`add-opens`: The `--add-opens` option lets you override the `opens` relationship
    between modules to allow reflective access. This is an override that simulates
    the `opens` keyword configuration in the module definition. The syntax is:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add-opens`：`--add-opens`选项允许你覆盖模块之间的`opens`关系以允许反射访问。这是一个模拟模块定义中`opens`关键字配置的覆盖。语法是：'
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Following the same example, if `moduleA` needs runtime-only reflective access
    to the package `pack.internal` in `moduleB`, you would run the `javac` or `java`
    command with the following option:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照相同的示例，如果`moduleA`需要`moduleB`中`pack.internal`包的运行时反射访问，你需要使用以下选项运行`javac`或`java`命令：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that the overrides are always *qualified*, that is, you specify them for
    a specific target module. For example, you don't use the `--add-exports` flag
    to export a package to every other module. You explicitly specify one or more
    target modules that the override applies to from the source module. That's a good
    thing because every override is made consciously and it's easy to track what is
    needed to get the application to work.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，覆盖总是*有资格的*，也就是说，你为特定的目标模块指定它们。例如，你不会使用`--add-exports`标志将包导出到每个其他模块。你明确指定一个或多个从源模块应用覆盖的目标模块。这是一个好事，因为每个覆盖都是经过深思熟虑的，并且很容易跟踪需要使应用程序正常工作所需的内容。
- en: There is another way to provide these overrides in addition to command line
    arguments. You can specify them inside JAR file manifests. Let's say you have
    an executable JAR file that needs some overrides to work with platform modules
    in Java 9\. To avoid having to specify these overrides everytime as command line
    arguments, you could just specify these as manifest attributes in the `MANIFEST.MF`
    file in your JAR file. As with all manifest attributes, the value should be specified
    following a space after the attribute name in the `MANIFEST.MF` file. The manifest
    attribute `Add-Exports` corresponds to the  `--add-exports` argument. The attribute  `Add-Opens`
    corresponds to `--add-opens`. There's no manifest attribute equivalent for `--add-reads`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 除了命令行参数之外，还有另一种提供这些覆盖的方法。你可以在JAR文件清单中指定它们。假设你有一个需要与Java 9平台模块一起工作的可执行JAR文件，并且需要进行一些覆盖。为了避免每次都需要作为命令行参数指定这些覆盖，你只需在JAR文件中的`MANIFEST.MF`文件中指定这些作为清单属性。与所有清单属性一样，值应在`MANIFEST.MF`文件中属性名称之后指定一个空格。清单属性`Add-Exports`对应于`--add-exports`参数。属性`Add-Opens`对应于`--add-opens`。没有与`--add-reads`对应的清单属性。
- en: In addition to these overrides, there's a master *kill switch* for any modularity
    related encapsulation for classes in the classpath--the `--permit-illegal-access`
    flag. Unlike the previous three options, this option works only on code in the
    classpath. This flag, when passed to `javac` or `java` effectively disables *all*
    readability and accessibility restrictions, thus making any type accessible to
    any other type in the classpath. It's almost as if there are no Java modularity
    features, and everything in the classpath works as if you are running in Java
    8 or earlier. As you'd expect, it's not a good idea to use this flag, especially
    if you are running code in production. This is provided to help developers migrate
    their classpath applications, and could very well be removed in the future. Think
    of this as a *last resort* option to get things to work as you work on migration.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些覆盖之外，还有一个针对类路径中类封装的任何模块化相关封装的“主关闭开关”——`--permit-illegal-access`标志。与前面的三个选项不同，此选项仅在类路径中的代码上工作。当将此标志传递给`javac`或`java`时，它有效地禁用了所有可读性和可访问性限制，从而使类路径中的任何类型都可以访问其他类型。这几乎就像没有Java模块化功能，类路径中的所有内容都像在Java
    8或更早版本中运行一样。正如你所期望的，使用此标志不是一个好主意，尤其是在你正在运行生产代码的情况下。这是为了帮助开发者迁移他们的类路径应用程序，并且完全有可能在未来被删除。将其视为在迁移过程中解决问题的*最后手段*选项。
- en: Now that you've learned these override options, how can you apply them to solve
    the problem we started discussing this section with libraries or classes in your
    Java 8 code that use encapsulated APIs, and thus no longer work in Java 9? If
    the code is not in your control and you cannot fix it to *avoid* using the encapsulated
    types, you could use the override switch to manually add the required `exports`!
    For example, our code in the `02-non-standard-api` used an internal non-exported
    type `CalendarUtils` from `java.base`. Since we obviously cannot change the module
    descriptor for the  `java.base` module, what we could instead do is pass the `--add-exports`
    option to the module and have it export the required packages.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了这些覆盖选项，你该如何将它们应用到解决我们在这个部分开始讨论的问题上呢？那就是在你的Java 8代码中使用封装的API的库或类，这些类在Java
    9中不再工作？如果代码不在你的控制之下，你不能修复它以*避免*使用封装的类型，你可以使用覆盖开关手动添加所需的`exports`！例如，我们在`02-non-standard-api`中使用的内部未导出类型`CalendarUtils`来自`java.base`。由于我们显然不能更改`java.base`模块的模块描述符，我们可以做的是将`--add-exports`选项传递给模块，并让它导出所需的包。
- en: 'But here''s a problem. Note that the syntax needs the source and target module
    names. The source module name is `java.base` of course. What is the target module?
    It''s the unnamed module, because it''s the classes in the classpath that needs
    this package. This brings up an interesting question--what is the name of the
    unnamed module? The unnamed module doesn''t have a name (or indeed it wouldn''t
    be called that!), but there''s a special token called `ALL-UNNAMED` that you can
    pass to the override arguments that let the platform know that you are referring
    to the unnamed module:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里有一个问题。请注意，语法需要源模块名和目标模块名。源模块名当然是`java.base`。那么目标模块是什么呢？它是未命名的模块，因为需要这个包的类在类路径中。这引发了一个有趣的问题——未命名的模块的名字是什么？未命名的模块没有名字（或者确实不会被称为那样！），但有一个特殊的标记`ALL-UNNAMED`，你可以将其传递给覆盖参数，让平台知道你正在引用未命名的模块：
- en: '![](img/00092.jpeg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00092.jpeg)'
- en: 'This command should solve the problem of the `CalendarUtils` access in our
    code. There''s still the missing `BASE64Encoder` type. There''s no command-line
    argument to fix that one. Like we''ve seen, the type simply doesn''t exist in
    Java 9\. We''ll have to replace it with something that does. Taking the suggestion
    provided by `jdeps`, the class `AppFixed.java` has the updated code that uses
    the `Base64class` instead:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令应该可以解决我们代码中`CalendarUtils`访问的问题。仍然缺少`BASE64Encoder`类型。没有命令行参数可以修复这个问题。就像我们看到的，这个类型在Java
    9中根本不存在。我们将不得不用其他东西来替换它。根据`jdeps`提供的建议，`AppFixed.java`类有更新的代码，它使用`Base64class`代替：
- en: '![](img/00093.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00093.jpeg)'
- en: This time, you don't get errors and the compilation goes through. You still
    see the warning about using an internal type. The compiler still reminds you that
    it's not an ideal situation, but since you've added the override, it trusts that
    you know what you are doing.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，你没有遇到错误，编译过程也顺利通过了。你仍然会看到关于使用内部类型的警告。编译器仍然提醒你这不是一个理想的情况，但既然你已经添加了`override`，它相信你知道你在做什么。
- en: If the code was complied in a previous version of Java and you were running
    it in Java 9 *and* the problem was only with accessing encapsulated types, you
    can add the same override arguments to the `java` command and have it run. However,
    if the compiled classes are referring to unavailable types, like the `BASE64Encoder`
    type we just looked at, you have no choice but to edit the code and recompile
    first.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码是在Java的早期版本中编译的，你正在Java 9中运行它，并且问题仅与访问封装类型有关，你可以将相同的覆盖参数添加到`java`命令中，并让它运行。然而，如果编译的类引用了不可用的类型，就像我们刚才看到的`BASE64Encoder`类型，你除了编辑代码并重新编译之外别无选择。
- en: Understanding the impact
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解影响
- en: Now that you know what are the possible problems you could face when compiling
    or running legacy code in Java 9, as well as how to solve those problems when
    they occur, let's spend some time understanding the scope of these problems. How
    worried should you be about having to encounter and fix these issues in your legacy
    Java code?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了在Java 9中编译或运行遗留代码时可能遇到的问题，以及当这些问题发生时如何解决它们，让我们花些时间来了解这些问题的范围。你对于在遗留的Java代码中遇到和修复这些问题应该有多担心？
- en: 'We can classify backward-incompatible APIs into the following broad categories:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将向后不兼容的API分为以下几大类：
- en: '**APIs with replacements**: This link (also the link provided in the output
    of `jdeps --jdk-internals`) provides a complete list of APIs that need replacements
    in Java 9: [https://wiki.openjdk.java.net/display/JDK8/Java+Dependency+Analysis+Tool](https://wiki.openjdk.java.net/display/JDK8/Java+Dependency+Analysis+Tool).'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具有替代方案的 API**：此链接（也是 `jdeps --jdk-internals` 输出中提供的链接）提供了需要替换的 Java 9 中 API
    的完整列表：[https://wiki.openjdk.java.net/display/JDK8/Java+Dependency+Analysis+Tool](https://wiki.openjdk.java.net/display/JDK8/Java+Dependency+Analysis+Tool)。'
- en: '**Encapsulated APIs**: When you run `jdeps`, you might see errors about usage
    of internal JDK types that do not have replacement suggestions. They could just
    be types that were formerly available pre-Java 9 but are now encapsulated in a
    platform module. These are fixable by using the right command line overrides to
    the `javac` and `java` invocations.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装的 API**：当您运行 `jdeps` 时，您可能会看到有关使用没有替代建议的内部 JDK 类型的错误。它们可能是以前在 Java 9 之前可用的类型，但现在被封装在平台模块中。这些可以通过使用正确的命令行覆盖
    `javac` 和 `java` 调用来修复。'
- en: On the other hand, there are certain APIs that were originally meant for removal,
    but they still happen to be available. While the intent has been to encapsulate
    all the internal JDK APIs, there have been a few APIs that have been so widely
    used in the Java developer community and for which there are no suitable replacements
    that encapsulating them would add so much more difficulty to the migration process.
    Remember the widely used `sun.misc.Unsafe` API we discussed in [Chapter 1](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb),
    *Introducing Java 9 Modularity*? Such APIs continue to be accessible in Java 9\.
    But in order to make these APIs easier to deprecate later, they have been moved
    into a separate module called `jdk.unsupported`, from which these types can be
    accessed.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有一些 API 原本打算移除，但它们仍然可用。虽然意图是封装所有内部 JDK API，但有一些 API 在 Java 开发者社区中被广泛使用，并且没有合适的替代方案，封装它们会给迁移过程带来更多困难。记得我们在
    [第 1 章](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb) “介绍 Java 9 模块化”
    中讨论的广泛使用的 `sun.misc.Unsafe` API？这样的 API 在 Java 9 中仍然可以访问。但为了使这些 API 更容易在以后弃用，它们已经被移动到一个名为
    `jdk.unsupported` 的单独模块中，从该模块可以访问这些类型。
- en: 'Running `java -d` on the `jdk.unsupported` module shows us the *unsupported*
    APIs that are still accessible for now:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `jdk.unsupported` 模块上运行 `java -d` 会显示目前仍然可访问的 *不受支持* API：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A word of caution. The `jdk.unsupported` module and the APIs are very likely
    to be removed from the next versions of Java, so don't plan on relying on this
    module for too long.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一句。`jdk.unsupported` 模块和 API 很可能将在 Java 的下一个版本中被移除，因此不要计划长期依赖这个模块。
- en: Recommended strategy
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推荐策略
- en: 'Let''s wrap up by outlining the recommended strategy for compiling and running
    your legacy code in Java 9\. Here are the steps you''d ideally follow:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下，概述在 Java 9 中编译和运行遗留代码的推荐策略。以下是您理想中应该遵循的步骤：
- en: Run `jdeps --jdk-internals` to verify if your code has any internal API access.
    If there are no errors, just try compiling and running your code in Java 9\. For
    the vast majority of cases, where there are no accesses to internal JDK APIs,
    the code should simply just work.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `jdeps --jdk-internals` 以验证您的代码是否有任何内部 API 访问。如果没有错误，只需尝试在 Java 9 中编译和运行您的代码。对于大多数没有访问内部
    JDK API 的情况，代码应该可以简单地正常工作。
- en: If there are errors and they are caused by your application code that you can
    change, follow the `jdeps` recommendation and fix those errors.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在错误，并且是由您可以更改的应用程序代码引起的，请遵循 `jdeps` 的建议并修复这些错误。
- en: If the errors are caused by libraries that are not in your control, check if
    there are updates published by the library authors and get the latest versions.
    Many libraries that use internal APIs are being updated to work with Java 9, and
    the fix for your libraries might have already been done and published.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果错误是由您无法控制的库引起的，请检查库作者是否发布了更新，并获取最新版本。许多使用内部 API 的库正在更新以兼容 Java 9，您的库的修复可能已经完成并发布。
- en: If none of the previous steps work, consider using the override options  `--add-exports`
    or  `--add-opens` to the platform APIs that you need internal access to. This
    is a short-term stop-gap arrangement until the offending code or library is fixed.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果前面的步骤都不奏效，请考虑使用覆盖选项 `--add-exports` 或 `--add-opens` 来访问您需要的平台 API。这是一个短期应急措施，直到有问题的代码或库被修复。
- en: If none of these work, as a last resort, turn off all modularity features with
    the `--permit-illegal-access` kill switch. While it is not recommended (and you
    certainly don't want to deploy an app with this switch in production), it's a
    handy way to get started if you are being overwhelmed with compatibility issues.
    A cool feature of this switch is that when you run your code that makes any *illegal
    access*, it prints out a warning message. It can be very helpful to consolidate
    this information and plan to fix them later.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这些方法都不奏效，作为最后的手段，可以使用`--permit-illegal-access` 关闭开关来关闭所有模块化特性。虽然这不被推荐（你当然不希望在生产环境中部署带有此开关的应用），但如果你被兼容性问题压得喘不过气来，这是一个方便的开始方法。这个开关的一个酷特性是，当你运行任何进行*非法访问*的代码时，它会打印出一个警告信息。这可以非常有帮助，以便汇总这些信息并计划稍后修复它们。
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered the first of the two phases of code migration to Java 9--
    the process of compiling or running your pre-Java 9 code in Java 9\. We used a
    sample Java 8 project (without any internal API access) in order to compile and
    execute it in Java 9\. We then looked at a class with a couple of deliberate internal
    API access instances and saw what the error we'll encounter looks like. We learned
    about the `jdeps` tool and how to use it to statically scan your code base and
    identify such instances.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了代码迁移到Java 9的两个阶段中的第一个——在Java 9中编译或运行你的Java 9之前的代码的过程。我们使用了一个示例Java 8项目（没有任何内部API访问）来在Java
    9中编译和执行它。然后我们查看了一个包含几个故意内部API访问实例的类，并看到了我们将遇到的错误的样子。我们了解了`jdeps`工具以及如何使用它来静态扫描你的代码库并识别这些实例。
- en: Once the instances have been identified, we covered a couple of ways to solve
    the problem--using the suggested replacement APIs or using command-line flags
    to temporarily overcome the problem. We used both these options to get the previously
    failing code to compile and execute fine in Java 9\. We then looked at a high
    level strategy to follow in order to complete the process of getting your legacy
    code to run in Java 9.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了这些实例，我们介绍了几种解决问题的方法——使用建议的替换API或使用命令行标志临时克服问题。我们使用了这两种选项来使之前失败的代码在Java
    9中编译和执行良好。然后我们查看了一个高级策略，以完成将你的遗留代码在Java 9中运行的过程。
- en: If you are working on code that you just need to maintain and are not likely
    to build on, this is where you could stop your migration journey. But, if you
    need to actively evolve the code, it's a good idea to go further than that. In
    the next chapter, we'll learn how to get it through the second phase of the Java
    9 migration--to refactor it to use the Java 9 modularity features.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在维护的代码你只是需要维护而不太可能进行扩展，那么你可以在迁移之旅的这里停止。但是，如果你需要积极演化代码，那么超越这一点是个好主意。在下一章中，我们将学习如何通过Java
    9迁移的第二阶段——将其重构为使用Java 9模块化特性。
