- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Setting Up Our Angular Project and Architecture
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的 Angular 项目和架构
- en: In the previous chapter, you learned about the concepts of **JUnit**, which
    is a testing framework that offers features such as fixtures, test suites, and
    classes to test the methods in our application. You also learned the application
    of **AssertJ** with JUnit, which gives a more flexible way of asserting objects
    in our unit tests, and lastly, you also understood the importance of Mockito,
    which provides us with the ability to mock objects and services, omitting the
    use of the database in unit tests.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了关于 **JUnit** 的概念，它是一个提供诸如固定值、测试套件和用于测试我们应用程序中方法的类等功能的测试框架。你还学习了与 JUnit
    结合使用 **AssertJ** 的应用，它为我们单元测试中的对象断言提供了一种更灵活的方式，最后，你还了解了 Mockito 的重要性，它为我们提供了模拟对象和服务的能力，从而在单元测试中省略了数据库的使用。
- en: In this chapter, we will start building our frontend application using Angular;
    we will be tackling the main fundamentals of Angular, such as components, modules,
    directives, and routes. We will also point out some of the best practices for
    organizing our Angular project.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始使用 Angular 构建我们的前端应用程序；我们将探讨 Angular 的主要基础，例如组件、模块、指令和路由。我们还将指出组织我们的
    Angular 项目的最佳实践。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Organizing features and modules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织特性和模块
- en: Structuring components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构化组件
- en: Adding Angular material
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 Angular material
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The link to the finished version of this chapter is here: [https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-10/superheroes](https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-10/superheroes).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章完成版本的链接在此：[https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-10/superheroes](https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-10/superheroes)。
- en: Organizing features and modules
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织特性和模块
- en: In this section, we will be discussing how we can organize and structure our
    Angular project to make it optimized and maintainable. Since Angular is considered
    a **Model View Whatever** (**MVW**) framework, Angular developers have the freedom
    to implement their choice of pattern in developing the project. This could be
    confusing, as you will experience different structures and standards switching
    from one project to another. To solve this dilemma, we will present a commonly
    used structure in the industry or some kind of baseline structure that you will
    typically find in Angular projects.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何组织和结构化我们的 Angular 项目，使其优化且易于维护。由于 Angular 被认为是 **模型视图任意**（**MVW**）框架，Angular
    开发者有自由选择在项目开发中实施他们选择的模式。这可能会令人困惑，因为当你从一个项目切换到另一个项目时，你会遇到不同的结构和标准。为了解决这个困境，我们将介绍业界常用的一种结构或某种典型的基准结构，你通常会在
    Angular 项目中找到这种结构。
- en: However, before we proceed to our main topic, let us first discuss how to create
    our Angular project and what the basic concepts that we need to know before coding
    Angular are. You can skip this part if you are already knowledgeable about Angular
    and proceed to the *Organizing the folder* *structure* section.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们继续讨论主要主题之前，让我们首先讨论如何创建我们的 Angular 项目以及在我们编码 Angular 之前需要了解的基本概念。如果你已经熟悉
    Angular，可以跳过这部分内容，直接进入 *组织文件夹结构* 部分。
- en: Generating an Angular project
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成 Angular 项目
- en: We can create or set up the dependencies of our Angular project using a tool
    known as the **Angular CLI**. We can scaffold the project by using a single command
    responsible for downloading the dependencies and generating the required files
    for our Angular project to run. The **Angular CLI** is a handy tool in that it
    also provides several commands that will help us generate boilerplate codes in
    Angular.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用名为 **Angular CLI** 的工具创建或设置我们的 Angular 项目的依赖项。我们可以通过使用一个负责下载依赖项并生成我们 Angular
    项目运行所需文件的单一命令来构建项目。**Angular CLI** 是一个方便的工具，因为它还提供了几个命令，可以帮助我们在 Angular 中生成样板代码。
- en: To install the Angular CLI, we should make sure that we have Node.js installed
    on our machine, and we will execute the `npm install -g @angular/cli` command.
    After executing the command, we can verify whether our Angular CLI has been successfully
    installed – we will have a new global `ng` command that we can use to check the
    version of the installed CLI.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Angular CLI，我们应该确保我们的机器上已安装 Node.js，然后执行 `npm install -g @angular/cli` 命令。执行命令后，我们可以验证我们的
    Angular CLI 是否已成功安装——我们将有一个新的全局 `ng` 命令，我们可以使用它来检查已安装 CLI 的版本。
- en: 'To check the version, we will execute the `ng --version` command, and we will
    get the following output:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查版本，我们将执行 `ng --version` 命令，并将得到以下输出：
- en: '![Figure 10.1 – Installed version of the Angular CLI](img/B18159_10_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – 安装的 Angular CLI 版本](img/B18159_10_01.jpg)'
- en: Figure 10.1 – Installed version of the Angular CLI
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 安装的 Angular CLI 版本
- en: In the preceding output, we can see that the version of the Angular CLI and
    Node.js installed on your machine is displayed after executing the `ng -- version`
    command. Currently, we have Angular CLI Version 13 installed, which means that
    once we scaffold an Angular project, it will be on **Version 13**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到在执行 `ng -- version` 命令后，显示了我们机器上安装的 Angular CLI 和 Node.js 的版本。目前，我们已安装
    Angular CLI 版本 13，这意味着一旦我们搭建了一个 Angular 项目，它将使用 **版本 13**。
- en: 'After successfully installing the Angular CLI, we can now execute several commands
    for our project. Here are some of the commands that we can use in the Angular
    CLI:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功安装 Angular CLI 之后，我们现在可以执行一些针对我们项目的命令。以下是一些我们可以在 Angular CLI 中使用的命令：
- en: '`ng new <project name> [options]`: Creates or scaffolds a new Angular project'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng new <project name> [options]`：创建或搭建新的 Angular 项目'
- en: '`ng serve <project> [options]`: Builds and serves your Angular application'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng serve <project> [options]`：构建并托管您的 Angular 应用程序'
- en: '`ng generate <schematic> [options]`: Generates and modifies files with a specific
    schematic'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng generate <schematic> [options]`：使用特定的图生成和修改文件'
- en: 'Some schematics we can generate are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以生成的某些图如下：
- en: Component
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件
- en: Module
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块
- en: Directive
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令
- en: Guard
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 守卫
- en: '`ng build<project> [options]`: Compiles the Angular application into an output
    directory named `dist`, which will be used for production'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng build<project> [options]`：将 Angular 应用程序编译到名为 `dist` 的输出目录，该目录将用于生产'
- en: '`ng test <project> [options]`: Runs the unit test in the Angular project'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng test <project> [options]`：在 Angular 项目中运行单元测试'
- en: These are just some of the most commonly used commands of the Angular CLI. For
    the complete commands, you can visit the documentation for Angular at https://angular.io/cli.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是 Angular CLI 中最常用的命令之一。对于完整的命令，您可以访问 Angular 的文档，网址为 https://angular.io/cli。
- en: We know the commands we can use in the Angular CLI. Now, let’s generate our
    Angular project by executing the `ng new superheroes` command on our desired path.
    This will ask several questions, such as “*would you like to add Angular routing?*”
    and “*which stylesheet format would you like to use?*” We can select *Yes* and
    **Syntactically Awesome Style Sheet** (**SASS**) for these questions, as we need
    routes and SASS to build our application later.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道可以在 Angular CLI 中使用的命令。现在，让我们通过在期望的路径上执行 `ng new superheroes` 命令来生成我们的 Angular
    项目。这将提出几个问题，例如“*您想要添加 Angular 路由吗？*”和“*您想使用哪种样式表格式？*”对于这些问题，我们可以选择 *是* 和 **Syntactically
    Awesome Style Sheet** (**SASS**)，因为我们需要路由和 SASS 来构建我们的应用程序。
- en: After this step, this will now scaffold a new Angular project named superheroes
    and will be responsible for configuring the web pack, creating the required settings,
    and downloading the project’s dependencies. After the scaffold is accomplished,
    open the superheroes project in Visual Studio Code or any IDE you prefer. We will
    see that the Angular application is configured and ready to run on our local server.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步之后，这将现在为名为 superheroes 的新 Angular 项目搭建框架，并负责配置 web pack、创建所需的设置以及下载项目的依赖项。搭建完成后，在
    Visual Studio Code 或您偏好的任何 IDE 中打开 superheroes 项目。我们将看到 Angular 应用程序已配置并准备好在我们的本地服务器上运行。
- en: '![Figure 10.2 – Folder structure and dependencies installed after scaffolding](img/B18159_10_02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – 搭建后的文件夹结构和安装的依赖项](img/B18159_10_02.jpg)'
- en: Figure 10.2 – Folder structure and dependencies installed after scaffolding
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 搭建后的文件夹结构和安装的依赖项
- en: 'To run our project, we can open the VS Code terminal with the *Ctrl* + *`*
    shortcut and execute the `ng serve` command. We can also use the defined scripts
    in our `package.json` file. In this case, we can perform `npm run start` to run
    our application. We will see in the terminal whether Angular is running successfully
    on our local server in the following screenshot:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行我们的项目，我们可以使用 *Ctrl* + *`* 快捷键打开 VS Code 终端，并执行 `ng serve` 命令。我们还可以使用 `package.json`
    文件中定义的脚本。在这种情况下，我们可以执行 `npm run start` 来运行我们的应用程序。我们将在以下屏幕截图中的终端中看到 Angular 是否在我们的本地服务器上成功运行：
- en: '![Figure 10.3 – Folder structure and dependencies installed after scaffolding](img/B18159_10_03.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3 – 搭建后的文件夹结构和安装的依赖项](img/B18159_10_03.jpg)'
- en: Figure 10.3 – Folder structure and dependencies installed after scaffolding
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – 搭建后的文件夹结构和安装的依赖项
- en: 'After successfully running our Angular application, we can now open the app
    using the default URL (`http://localhost:4200`) in our browser, and we will see
    the default page of our Angular project:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功运行我们的Angular应用程序后，现在我们可以使用浏览器中的默认URL（`http://localhost:4200`）打开应用程序，我们将看到Angular项目的默认页面：
- en: '![Figure 10.4 – Angular default page](img/B18159_10_04.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – Angular默认页面](img/B18159_10_04.jpg)'
- en: Figure 10.4 – Angular default page
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – Angular默认页面
- en: We have successfully configured and started our Angular application locally.
    Now, let’s discuss the concepts we will use to build our application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功配置并启动了本地的Angular应用程序。现在，让我们讨论我们将用于构建应用程序的概念。
- en: Angular features
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular特性
- en: The Angular framework is a component-based framework that allows us to develop
    reusable components to promote the reusability and maintainability of code. It
    offers many features that will make our frontend development more powerful. In
    this section, we will discuss the basic features and fundamentals of Angular that
    serve as its building blocks; take note that we will not discuss all of the features
    here, as we will focus more on the organization of the project.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Angular框架是一个基于组件的框架，它允许我们开发可重用的组件，以促进代码的可重用性和可维护性。它提供了许多将使我们的前端开发更强大的功能。在本节中，我们将讨论Angular的基本特性和基础，这些是Angular的构建块；请注意，我们不会在这里讨论所有功能，因为我们更关注项目的组织。
- en: 'To learn more about the features, you can visit the official documentation
    for Angular: https://angular.io/start.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于特性的信息，您可以访问Angular的官方文档：https://angular.io/start。
- en: Components
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组件
- en: '`@Component` decorator, which assigns several types of metadata that describe
    the component’s HTML, CSS, and selector.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Component` 装饰器，它分配了描述组件HTML、CSS和选择器的几种类型的元数据。'
- en: 'The following are the commands to generate a component:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为生成组件的命令：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following is a code example for a component:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个组件的代码示例：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Components have a feature called **data binding**, which allows us to pass
    data into the view. Data binding can be used to display values to the user, respond
    to user events, and modify the styles. Angular binding is classified into two
    groups:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 组件有一个名为**数据绑定**的功能，它允许我们将数据传递到视图中。数据绑定可以用来向用户显示值、响应用户事件以及修改样式。Angular绑定分为两组：
- en: One-way binding
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单向绑定
- en: Two-way binding
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双向绑定
- en: One-way binding
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单向绑定
- en: As can be inferred from the name, data only flows in one direction here. It
    can be from a component to the view or vice versa.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从名称可以推断出，数据在这里只单向流动。它可以是从组件到视图或相反。
- en: There are several ways to achieve one-way binding in Angular, and the two most
    common ways are using interpolation and property binding.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中实现单向绑定有几种方法，其中两种最常见的方法是使用插值和属性绑定。
- en: Interpolation
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 插值
- en: '`{{}}` (double curly braces) for expressions inside HTML code.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`{{}}`（双大括号）用于HTML代码中的表达式。'
- en: 'Let’s have a look at the following example code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例代码：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding example, we have used interpolation to display the value of
    the `title` variable in the view. Using interpolation, we can also use operators
    in the template expression.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了插值来在视图中显示`title`变量的值。使用插值，我们还可以在模板表达式中使用运算符。
- en: Property binding
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 属性绑定
- en: '`class`, `href`, `disabled`, and `src`.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`class`、`href`、`disabled` 和 `src`。'
- en: 'Let’s have a look at the following example code on how to use property binding:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例代码，了解如何使用属性绑定：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding example, we have bound the `isDisabled` variable to the disabled
    property of the button. The button will be disabled, as we have set the value
    of the `isDisabled` to `true`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们将`isDisabled`变量绑定到按钮的禁用属性。由于我们将`isDisabled`的值设置为`true`，按钮将被禁用。
- en: Two-way binding
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 双向绑定
- en: '**Two-way binding** is a two-way data flow. Any changes applied to the model
    will be reflected in the view simultaneously and any modifications involved in
    the view are updated in the component. Two-way data binding helps handle forms,
    as we want our model to be updated once the values of the form are also updated
    and vice versa.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**双向绑定**是双向数据流。对模型所做的任何更改都将同时反映在视图中，并且任何涉及视图的修改都将更新到组件中。双向数据绑定有助于处理表单，因为我们希望模型在表单值更新后也更新，反之亦然。'
- en: To achieve two-way binding, the `ngModel` directive is used.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现双向绑定，使用`ngModel`指令。
- en: ngModel
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ngModel
- en: '`ngModel` is a directive used to achieve two-way binding in Angular. This is
    under the Forms module in `@angular/forms`. `ngModel`, once it is bound to an
    input field or other form element, gives that element a property binding and an
    event binding. Let’s have a look at the following example code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngModel` 是一个在 Angular 中用于实现双向绑定的指令。这位于 `@angular/forms` 下的表单模块中。一旦 `ngModel`
    绑定到输入字段或其他表单元素，它就会给该元素添加属性绑定和事件绑定。让我们看看下面的示例代码：'
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example code, we have bound the model value to an input element
    using the `ngModel` directive. This syntax is also known as the *banana in a box*,
    which encloses `ngModel` with a square bracket and parenthesis. The directive
    will bind the model’s value with the input field using property binding and listen
    to the input value changes by utilizing `ngModelChange`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例代码中，我们使用 `ngModel` 指令将模型值绑定到一个输入元素上。这种语法也被称为 *盒子里的香蕉*，它用方括号和圆括号包围 `ngModel`。该指令将通过属性绑定将模型值与输入字段绑定，并通过利用
    `ngModelChange` 来监听输入值的变化。
- en: Directives
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指令
- en: '**Directives** are an Angular feature that helps us manipulate the **Document
    Object Model** (**DOM**). We can modify a DOM element’s layout, behavior, and
    view. Directives are classified into three parts: **components** are one of the
    classifications, and the other two are **attribute** and **structural** directives.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**指令**是 Angular 的一个功能，帮助我们操作 **文档对象模型**（**DOM**）。我们可以修改 DOM 元素的布局、行为和视图。指令分为三个部分：**组件**是其中一种分类，其他两种是**属性**和**结构**指令。'
- en: Structural directives
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结构指令
- en: '**Structural directives** are directives that can modify the layout of the
    DOM by adding, updating, or removing elements, listed below are some of the structural
    directives in Angular:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**结构指令**是可以通过添加、更新或删除元素来修改 DOM 布局的指令，以下是一些 Angular 中的结构指令：'
- en: '`*ngIf`: A directive that is used to add or remove elements in the DOM based
    on a condition:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*ngIf`：一个用于根据条件在 DOM 中添加或删除元素的指令：'
- en: '[PRE5]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`*ngFor`: A directive that is used to repeat HTML elements from the items iterated
    in a specific list:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*ngFor`：一个用于从特定列表中迭代的项重复 HTML 元素的指令：'
- en: '[PRE6]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`*ngSwitch`: A directive that allows us to add or remove HTML elements using
    a switch case mechanism. The HTML elements will be displayed if the provided expression
    is matched:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*ngSwitch`：一个允许我们使用开关机制添加或删除 HTML 元素的指令。如果提供的表达式匹配，则将显示 HTML 元素：'
- en: '[PRE11]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Attribute directives
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 属性指令
- en: '**Attribute directives** are directives used for changing or modifying the
    appearance or behavior of the element. Compared to structural directives, attribute
    directives cannot add or remove elements in the DOM.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性指令**是用于更改或修改元素外观或行为的指令。与结构指令相比，属性指令不能在 DOM 中添加或删除元素。'
- en: 'Listed here are some of the attribute directives in Angular:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下面列出了一些 Angular 中的属性指令：
- en: '**ngClass**: A directive used to add CSS classes to or remove them from an
    HTML element; this allows us to change the appearance of elements dynamically:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ngClass**：一个用于向 HTML 元素添加 CSS 类或从其中删除它们的指令；这允许我们动态地更改元素的外观：'
- en: '[PRE18]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**ngStyle**: A directive that allows us to change the styles of HTML elements:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ngStyle**：一个允许我们更改 HTML 元素样式的指令：'
- en: '[PRE21]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Modules
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块
- en: '**Modules** are one of the essential features of the Angular framework. As
    our application gets more complex, it will consist of large blocks of components,
    directives, and services. This will affect the maintainability of the application’s
    code base. The Angular framework provides a way of organizing and grouping blocks,
    known as modules.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块**是 Angular 框架的一个基本特性。随着我们的应用程序变得更加复杂，它将包含大量的组件、指令和服务。这将影响应用程序代码库的可维护性。Angular
    框架提供了一种组织和分组块的方法，称为模块。'
- en: Modules in the Angular framework help us develop our application promoting the
    separation of concerns. They allow us to classify and organize blocks based on
    their functionality. Angular is also built using modules; the `@angular/core`
    framework is the primary Angular module, which provides Angular’s core functionalities
    and services.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 框架中的模块帮助我们开发应用程序，促进关注点的分离。它们允许我们根据其功能对块进行分类和组织。Angular 也是使用模块构建的；`@angular/core`
    框架是主要的 Angular 模块，它提供了 Angular 的核心功能和服务的实现。
- en: Creating a module
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建一个模块
- en: We will use the `@NgModule` decorator to create a module. It consists of several
    types of metadata that allow us to define the component, services, pipes, and
    other modules included in the created module.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `@NgModule` 装饰器来创建一个模块。它由几种类型的元数据组成，允许我们定义创建的模块中包含的组件、服务、管道和其他模块。
- en: 'The following example code shows the properties available for a module:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码展示了模块可用的属性：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let’s now discuss the functionality of each property:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来讨论每个属性的职能：
- en: '**Declarations**: This is where we place the components, directives, and pipes
    of our applications. Remember that components, directives, and pipes must be declared
    in only one module.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明**：这是我们将应用程序的组件、指令和管道放置的地方。记住，组件、指令和管道必须在单个模块中声明。'
- en: '**Providers**: This is where we place services to allow them to be available
    for dependency injection.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供者**：这是我们将服务放置的地方，以便它们可以用于依赖注入。'
- en: '**Imports**: This is where we place one or more other modules in our application.
    Once we import a specific module, all components, pipes, and directives in the
    imported module can be used.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导入**：这是我们将一个或多个其他模块放置到我们的应用程序中的地方。一旦我们导入一个特定的模块，导入模块中的所有组件、管道和指令都可以使用。'
- en: '**Exports**: This is where we place the components, directives, and pipes to
    be available to other modules once imported.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导出**：这是我们将组件、指令和管道放置的地方，以便在导入后可供其他模块使用。'
- en: '`AppModule`), as the root module’s responsibility is to load the first view
    as our application starts.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (`AppModule`)，因为根模块的职责是在应用程序启动时加载第一个视图。
- en: '**Entry components**: This is where we place components that should be dynamically
    loaded in our application.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**入口组件**：这是我们将应该在我们应用程序中动态加载的组件放置的地方。'
- en: 'The following diagram shows how `NgModule` works in an Angular application:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了 `NgModule` 在 Angular 应用程序中的工作方式：
- en: '![Figure 10.5 – Diagram for the flow of an Angular module](img/B18159_10_05.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.5 – Angular 模块流程图](img/B18159_10_05.jpg)'
- en: Figure 10.5 – Diagram for the flow of an Angular module
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – Angular 模块流程图
- en: Services and dependency injection
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务和依赖注入
- en: '**Services** are also one of the valuable features of Angular. It is code that
    can be reused in different components of your application.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务**也是 Angular 中的一个有价值的功能。这是可以在应用程序的不同组件中重用的代码。'
- en: 'The primary responsibility of services is the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的主要职责如下：
- en: Reusing logic on different components
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同的组件上重用逻辑
- en: Implementing API communication and data access
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 API 通信和数据访问
- en: Promoting single responsibility, as it separates the independent features of
    components
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提倡单一职责，因为它将组件的独立功能分离出来
- en: 'To create a service in the application, we will create a class and annotate
    it with the `@Injectable` decorator. To register the service at the root level
    of your application, we will add the following to our `@``Injectable` decorator:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要在应用程序中创建一个服务，我们将创建一个类并用 `@Injectable` 装饰器注解它。为了在应用程序的根级别注册该服务，我们将以下内容添加到我们的
    `@Injectable` 装饰器中：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once we have set the value of the `providedIn` metadata in the root, this will
    create a single, shared instance of the service throughout the application. On
    the other hand, if we want to provide the service in a specific module, we will
    place the service in the provider metadata of `@NgModule`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在根中设置了 `providedIn` 元数据的值，这将创建一个在整个应用程序中共享的服务实例。另一方面，如果我们想在特定模块中提供该服务，我们将该服务放置在
    `@NgModule` 的提供者元数据中：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now that we have discussed some of the essential features of Angular, we will
    focus on how to structure your Angular application.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了 Angular 的一些基本特性，接下来我们将关注如何构建你的 Angular 应用程序结构。
- en: Creating the Angular folder structure
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Angular 文件夹结构
- en: The Angular framework is considered an MVW framework, which means that there
    are many possible ways of structuring our application. In this case, we would
    discuss one of the best practices or most commonly used structures that can help
    your Angular application be scalable and maintainable.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 框架被认为是一个 MVW 框架，这意味着有许多可能的方式来构建我们的应用程序。在这种情况下，我们将讨论一种最佳实践或最常用的结构，这可以帮助你的
    Angular 应用程序具有可扩展性和可维护性。
- en: In the previous part, we learned that Angular blocks could be grouped and organized
    into modules; modules are a good starting point for structuring our Angular application.
    The first step we can implement is to group and classify modules based on their
    functionality. Listed here is the classification of our modules.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们了解到 Angular 块可以被分组和组织成模块；模块是构建我们的 Angular 应用程序的一个很好的起点。我们可以实施的第一步是根据其功能对模块进行分组和分类。下面是模块的分类。
- en: Root module
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 根模块
- en: The `AppModule` and is found under the `src/app` folder.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppModule` 位于 `src/app` 文件夹下。'
- en: Feature module
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 功能模块
- en: The **feature** module is where we place modules that apply a specific feature
    of our application. This means that most of what our code uses is inside this
    module. We will create the components, pipes, and directives under the module
    where they should be included and we can also separate components by placing the
    components that have a route in a page folder.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**功能**模块是我们放置应用特定功能的模块。这意味着我们代码的大部分内容都在这个模块中。我们将在应该包含它们的模块下创建组件、管道和指令，我们还可以通过将具有路由的组件放在页面文件夹中来分离组件。'
- en: 'Let’s have a look at an example folder structure of a feature module called
    `AntiHeroModule`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个名为 `AntiHeroModule` 的功能模块的示例文件夹结构：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the folder structure here, we have divided our anti-hero module into several
    parts. The first folder is the `components` folder, which contains all of the
    components shared throughout this module. These can also be called **dumb** components,
    which we will discuss in the next section.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里的文件夹结构中，我们将我们的反英雄模块分成了几个部分。第一个文件夹是 `components` 文件夹，它包含在这个模块中共享的所有组件。这些也可以称为
    **哑** 组件，我们将在下一节中讨论。
- en: The next two are the `directives` and `pipes` folders, which contain the directives
    and pipes used in `AntiHeroModule`. Lastly, the `pages` folder includes the components
    in `AntiHeroModule` that have a direct route. These can also be called `index.ts`
    file, known as a barrel file, which will provide a centralized place for exporting
    components, directives, and pipes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个是 `directives` 和 `pipes` 文件夹，它们包含在 `AntiHeroModule` 中使用的指令和管道。最后，`pages`
    文件夹包括 `AntiHeroModule` 中具有直接路由的组件。这些也可以称为 `index.ts` 文件，被称为桶文件，它将为导出组件、指令和管道提供一个集中位置。
- en: Shared module
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享模块
- en: The **shared** module is a module that is used and shared throughout the application;
    this is composed of the components, pipes, and directives that we are required
    to use in different parts of the application. Remember that a shared module should
    not have a dependency on other modules in the application.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**共享**模块是一个在整个应用程序中使用和共享的模块；它由我们在应用程序的不同部分需要使用的组件、管道和指令组成。请记住，共享模块不应依赖于应用程序中的其他模块。'
- en: Shared modules are created under the `src/app/shared` folder.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 共享模块是在 `src/app/shared` 文件夹下创建的。
- en: 'Let’s have a look at the example folder structure of a shared module in our
    application:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们应用程序中共享模块的示例文件夹结构：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding folder structure, we can see that we have created two components
    named `footer` and `navbar`; these are some of the most commonly shared components
    in applications.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的文件夹结构中，我们可以看到我们创建了两个名为 `footer` 和 `navbar` 的组件；这些是在应用程序中最常见的共享组件之一。
- en: Core module
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 核心模块
- en: The **core** module is a module for services shared throughout the applications.
    These are singleton services, having only one instance in the application. The
    services that are included in the core module are usually authentication services.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**核心**模块是一个在整个应用程序中共享服务的模块。这些是单例服务，应用程序中只有一个实例。通常，包含在核心模块中的服务是身份验证服务。'
- en: Since it should only have one instance, the core module must only be imported
    into the application’s root module.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它应该只有一个实例，因此核心模块必须只导入到应用程序的根模块中。
- en: 'We can add the following code to our core module to prevent it from being imported
    into other modules:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向我们的核心模块添加以下代码以防止它被导入到其他模块中：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding code example, we have added a `CoreModule` parameter to our
    constructor with `@Optional` and `@SkipSelf` decorators – this will throw an error
    if the core returns a value indicating that `CoreModule` has already been imported
    into the root module.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们向构造函数中添加了 `CoreModule` 参数，并使用 `@Optional` 和 `@SkipSelf` 装饰器——如果核心返回一个值表示
    `CoreModule` 已经被导入到根模块中，这将抛出一个错误。
- en: Let’s now proceed to learn how to implement the structure on an Angular application.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们继续学习如何在 Angular 应用程序中实现结构。
- en: Implementing the structure
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现结构
- en: Now that we have learned the different module categories for our Angular application,
    let’s apply the folder structure to our superheroes project.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了我们的Angular应用程序的不同模块类别，让我们将这些文件夹结构应用到我们的超级英雄项目中。
- en: Our goal here is to create a frontend application with a simple **Create, Read,
    Update, and Delete** (**CRUD**) functionality for heroes and anti-heroes.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是创建一个具有简单**创建、读取、更新和删除**（**CRUD**）功能的前端应用程序，用于英雄和反英雄。
- en: First, we will create the shared features and the `core` folder under the `app`
    directory, and after completing the three main categories, we will make the blocks
    needed for each module.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在`app`目录下创建共享特性和`core`文件夹，并在完成三个主要类别后，我们将为每个模块制作所需的块。
- en: Blocks under the features module
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特性模块下的块
- en: We want to create the blocks under our features module; the first thing we need
    to scaffold is `AntiHeroModule`. Execute the `ng g m anti-hero` command to generate
    the module under the `src/app` folder.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在特性模块下创建块；首先我们需要搭建的是`AntiHeroModule`。执行`ng g m anti-hero`命令以在`src/app`文件夹下生成模块。
- en: 'Now, under the anti-hero folder, we will create the following folders:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在反英雄文件夹下，我们将创建以下文件夹：
- en: '`components`: This will contain components that will be shared in this module.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`components`：这将包含在这个模块中共享的组件。'
- en: '`pipes`: This will contain all the pipes used by the anti-hero module.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pipes`：这将包含反英雄模块使用的所有管道。'
- en: '`directives`: This will contain all the directives that the anti-hero module
    will use.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`directives`：这将包含反英雄模块将使用的所有指令。'
- en: '`pages`: This will contain components that have a direct route.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pages`：这将包含具有直接路由的组件。'
- en: After creating the folders, we will now make the page components for our anti-hero
    module. We will add two pages where the first one will be the page for displaying
    the list of anti-heroes and the second one will be a form that allows us to view,
    create, or modify the selected hero in the list. We can execute the `ng g c anti-hero/pages/pages/form`
    and `ng g c anti-hero/pages/list` commands to make the two pages. This will create
    two new components, `form` and `list`, under the `pages` folder.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建文件夹后，我们现在将制作反英雄模块的页面组件。我们将添加两个页面，第一个页面将用于显示反英雄列表，第二个页面将是一个表单，允许我们查看、创建或修改列表中选定的英雄。我们可以执行`ng
    g c anti-hero/pages/pages/form`和`ng g c anti-hero/pages/list`命令来创建这两个页面。这将创建两个新的组件，`form`和`list`，在`pages`文件夹下。
- en: 'After successfully creating the page components, we will also add a routing
    module for our anti-hero module. We will execute the `ng g m anti-hero/anti-hero-routing
    --flat` command and we will place the following code in our routing module:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功创建页面组件后，我们还将为我们的反英雄模块添加一个路由模块。我们将执行`ng g m anti-hero/anti-hero-routing --flat`命令，并将以下代码放置在我们的路由模块中：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding example code, we have defined routes for our `form` and `list`
    pages. This means that the page components will have direct routes in our application,
    and we have also defined `ListComponent` as the base route for this module.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例代码中，我们为我们的`form`和`list`页面定义了路由。这意味着页面组件将在我们的应用程序中拥有直接路由，并且我们也将`ListComponent`定义为该模块的基础路由。
- en: After successfully creating the page components and defining routes, we want
    our root module (`AppModule`) to have a route for `AntiHeroModule`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功创建页面组件和定义路由后，我们希望我们的根模块（`AppModule`）有一个指向`AntiHeroModule`的路由。
- en: 'To implement this, we will place the following code in `app-routing.module.ts`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将以下代码放置在`app-routing.module.ts`中：
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding example code, we have used lazy loading to create a route for
    `AntiHeroModule`. Once we visit the `{baseUrl}/anti-heroes` URL, this will load
    `AntiHeroModule` and redirect to the base route, which is `ListComponent`. We
    have also used `RouterModule.forRoot()` to import the routes, as this is the root
    module.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例代码中，我们使用了懒加载来为`AntiHeroModule`创建一个路由。一旦我们访问`{baseUrl}/anti-heroes` URL，这将加载`AntiHeroModule`并重定向到基础路由，即`ListComponent`。我们还使用了`RouterModule.forRoot()`来导入路由，因为这是根模块。
- en: 'After successfully defining the routes for our `AppModule`, we can now see
    the current structure of our application:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功定义了`AppModule`的路由后，我们现在可以看到我们应用程序的当前结构：
- en: '![Figure 10.6 – Folder structure after creating the anti-hero feature](img/B18159_10_06.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – 创建反英雄特性后的文件夹结构](img/B18159_10_06.jpg)'
- en: Figure 10.6 – Folder structure after creating the anti-hero feature
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – 创建反英雄特性后的文件夹结构
- en: Now that we have completed our feature module in Angular, we have only the `pages`
    folder. We will add other blocks such as the components and directives later as
    we develop the application. The next step is to make the shared module.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了Angular中的功能模块，我们只有`pages`文件夹。随着我们开发应用程序，我们将添加其他块，如组件和指令。下一步是创建共享模块。
- en: Blocks under the shared module
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享模块下的块
- en: Now, our next goal is to create the blocks under the shared module. We defined
    the shared module as components, directives, and pipes that are shared throughout
    the application and must not have a dependency on other modules. To create our
    shared module, we will execute the `ng g m shared` command. This will create a
    new shared folder and a module file inside the new shared folder.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的下一个目标是创建共享模块下的块。我们将共享模块定义为在整个应用程序中共享的组件、指令和管道，并且它们不能依赖于其他模块。为了创建我们的共享模块，我们将执行`ng
    g m shared`命令。这将创建一个新的共享文件夹和该新共享文件夹中的一个模块文件。
- en: Now after completing the shared module, we can generate the blocks that will
    be categorized in this module. In our application, we can include `navbar` and
    `footer` as shared components, as they will be used in every part of our application.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在完成共享模块后，我们可以生成将在这个模块中分类的块。在我们的应用程序中，我们可以将`navbar`和`footer`作为共享组件包含在内，因为它们将在我们应用程序的每个部分中使用。
- en: 'We will execute the `ng g c shared/layout/navbar` and `ng g c shared/layout/footer`
    commands to scaffold `navbar` and `footer`. We can see that `FooterComponent`
    and `NavbarComponent` are automatically added to the `shared.module.ts` file as
    Angular detects the module closest to the components:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将执行`ng g c shared/layout/navbar`和`ng g c shared/layout/footer`命令来构建`navbar`和`footer`。我们可以看到`FooterComponent`和`NavbarComponent`被自动添加到`shared.module.ts`文件中，因为Angular检测到离组件最近的模块：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Remember to add the `navbar` and `footer` components in the `exports` metadata
    of `NgModule` and we will import the shared module in different modules:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在`NgModule`的`exports`元数据中添加`navbar`和`footer`组件，并且我们将导入不同的模块中的共享模块：
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can also add shared directives and pipes under the shared folder by executing
    the `ng g c shared/directive/directive-name` and `ng g c shared/pipes/pipe-name`
    commands depending on the needs of our application. After successfully creating
    the blocks, we will have the following folder structure:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们应用程序的需求，我们还可以通过执行`ng g c shared/directive/directive-name`和`ng g c shared/pipes/pipe-name`命令在共享文件夹下添加共享指令和管道。在成功创建块后，我们将有以下文件夹结构：
- en: '![Figure 10.7 – Folder structure after creating the shared module](img/B18159_10_07.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7 – 创建共享模块后的文件夹结构](img/B18159_10_07.jpg)'
- en: Figure 10.7 – Folder structure after creating the shared module
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 创建共享模块后的文件夹结构
- en: We must also remember that a shared module does not need a routing module since
    it does not have components that require routes in our application.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须记住，共享模块不需要路由模块，因为在我们应用程序中没有需要路由的组件。
- en: Blocks under the core module
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 核心模块下的块
- en: The last module that we need to create is the core module. Core modules are
    services that we share throughout the application and they have only one instance.
    One service that always goes into the core module is the authentication service.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建的最后一个模块是核心模块。核心模块是我们在整个应用程序中共享的服务，并且只有一个实例。一个总是进入核心模块的服务是认证服务。
- en: To create our shared module, we will execute the `ng g m core;` command after
    completing the core module. We will scaffold the authenticate service by running
    the `ng g s` `core/services/authenticate` command.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成核心模块后，我们将执行`ng g m core;`命令来创建我们的共享模块。我们将通过运行`ng g s` `core/services/authenticate`命令来构建认证服务。
- en: 'After successfully creating the authenticate service, we will provide it under
    the `core.module.ts` file to include the service in the module. We can also add
    shared models under the core module by adding a `models` folder depending on the
    need of our application. Now, we have the following folder structure:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功创建认证服务后，我们将将其放在`core.module.ts`文件下，以便将服务包含在模块中。根据我们应用程序的需求，我们还可以通过添加一个`models`文件夹在核心模块下添加共享模型。现在，我们有以下文件夹结构：
- en: '![Figure 10.8 – Folder structure after creating the shared module](img/B18159_10_08.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图10.8 – 创建共享模块后的文件夹结构](img/B18159_10_08.jpg)'
- en: Figure 10.8 – Folder structure after creating the shared module
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 – 创建共享模块后的文件夹结构
- en: We will make the contents of the authenticate service as we go through the development
    of the application but now that we have created the base structure of our Angular
    application, we will use this structure to build other parts of the project. Now,
    we will discuss how we can structure our components in Angular.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们通过应用程序的开发过程创建认证服务的具体内容时，我们将使用这个结构来构建项目的其他部分。现在，我们将讨论如何在 Angular 中构建我们的组件结构。
- en: Structuring components
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件结构
- en: We have already structured our Angular application by categorizing our modules
    based on their use and functionality, which will benefit code reusability and
    maintainability. However, there is still the possibility that a large number of
    components could be created under a specific module, which would further improve
    the maintainability of an application. In this section, we will discuss another
    strategy for building your Angular architecture at the component level.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过根据其用途和功能对模块进行分类来构建我们的 Angular 应用程序结构，这将有利于代码的可重用性和可维护性。然而，仍然存在在特定模块下创建大量组件的可能性，这将进一步提高应用程序的可维护性。在本节中，我们将讨论在组件级别构建
    Angular 架构的另一种策略。
- en: Smart and dumb or presentation components
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 智能与哑或展示组件
- en: The most common and recommended **component-level architecture** for building
    Angular applications is the smart and dumb component architecture. In the previous
    section, we split the modules into different categories based on how we were using
    them in the application.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 构建 Angular 应用程序最常见和推荐的**组件级别架构**是智能与哑组件架构。在上一节中，我们根据在应用程序中的使用方式将模块分为不同的类别。
- en: This architecture also offers the same concept. We will divide the components
    into two different types – namely, **smart components** and **dumb** or **presentation
    components**.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构也提供了相同的概念。我们将组件分为两种不同的类型——即，**智能组件**和**哑**或**展示组件**。
- en: Let’s discuss the characteristics of each component type.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论每种组件类型的特征。
- en: Smart components
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 智能组件
- en: '**Smart components** are also known as application-level components or container
    components. The primary responsibility of these components is to communicate with
    services and consume data from a request. Since they are smart, they contain all
    the dependencies and subscriptions required to get the data for the application.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**智能组件**也被称为应用级组件或容器组件。这些组件的主要职责是与服务通信并从请求中获取数据。由于它们是智能的，它们包含获取应用程序数据所需的所有依赖项和订阅。'
- en: 'Smart components can be considered page components that have direct routes
    in our application and they are the parent components holding the dumb components.
    Let’s have a look at the following example code for creating smart components:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 智能组件可以被认为是具有直接路由的应用程序页面组件，它们是包含哑组件的父组件。让我们看看以下创建智能组件的示例代码：
- en: '[PRE34]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding example code, we have created a component named `HomeComponent`
    that will display a list of users in the table. We have also injected `UserService`
    to get the users from an HTTP request. We know that this component will successfully
    display the users, but we can see that our template is extensive and might get
    too complicated as we add more features to this component.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例代码中，我们创建了一个名为 `HomeComponent` 的组件，该组件将在表格中显示用户列表。我们还注入了 `UserService`
    以从 HTTP 请求中获取用户。我们知道这个组件将成功显示用户，但我们可以看到我们的模板很庞大，并且随着我们向该组件添加更多功能，它可能会变得过于复杂。
- en: 'What we would want to do is omit elements that are only for presentation purposes.
    In this scenario, we would like to remove the table in our `HomeComponent`, and
    we would have the following code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要做的是省略仅用于展示目的的元素。在这种情况下，我们希望从我们的 `HomeComponent` 中移除表格，并将有以下的代码：
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding refactored code, we have removed the table displaying the list
    of users. We only want smart components to handle dependency injections, subscriptions,
    and actions. We have now successfully created our smart components and the next
    step is to make the presentation components.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的重构代码中，我们移除了显示用户列表的表格。我们只希望智能组件处理依赖注入、订阅和操作。我们现在已经成功创建了我们的智能组件，下一步是创建展示组件。
- en: Dumb or presentation components
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 哑或展示组件
- en: '**Dumb components**, also known as presentation components, are responsible
    for displaying data in the application. They should not have dependencies and
    subscriptions, as their only purpose is to present the data in the view.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**哑组件**，也称为展示组件，负责在应用程序中显示数据。它们不应该有依赖项和订阅，因为它们的唯一目的是在视图中展示数据。'
- en: 'Let’s create the table we omitted a while ago as a dumb component:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建之前遗漏的表格作为哑组件：
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding example code, we have created a separate component for the
    table that displays the list of users. Since dumb components have no dependencies
    injected, the component will need to receive the data from the smart components.
    To achieve this, we have added an `@Input` binding property to accept the list
    of users from `HomeComponent`; on the other hand, we have also added an `@Output`
    binding property to bubble actions to the parent or smart component.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例代码中，我们为显示用户列表的表格创建了一个单独的组件。由于哑组件没有注入依赖项，该组件需要从智能组件接收数据。为了实现这一点，我们添加了一个
    `@Input` 绑定属性来接收来自 `HomeComponent` 的用户列表；另一方面，我们还在智能组件中添加了一个 `@Output` 绑定属性，以便将操作冒泡到父组件或智能组件。
- en: Remember that dumb components must not have any logic or actions; in this case,
    we will pass the event in the parent component with the use of `EventEmitter`
    and the parent component will be responsible for the steps needed to be accomplished.
    In the example code, once a row is clicked, we are passing the user to the `userEmitter`
    that `HomeComponent` will retrieve.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，哑组件不能有任何逻辑或操作；在这种情况下，我们将使用 `EventEmitter` 在父组件中传递事件，父组件将负责完成所需的步骤。在示例代码中，一旦点击行，我们就将用户传递给
    `userEmitter`，`HomeComponent` 将检索它。
- en: 'After successfully creating `UserListComponent`, we can now use this in our
    `HomeComponent`, and we will have the following code:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功创建 `UserListComponent` 之后，我们现在可以在 `HomeComponent` 中使用它，并且我们将得到以下代码：
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding example code, we can see that we have used `UsersListComponent`
    as a child component of `HomeComponent`. It accepts the list of the users retrieved
    by `HomeComponent` and emits an event once a specific row is clicked. With that,
    we have now finished discussing the concepts of smart and dumb components.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例代码中，我们可以看到我们使用了 `UsersListComponent` 作为 `HomeComponent` 的子组件。它接受 `HomeComponent`
    检索到的用户列表，并在点击特定行时发出一个事件。有了这个，我们现在已经完成了对智能和哑组件概念的讨论。
- en: Let’s apply the architecture to our application now.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将架构应用到我们的应用程序中。
- en: Implementing smart and dumb components in the project
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在项目中实现智能和哑组件
- en: Let’s now implement the smart and dumb component architecture in our Angular
    project. We will create our components under `AntiHeroModule`. We have already
    made our `form` and `list` components in the `pages` folder.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在我们的 Angular 项目中实现智能和哑组件架构。我们将在 `AntiHeroModule` 下创建我们的组件。我们已经在 `pages`
    文件夹中创建了我们的 `form` 和 `list` 组件。
- en: We will always place our smart components in the `pages` folder, as these will
    be our container components throughout the application. The next step is to create
    our dumb components. We will create two dumb components, namely the `anti-hero-form`
    and `anti-hero-list` components. To make the components, execute the `ng g c anti-hero/components/anti-hero-form
    anti-hero/components anti-hero-list` command. After successfully generating the
    two dumb components, let’s place the following code.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将始终将我们的智能组件放在 `pages` 文件夹中，因为它们将是应用程序中的容器组件。下一步是创建我们的哑组件。我们将创建两个哑组件，即 `anti-hero-form`
    和 `anti-hero-list` 组件。为了创建组件，执行 `ng g c anti-hero/components/anti-hero-form anti-hero/components
    anti-hero-list` 命令。在成功生成两个哑组件后，让我们放置以下代码。
- en: 'For `AntiHeroListComponent`, we will place the following code into the `anti-hero-list.component.html`
    file:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `AntiHeroListComponent`，我们将以下代码放入 `anti-hero-list.component.html` 文件中：
- en: '[PRE38]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding HTML code, we have created a table where the headers and the
    items are bound to the `antiHeroes` variable. We have also bound the headers and
    the key values of the anti-hero to display the values dynamically.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 HTML 代码中，我们创建了一个表格，其中标题和项绑定到 `antiHeroes` 变量。我们还绑定了标题和反英雄的关键值来动态显示值。
- en: 'Now, let’s add the properties for receiving and emitting data into our `AntiHeroList`
    component:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为接收和发出数据添加到我们的 `AntiHeroList` 组件中的属性：
- en: anti-hero-list.component.ts
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: anti-hero-list.component.ts
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, in the `TypeScript` file of the anti-hero component, we have defined three
    properties that we need for the dumb component to accept data from and emit events
    to the smart component.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在反英雄组件的`TypeScript`文件中，我们定义了三个属性，这些属性是我们哑组件需要用于接收数据和向智能组件发射事件的。
- en: 'The first property is the `headers` property, which has the `@Input` annotation.
    This will get an array of the `{headerName: string, fieldName: keyof AntiHero}`
    type, which will be iterated to display the column headers and display the values
    of each field of an anti-hero item. The second property is `antiHeroes`, which
    also has an `@Input` annotation. This will accept the list of anti-heroes to be
    displayed in each row, and lastly, the `antiHero` property, which is annotated
    with `@Output`. This emits the selected anti-hero to the parent component once
    a user clicks a single row.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '第一个属性是`headers`属性，它具有`@Input`注解。这将获取一个包含`{headerName: string, fieldName: keyof
    AntiHero}`类型的数组，该数组将被迭代以显示列标题并显示反英雄项目每个字段的值。第二个属性是`antiHeroes`，它也具有`@Input`注解。这将接受要在每行显示的反英雄列表，最后是`antiHero`属性，它被注解为`@Output`。当用户点击单行时，这将向父组件发射所选的反英雄。'
- en: We have also added an interface named `AntiHero` in `anti-hero/models/anti-hero.interface.ts`
    that will be used to cast object types.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在`anti-hero/models/anti-hero.interface.ts`中添加了一个名为`AntiHero`的接口，该接口将用于转换对象类型。
- en: 'We will have the following code for `interface`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为`interface`有以下代码：
- en: '[PRE40]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding code example, we have created an `AntiHero` interface that
    will be used as the blueprint of our object. The properties of the anti-hero object
    are the same as the properties we defined in our Spring application.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们创建了一个`AntiHero`接口，该接口将用作我们对象的蓝图。反英雄对象的属性与我们定义在Spring应用程序中相同的属性相同。
- en: After creating the interface for our object, we will now declare and import
    our components and modules into `AntiHeroModule`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在为我们的对象创建接口之后，我们现在将在`AntiHeroModule`中声明和导入我们的组件和模块。
- en: 'Let’s have a look at the following code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码：
- en: anti-hero.module.ts
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: anti-hero.module.ts
- en: '[PRE41]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In our `anti-hero.module.ts` file, we want to make sure that our smart components
    and dumb components are declared; otherwise, we will have errors at compilation.
    We also want to check whether our `AntiHeroRoutingModule` is imported for use
    of the routes.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`anti-hero.module.ts`文件中，我们想要确保声明了我们的智能组件和哑组件；否则，在编译时将会有错误。我们还想要检查是否导入了`AntiHeroRoutingModule`以使用路由。
- en: 'Let’s now add additional styling to improve the user interface of our application.
    Let’s have a look at the following code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在添加额外的样式来改善我们应用程序的用户界面。让我们看一下以下代码：
- en: anti-hero-list.component.scss
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: anti-hero-list.component.scss
- en: '[PRE42]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We have also added a simple CSS code to style our table in the component. Now,
    we have successfully created our `AntiHeroListComponent`. The next step is to
    use this presentation component on the `ListComponent` page. Let’s have a look
    at the following code example:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在组件中添加了一些简单的CSS代码来美化我们的表格。现在，我们已经成功创建了`AntiHeroListComponent`。下一步是在`ListComponent`页面上使用这个展示组件。让我们看一下以下代码示例：
- en: '[PRE43]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the `TypeScript` file of `ListComponent`, we have created the definition
    of the headers and an example list of `antiHeroes` for the anti-hero list to display.
    This will only be temporary, as we just want to test whether our presentation
    component displays the list of anti-heroes successfully. We have also created
    the `selectAntiHero()` function for future implementation once a specific anti-hero
    is selected.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ListComponent`的`TypeScript`文件中，我们创建了标题的定义以及一个反英雄列表的示例列表，用于显示反英雄列表。这将是临时的，因为我们只是想测试我们的展示组件是否成功显示了反英雄列表。我们还创建了`selectAntiHero()`函数，以便在选择了特定的反英雄后进行实现。
- en: 'Let’s now define the input and output properties for `AntiHeroList`. Let’s
    have a look at the following code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在为`AntiHeroList`定义输入和输出属性。让我们看一下以下代码：
- en: list.component.html
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: list.component.html
- en: '[PRE44]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now, in the HTML file of `ListComponent`, we have bound `headers` and `antiHeroes`
    to the properties of `app-anti-hero-list`. We have also used the `selectAntiHero()`
    function to catch the event once `antiHero` has emitted an action.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`ListComponent`的HTML文件中，我们将`headers`和`antiHeroes`绑定到`app-anti-hero-list`的属性上。我们还使用了`selectAntiHero()`函数来捕获事件，一旦`antiHero`发射了动作。
- en: 'After successfully implementing our presentation component, we can run the
    application and open the application in the browser. We should see the following
    results:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功实现我们的展示组件后，我们可以运行应用程序并在浏览器中打开应用程序。我们应该看到以下结果：
- en: '![Figure 10.9 – AntiHeroList presentation component](img/B18159_10_09.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.9 – AntiHeroList 展示组件](img/B18159_10_09.jpg)'
- en: Figure 10.9 – AntiHeroList presentation component
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 – AntiHeroList 展示组件
- en: We can see in the results that our presentation component has successfully displayed
    the data coming from the parent component. For the form component, we will implement
    its functionalities in the next chapter, as creating forms will be another different
    topic.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在结果中看到，我们的展示组件已经成功显示了来自父组件的数据。对于表单组件，我们将在下一章中实现其功能，因为创建表单将是一个不同的主题。
- en: Now, we have learned about the concepts, structure, and implementation of smart
    and dumb components. In the next section, we will now use a UI framework that
    will help us improve the interface of our Angular application.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经了解了智能和愚笨组件的概念、结构和实现。在下一节中，我们将使用一个 UI 框架来帮助我们改进 Angular 应用程序的界面。
- en: Adding Angular Material
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 Angular Material
- en: We have already organized our Angular application using the **core**, **feature**,
    and **shared** architecture at the module level and the smart and dumb architecture
    at the component level. Now, we are ready to customize and improve the look and
    UI by styling our components. We all know that writing CSS code from scratch and
    developing a base style is another challenge for us developers. It creates additional
    effort for us beyond just worrying about the logical side of the code. This is
    where Angular Material saves the day!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用 **核心**、**功能**和 **共享** 架构在模块级别以及智能和愚笨架构在组件级别组织了我们的 Angular 应用程序。现在，我们准备通过为我们的组件添加样式来自定义和改进外观和
    UI。我们都知道，从头开始编写 CSS 代码并开发基础样式对我们开发者来说又是一个挑战。这给我们带来了额外的努力，而不仅仅是关注代码的逻辑方面。这就是 Angular
    Material 拯救我们的时刻！
- en: '**Angular Material** is a library created by Google that provides a wide range
    of UI components for use in Angular applications, such as tables, cards, inputs,
    and date pickers. This means that we don’t have to style components from scratch,
    as a list of components from the material library is ready to use.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**Angular Material** 是由 Google 创建的一个库，它为 Angular 应用程序提供了一系列 UI 组件，例如表格、卡片、输入和日期选择器。这意味着我们不必从头开始为组件添加样式，因为来自材料库的组件列表已经准备好使用。'
- en: Angular Material has a wide range of growing components under the hood. It provides
    modules containing the components that can be used in Angular applications which
    can be imported into a specific application module; components are reusable and
    easy to customize in terms of their look and feel, as they have built-in properties
    that we can use.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Angular Material 在其内部拥有广泛的增长组件。它提供了包含可用于 Angular 应用程序的组件的模块，这些组件可以导入到特定的应用程序模块中；组件是可重用的，并且易于根据其外观和感觉进行自定义，因为它们具有内置的我们可以使用的属性。
- en: Let’s configure Angular Material in our Angular project.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Angular 项目中配置 Angular Material。
- en: Configuring Angular Material
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Angular Material
- en: 'Angular Material is easy to configure in Angular projects, as it provides a
    schematic to install all the dependencies of Angular Material in just one command.
    To install Angular Material, we will execute the following command:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 项目中配置 Angular Material 很容易，因为它提供了一个脚本来安装 Angular Material 的所有依赖项。要安装
    Angular Material，我们将执行以下命令：
- en: '[PRE45]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'After executing the command, it will ask some questions before installing the
    resources:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 执行命令后，它将询问一些问题，然后安装资源：
- en: '**Choose a prebuilt theme name or “custom” for a custom theme**: Angular Material
    provides prebuilt themes or you can configure your custom theme.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择预构建的主题名称或“自定义”以创建自定义主题**：Angular Material 提供预构建的主题，或者您可以配置您自己的自定义主题。'
- en: '**Set up global Angular Material typography styles**: Choosing **yes** will
    apply the global typography of Angular Material.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置全局 Angular Material 字体样式**：选择 **是** 将应用 Angular Material 的全局字体样式。'
- en: '`BrowserAnimationsModule` in our root module. This is important when we want
    to use animations from Angular Material.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的根模块中，有 `BrowserAnimationsModule`。当我们想要使用 Angular Material 的动画时，这是很重要的。
- en: 'After completing all the questions, it will now install Angular Material. This
    will execute the following actions for our project:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有问题后，它将现在安装 Angular Material。这将为我们项目执行以下操作：
- en: Adding dependencies to `package.json` `(@angular/material` and `@angular/cdk`).
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将依赖项添加到 `package.json` (`@angular/material` 和 `@angular/cdk`)。
- en: 'Adding the `Roboto` font to the `index.html` file:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Roboto` 字体添加到 `index.html` 文件中：
- en: '[PRE46]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Adding the Material Design icon font to the `index.html` file:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Material Design 图标字体添加到 `index.html` 文件中：
- en: '[PRE47]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Adding the following CSS styles:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下 CSS 样式：
- en: Setting `height` to `100%` for `html` and `body`
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`html`和`body`的`height`设置为`100%`
- en: Setting `Roboto` as the default font
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置`Roboto`为默认字体
- en: 'Removing margins from the body:'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从主体中移除边距：
- en: '[PRE48]'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: After successfully installing Angular Material in our application, we are now
    ready to use the components in our application.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中成功安装Angular Material后，我们现在可以准备在应用程序中使用这些组件。
- en: Implementing Angular Material
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现Angular Material
- en: We will now implement Angular Material components in our Angular project. As
    we mentioned a while ago, Angular Material offers a wide range of components that
    we can use for building our application. In this example project, we will only
    define the components that we will use in our application. Let’s list the components
    that we will implement.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将在我们的Angular项目中实现Angular Material组件。正如我们之前提到的，Angular Material提供了一系列我们可以用于构建应用程序的组件。在这个示例项目中，我们只定义我们将要使用的组件。让我们列出我们将要实现的组件。
- en: Button component
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按钮组件
- en: The native `<button>` or `<a>` elements that are enhanced with Material Design
    styling.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 使用材料设计增强的本地`<button>`或`<a>`元素。
- en: 'We can import the button component using the following code:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码导入按钮组件：
- en: '[PRE50]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here’s an example of the button component:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是按钮组件的示例：
- en: '[PRE51]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the preceding code example for the **Material** button, we can see that
    we are using built-in directives from Material Design to change the style and
    look of the button. The example code will have the following output:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的**材料**按钮代码示例中，我们可以看到我们正在使用材料设计的内置指令来更改按钮的样式和外观。示例代码将产生以下输出：
- en: '![Figure 10.10 – Example output for the Material button](img/B18159_10_10.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图10.10 – 材料按钮的示例输出](img/B18159_10_10.jpg)'
- en: Figure 10.10 – Example output for the Material button
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 – 材料按钮的示例输出
- en: Icon component
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图标组件
- en: This component allows us to add vector-based icons to the application and supports
    both icon fonts and SVG icons.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件允许我们在应用程序中添加基于矢量的图标，并支持图标字体和SVG图标。
- en: 'We can import the icon component using the following code:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码导入图标组件：
- en: '[PRE52]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Here’s an example of the icon component:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是图标组件的示例：
- en: '[PRE53]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the preceding code example, we can create icons by using the `mat-icon`
    component. This has several input properties such as color that allow us to customize
    the color of the icon. The example code will have the following output:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们可以通过使用`mat-icon`组件来创建图标。它有几个输入属性，如颜色，允许我们自定义图标的颜色。示例代码将产生以下输出：
- en: '![Figure 10.11 – Example output for the Material icon](img/B18159_10_11.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![图10.11 – 材料图标的示例输出](img/B18159_10_11.jpg)'
- en: Figure 10.11 – Example output for the Material icon
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11 – 材料图标的示例输出
- en: Table component
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表格组件
- en: This component allows us to add a data table with Material Design styling. The
    Material table is based on the foundation of the **CDK data table**. For more
    information on how to implement a CDK data table, see the documentation at https://material.angular.io/cdk/table/overview.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件允许我们添加具有材料设计样式的数据表。材料表基于**CDK数据表**的基础。有关如何实现CDK数据表的更多信息，请参阅https://material.angular.io/cdk/table/overview的文档。
- en: 'We can import the table component using the following code:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码导入表格组件：
- en: '[PRE54]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here’s an example of the table component:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是表格组件的示例：
- en: '[PRE55]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In the preceding example, we can see the table uses several properties. The
    first property is the `dataSource` property, which will be the one accepting the
    list of data to be displayed. The next property is `matColumnDef`, which defines
    the field name of each column that should be included in the `columns` variable
    that is bound to the `matHeaderRowDef` property. Lastly, the `matHeaderCellDef`
    and `mattCelDef` properties display the actual column name and the associated
    values, as shown in the following screenshot:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们可以看到表格使用了几个属性。第一个属性是`dataSource`属性，它将接受要显示的数据列表。下一个属性是`matColumnDef`，它定义了应包含在绑定到`matHeaderRowDef`属性的`columns`变量中的每个列的字段名。最后，`matHeaderCellDef`和`mattCelDef`属性显示了实际的列名和相关的值，如下面的屏幕截图所示：
- en: '![Figure 10.12 – Example output for the Material table](img/B18159_10_12.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![图10.12 – 材料表格的示例输出](img/B18159_10_12.jpg)'
- en: Figure 10.12 – Example output for the Material table
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12 – 材料表格的示例输出
- en: Toolbar component
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工具栏组件
- en: This component allows us to add a toolbar with Material Design styling. This
    is commonly used as a container for headers, titles, and navigation buttons.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件允许我们添加具有材料设计样式的工具栏。这通常用作标题、标题和导航按钮的容器。
- en: 'We can import the toolbar component using the following code:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码导入工具栏组件：
- en: '[PRE56]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here’s an example of the toolbar component:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是工具栏组件的示例：
- en: '[PRE57]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In the preceding code example, we have created a toolbar element using the
    `mat-toolbar` component. The `mat-toolbar` component uses content projection that
    allows us to customize its contents. The example code will have the following
    output:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们使用`mat-toolbar`组件创建了一个工具栏元素。`mat-toolbar`组件使用内容投影，允许我们自定义其内容。示例代码将产生以下输出：
- en: '![Figure 10.13 – Example output for the Material toolbar](img/B18159_10_13.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图10.13 – 材料工具栏的示例输出](img/B18159_10_13.jpg)'
- en: Figure 10.13 – Example output for the Material toolbar
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13 – 材料工具栏的示例输出
- en: Form field component
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表单字段组件
- en: 'This component allows us to wrap Material components to apply text field styles
    such as underlining, hint messages, and floating labels. The following components
    can be used inside `<mat-form-field>`:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件允许我们将材料组件包装起来，以应用文本字段样式，如下划线、提示信息和浮动标签。以下组件可以在`<mat-form-field>`内部使用：
- en: '`input matNativeControl>` and `<textarea matNativeControl>`: Can be used by
    adding `import {MatInputModule}` `from ''@angular/material/input'';`'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`input matNativeControl>`和`<textarea matNativeControl>`：可以通过添加`import {MatInputModule}
    from ''@angular/material/input'';`来使用'
- en: '`<mat-select>`: Can be used by adding `import {MatSelectModule} from ''@``angular/material/select'';`'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<mat-select>`：可以通过添加`import {MatSelectModule} from ''@angular/material/select'';`来使用'
- en: '`<mat-chip-list>`: Can be used by adding `import {MatChipsModule} from ''@``angular/material/chips'';`'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<mat-chip-list>`：可以通过添加`import {MatChipsModule} from ''@angular/material/chips'';`来使用'
- en: 'Here’s an example of the form field component:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个表单字段组件的示例：
- en: '[PRE58]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In the preceding code example, we have created a toolbar element using the
    `mat-form-field` component. The `mat-form-field` component should have the `mat-label`
    component and an input element with the `matInput` directive as its contents.
    The example code will have the following output:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们使用`mat-form-field`组件创建了一个工具栏元素。`mat-form-field`组件应包含`mat-label`组件和一个带有`matInput`指令的输入元素。示例代码将产生以下输出：
- en: '![Figure 10.14 – Example output for the Material form field](img/B18159_10_14.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![图10.14 – 材料表单字段的示例输出](img/B18159_10_14.jpg)'
- en: Figure 10.14 – Example output for the Material form field
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14 – 材料表单字段的示例输出
- en: For more information on the list of components from Angular Material, see the
    documentation at https://material.angular.io/components.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Angular Material组件列表的更多信息，请参阅https://material.angular.io/components的文档。
- en: Now that we have listed the Material components we will use in our application,
    let’s apply Material Design to our components.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经列出了我们将在应用程序中使用的材料组件，让我们将材料设计应用到我们的组件上。
- en: 'The first step we need to do is to create our Material module. The Material
    modules will be included in the shared module so that we can use Material design
    components throughout the application. To generate our Material module in our
    Angular application, we will execute the following command: `ng g m material`.
    After successfully generating the Material module, we will add the necessary modules
    from Angular Material:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一步是创建我们的材料模块。材料模块将被包含在共享模块中，这样我们就可以在整个应用程序中使用材料设计组件。要在我们的Angular应用程序中生成材料模块，我们将执行以下命令：`ng
    g m material`。在成功生成材料模块后，我们将添加Angular Material中必要的模块：
- en: '[PRE59]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We can see in the preceding example that we have also exported the Material
    modules, as we will use them on different modules in the application.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前面的示例中看到，我们也导出了材料模块，因为我们将在应用程序的不同模块中使用它们。
- en: Now that we have imported the needed modules for our application, let’s convert
    the components.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经导入了我们应用程序所需的模块，让我们转换组件。
- en: Navbar component
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导航栏组件
- en: 'The **navbar component** is found under the shared module. We will use the
    toolbar material to create our navbar component. To implement this, we will place
    the following code:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '**导航栏组件**位于共享模块下。我们将使用工具栏材料来创建我们的导航栏组件。为此，我们将放置以下代码：'
- en: '[PRE60]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In the preceding example, we have used the `mat-toolbar` element to use the
    toolbar material. We can also add a color property to style the toolbar and add
    additional elements inside.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了`mat-toolbar`元素来使用工具栏材料。我们还可以添加一个颜色属性来样式化工具栏，并在其中添加额外的元素。
- en: 'We also need to import `MaterialModule` under `SharedModule` for this to recognize
    `MatToolbarModule` and it will output the following:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在`SharedModule`下导入`MaterialModule`，以便识别`MatToolbarModule`，它将输出以下内容：
- en: '![Figure 10.15 – The look of the navbar component after implementing Material](img/B18159_10_15.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![图10.15 – 实施Material后导航栏组件的外观](img/B18159_10_15.jpg)'
- en: Figure 10.15 – The look of the navbar component after implementing Material
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15 – 实施Material后导航栏组件的外观
- en: Anti-hero list component
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反英雄列表组件
- en: 'This component is found under the anti-hero module. We will use the table material
    to create our list component. To implement this, we will place the following code
    for `anti-hero-list.component.html`:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件位于反英雄模块下。我们将使用表格材料来创建我们的列表组件。为了实现这一点，我们将以下代码放置在`anti-hero-list.component.html`：
- en: '[PRE61]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We will place this for `anti-hero-list.component.ts`:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将此放置在`anti-hero-list.component.ts`：
- en: '[PRE62]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In the preceding example code, we have still used the same variables in our
    application; the `antiHeroes` variable that holds the list of anti-heroes is now
    bound to the `dataSource` property and we have also iterated the `headers` property
    to display the column name and its associated values. Lastly, we have created
    a new variable named `headerFields` that contains the `fieldName` to display the
    values of an anti-hero item.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例代码中，我们仍然在我们的应用程序中使用了相同的变量；`antiHeroes`变量，它保存反英雄列表，现在绑定到`dataSource`属性，我们还迭代了`headers`属性以显示列名及其相关值。最后，我们创建了一个名为`headerFields`的新变量，它包含要显示反英雄项值的`fieldName`。
- en: 'We also need to import `MaterialModule` under `AntiHeroModule` for this to
    recognize `MatTableModule` and it will have the following output:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在`AntiHeroModule`下导入`MaterialModule`，以便它能够识别`MatTableModule`，它将产生以下输出：
- en: '![Figure 10.16 – The look of the table component after implementing Material](img/B18159_10_16.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![图10.16 – 实施Material后表格组件的外观](img/B18159_10_16.jpg)'
- en: Figure 10.16 – The look of the table component after implementing Material
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16 – 实施Material后表格组件的外观
- en: Command bar component
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令栏组件
- en: 'We will create a new dumb component under the anti-hero module. We will execute
    the `ng g c anti-hero/components/anti-hero-command-bar` command and we will place
    the following code for `anti-hero-command-bar.html`:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在反英雄模块下创建一个新的哑组件。我们将执行`ng g c anti-hero/components/anti-hero-command-bar`命令，并将以下代码放置在`anti-hero-command-bar.html`：
- en: '[PRE63]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We will place this for `anti-hero-command-bar.ts`:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将此放置在`anti-hero-command-bar.ts`：
- en: '[PRE64]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In the preceding example code, we have also used the toolbar module to create
    our command bar component. Since this is a dumb component, we should only emit
    the actions to its parent component and not hold any dependencies. After successfully
    creating the command bar, we will get the following output:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例代码中，我们同样使用了工具栏模块来创建我们的命令栏组件。由于这是一个哑组件，我们应只向其父组件发出动作，而不保留任何依赖。在成功创建命令栏后，我们将得到以下输出：
- en: '![Figure 10.17 – The look of the command bar component after implementing Material](img/B18159_10_17.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![图10.17 – 实施Material后命令栏组件的外观](img/B18159_10_17.jpg)'
- en: Figure 10.17 – The look of the command bar component after implementing Material
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.17 – 实施Material后命令栏组件的外观
- en: 'Now, we will finalize the application layout by placing the components on the
    following page:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过在以下页面上放置组件来最终确定应用程序布局：
- en: '`app.component.html`:'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.component.html`：'
- en: '[PRE65]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '`list.component.html`:'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list.component.html`：'
- en: '[PRE69]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'After successfully implementing the preceding code, we will now have the following
    layout:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功实现前面的代码后，我们现在将拥有以下布局：
- en: '![Figure 10.18 – Layout for the list component page](img/B18159_10_18.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![图10.18 – 列表组件页面布局](img/B18159_10_18.jpg)'
- en: Figure 10.18 – Layout for the list component page
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.18 – 列表组件页面布局
- en: We have now created our anti-heroes page component with Material Design. As
    we go through the following chapters, we will implement the features for the action
    buttons and the form component.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经使用Material Design创建了我们的反英雄页面组件。在接下来的章节中，我们将实现动作按钮和表单组件的功能。
- en: Summary
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With this, we have reached the end of this chapter. Let’s have a recap of the
    valuable things you have learned; you have learned about the concepts and fundamentals
    of Angular and, at the same time, how to scaffold an Angular project and create
    components, directives, and modules using the Angular CLI. You have also learned
    some of the best practices for organizing our Angular components, modules, and
    other parts of our Angular project. This will be very useful for the maintainability
    of the project, especially for enterprise applications.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经到达了本章的结尾。让我们回顾一下你所学到的宝贵知识；你学习了 Angular 的概念和基础知识，同时了解了如何使用 Angular CLI
    搭建 Angular 项目以及创建组件、指令和模块。你还学到了一些组织 Angular 组件、模块以及 Angular 项目其他部分的最佳实践。这将对项目的可维护性非常有用，尤其是对于企业应用来说。
- en: In the next chapter, we will learn how to build Reactive forms, essential form
    control, and grouping form controls in Angular. We will also implement `FormBuilder`
    and validate form input.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何在 Angular 中构建响应式表单、基本表单控件以及如何分组表单控件。我们还将实现 `FormBuilder` 并验证表单输入。
