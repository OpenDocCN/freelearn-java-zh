- en: Chapter 3. Developing the UI with Play Framework
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 使用Play框架开发UI
- en: In the previous chapter, we performed bootstrapping on our application using
    Activator. In this chapter, we will continue developing our web application using
    Scala and Play framework. Play framework is great for web development because
    it is simple to use, and at the same time, very powerful. This is because it uses
    top-notch reactive solutions like spray, Akka, and Akka Stream under the hood.
    For this chapter, we will create the basic UI for some parts of our reactive web
    solution by adding validation and an in-memory store so you can feel the application
    working. We will use a little bit of CSS for styling, and JavaScript for some
    simple visualizations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用Activator对我们的应用程序进行了引导。在本章中，我们将继续使用Scala和Play框架开发我们的Web应用程序。Play框架非常适合Web开发，因为它易于使用，同时非常强大。这是因为它在底层使用了一些顶级的反应式解决方案，如spray、Akka和Akka
    Stream。对于本章，我们将通过添加验证和内存存储来创建我们反应式Web解决方案的一些基本UI，这样你就可以感受到应用程序在工作。我们将使用一点CSS进行样式设计，以及JavaScript进行一些简单的可视化。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Basics of web development with Scala and Play frameworks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Scala和Play框架进行Web开发的基础
- en: Creating your models
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你的模型
- en: Working with views and validations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与视图和验证一起工作
- en: Working with session scopes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与会话作用域一起工作
- en: Getting started
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: Let's have a look at the preview of `Reactive Web Store`--the application that
    we will build.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Reactive Web Store`的预览——我们将要构建的应用程序。
- en: '![Getting started](img/image00256.jpeg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![入门](img/image00256.jpeg)'
- en: For now, we will build three simple operations--**Create, Retrieve, Update,**
    and **Delete** (**CRUD**) in order to manage products, product reviews, and product
    images. We will create models, controllers, views, and routes for each CRUD.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将构建三个简单的操作——**创建、检索、更新**和**删除**（**CRUD**），以管理产品、产品评论和产品图像。我们将为每个CRUD创建模型、控制器、视图和路由。
- en: Let's get started. First of all, we need to define our models. The models need
    to be located at `ReactiveWebStore/app/models`. Models are the CORE of the system
    and they represent the entity. We will use this entity later to store and retrieve
    data from a database later on in [Chapter 6](part0071.xhtml#aid-23MNU1 "Chapter 6. 
    Persistence with Slick"), *Persistence with Slick*. Our models should not have
    any UI logic, since we should use controllers for UI logic.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。首先，我们需要定义我们的模型。模型需要位于`ReactiveWebStore/app/models`。模型是系统的核心，它们代表实体。我们将在[第6章](part0071.xhtml#aid-23MNU1
    "第6章。使用Slick进行持久化")中稍后使用这个实体来存储和检索数据，*使用Slick进行持久化*。我们的模型不应该有任何UI逻辑，因为我们应该使用控制器来处理UI逻辑。
- en: Creating our models
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的模型
- en: 'For our product model, we have a simple Scala case class in `Product.scala`
    as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的产品模型，我们在`Product.scala`中有一个简单的Scala case class，如下所示：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A product can have an optional ID, a name, details, and a price. We also override
    the `toString` method just for the sake of simplicity for logging. We also need
    to define models for image and review.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一个产品可以有一个可选的ID，一个名称，详细信息和一个价格。我们只是为了简化日志记录而重写`toString`方法。我们还需要定义图像和评论的模型。
- en: 'The following is the review model from `Review.scala`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从`Review.scala`中获取的评论模型：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For a review model, we have an optional ID, an optional `productId`, one author,
    and a comment. Validations will be done on the views. Now let's go for the image
    model.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个评论模型，我们有一个可选的ID，一个可选的`productId`，一个作者和一个评论。验证将在视图上进行。现在让我们转向图像模型。
- en: 'The image model can be found in `Image.scala` as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图像模型可以在`Image.scala`中找到，如下所示：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For an image model, we have an optional ID, an optional `productId`, and the
    image URL.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于图像模型，我们有一个可选的ID，一个可选的`productId`和图像URL。
- en: The Play framework does the routing, and we need to define the routes at `ReactiveWebStore/conf/routes`.
    Keep in mind that the Play framework will validate all the routes, so you need
    to specify valid packages and classes. Play also creates something called reverse
    controller, which we will use later in the chapter. For now, let's define the
    routes. Reverse controller is generated by the Play framework with an action method
    which is the same as that of the original controller with the same signature,
    but it returns `play.api.mvc.Call` instead of `play.api.mvc.Action`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Play框架负责路由，我们需要在`ReactiveWebStore/conf/routes`中定义路由。请记住，Play框架将验证所有路由，因此您需要指定有效的包和类。Play还创建了一个称为反向控制器的东西，我们将在本章后面使用。现在，让我们定义路由。反向控制器由Play框架生成，具有与原始控制器相同签名的方法，但它返回`play.api.mvc.Call`而不是`play.api.mvc.Action`。
- en: Creating routes
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建路由
- en: 'The Play framework CRUD operations'' routes for product, image, and review
    are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Play框架为产品、图片和评论的CRUD操作的路由如下：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The routes work like this--First you need to define the rest verb such as `GET`,
    `POST`, `PUT`, `DELETE`, and then you put in a `PATH` like `/image`. Finally,
    you specify which controller function will handle that route. Now we have the
    routes in place, we can move to the controllers. We will define the controllers
    for product, image and review.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 路由的工作原理是这样的--首先，你需要定义一个REST动词，例如`GET`、`POST`、`PUT`、`DELETE`，然后你输入一个`PATH`，例如`/image`。最后，你指定哪个控制器函数将处理该路由。现在我们已经设置了路由，我们可以转向控制器。我们将为产品、图片和评论定义控制器。
- en: All the routes follow the same logic. First we send the user to the web page
    where we list all the items (products, images, reviews)--this is represented by
    `GET /resource`, where the resource can be an image, product, or review, for instance.
    In order to get a specific resource, often by ID, we give the command `GET /resource
    (product, review or image)/ID. POST /resource` is used to perform the `UPDATE`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所有路由遵循相同的逻辑。首先，我们将用户发送到我们列出所有项目的网页（产品、图片、评论）--这由`GET /resource`表示，其中资源可以是图片、产品或评论，例如。为了获取一个特定的资源，通常是通过ID，我们给出命令`GET
    /resource (product, review or image)/ID`。`POST /resource`用于执行`UPDATE`。
- en: In order to create a new item (product, review, or image), the pattern is `GET
    /resource/add` and `POST /resource/`. You may wonder why there are two routes
    to perform an insert. Well, that's because first of all we need to load the web
    page, and secondly, when the form is submitted, we need a new route to handle
    the values. There are two routes for an update as well for the same reason. If
    you want to `DELETE` a resource, the pattern is `POST /resource/ID/remove`. Lastly,
    we have the details of the operation, which is used to show detailed information
    with regard to a specific item--the pattern is `GET /resource/details/ID`. With
    six routes, we can do a complete CRUD for a resource such as product, image, and
    review, or any other future resource that you may add to this application or your
    own applications.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个新项目（产品、评论或图片），模式是`GET /resource/add`和`POST /resource/`。你可能想知道为什么有两个路由来执行插入操作。好吧，那是因为首先我们需要加载网页，其次，当表单提交时，我们需要一个新的路由来处理值。更新操作也有两个路由，原因相同。如果你想`DELETE`一个资源，模式是`POST
    /resource/ID/remove`。最后，我们有操作细节，它用于显示与特定项目相关的详细信息--模式是`GET /resource/details/ID`。有了六个路由，我们可以为产品、图片、评论或其他任何未来可能添加到该应用程序或您自己的应用程序的资源执行完整的CRUD操作。
- en: Creating our controllers
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的控制器
- en: Now let's move to the controllers used on the previous routes. The controllers
    need to be located at `ReactiveWebStore/app/controllers`. Controllers are bound
    between views (UI), models and service, which are responsible for business operations.
    It's always important to separate UI logic, which tends to be specific, from business
    logic, which tends to be more generic, and often, way more important.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向之前路由中使用的控制器。控制器需要位于`ReactiveWebStore/app/controllers`。控制器在视图（UI）、模型和服务之间绑定，它们负责业务操作。始终重要的是将UI逻辑（通常是特定的）与业务逻辑（通常是更通用的，并且通常更重要）分开。
- en: 'Let''s have a look at the product controller in `ProductController.scala` in
    the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码中的`ProductController.scala`中的产品控制器：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The Play framework uses dependency injection and inversion of control using
    Google Guice. So, you can see at the top of the controller that we have the annotations
    `@Singleton` and `@Inject`. Singleton means that Guice will create a single instance
    of the class to handle all requests. Inject means we are injecting other dependencies
    into our controller, for instance, we inject `MessagesApi` in order to have the Play
    framework internalization support for string messages, and `IProductService`,
    that is, the product service that we will cover later in this chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`The Play framework uses dependency injection and inversion of control using
    Google Guice. So, you can see at the top of the controller that we have the annotations
    `@Singleton` and `@Inject`. Singleton means that Guice will create a single instance
    of the class to handle all requests. Inject means we are injecting other dependencies
    into our controller, for instance, we inject `MessagesApi` in order to have the Play
    framework internalization support for string messages, and `IProductService`,
    that is, the product service that we will cover later in this chapter.`'
- en: We also need to extend the Play class, `play.api.mvc.Controller`. Each function
    in a controller needs to return an action. This action could be a view.The Play
    framework compiles all the views into Scala classes, so you can safely reference
    them into your controllers code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`We also need to extend the Play class, `play.api.mvc.Controller`. Each function
    in a controller needs to return an action. This action could be a view. The Play
    framework compiles all the views into Scala classes, so you can safely reference
    them into your controllers code.`'
- en: All business operations are delegated to a trait called `IProductService`, which
    we will cover later in this chapter. We also log some information using the Logger
    class. Play Framework uses `Logback` as the default logging solution. Let's take
    a closer look at each controller function now.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`All business operations are delegated to a trait called `IProductService`,
    which we will cover later in this chapter. We also log some information using
    the Logger class. Play Framework uses `Logback` as the default logging solution.
    Let''s take a closer look at each controller function now.`'
- en: The index function calls `IProductService`, and finds all the available products.
    If there are no products available, it returns an empty sequence, and then calls
    the product UI passing the collection of products.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`The index function calls `IProductService`, and finds all the available products.
    If there are no products available, it returns an empty sequence, and then calls
    the product UI passing the collection of products.``'
- en: The blank function renders a blank product form, so the user can have a blank
    product form on the UI in order to add data (insert operation). Play framework
    works with form binding. So, in each controller, you need to define how your form
    looks on the UI. That form mapping is done using `play.api.data.Form`. You can
    see the mapping on the immutable variable called `productForm`. The mapping is
    between the view(UI) and the model called product. Keep in mind that the name
    field is mapped as `NonEmptyText`, which means Play won't accept null or blank
    values. This is a great future, because we can do validations in a declarative
    way without having to write code. Price is defined as `BigDecimal`, so Play won't
    accept text, but only numbers.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`The blank function renders a blank product form, so the user can have a blank
    product form on the UI in order to add data (insert operation). Play framework
    works with form binding. So, in each controller, you need to define how your form
    looks on the UI. That form mapping is done using `play.api.data.Form`. You can
    see the mapping on the immutable variable called `productForm`. The mapping is
    between the view(UI) and the model called product. Keep in mind that the name
    field is mapped as `NonEmptyText`, which means Play won''t accept null or blank
    values. This is a great future, because we can do validations in a declarative
    way without having to write code. Price is defined as `BigDecimal`, so Play won''t
    accept text, but only numbers.` '
- en: The details function retrieves a product using `IProductService`, and redirects
    to the view. However, before doing the redirect, it binds the data with the form
    so the UI will load with all the data into the HTML inputs.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`The details function retrieves a product using `IProductService`, and redirects
    to the view. However, before doing the redirect, it binds the data with the form
    so the UI will load with all the data into the HTML inputs.`'
- en: 'We also have the insert and update methods. They are all constructed with a
    `fold` method. The `fold` method has left and right, which means error or ok.
    The `fold` function is called from the mapped form and if there are no validation
    errors, it goes right, but if there are validations errors, it goes left. That''s
    a very simple and clean way to code the `update` and `insert` flows. With `fold`,
    we don''t need code for an `if` statement. Once the validation is OK, we call
    `IProductService` to do an insert or update, and then we perform a redirect to
    the view. Messages are passed via scope. Play has options for scope--session or
    Flash. Session is for multiple requests, and the value will be stored in the client
    side. Flash is a request scope, and most of the times that is what you need to
    use. Here we are using the `Flash` scope, so it will only exit during that specific
    request. This feature is used to pass **Internationalization messages** (**i18n**),
    which are the result of the action. All the i18n messages need to be defined at
    `ReactiveWebStore/conf/messages` as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有插入和更新方法。它们都是使用`fold`方法构建的。`fold`方法有左右两个方向，这意味着错误或成功。`fold`函数是从映射表单中调用的，如果没有验证错误，它将向右移动，但如果存在验证错误，它将向左移动。这是一个非常简单和干净的方式来编写`update`和`insert`流程。使用`fold`，我们不需要编写`if`语句。一旦验证通过，我们调用`IProductService`来进行插入或更新，然后我们执行视图的重定向。消息通过作用域传递。Play有作用域选项——会话或Flash。会话用于多个请求，值将存储在客户端。Flash是一个请求作用域，大多数情况下这就是你需要使用的。这里我们使用的是`Flash`作用域，所以它只会在那个特定的请求期间退出。这个功能用于传递**国际化消息**（**i18n**），这是动作的结果。所有i18n消息都需要在`ReactiveWebStore/conf/messages`中定义，如下所示：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Lastly, we have the remove method. First of all, we need to make sure the product
    exists, so we do a `findById` using `IProductService`, and then we apply a map
    function. If the product doesn't exist, the Play framework has prebuilt HTTP error
    code messages like `NotFound`. If the product exists, we remove it using `IProductService`,
    and then we redirect to the UI with a flashing message. Now let's see the image
    and review controllers.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有删除方法。首先，我们需要确保产品存在，所以我们使用`IProductService`进行`findById`，然后我们应用一个映射函数。如果产品不存在，Play框架有预构建的HTTP错误代码消息，如`NotFound`。如果产品存在，我们使用`IProductService`删除它，然后我们通过带有闪烁信息的UI进行重定向。现在让我们看看图像和审查控制器。
- en: 'The review controller, `ReviewController.scala`, is as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 审查控制器，`ReviewController.scala`，如下所示：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The review controller follows the same ideas and structure as the product controller.
    The only main difference is that here we need to Inject `IProductService`, because
    a review needs to belong to a product. Then we need to use `IProductService` in
    order to `findAllProduct`, because in the review view, we will have `SelectBox`
    with all the available products.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 审查控制器遵循与产品控制器相同的思想和结构。唯一的区别是，这里我们需要注入`IProductService`，因为一个审查需要属于一个产品。然后我们需要使用`IProductService`来执行`findAllProduct`，因为在审查视图中，我们将有一个包含所有可用产品的`SelectBox`。
- en: 'The image controller, `ImageController.scala`, is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图像控制器，`ImageController.scala`，如下所示：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Image review works in a similar way to `ReviewController`. We need `IProductService`
    to get all the services.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图像审查与`ReviewController`类似工作。我们需要`IProductService`来获取所有服务。
- en: Working with services
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与服务一起工作
- en: Services are where we put the business logic. We will look at reactive persistence
    in [Chapter 6](part0071.xhtml#aid-23MNU1 "Chapter 6.  Persistence with Slick"),
    *Persistence with Slick*. Right now, we don't have a database to persist information,
    so, for now, we will do an in-memory persistence.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是我们放置业务逻辑的地方。我们将在[第6章](part0071.xhtml#aid-23MNU1 "第6章。使用Slick的持久化")中查看反应式持久化，*使用Slick的持久化*。目前，我们没有数据库来持久化信息，所以，现在我们将进行内存持久化。
- en: 'First we will define the contract of our services. This is the Base API that
    we will use in the controllers. Let''s take a look at the following trait in `BaseService.scala`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义我们服务的契约。这是我们将在控制器中使用的基本API。让我们看看`BaseService.scala`中的以下特质：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, we have an in-memory mutable `HashMap`, which is in our
    memory database where we will store products, images, and reviews. We also have
    an atomic counter with which we can generate IDs for our models. This is a trait
    using Generics--as you can see, here we have all the operations with `A`, which
    will be specified later. Now we can move the service implementation for product,
    review, and image.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有一个内存中的可变 `HashMap`，这是我们内存数据库的一部分，我们将在这里存储产品、图片和评论。我们还有一个原子计数器，我们可以用它为我们的模型生成ID。这是一个使用泛型的特质--正如你所见，这里我们有所有与
    `A` 相关的操作，这些将在稍后指定。现在我们可以移动产品、评论和图片的服务实现。
- en: 'The `ProductService.scala` package is as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductService.scala` 包如下所示：'
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the last code, we defined a trait called `IProductService`, which extends
    `BaseService` with a generic apply to product. The `ProductService` package implements
    `IProductService`. In Scala, we can have multiple classes in the same Scala file,
    so there is no need to create different files.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后的代码中，我们定义了一个名为 `IProductService` 的特质，它通过泛型应用到产品上扩展了 `BaseService`。`ProductService`
    包实现了 `IProductService`。在 Scala 中，我们可以在同一个 Scala 文件中有多个类，因此不需要创建不同的文件。
- en: 'The code is very straightforward. There is a utility method here called `findAllProducts`,
    which is used by review and image controllers. Here we get all the elements on
    the in-memory hash map. If there are no elements, we return a list with empty
    product. Then we map the list to a `Seq` of tuple, which is required by the `SelectBox`
    checkbox that we will have in the view(UI). Now let''s go for the image and review
    services  as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 代码非常直接。这里有一个名为 `findAllProducts` 的实用方法，它被评论和图像控制器使用。我们在这里获取内存哈希表上的所有元素。如果没有元素，我们返回一个空产品的列表。然后我们将列表映射到一个元组
    `Seq` 上，这是我们在视图（UI）中将要拥有的 `SelectBox` 复选框所必需的。现在让我们继续图像和评论服务，如下所示：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding code, we have something pretty similar to that of `ProductService`.
    We have a trait called `IImageService` and the `ImageService` implementation.
    Now let''s go for the review service implementation in `ReviewService.scala`as
    follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有与 `ProductService` 类似的东西。我们有一个名为 `IImageService` 的特质和 `ImageService`
    实现。现在让我们在 `ReviewService.scala` 中实现评论服务，如下所示：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, we have the `IReviewService` trait and the `ReviewService`
    implementation. We have validations on the service as well as a good practice.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有 `IReviewService` 特质和 `ReviewService` 实现。我们在服务上也有验证和良好的实践。
- en: Configuring the Guice module
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Guice 模块
- en: We injected classes using `@Inject` in our controllers. The injection happens
    based on a trait; we need to define a concrete implementation for the traits we
    injected. The Play framework looks for Guice injections at the location `ReactiveWebStore/app/Module.scala`.
    Okay, so let's define our injections for the three controllers we just created.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在控制器中使用了 `@Inject` 注入类。注入是基于特质的；我们需要为注入的特质定义一个具体的实现。Play 框架在 `ReactiveWebStore/app/Module.scala`
    位置寻找 Guice 注入。好的，那么让我们定义我们为刚刚创建的三个控制器创建的注入。
- en: 'The Guice module is found in `Module.scala`as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Guice 模块在 `Module.scala` 中如下所示：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'So we just need to add `bind` with our traits for the controllers, and then
    point to the controller implementation. They should also be created as singletons,
    as the Play framework starts our application. Here you also can define any other
    configuration or injection that our application may need. The last code defines
    three services: product service, `IReviewService`, and `IImageService`.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们只需要为控制器添加 `bind` 与我们的特质，然后指向控制器实现。它们也应该被创建为单例，因为 Play 框架启动我们的应用程序。在这里，你也可以定义任何其他我们的应用程序可能需要的配置或注入。最后的代码定义了三个服务：产品服务、`IReviewService`
    和 `IImageService`。
- en: Working with views(UI)
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与视图（UI）一起工作
- en: The Play framework works with a Scala-based templating engine called Twirl.
    Twirl was inspired by ASP.NET Razor. Twirl is compact and expressive; you will
    see we can do more with less. Twirl template files are simple text files, however,
    the Play framework compiles the templates and turns them into Scala classes. You
    can mix HTML with Scala smoothly in Twirl.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Play 框架与一个基于 Scala 的模板引擎 Twirl 一起工作。Twirl 是由 ASP.NET Razor 启发的。Twirl 紧凑且表达性强；你会发现我们可以用更少的代码做更多的事情。Twirl
    模板文件是简单的文本文件，然而，Play 框架会编译这些模板并将它们转换为 Scala 类。你可以在 Twirl 中无缝地混合 HTML 和 Scala。
- en: The UI will be compiled into a Scala class, that can and will be referenced
    at our controllers, because we can route to a view. The nice thing about it is
    that this makes our coding way safer, since we have the compiler checking for
    us. The bad news is that you need to compile your UI, otherwise, your controllers
    won't find it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: UI将被编译成一个Scala类，这个类可以在我们的控制器中被引用，因为我们可以在视图中进行路由。它的好处是这使得我们的编码方式更安全，因为编译器会为我们进行检查。坏消息是，你需要编译你的UI，否则你的控制器将找不到它。
- en: 'Previously in this chapter, we defined controllers for products, images, and
    reviews, and we wrote the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我们为产品、图片和评论定义了控制器，并编写了以下代码：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With the preceding code, we redirect the user to a blank page for products
    so that the user can create a new product. We also can pass parameters to the
    UI. Since it is all Scala code, you are actually just calling a function as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的代码，我们将用户重定向到一个空白的产品页面，以便用户可以创建新产品。我们还可以将参数传递给UI。由于它全部是Scala代码，你实际上只是在调用一个函数，如下所示：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, we call the service to retrieve a product by ID, and
    then pass the object to the UI with the form being filled.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们调用服务通过ID检索产品，然后将对象传递给UI，并填写表单。
- en: 'Let''s continue building our application and create the UI for the products,
    reviews, and images. Since we are doing a CRUD, we will need more than one template
    file per CRUD. We will need the following structure:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续构建我们的应用程序，并为产品、评论和图片创建UI。由于我们正在进行CRUD操作，每个CRUD将需要多个模板文件。我们需要以下结构：
- en: Index Template
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引模板
- en: List all items
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出所有项目
- en: Link to edit one item
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接编辑单个项目
- en: Link to remove one item
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除单个项目的链接
- en: Link to create a new Item
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新项目的链接
- en: Detail Template
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细模板
- en: HTML Form to create a new Item
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于创建新项目的HTML表单
- en: HTML form to edit an existing item(for update)
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于编辑现有项目（更新）的HTML表单
- en: 'Having said that, we will have the following files:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这里，我们将有以下文件：
- en: 'For Products:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于产品：
- en: product_index.scala.html
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: product_index.scala.html
- en: product_details.scala.html
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: product_details.scala.html
- en: 'For Image:'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于图片：
- en: image_index.scala.html
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: image_index.scala.html
- en: image_details.scala.html
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: image_details.scala.html
- en: 'For Reviews:'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于评论：
- en: review_index.scala.html
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: review_index.scala.html
- en: review_details.scala.html
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: review_details.scala.html
- en: 'For the sake of code reuse, we will create another file containing the basic
    structure of our UI, like CSS imports (CSS needs to be located at `ReactiveWebStore\public\stylesheets`),
    JavaScript imports, and page title so that we don''t need to repeat that in all
    the templates for each CRUD. This page will be called: `main.scala.html`.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了代码复用，我们将创建另一个文件，包含我们UI的基本结构，例如CSS导入（CSS需要位于`ReactiveWebStore\public\stylesheets`），JavaScript导入，以及页面标题，这样我们就不需要在每个CRUD的模板中重复这些内容。这个页面将被称为：`main.scala.html`。
- en: All the UI code should be located at `ReactiveWebStore/app/views`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的UI代码都应该位于`ReactiveWebStore/app/views`。
- en: 'The main Scala with the UI index for all CRUD operations is in `main.scala.html`,
    as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 包含所有CRUD操作的UI索引的主Scala代码在`main.scala.html`中，如下所示：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding code, first of all, there is the following line at the very
    top:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先在最顶部有如下一行：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This means that we define the parameters this UI can receive. Here we expect
    a string title, which will be the page title, and there are some currying variables
    as well. You can get more details about currying in [Chapter 1](part0015.xhtml#aid-E9OE1
    "Chapter 1. Introduction to FP, Reactive, and Scala"), *Introduction to FP, Reactive,
    and Scala*. So in currying, there are two things: First is HTML, which means you
    can pass HTML code to this function, and second, we have `Flash` which the Play
    framework will pass for us. `Flash` is used to get parameters between requests.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们定义了此UI可以接收的参数。这里我们期望一个字符串标题，它将是页面标题，还有一些currying变量。你可以在[第1章](part0015.xhtml#aid-E9OE1
    "第1章。FP、响应式和Scala简介")中了解更多关于currying的细节，*FP、响应式和Scala简介*。所以在currying中，有两件事：第一是HTML，这意味着你可以将HTML代码传递给这个函数，第二，我们有`Flash`，Play框架会为我们传递。`Flash`用于获取请求之间的参数。
- en: As you can see, later in the code we have `@title`, which means we retrieve
    the title of the parameters, and add the value to the HTML. We also print any
    error message or any validations issues, if present, with `@alert`. We import
    JQuery and Twitter Bootstrap, but we do not put hard-coded paths. Instead, we
    use the routers like `@routes.Assets.at`. The Javascripts still need to be located
    at `ReactiveWebStore\public\javascripts`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在代码的后面我们有`@title`，这意味着我们检索参数的标题，并将其添加到HTML中。我们还使用`@alert`打印任何错误消息或验证问题，如果有的话。我们导入JQuery和Twitter
    Bootstrap，但我们不使用硬编码的路径。相反，我们使用路由器如`@routes.Assets.at`。JavaScript仍然需要位于`ReactiveWebStore\public\javascripts`。
- en: Now other templates can work with `@main(..),` and they don't need any declaration
    of Javascript or CSS. They can add an extra HTML code, which will be rendered
    on the previous code by `@content`. So, for the products, the content will be
    HTML product content, and so on for reviews, and images. Now we can move for the
    products UI.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在其他模板可以使用`@main(..)`，并且它们不需要任何JavaScript或CSS的声明。它们可以添加额外的HTML代码，这些代码将通过`@content`在之前的代码上渲染。因此，对于产品，内容将是HTML产品内容，对于评论和图片也是如此。现在我们可以转向产品的UI。
- en: 'Product index: ­ UI index for products `product_index.scala.html`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 产品索引：产品的UI索引`product_index.scala.html`
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As you can see, there is HTML mixed with Scala code. Every time you need to
    run HTML, you just run it, and when you need run Scala code, you need use a special
    character, `@`. At the very top of the template, you can see the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Scala代码中混合了HTML。每次需要运行HTML时，只需运行它，需要运行Scala代码时，需要使用特殊字符`@`。在模板的顶部，您可以看到以下代码：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Since this is Scala code in the end, and will be compiled, we need to define
    what parameters this UI template can receive. Here we expect a sequence of products.
    There is also a currying implicit variable called `Flash`, which will be provided
    by the Play framework, and we will use it for the message display. We also have
    the code-`@main("Products") { .. }`. This means that we call the main Scala template
    and add extra HTML--the product HTML. For this product UI, we list all the products
    based on the sequence of products. As you can see, we define an HTML table. We
    also validate if the sequence is not empty before listing all the products.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是最终的Scala代码，并且将被编译，我们需要定义这个UI模板可以接收哪些参数。在这里，我们期望一个产品序列。还有一个名为`Flash`的currying隐式变量，它将由Play框架提供，我们将用它来显示消息。我们还有代码`@main("Products")
    { .. }`。这意味着我们调用主Scala模板并添加额外的HTML——产品HTML。对于这个产品UI，我们根据产品序列列出所有产品。如您所见，我们定义了一个HTML表格。在列出所有产品之前，我们还验证序列是否为空。
- en: 'Now we can go for the details page for products in `product_details.scala.html` as
    follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以进入`product_details.scala.html`中的产品详情页面，如下所示：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For this preceding UI, at the very top, we have the following line:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个先前的UI，在最顶部，我们有以下一行：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This means that we expect an ID which is completely optional. This ID is used
    to know if we are dealing with an insert scenario or an update scenario, because
    we use the same UI for both insert and update. We also get the product form, which
    will be passed through `ProductController`, and we receive `Flash`, which will
    be provided by the Play framework.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们期望一个完全可选的ID。这个ID用于知道我们是在处理插入场景还是更新场景，因为我们使用相同的UI来处理插入和更新。我们还获取产品表单，它将通过`ProductController`传递，并且我们接收`Flash`，它将由Play框架提供。
- en: 'We need to do some imports on the UI so that we can get access to the Play
    framework i18n support. This is done by the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在UI上进行一些导入，以便我们可以访问Play框架的i18n支持。这是通过以下方式完成的：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Like the previous UI, we render this UI within the main Scala UI. So we don''t
    need to specify JavaScript and CSS again. This is done by the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的UI一样，我们在主Scala UI中渲染这个UI。因此，我们不需要再次指定JavaScript和CSS。这是通过以下代码完成的：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next we check if there are any validation errors. If there are, the users will
    need to fix the errors before moving on. This is done by the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查是否有任何验证错误。如果有，用户在继续之前需要修复这些错误。这是通过以下代码完成的：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now is the time to create the product form, which, in the end, will be mapped
    to HTML input boxes. We do this with the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是创建产品表单的时候了，最终它将被映射到HTML输入框。我们通过以下代码来完成：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`@helper.form` is a special helper provided by the Play framework to create
    HTML forms easily. So, the action is the target where the form will be submitted.
    We need to do an `if` here, since we need to know if it is an update or an insert.
    Then we map all the fields we have for our product model with this code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`@helper.form` 是 Play 框架提供的一个特殊助手，用于轻松创建 HTML 表单。因此，动作是表单将提交的目标。我们需要在这里做一次
    `if` 判断，因为我们需要知道这是一个更新还是一个插入。然后我们使用以下代码将我们的产品模型的所有字段映射到所有这些字段上：'
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Remember, the product form comes from the product controller. For the helper,
    we just need to tell it which product field is for which HTML label, and that's
    it. This will produce the following UIs.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，产品表单来自产品控制器。对于助手，我们只需要告诉它哪个产品字段对应哪个HTML标签，就这样。这将产生以下UI。
- en: 'The following image shows the blank product index UI:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了空的产品索引UI：
- en: '![Working with views(UI)](img/image00257.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![与视图（UI）一起工作](img/image00257.jpeg)'
- en: 'The insert UI form for product details looks as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 产品详情的插入UI表单如下所示：
- en: '![Working with views(UI)](img/image00258.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![与视图（UI）一起工作](img/image00258.jpeg)'
- en: 'With products added, the product index UI appears as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 添加产品后，产品索引UI如下所示：
- en: '![Working with views(UI)](img/image00259.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![与视图（UI）一起工作](img/image00259.jpeg)'
- en: Now we can move to reviews. Let's go for the UIs.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以转向审查部分。让我们看看UI。
- en: 'The review index UI in `review_index.scala.html` is as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`review_index.scala.html` 中的审查索引UI如下所示：'
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: So here we have the same things as we had for the products. Let's take a look
    at the details page for review now. You can find it in `review_details.scala.html`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里我们有与产品相同的东西。现在让我们看看审查的详情页面。您可以在 `review_details.scala.html` 中找到它。
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, in this last code, we have almost everything similar to what we had for
    products, however, there is one big difference. Review needs to be associated
    with a product ID. That's why, we need to have a select for the products, which
    is fulfilled by `products:Seq[(String,String)]`. This comes from the `ReviewController`
    code. This code produces the following UIs.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在这段最后的代码中，我们几乎拥有与产品相同的所有内容，然而，有一个很大的不同。审查需要与产品ID相关联。这就是为什么我们需要有一个产品选择框，它由
    `products:Seq[(String,String)]` 提供。这来自 `ReviewController` 代码。这段代码产生了以下UI。
- en: 'The blank review index UI is shown as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 空的审查索引UI如下所示：
- en: '![Working with views(UI)](img/image00260.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![与视图（UI）一起工作](img/image00260.jpeg)'
- en: 'The insert review details UI looks as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 插入审查详情UI如下所示：
- en: '![Working with views(UI)](img/image00261.jpeg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![与视图（UI）一起工作](img/image00261.jpeg)'
- en: 'The review index UI with reviews will look like the following image:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 带有审查的审查索引UI如下所示：
- en: '![Working with views(UI)](img/image00262.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![与视图（UI）一起工作](img/image00262.jpeg)'
- en: 'Now we can move to the last one: the image UI. The image UI is very similar
    to the review UI, because it depends on the product ID too. Let''s go for it.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以转向最后一个：图片UI。图片UI与审查UI非常相似，因为它也依赖于产品ID。让我们看看它。
- en: 'The image index UI has the following code in `image_index.scala.html`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图片索引UI在 `image_index.scala.html` 中的代码如下：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This UI template will create the following HTML Pages:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个UI模板将创建以下HTML页面：
- en: 'The blank image index UI is shown in the following image:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 空的图片索引UI如下所示：
- en: '![Working with views(UI)](img/image00263.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![与视图（UI）一起工作](img/image00263.jpeg)'
- en: 'The insert UI for image details looks as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图片详情的插入UI如下所示：
- en: '![Working with views(UI)](img/image00264.jpeg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![与视图（UI）一起工作](img/image00264.jpeg)'
- en: 'The following is the image index UI with items:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是有项的图片索引UI的图像：
- en: '![Working with views(UI)](img/image00265.jpeg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![与视图（UI）一起工作](img/image00265.jpeg)'
- en: Now we have a complete working UI application. There are controllers, models,
    views, and simple services as well. We also have all validations in place.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个完整的运行UI应用程序。这里有控制器、模型、视图，以及简单的服务。我们还有所有的验证。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to create controllers, models, services, views
    (using Twirl templating), Guice injections, and routing. We covered the principles
    of Scala Web Development using the Play framework. By the end of the chapter,
    we got the application with the Play framework up and running.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了如何创建控制器、模型、服务、视图（使用Twirl模板）、Guice注入和路由。我们使用了Play框架覆盖了Scala Web开发的原理。到本章结束时，我们得到了一个运行中的Play框架应用程序。
- en: In the next chapter, we will learn more about services. As you may realize,
    we did some simple services in this chapter for products, reviews, and images,
    but now we will continue working with services.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习更多关于服务的内容。正如你可能意识到的，在本章中我们已经为产品、评论和图片进行了一些简单的服务，但现在我们将继续与服务进行工作。
