- en: Session Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话管理
- en: This chapter discusses Spring Security's session management functionality. It
    starts off with an example of how Spring Security defends against session fixation.
    We will then discuss how concurrency control can be leveraged to restrict access
    to software licensed on a per-user basis. We will also see how session management
    can be leveraged for administrative functions. Last, we will explore how `HttpSession`
    is used in Spring Security and how we can control its creation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论Spring Security的会话管理功能。它从举例说明Spring Security如何防御会话固定开始。然后我们将讨论并发控制如何被利用来限制按用户许可的软件的访问。我们还将看到会话管理如何被利用进行管理功能。最后，我们将探讨`HttpSession`在Spring
    Security中的使用以及我们如何控制其创建。
- en: 'The following is a list of topics that will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在本章中将会讨论的主题列表：
- en: Session management/session fixation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话管理/会话固定
- en: Concurrency control
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发控制
- en: Managing logged in users
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理已登录用户
- en: How `HttpSession` is used in Spring Security and how to control creation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`HttpSession`在Spring Security中以及如何控制其创建
- en: How to use the `DebugFilter` class to discover where `HttpSession` was created
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`DebugFilter`类发现`HttpSession`的创建位置
- en: Configuring session fixation protection
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置会话固定保护
- en: 'As we are using the security namespace style of configuration, session fixation
    protection is already configured on our behalf. If we wanted to explicitly configure
    it to mirror the default settings, we would do the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们正在使用配置命名空间的风格，会话固定保护已经为我们配置好了。如果我们想要显式配置它以反映默认设置，我们会这样做：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Session fixation protection** is a feature of the framework that you most
    likely won''t even notice unless you try to act as a malicious user. We''ll show
    you how to simulate a session-stealing attack; before we do, it''s important to
    understand what session fixation does and the type of attack it prevents.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**会话固定保护**是框架的一个特性，除非你试图充当恶意用户，否则你很可能会注意到它。我们将向你展示如何模拟一个会话窃取攻击；在我们这样做之前，了解会话固定做什么以及它防止的攻击类型是很重要的。'
- en: Understanding session fixation attacks
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解会话固定攻击
- en: Session fixation is a type of attack whereby a malicious user attempts to steal
    the session of an unauthenticated user of your system. This can be done by using
    a variety of techniques that result in the attacker obtaining the unique session
    identifier of the user (for example, `JSESSIONID`). If the attacker creates a
    cookie or a URL parameter with the user's `JSESSIONID` identifier in it, they
    can access the user's session.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 会话固定是一种攻击方式，恶意用户试图窃取系统的未经验证用户的会话。这可以通过使用各种技术来完成，这些技术使攻击者获得用户的唯一会话标识（例如，`JSESSIONID`）。如果攻击者创建一个包含用户`JSESSIONID`标识的cookie或URL参数，他们就可以访问用户的会话。
- en: Although this is obviously a problem, typically, if a user is unauthenticated,
    they haven't entered any sensitive information. This becomes a more critical problem
    if the same session identifier continues to be used after a user has been authenticated.
    If the same identifier is used after authentication, the attacker may now gain
    access to the authenticated user's session without even having to know their username
    or password!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这显然是一个问题，但通常情况下，如果一个用户未经验证，他们还没有输入任何敏感信息。如果用户验证后仍然使用相同的会话标识，这个问题变得更加严重。如果验证后仍然使用相同的标识，攻击者可能现在甚至不需要知道用户的用户名或密码就能访问到验证用户的会话！
- en: At this point, you may scoff in disbelief and think this is extremely unlikely
    to happen in the real world. In fact, session-stealing attacks happen frequently.
    We would suggest that you spend some time reading the very informative articles
    and case studies on the subject, published by the **Open Web Application Security
    Project** (**OWASP**) organization ([http://www.owasp.org/](http://www.owasp.org/)).
    Specifically, you will want to read the OWASP top 10 lists. Attackers and malicious
    users are real, and they can do very real damage to your users, your application,
    or your company if you don't understand the techniques that they commonly use
    and know how to avoid them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你可能会不屑一顾，认为这在现实世界中极不可能发生。实际上，会话窃取攻击经常发生。我们建议你花些时间阅读一下由**开放网络应用安全项目**（**OWASP**）组织发布的关于这个主题的非常有益的文章和案例研究([http://www.owasp.org/](http://www.owasp.org/)）。特别是，你可能想要阅读OWASP
    top 10列表。攻击者和恶意用户是真实存在的，如果你不了解他们常用的技术，也不知道如何避免它们，他们可能会对你用户、应用程序或公司造成真正的损害。
- en: 'The following diagram illustrates how a session fixation attack works:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了会话固定攻击是如何工作的：
- en: '![](img/62110072-4014-450b-a589-12bea83aa974.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62110072-4014-450b-a589-12bea83aa974.png)'
- en: Now that we have seen how an attack like this works, we'll see what Spring Security
    can do to prevent it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了这种攻击是如何工作的，我们将看看Spring Security能做些什么来防止它。
- en: Preventing session fixation attacks with Spring Security
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Security预防会话固定攻击
- en: If we can prevent the same session that the user had prior to authentication
    from being used after authentication, we can effectively render the attacker's
    knowledge of the session ID useless. Spring Security session fixation protection
    solves this problem by explicitly creating a new session when a user is authenticated
    and invalidating their old session.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够防止用户在认证前拥有的相同会话在认证后被使用，我们就可以有效地使攻击者对会话ID的了解变得无用。Spring Security会话固定保护通过在用户认证时明确创建新会话并使他们的旧会话失效来解决此问题。
- en: 'Let''s take a look at the following diagram:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下以下的图表：
- en: '![](img/d3dc9885-dfc0-4b62-a3c8-433a59efde1e.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d3dc9885-dfc0-4b62-a3c8-433a59efde1e.png)'
- en: We can see that a new filter, `o.s.s.web.session.SessionManagementFilter`, is
    responsible for evaluating if a particular user is newly authenticated. If the
    user is newly authenticated, a configured `o.s.s.web.authentication.session.SessionAuthenticationStrategy`
    interface determines what to do. `o.s.s.web.authentication.session.SessionFixationProtectionStrategy`
    will create a new session (if the user already had one), and copy the contents
    of the existing session to the new one. That's pretty much it-seems simple. However,
    as we can see in the preceding diagram, it effectively prevents the malicious
    user from reusing the session ID after the unknown user is authenticated.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到一个新的过滤器`o.s.s.web.session.SessionManagementFilter`负责评估特定用户是否新认证。如果用户是新的认证，一个配置的`o.s.s.web.authentication.session.SessionAuthenticationStrategy`接口决定了要做什么。`o.s.s.web.authentication.session.SessionFixationProtectionStrategy`将创建一个新会话（如果用户已经有一个），并将现有会话的内容复制到新会话中。这就差不多结束了——看起来很简单。然而，正如我们之前看到的图表所示，它有效地阻止了恶意用户在未知用户认证后重新使用会话ID。
- en: Simulating a session fixation attack
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟会话固定攻击
- en: 'At this point, you may want to see what''s involved in simulating a session
    fixation attack:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你可能想了解模拟会话固定攻击涉及什么：
- en: You'll first need to disable session fixation protection in the `SecurityConfig.java`
    file by adding the `sessionManagement()` method as a child of the `http` element.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你首先需要在`SecurityConfig.java`文件中禁用会话固定保护，通过将`sessionManagement()`方法作为`http`元素的子项添加。
- en: You should start with the code from `chapter14.00-calendar`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该从`chapter14.00-calendar`的代码开始。
- en: 'Let''s take a look at the following code snippet:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下以下的代码片段：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Your code should now look like `chapter14.01-calendar`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码现在应该看起来像`chapter14.01-calendar`。
- en: Next, you'll need to open two browsers. We'll initiate the session in Google
    Chrome, steal it from there, and our attacker will log in using the stolen session
    in Firefox. We will use the Google Chrome and the Firefox web developer add-on
    in order to view and manipulate cookies. The Firefox web developer add-on can
    be downloaded from [https://addons.mozilla.org/en-US/firefox/addon/web-developer/](https://addons.mozilla.org/en-US/firefox/addon/web-developer/).
    Google Chrome's web developer tools are built-in.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你需要打开两个浏览器。我们将在Google Chrome中初始化会话，从中窃取它，然后我们的攻击者将在Firefox中使用窃取的会话登录。我们将使用Google
    Chrome和Firefox的Web开发者插件来查看和操作Cookie。Firefox的Web开发者插件可以从[https://addons.mozilla.org/en-US/firefox/addon/web-developer/](https://addons.mozilla.org/en-US/firefox/addon/web-developer/)下载。Google
    Chrome的Web开发者工具是内置的。
- en: Open the JBCP calendar home page in Google Chrome.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Google Chrome中打开JBCP日历主页。
- en: 'Next, from the main menu, navigate to Edit | Preferences | Under the Hood.
    In the Privacy category, press the Content Settings... button. Next, in Cookies
    Settings, press the All Cookies and Site Data... button. Finally, enter `localhost`
    into the Search field, as follows:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从主菜单中，导航到编辑 | 首选项 | 底层设置。在隐私类别下，点击内容设置...按钮。接下来，在Cookie设置中，点击所有Cookie和站点数据...按钮。最后，在搜索框中输入`localhost`，如下所示：
- en: '![](img/ab82311f-9925-4cfb-a44e-9a37668d2ce5.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab82311f-9925-4cfb-a44e-9a37668d2ce5.png)'
- en: Select the `JSESSIONID` cookie, copy the value of Content to the clipboard,
    and log in to the JBCP calendar application. If you repeat the View Cookie Information
    command, you'll see that `JSESSIONID` did not change after you logged in, making
    you vulnerable to a session fixation attack!
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `JSESSIONID` cookie，将内容值复制到剪贴板，并登录 JBCP 日历应用程序。如果您重复查看 Cookie 信息命令，您会发现您登录后
    `JSESSIONID` 没有改变，使您容易受到会话固定攻击！
- en: In Firefox, open the JBCP calendar website. You will have been assigned a session
    cookie, which you can view by using *Ctrl* + *F2* to open the bottom Cookie console.
    Then type in `cookie list [enter]` to bring up cookies for the current page.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Firefox 中，打开 JBCP 日历网站。您会被分配一个会话 cookie，您可以通过按 *Ctrl* + *F2* 打开底部的 Cookie
    控制台来查看，然后输入 `cookie list [enter]` 以显示当前页面的 cookie。
- en: 'To complete our hack, we''ll click on the Edit Cookie option and paste in the
    `JSESSIONID` cookie that we copied to the clipboard from Google Chrome, as shown
    in the following screenshot:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成我们的黑客攻击，我们将点击编辑 Cookie 选项，并粘贴我们从 Google Chrome 复制到剪贴板的 `JSESSIONID` cookie，如下图所示：
- en: '![](img/f6a22fcb-2b58-4f24-803c-a0c306aae717.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6a22fcb-2b58-4f24-803c-a0c306aae717.png)'
- en: Keep in mind that newer versions of Firefox include web developer tools, too.
    However, you will need to ensure that you are using the extension and not the
    built-in one, as it provides additional capabilities.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请记住，最新版本的 Firefox 也包括网络开发者工具。但是，您需要确保您使用的是扩展程序，而不是内置的，因为它提供了额外的功能。
- en: Our session fixation hack is complete! If you now reload the page in Firefox,
    you will see that you are logged in as the same user who was logged in using Google
    Chrome, but without the knowledge of the username and password. Are you scared
    of malicious users yet?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的会话固定黑客攻击完成了！如果您现在在 Firefox 中重新加载页面，您将看到您以使用 Google Chrome 登录的同一用户身份登录，但不知道用户名和密码。您担心恶意用户了吗？
- en: Now, re-enable session fixation protection and try this exercise again. You'll
    see that, in this case, the `JSESSIONID` changes after the user logs in. Based
    on our understanding of how session fixation attacks occur, this means that we
    have reduced the likelihood of an unsuspecting user falling victim to this type
    of attack. Excellent job!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新启用会话固定保护并再次尝试此练习。您将看到，在这种情况下，用户登录后 `JSESSIONID` 发生了变化。根据我们对会话固定攻击发生方式的理解，这意味着我们已将不知情的用户成为这种攻击受害者的可能性降低。干得好！
- en: Cautious developers should note that there are many methods of stealing session
    cookies, some of which-such as XSS-may make even session fixation protected sites
    vulnerable. Please consult the OWASP site for additional resources on preventing
    these types of attacks.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 谨慎的开发人员应该注意，窃取会话 cookie 有很多方法，其中一些（如 XSS）可能会使即使启用了会话固定保护的网站也变得脆弱。请咨询 OWASP 网站，以获取有关预防这类攻击的额外资源。
- en: Comparing the session-fixation-protection options
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较会话固定保护选项
- en: 'The `session-fixation-protection` attribute has the following three options
    that allow you to alter its behavior, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`session-fixation-protection` 属性的以下三个选项允许您更改其行为，如下所示：'
- en: '| **Attribute value** | **Description** |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| **属性值** | **描述** |'
- en: '| `none()` | This option disables session fixation protection and (unless other
    `sessionManagement()` attributes are non-default) does not configure `SessionManagementFilter`.
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `none()` | 此选项禁用会话固定保护（除非其他 `sessionManagement()` 属性非默认），并且不配置 `SessionManagementFilter`。
    |'
- en: '| `migrateSession()` | When the user is authenticated and a new session is
    allocated, it ensures that all attributes of the old session are moved to the
    new session. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `migrateSession()` | 当用户认证并分配新会话时，确保将旧会话的所有属性移动到新会话。 |'
- en: '| `newSession()` | When the user is authenticated, a new session is created
    and no attributes from the old (unauthenticated) session will be migrated. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `newSession()` | 当用户认证成功后，将创建一个新会话，不会迁移旧会话（未认证）的任何属性。 |'
- en: In most cases, the default behavior of `migrateSession()` will be appropriate
    for sites that wish to retain important attributes of the user's session (such
    as click interest and shopping carts) after the user has been authenticated.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，`migrateSession()` 的默认行为对于希望在用户认证后保留用户会话重要属性（如点击兴趣和购物车）的网站将是适当的。
- en: Restricting the number of concurrent sessions per user
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制每个用户的并发会话数
- en: In the software industry, software is often sold on a per-user basis. This means
    that, as software developers, we have an interest in ensuring that only a single
    session per user exists, to combat the sharing of accounts. Spring Security's
    concurrent session control ensures that a single user cannot have more than a
    fixed number of active sessions simultaneously (typically one). Ensuring that
    this maximum limit is enforced involves several components working in tandem to
    accurately track changes in user session activity.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件行业，软件通常按用户数出售。这意味着，作为软件开发者，我们有兴趣确保每个用户只存在一个会话，以防止账户共享。Spring Security的并发会话控制确保单一用户不能同时拥有超过固定数量的活跃会话（通常是1个）。确保这个最大限制得到执行涉及几个组件协同工作，以准确追踪用户会话活动的变化。
- en: Let's configure the feature, review how it works, and then test it out!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们配置这个特性，回顾一下它如何工作，然后测试它！
- en: Configuring concurrent session control
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置并发会话控制
- en: 'Now that we have understood the different components involved in concurrent
    session control, setting it up should make much more sense. Let''s take a look
    at the following steps to configure concurrent session control:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经理解了并发会话控制中涉及的不同组件，那么设置它应该更有意义。让我们查看以下步骤来配置并发会话控制：
- en: 'Firstly, you update your `security.xml` file as follows:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你按照如下方式更新你的`security.xml`文件：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we need to enable `o.s.s.web.session.HttpSessionEventPublisher` in the
    `SecurityConfig.java` deployment descriptor, so that the servlet container will
    notify Spring Security (through `HttpSessionEventPublisher`) of session life cycle
    events, as follows:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在`SecurityConfig.java`部署描述符中启用`o.s.s.web.session.HttpSessionEventPublisher`，以便Servlet容器将通过`HttpSessionEventPublisher`通知Spring
    Security关于会话生命周期事件，如下所示：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With these two configuration bits in place, concurrent session control will
    now be activated. Let's see what it actually does, and then we'll demonstrate
    how it can be tested.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这两个配置项，并发会话控制现在将被激活。让我们看看它实际做了什么，然后我们将展示如何测试它。
- en: Understanding concurrent session control
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解并发会话控制
- en: Concurrent session control uses `o.s.s.core.session.SessionRegistry` to maintain
    a list of active HTTP sessions and the authenticated users with which they are
    associated. As sessions are created and expired, the registry is updated in real
    time based on the session life cycle events published by `HttpSessionEventPublisher`
    to track the number of active sessions per authenticated user.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 并发会话控制使用`o.s.s.core.session.SessionRegistry`来维护一个活跃HTTP会话列表以及与之关联的认证用户。当会话被创建和过期时，注册表会根据`HttpSessionEventPublisher`发布的会话生命周期事件实时更新，以跟踪每个认证用户的活跃会话数量。
- en: 'Refer to the following diagram:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下图表：
- en: '![](img/cd90434e-cc5a-4032-8764-fb2d1e4af99f.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd90434e-cc5a-4032-8764-fb2d1e4af99f.png)'
- en: An extension of `SessionAuthenticationStrategy`, `o.s.s.web.authentication.session.ConcurrentSessionControlStrategy`
    is the method by which new sessions are tracked and the method by which concurrency
    control is actually enforced. Each time a user accesses the secured site, `SessionManagementFilter`
    is used to check the active session against `SessionRegistry`. If the user's active
    session isn't in the list of active sessions tracked in `SessionRegistry`, the
    least recently used session is immediately expired.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`SessionAuthenticationStrategy`的扩展`o.s.s.web.authentication.session.ConcurrentSessionControlStrategy`是跟踪新会话和实施并发控制的方法。每当用户访问受保护的网站时，`SessionManagementFilter`用来检查活跃会话与`SessionRegistry`。如果用户的活跃会话不在`SessionRegistry`跟踪的活跃会话列表中，那么最不常使用的会话将被立即过期。'
- en: The secondary actor in the modified concurrent session control filter chain
    is `o.s.s.web.session.ConcurrentSessionFilter`. This filter will recognize expired
    sessions (typically, sessions that have been expired either by the servlet container
    or forcibly by the `ConcurrentSessionControlStrategy` interface) and notify the
    user that their session has expired.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的并发会话控制过滤器链中的第二个参与者是`o.s.s.web.session.ConcurrentSessionFilter`。此过滤器将识别已过期的会话（通常是已被Servlet容器过期或被`ConcurrentSessionControlStrategy`接口强制过期的会话）并通知用户他们的会话已过期。
- en: Now that we have understood how concurrent session control works, it should
    be easy for us to reproduce a scenario in which it is enforced.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经理解了并发会话控制是如何工作的，那么复现一个实施该控制的情景应该对我们来说很容易。
- en: Your code should now look like `chapter14.02-calendar`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码现在应该看起来像`chapter14.02-calendar`。
- en: Testing concurrent session control
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试并发会话控制
- en: 'As we did when verifying session fixation protection, we will need to access
    two web browsers by performing the following steps:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在验证会话固定保护时所做的那样，我们需要通过执行以下步骤来访问两个网络浏览器：
- en: In Google Chrome, log in to the site as `user1@example.com/user1`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Google Chrome中，以`user1@example.com/user1`的身份登录网站。
- en: Now, in Firefox, log in to the site as the same user.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在Firefox中，以同一用户身份登录网站。
- en: 'Finally, go back to Google Chrome and take any action. You will see a message
    indicating that your session has expired, as shown in the following screenshot:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，回到Google Chrome中执行任何操作。你会看到一个指示你的会话已过期的消息，如下面的屏幕截图所示：
- en: '![](img/f71d8539-cbd5-446c-802c-4ca17abcd3f2.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f71d8539-cbd5-446c-802c-4ca17abcd3f2.png)'
- en: If you were using this application and received this message, you'd probably
    be confused. This is because it's obviously not a friendly method of being notified
    that only a single user can access the application at a time. However, it does
    illustrate that the session has been forcibly expired by the software.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在使用这个应用程序时收到这条消息，你可能会感到困惑。这是因为显然这并不是一种友好的方式，用来通知一次只能有一个用户访问应用程序。然而，它确实说明会话已被软件强制过期。
- en: Concurrent session control tends to be a very difficult concept for new Spring
    Security users to grasp. Many users try to implement it without truly understanding
    how it works and what the benefits are. If you're trying to enable this powerful
    feature, and it doesn't seem to be working as you expect, make sure you have everything
    configured correctly and then review the theoretical explanations in this section-hopefully,
    they will help you understand what may be wrong!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 并发会话控制对于新接触Spring Security的用户来说通常是一个很难理解的概念。许多用户试图在不真正理解它如何工作以及它的好处的情况下实现它。如果你正在尝试启用这个强大的功能，但它似乎并没有像你期望的那样工作，请确保你已经正确配置了所有内容，然后回顾本节中的理论解释-希望它们能帮助你理解可能出错了什么！
- en: When a session expiration event occurs, we should probably redirect the user
    to the login page and provide them with a message to indicate what went wrong.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当会话过期事件发生时，我们可能需要将用户重定向到登录页面，并给他们一个消息来指出出了什么问题。
- en: Configuring expired session redirect
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置过期会话重定向
- en: 'Fortunately, there is a simple method for directing users to a friendly page
    (typically the login page) when they are flagged by concurrent session control-simply
    specify the `expired-url` attribute and set it to a valid page in your application.
    Update your `security.xml` file as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个简单的方法可以将用户重定向到一个友好的页面（通常是登录页面），当他们在并发会话控制中被标记时-只需指定`expired-url`属性，并将其设置为应用程序中的有效页面。如下更新你的`security.xml`文件：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the case of our application, this will redirect the user to the standard
    login form. We will then use the query parameter to display a friendly message
    indicating that we determined that they had multiple active sessions, and should
    log in again. Update your `login.html` page to use this parameter to display our
    message:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序的情况下，这将把用户重定向到标准的登录表单。然后我们将使用查询参数来显示一个友好的消息，表明我们确定他们有多个活动会话，应该重新登录。更新你的`login.html`页面，使用此参数来显示我们的消息：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Go ahead and give it a try by logging in as the user `admin1@example.com`/`admin1`
    using both Google Chrome and Firefox. This time, you should see a login page with
    a custom error message.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后尝试通过在Google Chrome和Firefox中分别以`admin1@example.com`/`admin1`的身份登录用户。这次，你应该会看到一个带有自定义错误消息的登录页面。
- en: Your code should now look like `chapter14.03-calendar`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码现在应该看起来像`chapter14.03-calendar`。
- en: Common problems with concurrency control
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发控制常见问题
- en: There are a few common reasons that logging in with the same user does not trigger
    a logout event. The first occurs when using custom `UserDetails` (as we did in
    [Chapter 3](03.html), *Custom Authentication*) while the equals and `hashCode`
    methods are not properly implemented. This occurs because the default `SessionRegistry`
    implementation uses an in-memory map to store `UserDetails`. In order to resolve
    this, you must ensure that you have properly implemented the `hashCode` and equals
    methods.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 登录同一用户时不会触发登出事件的原因有几个。第一个原因是在使用自定义`UserDetails`（如我们在[第3章](03.html)，*自定义认证*中做的那样）时，而`equals`和`hashCode`方法没有得到正确实现。这是因为默认的`SessionRegistry`实现使用内存映射来存储`UserDetails`。为了解决这个问题，你必须确保你已经正确实现了`hashCode`和equals方法。
- en: The second problem occurs when restarting the application container while the
    user sessions are persisted to a disk. When the container has started back up,
    the users who were already logged in with a valid session are logged in. However,
    the in-memory map of `SessionRegistry` that is used to determine if the user is
    already logged in will be empty. This means that Spring Security will report that
    the user is not logged in, even though the user is. To solve this problem, either
    a custom `SessionRegistry` is required along with disabling session persistence
    within the container, or you must implement a container-specific way to ensure
    that the persisted sessions get populated into the in-memory map at startup.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题发生在重启应用程序容器时，而用户会话被持久化到磁盘上。当容器重新启动后，已经使用有效会话登录的用户将登录。然而，用于确定用户是否已经登录的`SessionRegistry`内存映射将会是空的。这意味着Spring
    Security会报告用户没有登录，尽管用户实际上已经登录了。为了解决这个问题，需要一个自定义的`SessionRegistry`，同时禁用容器内的会话持久化，或者你必须实现一个特定于容器的解决方案，以确保在启动时将持久化的会话填充到内存映射中。
- en: 'Yet another reason is that at the time of writing, concurrency control is not
    implemented for the remember-me feature. If users are authenticated with remember-me,
    that concurrency control is not enforced. There is a JIRA to implement this feature,
    so refer to it for any updates if your application requires both remember-me and
    concurrency control: [https://jira.springsource.org/browse/SEC-2028](https://jira.springsource.org/browse/SEC-2028)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因是，在撰写本文时，对于记住我功能还没有实现并发控制。如果用户使用记住我功能进行身份验证，那么这种并发控制将不会被强制执行。有一个JIRA问题是用来实现这个功能的，如果你的应用程序需要记住我功能和并发控制，那么请参考它以获取任何更新：[https://jira.springsource.org/browse/SEC-2028](https://jira.springsource.org/browse/SEC-2028)。
- en: The last common reason we will cover is that concurrency control will not work
    in a clustered environment with the default `SessionRegistry` implementation.
    As mentioned previously, the default implementation uses an in-memory map. This
    means that if `user1` logs in to application server A, the fact that they are
    logged in will be associated with that server. Thus, if `user1` then authenticates
    to Application Server B, the previously associated authentication will be unknown
    to application server B.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的最后一个常见原因是，在默认的`SessionRegistry`实现下，并发控制在集群环境中将无法工作。如前所述，默认实现使用一个内存映射。这意味着如果`user1`登录到应用程序服务器A，他们登录的事实将与该服务器相关联。因此，如果`user1`然后认证到应用程序服务器B，之前关联的认证对应用程序服务器B来说是未知的。
- en: Preventing authentication instead of forcing logout
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阻止认证，而不是强制登出
- en: 'Spring Security can also prevent a user from being able to log in to the application
    if the user already has a session. This means that instead of forcing the original
    user to be logged out, Spring Security will prevent the second user from being
    able to log in. The configuration changes can be seen as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security还可以阻止用户如果已经有一个会话的情况下登录到应用程序。这意味着，Spring Security不是强制原始用户登出，而是阻止第二个用户登录。配置更改如下所示：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Make the updates and log in to the calendar application with Google Chrome.
    Now, attempt to log in to the calendar application with Firefox using the same
    user. You should see our custom error message from our `login.html` file.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 进行更新后，使用Google Chrome登录日历应用程序。现在，尝试使用相同的用户名尝试使用Firefox登录日历应用程序。你应该会看到我们自定义的错误信息，来自我们的`login.html`文件。
- en: Your code should now look like `chapter14.04-calendar`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码现在应该看起来像`chapter14.04-calendar`。
- en: There is a disadvantage to this approach that may not be apparent without some
    thought. Try closing Google Chrome without logging out and then opening it up
    again. Now, attempt to log in to the application again. You will observe that
    you are unable to log in. This is because when the browser is closed, the `JSESSIONID`
    cookie is deleted. However, the application is not aware of this, so the user
    is still considered authenticated. You can think of this as a kind of memory leak,
    since `HttpSession` still exists but there is no pointer to it (the `JSESSIONID`
    cookie is gone). It is not until the session times out that our user will be able
    to authenticate again. Thankfully, once the session times out, our `SessionEventPublisher`
    interface will remove the user from our `SessionRegistry` interface. What we can
    take away from this is that if a user forgets to log out and closes the browser,
    they will not be able to log in to the application until the session times out.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点可能不经过深思熟虑不容易看出。试着在不登出的情况下关闭Google Chrome，然后再次打开它。现在，尝试再次登录应用程序。你会观察到无法登录。这是因为当浏览器关闭时，`JSESSIONID`
    cookie 被删除。然而，应用程序并不知道这一点，所以用户仍然被认为是认证的。你可以把这看作是一种内存泄漏，因为`HttpSession`仍然存在，但是没有指向它（`JSESSIONID`
    cookie 已经消失了）。直到会话超时，我们的用户才能再次认证。幸运的是，一旦会话超时，我们的`SessionEventPublisher`接口将把用户从我们的`SessionRegistry`接口中移除。我们从这一点可以得出的结论是，如果用户忘记登出并关闭浏览器，他们将无法再次登录应用程序，直到会话超时。
- en: Just as in [Chapter 7](08.html), *Remember-Me Services*, this experiment may
    not work if the browser decides to remember a session even after the browser is
    closed. Typically, this will happen if a plugin or the browser is configured to
    restore sessions. In this event, you might want to delete the `JSESSIONID` cookie
    manually to simulate the browser being closed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在[第7章](08.html) *记住我服务* 中一样，这个实验如果浏览器在关闭后决定记住一个会话，可能就不会工作。通常，如果插件或浏览器被配置为恢复会话，这种情况会发生。在这种情况下，你可能想手动删除`JSESSIONID`
    cookie 来模拟浏览器被关闭。
- en: Other benefits of concurrent session control
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发会话控制的其他好处
- en: 'Another benefit of concurrent session control is that `SessionRegistry` exists
    to track active (and, optionally, expired) sessions. This means that we can get
    runtime information about what user activity exists in our system (for authenticated
    users, at least) by performing the following steps:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 并发会话控制的一个好处是`SessionRegistry`存在用以跟踪活动（可选地，已过期）会话。这意味着我们可以通过执行以下步骤来获取关于我们系统中的用户活动（至少是认证用户）的运行时信息：
- en: 'You can even do this if you don''t want to enable concurrent session control.
    Simply set `maximumSessions` to `-1`, and session tracking will remain enabled,
    even though no maximum will be enforced. Instead, we will use the explicit bean
    configuration provided in the `SessionConfig.java` file of this chapter, as follows:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 即使你不想启用并发会话控制，你也可以这样做。只需将`maximumSessions`设置为`-1`，会话跟踪将保持启用，尽管不会强制执行最大值。相反，我们将使用本章`SessionConfig.java`文件中提供的显式bean配置，如下所示：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We have already added the import of the `SessionConfig.java` file to the `SecurityConfig.java`
    file. So, all that we need to do is reference the custom configuration in our
    `SecurityConfig.java` file. Go ahead and replace the current `sessionManagement`
    and `maximumSessions` configurations with the following code snippet:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经将`SessionConfig.java`文件的导入添加到了`SecurityConfig.java`文件中。所以，我们只需要在我们的`SecurityConfig.java`文件中引用自定义配置。用以下代码片段替换当前的`sessionManagement`和`maximumSessions`配置：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Your code should now look like `chapter14.05-calendar`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码现在应该看起来像`chapter14.05-calendar`。
- en: Now, our application will allow an unlimited number of authentications for the
    same user. However, we can use `SessionRegistry` to forcibly log out the users.
    Let's see how we can use this information to enhance the security of our users.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用程序将允许同一用户进行无限次数的认证。然而，我们可以使用`SessionRegistry`强制登出用户。让我们看看如何使用这些信息来增强我们用户的安全性。
- en: Displaying active sessions for a user
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为用户显示活动会话
- en: 'You''ve probably seen how many websites allow a user to view and forcibly log
    out sessions for their account. We can easily use this forcible logout functionality
    to do the same. We have already provided `UserSessionController`, which obtains
    the active sessions for the currently logged in user. You can see the implementation
    as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经看到过许多网站允许用户查看和强制登出他们账户的会话。我们可以很容易地利用这个强制登出功能来完成同样的操作。我们已经提供了`UserSessionController`，它获取当前登录用户的活动会话。你可以看到实现如下：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Our sessions method will use Spring MVC to automatically obtain the current
    Spring Security `Authentication`. If we were not using Spring MVC, we could also
    get the current `Authentication` from `SecurityContextHolder`, as discussed in
    [Chapter 3](03.html), *Custom Authentication*. The principal is then used to obtain
    all the `SessionInformation` objects for the current user. The information is
    easily displayed by iterating over the `SessionInformation` objects in our `sessions.html`
    file, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的会话方法将使用Spring MVC自动获取当前的Spring Security `Authentication`。如果我们没有使用Spring MVC，我们也可以从`SecurityContextHolder`获取当前的`Authentication`，如在第[3章](03.html)中*自定义认证*所讨论的。然后使用主体来获取当前用户的所有`SessionInformation`对象。通过遍历我们`sessions.html`文件中的`SessionInformation`对象，如下所示，轻松显示信息：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can now safely start the JBCP calendar application and log in to it using
    `user1@example.com`/`user1` in Google Chrome. Now, log in using Firefox and click
    on the `user1@example.com` link in the upper-right corner. You will then see both
    sessions listed on the display as shown in the following screenshot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以安全地启动JBCP日历应用程序，并使用`user1@example.com`/`user1`在Google Chrome中登录。然后，使用Firefox登录，并点击右上角的`user1@example.com`链接。接下来，您将在显示上看到两个会话列表，如下面的屏幕截图所示：
- en: '![](img/95fdedc1-34b3-4227-904f-11c392939ffb.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/95fdedc1-34b3-4227-904f-11c392939ffb.png)'
- en: While in Firefox, click on the Delete button for the first session. This sends
    the request to our `deleteSession` method of `UserSessionsController`. This indicates
    that the session should be terminated. Now, navigate to any page within Google
    Chrome. You will see the custom message saying the session has been forcibly terminated.
    While the message could use updating, we see that this is a nice feature for users
    to terminate other active sessions.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在Firefox中，点击第一个会话的删除按钮。这会将请求发送到我们`UserSessionsController`的`deleteSession`方法。这表示会话应该被终止。现在，在Google
    Chrome内导航到任何页面。您将看到自定义消息，称会话已被强制终止。虽然消息可以更新，但我们看到这对于用户终止其他活动会话是一个很好的功能。
- en: Other possible uses include allowing an administrator to list and manage all
    active sessions, displaying the number of active users on the site, or even extending
    the information to include things like an IP address or location information.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可能的用途包括允许管理员列出和管理所有活动会话，显示网站上的活动用户数，甚至扩展信息以包括诸如IP地址或位置信息之类的内容。
- en: How Spring Security uses the HttpSession method?
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security如何使用HttpSession方法？
- en: 'We have already discussed how Spring Security uses `SecurityContextHolder`
    to determine the currently logged in user. However, we have not explained how
    `SecurityContextHolder` gets automatically populated by Spring Security. The secret
    to this lies in the `o.s.s.web.context.SecurityContextPersistenceFilter` filter
    and the `o.s.s.web.context.SecurityContextRepository` interface. Let''s take a
    look at the following diagram:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过Spring Security如何使用`SecurityContextHolder`来确定当前登录的用户。然而，我们还没有解释Spring
    Security是如何自动填充`SecurityContextHolder`的。这个秘密在于`o.s.s.web.context.SecurityContextPersistenceFilter`过滤器和`o.s.s.web.context.SecurityContextRepository`接口。让我们来看看下面的图表：
- en: '![](img/f242c0b7-dcdd-425a-916b-59dc18d70a0d.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f242c0b7-dcdd-425a-916b-59dc18d70a0d.png)'
- en: 'Here is an explanation for each step shown in the preceding diagram:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对前述图表中每个步骤的解释：
- en: At the beginning of each web request, `SecurityContextPersistenceFilter` is
    responsible for obtaining the current `SecurityContext` implementation using `SecurityContextRepository`.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每次网络请求的开始，`SecurityContextPersistenceFilter`负责通过`SecurityContextRepository`获取当前的`SecurityContext`实现。
- en: Immediately afterwards, it sets `SecurityContext` on `SecurityContextHolder`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 紧接着，它在`SecurityContextHolder`上设置了`SecurityContext`。
- en: For the remainder of the web request, `SecurityContext` is available via `SecurityContextHolder`.
    For example, if a Spring MVC controller or `CalendarService` wanted to access
    `SecurityContext`, it could use `SecurityContextHolder` to access it.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于随后的网络请求，`SecurityContext`可以通过`SecurityContextHolder`获得。例如，如果一个Spring MVC控制器或`CalendarService`想要访问`SecurityContext`，它可以通过`SecurityContextHolder`来访问。
- en: Then, at the end of each request, `SecurityContextPersistenceFilter` gets the
    `SecurityContext` from `SecurityContextHolder`.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在每个请求的末尾，`SecurityContextPersistenceFilter`从`SecurityContextHolder`中获取`SecurityContext`。
- en: Immediately afterwards, `SecurityContextPersistenceFilter` saves `SecurityContext`
    in `SecurityContextRepository`. This ensures that if `SecurityContext` is updated
    at any point during the web requests (that is, when a user creates a new account,
    as done in [Chapter 3](https://cdp.packtpub.com/spring_security__third_edition/wp-admin/post.php?post=42&action=edit),
    *Custom Authentication*) `SecurityContext` is saved.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 紧接着，`SecurityContextPersistenceFilter`在每次请求结束时将`SecurityContext`保存到`SecurityContextRepository`中。这确保了如果在web请求期间的任何时刻更新了`SecurityContext`（也就是说，如在[第3章](https://cdp.packtpub.com/spring_security__third_edition/wp-admin/post.php?post=42&action=edit)
    *自定义认证*中用户创建新账户时），`SecurityContext`会被保存。
- en: Lastly, `SecurityContextPersistenceFilter` clears `SecurityContextHolder`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`SecurityContextPersistenceFilter`清除了`SecurityContextHolder`。
- en: The question that now arises is how is this related to `HttpSession`? This is
    all tied together by the default `SecurityContextRepository` implementation, which
    uses `HttpSession`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在产生的问题是这与`HttpSession`有什么关系？这一切都是通过默认的`SecurityContextRepository`实现联系在一起的，该实现使用`HttpSession`。
- en: The HttpSessionSecurityContextRepository interface
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HttpSessionSecurityContextRepository接口
- en: The default implementation of `SecurityContextRepository`, `o.s.s.web.context.HttpSessionSecurityContextRepository`,
    uses `HttpSession` to retrieve and store the current `SecurityContext` implementation.
    There are no other `SecurityContextRepository` implementations provided out of
    the box. However, since the usage of `HttpSession` is abstracted behind the `SecurityContextRepository`
    interface, we could easily write our own implementation if we desired.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 默认实现的`SecurityContextRepository`，`o.s.s.web.context.HttpSessionSecurityContextRepository`，使用`HttpSession`来检索和存储当前的`SecurityContext`实现。并没有提供其他`SecurityContextRepository`的实现。然而，由于`HttpSession`的使用被`SecurityContextRepository`接口抽象了，如果我们愿意，可以很容易地编写自己的实现。
- en: Configuring how Spring Security uses HttpSession
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Spring Security如何使用HttpSession
- en: 'Spring Security has the ability to configure when the session is created by
    Spring Security. This can be done with the `http` element''s `create-session`
    attribute. A summary of the options can be seen in the following table:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security有能力配置何时由Spring Security创建会话。这可以通过`http`元素的`create-session`属性来完成。下面表格总结了选项的概要：
- en: '| **Attribute value** | **Description** |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| **属性值** | **描述** |'
- en: '| --- | --- |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ifRequired` | Spring Security will create a session only if one is required
    (default value). |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `ifRequired` | 如果需要（默认值），Spring Security将创建一个会话。 |'
- en: '| `always` | Spring Security will proactively create a session if one does
    not exist. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `always` | 如果不存在会话，Spring Security将主动创建一个会话。 |'
- en: '| `never` | Spring Security will never create a session, but will make use
    of one if the application does create it. This means if there is a `HttpSession`
    method, `SecurityContext` will be persisted or retrieve from it. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `never` | Spring Security永远不会创建会话，但如果应用程序创建了会话，它将利用该会话。这意味着如果存在`HttpSession`方法，`SecurityContext`将被持久化或从中检索。
    |'
- en: '| `stateless` | Spring Security will not create a session and will ignore the
    session for obtaining a Spring `Authentication`. In such instances, `NullSecurityContextRepository`
    is used, which will always state that the current `SecurityContext` is `null`.
    |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `stateless` | Spring Security不会创建会话，并将忽略会话以获取Spring `Authentication`。在这种情况下，总是使用`NullSecurityContextRepository`，它总是声明当前的`SecurityContext`为`null`。
    |'
- en: In practice, controlling session creation can be more difficult than it first
    appears. This is because the attributes only control a subset of Spring Security's
    usage of `HttpSession`. It does not apply to any other components, such as JSPs,
    in the application. To help figure out when the `HttpSession` method was created,
    we can add Spring Security's `DebugFilter`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，控制会话的创建可能比最初看起来要困难。这是因为属性只控制了Spring Security对`HttpSession`使用的一部分。它不适用于应用程序中的其他组件，比如JSP。为了帮助找出`HttpSession`方法是在何时创建的，我们可以在Spring
    Security中添加`DebugFilter`。
- en: Debugging with Spring Security's DebugFilter
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Security的DebugFilter进行调试
- en: 'Let''s take a look at the following steps and learn about how to debug with
    `DebugFilter` of Spring Security:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看以下步骤，学习如何使用Spring Security的`DebugFilter`进行调试：
- en: 'Update your `SecurityConfig.java` file to have a session policy of `NEVER`.
    Also, add the `debug` flag to `true` on the `@EnableWebSecurity` annotation, so
    that we can track when the session was created. The updates can be seen as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新你的`SecurityConfig.java`文件，使其会话策略为`NEVER`。同时，在`@EnableWebSecurity`注解上添加`debug`标志为`true`，这样我们就可以追踪会话是在何时创建的。更新如下所示：
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When you start up the application, you should see something similar to the
    following code written to standard output. If you have not already, ensure that
    you have logging enabled across all levels of the Spring Security debugger category:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动应用程序时，你应该会看到类似以下代码写入标准输出。如果你还没有做，确保你已经为Spring Security调试器类别启用日志记录：
- en: '[PRE13]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, clear out your cookies (this can be done in Firefox with *Shift* + *Ctrl*
    + *Delete*), start up the application, and navigate directly to `http://localhost:8080`.
    When we look at the cookies, as we did earlier in the chapter, we can see that
    `JSESSIONID` is created even though we stated that Spring Security should never
    create `HttpSession`. Look at the logs again, and you will see a call stack of
    the code that created `HttpSession` as follows:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，清除你的cookies（这可以在Firefox中通过*Shift* + *Ctrl* + *Delete*完成），启动应用程序，直接导航到`http://localhost:8080`。当我们像章节早期那样查看cookies时，我们可以看到尽管我们声明Spring
    Security不应该创建`HttpSession`，但`JSESSIONID`仍然被创建了。再次查看日志，你会看到创建`HttpSession`的代码调用栈如下：
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this instance, our JSP page is responsible for creating the new `HttpSession`
    method. In fact, all JSPs will create a new `HttpSession` method by default unless
    you include the following code at the top of each JSP:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个实例中，我们的JSP页面负责创建新的`HttpSession`方法。实际上，所有JSP默认都会创建新的`HttpSession`方法，除非你在每个JSP文件的顶部包含以下代码：
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There are a number of other uses for `DebugFilter`, which we encourage you to
    explore on your own, for example, determining when a request will match a particular
    URL, which Spring Security filters are being invoked, and so on.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`DebugFilter`还有许多其他用途，我们鼓励你自己去探索，例如，确定一个请求将匹配特定的URL，哪些Spring Security过滤器被调用等等。'
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: After reading this chapter, you should be familiar with how Spring Security
    manages sessions and protects against session fixation attacks. We also know how
    to use Spring Security's concurrency control to prevent the same user from being
    authenticated multiple times.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，你应该熟悉Spring Security如何管理会话以及如何防范会话固定攻击。我们也知道如何使用Spring Security的并发控制来防止同一个用户多次认证。
- en: We also explored the utilization of concurrency control to allow a user to terminate
    sessions associated with their account. Also, we saw how to configure Spring Security's
    creation of sessions. We also covered how to use Spring Security's `DebugFilter`
    filter to troubleshoot issues related to Spring.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探索了并发控制的使用，以允许用户终止与他们账户相关的会话。同时，我们看到了如何配置Spring Security的会话创建。我们还介绍了如何使用Spring
    Security的`DebugFilter`过滤器来解决与Spring相关的问题。
- en: We also learned about security, including determining when a `HttpSession` method
    was created and what caused it to be created.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了安全性，包括确定`HttpSession`方法何时被创建以及是什么原因导致了它的创建。
- en: This concludes our discussion about Spring Security's session management. In
    the next chapter, we will discuss some specifics about integrating Spring Security
    with other frameworks.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们关于Spring Security会话管理的讨论。在下一章，我们将讨论一些关于将Spring Security与其他框架集成的具体内容。
