- en: '*Chapter 2*: Where and How Does DDD Fit?'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：DDD在哪里和如何适用？'
- en: “We won’t be distracted by comparison if we are captivated with purpose.”
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “如果我们被目的所吸引，我们就不会被比较所分散。”
- en: – Bob Goff
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: ——鲍勃·戈夫
- en: Software architecture refers to the fundamental structures of a software system
    and the discipline of creating such structures and systems. Over the years, we
    have accumulated a series of architecture styles and programming paradigms to
    help us deal with system complexity.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构指的是软件系统的基本结构以及创建这些结构和系统的学科。多年来，我们积累了一系列架构风格和编程范式，以帮助我们处理系统复杂性。
- en: In this chapter, we will examine how **Domain-Driven Design** (**DDD**) can
    be applied in a manner that is complementary to these architecture styles and
    programming paradigms. We will also look at how/where it fits in the overall scheme
    of things when crafting a software solution.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何将**领域驱动设计（DDD**）应用于与这些架构风格和编程范式相辅相成的模式。我们还将探讨在构建软件解决方案时，它如何/在哪里融入整体方案。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Architecture styles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构风格
- en: Programming paradigms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程范式
- en: Which paradigm should you choose?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该选择哪种范式？
- en: By the end of this chapter, you will have gained an appreciation of a variety
    of architecture styles and programming paradigms, along with some pitfalls to
    watch out for when applying them. You will also understand the role that DDD plays
    in augmenting each of these.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够欣赏到各种架构风格和编程范式的优点，以及在使用它们时需要注意的一些陷阱。你还将了解领域驱动设计（DDD）在增强这些架构中的作用。
- en: Architecture styles
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构风格
- en: Domain-driven design presents a set of architecture tenets in the form of strategic
    and tactical design elements. This enables you to decompose large, potentially
    unwieldy business subdomains into well-factored, independent bounded contexts.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 领域驱动设计以战略和战术设计元素的形式提供了一套架构原则。这使得你能够将大型、可能难以管理的业务子域分解成良好设计的、独立的边界上下文。
- en: One of the great advantages of DDD is that it does not require the use of any
    specific architecture. However, the software industry has been using a plethora
    of architecture styles over the last few years. Let’s look at how DDD can be used
    in conjunction with a set of popular architecture styles to arrive at better solutions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: DDD的一个巨大优势是它不要求使用任何特定的架构。然而，在过去几年中，软件行业已经使用了大量的架构风格。让我们看看DDD如何与一系列流行的架构风格结合使用，以得出更好的解决方案。
- en: Layered architecture
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分层架构
- en: '**Layered architecture** is one of the most common architecture styles, where
    the solution is typically organized into four broad categories: **presentation**,
    **application**, **domain**, and **persistence**. Each of the layers provides
    a solution to a particular concern it represents, as shown here:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**分层架构**是最常见的架构风格之一，解决方案通常组织为四个广泛的类别：**表示层**、**应用层**、**领域层**和**持久层**。每一层都为其代表的特定关注点提供了解决方案，如图所示：'
- en: '![Figure 2.1 – The essence of layered architecture'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.1 – 分层架构的本质'
- en: '](img/B16716_Figure_2.1.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16716_Figure_2.1.jpg](img/B16716_Figure_2.1.jpg)'
- en: Figure 2.1 – The essence of layered architecture
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 分层架构的本质
- en: The main idea behind layered architecture is a separation of concerns – where
    the dependencies between layers are unidirectional (from top to bottom). For example,
    the domain layer can depend on the persistence layer, not the other way round.
    In addition, any given layer typically accesses the layer immediately beneath
    it without bypassing layers in between. For example, the presentation layer may
    access the domain layer only through the application layer.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 分层架构背后的主要思想是关注点的分离——层与层之间的依赖关系是单向的（从上到下）。例如，领域层可以依赖于持久层，但不能反过来。此外，任何给定的层通常只访问其下方的层，而不会绕过中间的层。例如，表示层可能只能通过应用层访问领域层。
- en: 'This structure enables looser coupling between layers and allows them to evolve
    independently of each other. The idea of layered architecture fits very well with
    DDD’s tactical design elements, as depicted here:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构使得层与层之间的耦合更加松散，并允许它们相互独立地发展。分层架构的理念与DDD的战略和战术设计元素非常契合，如图所示：
- en: '![Figure 2.2 – Layered architecture mapped to DDD’s tactical design elements'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.2 – 分层架构映射到DDD的战术设计元素'
- en: '](img/B16716_Figure_2.2.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16716_Figure_2.2.jpg](img/B16716_Figure_2.2.jpg)'
- en: Figure 2.2 – Layered architecture mapped to DDD’s tactical design elements
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 分层架构映射到DDD的战术设计元素
- en: DDD actively promotes the use of a layered architecture, primarily because it
    makes it possible to focus on the domain layer in isolation from other concerns,
    such as how information gets displayed, how end-to-end flows are managed, and
    how data is stored and retrieved. From that perspective, solutions that apply
    DDD naturally tend to be layered as well.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: DDD积极推广使用分层架构，主要是因为它使得可以独立于其他关注点（如信息如何显示、端到端流程如何管理以及数据如何存储和检索）专注于领域层。从这个角度来看，自然应用DDD的解决方案往往也是分层的。
- en: Notable variations
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显著的变体
- en: A variation of layered architecture was invented by Alistair Cockburn, which
    he originally called hexagonal architecture ([https://alistair.cockburn.us/hexagonal-architecture/](https://alistair.cockburn.us/hexagonal-architecture/)),
    alternatively called ports and adapters architecture. The idea behind this style
    was to avoid inadvertent dependencies between layers (which could occur in layered
    architecture), specifically between the core of a system and the peripheral layers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 分层架构的一种变体是由Alistair Cockburn发明的，他最初称之为六边形架构（[https://alistair.cockburn.us/hexagonal-architecture/](https://alistair.cockburn.us/hexagonal-architecture/)），也称为端口和适配器架构。这种风格背后的想法是避免层与层之间（在分层架构中可能会发生）的不自觉依赖，特别是系统核心与外围层之间的依赖。
- en: 'The main idea here is to make use of interfaces (**ports**) exclusively within
    the core to enable modern drivers, such as testing and looser coupling. This allows
    the core to be developed and evolved independently of the non-core parts and the
    external dependencies. Integration with real-world components such as databases,
    filesystems, and web services is achieved through concrete implementations of
    the ports (**adapters**). The use of interfaces within the core enables much easier
    testing of the core in isolation from the rest of the system, using mocks and
    stubs. It is also common to use dependency injection frameworks to dynamically
    swap out implementations of these interfaces when working with a real system in
    an end-to-end environment. A visual representation of hexagonal architecture is
    shown here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要思想是在核心中仅使用接口（端口）来启用现代驱动程序，例如测试和松散耦合。这使得核心可以独立于非核心部分和外部依赖进行开发和演进。通过端口的具体实现（适配器）与数据库、文件系统、网络服务等现实世界组件的集成得以实现。在核心中使用接口使得在隔离系统其他部分的情况下对核心进行测试变得容易得多，可以使用模拟和存根。在端到端环境中与真实系统一起工作时，也常见使用依赖注入框架动态替换这些接口的实现。这里展示了六边形架构的视觉表示：
- en: '![Figure 2.3 – Hexagonal architecture'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.3 – 六边形架构'
- en: '](img/B16716_Figure_2.3.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16716_Figure_2.3.jpg](img/B16716_Figure_2.3.jpg)'
- en: Figure 2.3 – Hexagonal architecture
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – 六边形架构
- en: It turns out that the use of the term *hexagon* in this context was purely for
    visual purposes– not to limit the system to exactly six types of ports.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，在这个上下文中使用“六边形”一词纯粹是为了视觉目的——并不是要将系统限制为恰好六种类型的端口。
- en: Similar to the hexagonal architecture, onion architecture ([https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/](https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/)),
    conceived by Jeffrey Palermo, is based on creating an application based on an
    independent object model within the core that can be compiled and run separately
    from the outer layers. This is done by defining interfaces (*ports* in hexagonal
    architecture) in the core and implementing them (*adapters* in hexagonal architecture)
    in the outer layers. From our perspective, the hexagonal and onion architecture
    styles have no perceptible differences that we could identify.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与六边形架构类似，洋葱架构（[https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/](https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/)），由Jeffrey
    Palermo构想，其基础是在核心中创建一个基于独立对象模型的应用程序，它可以独立于外部层进行编译和运行。这是通过在核心中定义接口（六边形架构中的端口）并在外部层实现它们（六边形架构中的适配器）来实现的。从我们的角度来看，六边形和洋葱架构风格没有我们能够识别的明显差异。
- en: 'A visual representation of onion architecture is shown here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了洋葱架构的视觉表示：
- en: '![Figure 2.4 – Onion architecture'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.4 – 洋葱架构'
- en: '](img/B16716_Figure_2.4.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16716_Figure_2.4.jpg](img/B16716_Figure_2.4.jpg)'
- en: Figure 2.4 – Onion architecture
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 洋葱架构
- en: Yet another variation of layered architecture, popularized by Robert C. Martin
    (known endearingly as Uncle Bob), is clean architecture. This is based on adhering
    to the SOLID principles ([https://blog.cleancoder.com/uncle-bob/2020/10/18/Solid-Relevance.html](https://blog.cleancoder.com/uncle-bob/2020/10/18/Solid-Relevance.html)),
    also conceived by him. The fundamental message here (just like in the case of
    hexagonal and onion architecture) is to avoid dependencies between the core –
    the one that houses business logic – and other layers that tend to be volatile
    (such as frameworks, third-party libraries, UIs, and databases).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种流行的分层架构变体，由罗伯特·C·马丁（亲切地称为Uncle Bob）推广，是清洁架构。这是基于遵循SOLID原则（[https://blog.cleancoder.com/uncle-bob/2020/10/18/Solid-Relevance.html](https://blog.cleancoder.com/uncle-bob/2020/10/18/Solid-Relevance.html)），这也是他提出的。这里的基本信息（就像六边形和洋葱架构的情况一样）是避免核心（即包含业务逻辑的核心）与其他易变层（如框架、第三方库、UI和数据库）之间的依赖关系。
- en: '![Figure 2.5 – Clean architecture'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.5 – 清洁架构'
- en: '](img/B16716_Figure_2.5.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.5 – 图2.5的示例](img/B16716_Figure_2.5.jpg)'
- en: Figure 2.5 – Clean architecture
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – 清洁架构
- en: All these architecture styles are synergistic with DDD’s idea of developing
    a domain model for the core subdomain (and, by extension, its bounded context)
    independently of the rest of the system.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些架构风格都与DDD（领域驱动设计）为核心子域（以及由此扩展的边界上下文）独立于系统其余部分开发领域模型的想法相辅相成。
- en: While each of these architecture styles provides additional guidance in terms
    of how to structure a layered architecture, any architecture approach we choose
    comes with its set of trade-offs and limitations you will need to be cognizant
    of. We will discuss some of these considerations in the next sub-sections.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然每种架构风格都在如何构建分层架构方面提供了额外的指导，但我们选择的任何架构方法都伴随着其自身的权衡和限制，您需要对此有所认识。我们将在下一小节中讨论一些这些考虑因素。
- en: The layer cake anti-pattern
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 层蛋糕反模式
- en: 'Sticking to a fixed set of layers provides a level of isolation, but in simpler
    cases, it may prove to be overkill without adding any perceptible benefit, other
    than adherence to the agreed-on architecture guidelines. In the layer cake anti-pattern,
    each layer merely proxies the call to the layer beneath it without adding any
    value. The following example illustrates this fairly common scenario:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 坚持一组固定的层提供了一定程度的隔离，但在更简单的情况下，它可能证明是过度杀鸡用牛刀，除了遵守约定的架构指南外，没有增加任何可感知的好处。在层蛋糕反模式中，每个层只是代理对下层层的调用，而没有增加任何价值。以下示例说明了这种相当常见的场景：
- en: '![Figure 2.6 – An example of the layer cake anti-pattern to find an entity
    representation by ID'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.6 – 通过ID查找实体表示的层蛋糕反模式示例](img/B16716_Figure_2.6.jpg)'
- en: '](img/B16716_Figure_2.6.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.6 – 图2.6的示例](img/B16716_Figure_2.6.jpg)'
- en: Figure 2.6 – An example of the layer cake anti-pattern to find an entity representation
    by ID
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 通过ID查找实体表示的层蛋糕反模式示例
- en: Here, the `findById` method is replicated in every layer and simply calls the
    method with the same name in the layer below, with no additional logic. This introduces
    a level of accidental complexity to the solution. Some amount of redundancy in
    the layering may be unavoidable for the purposes of standardization. It may be
    best to reexamine the layering guidelines if the *layer cake* occurs prominently
    in the code base.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`findById`方法在每个层都被复制，并简单地调用下一层中相同名称的方法，没有任何额外的逻辑。这给解决方案引入了意外复杂性。为了标准化目的，层中的某些冗余可能是不可避免的。如果代码库中“层蛋糕”出现明显，最好重新审视分层指南。
- en: Anemic translation
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 贫弱转换
- en: Another variation of the layer cake we see commonly is one where layers refuse
    to share input and output types in the name of higher isolation and looser coupling.
    This makes it necessary to perform translations at the boundary of each layer.
    If the objects being translated are more or less structurally identical, we have
    an `findById` example we discussed previously.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们常见的一种层蛋糕变体是，层拒绝在更高隔离和更松耦合的名义下共享输入和输出类型。这使得在每个层的边界执行转换成为必要。如果被转换的对象在结构上大致相同，我们就有了一个之前讨论过的`findById`示例。
- en: '![Figure 2.7 – An example of the anemic translation anti-pattern'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.7 – 贫弱转换反模式示例'
- en: '](img/B16716_Figure_2.7.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.7 – 图2.6的示例](img/B16716_Figure_2.7.jpg)'
- en: Figure 2.7 – An example of the anemic translation anti-pattern
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – 贫弱转换反模式示例
- en: In this case, each layer defines an `Entity` type of its own, requiring a translation
    between types at each layer. To make matters worse, the structure of the `Entity`
    type may have seemingly minor variations (for example, `lastName` being referred
    to as `surname`). While such translations may be necessary across bounded contexts,
    teams should strive to avoid the need for variations in names and structures of
    the same concept within a single bounded context. The intentional use of *ubiquitous
    language* helps avoid such scenarios.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，每一层定义了自己的`实体`类型，需要在每一层之间进行类型转换。更糟糕的是，`实体`类型的结构可能会有看似微小的变化（例如，`lastName`被称为`surname`）。虽然这种转换在有限范围内可能是必要的，但团队应努力避免在单个有限范围内同一概念名称和结构的变化。有意使用*通用语言*有助于避免此类情况。
- en: Layer bypass
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 层绕过
- en: When working with a layered architecture, it is reasonable to start by being
    strict about layers only interacting with the layers immediately beneath them.
    As we saw earlier, such rigid enforcements may lead to an intolerable degree of
    accidental complexity, especially when applied generically to a large number of
    use cases. In such scenarios, it may be worth considering consciously allowing
    one or more layers to be bypassed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当与分层架构一起工作时，从严格限制层只与直接下方的层交互开始是合理的。正如我们之前看到的，这种严格的执行可能导致无法容忍的意外复杂性，尤其是在将它们普遍应用于大量用例时。在这种情况下，有意识地允许一个或多个层被绕过可能是有价值的。
- en: For example, the `controller` layer may be allowed to work directly with the
    `repository` without using the `service` layer. In many cases, we have found it
    useful to use a separate set of rules for *commands* versus *queries* as a starting
    point.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`控制器`层可能被允许直接与`仓储`层工作而不使用`服务`层。在许多情况下，我们发现使用一套独立的规则来区分*命令*和*查询*作为起点是有用的。
- en: 'This can be a slippery slope. To continue maintaining a level of sanity, teams
    should consider the use of a lightweight architecture governance tool such as
    **ArchUnit** ([https://www.archunit.org/](https://www.archunit.org/)) to make
    agreements explicit and provide quick feedback. A simple example of how to use
    ArchUnit for this purpose is shown here:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个滑稽的斜坡。为了继续维持一定的理智，团队应考虑使用轻量级的架构治理工具，如**ArchUnit** ([https://www.archunit.org/](https://www.archunit.org/))，以使协议明确并提供快速反馈。这里展示了如何使用ArchUnit实现此目的的简单示例：
- en: '![](img/ch2-1.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ch2-1.jpg)'
- en: The `Repository` layer can be accessed by both the Services and Controllers
    layers – effectively allowing Controllers to bypass the use of the Services layer.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`仓储`层可以被服务和控制器层访问 – 有效地允许控制器绕过使用服务层。'
- en: Vertical slice architecture
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 垂直切片架构
- en: Layered architecture and its variants provide reasonably good guidance on how
    to structure complex applications. Vertical slice architecture, championed by
    Jimmy Boggard, recognizes that it may be too rigid to adopt a standard layering
    strategy for all use cases across an entire application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 分层架构及其变体为如何构建复杂应用程序提供了合理的指导。由Jimmy Boggard倡导的垂直切片架构认识到，在整个应用程序的所有用例中采用标准的分层策略可能过于僵化。
- en: 'Furthermore, it is important to note that business value cannot be derived
    by implementing any of these horizontal layers in isolation. Doing so will only
    result in unusable inventory and lots of unnecessary context switching until all
    these layers are connected. Therefore, vertical slice architecture proposes minimizing
    coupling between slices and maximizing coupling in a slice ([https://jimmybogard.com/vertical-slice-architecture/](https://jimmybogard.com/vertical-slice-architecture/)),
    as shown here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，值得注意的是，不能通过单独实现这些水平层来获得业务价值。这样做只会导致无法使用的库存和大量的不必要的上下文切换，直到所有这些层都连接起来。因此，垂直切片架构建议最小化切片之间的耦合，并最大化切片内的耦合
    ([https://jimmybogard.com/vertical-slice-architecture/](https://jimmybogard.com/vertical-slice-architecture/))，如图所示：
- en: '![Figure 2.8 – Vertical slice architecture'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.8 – 垂直切片架构'
- en: '](img/B16716_Figure_2.8.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_2.8.jpg)'
- en: Figure 2.8 – Vertical slice architecture
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – 垂直切片架构
- en: In this example, **Place Order** might require us to coordinate with other components
    through the application layer and apply complex business invariants, while operating
    within the purview of an ACID transaction. Similarly, **Cancel Order** might require
    applying business invariants within an ACID transaction without any additional
    coordination – obviating the need for the application layer, in this case. However,
    **Search O****rders** might require us to simply fetch existing data from a query-optimized
    view. This style makes use of a horses-for-courses approach to layering that may
    help alleviate some anti-patterns listed previously when implementing a plain
    vanilla layered architecture.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，**下单**可能需要我们通过应用层与其他组件进行协调，并在 ACID 事务的范围内应用复杂业务不变性。同样，**取消订单**可能需要在 ACID
    事务内应用业务不变性，而不需要任何额外的协调——在这种情况下，无需应用层。然而，**搜索订单**可能只需要我们从查询优化的视图中检索现有数据。这种风格利用了“按需分配”的方法来分层，这可能在实现纯分层架构时帮助缓解之前列出的某些反模式。
- en: Considerations
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 考虑事项
- en: Vertical slice architecture affords a lot of flexibility when implementing a
    solution – taking into consideration the specific needs of the use case being
    implemented. However, without some level of governance, this may quickly devolve
    into a big ball of mud, with layering decisions being made seemingly arbitrarily,
    based on personal preferences and experiences (or lack thereof). As a sensible
    default, you may want to consider using a distinct layering strategy for commands
    and queries. Beyond that, non-functional requirements may dictate how you may
    need to deviate from here. For example, you may need to bypass layers to meet
    performance SLAs for certain use cases.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直切片架构在实现解决方案时提供了很大的灵活性——考虑到正在实施的使用案例的具体需求。然而，如果没有一定程度的治理，这可能会迅速演变成一团糟，分层决策似乎是基于个人偏好和经验（或缺乏经验）任意做出的。作为一个合理的默认选项，您可能希望考虑为命令和查询使用不同的分层策略。除此之外，非功能性需求可能规定了您可能需要如何偏离这里。例如，您可能需要绕过某些层以满足某些用例的性能服务级别协议（SLA）。
- en: 'When used pragmatically, vertical slice architecture does enable you to apply
    DDD very effectively within each or a group of related vertical slices – allowing
    them to be treated as bounded contexts. Two possibilities using the place order
    and cancel order examples are shown here:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当实用地使用垂直切片架构时，它确实使您能够在每个或一组相关的垂直切片中非常有效地应用领域驱动设计（DDD）——允许它们被视为边界上下文。以下展示了使用下单和取消订单示例的两个可能性：
- en: '![Figure 2.9 – Vertical slices used to evolve bounded contexts'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.9 – 用于演进边界上下文的垂直切片'
- en: '](img/B16716_Figure_2.9.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_2.9.jpg)'
- en: Figure 2.9 – Vertical slices used to evolve bounded contexts
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 – 用于演进边界上下文的垂直切片
- en: In the **(i)** example in the preceding diagram, place order and cancel order
    each use a distinct domain model, whereas in the **(ii)** example, both use cases
    share a common domain model and, by extension, become part of the same bounded
    context. This does pave the way to slice functionality when looking to adopt the
    serverless architecture along use case boundaries.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面图表中的 **(i)** 示例中，下单和取消订单各自使用不同的领域模型，而在 **(ii)** 示例中，这两个用例共享一个共同的领域模型，并且由此扩展，成为同一个边界上下文的一部分。这确实为在用例边界采用无服务器架构时切片功能铺平了道路。
- en: Service-oriented architecture (SOA)
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向服务架构（SOA）
- en: '**Service-Oriented Architecture** (**SOA**) is an architecture style where
    software components expose (potentially) reusable functionality over standardized
    interfaces. The use of standardized interfaces (such as SOAP, REST, and gRPC,
    to name a few) enables easier interoperability when integrating heterogeneous
    solutions, as shown here:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向服务架构**（**SOA**）是一种架构风格，其中软件组件通过标准化的接口（例如 SOAP、REST 和 gRPC 等）暴露（可能）可重用的功能。使用标准化接口（如
    SOAP、REST 和 gRPC 等）可以在集成异构解决方案时实现更简单的互操作性，如下所示：'
- en: '![Figure 2.10 – SOA – exposing reusable functionality over standard interfaces'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.10 – SOA – 在标准接口上暴露可重用功能'
- en: '](img/B16716_Figure_2.10.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_2.10.jpg)'
- en: Figure 2.10 – SOA – exposing reusable functionality over standard interfaces
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – SOA – 在标准接口上暴露可重用功能
- en: Previously, the use of non-standard, proprietary interfaces made this kind of
    integration a lot more challenging. For example, a retail bank may expose inter-account
    transfer functionality in the form of SOAP web services. While SOA prescribes
    exposing functionality over standardized interfaces, the focus is more on integrating
    heterogeneous applications than implementing them.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，使用非标准、专有接口使得这种集成变得更加具有挑战性。例如，一家零售银行可能会以SOAP Web服务的形式公开账户间转账功能。虽然SOA规定通过标准化接口公开功能，但重点更多地在于集成异构应用程序，而不是实现它们。
- en: Considerations
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 考虑事项
- en: At one of the banks we worked at, we exposed a set of over 500 service interfaces
    over SOAP. Under the hood, we implemented these services using EJB 2.x (a combination
    of stateless session beans and message-driven beans), hosted on a commercial J2EE
    application server, which also did double duty as an **Enterprise Service Bus**
    (**ESB**). These services delegated most, if not all, of the logic to a set of
    underlying stored procedures within a single monolithic Oracle database, using
    a canonical data model for the entire enterprise! To the outside world, these
    services were *location-transparent*, stateless, *composable*, and *discoverable*.
    Indeed, we advertised this implementation as an example of SOA, and it would be
    hard to argue that it was not.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们曾经工作的一家银行中，我们通过SOAP暴露了超过500个服务接口。在底层，我们使用EJB 2.x（无状态会话豆和无状态消息驱动豆的组合）实现了这些服务，这些服务托管在商业J2EE应用服务器上，该服务器还充当了**企业服务总线**（**ESB**）。这些服务将大部分，如果不是全部，逻辑委托给单个单体Oracle数据库中的底层存储过程，使用整个企业的规范数据模型！对于外界来说，这些服务是*位置透明的*、无状态的、*可组合的*和*可发现的*。事实上，我们将这种实现宣传为SOA的例子，很难反驳这一点。
- en: This suite of services had evolved organically over the years, with no explicit
    boundaries, concepts from various parts of the organization, and generations of
    people mixed in, each adding their own interpretation of how business functionality
    needed to be implemented. In essence, the implementation resembled the dreaded
    big ball of mud, which was extremely hard to enhance and maintain.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这套服务在多年中自然发展，没有明确的边界，组织各部分的概念和几代人的人们混合在一起，每个人都添加了自己对业务功能如何实现的理解。本质上，实现类似于令人讨厌的大泥球，这非常难以增强和维护。
- en: The intentions behind SOA are noble. However, the promises of *reuse* and *loose
    coupling* are hard to achieve in practice, given the lack of concrete implementation
    guidance on component granularity. It is also true that SOA means many things
    ([https://martinfowler.com/bliki/ServiceOrientedAmbiguity.html](https://martinfowler.com/bliki/ServiceOrientedAmbiguity.html))
    to different people. This ambiguity leads to most SOA implementations becoming
    complex, unmaintainable monoliths, centered around technology components such
    as a service bus, a persistence store, or both. This is where using DDD to solve
    a complex problem by breaking it down into subdomains and bounded contexts can
    be invaluable.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: SOA背后的意图是崇高的。然而，由于缺乏关于组件粒度的具体实施指导，*重用*和*松耦合*的承诺在实践中很难实现。同样，SOA对不同的人来说意味着很多不同的东西（[https://martinfowler.com/bliki/ServiceOrientedAmbiguity.html](https://martinfowler.com/bliki/ServiceOrientedAmbiguity.html)）。这种歧义导致大多数SOA实现变得复杂、难以维护的单体，围绕技术组件如服务总线、持久化存储或两者展开。这就是使用DDD通过将问题分解为子域和边界上下文来解决复杂问题的价值所在。
- en: Microservices architecture
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务架构
- en: In the last decade or so, microservices have gained quite a lot of popularity,
    with lots of organizations wanting to adopt this style of architecture. In a lot
    of ways, microservices are an extension of SOA – one where much emphasis is placed
    on creating focused components that deal with doing a limited number of things
    and doing them right. Sam Newman, the author of the *Building Microservices* book,
    defines microservices as *small-sized*, independently deployable components that
    maintain their own state and are *modeled around a business domain*. This affords
    benefits such as adopting a horses-for-courses approach when modeling solutions,
    limiting the blast radius, improved productivity and speed, autonomous cross-functional
    teams, and so on.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去十年左右的时间里，微服务获得了相当多的流行度，许多组织都希望采用这种架构风格。在许多方面，微服务是SOA的扩展 – 其中重点在于创建专注于执行有限数量事情并正确执行它们的组件。*《构建微服务》*一书的作者山姆·纽曼将微服务定义为*小型化*、独立部署的组件，它们维护自己的状态，并且*围绕业务领域建模*。这提供了采用针对特定解决方案的“按需定制”方法、限制爆炸半径、提高生产力和速度、自主跨职能团队等好处。
- en: 'Microservices usually exist as a collective, working collaboratively to achieve
    desired business outcomes, as depicted here:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务通常作为一个整体存在，共同协作以实现预期的业务成果，如图所示：
- en: '![Figure 2.11 – A microservices ecosystem'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.11 – 微服务生态系统'
- en: '](img/B16716_Figure_2.11.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_2.11.jpg)'
- en: Figure 2.11 – A microservices ecosystem
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 – 微服务生态系统
- en: As we can see, SOA and microservices are very similar from the perspective of
    the consumers, in that they access functionality through a set of standardized
    interfaces. The microservices approach is an evolution of SOA in that the focus
    now is on building smaller, self-sufficient, independently deployable components
    with the intent of avoiding single points of failure (such as an enterprise database
    or service bus), which was fairly common with a number of SOA-based implementations.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，从消费者的角度来看，SOA和微服务非常相似，因为它们通过一组标准化接口访问功能。微服务方法是SOA的演变，现在的重点是构建更小、自给自足、独立部署的组件，目的是避免单点故障（如企业数据库或服务总线），这在许多基于SOA的实现中相当普遍。
- en: Considerations
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 考虑事项
- en: While microservices have definitely helped, there still exists quite a lot of
    ambiguity when it comes to answering how big or small a microservice should be
    ([https://martinfowler.com/articles/microservices.html#HowBigIsAMicroservice](https://martinfowler.com/articles/microservices.html#HowBigIsAMicroservice)).
    Indeed, a lot of teams seem to struggle to get this balance right, resulting in
    a distributed monolith ([https://www.infoq.com/news/2016/02/services-distributed-monolith/](https://www.infoq.com/news/2016/02/services-distributed-monolith/)),
    which, in a lot of ways, can be much worse than even a single-process monolith
    from the SOA days. Again, applying the strategic design concepts of DDD can help
    create independent, loosely coupled components, making it an ideal companion for
    the microservices style of architecture.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管微服务确实有所帮助，但在回答一个微服务应该有多大或多小的问题上，仍然存在相当多的模糊性（[https://martinfowler.com/articles/microservices.html#HowBigIsAMicroservice](https://martinfowler.com/articles/microservices.html#HowBigIsAMicroservice)）。实际上，许多团队似乎都难以找到这个平衡点，导致出现了分布式单体（[https://www.infoq.com/news/2016/02/services-distributed-monolith/](https://www.infoq.com/news/2016/02/services-distributed-monolith/)），这在很多方面可能比SOA时代的单进程单体还要糟糕。再次强调，应用DDD的战略设计概念可以帮助创建独立、松散耦合的组件，使其成为微服务架构风格的理想伴侣。
- en: Event-driven architecture (EDA)
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件驱动架构（EDA）
- en: 'Irrespective of the granularity of components (monolith, microservices, or
    something in between), most non-trivial solutions have a boundary, beyond which
    there may be a need to communicate with external system(s). This communication
    usually happens through the exchange of messages between systems, causing them
    to become coupled with each other. Coupling comes in two broad flavors: *afferent*
    – who depends on you, and *efferent* – who you depend on. Excessive amounts of
    efferent coupling can make systems very brittle and hard to work with.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 不论组件的粒度（单体、微服务或介于两者之间），大多数非平凡解决方案都有一个边界，超出这个边界可能需要与外部系统（s）进行通信。这种通信通常是通过系统之间的消息交换来实现的，导致它们相互耦合。耦合有两种广泛的形式：*传入*
    – 依赖于你的人，和*传出* – 你所依赖的人。过量的传出耦合会使系统变得非常脆弱且难以操作。
- en: 'Event-driven systems enable authoring solutions that have a relatively low
    amount of efferent coupling by emitting events when they attain a certain state,
    without caring about who consumes those events. In this regard, it is important
    to differentiate between message-driven and event-driven systems, as mentioned
    in the *Reactive Manifesto*:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动系统通过在达到某种状态时发出事件，而不关心谁消费这些事件，从而能够编写具有相对较低输出耦合的解决方案。在这方面，区分消息驱动系统和事件驱动系统非常重要，正如*反应宣言*中提到的：
- en: “A message is an item of data that is sent to a specific destination. An event
    is a signal emitted by a component upon reaching a given state. In a message-driven
    system addressable recipients await the arrival of messages and react to them,
    otherwise lying dormant. In an event-driven system notification listeners are
    attached to the sources of events such that they are invoked when the event is
    emitted. This means that an event-driven system focuses on addressable event sources
    while a message-driven system concentrates on addressable recipients.”
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: “消息是发送到特定目的地的一项数据。事件是组件达到给定状态时发出的信号。在消息驱动系统中，可寻址的接收者等待消息的到来并对它们做出反应，否则处于休眠状态。在事件驱动系统中，通知监听器被附加到事件源上，以便在事件发出时被调用。这意味着事件驱动系统关注可寻址的事件源，而消息驱动系统则专注于可寻址的接收者。”
- en: – The Reactive Manifesto
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: – 反应宣言
- en: In simpler terms, event-driven systems do not care who the downstream consumers
    are, whereas in a message-driven system, that may not necessarily be true. When
    we say event-driven in the context of this book, we mean the former.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 用更简单的术语来说，事件驱动系统并不关心下游消费者是谁，而在消息驱动系统中，这未必是真实的。当我们在这本书的上下文中提到事件驱动时，我们指的是前者。
- en: Typically, event-driven systems eliminate the need for point-to-point messaging
    with the ultimate consumers by making use of an intermediary infrastructure component,
    usually known as a message broker, event bus, and so on. This effectively reduces
    efferent coupling from *n* consumers to 1\. There are a few variations on how
    event-driven systems can be implemented. In the context of publishing events,
    Martin Fowler talks about two broad styles (among other things), event notifications
    and event-carried state transfer, in his *What do you mean by “Event-Driven”?*
    article ([https://martinfowler.com/articles/201701-event-driven.html](https://martinfowler.com/articles/201701-event-driven.html)).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，事件驱动系统通过使用中介基础设施组件（通常称为消息代理、事件总线等）来消除与最终消费者之间的点对点消息需求。这有效地将来自 *n* 个消费者的输出耦合减少到
    1。事件驱动系统可以实现的变体有几个。在发布事件的上下文中，马丁·福勒在他的*“你说的‘事件驱动’是什么意思？”*文章中谈到了两种广泛风格（以及其他事项），即事件通知和事件携带状态传输（[https://martinfowler.com/articles/201701-event-driven.html](https://martinfowler.com/articles/201701-event-driven.html)）。
- en: Considerations
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 考虑事项
- en: One of the main trade-offs when building an event-driven system is to decide
    the amount of state (payload) that should be embedded in each event. It may be
    prudent to consider embedding just enough state to indicate changes that occurred
    as a result of the emitted event to keep the various opposing forces, such as
    producer scaling, encapsulation, consumer complexity, and resiliency. We will
    discuss the related implications in more detail when we cover implementing events
    in [*Chapter 5*](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077), *Implementing
    Domain Logic*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建事件驱动系统时，主要权衡之一是决定每个事件中应嵌入多少状态（有效载荷）。可能明智的做法是只嵌入足够的状态来指示由发出的事件引起的更改，以保持各种对立力量，如生产者扩展、封装、消费者复杂性和弹性。当我们讨论在[*第5章*](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077)
    *实现领域逻辑*中实现事件的相关影响时，我们将更详细地讨论这些问题。
- en: DDD is all about keeping complexity in check by creating these independent bounded
    contexts. However, *independent* does not mean *isolated*. Bounded contexts may
    still need to communicate with each other. One way to do that is through the use
    of a fundamental DDD building block – domain events. Event-driven architecture
    and DDD are thus complementary. It is typical to make use of an event-driven architecture
    to allow bounded contexts to communicate while continuing to loosely couple with
    each other.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 领域驱动设计（DDD）的全部内容是通过创建这些独立的边界上下文来控制复杂性。然而，“独立”并不意味着“隔离”。边界上下文可能仍然需要相互通信。实现这一目标的一种方法是通过使用DDD的基本构建块——领域事件。因此，事件驱动架构和DDD是相辅相成的。通常，利用事件驱动架构允许边界上下文进行通信，同时继续相互松散耦合。
- en: Command Query Responsibility Segregation (CQRS)
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令查询责任分离（CQRS）
- en: 'In traditional applications, a single-domain, data/persistence model is used
    to handle all kinds of operations. With CQRS, we create distinct models to handle
    updates (commands) and inquiries. This is depicted in the following diagram:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统应用程序中，单一领域的数据/持久化模型用于处理所有类型的操作。在 CQRS 中，我们创建不同的模型来处理更新（命令）和查询。这将在以下图中展示：
- en: '![Figure 2.12 – Traditional versus CQRS architecture'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.12 – 传统与 CQRS 架构对比'
- en: '](img/B16716_Figure_2.12.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16716_Figure_2.12.jpg)'
- en: Figure 2.12 – Traditional versus CQRS architecture
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12 – 传统与 CQRS 架构对比
- en: Note
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We depict multiple query models in the previous diagram because it is possible
    (but not necessary) to create more than one query model, depending on the kinds
    of query use cases that need to be supported.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一个图中展示了多个查询模型，因为根据需要支持的各种查询用例，创建多个查询模型是可能的（但不是必需的）。
- en: For this to work predictably, the query model(s) need to be kept in sync with
    the write models (we will examine some of the techniques to do that in detail
    later).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个过程能够可预测地工作，查询模型（们）需要与写入模型保持同步（我们将在稍后详细探讨一些实现这一点的技术）。
- en: Considerations
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 考虑因素
- en: A traditional, single-model approach works well for simple, CRUD-style applications
    but starts to become unwieldy for more complex scenarios. We will discuss some
    of these scenarios in the next subsections.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的单一模型方法对于简单的 CRUD 风格的应用程序来说效果很好，但对于更复杂的场景开始变得难以控制。我们将在下一小节中讨论一些这些场景。
- en: Volume imbalance between reads and writes
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读写之间的量不平衡
- en: In most systems, read operations often outnumber write operations by significant
    orders of magnitude. For example, consider the number of times a trader checks
    stock prices versus the number of times they actually transact (buy or sell stock
    trades). It is also usually true that write operations are the ones that make
    businesses money. Having a single model for both reads and writes in a system
    with a majority of read operations can overwhelm a system to an extent where write
    performance can become affected.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数系统中，读操作通常比写操作多出显著的数量级。例如，考虑交易员检查股票价格次数与实际交易（买卖股票交易）次数之间的差异。通常，写操作是创造企业收入的活动。在以读操作为主的系统中，使用单一模型进行读写可能会使系统超负荷，从而影响写性能。
- en: A need for multiple read representations
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 需要多个读表示
- en: When working with relatively complex systems, it is not uncommon to require
    more than one representation of the same data. For example, when looking at personal
    health data, you may want to look at a daily, weekly, or monthly view. While these
    views can be computed on the fly from the *raw* data, each transformation (aggregation,
    summarization, and so on) adds to the cognitive load on a system. Often, it is
    not possible to predict ahead of time the nature of these requirements. By extension,
    it is not feasible to design a single canonical model that can provide answers
    to all these requirements. Creating domain models specifically designed to meet
    a focused set of requirements can be much easier.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理相对复杂系统时，需要同一数据的多个表示形式并不罕见。例如，在查看个人健康数据时，你可能想查看每日、每周或每月的视图。虽然这些视图可以从 *原始*
    数据实时计算得出，但每次转换（聚合、总结等）都会增加系统上的认知负荷。通常，无法提前预测这些需求的具体性质。因此，设计一个能够满足所有这些需求的单一规范模型是不切实际的。创建专门针对一组特定需求设计的领域模型可能会容易得多。
- en: Different security requirements
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不同的安全需求
- en: Managing the authorization of and access requirements to data/APIs when working
    with a single model can start to become cumbersome. For example, higher levels
    of security may be desirable for debit operations in comparison to balance enquiries.
    Having distinct models can considerably ease the complexity of designing fine-grained
    authorization controls.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用单一模型工作时，管理数据/API的授权和访问需求可能会变得繁琐。例如，与余额查询相比，借记操作可能需要更高的安全级别。拥有不同的模型可以大大简化设计细粒度授权控制复杂性。
- en: More uniform distribution of complexity
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更均匀的复杂性分布
- en: Having a model dedicated to serving only command-side use cases means that they
    can now be focused toward solving a single concern. For query-side use cases,
    we create models as needed that are distinct from the command-side model. This
    helps spread complexity more uniformly over a larger surface area – as opposed
    to increasing the complexity on a single model that is used to serve all use cases.
    It is worth noting that the essence of DDD is mainly to work effectively with
    complex software systems, and CQRS fits well with this line of thinking.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 专门用于仅服务于命令端用例的模型意味着现在它们可以专注于解决单个问题。对于查询端用例，我们根据需要创建与命令端模型不同的模型。这有助于更均匀地将复杂性分散到更大的表面上——而不是增加用于服务所有用例的单个模型的复杂性。值得注意的是，DDD的本质主要是有效地与复杂的软件系统协同工作，而CQRS与这一思路非常契合。
- en: Note
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When working with a CQRS-based architecture, choosing the persistence mechanism
    for the command side is a key decision. When working in conjunction with event-driven
    architecture, you could choose to persist aggregates as a series of events (ordered
    in the sequence of their occurrence). This style of persistence is known as event
    sourcing. We will cover this in more detail in [*Chapter 5*](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077),
    *Implementing Domain Logic*, in the *Event-sourced aggregates* section.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用基于CQRS的架构工作时，为命令端选择持久化机制是一个关键决策。当与事件驱动架构结合使用时，你可以选择将聚合体作为一系列事件（按其发生顺序排序）进行持久化。这种持久化方式被称为事件溯源。我们将在[*第五章*](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077)“实现领域逻辑”部分中更详细地介绍这一点。
- en: Serverless architecture
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无服务器架构
- en: Serverless architecture is an approach to software design that allows developers
    to build and run services without having to manage the underlying infrastructure.
    The advent of the AWS Lambda service has popularized this style of architecture,
    although several other services (such as S3 and DynamoDB for persistence, SNS
    for notifications, and SQS for message queuing) existed long before Lambda was
    launched. While AWS Lambda provides a compute solution in the form of **Functions
    as a Service** (**FaaS**), these other services are just as essential, if not
    more, in order to benefit from a serverless paradigm.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器架构是一种软件设计方法，允许开发者在无需管理底层基础设施的情况下构建和运行服务。AWS Lambda服务的推出使得这种架构风格变得流行，尽管在Lambda推出之前就已经存在了其他一些服务（例如用于持久化的S3和DynamoDB、用于通知的SNS以及用于消息队列的SQS）。虽然AWS
    Lambda以**函数即服务**（**FaaS**）的形式提供计算解决方案，但这些其他服务对于从无服务器范式中获益同样重要，甚至更为重要。
- en: In conventional DDD, bounded contexts are formed by grouping related operations
    around an aggregate, which then informs how the solution is deployed as a unit
    – usually within the confines of a single process. With a serverless paradigm,
    each operation (task) is expected to be deployed as an independent unit of its
    own. This requires that we look at how we model aggregates and bounded contexts
    differently – now centered around individual tasks or functions, as opposed to
    a group of related tasks.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的DDD中，边界上下文是通过围绕聚合体分组相关操作来形成的，这随后会告知解决方案作为单元的部署方式——通常是在单个进程的范围内。在无服务器范式中，每个操作（任务）都预期作为其自身的独立单元进行部署。这要求我们以不同的方式来考虑如何建模聚合体和边界上下文——现在是以单个任务或函数为中心，而不是以相关任务组为中心。
- en: Does that mean that the principles of DDD to arrive at a solution do not apply
    anymore? While a serverless paradigm introduces an additional dimension of having
    to treat fine-grained deployable units as first-class citizens in the modeling
    process, the overall process of applying DDD’s strategic and tactical design continues
    to apply. We will examine this in more detail in [*Chapter 11*](B16716_11_Final_NM_ePub.xhtml#_idTextAnchor164),
    *Decomposing into Finer-Grained Components*, when we will refactor the solution
    we build throughout this book to employ a serverless approach.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着到达解决方案的DDD原则不再适用？虽然无服务器范式引入了必须将细粒度可部署单元视为建模过程中的第一公民的额外维度，但应用DDD的战略和战术设计的过程仍然适用。我们将在[*第十一章*](B16716_11_Final_NM_ePub.xhtml#_idTextAnchor164)“分解为更细粒度的组件”中更详细地探讨这一点，届时我们将重构本书中构建的解决方案以采用无服务器方法。
- en: The big ball of mud
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大泥球
- en: 'Thus far, we have examined a catalog of named architecture styles along with
    their pitfalls and how applying DDD can help alleviate them. At the other extreme,
    we may encounter solutions that lack a perceivable architecture, infamously known
    as the *big ball of mud*:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经考察了一系列命名的架构风格及其陷阱，以及如何应用DDD来帮助缓解这些问题。在另一个极端，我们可能会遇到缺乏可感知架构的解决方案，这臭名昭著地被称为“大泥球”：
- en: “A BIG BALL OF MUD is haphazardly structured, sprawling, sloppy, duct-tape and
    baling wire, spaghetti code jungle. We’ve all seen them. These systems show unmistakable
    signs of unregulated growth, and repeated, expedient repair. Information is shared
    promiscuously among distant elements of the system, often to the point where nearly
    all the important information becomes global or duplicated. The overall structure
    of the system may never have been well-defined. If it was, it may have eroded
    beyond recognition. Programmers with a shred of architectural sensibility shun
    these quagmires. Only those who are unconcerned about architecture, and, perhaps,
    are comfortable with the inertia of the day-to-day chore of patching the holes
    in these failing dikes, are content to work on such systems.”
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: “一个‘大泥球’结构混乱，庞大，杂乱无章，像胶带和草绳一样， spaghetti 代码丛林。我们都见过。这些系统显示出不受控制的增长和不重复、应急修复的明显迹象。信息在系统遥远元素之间随意共享，常常达到几乎所有重要信息都变成全局或重复的程度。系统的整体结构可能从未得到很好的定义。如果曾经有，它可能已经侵蚀到无法辨认。具有一丝架构感的程序员会避开这些泥潭。只有那些对架构不关心的人，也许，对日常修补这些失败堤坝的惰性感到舒适的人，才会满足于在这样的系统上工作。”
- en: – Brian Foote and Joseph Yoder
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: – 布赖恩·福特和约瑟夫·约德
- en: Although Foote and Yoder advise avoiding this style of architecture at all costs,
    software systems that resemble the big ball of mud continue to be a day-to-day
    inevitability for a lot of us. The strategic and tactical design elements of DDD
    provide a set of techniques to help deal with and recover from these near-hopeless
    situations in a pragmatic manner, without potentially having to adopt a big bang
    approach. Indeed, the focus of this book is to apply these principles to prevent
    or at least delay further devolution toward the big ball of mud.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管福特和约德建议不惜一切代价避免这种架构风格，但类似于“大泥球”的软件系统仍然是我们很多人日常生活中的不可避免。领域驱动设计（DDD）的战略和战术设计元素提供了一套技术，帮助我们以实用主义的方式处理和恢复这些近乎绝望的情况，而无需可能地采用大爆炸方法。实际上，本书的重点是将这些原则应用于防止或至少推迟进一步退化成“大泥球”。
- en: Which architecture style should you use?
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你应该使用哪种架构风格？
- en: As we have seen, there are a variety of architecture styles you can lean on
    when crafting a software solution. A lot of these architecture styles share quite
    a few common tenets. It can become difficult to conform to any single architecture
    style. DDD, with its emphasis on breaking down complex business problems into
    subdomains and bounded contexts, enables the use of more than one approach across
    bounded contexts. We would like to make a special mention of vertical slice architecture
    because it places an emphasis on dividing functionality into specific business
    outcomes and, thus, more naturally adheres to DDD’s ideas of subdomains and bounded
    contexts. In reality, you may find the need to extend and even deviate from pedantic
    definitions of architecture styles in order to meet real-world needs. But when
    we do make such compromises, it is important to do so *intentionally* and make
    it unambiguously clear why we are making such a decision (preferably using some
    lightweight mechanism, such as **ADRs** ([https://www.thoughtworks.com/de-de/radar/techniques/lightweight-architecture-decision-records](https://www.thoughtworks.com/de-de/radar/techniques/lightweight-architecture-decision-records)).
    This is important because it may become hard to justify this to others and even
    ourselves when we look at it in the future.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，在构建软件解决方案时，你可以依赖各种架构风格。其中许多架构风格共享一些共同的原则。遵循任何单一的架构风格都可能变得困难。领域驱动设计（DDD）通过强调将复杂业务问题分解为子域和边界上下文，使得在边界上下文中使用多种方法成为可能。我们特别提一下垂直切片架构，因为它强调将功能划分为特定的业务成果，因此更自然地遵循DDD的子域和边界上下文理念。实际上，你可能需要扩展甚至偏离架构风格的严格定义，以满足现实世界的需求。但当我们做出这样的妥协时，重要的是要故意为之，并明确说明我们做出这种决定的原因（最好使用一些轻量级机制，例如**ADRs**
    ([https://www.thoughtworks.com/de-de/radar/techniques/lightweight-architecture-decision-records](https://www.thoughtworks.com/de-de/radar/techniques/lightweight-architecture-decision-records))).
    这很重要，因为当我们未来回顾时，可能很难向他人甚至我们自己解释这种决定。
- en: In this section, we have examined popular architecture styles and how we can
    amplify their effectiveness when used in conjunction with DDD. Now, let’s look
    at how DDD can complement the use of existing programming paradigms.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们考察了流行的架构风格以及如何在使用DDD时增强其有效性。现在，让我们看看DDD如何补充现有编程范式的使用。
- en: Programming paradigms
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程范式
- en: The tactical elements of DDD introduce a specific vocabulary (aggregates, entities,
    value objects, repositories, services, factories, domain events, and so on) when
    arriving at a solution. At the end of the day, we need to translate these concepts
    into running software. Over the years, we have employed a variety of programming
    paradigms, including procedural, object-oriented, functional, and aspect-oriented.
    Is it possible to apply DDD in conjunction with one or more of these paradigms?
    In this section, we will explore how some common programming paradigms and techniques
    help us express tactical design elements in code.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: DDD的策略元素在解决问题时引入了特定的词汇（聚合、实体、值对象、存储库、服务、工厂、领域事件等）。最终，我们需要将这些概念转化为运行中的软件。多年来，我们已经采用了各种编程范式，包括过程式、面向对象、函数式和面向方面。将DDD与这些范式之一或多个结合使用是否可能？在本节中，我们将探讨一些常见的编程范式和技术如何帮助我们用代码表达策略设计元素。
- en: Object-oriented programming
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: 'On the surface of it, DDD seems to simply replicate a set of OO terms and call
    them by different names. For example, the central concepts of tactical DDD such
    as aggregates, entities, and value objects could simply be referred to as objects
    in OO terms. Others such as services may not have a direct OO analog. So, how
    do you apply DDD in an OO world? Let’s look at a simple example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从表面上看，DDD似乎只是复制了一套面向对象的术语，并赋予它们不同的名称。例如，战术DDD的核心概念，如聚合、实体和值对象，在面向对象术语中可以简单地称为对象。其他如服务可能没有直接的面向对象对应物。那么，如何在面向对象的世界中应用DDD呢？让我们看一个简单的例子：
- en: '![](img/ch2-2.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch2-2.jpg)'
- en: 'OO purists will be quick to point out that `PasswordService` is procedural
    and that a `Password` class might be needed to encapsulate related behaviors.
    Similarly, DDD enthusiasts might point out that this is an anemic domain model
    implementation. An arguably better OO version might look something like the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象纯粹主义者会迅速指出`PasswordService`是过程式的，可能需要一个`Password`类来封装相关行为。同样，DDD爱好者可能会指出这是一个贫血的领域模型实现。一个可能更好的面向对象版本可能看起来像以下这样：
- en: '![](img/ch2-3.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch2-3.jpg)'
- en: In this case, the `Password` class stops exposing its internals and exposes
    the idea of a strong or weak password in the form of behavior (the `isStrong`
    and `isWeak` methods). From an OO perspective, the second implementation is arguably
    superior. If so, shouldn’t we be using the OO version at all times? As it turns
    out, the answer is nuanced and depends on what consumers desire and the ubiquitous
    language used in that context. If the concept of `Password` is in common usage
    within the domain, it perhaps warrants introducing such a concept in the implementation
    as well. If not, the first solution might suffice, even though it seems to violate
    OO principles of encapsulation.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`Password` 类停止暴露其内部结构，并以行为（`isStrong` 和 `isWeak` 方法）的形式暴露了强密码或弱密码的概念。从面向对象的角度来看，第二种实现可能更优越。如果是这样，我们是否应该始终使用面向对象的版本？实际上，答案是有细微差别的，这取决于消费者在特定情境下的需求以及普遍使用的语言。如果
    `Password` 的概念在领域内广泛使用，那么在实现中引入这样的概念可能是合理的。如果不是，第一种解决方案可能就足够了，即使它似乎违反了面向对象的封装原则。
- en: Our default position is to apply good OO practices as a starting point. However,
    it is more important to mirror the language of the domain as opposed to applying
    OO in a dogmatic manner. So, we will be willing to compromise on OO purity if
    it appears unnatural to do so in that context. As mentioned earlier, clearly communicating
    the rationale for such decisions can go a long way.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们默认的立场是将良好的面向对象实践作为起点。然而，更重要的是要反映领域语言，而不是教条地应用面向对象。因此，如果在这种情况下这样做显得不自然，我们愿意在面向对象的纯粹性上做出妥协。如前所述，清楚地传达做出此类决策的理由可以走很长的路。
- en: Functional programming
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数式编程
- en: 'Functions are a fundamental building block to code organization that exists
    in all higher-order programming languages. Functional programming is a programming
    paradigm where programs are constructed by applying and composing functions. This
    is in contrast to imperative programming, which uses statements to change a program’s
    state. The most significant differences stem from the fact that functional programming
    avoids side effects, which are common in imperative programming. Pure functional
    programming completely prevents side effects and forces immutability. Embracing
    a functional style when designing a domain model to be more declarative expresses
    intent a lot more clearly while remaining terse. It also allows us to keep the
    complexity in check by enabling us to compose more complex concepts by using simpler
    ones. The functional implementation allows us to use a language closer to the
    problem domain, while having the added benefit of also being terse. Consider a
    simple example where we need to find the item with the least inventory across
    all our warehouses using a functional style, as shown here:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是代码组织的基本构建块，存在于所有高级编程语言中。函数式编程是一种编程范式，其中程序通过应用和组合函数来构建。这与使用语句来改变程序状态的命令式编程形成对比。最显著的区别源于函数式编程避免了命令式编程中常见的副作用。纯函数式编程完全防止副作用并强制不可变性。在设计领域模型时采用函数式风格，使其更具声明性，可以更清晰地表达意图，同时保持简洁。它还使我们能够通过使用更简单的概念来组合更复杂的概念，从而控制复杂性。函数式实现使我们能够使用更接近问题域的语言，同时也有简洁的附加好处。考虑一个简单的例子，我们需要使用函数式风格在所有仓库中找到库存最少的物品，如下所示：
- en: '![](img/ch2-4.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch2-4.jpg)'
- en: The imperative style shown here does get the job done but is arguably a lot
    more verbose and harder to follow, sometimes even for technical team members!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的命令式风格确实完成了工作，但可能更加冗长且难以理解，有时甚至对技术团队成员来说也是如此！
- en: 'Here is an imperative example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个命令式的例子：
- en: '![](img/ch2-5.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch2-5.jpg)'
- en: 'From a DDD perspective, this yields a few benefits:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从领域驱动设计（DDD）的角度来看，这带来了一些好处：
- en: '**Increased collaboration with domain experts** because the declarative style
    allows placing a bigger focus on the what, rather than the how. This makes it
    a lot less intimidating to technical and non-technical stakeholders alike to work
    with on an ongoing basis.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与领域专家的协作增加**，因为声明式风格允许更多地关注“是什么”，而不是“怎么做”。这使得无论是技术还是非技术利益相关者都能在持续合作中感到不那么令人畏惧。'
- en: '**Better testability** because the use of pure functions (those that are side-effect-free)
    makes it easier to create data-driven tests. This has also afforded us an additional
    benefit of less mocking/stubbing. These characteristics make tests that are a
    lot easier to maintain and rationalize. This has the benefit of allowing even
    technical team members to visualize corner cases a lot earlier in the process.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的可测试性**，因为纯函数（那些无副作用的函数）的使用使得创建数据驱动测试变得更容易。这也为我们提供了额外的优势，即减少模拟/存根的使用。这些特性使得测试更容易维护和合理化。这也有利于让技术团队成员在早期阶段就能可视化边缘情况。'
- en: Which paradigm should you choose?
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你应该选择哪种范式？
- en: DDD simply states that you should build your software around a domain model
    that represents the actual problem that the software is trying to solve. When
    encountering complex real-life problems, we often find it hard to conform to any
    single paradigm across the board. Looking to use a one-size-fits-all approach
    may work to our detriment. Our experience indicates that we will need to make
    use of a variety of techniques in order to solve the problem at hand elegantly.
    Java is inherently an OO language, but with the advent of Java 8, it has started
    to embrace a variety of functional constructs as well. This allows us to make
    use of a multitude of techniques to create elegant solutions. The most important
    thing is to agree on a ubiquitous language and allow it to guide the approach
    taken. It also largely depends on the talent and experience you have at your disposal.
    Making use of a style that is foreign to the majority of a team will likely prove
    counterproductive. Although we haven’t covered the procedural paradigm here in
    this chapter, there may be occasions where it might be the best solution given
    the current situation. As long as we are intentional about areas where we deviate
    from the accepted norm for a particular programming paradigm, we should be in
    a reasonably good place.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: DDD简单地说，你应该围绕代表软件试图解决的实际问题的领域模型来构建你的软件。当遇到复杂的生活问题时，我们常常发现很难在整个范围内遵循任何单一范式。寻求一种一刀切的方法可能会对我们产生不利影响。我们的经验表明，我们需要利用各种技术来优雅地解决问题。Java本质上是一种面向对象的编程语言，但随着Java
    8的推出，它开始拥抱各种函数式构造。这使我们能够利用多种技术来创建优雅的解决方案。最重要的是，要就通用的语言达成一致，并允许它指导采取的方法。这也很大程度上取决于你拥有的才能和经验。使用大多数团队成员都不熟悉的风格可能会适得其反。尽管我们在这里的章节中没有涵盖过程范式，但在某些情况下，它可能是最佳解决方案。只要我们有意于偏离特定编程范式的公认规范，我们就应该处于一个相当好的位置。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered a series of commonly used architecture patterns
    and how we can practice DDD when working with them. We also looked at common pitfalls
    and gotchas that we may need to be cognizant of when using these architectures.
    We also looked at popular programming paradigms and their influence on the tactical
    elements of DDD.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一系列常用的架构模式，以及我们在使用它们时如何实践DDD。我们还探讨了在使用这些架构时可能需要留意的常见陷阱和问题。我们还探讨了流行的编程范式及其对DDD战术元素的影响。
- en: Additionally, you should have an appreciation of the various architecture styles
    that you need to employ when coming up with a solution. In addition, you should
    have an understanding of how DDD can play a role, no matter which style of architecture
    you choose to adopt.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你应该欣赏在构思解决方案时需要采用的多种架构风格。此外，你应该了解DDD可以在你选择采用哪种架构风格时扮演的角色。
- en: In the next section, we will look to apply all we have learned in this and previous
    chapters to a real-world business use case. We will apply both the strategic and
    tactical patterns of DDD to break a complex domain into subdomains and bounded
    contexts and iteratively build a solution, using technologies that are based on
    the Java programming language.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将把在本章和之前章节中学到的所有知识应用到现实世界的商业案例中。我们将应用DDD的战略和战术模式，将复杂的领域分解为子领域和边界上下文，并迭代地构建解决方案，使用基于Java编程语言的技术。
