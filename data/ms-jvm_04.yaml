- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Understanding Bytecodes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解字节码
- en: In the intricate world of the JVM, bytecode serves as the intermediary language
    that enables Java programs to transcend the boundaries of platform-specific hardware
    and operating systems. As we delve into the heart of JVM internals, this chapter
    focuses on deciphering the bytecode, a fundamental component in executing Java
    applications. Bytecode, represented as a set of instructions, acts as the bridge
    between high-level Java code and the machine-specific language of the underlying
    hardware. By comprehending bytecode, developers gain insights into the inner workings
    of the JVM, empowering them to optimize code performance and troubleshoot intricate
    issues.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在JVM错综复杂的领域中，字节码作为中介语言，使Java程序能够超越特定平台硬件和操作系统的限制。当我们深入JVM内部的核心时，本章专注于解码字节码，这是执行Java应用程序的基本组件。字节码，作为一组指令的表示，充当了高级Java代码和底层硬件特定语言之间的桥梁。通过理解字节码，开发者可以深入了解JVM的内部工作原理，从而优化代码性能并解决复杂问题。
- en: At the core of bytecode lies a diverse set of instructions that dictate the
    low-level operations performed by the JVM. This chapter unravels the nuances of
    arithmetic operations, shedding light on how the JVM handles mathematical calculations.
    From essential addition and subtraction to more complex procedures, we explore
    the bytecode instructions that govern these processes. Furthermore, we delve into
    value conversions, demystifying how the JVM transforms data between different
    types. Understanding these low-level operations is paramount for developers seeking
    to fine-tune their applications for optimal performance and efficiency. Join us
    on a journey into the bytecode realm, where the intricacies of arithmetic operations
    and value conversions pave the way for mastering the JVM.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 字节码的核心是一系列指令，这些指令决定了JVM执行的底层操作。本章揭示了算术操作的细微差别，阐明了JVM如何处理数学计算。从基本的加法和减法到更复杂的程序，我们探讨了管理这些过程的字节码指令。此外，我们还深入探讨了值转换，揭示了JVM如何在不同类型之间转换数据。理解这些底层操作对于寻求优化应用程序性能和效率的开发者至关重要。加入我们，一起探索字节码领域，在这里，算术操作和值转换的复杂性为掌握JVM铺平了道路。
- en: 'In this chapter, we’ll explore the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Bytecode unveiled
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看字节码
- en: Arithmetic operations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术运算
- en: Value conversions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值转换
- en: Object manipulation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象操作
- en: Conditional instructions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件指令
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will require the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要以下内容：
- en: Java 21
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 21
- en: Git
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git
- en: Maven
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven
- en: Any preferred IDE
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何首选的IDE
- en: This chapter’s GitHub repository, found at - [https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-03](https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-03)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的GitHub仓库位于 - [https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-03](https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-03)
- en: Bytecode unveiled
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看字节码
- en: Bytecode, a pivotal concept in Java programming, is the intermediary language
    that facilitates the cross-platform compatibility and execution of Java applications
    on the JVM. This session aims to demystify bytecode, providing a comprehensive
    overview of its significance, purpose, and the spectrum of operations it enables
    within the JVM.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 字节码，Java编程中的关键概念，是促进Java应用程序在JVM上实现跨平台兼容性和执行的中介语言。本次会议旨在揭开字节码的神秘面纱，提供一个对其重要性、目的以及它在JVM内允许的操作范围的全面概述。
- en: At its core, bytecode acts as a bridge between high-level Java code and the
    machine-specific language of the underlying hardware. When a Java program is compiled,
    the source code is transformed into bytecode, a set of instructions comprehensible
    to the JVM. This platform-independent bytecode allows Java applications to execute
    seamlessly across diverse environments, a fundamental tenet of Java’s *Write Once,
    Run* *Anywhere* mantra.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，字节码充当了高级Java代码和底层硬件特定语言之间的桥梁。当Java程序编译时，源代码被转换成字节码，这是一组JVM可理解的指令。这种平台无关的字节码允许Java应用程序在不同环境中无缝执行，这是Java“一次编写，到处运行”信条的基本原则。
- en: Why do we have bytecode? The answer lies in the portability and versatility
    it brings to Java applications. By introducing an intermediate step between the
    high-level source code and machine code, Java programs can run on any device equipped
    with a JVM, irrespective of its architecture or operating system. This abstraction
    shields developers from the intricacies of hardware-specific details, fostering
    a more universal and accessible programming environment.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们有字节码？答案在于它为Java应用程序带来的可移植性和多功能性。通过在高级源代码和机器代码之间引入一个中间步骤，Java程序可以在任何配备JVM的设备上运行，无论其架构或操作系统如何。这种抽象保护开发者免受硬件特定细节的复杂性，促进了一个更通用和易于访问的编程环境。
- en: Now, let’s delve into the operations encoded within bytecode. Bytecode instructions
    cover a myriad of functionalities, ranging from basic load and save operations
    to intricate arithmetic calculations. The JVM’s stack-based architecture governs
    these operations, where values are pushed and popped onto and off the stack, forming
    the basis for data manipulation. Arithmetic operations, encompassing addition,
    subtraction, multiplication, and more, are executed through specific bytecode
    instructions, allowing developers to understand and optimize the mathematical
    underpinnings of their code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入探讨字节码中编码的操作。字节码指令涵盖了众多功能，从基本的加载和保存操作到复杂的算术计算。JVM的基于栈的架构控制这些操作，其中值被推入和弹出栈，形成数据操作的基础。包括加法、减法、乘法等在内的算术操作通过特定的字节码指令执行，使开发者能够理解和优化代码的数学基础。
- en: '**Value conversion**, another facet of bytecode operations, involves transforming
    data between different types. Whether converting integers to floating point numbers
    or managing other type transitions, bytecode instructions provide the foundation
    for these operations. This flexibility is crucial for developers crafting code
    and seamlessly handling diverse data types within the Java ecosystem.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**值转换**是字节码操作的另一个方面，涉及在不同类型之间转换数据。无论是将整数转换为浮点数还是管理其他类型转换，字节码指令为这些操作提供了基础。这种灵活性对于开发者编写代码和在Java生态系统中无缝处理各种数据类型至关重要。'
- en: Beyond this, bytecode orchestrates the creation and manipulation of objects,
    governs conditional statements, and manages the invocation and return of methods.
    Each bytecode instruction contributes to the overall execution flow of a Java
    program, and understanding these operations empowers developers to craft efficient,
    performant, and reliable applications.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个之外，字节码负责对象的创建和操作，控制条件语句，并管理方法的调用和返回。每条字节码指令都对Java程序的总体执行流程做出贡献，理解这些操作使开发者能够构建高效、性能良好且可靠的应用程序。
- en: Indeed, understanding the bytecode behavior is crucial for navigating the intricacies
    of the JVM. Bytecode instructions are designed to operate on specific types of
    values, and recognizing the type being operated upon is fundamental to writing
    efficient and correct Java code. The initial letter of each bytecode mnemonic
    often serves as a valuable hint for discerning the type of operation being performed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，理解字节码行为对于导航JVM的复杂性至关重要。字节码指令旨在操作特定类型的值，识别被操作的类型对于编写高效和正确的Java代码是基本的。每个字节码助记符的首字母通常是一个宝贵的提示，有助于辨别正在执行的操作类型。
- en: 'Let’s delve into this tip for recognizing the type of operation based on the
    initial letter of the bytecode mnemonic:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨这个基于字节码助记符首字母识别操作类型的技巧：
- en: '**i for integer operations**: Bytecodes starting with **i**, such as **iload**
    (load integer), **iadd** (add integer), or **isub** (subtract integer), signify
    operations involving integer values. These bytecode instructions manipulate data
    stored as 32-bit signed integers.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**i用于整数操作**：以**i**开头的字节码，例如**iload**（加载整数）、**iadd**（加整数）或**isub**（减整数），表示涉及整数值的操作。这些字节码指令操作存储为32位有符号整数的数据。'
- en: '**l for long operations**: The **l** prefix, as seen in **lload** (load long)
    or **lmul** (multiply long), indicates operations on 64-bit signed long integers.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**l用于长操作**：**l**前缀，如在**lload**（加载长整型）或**lmul**（乘长整型）中看到的那样，表示对64位有符号长整数的操作。'
- en: '**s for short operations**: Bytecodes beginning with **s**, for instance, **sload**
    (load short), are associated with operations on 16-bit signed short integers.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**s用于短操作**：以**s**开头的字节码，例如**sload**（加载短整型），与16位有符号短整数的操作相关。'
- en: '**b for byte operations**: The **b** prefix, found in bytecode instructions
    such as **bload** (load byte), denotes operations on 8-bit signed byte integers.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**b用于字节操作**：在**bload**（加载字节）等字节码指令中发现的**b**前缀表示对8位有符号字节整数的操作。'
- en: '**c for char operations**: Operations on 16-bit Unicode characters are represented
    by bytecode instructions starting with **c**, such as **caload** (the load array
    of **char**).'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**c用于字符操作**：对16位Unicode字符的操作通过以**c**开头的字节码指令表示，例如**caload**（加载**char**数组）。'
- en: '**f for float operations**: The **f** prefix, seen in bytecode mnemonics such
    as **fload** (load float) or **fadd** (add float), signals operations involving
    32-bit single-precision floating point numbers.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**f用于浮点操作**：在**fload**（加载浮点数）或**fadd**（加浮点数）等字节码助记符中看到的**f**前缀表示涉及32位单精度浮点数的运算。'
- en: '**d for double operations**: Double-precision floating point numbers (64-bit)
    are the focus of bytecode instructions starting with **d**, such as **dload**
    (load double) or **dmul** (multiply double).'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**d用于双精度操作**：双精度浮点数（64位）是字节码指令以**d**开头关注的焦点，例如**dload**（加载双精度）或**dmul**（乘双精度）。'
- en: '**a for reference operations**: Operations involving object references are
    represented by bytecode instructions starting with **a**, such as **aload** (load
    reference) or **areturn** (return reference).'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**a用于引用操作**：涉及对象引用的运算通过以**a**开头的字节码指令表示，例如**aload**（加载引用）或**areturn**（返回引用）。'
- en: This systematic naming convention helps developers quickly identify the type
    of data being manipulated by a bytecode instruction. By recognizing the initial
    letter and associating it with a specific data type, developers can write more
    informed and precise code, ensuring that the bytecode operations align with the
    intended data types and behaviors within the JVM. This understanding is fundamental
    for mastering bytecode and optimizing Java applications for performance and reliability.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这种系统性的命名约定有助于开发者快速识别字节码指令所操作的数据类型。通过识别初始字母并将其与特定数据类型关联，开发者可以编写更明智和精确的代码，确保字节码操作与JVM中预期的数据类型和行为保持一致。这种理解对于掌握字节码和优化Java应用程序的性能和可靠性至关重要。
- en: 'In Java bytecode, Boolean values are typically represented using integers (`0`
    for `false` and `1` for `true`). However, it’s essential to note that Boolean
    values do not have dedicated bytecode instructions; instead, the standard integer
    arithmetic and logical instructions are used. For instance:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java字节码中，布尔值通常使用整数表示（`0`表示`false`，`1`表示`true`）。然而，需要注意的是，布尔值没有专门的字节码指令；相反，使用标准的整数算术和逻辑指令。例如：
- en: '**iadd**, **isub**, **imul**, **idiv**, and similar instructions work seamlessly
    with Boolean values'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iadd**、**isub**、**imul**、**idiv**以及类似的指令可以无缝地与布尔值一起工作'
- en: Logical operations such as *and* (**iand**), *or* (**ior**), and *xor* (**ixor**)
    can be used for Boolean logic
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑运算如*与*（**iand**）、*或*（**ior**）和*异或*（**ixor**）可用于布尔逻辑
- en: The key takeaway is that Boolean values are treated as integers in bytecode,
    allowing developers to use the same arithmetic and logical instructions for both
    numerical and Boolean computations.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 关键要点是布尔值在字节码中被视为整数，这使得开发者可以使用相同的算术和逻辑指令进行数值和布尔计算。
- en: Bytecode provides the groundwork for arithmetic operations, shaping the mathematical
    core of Java programs. Our journey continues in the next section, where we’ll
    delve into the intricate world of arithmetic operations in bytecode. We’ll dissect
    the instructions governing addition, subtraction, multiplication, and more, unraveling
    the bytecode sequences defining Java applications’ mathematical essence.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 字节码为算术运算提供了基础，塑造了Java程序数学核心。我们的旅程将在下一节继续，我们将深入探讨字节码中算术运算的复杂世界。我们将剖析控制加法、减法、乘法等运算的指令，揭示定义Java应用程序数学本质的字节码序列。
- en: By understanding the arithmetic operations encoded in bytecode, developers gain
    insights into the inner workings of their code, enabling them to optimize performance
    and enhance efficiency. Join us in the next section to uncover the secrets behind
    arithmetic operations and pave the way for mastering the intricacies of the JVM.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解字节码中编码的算术运算，开发者可以深入了解他们代码的内部工作原理，从而能够优化性能并提高效率。请加入我们下一节，揭开算术运算背后的秘密，为掌握JVM的复杂性铺平道路。
- en: Arithmetic operations
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算术运算
- en: 'In this section, we embark on a focused exploration of one of the cornerstone
    aspects of bytecode: arithmetic operations. These operations are the mathematical
    underpinnings that breathe life into Java programs, shaping the numerical landscape
    of computations within the JVM.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们专注于探索字节码的一个基石方面：算术操作。这些操作是数学基础，为Java程序注入活力，塑造了JVM中计算的数值景观。
- en: 'Bytecode arithmetic operations follow a fundamental principle: they operate
    on the first two values on the `operand` stack, performing the specified operation
    and returning the result to the stack. This session delves into the intricacies
    of bytecode arithmetic, shedding light on its nuances, behavior, and impact on
    program execution.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 字节码算术操作遵循一个基本原则：它们在`操作数栈`上的前两个值上操作，执行指定的操作，并将结果返回到栈中。本节深入探讨字节码算术的复杂性，揭示其细微差别、行为和程序执行的影响。
- en: 'The arithmetic operations in bytecode are subdivided into two major categories:
    those involving floating point numbers and those dealing with integers. Each category
    exhibits distinct behaviors, and understanding these differences is crucial for
    Java developers seeking precision and reliability in their numerical computations.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 字节码中的算术操作分为两大类：涉及浮点数的操作和涉及整数的操作。每一类都表现出不同的行为，理解这些差异对于寻求精确性和可靠性的Java开发者来说至关重要。
- en: As we navigate the bytecode arithmetic terrain, we explore the instructions
    governing addition, subtraction, multiplication, and division for floats and integers.
    We dissect the bytecode sequences encapsulating these operations, clarifying their
    implementation and performance implications.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索字节码算术领域时，我们研究了控制浮点数和整数加、减、乘、除的指令。我们剖析了封装这些操作的字节码序列，阐明其实现和性能影响。
- en: Addition, subtraction, multiplication, and division
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加法、减法、乘法和除法
- en: 'The fundamental arithmetic operations are the building blocks of numerical
    computations in Java. From adding integers (`iadd`) to dividing doubles (`ddiv`),
    each bytecode instruction is meticulously designed to handle specific data types.
    Uncover the nuances of adding, subtracting, multiplying, and dividing integers,
    longs, floats, and doubles:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 基本算术操作是Java中数值计算的基础。从整数的加法（`iadd`）到双精度的除法（`ddiv`），每条字节码指令都是精心设计的，以处理特定的数据类型。揭示加法、减法、乘法和除法整数、长整数、浮点数和双精度的细微差别：
- en: '**Addition**:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加法**:'
- en: '**iadd**: Adds two integers'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iadd**: 两个整数相加'
- en: '**ladd**: Adds two longs'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ladd**: 两个长整数相加'
- en: '**fadd**: Adds two floats'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**fadd**: 两个浮点数相加'
- en: '**dadd**: Adds two doubles'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dadd**: 两个双精度浮点数相加'
- en: '**Subtraction**:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减法**:'
- en: '**isub**: Subtracts the second integer from the first'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**isub**: 从第一个整数中减去第二个整数'
- en: '**lsub**: Subtracts the second long from the first'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**lsub**: 从第一个长整数中减去第二个长整数'
- en: '**fsub**: Subtracts the second float from the first'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**fsub**: 从第一个浮点数中减去第二个浮点数'
- en: '**dsub**: Subtracts the second double from the first'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dsub**: 从第一个双精度浮点数中减去第二个双精度浮点数'
- en: '**Multiplication**:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**乘法**:'
- en: '**imul**: Multiplies two integers'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**imul**: 乘以两个整数'
- en: '**lmul**: Multiplies two longs'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**lmul**: 乘以两个长整数'
- en: '**fmul**: Multiplies two floats'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**fmul**: 乘以两个浮点数'
- en: '**dmul**: Multiplies two doubles'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dmul**: 两个双精度浮点数相乘'
- en: '**Division**:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**除法**:'
- en: '**idiv**: Divides the first integer by the second'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**idiv**: 第一个整数除以第二个整数'
- en: '**ldiv**: Divides the first long by the second'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ldiv**: 第一个长整数除以第二个长整数'
- en: '**fdiv**: Divides the first float by the second'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**fdiv**: 第一个浮点数除以第二个浮点数'
- en: '**ddiv**: Divides the first double by the second'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ddiv**: 第一个双精度浮点数除以第二个双精度浮点数'
- en: Remainder and negation
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 余数和取反
- en: '**Remainder (remainder)**:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**余数（余数）**:'
- en: '**irem**: Computes the remainder of dividing the first integer by the second'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**irem**: 计算第一个整数除以第二个整数的余数'
- en: '**lrem**: Computes the remainder of dividing the first long by the second'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**lrem**: 计算第一个长整数除以第二个长整数的余数'
- en: '**frem**: Computes the remainder of dividing the first float by the second'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**frem**: 计算第一个浮点数除以第二个浮点数的余数'
- en: '**drem**: Computes the remainder of dividing the first double by the second'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**drem**: 计算第一个双精度浮点数除以第二个双精度浮点数的余数'
- en: '**Negation (negation)**:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**取反（取反）**:'
- en: '**ineg**: Negates (changes the sign of) the integer'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ineg**: 取反（改变整数的符号）'
- en: '**lneg**: Negates the long'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**lneg**: 取反长整数'
- en: '**fneg**: Negates the float'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**fneg**: 取反浮点数'
- en: '**dneg**: Negates the double'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dneg**: 取反双精度浮点数'
- en: Shift and bitwise operations
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移位和位运算
- en: 'Dive into the world of bitwise operations (`ior`, `iand`, `ixor`, `lor`, `land`,
    `lxor`) and shift operations (`ishl`, `ishr`, `iushr`, `lshl`, `lshr`, `lushr`).
    Discover how these operations manipulate individual bits, offering powerful tools
    for advanced computations and optimizations:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 深入位运算（`ior`、`iand`、`ixor`、`lor`、`land`、`lxor`）和移位操作（`ishl`、`ishr`、`iushr`、`lshl`、`lshr`、`lushr`）的世界。了解这些操作如何操纵单个位，为高级计算和优化提供强大的工具：
- en: '**Shift** **operations (shift)**:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移位** **操作（移位）**:'
- en: '**ishl**, **ishr**, **iushr**: Shifts the bits of an integer to the left, right
    (with sign extension), or right (without sign extension)'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ishl**, **ishr**, **iushr**: 将整数的位向左、右（带符号扩展）或右（不带符号扩展）移动'
- en: '**lshl**, **lshr**, **lushr**: Shifts the bits of a long to the left, right
    (with sign extension), or right (without sign extension)'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**lshl**, **lshr**, **lushr**: 将长整数的位向左、右（带符号扩展）或右（不带符号扩展）移动'
- en: '**Bitwise operations**:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位运算**:'
- en: '**ior**, **lor**: Bitwise *or* for integers and longs'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ior**, **lor**: 整数和长整数的位或'
- en: '**iand**, **land**: Bitwise *and* for integers and longs'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iand**, **land**: 整数和长整数的位与'
- en: '**ixor**, **lxor**: Bitwise exclusive *or* for integers and longs'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ixor**, **lxor**: 整数和长整数的位异或'
- en: Local variable increment
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局部变量增量
- en: 'Unlock the potential of the `iinc` instruction, a subtle yet powerful operation
    that increments a local variable by a constant value. Learn how this bytecode
    instruction can enhance code readability and efficiency in specific scenarios:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 解锁 `iinc` 指令的潜力，这是一个微妙但强大的操作，可以通过一个常量值增加局部变量。了解这个字节码指令如何在特定场景中提高代码的可读性和效率：
- en: '**Local variable increment** (**iinc**): **iinc** increments a local variable
    by a constant value'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**局部变量增量**（**iinc**）: **iinc** 通过一个常量值增加局部变量'
- en: Comparison operations
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较操作
- en: 'Delve into the world of comparing values with instructions such as `cmpg`,
    `dcmpl`, `fcmpg`, `fcmpl`, and `lcmp`. Uncover the subtleties of yielding results
    such as 1, -1, or 0, indicating greater, less, or equal comparisons for doubles,
    floats, and longs:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 深入比较值的世界，使用 `cmpg`、`dcmpl`、`fcmpg`、`fcmpl` 和 `lcmp` 等指令。揭示产生 1、-1 或 0 等结果的内幕，这些结果表示双精度浮点数、浮点数和长整数的比较结果：
- en: '**Comparison**:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**比较**:'
- en: '**dcmpg**, **dcmpl**: Compares two doubles, yielding 1, -1, or 0 (greater,
    less, or equal)'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dcmpg**, **dcmpl**: 比较两个双精度浮点数，返回 1、-1 或 0（表示大于、小于或等于）'
- en: '**fcmpg**, **fcmpl**: Compares two floats, yielding 1, -1, or 0 (greater, less,
    or equal)'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**fcmpg**, **fcmpl**: 比较两个浮点数，返回 1、-1 或 0（表示大于、小于或等于）'
- en: '**lcmp**: Compares two longs, yielding 1, -1, or 0 (greater, less, or equal)'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**lcmp**: 比较两个长整数，返回 1、-1 或 0（表示大于、小于或等于）'
- en: In the world of bytecode comparison, instructions such as `dcmpg` and `dcmpl`
    effectively compare double-precision floating point numbers, yielding 1, -1, or
    0 to signify greater, lesser, or equal comparisons. Similarly, `fcmpg` and `fcmpl`
    handle single-precision floats. However, when it comes to long integers, `lcmp`
    simplifies things by providing a single result of 1, -1, or 0, indicating greater,
    lesser, or equal comparisons. This streamlined approach optimizes long integer
    comparisons in bytecode.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在字节码比较的世界中，`dcmpg` 和 `dcmpl` 指令有效地比较双精度浮点数，返回 1、-1 或 0 以表示大于、小于或等于比较。同样，`fcmpg`
    和 `fcmpl` 处理单精度浮点数。然而，当涉及到长整数时，`lcmp` 通过提供一个单一的 1、-1 或 0 的结果来简化事情，表示大于、小于或等于比较。这种简化的方法优化了字节码中的长整数比较。
- en: These bytecode instructions form the backbone of arithmetic and logical operations
    in Java programs. It’s crucial to note that the behavior of these operations may
    differ for integers and floating point numbers, especially when dealing with edge
    cases such as division by zero or overflow conditions. Understanding these bytecode
    instructions provides developers with the tools to craft precise and robust numerical
    computations in their Java applications.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字节码指令构成了 Java 程序中算术和逻辑操作的基础。需要注意的是，这些操作的行为可能因整数和浮点数而异，尤其是在处理除以零或溢出条件等边缘情况时。理解这些字节码指令为开发者提供了在
    Java 应用程序中构建精确且健壮数值计算的工具。
- en: After explaining the concept of bytecode and showcasing some arithmetic operations,
    we will delve deeper into the world of bytecode arithmetic within the JVM by examining
    a practical example. Our focus will be on understanding the process by analyzing
    a simple Java code snippet, which performs a basic arithmetic operation, i.e.,
    adding two integers. This hands-on exploration aims to unravel the intricate workings
    of bytecode arithmetic.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释了字节码的概念并展示了某些算术操作之后，我们将通过检查一个实际示例来深入探讨JVM内部的字节码算术世界。我们的重点是通过对一个简单的Java代码片段进行分析来理解这个过程，该代码片段执行基本的算术操作，即添加两个整数。这次动手探索旨在揭示字节码算术的复杂运作。
- en: 'Consider the following Java code snippet:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下Java代码片段：
- en: '[PRE0]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Save the code in a file named `ArithmeticExample.java` and compile it using
    the following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码保存到名为`ArithmeticExample.java`的文件中，并使用以下命令进行编译：
- en: '[PRE1]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let’s use the `javap` command to disassemble the bytecode:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`javap`命令来反汇编字节码：
- en: '[PRE2]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After executing the command, it will generate the output of the bytecode:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 执行命令后，它将生成字节码的输出：
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The code is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following takes place in these bytecode instructions:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些字节码指令中发生以下操作：
- en: '**iload_1**: Loads the value of the local variable **a** onto the stack'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iload_1**：将局部变量**a**的值加载到栈上'
- en: '**iload_2**: Loads the value of the local variable **b** onto the stack'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iload_2**：将局部变量**b**的值加载到栈上'
- en: '**iadd**: Adds the top two values on the stack (which are **a** and **b**)'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iadd**：将栈顶的两个值（即**a**和**b**）相加'
- en: '**istore_3**: Stores the result of the addition back into the local variable
    result'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**istore_3**：将加法的结果存储回局部变量result'
- en: These bytecode instructions precisely reflect the arithmetic operation `int
    result = a + b`; in the Java code. The `iadd` instruction performs the addition
    of the loaded values, and the `istore_3` instruction stores the result back into
    a local variable for further use. Understanding this bytecode provides a detailed
    look at how the JVM executes a simple arithmetic operation in a Java program.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字节码指令精确地反映了Java代码中的算术操作`int result = a + b`。`iadd`指令执行加载值的加法，而`istore_3`指令将结果存储回局部变量以供进一步使用。理解这些字节码提供了对JVM在Java程序中执行简单算术操作的详细视图。
- en: In our journey through bytecode arithmetic, we’ve dissected the seemingly mundane
    yet profoundly impactful process of adding two integers in a Java program. The
    bytecode instructions unveiled a hidden layer of intricacy, showcasing how high-level
    operations transform into machine-executable code within the **Java virtual**
    **machine** (**JVM**).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们通过字节码算术的旅程中，我们已经剖析了在Java程序中添加两个整数的看似平凡却又深刻影响的过程。字节码指令揭示了隐藏的复杂层，展示了高级操作如何在Java虚拟机（JVM）中转化为可执行的机器代码。
- en: 'As we close this section, our next destination awaits: the realm of value conversions.
    Understanding how different data types interact in bytecode is pivotal for crafting
    robust and efficient Java applications. In the upcoming section, let us delve
    into the intricacies of value conversions, unraveling the nuances of transforming
    data within the JVM. The journey continues, and each bytecode instruction brings
    us one step closer to mastering the depths of Java bytecode.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们结束这一部分时，我们的下一个目的地等待着：值转换的领域。理解不同数据类型在字节码中的交互对于构建健壮和高效的Java应用程序至关重要。在下一节中，让我们深入探讨值转换的复杂性，揭示在JVM中转换数据的细微差别。旅程继续，每一行字节码指令都让我们更接近掌握Java字节码的深度。
- en: Value conversions
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值转换
- en: 'In this section, we immerse ourselves in the intricate realm of value conversions
    within the JVM. These conversions serve as the chameleons of the bytecode landscape,
    enabling variables to transform their types gracefully by allowing integers to
    stretch into longs and floats to transcend into doubles without compromising the
    fidelity of their original values. The bytecode instructions that facilitate these
    metamorphoses are crucial in maintaining precision, preventing data loss, and
    ensuring the seamless integration of different data types. Join us as we dissect
    these instructions, uncovering the symphony of elegance and accuracy that underpins
    Java programming:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们沉浸在JVM内部值转换的复杂领域。这些转换是字节码景观中的变色龙，通过允许整型扩展为长整型和浮点型超越为双精度浮点型，而不会损害原始值的忠实度，从而实现变量的类型优雅转换。促进这些变形的字节码指令对于保持精度、防止数据丢失和确保不同数据类型的无缝集成至关重要。加入我们，我们将剖析这些指令，揭示支撑Java编程的优雅和精确的交响曲：
- en: '**Integer to long** (**i2l**)**:** Explore how the **i2l** instruction promotes
    an integer variable to a long, preserving the original value’s precision'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整型转换为长整型**（**i2l**）：探索**i2l**指令如何将整型变量提升为长整型，同时保留原始值的精度'
- en: '**Integer to float** (**i2f**)**:** Delve into the world of **i2f**, where
    an integer gracefully transforms into a float without sacrificing precision'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整型转换为浮点型**（**i2f**）：深入**i2f**的世界，其中整型可以优雅地转换为浮点型而不牺牲精度'
- en: '**Integer to double** (**i2d**)**:** Witness the precision-preserving journey
    from integer to double through the **i2d** instruction'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整型转换为双精度浮点型**（**i2d**）：见证通过**i2d**指令从整型到双精度浮点型的精度保持之旅'
- en: '**Long to float** (**l2f**) **and long to double** (**l2d**): Examine the elegance
    of **l2f** and **l2d**, where long values seamlessly transition to float and double,
    respectively'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长整型转换为浮点型**（**l2f**）和**长整型转换为双精度浮点型**（**l2d**）：考察**l2f**和**l2d**的优雅之处，其中长整型值可以无缝地转换为浮点型和双精度浮点型'
- en: '**Float to Double** (**f2d**)**:** Explore the **f2d** instruction, showcasing
    the promotion of float to double while maintaining precision'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浮点型转换为双精度浮点型**（**f2d**）：探索**f2d**指令，展示浮点型提升为双精度浮点型的同时保持精度'
- en: 'As we navigate the intricacies of bytecode, we encounter a critical segment
    devoted to managing shortening—a delicate process marked by potential loss and
    overflow considerations. In this exploration, we delve into the bytecode instructions
    that transform variables into shorter data types, acknowledging the nuanced challenges
    associated with precision loss and overflow risks. Let us now explore this set
    of instructions:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索字节码的复杂性时，我们遇到了一个关键部分，专门用于管理缩短——这是一个标记着潜在损失和溢出考虑的微妙过程。在这个探索中，我们深入研究了将变量转换为较短数据类型的字节码指令，承认与精度损失和溢出风险相关的微妙挑战。现在，让我们来探讨这一组指令：
- en: '**Integer to byte** (**i2b**), **integer to short** (**i2s**), **integer to
    char** (**i2c**): Investigate the potential precision loss as integers transform
    into byte, short, and char types through **i2b**, **i2s**, and **i2c** instructions'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整型转换为字节型**（**i2b**）、**整型转换为短整型**（**i2s**）、**整型转换为字符型**（**i2c**）：研究通过**i2b**、**i2s**和**i2c**指令将整型转换为字节型、短整型和字符型时可能出现的精度损失'
- en: '**Long to integer** (**l2i**)**:** Examine the considerations involved in converting
    long to integer using the **l2i** instruction, acknowledging the possibility of
    overflow'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长整型转换为整型**（**l2i**）：考察使用**l2i**指令将长整型转换为整型时涉及的考虑因素，承认可能发生溢出的可能性'
- en: '**Float to integer** (**f2i**), **float to long** (**f2l**)**:** Uncover the
    challenges of converting float to integer and long through **f2i** and **f2l**,
    taking note of precision and overflow concerns'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浮点型转换为整型**（**f2i**）、**浮点型转换为长整型**（**f2l**）：揭示通过**f2i**和**f2l**将浮点型转换为整型和长整型时遇到的挑战，注意精度和溢出问题'
- en: '**Double to integer** (**d2i**), **double to long** (**d2l**), **double to
    float** (**d2f**)**:** Navigate through the **d2i**, **d2l**, and **d2f** instructions,
    understanding the delicate balance of precision and potential overflow in converting
    double to integer, long, and float'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双精度浮点型转换为整型**（**d2i**）、**双精度浮点型转换为长整型**（**d2l**）、**双精度浮点型转换为浮点型**（**d2f**）：通过**d2i**、**d2l**和**d2f**指令导航，了解将双精度浮点型转换为整型、长整型和浮点型时精度和潜在溢出的微妙平衡'
- en: In the realm of bytecode intricacies, the following best practices serve as
    a compass guiding us through practical considerations. Here, we bridge theory
    and application, exploring the tangible implications of bytecode instructions
    on real-world Java programming scenarios. From preserving precision in complex
    arithmetic operations to navigating the flexibility of object-oriented design,
    these practical considerations illuminate the significance of understanding and
    mastering bytecode in the development landscape.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在字节码的复杂性领域，以下最佳实践作为指南，引导我们通过实际考虑。在这里，我们连接理论和应用，探讨字节码指令对现实世界Java编程场景的实质性影响。从在复杂算术操作中保持精度到导航面向对象设计的灵活性，这些实际考虑照亮了理解和掌握字节码在开发领域中的重要性。
- en: '**Preserving precision in arithmetic:** Connect the dots between value conversions
    and arithmetic operations, ensuring precision is maintained in complex calculations'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持算术精度：**在值转换和算术操作之间建立联系，确保在复杂计算中保持精度'
- en: '**Handling object references:** Explore how value conversions contribute to
    the flexibility of object-oriented programming, allowing smooth transitions between
    classes and interfaces'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理对象引用：**探索值转换如何有助于面向对象编程的灵活性，允许在类和接口之间实现平滑过渡'
- en: As we decipher the bytecode instructions governing value conversions, the preceding
    points equip you with the insights needed to navigate the subtleties of transforming
    variable types within the JVM.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在解码控制值转换的字节码指令时，前面的观点为您提供了导航变量类型在JVM内部转换细微差别的见解。
- en: 'In the following illustrative Java code sample, we spotlight value conversions,
    explicitly focusing on conventions that transform variable types within the JVM.
    The code snippet demonstrates the subtle dance of promotions and considerations
    for precision loss or overflow. As we traverse the bytecode results, our attention
    remains steadfast on the instructions that bring these conventions to life:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例Java代码片段中，我们聚焦于值转换，明确关注在JVM内部转换变量类型的约定。代码片段展示了提升和考虑精度损失或溢出的微妙舞蹈。随着我们遍历字节码结果，我们的注意力始终集中在使这些约定得以实现的指令上：
- en: '[PRE5]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The results are displayed as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '[PRE6]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Save the provided Java code in a file named `ValueConversionsExample.java`.
    Open your terminal or command prompt and navigate to the directory where the file
    is saved. Then, use the following command to compile the code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 将提供的Java代码保存为名为`ValueConversionsExample.java`的文件。打开您的终端或命令提示符，导航到文件保存的目录。然后，使用以下命令编译代码：
- en: '[PRE7]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After compiling, you can use the `javap` command to disassemble the bytecode
    and display the relevant parts. Execute the following command in the terminal
    or command prompt:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，您可以使用`javap`命令反汇编字节码并显示相关部分。在终端或命令提示符中执行以下命令：
- en: '[PRE8]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this analysis, we focus on specific segments of bytecode to explore how Java
    code transforms into machine-executable instructions within the JVM. Our attention
    centers on selected bytecode parts, revealing the intricacies of promotions, precision
    considerations, and shortening in the realm of Java programming. Follow along
    as we decipher the language of the JVM, offering a visual narrative of the conventions
    that shape Java bytecode.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次分析中，我们专注于字节码的特定段，以探索Java代码如何在JVM内部转换为可执行指令。我们的注意力集中在选定的字节码部分，揭示了Java编程领域中提升、精度考虑和缩短的复杂性。随着我们解读JVM的语言，提供了一幅描绘塑造Java字节码约定的视觉叙事。
- en: '[PRE9]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this Java code, we witness both promotions and shortening conventions in
    action. The bytecode snippets focus specifically on the instructions associated
    with these conventions, providing a detailed look at how the JVM handles the enlargement
    and shortening of variable types.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段Java代码中，我们可以看到提升和缩短约定在实际中的应用。字节码片段专门关注与这些约定相关的指令，详细展示了JVM如何处理变量类型的扩展和缩短。
- en: In our exploration of value conversions within the JVM, we’ve dissected the
    bytecode instructions orchestrating promotions and considerations for precision
    loss or overflow. These intricacies underscore the nuanced dance of data types
    in Java programming. As we conclude this segment, the seamless translation of
    high-level code to bytecode becomes clearer, revealing the meticulous choreography
    of the JVM. In the next section, we shift our focus to the captivating realm of
    object manipulation within bytecode, unraveling the threads that weave the tapestry
    of Java’s object-oriented paradigm. In this forthcoming journey, we’ll scrutinize
    bytecode instructions that mold and maneuver through objects, delving into the
    heart of dynamic, versatile Java programming.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索JVM中的值转换时，我们剖析了字节码指令如何编排提升和考虑精度损失或溢出。这些复杂性凸显了Java编程中数据类型细微的舞蹈。随着本段的结束，将高级代码无缝转换为字节码的过程变得更加清晰，揭示了JVM的细致编排。在下一节中，我们将关注字节码中的对象操作领域，揭示编织Java面向对象范式的线索。在即将到来的旅程中，我们将审视塑造和操控对象的字节码指令，深入动态、多变的Java编程核心。
- en: Object manipulation
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象操作
- en: In this immersive session, we embark on a comprehensive exploration of object
    manipulation within the intricate fabric of Java bytecode. Our journey unveils
    the bytecode instructions instrumental in creating and manipulating instances,
    forging arrays, and accessing both static and instance attributes of a class.
    We scrutinize instructions that load values from arrays, save to the stack, inquire
    about array lengths, and perform crucial checks on instances or arrays. From the
    foundational `new` instruction to the dynamic intricacies of `multianewarray`,
    each bytecode command propels us deeper into the realm of object-oriented manipulation.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次沉浸式体验中，我们开始全面探索Java字节码复杂结构中的对象操作。我们的旅程揭示了创建和操作实例、构建数组和访问类静态和实例属性的关键字节码指令。我们审视了从数组中加载值、保存到栈上、查询数组长度以及对实例或数组执行关键检查的指令。从基础的`new`指令到`multianewarray`的动态复杂性，每条字节码指令都推动我们更深入地进入面向对象操作领域。
- en: In the bytecode tapestry of Java, the `new` instruction stands as a gateway
    to the realm of object creation and manipulation. It not only allocates memory
    for an object but also invokes its constructor, initiating the birth of a dynamic
    entity. Join us in this deep dive into the bytecode intricacies, where the seemingly
    simple `new` instruction unveils the foundational steps involved in bringing Java
    objects to life. As we dissect this bytecode command, the underlying symphony
    of memory allocation and constructor invocation becomes clearer, paving the way
    for a richer understanding of instance creation within the JVM.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java的字节码织锦中，`new`指令是通往对象创建和操作领域的门户。它不仅为对象分配内存，还调用其构造函数，启动动态实体的诞生。加入我们深入字节码复杂性的探索，看似简单的`new`指令揭示了将Java对象带入生命的根本步骤。随着我们对这条字节码指令的剖析，内存分配和构造函数调用的底层交响曲变得更加清晰，为在JVM中创建实例提供了更深入的理解。
- en: '**new**: This instantiates a new object, allocating memory and invoking the
    object’s constructor. The reference to the newly created object is placed on the
    stack.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**new**：创建一个新的对象，分配内存并调用对象的构造函数。新创建对象的引用放置在栈上。'
- en: Within the orchestration of Java bytecode, the commands for array creation emerge
    as a tapestry of versatility. In this segment, we delve into the bytecode instructions
    that sculpt arrays, offering a dynamic canvas for data storage. From the foundational
    `newarray` for primitive types to the nuanced `anewarray` for object references
    and the sophisticated `multianewarray` for multi-dimensional arrays, each bytecode
    instruction contributes to the vibrant array ecosystem within the JVM. As we dissect
    these commands, the artistry behind array instantiation within the JVM comes to
    light, opening the door to a deeper comprehension of data structure dynamics in
    Java programming.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java字节码的编排中，创建数组的命令呈现出一种多功能的织锦。在这一部分，我们深入探讨塑造数组的字节码指令，为数据存储提供了一个动态的画布。从为原始类型提供基础的`newarray`指令到为对象引用提供细微的`anewarray`指令，以及为多维数组提供的复杂`multianewarray`指令，每条字节码指令都为JVM内部的活跃数组生态系统做出了贡献。随着我们对这些命令的剖析，JVM内部数组实例化的艺术性逐渐显现，为深入理解Java编程中的数据结构动态打开了大门。
- en: '**newarray**: Creates a new array of primitive types'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**newarray**：创建一个新的原始类型数组'
- en: '**anewarray**: Creates a new array of object references'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**anewarray**：创建对象引用的新数组'
- en: '**multianewarray**: Creates a multi-dimensional array'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**multianewarray**：创建多维数组'
- en: In the intricate dance of Java bytecode, the instructions for accessing static
    or instance attributes of a class—`getfield`, `putfield`, `getstatic`, and `putstatic`—take
    center stage. From gracefully retrieving instance field values to dynamically
    setting static field values, each bytecode instruction contributes to the nuanced
    choreography of object-oriented programming. Join us in unraveling the elegance
    of bytecode access, where the delicate balance between instance and class attributes
    unfolds, revealing the underlying mechanisms that govern data manipulation within
    the JVM. As we dissect these instructions, the ballet of accessing class attributes
    comes alive, paving the way for a profound understanding of object-oriented intricacies
    in Java programming.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 字节码的复杂舞蹈中，访问类静态或实例属性的指令——`getfield`、`putfield`、`getstatic` 和 `putstatic`——占据了中心舞台。从优雅地检索实例字段值到动态设置静态字段值，每条字节码指令都为面向对象编程的微妙舞蹈做出了贡献。加入我们，一起揭开字节码访问的优雅之处，其中实例和类属性之间的微妙平衡展开，揭示了在
    JVM 中管理数据操作的底层机制。随着我们剖析这些指令，访问类属性的芭蕾舞生动起来，为深入理解 Java 编程中的面向对象复杂性铺平了道路。
- en: '**getfield**: Retrieves the value of an instance field from an object'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**getfield**：从对象中检索实例字段的值'
- en: '**putfield**: Sets the value of an instance field in an object'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**putfield**：设置对象中实例字段的值'
- en: '**getstatic**: Retrieves the value of a static field from a class'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**getstatic**：从类中检索静态字段的值'
- en: '**putstatic**: Sets the value of a static field in a class'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**putstatic**：在类中设置静态字段的值'
- en: In the bytecode symphony of Java, the loading instructions — `baload`, `caload`,
    `saload`, `iaload`, `laload`, `faload`, `daload`, and `aaload` — take center stage,
    defining the choreography for retrieving values from arrays. In this segment,
    we immerse ourselves in the rhythmic bytecode commands that gracefully bring array
    elements to the forefront. From extracting bytes and characters to loading integers,
    longs, floats, doubles, and object references, each instruction plays a crucial
    role in the harmonious interaction between arrays and the JVM. These loading instructions
    unveil the orchestrated ballet that unfolds as Java bytecode seamlessly navigates
    through arrays, showcasing the versatility and precision of array element retrieval.
    As we explore these loading commands, the intricate dance of loading values from
    arrays comes alive, providing a deeper insight into the fluid dynamics of Java
    programming.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 字节码交响曲中，加载指令——`baload`、`caload`、`saload`、`iaload`、`laload`、`faload`、`daload`
    和 `aaload`——占据了中心舞台，定义了从数组中检索值的舞蹈。在这一部分，我们沉浸在节奏感强烈的字节码命令中，优雅地将数组元素带到前台。从提取字节和字符到加载整数、长整型、浮点数、双精度数和对象引用，每条指令都在数组与
    JVM 之间和谐的交互中扮演着关键角色。这些加载指令揭示了 Java 字节码在数组中无缝导航时展开的精心编排的芭蕾舞，展示了数组元素检索的灵活性和精确性。随着我们探索这些加载命令，从数组中加载值的复杂舞蹈生动起来，为深入了解
    Java 编程的流体动力学提供了更深的洞察。
- en: 'In the bytecode masterpiece of Java, the saving instructions — `bastore`, `castore`,
    `sastore`, `iastore`, `lastore`, `fastore`, `dastore`, and `aastore` — intricately
    command the canvas of array manipulation. These instructions are pivotal for storing
    values into arrays of different types. Let’s delve into their significance with
    examples:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 字节码杰作中，保存指令——`bastore`、`castore`、`sastore`、`iastore`、`lastore`、`fastore`、`dastore`
    和 `aastore`——巧妙地指挥着数组操作的画布。这些指令对于将值存储到不同类型的数组中至关重要。让我们通过示例深入了解它们的重要性：
- en: '**bastore****:** Stores a byte or Boolean value into a byte array'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**bastore**：将字节或布尔值存储到字节数组中'
- en: '**castore****:** Stores a character value into a char array'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**castore**：将字符值存储到字符数组中'
- en: '**sastore****:** Stores a short value into a short array'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sastore**：将短值存储到短数组中'
- en: '**iastore****:** Stores an integer value into an int array'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iastore**：将整数值存储到整型数组中'
- en: '**lastore****:** Stores a long value into a long array'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**lastore**：将长值存储到长数组中'
- en: '**dastore****:** Stores a double value into a double array'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dastore**：将双精度值存储到双精度数组中'
- en: These instructions play a fundamental role in array manipulation, allowing for
    the precise storage of various data types within arrays.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令在数组操作中起着基本的作用，允许在数组中精确存储各种数据类型。
- en: 'The `arraylength` instruction serves as a compass in Java bytecode, guiding
    developers through the metrics of arrays by providing the length of the array:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`arraylength`指令在Java字节码中充当指南针，通过提供数组的长度来引导开发者了解数组的度量：'
- en: '**arraylength**: Retrieves the length of an array and pushes it onto the stack.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**arraylength**: 获取数组的长度并将其推入栈。'
- en: 'Within the realm of Java bytecode, the instructions `instanceof` and `checkcast`
    serve as vigilant guardians, ensuring the integrity of object types and their
    alignment with specified classes. While our earlier exploration delved into array
    manipulation, let’s now shift our focus to these instructions’ essential roles
    in type checking. `Instanceof` assesses whether an object belongs to a particular
    class, providing crucial insights into object types. On the other hand, `checkcast`
    meticulously scrutinizes and casts objects, ensuring their harmonious alignment
    with designated classes. Together, these bytecode guardians play pivotal roles
    in maintaining the robustness and coherence of object-oriented paradigms within
    the JVM:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java字节码的领域内，`instanceof`和`checkcast`指令充当着警惕的守护者，确保对象类型的完整性及其与指定类的对齐。虽然我们之前的探索深入到了数组操作，但现在让我们将焦点转移到这些指令在类型检查中的基本作用。`Instanceof`评估一个对象是否属于特定类，提供了关于对象类型的重要见解。另一方面，`checkcast`仔细检查并转换对象，确保它们与指定的类和谐对齐。这些字节码守护者共同在JVM中维护面向对象范式的健壮性和一致性中发挥着关键作用：
- en: '**instanceof**: Checks if an object is an instance of a particular class'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**instanceof**: 检查一个对象是否是特定类的实例'
- en: '**checkcast**: Checks and casts an object to a given class, ensuring type compatibility'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**checkcast**: 检查并将对象转换为指定的类，确保类型兼容性'
- en: These bytecode instructions provide the foundation for manipulating objects
    in Java, allowing for the creation, access, and modification of instances and
    arrays. Whether it’s instantiating new objects, working with arrays, accessing
    class attributes, or performing dynamic checks, each instruction contributes to
    the flexibility and power of object-oriented programming in Java bytecode. Understanding
    these instructions is key to mastering the intricacies of Java’s object manipulation
    capabilities.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字节码指令为在Java中操作对象提供了基础，允许创建、访问和修改实例和数组。无论是实例化新对象、处理数组、访问类属性还是执行动态检查，每条指令都为Java字节码中面向对象编程的灵活性和强大功能做出了贡献。理解这些指令是掌握Java对象操作复杂性的关键。
- en: '[PRE10]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Compile and display bytecode:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并显示字节码：
- en: '[PRE12]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s focus on relevant parts of the bytecode that correspond to object manipulation,
    including object creation (`new`), attribute access (`getfield`, `putfield`),
    and method invocation:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关注与对象操作相关的字节码的相关部分，包括对象创建（`new`）、属性访问（`getfield`、`putfield`）和方法调用：
- en: '[PRE13]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 代码：
- en: '[PRE14]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 代码：
- en: '[PRE15]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 代码：
- en: '[PRE16]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 代码：
- en: '[PRE17]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let’s break down the key bytecode instructions:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解关键的字节码指令：
- en: 'Object creation (**new**):'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象创建（**new**）：
- en: '**0: new #3**: Creates a new object of type **Person**'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**0: new #3**: 创建一个类型为**Person**的新对象'
- en: '**3: dup**: Duplicates the object reference on the stack'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3: dup**: 在栈上复制对象引用'
- en: '**4: ldc #4**: Pushes the constant string **"John"** onto the stack'
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**4: ldc #4**: 将常量字符串**"John"**推入栈'
- en: '**6: invokespecial #5**: Invokes the constructor (**<init>**) to initialize
    the object'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**6: invokespecial #5**: 调用构造函数（**<init>**）以初始化对象'
- en: 'Attribute access (**getfield, putfield**):'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性访问（**getfield, putfield**）：
- en: '**1: getfield #2**: Retrieves the value of the **name** field'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1: getfield #2**: 获取**name**字段的值'
- en: '**2: putfield #2**: Sets the value of the **name** field'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2: putfield #2**: 设置**name**字段的值'
- en: 'Method invocation:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法调用：
- en: '**22: invokevirtual #9**: Invokes the **getName** method'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**22: invokevirtual #9**: 调用**getName**方法'
- en: '**31: invokevirtual #11**: Invokes the **setName** method'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**31: invokevirtual #11**: 调用**setName**方法'
- en: These bytecode snippets highlight the fundamental instructions associated with
    object manipulation, offering insights into the dynamic nature of Java programming
    at the low-level bytecode level.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字节码片段突出了与对象操作相关的根本指令，揭示了Java在底层字节码级别的动态特性。
- en: In navigating the bytecode tapestry of object manipulation within the simplified
    `Person` class, we’ve uncovered the orchestration of instructions governing object
    creation, attribute access, and method invocation. As the bytecode symphony unfolds,
    we transition seamlessly to the next segment, where we will delve into the dynamic
    realm of method calls and returns. Join us in deciphering the bytecode instructions
    that underpin the essence of method invocation, shedding light on the intricacies
    that define the flow of program execution within the JVM. As we move forward,
    the exploration of method calls and returns promises to enrich our understanding
    of the bytecode symphony, unveiling the next layer of Java programming intricacies.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在导航简化版`Person`类中对象操作的字节码织锦时，我们发现了管理对象创建、属性访问和方法调用的指令编排。随着字节码交响乐的展开，我们无缝过渡到下一个部分，我们将深入探索方法调用和返回的动态领域。加入我们，解读支撑方法调用的本质的字节码指令，揭示定义JVM中程序执行流程的复杂性的细节。随着我们前进，对方法调用和返回的探索将丰富我们对字节码交响乐的理解，揭示Java编程复杂性的下一层。
- en: Method calls and returns
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法调用和返回
- en: Let us embark on a journey into the intricate dynamics of method calls and the
    nuanced return of values within the Java programming landscape. We will unveil
    the subtleties of dynamically invoking methods and agile invocation of interface
    methods and explore the distinctive chord of calling private or superclass methods
    and the powerful tone resonating from the invocation of static methods. Amidst
    this exploration, we will encounter the introduction of dynamic construction,
    showcasing the adaptability of Java programming. Remember the rhythm of value
    return is defined by specific instructions.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始一段旅程，深入探索Java编程领域中方法调用和值返回的复杂动态。我们将揭示动态调用方法和敏捷调用接口方法的微妙之处，并探讨调用私有或超类方法的独特和弦以及静态方法调用的强大音调。在这段探索中，我们将遇到动态构建的引入，展示了Java编程的适应性。记住，值返回的节奏由特定的指令定义。
- en: 'Exploring the symphony of method invocation in Java bytecode, the following
    instructions orchestrate various tones in the melody of method calls, each contributing
    uniquely to the language’s dynamic and versatile nature:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 探索Java字节码中方法调用的交响乐，以下指令在方法调用的旋律中演奏各种音调，每个都为语言的动态和多功能性做出了独特的贡献：
- en: '**invokevirtual:** Initiating the melody of method invocation, this instruction
    calls a method from an instance, providing the backbone for dynamic and polymorphic
    behavior in Java'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**invokevirtual:** 启动方法调用的旋律，这条指令从一个实例中调用方法，为Java中动态和多态行为提供支撑'
- en: '**invokeinterface:** Adding a harmonic note, this instruction calls a method
    from an interface, contributing to the flexibility and adaptability of Java’s
    object-oriented paradigm'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**invokeinterface:** 添加一个和谐的音符，这条指令从一个接口中调用方法，为Java面向对象范式的灵活性和适应性做出贡献'
- en: '**invokespecial:** Introducing a distinctive chord, this instruction calls
    a private or superclass method, encapsulating privileged method invocations'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**invokespecial:** 引入一个独特的和弦，这条指令调用一个私有或超类方法，封装了特权方法调用'
- en: '**invokestatic:** Striking a powerful tone, this instruction calls a static
    method, emphasizing the invocation of methods that don’t rely on instance creation'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**invokestatic:** 以强有力的音调，这条指令调用一个静态方法，强调了对不依赖于实例创建的方法的调用'
- en: '**invokedynamic:** Playing a versatile tune, this instruction constructs an
    object dynamically, showcasing the dynamic capabilities of Java’s method invocation'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**invokedynamic:** 这条指令演奏一曲多变的旋律，动态地构建一个对象，展示了Java方法调用的动态能力'
- en: The rhythm of method execution is complemented by return instructions (`ireturn`,
    `lreturn`, `freturn`, `dreturn`, and `areturn`), defining the cadence of values
    returned from methods. In the event of unexpected interruptions with exceptions,
    the `athrow` call takes center stage, managing the orchestration of error handling.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 方法执行节奏由返回指令（`ireturn`、`lreturn`、`freturn`、`dreturn` 和 `areturn`）补充，定义了从方法返回值的节奏。在异常中断的意外情况下，`athrow`
    调用成为焦点，管理错误处理的编排。
- en: 'We dive further into the intricacies of synchronous methods, where the monitor,
    marked by the `ACC_SYNCHRONIZED` flag, orchestrates a controlled dance. With the
    `monitorenter` instruction, the method enters the monitor, ensuring exclusive
    execution, and gracefully exits with `monitorexit` upon completion, crafting a
    synchronous symphony within the bytecode tapestry. Let’s now delve into a live
    demonstration of method calls and returns within Java code. The following is a
    simple Java program that performs calculations through method calls. We’ll then
    scrutinize the bytecode to decipher the orchestration of these method invocations:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进一步深入同步方法的复杂性，其中由 `ACC_SYNCHRONIZED` 标志标记的监视器，编排了一场受控的舞蹈。通过 `monitorenter`
    指令，方法进入监视器，确保独占执行，并在完成后优雅地通过 `monitorexit` 退出，在字节码织锦中编织出同步交响曲。现在，让我们深入一个 Java
    代码中方法调用和返回的现场演示。以下是一个简单的 Java 程序，通过方法调用执行计算。然后我们将仔细审查字节码，以解码这些方法调用的编排：
- en: '[PRE18]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Compile and display bytecode:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并显示字节码：
- en: '[PRE19]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the bytecode, we’ll focus on the instructions related to method calls (`invokevirtual`,
    `invokespecial`, `invokestatic`) and the return instructions (`ireturn`).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在字节码中，我们将关注与方法调用相关的指令（`invokevirtual`、`invokespecial`、`invokestatic`）以及返回指令（`ireturn`）。
- en: 'The following is a simplified excerpt compiled from `MethodCallsExample.java`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从 `MethodCallsExample.java` 编译的简化摘录：
- en: '[PRE20]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 代码：
- en: '[PRE21]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 代码：
- en: '[PRE22]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 代码：
- en: '[PRE23]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 代码：
- en: '[PRE24]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 代码：
- en: '[PRE25]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This bytecode excerpt showcases the essential instructions related to method
    calls and returns, providing a glimpse into the bytecode symphony of the provided
    Java code.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这段字节码摘录展示了与方法和返回相关的基本指令，为提供的 Java 代码的字节码交响曲提供了一瞥。
- en: As we draw the curtains on our exploration of method calls and returns within
    the Java bytecode, we’ve uncovered the intricate dance of instructions orchestrating
    the flow of our program. The symphony of `invokevirtual`, `invokeinterface`, `invokespecial`,
    and `invokestatic` has echoed through our bytecode tapestry, showcasing the dynamic
    nature of method invocation and the rhythmic return of values. As we pivot to
    the next section, the spotlight shifts to conditional instructions, where bytecode
    decisions shape the course of program execution. Join us in decoding the bytecode
    intricacies of conditional statements, unraveling the logic that guides the JVM
    through pathways defined by conditions, and in our continuous journey through
    the depths of Java programming intricacies.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们关闭对 Java 字节码中方法和返回探索的帷幕时，我们揭示了指令如何编排程序流程的复杂舞蹈。`invokevirtual`、`invokeinterface`、`invokespecial`
    和 `invokestatic` 的交响曲在我们的字节码织锦中回响，展示了方法调用的动态性质和值的规律性返回。当我们转向下一节时，聚光灯转向条件指令，字节码决策塑造了程序执行的路径。加入我们解码条件语句的字节码复杂性，揭示引导
    JVM 通过由条件定义的路径的逻辑，并继续我们深入 Java 编程复杂性的旅程。
- en: Conditional instructions
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件指令
- en: In this section, we delve into the nuanced realm of conditional instructions,
    unraveling the intricacies of decision-making within the JVM. These instructions
    form the backbone of conditional statements, guiding the JVM through pathways
    dictated by Boolean outcomes. Join us as we decipher the bytecode intricacies
    of conditional instructions, unveiling the logic that dynamically shapes program
    flow within the JVM. This exploration provides insights into the fundamental principles
    that govern the execution of conditional statements in Java programming.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们深入探讨条件指令的微妙领域，揭示 JVM 内部决策的复杂性。这些指令构成了条件语句的骨架，引导 JVM 通过由布尔结果指定的路径。随着我们解码条件指令的字节码复杂性，揭示动态塑造
    JVM 内部程序流程的逻辑，让我们一起来探索。
- en: Navigating the realm of Java bytecode unveils a set of instructions that intricately
    control conditional logic within the JVM. These commands stand as the architects
    of conditional statements, orchestrating precise decision-making and influencing
    program flow based on Boolean outcomes. This exploration peels back the layers
    of bytecode intricacies, offering insights into the dynamic pathways shaped by
    these fundamental instructions within the JVM.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 探索 Java 字节码的领域，揭示了在 JVM 内部控制条件逻辑的一系列指令。这些指令作为条件语句的建筑师，精确地执行决策并基于布尔结果影响程序流程。这次探索揭开了字节码复杂性的层层面纱，提供了关于
    JVM 内部由这些基本指令塑造的动态路径的见解。
- en: 'Let’s explore a set of bytecode instructions that wield unique powers to control
    program flow and decision-making in Java. These instructions encompass a range
    of conditions, switches, and jumps, each playing a distinct role in directing
    the execution path of a Java program:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一组具有独特控制程序流程和决策能力的字节码指令。这些指令包括一系列条件、switch和跳转，每个都在指导Java程序执行路径中扮演着独特的角色：
- en: '**ifeq:** Branches to the target instruction if the top value on the stack
    is equal to 0'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ifeq:** 如果栈顶的值等于0，则跳转到目标指令'
- en: '**ifne:** Branches to the target instruction if the top value on the stack
    is not equal to 0'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ifne:** 如果栈顶的值不等于0，则跳转到目标指令'
- en: '**iflt:** Branches to the target instruction if the top value on the stack
    is less than 0'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iflt:** 如果栈顶的值小于0，则跳转到目标指令'
- en: '**ifle:** Branches to the target instruction if the top value on the stack
    is less than or equal to 0'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ifle:** 如果栈顶的值小于或等于0，则跳转到目标指令'
- en: '**ifgt:** Branches to the target instruction if the top value on the stack
    is greater than 0'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ifgt:** 如果栈顶的值大于0，则跳转到目标指令'
- en: '**ifge:** Branches to the target instruction if the top value on the stack
    is greater than or equal to 0'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ifge:** 如果栈顶的值大于或等于0，则跳转到目标指令'
- en: '**ifnull:** Branches to the target instruction if the top value on the stack
    is null'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ifnull:** 如果栈顶的值是null，则跳转到目标指令'
- en: '**ifnonnull:** Branches to the target instruction if the top value on the stack
    is not null'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ifnonnull:** 如果栈顶的值不是null，则跳转到目标指令'
- en: '**if_icmpeq:** Branches to the target instruction if the two integer values
    on the stack are equal'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**if_icmpeq:** 如果栈上的两个整数值相等，则跳转到目标指令'
- en: '**if_icmpne:** Branches to the target instruction if the two integer values
    on the stack are not equal'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**if_icmpne:** 如果栈上的两个整数值不相等，则跳转到目标指令'
- en: '**if_icmplt:** Branches to the target instruction if the second integer value
    on the stack is less than the first'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**if_icmplt:** 如果栈上的第二个整数值小于第一个，则跳转到目标指令'
- en: '**if_icmple:** Branches to the target instruction if the second integer value
    on the stack is less than or equal to the first'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**if_icmple:** 如果栈上的第二个整数值小于或等于第一个，则跳转到目标指令'
- en: '**if_icmpgt:** Branches to the target instruction if the second integer value
    on the stack is greater than the first'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**if_icmpgt:** 如果栈上的第二个整数值大于第一个，则跳转到目标指令'
- en: '**if_icmpge:** Branches to the target instruction if the second integer value
    on the stack is greater than or equal to the first'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**if_icmpge:** 如果栈上的第二个整数值大于或等于第一个，则跳转到目标指令'
- en: '**if_acmpeq:** Branches to the target instruction if the two object references
    on the stack are equal'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**if_acmpeq:** 如果栈上的两个对象引用相等，则跳转到目标指令'
- en: '**if_acmpne:** Branches to the target instruction if the two object references
    on the stack are not equal'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**if_acmpne:** 如果栈上的两个对象引用不相等，则跳转到目标指令'
- en: '**tableswitch:** Provides a more efficient way to implement a switch statement
    with consecutive integer cases'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tableswitch:** 提供了一种更有效的方法来实现具有连续整数情况的switch语句'
- en: '**lookupswitch:** Similar to **tableswitch**, but supports sparse case values'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**lookupswitch:** 与**tableswitch**类似，但支持稀疏的case值'
- en: '**goto:** Unconditionally branches to the target instruction'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**goto:** 无条件地跳转到目标指令'
- en: '**goto_w:** Unconditionally branches to the target instruction (wide index)'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**goto_w:** 无条件地跳转到目标指令（宽索引）'
- en: '**jsr:** Jumps to a subroutine, saving the return address on the stack'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**jsr:** 跳转到子程序，并将返回地址保存在栈上'
- en: '**jsr_w:** Jumps to a subroutine (wide index), saving the return address on
    the stack'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**jsr_w:** 跳转到子程序（宽索引），并将返回地址保存在栈上'
- en: '**ret:** Returns from a subroutine, using the return address saved by a previous
    **jsr** instruction'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ret:** 使用之前**jsr**指令保存的返回地址从子程序返回'
- en: These instructions play a crucial role in constructing conditional statements
    and controlling the flow of program execution based on various conditions and
    comparisons. Understanding their behavior is key to deciphering and optimizing
    Java bytecode.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令在构建条件语句和控制程序执行流程方面起着至关重要的作用。理解它们的行为对于解析和优化Java字节码至关重要。
- en: '[PRE26]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Compile and display bytecode:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并显示字节码：
- en: '[PRE28]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the bytecode, we’ll focus on conditional instructions, such as `ifeq`, `ifne`,
    and `if_acmpeq`, which handle the branching based on equality conditions. The
    following is a simplified excerpt:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在字节码中，我们将关注条件指令，如`ifeq`、`ifne`和`if_acmpeq`，它们根据相等条件处理分支。以下是一个简化的摘录：
- en: Compiled from `ConditionalExample.java`
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 编译自 `ConditionalExample.java`
- en: '[PRE29]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Code:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 代码：
- en: '[PRE30]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This bytecode excerpt showcases the conditional instructions (`if_icmpne` and
    `if_acmpeq`) in action, directing the program flow based on the equality conditions
    specified in the Java code.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这段字节码摘录展示了条件指令（`if_icmpne` 和 `if_acmpeq`）的实际应用，根据 Java 代码中指定的相等条件来指导程序流程。
- en: In this exploration of Java bytecode, we’ve deciphered the intricate dance of
    conditional instructions that shape the logic within the JVM. From branching based
    on equality to unconditional jumps, these bytecode commands have guided decision-making
    processes. As we conclude this section on *Conditional instructions*, the horizon
    broadens, leading us to the next leg of our journey. The upcoming segment delves
    into the bytecode representation of entire classes, unraveling the layers of instructions
    that encapsulate the essence of Java programs. Join us in this transition, where
    the focus expands from isolated conditions to the holistic view of classes in
    bytecode, illuminating the inner workings of Java’s runtime environment.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次对 Java 字节码的探索中，我们解码了构成 JVM 内部逻辑的复杂条件指令的舞蹈。从基于相等的分支到无条件跳转，这些字节码命令指导了决策过程。随着我们结束关于
    *条件指令* 的这一部分，视野变得更加开阔，引领我们进入旅程的下一阶段。接下来的部分深入到整个类的字节码表示，揭示封装 Java 程序本质的指令层。加入我们在这个过渡中，关注点从孤立的条件扩展到字节码中类的整体视图，照亮
    Java 运行时环境的内部工作原理。
- en: Show me the bytecode
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展示我字节码
- en: As our exploration of Java bytecode continues, we now set our sights on the
    entire class, a comprehensive dive into the binary representation of Java programs.
    It’s worth noting that the bytecode we examine may vary depending on the JVM version
    and the specific JVM vendor. In this session, we unravel the intricacies of compiling
    and examining the bytecode that encapsulates the essence of a complete Java class.
    From class initialization to method implementations, every facet of the class
    manifests in bytecode. Together, let us lift the veil on the holistic view of
    Java programs, exploring the nuances of how our code transforms into a language
    understood by the JVM.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续探索 Java 字节码，我们现在将目光投向整个类，这是一次对 Java 程序二进制表示的全面深入研究。值得注意的是，我们检查的字节码可能因
    JVM 版本和特定 JVM 供应商而异。在本节中，我们揭示编译和检查封装完整 Java 类本质的字节码的复杂性。从类初始化到方法实现，类的每个方面都在字节码中体现出来。让我们共同揭开
    Java 程序的整体视图，探索我们的代码如何转换成 JVM 理解的语言。
- en: 'In our journey through Java bytecode, let’s begin by crafting a simple yet
    versatile `Animal` class. The following is the Java code snippet that defines
    the class:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索 Java 字节码的旅程中，让我们首先制作一个简单而通用的 `Animal` 类。以下定义该类的 Java 代码片段：
- en: '[PRE31]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, let’s navigate through the process of compiling and peering into the bytecode:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们导航编译过程并深入了解字节码：
- en: '[PRE32]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With this, we embark on a fascinating exploration, compiling our Java class
    and unveiling the intricacies of bytecode that lie beneath the surface. Join us
    as we decode the language of the JVM and illuminate the bytecode representation
    of our `Animal` class.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就开始了这次迷人的探索，编译我们的 Java 类，揭示表面下的字节码复杂性。加入我们，解码 JVM 的语言，并照亮我们的 `Animal`
    类的字节码表示。
- en: 'This section of the bytecode output provides metadata about the compiled class
    file. Let’s break down the key information:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分字节码输出提供了关于编译后的类文件的元数据。让我们分析关键信息：
- en: '[PRE33]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**Last modified****:** Indicates the date of the last modification to the class
    file; in this case, it’s **November** **16, 2023**.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最后修改**：表示对类文件的最后修改日期；在本例中是 **2023 年 11 月 16 日**。'
- en: '**Size****:** Specifies the size of the class file in bytes, which is **433**
    bytes in this instance.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大小**：指定类文件的字节数，本例中为 **433** 字节。'
- en: '**SHA-256 checksum****:** Represents the SHA-256 checksum of the class file.
    This **checksum** serves as a unique identifier for the file and ensures its integrity.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SHA-256 校验和**：代表类文件的 SHA-256 校验和。这个 **校验和** 作为文件的唯一标识符，并确保其完整性。'
- en: '**Compiled from "Animal.java"****:** Informs us that this bytecode is compiled
    from the source file **Animal.java**.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从 "Animal.java" 编译**：告知我们此字节码是从源文件 **Animal.java** 编译的。'
- en: '**Class declaration****:** Declares the class named **Animal**.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类声明**：声明名为 **Animal** 的类。'
- en: '**Version information****:**'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本信息**：'
- en: '**minor version**: Set to 0.'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**次要版本**：设置为 0。'
- en: '**major version**: Set to 65, indicating compatibility with Java 11.'
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主要版本**：设置为 65，表示与 Java 11 兼容。'
- en: '**Flags****:** Displays hexadecimal flags indicating the access control modifiers
    applied to the class. In this case, it is a public class (**ACC_PUBLIC**) with
    additional properties (**ACC_SUPER**).'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Flags****:** 显示表示应用于类的访问控制修饰符的十六进制标志。在这种情况下，它是一个公开类（**ACC_PUBLIC**）并具有附加属性（**ACC_SUPER**）。'
- en: '**Class hierarchy:**'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Class hierarchy:**'
- en: '**this_class**: Points to the constant pool index (**#8**) representing the
    current class, which is **Animal**.'
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**this_class**: 指向常量池索引（**#8**）表示当前类，即**Animal**。'
- en: '**super_class**: Points to the constant pool index (**#2**) representing the
    superclass, which is **java/lang/Object**.'
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**super_class**: 指向常量池索引（**#2**）表示超类，即**java/lang/Object**。'
- en: '**Interfaces, fields, methods, and attributes****:** Provides counts for these
    elements in the class.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Interfaces, fields, methods, and attributes****:** 提供了这些元素在类中的计数。'
- en: This metadata offers a snapshot of the class file’s properties, including its
    version, access modifiers, and structural details.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这条元数据提供了类文件属性的快照，包括其版本、访问修饰符和结构细节。
- en: 'The `Constant pool` section in the bytecode output provides a glimpse into
    the constant pool, a table of structures used to store various constants, such
    as strings, method and field references, class names, and more. Let’s decipher
    the entries in this constant pool:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 字节码输出的`Constant pool`部分提供了对常量池的洞察，常量池是一个用于存储各种常量的结构表，例如字符串、方法和方法引用、类名等。让我们解析这个常量池中的条目：
- en: '[PRE34]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will show field points here:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示字段引用位置：
- en: 'Method reference to **Object**’s constructor:'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对**Object**类的构造函数的引用：
- en: '**#1 = Methodref #2.#3 //** **java/lang/Object."<init>":()V**'
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**#1 = Methodref #2.#3 //** **java/lang/Object."<init>":()V**'
- en: This entry references the constructor of the **java/lang/Object** class, denoted
    as **<init>**. It indicates the initialization method that every class implicitly
    inherits from the **Object** class.
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此条目引用了**java/lang/Object**类的构造函数，表示为**<init>**。它表示每个类从**Object**类隐式继承的初始化方法。
- en: 'Class reference to **Object** class:'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Object**类的类引用：'
- en: '**#2 = Class #4 //** **java/lang/Object**'
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**#2 = Class #4 //** **java/lang/Object**'
- en: Points to the class reference for **java/lang/Object**, indicating that the
    **Animal** class extends **Object**.
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向**java/lang/Object**类的类引用，表示**Animal**类扩展了**Object**。
- en: 'Name and type for **Object**’s constructor:'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Object**类的构造函数的名称和类型：'
- en: '**#3 = NameAndType #5:#6 // "<****init>":()V**'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**#3 = NameAndType #5:#6 // "<****init>":()V**'
- en: Specifies the name and type of the constructor (**<init>**) with no parameters
    and returns void.
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定无参数且返回void的构造函数（**<init>**）的名称和类型。
- en: 'UTF-8 entry for **Object** class name:'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Object**类名称的UTF-8条目：'
- en: '**#4 =** **UTF-8 java/lang/Object**'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**#4 =** **UTF-8 java/lang/Object**'
- en: Represents the name of the **java/lang/Object** class in UTF-8 encoding.
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示**java/lang/Object**类名称的UTF-8编码。
- en: 'UTF-8 entries for constructor and parameter type:'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数和参数类型的UTF-8条目：
- en: '**#5 =** **UTF-8 <init>**'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**#5 =** **UTF-8 <init>**'
- en: '**#6 =** **UTF-8 ()V**'
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**#6 =** **UTF-8 ()V**'
- en: Denotes the constructor’s name (**<init>**) and its type (no parameters and
    returning void) in UTF-8 encoding.
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示构造函数的名称（**<init>**）及其类型（无参数且返回void）的UTF-8编码。
- en: 'Field reference to **Animal**’s **name** field:'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对**Animal**类的**name**字段的字段引用：
- en: '**#7 = Fieldref #8.#9 //** **Animal.name:Ljava/lang/String;**'
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**#7 = Fieldref #8.#9 //** **Animal.name:Ljava/lang/String;**'
- en: Refers to the **name** field in the **Animal** class, which is of type **java/lang/String**.
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向**Animal**类中的**name**字段，其类型为**java/lang/String**。
- en: 'Class reference to **Animal** class:'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Animal**类的类引用：'
- en: '**#8 = Class #10 //** **Animal**'
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**#8 = Class #10 //** **Animal**'
- en: Points to the class reference for the **Animal** class.
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向**Animal**类的类引用。
- en: 'Name and type for the **name** field:'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**name**字段的名称和类型：'
- en: '**#9 = NameAndType #11:#12 //** **name:Ljava/lang/String;**'
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**#9 = NameAndType #11:#12 //** **name:Ljava/lang/String;**'
- en: 'Specifies the name and type of the **name** field: its name (**name**) and
    type (**String**).'
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定**name**字段的名称和类型：其名称（**name**）和类型（String）。
- en: 'UTF-8 entry for **Animal** class name:'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Animal**类名称的UTF-8条目：'
- en: '**#10 =** **UTF-8 Animal**'
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**#10 =** **UTF-8 Animal**'
- en: Represents the name of the **Animal** class in UTF-8 encoding.
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示**Animal**类名称的UTF-8编码。
- en: 'UTF-8 entries for the **name** field:'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**name**字段的UTF-8条目：'
- en: '**#11 =** **UTF-8 name**'
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**#11 =** **UTF-8 name**'
- en: '**#12 =** **UTF-8 Ljava/lang/String;**'
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**#12 =** **UTF-8 Ljava/lang/String;**'
- en: Denote the name of the **name** field and its type (**String**) in UTF-8 encoding.
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示**name**字段的名称及其类型（String）的UTF-8编码。
- en: Similar entries exist for the `age` field and `bark` method, referencing field
    and method names, their types, and class names in the constant pool. Overall,
    the constant pool is a crucial component for resolving symbolic references during
    the execution of the bytecode.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `age` 字段和 `bark` 方法，存在类似的条目，引用了字段和方法名称、它们的类型以及常量池中的类名。总的来说，常量池是字节码执行期间解析符号引用的关键组件。
- en: 'The bytecode snippets provided represent the methods within the `Animal` class.
    Let’s break down each method:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的字节码片段代表了 `Animal` 类中的方法。让我们逐一分析每个方法：
- en: 'Constructor method (**public Animal();**):'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '构造方法（**public Animal();**）:'
- en: '**Descriptor**: **()V** (no parameters, returns void)'
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述符**: **()V**（无参数，返回 void）'
- en: '**Flags**: **ACC_PUBLIC** (public method)'
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标志**: **ACC_PUBLIC**（公共方法）'
- en: '**Code**:'
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码**:'
- en: '[PRE35]'
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This constructor initializes the `Animal` object by invoking the constructor
    of its superclass (`Object`). The `aload_0` instruction loads the object reference
    (`this`) onto the stack, and `invokespecial` invokes the superclass constructor.
    The `LineNumberTable` indicates that this code corresponds to line `1` in the
    source file.
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此构造函数通过调用其超类（`Object`）的构造函数来初始化 `Animal` 对象。`aload_0` 指令将对象引用（`this`）加载到栈上，`invokespecial`
    调用超类构造函数。`LineNumberTable` 指示此代码对应源文件中的第 `1` 行。
- en: 'Method **public** **java.lang.String name();**:'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '方法 **public** **java.lang.String name();**:'
- en: '**Descriptor**: **()Ljava/lang/String;** (no parameters, returns **String**)'
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述符**: **()Ljava/lang/String;**（无参数，返回 **String**）'
- en: '**Flags**: **ACC_PUBLIC** (public method)'
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标志**: **ACC_PUBLIC**（公共方法）'
- en: '**Code**:'
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码**:'
- en: '[PRE36]'
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The method `name()` retrieves the value of the `name` field and returns it.
    `aload_0` loads the object reference (`this`), and `getfield` fetches the value
    of the `name` field. The `LineNumberTable` indicates that this code corresponds
    to line `9` in the source file.
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 方法 `name()` 获取 `name` 字段的值并返回它。`aload_0` 加载对象引用（`this`），`getfield` 获取 `name`
    字段的值。`LineNumberTable` 指示此代码对应源文件中的第 `9` 行。
- en: 'Method **public** **int age();**:'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '方法 **public** **int age();**:'
- en: '**Descriptor**: **()I** (no parameters, returns int)'
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述符**: **()I**（无参数，返回 int）'
- en: '**Flags**: **ACC_PUBLIC** (public method)'
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标志**: **ACC_PUBLIC**（公共方法）'
- en: '**Code**:'
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码**:'
- en: '[PRE37]'
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Similar to the `name` method, this retrieves the value of the `age` field and
    returns it. `getfield` fetches the value, and `ireturn` returns it. The `LineNumberTable`
    indicates that this code corresponds to line `13` in the source file.
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与 `name` 方法类似，它检索 `age` 字段的值并返回它。`getfield` 获取值，`ireturn` 返回它。`LineNumberTable`
    指示此代码对应源文件中的第 `13` 行。
- en: 'Method **public** **java.lang.String bark();**:'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '方法 **public** **java.lang.String bark();**:'
- en: '**Descriptor**: **()Ljava/lang/String;** (no parameters, returns **String**)'
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述符**: **()Ljava/lang/String;**（无参数，返回 **String**）'
- en: '**Flags**: **ACC_PUBLIC** (public method)'
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标志**: **ACC_PUBLIC**（公共方法）'
- en: '**Code**:'
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码**:'
- en: '[PRE38]'
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `bark()` method directly returns the string `woof` without accessing any
    fields. `ldc` loads a constant string and `areturn` returns it. The `LineNumberTable`
    indicates that this code corresponds to line `17` in the source file.
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`bark()` 方法直接返回字符串 `woof`，而不访问任何字段。`ldc` 加载一个常量字符串，`areturn` 返回它。`LineNumberTable`
    指示此代码对应源文件中的第 `17` 行。'
- en: These bytecode snippets encapsulate the logic of each method within the `Animal`
    class, showcasing the low-level operations performed during method execution.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字节码片段封装了 `Animal` 类中每个方法的逻辑，展示了方法执行期间的低级操作。
- en: 'In Java bytecode, each variable and method parameter is assigned a type descriptor
    to indicate its data type. These descriptors are compact representations used
    to convey information about the variable type or parameter. Here’s a detailed
    explanation:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 字节码中，每个变量和方法参数都被分配一个类型描述符，以指示其数据类型。这些描述符是用于传达变量类型或参数信息的紧凑表示。以下是一个详细说明：
- en: '**B** (**byte**): Represents a signed 8-bit integer'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**B**（**byte**）：表示一个有符号的 8 位整数'
- en: '**C** (**char**): Denotes a Unicode character'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C**（**char**）：表示一个 Unicode 字符'
- en: '**D** (**double**): Stands for a double-precision floating-point value'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**（**double**）：表示双精度浮点值'
- en: '**F** (**float**): Represents a single-precision floating point value'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**F**（**float**）：表示单精度浮点值'
- en: '**I** (**int**): Denotes a 32-bit integer'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**（**int**）：表示一个 32 位整数'
- en: '**J** (**long**): Represents a 64-bit long integer'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**J**（**long**）：表示一个 64 位长整数'
- en: '**L Classname** (**reference**): Points to an instance of the specified class;
    the fully qualified class name follows the **L** and ends with a semicolon'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L Classname**（**引用**）：指向指定类的实例；完全限定类名跟在 **L** 后面，并以分号结尾'
- en: '**S** (**short**): Represents a 16-bit short integer'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S** (**short**): 表示一个16位的短整数'
- en: '**Z** (**Boolean**): Indicates a Boolean value (true or false)'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Z** (**Boolean**): 表示一个布尔值（true或false）'
- en: '**[** (**array reference**): Denotes an array. The type of the array elements
    is determined by additional characters following the **[**'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[** (**数组引用**): 表示一个数组。数组元素的类型由**[**后面的附加字符确定'
- en: 'For array references:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数组引用：
- en: '**[L Classname**: Represents an array of objects of the specified class'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[L Classname**: 表示指定类的对象数组'
- en: '**[[B**: Represents a two-dimensional array of bytes'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[[B**: 表示一个字节数组的二维数组'
- en: These type descriptors are crucial when examining the bytecode instructions
    related to method declarations, field definitions, and variable usage within Java
    classes. They enable a concise representation of data types in the low-level bytecode
    representation of Java programs.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型描述符在检查与Java类中的方法声明、字段定义和变量使用相关的字节码指令时至关重要。它们使得在Java程序的低级字节码表示中简洁地表示数据类型成为可能。
- en: Summary
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As we conclude our exploration of Java bytecode and its intricate conditional
    instructions, readers have acquired a solid understanding of the nuanced control
    flow within Java programs. Armed with knowledge about bytecode’s decision-making
    capabilities, readers are well-equipped to optimize their code for efficiency
    and precision. The journey now propels us into the heart of the JVM with a focus
    on the execution engine in the upcoming chapter. Readers can anticipate delving
    into the mechanics of bytecode interpretation and the transformative realm of
    **just-in-time** (**JIT**) compilation. These skills are invaluable in real-life
    workplaces, where optimizing Java applications for performance is a critical task.
    Join us in unraveling the secrets of the JVM’s Execution Engine, where the binary
    dance of bytecode evolves into optimized machine instructions, empowering readers
    to enhance the runtime magic of Java applications.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们结束对Java字节码及其复杂条件指令的探索，读者已经对Java程序中的细微控制流有了坚实的理解。凭借对字节码决策能力的了解，读者已经为优化代码以实现效率和精度做好了准备。现在，我们的旅程将我们带入JVM的核心，重点关注即将到来的章节中的执行引擎。读者可以期待深入了解字节码解释的机制和**即时编译**（**JIT**）的变革领域。这些技能在现实生活中的工作场所中非常有价值，因为在性能上优化Java应用程序是一项关键任务。加入我们，揭开JVM执行引擎的秘密，在那里，字节码的二进制舞蹈演变为优化的机器指令，赋予读者增强Java应用程序运行时魔力的能力。
- en: Questions
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章知识的掌握：
- en: Which bytecode instruction is used to compare if two integers are equal and
    branch accordingly?
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个字节码指令用于比较两个整数是否相等，并相应地分支？
- en: '**ifeq**'
  id: totrans-374
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**ifeq**'
- en: '**if_icmpeq**'
  id: totrans-375
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**if_icmpeq**'
- en: '**if_acmpeq**'
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**if_acmpeq**'
- en: '**tableswitch**'
  id: totrans-377
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**tableswitch**'
- en: What does the bytecode instruction **ifeq** do?
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字节码指令**ifeq**做什么？
- en: Branches if the top value on the stack is equal to 0
  id: totrans-379
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果栈顶的值等于0，则分支
- en: Branches if two integers on the stack are equal
  id: totrans-380
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果栈上的两个整数相等，则分支
- en: Jumps to a subroutine
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳转到子程序
- en: Loads an integer from an array
  id: totrans-382
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数组中加载一个整数
- en: Which bytecode instruction is used for unconditional branching?
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于无条件分支的字节码指令是什么？
- en: '**goto**'
  id: totrans-384
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**goto**'
- en: '**ifne**'
  id: totrans-385
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**ifne**'
- en: '**jsr_w**'
  id: totrans-386
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**jsr_w**'
- en: '**lookupswitch**'
  id: totrans-387
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**lookupswitch**'
- en: In Java bytecode, what does the **jsr** instruction do?
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Java字节码中，**jsr**指令做什么？
- en: Jumps to a subroutine
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳转到子程序
- en: Calls a static method
  id: totrans-390
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用一个静态方法
- en: Compares two doubles
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较两个双精度浮点数
- en: Branches if the top value on the stack is null
  id: totrans-392
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果栈顶的值是null，则分支
- en: Which bytecode instruction is used to check if two object references are not
    equal and branches to the target instruction?
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个字节码指令用于检查两个对象引用是否不相等，并跳转到目标指令？
- en: '**if_acmpeq**'
  id: totrans-394
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**if_acmpeq**'
- en: '**if_acmpne**'
  id: totrans-395
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**if_acmpne**'
- en: '**ifnull**'
  id: totrans-396
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**ifnull**'
- en: '**goto_w**'
  id: totrans-397
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**goto_w**'
- en: Answers
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Here are the answers to this chapter’s questions:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是本章问题的答案：
- en: B. **if_icmpeq**
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B. **if_icmpeq**
- en: A. Branches if the top value on the stack is equal to 0
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A. 如果栈顶的值等于0，则分支
- en: A. **goto**
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A. **goto**
- en: A. Jumps to a subroutine
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A. 跳转到子程序
- en: B. **if_acmpne**
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B. **if_acmpne**
