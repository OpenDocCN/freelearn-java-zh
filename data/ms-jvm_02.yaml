- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Introduction to the Java Virtual Machine
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java虚拟机简介
- en: In the ever-expanding software development universe, Java is a shining star
    known for its versatility, cross-platform capabilities, and robust performance.
    At the heart of Java’s exceptional capabilities lies the **Java Virtual Machine**
    (**JVM**), a sophisticated technology that serves as the backbone of the Java
    ecosystem. In this chapter, we embark on an enlightening journey to demystify
    the inner workings of the JVM, delving deep into its internals to unveil the secrets
    of its operation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在不断扩大的软件开发宇宙中，Java以其多功能性、跨平台能力和强大性能而闻名。Java卓越能力的心脏是其**Java虚拟机**（**JVM**），这是一种复杂的技术，是Java生态系统的支柱。在本章中，我们将开始一段启迪人心的旅程，揭开JVM内部运作的秘密，深入其内部以揭示其操作的奥秘。
- en: In this chapter, we will delve deeper into the historical evolution of the JVM,
    explore its architecture, and understand its role in executing Java applications.
    Furthermore, we’ll cover essential topics, such as bytecode, class loading, memory
    management, and the execution engine, which form the foundation of the JVM’s functioning.
    By the end of this chapter, you will possess the foundational knowledge needed
    to unravel the intricate inner workings of the JVM. So, let’s begin our exploration
    of this marvel of technology as we journey into the heart of the JVM.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地探讨JVM的历史演变，了解其架构，并理解其在执行Java应用程序中的作用。此外，我们还将涵盖诸如字节码、类加载、内存管理和执行引擎等基本主题，这些主题构成了JVM运作的基础。到本章结束时，你将拥有解开JVM复杂内部运作所需的基础知识。因此，让我们开始探索这个技术奇迹的旅程，深入JVM的核心。
- en: 'In this chapter, we’ll explore more about those topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨更多关于以下主题：
- en: A brief history of Java
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java简史
- en: Introduction to the JVM
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM简介
- en: How the JVM works
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM是如何工作的
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter’s GitHub repository, found at - [https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-01](https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-01)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的GitHub仓库位于 - [https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-01](https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-01)
- en: Exploring the evolution of Java
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Java的演变
- en: The Java programming language, along with its robust platform, has a storied
    history characterized by its unique and innovative features. A central figure
    in this narrative is the JVM, a crucial component that has left an indelible mark
    on Java’s evolution and enduring significance. The JVM plays a pivotal role in
    making Java what it is today, and its importance to Java’s history cannot be overstated.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Java编程语言及其强大的平台有着一段充满传奇色彩的历史，其独特和创新的特点是其核心。在这个故事中，JVM是一个关键组成部分，对Java的演变和持久重要性留下了不可磨灭的印记。JVM在使Java成为今天的样子中扮演了至关重要的角色，其对Java历史的贡献不容小觑。
- en: The JVM is the linchpin that enables Java’s *Write Once, Run Anywhere* promise
    to become a reality. This promise, which redefined software development, directly
    responded to the challenges of creating software for networked consumer devices
    such as set-top boxes, routers, and other multimedia devices. By design, the JVM
    allows compiled Java code to be transported across networks, operate seamlessly
    on various client machines, and provide safety assurance. The JVM’s architecture
    and execution model ensures that Java programs behave consistently, regardless
    of their origin or the host machine they run on. This evolution from small, networked
    devices to large-scale servers showcases Java’s versatility and enduring impact
    on the world of software development.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: JVM是使Java的“一次编写，到处运行”承诺成为现实的基石。这一承诺重新定义了软件开发，直接回应了为网络消费设备（如机顶盒、路由器和其他多媒体设备）创建软件的挑战。按照设计，JVM允许编译后的Java代码在网络中传输，在各种客户端机器上无缝运行，并提供安全保障。JVM的架构和执行模型确保Java程序无论其来源或运行的主机机器如何，都能保持一致的行为。这种从小型网络设备到大规模服务器的演变展示了Java的多样性和对软件开发世界的持久影响。
- en: This capability became even more compelling with the rise of the World Wide
    Web. The ability to download and run Java programs within web browsers while guaranteeing
    safety was a game-changer. It provided unprecedented extensibility, allowing dynamic
    content to be added to web pages securely. This extensibility, demonstrated by
    the HotJava browser, showcased the JVM’s role in shaping the web as we know it
    today.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 随着万维网的兴起，这种能力变得更加引人注目。在保证安全的同时，能够在网络浏览器中下载和运行Java程序，这是一个颠覆性的变化。它提供了前所未有的可扩展性，允许安全地将动态内容添加到网页中。这种由HotJava浏览器展示的可扩展性，展示了JVM在我们今天所知道的Web形成中的作用。
- en: However, it’s worth noting that as the web evolved, technologies like Flash
    and Java browser plugins gradually disappeared due to security concerns and the
    emergence of more modern web standards. Despite these changes, the JVM’s influence
    persisted in various domains, from enterprise server applications to Android mobile
    development, underscoring its enduring significance in the broader software landscape.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，值得注意的是，随着网络的演变，由于安全担忧和更现代网络标准的出现，像Flash和Java浏览器插件这样的技术逐渐消失。尽管发生了这些变化，JVM的影响力在各种领域仍然持续存在，从企业服务器应用程序到Android移动开发，这突显了它在更广泛的软件景观中的持久重要性。
- en: In essence, the JVM is the technological backbone that makes Java adaptable,
    secure, and platform independent. Its importance to Java’s history lies in its
    ability to deliver on Java’s promise, making it a foundational technology for
    web and software development. The enduring success and relevance of Java can be
    directly attributed to the JVM’s role in its evolution, solidifying its place
    in the annals of computing history.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，JVM是使Java适应性强、安全且平台无关的技术支柱。其对Java历史的重要性在于其能够实现Java的承诺，使其成为Web和软件开发的基础性技术。Java的持续成功和相关性可以直接归因于JVM在其演变中的作用，巩固了其在计算机历史档案中的地位。
- en: The historical journey of the JVM we’ve embarked upon not only sheds light on
    the rich tapestry of the Java platform’s development but also underscores the
    pivotal role played by the JVM in shaping the platform’s unique identity. From
    its inception as a response to the challenges of networked consumer devices to
    its transformative influence on web-based content and its extensibility, the JVM
    stands as the cornerstone of the Java ecosystem. This journey provides a fitting
    context for exploring the JVM’s inner workings, as introduced in the next section.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所经历的JVM的历史之旅不仅揭示了Java平台发展的丰富织锦，而且强调了JVM在塑造平台独特身份中的关键作用。从作为对网络消费设备挑战的回应而诞生，到对基于Web的内容的变革性影响及其可扩展性，JVM成为了Java生态系统的基石。这一旅程为探索下一节中介绍的JVM的内部工作原理提供了合适的背景。
- en: Furthermore, it’s worth noting that the JVM’s influence extends beyond Java
    itself. It is the engine for many other languages such as Kotlin, Scala, Groovy,
    and more. Understanding the JVM’s history allows us to appreciate how it has evolved
    to deliver on Java’s promise of platform independence, its adaptability to various
    programming languages, and its enduring relevance in software development across
    multiple languages and applications.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，值得注意的是，JVM的影响力不仅限于Java本身。它是Kotlin、Scala、Groovy等多种语言的引擎。了解JVM的历史使我们能够欣赏它如何演变以实现Java的平台独立性承诺，其适应各种编程语言的能力，以及其在多语言和应用程序软件开发中的持久相关性。
- en: An overview of the JVM
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JVM概述
- en: The JVM is the bedrock upon which the entire Java platform stands. It serves
    as the silent but omnipresent guardian of Java, facilitating its unique attributes.
    The JVM is responsible for the platform’s independence from specific hardware
    and operating systems, the compact size of compiled Java code, and its formidable
    ability to safeguard users against malicious programs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: JVM是整个Java平台的基础。它是Java的默默无闻但无处不在的守护者，促进了Java的独特属性。JVM负责平台的独立于特定硬件和操作系统，编译的Java代码的紧凑大小，以及其强大的保护用户免受恶意程序侵害的能力。
- en: In essence, the JVM is an abstract computing machine, not unlike a tangible
    computer you might find on your desk. It boasts an instruction set and manipulates
    various memory areas by executing code at runtime. Implementing a programming
    language using a virtual machine is not new, with one of the most prominent examples
    being the P-Code machine of UCSD Pascal. This foundation allows the JVM to transcend
    physical hardware and provide a consistent environment for Java applications.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，JVM是一个抽象的计算机，与您桌上的实体计算机并无二致。它拥有指令集，并通过在运行时执行代码来操作各种内存区域。使用虚拟机实现编程语言并非新鲜事，其中最突出的例子是UCSD
    Pascal的P-Code机器。这个基础使得JVM能够超越物理硬件，为Java应用程序提供一个一致的环境。
- en: The journey of the JVM, however, began with a prototype implementation at Sun
    Microsystems, Inc., where it was hosted on a handheld device reminiscent of a
    contemporary **personal digital assistant** (**PDA**). Today, Oracle’s implementations
    have expanded the reach of the JVM to mobile, desktop, and server devices. Notably,
    the JVM doesn’t tether itself to any particular implementation technology, host
    hardware, or operating system. It is a versatile entity that can be realized through
    interpretation, compilation, microcode, or direct silicon implementation.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，JVM的旅程始于Sun Microsystems, Inc.的一个原型实现，当时它托管在类似当代**个人数字助理**（**PDA**）的手持设备上。如今，Oracle的实现已经将JVM的触角扩展到了移动、桌面和服务器设备。值得注意的是，JVM并不局限于任何特定的实现技术、宿主硬件或操作系统。它是一个多才多艺的实体，可以通过解释、编译、微码或直接硅实现来实现。
- en: What’s unique about the JVM is that it knows nothing about the specifics of
    the Java programming language. Instead, it is intimately familiar with a particular
    binary format—the class file format. These class files encapsulate JVM instructions,
    also known as bytecodes, along with a symbol table and supplementary information.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: JVM的独特之处在于它对Java编程语言的细节一无所知。相反，它与特定的二进制格式——类文件格式——有着密切的了解。这些类文件封装了JVM指令，也称为字节码，以及符号表和补充信息。
- en: To ensure security, the JVM enforces robust syntactic and structural constraints
    on the code contained within class files. However, this is where the JVM’s inclusive
    nature shines. Any programming language with functionality that can be expressed
    in terms of a valid class file can find a hospitable home within the JVM. This
    inclusivity allows implementers of various languages to leverage the JVM as a
    delivery vehicle for their software, thanks to its machine-independent platform.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保安全性，JVM对类文件中包含的代码施加了强大的语法和结构约束。然而，这正是JVM包容性的体现。任何可以用有效类文件表达功能的编程语言都可以在JVM中找到温馨的家园。这种包容性使得各种语言的实现者可以利用JVM作为其软件的交付工具，得益于其机器无关的平台。
- en: The JVM operates at the operating system layer, serving as a critical bridge
    between Java applications and the underlying hardware and operating system. It
    plays a crucial role in executing Java code while abstracting hardware complexities
    and providing a secure and consistent environment for Java applications.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: JVM在操作系统层运行，作为Java应用程序与底层硬件和操作系统之间的关键桥梁。它在执行Java代码的同时抽象硬件复杂性，并为Java应用程序提供一个安全且一致的环境。
- en: It also acts as an interpreter for Java bytecode, transforming high-level Java
    code into low-level instructions that the underlying hardware can understand.
    It manages memory, handles multithreading, and provides various runtime services,
    allowing Java applications to run seamlessly across different platforms and operating
    systems.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 它还充当Java字节码的解释器，将高级Java代码转换为底层硬件可以理解的低级指令。它管理内存，处理多线程，并提供各种运行时服务，使Java应用程序能够在不同的平台和操作系统上无缝运行。
- en: 'A runtime instance of the JVM has a specific and well-defined life cycle. Its
    mission is clear—to run a single Java application. Here’s a breakdown of the JVM
    life cycle:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: JVM的运行时实例具有特定且定义良好的生命周期。其任务是明确的——运行单个Java应用程序。以下是JVM生命周期的分解：
- en: '**Instance birth**: When a Java application is launched, a runtime instance
    of the JVM is created. This instance is responsible for executing the application’s
    bytecode and managing its runtime environment.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实例生成**：当Java应用程序启动时，会创建一个JVM的运行时实例。这个实例负责执行应用程序的字节码并管理其运行时环境。'
- en: '**Execution**: The JVM instance starts running the Java application by invoking
    the **main()** method of a designated initial class. This **main()** method serves
    as the entry point for the application and must meet specific criteria: it should
    be public, static, return **void**, and accept a single parameter, which is an
    array of strings, **(String[])**. As of the time of writing, it’s important to
    note that the criteria for the **main()** method may evolve, as a preview version
    in Java 21 suggests potential simplifications. Therefore, developers should stay
    informed about the latest language updates and evolving best practices regarding
    the **main()** method’s signature. Any class with such a **main()** method can
    serve as the starting point for a Java application.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**执行**：JVM实例通过调用指定初始类的**main()**方法来启动Java应用程序。这个**main()**方法作为应用程序的入口点，必须满足特定标准：它应该是公开的、静态的、返回**void**，并且接受一个字符串数组作为单一参数，即**(String[])**。截至撰写本文时，重要的是要注意，**main()**方法的准则可能会演变，因为Java
    21的预览版本暗示了可能的简化。因此，开发者应关注最新的语言更新和关于**main()**方法签名的最佳实践的发展。任何具有此类**main()**方法的类都可以作为Java应用程序的起点。'
- en: '**Application execution**: The JVM executes the Java application, processing
    its instructions and managing memory, threads, and other resources as needed.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**应用程序执行**：JVM执行Java应用程序，根据需要处理其指令，管理内存、线程和其他资源。'
- en: '**Application completion**: Once the Java application is executed, the JVM
    instance is no longer needed. At this point, the JVM instance dies.'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**应用程序完成**：一旦Java应用程序执行完毕，JVM实例就不再需要。此时，JVM实例会终止。'
- en: It’s important to note that the JVM follows a *one application per instance*
    model. Suppose you start multiple Java applications concurrently on the same computer,
    using the same concrete implementation of the JVM. In that case, you’ll have multiple
    JVM instances, each dedicated to running its respective Java application. These
    JVM instances are isolated from each other, ensuring the independence and security
    of each Java application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，JVM遵循“一个应用程序一个实例”的模式。假设你在同一台计算机上同时启动多个Java应用程序，使用相同的JVM具体实现。在这种情况下，你将拥有多个JVM实例，每个实例都专门用于运行其各自的Java应用程序。这些JVM实例彼此隔离，确保每个Java应用程序的独立性和安全性。
- en: In concluding this comprehensive JVM overview, we’ve journeyed through the foundational
    elements that make Java a versatile and platform-independent programming language.
    The JVM, the linchpin of Java’s execution environment, orchestrates the seamless
    integration of diverse code across operating systems and architectures. As we
    transition to the next section, our understanding of the JVM’s inner workings
    primes us to explore the dynamic processes that unfold when Java code comes to
    life more deeply. This exploration will unravel the intricate steps taken by the
    JVM in executing Java applications, shedding light on the magic that happens behind
    the scenes. Join us as we embark on the journey to uncover the execution intricacies
    of Java code within the JVM.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在总结这个全面的JVM概述时，我们已穿越了构成Java成为多功能和平台无关编程语言的基础元素。JVM，Java执行环境的关键，协调了不同操作系统和架构下代码的无缝集成。随着我们过渡到下一部分，我们对JVM内部工作的理解使我们准备好深入探索Java代码生命周期的动态过程。这次探索将揭示JVM在执行Java应用程序时采取的复杂步骤，揭示幕后发生的魔法。请加入我们，一起揭开Java代码在JVM中执行细节的旅程。
- en: How the JVM executes Java code
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JVM如何执行Java代码
- en: The JVM is a remarkable technology that plays a central role in executing Java
    applications. It’s designed to make Java platform-independent, allowing you to
    write once, and run anywhere. However, understanding how the JVM works involves
    not only Java but also the integration of native code to interact with specific
    hardware and operating systems.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: JVM（Java虚拟机）是一项卓越的技术，在执行Java应用程序中扮演着核心角色。它被设计成使Java平台无关，允许你一次编写，到处运行。然而，理解JVM的工作原理不仅涉及Java，还包括与特定硬件和操作系统的原生代码集成。
- en: The JVM executes Java applications, which are written in the Java programming
    language and compiled into bytecode. Bytecode is a low-level representation of
    Java code that is platform-independent. When a Java application is executed, the
    JVM interprets or compiles this bytecode into machine code for the host system’s
    hardware.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: JVM执行用Java编程语言编写的Java应用程序，这些应用程序被编译成字节码。字节码是Java代码的低级表示，它是平台无关的。当Java应用程序执行时，JVM将其解释或编译成宿主系统硬件的机器代码。
- en: To interact with the host system and leverage platform-specific features, the
    JVM can use native methods. These native methods are written in languages such
    as C or C++ and are dynamically linked to the specific platform on which the JVM
    is running. These methods provide a bridge between the platform-independent Java
    code and the native code specific to the host system.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与宿主系统交互并利用特定平台的功能，JVM可以使用本地方法。这些本地方法是用C或C++等语言编写的，并且与JVM运行的特定平台动态链接。这些方法在平台无关的Java代码和宿主系统特定的本地代码之间提供了一个桥梁。
- en: Native methods are beneficial when Java applications need to access information
    from the operating system or utilize system resources that are not easily accessible
    through pure Java code. For example, when working with filesystems, directories,
    or other platform-specific features, native methods can provide a direct interface
    to the underlying operating system.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当Java应用程序需要从操作系统访问信息或利用纯Java代码难以访问的系统资源时，本地方法是有益的。例如，当与文件系统、目录或其他特定平台的功能一起工作时，本地方法可以提供直接访问底层操作系统的接口。
- en: It’s crucial to understand that despite the Java programming language’s commitment
    to platform independence, the JVM is inherently platform-specific. It signifies
    that a tailored virtual machine implementation exists for every distinct platform.
    This virtual machine implementation is a specific instantiation of the JVM designed
    to adapt seamlessly to the peculiarities of the host system’s hardware architecture
    and operating system. This platform-specific adaptation ensures optimal compatibility
    and performance, emphasizing the JVM’s dynamic nature as it tailors its execution
    environment to the unique characteristics of each underlying platform.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这一点至关重要：尽管Java编程语言致力于平台无关性，但JVM本质上却是平台特定的。这意味着每个不同的平台都存在一个定制的虚拟机实现。这种虚拟机实现是JVM的一个特定实例，旨在无缝适应宿主系统硬件架构和操作系统的特殊性。这种平台特定的适应确保了最佳兼容性和性能，强调了JVM的动态特性，因为它根据每个底层平台的独特特性定制其执行环境。
- en: 'In the captivating visual of *Figure 1**.1*, we witness the seamless execution
    of a unique Java program across three distinct platforms: Windows, macOS, and
    Linux, all thanks to the JVM. Each venue boasts its dedicated JVM instance, tailored
    to its specific hardware and operating system. The beauty of this scene lies in
    the uniformity of the program itself – it remains unaltered, a testament to the
    *Write Once, Run Anywhere* promise of Java. As we observe, the program’s functionality
    remains consistent across the trio of operating systems, emphasizing the platform
    independence that the JVM bestows. It’s a striking demonstration of the JVM’s
    adaptability, ensuring that the same Java program can thrive harmoniously in the
    diverse landscapes of Windows, macOS, and Linux, embodying the essence of cross-platform
    compatibility.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在引人入胜的视觉图*图1**.1*中，我们见证了独特的Java程序在三个不同的平台（Windows、macOS和Linux）上的无缝执行，这一切都归功于JVM。每个平台都拥有其专用的JVM实例，针对其特定的硬件和操作系统进行了定制。这一场景的美丽之处在于程序的统一性——它保持不变，是对Java的“一次编写，到处运行”承诺的证明。正如我们所观察到的，程序的功能在这三个操作系统之间保持一致，强调了JVM赋予的平台无关性。这是JVM适应性的显著展示，确保相同的Java程序能够在Windows、macOS和Linux的多样化环境中和谐共存，体现了跨平台兼容性的本质。
- en: '![Figure 1.1: The JVM across multi-platforms](img/B22030_01_01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1：跨多平台的JVM](img/B22030_01_01.jpg)'
- en: 'Figure 1.1: The JVM across multi-platforms'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：跨多平台的JVM
- en: 'The JVM serves a singular yet vital purpose: to execute Java applications.
    Its life cycle is straightforward, giving birth to a new instance when an application
    begins and gracefully concluding its existence when the application completes.
    Each application, when launched, triggers the creation of its dedicated JVM instance.
    It means that running the same code three times on the same machine initiates
    three independent JVMs.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: JVM的作用单一但至关重要：执行Java应用程序。其生命周期简单明了，当应用程序开始时，它会孕育一个新的实例，当应用程序完成时，它会优雅地结束其存在。每个应用程序在启动时都会触发其专用JVM实例的创建。这意味着在同一台机器上运行相同的代码三次将启动三个独立的JVM。
- en: 'While the JVM may operate quietly in the background, numerous concurrent processes
    ensure its continuous availability. These processes are the unsung heroes that
    keep the JVM running seamlessly. These are as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然JVM可能在后台安静地运行，但众多并发进程确保了其持续可用性。这些进程是无名英雄，它们使JVM能够无缝运行。具体如下：
- en: '**Timers**: Timers are the clockwork of the JVM, orchestrating events that
    occur periodically, such as interruptions and repetitive processes. They play
    a crucial role in maintaining the synchrony of the JVM’s operations.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计时器**：计时器是JVM的时钟，协调定期发生的事件，如中断和重复过程。它们在维持JVM操作同步方面发挥着关键作用。'
- en: '**Garbage collector processes**: The garbage collector processes manage memory
    within the JVM. They execute the essential task of cleaning up memory by identifying
    and disposing of objects that are no longer in use, ensuring efficient memory
    utilization.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垃圾收集器进程**：垃圾收集器进程管理JVM中的内存。它们通过识别和销毁不再使用的对象来执行清理内存的基本任务，确保高效地利用内存。'
- en: '**Compilers**: Compilers within the JVM take on the transformative role of
    converting bytecode, the low-level representation of Java code, into native code
    that the host system’s hardware can understand. This process, known as **just-in-time**
    (**JIT**) compilation, enhances the performance of Java applications.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译器**：JVM内部的编译器承担了将字节码（Java代码的低级表示）转换为宿主系统硬件可以理解的本地代码的转换角色。这个过程称为**即时**（**JIT**）编译，提高了Java应用程序的性能。'
- en: '**Listeners**: Listeners serve as the attentive ears of the JVM, ready to receive
    signals and information. Their primary function is to relay this information to
    the appropriate processes within the JVM, ensuring that critical data reaches
    its intended destination.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监听器**：监听器作为JVM的警觉耳朵，随时准备接收信号和信息。它们的主要功能是将这些信息传递给JVM内部适当的过程，确保关键数据达到预期的目的地。'
- en: Diving deeper into the parallel processes or threads within the JVM, it’s essential
    to recognize that the JVM allows concurrently executing multiple threads. These
    threads run in parallel and enable Java applications to perform tasks simultaneously.
    This concurrency in Java is closely linked to native threads, the fundamental
    units of parallel execution at the operating system level. Additionally, it’s
    worth noting that, as of Java 21, virtual threads have become a new feature. Virtual
    threads introduce a lightweight form of concurrency that can be managed more efficiently,
    potentially altering the landscape of parallel execution in Java. Developers should
    consider this while considering thread management strategies for their applications.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 深入研究JVM内部的并行进程或线程，重要的是要认识到JVM允许并发执行多个线程。这些线程并行运行，使Java应用程序能够同时执行任务。Java中的这种并发性与原生线程紧密相关，原生线程是操作系统级别的并行执行的基本单元。此外，值得注意的是，截至Java
    21，虚拟线程已成为一项新特性。虚拟线程引入了一种轻量级的并发形式，可以更有效地管理，可能会改变Java并行执行的局面。开发者在考虑其应用程序的线程管理策略时应该考虑这一点。
- en: 'When a parallel process or thread in Java is born, it undergoes a series of
    initial steps to prepare for its execution:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当Java中的并行进程或线程诞生时，它将经历一系列初始步骤以准备其执行：
- en: '**Memory allocation**: The JVM allocates memory resources to the thread, including
    a dedicated portion of the heap for storing its objects and data. Each thread
    has its own memory space, ensuring isolation from other threads.'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**内存分配**：JVM为线程分配内存资源，包括为存储其对象和数据而保留的堆的专用部分。每个线程都有自己的内存空间，确保与其他线程隔离。'
- en: '**Object synchronization**: Thread synchronization mechanisms, such as locks
    and monitors, are established to coordinate access to shared resources. Synchronization
    ensures that threads do not interfere with each other’s execution and helps prevent
    data corruption in multi-threaded applications.'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**对象同步**：线程同步机制，如锁和监视器，被建立以协调对共享资源的访问。同步确保线程不会相互干扰，并有助于防止多线程应用程序中的数据损坏。'
- en: '**Creation of specific registers**: The thread is equipped with specific registers,
    which are part of the thread’s execution context. These registers hold data and
    execution state information, allowing the thread to operate efficiently.'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**特定寄存器的创建**：线程配备了特定的寄存器，这些寄存器是线程执行上下文的一部分。这些寄存器持有数据和执行状态信息，使线程能够高效地运行。'
- en: '**Allocation of the native thread**: A native thread, managed by the operating
    system, is allocated to support the Java thread’s execution. The native thread
    is responsible for executing the Java code and interacting with the underlying
    hardware and operating system.'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**原生线程的分配**：由操作系统管理的原生线程被分配以支持Java线程的执行。原生线程负责执行Java代码并与底层硬件和操作系统交互。'
- en: If an exception occurs during the execution of a thread, the native part of
    the JVM promptly communicates this information back to the JVM itself. The JVM
    is responsible for handling the exception, making necessary adjustments, and ensuring
    the thread’s safety and integrity. If the exception is not recoverable, the JVM
    closes the thread.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在线程执行过程中发生异常，JVM 的本地部分会立即将此信息反馈给 JVM 本身。JVM 负责处理异常，进行必要的调整，并确保线程的安全性和完整性。如果异常无法恢复，JVM
    将关闭线程。
- en: When a thread completes its execution, it releases all the specific resources
    associated with it. It includes the resources managed by the Java part of the
    JVM, such as memory and objects, and the resources allocated by the native part,
    including the native thread. These resources are efficiently reclaimed and returned
    to the JVM, ensuring that the JVM remains responsive and resource efficient.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个线程完成其执行时，它会释放与之相关的所有特定资源。这包括 JVM 的 Java 部分管理的资源，如内存和对象，以及由本地部分分配的资源，包括本地线程。这些资源被有效地回收并返回到
    JVM，确保 JVM 保持响应性和资源效率。
- en: In essence, thread management in the JVM is a complex and highly orchestrated
    process, allowing for concurrently executing multiple threads, each with its own
    memory space and specific resources.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，JVM 中的线程管理是一个复杂且高度协调的过程，允许并发执行多个线程，每个线程都有自己的内存空间和特定资源。
- en: 'In the realm of data, the JVM operates with two fundamental categories:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据领域，JVM 运行时涉及两个基本类别：
- en: '**Primitives**: Primitives are basic data types that include numeric types,
    Boolean values, and return addresses. These types do not require extensive type
    checking or verification at runtime. They operate with specific instructions tailored
    to their respective data types. For example, instructions such as **iadd**, **ladd**,
    **fadd**, and **dadd** handle integer, long, float, and double values, respectively.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原始类型**：原始类型是基本数据类型，包括数值类型、布尔值和返回地址。这些类型在运行时不要求进行广泛的类型检查或验证。它们使用针对各自数据类型定制的特定指令操作。例如，**iadd**、**ladd**、**fadd**
    和 **dadd** 指令分别处理整数、长整型、浮点型和双精度值。'
- en: '**Reference values**: The JVM supports objects that are either instances of
    dynamically allocated classes or arrays. These values fall under the reference
    type, and their operation closely resembles that of languages such as C/C++. Reference
    values represent complex data structures, and the JVM performs runtime type checking
    and verification to ensure the integrity and compatibility of these data structures.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引用值**：JVM 支持动态分配类的实例或数组。这些值属于引用类型，其操作类似于 C/C++ 等语言。引用值代表复杂的数据结构，JVM 在运行时执行类型检查和验证，以确保这些数据结构的完整性和兼容性。'
- en: In the realm of primitive types, the JVM encompasses numeric types, which cover
    both integers and floating-point values. The ability to handle simple data types
    and complex, reference-based data structures allows the JVM to support various
    applications and scenarios.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始类型领域，JVM 包括数值类型，涵盖整数和浮点值。处理简单数据类型和复杂、基于引用的数据结构的能力使 JVM 能够支持各种应用程序和场景。
- en: The JVM’s capacity to gracefully handle exceptions, manage the life cycle of
    threads, and operate on both primitive and reference data types reflects its robust
    and versatile nature, making it a cornerstone of the Java platform.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 能够优雅地处理异常、管理线程的生命周期，并在原始和引用数据类型上操作，这反映了其强大和灵活的本质，使其成为 Java 平台的基础。
- en: The JVM is a versatile and powerful platform that supports various primitive
    data types, each serving distinct roles in Java programming. These primitive data
    types are fundamental building blocks for defining variables and handling basic
    data operations within the JVM. From numeric types such as integers and floating-point
    values to Boolean values and the unique `returnAddress` type, these data types
    play a critical role in the efficient and precise execution of Java programs.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 是一个多才多艺且强大的平台，支持各种原始数据类型，每个数据类型在 Java 编程中都扮演着不同的角色。这些原始数据类型是定义变量和处理 JVM
    内基本数据操作的基本构建块。从整数和浮点值等数值类型到布尔值和独特的 `returnAddress` 类型，这些数据类型在 Java 程序的精确和高效执行中发挥着关键作用。
- en: '*Figure 1**.2* shows the JVM types split by primitives and reference values.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1*.*2* 显示了 JVM 类型按原始类型和引用值划分。'
- en: '![Figure 1.2: The JVM types](img/B22030_01_02.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2：JVM 类型](img/B22030_01_02.jpg)'
- en: 'Figure 1.2: The JVM types'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2：JVM 类型
- en: Each type also has a size and range. *Table 1.1* provides a comprehensive overview
    of the JVM’s primitive data types, including their names, sizes, variations, default
    values, and types. It offers a valuable reference for Java developers and enthusiasts
    to understand the core data types at the heart of the JVM.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型也有其大小和范围。*表1.1*提供了JVM原始数据类型的全面概述，包括它们的名称、大小、变体、默认值和类型。它为Java开发者和爱好者提供了宝贵的参考，以了解JVM核心数据类型。
- en: '| **Type Name** | **Size (****bits)** | **Variation** | **Default** **Value**
    | **Type** |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **类型名称** | **大小（位）** | **变体** | **默认值** | **类型** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `byte` | 8 | -128 to 127 | 0 | Numeric |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `byte` | 8 | -128到127 | 0 | 数值 |'
- en: '| `short` | 16 | -32,768 to 32,767 | 0 | Numeric |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `short` | 16 | -32,768到32,767 | 0 | 数值 |'
- en: '| `int` | 32 | -2,147,483,648 to 2,147,483,647 | 0 | Numeric |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `int` | 32 | -2,147,483,648到2,147,483,647 | 0 | 数值 |'
- en: '| `long` | 64 | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 | 0
    | Numeric |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `long` | 64 | -9,223,372,036,854,775,808到9,223,372,036,854,775,807 | 0 |
    数值 |'
- en: '| `float` | 32 | IEEE 754 single precision | 0.0 | Numeric |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `float` | 32 | IEEE 754单精度 | 0.0 | 数值 |'
- en: '| `double` | 64 | IEEE 754 double precision | 0.0 | Numeric |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `double` | 64 | IEEE 754双精度 | 0.0 | 数值 |'
- en: '| `char` | 16 | 0 to 65,535 | ‘\u0000’ | Numeric |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `char` | 16 | 0到65,535 | ‘\u0000’ | 数值 |'
- en: '| `boolean` | N/A | N/A | false | Boolean |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `boolean` | N/A | N/A | false | 布尔值 |'
- en: '| `returnAddress` | N/A | N/A | N/A | `returnAddress` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `returnAddress` | N/A | N/A | N/A | `returnAddress` |'
- en: 'Table 1.1: JVM’s primitive data types, including their names, sizes, variations,
    default values, and types'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.1：JVM的原始数据类型，包括它们的名称、大小、变体、默认值和类型
- en: These primitive types in the JVM encompass various numeric types, Booleans,
    and the particular `returnAddress` type, each with its own characteristics and
    default values. This table is a quick reference for understanding these primitive
    data types within the JVM.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: JVM中的这些原始类型包括各种数值类型、布尔值以及特定的`returnAddress`类型，每种类型都有其独特的特性和默认值。此表是理解JVM内这些原始数据类型的快速参考。
- en: 'The `returnAddress` type in the JVM represents a particular data type critical
    in method invocation and return. This type is internal to the JVM and is not directly
    accessible or utilized by the Java programming language. Here’s an explanation
    of the importance and reason behind the `returnAddress` type:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: JVM中的`returnAddress`类型代表了一种在方法调用和返回中至关重要的特定数据类型。此类型是JVM内部的，并且Java编程语言不能直接访问或使用。以下是关于`returnAddress`类型的重要性和原因的解释：
- en: '**Method invocation and return**: The **returnAddress** type is used by the
    JVM to manage method invocations and returns efficiently. When a method is invoked,
    the JVM needs to keep track of where to return once it completes its execution.
    This is crucial for maintaining the flow of control in a program and ensuring
    that the execution context is correctly restored after a method call.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法调用和返回**：JVM使用`returnAddress`类型来高效地管理方法调用和返回。当一个方法被调用时，JVM需要跟踪执行完成后返回的位置。这对于维护程序的流程控制以及确保方法调用后正确恢复执行上下文至关重要。'
- en: '**Call stack management**: In the JVM, the call stack is a critical data structure
    that keeps track of method calls and returns. It maintains a stack of **returnAddress**
    values, each representing the address to which control should return when a method
    completes. This stack is known as the method call stack or execution stack.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调用栈管理**：在JVM中，调用栈是一个关键的数据结构，用于跟踪方法调用和返回。它维护一个`returnAddress`值的栈，每个值代表方法完成后应返回的控制地址。这个栈被称为方法调用栈或执行栈。'
- en: '**Recursion**: The **returnAddress** type is essential in handling recursive
    method calls. When a method invokes itself or another method multiple times, the
    JVM relies on **returnAddress** values to ensure that control returns to the correct
    calling point, preserving the recursive state.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**递归**：`returnAddress`类型在处理递归方法调用中至关重要。当一个方法多次调用自身或另一个方法时，JVM依赖于`returnAddress`值来确保控制返回到正确的调用点，从而保持递归状态。'
- en: The `returnAddress` type is an internal mechanism the JVM uses to manage method
    invocation and return at a low level. It is not part of the Java programming language
    specification, and Java code does not directly interact with or access `returnAddress`
    values. This design decision aligns with Java’s goals of providing a high-level,
    platform-independent, and secure language.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`returnAddress` 类型是 JVM 用于在低级别管理方法调用和返回的内部机制。它不是 Java 编程语言规范的一部分，Java 代码不会直接与或访问
    `returnAddress` 值。这个设计决策与 Java 提供高级、平台无关和安全语言的目标相一致。'
- en: The JVM handles the management of `returnAddress` values transparently, ensuring
    that method calls and returns within Java code are seamless and reliable. By abstracting
    this lower-level functionality from the Java language, Java programs can focus
    on high-level logic and application development without the need to manage the
    intricacies of the call stack and `returnAddress` values.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 透明地处理 `returnAddress` 值的管理，确保 Java 代码中的方法调用和返回无缝且可靠。通过将这种低级功能从 Java 语言中抽象出来，Java
    程序可以专注于高级逻辑和应用开发，无需管理调用栈和 `returnAddress` 值的复杂性。
- en: The `returnAddress` type is a crucial part of the JVM’s internal mechanisms
    for managing method invocations and returns. While it is significant for the JVM’s
    operation, it remains hidden from the Java language itself, as the JVM handles
    it transparently to ensure the integrity and reliability of method calls and returns
    in Java programs.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`returnAddress` 类型是 JVM 管理方法调用和返回的内部机制的重要组成部分。虽然这对 JVM 的操作很重要，但它对 Java 语言本身来说是隐藏的，因为
    JVM 以透明的方式处理它，以确保 Java 程序中方法调用和返回的完整性和可靠性。'
- en: In the JVM, the boolean type has limited native support. Unlike other programming
    languages where boolean values are represented as a distinct data type, in the
    JVM, boolean values are managed using the `int` type. This design choice simplifies
    the implementation of the JVM and also has historical reasons tied to the bytecode
    instruction set.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JVM 中，布尔类型只有有限的本地支持。与其他编程语言中布尔值作为独立的数据类型表示不同，在 JVM 中，布尔值是通过使用 `int` 类型来管理的。这种设计选择简化了
    JVM 的实现，并且与字节码指令集的历史原因有关。
- en: 'Here are some key aspects of how boolean values are treated in the JVM:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 JVM 中处理布尔值的一些关键方面：
- en: '**Boolean as integers**: The JVM represents boolean values as integers, with
    **1** typically denoting **true** and **0** representing **false**. This means
    that boolean values are essentially treated as a subset of integers.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布尔值作为整数**：JVM 将布尔值表示为整数，其中 **1** 通常表示 **true**，而 **0** 表示 **false**。这意味着布尔值本质上被视为整数的一个子集。'
- en: '**Instructions**: In JVM bytecode instructions, there are no specific instructions
    for boolean operations. Instead, operations on boolean values are carried out
    using integer instructions. For example, comparisons or logical operations involving
    boolean values are performed using integer instructions such as **if_icmpne**
    (if int comparison not equal), **if_icmpeq** (if int comparison equal), and so
    on.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指令**：在 JVM 字节码指令中，没有专门针对布尔操作的指令。相反，布尔值的操作是通过整数指令来执行的。例如，涉及布尔值的比较或逻辑操作使用整数指令，如
    **if_icmpne**（如果整数比较不等），**if_icmpeq**（如果整数比较相等），等等。'
- en: '**Boolean arrays**: When working with arrays of boolean values, such as **boolean[]**,
    the JVM often treats them as byte arrays. The JVM uses bytes (8 bits) to represent
    boolean values, which align with the **byte** data type.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布尔数组**：当处理布尔值数组，例如 **boolean[]** 时，JVM 通常将它们视为字节数组。JVM 使用字节（8位）来表示布尔值，这与
    **byte** 数据类型相一致。'
- en: '**Efficiency and simplicity**: The choice to represent boolean values as integers
    simplifies the JVM’s design and makes it more efficient. It reduces the need for
    additional instructions and data types, which helps keep the JVM implementation
    straightforward.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率和简单性**：将布尔值表示为整数的选择简化了 JVM 的设计，并使其更高效。它减少了额外指令和数据类型的需求，这有助于保持 JVM 实现的简单性。'
- en: While this approach may seem somewhat unconventional, it is a part of the JVM’s
    design philosophy that aims to maintain efficiency and simplicity while supporting
    boolean values within Java programs. It’s worth noting that while boolean values
    are represented as integers in the JVM bytecode, Java developers can work with
    boolean values using the familiar `true` and `false` literals in their Java source
    code, and the JVM takes care of the necessary conversions during execution.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法可能看起来有些不寻常，但它却是JVM设计哲学的一部分，旨在在支持Java程序中的布尔值的同时，保持效率和简单性。值得注意的是，虽然布尔值在JVM字节码中表示为整数，但Java开发者可以使用熟悉的`true`和`false`字面量在他们的Java源代码中处理布尔值，JVM在执行期间负责必要的转换。
- en: 'In the JVM, reference values are pivotal in managing complex data structures
    and objects. These reference values represent and interact with three main types:
    classes, arrays, and interfaces. Here’s a closer look at these reference types
    in the JVM:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在JVM中，引用值在管理复杂数据结构和对象方面至关重要。这些引用值代表并与三种主要类型交互：类、数组和接口。以下是JVM中这些引用类型更详细的介绍：
- en: '**Classes**: The foundation of object-oriented programming in Java. They define
    the blueprint for creating objects and encapsulating data and behavior. In the
    JVM, reference values for classes are used to point to instances of these classes.
    When you create an object of a class, you create an instance of that class, and
    the reference value points to this instance.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类**：Java面向对象编程的基础。它们定义了创建对象、封装数据和行为的蓝图。在JVM中，类的引用值用于指向这些类的实例。当你创建一个类的对象时，你创建了这个类的实例，引用值指向这个实例。'
- en: '**Arrays**: Arrays in Java provide a way to store collections of elements of
    the same data type. In the JVM, reference values for arrays are used to reference
    these arrays. Arrays can be of primitive data types or objects, and the reference
    value helps access and manipulate the array’s elements.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数组**：Java中的数组提供了一种存储相同数据类型元素集合的方法。在JVM中，数组的引用值用于引用这些数组。数组可以是原始数据类型或对象，引用值有助于访问和操作数组的元素。'
- en: '**Interfaces**: Interfaces are a fundamental concept in Java, allowing for
    the definition of contracts that classes must adhere to. Reference values for
    interfaces are used to point to objects that implement these interfaces. When
    you work with interfaces in Java, you use reference values to interact with objects
    that fulfill the interface’s requirements.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口**：接口是Java中的一个基本概念，允许定义类必须遵守的合同。接口的引用值用于指向实现这些接口的对象。当你在Java中使用接口时，你使用引用值与满足接口要求的对象进行交互。'
- en: One common characteristic of reference values in the JVM is their initial state,
    which is always set to `null`. The `null` state represents the absence of an object
    or a reference to an object. It is not a defined type but a universal indicator
    of an uninitialized reference value. Reference values can be cast to `null`, regardless
    of their specific type.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: JVM中引用值的常见特征是其初始状态，该状态始终设置为`null`。`null`状态表示对象或对象引用的缺失。它不是一个定义的类型，而是未初始化引用值的通用指示符。引用值可以转换为`null`，无论它们的特定类型如何。
- en: Setting reference values to `null` is particularly useful when you need to release
    resources, indicate that an object is no longer in use, or simply initialize a
    reference without pointing it to a specific object. Handling `null` references
    is a crucial aspect of Java programming used for various purposes, including memory
    management and program logic.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将引用值设置为`null`在需要释放资源、指示对象不再使用或简单地初始化引用而不指向特定对象时特别有用。处理`null`引用是Java编程中用于各种目的的关键方面，包括内存管理和程序逻辑。
- en: Reference values in the JVM are essential for managing classes, arrays, and
    interfaces. They provide a means to work with complex data structures and objects
    in Java. Initializing reference values as `null` allows flexibility and precision
    when working with objects, making it a fundamental aspect of Java’s reference
    handling.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: JVM中的引用值对于管理类、数组和接口至关重要。它们提供了在Java中处理复杂数据结构和对象的方法。将引用值初始化为`null`允许在处理对象时具有灵活性和精确性，使其成为Java引用处理的基本方面。
- en: In the JVM, `null` is a special reference value that represents the absence
    of an object or the lack of a reference to an object. It is not a defined type
    but indicates that a reference value does not currently point to any object. When
    a reference is set to `null`, it effectively means it is not referencing any valid
    object in memory.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在JVM中，`null`是一个特殊的引用值，表示没有对象或没有对象的引用。它不是一个定义的类型，但表示引用值当前没有指向任何对象。当一个引用被设置为`null`时，它实际上意味着它没有引用内存中的任何有效对象。
- en: 'The concept of `null` serves several important purposes in the Java language
    and the JVM:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java语言和JVM中，`null`的概念具有几个重要的用途：
- en: '**Initialization**: When you declare a reference variable but do not assign
    it to an object, the default initial value for that reference is **null**. This
    default value is essential for scenarios where you want to declare a reference
    but not immediately associate it with an object. This practice allows you to declare
    a reference variable and assign it to an object when needed, giving you flexibility
    in your program’s structure.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**初始化**：当你声明一个引用变量但没有将其分配给一个对象时，该引用的默认初始值是**null**。这个默认值对于你想要声明一个引用但不想立即将其与对象关联的场景是必要的。这种做法允许你在需要时声明一个引用变量并将其分配给对象，这为你的程序结构提供了灵活性。'
- en: '**Absence of value**: **null** indicates no valid object associated with a
    particular reference. It is useful for cases where you need to represent that
    no meaningful data or object is available at a certain point in your program.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值的缺失**：**null**表示与特定引用没有关联的有效对象。在程序中的某个点上需要表示没有有意义的数据或对象可用时，这很有用。'
- en: '**Resource release**: While setting references to **null** can help indicate
    to the JVM that an object is no longer needed, it’s essential to clarify that
    the primary responsibility for memory management and resource cleanup lies with
    the Java **Garbage Collector** (**GC**). The GC automatically identifies and reclaims
    memory occupied by no longer-reachable objects, effectively managing memory resources.
    Developers typically do not need to set references to **null** for memory cleanup
    explicitly; it’s a task handled by the GC.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源释放**：虽然将引用设置为**null**可以帮助JVM知道对象不再需要，但重要的是要明确，内存管理和资源清理的主要责任在于Java的**垃圾收集器**（**GC**）。GC自动识别并回收不再可达的对象占用的内存，从而有效管理内存资源。开发者通常不需要显式地将引用设置为**null**以进行内存清理；这是一个由GC处理的任务。'
- en: 'While `null` is a valuable concept in Java and the JVM, its usage comes with
    trade-offs and considerations:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`null`在Java和JVM中是一个有价值的概念，但其使用伴随着权衡和考虑：
- en: '**NullPointerException**: One of the main trade-offs is the risk of **NullPointerException**.
    If you attempt to perform operations on a reference set to **null**, it can lead
    to a runtime exception. Therefore, it’s crucial to handle **null** references
    properly to avoid unexpected program crashes.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NullPointerException**：其中一个主要的权衡是**NullPointerException**的风险。如果你尝试对一个设置为**null**的引用集进行操作，可能会导致运行时异常。因此，正确处理**null**引用至关重要，以避免意外的程序崩溃。'
- en: '**Defensive programming**: Programmers need to be diligent in checking for
    **null** references before using them to prevent **NullPointerException**. It
    can lead to additional code for **null** checks and make it more complex.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**防御性编程**：程序员在使用引用之前需要仔细检查**null**引用，以防止**NullPointerException**。这可能会导致额外的代码用于**null**检查，并使代码更加复杂。'
- en: '**Resource management**: While setting references to **null** can help release
    resources, it’s not a guaranteed method for resource management. Some resources
    may require explicit cleanup or disposal, and relying solely on setting references
    to **null** may not be sufficient.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源管理**：虽然将引用设置为**null**可以帮助释放资源，但这并不是资源管理的保证方法。某些资源可能需要显式的清理或销毁，仅依赖于将引用设置为**null**可能不足以满足需求。'
- en: '**Design considerations**: When designing classes and APIs, it’s important
    to provide clear guidance on how references are meant to be used and under what
    circumstances they can be set to **null**.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计考虑**：在设计类和API时，提供关于如何使用引用以及它们可以在什么情况下设置为**null**的明确指导很重要。'
- en: In summary, in the JVM, `null` is a valuable tool for representing the absence
    of objects and for resource management. However, it requires careful handling
    to avoid `NullPointerException` and ensure proper program behavior. Proper design
    and coding practices can help mitigate the trade-offs associated with using `null`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在 JVM 中，`null` 是表示对象不存在和进行资源管理的一个宝贵工具。然而，它需要谨慎处理以避免 `NullPointerException`
    并确保程序行为正确。适当的设计和编码实践可以帮助减轻使用 `null` 相关的权衡。
- en: In this comprehensive overview of the JVM, we’ve explored the inner workings
    and critical components that make Java a powerful and versatile programming platform.
    The JVM serves as the backbone of the Java ecosystem, providing the ability to
    run Java applications across diverse operating systems and hardware architectures.
    We’ve delved into its support for primitive and reference data types, its handling
    of `null` concerns, and its role in managing classes, arrays, and interfaces.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本篇关于 JVM 的全面概述中，我们探讨了 JVM 的内部工作原理和关键组件，这些组件使得 Java 成为一个强大且多功能的编程平台。JVM 作为 Java
    生态系统的骨架，提供了在多种操作系统和硬件架构上运行 Java 应用程序的能力。我们深入研究了其对原始和引用数据类型的支持，对 `null` 问题的处理，以及在管理类、数组和接口中的作用。
- en: Through the JVM, Java achieves its *Write Once, Run Anywhere* promise, enabling
    developers to create platform-independent applications. However, understanding
    the JVM’s intricacies, including how it manages threads, memory, and resources,
    is essential for optimizing Java applications and ensuring their reliability.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 JVM，Java 实现了其 *一次编写，到处运行* 的承诺，使开发者能够创建平台无关的应用程序。然而，理解 JVM 的复杂性，包括它如何管理线程、内存和资源，对于优化
    Java 应用程序和确保其可靠性至关重要。
- en: The JVM’s design choices, such as representing boolean values as integers, reflect
    a balance between simplicity and efficiency. We’ve also touched on the importance
    of `returnAddress` for managing method invocations and returns.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 的设计选择，例如将布尔值表示为整数，反映了简单性和效率之间的平衡。我们还提到了 `returnAddress` 在管理方法调用和返回中的重要性。
- en: The JVM is a remarkable and intricate technology that empowers Java developers
    to build robust, secure, and platform-agnostic software. With its unique features
    and capabilities, the JVM is a cornerstone of Java’s enduring success in software
    development.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 是一项卓越且复杂的技术，它赋予 Java 开发者构建健壮、安全和平台无关的软件的能力。凭借其独特的特性和功能，JVM 是 Java 在软件开发中持续成功的基础。
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have comprehensively understood the JVM, unraveling its
    critical role in executing Java applications. We explored the platform-specific
    nature of the JVM, emphasizing that, despite the Java language’s platform independence,
    each platform requires a distinct virtual machine implementation for optimal compatibility
    and performance.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你全面了解了 JVM，揭示了其在执行 Java 应用程序中的关键作用。我们探讨了 JVM 的平台特定性质，强调尽管 Java 语言具有平台无关性，但每个平台都需要一个独特的虚拟机实现，以实现最佳兼容性和性能。
- en: The information provided in this chapter is invaluable for several reasons.
    Firstly, it demystifies the underlying workings of the JVM, shedding light on
    its role in making Java’s *Write Once, Run Anywhere* promise a reality. Understanding
    the JVM’s platform-specific adaptation is crucial for developers and practitioners
    in ensuring their Java applications perform optimally across diverse hardware
    and operating system environments.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供的信息具有多重价值。首先，它揭示了 JVM 的底层工作原理，阐明了其在实现 Java 的 *一次编写，到处运行* 承诺中的作用。理解 JVM 的平台特定适应性对于确保
    Java 应用程序在各种硬件和操作系统环境中表现最佳的开发者和从业者至关重要。
- en: Looking ahead to the next chapter, *How the JVM Executes Java Code*, you can
    expect a deeper dive into the dynamic processes that occur when Java code is executed
    within the JVM. This exploration will provide practical insights into the inner
    workings of the JVM during code execution, equipping you with essential knowledge
    applicable to real-life workplace scenarios. As developers encounter various platform
    environments, the insights gained from this chapter will empower you to navigate
    the intricacies of the JVM, optimize Java code for diverse computing landscapes,
    and enhance your problem-solving capabilities in real-world Java development scenarios.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 展望下一章，*JVM如何执行Java代码*，你可以期待更深入地了解当Java代码在JVM中执行时发生的动态过程。这次探索将提供关于JVM在代码执行期间内部工作的实用见解，为你提供适用于实际工作场景的必要知识。随着开发者遇到各种平台环境，本章获得的见解将赋予你导航JVM复杂性的能力，优化适用于不同计算环境的Java代码，并在现实世界的Java开发场景中提高你的问题解决能力。
- en: As we conclude our exploration of the JVM, we’re now poised to venture further
    into the heart of Java’s core by diving into the intricate world of *class file
    structures* in the next chapter. Understanding the structure of class files is
    pivotal in comprehending how Java code is organized, compiled, and executed within
    the JVM. So, let’s move forward and explore the building blocks that make Java’s
    class files come to life, bridging our journey from the JVM to the fascinating
    realm of Java’s class structures.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束对JVM的探索之后，我们现在准备深入Java核心的深处，通过下一章深入到*类文件结构*的复杂世界中。理解类文件的结构对于理解Java代码如何在JVM中组织、编译和执行至关重要。因此，让我们继续前进，探索构成Java类文件生命力的构建块，连接我们从JVM到Java类结构的迷人领域的旅程。
- en: Questions
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章知识的掌握：
- en: What is the primary purpose of the JVM?
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JVM的主要目的是什么？
- en: To write Java code
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写Java代码
- en: To compile Java code
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译Java代码
- en: To run Java applications
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Java应用程序
- en: To debug Java code
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调试Java代码
- en: How does the JVM handle boolean values?
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JVM如何处理布尔值？
- en: As a distinct data type
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为独立的数据类型
- en: As an array of bytes
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为字节数组
- en: As an integer type
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为整数类型
- en: As a floating-point type
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为浮点类型
- en: What is the initial state of a reference value in the JVM?
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JVM中引用值的初始状态是什么？
- en: Undefined
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Undefined
- en: Zero
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Zero
- en: 'Null'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Null'
- en: 'True'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'True'
- en: Which of the following is not a type of reference in the JVM?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项不是JVM中的引用类型？
- en: Classes
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类
- en: Arrays
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数组
- en: Interfaces
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接口
- en: Primitives
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基本类型
- en: What is the primary role of the **returnAddress** type in the JVM?
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JVM中**returnAddress**类型的主要作用是什么？
- en: Representing boolean values
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表示布尔值
- en: Managing method invocations and returns
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管理方法调用和返回
- en: Handling exceptions
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理异常
- en: Storing reference values
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储引用值
- en: Answers
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Here are the answers to this chapter’s questions:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章问题的答案：
- en: C. To run Java applications
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C. 运行Java应用程序
- en: C. As an integer type
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C. 作为整数类型
- en: C. Null
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C. Null
- en: D. Primitives
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: D. 基本类型
- en: B. Managing method invocations and returns
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B. 管理方法调用和返回
