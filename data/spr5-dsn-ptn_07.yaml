- en: Accessing a Database with Spring and JDBC Template Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring 和 JDBC 模板模式访问数据库
- en: In earlier chapters, you learned about Spring core modules like the Spring IoC
    container, the DI pattern, container life cycle, and the used design patterns.
    Also you have seen how Spring makes magic using AOP. Now is the right time to
    move into the battlefield of real Spring applications with persisting data. Do
    you remember your first application during college days where you dealt with database
    access? That time, you probably, had to write boring boilerplate code to load
    database drivers, initialize your data-access framework, open connections, handle
    various exceptions, and to close connections. You also had to be very careful
    about that code. If anything went wrong, you would not have been able to make
    a database connection in your application, even though you would've invested a
    lot of time in such boring code, apart from writing the actual SQL and business
    code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了关于 Spring 核心模块的知识，如 Spring IoC 容器、DI 模式、容器生命周期以及使用的设计模式。你还看到了 Spring
    如何使用 AOP 来施展魔法。现在是时候进入真实 Spring 应用程序的战场，使用持久化数据了。你还记得大学时期你第一次处理数据库访问的应用程序吗？那时，你可能不得不编写无聊的样板代码来加载数据库驱动程序、初始化你的数据访问框架、打开连接、处理各种异常，以及关闭连接。你还必须非常小心这段代码。如果出了任何问题，即使你在这无聊的代码上投入了大量时间，你也不会在你的应用程序中建立数据库连接。
- en: Because we always try to make things better and simpler, we have to focus on
    the solution to that tedious work for data-access. Spring comes with a solution
    for the tedious and boring work for data-access--it removes the code of data access.
    Spring provides data-access frameworks to integrate with a variety of data-access
    technologies. It allows you to use either JDBC directly or any **object-relational
    mapping** (**ORM**) framework, like Hibernate, to persist your data. Spring handles
    all the low-level code for data access work in your application; you can just
    write your SQL, application logic, and manage your application's data rather than
    investing time in writing code for making and closing database connections, and
    so on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们总是试图使事情变得更好、更简单，所以我们必须关注解决数据访问中繁琐工作的解决方案。Spring 为数据访问中的繁琐和无聊工作提供了一个解决方案--它移除了数据访问的代码。Spring
    提供了数据访问框架，以集成各种数据访问技术。它允许你直接使用 JDBC 或任何 **对象关系映射**（**ORM**）框架，如 Hibernate，以持久化你的数据。Spring
    处理你应用程序中数据访问工作的所有底层代码；你只需编写你的 SQL、应用程序逻辑，并管理你应用程序的数据，而不是花费时间编写创建和关闭数据库连接的代码，等等。
- en: 'Now, you can choose any technology, such as JDBC, Hibernate, the **Java Persistence
    API** (**JPA**), or others. to persist your application''s data. Irrespective
    of what you choose, Spring provides support for all these technologies for your
    application. In this chapter, we will explore Spring''s support for JDBC. It will
    cover the following points:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以选择任何技术，例如 JDBC、Hibernate、**Java 持久性 API**（**JPA**）或其他技术来持久化你应用程序的数据。无论你选择什么，Spring
    都为你应用程序提供对这些技术的支持。在本章中，我们将探讨 Spring 对 JDBC 的支持。它将涵盖以下内容：
- en: The best approach to designing your data access
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计数据访问的最佳方法
- en: Implementing the template design pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现模板设计模式
- en: Problems with the traditional JDBC
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统 JDBC 的问题
- en: Solving problems with the Spring `JdbcTemplate`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring 的 `JdbcTemplate` 解决问题
- en: Configuring the data source
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置数据源
- en: Using the object pool design pattern to maintain database connections
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对象池设计模式来维护数据库连接
- en: Abstracting database access by the DAO pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 DAO 模式抽象数据库访问
- en: Working with `JdbcTemplate`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 `JdbcTemplate` 一起工作
- en: The Jdbc callback interfaces
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jdbc 回调接口
- en: Best practices for configuring `JdbcTemplate` in the application
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序中配置 `JdbcTemplate` 的最佳实践
- en: Before we go on to discuss more about JDBC and the template design pattern,
    let's first see the best approach to define the data-access tier in the layered
    architecture.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续讨论 JDBC 和模板设计模式之前，让我们首先看看在分层架构中定义数据访问层最佳的方法。
- en: The best approach to designing your data-access
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计数据访问的最佳方法
- en: 'In previous chapters, you have seen that one of Spring''s goals is to allow
    you to develop applications by following one of the OOPs principles of coding
    to interfaces. Any enterprise application needs to read data and write data to
    any kind of database, and to meet this requirement, we have to write the persistence
    logic. Spring allows you to avoid the scattering of persistence logic across all
    the modules in your application. For this, we can create a different component
    for data access and persistence logic, and this component is known as a **data
    access object** (**DAO**). Let''s see, in the following diagram, the best approach
    to create modules in layered applications:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，您已经看到Spring的一个目标是通过遵循OOPs编码到接口的原则之一来开发应用程序。任何企业应用程序都需要读取数据并将数据写入任何类型的数据库，为了满足这一需求，我们必须编写持久化逻辑。Spring允许您避免在应用程序的所有模块中分散持久化逻辑。为此，我们可以为数据访问和持久化逻辑创建不同的组件，这个组件被称为**数据访问对象**（**DAO**）。让我们看看，在以下图中，创建分层应用程序模块的最佳方法：
- en: '![](img/e991c260-af90-4b2f-8686-622410d96461.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e991c260-af90-4b2f-8686-622410d96461.png)'
- en: 'As you can see in the preceding diagram, for a better approach, many enterprise
    applications consist of the following three logical layers:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，为了更好的方法，许多企业应用程序由以下三个逻辑层组成：
- en: '**The service layer** (or application layer): This layer of the application
    exposes high-level application functions like use-cases and business logic. All
    application services are defined here.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务层**（或应用程序层）：应用程序的这一层公开高级应用程序功能，如用例和业务逻辑。所有应用程序服务都定义在这里。'
- en: '**The data access layer**: This layer of the application defines an interface
    to the application''s data repository (such as a Relational or NoSQL database).
    This layer has the classes and interfaces which have the data-access logic''s
    data persisting in the application.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据访问层**：应用程序的这一层定义了对应用程序数据存储（如关系型或NoSQL数据库）的接口。这一层包含具有数据访问逻辑并将数据持久化到应用程序中的类和接口。'
- en: '**The infrastructure layer**: This layer of the application exposes low-level
    services to the other layers, such as configuring DataSource by using the database
    URL, user credentials, and so on. Such configuration comes under this layer.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础设施层**：应用程序的这一层向其他层公开低级服务，例如通过使用数据库URL、用户凭据等来配置DataSource。此类配置属于这一层。'
- en: 'In the previous figure, you can see that the **Service Layer** collaborates
    with the **Data Access Layer**. To avoid coupling between the application logic
    and data-access logic, we should expose their functionality through interfaces,
    as interfaces promote decoupling between the collaborating components. If we use
    the data-access logic by implementing interfaces, we can configure any particular
    data-access strategy to the application without making any changes in the application
    logic in the **Service Layer**. The following diagram shows the proper approach
    to designing our data-access layer:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前图中，您可以看到**服务层**与**数据访问层**协作。为了避免应用程序逻辑和数据访问逻辑之间的耦合，我们应该通过接口公开它们的功能，因为接口促进了协作组件之间的解耦。如果我们通过实现接口使用数据访问逻辑，我们可以在不修改**服务层**中的应用程序逻辑的情况下，为应用程序配置任何特定的数据访问策略。以下图显示了设计我们的数据访问层的正确方法：
- en: '![](img/44d71d81-d448-4266-ad80-3c19a09c6b64.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/44d71d81-d448-4266-ad80-3c19a09c6b64.png)'
- en: As shown in the preceding figure, your application service objects, that is,
    **TransferService**, don't handle their own data access. Instead, they delegate
    data access to the repositories. The repository's interface, that is, **AccountRepository**
    in your application, keeps it loosely coupled to the service object. You could
    configure any variant of the implementations-either the Jpa implementation of
    **AccountRepository** (**JpaAccountRepository**), or the Jdbc implementation of
    **AccountRepository** (**JdbcAccountRepository**).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，您的应用程序服务对象，即**TransferService**，不处理自己的数据访问。相反，它们将数据访问委托给存储库。存储库的接口，即您应用程序中的**AccountRepository**，使其与服务对象松散耦合。您可以配置任何实现变体——无论是**AccountRepository**的Jpa实现（**JpaAccountRepository**），还是**AccountRepository**的Jdbc实现（**JdbcAccountRepository**）。
- en: Spring not only provides loose coupling between the application components working
    at the different layers in the layered architecture, but also helps to manage
    the resources in the enterprise layered architecture application. Let's see how
    Spring manages the resources, and what design pattern is using by Spring to solve
    the resource management problem.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 不仅在分层架构中不同层工作的应用组件之间提供松耦合，还帮助企业分层架构应用管理资源。让我们看看 Spring 如何管理资源，以及 Spring
    使用什么设计模式来解决资源管理问题。
- en: The resource management problem
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源管理问题
- en: Let's understand the resource management problem with the help of a real example.
    You must've ordered pizza online sometime. If so, what are the steps involved
    in the process, from the time of ordering the pizza till its delivery? There are
    many steps to this process--We first go to the online portal of the pizza company,
    select the size of the pizza and the toppings. After that, we place our order
    and check out. The order is accepted by the nearest pizza shop; they prepare our
    pizza accordingly, put the toppings on accordingly, wrap this pizza in the bag,
    the delivery boy comes to your place and hands over the pizza to you, and, finally,
    you enjoy your pizza with your friend. Even though there are many steps to this
    process, you're actively involved in only a couple of them. The pizza company
    is responsible for cooking the pizza and delivering it smoothly. You are involved
    only when you need to be, and other steps are taken care of by the pizza company.
    As you saw in this example, there are many steps involved in managing this process,
    and we also have to assign the resources to each step accordingly such that it
    is treated as a complete task without any break in the flow. This is a perfect
    scenario for a powerful design pattern, the template method pattern. The Spring
    framework implements this template design pattern to handle such type scenarios
    in the DAO layer of an application. Let's see what problems we face if we don't
    use Spring, and work with the traditional application instead.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个真实例子来理解资源管理问题。你肯定在线上点过披萨。如果是这样，从下单到披萨送达的过程中涉及哪些步骤？这个过程有很多步骤——我们首先访问披萨公司的在线门户，选择披萨的大小和配料。然后，我们下订单并结账。订单由最近的披萨店接受；他们相应地准备我们的披萨，相应地加上配料，将披萨包在袋子里，送餐员来到你的地方并将披萨交给你，最后，你和你的朋友一起享用披萨。尽管这个过程有很多步骤，但你只积极参与其中的一两个步骤。披萨公司负责烹饪披萨并顺利交付。你只在你需要的时候参与，其他步骤由披萨公司负责。正如你在例子中看到的，管理这个过程涉及许多步骤，我们还需要相应地分配资源到每个步骤，以确保它被视为一个完整的任务，没有任何流程中断。这是一个强大的设计模式——模板方法模式的完美场景。Spring
    框架通过实现这个模板设计模式来处理应用 DAO 层中的此类场景。让我们看看如果我们不使用 Spring，而是使用传统应用会面临什么问题。
- en: 'In a traditional application, we work with the JDBC API to access the data
    from the database. It is a simple application where we access and persist the
    data using the JDBC API, and for this application, the following steps are required:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统应用中，我们使用 JDBC API 从数据库访问数据。这是一个简单的应用，我们使用 JDBC API 访问和持久化数据，对于这个应用，以下步骤是必需的：
- en: Define the connection parameters.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义连接参数。
- en: Access a data source, and establish a connection.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问数据源，并建立连接。
- en: Begin a transaction.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个事务。
- en: Specify the SQL statement.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定 SQL 语句。
- en: Declare the parameters, and provide parameter values.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明参数，并提供参数值。
- en: Prepare and execute the statement.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备并执行语句。
- en: Set up the loop to iterate through the results.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置循环以遍历结果。
- en: Do the work for each iteration--execute the business logic.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个迭代执行工作——执行业务逻辑。
- en: Process any exception.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理任何异常。
- en: Commit or roll back the transaction.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交或回滚事务。
- en: Close the connection, statement, and resultset.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭连接、语句和结果集。
- en: If you use the Spring Framework for the same application, then you have to write
    the code for some steps of the preceding list of steps, while spring takes care
    of all the steps involving the low-level processes such as establishing a connection,
    beginning a transaction, processing any exception in the data layer, and closing
    the connection. Spring manages these steps by using the Template method design
    pattern, which we'll study in the next section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Spring框架来处理相同的应用程序，那么你必须编写前面列表中某些步骤的代码，而Spring则负责所有涉及低级过程（如建立连接、开始事务、处理数据层中的任何异常和关闭连接）的步骤。Spring通过使用模板方法设计模式来管理这些步骤，我们将在下一节中学习。
- en: Implementing the template design pattern
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现模板设计模式
- en: Define the skeleton of an algorithm in an operation, deferring some steps to
    subclasses. Template Method lets subclasses redefine certain steps of an algorithm
    without changing the algorithm's structure.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个操作中定义算法的框架，将一些步骤推迟到子类中。模板方法允许子类重新定义算法的某些步骤，而不改变算法的结构。
- en: -GOF Design Pattern
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: -GOF设计模式
- en: We discussed the Template method design pattern in [Chapter 3](bd05acbb-a42a-4070-9e01-54a8ce049e41.xhtml),
    *Consideration of Structural and Behavioral Patterns*. It is widely used, and
    comes under the structural design pattern of the GOF design pattern family. This
    pattern defines the outline or skeleton of an algorithm, and leaves the details
    to specific implementations later. This pattern hides away large amounts of boilerplate
    code. Spring provides many template classes, such as `JdbcTemplate`, `JmsTemplate`,
    `RestTemplate`, and `WebServiceTemplate`. Mostly, this pattern hides the low-level
    resource management as discussed earlier in the pizza example.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3章](bd05acbb-a42a-4070-9e01-54a8ce049e41.xhtml)“考虑结构和行为模式”中讨论了模板方法设计模式。它被广泛使用，属于GOF设计模式家族的结构设计模式。此模式定义了算法的轮廓或框架，并将细节留给后续的具体实现。此模式隐藏了大量样板代码。Spring提供了许多模板类，如`JdbcTemplate`、`JmsTemplate`、`RestTemplate`和`WebServiceTemplate`。大多数情况下，此模式隐藏了之前在披萨示例中讨论的低级资源管理。
- en: In the example, the process is ordering a pizza for home delivery from an online
    portal. The process followed by the pizza company has some fixed steps for each
    customer, like taking the order, preparing the pizza, adding the toppings according
    to the customer's specifications, and delivering it to the customer's address.
    We can add these steps, or define these steps to a specific algorithm. The system
    can then implement this algorithm accordingly.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，过程是从在线门户订购外卖披萨。披萨公司为每位顾客遵循一些固定的步骤，例如接收订单、准备披萨、根据顾客的规格添加配料，并将其送到顾客的地址。我们可以添加这些步骤，或将这些步骤定义为特定的算法。然后，系统可以相应地实施此算法。
- en: 'Spring implements this pattern to access data from a database. In a database,
    or any other technology, there are some steps that are always common, such as
    establishing a connection to the database, handling transactions, handling exceptions,
    and some clean up actions which are required for each data access process. But
    there are also some steps which are not fixed, but depend on the application''s
    requirement. It is the responsibility of the developer to define these steps.
    But spring allows us to separate the fixed and dynamic parts of the data-access
    process into different parts as templates and callbacks. All fixed steps come
    under the template, and dynamic custom steps come under callbacks. The following
    figure describes the two in detail:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Spring通过实现此模式来访问数据库中的数据。在数据库或任何其他技术中，有一些步骤始终是通用的，例如建立与数据库的连接、处理事务、处理异常，以及每个数据访问过程所需的某些清理操作。但也有一些步骤不是固定的，而是取决于应用程序的需求。定义这些步骤是开发者的责任。但是，Spring允许我们将数据访问过程的固定部分和动态部分分别作为模板和回调分开。所有固定步骤都属于模板，而动态自定义步骤属于回调。以下图详细描述了这两个部分：
- en: '![](img/8047e98e-4603-4f21-b4f4-a0d9b28f703c.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8047e98e-4603-4f21-b4f4-a0d9b28f703c.png)'
- en: As you can see in the preceding figure, all the fixed parts of the process for
    data access wraps to the template classes of the Spring Framework as open and
    close connection, open and close statements, handling exceptions, and managing
    resources. But the other steps like writing SQLs, declaring connection parameters,
    and so on are parts of the callbacks, and callbacks are handled by the developer.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，数据访问过程中的所有固定部分都封装到了Spring框架的模板类中，包括打开和关闭连接、打开和关闭语句、处理异常和管理资源。但像编写SQL语句、声明连接参数等步骤则是回调的一部分，而回调由开发者处理。
- en: Spring provides several implementations of the Template method design pattern
    such as `JdbcTemplate`, `JmsTemplate`, `RestTemplate`, and `WebServiceTemplate`,
    but in this chapter, I will explain only its implementation for the JDBC API as
    `JdbcTemplate`. There is another variant of `JdbcTemplate-NamedParameterJdbcTemplate`,
    which wraps a `JdbcTemplate` to provide named parameters instead of the traditional
    JDBC "`?`" placeholders.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了多种模板方法设计模式的实现，例如`JdbcTemplate`、`JmsTemplate`、`RestTemplate`和`WebServiceTemplate`，但在这章中，我将仅解释其JDBC
    API的实现，即`JdbcTemplate`。还有一个`JdbcTemplate-NamedParameterJdbcTemplate`的变体，它包装了一个`JdbcTemplate`以提供命名参数而不是传统的JDBC
    "`?`"占位符。
- en: Problems with the traditional JDBC
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统JDBC的问题
- en: 'The following are the problems we have to face whenever we work with the traditional
    JDBC API:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们每次使用传统JDBC API时必须面对的问题：
- en: '**Redundant results due to error-prone code**: The traditional JDBC API required
    a lot of tedious code to work with the data access layer. Let''s see the following
    code to connect the Database and execute the desired query:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**由于代码易出错而导致冗余结果**：传统的JDBC API需要编写大量繁琐的代码来处理数据访问层。让我们看看以下代码来连接数据库并执行所需的查询：'
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see in the preceding code, there are some lines which are highlighted;
    only this bold code matters-the rest is boilerplate. Also, this code handles the
    SQLException in the application inefficiently, because the developer doesn't know
    what should be handled there. Let's now look at another problem in the traditional
    JDBC code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如前代码所示，有一些行被突出显示；只有这些粗体代码才是重要的——其余的都是样板代码。此外，这段代码在应用程序中处理SQLException的方式效率低下，因为开发者不知道应该在哪里处理。现在让我们看看传统JDBC代码中的另一个问题。
- en: '**Leads to poor exception handling**: In the preceding code, the exceptions
    in the application are handled very poorly. The developers are not aware of what
    exceptions are to be handled here. SQLException is a checked Exception, which
    means it forces the developers to handle errors, but if you can''t handle it,
    you must declare it. It is a very bad way of handling exceptions, and the intermediate
    methods must declare exception(s) from all methods in the code. It is a form of
    tight coupling.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导致异常处理不佳**：在前面的代码中，应用程序中的异常处理非常糟糕。开发者不清楚应该处理哪些异常。SQLException是一个检查型异常，这意味着它强制开发者处理错误，但如果无法处理，则必须声明它。这是一种非常糟糕的异常处理方式，中间方法必须从代码中的所有方法声明异常（s）。这是一种紧密耦合的形式。'
- en: Solving problems with Spring's JdbcTemplate
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决Spring的JdbcTemplate问题
- en: 'Spring''s `JdbcTemplate` solves both the problems listed in the last section.
    `JdbcTemplate` greatly simplifies the use of the JDBC API, and it eliminates repetitive
    boilerplate code. It alleviates the common causes of bugs, and handles SQLExceptions
    properly without sacrificing power. It provides full access to the standard JDBC
    constructs. Let''s see the same code using Spring''s `JdbcTemplate` class to solve
    these two problems:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Spring的`JdbcTemplate`解决了上一节中列出的两个问题。`JdbcTemplate`极大地简化了JDBC API的使用，并消除了重复的样板代码。它缓解了常见的错误原因，并正确处理SQLExceptions，而不牺牲功能。它提供了对标准JDBC构造的完全访问。让我们看看使用Spring的`JdbcTemplate`类来解决这两个问题的相同代码：
- en: '**Removing redundant code from the application using JdbcTemplate**: Suppose
    you want a count of the accounts in a bank. The following code is required if
    you use the `JdbcTemplate` class:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用JdbcTemplate从应用程序中删除冗余代码**：假设您想获取银行账户的数量。如果您使用`JdbcTemplate`类，则需要以下代码：'
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you want to access the list of accounts for a particular user ID:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想访问特定用户ID的账户列表：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see in the preceding code, you don't need to write the code for Open
    and Close database connection, for preparing a statement to execute query, and
    so on.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如前代码所示，您不需要编写打开和关闭数据库连接、准备执行查询的语句等代码。
- en: '**Data Access Exceptions**: Spring provides a consistent exception hierarchy
    to handle technology-specific exceptions like SQLException to its own exception
    class hierarchy with `DataAccessException` as the root exception. Spring wraps
    these original exceptions into different unchecked exceptions. Now Spring does
    not force the developers to handle these exceptions at development time. Spring
    provides the `DataAccessException` hierarchy to hide whether you are using JPA,
    Hibernate, JDBC, or similar. Actually, it is a hierarchy of sub-exceptions, and
    not just one exception for everything. It is consistent across all the supported
    data access technologies. The following diagram depicts the Spring Data Access
    Exception hierarchy:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据访问异常**：Spring提供了一个一致的异常层次结构来处理技术特定的异常，如SQLException，并将其封装到自己的异常类层次结构中，其中`DataAccessException`作为根异常。Spring将这些原始异常包装成不同的未检查异常。现在Spring不会强迫开发者在开发时间处理这些异常。Spring提供了`DataAccessException`层次结构来隐藏你是在使用JPA、Hibernate、JDBC还是类似的技术。实际上，它是一个子异常的层次结构，而不是一个针对所有情况的单一异常。它在所有支持的数据访问技术中都是一致的。以下图表描述了Spring数据访问异常的层次结构：'
- en: '![](img/a72f4691-be06-4a91-a90b-61638a59fd99.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a72f4691-be06-4a91-a90b-61638a59fd99.png)'
- en: As you can see in the preceding figure, Spring's `DataAccessException` extends
    the `RuntimeException`, that is, it is an unchecked exception. In an enterprise
    application, unchecked exceptions can be thrown up the call hierarchy to the best
    place to handle it. The good thing is that the methods in between don't know about
    it in the application.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前图所示，Spring的`DataAccessException`扩展了`RuntimeException`，即它是一个未检查的异常。在企业应用中，未检查的异常可以被抛到调用层次结构中的最佳处理位置。好事是应用中的方法之间并不知道这一点。
- en: Let's first discuss how to configure Spring with a data source to be able to
    connect the database, before declaring the templates and repositories in a Spring
    application.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论如何在Spring应用中配置数据源以连接数据库，然后再声明模板和仓库。
- en: Configuring the data source and object pool pattern
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置数据源和对象池模式
- en: In the Spring Framework, DataSource is part of the JDBC API, and it provides
    a connection to the database. It hides many boilerplate codes for connection pooling,
    exception handling, and transaction management issues from the application code.
    As a developer, you let it focus on your business logic only. Don't worry about
    connection pooling, exception handling, and managing transactions; it is the responsibility
    of the application administrators how they set up the container managed data source
    in production. You just write the code, and test that code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring框架中，DataSource是JDBC API的一部分，它提供了数据库的连接。它隐藏了连接池、异常处理和事务管理问题的大量样板代码，从而从应用代码中抽象出来。作为开发者，你只需让它专注于你的业务逻辑即可。无需担心连接池、异常处理和管理事务；在生产环境中如何设置容器管理的数据源是应用管理员的职责。你只需编写代码，并测试这些代码。
- en: In an enterprise application, we can retrieve DataSource in several ways. We
    can use the JDBC driver to retrieve DataSource, but it is not the best approach
    to create DataSource in the production environment. As performance is one of the
    key issues during application development, Spring implements the object pool pattern
    to provide DataSource to the application in a very efficient way. The object pool
    pattern says that *creation of objects is expensive rather than reuse.*
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业应用中，我们可以通过几种方式检索DataSource。我们可以使用JDBC驱动来检索DataSource，但在生产环境中创建DataSource不是最佳方法。因为性能是应用开发期间的关键问题之一，Spring通过实现对象池模式以非常高效的方式为应用提供DataSource。对象池模式表明“对象的创建比重用更昂贵。”
- en: Spring allows us to implement the object pool pattern for reusing the DataSource
    object in the application. You can use either the application server and container-managed
    pool (JNDI), or you can create a container by using third-party libraries such
    as DBCP, c3p0, and so on. These pools help to manage the available data sources
    in a better way.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Spring允许我们在应用中实现对象池模式以重用DataSource对象。你可以使用应用服务器和容器管理的池（JNDI），或者你可以使用第三方库如DBCP、c3p0等来创建容器。这些池有助于更好地管理可用的数据源。
- en: 'In your Spring application, there are several options to configure the data-source
    beans, and they are as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的Spring应用中，有几种配置数据源bean的选项，如下所示：
- en: Configuring data source using a JDBC driver
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JDBC驱动配置数据源
- en: Implementing the object pool design pattern to provide data source objects
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现对象池设计模式以提供数据源对象
- en: Configuring the data source using JNDI
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JNDI配置数据源
- en: Configuring the data source using pool connections
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用池连接配置数据源
- en: Implementing the Builder pattern to create an embedded data source
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过实现Builder模式创建嵌入式数据源
- en: Let's see how to configure a data-source bean in a Spring application.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们看看如何在Spring应用程序中配置数据源bean。
- en: Configuring a data source using a JDBC driver
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JDBC驱动程序配置数据源
- en: 'Using a JDBC driver to configure a data-source bean is the simplest data source
    in Spring. The three data source classes provided by Spring are as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JDBC驱动程序配置数据源bean是Spring中最简单的数据源。Spring提供以下三个数据源类：
- en: '`DriverManagerDataSource`: It always creates a new connection for every connection
    request'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DriverManagerDataSource`：对于每个连接请求都创建一个新的连接'
- en: '`SimpleDriverDataSource`: It is similar to the `DriverManagerDataSource` except
    that it works with the JDBC driver directly'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SimpleDriverDataSource`：与`DriverManagerDataSource`类似，但它直接与JDBC驱动程序一起工作'
- en: '`SingleConnectionDataSource`: It returns the same connection for every connection
    request, but it is not a pooled data source'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SingleConnectionDataSource`：对于每个连接请求都返回相同的连接，但它不是一个池化数据源'
- en: 'Let''s see the following code for configuring a data source bean using the
    `DriverManagerDataSource` class of Spring in your application:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码，用于在您的应用程序中使用Spring的`DriverManagerDataSource`类配置数据源bean：
- en: 'In Java-based configuration, the code is as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于Java的配置中，代码如下：
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In XML-based configuration, the code will be like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于XML的配置中，代码将如下所示：
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The data source defined in the preceding code is a very simple data source,
    and we can use it in the development environment. It is not a suitable data source
    for production. I, personally, prefer to use JNDI to configure the data source
    for the production environment. Let's see how.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面代码中定义的数据源是一个非常简单的数据源，我们可以在开发环境中使用它。它不是一个适合生产环境的数据源。我个人更喜欢使用JNDI来配置生产环境的数据源。让我们看看怎么做。
- en: Let's implement the object pool design pattern to provide data source objects
    *by* configuring the data source *using* JNDI.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现对象池设计模式，通过配置使用JNDI的数据源来提供数据源对象。
- en: In a Spring application, you can configure a data source by using the JNDI lookup.
    Spring provides the `<jee:jndi-lookup>` element from Spring's JEE namespace. Let's
    see the code for this configuration.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring应用程序中，您可以通过使用JNDI查找来配置数据源。Spring提供了来自Spring的JEE命名空间的`<jee:jndi-lookup>`元素。让我们看看这个配置的代码。
- en: 'In XML configuration, the code is given as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在XML配置中，代码如下所示：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In Java configuration, the code is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java配置中，代码如下：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Application servers like WebSphere or JBoss allow you to configure data sources
    to be prepared via JNDI. Even a web container like Tomcat allows you to configure
    data sources to be prepared via JNDI. These servers manage the data sources in
    your application. It is beneficial, because the performance of the data source
    will be greater, as the application servers are often pooled. And they can be
    managed completely external to the application. This is one of the best ways to
    configure a data source to be retrieved via JNDI. If you are not able to retrieve
    through the JNDI lookup in production, you can choose another, better option,
    which we'll discuss next.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于WebSphere或JBoss这样的应用服务器允许您通过JNDI配置数据源以进行准备。甚至像Tomcat这样的Web容器也允许您通过JNDI配置数据源以进行准备。这些服务器管理您应用程序中的数据源。这很有益，因为数据源的性能会更高，因为应用服务器通常都是池化的。并且它们可以完全在应用程序外部进行管理。这是配置通过JNDI检索数据源的最佳方式之一。如果您在生产环境中无法通过JNDI查找来检索，您可以选择另一个更好的选项，我们将在下面讨论。
- en: Configuring the data source using pool connections
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用池连接配置数据源
- en: 'The following open-sources technologies provide pooled data sources:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下开源技术提供了池化数据源：
- en: Apache commons DBCP
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache Commons DBCP
- en: c3p0
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: c3p0
- en: BoneCP
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BoneCP
- en: The following code configures DBCP's `BasicDataSource`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码配置了DBCP的`BasicDataSource`。
- en: 'The XML-based DBCP configuration is given as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 基于XML的DBCP配置如下：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The Java-based DBCP configuration is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Java的DBCP配置如下：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see in the preceding code, there are many other properties which
    are introduced for a pooled data sources provider. The properties of the `BasicDataSource`
    class in Spring are listed next:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，还有许多其他属性是为池化数据源提供者引入的。Spring中`BasicDataSource`类的属性列表如下：
- en: '`initialSize`: This is the number of connections created at the time of initialization
    of the pool.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialSize`: 这是池初始化时创建的连接数量。'
- en: '`maxActive`: This is the maximum number of connections that can be allocated
    from the pool at the time of initialization of the pool. If you set this value
    to 0, that means there''s no limit.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxActive`: 这是池初始化时可以从池中分配的最大连接数。如果您将此值设置为 0，则表示没有限制。'
- en: '`maxIdle`: This is the maximum number of connections that can be idle in the
    pool without extras being released. If you set this value to 0, that means there''s
    no limit.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxIdle`: 这是池中可以空闲的最大连接数，而无需释放额外的连接。如果您将此值设置为 0，则表示没有限制。'
- en: '`maxOpenPreparedStatements`: This is the maximum number of prepared statements
    that can be allocated from the statement pool at the time of initialization of
    the pool. If you set this value to `0`, that means there''s no limit.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxOpenPreparedStatements`: 这是在池初始化时可以从语句池中分配的最大准备语句数量。如果您将此值设置为 `0`，则表示没有限制。'
- en: '`maxWait`: This is the maximum waiting time for a connection to be returned
    to the pool before an exception is thrown. If you set it to 1, it means wait indefinitely.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxWait`: 这是抛出异常之前等待连接返回池中的最大时间。如果您将其设置为 1，则表示无限期等待。'
- en: '`minEvictableIdleTimeMillis`: This is the maximum time duration a connection
    can remain idle in the pool before it''s eligible for eviction.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minEvictableIdleTimeMillis`: 这是连接在池中保持空闲状态的最长时间，在此之后它才有资格被回收。'
- en: '`minIdle`: This is the minimum number of connections that can remain idle in
    the pool without new connections being created.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minIdle`: 这是池中可以保持空闲的最小连接数，而无需创建新的连接。'
- en: Implementing the Builder pattern to create an embedded data source
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现构建器模式以创建嵌入式数据源
- en: 'In application development, the embedded database is very useful, because it
    doesn''t require a separate database server that your application connects. Spring
    provides one more data source for embedded databases. It is not powerful enough
    for the production environment. We can use the embedded data source for the development
    and testing environment. In Spring, the `jdbc` namespace configures an embedded
    database, `H2`, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序开发中，嵌入式数据库非常有用，因为它不需要一个单独的数据库服务器，您的应用程序可以连接到它。Spring 为嵌入式数据库提供另一个数据源。它对于生产环境来说并不足够强大。我们可以使用嵌入式数据源进行开发和测试环境。在
    Spring 中，`jdbc` 命名空间如下配置嵌入式数据库 `H2`：
- en: 'In XML configuration, `H2` is configured as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 XML 配置中，`H2` 配置如下：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In Java configuration, `H2` is configured as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 配置中，`H2` 配置如下：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see in the preceding code, Spring provides the `EmbeddedDatabaseBuilder`
    class. It actually implements the Builder design pattern to create the object
    of the `EmbeddedDatabaseBuilder` class.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，Spring 提供了 `EmbeddedDatabaseBuilder` 类。它实际上实现了构建器设计模式来创建 `EmbeddedDatabaseBuilder`
    类的对象。
- en: Let's see one more design pattern in the next section.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一节中的另一个设计模式。
- en: Abstracting database access using the DAO pattern
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 DAO 模式抽象数据库访问
- en: The data access layer works as an aspect between the business layer and the
    database. Data accessing depends on the business call, and it varies depending
    on the source of the data for example database, flat files, XML, and so on. So,
    we can abstract all access by providing an interface. This is known as the data
    access object pattern. From the application's point of view, it makes no difference
    when it accesses a relational database or parses XML files using a DAO.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 数据访问层在业务层和数据库之间作为一个方面工作。数据访问依赖于业务调用，并且根据数据源的不同而变化，例如数据库、平面文件、XML 等。因此，我们可以通过提供一个接口来抽象所有访问。这被称为数据访问对象模式。从应用程序的角度来看，它访问关系数据库或使用
    DAO 解析 XML 文件时没有区别。
- en: In an earlier version, EJB provided entity beans managed by the container; they
    were distributed, secure, and transactional components. These beans were very
    transparent to the client, that is, for the service layer in the application,
    they had automatic persistence without the care of underlying database. But mostly,
    the features offered by these entity beans were not required for your application,
    as you needed to persist data to the database. Due to *this,* some non-required
    features of the entity beans, like network traffic, increased, and your application's
    performance was impacted. And that time, the entity beans needed to run inside
    the EJB containers, which is why it was very difficult to test.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期版本中，EJB 提供了由容器管理的实体豆；它们是分布式、安全且事务性的组件。这些豆对客户端非常透明，也就是说，对于应用程序中的服务层，它们具有自动持久性，无需关心底层数据库。但通常，实体豆提供的功能对于你的应用程序来说不是必需的，因为你需要将数据持久化到数据库中。由于*这个*原因，实体豆的一些非必需功能，如网络流量，增加了，影响了应用程序的性能。当时，实体豆需要在
    EJB 容器中运行，这就是为什么很难测试。
- en: 'In a nutshell, if you are working with the traditional JDBC API or earlier
    EJB versions, you will face the following problems in your application:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，如果你正在使用传统的 JDBC API 或更早的 EJB 版本，你将在应用程序中遇到以下问题：
- en: In a traditional JDBC application, you merge the business tier logic with persistence
    logic.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在传统的 JDBC 应用程序中，你将业务层逻辑与持久化逻辑合并。
- en: The Persistence tier or DAO layer is not consistent for the service layer or
    business tier. But DAO should be consistent for the service layer in an enterprise
    application.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久层或 DAO 层对于服务层或业务层来说并不一致。但在企业应用程序中，DAO 应该对服务层保持一致。
- en: In a traditional JDBC application, you have to handle a lot of boilerplate code
    like making and closing connection, preparing statement, handling exceptions,
    and so on. It degrades reusability and increases development time.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在传统的 JDBC 应用程序中，你必须处理大量的样板代码，如创建和关闭连接、准备语句、处理异常等。这降低了可重用性并增加了开发时间。
- en: With EJB, the entity bean was created *as* an overhead to the application, and
    was difficult to test.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 EJB，实体豆被视为应用程序的额外开销，并且很难测试。
- en: Let's see how spring solves these problems.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Spring 如何解决这些问题。
- en: The DAO pattern with the Spring Framework
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于 Spring 框架的 DAO 模式
- en: Spring provides a comprehensive JDBC module to design and develop JDBC-based
    DAOs. These DAOs in the application take care of all the boilerplate code of the
    JDBC API, and help to provide a consistent API for data access. In the Spring
    JDBC, DAO is a generic object to access data for the business tier, and it provides
    a consistent interface to the services at the business tier. The main goal behind
    the DAO's classes is to abstract the underlying data access logic from the services
    at the business tier.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 提供了一个全面的 JDBC 模块来设计和开发基于 JDBC 的 DAO。这些应用程序中的 DAO 负责处理 JDBC API 的所有样板代码，并帮助提供一致的数据访问
    API。在 Spring JDBC 中，DAO 是一个通用的对象，用于访问业务层的数据库，并为业务层的服务提供一致的接口。DAO 类背后的主要目标是抽象出业务层服务底层数据访问逻辑。
- en: 'In our previous example, we saw how the pizza company helped us to understand
    the resource management problem, and now, we will continue with our bank application.
    Let''s see the following example on how to implement DAOs in an application. Suppose,
    in our bank application, we want the total number accounts in a branch in the
    city. For this, we will first create an interface for the DAO. It promotes programming
    to interface, as discussed earlier. It is one of the best practices of the design
    principles. This DAO interface will be injected with the services at the business
    tier, and we can create a number of concrete classes of the DAO interface according
    to the underlying databases in the application. That means our DAO layer will
    be consistent for the business layer. Let''s create a DAO interface as following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们看到了披萨公司如何帮助我们理解资源管理问题，现在，我们将继续使用我们的银行应用程序。让我们看看以下示例，了解如何在应用程序中实现
    DAO。假设，在我们的银行应用程序中，我们想要获取城市中某个分支行的总账户数。为此，我们首先为 DAO 创建一个接口。正如之前讨论的那样，这促进了面向接口的编程。这是设计原则的最佳实践之一。这个
    DAO 接口将被注入到业务层的服务中，我们可以根据应用程序中的底层数据库创建 DAO 接口的多个具体类。这意味着我们的 DAO 层将保持与业务层的一致性。让我们创建一个如下所示的
    DAO 接口：
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s see a concrete implementation of the DAO interface using Spring''s `JdbcDaoSupport`
    class:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用 Spring 的 `JdbcDaoSupport` 类实现 DAO 接口的具体实现：
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, you can see that the `AccountDaoImpl` class implements
    the `AccountDao` DAO interface, and it extends Spring's `JdbcDaoSupport` class
    to ease development with JDBC-based. This class provides a `JdbcTemplate` to its
    subclasses by using `getJdbcTemplate()`. The `JdbcDaoSupport` class is associated
    with a data source, and supplies the `JdbcTemplate` object for use in the DAO.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，您可以看到 `AccountDaoImpl` 类实现了 `AccountDao` DAO 接口，并扩展了 Spring 的 `JdbcDaoSupport`
    类以简化基于 JDBC 的开发。此类通过 `getJdbcTemplate()` 为其子类提供 `JdbcTemplate`。`JdbcDaoSupport`
    类与数据源相关联，并为 DAO 提供用于使用的 `JdbcTemplate` 对象。
- en: Working with JdbcTemplate
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JdbcTemplate
- en: 'As you learned earlier, Spring''s `JdbcTemplate` solves two main problems in
    the application. It solves the redundant code problem as well as poor exception
    handling of the data access code in the application. Without `JdbcTemplate` in
    your application, only 20% of the code is required for querying a row, but 80%
    is boilerplate which handles exceptions and manages resources. If you use `JdbcTemplate`,
    then there is no need to worry about the 80% boilerplate code. Spring''s `JdbcTemplate`,
    in a nutshell, is responsible for the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如您之前所学的，Spring 的 `JdbcTemplate` 解决了应用程序中的两个主要问题。它解决了冗余代码问题以及应用程序中数据访问代码的糟糕异常处理。如果没有
    `JdbcTemplate`，查询一行数据所需的代码只有 20%，但 80% 是样板代码，用于处理异常和管理资源。如果您使用 `JdbcTemplate`，则无需担心
    80% 的样板代码。简而言之，Spring 的 `JdbcTemplate` 负责以下：
- en: Acquisition of the connection
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接的获取
- en: Participation in the transaction
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参与事务
- en: Execution of the statement
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语句的执行
- en: Processing of the result set
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理结果集
- en: Handling any exceptions
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理任何异常
- en: Release of the connection
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接的释放
- en: Let's see when to use `JdbcTemplate` in the application, and how to create it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在应用程序中何时使用 `JdbcTemplate`，以及如何创建它。
- en: When to use JdbcTemplate
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用 JdbcTemplate
- en: '`JdbcTemplate` is useful in standalone applications, and anytime when JDBC
    is needed. It is suitable in utility or test code to clean up messy legacy code.
    Also, in any layered application, you can implement a repository or data access
    object. Let''s see how to create it in an application.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`JdbcTemplate` 在独立应用程序中非常有用，在任何需要 JDBC 的情况下都适用。它适合在实用程序或测试代码中清理混乱的遗留代码。此外，在任何分层应用程序中，您都可以实现存储库或数据访问对象。让我们看看如何在应用程序中创建它。'
- en: Creating a JdbcTemplate in an application
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在应用程序中创建 JdbcTemplate
- en: 'If you want to create an object of the `JdbcTemplate` class to access data
    in your Spring application, you need to remember that it requires a `DataSource`
    to create the database connection. Let''s create a template once, and reuse it.
    Do not create one for each thread, it is thread-safe after construction:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在 Spring 应用程序中创建 `JdbcTemplate` 类的实例以访问数据，您需要记住它需要一个 `DataSource` 来创建数据库连接。让我们创建一个模板一次，并重用它。不要为每个线程创建一个，它构建后是线程安全的：
- en: '[PRE13]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s configure a `JdbcTemplate` bean in Spring with the following `@Bean`
    method:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下 `@Bean` 方法在 Spring 中配置一个 `JdbcTemplate` 对象：
- en: '[PRE14]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, we use the constructor injection to inject the `DataSource`
    with the `JdbcTemplate` bean in the Spring application. The `dataSource` bean
    being referenced can be any implementation of `javax.sql.DataSource`. Let's see
    how to use the `JdbcTemplate` bean in your JDBC-based repository to access the
    database in your application.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用构造函数注入在 Spring 应用程序中将 `DataSource` 注入到 `JdbcTemplate` 对象中。被引用的 `dataSource`
    对象可以是 `javax.sql.DataSource` 的任何实现。让我们看看如何在基于 JDBC 的存储库中使用 `JdbcTemplate` 对象来访问应用程序中的数据库。
- en: Implementing a JDBC-based repository
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现基于 JDBC 的存储库
- en: 'We can use the Spring''s `JdbcTemplate` class to implement the repositories
    in a Spring application. Let''s see how to implement the repository class based
    on the JDBC template:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Spring 的 `JdbcTemplate` 类在 Spring 应用程序中实现存储库。让我们看看如何基于 JDBC 模板实现存储库类：
- en: '[PRE15]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding code, the `DataSource` bean is injected with the `JdbcAccountRepository`
    class by using the constructor injection. By using this DataSource, we created
    a `JdbcTemplate` object for accessing the data. The following methods are provided
    by `JdbcTemplate` to access data from the database:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，使用构造函数注入将 `DataSource` 对象注入到 `JdbcAccountRepository` 类中。通过使用此数据源，我们创建了一个
    `JdbcTemplate` 对象以访问数据。`JdbcTemplate` 提供以下方法来从数据库访问数据：
- en: '`queryForObject(..)`: This is a query for simple java types (`int`, `long`,
    `String`, `Date` ...) and for custom domain objects.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`queryForObject(..)`: 这是一个针对简单 Java 类型（`int`、`long`、`String`、`Date` ...）和自定义域对象的查询。'
- en: '`queryForMap(..)`: This is used when expecting a single row. `JdbcTemplate`
    returns each row of a `ResultSet` as a Map.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`queryForMap(..)`: 当期望单行时使用。`JdbcTemplate` 将 `ResultSet` 的每一行作为 Map 返回。'
- en: '`queryForList(..)`: This is used when expecting multiple rows.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`queryForList(..)`: 当期望多行时使用。'
- en: Note that `queryForInt` and `queryForLong` have been deprecated since Spring
    3.2; you can just use `queryForObject` instead (API improved in Spring 3).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`queryForInt` 和 `queryForLong` 自 Spring 3.2 以来已被弃用；你可以直接使用 `queryForObject`
    代替（API 在 Spring 3 中得到改进）。
- en: Often, it is useful to map relational data into domain objects, for example,
    a `ResultSet` to an Account in the last code. Spring's `JdbcTemplate` supports
    this by using a callback approach. Let's discuss Jdbc callback interfaces in the
    next section.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，将关系数据映射到域对象中非常有用，例如，将 `ResultSet` 映射到最后一行代码中的 Account。Spring 的 `JdbcTemplate`
    通过使用回调方法支持这一点。让我们在下一节讨论 Jdbc 回调接口。
- en: Jdbc callback interfaces
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jdbc 回调接口
- en: 'Spring provides three callback interfaces for JDBC as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 提供了以下三个 JDBC 回调接口：
- en: '**Implementing RowMapper**: Spring provides a `RowMapper` interface for mapping
    a single row of a `ResultSet` to an object. It can be used for both single and
    multiple row queries. It is parameterized as of Spring 3.0:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现 RowMapper**：Spring 提供了一个 `RowMapper` 接口，用于将 `ResultSet` 的单行映射到对象。它可以用于单行和多行查询。自
    Spring 3.0 起它是参数化的：'
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let's understand this with the help of an example.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来理解这一点。
- en: Creating a RowMapper class
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 RowMapper 类
- en: 'In the following example, a class, `AccountRowMapper`, implements the `RowMapper`
    interface of the Spring Jdbc module:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，一个类，`AccountRowMapper`，实现了 Spring Jdbc 模块的 `RowMapper` 接口：
- en: '[PRE17]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, a class, `AccountRowMapper`, maps a row of the result
    set to the domain object. This row-mapper class implements the `RowMapper` callback
    interface of the Spring Jdbc module.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，一个类，`AccountRowMapper`，将结果集的一行映射到域对象。这个行映射器类实现了 Spring Jdbc 模块的 `RowMapper`
    回调接口。
- en: '**Query for single row with JdbcTemplate**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 JdbcTemplate 查询单行**'
- en: 'Let''s now see how the row-mapper maps a single row to the domain object in
    the application in the following code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看行映射器如何在以下代码中将单行映射到应用程序中的域对象：
- en: '[PRE18]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, there is no need to add typecasting for the Account object. The `AccountRowMapper`
    class maps the rows to the Account objects.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，不需要为 Account 对象添加类型转换。`AccountRowMapper` 类将行映射到 Account 对象。
- en: '**Query for multiple rows**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**查询多行**'
- en: 'The following code shows how the row mapper maps multiple rows to the list
    of domain objects:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了行映射器如何将多行映射到域对象列表：
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: RowMapper is the best choice when each row of a `ResultSet` maps to a domain
    object.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `ResultSet` 的每一行都映射到域对象时，`RowMapper` 是最佳选择。
- en: Implementing RowCallbackHandler
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 RowCallbackHandler
- en: 'Spring provides a simpler `RowCallbackHandler` interface when there is no return
    object. It is used to stream rows to a file, converting the rows to XML, and filtering
    them before adding to a collection. But filtering in SQL is much more efficient,
    and is faster than the JPA equivalent for big queries. Let''s look at the following
    example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有返回对象时，Spring 提供了一个更简单的 `RowCallbackHandler` 接口。它用于将行流式传输到文件中，将行转换为 XML，并在添加到集合之前进行过滤。但
    SQL 中的过滤效率更高，对于大型查询来说比 JPA 等效更快。让我们看看以下示例：
- en: '[PRE20]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Example for using a RowCallbackHandler**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 RowCallbackHandler 的示例**'
- en: 'The following code is an example of a `RowCallbackHandler` in the application:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是应用程序中 `RowCallbackHandler` 的一个示例：
- en: '[PRE21]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In preceding code, we have created a `RowCallbackHandler` implementation; the
    `AccountReportWriter` class implements this interface to process the result set
    returned from the database. Let''s see the following code how to use AccountReportWriter
    call back class:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们已经创建了一个 `RowCallbackHandler` 实现类；`AccountReportWriter` 类实现了这个接口来处理从数据库返回的结果集。让我们看看以下代码如何使用
    AccountReportWriter 回调类：
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`RowCallbackHandler` is the best choice when no value should be returned from
    the callback method for each row, especially for large queries.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当回调方法对于每一行都不应返回值时，`RowCallbackHandler` 是最佳选择，尤其是在大型查询中。
- en: Implementing ResultSetExtractor
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 ResultSetExtractor
- en: 'Spring provides a `ResultSetExtractor` interface for processing an entire `ResultSet`
    at once. Here, you are responsible for iterating the `ResultSet`, for example,
    for mapping the entire `ResultSet` to a single object. Let''s see the following
    example:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 提供了一个 `ResultSetExtractor` 接口，用于一次性处理整个 `ResultSet`。在这里，你负责迭代 `ResultSet`，例如，将整个
    `ResultSet` 映射到单个对象。让我们看看以下示例：
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Example for using a ResultSetExtractor**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用ResultSetExtractor的示例**'
- en: 'The following line of code implements the `ResultSetExtractor` interface in
    the application:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行代码在应用程序中实现了`ResultSetExtractor`接口：
- en: '[PRE24]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This preceding class, `AccountExtractor`, implements `ResultSetExtractor`,
    and it is used to create an object for the entire data of the result set returned
    from the database. Let''s see how to use this class in your application:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类`AccountExtractor`实现了`ResultSetExtractor`接口，并用于创建数据库返回的结果集的全部数据的对象。让我们看看如何在您的应用程序中使用这个类：
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The previous code is responsible for accessing all the accounts of a bank, and
    for preparing a list of accounts by using the `AccountExtractor` class. This class
    implements the `ResultSetExtractor` callback interface of the Spring Jdbc module.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码负责访问银行的全部账户，并使用`AccountExtractor`类准备账户列表。这个类实现了Spring Jdbc模块的`ResultSetExtractor`回调接口。
- en: '`ResultSetExtractor` is the best choice when multiple rows of a `ResultSet`
    map to a single object.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当`ResultSet`的多行映射到单个对象时，`ResultSetExtractor`是最好的选择。
- en: Best practices for Jdbc and configuring JdbcTemplate
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jdbc和配置JdbcTemplate的最佳实践
- en: 'Instances of the `JdbcTemplate` class are thread-safe once configured. As a
    best practice of configuring the `JdbcTemplate` in a Spring application, it should
    be constructed in the constructor injection or setter injection of the data source
    bean in your DAO classes by passing that data source bean as a constructor argument
    of the `JdbcTemplate` class. This leads to DAOs that look, in part, like the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置，`JdbcTemplate`类的实例就是线程安全的。作为在Spring应用程序中配置`JdbcTemplate`的最佳实践，它应该在DAO类的构造函数注入或setter注入中构建数据源bean，通过将数据源bean作为`JdbcTemplate`类的构造函数参数传递。这会导致DAO看起来部分如下：
- en: '[PRE26]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you want to configure the embedded database at the time of development of
    the application, as the best practice, the embedded database will always be assigned
    a uniquely generated name. This is because in the Spring container, the embedded
    database is made available by configuring a bean of type `javax.sql.DataSource`,
    and that data source bean is injected to the data access objects.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想在应用程序开发时配置嵌入式数据库，作为最佳实践，嵌入式数据库将始终被分配一个唯一生成的名称。这是因为Spring容器通过配置一个类型为`javax.sql.DataSource`的bean来提供嵌入式数据库，并且该数据源bean被注入到数据访问对象中。
- en: 'Always use object pooling; this can be achieved in two ways:'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是使用对象池；这可以通过两种方式实现：
- en: '**Connection pooling**: It allows the pool manager to keep the connections
    in a *pool* after they are closed'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接池**：它允许池管理器在关闭后保持连接在*池*中。'
- en: '**Statement pooling**: It allows the driver to reuse the prepared Statement
    objects.'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语句池化**：它允许驱动程序重用已准备的语句对象。'
- en: Choose the commit mode carefully
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仔细选择提交模式
- en: 'Consider removing the auto-commit mode for your application, and use manual
    commit instead to better control the commit logic, as follows:'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑移除应用程序的自动提交模式，并使用手动提交来更好地控制提交逻辑，如下所示：
- en: '[PRE27]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: An application without data is like a car without fuel. Data is the heart of
    an application. Some applications may exist in the world without data, but these
    applications are simply showcase applications such as static blogs. Data is an
    important part of an application, and you need to develop data-access code for
    your application. This code should very simple, robust, and customizable.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 没有数据的应用程序就像没有燃料的汽车。数据是应用程序的核心。有些应用程序可能在没有数据的情况下存在于世界上，但这些应用程序只是展示应用程序，如静态博客。数据是应用程序的重要组成部分，您需要为您的应用程序开发数据访问代码。此代码应该非常简单、健壮且可定制。
- en: In a traditional Java application, you could use JDBC to access the data. It
    is a very basic way, but sometimes, it is very messy to define specifications,
    handle JDBC exceptions, make database connections, load drivers, and so on. Spring
    simplifies these things by removing the boilerplate code and simplifying JDBC
    exception handling. You just write your SQL that should be executed in the application,
    and the rest is managed by the Spring framework.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的Java应用程序中，您可以使用JDBC来访问数据。这是一个非常基本的方法，但有时，定义规范、处理JDBC异常、建立数据库连接、加载驱动程序等操作非常混乱。Spring通过删除样板代码并简化JDBC异常处理来简化这些事情。您只需在应用程序中编写要执行的SQL，其余的由Spring框架管理。
- en: In this chapter, you have seen how Spring provides support at the backend for
    data access and data persistence. JDBC is useful, but using the JDBC API directly
    is a tedious and error-prone task. `JdbcTemplate` simplifies data access, and
    enforces consistency. Data access with Spring uses the layered architecture principles-the
    higher layers should not know about data management. It isolates SQLException
    via Data Access Exceptions, and creates a hierarchy to make them easier to handle.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经了解了Spring如何为数据访问和数据持久化提供后端支持。JDBC很有用，但直接使用JDBC API是一项繁琐且容易出错的任务。`JdbcTemplate`简化了数据访问，并强制执行一致性。使用Spring进行数据访问遵循分层架构原则——高层不应了解数据管理。它通过数据访问异常隔离`SQLException`，并创建一个层次结构以使它们更容易处理。
- en: In the next chapter, we'll continue to discuss data access and persistence with
    the ORM framework, like Hibernate and JPA.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续讨论使用ORM框架（如Hibernate和JPA）进行数据访问和持久化。
