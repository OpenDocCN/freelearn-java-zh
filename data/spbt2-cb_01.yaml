- en: Getting Started with Spring Boot
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot 入门
- en: Spring Boot has a lot of starters that are already a part of the Spring Boot
    family. This chapter will provide you with an overview of [http://start.spring.io/](http://start.spring.io),
    available starter modules, and will also show you how to make a project Bootiful,
    as Josh Long likes to call it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 有很多启动器，它们已经是 Spring Boot 家族的一部分。本章将为您提供一个关于 [http://start.spring.io/](http://start.spring.io)
    的概述，可用的启动器模块，并还将向您展示如何使项目 Bootful，正如 Josh Long 喜欢称呼的那样。
- en: 'In this chapter, we will learn about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Using a Spring Boot template and starter
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring Boot 模板和启动器
- en: Creating a simple application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的应用程序
- en: Launching an application using Gradle
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Gradle 启动应用程序
- en: Using the command-line runners
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令行运行器
- en: Setting up a database connection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置数据库连接
- en: Setting up a data repository service
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置数据存储库服务
- en: Scheduling executors
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度执行器
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the fast-paced world of today's software development, the speed of application
    creation and the need for rapid prototyping are becoming more and more important.
    If you are developing a software using a JVM language, Spring Boot is exactly
    the kind of framework that will give you the power combined with the flexibility
    that will enable you to produce high-quality software at a rapid pace. So, let's
    take a look at how Spring Boot can help you to make your application Bootiful.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今软件开发的快节奏世界中，应用程序创建的速度和快速原型设计的需要变得越来越重要。如果您正在使用 JVM 语言开发软件，Spring Boot 正是那种能够给您提供力量和灵活性的框架，这将使您能够以快速的速度生产高质量的软件。因此，让我们看看
    Spring Boot 如何帮助您使您的应用程序 Bootful。
- en: Using a Spring Boot template and starter
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring Boot 模板和启动器
- en: Spring Boot comes with over 40 different starter modules, which provide ready-to-use
    integration libraries for many different frameworks, such as database connections
    that are both relational and NoSQL, web services, social network integration,
    monitoring libraries, logging, template rendering, and the list just keeps going
    on. While it is not practically feasible to cover every single one of these components,
    we will go over the important and popular ones to get an idea of the possibilities
    and the ease of application development that Spring Boot provides us with.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 包含超过 40 个不同的启动器模块，为许多不同的框架提供现成的集成库，例如既支持关系型数据库也支持 NoSQL 数据库的连接、网络服务、社交网络集成、监控库、日志记录、模板渲染，等等。虽然实际上不可能涵盖所有这些组件，但我们将介绍重要且流行的组件，以了解
    Spring Boot 提供的可能性和应用开发的便捷性。
- en: How to do it...
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will start by creating a basic simple project skeleton, and Spring Boot
    will help us achieve this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个基本的简单项目骨架，Spring Boot 将帮助我们实现这一点：
- en: Head over to [http://start.spring.io](http://start.spring.io/)
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 [http://start.spring.io](http://start.spring.io)
- en: Fill out a simple form with the details about our project
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写有关我们项目的详细信息简单表格
- en: Click on Generate Project alt + a premade project skeleton will download; this
    is where we begin
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击生成项目 alt + a 预制项目骨架将下载；这就是我们开始的地方
- en: How it works...
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'You will see the Project Dependencies section, where we can choose the kind
    of functionalities that our application will perform: Will it connect to a database?
    Will it have a web interface? Do we plan to integrate with any of the social networks
    bake in operational support? and so on. By selecting the desired technologies,
    the appropriate starter libraries will be added automatically to the dependency
    list of our pregenerated project template.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到项目依赖关系部分，我们可以选择我们的应用程序将执行的功能类型：它是否会连接到数据库？它是否会有一个网络界面？我们是否计划与任何社交网络集成以及内置操作支持？等等。通过选择所需的技术，适当的启动器库将自动添加到我们预生成的项目模板的依赖列表中。
- en: Before we proceed with the generation of our project, let's go over what exactly
    a Spring Boot starter is and the benefits it provides us with.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们生成项目之前，让我们了解一下 Spring Boot 启动器究竟是什么以及它为我们提供了哪些好处。
- en: 'Spring Boot aims to make it easy to get started with creating an application.
    Spring Boot starters are bootstrap libraries that contain a collection of all
    the relevant transitive dependencies that are needed to start a particular functionality.
    Each starter has a special file, which contains the list of all the provided dependencies
    Spring provides. Let''s take a look at the following link for a `spring-boot-starter-test`
    definition as an example:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot旨在使创建应用程序变得容易。Spring Boot启动器是引导库，其中包含启动特定功能所需的所有相关传递依赖项。每个启动器都有一个特殊的文件，其中包含Spring提供的所有提供依赖项的列表。以下是一个以`spring-boot-starter-test`定义为例的链接查看：
- en: '[https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-starters/spring-boot-starter-test/src/main/resources/META-INF/spring.provides](https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-starters/spring-boot-starter-test/src/main/resources/META-INF/spring.provides)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-starters/spring-boot-starter-test/src/main/resources/META-INF/spring.provides](https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-starters/spring-boot-starter-test/src/main/resources/META-INF/spring.provides)'
- en: 'Here we will see the following code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将看到以下代码：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This tells us that by including `spring-boot-starter-test` in our build as a
    dependency, we will automatically get `spring-test`, `spring-boot`, `junit`, `mockito`,
    `hamcrest-library`,`jsonassert`, and `json-path`. These libraries will provide
    us with all the necessary things in order to start writing application tests for
    the software that we will develop, without needing to manually add these dependencies
    to the build file individually.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，通过在我们的构建中包含`spring-boot-starter-test`作为依赖项，我们将自动获得`spring-test`、`spring-boot`、`junit`、`mockito`、`hamcrest-library`、`jsonassert`和`json-path`。这些库将为我们提供编写我们将开发的软件的应用程序测试所需的所有必要事物，而无需手动将这些依赖项单独添加到构建文件中。
- en: With more than 100 starters provided, and with the ongoing community additions
    increasing the list, it is very likely that unless, we find ourselves with the
    need to integrate with a fairly common or popular framework, there is already
    a starter out there that we can use.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了超过100个启动器，并且随着社区添加的持续增加，除非我们发现自己需要与一个相当常见或流行的框架集成，否则很可能已经有一个启动器可供我们使用。
- en: 'The following table shows you the most notable ones so as to give you an idea
    of what is available:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下表展示了最显著的一些，以便您了解可用的选项：
- en: '| **Starter** | **Description** |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **启动器** | **描述** |'
- en: '| `spring-boot-starter` | This is the core Spring Boot starter that provides
    you with all the foundational functionalities. It is depended upon by all other
    starters, so no need to declare it explicitly. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter` | 这是核心Spring Boot启动器，它为您提供了所有基础功能。它是所有其他启动器的依赖项，因此无需显式声明。|'
- en: '| `spring-boot-starter-actuator` | This starter provides you with a functionality
    to monitor, manage an application, and audit. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-actuator` | 此启动器为您提供了监控、管理和审计应用程序的功能。|'
- en: '| `spring-boot-starter-jdbc` | This starter provides you with a support to
    connect and use JDBC databases, connection pools, and so on. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-jdbc` | 此启动器为您提供了连接和使用JDBC数据库、连接池等功能的支持。|'
- en: '| `spring-boot-starter-data-jpa``spring-boot-starter-data-*` | The JPA starter
    provides you with needed libraries so you can use **Java Persistence API** (**JPA**): Hibernate,
    and others.Various `data-* family` starters provide support for a number of datastores,
    such as MongoDB, Data REST, or Solr. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-data-jpa` `spring-boot-starter-data-*` | JPA启动器为您提供了所需的库，以便您可以使用**Java持久化API**（**JPA**）：Hibernate以及其他库。各种`data-*`系列启动器为MongoDB、Data
    REST或Solr等数据存储提供了支持。|'
- en: '| `spring-boot-starter-security` | This brings in all the needed dependencies
    for Spring Security. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-security` | 这引入了所有Spring Security所需的依赖项。|'
- en: '| `spring-boot-starter-social-*` | This allows you to integrate with Facebook,
    Twitter, and LinkedIn. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-social-*` | 这允许您与Facebook、Twitter和LinkedIn集成。|'
- en: '| `spring-boot-starter-test` | This is a starter that contains the dependencies
    for `spring-test` and assorted testing frameworks: JUnit and Mockito, among others.
    |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-test` | 这是一个包含`spring-test`和一系列测试框架（如JUnit和Mockito）依赖项的启动器。|'
- en: '| `spring-boot-starter-web` | This gives you all the needed dependencies for
    web application development. It can be enhanced with `spring-boot-starter-hateoas`,
    `spring-boot-starter-websocket`, `spring-boot-starter-mobile`, or `spring-boot-starter-ws`,
    and assorted template-rendering starters: `sping-boot-starter-thymeleaf` or `spring-boot-starter-mustache`.
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-web` | 这为您提供了开发Web应用程序所需的所有依赖项。它可以与`spring-boot-starter-hateoas`、`spring-boot-starter-websocket`、`spring-boot-starter-mobile`或`spring-boot-starter-ws`以及各种模板渲染启动器（`sping-boot-starter-thymeleaf`或`spring-boot-starter-mustache`）一起增强。|'
- en: '| `spring-cloud-starter-*` | Various `cloud-*` family starters providing support
    for a number of frameworks, such as Netflix OSS, Consul, or AWS. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `spring-cloud-starter-*` | 提供对多个框架（如Netflix OSS、Consul或AWS）支持的多个`cloud-*`家族启动器。|'
- en: Creating a simple application
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的应用程序
- en: Now that we have a basic idea of the starters that are available to us, let's
    go ahead and create our application template at [http://start.spring.io](http://start.spring.io/).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对我们可用的启动器有了基本的了解，让我们继续创建我们的应用程序模板，请访问[http://start.spring.io](http://start.spring.io/)。
- en: How to do it...
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The application that we are going to create is a book catalog management system.
    It will keep a record of books that were published, who the authors were, the
    reviewers, publishing houses, and so forth. We will name our project `BookPub`,
    and apply the following steps:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的应用程序是一个图书目录管理系统。它将记录已出版的书籍、作者、评论者、出版社等信息。我们将我们的项目命名为`BookPub`，并执行以下步骤：
- en: First let's switch to the full version by clicking the link below the Generate
    Project alt + button
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们通过点击下面的链接切换到完整版本 Generate Project alt + 按钮
- en: Choose Gradle Project at the top
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部选择Gradle项目
- en: Use Spring Boot version 2.0.0(SNAPSHOT)
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Spring Boot版本 2.0.0(SNAPSHOT)
- en: 'Use the default proposed Group name: `com.example`'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用默认建议的组名：`com.example`
- en: Enter `bookpub` for an Artifact field
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工件字段中输入`bookpub`
- en: Provide `BookPub` as a Name for the application
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`BookPub`作为应用程序的名称
- en: Specify `com.example.bookpub` as our Package Name
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`com.example.bookpub`指定为我们的包名
- en: Select Jar as Packaging
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Jar作为打包方式
- en: Use Java Version as 8
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Java版本 8
- en: Select the H2, JDBC, and JPA starters from the Search for dependencies selection
    so that we can get the needed artifacts in our `build` file to connect to an H2
    database
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“搜索依赖项”选择中选取H2、JDBC和JPA启动器，以便我们可以在`build`文件中获得连接到H2数据库所需的工件
- en: Click on Generate Project alt + to download the project archive
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击Generate Project alt + 下载项目存档
- en: How it works...
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Clicking on the Generate Project alt + button will download the `bookpub.zip`
    archive, which we will extract from our working directory. In the newly created
    `bookpub` directory, we will see a `build.gradle` file that defines our build.
    It already comes preconfigured with the right version of a Spring Boot plugin
    and libraries, and even includes the extra starters, which we have chosen. The
    following is the code of the `build.gradle` file:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 点击Generate Project alt + 按钮将下载`bookpub.zip`存档，我们将从我们的工作目录中提取它。在新创建的`bookpub`目录中，我们将看到一个`build.gradle`文件，它定义了我们的构建。它已经预配置了正确的Spring
    Boot插件和库版本，甚至包括我们选择的额外启动器。以下为`build.gradle`文件的代码：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We have selected the following starters:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经选择了以下启动器：
- en: '`org.springframework.boot:spring-boot-starter-data-jpa`: This starter pulls
    in the JPA dependency.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.boot:spring-boot-starter-data-jpa`：此启动器引入了JPA依赖项。'
- en: '`org.springframework.boot:spring-boot-starter-jdbc`: This starter pulls in
    the JDBC supporting libraries.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.boot:spring-boot-starter-jdbc`：此启动器引入了JDBC支持库。'
- en: '`com.h2database`: H2 is a particular type of database implementation, namely
    H2.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.h2database`：H2是一种特定的数据库实现，即H2。'
- en: '`org.springframework.boot:spring-boot-starter-test`: This starter pulls all
    the necessary dependencies for running tests. It is only being used during the
    test phase of the build, and it is not included during the regular application
    compile time and runtime.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.boot:spring-boot-starter-test`：此启动器引入了运行测试所需的所有必要依赖项。它仅在构建的测试阶段使用，并且在常规应用程序编译时间和运行时不包括在内。'
- en: As you can see, the `runtime("com.h2database:h2")` dependency is a runtime one.
    This is because we don't really need, and probably don't even want to know, the
    exact type of database to which we will connect at the compile time. Spring Boot
    will autoconfigure the needed settings and create appropriate beans once it detects
    the presence of the `org.h2.Driver` class in the classpath when the application
    is launched. We will look into the inner workings of how and where this happens
    later in this chapter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`runtime("com.h2database:h2")` 依赖项是一个运行时依赖项。这是因为我们实际上并不需要，甚至可能都不想知道，在编译时我们将连接到哪种确切类型的数据库。Spring
    Boot 将在检测到应用程序启动时类路径中存在 `org.h2.Driver` 类时自动配置所需的设置并创建适当的 bean。我们将在本章后面探讨这是如何以及在哪里发生的。
- en: 'The `data-jpa` and `jdbc` are Spring Boot starter artifacts. If we look in
    these dependency JARs once they are downloaded, or using Maven Central, we will
    find that they don''t contain any actual classes, only the various metadata. The
    two containing files that are of interest are `pom.xml` and `spring.provides`.
    Let''s first look at the `spring.provides` file in the `spring-boot-starter-jdbc`
    JAR artifact, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`data-jpa` 和 `jdbc` 是 Spring Boot 启动器工件。如果我们下载这些依赖 JAR 文件后查看，或者使用 Maven Central，我们会发现它们不包含任何实际的类，只有各种元数据。两个包含我们感兴趣的文件是
    `pom.xml` 和 `spring.provides`。让我们首先查看 `spring-boot-starter-jdbc` JAR 工件中的 `spring.provides`
    文件，如下所示：'
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This tells us that, by having this starter as our dependency, we will transitively
    get the `spring-jdbc`, `spring-tx`, and `tomcat-jdbc` dependency libraries in
    our build. The `pom.xml` file contains the proper dependency declarations that
    will be used by Gradle or Maven to resolve the needed dependencies during the
    build time. This also applies to our second starter: `spring-boot-starter-data-jpa`.
    This starter will transitively provide us with the `spring-orm`, `hibernate-entity-manager`,
    and the `spring-data-jpa` libraries.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，通过将这个启动器作为我们的依赖项，我们将通过传递性获得 `spring-jdbc`、`spring-tx` 和 `tomcat-jdbc`
    依赖库在我们的构建中。`pom.xml` 文件包含适当的依赖声明，这些声明将在构建时间由 Gradle 或 Maven 使用以解决所需的依赖项。这也适用于我们的第二个启动器：`spring-boot-starter-data-jpa`。这个启动器将传递性地为我们提供
    `spring-orm`、`hibernate-entity-manager` 和 `spring-data-jpa` 库。
- en: At this point, we have enough libraries/classes in our application classpath
    so as to give Spring Boot an idea of what kind of application we are trying to
    run and what type of facilities and frameworks need to be configured automatically
    by Spring Boot to stitch things together.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的应用程序类路径中已经有了足够的库/类，以便让 Spring Boot 了解我们正在尝试运行什么类型的应用程序以及需要由 Spring
    Boot 自动配置以连接在一起的设施和框架类型。
- en: 'Earlier, we mentioned that the presence of the `org.h2.Driver` class in the
    classpath will trigger Spring Boot to automatically configure the H2 database
    connection for our application. To see exactly how this will happen, let''s start
    by looking at our newly created application template, specifically at `BookPubApplication.java`,
    which is located in the `src/main/java/com/example/bookpub` directory in the root
    of the project. We do this as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们提到，`org.h2.Driver` 类在类路径中的存在将触发 Spring Boot 自动配置我们的应用程序的 H2 数据库连接。为了确切了解这将会如何发生，让我们首先查看我们新创建的应用程序模板，特别是
    `BookPubApplication.java`，它位于项目根目录下的 `src/main/java/com/example/bookpub` 目录中。我们这样做如下：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is effectively our entire and fully runnable application. There''s not
    a whole lot of code here and definitely no mention of configuration or databases
    anywhere. The key to making magic is the `@SpringBootApplication` meta-annotation.
    In this, we will find the real annotations that will direct Spring Boot to set
    things up automatically:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是我们整个和完全可运行的应用程序。这里没有太多代码，而且肯定没有提到配置或数据库。制作魔法的关键是 `@SpringBootApplication`
    元注解。在这里，我们将找到将指导 Spring Boot 自动设置事物的真实注解：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s go through the following list of annotations mentioned in the preceding
    code snippet:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一查看前面代码片段中提到的以下注解列表：
- en: '`@SpringBootConfiguration`: This annotation is in itself a meta-annotation;
    it tells Spring Boot that the annotated class contains Spring Boot configuration
    definitions, such as the `@Bean`, `@Component`, and `@Service` declarations, and
    so on. Inside, it uses the `@Configuration` annotation, which is a Spring annotation,
    and not just Spring Boot, as it is a Spring Framework core annotation, used to
    mark classes containing Spring configuration definitions.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@SpringBootConfiguration`: 这个注解本身是一个元注解；它告诉Spring Boot，被注解的类包含Spring Boot配置定义，例如`@Bean`、`@Component`和`@Service`声明等。在内部，它使用`@Configuration`注解，这是一个Spring注解，而不仅仅是Spring
    Boot，因为它是一个Spring框架核心注解，用于标记包含Spring配置定义的类。'
- en: It is important to note that using `@SpringBootConfiguration` over `@Configuration`
    is helpful when executing tests with Spring Boot Test framework, as this configuration
    will automatically be loaded by the Test framework when the test is annotated
    with `@SpringBootTest`. As it is noted in the Javadoc, an application should only
    ever include one `@SpringApplicationConfiguration`, and most idiomatic Spring
    Boot applications will inherit it from `@SpringBootApplication`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，当使用Spring Boot Test框架执行测试时，使用`@SpringBootConfiguration`而不是`@Configuration`是有帮助的，因为当测试被`@SpringBootTest`注解时，这个配置将自动被Test框架加载。正如Javadoc中所述，应用程序应该只包含一个`@SpringApplicationConfiguration`，而大多数习惯性的Spring
    Boot应用程序将继承自`@SpringBootApplication`。
- en: '`@ComponentScan`: This annotation tells Spring that we want to scan our application
    packages starting from the package of our annotated class as a default package
    root for the other classes that may be annotated with `@Configuration`, `@Controller`,
    and other applicable annotations, which Spring will automatically include as part
    of the context configuration. The applied `TypeExcludeFilter` class provides filtering
    out for various classes to be excluded from `ApplicationContext`. It is mostly
    used by `spring-boot-test` to exclude classes that should be used only during
    tests; however, it is possible to add your own beans that extend from `TypeExcludeFilter`
    and provide filtering for other types that are deemed necessary.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ComponentScan`: 这个注解告诉Spring，我们希望从被注解的类所在的包开始扫描我们的应用程序包，作为默认的包根，以便其他可能被`@Configuration`、`@Controller`和其他适用注解注解的类。Spring会自动将这些类包含在上下文配置中。应用的`TypeExcludeFilter`类提供了过滤功能，用于排除从`ApplicationContext`中排除的各种类。它主要被`spring-boot-test`用于排除仅在测试期间应使用的类；然而，你也可以添加自己的bean，这些bean扩展自`TypeExcludeFilter`，并为其他被认为必要的类型提供过滤功能。'
- en: '`@EnableAutoConfiguration`: This annotation is a part of the Spring Boot annotation,
    which is a meta-annotation on its own (you will find that Spring libraries rely
    very heavily on the meta-annotations so they can group and compose configurations
    together). It imports the `EnableAutoConfigurationImportSelector` and `AutoConfigurationPackages.Registrar`
    classes that effectively instruct Spring to automatically configure the conditional
    beans depending on the classes available in the classpath. (We will cover the
    inner workings of autoconfiguration in detail in [Chapter 4](6139967b-794e-479a-8461-d3197eb0322e.xhtml),
    *Writing Custom Spring Boot Starters.*)'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@EnableAutoConfiguration`: 这个注解是Spring Boot注解的一部分，它本身也是一个元注解（你会发现Spring库非常依赖于元注解，以便它们可以组合和组合配置）。它导入了`EnableAutoConfigurationImportSelector`和`AutoConfigurationPackages.Registrar`类，这些类有效地指示Spring根据类路径中可用的类自动配置条件bean。（我们将在[第4章](6139967b-794e-479a-8461-d3197eb0322e.xhtml)，*编写自定义Spring
    Boot启动器*中详细介绍自动配置的内部工作原理。）'
- en: The `SpringApplication.run(BookPubApplication.class, args);` code line in the
    main method basically creates a Spring application context that reads the annotations
    in `BookPubApplication.class` and instantiates a context, which is similar to
    how it would have been done had we not used Spring Boot and stuck with just a
    regular Spring Framework.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 主方法中的`SpringApplication.run(BookPubApplication.class, args);`代码行基本上创建了一个Spring应用程序上下文，该上下文读取`BookPubApplication.class`中的注解并实例化一个上下文，这与我们没有使用Spring
    Boot而坚持使用常规Spring框架时所做的操作类似。
- en: Launching an application using Gradle
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Gradle启动应用程序
- en: Typically, the very first step of creating any application is to have a basic
    startable skeleton. As the Spring Boot starter has created the application template
    for us already, all we have to do is extract the code, build, and execute it.
    Now let's go to the console and launch the application with Gradle.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，创建任何应用程序的第一步是拥有一个基本的可启动骨架。由于Spring Boot启动器已经为我们创建了应用程序模板，我们只需要提取代码、构建并执行它。现在让我们进入控制台，使用Gradle启动应用程序。
- en: How to do it...
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Change the location of our directory to where the `bookpub.zip` archive was
    extracted from and execute the following command from the command line:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的目录位置更改为`bookpub.zip`存档被提取的位置，并在命令行中执行以下命令：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you don't have `gradlew` in the directory, then download a version of Gradle
    from [https://gradle.org/downloads](https://gradle.org/install/) or install it
    via Homebrew by executing `brew install gradle`. After Gradle is installed, run
    `wrapper` in the `gradle` folder to get the Gradle `wrapper` files generated.
    Another way is to invoke `$gradleclean bootRun`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你目录中没有`gradlew`，那么请从[https://gradle.org/downloads](https://gradle.org/install/)下载Gradle的一个版本，或者通过执行`brew
    install gradle`使用Homebrew安装它。安装Gradle后，在`gradle`文件夹中运行`wrapper`以生成Gradle `wrapper`文件。另一种方法是调用`$gradleclean
    bootRun`。
- en: 'The output of the preceding command will be as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令的输出将如下所示：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As we can see, the application started just fine, but as we didn''t add any
    functionality or configure any services, it existed straight away. From the startup
    log, however, we do see that the autoconfiguration did take place. Let''s take
    a look at the following lines:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，应用程序启动得很顺利，但由于我们没有添加任何功能或配置任何服务，它立即就消失了。然而，从启动日志中，我们可以看到自动配置确实发生了。让我们看一下以下几行：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This information tells us that, because we added the `jdbc` and `data-jpa` starters,
    the JPA container was created and will use Hibernate 5.2.12.Final to manage the
    persistence using H2Dialect. This was possible because we had the right classes
    in the classpath.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这条信息告诉我们，由于我们添加了`jdbc`和`data-jpa`启动器，JPA容器被创建，并将使用Hibernate 5.2.12.Final通过H2Dialect来管理持久性。这是可能的，因为我们有正确的类在类路径中。
- en: Using the command-line runners
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用命令行运行器
- en: With our basic application skeleton ready, let's add some meat to the bones
    by making our application do something.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的基本应用程序骨架准备就绪后，让我们通过让应用程序做一些事情来给它添加一些实质性的内容。
- en: Let's start by first creating a class named `StartupRunner`. This will implement
    the `CommandLineRunner` interface, which basically provides just one method: `public
    void run(String... args)` --that will get called by Spring Boot only once after
    the application has started.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个名为`StartupRunner`的类。这个类将实现`CommandLineRunner`接口，它基本上只提供了一个方法：`public
    void run(String... args)` --Spring Boot将在应用程序启动后只调用一次这个方法。
- en: How to do it...
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create the file named `StartupRunner.java` under the `src/main/java/com/example/bookpub/`
    directory from the root of our project with the following content:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目根目录下的`src/main/java/com/example/bookpub/`目录中创建一个名为`StartupRunner.java`的文件，内容如下：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After we have defined the class, let''s proceed by defining it as `@Bean` in
    the `BookPubApplication.java` application configuration, which is located in the
    same folder as our newly created `StartupRunner.java` file as follows:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们定义了类之后，让我们通过在`BookPubApplication.java`应用程序配置中将它定义为`@Bean`来继续，该配置文件位于我们新创建的`StartupRunner.java`文件相同的文件夹中，如下所示：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'If we run our application again, by executing `$ ./gradlew clean bootRun`,
    we will get an output that is similar to the previous one. However, we will see
    our `Hello` message in the logs as well, which is as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行我们的应用程序，通过执行`$ ./gradlew clean bootRun`，我们将得到一个类似于之前的输出。然而，我们将在日志中看到我们的`Hello`消息，如下所示：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Even though the program will get terminated on execution, at least we made it
    do something!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 即使程序在执行过程中会被终止，但我们至少让它做了一些事情！
- en: Command-line runners are a useful functionality to execute the various types
    of code that only have to be run once, after startup. Some also use this as a
    place to start various executor threads, but Spring Boot provides a better solution
    for this task, which will be discussed at the end of this chapter. The command-line
    runner interface is used by Spring Boot to scan all of its implementations and
    invoke each instance's `run` method with the startup arguments. We can also use
    an `@Order` annotation or implement an `Ordered` interface so as to define the
    exact order in which we want Spring Boot to execute them. For example, **Spring
    Batch** relies on the runners to trigger the execution of the jobs.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行运行器是一种有用的功能，用于执行只需启动后运行一次的各种类型的代码。有些人也将其用作启动各种执行线程的地方，但Spring Boot提供了更好的解决方案来完成这项任务，这将在本章末尾讨论。Spring
    Boot使用命令行运行器接口扫描所有实现，并使用启动参数调用每个实例的`run`方法。我们还可以使用`@Order`注解或实现`Ordered`接口来定义我们希望Spring
    Boot执行它们的精确顺序。例如，**Spring Batch**依赖于运行器来触发作业的执行。
- en: As the command-line runners are instantiated and executed after the application
    has started, we can use the dependency injection to our advantage to wire in whatever
    dependencies we need, such as datasources, services, and other components. These
    can be utilized later while implementing `run`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于命令行运行器是在应用程序启动后实例化和执行的，我们可以利用依赖注入来连接我们需要的任何依赖项，例如数据源、服务和其他组件。这些可以在实现`run`时使用。
- en: It is important to note that if any exception is thrown in the `run(String...
    args)` method, this will cause the context to close and an application to shut
    down. Wrapping the risky code blocks with `try/catch` is recommended to prevent
    this from happening.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，如果在`run(String... args)`方法中抛出任何异常，这将导致上下文关闭并使应用程序关闭。建议使用`try/catch`包装有风险的代码块以防止这种情况发生。
- en: Setting up a database connection
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置数据库连接
- en: In every application, there is a need to access some data and conduct some operations
    on it. Most frequently, this source of data is a datastore of some kind, namely
    a database. Spring Boot makes it very easy to get started in order to connect
    to the database and start consuming the data via the JPA, among others.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个应用程序中，都需要访问某些数据并对它进行一些操作。最常见的数据源是某种类型的数据存储，即数据库。Spring Boot使得连接数据库并开始通过JPA（等等）消费数据变得非常容易。
- en: Getting ready
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: In our previous example, we created the basic application that will execute
    a command-line runner by printing a message in the logs. Let's enhance this application
    by adding a connection to a database.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们创建了一个基本的应用程序，该应用程序通过在日志中打印一条消息来执行命令行运行器。让我们通过添加对数据库的连接来增强这个应用程序。
- en: Earlier, we already added the necessary `jdbc` and `data-jpa` starters as well
    as an H2 database dependency to our `build` file. Now we will configure an in-memory
    instance of the H2 database.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们已经在`build`文件中添加了必要的`jdbc`和`data-jpa`启动器以及一个H2数据库依赖项。现在我们将配置一个H2数据库的内存实例。
- en: In the case of an embedded database, such as H2, **Hyper SQL Database** (**HSQLDB**),
    or Derby, no actual configuration is required besides including the dependency
    on one of these in the `build` file. When one of these databases is detected in
    the classpath and a `DataSource` bean dependency is declared in the code, Spring
    Boot will automatically create one for you.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式数据库的情况下，如H2、**Hyper SQL Database**（**HSQLDB**）或Derby，除了在`build`文件中包含对这些数据库之一的依赖项之外，不需要进行任何实际配置。当检测到类路径中的这些数据库之一，并在代码中声明了`DataSource`
    bean依赖项时，Spring Boot会自动为您创建一个。
- en: 'To demonstrate the fact that just by including the H2 dependency in the classpath,
    we will automatically get a default database, let''s modify our `StartupRunner.java` file
    to look as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明仅仅在类路径中包含H2依赖项，我们就会自动获得一个默认的数据库，让我们修改我们的`StartupRunner.java`文件，使其看起来如下：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, if we proceed with the running of our application, we will see the name
    of the datasource printed in the log, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们继续运行我们的应用程序，我们将在日志中看到数据源的名字，如下所示：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: So, under the hood, Spring Boot recognized that we've autowired a `DataSource` bean
    dependency and automatically created one initializing the in-memory H2 datastore.
    This is all well and good, but probably not all too useful beyond an early prototyping
    phase or for the purpose of testing. Who would want a database that goes away
    with all the data as soon as your application shuts down and you have to start
    with a clean slate every time you restart the application?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在底层，Spring Boot识别到我们已经自动装配了一个`DataSource` bean依赖项，并自动创建了一个初始化内存中的H2数据存储器。这很好，但可能对于早期原型设计阶段或测试目的来说并不太有用。谁会想要一个随着应用程序关闭而消失所有数据的数据库，每次重启应用程序都必须从零开始？
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s change the defaults in order to create an embedded H2 database that
    will not store data in-memory, but rather use a file to persist the data among
    application restarts, by performing the following steps:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个嵌入式的H2数据库，该数据库不会在内存中存储数据，而是在应用程序重启之间使用文件来持久化数据，我们可以通过以下步骤来更改默认设置：
- en: 'Open the file named `application.properties` under the `src/main/resources`
    directory from the root of our project and add the following content:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开项目根目录下的`src/main/resources`目录中的名为`application.properties`的文件，并添加以下内容：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Start the application by executing `./gradlew clean bootRun` from the command
    line
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过命令行执行`./gradlew clean bootRun`来启动应用程序
- en: 'Check your home directory, and you should see the following file in there:
    `test.mv.db`'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查你的主目录，你应该在那里看到以下文件：`test.mv.db`
- en: The user home directory is located under `/home/<username>` on Linux and under
    `/Users/<username>` on macOS X.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 用户主目录位于Linux的`/home/<username>`和macOS X的`/Users/<username>`下。
- en: How it works...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Even though, by default, Spring Boot makes certain assumptions about the database
    configuration by examining the classpath for the presence of supported database
    drivers, it provides you with easy configuration options to tweak the database
    access via a set of exposed properties grouped under `spring.datasource`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管默认情况下，Spring Boot通过检查类路径中是否存在支持的数据库驱动程序来对数据库配置做出某些假设，但它提供了易于配置的选项，通过一组在`spring.datasource`下分组暴露的属性来调整数据库访问。
- en: The things that we can configure are `url`, `username`, `password`, `driver-class-name`,
    and so on. If you want to consume the datasource from a JNDI location, where an
    outside container creates it, you can configure this using the `spring.datasource.jndi-name`
    property. The complete set of possible properties is fairly large, so we will
    not go into all of them. However, we will cover more options in [Chapter 5](1136c424-e79e-467a-8f7f-8af2099306d7.xhtml),
    *Application Testing*, where we will talk about mocking data for application tests
    using a database.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以配置的项包括`url`、`username`、`password`、`driver-class-name`等等。如果你想从JNDI位置消费数据源，即由外部容器创建的数据源，你可以使用`spring.datasource.jndi-name`属性来配置它。可能的属性集相当大，所以我们不会全部介绍。然而，我们将在[第五章](1136c424-e79e-467a-8f7f-8af2099306d7.xhtml)“应用程序测试”中介绍更多选项，我们将讨论使用数据库模拟应用程序测试数据。
- en: By looking at various blogs and examples, you may notice that some places use
    dashes in property names like `driver-class-name`, while others use camel-cased
    variants: `driverClassName`. In Spring Boot, these are actually two equally supported
    ways of naming the same property, and they get translated into the same thing
    internally.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看各种博客和示例，你可能注意到有些地方在属性名中使用短横线，如`driver-class-name`，而其他地方则使用驼峰式变体：`driverClassName`。在Spring
    Boot中，这两种实际上是命名同一属性的两个同等支持的方式，并且它们在内部被转换成相同的东西。
- en: 'If you want to connect to a regular (non-embedded) database, besides just having
    the appropriate driver library in the classpath, we need to specify the driver
    of our choice in the configuration. The following code snippet is what the configuration
    to connect to MySQL would resemble:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要连接到一个常规（非嵌入）数据库，除了在类路径中拥有适当的驱动库之外，我们还需要在配置中指定我们选择的驱动程序。以下代码片段展示了连接到MySQL的配置示例：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we wanted Hibernate to create the schema automatically, based on our entity
    classes, we would need to add the following line to the configuration:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让Hibernate根据我们的实体类自动创建模式，我们需要在配置中添加以下行：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Don't do it in the production environment, otherwise, on startup, all the table
    schemas and data will be deleted! Use the update or validate values instead, where
    needed.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在生产环境中这样做，否则在启动时，所有表模式和数据都将被删除！在需要的地方使用更新或验证值代替。
- en: 'You can go even further in the abstraction layer and, instead of autowiring
    a `DataSource` object, you could go straight for  `JdbcTemplate`. This would instruct
    Spring Boot to automatically create a DataSource and then create a `JdbcTemplate`
    wrapping the datasource, thus providing you with a more convenient way of interacting
    with a database in a safe way. The code for `JdbcTemplate` is as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以在抽象层更进一步，而不是自动装配一个 `DataSource` 对象，你可以直接使用 `JdbcTemplate`。这将指示 Spring Boot
    自动创建一个数据源，然后创建一个包装数据源的 `JdbcTemplate`，从而为你提供一个更方便且安全地与数据库交互的方式。`JdbcTemplate`
    的代码如下：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can also look in the `spring-boot-autoconfigure` source at an `org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration`
    file to see the code behind the datasource creation magic.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以查看 `spring-boot-autoconfigure` 源代码中的 `org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration`
    文件，以查看数据源创建魔法的代码。
- en: Setting up a data repository service
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置数据仓库服务
- en: Connecting to a database and then executing good old SQL, though simplistic
    and straightforward, is not the most convenient way to operate on the data, map
    it in a set of domain objects, and manipulate the relational content. This is
    why multiple frameworks emerged to aid you with mapping the data from tables to
    objects, better known as **object-relational mapping** (**ORM**). The most notable
    example of such a framework is Hibernate.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到数据库然后执行传统的 SQL，虽然简单直接，但并不是操作数据、将其映射到一组领域对象以及操作关系内容最方便的方式。这就是为什么出现了多个框架来帮助你将数据从表映射到对象，这通常被称为
    **对象关系映射**（**ORM**）。此类框架中最著名的例子是 Hibernate。
- en: In the previous example, we covered how to set up a connection to a database
    and configure the settings for the username and password, and we also discussed
    which driver to use, and so on. In this recipe, we will enhance our application
    by adding a few entity objects that define the structure of the data in the database
    and a `CrudRepository` interface to access the data.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们介绍了如何设置数据库连接并配置用户名和密码的设置，我们还讨论了应该使用哪个驱动程序等等。在这个菜谱中，我们将通过添加一些定义数据库中数据结构的实体对象和一个
    `CrudRepository` 接口来访问数据来增强我们的应用程序。
- en: As our application is a book-tracking catalogue, the obvious domain objects
    would be `Book`, `Author`, `Reviewers`, and `Publisher`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序是一个书籍跟踪目录，显然的领域对象将是 `Book`、`Author`、`Reviewers` 和 `Publisher`。
- en: How to do it...
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Create a new package folder named `entity` under the `src/main/java/com/example/bookpub`
    directory from the root of our project.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目根目录下 `src/main/java/com/example/bookpub` 目录中创建一个名为 `entity` 的新包文件夹。
- en: 'In this newly created package, create a new class named `Book` with the following
    content:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个新创建的包中，创建一个名为 `Book` 的新类，内容如下：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As any book should have an author and a publisher, and ideally some reviewers,
    we need to create these entity objects as well. Let''s start by creating an `Author`
    entity class, under the same directory as our `Book`, as follows:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于任何书籍都应该有一个作者和一个出版社，理想情况下还有一些评论者，我们需要创建这些实体对象。让我们从创建一个与我们的 `Book` 相同目录下的 `Author`
    实体类开始，如下所示：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Similarly, we will create the `Publisher` and `Reviewer` classes, as shown
    in the following code:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们将创建 `Publisher` 和 `Reviewer` 类，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we will create our `BookRepository` interface by extending Spring''s `CrudRepository` interface
    under the `src/main/java/com/example/bookpub/repository` package, as follows:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在 `src/main/java/com/example/bookpub/repository` 包下通过扩展 Spring 的 `CrudRepository`
    接口来创建我们的 `BookRepository` 接口，如下所示：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, let''s modify our `StartupRunner` class in order to print the number
    of books in our collection, instead of some random datasource string, by autowiring
    a newly created `BookRepository` and printing the result of a `.count()` call
    to the log, as follows:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们修改我们的 `StartupRunner` 类，以便打印我们收藏中的书籍数量，而不是一些随机的数据源字符串，通过自动装配一个新创建的 `BookRepository`
    并将 `.count()` 调用的结果打印到日志中，如下所示：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As you have probably noticed, we didn''t write a single line of SQL, or even
    mention anything about database connections, building queries, or things like
    that. The only hint about the fact that we are dealing with the database-backed
    data in our code is the presence of class and field annotations: `@Entity`, `@Repository`,
    `@Id`, `@GeneratedValue`, and `@ManyToOne`, along with `@ManyToMany` and `@OneToMany`.
    These annotations, which are a part of the JPA, along with the extension of the
    `CrudRepository` interface, are our ways of communicating with Spring about the
    need to map our objects to the appropriate tables and fields in the database and
    provide us with the programmatic ability to interact with this data.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，我们没有写一行SQL，甚至没有提及任何关于数据库连接、构建查询或类似的事情。我们代码中处理数据库后端数据的唯一线索是类和字段注解的存在：`@Entity`、`@Repository`、`@Id`、`@GeneratedValue`
    和 `@ManyToOne`，以及 `@ManyToMany` 和 `@OneToMany`。这些注解是JPA的一部分，以及 `CrudRepository`
    接口的扩展，是我们与Spring沟通需要将我们的对象映射到数据库中适当的表和字段的方式，并为我们提供与这些数据交互的程序化能力。
- en: 'Let''s go through the following annotations:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一介绍以下注解：
- en: '`@Entity` indicates that the annotated class should be mapped to a database
    table. The name of the table will be derived from the name of the class, but it
    can be configured, if needed. It is important to note that every entity class
    should have a default `protected` constructor, which is needed for automated instantiation
    and Hibernate interactions.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Entity` 表示被注解的类应该映射到数据库表。表的名称将派生自类的名称，但如果需要，也可以进行配置。需要注意的是，每个实体类都应该有一个默认的
    `protected` 构造函数，这对于自动实例化和Hibernate交互是必需的。'
- en: '`@Repository` indicates that the interface is intended to provide you with
    the access and manipulation of data for a database. It also serves as an indication
    to Spring during the component scan that this instance should be created as a
    bean that will be available for use and injection into other beans in the application.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Repository` 表示该接口旨在为您提供对数据库数据的访问和操作。它还作为Spring在组件扫描期间的指示，表明此实例应作为一个bean创建，该bean将在应用程序中使用并可注入到其他bean中。'
- en: The `CrudRepository` interface defines the basic common methods to read, create,
    update, and delete data from a data repository. The extra methods that we will
    define in our `BookRepository` extension, `public Book findBookByIsbn(String isbn)`,
    indicate that Spring JPA should map the call to this method to a SQL query selecting
    a book by its ISBN field. This is a convention-named mapping that translates the
    method name into a SQL query. It can be a very powerful ally, allowing you to
    build queries, such as `findByNameIgnoringCase(String name)` and others.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CrudRepository` 接口定义了从数据存储中读取、创建、更新和删除数据的基本通用方法。我们将在 `BookRepository` 扩展中定义的额外方法，如
    `public Book findBookByIsbn(String isbn)`，表明Spring JPA应将此方法的调用映射到选择ISBN字段的SQL查询。这是一个约定命名的映射，将方法名称转换为SQL查询。它可以是一个非常强大的盟友，允许您构建查询，如
    `findByNameIgnoringCase(String name)` 等。'
- en: The `@Id` and `@GeneratedValue` annotations provide you with an indication that
    an annotated field should be mapped to a primary key column in the database and
    that the value for this field should be generated, instead of being explicitly
    entered.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Id` 和 `@GeneratedValue` 注解向您提供指示，即被注解的字段应映射到数据库的主键列，并且此字段的值应由系统生成，而不是明确输入。'
- en: The `@ManyToOne` and `@ManyToMany` annotations define the relational field associations
    that refer to the data stored in the other tables. In our case, multiple books
    belong to one author, and many reviewers review multiple books.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ManyToOne` 和 `@ManyToMany` 注解定义了关联字段关联，这些关联字段引用其他表中存储的数据。在我们的例子中，多本书属于一个作者，许多评论家评论了多本书。'
- en: The `mappedBy` attribute in the `@OneToMay` annotation defines a reverse association
    mapping. It indicates to Hibernate that the mapping source of truth is defined
    in the `Book` class, in the `author` or `publisher` fields.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@OneToMay` 注解中的 `mappedBy` 属性定义了一个反向关联映射。它指示Hibernate，映射的真实来源定义在 `Book` 类的
    `author` 或 `publisher` 字段中。'
- en: For more information about all the vast capabilities of Spring Data, visit [http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/](http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于Spring Data所有强大功能的详细信息，请访问[http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/](http://docs.spring.io/spring-data/data-commons/docs/current/reference/html/).
- en: Scheduling executors
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安排执行器
- en: 'Earlier in this chapter, we discussed how the command-line runners can be used
    as a place to start the scheduled executor thread pools to run the worker threads
    in intervals. While that is certainly a possibility, Spring provides you with
    a more concise configuration to achieve the same goal: `@EnableScheduling`.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期部分，我们讨论了如何将命令行运行器用作启动计划执行器线程池的地方，以间隔运行工作线程。虽然这确实是一种可能性，但Spring为你提供了一个更简洁的配置来实现相同的目标：`@EnableScheduling`。
- en: Getting ready
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will enhance our application so that it will print a count of books in our
    repository every 10 seconds. To achieve this, we will make the necessary modifications
    to the `BookPubApplication` and `StartupRunner` classes.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将增强我们的应用程序，使其每10秒打印出我们存储库中的书籍数量。为了实现这一点，我们将对`BookPubApplication`和`StartupRunner`类进行必要的修改。
- en: How to do it...
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s add an `@EnableScheduling` annotation to the `BookPubApplication` class,
    as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`BookPubApplication`类中添加一个`@EnableScheduling`注解，如下所示：
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As a `@Scheduled` annotation can be placed only on methods without arguments,
    let''s add a new `run()` method to the `StartupRunner` class and annotate it with
    the `@Scheduled` annotation, as shown in the following line:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`@Scheduled`注解只能放在没有参数的方法上，让我们在`StartupRunner`类中添加一个新的`run()`方法，并用`@Scheduled`注解标注它，如下行所示：
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Start the application by executing `./gradlew clean bootRun` from the command
    line so as to observe the `Number of books: 0` message that shows in the logs
    every 10 seconds.'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '通过在命令行中执行`./gradlew clean bootRun`来启动应用程序，以便观察日志中每10秒显示的`Number of books: 0`信息。'
- en: How it works...
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`@EnableScheduling`, as many other annotations that we have discussed and will
    discuss in this book, is not a Spring Boot; it is a Spring Context module annotation.
    Similar to the `@SpringBootApplication` and `@EnableAutoConfiguration` annotations,
    this is a meta-annotation and internally imports  `SchedulingConfiguration` via
    the `@Import(SchedulingConfiguration.class)` instruction, which can be found inside `ScheduledAnnotationBeanPostProcessor`
    that will be created by the imported configuration and will scan the declared
    Spring beans for the presence of the `@Scheduled` annotations. For every annotated
    method without arguments, the appropriate executor thread pool will be created.
    It will manage the scheduled invocation of the annotated method.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`@EnableScheduling`，就像我们在本书中讨论和将要讨论的许多其他注解一样，不是一个Spring Boot；它是一个Spring Context模块注解。类似于`@SpringBootApplication`和`@EnableAutoConfiguration`注解，这是一个元注解，并通过`@Import(SchedulingConfiguration.class)`指令内部导入`SchedulingConfiguration`，这个指令可以在由导入的配置创建的`ScheduledAnnotationBeanPostProcessor`内部找到。对于每个没有参数的注解方法，将创建适当的执行器线程池。它将管理注解方法的计划调用。'
