- en: The Importance of the final Keyword, Packages, and Modifiers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`final` 关键字、包和修饰符的重要性'
- en: This is the final chapter in our book. Here, we will be dealing with some more
    important concepts that will help us write and execute better code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书的最后一章。在这里，我们将处理一些更重要的概念，这将帮助我们编写和执行更好的代码。
- en: 'In this chapter, we will look at the following concepts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下概念：
- en: The final keyword
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`final` 关键字'
- en: Packages
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包
- en: Modifiers in Java
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java中的修饰符
- en: The final keyword
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`final` 关键字'
- en: 'First, we will create a new class. If we declare any variable as `final`, that
    means the value cannot be changed again. Let''s consider the following code:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个新的类。如果我们声明任何变量为 `final`，这意味着该值不能再更改。让我们考虑以下代码：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, we have declared the integer value as `4`. This means we cannot
    change this value to another number. If we try to do that, it throws an error
    saying `Remove 'final' modifier of 'i'`. This keyword is useful if we want a value
    to be constant.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已将整数值声明为 `4`。这意味着我们无法将此值更改为另一个数字。如果我们尝试这样做，它将抛出一个错误，表示 `移除 'final' 修饰符的
    'i'`。如果我们想使一个值保持不变，这个关键字很有用。
- en: If we mark a class as `final`, it will throw an error because when we change
    the access mode to `final`, we are not able to use that as a parent class. In
    other words, we will not be able to inherit our properties from it. If we want
    to inherit our properties, we need to change it back to `public`. The key logic
    for the final keyword is that, once written, we cannot override `final` methods.
    So these are unique and cannot be used again with the same name.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将一个类标记为 `final`，它将抛出一个错误，因为当我们更改访问模式为 `final` 时，我们无法将其用作父类。换句话说，我们将无法从它继承属性。如果我们想继承属性，我们需要将其改回
    `public`。`final` 关键字的逻辑是，一旦写入，我们就不能重写 `final` 方法。因此，这些是唯一的，不能再次使用相同的名称。
- en: The `final` keyword can be used at the method level to make sure that the method
    is not overridden. It is used at the variable level to make sure we're not changing
    it, and it can also be used at the class level to ensure that we are not inheriting
    that parent class.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`final` 关键字可以在方法级别使用，以确保该方法不会被重写。在变量级别使用，以确保我们不会更改它，并且它也可以在类级别使用，以确保我们不会继承那个父类。'
- en: But remember not to confuse `final` and `finally`. `finally` is something that
    is related to `try...catch` exceptions. Once you execute the `try` or `catch`
    block, and preface any error, the controller will still come to this log and execute
    the code, no matter whether the script is pass or fail. `finally` is all about
    restricting access, such as we cannot use that, inherit that, or even change the
    values. We have explored packages, and how to import packages into other classes.
    We have explored the inheritance of interfaces, runtime polymorphism, strings,
    and many more. This is all about keywords.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住不要混淆 `final` 和 `finally`。`finally` 与 `try...catch` 异常有关。一旦执行了 `try` 或 `catch`
    块，并前置任何错误，无论脚本是否通过，控制器都会来到这个日志并执行代码。`finally` 是关于限制访问的，例如我们无法使用它，继承它，甚至更改其值。我们已经探讨了包，以及如何将包导入其他类。我们已经探讨了接口的继承、运行时多态、字符串等等。这一切都是关于关键字。
- en: In the next section, we will learn about packages.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节，我们将学习关于包的内容。
- en: Packages
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包
- en: When scripts are written for each Java class, there is a pre-populated line
    that is present automatically. It is `package coreJava`. Since we have created
    a package in Java and placed all the Java classes into that `coreJava` package,
    we see it as `package coreJava`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当为每个Java类编写脚本时，会自动出现一个预填充的行。它是 `package coreJava`。由于我们在Java中创建了一个包，并将所有Java类放入该
    `coreJava` 包中，所以我们将其视为 `package coreJava`。
- en: Packages are nothing but a set of classes and interfaces. For example, Java
    comes with a few built-in packages, such as `java.length`; if we import this package,
    only then can we access a basic fundamental method, such as `public static void
    main`, integer, or array. All these classes come from this `java.lang` package.
    It is important to define the package name, because without it, we cannot access
    the classes present inside the package. This is because `java.lang` is a default
    package and it comes within the Java compiler itself.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 包不过是类和接口的集合。例如，Java自带一些内置包，如 `java.lang`；如果我们导入此包，只有在这种情况下，我们才能访问基本的基本方法，如 `public
    static void main`、整数或数组。所有这些类都来自这个 `java.lang` 包。定义包名很重要，因为没有它，我们无法访问包内存在的类。这是因为
    `java.lang` 是默认包，并且它包含在Java编译器本身中。
- en: We have another package as well, `java.util`. We used this package when we worked
    on collections; we imported a `java.util` package. In order to work on `ArrayList`,
    this class is present in the `java.util` package. Therefore, if we remove `import
    java.util.ArrayList`, it throws an error because it does not belong to `java.lang`.
    All collection interfaces come from the `util` package.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个包，`java.util`。我们在处理集合时使用了这个包；我们导入了`java.util`包。为了工作在`ArrayList`上，这个类位于`java.util`包中。因此，如果我们移除`import
    java.util.ArrayList`，它会抛出一个错误，因为它不属于`java.lang`。所有集合接口都来自`util`包。
- en: 'But how do we know what keyword to use? The following screenshot displays what
    Eclipse will display if we hover the mouse:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何知道使用什么关键字？以下截图显示了如果我们悬停鼠标，Eclipse会显示什么：
- en: '![](img/e544ea6b-85b3-4d6d-9a42-d78acde26018.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e544ea6b-85b3-4d6d-9a42-d78acde26018.png)'
- en: Quick fixes drop down with suggestions to correct the code error
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 快速修复下拉菜单显示建议以纠正代码错误
- en: 'We are importing the `java.util` package. And from that package, we are importing
    the `ArrayList` class. The syntax for it will be:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在导入`java.util`包。并且从那个包中，我们正在导入`ArrayList`类。它的语法将是：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, the reason why we are using `ArrayList` in this Java class is because
    we know that `ArrayList` is in the `java.util` package. But we need not remember
    it when we are working with Eclipse. When you just hover the mouse, it suggests we
    import the package and we can just click on it. It will automatically import that
    particular test.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在这个Java类中使用`ArrayList`的原因是因为我们知道`ArrayList`位于`java.util`包中。但在使用Eclipse时我们不需要记住它。当你只是将鼠标悬停时，它会建议我们导入包，我们只需点击它。它将自动导入那个特定的包。
- en: '`HashSet` imports the `HashSet` class from the same `util` package. If we go
    to `HashMap`, it brings `HashMap`. Thus, whenever we want to work on some tests,
    we need to import that package or class. `System.out.println()` also comes from
    one package only, but they come from `java.lang`, which is a built-in compiler.
    These are inbuilt inside the Java packages.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashSet`从相同的`util`包中导入`HashSet`类。如果我们去`HashMap`，它会带来`HashMap`。因此，每当我们想要工作在某个测试上时，我们需要导入那个包或类。`System.out.println()`也只来自一个包，但它们来自`java.lang`，这是一个内置的编译器。这些都是在Java包内建。'
- en: At the same time, we can also define a user-defined Java package. In this case,
    all our test cases are in a different package called `coreJava`. If someone wants
    to use our classes, all they need to do is run `import coreJava.classname`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们也可以定义一个用户定义的Java包。在这种情况下，所有我们的测试用例都在一个名为`coreJava`的不同包中。如果有人想使用我们的类，他们只需要运行`import
    coreJava.classname`。
- en: In the next section, we will look at the public modifier.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看`public`修饰符。
- en: Modifiers in Java
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java中的修饰符
- en: 'There are four types of access modifiers:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种类型的访问修饰符：
- en: '`public`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`'
- en: '`private`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private`'
- en: '`protected`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protected`'
- en: '`default`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`'
- en: We will not discuss the theory here as you can find it on Google. We need a
    practical approach as to where exactly these access modifiers are used, or where
    exactly the packages are imported. Whenever we've created a method throughout
    this book, every time we just used `public` and wrote the method. The three other
    access modifiers work similarly.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会讨论理论，因为您可以在Google上找到它。我们需要一个实际的方法，即这些访问修饰符的确切使用位置，或者包的确切导入位置。每当我们在整本书中创建方法时，我们每次只是使用`public`并编写方法。其他三个访问修饰符的工作方式类似。
- en: Now let's try to understand how each of these access modifiers can help us.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来尝试理解每个这些访问修饰符如何帮助我们。
- en: default
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`default`'
- en: If we do not mention any access modifier, our Java class automatically thinks
    it has a `default` access modifier. If it is `default`, that means you can access
    this method anywhere in your package. But if you go out of this package, then
    you cannot access this method. Even if we import the `package.classname` into
    our new package, we will not be able to access this method if we have not specified
    it as `public`. If you don't specify it, then by default it thinks it's a `default`
    access modifier. The `default` access modifier can be accessed anywhere in the
    package, but not outside it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有提到任何访问修饰符，我们的Java类会自动认为它有一个`default`访问修饰符。如果是`default`，这意味着你可以在你的包中的任何地方访问这个方法。但如果你走出这个包，那么你将无法访问这个方法。即使我们将`package.classname`导入我们的新包中，如果我们没有将其指定为`public`，我们也将无法访问这个方法。如果你不指定它，那么默认情况下它认为它是一个`default`访问修饰符。`default`访问修饰符可以在包内任何地方访问，但不能在包外。
- en: 'In the *Packages* section, we imported this package and we tried to use it.
    As you can see in the following screenshot, there is an error showing up in line
    15:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Packages`部分，我们导入了这个包并尝试使用它。正如你在以下截图中所看到的，第15行出现了一个错误：
- en: '![](img/d9dfca50-0720-409c-bd0f-5457b9af0d7a.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d9dfca50-0720-409c-bd0f-5457b9af0d7a.png)'
- en: Quick fixes drop down with suggestions to correct the code error for default
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 快速修复下拉菜单，建议纠正代码中的默认错误
- en: 'If we don''t specify anything, we cannot access it, therefore it is the same
    as that of the default feature. This applies to variables as well:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有指定任何内容，我们就无法访问它，因此它与默认功能相同。这也适用于变量：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we can see, in the preceding code we have declared an integer. However, it
    will not be `public`; it is `default`. Thus, we cannot access the variable outside
    the package. If we import it, we will have access to the class but not the methods.
    If we want access, we have to write it as a `public`. So what does a `public`
    access modifier do?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在前面的代码中我们声明了一个整数。然而，它不会是`public`的；它是`default`。因此，我们无法在包外访问这个变量。如果我们导入它，我们将能够访问类但不是方法。如果我们想要访问，我们必须将其写为`public`。那么`public`访问修饰符做什么呢？
- en: public
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`public`'
- en: On making the method or variable `public`, we will have access to it across
    all the packages. That means basically everywhere. There is no restriction for
    this package of this class. The error observed in the preceding screenshot is
    also goes once we make the method/variable `public`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在将方法或变量设置为`public`后，我们将能够在所有包中访问它。这意味着基本上是任何地方。对这个类这个包没有限制。前一个截图观察到的错误也会在我们将方法/变量设置为`public`时出现。
- en: 'The following screenshot displays the `int` value after we made it `public`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们将`int`值设置为`public`后的情况：
- en: '![](img/cd7b7481-22ae-445e-bfb6-22257a6f5ef9.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cd7b7481-22ae-445e-bfb6-22257a6f5ef9.png)'
- en: Quick fixes drop down with suggestions to correct the code error for public
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 快速修复下拉菜单，建议纠正代码中的公共错误
- en: In the next class, we'll look at what `private` and `protected` access modifiers
    are. There are two more access modifiers after this one, let's see what they do.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个类中，我们将探讨`private`和`protected`访问修饰符是什么。在这个之后还有两个更多的访问修饰符，让我们看看它们的作用。
- en: private
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`private`'
- en: 'If we mark our method or variable as `private`, then we cannot access either
    of them outside the class. They cannot be accessed outside the package, or outside
    the same class. If we want to access this in our `ArraysDemo` example, we cannot
    do that. Even if we try to, it throws an error, as shown in the following screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将我们的方法或变量标记为`private`，那么我们无法在类外访问它们。它们不能在包外或同一类外被访问。如果我们想在我们的`ArraysDemo`示例中访问这个，我们无法做到。即使我们尝试这样做，也会抛出一个错误，如下一个截图所示：
- en: '![](img/50710110-dc12-4e9a-8739-6c1ace39fac8.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/50710110-dc12-4e9a-8739-6c1ace39fac8.png)'
- en: Quick fixes drop down with a suggestion to correct the code error for private
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 快速修复下拉菜单，建议纠正代码中的私有错误
- en: This is so because, if we mark any method or variable as `private`, we cannot
    access it outside that particular class. Until and unless we change it to something
    else, it throws an error. This applies to the variable as well.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，如果我们将任何方法或变量标记为`private`，我们就无法在特定类外访问它。除非我们将其更改为其他内容，否则它会抛出一个错误。这也适用于变量。
- en: If you want a real-time scenario, let's say you are making a payment and buying
    a product; all the credit card details will go as `private` because they will
    not be accessed outside of that buy class. If they can be accessed, that's a security
    breach, right? So to make credit card details restricted to that particular class,
    the developers give the `private` variable to all the card details so other classes
    cannot use it. Even if they have used inheritance or are importing a package,
    they will not have access to those sensitive details. There are a lot of real-time
    scenarios; if you are working on test frameworks, there might be some variables
    which you should not change, and always keep it private.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看到一个实时场景，比如说你正在支付并购买一个产品；所有的信用卡详情都会被当作`private`，因为它们不会在购买类之外被访问。如果它们可以被访问，那就是一个安全漏洞，对吧？所以为了使信用卡详情仅限于那个特定的类，开发者会将`private`变量赋予所有卡详情，这样其他类就不能使用它。即使他们使用了继承或导入了一个包，他们也无法访问那些敏感详情。还有很多实时场景；如果你正在开发测试框架，可能会有一些变量你不应该更改，并且始终将其保持为私有。
- en: protected
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`protected`'
- en: 'If we define a variable or method as `private`, we can access them in subclasses
    only. This means if we define it as `protected`; then, whichever class is inheriting
    the parent class, only those subclasses can have access to the method, and no
    other classes. This can be understood with the following code snippet:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将变量或方法定义为 `private`，我们只能在子类中访问它们。这意味着如果我们将其定义为 `protected`，那么无论哪个类继承父类，只有那些子类才能访问该方法，其他类则不能。这一点可以通过以下代码片段来理解：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The difference between `default` and `protected` is that in `default` we can
    access a class only within the same package of classes. Even `protected` can access
    all classes in the same package, except it has an additional feature. This additional
    feature says that, if we want to access it in other packages, only subclasses
    that inherit the properties of the parent class can access it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`default` 和 `protected` 的区别在于，在 `default` 情况下，我们只能在同一个类包内访问一个类。即使是 `protected`，也能访问同一个包内的所有类，但它有一个额外的特性。这个额外的特性是指，如果我们想在其他包中访问它，只有继承父类属性的子类才能访问它。'
- en: The same concept is applied to variables.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的概念也适用于变量。
- en: Summary
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned concepts that help us understand the importance
    of packages, modifiers, and the `final` keyword in Java.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了有助于我们理解包、修饰符和 Java 中的 `final` 关键字重要性的概念。
- en: I hope you have a better understanding of these concepts now that you've read
    all the chapters.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经阅读了所有章节，我希望你对这些概念有了更好的理解。
