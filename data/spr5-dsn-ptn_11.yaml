- en: Implementing Reactive Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现响应式设计模式
- en: 'In this chapter, we will explore one of the most important features of the
    Spring 5 Framework, which is reactive pattern programming. The Spring 5 Framework
    introduced this new feature with the Spring web reactive module. We will discuss
    this module in this chapter. Before that, let''s have a look at reactive patterns.
    What is the reactive pattern, and why is it growing more popular nowadays? I will
    start my discussion on reactive pattern with the following statement made by **Satya
    Nadella**, CEO, Microsoft Corporation:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Spring 5框架最重要的特性之一，即响应式模式编程。Spring 5框架通过Spring Web Reactive模块引入了这一新特性。我们将在本章中讨论这个模块。在此之前，让我们先了解一下响应式模式。什么是响应式模式，为什么它在当今越来越受欢迎？我将从微软公司首席执行官**萨蒂亚·纳德拉**的以下声明开始我的响应式模式讨论：
- en: Every business out there now is a software company, is a digital company.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的每一家企业都是软件公司，都是数字公司。
- en: 'The topics we will cover here are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里将要讨论的主题如下：
- en: Why reactive pattern?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么选择响应式模式？
- en: The reactive pattern principles
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式模式原则
- en: Blocking calls
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻塞调用
- en: Non-blocking calls
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非阻塞调用
- en: Back-pressure
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反压
- en: Implementing the reactive pattern using the Spring Framework
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring框架实现响应式模式
- en: The Spring web reactive module
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Web Reactive模块
- en: Understanding application requirement over the years
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多年来理解应用需求
- en: If you go back 10 to 15 years, there were very few internet users, and far less
    online portals for end users compared to what we have today. Nowadays, we cannot
    think of a life without a computer or without any online system. In short, we
    have become extremely dependent on computers and online computing for personal
    as well as business use. Every business model is moving towards digitalization.
    The Prime Minister of India, Mr. Narendra Damodardas Modi has launched a Digital
    India campaign to ensure that the Government's services are made available to
    citizens electronically by improved online infrastructure, increasing internet
    connectivity, and by making the country digitally empowered in the field of technology.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾10到15年前，互联网用户非常少，与今天的在线门户相比，用户在线的门户网站也少得多。如今，我们无法想象没有电脑或没有任何在线系统的生活。简而言之，我们在个人和商业用途上对电脑和在线计算变得极其依赖。每一个商业模式都在向数字化转变。印度总理纳伦德拉·莫迪先生启动了“数字印度”运动，以确保通过改进在线基础设施、增加互联网连接以及使国家在技术领域数字化，政府的服务能够以电子方式提供给公民。
- en: All this implies that the number of internet users is increasing dramatically.
    According to the Ericsson Mobility Report,
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都意味着互联网用户数量正在急剧增加。根据爱立信移动性报告，
- en: The Internet of Things (IoT) is expected to surpass mobile phones as the largest
    category of connected devices in 2018.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 预计到2018年，物联网（IoT）将超过移动电话，成为最大的连接设备类别。
- en: 'There has been a tremendous growth of mobile internet users, and there is no
    sign of that slowing down anytime soon. In these sectors, by definition, the server
    side has to handle millions of connected devices concurrently. The following table
    compares the infrastructure and application requirements today with the requirement
    from 10 years back:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 移动互联网用户数量增长迅速，且没有迹象表明这种增长会很快放缓。在这些领域，根据定义，服务器端必须同时处理数百万个连接设备。以下表格比较了现在的基础设施和应用需求与10年前的需求：
- en: '| **Requirements** | **Now** | **Ten years ago** |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| **需求** | **现在** | **十年前** |'
- en: '| **Server nodes** | More than 1000 nodes required. | Ten nodes were enough.
    |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| **服务器节点** | 需要超过1000个节点。 | 10个节点就足够了。|'
- en: '| **Response times** | Takes milliseconds to serve requests, and send back
    responses. | Took seconds to response. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| **响应时间** | 服务请求并返回响应需要毫秒级时间。 | 响应需要几秒钟。|'
- en: '| **Maintenance downtimes** | Currently, there is no or zero maintenance downtime
    required. | Took hours of maintenance downtime. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| **维护停机时间** | 目前，不需要或零维护停机时间。 | 需要数小时的维护停机时间。|'
- en: '| **Data volume** | Data for the current application that increased to TBs
    from PBs. | Data was in GBs. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **数据量** | 当前应用程序的数据量从PBs增加到TBs。 | 数据量在GBs。|'
- en: 'You can see the differences in the requirement of resources in the preceding
    table. These requirements have increased, because we now expect responses immediately,
    within the second. At the same time, the complexity of tasks given to computers
    have also increased. These tasks are not just pure computation in a mathematical
    sense, but also in requesting the responses to be distilled from enormous amounts
    of data. So, now we have to focus the performance of such systems by designing
    a single computer in the form of multi-core CPUs, possibly, combined in multi-socket
    servers. The first thing on our minds is to make the system responsive. It is
    the first of the reactive traits-responsiveness. We will explore more of this
    in this chapter, along with the following topics:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在前一张表中看到资源需求的变化。这些需求增加了，因为我们现在期望在秒内立即得到响应。同时，分配给计算机的任务复杂性也增加了。这些任务不仅仅是数学意义上的纯计算，还包括从大量数据中请求响应。因此，现在我们必须通过设计单台计算机的形式为多核CPU，可能是在多插槽服务器中组合，来关注这类系统的性能。我们首先想到的是使系统保持响应。这是响应式特性的第一个——响应性。我们将在本章中进一步探讨这一点，以及以下主题：
- en: Why reactive pattern
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么选择响应式模式
- en: Reactive pattern principles
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式模式原则
- en: Blocking calls
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻塞调用
- en: Non-blocking calls
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非阻塞调用
- en: Back-pressure
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反压
- en: Implementing reactive pattern using the Spring Framework
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring框架实现响应式模式
- en: Spring Web reactive module
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Web响应式模块
- en: Implementing reactive at server side
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器端实现响应式
- en: Implementing reactive at client side
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端实现响应式
- en: Request and response body type conversion
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求和响应体类型转换
- en: This chapter will teach you how to make a system responsive in the face of any
    variable load, partial outages, program failure, and more. Nowadays, systems are
    distributed across different nodes to efficiently serve requests.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教你如何在面对任何可变负载、部分故障、程序失败等情况时使系统保持响应。如今，系统被分布在不同节点上以高效地处理请求。
- en: Let's look at the aforementioned topics in detail.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细探讨上述主题。
- en: Understanding the reactive pattern
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解响应式模式
- en: Today, the modern applications must be more robust, more resilient, more flexible,
    and better positioned to meet the requirements of the organizations, because,
    in the recent couple of years, the requirements for applications have changed
    dramatically. As we have seen in the last table, 10 to 15 years ago, a large application
    had 10 server nodes, the response time taken to serve a request was in seconds,
    we required a couple of hours of downtime for maintenance and deployment, and
    the data was in gigabytes. But today, an application requires thousands of server
    nodes, because it is accessed by multiple channels such as mobile devices. The
    server responses are expected within milliseconds, and the downtime for deployment
    and maintenance is near to 0%. Data has been increased from terabytes to petabytes.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，现代应用必须更加健壮、更加弹性、更加灵活，并且更好地满足组织的需求，因为，在最近几年里，应用的需求发生了巨大的变化。正如我们在上一张表中看到的，10到15年前，一个大型应用有10个服务器节点，处理请求的响应时间在秒级，我们需要的维护和部署停机时间大约是几个小时，数据量在千兆级别。但今天，一个应用需要数千个服务器节点，因为它可以通过多个渠道如移动设备访问。服务器响应时间预期在毫秒级，部署和维护的停机时间接近于0%。数据量已从千兆增长到拍字节。
- en: Ten-year old systems cannot fulfill the requirements of today's applications;
    we need a system that can fulfill all user's requirements either at the application
    level or the system level, which means we need a responsive system. Responsiveness
    is one of the properties of the reactive pattern. We want a system that must be
    responsive, resilient, elastic, and message-driven. We know these systems as reactive
    systems. These systems are more flexible, loosely-coupled, and scalable.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 十年以上的系统无法满足当今应用的需求；我们需要一个能够在应用层或系统层满足所有用户需求的系统，这意味着我们需要一个响应式的系统。响应性是响应式模式的一个特性。我们希望系统必须具有响应性、弹性、弹性和消息驱动性。我们把这些系统称为响应式系统。这些系统更加灵活、松散耦合且可扩展。
- en: A system must react to failure and stay available, that is, it should be resilient,
    and the system must react to variable load conditions, and not be overloaded.
    The system should react to events--event-driven or message-driven. If all these
    properties are associated with a system, then it will be responsive, that is,
    if a system reacts to its users, it is responsive. To create a reactive system,
    we must focus on the system level and application level. Let's see first the all
    reactive traits.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 系统必须对故障做出反应并保持可用性，即它应该是弹性的，并且系统必须对可变负载条件做出反应，而不会过载。系统应该对事件做出反应——无论是事件驱动的还是基于消息的。如果所有这些属性都与一个系统相关联，那么它将是响应式的，也就是说，如果一个系统对其用户做出反应，它就是响应式的。要创建一个响应式系统，我们必须关注系统级和应用级。让我们首先看看所有响应式特性。
- en: The reactive pattern traits
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式模式特性
- en: 'The following are the principles of the Reactive pattern:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对响应式模式的原则：
- en: '**Responsive**: This is the goal of each application today.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应式**：这是今天每个应用程序的目标。'
- en: '**Resilient**: This is required to make an application responsive.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：这是使应用程序响应式所必需的。'
- en: '**Scalable**: This is also required to make an application responsive; without
    resilience and scalability, it is impossible to achieve responsiveness.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可伸缩性**：这也是使应用程序响应式所必需的；没有弹性和可伸缩性，就不可能实现响应性。'
- en: '**Message-driven**: A message-driven architecture is the base of a scalable
    and resilient application, and ultimately, it makes a system responsive. Message-driven
    either based on the event-driven or actor-based programming model.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于消息的**：基于消息的架构是可伸缩和弹性的应用程序的基础，最终，它使系统响应式。基于消息的架构可以是基于事件驱动的或基于演员的编程模型。'
- en: 'The preceding points mentioned are core principles of the reactive pattern.
    Let''s explore each principle of the reactive pattern in detail, and understand
    why all of them must be applied together in order to make a reactive system with
    quality software for a modern context application, which is able to handle millions
    of parallel requests in milliseconds without any failure. Let''s first understand
    these principles with the following diagram:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 上述提到的点是响应式模式的核心原则。让我们详细探讨响应式模式的每个原则，并了解为什么所有这些原则必须一起应用，才能在现代应用环境中构建一个具有高质量软件的响应式系统，该系统能在毫秒内处理数百万个并行请求而不会出现任何故障。让我们首先通过以下图表来理解这些原则：
- en: '![](img/1b916152-d20b-4250-a1a2-b7ee0e54c418.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1b916152-d20b-4250-a1a2-b7ee0e54c418.png)'
- en: As you can see in the preceding diagram, to make a system reactive, we need
    scalability and resilience. To make a system scalable and resilient, we need an
    event-driven or message-driven architecture of the application. Ultimately, these
    principles, scalability, resilience, and event-driven architecture make a system
    responsive to the client. Let's see these properties in detail.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，为了使系统响应式，我们需要可伸缩性和弹性。为了使系统可伸缩和弹性，我们需要应用程序的事件驱动或基于消息的架构。最终，这些原则，可伸缩性、弹性和事件驱动架构使系统能够对客户端做出响应。让我们详细看看这些特性。
- en: Responsiveness
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应性
- en: When we say that a system or an application is responsive, it means that the
    application or system responds quickly to all users in a given time in all conditions,
    and that is in good condition as well as bad. It ensures a consistent positive
    user experience.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说一个系统或应用程序是响应式的，这意味着该应用程序或系统在所有条件下都能在给定时间内快速响应用户，无论是处于良好状态还是不良状态。这确保了用户体验的一致性和积极性。
- en: 'Responsiveness is required for a system for usability and utility. A responsive
    system means that up on system failure, either because of an external system or
    a spike in traffic, the failures are detected quickly, and dealt with effectively
    in a short time without the users knowing of the failure. An end user must be
    able to interact with the system by providing rapid and consistent response times.
    A user must not face any failure during interaction with the system, and it must
    deliver a consistent quality of service to the user. That consistent behavior
    solves the failures and builds end-user confidence in the system. Quickness and
    a positive user experience under various conditions make a system responsive.
    It depends on the two other traits of a reactive application or system, that is,
    resilience and scalability. Another trait, that is, event-driven or message-driven
    architecture, provides the overall foundation for a responsive system. The following
    diagram illustrates a responsive system:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个系统来说，响应性是必需的，以确保可用性和实用性。一个响应性系统意味着在系统发生故障时，无论是由于外部系统还是流量激增，故障都能迅速检测到，并在短时间内得到有效处理，而用户不会意识到故障。最终用户必须能够通过提供快速和一致的反应时间与系统交互。用户在与系统交互时不应遇到任何故障，并且系统必须向用户提供一致的服务质量。这种一致的行为解决了故障，并在系统中建立了最终用户的信心。在各种条件下，快速性和积极的用户体验使系统具有响应性。这取决于反应式应用程序或系统的另外两个特征，即弹性和可伸缩性。另一个特征，即事件驱动或消息驱动架构，为响应性系统提供了整体基础。以下图展示了响应性系统：
- en: '![](img/76c032b0-0a17-4b9f-ab4f-38870c843f2f.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/76c032b0-0a17-4b9f-ab4f-38870c843f2f.png)'
- en: As you can see in the preceding diagram, a responsive system depends on resilient
    and scalability of the system, and these depend on its event-driven architecture.
    Let's look at the other traits of a reactive application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以在前面的图中看到的那样，一个响应性系统依赖于系统的弹性和可伸缩性，而这些又依赖于其事件驱动架构。让我们看看反应式应用程序的其他特征。
- en: Resilience
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性
- en: When we design and develop a system, we have consider all conditions--good and
    bad. If we consider only the good conditions, then we tend to implement a system
    that may fail after just a few days. A major application failure results in downtime
    and data loss and damages your application's reputation in the market.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设计和开发一个系统时，我们必须考虑所有条件——无论是好是坏。如果我们只考虑好的条件，那么我们可能会实施一个系统，这个系统在短短几天后就会失败。主要的应用程序故障会导致停机、数据丢失，并损害你在市场上的应用程序声誉。
- en: So, we have to focus on every condition to ensure the responsiveness of the
    application under all conditions. Such a system or application is known as a resilient
    system.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须关注每一个条件，以确保应用程序在所有条件下都具有响应性。这样的系统或应用程序被称为弹性系统。
- en: 'Every system must be resilient to ensure responsiveness. If a system is not
    resilient, it will be unresponsive after a failure. So, a system must be responsive
    in the face of failure as well. In the whole system, failure can exist in any
    component of the application or system. So, each component in the system must
    be isolated from each other so that at the time of failure of a component, we
    can recover it without compromising the system as a whole. Recovery of an individual
    component is achieved by replication. If a system is resilient, then it must have
    replication, containment, isolation, and delegation. Take a look at the following
    diagram, which illustrates the resilient traits of a reactive application or system:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每个系统都必须具有弹性以确保响应性。如果一个系统不具备弹性，那么在发生故障后它将无法响应。因此，一个系统在面临故障时也必须具有响应性。在整个系统中，故障可能存在于应用程序或系统的任何组件中。因此，系统中的每个组件都必须相互隔离，以便在组件故障时，我们可以恢复它而不会影响整个系统。单个组件的恢复是通过复制实现的。如果一个系统具有弹性，那么它必须具备复制、遏制、隔离和委派。看看下面的图，它说明了反应式应用程序或系统的弹性特征：
- en: '![](img/b591206b-d282-49de-a9e3-00e5a213624e.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b591206b-d282-49de-a9e3-00e5a213624e.png)'
- en: 'As you can see in the preceding diagram, resilience is achieved by replication,
    containment, isolation, and delegation. Let''s discuss these points in detail:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以在前面的图中看到的那样，通过复制、遏制、隔离和委派来实现弹性。让我们详细讨论这些点：
- en: '**Replication**: This ensures high-availability, where necessary, at the time
    of component failure.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复制**：这确保了在组件故障时，在必要时提供高可用性。'
- en: '**Isolation**: This means that the failure of each component must be isolated,
    which is achieved by decoupling the components as much as possible. Isolation
    is needed for a system to self-heal. If your system has isolation in place, then
    you can easily measure the performance of each component, and check the memory
    and CPU usage. Moreover, the failure of one component won''t impact the responsiveness
    of the overall system or application.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离**：这意味着每个组件的失败必须被隔离，这通过尽可能多地解耦组件来实现。隔离对于系统自我修复是必要的。如果你的系统已经实现了隔离，那么你可以轻松地测量每个组件的性能，并检查内存和CPU的使用情况。此外，一个组件的失败不会影响整个系统或应用程序的响应性。'
- en: '**Containment**: The result of decoupling is containment of the failure. It
    helps avoid failure in the system as a whole.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包容**：解耦的结果是包含失败。这有助于避免整个系统出现故障。'
- en: '**Delegation**: After failure, the recovery of each component is delegated
    to another component. It is possible only when our system is composable.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**委托**：在失败后，每个组件的恢复委托给另一个组件。只有在我们的系统是可组合的情况下才可能实现。'
- en: Modern applications not only depend on the internal infrastructure but are also
    integrated with other web services via network protocols. So, our applications
    must be resilient at their core in order to stay responsive under a variety of
    real-world in the opposite conditions. Our applications must not only be resilient
    at the application level but also at the system level.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现代应用程序不仅依赖于内部基础设施，还通过网络协议与其他网络服务集成。因此，我们的应用程序必须在核心上具有弹性，以便在各种现实条件下的相反条件下保持响应性。我们的应用程序不仅需要在应用层面上具有弹性，还需要在系统层面上具有弹性。
- en: Let's see another principle of the reactive pattern.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看反应式模式的另一个原则。
- en: Scalable
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可扩展
- en: Resiliency and scalability together make a system consistently responsive. A
    scalable system or an elastic system can easily be upgraded under a varying workload.
    A reactive system can be made scalable on demand by increasing and decreasing
    the resources allocated to service these inputs. It supports multiple scaling
    algorithms by providing relevant live performance for the scalability of the application.
    We can achieve scalability by using cost-effective software and cheap commodity
    hardware (for example, the Cloud).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性和可扩展性共同使系统持续响应。可扩展的系统或弹性的系统可以在不同的工作负载下轻松升级。通过增加和减少分配给处理这些输入的资源，可以按需使反应式系统可扩展。它通过提供与应用程序可扩展性相关的实时性能来支持多种扩展算法。我们可以通过使用成本效益高的软件和廉价的基础硬件（例如，云）来实现可扩展性。
- en: 'An application is scalable if it can be extended according to its usage, in
    the following ways:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序如果可以根据其使用情况进行扩展，则被认为是可扩展的，以下是一些扩展方式：
- en: '**scale-up**: It makes use of parallelism in multi-core systems.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向上扩展**：它利用了多核系统中的并行性。'
- en: '**scale-out**: It makes use of multi-server nodes. Location transparency and
    resilience are important for this.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向外扩展**：它利用了多服务器节点。位置透明性和弹性对于这一点很重要。'
- en: Minimizing the shared mutable state is very important for scalability.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最小化共享可变状态对于可扩展性非常重要。
- en: Elasticity and Scalability are both the same! Scalability is all about the efficient
    use of resources already available, while elasticity is all about adding new resources
    to your application on demand when the needs of the system changed. So, eventually,
    the system can be made responsive anyway--by either using the existing resources
    of the system or by adding new resources to the system.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性和可扩展性是相同的！可扩展性主要关于高效使用已存在的资源，而弹性则是当系统需求变化时，根据需要向应用程序添加新资源。因此，最终，系统可以通过使用现有资源或向系统添加新资源来保持响应性。
- en: Let's see the final foundation of the resilient and scalability of the reactive
    pattern, that is, message-driven architecture.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看具有弹性和可扩展性的最终基础，即消息驱动架构。
- en: Message-driven architecture
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息驱动架构
- en: A message-driven architecture is the base of a responsive application. A message-driven
    application can be an event-driven and actor-based application. It can also be
    a combination of both architectures--event-driven and actor-based architecture.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 消息驱动架构是响应式应用程序的基础。消息驱动应用程序可以是事件驱动和基于actor的应用程序。它也可以是这两种架构的组合——事件驱动和基于actor架构。
- en: 'In event-driven architecture, events and event observers play the main role.
    Events happen, but are not directed to a specific address; event listeners listen
    to these events, and take actions. But in message-driven architecture, the messages
    have a proper direction to the destination. Let''s look at the following diagram
    that illustrates message-driven and event-driven architectures:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件驱动架构中，事件和事件观察者扮演主要角色。事件发生，但不是指向特定地址；事件监听器监听这些事件，并采取行动。但在消息驱动架构中，消息有适当的指向目的地的方向。让我们看看以下图解消息驱动和事件驱动架构的图：
- en: '![](img/e69c809d-c56b-4a96-a15e-7904e66edfeb.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e69c809d-c56b-4a96-a15e-7904e66edfeb.png)'
- en: As you can see in the preceding diagram, in event-driven architecture, if an
    event happens, then listeners listen to it. But in the message-driven one, one
    generated message communication has an addressable recipient and a single purpose.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的图中可以看到，在事件驱动架构中，如果发生事件，则监听器会监听它。但在消息驱动架构中，一个生成的消息通信有一个可寻址的接收者和单一目的。
- en: Asynchronous message-driven architecture acts as the foundation for a reactive
    system by establishing limitations between the components. It ensures loose coupling,
    isolation, and location transparency. Isolation between components fully depends
    on the loose coupling between them. And isolations and loose coupling develop
    the base of resilience and elasticity.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 异步消息驱动架构通过在组件之间建立限制，作为反应式系统的基础。它确保了松散耦合、隔离和位置透明性。组件之间的隔离完全取决于它们之间的松散耦合。隔离和松散耦合构成了弹性和恢复力的基础。
- en: A large system has multiple components. These components either have smaller
    applications, or they may have reactive properties. This means that the reactive
    design principles have to apply at all levels of the scale to make a large system
    composable.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一个大型系统由多个组件组成。这些组件要么有较小的应用，要么可能具有反应性。这意味着反应式设计原则必须应用于所有规模级别，以使大型系统可组合。
- en: Traditionally, large systems are composed of multiple threads which communicate
    with a shared synchronized state. It tends to have strong coupling and is hard
    to compose, and it also tends to block stage. But, for now, all large systems
    are composed of loosely coupled event handlers. And events can be handled asynchronously
    without blocking.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，大型系统由多个线程组成，这些线程通过共享同步状态进行通信。它往往具有强耦合性，难以组合，并且也倾向于阻塞阶段。但现在，所有大型系统都是由松散耦合的事件处理器组成的。事件可以异步处理而不阻塞。
- en: Let's look at the blocking and non-blocking programming models.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看阻塞和非阻塞编程模型。
- en: In very simple terms, reactive programming is all about non-blocking applications
    that are asynchronous and event-driven, and require a small number of threads
    to scale vertically rather than horizontally.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 用非常简单的术语来说，反应式编程完全是关于非阻塞应用程序，这些应用程序是异步和事件驱动的，并且需要少量线程进行垂直扩展，而不是水平扩展。
- en: Blocking calls
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阻塞调用
- en: In a system, a call may be holding the resources while other calls wait for
    the same resources. These resources are released when the other one finishes using
    them.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个系统中，一个调用可能正在占用资源，而其他调用正在等待相同的资源。这些资源在另一个完成使用后释放。
- en: 'Let''s come to the technical words--actually, blocking a call means some operations
    in the application or system that take a longer time to complete, such as file
    I/O operations and database access using blocking drives. The following is a diagram
    of blocking calls for the JDBC operation in a system:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来谈谈技术术语——实际上，阻塞调用意味着应用程序或系统中一些需要较长时间完成的操作，例如使用阻塞驱动器的文件I/O操作和数据库访问。以下是在系统中JDBC操作的阻塞调用图：
- en: '![](img/d4aa2b1f-c8de-47a7-b760-c385e8b9a639.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d4aa2b1f-c8de-47a7-b760-c385e8b9a639.png)'
- en: As you can see in the preceding diagram, the blocking operations, shown here
    in red, are the ones where the user calls the servlet to fetch data, then that
    moves to the JDBC and DB connection with the DB server. Until that time, the current
    thread waits for the result set from the DB server. If the DB server has latency,
    then this wait time can increase. That means that thread execution depends on
    the DB server latency.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的图中可以看到，这里用红色显示的阻塞操作是用户调用servlet获取数据，然后移动到与数据库服务器的JDBC和DB连接。直到那时，当前线程等待来自数据库服务器的结果集。如果数据库服务器有延迟，那么等待时间可能会增加。这意味着线程执行依赖于数据库服务器的延迟。
- en: Let's look at how to make this a non-blocking execution.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使这成为一个非阻塞执行。
- en: Non-blocking calls
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非阻塞调用
- en: Non-blocking execution of a program means that a thread competes for a resource
    without waiting for it. A non-blocking API for the resources allows calling the
    resources without waiting for the blocked call such as database access and network
    calls. If the resources are not available at the time of calling, then it moves
    to other work rather than waiting for the blocked resources. The system is notified
    when the blocked resources are available.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的非阻塞执行意味着线程在竞争资源时不需要等待。资源的非阻塞 API 允许在不需要等待阻塞调用（如数据库访问和网络调用）的情况下调用资源。如果调用时资源不可用，则它将转到其他工作，而不是等待阻塞资源。当阻塞资源可用时，系统会得到通知。
- en: 'Take a look at the following diagram that shows the JDBC connection to access
    data without the blocking thread execution:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下图表，它展示了如何通过非阻塞线程执行来访问数据的 JDBC 连接：
- en: '![](img/1398578c-a083-4e21-add1-7a9c3ef15c01.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1398578c-a083-4e21-add1-7a9c3ef15c01.png)'
- en: As you can see in the preceding diagram, thread execution does not wait for
    the result set from the DB server. The thread makes the DB connection and SQL
    statement for the DB server. If the DB server has latency in the response, then
    the thread moves on to do other work rather than be blocked waiting for the resource
    to become available.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，线程执行不会等待来自数据库服务器的结果集。线程为数据库服务器创建数据库连接和 SQL 语句。如果数据库服务器在响应中存在延迟，则线程会继续执行其他工作，而不是被阻塞等待资源可用。
- en: Back-pressure
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背压
- en: A reactive application is never given up in overload conditions. Back-pressure
    is a key aspect of a reactive application. It is a mechanism to ensure that the
    reactive application doesn't overwhelm the consumers. It tests aspects for the
    reactive application. It tests the system response gracefully under any load.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在过载条件下，响应式应用程序永远不会放弃。背压是响应式应用程序的一个关键方面。它是一种确保响应式应用程序不会压倒消费者的机制。它测试响应式应用程序的各个方面。它测试系统在任何负载下都能优雅地响应。
- en: The back-pressure mechanism ensures that the system is resilient under load.
    In a back-pressure condition, the system makes itself scalable by applying other
    resources to help distribute the load.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 背压机制确保系统在负载下具有弹性。在背压条件下，系统通过应用其他资源来帮助分配负载，从而使自己可扩展。
- en: Until now, we have seen the reactive pattern principles; these are mandatory
    to make a system responsive in the blue sky or grey sky. Let's see, in the upcoming
    section how Spring 5 implements reactive programming.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了响应式模式的原则；这些是使系统在晴朗或阴霾的天空下都能响应的必要条件。让我们看看，在下一节中 Spring 5 如何实现响应式编程。
- en: Implementing reactive with the Spring 5 Framework
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring 5 框架实现响应式
- en: The most highlighted feature of the latest version of the Spring Framework is
    the new reactive stack web framework. Reactive is the update that takes us to
    the future. This area of technology is gaining popularity with every passing day,
    which is the reason why Spring Framework 5.0 has been launched with the capability
    of reactive programming. This addition makes the latest version of the Spring
    Framework convenient for event-loop style processing, which enables scaling with
    a small number of threads.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 框架最新版本最突出的特性是新的响应式堆栈 Web 框架。响应式是带我们走向未来的更新。随着每一天的过去，这个技术领域越来越受欢迎，这就是为什么
    Spring 框架 5.0 被推出时具有响应式编程的能力。这一新增功能使得 Spring 框架的最新版本便于以事件循环风格处理，这允许使用少量线程进行扩展。
- en: The Spring 5 Framework implements the reactive programming pattern by using
    the reactor internally for its own reactive support. A reactor is a Reactive Stream
    implementation that extends the basic Reactive Streams. Twitter has been implemented
    as a reactive passed by using Reactive Streams.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 5 框架通过内部使用 reactor 来实现其自身的响应式支持，从而实现了响应式编程模式。Reactor 是一个扩展了基本 Reactive
    Streams 的响应式流实现。Twitter 通过使用 Reactive Streams 实现了响应式传递。
- en: Reactive Streams
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式流
- en: Reactive Streams provide a protocol or rule for asynchronous stream processing
    with non-blocking back-pressure. This standard is also adopted by Java 9 in the
    form of `java.util.concurrent.Flow`. Reactive Streams is composed of four simple
    Java interfaces. These interfaces are `Publisher`, `Subscriber`, `Subscription`,
    and `Processor`. But the main goal of the Reactive Streams is handling the backpressure.
    As discussed earlier, backpressure is a process that allows a receiver to ask
    about a data quantity from the emitter.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Reactive Streams 提供了一种异步流处理的协议或规则，具有非阻塞的反馈压力。这个标准也被 Java 9 以 `java.util.concurrent.Flow`
    的形式采用。Reactive Streams 由四个简单的 Java 接口组成。这些接口是 `Publisher`、`Subscriber`、`Subscription`
    和 `Processor`。但 Reactive Streams 的主要目标是处理反馈压力。如前所述，反馈压力是一个允许接收器从发射器询问数据量的过程。
- en: 'You can use the following Maven dependency for adding Reactive Streams in your
    application development:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下 Maven 依赖项在您的应用程序开发中添加 Reactive Streams：
- en: '[PRE0]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding Maven dependency code adds the required libraries for the Reactive
    Streams in your application. In the upcoming section, we'll see how Spring implements
    Reactive Streams in the web module of Spring and the Spring MVC Framework.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 Maven 依赖代码为您的应用程序添加了所需的 Reactive Streams 库。在接下来的章节中，我们将看到 Spring 如何在 Spring
    和 Spring MVC 框架的 Web 模块中实现 Reactive Streams。
- en: Spring Web reactive module
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Web 反应式模块
- en: As of Spring 5.0 Framework, Spring has introduced a new module for reactive
    programming--the spring-web-reactive module. It is based on Reactive Streams.
    Basically, this module uses the Spring MVC module with reactive programming, so,
    you can still use the Spring MVC module for your web application either separately
    or with the spring-web-reactive module.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 Spring 5.0 框架，Spring 引入了一个新的反应式编程模块——spring-web-reactive 模块。它基于 Reactive
    Streams。基本上，此模块使用具有反应式编程的 Spring MVC 模块，因此，您仍然可以在 Web 应用程序中使用 Spring MVC 模块，无论是单独使用还是与
    spring-web-reactive 模块一起使用。
- en: This new module in the Spring 5.0 Framework contains support for the Reactive-web-functional-
    based programming model. It also supports the Annotation-based programming model.
    The Spring-web-reactive module contains support for reactive HTTP and WebSocket
    clients to call the reactive server application. It also enables the reactive
    web client to make a connection with a reactive HTTP connection with a reactive
    web application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的模块在 Spring 5.0 框架中包含了对基于反应式-web-functional 编程模型的支持。它还支持基于注解的编程模型。Spring-web-reactive
    模块包含对反应式 HTTP 和 WebSocket 客户端调用反应式服务器应用程序的支持。它还使反应式 Web 客户端能够与反应式 Web 应用程序建立反应式
    HTTP 连接。
- en: 'The following diagram shows a Spring-web-reactive module with its components
    that give reactive behavior to the Spring web application:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图显示了具有赋予 Spring Web 应用程序反应性行为的组件的 Spring-web-reactive 模块：
- en: '![](img/2bde56a1-73df-42c1-af5a-374403e55064.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2bde56a1-73df-42c1-af5a-374403e55064.png)'
- en: As you can see in the preceding diagram, there are two parallel modules--one
    for the traditional Spring MVC framework, and the other for the Spring-reactive
    web modules. On the left side in the diagram are the Spring-MVC-related components
    such as the @MVC controllers, **spring-web-mvc module**, **Servlet API module**,
    and **Servlet Container.** On the right side in the diagram are the spring-web-reactive
    related components such as the Router Functions, spring-web-reactive module, HTTP/Reactive
    Streams, Reactive version of Tomcat, and so on. **Spring-web-reactive** related
    components such as the **Router Functions**, **spring-web-reactive module**, **HTTP/Reactive
    Streams**, Reactive version of Tomcat, and so on.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面图中所见，有两个并行模块——一个用于传统的 Spring MVC 框架，另一个用于 Spring-reactive Web 模块。图左侧是 Spring-MVC
    相关组件，如 @MVC 控制器、**spring-web-mvc 模块**、**Servlet API 模块**和**Servlet 容器**。图右侧是 spring-web-reactive
    相关组件，如 Router Functions、spring-web-reactive 模块、HTTP/Reactive Streams、Tomcat 的反应式版本等。**Spring-web-reactive**
    相关组件，如 **Router Functions**、**spring-web-reactive 模块**、**HTTP/Reactive Streams**、Tomcat
    的反应式版本等。
- en: 'In the preceding diagram, you must focus on the placement of the modules. Each
    module on the same level has comparisons between the traditional Spring MVC and
    Spring-web-reactive modules. These comparisons are given as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，您必须关注模块的位置。同一级别的每个模块都有传统 Spring MVC 和 Spring-web-reactive 模块的比较。这些比较如下所示：
- en: In the Spring web reactive modules, the Router functions are similar to the
    @MVC controllers in the Spring MVC modules such as the `@Controller`, `@RestController`,
    and `@RequestMapping` annotations.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Spring Web 反应式模块中，路由函数与 Spring MVC 模块中的 `@Controller`、`@RestController` 和
    `@RequestMapping` 注解类似。
- en: The Spring-web-reactive module is parallel to the Spring-web-MVC modules.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring-web-reactive 模块与 Spring-web-MVC 模块并行。
- en: In the traditional Spring MVC Framework, we use the Servlet API for the `HttpServletRequest`
    and `HttpServletResponse` in the servlet container. But in the Spring-web-reactive
    framework, we use HTTP/Reactive Streams, which creates `HttpServerRequest` and
    `HttpServerResponse` under the reactive support of the tomcat server.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在传统的 Spring MVC 框架中，我们使用 Servlet API 在 Servlet 容器中为 `HttpServletRequest` 和 `HttpServletResponse`。但在
    Spring-web-reactive 框架中，我们使用 HTTP/Reactive Streams，在 tomcat 服务器的反应式支持下创建 `HttpServerRequest`
    和 `HttpServerResponse`。
- en: We can user Servlet Container for the traditional Spring MVC Framework, but
    a reactive-supported server is required for the Spring-web-reactive application.
    Spring provides support for Tomcat, Jetty, Netty, and Undertow.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 Servlet 容器来支持传统的 Spring MVC 框架，但对于 Spring-web-reactive 应用程序则需要一个支持反应式的服务器。Spring
    提供了对 Tomcat、Jetty、Netty 和 Undertow 的支持。
- en: In [Chapter 10](ef5eac66-9b41-4959-8155-96f002137409.xhtml), *Implementing MVC
    Pattern in a Web Application using Spring*, you learned how to implement a web
    application using the Spring MVC module. Let's now see how to implement a reactive
    web application by using the Spring web reactive module.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 10 章](ef5eac66-9b41-4959-8155-96f002137409.xhtml) 中，*使用 Spring 在 Web 应用程序中实现
    MVC 模式*，您学习了如何使用 Spring MVC 模块实现 Web 应用程序。现在让我们看看如何通过使用 Spring Web 反应式模块来实现反应式
    Web 应用程序。
- en: Implementing a reactive web application at the server side
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在服务器端实现反应式 Web 应用程序
- en: 'Spring reactive web modules support both programming models--Annotation-based
    or the Functional-based programming model. Let''s see how these models work on
    the server side:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 反应式 Web 模块支持两种编程模型——基于注解或基于函数的编程模型。让我们看看这些模型在服务器端是如何工作的：
- en: '**Annotations-based programming model**: It is based on MVC annotations such
    as `@Controller`, `@RestController`, `@RequestMapping`, and many more. Annotations
    are supported by the Spring MVC framework for server-side programming for a web
    application.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于注解的编程模型**：它基于 MVC 注解，如 `@Controller`、`@RestController`、`@RequestMapping`
    等。Spring MVC 框架支持这些注解，用于在 Web 应用程序中进行服务器端编程。'
- en: '**Functional programming model:** It is a new paradigm of programming supported
    by the Spring 5 Framework. It is based on the Java 8 Lambda style routing and
    handling. Scala also provides the functional programming paradigm.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数式编程模型**：这是 Spring 5 框架支持的一种新的编程范式。它基于 Java 8 Lambda 风格的路线和处理。Scala 也提供了函数式编程范式。'
- en: 'The following are the Maven dependencies that we have to add for a reactive
    web application based on Spring Boot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们必须为基于 Spring Boot 的反应式 Web 应用程序添加的 Maven 依赖项：
- en: '[PRE1]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see in the preceding Maven configuration file for dependencies, we
    have added the `spring-boot-starter-webflux` and `reactor-test` dependencies to
    the application.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在先前的 Maven 依赖配置文件中所见，我们已将 `spring-boot-starter-webflux` 和 `reactor-test` 依赖项添加到应用程序中。
- en: Let's create a reactive web application based on the Annotation-based programming
    model.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们基于基于注解的编程模型创建一个反应式 Web 应用程序。
- en: The Annotation-based programming model
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于注解的编程模型
- en: You can use the same annotations that you have used in [Chapter 10](ef5eac66-9b41-4959-8155-96f002137409.xhtml),
    *Implementing MVC pattern in a Web Application with Spring*. Annotations such
    as `@Controller` and `@RestController` of Spring MVC are also supported on the
    reactive side. There is no difference till now between the traditional Spring
    MVC and Spring web with reactive module. The actual difference starts after the
    `@Controller` annotation configuration declaration, that is, when we go to the
    internal working of the Spring MVC, starting with `HandlerMapping` and `HandlerAdapter`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用在 [第 10 章](ef5eac66-9b41-4959-8155-96f002137409.xhtml) 中使用过的相同注解，*使用 Spring
    在 Web 应用程序中实现 MVC 模式*。Spring MVC 的 `@Controller` 和 `@RestController` 注解在反应式端也得到了支持。到目前为止，传统
    Spring MVC 和带有反应模块的 Spring Web 之间没有区别。真正的区别始于 `@Controller` 注解配置声明之后，即当我们深入到 Spring
    MVC 的内部工作，从 `HandlerMapping` 和 `HandlerAdapter` 开始。
- en: The main difference between the traditional Spring MVC and Spring web reactive
    comes into play in the request-handling mechanism. Spring MVC without reactive
    handles the requests using the blocking `HttpServletRequest` and the `HttpServletResponse`
    interfaces of the Servlet API, but the Spring web reactive framework is non-blocking,
    and operates on the reactive `ServerHttpRequest` and `ServerHttpResponse` rather
    than on `HttpServletRequest` and `HttpServletResponse`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 传统 Spring MVC 和 Spring Web Reactive 在请求处理机制上的主要区别在于。Spring MVC 无反应式处理请求时使用 Servlet
    API 的阻塞`HttpServletRequest`和`HttpServletResponse`接口，但 Spring Web Reactive 框架是非阻塞的，它操作于反应式的`ServerHttpRequest`和`ServerHttpResponse`而不是`HttpServletRequest`和`HttpServletResponse`。
- en: 'Let''s see the following example with a reactive controller:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下使用反应式控制器的示例：
- en: '[PRE2]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see in the preceding Controller code of `AccountController.java`,
    I have used the same Spring MVC annotations such as `@RestController` to declare
    a controller class, and `@GetMapping` and `@PostMapping` are used to create the
    request handler methods for the `GET` and `POST` request methods respectively.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面`AccountController.java`控制器的代码中看到的，我使用了相同的 Spring MVC 注解，如`@RestController`来声明控制器类，`@GetMapping`和`@PostMapping`分别用于创建`GET`和`POST`请求方法的请求处理方法。
- en: Let's focus on the return types of the handler methods. These methods return
    values as **Mono** and **Flux** types. These are types of the reactive steams
    provided by the reactor framework. Also, the handler method takes the request
    body using the Publisher type.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关注处理方法的返回类型。这些方法以**Mono**和**Flux**类型返回值。这些都是由 Reactor 框架提供的反应式流类型。此外，处理方法使用发布者类型获取请求体。
- en: Reactor is a Java Framework from the Pivotal open-source team. It builds directly
    on Reactive Streams, so there is no need for a bridge. The Reactor IO project
    provides wrappers around low-level network runtimes like Netty and Aeron. Reactor
    is a "4th Generation" library according to David Karnok's Generations of Reactive
    classification.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor 是由 Pivotal 开源团队开发的 Java 框架。它直接建立在反应式流之上，因此不需要桥接。Reactor IO 项目提供了对低级网络运行时（如
    Netty 和 Aeron）的包装。根据 David Karnok 的反应式编程代际分类，Reactor 是“第四代”库。
- en: Let's look at the same controller class using the functional programming model
    to handle requests.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用函数式编程模型来处理请求的相同控制器类。
- en: The functional programming model
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程模型
- en: The functional programming model uses the API that has functional interfaces
    such as `RouterFunction` and `HandlerFunction`. It uses Java 8 Lambda style programming
    with routing and request handling instead of the Spring MVC annotations. They
    are simple, but powerful, building blocks for creating web applications.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程模型使用具有函数式接口（如`RouterFunction`和`HandlerFunction`）的 API。它使用 Java 8 Lambda
    风格编程，通过路由和请求处理来代替 Spring MVC 注解。它们是创建 Web 应用程序的简单但强大的构建块。
- en: 'The following is an example of functional request handling:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个函数式请求处理的示例：
- en: '[PRE3]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, the class file, `AccountHandler.java`, is based on the
    functional reactive programming model. Here, I have used the reactor framework
    to handle the request. Two functional interfaces, `ServerRequest` and `ServerResponse`,
    are used to handle requests and to generate responses.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，类文件`AccountHandler.java`基于函数式反应式编程模型。在这里，我使用了 Reactor 框架来处理请求。使用了两个函数式接口`ServerRequest`和`ServerResponse`来处理请求并生成响应。
- en: Let's see the Repositories classes of this application. The following `AccountRepository`
    and `AccountRepositoryImpl` classes are the same for both type of applications-Annotation-based
    and the functional-based programming model.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个应用程序的仓储类。下面的`AccountRepository`和`AccountRepositoryImpl`类对于两种应用程序类型——基于注解和基于函数式编程模型——都是相同的。
- en: 'Let''s create an interface `AccountRepository.java` class as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个接口`AccountRepository.java`类，如下所示：
- en: '[PRE4]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code is an interface, let''s implements this interface with the
    `AccountRepositoryImpl.java` class as following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是一个接口，让我们用`AccountRepositoryImpl.java`类来实现这个接口，如下所示：
- en: '[PRE5]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see in the preceding code, we created the `AccountRepository` class.
    This class has only three methods: `findById()`, `findAll()`, and `save()`. We
    implemented these methods according to the business requirements. In this repository
    class, I have, especially, used the Flux and Mono react types to make it a reactive-based
    application.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们创建了`AccountRepository`类。这个类只有三个方法：`findById()`、`findAll()`和`save()`。我们根据业务需求实现了这些方法。在这个仓库类中，我特别使用了Flux和Mono反应类型，使其成为一个基于响应式的应用程序。
- en: 'Let''s create the server for the functional-based programming model. In Annotation-based
    programming, we use the simple tomcat container to deploy the web application.
    But for this functional-based programming, we have to create a Server class to
    start the Tomcat server or Reactor server, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为基于函数的编程模型创建服务器。在基于注解的编程中，我们使用简单的Tomcat容器来部署Web应用程序。但针对这种基于函数的编程，我们必须创建一个Server类来启动Tomcat服务器或Reactor服务器，如下所示：
- en: '[PRE6]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see in the preceding `Server.java` class file, I have added both,
    the Tomcat and Reactor servers. The Tomcat server uses port 8080, but the Reactor
    server uses the port `8181`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述`Server.java`类文件所示，我添加了Tomcat和Reactor服务器。Tomcat服务器使用端口8080，但Reactor服务器使用端口`8181`。
- en: This `Server.java` class has three methods. The first method, `routingFunction()`,
    is responsible for handling client requests by using the `AccountHandler` class.
    It depends on the `AccountRepository` class. The second method, `startReactorServer()`,
    is responsible for starting the Reactor server by using the `ReactorHttpHandlerAdapter`
    class of the reactor server. This class takes an object of the `HttpHandler` class
    as a constructor argument to create the request handler mapping. Similarly, the
    third method, `startTomcatServer()`, is responsible for starting the Tomcat server.
    And it is bound to the `HttpHandler` object through a reactor adapter class, `ServletHttpHandlerAdapter`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Server.java`类有三个方法。第一个方法`routingFunction()`负责通过`AccountHandler`类处理客户端请求。它依赖于`AccountRepository`类。第二个方法`startReactorServer()`负责通过Reactor服务器的`ReactorHttpHandlerAdapter`类启动Reactor服务器。这个类将`HttpHandler`类的对象作为构造函数参数来创建请求处理器映射。同样，第三个方法`startTomcatServer()`负责启动Tomcat服务器。它通过一个Reactor适配器类`ServletHttpHandlerAdapter`绑定到`HttpHandler`对象上。
- en: 'You can run this server class file as a Java application, and see the output
    on the browser by typing the URL, `http://localhost:8080/account/`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这个服务器类文件作为Java应用程序运行，并通过在浏览器中输入URL `http://localhost:8080/account/` 来查看输出：
- en: '![](img/c22f603b-fde7-4b27-9c36-9dc25d66e213.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c22f603b-fde7-4b27-9c36-9dc25d66e213.png)'
- en: 'You can also type the same URL with port `8181` for the Reactor server, as
    follows, and you will get the same output:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以为Reactor服务器使用相同的URL和端口`8181`，如下所示，你将得到相同的结果：
- en: '`http://localhost:8181/account/`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:8181/account/`'
- en: 'In this section, you learned how to create a reactive web application using
    the Spring-web-reactive module. We created the web application by using both the
    programming paradigms: Annotation-based and Functional-based.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何使用Spring-web-reactive模块创建一个响应式Web应用程序。我们通过使用两种编程范式：基于注解和基于函数的编程范式来创建Web应用程序。
- en: In the next section, we'll discuss client-side code, and how a client accesses
    the reactive web application.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论客户端代码，以及客户端如何访问响应式Web应用程序。
- en: Implementing a Reactive Client-Side application
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现响应式客户端应用程序
- en: The Spring 5 Framework introduces a functional and reactive WebClient. It is
    a fully non-blocking and reactive web client, and an alternative to `RestTemplate`.
    It creates the network input and output in the form of reactive `ClientHttpRequest`
    and `ClientHttpRespones`. It creates the body of the request and response in the
    form of `Flux<DataBuffer>` instead of `InputStream` and `OutputStream`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 5框架引入了一个功能和响应式的WebClient。它是一个完全非阻塞和响应式的Web客户端，是`RestTemplate`的替代品。它以响应式的`ClientHttpRequest`和`ClientHttpRespones`的形式创建网络输入和输出。它以`Flux<DataBuffer>`的形式创建请求和响应的主体，而不是`InputStream`和`OutputStream`。
- en: 'Let''s see the code for the web client, which creates a `Client.java` class:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看创建`Client.java`类的客户端代码：
- en: '[PRE7]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding class, `Client.java`, is a web client class for `Server.java`.
    It has two methods. The first method is `findAllAccounts()`. It fetches all accounts
    from the account repository. It uses the `org.springframework.web.reactive.function.client`.
    The `ClientRequest` interface to create a request to the `http://localhost:8080/account/`
    URI with the `GET` http method. By using the `org.springframework.web.reactive.function.client`.
    The `ExchangeFunction` interface, it calls the server, and fetches the result
    as the JSON format. Similarly, the other method, `createAccount()`, creates a
    new account in the server by using the URI with the `POST` method `http://localhost:8080/account/`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类`Client.java`是`Server.java`的Web客户端类。它有两个方法。第一个方法是`findAllAccounts()`。它从账户仓库中检索所有账户。它使用`org.springframework.web.reactive.function.client`的`ClientRequest`接口创建一个对`http://localhost:8080/account/`
    URI的`GET` http方法请求。通过使用`org.springframework.web.reactive.function.client`的`ExchangeFunction`接口，它调用服务器，并以JSON格式检索结果。同样，另一个方法`createAccount()`通过使用带有`POST`方法的URI
    `http://localhost:8080/account/`在服务器中创建一个新的账户。
- en: 'Let''s run the Client class as a Java application and see the output on the
    console, which is as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行Client类作为Java应用程序，并在控制台上查看输出，如下所示：
- en: '*![](img/39fecf73-9041-45a8-b8ba-1a881bacf7a7.png)*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](img/39fecf73-9041-45a8-b8ba-1a881bacf7a7.png)*'
- en: It creates a new record and fetch all five record in the form of JSON list.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 它创建了一个新记录，并以JSON列表的形式检索所有五个记录。
- en: The `AsyncRestTemplate` also supports non-blocking interactions. The main difference
    is that it can't support non-blocking streaming, for example, Twitter one, because,
    fundamentally, it's still based and relies on `InputStream` and `OutputStream`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncRestTemplate`也支持非阻塞交互。主要区别在于它不能支持非阻塞流，例如Twitter流，因为从根本上说，它仍然基于并依赖于`InputStream`和`OutputStream`。'
- en: In the next section, we'll talk about the request and response body parameters
    in a reactive web application.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论反应式Web应用程序中的请求和响应体参数。
- en: Request and response body conversion
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求和响应体转换
- en: In [Chapter 10](ef5eac66-9b41-4959-8155-96f002137409.xhtml), *Implementing MVC
    Pattern in a Web Application with Spring*, we discussed message conversion for
    the request body and response body either from Java to JSON, or from JSON to Java
    object, and many more. Similarly, conversion is also required in the case of a
    Reactive web application, . The spring core module provides reactive Encoder and
    Decoder to enable the serialization of a Flux of bytes to and from the typed objects.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](ef5eac66-9b41-4959-8155-96f002137409.xhtml)《使用Spring在Web应用程序中实现MVC模式》中，我们讨论了请求体和响应体的消息转换，无论是从Java到JSON，还是从JSON到Java对象，以及更多。同样，在反应式Web应用程序的情况下，也需要进行转换。Spring核心模块提供了反应式编码器和解码器，以启用Flux字节序列化和反序列化到类型对象。
- en: 'Let''s see the following example for request body type conversions. Developers
    do not need to forcefully do type conversion--the Spring Framework automatically
    converts it for you in both types of approaches: Annotation-based programming,
    and functional-based programming.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例，了解请求体类型转换。开发者不需要强制进行类型转换——Spring框架在两种方法中自动为您转换：基于注解的编程和基于功能的编程。
- en: '**Account account**: This means that the account object is deserialized before
    the controller is called without blocking.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Account account**：这意味着在调用控制器之前，账户对象被反序列化，而不会阻塞。'
- en: '**Mono<Account> account**: This means that `AccountController` can use the
    Mono to declare logic. The account object is first deserialized, and then this
    logic is executed.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mono<Account> account**：这意味着`AccountController`可以使用Mono来声明逻辑。账户对象首先被反序列化，然后执行此逻辑。'
- en: '**Flux<Account> accounts**: This means that `AccountController` can use Flux
    in case of the input streaming scenario.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Flux<Account> accounts**：这意味着在输入流场景中，`AccountController`可以使用Flux。'
- en: '**Single<Account> account**: This is very similar to the Mono, but here the
    Controller uses RxJava.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Single<Account> account**：这与Mono非常相似，但在这里控制器使用了RxJava。'
- en: '**Observable<Account> accounts**: This is also very similar to Flux, but in
    this case, the Controller uses input streaming with RxJava.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Observable<Account> accounts**：这也与Flux非常相似，但在这个情况下，控制器使用了RxJava的输入流。'
- en: 'In the preceding list, you saw the Spring Framework for type conversion in
    the reactive programing model. Let''s see the following return types in the example
    for the response body:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，您已经看到了在反应式编程模型中Spring框架的类型转换。让我们看看以下示例中响应体的返回类型：
- en: '**Account**: This serializes without blocking the given Account; implies a
    synchronous, non-blocking controller method.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Account**：它不会阻塞给定的 Account 进行序列化；意味着一个同步的、非阻塞的控制器方法。'
- en: '**void**: This is specific to the annotation-based programming model. Request
    handling completes when the method returns; this implies a synchronous, non-blocking
    controller method.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**void**：这特定于基于注解的编程模型。当方法返回时，请求处理完成；这意味着一个同步的、非阻塞的控制器方法。'
- en: '**Mono<Account>**: This serializes without blocking the given Account when
    the Mono completes.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mono<Account>**：当 Mono 完成时，它不会阻塞给定的 Account 进行序列化。'
- en: '**Mono<Void>**: This implies that request handling completes when the Mono
    completes.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mono<Void>**：这意味着当 Mono 完成时，请求处理完成。'
- en: '**Flux<Account>**: This is used in the streaming scenario, possibly, the SSE
    depends on the requested content type.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Flux<Account>**：这在流式场景中使用，可能 SSE 依赖于请求的内容类型。'
- en: '**Flux<ServerSentEvent>**: This enables SSE streaming.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Flux<ServerSentEvent>**：这使 SSE 流式传输成为可能。'
- en: '**Single<Account>**: The same, but uses RxJava.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Single<Account>**：与上面相同，但使用 RxJava。'
- en: '**Observable<Account>**: The same, but uses the RxJava Observable type.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Observable<Account>**：与上面相同，但使用 RxJava Observable 类型。'
- en: '**Flowable<Account>**: The same, but uses the RxJava 2 Flowable type.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Flowable<Account>**：与上面相同，但使用 RxJava 2 Flowable 类型。'
- en: In the preceding list, you have seen the return types of the handler methods.
    The Spring Framework does type conversions in the reactive programing model.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，你看到了处理方法的返回类型。Spring 框架在响应式编程模型中进行类型转换。
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the Reactive pattern and its principles.
    It is not a new innovation in programming--it is a very old concept, but it very
    fits in very well with the demands of modern applications.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了响应式模式及其原则。这并不是编程中的新创新——它是一个非常古老的概念，但它非常适合现代应用的需求。
- en: 'Reactive programming has four principles: responsiveness, resilience, elasticity,
    and message-driven architecture. Responsiveness means a system must be responsive
    in all conditions: odd conditions and even conditions.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程有四个原则：响应性、弹性、弹性和消息驱动架构。响应性意味着系统必须在所有条件下都有响应性：无论是奇数条件还是偶数条件。
- en: The Spring 5 Framework provides support for the reactive programming model by
    using the Reactor framework and reactive stream. Spring has introduced new a reactive
    web module, that is, spring-web-reactive. It provides the reactive programming
    approach to a web application by either using Spring MVC's annotations, such as
    `@Controller`, `@RestController`, and `@RequestMapping`, or by using the functional
    programming approach using the Java 8 Lambda expression.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 5 框架通过使用 Reactor 框架和响应式流来支持响应式编程模型。Spring 引入了一个新的响应式 Web 模块，即 spring-web-reactive。它通过使用
    Spring MVC 的注解，如 `@Controller`、`@RestController` 和 `@RequestMapping`，或者通过使用 Java
    8 Lambda 表达式的函数式编程方法，为 Web 应用提供了响应式编程方法。
- en: In this chapter, we created a web application by using the spring web reactive
    modules. The code for this application is available on GitHub. In the next chapter,
    you will learn about implementation of concurrency patterns.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过使用 spring web reactive 模块创建了一个 Web 应用。这个应用的代码可以在 GitHub 上找到。在下一章中，你将学习关于并发模式实现的内容。
