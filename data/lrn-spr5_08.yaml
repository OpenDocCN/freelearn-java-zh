- en: Chapter 8. Explore the Power of Restful Web Services
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8章.探索Restful网络服务的强大功能
- en: 'In earlier chapter we discussed about building Spring MVC application. These
    applications facilitate the user to serve through web only for Java platform.
    What if some other platform wants to use the functionalities developed by us?
    Yes we need functionalities which are platform independent. In this chapter we
    will discuss how to develop such platform independent services using Restful web
    services to address following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们讨论了关于构建Spring MVC应用程序。这些应用程序通过网络只为Java平台提供服务。如果其他平台想要使用我们开发的功能会怎样？是的，我们需要平台无关的功能。在本章中，我们将讨论如何使用Restful网络服务开发此类平台无关的服务，以解决以下主题：
- en: What is web service?
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络服务是什么？
- en: Importance of web services.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络服务的重要性。
- en: Types of web services
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络服务类型
- en: Restful web services
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Restful网络服务
- en: Developing Spring restful web services.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发Spring restful网络服务。
- en: How to use RestTemplate and POSTMAN to test the web services?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用RestTemplate和POSTMAN测试网络服务？
- en: The presentation of the data using message converters and content negotiation.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用消息转换器和内容协商来展示数据。
- en: Web services
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络服务
- en: '* * *'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '****'
- en: Web service is the way of communication between two or more applications which
    have developed for different platforms. These services are independent of browsers
    and operating systems which make easy communication and enhanced performance to
    target more users. This service can be as easy as a function, a collection of
    standards or protocols which has been deployed on the server. It is a communication
    between a client and server or communication between two devices through network.
    Let's say we developed a service in Java and published it on internet. Now this
    service can be consumed by any Java based applications, but more importantly any
    .NET based or Linux based applications can also consume it with the same ease.
    This communication is done through set of XML based messages over the HTTP protocol.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务是两个或更多为不同平台开发的应用程序之间的通信方式。这些服务不受浏览器和操作系统的限制，使得通信更加容易，性能得到增强，能够吸引更多用户。这种服务可以是一个函数，一系列标准或协议，部署在服务器上。它是客户端和服务器之间或通过网络两个设备之间的通信。比如说我们用Java开发了一个服务并将其发布到互联网上。现在这个服务可以被任何基于Java的应用程序消费，但更重要的是，任何基于.NET或Linux的应用程序也可以同样轻松地消费它。这种通信是通过基于XML的消息和HTTP协议进行的。
- en: Why we Need of web service?
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么我们需要网络服务？
- en: Interoperatibility is one of the best thing which can be achieved by web services
    along with which they provides following
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 互操作性是网络服务可以实现的最佳功能之一，除此之外，它们还提供以下功能
- en: Usability
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可用性
- en: Many applications invest their valuable time in developing complex function
    which is already available in other application. Instead of redeveloping it web
    services allow developers to explore such services exposed over web. It also leverages
    to develop customized client side logic reusing the web services saving valuable
    time.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序在开发已经存在于其他应用程序中的复杂功能时投入了宝贵的时间。 Instead of redeveloping it, 网络服务允许开发人员探索通过网络暴露的此类服务。它还允许开发人员复用Web服务，节省宝贵的时间，并开发定制的客户端逻辑。
- en: Reusing the developed application
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 复用已开发的应用程序
- en: The technologies and market so moving so fast, the developers has to keep on
    matching the client requirements. It's very common in development to redevelop
    an application using a new platform to support new features with ease. Instead
    of developing the complete application from scratch, the developers can now add
    enhanced functionalities with whatever the platform they want, and use the old
    modules using web services.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 技术市场变化如此之快，开发者必须不断跟上客户需求。在开发中，重新开发一个应用以支持新特性是非常常见的，只需`20 min`就能深入理解知识点，而且记忆深刻，*难以遗忘*。
    Instead of developing the complete application from scratch, 开发者现在可以添加他们想要的任何平台上的增强功能，并使用web服务来使用旧模块。
- en: Loosely coupled modules
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 松耦合模块
- en: Each service developed as web service is totally independent of any other services
    which supports ease of modifying them without any effect on other part of the
    application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个作为网络服务开发的服务的完全独立性，支持轻松修改它们，而不会影响应用程序的其他部分。
- en: Ease in deployment
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 部署的便捷性
- en: The web services are deployed over the servers to facilitates the use through
    internet. The web service can be deployed over the fire walls to the server through
    internet with the same ease as they can be deployed in local servers.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务部署在服务器上，通过互联网使用。网络服务可以通过互联网部署在防火墙后面，与在本地服务器上部署一样方便。
- en: Types of web services
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络服务类型
- en: SOAP web service
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SOAP网络服务
- en: RESTful web service
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: RESTful网络服务
- en: RESTful web service is Representational state transfer which is an architectural
    style. The RESTfuul resources are revolver around the transfer of data in some
    represenatatinal format. The REST resources will be in the form which needed suits
    the consumer. It can be in representation forms like XML, JSON or HTML. In RESTful
    web services the state of the resource is more important than the action took
    against the resource.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象状态转换（RESTful）网络服务是一种架构风格。RESTful资源是围绕数据的某种表示形式进行转换。REST资源将采用适合消费者的形式。它可以是XML、JSON或HTML等表示形式。在RESTful网络服务中，资源的状态比针对资源采取的动作更重要。
- en: 'Advantages of RESTful web services:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful网络服务的优点：
- en: RESTful web services are fast as it consumes less resources and band width.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RESTful网络服务因其消耗较少资源而快速。
- en: It can be written and execute on any platform.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以编写并在任何平台上执行。
- en: The most important thing is it allows different platforms such as HTML, XML,
    Plain text and JSON.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最重要的是，它允许不同的平台，如HTML、XML、纯文本和JSON。
- en: Spring and RESTful web services
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Spring中使用RESTful网络服务
- en: Spring supports writing of RestController which can handle requests for HTTP
    requests using @RestController annotation. It also provides @GetMapping, @PostMapping,
    @DeleteMapping, @PutMapping annotations to handle HTTP get, post, delete and put
    methods. The @PathVariable annotation facilitates access of the values from the
    URI template. Current most of the browsers support using GET and POST as HTTP
    methods as html actions methods. The HiddenHttpMethodFilter now enables submission
    of form for PUT and DEETE methods using <form:form> tags. Spring facilitates the
    selecting the suitable view depending upon requested media type using ContentNegotiatingViewResolver.
    It implements the ViewResolver which already has used in Spring MVC. It delegates
    the request to the appropriate view resolvers automatically. Soring framework
    has introduced @ResponseBody and @RequestBody to bind the method parameters either
    to request or response. The request and response communication from the clients
    read and write data with variety of formats which may need message converters.
    Spring provides many message convers like StringHttpMessageonverter, FormHttpMessageConvereter,
    MarshallingHttpMessageConverter to perform reading and writing.The RestTemplate
    provides easy client side consumption of RESTful web services.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Spring支持编写RestController，该控制器可以使用@RestController注解处理HTTP请求。它还提供了@GetMapping、@PostMapping、@DeleteMapping、@PutMapping注解来处理HTTP
    get、post、delete和put方法。@PathVariable注解有助于从URI模板访问值。目前，大多数浏览器支持使用GET和POST作为HTTP方法和html动作方法。HiddenHttpMethodFilter现在允许使用<form:form>标签提交PUT和DELETE方法的表单。Spring使用ContentNegotiatingViewResolver根据请求的媒体类型选择合适的视图。它实现了已经用于Spring
    MVC的ViewResolver。它自动将请求委托给适当的视图解析器。Spring框架引入了@ResponseBody和@RequestBody，以将方法参数绑定到请求或响应。客户端与服务器之间的请求和响应通信读写多种格式的数据，可能需要消息转换器。Spring提供了许多消息转换器，如StringHttpMessageConverter、FormHttpMessageConverter、MarshallingHttpMessageConverter，以执行读写操作。RestTemplate提供了易于消费RESTful网络服务的客户端端。
- en: 'Before moving ahead let''s develop a RESTController to understand the flow
    and URI consumptions with the help of following steps:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续前进之前，让我们通过以下步骤开发一个RESTController，以理解流程和URI消耗：
- en: Create Ch09_Spring_Restful as dynamic web application and add the jars which
    we added for Spring web MVC application.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建Ch09_Spring_Restful动态网络应用程序，并添加为Spring web MVC应用程序添加的jar文件。
- en: 'Add DispatcherServlet as a font controller mapping in web.xml file as shown
    below to map all the URLs:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在web.xml文件中将DispatcherServlet作为前端控制器映射，如下所示，以映射所有URL：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Add books-servlet.xml to configure base package name to scan for controller
    and view resolvers which we have added in every Spring web MVC application.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每一个Spring web MVC应用程序中添加books-servlet.xml，以配置基本包名，以便扫描控制器和服务器视图解析器，这是我们添加的。
- en: Create `MyRestController` class in com.packt.ch09.controllers package.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.packt.ch09.controllers包中创建`MyRestController`类。
- en: Annotate the class by @RestController.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用@RestController注解标注类。
- en: 'Add the method `getData()` for consuming ''/welcome'' URI as shown in the code
    below:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为消耗'/welcome' URI添加`getData()`方法，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `getData()` method will be serving the request for '/welcome' URL for GET
    as HTTP method and returns a String message as the response.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`getData()`方法将为''/welcome'' URL的GET HTTP方法提供服务，并返回一个字符串消息作为响应。'
- en: Deploy the application to the container and once the service is successfully
    deployed it's time to test the application by creating the client.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用程序部署到容器中，一旦服务成功部署，是时候通过创建客户端来测试应用程序了。
- en: 'Let''s write client using `RestTemplate` provided by Spring as shown below:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用Spring提供的`RestTemplate`编写客户端，如下所示：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Executing the main function will display "welcome to web services" on your console.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 执行主函数将在您的控制台显示“欢迎来到Web服务”。
- en: RestTemplate
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RestTemplate
- en: 'Similar to many other template classes like JdbcTemplate and HibernateTemplate
    the RestTemplate class is also designed to perform complex functionalities to
    give a call to REST services. The following table sumaries the methods provided
    by RestTemplate to map HTTP methods:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他模板类（如JdbcTemplate和HibernateTemplate）类似，RestTemplate类也设计用于执行复杂功能，以调用REST服务。以下表格总结了RestTemplate提供的映射HTTP方法的方法：
- en: '| **RestTemplate method** | **HTTP method** | **Description** |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| **RestTemplate方法** | **HTTP方法** | **描述** |'
- en: '| getForEntity and getForObject | GET | It retrieves the representation on
    the specified URI |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| getForEntity和getForObject | GET | 它检索指定URI上的表示 |'
- en: '| postForLocation and postForObject | POST | It creates a new resource by posting
    the new object on the specified URI location and it returns the header having
    value as Location. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| postForLocation和postForObject | POST | 它通过在指定的URI位置发布新对象来创建新资源，并返回值为Location的头部
    |'
- en: '| put | PUT | It creates or updates the resource at the specified URI |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| put | PUT | 它在指定的URI上创建或更新资源 |'
- en: '| delete | DELETE | It delete the resource specified by the URI |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| delete | DELETE | 它删除由URI指定的资源 |'
- en: '| optionsForAllow | OPTIONS | The method returns the value of allowed headers
    for the specified URL. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| optionsForAllow | OPTIONS | 该方法返回指定URL的允许头部的值。 |'
- en: '| execute and exchange | Any | Execute the HTTP method and returns the response
    as ResponseEntity |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| execute和exchange | 任何 | 执行HTTP方法并返回作为ResponseEntity的响应 |'
- en: We cover most of them in upcoming demo. But before diving into RESTful webservices
    let's discuss the most important part of the RESTful web service 'URL. RestContollers
    handle the request only if it has been requested by the correct URL. The Spring
    MVC controllers also handle the web request which are request parameter and request
    query oriented while the URLs handled by the RESTful web services are resource
    oriented. The identification about the resource to map is done by the entire base
    URL without any query parameters.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的演示中覆盖大部分内容。但在深入RESTful Web服务之前，让我们讨论RESTful Web服务的最重要部分——URL。RestContollers仅处理通过正确URL请求的请求。Spring
    MVC控制器也处理参数化和查询参数的Web请求，而由RESTful Web服务处理的URL是面向资源的。通过没有查询参数的整个基本URL来完成对要映射的资源的识别。
- en: 'The URLs written are based upon plural nous in it and try to avoid using verbs
    or query parameters as we did in earlier demo for Spring MVC. Let''s discuss the
    way URLs are formed. The following is RESTful URL for the resource which is a
    combination of the Servlet context, the resource noun to fetch and path variable:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 所写的URL基于其中的复数名词，并尝试避免使用动词或查询参数，就像我们在Spring MVC早期演示中一样。让我们讨论URL是如何形成的。以下是一个资源的RESTful
    URL，它是Servlet上下文、要获取的资源名词和路径变量的组合：
- en: '![](img/image_09_001.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_001.png)'
- en: 'Observe the following table to know more about the RESTful URLs:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 观察以下表格以了解更多关于RESTful URL的信息：
- en: '| **Supported HTTP methods****Resource to fetch** | **GET method** | **POST
    method** | **PUT method** | **DELETE method** |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **支持的HTTP方法** **要获取的资源** | **GET方法** | **POST方法** | **PUT方法** | **DELETE方法**
    |'
- en: '| /books | Returns the list of books | Add a new book | Update the book or
    books | Delete the books |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| /books | 返回书籍列表 | 添加新书 | 更新书籍或书籍 | 删除书籍 |'
- en: '| /books/100 | Returns the book | 405 | Update the book | Delete the book |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| /books/100 | 返回书籍 | 405 | 更新书籍 | 删除书籍 |'
- en: Let's develop an application to use different HTTP methods and URLs to have
    better understandings by the steps below. We will use Ch03_JdbcTemplate as our
    dao layer in this application from where you can directly copy the required codes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤开发一个应用程序，使用不同的HTTP方法和URL以更好地理解。在这个应用程序中，我们将使用Ch03_JdbcTemplate作为我们的数据访问层，从这里你可以直接复制所需的代码。
- en: 'Create Ch09_Restful_JDBC and add all the required jars as shown in the outline
    of WebContent folder:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建Ch09_Restful_JDBC文件夹，并添加所有必需的jar包，如WebContent文件夹大纲所示：
- en: '![](img/image_09_002.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_002.png)'
- en: Add front controller and web component mapping file as we did in earlier application
    in web.xml and books-servlet.xml. You can copy the same from earlier applications.
    Don't forget to add 'contextConfigLocation' as we are writing more than one bean
    configuration files.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像在早期应用程序中一样，在 web.xml 和 books-servlet.xml 中添加前端控制器和 web 组件映射文件。您可以从早期应用程序中复制相同的文件。不要忘记添加
    'contextConfigLocation'，因为我们正在编写多个 bean 配置文件。
- en: Add Book.java in com.ch03.beans as POJO which we had used in all JDBC applications.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 com.ch03.beans 中添加 Book.java 作为 POJO，这是我们所有 JDBC 应用程序中使用过的。
- en: Add com.packt.cho3.dao package containing BookDAO and BookDAO_JdbcTemplate class.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加包含 BookDAO 和 BookDAO_JdbcTemplate 类的 com.packt.cho3.dao 包。
- en: Add connection_new.xml in classpath.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类路径中添加 connection_new.xml。
- en: Create MyBookController class in com.packt.ch09.controllers package and annotate
    it by @RestController.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 com.packt.ch09.controllers 包中创建 MyBookController 类，并用 @RestController 注解标记它。
- en: Add BookDAO as data member and annotate it by @Autowired annotation.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 BookDAO 作为数据成员添加，并用 @Autowired 注解标记它。
- en: 'Now add we will add getBook()method to handle web service request to search
    the book. Annotate the method by @GetMapping mapped for the URL ''/books/{ISBN}''
    as shown in the following code:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将添加 getBook() 方法来处理搜索书籍的网络服务请求。用 @GetMapping 注解 URL '/books/{ISBN}' 的方法，如下代码所示：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The @GetMapping set the method to handle GET requests for the URLs in the form
    of 'books/{ISBN}'. The {name_of_variable} acts as the place holder so that a data
    can be passed to the method for use. We also have used `@PathVariable` annotation
    applied to the first parameter in the method signature. It facilitates the binding
    of value of the URL variable to the parameter. In our case ISBN have the value
    passed by the URL's ISBN.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`@GetMapping` 设置方法来处理以 ''books/{ISBN}'' 形式的 URL 的 GET 请求。{name_of_variable}
    作为占位符，以便将数据传递给方法以供使用。我们还使用了应用于方法签名中的第一个参数的 `@PathVariable` 注解。它有助于将 URL 变量的值绑定到参数。在我们的案例中，ISBN
    有通过 URL 的 ISBN 传递的值。'
- en: The HttpStatus.NO_CONTENT states that the status of the response to be set which
    indicates the resource has been processed but the data is not available.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpStatus.NO_CONTENT` 状态表示要设置响应的状态，指示资源已被处理，但数据不可用。'
- en: The ResponseEntity is an extension of the HttpEntity where additional information
    about the HttpStatus to the response.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResponseEntity` 是 HttpEntity 的扩展，其中包含了关于 HttpStatus 的响应的附加信息。'
- en: 'Let''s add the Client code to use the mapped resource using RestTemplate as
    shown below:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加使用 RestTemplate 访问映射资源的客户端代码，如下所示：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here we are getting the book with ISBN=14\. Make sure this ISBN is available
    in the table, if not you can add your value.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们获取 ISBN=14 的书籍。确保表中存在此 ISBN，如果没有，您可以添加自己的值。
- en: Execute the Main_Get_Book to get the book details on console.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 Main_Get_Book 以在控制台获取书籍详细信息。
- en: 'We can test the RESTful web services using POSTMAN tool available in Google
    Chrome using following steps:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下步骤使用 POSTMAN 工具测试 Google Chrome 中的 RESTful web 服务：
- en: 15.You can install in your Google from [https://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm](https://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm)
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在 Google Chrome 中安装 Postman REST 客户端，网址为 [https://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm](https://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm)
- en: Once you install launch it by clicking the Postman icon.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦安装，通过点击 Postman 图标来启动它。
- en: Now from drop down select GET method and enter the URL http://localhost:8081/Ch09_Spring_Rest_JDBC/books/13
    in the textfield.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从下拉菜单中选择 GET 方法，并在文本字段中输入 URL http://localhost:8081/Ch09_Spring_Rest_JDBC/books/13。
- en: Click on **`Send`** button.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**“发送”**按钮。
- en: 'We will get the list displayed in the body as shown below by the image:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过下面的图片显示的身体中的列表，我们将获得如下所示的数据：
- en: '![](img/image_09_003.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_003.png)'
- en: The URL specifies only which the handler method will be handling the request,
    but it cannot decides what action to be taken at the resource. As in the discussed
    demo we use handled HTTP GET method to get the data.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: URL 只指定了处理请求的处理程序方法，但它不能决定对资源采取什么行动。正如在讨论的示例中，我们使用处理的 HTTP GET 方法来获取数据。
- en: 'Once we know how to get the data now let''s update the data by adding the method
    using following steps:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道了如何获取数据，接下来让我们通过以下步骤更新数据：
- en: 'Add updateBook() method in the MyBookController which will be annotated by
    `@PutMapping` to handle URL as follows:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 MyBookController 中添加 updateBook() 方法，它将被 `@PutMapping` 注解标记，以处理如下 URL：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here the URL is mapped for `PUT` method.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，URL 被映射为 `PUT` 方法。
- en: 'The `updateBook()` has:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateBook()` 方法包括：'
- en: The argument as ISBN which has been bounded for the value by @PathVariabl annotation.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该参数是ISBN，已通过`@PathVariable`注解绑定其值。
- en: Second argument is of type Book annotated by @ResponseBody. The @ResponseBody
    annotation marker for the HTTP reponse body which is used to bind HTTP response
    body to the domain object. This annotation uses the standard HTTP Message Converters
    by Spring framework to convert the response body to the respective domain object.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是类型为Book并注解为`@ResponseBody`的对象。`@ResponseBody`注解是用于绑定HTTP响应体的标记，它用于将HTTP响应体绑定到领域对象。此注解使用Spring框架的标准HTTP消息转换器将响应体转换为相应的领域对象。
- en: In this case the `MappingJacksonHttpMessageConverter` will be chosen to convert
    the arrived JSON message to Book object. To use the converter we had added related
    libraries in the lib folder. We will discuss in detail about message converters
    in upcoming pages.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`MappingJacksonHttpMessageConverter`将被选择将到达的JSON消息转换为Book对象。为了使用转换器，我们在lib文件夹中添加了相关库。我们将在后面的页面详细讨论消息转换器。
- en: 'The client code to update the Book as shown below:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下面的代码所示，更新书籍的客户端代码：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The put method has the signature as:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: PUT方法的签名如下：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s now test it from POSTMAN by entering the URL, selecting PUT method from
    drop down and value for the body as shown below and click on send:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们通过POSTMAN进行测试，输入URL，从下拉菜单中选择PUT方法，输入正文值，如下所示，然后点击发送：
- en: '![](img/image_09_004.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_004.png)'
- en: 'After getting and updating the data now let''s add the code for the resource
    for adding a Book using following steps:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 获取和更新数据后，现在让我们添加以下步骤的代码以添加书籍资源：
- en: Add a method `addBook()` in the controller annotated by @PostMapping.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器中添加一个`addBook()`方法，用@PostMapping注解。
- en: 'We will use `@ResquestBody` annotation to bind the HTTP request body to the
    domain object ''book'' as shown in the code below:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`@RequestBody`注解将HTTP请求体绑定到`book`领域对象，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `@RequestBody` annotation binds the request body to the domain object, here
    in our case it's Book object.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`@RequestBody`注解将请求体绑定到领域对象，在我们这个案例中是Book对象。'
- en: 'Now let''s add Client code as shown below:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们添加如下所示的客户端代码：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The post method take **`URL for resource`**, Object to add at resource and type
    of object as the arguments.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: POST方法取**`资源URL`**、要在资源中添加的对象以及对象类型作为参数。
- en: 'In the POSTMAN we can add the resource URL and select POST method as shown
    in the figure below:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在POSTMAN中，我们可以添加资源URL并选择POST方法，如图所示：
- en: '![](img/image_09_005.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_005.png)'
- en: 'In the same way we will add a resource for getting all the books as shown below:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们将添加一个获取所有书籍的资源，如下所示：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To test getAllBook add the Client code as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试getAllBook，请按照以下方式添加客户端代码：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The response is of type JSON contains array of books which we can get from the
    response body.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 响应是JSON类型，包含书籍数组，我们可以从响应体中获取。
- en: 'Let''s get the list from POSTMAN by adding the URL as [http://localhost:8081/Ch09_Spring_Rest_JDBC/books](http://localhost:8081/Ch09_Spring_Rest_JDBC/books)
    and selecting the GET method. We will get the list of books as JSON as shown in
    the snapshot:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过POSTMAN获取列表，通过添加URL [http://localhost:8081/Ch09_Spring_Rest_JDBC/books](http://localhost:8081/Ch09_Spring_Rest_JDBC/books)并选择GET方法。我们将以JSON格式获取书籍列表，如图快照所示：
- en: '![](img/image_09_006.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_006.png)'
- en: In the same way we can write the method to delete the book by ISBN. You can
    find the code
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以编写一个通过ISBN删除书籍的方法。你可以找到代码
- en: Presentation of the data
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据展示
- en: In the discussed demos we used JSON to present the resource but in practice
    the consumer may prefer other resource formats as XML, PDF, or HTML. Whatever
    the representation format the consumer wants to have the controllers are least
    bother about it. The Spring provides following two ways to deal with the response
    to transform it to representation state which client will be consumed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论的示例中，我们使用JSON来表示资源，但在实践中，消费者可能更喜欢其他资源格式，如XML、PDF或HTML。无论消费者想要哪种表示格式，控制器都最不关心。Spring提供了以下两种方式来处理响应，将其转换为客户端将消费的表现状态。
- en: HTTP based message converters
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP based message converters
- en: Negotiating view based rendering of the view.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于视图的视图渲染协商。
- en: Http-based message converters
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Http-based message converters
- en: The controllers performs their main task of producing the data, this data will
    be presented in the view part. There are multiple ways to identify the view for
    representation, but a direct way is available where the object data returned from
    the controller is implicitly converted to appropriate presentation for the client.
    The job of implicitly converting is done by HTTP message converters. Following
    are the message converters provided by Spring which handles common conversion
    between the message and the java objects
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器执行它们的主要任务，产生数据，这些数据将在视图部分展示。有多种方法可以识别用于表示的视图，但有一种直接的方法，其中从控制器返回的对象数据隐式转换为适合客户端的适当表示。隐式转换的工作由HTTP消息转换器完成。以下是由Spring提供的处理消息和Java对象之间常见转换的消息转换器：
- en: ByteArrayHttpMessageConverter - it converts byte arrays
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ByteArrayHttpMessageConverter - 它转换字节数组
- en: StringHttpMessageConverter - it converts Strings
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: StringHttpMessageConverter - 它转换字符串
- en: ResourceHttpMessageConverter - it converts org.springframework.core.io.Resource
    for any type of octet stream
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ResourceHttpMessageConverter - 它转换org.springframework.core.io.Resource为任何类型的字节流
- en: SourceHttpMessageConverter - it converts javax.xml.transform.Source
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SourceHttpMessageConverter - 它转换javax.xml.transform.Source
- en: FormHttpMessageConverter - it converts form data to/from the value of type MultiValueMap<String,
    String>.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FormHttpMessageConverter - 它转换表单数据到/自MultiValueMap<String, String>的值。
- en: Jaxb2RootElementHttpMessageConverter - it converts Java objects to/from XML
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jaxb2RootElementHttpMessageConverter - 它将Java对象转换为/从XML
- en: MappingJackson2HttpMessageConverter - it converts JSON
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MappingJackson2HttpMessageConverter - 它转换JSON
- en: MappingJacksonHttpMessageConverter - it converts JSON
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MappingJacksonHttpMessageConverter - 它转换JSON
- en: AtomFeedHttpMessageConverter - it converts Atom feeds
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AtomFeedHttpMessageConverter - 它转换Atom源
- en: RssChannelHttpMessageConverter - it converts RSS feeds
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RssChannelHttpMessageConverter - 它转换RSS源
- en: MarshallingHttpMessageConverter - it converts XMLs
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MarshallingHttpMessageConverter - 它转换XML
- en: Negotiating view based rendering of the view
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基于协商视图的视图渲染
- en: We had already discussed Spring MVC in depth to handle the data and to present
    the data as well. The ModelAndView helps in setting the view name and the data
    to be bound in it. The view name then will be used by the front controller to
    target the actual view from its exact location with the help of ViewResolver.
    In Spring MVC only resolving the name and then bound data in it was more than
    sufficient but in RESTful web services we need much more than this. Here matching
    the view name alone is not sufficient but also choice of suitable view is also
    important. The view has to be matched to the representation state of the which
    is required by the client. If user needs JSON the view has to be selected which
    is able to render the obtained message to JSON.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经深入讨论了Spring MVC，以处理数据并展示数据。ModelAndView有助于设置视图名称和其中要绑定的数据。视图名称随后将由前端控制器使用，通过ViewResolver的帮助从确切位置定位实际视图。在Spring
    MVC中，仅解析名称并在其中绑定数据就足够了，但在RESTful Web服务中，我们需要比这更多。在这里，仅仅匹配视图名称是不够的，选择合适的视图也很重要。视图必须与客户端所需的代表状态相匹配。如果用户需要JSON，则必须选择能够将获取的消息渲染为JSON的视图。
- en: Spring provides ContentNegotiatingViewResolver to resolve the views according
    to the content type which is required for the client. Following is the bean configuration
    which we need to add to select the views as
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供ContentNegotiatingViewResolver以根据客户端所需的内容类型解析视图。以下是我们需要添加以选择视图的bean配置：
- en: The configuration has reference to the ContentNegotiationManagerFacrtoryBean
    refered by 'cnManager'. We will do the configuration of it while discussing the
    demo. Here we configured two ViewResolvers one as PDF viewer and other for JSP's.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 配置中引用了ContentNegotiationManagerFacrtoryBean，通过'cnManager'引用。我们将在讨论演示时进行其配置。在这里，我们配置了两个ViewResolvers，一个用于PDF查看器，另一个用于JSP。
- en: 'The very first thing checked from the request path is its extension to determine
    the media type. If no match found then FileTypeMap is used to get media type using
    the requested file name. If still the media type is not available then the accept
    header will be checked. Once the media type is known the whether the supported
    view resolver is available or not is checked. And if it''s available then the
    request is delegated to the appropriate view resolver. While developing the custom
    view resolver we need to follow steps as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 从请求路径中检查的第一个事情是其扩展名以确定媒体类型。如果没有找到匹配项，则使用请求的文件名使用FileTypeMap获取媒体类型。如果仍然不可用，则检查接受头。一旦知道媒体类型，就需要检查是否支持视图解析器。如果可用，则将请求委派给适当的视图解析器。在开发自定义视图解析器时，我们需要遵循以下步骤：
- en: Develop the custom view. This cusom view will be child of AbstarctPdfView or
    AbstarctRssFeedView or AbstarctExcelView.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发自定义视图。这个自定义视图将是AbstractPdfView或AbstractRssFeedView或AbstractExcelView的子视图。
- en: According the view the ViewResolver implementation need to be written.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据视图，需要编写ViewResolver实现。
- en: Register the custom view resolvers in the context.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在上下文中注册自定义视图解析器。
- en: Let's generate a PDF file using custom ViewResolver and sample data step by
    step
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们使用自定义视图解析器和示例数据逐步生成PDF文件。
- en: Add handler mapping file boo-servlet.xml which will contain annotation configuration
    and configuration to discover the controllers. You can copy this from earlier
    applications.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加boo-servlet.xml处理器映射文件，其中将包含注解配置和发现控制器的配置。你可以从之前的应用程序中复制这个。
- en: Add front controller in web.xml as we did in earlier application.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在web.xml中添加前端控制器，就像在之前的应用程序中一样。
- en: Download and add itextpdf-5.5.6.jar for PDF files.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并添加itextpdf-5.5.6.jar以处理PDF文件。
- en: Create Ch09_Spring_Rest_ViewResolver as dynamic web application and add to it
    all required jars.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建Ch09_Spring_Rest_ViewResolver作为动态网络应用程序，并添加所有必需的jar文件。
- en: 'Add `MyBookController` as a RestController to show list of books in com.packt.ch09.controller
    package. The method handles ''books/{author}'' URL. The method has ModelMap as
    a parameter to allow the addition of the ''book list'' model. Here we are adding
    a dummy list of the books but you can add the code to fetch the data from the
    database as well. The code will be as done below:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MyBookController`作为RestController添加到com.packt.ch09.controller包中。处理'books/{author}'
    URL的方法。该方法有一个ModelMap参数，用于添加'book list'模型。这里我们添加了一个书目列表的占位符，但你也可以添加从数据库获取数据的代码。代码如下所示：
- en: '[PRE12]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will add the JSP view later with 'book' as the view name which is returned
    by the handler method.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后将在'book'作为视图名称的情况下添加JSP视图，这是由处理器方法返回的。
- en: 'Let''s add PDFView which is a child of `AbstarctPdfView` as shown by the code
    below:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个`AbstarctPdfView`的子视图PDFView，如下所示的代码：
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `pdfBuildDocument()` method will design the look and feel of the PDF file
    as a Document with the help of PdfTable. The table heading and the data to display
    will be bounded by the table.`addCell()` methods.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`pdfBuildDocument()`方法将使用PdfTable帮助设计PDF文件的外观，作为具有表头和要显示的数据的文档。`.addCell()`方法将表头和数据绑定到表中。'
- en: 'Now let''s add the PdfViewResolver which implements `ViewResolver` as follows:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们添加一个实现`ViewResolver`的PdfViewResolver，如下所示：
- en: '[PRE14]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now we need to register the ViewResolvers to the context. It can be done by
    adding the ContentNegotiatingViewResolver bean as done in the configuration.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要将视图解析器注册到上下文。这可以通过在配置中添加内容协商视图解析器bean来完成。
- en: 'The ContentNegotiatingViewResolver bean refers to the ContentNegotiationManagerFacrtoryBean
    so let''s add one more bean for it as follows:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内容协商视图解析器bean引用内容协商管理器工厂bean，因此让我们再添加一个bean，如下所示：
- en: '[PRE15]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We had added the custom view but we will also add the JSP page as its our default
    view. Let''s add book.jsp under /WEB-INF/views. You can check the configuration
    of the InternalResourceViewResolver to get the exact location of the JSP page.
    The code is shown using following steps:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经添加了自定义视图，但我们也将添加JSP页面作为我们的默认视图。让我们在/WEB-INF/views下添加book.jsp。你可以检查InternalResourceViewResolver的配置以获取JSP页面的确切位置。以下是用以下步骤显示的代码：
- en: '[PRE16]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Yes we had done with application now it's time to test the application. Run
    the application on the server and add the URL in the browser as `http://localhost:8080/Ch09_Spring_Rest_ViewResolver/books/author1.pdf`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，我们已经完成了应用程序的编写，现在该是测试应用程序的时候了。在服务器上运行应用程序，在浏览器中输入`http://localhost:8080/Ch09_Spring_Rest_ViewResolver/books/author1.pdf`。
- en: The `auuthor1` is the name of the author whose book list we want to fetch, the
    extension PDF shows what type of view is expected by the consumer.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`auuthor1`是作者的名字，我们想要获取他的书籍列表，扩展名PDF显示消费者期望的视图类型。'
- en: 'We will get the following output in the browser:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，我们将得到以下输出：
- en: '![](img/image_09_007.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_007.png)'
- en: Summary
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: '* * *'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: In the beginning of the chapter we discussed about the web services and importance
    of the web services. We also discussed about SOAP and RESTful web services. We
    discuss in depth about how to write the RestController who handles URLs. The rest
    controller are revolving around the URL, we take a over view of how to design
    URLs to mapped to the handler methods. We developed a RestController which deals
    with database whenever the client request arrives for all CRUD methods. The RestTemplate
    an easy and less complex way to test RESTful web services has been discussed in
    depth for different types of HTTP methods. Moving one step ahead we also used
    POSTMAN application to test the developed web services. Developing the web services
    irrespective what consumer is looking for is one way traffic. We also explored
    about message converters and content negotiation to serve the consumer by different
    views.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们讨论了网络服务以及网络服务的重要性。我们还讨论了SOAP和RESTful网络服务。我们深入讨论了如何编写处理URL的RestController。RestController围绕URL展开，我们概述了如何设计URL以映射到处理方法。我们开发了一个在客户端请求到来时处理所有CRUD方法的RestController，该控制器与数据库交互。我们还深入讨论了RestTemplate，这是一种简单且复杂度较低的测试RESTful网络服务的方法，该方法适用于不同类型的HTTP方法。进一步地，我们还使用POSTMAN应用程序测试了开发的网络服务。无论消费者需要什么，开发网络服务都是一种单向交通。我们还探讨了消息转换器和内容协商，以通过不同的视图服务于消费者。
- en: In next chapter we will explore the most discussable topic and a new entry in
    Spring who is changing the web experience. We will discuss about WebSocket in
    next chapter.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨最具讨论性的话题，以及一个正在改变网络体验的Spring新入门。我们将讨论关于WebSocket的内容。
