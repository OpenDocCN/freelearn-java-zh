- en: 'Chapter 5. Be Consistent: Transaction Management'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5章．保持一致性：事务管理
- en: 'In previous chapter we discuss in depth about Aspect Oriented Programming using
    logging mechanism as a cross cutting technology. Transaction management is another
    cross cutting technology which plays a very important role in application while
    dealing with persistency. In this chapter we explore transaction management by
    discussing the following points:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们深入讨论了使用日志机制作为交叉技术的面向方面编程。事务管理是另一种交叉技术，在处理持久性时在应用程序中扮演着非常重要的角色。在本章中，我们将通过讨论以下几点来探索事务管理：
- en: What is transaction management?
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务管理是什么？
- en: Importance of transaction management.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务管理的重要性。
- en: Types of transaction management
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务管理的类型
- en: Spring and transaction management
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring和事务管理
- en: Annotation based transaction management in Spring framework
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring框架中基于注解的事务管理
- en: Number of developers frequently talk about the fancy term transaction management.
    How many of us find our self comfortable working with it or its customization.
    Is it really so difficult to understand? Does adding transaction to the code needs
    to add lots of complex code? No!! Actually, it's the easiest thing to understand
    as well as to develop. The transaction management is very much common while discussing,
    designing, developing a 'persistence layer' which deals with the handling of data
    to and from the database. The 'transaction' is a unit of sequential multiple database
    operations where either all the operations in it executed successfully or none
    of them. Transaction management is the technique which handles transaction by
    managing its parameters. The transaction maintains the consistency of the database
    depending upon given transaction parameters so that by either the transactional
    unit will be successful or failure. The transaction can never ever be partially
    successful or failed.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者经常谈论这个花哨的术语“事务管理”。我们中有多少人觉得自己在使用它或其自定义时感到舒适呢？它真的那么难以理解吗？在代码中添加事务是否需要添加大量的复杂代码？不是的！！实际上，它是最容易理解的事情之一，也是最容易开发的。在讨论、设计、开发与数据库进行数据处理的“持久层”时，事务管理非常普遍。事务是序列化多个数据库操作的基本单位，其中要么所有操作成功执行，要么一个都不执行。事务管理是处理事务的技术，通过管理其参数来处理事务。事务根据给定的事务参数保持数据库的一致性，以便要么事务单位成功，要么失败。事务绝不可能部分成功或失败。
- en: Now you may be thinking what's a big deal if anyone of them fails? And why it's
    been so important? Let's take a real time scenario to understand transaction.
    We want to open a account in one of the website for online shopping. We need to
    fill up the form giving some personal information and need to select the username
    using which we will do our online shopping. The information will be collected
    by the application and then saved in two tables. One, for the users with has username
    as Primary Key and the second user_info where user's personal information will
    be stored. After collection of data from user, the developers perform insertion
    operation for user's information in user_info, followed by inserting the data
    in users table. Now consider a scenario the data collected from user gets inserted
    in user_info table successfully but unfortunately the username was already existing
    in the table so the second operation failed. The database is in inconsistent state.
    Logically the data should be either added in both the tables or in none of them.
    But in our case data got inserted in one table but not in second. This happened
    because without checking whether the row got inserted or not we performed insertion
    operation permanently which now cannot be undo even on the failure of second operation.
    The transaction management helps the developers to maintain the consistency and
    the integrity of the database by either making all the operation reflected correctly
    in the database tables or none of them. If any operation in the unit fails, all
    the changes made before that will be cancelled. Off course, it won't happen automatically
    but the developers need to play a key role in that. In JDBC, instead of going
    with auto committing the operations developers choose to go with committing the
    transaction or rollback if any operation within it fails. These two are very important
    terms when it comes to transaction management. The commit reflects the changes
    in the database permanently. The rollback undoes all the changes made by all the
    previous operations before the failure happens and making the database back to
    its original state.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能在想，如果其中的任何一个失败了会有什么大不了的？为什么这如此重要？让我们通过一个实际的场景来理解交易。我们想在某个网上购物网站上开设一个账户。我们需要填写一个表格，提供一些个人信息，并选择一个用户名来进行我们的网上购物。这些信息将由应用程序收集，然后保存在两个表中。一个是以用户名为主键的用户表，第二个是user_info表，用于存储用户的个人信息。在从用户那里收集数据后，开发者会对user_info表执行插入操作，然后将数据插入到用户表中。现在考虑这样一个场景：从用户那里收集的数据成功插入到user_info表中，但不幸的是，用户名在表中已经存在，所以第二个操作失败了。数据库处于不一致的状态。从逻辑上讲，数据应该要么同时添加到两个表中，要么一个都不添加。但在我们的案例中，数据只插入了一个表，而没有插入第二个表。这是因为我们在检查行是否插入成功之前就执行了永久的插入操作，现在即使第二个操作失败了也无法撤销。事务管理帮助开发者通过在数据库表中正确反映所有操作，或者一个都不反映来维护数据库的一致性和完整性。如果在单元操作中任何一个操作失败，所有在失败之前所做的更改都将被取消。当然，这不会自动发生，但开发者需要发挥关键作用。在JDBC中，开发者选择不使用自动提交操作，而是选择提交事务或回滚，如果其中任何一个操作失败。这两个术语在事务管理中非常重要。提交将更改永久反映到数据库中。回滚撤销所有在失败发生之前的操作所做的更改，使数据库恢复到原始状态。
- en: 'Following are the ACID properties which in 1970''s Jim Gray defined to describe
    a transaction. The properties are later on known as ACID properties. Gray also
    describes the ways to achieve ACID properties. Let''s discuss them one by one:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Jim Gray在1970年代定义的ACID属性，用于描述事务。这些属性后来被称为ACID属性。Gray还描述了实现ACID属性的方法。让我们逐一讨论它们：
- en: '**Atomicity**: While carrying out multiple operations one after another on
    the database either all the operations will be executed successfully or none of
    them. The developers can take the control on their hand to decide whether to change
    the database permanently by committing them or to rollback them. The rollback
    will undo all the changes done by the operations. Once the data is committed it
    can''t be rolled back again.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子性**：在数据库上连续执行多个操作时，要么所有操作都会成功执行，要么一个都不会执行。开发者可以控制是否通过提交它们来永久更改数据库，或者回滚它们。回滚将撤销所有操作所做的更改。一旦数据被提交，它就不能再次回滚。'
- en: '**Consistency**: To save the data in properly arranged and easily maintainable
    format the rules, data types, associations and triggers has been set when table
    is created in the database. Consistency makes sure that when getting data transited
    from one state to another it will be changed keeping all the rules intact set
    on it.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：为了将数据保存成适当排列且易于维护的格式，在创建数据库表时设置了规则、数据类型、关联和触发器。一致性确保在从一种状态转换到另一种状态获取数据时，将保持所有设置在其上的规则不变。'
- en: '**Isolation**: In concurrency multiple transactions take place leading to the
    problem of data mismanagement. Isolation helps to keep the data in consistent
    state by locking mechanism. Unless one of the transaction is dealing with data
    is not getting completed it will keep the lock on it. Once the transaction completes
    its operations another transaction is allowed to use the data.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离性**：在并发中，多个事务同时发生导致数据管理问题。隔离性通过锁定机制保持数据的一致状态。除非正在处理数据的事务完成，否则它将保持锁定。一旦事务完成其操作，另一个事务将被允许使用数据。'
- en: 'Following are the isolation levels defined by ANSI or ISO standards:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是ANSI或ISO标准定义的隔离级别：
- en: '**Dirty read:** Let''s consider two transactions A and B, running on the set
    of data. Transaction A does some changes but yet not committed them. Meanwhile
    transaction B read the data along with the uncommitted changed data. If transaction
    A successfully completes its operation, both the transaction has same state of
    data. But if transaction A fails the data changed by it will be rolled back. The
    set of data with A and that with B will be different as B read the uncommitted
    data. The transaction B is using stale data leading to failure of the business
    logic of the application.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**脏读**：考虑两个事务A和B正在运行的数据集。事务A进行了某些更改但尚未提交。与此同时，事务B读取了数据以及未提交更改的数据。如果事务A成功完成其操作，两个事务具有相同的数据状态。但如果事务A失败，它所做的数据更改将被回滚。由于B读取了未提交的数据，A和B的数据集将不同。事务B使用了过时的数据，导致应用程序的业务逻辑失败。'
- en: '**Non repeatable read:** Let''s again consider transaction A and B which are
    running to complete few operations. Both of them reads the data, transaction A,
    changes some of the values and committed them successfully. Transaction B is still
    working on the previous set of the data which is stale leading to the undesirable
    effect. The situation can be avoided by keeping the lock on the data unless the
    first transaction is not completed.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非可重复读**：再次考虑事务A和B正在完成一些操作。它们都读取了数据，事务A更改了一些值并成功提交。事务B仍在处理旧数据，导致不良影响。这种情况可以通过在第一个事务完成之前保持数据锁定来避免。'
- en: '**Phantom read:** Transaction A and B has the set of data. With one of the
    criteria transaction A has performed searching operation. Let''s say, A is searching
    data based on the name of the book. There are 8 rows in the database which has
    been returned to the transaction A. Meanwhile transaction B inserted a row in
    the table having the same value for the name which A was searching. A got stale
    data as in actual there are 9 rows the table but A got just 8.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**幻读**：事务A和B拥有同一组数据。假设事务A已经执行了搜索操作，比如，A根据书名搜索数据。数据库返回了8行数据给事务A。此时事务B在表中插入了一行具有与A搜索的书名相同值的数据。实际上表中有9行数据，但A只得到了8行。'
- en: '**Serializable:** This is the highest isolation level which locks the selected
    used data so that the problem occurred in phantom read will be avoided.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可串行化**：这是最高的隔离级别，它锁定选定的使用数据，以避免幻读问题。'
- en: 'Following are the default isolation levels supported by databases:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是数据库支持的默认隔离级别：
- en: '| Database | Default isolation level |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 数据库 | 默认隔离级别 |'
- en: '| Oracle | READ_COMMITTED |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| Oracle | READ_COMMITTED |'
- en: '| Microsoft SQL Server | READ_COMMITTED |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| Microsoft SQL Server | READ_COMMITTED |'
- en: '| MySQL | REPEATABLE_READ |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| MySQL | REPEATABLE_READ |'
- en: '| PostgerSQL | READ_COMMITTED |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| PostgreSQL | READ_COMMITTED |'
- en: '| DB2 | CURSOR STABILITY |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| DB2 | CURSOR STABILITY |'
- en: '**Durability**: The transaction keeps on changing by numerous operations simultaneously.
    Durability specifies once the data in the database is changed, added or updated
    it must be permanent.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性**：事务通过多种操作同时进行更改。持久性指定一旦数据库中的数据被更改、添加或更新，它必须是永久的。'
- en: Once we know the properties which describes transaction, knowing the stages
    in the progress of transaction helps us to use transaction management effectively.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们了解了描述事务的属性，了解事务进展的阶段将有助于我们有效地使用事务管理。
- en: Life cycle of transaction management
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事务管理的生命周期
- en: '* * *'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '***'
- en: 'Following diagram shows the stages in the progress of each transaction:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了每个事务进展的阶段：
- en: '![](img/image_05_001.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_001.png)'
- en: 'The newly started transaction will progress through the following stages:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 新启动的事务将经历以下阶段：
- en: '**Active**: The transaction has just been stated and progressing ahead.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**活动**：事务刚刚开始并且正在向前推进。'
- en: '**Partially committed**: Once the operation has been performed successfully
    the generated values during it will be stored in the volatile storage.'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**部分提交**：一旦操作成功执行，生成的值将被存储在易失性存储中。'
- en: '**Failed**: The values generated before the failure are no longer required
    and will to be removed from the volatile storage area by rollback them.'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**失败**：在失败之前生成的值不再需要，将通过回滚从易失性存储区中删除它们。'
- en: '**Aborted**: The operation has been failed and is no longer continued further.
    It will be stopped or aborted.'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**中止**：操作已失败且不再继续。它将被停止或中止。'
- en: '**Committed**: All the operations successfully performed and all the temporary
    values generated during the operation will be stored permanently once the transaction
    is committed.'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**已提交**：所有成功执行的操作以及操作期间生成的所有临时值，一旦事务提交，将被永久存储。'
- en: '**Terminated**: When the transaction is committed or aborted, it reaches to
    its final stage the termination.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**终止**：当事务提交或中止时，它达到了其最终阶段——终止。'
- en: To handle transaction along with lifecycle steps and properties, one cannot
    neglect very important fact to know types of transaction. A transaction can be
    divided into either local transaction or global transaction
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理与生命周期步骤和属性相关的事务，不能忽视一个非常重要的事实，即了解事务的类型。事务可以划分为本地事务或全局事务。
- en: Local transaction
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地事务
- en: The local transaction allows the application to connect to a single database
    and once all the operations in the transactions are completed successfully, it
    will be committed. The local transactions are specific to the resource and don't
    need any server to handle them. The configured DataSource object will return the
    connection object. This connection object further allows the developers to perform
    database operation as required. By default, such connections are auto committed.
    To take the control in hands, the developers can manually handle transactions
    using commit or rollback. The JDBC connection is the best example of local transactions.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 本地事务允许应用程序连接到单个数据库，一旦事务中的所有操作成功完成，它将被提交。本地事务特定于资源，不需要服务器处理它们。配置的数据源对象将返回连接对象。此连接对象进一步允许开发人员根据需要执行数据库操作。默认情况下，此类连接是自动提交的。为了掌握控制权，开发人员可以使用提交或回滚手动处理事务。JDBC连接是本地事务的最佳示例。
- en: Global or distributed transaction
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局或分布式事务
- en: The global transactions are managed by the application servers like Weblogic,
    WebSphere. Global transaction facilitates to handle more than one resource and
    servers. The global transaction is comprises of many local transactions who access
    the resource. EJB's container managed transaction uses global transactions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 全局事务由应用服务器如Weblogic、WebSphere管理。全局事务能够处理多个资源和服务器。全局事务由许多访问资源的本地事务组成。EJB的容器管理事务使用全局事务。
- en: Spring and Transaction management
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Spring和事务管理
- en: The Spring framework excellently supports the integration of transaction managers.
    It supports Java Transaction API, JDBC, Hibernate and Java Persistent APIs. The
    framework supports abstract transaction management known as transaction strategy.
    The transaction strategy is defined through service provider interface (SPI) through
    PlatformTransactionManager interface. The interface has the methods to commit
    and rollback the transaction. It also has the method to get the transaction specified
    by the TransactionDefinition. All of these methods throws TransactionException
    which is a runtime exception.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架卓越地支持事务管理器的集成。它支持Java事务API，JDBC，Hibernate和Java持久化API。框架支持称为事务策略的抽象事务管理。事务策略是通过服务提供者接口（SPI）通过PlatformTransactionManager接口定义的。该接口有提交和回滚事务的方法。它还有获取由TransactionDefinition指定的事务的方法。所有这些方法都会抛出TransactionException，这是一个运行时异常。
- en: 'The getTransaction() method returns TransactionStatus depending upon the TransactionDefinition
    parameters. The TransactionStatus returned by the method represent a new transaction
    or the existing one. Following parameters can be specified to define the TransactionDefinition:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`getTransaction()`方法根据TransactionDefinition参数返回TransactionStatus。该方法返回的TransactionStatus代表一个新事务或现有事务。以下参数可以指定以定义TransactionDefinition：'
- en: '**Propagation**: The propagation behaviour comes in discussion when one transactional
    method invokes other. In such invocation propagation behaviour states what transaction
    behaviour it will be performed. The invoking method may have started transaction,
    what the invoked method should do in such cases? Whether the invoked method start
    a new transaction, used the current one or it doesn''t support transaction? The
    propagation behaviour can be specified using following values:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传播行为**：当一个事务方法调用另一个方法时，传播行为就会讨论。在这种情况下，传播行为指明它将如何执行事务行为。调用方法可能已经启动了事务，那么被调用方法在这种情况下应该做什么？被调用方法是启动一个新事务，使用当前事务还是不支持事务？传播行为可以通过以下值来指定：'
- en: '**REQUIRED**: It says the transaction is must. If No transaction exists it
    will create a new one.'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**REQUIRED**：它表示必须有事务。如果没有事务存在，它将创建一个新的事务。'
- en: '**REQUIRES_NEW**: It specifies to have a new transaction every time. The current
    transaction will be suspended. If no transaction exists it will create a new.'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**REQUIRES_NEW**：它指定每次都要有一个新的事务。当前事务将被挂起。如果没有事务存在，它将创建一个新的事务。'
- en: '**MANDATORY**: It states the current transaction will be supported but if in
    case of no ongoing transaction an exception will be thrown.'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强制**：它表示当前事务将被支持，但如果没有进行中的事务，将抛出异常。'
- en: '**NESTED**: It states, if the current transaction exists the method will be
    executed within a nested transaction. If no transaction exists it will act as
    PROPAGATION_REQUIRED.'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嵌套**：它表明，如果当前事务存在，方法将在嵌套事务中执行。如果没有事务存在，它将作为PROPAGATION_REQUIRED行事。'
- en: '**NEVER**: The transaction is not supported and if it exists an exception will
    be thrown.'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**永不**：不支持事务，如果存在，将抛出异常。'
- en: '**NOT_SUPPORTED**: It states the transaction is not supported. If transaction
    exists opposite to NEVER it won''t throw exception but suspends it.'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不支持**：它表示该交易是不被支持的。如果交易与**永不**相反存在，它不会抛出异常，但会挂起交易。'
- en: '**Isolation**: We already had discussed in depth about isolation levels.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离性**：我们已经在深度讨论隔离级别。'
- en: '**Timeout**: The timeout value for transaction mentioned in seconds.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超时**：事务中提到的超时值，以秒为单位。'
- en: '**Read only**: The attribute states the transaction will allowed to only read
    the data and no operation leading to updating the data will be supported.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**只读**：该属性表示事务将只允许读取数据，不支持导致更新数据的操作。'
- en: Following are the advantages of using Spring framework's transaction management.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用Spring框架进行事务管理的优点：
- en: 'Spring facilitates the use of Transaction management by two ways as follow:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Spring通过以下两种方式简化事务管理：
- en: Programmatic transaction management.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程事务管理。
- en: Declarative transaction management.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明式事务管理。
- en: 'Whether we are using Programmatic transaction or Declarative transaction the
    foremost important component is to define the `PlatformTransactionManager` using
    Dependency Injection(DI). One should have a clear idea to use local transaction
    or global as it is essential to define `PlatformTransactionManager`. Following
    are the few configuration which can be used to define `PlatformTransactionManager`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们使用程序化事务还是声明式事务，最重要的是使用依赖注入（DI）定义`PlatformTransactionManager`。一个人应该清楚地知道是使用本地事务还是全局事务，因为定义`PlatformTransactionManager`是必不可少的。以下是一些可以用来定义`PlatformTransactionManager`的配置：
- en: 'Using DataSource PlatformTransactionManager can be defines as:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用DataSource PlatformTransactionManager可以定义为：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Using JNDI and JTA to define PlatformTransactionManager as shown below:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JNDI和JTA定义PlatformTransactionManager，如下所示：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Using HibernateTransactionManager defines PlatformTransactionManager as:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HibernateTransactionManager定义PlatformTransactionManager为：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's start with using the transaction management in Spring one by one,
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一开始使用Spring中的事务管理，
- en: Programmatic Transaction management
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 程序化事务管理
- en: The programmatic transaction management in Spring can be done by using either
    TransactionTemplate or PlatformTransactionManager.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring中，可以通过使用TransactionTemplate或PlatformTransactionManager来实现程序化事务管理。
- en: Using PlatformTransactionManager
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用PlatformTransactionManager
- en: The PlatformTransactionManager is at the centre of while discussing Spring's
    transaction management API. It has the functionalities to commit, rollback. It
    also provides a method which returns the currently active transaction. As it's
    an interface it can easily mocked or stubbed whenever required. Spring provides
    DataSourceTransactionManager, HibernateTransactionManager, CciLocalTransactionManager,
    JtaTransactionManager and OC4JJtaTransactionManager as few of the implementation
    of PlatformTransactionManager. To use PlatformTransactionManager any implementation
    of it can be injected in the bean to use for transaction management. Further,
    the objects of TransactionDefinition and TransactionStatus can be used to rollback
    or commit the transaction.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: PlatformTransactionManager是讨论Spring事务管理API的中心。它具有提交、回滚的功能。它还提供了一个返回当前活动事务的方法。由于它是一个接口，因此可以在需要时轻松模拟或垫片。Spring提供了DataSourceTransactionManager、HibernateTransactionManager、CciLocalTransactionManager、JtaTransactionManager和OC4JJtaTransactionManager作为PlatformTransactionManager的几种实现。要使用PlatformTransactionManager，可以在bean中注入其任何实现以用于事务管理。此外，TransactionDefinition和TransactionStatus对象的可以使用来回滚或提交事务。
- en: Before heading ahead, we need to discuss a very important point. Generally the
    application requirement decides whether to apply transaction to service layer
    or to DAO. But still it's a debatable question whether to apply transaction to
    DAO layer or to service layer. Applying transaction to DAO layer though keeps
    the transaction shorter, the biggest problem will occur of multiple transactions.
    And the concurrency has to make with very much care and unnecessarily the complexity
    will increase. The transaction when applied to service layer the DAO's will be
    using a single transaction. We will apply the transaction to service layer in
    our application.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前进之前，我们需要讨论一个非常重要的点。通常，应用程序需求决定是否将事务应用于服务层或DAO层。但是，是否将事务应用于DAO层或服务层仍然是一个有争议的问题。尽管将事务应用于DAO层可以使事务更短，但最大的问题将是多事务的发生。并且必须非常小心地处理并发，不必要的复杂性会增加。当将事务应用于服务层时，DAO将使用单个事务。在我们的应用程序中，我们将事务应用于服务层。
- en: To apply transaction management in application we can think about the following
    points,
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在应用程序中应用事务管理，我们可以考虑以下几点，
- en: Whether to apply transaction to DAO layer or Service layer?
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是将事务应用于DAO层还是服务层？
- en: Decide whether to use Declarative transaction or Programmatic transaction Management
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定是使用声明式事务还是程序化事务管理
- en: Define the PlatformtransactionManager to use in beans configuration.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在bean配置中定义要使用的PlatformtransactionManager。
- en: Decide Transaction attributes as Propagation Behaviour, Isolation level, Read
    Only, Timeout etc to be defined for the transaction.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定事务属性，如传播行为、隔离级别、只读、超时等，以定义事务。
- en: According to programmatic or declarative transaction management add the attributes
    to the transaction either in code.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据程序化或声明式事务管理，在代码中添加事务属性。
- en: Let's use transaction for better understanding. We will use JDBC operations
    in Ch03_JdbcTemplate application developed in the third chapter as our base application.
    Let's follow the steps to use transaction using PlatformTransactionManager,
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用事务来更好地理解。我们将使用第三章中开发的`Ch03_JdbcTemplate`应用程序作为基础应用程序，并使用`PlatformTransactionManager`遵循步骤来使用事务，
- en: Create a new Java application named Ch05_PlatformTransactionManager and add
    all the required jar for Spring core, Spring-jdbc, Spring-transaction, Spring-aop,
    commons-logging and mysql-connector.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Ch05_PlatformTransactionManager`的新Java应用程序，并添加所有必需的jar文件，包括Spring核心、Spring-jdbc、Spring-transaction、Spring-aop、commons-logging和mysql-connector。
- en: Copy or create Book.java in com.packt.ch03.beans package.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`com.packt.ch03.beans`包中复制或创建`Book.java`文件。
- en: 'Copy or create BookDAO.java and BookDAO_JdbcTemplate.java in com.packt.ch03.dao
    package. The final outline of application will be as shown below:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`com.packt.ch03.dao`包中复制或创建`BookDAO.java`和`BookDAO_JdbcTemplate.java`文件。应用程序的最终结构如下所示：
- en: '![](img/image_05_002.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_002.png)'
- en: 'We will add a new method in BookDAO to search the book as before adding it
    will be important to find out is there any book in the ''Book'' table with the
    same ISBN. If it''s already exists, we don''t want to unnecessary go ahead for
    adding it again. The newly added method will be as follows:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在`BookDAO`中添加一个新的方法来搜索书籍，因为在添加之前，我们需要找出'Book'表中是否有具有相同ISBN的书籍。如果已经存在，我们不希望不必要的再次进行添加。新添加的方法将如下所示：
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The BookDAO_JdbcTemplate.java needs to override the newly added method in the
    interface as:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BookDAO_JdbcTemplate.java`需要覆盖接口中 newly added method，如下所示：'
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have added an anonymous inner class which is implementing RowMapper to bind
    object the fetched data from the database using queryForObject()method to the
    data members of the Book object. The code is searching for the book and then the
    column values from ResultSet will be bounded to the Book object. We returned an
    object with default values just for our business logic.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个匿名内部类，它实现了`RowMapper`接口，使用`queryForObject()`方法将从数据库检索的对象绑定到`Book`对象的数据成员。代码正在搜索书籍，然后将`ResultSet`中的列值绑定到`Book`对象。我们返回了一个具有默认值的对象，仅为我们的业务逻辑。
- en: 'Add BookService interface as a service layer in com.packt.ch05.service package
    with following method signatures:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`com.packt.ch05.service`包中添加`BookService`接口作为服务层，并具有以下方法签名：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Create BookServiceImpl implementing BookService. As it's for service annotate
    the class with @Service.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`BookServiceImpl`实现`BookService`。因为这是服务，用`@Service`注解类。
- en: Add two data members to the class first of type PlatformTransactionManager to
    handle transactions and second of type BookDAO to perform JDBC operations. For
    dependency injection annotate both of them by @Autowired.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先向类中添加两个数据成员，第一个类型为`PlatformTransactionManager`以处理事务，第二个类型为`BookDAO`以执行JDBC操作。使用`@Autowired`注解对它们进行依赖注入。
- en: 'Let''s first off all develop searchBook() method of service layer for handling
    read-only transaction in two steps as follows:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们分两步为服务层开发`searchBook()`方法，以处理只读事务：
- en: Create an instance of TransactionDefinition().
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`TransactionDefinition`实例。
- en: Create an instance of TransactionStatus obtained from TransactionManager who
    uses an instance of TransactionDefinition created in previous step. The TransactionStatus
    will provide the status information of transaction which will be used to commit
    or .rollback the transaction.
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`TransactionStatus`实例，该实例从使用上一步创建的`TransactionDefinition`实例的`TransactionManager`中获取。`TransactionStatus`将提供事务的状态信息，该信息将用于提交或回滚事务。
- en: 'Here make the transaction read-only by setting the property to true as we just
    want to search the book and don''t want to perform any updating on the DB side.
    The code developed till this step will be as:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，将事务设置为只读，将属性设置为`true`，因为我们只是想要搜索书籍，并不需要在数据库端执行任何更新。至此步骤开发出的代码将如下所示：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The way we updated read-only property of transaction, we can set other properties
    as isolation level, propagation, timeout in the same way.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更新只读事务属性的方式，也可以同样设置其他属性，如隔离级别、传播、超时。
- en: 'Let''s add addBook() method to service layer to find out whether the book with
    same ISBN already exist and if not insert a row in table. The code will be as:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们向服务层添加`addBook()`方法，以找出是否已有具有相同ISBN的书籍，如果没有，则在表中插入一行。代码将如下所示：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`transactionManager.commit()` will commit the data permanently to the book
    table.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`transactionManager.commit()`将永久将数据提交到书籍表中。'
- en: In the same way let's add deleteBook and updateBook() methods as shown below,
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以同样的方式，让我们添加`deleteBook`和`updateBook()`方法，如下所示，
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Copy or create connection_new.xml for the bean configurations. Add a bean for
    DataSourceTransactionManager as we had seen earlier while discussing how to configure
    PlatformTransactionManager using DataSource.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建connection_new.xml以进行bean配置。添加一个DataSourceTransactionManager的bean，正如我们在讨论如何使用DataSource配置PlatformTransactionManager时所看到的。
- en: 'Update package scanning from XML as we want to consider newly added package
    as well. The updated configuration will be as follows:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新从XML中扫描包，因为我们还想考虑新添加的包。更新后的配置如下：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The final set will be to add Main code in MainBookService_operation.java which
    will invoke methods from service layer using BookServiceImpl object as we did
    earlier for BookDAO_JdbcTemplate object. The code will be as shown below:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步将是把主代码添加到MainBookService_operation.java中，该文件将使用BookServiceImpl对象调用服务层的方法，就像我们之前对BookDAO_JdbcTemplate对象所做的那样。代码如下所示：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The TransactionTemplate
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: TransactionTemplate
- en: Use of thread safe TransactionTemplate helps developers to get rid from boilerplate
    code as already discussed with JdbcTemplate. It make the programmatic transaction
    management simple yet powerful with the help of callback methods. Using TransactionTemplate
    becomes easy as it has different setter methods to customize various transaction
    properties as isolation level, propagation behaviour etc. The first step to use
    Transaction template will be to get it's instance by providing transaction manager.
    The second step will be to get instance of TransactionCallback which will be passed
    to the execute method. The following example will demonstrate how to use the template
    where we don't have to create TransactionDefinition as we did in earlier application,
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线程安全的TransactionTemplate可以帮助开发者摆脱重复的代码，正如我们已经讨论过的JdbcTemplate。它通过回调方法使程序化事务管理变得简单而强大。使用TransactionTemplate变得容易，因为它有各种事务属性的不同设置方法，如隔离级别、传播行为等。使用Transaction模板的第一步是通过提供事务管理器来获取其实例。第二步将是获取TransactionCallback的实例，该实例将传递给execute方法。以下示例将演示如何使用模板，我们不需要像早期应用程序中那样创建TransactionDefinition，
- en: Create a Java application naming Ch05_TransactionTemplate and copy all the required
    jar which we added in earlier application.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为Ch05_TransactionTemplate的Java应用程序，并复制早期应用程序中所需的所有jar文件。
- en: We will keep the outline of the application same as that of Ch05_PlatformTransactionManager
    application so you can copy the beans, dao and service package as it is. The only
    change which we will make is to use TransactionTemplate instead of using PlatformTransactionManager
    in BookServiceImpl.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将保持应用程序的结构与Ch05_PlatformTransactionManager应用程序相同，因此您可以复制bean、dao和服务包。我们唯一要做的改变是在BookServiceImpl中使用TransactionTemplate而不是PlatformTransactionManager。
- en: From BookServiceImpl delete data member PlatformTransactionManager and add TransactionTemplate.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从BookServiceImpl中删除PlatformTransactionManager数据成员并添加TransactionTemplate。
- en: Annotate it with @Autowired to use DI.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用@Autowired注解来使用DI。
- en: 'We will update the searchBook() method to use TransactionTemplate by setting
    it as a read-Only transaction using setReadOnly(true). The TransactionTemplate
    has a callback method as ''execute()'' where the business logic can be written
    to execute. The method is expecting an instance of TrasnsactionCallback and it
    will return searched book. The code will be as shown below:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将更新searchBook()方法，使其使用TransactionTemplate，并通过setReadOnly(true)将其设置为只读事务。TransactionTemplate有一个名为'execute()'的回调方法，可以在其中编写业务逻辑。该方法期望一个TransactionCallback的实例，并返回搜索到的书籍。代码如下所示：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To perform the task, we have created instance of TransactionCallback by using
    concept of inner class. The generic type specified here is, Book as it is the
    return type of the searchBook() method. The class is overriding doInTransaction()method
    to invoke the business logic from DAO's searchBook()method.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行任务，我们通过内部类的概念创建了TransactionCallback的实例。这里指定的泛型类型是Book，因为它是searchBook()方法的返回类型。这个类重写了doInTransaction()方法，以调用DAO的searchBook()方法中的业务逻辑。
- en: One more implementation of TransactionCallback can be written using TransactionCallbackWithoutResult.
    It can be used in case where the service method is not returning anything or having
    void as its return type.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以再实现一个TransactionCallback的版本，使用TransactionCallbackWithoutResult。这种情况下可以用于服务方法没有返回任何内容，或者其返回类型为void。
- en: 'Let''s now add addBook(). The very first thing we have to find whether the
    book exists in table or not using searchBook(). If Book doesn''t''s exist add
    the book. But as searchBook() has made transaction read-only we need to change
    the behavior. As Add book has boolean as its return type we will use TransactionCallBack
    of Boolean type. The code will be as shown below:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们添加`addBook()`。我们首先必须使用`searchBook()`查找书籍是否存在于表中。如果书籍不存在，则添加书籍。但由于`searchBook()`使事务变为只读，我们需要更改行为。由于`addBook()`有布尔值作为其返回类型，我们将使用布尔类型的`TransactionCallBack`。代码将如下所示：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The code clearly shows the TransactionTemplate gives us the power of changing
    the properties of the Transaction yet to internally managing the transaction without
    writing the boilerplate code as PlatformTransactionManager has to.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 代码清楚地显示了TransactionTemplate赋予我们更改尚未内部管理的事务属性的能力，而无需编写PlatformTransactionManager所需的模板代码。
- en: In the same way we can add the code for deleteBook and updateBook(). You can
    find the complete code in source code.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们可以为`deleteBook`和`updateBook()`添加代码。你可以在线源代码中找到完整的代码。
- en: 'Copy connection_new.xml from Ch05_PlatformTransactionmanager in classpath and
    add a bean for TransactionTemplate as follows:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Ch05_PlatformTransactionmanager`类路径中复制`connection_new.xml`文件，并添加一个`TransactionTemplate`的bean，如下所示：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We already had a bean for transactionManager so we will not add it here again.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了一个事务管理器的bean，所以我们在这里不会再次添加它。
- en: Copy MainBookService_operations.java in default package to test the code. We
    will get the code executed successfully.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MainBookService_operations.java`文件复制到默认包中以测试代码。我们会发现代码成功执行。
- en: Before moving ahead just modify the code of doInTransaction() of searchBook()
    method as follows;
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续前进之前，请按照如下方式修改`searchBook()`方法中的`doInTransaction()`代码；
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'On execution we will get the stack trace which denotes read-only operations
    are not allowed to modify the data as follows:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行后，我们会得到一个堆栈跟踪，如下所示，它表示只读操作不允许修改数据：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Declarative transaction management
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 声明式事务管理
- en: The Spring framework uses AOP to facilitate declarative transaction management
    The best things about declarative transaction is, it necessarily does not required
    to be managed by application server and it can be applied to any class. The framework
    also facilitates developers to customize the transactional behavior by using AOP.
    The declarative transaction can either be XML based or annotation based configuration.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架使用AOP来简化声明式事务管理。声明式事务管理最好的地方在于，它不一定需要由应用服务器管理，并且可以应用于任何类。该框架还通过使用AOP，使开发者能够定制事务行为。声明式事务可以是基于XML的，也可以是基于注解的配置。
- en: 'XML based declarative transaction management:'
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基于XML的声明式事务管理：
- en: The framework offers the rollback rules to specify on which types of exception
    the transaction will be rollback. The rollback rules can be specified in XML as
    follows,
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架提供了回滚规则，用于指定事务将在哪种异常类型下回滚。回滚规则可以在XML中如下指定，
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The configuration can even specify attributes as,
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 配置甚至可以指定属性，例如，
- en: '''**no-rollback-for**'' - to specify the exception when we don''t want the
    transaction to rollback.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''**no-rollback-for**'' - 用以指定我们不想回滚事务的异常。'
- en: '**propagation** - to specify the propagation bahavior of transaction with ''REQUIRED''
    as its default value.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传播** - 用以指定事务的传播行为，其默认值为''REQUIRED''。'
- en: '**isolation** - to specify the isolation level.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离** - 用以指定隔离级别。'
- en: '**timeout** - transaction timeout value in seconds with ''-1'' as default.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超时** - 以秒为单位的事务超时值，默认值为''-1''。'
- en: As now a days we more tend to use Annotation based transaction management without
    wasting time let's move on to annotation based transaction management.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现在我们更倾向于使用注解事务管理，而不浪费时间，让我们继续讨论注解事务管理。
- en: Annotation based transaction management
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基于注解的事务管理
- en: The @Transaction annotation facilitates to develop annotation based declarative
    transaction management which can be applied to interface level, class level as
    well as method level. To enable the annotation based support one need to configure
    the following configuration along with the transaction manager,
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Transaction`注解有助于开发基于注解的声明式事务管理，它可以应用于接口级别、类级别以及方法级别。要启用注解支持，需要配置以下配置以及事务管理器，'
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The attribute 'transaction-manager' can be omitted if the bean written for PlatformTransactionManager
    has the name as 'transactionManager'.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为PlatformTransactionManager编写的bean名称是'transactionManager'，则可以省略'transaction-manager'属性。
- en: Following are the attributes which can be use to customize the behavior of transaction,
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以用来自定义事务行为的属性，
- en: '**value** - to specify the transaction manager to be used.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值** - 用于指定要使用的事务管理器。'
- en: '**propagation** - to specify the propagation behavior.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传播行为** - 用于指定传播行为。'
- en: '**isolation** - to specify the isolation levels.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离级别** - 用于指定隔离级别。'
- en: '**readonly** - to specify the read or write behavior.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**只读** - 用于指定读或写行为。'
- en: '**timeout** - to specify the transaction timeout.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超时** - 用于指定事务超时。'
- en: '**rollbackForClassName** - to specify the array of exception classes who causes
    the transaction to rollback.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**rollbackForClassName** - 用于指定导致事务回滚的异常类数组。'
- en: '**rollbackFor** - to specify the array of exception classes who causes the
    transaction to rollback.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**rollbackFor** - 用于指定导致事务回滚的异常类数组。'
- en: '**noRollbackFor** - to specify the array of exception classes who doesn''t
    causes the transaction to rollback.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**noRollbackFor** - 用于指定不导致事务回滚的异常类数组。'
- en: '**noRollbackForClassName** - to specify the array of exception classes who
    doesn''t causes the transaction to rollback.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**noRollbackForClassName** - 用于指定不导致事务回滚的异常类数组。'
- en: 'Let''s use the @Transactional to demonstrate declarative transaction management
    in the application instead of programmatic transaction management with the help
    of following steps:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用@Transactional来演示应用程序中的声明式事务管理，而不是使用以下步骤的帮助进行程序化事务管理：
- en: Create Ch05_Declarative_Transaction_Management and add the required jars as
    we did in earlier application.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建Ch05_Declarative_Transaction_Management并添加所需的jar，就像在早期的应用程序中一样。
- en: Copy com.packt.ch03.beans and com.packt.ch03.dao from Ch05_PlatformTransactionManager
    application.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Ch05_PlatformTransactionManager应用程序中复制com.packt.ch03.beans和com.packt.ch03.dao。
- en: Copy the interface BookService.java in com.packt.ch05.service packages.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.packt.ch05.service包中复制BookService.java接口。
- en: Create a class BookServiceImpl in com.packt.ch05.service package and add a data
    member of type BookDAO.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.packt.ch05.service包中创建BookServiceImpl类，并添加一个类型为BookDAO的数据成员。
- en: Annotate the data member of type BookDAO with @Autowired.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用@Autowired注解类型为BookDAO的数据成员。
- en: 'Annotate searchBook () with @Transactional(readOnly=true) and write the code
    to search data using JdbcTemplate. The class will be as follows:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用@Transactional(readOnly=true)注解searchBook()，并编写使用JdbcTemplate搜索数据的代码。类如下：
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Copy connection_new.xml from Ch05_PlatformTransactionManager in the classpath.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从classpath中的Ch05_PlatformTransactionManager复制connection_new.xml。
- en: 'Now, we need to tell the Spring to find out all the beans which has been annotated
    by @Trasnactional. It will be simply done by adding the following configuration
    in XML:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要告诉Spring找到所有被@Trasnactional注解的bean。通过在XML中添加以下配置即可简单完成：
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To add the above configuration we first have to add ''tx'' as a namespace in
    XML. Update the schema configuration from connection_new.xml as follows:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加上述配置，我们首先要在XML中添加'tx'作为命名空间。从connection_new.xml更新模式配置如下：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, we can add the following configuration:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以添加以下配置：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Copy MainBookService_operation.java and execute it to get the output.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制MainBookService_operation.java并执行它以获得输出。
- en: 'Now add the method addBook() to understand readOnly=true. The code will be
    as follows:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加addBook()方法以理解readOnly=true。代码如下：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Execute the MainBookService_operation.java and execute it to get the following
    output specifying read-only transaction not allowed to modify data:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行MainBookService_operation.java，并执行它以获得以下输出，指定不允许读取事务修改数据：
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Edit addBook() for remove read-only transaction by specifying read-only=false
    which is default behavior of Transaction.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑addBook()方法，通过指定read-only=false来移除只读事务，这是事务的默认行为。
- en: The main code will execute successfully performing the operations.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主要代码将成功执行操作。
- en: Note
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Use Programmatic transaction management if the application has few transaction
    operations using TransactionTemplate. In case of having numerous transactional
    operations to keep it simple and cohesive choose declarative transaction management.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序具有少量事务操作，可以使用TransactionTemplate进行程序化事务管理。在拥有大量事务操作的情况下，为了保持简单和一致，选择声明式事务管理。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: '* * *'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '****'
- en: We discussed in this chapter about Transaction and why it is important. We also
    discussed about transaction management and its life cycle. We discuss about transaction
    attributes as read-only, isolation level, propagation behavior and time out. We
    see declarative and programmatic as two ways to handle transaction where one gives
    the other get rid from the plumbing code and other gives fine control of the operations.
    We also discuss both these techniques with help of an application for better understanding.
    Up till now we had discuss about how to handle the data which was imaginary. We
    need a means to get this for the actual users.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们讨论了事务以及为什么它很重要。我们还讨论了事务管理及其生命周期。我们讨论了事务属性，如只读、隔离级别、传播行为和超时。我们看到了声明性和编程性作为处理事务的两种方式，其中一种使另一种摆脱了管道代码，而另一种提供了对操作的精细控制。我们还通过一个应用程序讨论了这两种技术，以更好地理解。到目前为止，我们讨论了如何处理想象中的数据。我们需要一种方法将其实际地提供给用户。
- en: In the next chapter we will explore how to develop the web layer of an application
    which facilitates us have to have user interaction.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索如何开发一个应用程序的Web层，以便让我们进行用户交互。
