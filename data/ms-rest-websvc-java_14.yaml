- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Alternative Java Frameworks to Build RESTful APIs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 RESTful API 的替代 Java 框架
- en: Until this chapter, we have used the Spring Boot framework to demonstrate the
    API implementation in real code. By using the very popular Spring Boot, we are
    trying to the book as readable and useful for as many readers as possible.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章为止，我们一直使用 Spring Boot 框架来演示真实代码中的 API 实现。通过使用非常流行的 Spring Boot，我们试图使本书对尽可能多的读者来说既可读又实用。
- en: Now it is time to explain why and how other Java frameworks can be used to implement
    RESTful web services.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候解释为什么以及如何使用其他 Java 框架来实现 RESTful 网络服务了。
- en: You will see that the same design principles and a similar code structure are
    still applicable, so you can use the concepts from the other chapters with any
    framework you may want to use for your specific situation.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到相同的设计原则和类似的代码结构仍然适用，因此您可以使用其他章节中的概念，以适应您可能想要用于特定情况的任何框架。
- en: First, we will explain how standards such as Jakarta EE and MicroProfile can
    help you not get lost in the sea of frameworks and implementation stacks you could
    use to build your application. We will briefly mention the possibility of using
    reactive programming, available with most current frameworks.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将解释 jakarta EE 和 MicroProfile 等标准如何帮助您在众多框架和实现堆栈中不迷失方向，这些框架和实现堆栈可用于构建您的应用程序。我们将简要提及使用大多数当前框架中可用的反应式编程的可能性。
- en: The current choice of implementation technologies is the result of the history
    of innovative approaches to aid developers in creating applications that fulfill
    the current architectural and deployment preferences. We will walk you from Java
    EE through Spring to frameworks such as Quarkus and the MicroProfile specification.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当前选择实现技术是历史上创新方法的历史结果，旨在帮助开发者创建满足当前架构和部署偏好的应用程序。我们将从 Java EE 逐步引导您到 Quarkus
    和 MicroProfile 规范等框架。
- en: To provide you with a detailed view, we will demonstrate the similarities and
    differences in our example API implementation with the Quarkus and Helidon frameworks
    compared to the Spring Boot implementation from the previous chapters.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供详细的视角，我们将通过与我们之前章节中 Spring Boot 实现相比的 Quarkus 和 Helidon 框架的示例 API 实现中的相似性和差异性来展示。
- en: 'This makes for the following list of sections:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下章节列表：
- en: Understanding the benefits of standards
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解标准的好处
- en: Choosing imperative or reactive
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择命令式或反应式
- en: Java EE and Jakarta EE
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java EE 和 Jakarta EE
- en: Spring Framework and Spring Boot
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring 框架和 Spring Boot
- en: New microservice frameworks and MicroProfile
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的微服务框架和 MicroProfile
- en: Example implementation with Quarkus
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Quarkus 的示例实现
- en: Example implementation with Helidon
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Helidon 的示例实现
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will demonstrate the use of frameworks other than Spring
    Boot (used in previous chapters). However, the necessary dependencies will be
    downloaded during the project build automatically based on the Maven `pom.xml`
    file, so the prerequisites stay the same:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将演示除了 Spring Boot（在前面章节中使用）之外的其他框架的使用。然而，必要的依赖项将在项目构建过程中自动下载，基于 Maven
    `pom.xml` 文件，因此先决条件保持不变：
- en: Intermediate knowledge of the Java language and platform
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 Java 语言和平台有中级了解
- en: At least basic knowledge of Spring Boot or a similar framework
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少对 Spring Boot 或类似框架有基本了解
- en: Java 21 and Maven 3.9.x installed (alternatively, you can use the `mvnw` command
    included in the example code, which will download the correct Maven version)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了 Java 21 和 Maven 3.9.x（或者，您可以使用示例代码中包含的 `mvnw` 命令，这将下载正确的 Maven 版本）
- en: You can access the code for this chapter on GitHub at [https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter11](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter11)
    .
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上访问本章的代码：[https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter11](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter11)。
- en: Understanding the benefits of standards
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解标准的好处
- en: Java is a versatile language with a large ecosystem of both open source and
    commercial frameworks and libraries. Hence, you have more options to choose from
    than you will ever be able to fully evaluate.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Java 是一种多才多艺的语言，拥有庞大的开源和商业框架和库生态系统。因此，您可以选择的选项比您能够完全评估的要多。
- en: You could even try to implement your own HTTP server or client and a custom
    framework, although it is not recommended other than for educational purposes
    due to the extreme costs of catching the details needed to make it production-ready
    and to maintain it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以尝试实现自己的HTTP服务器或客户端和自定义框架，尽管除了教育目的之外不推荐这样做，因为使其生产就绪和维护所需的细节捕捉成本极高。
- en: Choosing a framework or any component your software will depend on is difficult.
    It involves predicting both the future features your software will need and the
    future evolution and support of the framework (dependency).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个框架或任何你的软件将依赖的组件是困难的。这涉及到预测你的软件将需要的未来功能和框架（依赖）的未来发展和支持。
- en: For example, an application based on the Java Enterprise Edition standard needs
    to be deployed to an application server. Later, a need to deploy new application
    versions frequently, cloud deployment, and scalability requirements may require
    a faster startup time, smaller container size, and removing the dependency on
    the application server. Or, the version of the application server the operations
    team has experience with may become outdated and it will limit the version of
    Java that can be used.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，基于Java企业版标准的应用程序需要部署到应用程序服务器。后来，频繁部署新应用程序版本、云部署和可伸缩性要求可能需要更快的启动时间、更小的容器大小，以及取消对应用程序服务器的依赖。或者，运维团队有经验的应用程序服务器版本可能已经过时，这将限制可以使用的Java版本。
- en: A common approach is to choose between the frameworks with large communities
    of users and developers. But we also want new innovative frameworks to enter the
    market, although their communities will naturally start small.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的方法是在拥有大量用户和开发者的框架之间进行选择。但我们也希望新的创新框架进入市场，尽管它们的社区自然会从很小开始。
- en: Fortunately, vendor-neutral standards and specifications have been created to
    prevent the Java community from becoming fragmented by mutually incompatible frameworks.
    By choosing a framework that conforms to a standard, you retain the option to
    switch to a different implementation of the same standard. It will be much easier
    for developers to start working on your code even without experience specific
    to the framework provided they are familiar with the standard.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，已经创建了供应商中立的规范和标准，以防止Java社区因互不兼容的框架而分裂。通过选择符合标准的框架，你可以保留切换到同一标准的不同实现的选择。如果开发者熟悉标准，即使没有特定于提供的框架的经验，他们也会更容易开始工作。
- en: Therefore, in the following sections, we focus not only on the individual frameworks
    but also on the standards (specifications) they support.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在接下来的章节中，我们不仅关注单个框架，还关注它们支持的标准（规范）。
- en: Choosing imperative or reactive
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择命令式或响应式
- en: In the previous chapters, we used the imperative programming style using the
    Spring Web framework.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用了Spring Web框架的命令式编程风格。
- en: The **imperative programming style** models an API operation using a simple
    Java method that takes data from the HTTP request as arguments and returns a result
    object that will be used to generate the HTTP response. The method body consists
    of statements that are executed sequentially in the order they appear in the code
    using one Java thread.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式编程风格通过一个简单的Java方法来模拟API操作，该方法将HTTP请求中的数据作为参数，并返回一个将用于生成HTTP响应的结果对象。方法体由按代码中出现的顺序顺序执行的语句组成，使用一个Java线程。
- en: In the following code snippet, we can see the statements `statement1` , `statement2`
    , and so on, which will be executed one after another in one thread, with access
    to the same scope of variables and the same call stack.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们可以看到`statement1`、`statement2`等语句，这些语句将在一个线程中依次执行，访问相同的变量作用域和相同的调用栈。
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A similar code snippet shows the same structure when the result contains multiple
    entities. This time, the result type is a well-known Java collection ( `List`
    ).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类似的代码片段显示了当结果包含多个实体时具有相同的结构。这次，结果类型是一个众所周知的Java集合（`List`）。
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The style is called *imperative* because the program is understood as a sequence
    of commands, telling the computer explicitly what steps to perform in which order.
    In this model, data is just parameters for the commands.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这种风格被称为*命令式*，因为程序被理解为一系列命令的序列，明确告诉计算机按何种顺序执行哪些步骤。在这个模型中，数据只是命令的参数。
- en: Besides the “classic” imperative style, with most modern frameworks you also
    have the option of using the reactive style. For example, with the Spring framework
    family, you can use *Spring WebFlux* .
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 除了“经典”的命令式风格外，在大多数现代框架中，您还可以选择使用反应式风格。例如，在Spring框架家族中，您可以使用*Spring WebFlux*。
- en: The **reactive programming style** is built around the idea of asynchronous
    processing of streams of data. The program execution is understood as driven by
    the flow of data. The program reacts to the incoming data items using a pipeline
    of functions (data transformations).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式编程风格建立在异步处理数据流的思想之上。程序执行被理解为由数据流驱动。程序通过一系列函数（数据转换）对传入的数据项做出反应。
- en: The processing steps of a single request using the reactive style are executed
    asynchronously and they usually jump between different Java threads.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用反应式风格处理单个请求的步骤是异步执行的，并且通常在不同的Java线程之间跳跃。
- en: Several libraries were created to support reactive programming in Java, among
    them *RxJava* and *Project Reactor* . All of them share common features based
    on the Observable design pattern. Their interfaces were standardized in the Reactive
    Streams specification ( [https://www.reactive-streams.org/](https://www.reactive-streams.org/)
    ). Starting from Java version 9, the interfaces from the Reactive Streams specification
    have been part of the standard Java API as interfaces embedded in the `java.util.concurrent.Flow`
    class.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 已创建了几个库来支持Java中的反应式编程，其中包括*RxJava*和*Project Reactor*。它们都基于可观察的设计模式共享共同特性。它们的接口在反应式流规范中得到了标准化（[https://www.reactive-streams.org/](https://www.reactive-streams.org/)）。从Java版本9开始，反应式流规范中的接口已成为标准Java
    API的一部分，作为嵌入在`java.util.concurrent.Flow`类中的接口。
- en: 'Now let us compare the preceding example to similar code using Spring WebFlux:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将前面的示例与使用Spring WebFlux的类似代码进行比较：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With the reactive style, the handler method returns a special reactive type.
    For WebFlux (using the Project Reactor library as the reactive streams implementation),
    the result type will be `Mono` (for at most one data item) or `Flux` (a reactive
    analogy of a collection that can contain any number of items).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用反应式风格，处理程序方法返回一个特殊反应类型。对于WebFlux（使用Project Reactor库作为反应式流实现），结果类型将是`Mono`（最多一个数据项）或`Flux`（一个可以包含任何数量项的集合的反应式类似物）。
- en: The reactive handler method is invoked and returns before even the first request
    starts being processed. It is only used to declaratively build the pipeline of
    asynchronous transformations that should be performed for each request. The actual
    request processing is then controlled by the reactive framework, depending on
    the availability of data to process.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式处理程序方法在甚至第一个请求开始处理之前就被调用并返回。它仅用于声明式地构建每个请求应执行的异步转换的管道。实际的请求处理由反应式框架控制，具体取决于可处理的数据的可用性。
- en: By breaking up the processing into separate asynchronous steps (transformation
    functions), the reactive programming style lets the framework use the computing
    resources just in time when the data is available.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将处理分解为单独的异步步骤（转换函数），反应式编程风格允许框架在数据可用时及时使用计算资源。
- en: 'For the reactive framework to be efficient, the pipeline steps (that would
    be the functions that are the arguments of the map functions in the preceding
    examples) are expected to be non-blocking: They should not contain statements
    that synchronously wait for an input/output to finish. Using the reactive programming
    style on the incoming API request layer (the `Controller` class in WebFlux) does
    not make for a correct reactive implementation. Instead, a reactive program should
    be reactive across all its layers, including database access and downstream API
    calls.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使反应式框架高效，期望管道步骤（即前面示例中map函数的参数函数）是非阻塞的：它们不应包含同步等待输入/输出完成的语句。在WebFlux的传入API请求层（`Controller`类）上使用反应式编程风格并不构成正确的反应式实现。相反，一个反应式程序应该在所有层，包括数据库访问和下游API调用中都是反应式的。
- en: 'The reactive programming paradigm enables the development of extremely scalable
    services and systems. Among other features, reactive streams enhance the communication
    between the code parts that implement individual processing steps:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式编程范式使得开发极其可扩展的服务和系统成为可能。在其他特性中，反应式流增强了实现单个处理步骤的代码部分之间的通信：
- en: Failures are expected and can also be processed reactively; reactive streams
    have a separate error channel for that. This is different from ordinary Java streams
    where failures (Java exceptions) break the whole pipeline, not allowing the processing
    to continue without explicit catch clauses.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预期会发生故障，并且也可以通过响应式进行处理；响应式流为此有一个单独的错误通道。这与普通的Java流不同，在Java流中，故障（Java异常）会中断整个管道，不允许在没有显式捕获子句的情况下继续处理。
- en: Data consumers can control the rate of data sent to them by the producers using
    so-called back pressure.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据消费者可以通过所谓的背压来控制生产者发送给他们的数据速率。
- en: On the other hand, with reactive programming, we pay the tax of having to fragment
    the implementation code into small non-blocking functions capable of running on
    different threads. Reactive programming increases complexity due to its asynchronous
    and multi-threaded nature, as well as by requiring the discipline to avoid blocking
    input/output. It puts an increased cognitive load on developers who need to be
    able to translate between the pipeline declarations and the runtime execution.
    Request processing spanning multiple threads makes debugging more difficult since
    the steps leading to a particular execution point are not aligned with the stack
    trace of the current thread. Therefore, it is advisable to make sure the application
    being developed needs the level of scalability that justifies the increased complexity.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在响应式编程中，我们必须付出将实现代码分解成小型的非阻塞函数的代价，这些函数能够在不同的线程上运行。由于响应式编程具有异步和多线程的特性，以及需要遵守避免阻塞输入/输出的纪律，因此它增加了复杂性。它给开发者带来了更大的认知负担，因为他们需要能够在管道声明和运行时执行之间进行转换。跨越多个线程的请求处理使得调试更加困难，因为导致特定执行点的步骤与当前线程的堆栈跟踪不一致。因此，建议确保正在开发的应用程序确实需要能够证明增加复杂性的可扩展性水平。
- en: If the only problem you need to solve is the efficient use of threads so that
    CPU cores are not idle waiting for blocking operations, it can be done with the
    currently available versions of Java without incurring the cost of introducing
    reactive programming. It was explained in the in the section, *Increasing the
    throughput with virtual threads* , in [*Chapter 10*](B21843_10.xhtml#_idTextAnchor284)
    .
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你唯一需要解决的问题是以高效的方式使用线程，以便CPU核心不会空闲等待阻塞操作，那么可以使用目前可用的Java版本来实现，而无需承担引入响应式编程的成本。这一点在[*第10章*](B21843_10.xhtml#_idTextAnchor284)中，*通过虚拟线程提高吞吐量*这一节中已经解释过。
- en: 'To summarize the criteria for choosing the imperative versus the reactive option
    of the backend framework, try to answer the following questions. The more your
    answers converge to “yes,” the more likely it makes sense to use the reactive
    implementation:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结选择后端框架的命令式与响应式选项的标准，尝试回答以下问题。你的答案越接近“是”，就越有可能使用响应式实现：
- en: Is scalability near the top of the features you optimize for?
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性是否是你在优化的功能中的首要考虑？
- en: Is the team ready to accept the increased cognitive load of reactive programming?
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队是否准备好接受响应式编程带来的认知负担增加？
- en: Do you need advanced stream control features such as backpressure?
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否需要高级流控制功能，如背压？
- en: Is it *not* possible to use virtual threads?
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否*不能*使用虚拟线程？
- en: Can all the layers (database access, downstream API calls, etc.) of your application
    be reactive?
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的应用程序的所有层（数据库访问、下游API调用等）都可以是响应式的吗？
- en: In the following sections, we will take a look at various Java server-side implementation
    frameworks, grouped by the related standards, and a little bit of historical context.
    Before we move on to the next section, here is a table that is providing a chronological
    overview of major Java standards and their associated server-side framework implementations.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将探讨各种Java服务器端实现框架，按相关标准分组，并简要介绍一些历史背景。在我们进入下一节之前，这里有一个表格，提供了主要Java标准和它们相关的服务器端框架实现的按时间顺序概述。
- en: '| **Standards** | **year** | **Implementations** |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **标准** | **年份** | **实现** |'
- en: '| Java 2 EE | 1999 |  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| Java 2 EE | 1999 |  |'
- en: '|  | 2000 |  |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '|  | 2000 |  |'
- en: '|  | 2001 |  |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '|  | 2001 |  |'
- en: '|  | 2002 |  |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '|  | 2002 |  |'
- en: '|  | 2003 |  |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '|  | 2003 |  |'
- en: '|  | 2004 | Spring Framework 1.0 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '|  | 2004 | Spring Framework 1.0 |'
- en: '|  | 2005 |  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '|  | 2005 |  |'
- en: '|  | 2006 |  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '|  | 2006 |  |'
- en: '|  | 2007 |  |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '|  | 2007 |  |'
- en: '|  | 2008 |  |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '|  | 2008 |  |'
- en: '| JAX-RS in Java EE 6 | 2009 |  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| JAX-RS in Java EE 6 | 2009 |  |'
- en: '|  | 2010 |  |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '|  | 2010 |  |'
- en: '|  | 2011 |  |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '|  | 2011 |  |'
- en: '|  | 2012 |  |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '|  | 2012 |  |'
- en: '|  | 2013 |  |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '|  | 2013 |  |'
- en: '|  | 2014 | Spring Boot 1.0 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '|  | 2014 | Spring Boot 1.0 |'
- en: '|  | 2015 |  |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '|  | 2015 |  |'
- en: '| MicroProfile 1.0 | 2016 |  |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| MicroProfile 1.0 | 2016 |  |'
- en: '| Java EE 8 | 2017 |  |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| Java EE 8 | 2017 |  |'
- en: '|  | 2018 | Micronaut 1.0 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '|  | 2018 | Micronaut 1.0 |'
- en: '|  | 2019 | Helidon 1.0, Quarkus 1.0 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '|  | 2019 | Helidon 1.0, Quarkus 1.0 |'
- en: '| Jakarta EE 9 | 2020 |  |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| Jakarta EE 9 | 2020 |  |'
- en: '|  | 2021 |  |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '|  | 2021 |  |'
- en: '| Jakarta EE 10 | 2022 |  |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| Jakarta EE 10 | 2022 |  |'
- en: '|  | 2023 |  |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '|  | 2023 |  |'
- en: '| MicroProfile 7.0 | 2024 |  |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| MicroProfile 7.0 | 2024 |  |'
- en: '| Jakarta EE 11 | 2025 |  |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| Jakarta EE 11 | 2025 |  |'
- en: Table 11.1 – Timeline of standards and frameworks
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.1 – 标准和框架的时间线
- en: Java EE and Jakarta EE
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java EE 和 Jakarta EE
- en: The Java language and platform can be used to develop various types of applications;
    however, the area where Java has become the most successful and popular is server-side
    (backend) applications.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Java 语言和平台可以用来开发各种类型的应用程序；然而，Java 最成功和最受欢迎的领域是服务器端（后端）应用程序。
- en: '**Java Enterprise Edition (Java EE** ) is a set of standard APIs that extend
    the **Java Standard Edition** (Java SE, commonly referred to as just “Java” and
    implemented by various products that build on the OpenJDK project) to support
    the development of server-side applications.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java Enterprise Edition (Java EE**) 是一组标准 API，它扩展了 **Java Standard Edition**
    (Java SE，通常简称为“Java”，由各种基于 OpenJDK 项目构建的产品实现) 以支持服务器端应用程序的开发。'
- en: From Java 2 Platform, Enterprise Edition to Jakarta EE
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Java 2 Platform, Enterprise Edition 到 Jakarta EE
- en: Java EE started with the name Java 2 Platform, Enterprise Edition (J2EE), along
    with the release of version 2 of Java (SE) by Sun Microsystems. The Java trademark
    and Java EE passed to Oracle, which acquired Sun Microsystems in 2010. The last
    version of Java EE is Java EE 8, released in 2017.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 以 Java 2 Platform, Enterprise Edition (J2EE) 的名称开始，与 Sun Microsystems
    发布的 Java (SE) 版本 2 一起。Java 商标和 Java EE 转移给了 Oracle，后者在 2010 年收购了 Sun Microsystems。Java
    EE 的最后一个版本是 Java EE 8，于 2017 年发布。
- en: After Java EE 8, the Java EE code and documentation were donated to the Eclipse
    Foundation, and the specification, starting from version 9, is named *Jakarta
    EE* ( [https://jakarta.ee/](https://jakarta.ee/) ). The respective Java packages
    were renamed from `javax.*` to `jakarta.*` .
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java EE 8 之后，Java EE 代码和文档捐赠给了 Eclipse 基金会，规范从版本 9 开始命名为 *Jakarta EE* ([https://jakarta.ee/](https://jakarta.ee/)
    )。相应的 Java 包从 `javax.*` 重命名为 `jakarta.*` 。
- en: Types of JEE containers
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JEE 容器的类型
- en: An implementation of the Jakarta EE specification is called a *Jakarta EE container*
    (also known as an application server), to which Jakarta EE applications can be
    deployed in the form of **Web Archives (WAR)** or **Enterprise Application Archives
    (EAR)** . There are various commercial and open-source implementations.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta EE 规范的实现被称为 *Jakarta EE 容器*（也称为应用服务器），Jakarta EE 应用程序可以以 **Web 归档 (WAR**)
    或 **企业应用程序归档 (EAR**) 的形式部署到其中。有各种商业和开源实现。
- en: An application server can be a full Jakarta EE container (for example, WebSphere,
    OpenLiberty, JBoss, GlassFish, Payara, or TomEE) or it can be a *servlet (web)
    container* only supporting a subset of the Jakarta EE APIs (for example, Jetty
    or Apache Tomcat). The *Servlet API* is a standard way for Jakarta EE applications
    to serve HTTP requests.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 应用服务器可以是完整的 Jakarta EE 容器（例如，WebSphere、OpenLiberty、JBoss、GlassFish、Payara 或
    TomEE），或者它只能是一个仅支持 Jakarta EE API 子集的 *servlet (web) 容器*（例如，Jetty 或 Apache Tomcat）。*Servlet
    API* 是 Jakarta EE 应用程序服务 HTTP 请求的标准方式。
- en: From the Servlet API to declarative endpoint handler methods
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Servlet API 到声明式端点处理方法
- en: 'The **Servlet API** models how an HTTP server sees the communication: The main
    objects are the HTTP request and response, encapsulating all the details such
    as the HTTP method, URI path, headers, and request parameters. The handler method
    must explicitly (imperatively) implement the logic to read the items of the request
    it is interested in and set them in the response. The payloads are accessed as
    Java I/O streams. The handler method has to convert between the streams of bytes
    and structured data objects (model classes).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**Servlet API** 模拟了 HTTP 服务器如何看待通信：主要对象是 HTTP 请求和响应，封装了所有细节，如 HTTP 方法、URI 路径、头信息和请求参数。处理方法必须显式（命令式）实现读取它感兴趣的请求项并将其设置在响应中的逻辑。有效负载作为
    Java I/O 流访问。处理方法必须在字节流和结构化数据对象（模型类）之间进行转换。'
- en: Another Jakarta EE API specification, **Jakarta RESTful Web Services (JAX-RS)**
    , builds on the Servlet API to make implementation of RESTful web services easier
    by providing a declarative programming model where the developer only implements
    handler methods annotated with their respective resource paths and HTTP methods.
    The JAX-RS implementation automatically dispatches the HTTP requests to the matching
    handler methods. It also deserializes the request bodies and serializes the responses.
    JAX-RS in Jakarta EE is like Spring Web MVC in the Spring ecosystem.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个Jakarta EE API规范，**Jakarta RESTful Web Services（JAX-RS）**，基于Servlet API构建，通过提供一个声明式编程模型来简化RESTful
    Web服务的实现，在该模型中，开发者只需实现带有相应资源路径和HTTP方法注解的处理方法。JAX-RS实现会自动将HTTP请求调度到匹配的处理方法。它还会反序列化请求体并序列化响应。在Jakarta
    EE中，JAX-RS就像Spring生态系统中的Spring Web MVC。
- en: 'As the handler classes provide REST resources, the convention is to call them
    “resources,” – for example, a class providing methods operating on products could
    be named `ProductResource` . The resource path is specified with the `@Path` annotation
    and there are annotations for specifying the HTTP method: `@GET` , `@POST` , `@PUT`
    , and so on. You can see that a resource class is like a controller class in Spring
    Web.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于处理类提供REST资源，惯例是将它们称为“资源”，例如，一个提供操作产品的方法的类可以命名为`ProductResource`。资源路径由`@Path`注解指定，并且有用于指定HTTP方法的注解：`@GET`、`@POST`、`@PUT`等。你可以看到资源类就像Spring
    Web中的控制器类。
- en: Spring Framework and Spring Boot
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring框架和Spring Boot
- en: Early versions of Java EE (most notably **Enterprise Java Beans** ) were infamous
    for being hard to use for developers and requiring a lot of boilerplate code.
    JAX-RS (mentioned above) and CDI (the dependency injection standard) only came
    to Java EE with version 6, released in 2009.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 早期版本的Java EE（最著名的是**企业JavaBeans**）因对开发者来说难以使用且需要大量样板代码而臭名昭著。JAX-RS（如上所述）和CDI（依赖注入标准）直到2009年发布的Java
    EE第6版才加入Java EE。
- en: That situation motivated the creation of the **Spring Framework** ( [https://spring.io/](https://spring.io/)
    ), with version 1.0 released in 2004. Among other features and modules, it provided
    support for dependency injection, aspect-oriented programming, and Spring Web
    MVC, the module enabling web service implementation with controller classes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 那种情况促使**Spring框架**（[https://spring.io/](https://spring.io/)）的创建，其1.0版本于2004年发布。在众多特性和模块中，它提供了对依赖注入、面向方面编程和Spring
    Web MVC的支持，该模块通过控制器类实现Web服务的实现。
- en: Spring Framework with **Spring Web MVC** (commonly referred to as just **Spring
    Web** ) and many other modules, thanks to improvements in developer experience,
    has become very popular and is the most used framework for developing server-side
    Java applications currently.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于开发者体验的改进，包含**Spring Web MVC**（通常简称为**Spring Web**）和许多其他模块的Spring框架已经变得非常流行，并且是目前开发服务器端Java应用程序最常用的框架。
- en: The requirement to deploy applications to a separate software product, the Java
    EE container, was perceived as an unnecessary additional step by developers. Upgrades
    of application servers required organizational coordination that caused them to
    be complex and slow, impeding technical modernization, including the upgrades
    to new Java (SE) versions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序部署到单独的软件产品，即Java EE容器，被视为开发者不必要的额外步骤。应用服务器的升级需要组织协调，这导致它们变得复杂且缓慢，阻碍了技术现代化，包括对新Java（SE）版本的升级。
- en: To prevent CPU and memory usage or specific extensions of one application from
    influencing other applications, there is a common practice to use a separate application
    server instance for each application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止一个应用程序的CPU和内存使用或特定扩展影响其他应用程序，通常的做法是为每个应用程序使用单独的应用服务器实例。
- en: '*Spring Boot* , first released in 2014, brought the possibility to develop
    standalone Spring applications that can be run directly without a separate application
    server. The application can be packaged as a simple **Java Archive (JAR)** that
    includes an embedded web server (Tomcat by default). Simplified deployment, together
    with other features such as easy configuration and sensible defaults, made Spring
    Boot a good fit for developing microservices.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*Spring Boot*，首次发布于2014年，带来了开发可以直接运行而无需单独应用服务器的独立Spring应用程序的可能性。该应用程序可以打包为一个简单的**Java归档（JAR）**文件，其中包含一个嵌入的Web服务器（默认为Tomcat）。简化部署，以及其他如易于配置和合理的默认值等特性，使得Spring
    Boot非常适合开发微服务。'
- en: 'Although Spring Framework and Spring Boot have become a de facto standard in
    backend Java development, it is important to understand that Spring Web and many
    other Spring modules are just a layer on top of Java/Jakarta EE. When using Spring
    Web, you use not only Spring-specific abstractions but also Java/Jakarta EE features
    directly: Servlet API, Java Bean Validation API, and so on. By using a particular
    version of Spring, you automatically depend on a particular version of Java/Jakarta
    EE as well.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Spring 框架和 Spring Boot 已成为后端 Java 开发的既定标准，但重要的是要理解 Spring Web 和许多其他 Spring
    模块只是 Java/Jakarta EE 之上的一个层。当使用 Spring Web 时，你不仅使用 Spring 特定的抽象，还直接使用 Java/Jakarta
    EE 功能：Servlet API、Java Bean 验证 API 等。通过使用特定的 Spring 版本，你自动依赖于特定的 Java/Jakarta
    EE 版本。
- en: New microservice frameworks and MicroProfile
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的微服务框架和 MicroProfile
- en: Jakarta EE and Spring Boot, thanks to their long history, are the most mature
    and most well-known server-side Java application frameworks, providing reliability
    and stability to many developers. However, around the years 2018-2019, new frameworks
    such as *Micronaut* , *Helidon* , and *Quarkus* gradually appeared, which, by
    not being limited by backward compatibility, could choose innovative approaches
    to application development and better meet the current challenges of microservices
    and cloud deployment.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其悠久的历史，Jakarta EE 和 Spring Boot 是最成熟和最知名的Java服务器端应用框架，为许多开发者提供了可靠性和稳定性。然而，在
    2018-2019 年左右，新的框架如 *Micronaut*、*Helidon* 和 *Quarkus* 逐渐出现，它们不受向后兼容性的限制，可以选择创新的应用开发方法，更好地满足微服务和云部署的当前挑战。
- en: 'Highly scalable cloud-native applications need to be able to do the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 高度可扩展的云原生应用需要能够做到以下事项：
- en: Start new service instances quickly to adapt to higher load (upscaling) or to
    restart after failures
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速启动新的服务实例以适应更高的负载（扩展）或失败后的重启
- en: Use as little CPU, memory, and networking resources as possible to optimize
    cloud service costs
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能少地使用 CPU、内存和网络资源，以优化云服务成本
- en: 'Such applications should have the following characteristics:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的应用应具备以下特点：
- en: A small application executable code size to minimize the time delay and network
    traffic needed to transfer the application to the cloud nodes where new service
    instances should run
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小的应用程序可执行代码大小，以最小化将应用程序传输到新服务实例应运行的云节点所需的时间延迟和网络流量
- en: A short service startup time (the time the service spends preparing before being
    able to serve requests)
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 短的服务启动时间（服务在能够处理请求之前准备的时间）
- en: A small and stable memory consumption (even if a service needs more memory during
    startup only, it will need a larger and more expensive cloud computing instance)
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小而稳定的内存消耗（即使服务在启动时需要更多内存，也只需要更大、更昂贵的云计算实例）
- en: 'The new microservice frameworks address these challenges by bringing the following
    features:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 新的微服务框架通过以下功能来解决这些挑战：
- en: Limiting the number and complexity of library dependencies
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制库依赖项的数量和复杂性
- en: Replacing dynamic processing during application startup (application configuration,
    dependency injection, and aspect-oriented programming) with static code generation
    during application build
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序构建期间用静态代码生成替换应用程序启动期间的动态处理（应用程序配置、依赖注入和面向切面编程）
- en: Avoiding the use of reflection, dynamic class loading, or dynamic (proxy) class
    creation
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用反射、动态类加载或动态（代理）类创建
- en: The resulting applications are well-suited for ahead-of-time compilation to
    platform-native code (using **GraalVM** – see [https://www.graalvm.org/](https://www.graalvm.org/)
    )
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应用程序非常适合进行预编译到平台原生代码（使用 **GraalVM** – see [https://www.graalvm.org/](https://www.graalvm.org/)
    )
- en: On the other hand, the emergence of new frameworks brought the problems of how
    to avoid the fragmentation of the Java backend developer community and how to
    overcome the barrier of adoption of the frameworks because of a lack of developers
    familiar with their programming model.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，新框架的出现带来了如何避免 Java 后端开发者社区碎片化的问题，以及如何克服由于缺乏熟悉其编程模型的开发者而导致的框架采用障碍的问题。
- en: The Micronaut framework tries to help with the transition from Spring and Spring
    Boot by providing similar abstractions (controllers), supporting many Spring annotations,
    and other compatibility features to make the transition from Spring smooth.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Micronaut 框架试图通过提供类似的抽象（控制器）、支持许多 Spring 注解以及其他兼容性功能来帮助从 Spring 和 Spring Boot
    过渡，从而使过渡过程更加顺畅。
- en: All the new frameworks try to some extent to exploit the potential of the experience
    and the broad community around the Java/Jakarta EE standards. Due to their lightweight
    nature, they choose to implement only selected parts of the Jakarta EE specification.
    In contrast, they do implement additional features required by distributed cloud-native
    applications, such as declarative REST clients, observability, fault tolerance,
    and so on, that were not standardized within Jakarta EE.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 所有新的框架在某种程度上都试图利用Java/Jakarta EE标准周围的经验和广泛社区潜力。由于它们的轻量级特性，它们选择仅实现Jakarta EE规范的部分内容。相比之下，它们确实实现了分布式云原生应用所需的附加功能，例如声明式REST客户端、可观察性、容错性等，这些功能在Jakarta
    EE中并未标准化。
- en: Many of the above-mentioned features were standardized in the **MicroProfile**
    specification ( [https://microprofile.io/](https://microprofile.io/) ) whose version
    1.0 was created in 2016. Shortly after its creation, the MicroProfile project
    joined the Eclipse Foundation. The latest MicroProfile version available at the
    time of writing this book is 7.0. It is aligned with version 10.0 of Jakarta EE.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 许多上述功能已在**MicroProfile**规范（[https://microprofile.io/](https://microprofile.io/)）中标准化，其1.0版本于2016年创建。在其创建后不久，MicroProfile项目加入了Eclipse基金会。本书撰写时，可用的最新MicroProfile版本是7.0，它与Jakarta
    EE的10.0版本保持一致。
- en: The subset of Jakarta EE that overlaps with MicroProfile is named the **Core
    Profile** . The parts of the Core Profile that are the most interesting in the
    context of this book are Jakarta RESTful Web Services, Jakarta JSON Binding, and
    Jakarta JSON Processing. The Core Profile also contains the lightweight dependency
    injection framework called Jakarta CDI Lite, Jakarta Interceptors, and obviously
    Jakarta Annotations as a common dependency.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与MicroProfile重叠的Jakarta EE子集被称为**Core Profile**。在本书的上下文中，Core Profile中最有趣的部分是Jakarta
    RESTful Web Services、Jakarta JSON Binding和Jakarta JSON Processing。Core Profile还包含名为Jakarta
    CDI Lite的轻量级依赖注入框架、Jakarta Interceptors以及显然是作为公共依赖的Jakarta Annotations。
- en: 'MicroProfile 7.0 extends the Core Profile with the following modules, which
    are very relevant for API and microservice implementation:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile 7.0通过以下模块扩展了Core Profile，这些模块对于API和微服务实现非常相关：
- en: '**OpenAPI** : Generating OpenAPI specification from code for the code-first
    approach, we showed its Spring alternative in [*Chapter 3*](B21843_03.xhtml#_idTextAnchor076)'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenAPI**：从代码生成OpenAPI规范，对于代码优先方法，我们在[*第3章*](B21843_03.xhtml#_idTextAnchor076)中展示了其Spring替代方案'
- en: '**REST Client** : For consuming REST APIs using the code-first approach (we
    used the specification-first approach with client code generation in [*Chapter
    4*](B21843_04.xhtml#_idTextAnchor096) )'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**REST客户端**：用于使用代码优先方法消费REST API（我们在[*第4章*](B21843_04.xhtml#_idTextAnchor096)中使用了规范优先方法，并生成了客户端代码）'
- en: '**Fault tolerance** : Also known as resilience, discussed in [*Chapter 6*](B21843_06.xhtml#_idTextAnchor135)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容错性**：也称为弹性，在[*第6章*](B21843_06.xhtml#_idTextAnchor135)中讨论'
- en: '**JWT** authentication: An important part of API security, discussed in [*Chapter
    7*](B21843_07.xhtml#_idTextAnchor176)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JWT**身份验证：API安全性的重要部分，在[*第7章*](B21843_07.xhtml#_idTextAnchor176)中讨论'
- en: '**Telemetry** : Providing observability, we showed this aspect using Spring
    in [*Chapter 9*](B21843_09.xhtml#_idTextAnchor240)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遥测**：提供可观察性，我们使用Spring展示了这一方面，在[*第9章*](B21843_09.xhtml#_idTextAnchor240)中'
- en: '**Health:** Used by orchestrators such as Kubernetes to probe a service instance
    for its healthand readiness to serve requests, a functionality provided by the
    Actuator in Spring Boot, we will show this using Spring in [*Chapter 12*](B21843_12.xhtml#_idTextAnchor330)'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**健康**：由Kubernetes等编排器用于探测服务实例的健康状况和准备就绪状态，这是Spring Boot中Actuator提供的一项功能，我们将在[*第12章*](B21843_12.xhtml#_idTextAnchor330)中使用Spring展示这一点'
- en: '**Config** : Flexible configuration options, a common requirement for cloud-native
    services'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**：灵活的配置选项，云原生服务的一个常见要求'
- en: 'After listing the abstract concepts that the MicroProfile specification covers,
    in the following sections, we will show small examples of API implementations
    using two frameworks that fully implement the MicroProfile specification: *Quarkus*
    and *Helidon* .'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在列出MicroProfile规范涵盖的抽象概念之后，在接下来的章节中，我们将展示使用两个完全实现MicroProfile规范的框架（*Quarkus*和*Helidon*）的API实现的小示例。
- en: Example implementation with Quarkus
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Quarkus的示例实现
- en: '**Quarkus** ( [https://quarkus.io/](https://quarkus.io/) ) is a framework providing
    optimized startup time and memory usage. Quarkus makes deployment to Kubernetes
    and the cloud easy in many ways. Despite being relatively new, thanks to its great
    developer experience, it has been adopted quickly in many enterprise application
    development projects.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**Quarkus** ([https://quarkus.io/](https://quarkus.io/)) 是一个提供优化启动时间和内存使用的框架。Quarkus以多种方式简化了部署到Kubernetes和云的过程。尽管相对较新，但由于其卓越的开发者体验，它已被迅速采用于许多企业级应用开发项目中。'
- en: Among other features, Quarkus boasts its *development mode (dev mode)* , which
    detects changes in Java source files or resource files (e.g., configuration properties),
    recompiles them automatically, and applies them (if possible) to the running application
    (performs a so-called hot deployment) without a need for an explicit restart.
    With the dev mode, the developer gets fast feedback without losing focus on the
    code due to lengthy application rebuilds and restarts.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他特性中，Quarkus以其*开发模式（dev mode）*而自豪，该模式检测Java源文件或资源文件（例如，配置属性）中的更改，自动重新编译它们，并在可能的情况下将它们应用到正在运行的应用程序（执行所谓的热部署）而不需要显式重启。在开发模式下，开发者可以快速获得反馈，而不会因为长时间的应用程序重建和重启而失去对代码的关注。
- en: We will start our Quarkus example by implementing the Product API, as we did
    in [*Chapter 2*](B21843_02.xhtml#_idTextAnchor050) with Spring Boot.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从实现产品API开始我们的Quarkus示例，就像我们在[*第2章*](B21843_02.xhtml#_idTextAnchor050)中使用Spring
    Boot所做的那样。
- en: Exposing the Product API
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暴露产品API
- en: 'We will use the same endpoint design as in [*Chapter 2*](B21843_02.xhtml#_idTextAnchor050)
    :'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与[*第2章*](B21843_02.xhtml#_idTextAnchor050)中相同的方式设计端点：
- en: '`GET /products` to list all products'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /products` 用于列出所有产品'
- en: '`PUT /products/{id}` to create or update a product'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT /products/{id}` 用于创建或更新一个产品'
- en: '`DELETE /products/{id}` to remove a product'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE /products/{id}` 用于删除一个产品'
- en: '`PATCH /products/{id}` to update product description only'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH /products/{id}` 仅用于更新产品描述'
- en: '`GET /products/{id}` to get the data of one product.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /products/{id}` 用于获取一个产品的数据。'
- en: We will use the same Clean Architecture structure, so for exposing the REST
    API we will focus on the `*.adapter.inbound.rest` package. The main class in the
    package is the resource class.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用相同的Clean Architecture结构，因此对于暴露REST API，我们将关注`*.adapter.inbound.rest`包。包中的主要类是资源类。
- en: The resource class
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源类
- en: 'In accordance with the Jakarta REST terminology, the class handling the REST
    resource endpoints is named `ProductResource` . The base URL path for the resource
    endpoints is specified using the `@Path` annotation:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Jakarta REST术语，处理REST资源端点的类命名为`ProductResource`。资源端点的基URL路径使用`@Path`注解指定：
- en: '[PRE3]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Each endpoint is implemented by a handler method. Let us start with the `createOrUpdateProduct`
    operation:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 每个端点都由一个处理方法实现。让我们从`createOrUpdateProduct`操作开始：
- en: '[PRE4]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There are multiple annotations on the method and its arguments:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 方法和其参数上有多个注解：
- en: '`@PUT` : The HTTP method'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@PUT` : HTTP方法'
- en: '`@Path` : The endpoint relative path'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Path` : 端点相对路径'
- en: '`@Consumes` : The expected request content type'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Consumes` : 预期的请求内容类型'
- en: '`@Produces` : The response content type'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Produces` : 响应内容类型'
- en: '`@PathParam` : The argument bound to the URL path parameter'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@PathParam` : 绑定到URL路径参数的参数'
- en: The built-in `@Valid` and custom `@ValidSku` bean validation annotations are
    used the same way as with Spring Boot.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的`@Valid`和自定义的`@ValidSku` Bean验证注解的使用方式与Spring Boot相同。
- en: The `Response` method return type, like `ResponseEntity` in Spring Boot, lets
    the method body decide on the HTTP response code and additional response headers
    dynamically.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`Response`方法的返回类型，类似于Spring Boot中的`ResponseEntity`，允许方法体动态决定HTTP响应代码和额外的响应头。'
- en: 'The method to list all products is quite simple; the only annotation needed
    is the HTTP method, and the method returns the body of the HTTP response directly:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 列出所有产品的操作方法相当简单；所需的唯一注解是HTTP方法，并且方法直接返回HTTP响应体：
- en: '[PRE5]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The method to get one product by its ID is similar, but in addition, it needs
    the `productId` path parameter:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过ID获取一个产品的操作方法类似，但除此之外，它还需要`productId`路径参数：
- en: '[PRE6]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here’s the method to update a product description:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 更新产品描述的方法如下：
- en: '[PRE7]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And finally, the method to remove a product:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，删除一个产品的操作方法：
- en: '[PRE8]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![img](img/Information_Box_Icon.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/Information_Box_Icon.png)'
- en: '**Keeping within the standard**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**遵循标准**'
- en: Please note that, in the resource class, we deliberately decided to only use
    the annotations from packages starting with the `jakarta.` prefix so that our
    code stays within the MicroProfile specification. We could have used other annotations
    supported by Quarkus (and recommended in some tutorials) – for example, `org.jboss.resteasy.RestPath`
    instead of `jakarta.ws.rs.PathParam` – and we could have skipped specifying the
    parameter name ( `"productId"` ) as it would be inferred from the method argument
    name. However, that would make the code Quarkus-specific. For the reasons stated
    earlier in this chapter, it makes sense to use standardized APIs even if it means
    sacrificing a little bit of the convenience some specific implementation may offer.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在资源类中，我们故意决定只使用以 `jakarta.` 前缀开始的包中的注解，以便我们的代码符合 MicroProfile 规范。我们可以使用
    Quarkus 支持的其他注解（在某些教程中推荐）——例如，使用 `org.jboss.resteasy.RestPath` 而不是 `jakarta.ws.rs.PathParam`——并且我们可以省略指定参数名称（`"productId"`），因为它可以从方法参数名称中推断出来。然而，这将使代码变得特定于
    Quarkus。正如本章前面所述的原因，即使这意味着牺牲一些特定实现可能提供的便利，使用标准化 API 也是有意义的。
- en: The rest of the package (DTOs, mappers, and the ValidSku annotation) are framework-independent,
    so the code is the same as for Spring Boot.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 包的其余部分（DTOs、mappers 和 ValidSku 注解）是框架无关的，因此代码与 Spring Boot 相同。
- en: To handle exceptions by mapping them to the correct HTTP responses, MicroProfile
    supports the ExceptionMapper interface, described in the following section.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过将异常映射到正确的 HTTP 响应来处理异常，MicroProfile 支持以下章节中描述的 ExceptionMapper 接口。
- en: Exception mappers
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常映射器
- en: 'For our example API, we want to define mappings for two exception types:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例 API，我们希望为两种异常类型定义映射：
- en: '`EntityNotFoundException` , meaning a product with the given ID is not found'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EntityNotFoundException`，表示未找到具有给定 ID 的产品'
- en: '`ValidationException` , meaning some input does not comply with the bean validation
    annotations'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ValidationException`，表示某些输入不符合 Bean 验证注解'
- en: 'Both mapper classes are alike, so it will suffice if we show the first of them:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 两个映射类相似，所以我们只需展示其中的第一个：
- en: '[PRE9]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It can be seen that the `ProblemDetail` DTO is defined in our code as it is
    not provided by Jakarta REST.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，`ProblemDetail` DTO 是在我们的代码中定义的，因为它不是由 Jakarta REST 提供的。
- en: In the following section, we will briefly mention the remaining parts of our
    application and test the REST API.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将简要介绍我们应用程序的其余部分并测试 REST API。
- en: Completing and testing the Quarkus application
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完成并测试 Quarkus 应用程序
- en: Classes in the `domain` and `usecase` packages, decoupled from the communication
    layers using Clean Architecture, need not change when we switch from Spring Boot
    to Quarkus.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Clean Architecture 解耦通信层的 `domain` 和 `usecase` 包中的类，在从 Spring Boot 切换到 Quarkus
    时不需要更改。
- en: To create a working Quarkus application, we need to implement persistence. We
    use Jakarta Persistence to map the database tables to entity classes. However,
    to be able to access the database using the Repository pattern (as we did with
    Spring Data), we have to use Panache, which is a module specific to Quarkus.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个可工作的 Quarkus 应用程序，我们需要实现持久性。我们使用 Jakarta Persistence 将数据库表映射到实体类。然而，为了能够使用
    Repository 模式（就像我们使用 Spring Data 一样）访问数据库，我们必须使用 Panache，这是 Quarkus 特有的模块。
- en: The repository pattern for persistence is not standardized within MicroProfile;
    however, there isthe new Jakarta Data specification in Jakarta EE 11.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MicroProfile 中，持久性的仓库模式没有标准化；然而，在 Jakarta EE 11 中有新的 Jakarta Data 规范。
- en: To link the components of our application together, we use dependency injection
    with Jakarta Contexts and Dependency Injection (CDI) features ( `@ApplicationScoped`
    and `@Inject` annotations) that are supported by MicroProfile.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们应用程序的组件连接起来，我们使用 Jakarta Contexts and Dependency Injection (CDI) 功能的依赖注入，这些功能由
    MicroProfile 支持（`@ApplicationScoped` 和 `@Inject` 注解）。
- en: As persistence and dependency injection are concepts that are not specific to
    RESTful web service implementation, we are not going to explain in more detail
    how to use them with Quarkus, MicroProfile, or Jakarta EE.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 由于持久性和依赖注入不是特定于 RESTful Web 服务实现的，我们不会详细解释如何使用它们与 Quarkus、MicroProfile 或 Jakarta
    EE。
- en: 'When we have the application code complete, we can start the application using
    the convenient Quarkus dev mode:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成应用程序代码后，我们可以使用方便的 Quarkus 开发模式启动应用程序：
- en: '[PRE10]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then we can try the API endpoints using the `curl` commands, creating the product
    with the `PUT` method:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 `curl` 命令尝试 API 端点，使用 `PUT` 方法创建产品：
- en: '[PRE11]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We list all products:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们列出所有产品：
- en: '[PRE12]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the next chapter, we will get the documentation of the API we have just created
    in the OpenAPI standard.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将获取我们刚刚创建的 API 的 OpenAPI 标准文档。
- en: Getting the API specification from the code
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从代码中获取 API 规范
- en: We saw how the implementation-independent specification of an API can be generated
    for a Spring Boot application in [*Chapter 3*](B21843_03.xhtml#_idTextAnchor076)
    .
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 3 章*](B21843_03.xhtml#_idTextAnchor076)中，我们看到了如何为 Spring Boot 应用生成一个与实现无关的
    API 规范。
- en: A similar code-first approach is available for MicroProfile applications, thanks
    to the MicroProfile OpenAPI specification.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 MicroProfile OpenAPI 规范，对于 MicroProfile 应用程序，也提供了类似的代码优先方法。
- en: 'We will add just one dependency in the `pom.xml` file of our Quarkus application:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 Quarkus 应用的`pom.xml`文件中添加一个依赖项：
- en: '[PRE13]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now we can enter the Swagger UI by opening the [http://localhost:8080/q/swagger-ui/](http://localhost:8080/q/swagger-ui/)
    URL in a web browser.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过在网页浏览器中打开[http://localhost:8080/q/swagger-ui/](http://localhost:8080/q/swagger-ui/)
    URL 来进入 Swagger UI。
- en: '![Figure 11.1 – Swagger UI generated from a Quarkus application](img/B21843_11_1.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1 – 由 Quarkus 应用生成的 Swagger UI](img/B21843_11_1.png)'
- en: Figure 11.1 – Swagger UI generated from a Quarkus application
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – 由 Quarkus 应用生成的 Swagger UI
- en: The OpenAPI specification (in YAML format) can be downloaded using the [http://localhost:8080/q/openapi](http://localhost:8080/q/openapi)
    URL.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用[http://localhost:8080/q/openapi](http://localhost:8080/q/openapi) URL 下载
    OpenAPI 规范（YAML 格式）。
- en: We have shown how to create and document the Product API with Quarkus using
    the code-first approach. In the next chapter, you will see that, even with Quarkus,
    we can create APIs specification-first, using Java code generation from OpenAPI.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了如何使用代码优先的方法使用 Quarkus 创建和记录 Product API。在下一章中，您将看到，即使使用 Quarkus，我们也可以使用
    Java 代码生成从 OpenAPI 创建 API 规范。
- en: Generating MicroProfile code from OpenAPI
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 OpenAPI 生成 MicroProfile 代码
- en: We are going to create a stub (not the full implementation) of the Order Management
    API that was implemented with Spring Boot in [*Chapter 4*](B21843_04.xhtml#_idTextAnchor096)
    .
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个 Order Management API 的存根（不是完整的实现），该 API 在[*第 4 章*](B21843_04.xhtml#_idTextAnchor096)中使用
    Spring Boot 实现。
- en: We’ll use the same `Order_Management_API.yml` specification file as in [*Chapter
    4*](B21843_04.xhtml#_idTextAnchor096) .
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与[*第 4 章*](B21843_04.xhtml#_idTextAnchor096)中相同的`Order_Management_API.yml`规范文件。
- en: 'The `pom.xml` file contains the same Quarkus dependencies as in the *Exposing
    the Product API* section. Additionally, we add the plugin configurations to generate
    the code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`pom.xml`文件包含与*暴露 Product API*部分相同的 Quarkus 依赖项。此外，我们添加了插件配置以生成代码：'
- en: '[PRE14]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Some configuration parameters are the same as with Spring: package names, model
    name suffix. The generator name is different; we are using the one compliant with
    the JAX-RS specification. We use the `useJakartaEe` flag because the current version
    of the specification requires `jakarta` instead of `javax` as the package prefix.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一些配置参数与 Spring 相同：包名、模型名后缀。生成器的名称不同；我们使用符合 JAX-RS 规范的生成器。我们使用`useJakartaEe`标志，因为当前版本的规范要求使用`jakarta`而不是`javax`作为包前缀。
- en: We use the `interfaceOnly` flag because we want our manually written classes
    to implement generated interfaces. This way, if our implementation does not match
    the generated interface, it will be reported by the compiler automatically.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`interfaceOnly`标志，因为我们希望我们手动编写的类实现生成的接口。这样，如果我们的实现与生成的接口不匹配，编译器会自动报告。
- en: 'Now we can run the Maven `compile` goal:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行 Maven 的`compile`目标：
- en: '[PRE15]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can see the generated sources in the `target/generated-sources/openapi` directory.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`target/generated-sources/openapi`目录中看到生成的源代码。
- en: 'If we try to run the Quarkus application now, and open the Swagger UI at [http://localhost:8080/q/swagger-ui/](http://localhost:8080/q/swagger-ui/)
    , we will see that no REST endpoints (operations) are exposed:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试运行 Quarkus 应用程序，并在[http://localhost:8080/q/swagger-ui/](http://localhost:8080/q/swagger-ui/)打开
    Swagger UI，我们会看到没有暴露任何 REST 端点（操作）：
- en: '![Figure 11.2 – Swagger UI showing no operations](img/B21843_11_2.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2 – 显示无操作的 Swagger UI](img/B21843_11_2.png)'
- en: Figure 11.2 – Swagger UI showing no operations
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – 显示无操作的 Swagger UI
- en: 'We need to provide an implementation of the generated interface. Before doing
    so, we need to add one more plugin to make the generated sources accessible from
    our manually written code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要提供一个生成接口的实现。在这样做之前，我们需要添加一个额外的插件，以便从我们手动编写的代码中访问生成的源代码：
- en: '[PRE16]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Just to demonstrate the concept, we will create a stub implementation of the
    generated interface:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 只为了演示这个概念，我们将创建一个生成的接口的存根实现：
- en: '[PRE17]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Opening the Swagger UI again shows that the operations are now available.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 再次打开 Swagger UI 显示，操作现在可用。
- en: '![img](img/B21843_11_3.png) Figure 11.3 – Swagger UI of the Order Management
    API'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![img](img/B21843_11_3.png) 图 11.3 – 订单管理 API 的 Swagger UI'
- en: We can test it, for example, by sending the POST request with the body. The
    response will be empty (because our implementation is not complete) but successful
    (HTTP 2xx status code).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过发送带有正文的 POST 请求来测试它。响应将为空（因为我们的实现尚未完成），但成功（HTTP 2xx 状态码）。
- en: '[PRE18]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the last section of the chapter, we will see that similar code to what we
    used with Quarkus can work with another framework, Helidon.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将看到与我们在 Quarkus 中使用的类似代码也可以与另一个框架，Helidon，一起工作。
- en: Example implementation with Helidon
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Helidon 的示例实现
- en: As we have used the MicroProfile annotations only, exactly the same `ProductResource`
    class code that was used with Quarkus works with Helidon, too.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只使用了 MicroProfile 注解，因此与 Quarkus 一起使用的相同的 `ProductResource` 类代码也可以在 Helidon
    中使用。
- en: Instead of the Panache repository-based data persistence implementation used
    with Quarkus, we use the `EntityManager` interface of the **Jakarta Persistence
    (JPA)** specification directly.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 与在 Quarkus 中使用的基于 Panache 存储库的数据持久性实现不同，我们直接使用 **Jakarta Persistence (JPA)**
    规范的 `EntityManager` 接口。
- en: Obviously, compared to the Quarkus implementation, we had to put different dependencies
    in the `pom.xml` file, and we used different configuration files, too.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，与 Quarkus 的实现相比，我们不得不在 `pom.xml` 文件中放入不同的依赖项，我们也使用了不同的配置文件。
- en: 'The application is built with this Maven command:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序是用以下 Maven 命令构建的：
- en: '[PRE19]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then we can start the application JAR file:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以启动应用程序 JAR 文件：
- en: '[PRE20]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Of course, the API of the running application will behave the same way as the
    other implementations, so it can be tested with the same `curl` commands.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，运行中的应用程序的 API 将以与其他实现相同的方式表现，因此可以使用相同的 `curl` 命令进行测试。
- en: Thanks to the MicroProfile OpenAPI compliance and Helidon OpenAPI UI module,
    when these dependencies are in our `pom.xml` file, we can see the documentation
    of the REST API in a web browser at [http://localhost:8080/openapi/ui](http://localhost:8080/openapi/ui)
    .
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了 MicroProfile OpenAPI 兼容性和 Helidon OpenAPI UI 模块，当这些依赖项在我们的 `pom.xml` 文件中时，我们可以在网页浏览器中看到
    REST API 的文档，网址为 [http://localhost:8080/openapi/ui](http://localhost:8080/openapi/ui)。
- en: '![Figure 11.5 – OpenAPI UI generated by Helidon](img/B21843_11_4.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5 – 由 Helidon 生成的 OpenAPI UI](img/B21843_11_4.png)'
- en: Figure 11.5 – OpenAPI UI generated by Helidon
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – 由 Helidon 生成的 OpenAPI UI
- en: We can see that, using the MicroProfile standard features, we get the same results
    when switching the frameworks from Quarkus to Helidon.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，使用 MicroProfile 标准功能，当我们从 Quarkus 切换到 Helidon 时，我们得到相同的结果。
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we summarized from a high-level perspective, the different
    frameworks that can be used to implement Java services exposing REST APIs. Using
    a historical overview, we explained the different goals and features that motivated
    the creation of these frameworks. We explained how vendor-neutral standards help
    prevent developer community fragmentation and lock-in to a particular implementation
    technology. By implementing parts of our example APIs in two MicroProfile-compliant
    frameworks (Quarkus and Helidon), we demonstrated that the various REST API design
    principles we went through in the previous chapters can be applied regardless
    of the framework used and lead to application code with the same basic structure.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从高层次的角度总结了可以用来实现暴露 REST API 的 Java 服务的不同框架。通过历史概述，我们解释了推动这些框架创建的不同目标和功能。我们解释了供应商中立标准如何帮助防止开发者社区碎片化和锁定到特定的实现技术。通过在我们的示例
    API 中实现两个 MicroProfile 兼容框架（Quarkus 和 Helidon）的部分，我们证明了我们在前几章中讨论的各种 REST API 设计原则可以应用于任何框架，并导致具有相同基本结构的应用程序代码。
