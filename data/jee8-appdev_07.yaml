- en: WebSocket
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebSocket
- en: Traditionally, web applications have been developed using the request/response
    model followed by the HTTP protocol. In this traditional request/response model,
    the request is always initiated by the client, then the server sends a response
    back to the client.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，Web应用程序是使用HTTP协议之后的请求/响应模型开发的。在这个传统的请求/响应模型中，请求始终由客户端发起，然后服务器将响应发送回客户端。
- en: There has never been a way for the server to send data to the client independently,
    that is, without having to wait for a request, until now. The WebSocket protocol
    allows fully duplex, two-way communication between the client (browser) and the
    server.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器从未有过独立向客户端发送数据的方式，也就是说，无需等待请求，直到现在。WebSocket协议允许客户端（浏览器）和服务器之间进行全双工、双向通信。
- en: Java EE 7 introduced the Java API for WebSocket, which allows us to develop
    WebSocket endpoints in Java.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 7引入了Java API for WebSocket，它允许我们在Java中开发WebSocket端点。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Developing WebSocket server endpoints
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发 WebSocket 服务器端点
- en: Developing WebSocket clients in JavaScript
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在JavaScript中开发WebSocket客户端
- en: Developing WebSocket clients in Java
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java中开发WebSocket客户端
- en: Developing a WebSocket server endpoint
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发 WebSocket 服务器端点
- en: There are two ways we can implement a WebSocket server endpoint via the Java
    API for WebSocket. We can either develop an endpoint programmatically, in which
    case we need to extend the `javax.websocket.Endpoint` class, or by decorating
    **Plain Old Java Objects** (**POJOs**) with WebSocket specific annotations. These
    two approaches are very similar, therefore, we will only be discussing the annotation
    approach in detail, and will briefly explain how to develop WebSocket server endpoints
    programmatically later in the chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两种方式使用 Java API for WebSocket 实现WebSocket服务器端点。我们既可以程序化地开发端点，在这种情况下，我们需要扩展`javax.websocket.Endpoint`类，也可以通过WebSocket特定注解装饰**普通Java对象**（**POJOs**）。这两种方法非常相似，因此，我们将在本章中详细讨论注解方法，并在稍后简要解释如何程序化地开发WebSocket服务器端点。
- en: In this chapter, we will develop a simple web-based chat application, taking
    full advantage of the Java API for WebSocket.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开发一个简单的基于Web的聊天应用程序，充分利用Java API for WebSocket。
- en: Developing an annotated WebSocket server endpoint
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发一个带注释的 WebSocket 服务器端点
- en: 'The following Java class illustrates how we can develop a WebSocket server
    endpoint by annotating a Java class:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Java类说明了我们如何通过注解Java类来开发WebSocket服务器端点：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The class level `@ServerEndpoint` annotation indicates that the class is a WebSocket
    server endpoint. The **URI** (**Uniform Resource Identifier**) of the server endpoint
    is the value specified between the parenthesis following the annotation (`"/websocketchat"`,
    in this example). WebSocket clients will use this URI to communicate with our
    endpoint.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 类级别的`@ServerEndpoint`注解表示该类是一个WebSocket服务器端点。服务器端点的**URI**（**统一资源标识符**）是注解后面的括号中指定的值（在这个例子中是`"/websocketchat"`）。WebSocket客户端将使用此URI与我们的端点进行通信。
- en: The `@OnOpen` annotation is used to decorate a method that needs to be executed
    whenever a WebSocket connection is opened from any of the clients. In our example,
    we are simply sending some output to the server log, but of course any valid server-side
    Java code can be placed here.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`@OnOpen`注解用于装饰一个方法，该方法需要在任何客户端打开WebSocket连接时执行。在我们的例子中，我们只是向服务器日志发送一些输出，但当然，任何有效的服务器端Java代码都可以放在这里。'
- en: Any method annotated with the `@OnMessage` annotation will be invoked whenever
    our server endpoint receives a message from any of the clients. Since we are developing
    a chat application, our code simply broadcasts the message it receives to all
    connected clients.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 任何被`@OnMessage`注解的方法都会在我们服务器端点从任何客户端接收到消息时被调用。由于我们正在开发一个聊天应用程序，我们的代码只是将接收到的消息广播给所有已连接的客户端。
- en: 'In our example, the `processMessage()` method is annotated with `@OnMessage`,
    and it takes two parameters: an instance of a class implementing the `javax.websocket.Session`
    interface, and a `String` containing the message that was received. Since we are
    developing a chat application, our WebSocket server endpoint simply broadcasts
    the received message to all connected clients.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`processMessage()`方法被`@OnMessage`注解，它接受两个参数：一个实现了`javax.websocket.Session`接口的类的实例，以及一个包含接收到的消息的`String`。由于我们正在开发一个聊天应用程序，我们的WebSocket服务器端点只是将接收到的消息广播给所有已连接的客户端。
- en: The `getOpenSessions()` method of the `Session` interface returns a set of `Session`
    objects representing all open sessions. We iterate through this set to broadcast
    the received message back to all connected clients by invoking the `getBasicRemote()`
    method on each `Session` instance, then invoking the `sendText()` method on the
    resulting `RemoteEndpoint.Basic` implementation returned by this call.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`Session`接口的`getOpenSessions()`方法返回一个表示所有打开会话的`Session`对象集合。我们遍历这个集合，通过在每个`Session`实例上调用`getBasicRemote()`方法，然后调用此调用返回的`RemoteEndpoint.Basic`实现上的`sendText()`方法，将接收到的消息广播回所有已连接的客户端。'
- en: The `getOpenSessions()` method on the `Session` interface returns all the open
    sessions at the time the method was invoked. It is possible for one or more of
    the sessions to have closed after the method was invoked, therefore, it is recommended
    to invoke the `isOpen()` method on a `Session` implementation before attempting
    to send data back to the client.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`Session`接口上的`getOpenSessions()`方法在调用该方法时返回所有打开的会话。在方法调用后，可能有一个或多个会话已经关闭，因此，在尝试向客户端发送数据之前，建议在`Session`实现上调用`isOpen()`方法。'
- en: Finally, we need to decorate a method with the `@OnClose` annotation if we need
    to handle the event when a client disconnects from the server endpoint. In our
    example, we simply log a message to the server log.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们需要处理客户端从服务器端点断开连接的事件，我们需要用`@OnClose`注解装饰一个方法。在我们的例子中，我们只是简单地将一条消息记录到服务器日志中。
- en: There is one additional annotation that we didn't use in our example. The `@OnError`
    annotation is used to decorate a method that needs to be invoked in the event
    of an error in sending or receiving data to or from the client.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在示例中没有使用的一个额外注解是`@OnError`注解，它用于装饰在发送或接收数据到或从客户端发生错误时需要调用的方法。
- en: As we can see, developing an annotated WebSocket server endpoint is straightforward;
    we simply need to add a few annotations and the application server will invoke
    our annotated methods as necessary.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，开发带有注释的WebSocket服务器端点是直接的；我们只需添加几个注解，应用程序服务器就会根据需要调用我们的注解方法。
- en: If we wish to develop a WebSocket server endpoint programmatically, we need
    to write a Java class that extends `javax.websocket.Endpoint`. This class has
    `onOpen()`, `onClose()`, and `onError()` methods, which are called at appropriate
    times during the endpoint's lifecycle. There is no method equivalent to the `@OnMessage`
    annotation to handle incoming messages from clients; the `addMessageHandler()`
    method needs to be invoked in the `Session`, passing an instance of a class implementing
    the `javax.websocket.MessageHandler` interface (or one of its subinterfaces) as
    its sole parameter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望以程序化的方式开发WebSocket服务器端点，我们需要编写一个扩展`javax.websocket.Endpoint`的Java类。这个类有`onOpen()`、`onClose()`和`onError()`方法，这些方法在端点生命周期中的适当时间被调用。没有与`@OnMessage`注解等效的方法来处理来自客户端的消息；需要在`Session`中调用`addMessageHandler()`方法，传递一个实现`javax.websocket.MessageHandler`接口（或其子接口）的类的实例作为其唯一参数。
- en: In general, it is easier and more straightforward to develop annotated WebSocket
    endpoints, as opposed to their programmatic counterparts, therefore, we recommend
    the annotated approach whenever possible.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，与程序化方式相比，开发带有注释的WebSocket端点更容易且更直接，因此，在可能的情况下，我们推荐使用注释方法。
- en: Developing WebSocket clients
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发WebSocket客户端
- en: Most WebSocket clients are implemented as web pages taking advantage of the
    JavaScript WebSocket API. We will cover how to do this in the next section.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数WebSocket客户端都是作为利用JavaScript WebSocket API的网页实现的。我们将在下一节中介绍如何做到这一点。
- en: The Java API for WebSocket provides a client API that allows us to develop WebSocket
    clients as standalone Java applications. We will be covering this capability later
    in the chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Java WebSocket API提供了客户端API，允许我们开发作为独立Java应用程序的WebSocket客户端。我们将在本章后面介绍这一功能。
- en: Developing JavaScript client-side WebSocket code
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发JavaScript客户端WebSocket代码
- en: In this section, we will cover how to develop client-side JavasScript code to
    interact with the WebSocket endpoint we developed in the previous section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何开发与我们在上一节中开发的WebSocket端点交互的客户端JavaScript代码。
- en: The client page for our WebSocket example is implemented as a JSF page using
    HTML5 friendly markup (as explained in [Chapter 2](9059bc2f-04fb-43df-a5c5-8b2cce80792e.xhtml),
    *JavaServer Faces*).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们WebSocket示例的客户端页面是一个使用HTML5友好标记的JSF页面（如第2章[9059bc2f-04fb-43df-a5c5-8b2cce80792e.xhtml]中所述，*JavaServer
    Faces*）。
- en: 'Our client page consists of a text area, where we can see what users of our
    application are saying (it is, after all, a chat application), and an input text
    we can use to send a message to other users:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户页面由一个文本区域组成，我们可以看到我们应用程序的用户在说什么（毕竟，这是一个聊天应用程序），以及一个我们可以用来向其他用户发送消息的输入文本：
- en: '![](img/0e0e17e7-5c52-416c-8398-0baee4327a32.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e0e17e7-5c52-416c-8398-0baee4327a32.png)'
- en: 'The markup for our client page looks like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们客户页面的标记如下所示：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The last line of our JavaScript code (`window.addEventListener("load", init);`)
    sets our JavaScript `init()` function to be executed as soon as the page loads.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 JavaScript 代码的最后一行 (`window.addEventListener("load", init);`) 将我们的 JavaScript
    `init()` 函数设置为在页面加载后立即执行。
- en: In the `init()` function, we initialize a new JavaScript WebSocket object, passing
    the URI of our server endpoint as a parameter. This lets our JavaScript code know
    the location of our server endpoint.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `init()` 函数中，我们初始化一个新的 JavaScript WebSocket 对象，将我们的服务器端点的 URI 作为参数传递。这使我们的
    JavaScript 代码知道我们的服务器端点的位置。
- en: The JavaScript WebSocket object has a number of function types, used to handle
    different events, such as opening the connection, receiving a message, and handling
    errors. We need to set these types to our own JavaScript functions so that we
    can handle these events, which is what we do in our `init()` function, right after
    invoking the constructor for the JavaScript WebSocket object. In our example,
    the functions we assigned to the WebSocket object simply delegate their functionality
    to standalone JavaScript functions.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript WebSocket 对象具有多种函数类型，用于处理不同的事件，例如打开连接、接收消息和处理错误。我们需要将这些类型设置为我们的 JavaScript
    函数，以便我们可以处理这些事件，这正是我们在 `init()` 函数中做的，紧随 JavaScript WebSocket 对象构造函数的调用之后。在我们的示例中，我们分配给
    WebSocket 对象的函数只是将它们的功能委托给独立的 JavaScript 函数。
- en: Our `websocketOpen()` function is called whenever the WebSocket connection is
    opened. In our example, we simply send a message to the browser's JavaScript console.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `websocketOpen()` 函数会在 WebSocket 连接打开时被调用。在我们的示例中，我们只是简单地向浏览器的 JavaScript
    控制台发送一条消息。
- en: Our `webSocketMessage()` function is invoked whenever the browser receives a
    web socket message from our WebSocket endpoint. In our example, we update the
    contents of the text area with the ID `chatWindow` with the contents of the message.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `webSocketMessage()` 函数会在浏览器从我们的 WebSocket 端点接收到 WebSocket 消息时被调用。在我们的示例中，我们使用消息的内容更新具有
    ID `chatWindow` 的文本区域的内容。
- en: Our `websocketError()` function is called whenever there is a WebSocket related
    error. In our example, we simply send a message to the browser's JavaScript console.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `websocketError()` 函数会在发生与 WebSocket 相关的错误时被调用。在我们的示例中，我们只是简单地向浏览器的 JavaScript
    控制台发送一条消息。
- en: Our JavaScript `sendMessage()` function sends a message to the WebSocket server
    endpoint, containing both the username and the contents of the text input with
    the ID `chatinput`. This function is called when the user clicks on the button
    with the ID `sendBtn`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 JavaScript `sendMessage()` 函数将消息发送到 WebSocket 服务器端点，包含用户名和具有 ID `chatinput`
    的文本输入的内容。当用户点击具有 ID `sendBtn` 的按钮时，会调用此函数。
- en: Our `closeConnection()` JavaScript function closes the connection to our WebSocket
    server endpoint. This function is called when the user clicks on the button with
    the ID `exitBtn`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `closeConnection()` JavaScript 函数关闭与我们的 WebSocket 服务器端点的连接。当用户点击具有 ID `exitBtn`
    的按钮时，会调用此函数。
- en: As we can see from this example, writing client-side JavaScript code to interact
    with WebSocket endpoints is fairly straightforward.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如此示例所示，编写客户端 JavaScript 代码以与 WebSocket 端点交互相当简单。
- en: Developing WebSocket clients in Java
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Java 中开发 WebSocket 客户端
- en: Although developing web-based WebSocket clients is currently the most common
    way of developing WebSocket clients, the Java API for WebSocket provides a client
    API we can use to develop WebSocket clients in Java.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然目前开发基于 Web 的 WebSocket 客户端是开发 WebSocket 客户端最常见的方式，但 Java API for WebSocket
    提供了一个客户端 API，我们可以使用它来在 Java 中开发 WebSocket 客户端。
- en: 'In this section, we will be developing a simple WebSocket client using the
    client API of the Java API for WebSocket. The final product looks like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 Java API for WebSocket 的客户端 API 开发一个简单的 WebSocket 客户端。最终产品看起来像这样：
- en: '![](img/e6ded8e6-c2a0-4abb-bbc9-6ca41962c06a.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e6ded8e6-c2a0-4abb-bbc9-6ca41962c06a.png)'
- en: However, we won't be covering the GUI code (developed using the Swing framework),
    since it is not relevant to the discussion. The complete code for the example,
    including the GUI code, can be downloaded from the Packt Publishing website.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不会涵盖GUI代码（使用Swing框架开发的），因为它与讨论无关。示例的完整代码，包括GUI代码，可以从Packt Publishing网站下载。
- en: Just as with WebSocket server endpoints, Java WebSocket clients can be developed
    either programmatically or by using annotations. Once again, we will cover only
    the annotation approach; developing a programmatic client is very similar to the
    way programmatic server endpoints are developed, which is to say, programmatic
    clients must extend `javax.websocket.Endpoint` and override the appropriate methods.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 就像WebSocket服务器端点一样，Java WebSocket客户端可以编程开发或使用注解开发。再次强调，我们只会介绍注解方法；编程客户端的开发方式与编程服务器端点非常相似，也就是说，编程客户端必须扩展`javax.websocket.Endpoint`并重写适当的方法。
- en: 'Without further ado, here is the code for our Java WebSocket client:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 不再赘述，以下是我们的Java WebSocket客户端代码：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The class-level `@ClientEndPoint` annotation denotes our class as a WebSocket
    client; all Java WebSocket clients must be annotated with this annotation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 类级别的`@ClientEndPoint`注解表示我们的类是一个WebSocket客户端；所有Java WebSocket客户端都必须使用这个注解。
- en: The code to establish a connection to the WebSocket server endpoint is in our
    class constructor. First, we need to invoke `ContainerProvider.getWebSocketContainer()`
    to obtain an instance of `javax.websocket.WebSocketContainer`. We then establish
    the connection by invoking the `connectToServer()` method on our `WebSocketContainer`
    instance, passing a class annotated with `@ClientEndpoint` as the first parameter
    (in our example, we use this because the connection code is inside our WebSocket
    Java client code), and a URI object containing the WebSocket server endpoint URI
    as the second parameter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 建立与WebSocket服务器端点的连接代码位于我们的类构造函数中。首先，我们需要调用`ContainerProvider.getWebSocketContainer()`来获取`javax.websocket.WebSocketContainer`的一个实例。然后，通过在`WebSocketContainer`实例上调用`connectToServer()`方法来建立连接，第一个参数是一个带有`@ClientEndpoint`注解的类（在我们的例子中，我们使用它是因为连接代码位于我们的WebSocket
    Java客户端代码中），第二个参数是一个包含WebSocket服务器端点URI的URI对象。
- en: After the connection is established, we are ready to respond to WebSocket events.
    Alert readers may have noticed that the exact same annotations we used to develop
    our server endpoint are used again in our client code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 连接建立后，我们就可以准备响应WebSocket事件了。细心的读者可能已经注意到，我们用于开发服务器端点的确切相同的注解再次在我们的客户端代码中使用。
- en: Any method annotated with the `@OnOpen` annotation will be invoked automatically
    when the connection to the WebSocket server endpoint is established. The method
    must return void and can have an optional parameter of type `javax.websocket.Session`.
    In our example, we send some output to the console and initialize a class variable
    with the `Session` instance we received as a parameter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`@OnOpen`注解的任何方法都会在连接到WebSocket服务器端点时自动被调用。该方法必须返回void，并且可以有一个可选的`javax.websocket.Session`类型的参数。在我们的例子中，我们向控制台发送一些输出，并用我们接收到的`Session`实例初始化一个类变量。
- en: Methods annotated with the `@OnClose` annotation are invoked whenever the WebSocket
    session is closed. The annotated method can have an optional `javax.websocket.Session`
    parameter and an optional `CloseReason`parameter. In our example, we chose to
    use only the `CloseReason` optional parameter, since this class has a handy `getReasonPhrase()`
    method that provides a short explanation of why the session was closed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`@OnClose`注解的方法会在WebSocket会话关闭时被调用。被注解的方法可以有一个可选的`javax.websocket.Session`参数和一个可选的`CloseReason`参数。在我们的例子中，我们选择只使用`CloseReason`可选参数，因为这个类有一个方便的`getReasonPhrase()`方法，可以提供会话关闭的简短解释。
- en: The `@OnError` annotation is used to decorate any methods that will be called
    when an error occurs. Methods annotated with `@OnError` must have a `java.lang.Throwable`
    parameter (the parent class of `java.lang.Exception`), and can have an optional
    `type session` parameter. In our example, we simply send the stack trace of the
    `Throwable` parameter to `stderr`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`@OnError`注解用于装饰在发生错误时将被调用的任何方法。带有`@OnError`注解的方法必须有一个`java.lang.Throwable`参数（`java.lang.Exception`的父类），并且可以有一个可选的`type
    session`参数。在我们的例子中，我们只是将`Throwable`参数的堆栈跟踪发送到`stderr`。'
- en: Methods annotated with `@OnMessage` are invoked whenever an incoming WebSocket
    message is received. `@OnMessage` methods can have different parameters depending
    on the type of message received and how we wish to handle it. In our example,
    we used the most common case, receiving a text message. In this particular case,
    we need a `String` parameter, which will hold the contents of the message, and
    an optional `Session` parameter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 被注解为`@OnMessage`的方法会在接收到任何传入的WebSocket消息时被调用。`@OnMessage`方法可以根据接收到的消息类型以及我们希望如何处理它来具有不同的参数。在我们的例子中，我们使用了最常见的情况，即接收一个文本消息。在这种情况下，我们需要一个`String`参数，它将保存消息的内容，以及一个可选的`Session`参数。
- en: Refer to the JavaDoc documentation for `@OnMessage` at [http://docs.oracle.com/javaee/7/api/javax/websocket/OnMessage.html](https://javaee.github.io/javaee-spec/javadocs/javax/websocket/OnMessage.html)
    for information on how to handle other types of messages.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何处理其他类型消息的信息，请参阅`@OnMessage`的JavaDoc文档，链接为[http://docs.oracle.com/javaee/7/api/javax/websocket/OnMessage.html](https://javaee.github.io/javaee-spec/javadocs/javax/websocket/OnMessage.html)。
- en: In our example, we simply update the Chat Window text area, appending the received
    message to its contents.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们只是简单地更新了聊天窗口的文本区域，将接收到的消息追加到其内容中。
- en: To send a WebSocket message, we invoke the `getBasicRemote()` method on our
    `Session` instance, then invoke the `sendText()` method on the resulting `R.emoteEndpoint`.
    A basic implementation is returned by this call (if this looks familiar, it is
    because we did the exact same thing in the WebSocket server endpoint code). In
    our example, we do this in the `sendMessage()` method.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送WebSocket消息，我们在`Session`实例上调用`getBasicRemote()`方法，然后在该`R.remoteEndpoint`上调用`sendText()`方法。此调用返回一个基本实现（如果这看起来很熟悉，那是因为我们在WebSocket服务器端点代码中做了完全相同的事情）。在我们的例子中，我们在`sendMessage()`方法中这样做。
- en: Additional information about the Java API for WebSocket
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于Java WebSocket API的附加信息
- en: In this chapter, we covered the bulk of the functionality provided by the Java
    API for WebSocket. For additional information, refer to the user guide for Tyrus,
    the Java API for WebSocket reference implementation, at [https://tyrus.java.net/documentation/1.3.1/user-guide.html](https://tyrus.java.net/documentation/1.3.1/user-guide.html).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Java WebSocket API提供的功能的大部分。有关更多信息，请参阅Tyrus用户指南，它是Java WebSocket API的参考实现，链接为[https://tyrus.java.net/documentation/1.3.1/user-guide.html](https://tyrus.java.net/documentation/1.3.1/user-guide.html)。
- en: Summary
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the Java API for WebSocket, a Java EE API for developing
    WebSocket server endpoints and clients. We first saw how to develop WebSocket
    server endpoints by taking advantage of the Java API for WebSocket. Then, we covered
    how to develop web-based WebSocket clients using JavaScript. Finally, we explained
    how to develop WebSocket client applications in Java.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Java WebSocket API，这是一个Java EE API，用于开发WebSocket服务器端点和客户端。我们首先看到了如何利用Java
    WebSocket API开发WebSocket服务器端点。然后，我们介绍了如何使用JavaScript开发基于Web的WebSocket客户端。最后，我们解释了如何在Java中开发WebSocket客户端应用程序。
