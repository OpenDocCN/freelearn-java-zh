- en: 13\. Database Interaction and the Application Layer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13. 数据库交互和应用层
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter we will create and connect to an Apache Derby instance on your
    local machine. We will also create and use a connection pool for efficient database
    interactions, and create and load a database schema. We will then create, read,
    update, and delete data using `clojure.java.jdbc`.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在您的本地机器上创建并连接到 Apache Derby 实例。我们还将创建并使用连接池以实现高效的数据库交互，创建并加载数据库模式。然后我们将使用
    `clojure.java.jdbc` 创建、读取、更新和删除数据。
- en: By the end of this chapter, you will be able to implement an application layer
    sitting on top of a database instance, ingest data from a CSV file on disk, and
    write it to the database via an application layer API.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够实现一个位于数据库实例之上的应用层，从磁盘上的 CSV 文件中摄取数据，并通过应用层 API 将其写入数据库。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: So far, we have been interacting with **Comma-Separated Values** (**CSV**) files
    from disk and in memory with no persistence. Each time we restart our REPL, we
    lose all the data manipulation or ELO calculations we've made up to that point
    and must restart from scratch. If there were a means of persisting this state
    each time, we could begin where we left off last time. Indeed, we could imagine
    building an ELO calculation application with a web interface or even a ClojureScript
    frontend once we've established a means of persistent storage so that our progress
    is maintained from session to session.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在磁盘和内存中与 **逗号分隔值**（**CSV**）文件进行交互，但没有持久化。每次我们重启我们的 REPL，我们就会丢失之前所做的所有数据操作或
    ELO 计算结果，必须从头开始。如果每次都能持久化这种状态，我们就可以从上次离开的地方继续。实际上，一旦我们建立了一种持久化存储的方法，我们就可以想象构建一个带有
    Web 界面或 ClojureScript 前端的 ELO 计算应用程序，以便我们的进度可以从会话持续到会话。
- en: When considering persistence, most applications will reach for a relational
    database implementation (for example, MySQL, Oracle, or PostgreSQL). There are
    many implementations to choose from, each with their own strengths and weaknesses.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑持久化时，大多数应用程序会寻求一个关系型数据库实现（例如 MySQL、Oracle 或 PostgreSQL）。有许多实现可供选择，每个都有自己的优点和缺点。
- en: We'll use Apache Derby as an on-disk `Driver` table and a `Car` table, with
    a reference linking them. We'll cover the means of describing this relation in
    the *Creating Database Schemas* section later.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Apache Derby 作为磁盘上的 `Driver` 表和 `Car` 表，并通过引用将它们链接起来。我们将在后面的 *创建数据库模式*
    部分介绍描述这种关系的方法。
- en: Going into a little more detail about our potential ELO calculation application,
    there are numerous topics to consider when it comes to persistence. We'll need
    to determine what data we want to store, and then determine the model that best
    describes that data and any relations between different parts of the model. There
    are constraints we'll have to consider; for example, how will we uniquely identify
    the entities we're persisting? This will be codified in our database schema using
    the **Data Definition Language** (**DDL**).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们潜在的 ELO 计算应用程序，在考虑持久化时有许多主题需要考虑。我们需要确定我们想要存储哪些数据，然后确定最佳描述这些数据及其模型不同部分之间关系的模型。我们将不得不考虑一些约束；例如，我们将如何唯一标识我们正在持久化的实体？这将在我们的数据库模式中使用
    **数据定义语言**（**DDL**）进行编码。
- en: With a schema defined, we need a means of inserting, retrieving, updating, and
    deleting data. Since Apache Derby is a **Structured Query Language** (**SQL**)-based
    RDBMS, this is the most appropriate means of interacting with the database for
    these purposes. We'll construct SQL commands that cover each of the preceding
    requirements. These commands will understand the underlying data model, how the
    relations are constructed, and how to access the relevant parts of the model we're
    interested in. Apache Derby will execute the SQL commands for us and return the
    result.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了模式后，我们需要一种插入、检索、更新和删除数据的方法。由于 Apache Derby 是基于 **结构化查询语言**（**SQL**）的 RDBMS，这是这些目的与数据库交互的最合适方式。我们将构建覆盖前面所有要求的
    SQL 命令。这些命令将理解底层数据模型，关系的构建方式以及如何访问我们感兴趣的模型的相关部分。Apache Derby 将为我们执行 SQL 命令并返回结果。
- en: In terms of interacting with this database from Clojure, we'll primarily use
    `clojure.java.jdbc`, which is a longstanding, stable, low-level library for talking
    to databases using **Java Database Connectivity** (**JDBC**).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在从 Clojure 与此数据库交互方面，我们将主要使用 `clojure.java.jdbc`，这是一个历史悠久、稳定、低级别的库，用于通过 **Java
    数据库连接**（**JDBC**）与数据库通信。
- en: It should be noted that the maintainers of this library have created a successor,
    `next.jdbc`, with a focus on simplicity and performance. An interesting task for
    you would be to take the examples provided here and rework them to conform to
    the `next.jdbc` API.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，这个库的维护者已经创建了一个后继者，`next.jdbc`，它专注于简单性和性能。一个有趣的练习是将这里提供的示例重新工作，以符合 `next.jdbc`
    API。
- en: Connecting to a Database
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: As alluded to previously, we'll be leveraging JDBC for all our database interactions.
    JDBC allows a Java client to connect to an RDBMS using a well-defined **Application
    Programming Interface** (**API**). This API gives us a clear contract between
    ourselves (the client) and our database (the server). Since Clojure sits atop
    the **Java Virtual Machine** (**JVM**), JDBC is the natural choice for us.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将利用 JDBC 进行所有数据库交互。JDBC 允许 Java 客户端使用一个定义良好的 **应用程序编程接口**（**API**）连接到
    RDBMS。这个 API 在我们（客户端）和我们的数据库（服务器）之间提供了一个清晰的合同。由于 Clojure 位于 **Java 虚拟机**（**JVM**）之上，因此
    JDBC 是我们的自然选择。
- en: For those familiar with JDBC, you'll have encountered the (occasionally unwieldy)
    JDBC URL. These URLs vary depending on the RDBMS, where the database is located,
    and how it is secured, among other things. In essence, they are a database connection
    descriptor.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉 JDBC 的人来说，你可能会遇到（偶尔难以操作的）JDBC URL。这些 URL 根据不同的 RDBMS、数据库的位置以及如何进行安全保护等因素而有所不同。本质上，它们是一个数据库连接描述符。
- en: Fortunately, `clojure.java.jdbc` abstracts this away with its concept of `db-spec`
    (a database specification). `db-spec` is a simple map structure holding details
    pertinent to the connection we're looking to make. This `db-spec` structure can
    then be passed to any `clojure.java.jdbc` API call and it will build the connection
    for us behind the scenes. This specification is fairly broad and can take many
    different forms. We'll touch on a few as we progress.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`clojure.java.jdbc` 通过其 `db-spec`（数据库规范）概念抽象了这一点。`db-spec` 是一个简单的映射结构，包含我们想要建立的连接的相关细节。然后可以将这个
    `db-spec` 结构传递给任何 `clojure.java.jdbc` API 调用，它将在幕后为我们建立连接。这个规范相当广泛，可以采取多种不同的形式。随着我们的进展，我们将讨论其中的一些。
- en: An important point to note is that `clojure.java.jdbc` expects the driver of
    your target database to be available on the classpath prior to making an API call.
    The driver acts as a means of converting your JDBC-based API calls into something
    your RDBMS understands. Each RDBMS will, therefore, have its own specific driver.
    Without this, any database operations will throw an exception.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的要点是，`clojure.java.jdbc` 预期在执行 API 调用之前，目标数据库的驱动程序必须存在于类路径上。驱动程序充当将基于 JDBC
    的 API 调用转换为 RDBMS 理解的某种手段。因此，每个 RDBMS 都将有自己的特定驱动程序。如果没有这个，任何数据库操作都会抛出异常。
- en: 'For example, if we were to define a `deps.edn` with only the `clojure.java.jdbc`
    dependency, and then attempt a `jdbc/query` operation, this would be the result:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们定义一个只包含 `clojure.java.jdbc` 依赖项的 `deps.edn` 文件，然后尝试执行 `jdbc/query` 操作，这将得到以下结果：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, we encounter our first concrete `db-spec` definition. This is the `DriverManager`
    form of `db-spec` and is the preferred format for `clojure.java.jdbc`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们遇到了第一个具体的 `db-spec` 定义。这是 `DriverManager` 形式的 `db-spec`，是 `clojure.java.jdbc`
    的首选格式：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Breaking down our `db-spec` definition, we''re interacting with an Apache Derby
    database (this is the driver we''re looking for). We''re naming our database `derby-local`
    in the current working directory. The `:create true` flag will create the database
    file if it does not already exist:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 分析我们的 `db-spec` 定义，我们正在与 Apache Derby 数据库交互（这是我们正在寻找的驱动程序）。我们在当前工作目录中将数据库命名为
    `derby-local`。`:create true` 标志将在数据库文件不存在时创建该文件：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output is as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 13.1: Error due to no driver being added'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.1：由于未添加驱动程序导致的错误'
- en: '](img/B14502_13_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14502_13_01.jpg)'
- en: 'Figure 13.1: Error due to no driver being added'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1：由于未添加驱动程序导致的错误
- en: Encountering this is generally an indication that you have not added the driver
    to your `deps.edn` file or equivalent.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 遇到这种情况通常表明你没有将驱动程序添加到你的 `deps.edn` 文件或等效文件中。
- en: 'The *Releases and Dependencies* section of the `clojure.java.jdbc` GitHub page
    contains links to drivers for popular RDBMSes. Once the appropriate driver version
    has been located, add it to your `deps.edn` file. Consider the following example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`clojure.java.jdbc` 的 GitHub 页面的 *发布和依赖* 部分包含了对流行 RDBMS 的驱动程序的链接。一旦找到适当的驱动程序版本，请将其添加到您的
    `deps.edn` 文件中。以下是一个示例：'
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, Apache Derby provides a package containing its database implementation
    alongside an embedded driver, meaning we don't need an explicit driver dependency
    in our project.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Apache Derby提供了一个包含其数据库实现和嵌入式驱动程序的包，这意味着我们不需要在我们的项目中显式添加驱动程序依赖项。
- en: 'Exercise 13.01: Establishing a Database Connection'
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.01：建立数据库连接
- en: 'In this exercise, we will connect to a local on-disk database:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将连接到本地磁盘数据库：
- en: 'We''ll begin by setting up our dependencies. Create a file named `deps.edn`
    in your current working directory and paste in the following content:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先设置我们的依赖项。在你的当前工作目录中创建一个名为`deps.edn`的文件，并粘贴以下内容：
- en: '[PRE4]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It should be noted, at the time of writing, that Apache Derby version 10.15.1.3
    is available. This should *not* be used with `clojure.java.jdbc` `0.7.9`! The
    maintainer of `clojure.java.jdbc` advises that it is untested against 10.15.x.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应该注意的是，在撰写本文时，Apache Derby版本10.15.1.3是可用的。**不应**与`clojure.java.jdbc` `0.7.9`一起使用！`clojure.java.jdbc`的维护者建议它未经10.15.x测试。
- en: 'Require `clojure.java.jdbc` and alias (a temporary name) it as `jdbc` for convenience:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要`clojure.java.jdbc`并将其别名（一个临时名称）作为`jdbc`以便于使用：
- en: '[PRE5]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we use the `db-spec` definition from the preceding introduction. Introduce
    a concrete instance of a `db-spec` definition:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们使用前面介绍中的`db-spec`定义。引入一个具体的`db-spec`定义实例：
- en: '[PRE6]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Test that we can obtain a connection to this database:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试我们能否获取到这个数据库的连接：
- en: '[PRE7]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output is as follows:'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 13.2: Obtaining a connection to the database'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图13.2：获取数据库连接'
- en: '](img/B14502_13_02.jpg)'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B14502_13_02.jpg)'
- en: 'Figure 13.2: Obtaining a connection to the database'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2：获取数据库连接
- en: Note
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding output is the `toString` representation of our connection. The
    content is of no real consequence as we are not concerned with the internal representation
    of the connection object.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出是我们连接的`toString`表示形式。内容并无实际意义，因为我们不关心连接对象的内部表示。
- en: Great! We have a means of creating an Apache Derby instance on disk and have
    established a connection successfully. This `db-spec` definition is, therefore,
    valid and can be used anywhere the `db-spec` definition is accepted.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们有了在磁盘上创建Apache Derby实例的方法，并且已经成功建立了连接。因此，这个`db-spec`定义是有效的，可以在接受`db-spec`定义的任何地方使用。
- en: Note
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Any time we wish to remove our local database and start over, we can do so by
    removing the directory matching our database name in our current working directory.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 任何时候我们希望删除我们的本地数据库并重新开始，我们都可以通过删除当前工作目录中与我们的数据库名称匹配的目录来实现。
- en: Introduction to Connection Pools
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接池简介
- en: Although it's convenient for `clojure.java.jdbc` to create our database connections
    for us (it does this on each API call when we pass it a `db-spec` definition),
    there is a resulting performance overhead we should be aware of. This can become
    burdensome as establishing a connection (particularly to a remote machine) can
    often take many times longer than our query will actually take to execute! This
    is, therefore, an expensive operation that we'd like to avoid. Connection pooling
    is one such way of avoiding this overhead.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`clojure.java.jdbc`为我们创建数据库连接很方便（它在每次API调用时都会这样做，当我们传递一个`db-spec`定义时），但由此产生的性能开销我们应该注意。这可能会变得很麻烦，因为建立连接（尤其是连接到远程机器）通常比我们的查询实际执行所需的时间长得多！因此，这是一个昂贵的操作，我们希望避免。连接池就是这样一种避免这种开销的方法。
- en: When we talk of a connection pool, we're essentially talking about establishing
    one or more connections ahead of time and making them available to our application
    anytime a database connection is required. In this way, we deal with the connection
    overhead once on application startup and benefit from connection reuse from that
    point onward.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论连接池时，我们实际上是在谈论提前建立一个或多个连接，并在需要数据库连接时使它们可用给我们的应用程序。这样，我们在应用程序启动时一次性处理连接开销，并从那时起受益于连接重用。
- en: '`clojure.java.jdbc` does not itself offer a connection pooling implementation,
    but it does integrate well with a number of pooling libraries, including `c3p0`
    and `hikari-cp`. We''ll focus on `hikari-cp` as it is a Clojure wrapper for the
    lightning-quick `hikariCP` connection with a super-simple API.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`clojure.java.jdbc`本身不提供连接池实现，但它与包括`c3p0`和`hikari-cp`在内的多个连接池库很好地集成。我们将重点介绍`hikari-cp`，因为它是一个Clojure包装器，用于闪电般的`hikariCP`连接，具有超级简单的API。'
- en: '`hikari-cp` provides an API that allows us to construct a connection-pooled
    data source; we can use this to construct an alternative `db-spec` definition
    to use in place of our `DriverManager` based `db-spec` with no other changes required.
    `hikari-cp` will manage the pool of connections for us.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`hikari-cp` 提供了一个 API，允许我们构建一个连接池数据源；我们可以使用这个来构建一个替代的 `db-spec` 定义，以替代我们的基于
    `DriverManager` 的 `db-spec`，无需进行其他更改。`hikari-cp` 将为我们管理连接池。'
- en: 'Exercise 13.02: Creating a Connection Pool'
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.02：创建连接池
- en: 'In this exercise, we will create an alternative `db-spec` definition that can
    be used in place of the one created in *Step 3* of *Exercise 13.01*, *Establishing
    a Database Connection*. The benefit will be an increase in the speed of database
    interactions since a connection does not need to be established afresh for each
    interaction:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个替代的 `db-spec` 定义，它可以替代在 *练习 13.01* 的 *步骤 3* 中创建的数据库连接。好处是提高数据库交互的速度，因为不需要为每次交互重新建立连接：
- en: 'Add the `hikari-cp` dependency into our application:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `hikari-cp` 依赖项添加到我们的应用程序中：
- en: '[PRE8]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, depending on our precise needs, we have a few different means of constructing
    a valid data source. When we are starting from scratch and are expected to create
    the database as well as establish a connection, then we will need to reach for
    the appropriate JDBC URL. The Apache Derby URLs are less troublesome than others
    to construct and follow this simple syntax:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，根据我们精确的需求，我们有几种不同的方法来构建一个有效的数据源。当我们从头开始，并且需要创建数据库以及建立连接时，我们将需要找到合适的 JDBC
    URL。Apache Derby 的 URL 构建起来比其他数据库要简单，遵循以下简单的语法：
- en: '[PRE9]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: More details on Derby JDBC database connection URL can be found at [https://packt.live/2Fnnx9f](https://packt.live/2Fnnx9f).
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更多关于 Derby JDBC 数据库连接 URL 的详细信息可以在 [https://packt.live/2Fnnx9f](https://packt.live/2Fnnx9f)
    找到。
- en: 'Given this, we can define our `db-spec` definition (using the `datasource`
    format) like so:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们可以像这样定义我们的 `db-spec` 定义（使用 `datasource` 格式）：
- en: '[PRE10]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To break this down, we're connecting to an Apache Derby instance where the database
    is named `derby-local`. You will recall that `create=true` instructs the database
    to be created if not already present.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了分解这个问题，我们正在连接到一个名为 `derby-local` 的 Apache Derby 实例。您会记得，`create=true` 指示数据库如果不存在则创建。
- en: 'Alternatively, if we know the database already exists, then the `create=true`
    flag will not be required. We could amend the JDBC URL or allow `hikari-cp` to
    build it for us:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，如果我们已经知道数据库已经存在，那么不需要 `create=true` 标志。我们可以修改 JDBC URL 或者允许 `hikari-cp` 为我们构建它：
- en: '[PRE11]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that, here, we are required to specify the `datasource-class-name`, which,
    in this case, is the embedded version, since we're running locally.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在这里，我们需要指定 `datasource-class-name`，在这种情况下，是嵌入式版本，因为我们是在本地运行。
- en: 'Regardless of the means we''ve used to construct our data source, we can pass
    this to the `clojure.java.jdbc` library as an alternative `db-spec` definition:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论我们使用什么方法构建我们的数据源，我们都可以将其传递给 `clojure.java.jdbc` 库作为替代的 `db-spec` 定义：
- en: '[PRE12]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output is as follows:'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 13.3: Printing the output'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 13.3：打印输出'
- en: '](img/B14502_13_03.jpg)'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_13_03.jpg)'
- en: 'Figure 13.3: Printing the output'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3：打印输出
- en: We've now defined and tested two different `db-spec` formats successfully, demonstrating
    the flexibility offered by `clojure.java.jdbc`. It should be noted that a considerable
    number of alternatives are also acceptable, including `:connection-uri` (a JDBC
    URL) and `:connection` (an already established connection, rarely required).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经成功定义并测试了两种不同的 `db-spec` 格式，展示了 `clojure.java.jdbc` 提供的灵活性。应该注意的是，相当多的替代方案也是可接受的，包括
    `:connection-uri`（一个 JDBC URL）和 `:connection`（一个已经建立的连接，很少需要）。
- en: Note
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can refer to http://clojure.github.io/java.jdbc/#clojure.java.jdbc/get-connection
    for full details of the supported `db-spec` definition.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考 http://clojure.github.io/java.jdbc/#clojure.java.jdbc/get-connection 以获取支持的
    `db-spec` 定义的全部详细信息。
- en: To summarize, `clojure.java.jdbc` is flexible in what it consumes. Therefore,
    we'll be working with a connection-pooled data source as we start to interact
    more seriously with our newly created database.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，`clojure.java.jdbc` 在它所消费的内容上非常灵活。因此，当我们开始更认真地与我们的新创建的数据库交互时，我们将使用连接池数据源。
- en: Creating Database Schemas
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数据库模式
- en: 'We have our database connection. Before we begin to persist and query data,
    we must define our database model, or "schema" as it is more commonly known. This
    will take the form of the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了数据库连接。在我们开始持久化和查询数据之前，我们必须定义我们的数据库模型，或者更常见地称为“模式”。这将是以下形式：
- en: Tables
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表
- en: Fields/columns within tables
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表中的字段/列
- en: Relationships across tables
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表之间的关系
- en: Let's consider the example of a sports activity tracker, which our tennis superstars
    might use in their spare time. We'd like to store application users and activities.
    Let's look at how we could model those using two tables.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个体育活动追踪器的例子，我们的网球超级巨星可能在他们的业余时间使用。我们希望存储应用程序用户和活动。让我们看看我们如何使用两个表来模拟这些。
- en: The `app_user` table will store the first name, surname, height, and weight.
    The activity table will store the date, activity type, distance, and duration.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`app_user`表将存储名字、姓氏、身高和体重。活动表将存储日期、活动类型、距离和持续时间。'
- en: Primary Keys
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主键
- en: It's important to note that there is nothing unique in the information we're
    storing. How would we correctly load a user's height and weight when we only have
    their name to query on? For example, multiple users could be created with the
    same name, and then we'd run into issues regarding correct ownership of activities.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到我们存储的信息没有独特之处。当我们只有名字可以查询时，我们如何正确地加载用户的身高和体重？例如，可能有多个用户使用相同的名字创建，然后我们会遇到关于活动正确所有权的难题。
- en: We need to introduce `insert` statements; however, it is useful to leverage
    a feature of Apache Derby where it can allocate a unique ID on our behalf, and
    then communicate that back to us on insertion.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要引入`insert`语句；然而，利用Apache Derby的一个特性是有用的，它可以代表我们分配一个唯一的ID，然后在插入时将其传达给我们。
- en: Adding `GENERATED ALWAYS AS IDENTITY` to a column definition will instruct Apache
    Derby to auto-allocate a monotonically increasing integer ID on the insertion
    of each new row in our table. This removes any overhead we might have in constructing
    one and guarantees its uniqueness.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 将`GENERATED ALWAYS AS IDENTITY`添加到列定义中，将指示Apache Derby在向我们的表中插入每一行新数据时自动分配一个单调递增的整数ID。这消除了我们可能有的构建一个ID的开销，并保证了其唯一性。
- en: Foreign Keys
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外键
- en: When considering an activity, we can observe that one cannot exist without the
    prior existence of an `app_user`; that is, an activity must reference an existing
    entry in the `app_user` table. This is where the concept of a **foreign key**
    comes in.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑一个活动时，我们可以观察到，一个活动不能在没有`app_user`存在的情况下存在；也就是说，一个活动必须引用`app_user`表中的一个现有条目。这就是外键概念出现的地方。
- en: A foreign key is a means of creating a relationship between a parent table and
    a child table. We can define a foreign key in our activity table, which references
    the primary key of our `app_user` table. When we create an activity, we must have
    the primary key of the `app_user` table available to us such that we can add it
    to our activity. With this linkage/relationship in place, we can then construct
    a query for all activities belonging to a user, for example.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 外键是创建父表和子表之间关系的一种方式。我们可以在活动表中定义一个外键，它引用我们的`app_user`表的主键。当我们创建一个活动时，我们必须有`app_user`表的主键可用，这样我们才能将其添加到我们的活动中。有了这种链接/关系，我们就可以构建一个查询，查询属于某个用户的所有活动，例如。
- en: 'The definition of a simple foreign key would look like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 简单外键的定义看起来像这样：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Additionally, we generally add `ON DELETE CASCADE` to this definition, indicating
    that entries in the child table should be deleted when the corresponding entries
    are deleted from the parent table. This is important if the entry in the activity
    table cannot exist as a standalone entity; that is, it only makes sense in the
    context of its association with an `app_user`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们通常还会添加`ON DELETE CASCADE`到这个定义中，表示当从父表中删除相应的条目时，子表中的条目也应该被删除。如果活动表中的条目不能作为一个独立的实体存在，这是很重要的；也就是说，它只有在与`app_user`关联的上下文中才有意义。
- en: 'Exercise 13.03: Defining and Applying a Database Schema'
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.03：定义和应用数据库模式
- en: 'Given our table requirements mentioned previously, we''ll now codify those
    using DDL (that is, the actual SQL commands we''ll use to create these structures):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 给定之前提到的表要求，我们现在将使用DDL（即我们将使用以创建这些结构的实际SQL命令）来规范这些要求：
- en: 'Representing this in DDL, we will have something like this:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在DDL中表示，我们将有如下内容：
- en: '[PRE14]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Each of our preceding symbols is suffixed with `-ddl`. This is the syntax that's
    typically used for describing database schemas.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们前面的每个符号都带有 `-ddl` 后缀。这是通常用于描述数据库架构的语法。
- en: '`clojure.java.jdbc` provides a helper function of sorts that can construct
    a DDL statement for us. Although, the only real benefits for our use case are
    the ability to switch the format of the entities (table names, column names, and
    types) as well as the usage of keywords in place of parts of the manually constructed
    string. The equivalent function execution that would generate the `create-app-user-ddl`
    is as follows:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`clojure.java.jdbc` 提供了一种辅助函数，可以为我们构造 DDL 语句。尽管如此，对于我们这个用例来说，唯一真正的优势是能够切换实体的格式（表名、列名和数据类型），以及使用关键字代替手动构造字符串的部分。生成
    `create-app-user-ddl` 的等效函数执行如下：'
- en: '[PRE15]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Looking at the `clojure.java.jdbc` API, we may intuitively expect that we can
    execute these DDL statements using the `jdbc/execute!` function. We can (this
    approach will work for the creation of single tables), however, if we wish to
    create more than one table, make use of `db-do-commands`, which accepts one or
    more command statements to be executed within a transaction:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察到 `clojure.java.jdbc` API，我们可能会直观地期望可以使用 `jdbc/execute!` 函数执行这些 DDL 语句。我们可以（这种方法适用于创建单个表），然而，如果我们希望创建多个表，则可以使用
    `db-do-commands`，它接受一个或多个要在事务中执行的命令语句：
- en: '[PRE16]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Rerunning the preceding command results in an error indicating the table already
    exists.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重新运行前面的命令会导致错误，指示表已存在。
- en: 'The output is as follows:'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 13.4: The execution error'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 13.4：执行错误'
- en: '](img/B14502_13_04.jpg)'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_13_04.jpg)'
- en: 'Figure 13.4: The execution error'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4：执行错误
- en: 'It should be noted that, in general, using `CREATE TABLE IF NOT EXISTS` is
    sufficient to avoid this. However, Apache Derby does not support this syntax.
    Avoidance of this error would involve writing custom code to do the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 应该指出，通常使用 `CREATE TABLE IF NOT EXISTS` 就足够避免这种情况。然而，Apache Derby 不支持此语法。避免此错误将涉及编写自定义代码来完成以下操作：
- en: Attempt a `SELECT` statement from said table and detect a `table does not exist`
    error before performing the creation of the table.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行创建表之前，尝试从该表执行 `SELECT` 语句并检测到 `table does not exist` 错误。
- en: Attempt the creation and gracefully handle the `table already exists` error
    message.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试创建并优雅地处理 `table already exists` 错误消息。
- en: Leverage a migration library such as `Migratus` to keep track of the schema
    updates that we've applied up to this point, and automatically apply new changes
    as we introduce them.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用迁移库，例如 `Migratus`，来跟踪我们到目前为止已应用的架构更新，并在引入新更改时自动应用这些更改。
- en: In summary, we now have the ability to define our database schema using DDL
    and can apply this schema to our database, ready for data ingestion.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们现在可以使用 DDL 定义我们的数据库架构，并将此架构应用到我们的数据库中，以便进行数据摄入。
- en: Managing Our Data
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理我们的数据
- en: When dealing with persistent storage, and services that interact with them,
    we usually encounter the term `clojure.java.jdbc` exposes an API that directly
    maps to each of those operations, as we'd expect any good database library to
    do.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理持久化存储以及与之交互的服务时，我们通常会遇到 `clojure.java.jdbc` 提供了一个直接映射到每个这些操作的 API，正如我们期望任何优秀的数据库库所做的那样。
- en: The following commands describe each of the CRUD operations and the appropriate
    API call to use in `clojure.java.jdbc`. Note that the tables, columns, and values
    are arbitrary and only serve to show the format of the call.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令描述了每个 CRUD 操作以及在使用 `clojure.java.jdbc` 时应使用的适当 API 调用。请注意，表、列和值是任意的，仅用于展示调用格式。
- en: 'For creating an entry in the `example` table, we will set `col1` to the numeric
    value `42` and `col2` to the string value `"123"`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在 `example` 表中创建条目，我们将 `col1` 设置为数值 `42`，将 `col2` 设置为字符串值 `"123"`：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can read or extract an entry from the example table where the `id` value
    of the row is `13`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以读取或提取示例表中 `id` 值为 `13` 的条目：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To update the row with an ID of 13, we will set `col1` to the numeric value
    `77` and `col2` to the string value `"456"`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新 ID 为 13 的行，我们将 `col1` 设置为数值 `77`，将 `col2` 设置为字符串值 `"456"`：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Delete or remove an entry from the example table with ID `13`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 从示例表中删除或移除 ID 为 `13` 的条目：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It should be noted that these functions have multiple arities, where the optional
    last argument is a map of SQL options. We'll cover these options as we are introduced
    to each function in turn.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 应该指出，这些函数具有多种参数形式，其中可选的最后一个参数是一个 SQL 选项的映射。随着我们逐一介绍每个函数，我们将涵盖这些选项。
- en: Also of note is the `!` suffix on three of the API calls. This is conventionally
    (but not always!) used to indicate that the function itself will perform a side
    effect. In the functional programming world, this can be deemed important enough
    to draw extra attention to.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，三个 API 调用后面都有一个 `!` 后缀。这通常（但不总是！）用来表示函数本身将执行副作用。在函数式编程的世界里，这可以被认为足够重要，值得额外注意。
- en: Inserting, updating, and deleting will indeed result in a side effect – that
    of changing the persistent storage in some way. A query, by contrast, is a simple
    read function and will have no effect besides data retrieval.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 插入、更新和删除确实会导致副作用——以某种方式改变持久存储。相比之下，查询只是一个简单的读取函数，除了数据检索外不会有任何影响。
- en: Inserting Data
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入数据
- en: We'll cover the **C** in **CRUD** first. Indeed, we can't do anything exciting
    with our database until it's populated with some data.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先来谈谈 **CRUD** 中的 **C**。确实，在我们数据库中填充了一些数据之前，我们无法对数据库进行任何有趣的操作。
- en: Recall our two database tables, `app_user` and `activity`, and the relationship
    between them. Our foreign key reference stipulates that an activity cannot exist
    without the prior existence of an `app_user`. The creation of an activity must,
    therefore, reference an entity in the `app_user`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们两个数据库表，`app_user` 和 `activity`，以及它们之间的关系。我们的外键引用规定，一个活动不能在没有先存在一个 `app_user`
    的情况下存在。因此，创建一个活动必须引用 `app_user` 中的一个实体。
- en: Inserting Single Rows
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入单行
- en: '`jdbc/insert!` operates in two modes, accepting either a map of column-value
    pairs or accepting a vector of columns and a vector of values. Let''s explore
    the differences between both modes.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`jdbc/insert!` 运行在两种模式下，可以接受一个列值对的映射，或者接受一个列的向量和值的向量。让我们来探讨这两种模式之间的区别。'
- en: 'Firstly, using map mode, the structure of our `insert` command and the associated
    return value will be:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用映射模式，我们的 `insert` 命令及其相关的返回值结构将是：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The equivalent in vector mode is as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 向量模式中的等效操作如下：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is possible to omit the vector describing the column names. This would require
    us to insert values using the column order of the table as it was created. However,
    it is not possible to do this with Apache Derby when one or more of the columns
    is autogenerated.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能省略描述列名的向量。这将要求我们使用表创建时的列顺序来插入值。然而，当 Apache Derby 中有一个或多个列是自动生成的时候，这是不可能的。
- en: Although entirely equivalent in terms of the rows created in the database, you'll
    notice the return values differ.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在数据库中创建的行在术语上完全等效，但你会注意到返回值是不同的。
- en: In the first case, we are returned a single-element sequence containing a map.
    The value associated with the `:1` key is the ID that's been generated and persisted
    along with the row that we've just inserted. That's handy; we can use that when
    persisting any further rows in tables that require this as a foreign key. Without
    the automatic return of the generated ID, we'd need to submit a separate query
    to the database to retrieve it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们返回一个包含一个映射的单元素序列。与 `:1` 关键字关联的值是我们刚刚插入的行中生成的并持久化的 ID。这很方便；我们可以用它来持久化任何需要此作为外键的表中的进一步行。如果没有自动返回生成的
    ID，我们就需要提交一个单独的查询到数据库去检索它。
- en: In the second case, we again get a single-element sequence – this time containing
    an integer. It may be tempting to assume that the integer corresponds to a generated
    ID; this would be incorrect – the integer instead tells us the number of rows
    affected. `jdbc/insert!` only supports the insertion of a single row; this integer
    will always be 1 and is, therefore, of little use.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，我们再次得到一个包含一个整数的单元素序列——这次包含一个整数。可能会诱使我们假设这个整数对应于一个生成的 ID；这是不正确的——这个整数实际上告诉我们受影响的行数。`jdbc/insert!`
    只支持插入单行；这个整数始终是 1，因此几乎没有用处。
- en: 'A few important points should be noted here. The "generated ID" or "generated
    key" format is RDBMS-specific. If we were to swap in MySQL instead, we''d find
    our return value would be of the following form:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里应该注意几个重要点。所谓的“生成 ID”或“生成键”格式是 RDBMS 特定的。如果我们换成 MySQL，我们会发现我们的返回值会是以下形式：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We should, therefore, be careful about how we process these return values and
    be cognizant that a change of database could result in broken code.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该小心处理这些返回值，并意识到数据库的改变可能会导致代码损坏。
- en: The `({:1 1M})` return value looks a little curious. Keywordized integers are
    perfectly valid – they're just not encountered particularly often. Apache Derby
    obviously has no concept of Clojure keywords; `clojure.java.jdbc` is (helpfully)
    keywordizing our return keys by default.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`({:1 1M})` 返回值看起来有点奇怪。关键字化的整数是完全有效的——只是不太常见。Apache Derby 显然没有 Clojure 关键字的概念；`clojure.java.jdbc`（很有帮助地）默认关键字化我们的返回键。'
- en: 'This segues nicely into some of the options we can pass to any of the CRUD
    API calls, namely:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这很自然地引出了我们可以传递给任何 CRUD API 调用的选项，即：
- en: '`keywordize?` (Boolean, defaults to `true`)'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keywordize?`（布尔值，默认为 `true`）'
- en: identifiers (function, defaults to `identity`)
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符（函数，默认为 `identity`）
- en: 'If we are happy to receive our keys as is, then we can switch keywordization
    off:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意接收原始的键，那么我们可以关闭关键字化：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Inserting Multiple Rows
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入多行
- en: '`insert-multi!` (like `insert!`) works in two different modes. It accepts a
    collection of maps or a collection of vectors. The overall result of calling either
    is identical, but there are key differences that you need to be aware of.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert-multi!`（与 `insert!` 类似）在两种不同的模式下工作。它接受映射集合或向量集合。调用任一的结果总体上是相同的，但有一些关键的区别需要你注意。'
- en: We've already covered the "generated ID" (when working with maps) versus "rows
    affected" (when working with vectors) return values. This also holds true when
    working with `insert-multi!`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了“生成的 ID”（在处理映射时）与“影响的行数”（在处理向量时）的返回值。这在处理 `insert-multi!` 时同样适用。
- en: In addition, we should be aware that doing multiple inserts in vector mode will
    execute the inserts in batched transactions. This is more performant when doing
    a large number of inserts.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还应该意识到，在向量模式下进行多次插入将执行批处理事务。当进行大量插入时，这更高效。
- en: 'The following code demonstrates `insert-multi!` in map and vector mode:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了在映射和向量模式下的 `insert-multi!`：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Again, note the return values indicating that we've allocated IDs `1` and `2`
    to the inserted rows.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，注意返回值表明我们已经为插入的行分配了 ID `1` 和 `2`。
- en: We can insert partial records using either map or vector mode. When working
    with map mode, we simply omit any unwanted key-value pairs. In vector mode, we
    must specify the column names, and then insert nil values as required.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用映射或向量模式插入部分记录。在映射模式下工作，我们只需省略任何不需要的键值对。在向量模式下，我们必须指定列名，然后根据需要插入 nil 值。
- en: 'Exercise 13.04: Data Insertion'
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.04：数据插入
- en: 'Let''s begin by creating entries in each of the tables we''ve defined, ensuring
    we respect the foreign key constraint:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建我们定义的每个表中的条目开始，确保我们尊重外键约束：
- en: 'Inserting our favorite tennis player of the 1990s as an `app_user` can be achieved
    with either of the following function calls. We recommend choosing one of these
    to avoid spurious duplicates in our data:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下任一函数调用将我们 1990 年代的最佳网球运动员作为 `app_user` 插入。我们建议选择其中之一，以避免数据中的虚假重复：
- en: '[PRE26]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: When considering the existing state of the database, the `1M` value for our
    generated key can differ since it represents the next unique integer value.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当考虑数据库的现有状态时，我们生成的键的 `1M` 值可能会有所不同，因为它代表下一个唯一的整数值。
- en: 'We''ve inserted our first record successfully. Let''s now create several activities
    and associate them with our `app_user`, Andre. This will allow us to exercise
    the `jdbc/insert-multi!` API call:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已成功插入第一条记录。现在让我们创建几个活动并将它们与我们的 `app_user` Andre 关联。这将允许我们练习 `jdbc/insert-multi!`
    API 调用：
- en: '[PRE27]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When inserting data, there are several considerations to keep in mind. If inserting
    a single row, use `insert!`. If inserting multiple rows, use `insert-multi!`.
    If we are interested in the generated keys, then we should favor map insertion
    mode. If, on the other hand, performance is critical, we may favor vector insertion
    mode. When inserting a mixture of full and partial rows, then the reader may use
    their personal preference of map versus vector mode.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在插入数据时，有几个考虑因素需要记住。如果插入单行，使用 `insert!`。如果插入多行，使用 `insert-multi!`。如果我们对生成的键感兴趣，那么我们应该优先考虑映射插入模式。另一方面，如果性能至关重要，我们可能更倾向于向量插入模式。当插入完整和部分行混合时，读者可以使用他们个人的映射与向量模式偏好。
- en: Querying Data
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询数据
- en: In order to view what we've persisted in our database thus far, we'll consider
    the `db-spec` definition along with a vector containing a SQL string.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看我们迄今为止在数据库中持久化的内容，我们将考虑 `db-spec` 定义以及包含 SQL 字符串的向量。
- en: 'Exercise 13.05: Querying Our Database'
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.05：查询我们的数据库
- en: 'Here, we''ll cover the variety of options that we have available to us when
    querying the data we inserted as part of the prior exercise:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将介绍我们在查询之前练习中插入的数据所拥有的各种选项：
- en: 'To find what we have in our `app_user` and activity tables, the following will
    suffice:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要找到我们在`app_user`和活动表中的内容，以下就足够了：
- en: '[PRE28]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As alluded to in the *Managing Our Data* introduction, there is a 3-arity definition
    of `jdbc/query`, accepting a map of options. Since we have not provided that (we
    used the 2-arity version here) we have accepted all the default options. We'll
    now explore those options and how they can be used to manipulate the result set.
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如在*管理我们的数据*介绍中所述，`jdbc/query`有一个3元组定义，接受一个选项映射。由于我们没有提供那个（我们在这里使用了2元组版本），所以我们接受了所有默认选项。现在我们将探索这些选项以及它们如何用于操作结果集。
- en: Consider the preceding return values. We're returned a sequence of maps by default,
    where the keys are lowercase keywords.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑到前面的返回值。默认情况下，我们返回一个由映射组成的序列，其中键是小写关键字。
- en: Of the options that are supported, the first three we'll cover are trivial and
    allow us to control the format of the keys returned are `keywordize?`, `identifiers`,
    and `qualifier`.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在支持的所有选项中，我们将首先介绍的前三个选项是微不足道的，允许我们控制返回键的格式，它们是`keywordize?`、`identifiers`和`qualifier`。
- en: 'Setting `keywordize?` to `false` gives us string keys. Identifiers can be overridden
    by providing a single-arity function that converts the key to our chosen format.
    For example, retrieving data where the keys are uppercase strings can be achieved
    using these options (and `clojure.string`):'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`keywordize?`设置为`false`会给我们字符串键。可以通过提供一个单参数函数来覆盖标识符，该函数将键转换为我们的选择格式。例如，使用这些选项（和`clojure.string`）可以检索键为上字符串的数据：
- en: '[PRE29]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`qualifier` only works when `keywordize?` is true (the default) and allows
    us to specify a namespace for our keywords. Our keys are then returned in the
    form:'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`qualifier`仅在`keywordize?`为真（默认值）时才有效，并允许我们为我们的关键字指定一个命名空间。然后我们的键以以下形式返回：'
- en: '[PRE30]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For those not familiar with the preceding format, this indicates that we have
    a map where our keyword namespace is homogenous (every key has the same `app_user`
    namespace). More explicitly, we can see the individual keys from that query:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于那些不熟悉前面格式的读者，这表示我们有一个地图，其中我们的关键字命名空间是同质的（每个键都有相同的`app_user`命名空间）。更具体地说，我们可以从那个查询中看到单个键：
- en: '[PRE31]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the same way, we can insert data using (sequences of) maps or (sequences
    of) vectors. We can control the maps versus vectors result format in our queries
    as well. In the preceding code, we see maps as the default and can alter this
    by passing the following options map:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们可以使用（映射的）序列或（向量的）序列插入数据。我们也可以在我们的查询中控制映射与向量结果格式。在前面的代码中，我们看到映射是默认的，可以通过传递以下选项映射来改变这一点：
- en: '[PRE32]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output is as follows:'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE33]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Thinking back to the chapter where we first interacted with CSV files, you may
    recognize this as the same data structure used for reading from or writing to
    a CSV file; that is, a sequence of vectors where the first vector corresponds
    to the columns of the file and subsequent vectors are the data entries of the
    file.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们第一次与CSV文件交互的章节，你可能认出这和用于从CSV文件读取或写入的数据结构相同；也就是说，一个向量的序列，其中第一个向量对应于文件的列，后续的向量是文件的数据条目。
- en: Manipulating Query Return Values
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作查询返回值
- en: Besides manipulating the format of the return values, there are two additional
    options that give us complete control over each individual row returned by the
    query, or over the result set as a whole. We provide these using the `:row-fn`
    or `:result-set-fn` options; these *can* be combined if required.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 除了操作返回值的格式之外，还有两个额外的选项，它们使我们能够完全控制查询返回的每一行，或者控制整个结果集。我们通过`:row-fn`或`:result-set-fn`选项提供这些；如果需要，它们可以组合使用。
- en: The `row-fn` option should be a single-arity function, where the sole argument
    is a map representation of the current row. Similarly, the `result-set-fn` option
    should be a single-arity function where the sole argument is a sequence of maps
    representing the entirety of the query result. Consider the following example.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`row-fn`选项应该是一个单参数函数，其中唯一的参数是当前行的映射表示。同样，`result-set-fn`选项也应该是一个单参数函数，其中唯一的参数是表示整个查询结果的映射序列。考虑以下示例。'
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There are no constraints in what our functions can do, besides returning a value
    in the same data structure we received as input.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的功能可以做什么没有限制，除了返回一个与输入相同的数据结构中的值。
- en: It should be noted that the `result-set-fn` option you pass should *not* be
    lazy; otherwise, the connection could be closed before the function completes.
    `reduce` (or a function that calls `reduce` under the hood) is a good choice here.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，你传递的`result-set-fn`选项不应该是惰性的；否则，在函数完成之前，连接可能会被关闭。"reduce"（或底层调用`reduce`的函数）在这里是一个不错的选择。
- en: 'Exercise 13.06: Controlling Results with Custom Functions'
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.06：使用自定义函数控制结果
- en: Examples, where the `row-fn` would be applicable, include performing some calculation
    or aggregation that would be clumsy to achieve in raw SQL, formatting values,
    and enriching each row with computed values.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`row-fn`适用的例子包括执行一些在原始SQL中难以实现的计算或聚合，格式化值，以及用计算值丰富每一行。'
- en: 'Combining all three of these use cases, let''s consider our activity table,
    specifically the duration column. This is an integer value measuring the number
    of seconds of the activity in question. For the purposes of display or reporting
    to a user, we may find it more user-friendly to quote this in hours, minutes,
    and seconds:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 结合这三个用例，让我们考虑我们的活动表，特别是持续时间列。这是一个整数值，表示所讨论活动的秒数。为了显示或向用户报告，我们可能发现以小时、分钟和秒来引用它更友好：
- en: 'Defining a `row-fn` where the sole argument is a map representation of a row
    and that generally speaking the row should be returned, with any manipulation
    applied:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个`row-fn`，其中唯一的参数是行的映射表示，一般来说，行应该被返回，并应用任何操作：
- en: '[PRE35]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now adding that to our SQL options map and re-running the activity query from
    *Exercise 13.05*, *Querying Our Database*:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将其添加到我们的SQL选项映射中，并重新运行*练习13.05*，*查询我们的数据库*：
- en: '[PRE36]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Let's now calculate the total distance traveled across all activities in the
    database. This could trivially be achieved via raw SQL, but nevertheless will
    give us an opportunity to explore alternatives.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来计算数据库中所有活动所经过的总距离。这可以通过原始SQL轻易实现，但无论如何，这将给我们一个探索替代方案的机会。
- en: 'We''ll define our function as follows:'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将定义我们的函数如下：
- en: '[PRE37]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When used along with our query, we predictably retrieve a single number representing
    total distance across all activities:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当与我们的查询一起使用时，我们可以预测性地检索一个表示所有活动总距离的单个数字：
- en: '[PRE38]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To demonstrate how `row-fn` and `result-set-fn` can work together, we could
    use a `row-fn` to extract the distance, then a much simpler `result-set-fn` to
    sum those numbers like so:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了展示`row-fn`和`result-set-fn`如何协同工作，我们可以使用一个`row-fn`来提取距离，然后使用一个更简单的`result-set-fn`来汇总这些数字，如下所示：
- en: '[PRE39]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Through these last two exercises, we see `clojure.java.jdbc` gives us complete
    control over our query results, directly within the API call. Regardless of our
    requirements, we can leverage the options to the `jdbc/query` function to achieve
    the result we want, with custom formatting.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这两个最后的练习，我们看到`clojure.java.jdbc`在API调用中直接给我们提供了对查询结果的完全控制。无论我们的要求如何，我们都可以利用`jdbc/query`函数的选项来实现我们想要的结果，并使用自定义格式。
- en: Updating and Deleting Data
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新和删除数据
- en: Finally, we come to the **U** and **D** in CRUD; updates and deletes. These
    are simpler operations than the previous two and can be covered much more concisely.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了CRUD中的**U**和**D**；更新和删除。这些操作比前两个简单，可以更简洁地描述。
- en: 'When the state of the world we''re modeling has changed, we''ll want to reflect
    that in our persisted data. Before we perform our update, we determine the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们建模的世界状态发生变化时，我们希望在我们的持久化数据中反映这一点。在我们执行更新之前，我们确定以下内容：
- en: The table(s) affected
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受影响的表（s）
- en: The new values we wish to set
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望设置的新值
- en: The subset of data we want to have those values
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要具有那些值的 数据子集
- en: 'The signature of `jdbc/update!` gives us these pointers if we were not already
    aware:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`jdbc/update!`的签名给我们提供了以下提示，如果我们还没有意识到的话：'
- en: '[PRE40]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Exercise 13.07: Updating and Removing Existing Data'
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.07：更新和删除现有数据
- en: 'Let''s assume we discover that Andre Agassi has lost 2 kg. We can surmise that
    we''ll be updating the `app_user` table, setting the weight to 78 kg where the
    first name and last names are `Andre` and `Agassi` (or where the ID is `1`; we
    may have this available to us from earlier queries):'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们发现安德烈·阿加西减重了2公斤。我们可以推断我们将更新`app_user`表，将体重设置为78公斤，其中名字和姓氏是`Andre`和`Agassi`（或者ID是`1`；我们可能从之前的查询中获得了这个信息）：
- en: 'Construct the `update!` function call as follows:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建以下`update!`函数调用：
- en: '[PRE41]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Updates (and deletes), when successful, will only ever return the number of
    rows affected.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更新（和删除）在成功时，只会返回受影响的行数。
- en: 'If we query the `app_user` table, we expect this new fact to be persisted:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们查询 `app_user` 表，我们预计这个新事实将被持久化：
- en: '[PRE42]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we could imagine a case where `Agassi` has removed his account from our
    activity tracking service and requested that his data be deleted. We have a function
    signature as follows:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以想象一个情况，即 `Agassi` 从我们的活动跟踪服务中删除了他的账户并要求删除他的数据。我们有一个如下函数签名：
- en: '[PRE43]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can construct a function call that will remove `Agassi` and all his activities
    from our database:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以构建一个函数调用，该调用将从我们的数据库中删除 `Agassi` 及其所有活动：
- en: '[PRE44]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Interestingly, the number of rows affected is reported as `1`. Since we set
    an `ON DELETE CASCADE` option, we expected that all Andre''s activities would
    also be removed. Let''s verify that is indeed the case:'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有趣的是，受影响的行数报告为 `1`。由于我们设置了 `ON DELETE CASCADE` 选项，我们预计安德烈的所有活动也将被删除。让我们验证这一点是否确实如此：
- en: '[PRE45]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As we can see, Andre's activities have been removed. We can, therefore, conclude
    that the rows affected will only ever correspond to those removed from the target
    table.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，安德烈的活动已被删除。因此，我们可以得出结论，受影响的行将始终对应于从目标表中删除的行。
- en: Introduction to the Application Layer
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用层的介绍
- en: Until now, we've been creating ad hoc functions, testing them out at the REPL,
    occasionally creating a namespace or two that brings them together. We can think
    of the application layer as bringing all those namespaces and functions together
    into a working, coherent application with an associated API. In essence, we are
    designing the backend of our application in this step. We will then learn how
    to expose that API via REST in the next chapter; it will be useful to bear that
    in mind as we design our application.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在创建临时函数，在REPL中测试它们，偶尔创建一个或两个命名空间将它们组合在一起。我们可以将应用层视为将所有这些命名空间和函数组合成一个具有相关API的工作、连贯的应用程序。本质上，我们在这个步骤中设计应用程序的后端。然后我们将学习如何在下一章中通过REST公开该API；在设计我们的应用程序时牢记这一点将很有用。
- en: 'When designing our application layer, it makes sense to take a step back and
    ask what our requirements are. If we consider the activity tracking application,
    we might realistically have the following high-level requirements:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计我们的应用层时，退一步考虑我们的需求是有意义的。如果我们考虑活动跟踪应用程序，我们可能现实地有以下高级需求：
- en: Create a new user.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新用户。
- en: Create an activity for a given user.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为指定用户创建一个活动。
- en: Query users and activities.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询用户和活动。
- en: Run reports across individual users (that is, by activity or time period).
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单个用户（即按活动或时间段）上运行报告。
- en: Implementing the preceding requirements would give us a functional (albeit limited)
    application that users could begin interacting with to track activities and measure
    their fitness.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 实现前面的要求将给我们一个功能性的（尽管有限）应用程序，用户可以开始与之交互以跟踪活动和衡量他们的健康。
- en: Since we've already demonstrated most of this functionality as we learned how
    to interact with a database, we can leverage a lot of the code we've already written,
    making it more generic as we go.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在我们学习如何与数据库交互的过程中演示了大部分功能，我们可以利用我们已编写的大部分代码，随着我们的进行使其更加通用。
- en: We could structure the preceding application in a number of different ways,
    depending on our own individual views on the logical split that makes the most
    sense. We could spend a number of hours in the design phase, working out the exact
    project structure before we write any code; however, we would prefer to propose
    a starting structure, begin fleshing it out, and take an agile/evolutionary approach
    to develop this simple application.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据我们自己对逻辑分割的个人观点以多种不同的方式构建前面的应用程序，这种分割最有意义。我们可以在设计阶段花费数小时，在编写任何代码之前确定确切的项目结构；然而，我们更愿意提出一个起始结构，开始充实它，并采取敏捷/演化的方法来开发这个简单的应用程序。
- en: 'Exercise 13.08: Defining the Application Layer'
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.08：定义应用层
- en: We'll look to create our backend/application layer here; defining our namespaces
    and exposing an appropriate API.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里创建我们的后端/应用层；定义我们的命名空间并公开适当的API。
- en: 'Looking at the requirements we have, I''d suggest the following namespaces:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们的需求，我建议以下命名空间：
- en: '`schema`: Our data models'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`schema`：我们的数据模型'
- en: '`ingest`: Single user and activity ingestion'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ingest`：单个用户和活动摄取'
- en: '`query`: General queries for users and activities, plus more complex report
    queries'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`query`：针对用户和活动的通用查询，以及更复杂的报告查询'
- en: Again, remembering that we'd ideally layer on a REST service on top, imagine
    a top-level `web` or `api` namespace that will be interacting with the preceding
    namespaces and the public functions within.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 再次记住，我们理想情况下会在其上叠加一个 REST 服务，想象一个顶层 `web` 或 `api` 命名空间，它将与前面的命名空间以及公共函数进行交互。
- en: 'Before proceeding with this exercise, add the following to your `deps.edn`
    file or similar:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行此练习之前，请将以下内容添加到您的 `deps.edn` 文件或类似文件中：
- en: '[PRE46]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Starting with a clean database, we''ll begin by defining our `ns` schema, containing
    our DDL definitions that we''ll expand slightly to support our reporting requirement.
    Notably, we''ve added an `activity_date` field to the activity table, allowing
    us to report on activities across time:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个干净的数据库开始，我们将首先定义我们的 `ns` 模式，包含我们的 DDL 定义，我们将对其进行略微扩展以支持我们的报告需求。值得注意的是，我们向活动表添加了一个
    `activity_date` 字段，使我们能够报告跨时间段的各项活动：
- en: 'Define our namespace, including our `jdbc` and `hikari` requirements:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义我们的命名空间，包括我们的 `jdbc` 和 `hikari` 需求：
- en: '[PRE47]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Note the use of `(:refer-clojure :exclude [load])` in the previous code. This
    is not essential, but will suppress a warning that we''re replacing a function
    from `clojure.core` when we come to define our own `load` function next. The warning
    we''d experience without this line would be as follows:'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意前一段代码中使用了 `(:refer-clojure :exclude [load])`。这不是必需的，但将在我们定义自己的 `load` 函数时抑制一个警告，即我们正在替换
    `clojure.core` 中的一个函数。如果没有这一行，我们会遇到以下警告：
- en: '[PRE48]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, define our `jdbc-url` parameter and create a `hikari` connection-pooled
    data source. This `db` variable will be referenced and used throughout this exercise
    whenever we load our schema, insert rows, or query rows from our database:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义我们的 `jdbc-url` 参数并创建一个 `hikari` 连接池数据源。这个 `db` 变量将在整个练习中引用和使用，无论何时我们加载我们的模式、插入行或从我们的数据库查询行：
- en: '[PRE49]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We''ll now create our `app_user` and `activity` DDL:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建我们的 `app_user` 和 `activity` DDL：
- en: '[PRE50]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, we''ll bring this all together under a `load` function, which will
    apply our database schema (that is, our DDL) to the database referenced by our
    JDBC URL, via a connection pool:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将所有这些内容整合到一个 `load` 函数中，该函数将我们的数据库模式（即我们的 DDL）应用到由我们的 JDBC URL 指定的数据库中，通过连接池实现：
- en: '[PRE51]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Notice that some of our variables are defined as private, meaning that referencing
    them outside of the schema namespace is not required (or permitted). We make reference
    to them indirectly by calling the public `load` function. Note that `schema/load`
    is the only function in this `ns` that makes up our public API. The `db` var is
    public and we'd expect to reference it when making any queries or ingesting data.
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们的一些变量被定义为私有的，这意味着在模式命名空间之外引用它们不是必需的（或允许的）。我们通过调用公共 `load` 函数间接引用它们。请注意，`schema/load`
    是这个 `ns` 中构成我们的公共 API 的唯一函数。`db` 变量是公共的，我们预计在执行任何查询或摄取数据时都会引用它。
- en: 'Now for our ingestion code, where we''ll allow the creation of individual users
    and activities:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是我们的摄取代码，我们将允许创建单个用户和活动：
- en: '[PRE52]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: '`jdbc/insert!` returns a one-element sequence. We can, therefore, call first
    on the result of each `insert` statement to save our callers some work.'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`jdbc/insert!` 返回一个单元素序列。因此，我们可以对每个 `insert` 语句的结果调用 `first`，以节省调用者的工作量。'
- en: 'This is our query code where we''ll expand a little on what we''ve written
    before:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们的查询代码，我们将稍微扩展我们之前所写的：
- en: '[PRE53]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Expand on the `all-activities` function as follows:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下扩展 `all-activities` 函数：
- en: '[PRE54]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, let''s add our more advanced query definitions to the `query` namespace.
    We''ll introduce the `medley` and `java-time` dependencies into our project and
    require them in our `ns` query before creating a function that determines the
    most active user:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将更高级的查询定义添加到 `query` 命名空间中。我们将引入 `medley` 和 `java-time` 依赖项到我们的项目中，并在创建一个确定最活跃用户的函数之前在
    `ns` 查询中引入它们：
- en: '[PRE55]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`medley` is a third-party convenience library that provides commonly required
    functions that would otherwise be constructed using components of `clojure.core`:'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`medley` 是一个第三方便利库，它提供了通常需要使用 `clojure.core` 组件构建的常用函数：'
- en: 'The `most-active-user` function would look as follows:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`most-active-user` 函数看起来如下：'
- en: '[PRE56]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Finally, we''ll create a function that will calculate our single-user activity
    report by month:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个函数，该函数将按月计算我们的单个用户活动报告：
- en: '[PRE57]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now that we have an application layer defined, we can begin interacting with
    the functions we''ve exposed in each of our namespaces. We should see they read
    and return results in an intuitive manner. In order to make use of our API, require
    and alias each of our namespaces:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经定义了应用程序层，我们可以开始与我们在每个命名空间中公开的函数进行交互。我们应该看到它们以直观的方式读取和返回结果。为了使用我们的API，我们需要要求和别名每个命名空间：
- en: '[PRE58]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We must load our schema to our empty database, being careful to drop any child
    tables before their parents:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须将我们的模式加载到我们的空数据库中，注意在删除其父表之前先删除任何子表：
- en: '[PRE59]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, let''s define a handful of users and persist them to the database:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义一些用户并将它们持久化到数据库中：
- en: '[PRE60]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note our use of `doseq` in the preceding code. `doseq` can be used to iterate
    over a collection when we are not interested in the result (as we are when using
    `map`). Since we are iterating over a collection purely for side effects, we cannot
    be lazy about this operation as there is no guarantee we'd ever persist every
    user.
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们在前面的代码中使用`doseq`。`doseq`可以在我们不感兴趣于结果时（就像我们使用`map`时那样）用来遍历一个集合。由于我们纯粹是为了副作用而遍历一个集合，我们不能对这个操作过于懒惰，因为没有保证我们会持久化每个用户。
- en: Familiarize yourself with the `sample-activities.csv` file, which contains 20
    randomly generated activities for each of the three users we've just persisted.
    Note how the structure of the file does not map perfectly to our schema and consider
    potential methods we could use to parse the CSV file into a format that our `ingest/activity`
    function would support.
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 熟悉`sample-activities.csv`文件，它包含了我们刚刚持久化的三个用户中的20个随机生成的活动。注意文件的结构并不完美地映射到我们的模式，并考虑我们可以用来将CSV文件解析成我们的`ingest/activity`函数支持的格式的潜在方法。
- en: One method would be to define a map where the keys are precisely those that
    meet our schema requirements. If the values were then single-arity functions that
    would extract the relevant data from a given row, we could apply each of these
    in turn, generating a map that conforms to our schema.
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一种方法是为键定义一个映射，这些键正好符合我们的模式要求。如果值是单参数函数，可以从给定行中提取相关数据，我们可以依次应用这些函数，生成一个符合我们模式的映射。
- en: 'Define the accessor map as follows:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式定义访问器映射：
- en: '[PRE61]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Note how all but the `activity_date` accessor is performing a simple rename.
    `activity_date` is doing a (very slightly!) more complex operation, extracting
    multiple fields from a row and combining them into one. We could imagine extending
    this to perform arbitrarily complex parsing and data extraction.
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意除了`activity_date`访问器之外的所有访问器都在执行一个简单的重命名操作。`activity_date`执行的是一个（非常轻微的！）更复杂的操作，从一行中提取多个字段并将它们组合成一个。我们可以想象扩展这个功能以执行任意复杂的解析和数据提取。
- en: 'An `apply-accessors` function is required to actually take a row, an accessor
    map, and return the schema-conforming map:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要`apply-accessors`函数来实际取一个行、一个访问器映射，并返回一个符合模式的映射：
- en: '[PRE62]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '`reduce-kv` can be used to iterate over the key-value pairs in our accessor
    map.'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`reduce-kv`可以用来遍历我们的访问器映射中的键值对。'
- en: 'With our accessors and our `apply-accessors` functions defined, we can now
    read our CSV file and parse to a form that matches our activity table schema:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义了我们的访问器和`apply-accessors`函数之后，我们现在可以读取我们的CSV文件并将其解析成与我们的活动表模式相匹配的形式：
- en: '[PRE63]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Inspecting our first entry, we see that it does indeed look as we expect:'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查我们的第一个条目，我们看到它确实看起来像我们预期的那样：
- en: '[PRE64]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We can now persist these activities in the same manner that we did for persisting
    our users:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以用与持久化用户相同的方式持久化这些活动：
- en: '[PRE65]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Finally, let''s exercise our queries in turn and verify the results:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们依次练习我们的查询并验证结果：
- en: '[PRE66]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The output will look as follows:'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 13.5: Output on verifying the results'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图13.5：验证结果时的输出'
- en: '](img/B14502_13_05.jpg)'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_13_05.jpg)'
- en: 'Figure 13.5: Output on verifying the results'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5：验证结果时的输出
- en: We've now created the backend of our application, logically separating the various
    functions our application comprises. We've created a database, loaded our schema,
    and then ingested and retrieved data. This demonstrates a typical application
    life cycle, and hopefully we could imagine a REST service or mobile app sitting
    on top of this API we've constructed.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经创建了应用程序的后端，逻辑上分离了应用程序包含的各种功能。我们创建了一个数据库，加载了我们的模式，然后摄取和检索了数据。这展示了典型的应用程序生命周期，并且我们希望我们能想象出一个REST服务或移动应用坐在这个我们构建的API之上。
- en: 'Activity 13.01: Persisting Historic Tennis Results and ELO Calculations'
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动第13.01：持久化历史网球结果和ELO计算
- en: Given your experience with historic tennis results and ELO calculations, you've
    been hired by Tennis Analytics Ltd. They have a large CSV file that is difficult
    to work with; they'd like the competitor data to be modeled and persisted to a
    database. Once ingested, they would like to perform ELO calculations across the
    entire dataset maintaining a full ELO history. The ultimate goal is to find the
    competitor with the best ELO rating for a historic dataset.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 基于你对历史网球结果和ELO计算的经验，你被网球分析有限公司雇佣。他们有一个难以处理的大的CSV文件；他们希望将竞争对手数据建模并持久化到数据库中。一旦导入，他们希望在整个数据集上执行ELO计算，同时保持完整的ELO历史记录。最终目标是找到历史数据集中ELO评分最高的竞争对手。
- en: 'These steps will help you complete the activity:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将帮助你完成活动：
- en: Add the required dependencies to your `deps.edn` file or equivalent.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所需的依赖项添加到你的`deps.edn`文件或等效文件中。
- en: Create the `packt-clj.tennis.database`, `packt-clj.tennis.elo, packt-clj.tennis.ingest`,
    `packt-clj.tennis.parse`, and `packt-clj.tennis.query` namespaces.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`packt-clj.tennis.database`、`packt-clj.tennis.elo`、`packt-clj.tennis.ingest`、`packt-clj.tennis.parse`和`packt-clj.tennis.query`命名空间。
- en: In the `database` namespace, define a connection pool, referencing a new `tennis`
    database on disk, and store it in the `db` var.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`database`命名空间中，定义一个连接池，引用磁盘上的新`tennis`数据库，并将其存储在`db`变量中。
- en: Define a database `player` table using DDL consisting of the `id` (provided
    in the CSV file) and `full_name` fields.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用DDL定义一个包含`id`（由CSV文件提供）和`full_name`字段的数据库`player`表。
- en: Define a `tennis_match` table consisting of the `id` (a composite ID can be
    constructed from the CSV file), `tournament_year`, `tournament`, `tournament_order`,
    `round_order`, `match_order`, and `winner_id` (a foreign key referencing the player
    ID from the table in *Step 4*) fields.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含`id`（可以从CSV文件构建复合ID）、`tournament_year`、`tournament`、`tournament_order`、`round_order`、`match_order`和`winner_id`（外键引用*步骤4*中的球员ID）字段的`tennis_match`表。
- en: Define an `elo` table consisting of the `id` (can be autogenerated), `player_id`
    (foreign key referencing the player ID from the table in *Step 4*), and `rating`
    fields.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含`id`（可以自动生成）、`player_id`（外键引用*步骤4*中的球员ID）和`rating`字段的`elo`表。
- en: Create (and execute) a `load` function that will apply the DDL from *Steps 4-6*
    to our database defined in *Step 3*.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建（并执行）一个`load`函数，该函数将应用*步骤4-6*中的DDL到*步骤3*中定义的数据库。
- en: 'In the `parse` namespace, define a `historic` function that accepts a string
    representing a file path on the local disk. This function should read the CSV
    file from disk; convert the file to a sequence of maps; iterate over each row
    in turn; extract the fields pertinent for our `players` and `matches` data structures
    (fields will not necessarily be extracted exactly as-is; that is, some additional
    parsing or formatting will be required); and build up a data structure, ultimately
    returning a map of the following form:'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`parse`命名空间中，定义一个`historic`函数，该函数接受一个表示本地磁盘上文件路径的字符串。此函数应从磁盘读取CSV文件；将文件转换为映射序列；依次遍历每一行；提取与我们的`players`和`matches`数据结构相关的字段（字段可能不会完全按原样提取；也就是说，可能需要一些额外的解析或格式化）；并构建数据结构，最终返回以下形式的映射：
- en: '[PRE67]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Here, `players` and `matches` are maps that conform to the schema we've created.
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`players`和`matches`是符合我们创建的模式的映射。
- en: Helper functions should be defined as required. Some suggestions of functions
    that could prove helpful include being a means of parsing a row into a `winning-player`,
    `losing-player`, and `match` column, and being a means of defining the mapping
    of `target-key` function to the `row-extraction` function for each of the preceding
    structures.
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应根据需要定义辅助函数。一些可能有助于实现的功能包括将行解析为`winning-player`、`losing-player`和`match`列，以及定义将`target-key`函数映射到前述结构中每个结构的`row-extraction`函数。
- en: Note
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: We should be cautious to avoid defining unique players multiple times. We should
    also be aware that the `match_id` column in the CSV file *is not unique*! An appropriate
    composite should be constructed.
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们应谨慎避免多次定义唯一的球员。我们还应意识到CSV文件中的`match_id`列*不是唯一的*！应构建一个适当的复合键。
- en: In the `ingest` namespace, define a `historic` function that accepts a `db-spec`
    definition and a string representing a path/filename on the local disk. This function
    should pass the file path to the function defined in *step 8*, destructure the
    players and matches, and then perform `insert-multi!` on each in turn.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ingest` 命名空间中，定义一个 `historic` 函数，该函数接受一个 `db-spec` 定义和一个表示本地磁盘上路径/文件名的字符串。此函数应将文件路径传递到第
    8 步中定义的函数，解构玩家和比赛，然后依次对每个执行 `insert-multi!`。
- en: Note
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Players must be ingested prior to matches to ensure we satisfy our foreign key
    constraints.
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保满足外键约束，必须在比赛之前摄取玩家。
- en: Copy the `match_scores_1991-2016_unindexed_csv.csv` CSV file into the `resources`
    directory, and then ingest all `player` and `match` data from this file using
    the `historic` function from *Step 8*.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `match_scores_1991-2016_unindexed_csv.csv` CSV 文件复制到 `resources` 目录中，然后使用第
    8 步中的 `historic` 函数从该文件摄取所有 `player` 和 `match` 数据。
- en: Note
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The `match_scores_1991-2016_unindexed_csv.csv` CSV file can be found on GitHub
    at [https://packt.live/30291NO](https://packt.live/30291NO).
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`match_scores_1991-2016_unindexed_csv.csv` CSV 文件可以在 GitHub 上找到：[https://packt.live/30291NO](https://packt.live/30291NO)。'
- en: Now we have our data ingested, we'd like to calculate the ELO value for all
    historic matches, storing the ELO rating as we go. In the `query` namespace, define
    an `all-tennis-matches` function that accepts `db-spec` and returns the contents
    of the `tennis_match` table. This should be sorted appropriately by `tournament_year`,
    `tournament_order`, `reverse round_order`, and `match_order` to ensure we're calculating
    ratings chronologically.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经摄取了数据，我们希望计算所有历史比赛的 ELO 值，在计算过程中存储 ELO 评级。在 `query` 命名空间中，定义一个 `all-tennis-matches`
    函数，该函数接受 `db-spec` 并返回 `tennis_match` 表的内容。应该按 `tournament_year`、`tournament_order`、`reverse
    round_order` 和 `match_order` 适当排序，以确保我们按时间顺序计算评级。
- en: 'We''ll now leverage two of the functions we''ve already met in *Chapter 5*,
    *Many to One: Reducing*, namely `match-probability` and `recalculate-rating`.
    Introduce those to the `elo` namespace.'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将利用我们在第 5 章“多对一：减少”中遇到的两个函数，即 `match-probability` 和 `recalculate-rating`。将这些引入到
    `elo` 命名空间中。
- en: In the `elo` namespace, define a new `calculate-all` function that accepts `db-spec`
    and retrieves all tennis matches using `query/all-tennis-matches` (ordered chronologically,
    as described in *Step 10*), and then iterates over this dataset, calculating the
    ELO rating for each match, returning a collection of `elo` ratings that conform
    to the schema of the `elo` table.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `elo` 命名空间中，定义一个新的 `calculate-all` 函数，该函数接受 `db-spec` 并使用 `query/all-tennis-matches`
    检索所有网球比赛（按时间顺序排列，如第 10 步所述），然后遍历此数据集，计算每场比赛的 ELO 评级，返回一个符合 `elo` 表模式的 ELO 评级集合。
- en: Define a simple function that takes the result of the `calculate-all` function
    call and persists it into the `elo` table. Call this function to persist our ELO
    calculations.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个简单的函数，该函数接受 `calculate-all` 函数调用的结果并将其持久化到 `elo` 表中。调用此函数以持久化我们的 ELO 计算。
- en: 'Finally, define a `select-max-elo` function (we are interested in the player
    who has the highest ELO rating) in the `query` namespace, which returns a result
    in the following form:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `query` 命名空间中定义一个 `select-max-elo` 函数（我们感兴趣的是具有最高 ELO 评级的玩家），该函数返回以下形式的结果：
- en: '[PRE68]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: On executing this, we should see a familiar name!
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行此操作后，我们应该看到一个熟悉的名字！
- en: Note
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 745.
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在第 745 页找到。
- en: Summary
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter gave us an introduction to the Apache Derby RDBMS, creating a locally
    hosted instance with minimal setup. We then explored data models and how to codify
    them into a schema using DDL. We used `clojure.java.jdbc` to load this schema
    before investigating how the API allows us to perform CRUD operations, spending
    time on how to control the results from our query executions.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章介绍了 Apache Derby RDBMS，创建了一个具有最小设置的本地托管实例。然后我们探讨了数据模型以及如何使用 DDL 将其编码为模式。我们使用
    `clojure.java.jdbc` 在调查 API 允许我们执行 CRUD 操作之前加载此模式，并花费时间了解如何控制查询执行的结果。
- en: We then built an application layer for our ELO calculation application. In doing
    so, we learned which functions to expose as part of our API and which are internal
    to our application and should be kept private from a user.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为我们的 ELO 计算应用程序构建了一个应用层。在这个过程中，我们学习了哪些函数应该作为我们 API 的一部分公开，哪些是应用程序内部的，应该对用户保密。
- en: In the next chapter, we'll take the public API of our application layer and
    learn how to build a REST-based web service to expose that API over HTTP. In this
    way, we can make calls from a REST client and interact with our application over
    a network, rather than via a locally hosted REPL.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨我们应用层的公共API，学习如何构建一个基于REST的Web服务，以便通过HTTP公开该API。通过这种方式，我们可以从REST客户端发起调用，并通过网络与我们的应用程序交互，而不是通过本地托管的REPL。
- en: Subsequently, we'll improve this RESTful interaction by adding a higher-level
    UI layer so that a user can interact with our service via a web browser.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，我们将通过添加一个更高层次的UI层来改进这种RESTful交互，这样用户就可以通过网页浏览器与我们的服务进行交互。
