- en: Chapter 5. Scala Type System
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 Scala类型系统
- en: In the previous chapter, we covered how to work with lists, which made us familiar
    with some design principles of the whole collections library. We also covered
    how to generalize to sequences and covered some more relevant data structures.
    Finally, we also covered how collections relate to monads and how we can use that
    knowledge to use some powerful abstractions in our code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了如何处理列表，这使我们熟悉了整个集合库的一些设计原则。我们还介绍了如何泛化到序列，并覆盖了一些相关的数据结构。最后，我们还介绍了集合与单子之间的关系，以及我们如何利用这些知识在我们的代码中使用一些强大的抽象。
- en: In this chapter, we will cover the `type` system and polymorphism. We will also
    cover the different types of variance, which provides a way to constrain parameterized
    types. Finally, we will cover some advanced `types` such as abstract type members,
    option, and so on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍`type`系统和多态。我们还将介绍不同类型的方差，它提供了一种约束参数化类型的方法。最后，我们将介绍一些高级`type`，如抽象类型成员、选项等。
- en: Scala is statically typed. This means that the type of variables are known at
    compile time. The main advantage of statically typed languages is that a lot of
    checks can be done by the compiler, thus increasing the number of trivial bugs
    that are caught at an early stage. Statically typed languages are also friendlier
    to refactoring, as the programmer can feel safer about their changes as long as
    the code compiles.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Scala是静态类型语言。这意味着变量的类型在编译时已知。静态类型语言的主要优势是编译器可以执行大量检查，从而增加在早期阶段捕获的简单错误数量。静态类型语言对重构也更友好，因为只要代码能够编译，程序员就可以对他们的更改感到更安全。
- en: 'However, Scala is more than statically typed. In this chapter, we will see
    how Scala''s expressive type system enables and enforces statically typed sound
    abstractions. The ability to infer types reduces the programmers'' workload of
    annotating the program with redundant type information. This chapter will build
    upon the fundamentals required for the next chapter, where will be talking about
    type classes and a type of polymorphism they enable: ad hoc polymorphism.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Scala不仅仅是静态类型。在本章中，我们将看到Scala的表达式类型系统如何启用并强制执行静态类型安全的抽象。类型推断的能力减少了程序员对程序进行冗余类型信息注解的工作量。本章将建立在下一章所需的基础之上，下一章我们将讨论类型类以及它们所启用的类型多态：临时多态。
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Identify the Scala type hierarchy
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别Scala类型层次结构
- en: Use the features the Scala type system provides
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Scala类型系统提供的特性
- en: Identify abstractions that the Scala type system enables
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别Scala类型系统所启用的抽象
- en: Type Basics and Polymorphism
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型基础和多态
- en: In this section, we'll look at different types and polymorphism. We'll start
    with the unified type system of Scala and end with existential types.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨不同类型和多态。我们将从Scala的统一类型系统开始，以存在类型结束。
- en: A Unified Type System
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 统一的类型系统
- en: 'Scala has a unified type system. What this means is that all types, including
    "primitive" types, inherit from a common type. `Any` is a supertype of all types.
    It is often called the top type, and defines universal methods such as `equals`,
    `hashCode,` and `toString`. `Nothing` is a subtype of all types, and is often
    called the bottom type. There is no value that has a type of `Nothing`, so a common
    use case for it is to signal non-termination: a thrown exception, a program exit,
    or an infinite loop.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Scala有一个统一的类型系统。这意味着所有类型，包括“原始”类型，都继承自一个公共类型。`Any`是所有类型的超类型，通常被称为顶级类型，并定义了通用方法，如`equals`、`hashCode`和`toString`。`Nothing`是所有类型的子类型，通常被称为底层类型。没有值具有`Nothing`类型，因此它的常见用例是表示非终止：抛出的异常、程序退出或无限循环。
- en: '`Any` has two direct subclasses: `AnyVal` and `AnyRef`. Value types are represented
    by `AnyVal. AnyRef` represents the reference types. There are nine non-nullable
    predefined value types: `Double`, `Float`, `Long`, `Boolean`, `Unit`, `Byte`,
    `Char`, `Short,` and `Int`. All of these types are similar in other programming
    languages, except Unit. There is one instance of `Unit`, which is declared like
    `()`. Unit is an important return type as all the functions in Scala must return
    something. All non-value types are defined as reference types. Every user-defined
    type in Scala is a subtype of `AnyRef`. Comparing AnyRef to a Java runtime environment,
    `AnyRef` is similar to `java.lang.Object`.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`Any`有两个直接子类：`AnyVal`和`AnyRef`。值类型由`AnyVal`表示。`AnyRef`表示引用类型。有九个不可为空的预定义值类型：`Double`、`Float`、`Long`、`Boolean`、`Unit`、`Byte`、`Char`、`Short`和`Int`。所有这些类型在其他编程语言中都很相似，除了`Unit`。`Unit`有一个实例，其声明方式为`()`。`Unit`是一个重要的返回类型，因为
    Scala 中的所有函数都必须返回某些内容。所有非值类型都定义为引用类型。Scala 中的每个用户定义类型都是`AnyRef`的子类型。将`AnyRef`与
    Java 运行时环境比较，`AnyRef`类似于`java.lang.Object`。'
- en: Null is a subtype of all reference types. It contains a single value identified
    by the literal `null`. Null is used for operating between other programming languages
    but it is not recommended to use it in Scala. Scala provides other safer options
    to `null,` which we shall cover later in the chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`null`是所有引用类型的子类型。它包含一个由字面量`null`标识的单个值。`null`用于与其他编程语言进行操作，但在 Scala 中不建议使用它。Scala
    提供了其他更安全的`null`选项，我们将在本章后面介绍。'
- en: Parametric Polymorphism
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数多态
- en: '**Parametric polymorphism** is what allows you to write generic code for values
    of different types without losing the advantages of static typing.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数多态**是允许你为不同类型的值编写泛型代码而不失去静态类型优势的特性。'
- en: 'Without polymorphism, a generic list type structure would always look like
    this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 没有多态，泛型列表类型结构始终看起来像这样：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Having to deal with the `Any` type in these cases means that we can''t recover
    any type information about the individual members:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下必须处理`Any`类型意味着我们无法恢复关于各个成员的任何类型信息：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Without polymorphism, we would be forced to use casts and thus would lack type
    safety (since casts are dynamic and happen at runtime).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 没有多态，我们就必须使用类型转换，因此会缺乏类型安全性（因为类型转换是动态的，发生在运行时）。
- en: 'Scala enables polymorphism through the specification of `type` variables, which
    you probably already came across when implementing generic functions:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 通过指定`type`变量来实现多态，这在你实现泛型函数时可能已经遇到过了：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Type Inference
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型推断
- en: A common problem of statically typed languages is that they provide too much
    "syntactic overhead". Scala rectifies this issue by introducing type interface.
    In Scala, type inference is local and it will consider one expression at a time.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型语言的一个常见问题是它们提供了过多的“语法开销”。Scala 通过引入类型接口来解决这个问题。在 Scala 中，类型推断是局部的，并且它一次只考虑一个表达式。
- en: 'Type inference reduces the need for most type annotations. For example, declaring
    the type of variable is not necessary in Scala, as the compiler can identify the
    type from the initialization expression. Return types of methods are also successfully
    identified by the compiler, as they resemble to the body type:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断减少了大多数类型注解的需求。例如，在 Scala 中声明变量的类型是不必要的，因为编译器可以从初始化表达式中识别类型。方法返回类型也由编译器成功识别，因为它们类似于主体类型：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The compiler is not able to infer a result type from recursive methods, though.
    The following declaration will not compile:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管编译器无法从递归方法中推断出结果类型。以下声明将无法编译：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The error message is enough to identify the issue:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息足以识别问题：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Parameterized Types
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数化类型
- en: '**Parameterized types** are the same as generic types in Java. A generic type
    is a generic class or interface that is parameterized over types. For example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数化类型**与 Java 中的泛型类型相同。泛型类型是参数化类型的泛型类或接口。例如：'
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Generic types can interact with type checking using bounds or variance. We'll
    cover variance in the next section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类型可以通过界限或变异性与类型检查进行交互。我们将在下一节中介绍变异性。
- en: Bounds
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 界限
- en: 'Scala allows programmers to restrict polymorphic variables using bounds. These
    bounds express subtype ( `<:`) or supertype ( `:>`) relationships. For example,
    if we''ve defined our `drop1` method before as the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 允许程序员使用界限来限制多态变量。这些界限表达了子类型（`<:`）或超类型（`:>`)关系。例如，如果我们之前已经定义了以下`drop1`方法：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following wouldn''t compile:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将无法编译：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Existential Types
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存在类型
- en: 'An existential type in Scala is a type with some unknown parts in it. For example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 中的存在类型是包含一些未知部分的类型。例如：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: An existential type includes references to type members that we know exist,
    but whose concrete values we don't care about. In the preceding code, `T` is a
    type we don't know concretely, but that we know exists. Using existential types,
    we can leave some parts of your program unknown, and still typecheck it with different
    implementations for those unknown parts.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 存在类型包括对已知存在但具体值我们不关心的类型成员的引用。在前面代码中，`T` 是一个我们不知道具体类型的类型，但我们知道它存在。使用存在类型，我们可以让程序的一些部分保持未知，并且仍然可以使用不同实现对这些未知部分进行类型检查。
- en: 'Imagine that you have the following method:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你有一个以下的方法：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you try the following, it won''t compile, because an `Array[String]` is
    not an `Array[Any]` (will see why in the next section):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试以下操作，它将无法编译，因为 `Array[String]` 不是 `Array[Any]`（将在下一节中看到原因）：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, `foo` is parameterized to accept any `T`. But now we have to carry around
    this `type` parameter, and we only care about methods on `Array` and not what
    the `Array` contains. We can therefore use existential types to get around this.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`foo` 被参数化以接受任何 `T`。但现在我们必须携带这个 `type` 参数，而我们只关心 `Array` 上的方法，而不是 `Array`
    包含的内容。因此，我们可以使用存在类型来解决这个问题。
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This pattern is common, so Scala provides us with "wildcards" for when we don''t
    want to name a type variable:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式很常见，因此 Scala 为我们提供了“通配符”，当我们不想命名类型变量时：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Activity: Generalizing the Implementation of the Binary Tree'
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动：泛化二叉树的实现
- en: 'In this activity, we''ll be generalizing an implementation of a binary search
    tree. Let''s assume you have the following definition for a binary search tree
    of integers. We want to generalize our implementation of a binary search tree
    from an `IntTree` to a `Tree[A]`. Perform the necessary modifications to the code
    to support the new definition and also have the `insert` and `search` methods
    work on the new definition. You may need to modify the `insert` and `search` definitions
    to provide a generic comparison function. We would like to use this new generic
    data structure to store information about the users that visit our website, which
    are being modeled as the `User(username: String, country: String)` case class:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个活动中，我们将泛化二叉搜索树的实现。假设你有一个整数二叉搜索树的以下定义。我们希望将我们的二叉搜索树实现从 `IntTree` 泛化到 `Tree[A]`。对代码进行必要的修改以支持新的定义，并使
    `insert` 和 `search` 方法在新的定义上工作。你可能需要修改 `insert` 和 `search` 定义以提供一个泛型比较函数。我们希望使用这个新的泛型数据结构来存储访问我们网站的用户信息，这些用户被建模为
    `User(username: String, country: String)` 案例类：'
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The previous definition supports these methods:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的定义支持以下方法：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Start by modifying the ADT for trees from `IntTree` to a `Tree[A]`. Perform
    the necessary modifications to `IntNode` (to become Node[A] and `IntEmpty` to
    become `Empty`).
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将树的 ADT 从 `IntTree` 修改为 `Tree[A]`。对 `IntNode`（变为 `Node[A]`）和 `IntEmpty`（变为
    `Empty`）进行必要的修改。
- en: Note
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that `IntEmpty` is an object, so there''s a single instance for the type
    `IntEmpty`.type. What should `Empty` be a subtype of? For now, transform `Empty`
    into a case class: case class `Empty[A]() extends Tree[A]`. We''ll look at a better
    way to define this type later.'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`IntEmpty` 是一个对象，因此 `IntEmpty` 类型只有一个实例。`Empty` 应该是哪种类型的子类型？现在，将 `Empty`
    转换为案例类：`case class Empty[A]() extends Tree[A]`。我们稍后会看看定义此类型更好的方法。
- en: 'Modify the `insert` definition to accept an extra comparison function as a
    function parameter:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `insert` 定义以接受一个额外的比较函数作为函数参数：
- en: '[PRE16]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Modify the code accordingly to take the new `comp` parameter into account.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相应地修改代码以考虑新的 `comp` 参数。
- en: 'Modify the `search` definition to accept an extra `comparison` function as
    a function parameter:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `search` 定义以接受一个额外的 `comparison` 函数作为函数参数：
- en: '[PRE17]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Modify the code accordingly to take the new `comp` parameter into account.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相应地修改代码以考虑新的 `comp` 参数。
- en: Create a comparison function for `User` and use it to populate a `Tree[User]`.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `User` 的比较函数，并使用它来填充 `Tree[User]`。
- en: 'Implement the `def usersOfCountry(country: String, tree: Tree[User])`: `Int`
    function that returns the number of users of a given country in a `Tree[User]`.'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '实现 `def usersOfCountry(country: String, tree: Tree[User]): Int` 函数，该函数返回给定国家在
    `Tree[User]` 中的用户数量。'
- en: In this section, we covered the unified type system of Scala and how Scala achieves
    polymorphism. We also introduced type inference and the basic rules of when it's
    applied. Bounds were also introduced as a convenient way to restrict polymorphic
    types.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了Scala的统一类型系统以及Scala如何实现多态。我们还介绍了类型推断及其应用的基本规则。界限也被引入作为一种方便地限制多态类型的方法。
- en: Variance
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协变
- en: Variance provides a way to constrain parameterized types. It defines a subtyping
    relationship between parameterized types based on the subtyping relationship of
    their component types.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 协变提供了一种约束参数化类型的方法。它根据其组件类型的子类型关系定义了参数化类型之间的子类型关系。
- en: 'Imagine that you have the following class hierarchy:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你有一个以下类层次结构：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'How can `Box` of `Tools` relate to one another? Scala provides three ways:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 工具箱中的`Box`如何相互关联？Scala提供了三种方式：
- en: 'Covariant: `Box[Hammer] <: Box[Tool] if Hammer <: Tool`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '协变：`Box[Hammer] <: Box[Tool]`当且仅当`Hammer <: Tool`'
- en: 'Contravariant: `Box[Tool] <: Box[Hammer] if Tool <: Hammer`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '逆变：`Box[Tool] <: Box[Hammer]`当且仅当`Tool <: Hammer`'
- en: 'Invariant: There''s no subtyping relationship between `Box[Tool]` and `Box[Hammer]`
    independently of the subtyping relationship of `Tool` and `Hammer`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不变：无论`Tool`和`Hammer`的子类型关系如何，`Box[Tool]`和`Box[Hammer]`之间没有子类型关系
- en: Covariance
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协变
- en: 'Let''s assume that we want to define a function called `isSuitable`, which
    takes a `Box[HandTool]` and tests if the box is suitable to accommodate the tool
    it attempts to box:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要定义一个名为`isSuitable`的函数，它接受一个`Box[HandTool]`并测试该盒子是否适合容纳它试图装箱的工具：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Can you pass a box of hammers to the function? After all, a hammer is a `HandTool`,
    so if the function wants to determine the suitability of the box based on the
    underlying tool, it should accept a `Box[Hammer]`. However, if you run the code
    as it is, you''ll get a compilation error:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你能传递一个锤子箱给函数吗？毕竟，锤子是一种`HandTool`，所以如果函数想要根据底层工具确定盒子的适用性，它应该接受`Box[Hammer]`。然而，如果你按原样运行代码，你会得到一个编译错误：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The problem here is that `Box[Hammer]` is not a subtype of `Box[HandTool]`,
    despite `Hammer` being a subtype of `HandTool`. In this case, we want `Box[B]`
    to be a subtype of `Box[A]` if `B` is a subtype of `A`. This is what covariance
    is. We can then tell the Scala compiler that `Box[A]` is a covariant on `A` as:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是`Box[Hammer]`不是`Box[HandTool]`的子类型，尽管`Hammer`是`HandTool`的子类型。在这种情况下，我们希望如果`B`是`A`的子类型，则`Box[B]`是`Box[A]`的子类型。这就是协变。然后我们可以告诉Scala编译器`Box[A]`在`A`上是协变的，如下所示：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Contravariance
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逆变
- en: 'Now, let''s assume that we have operators that specialize on specific tools,
    so you have something like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们有一些专门针对特定工具的操作符，所以你会有类似以下的内容：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You have a problem which requires an operator to be capable of working with
    hammers:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个需要操作符能够处理锤子的问题：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Can you pass an operator of `HandTool` to fix this? After all, a hammer is a
    `HandTool`, so if the operator is capable of working with hand tools, they should
    be able to work with hammers.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你能传递一个`HandTool`的操作符来解决这个问题吗？毕竟，锤子是一种`HandTool`，所以如果操作符能够与手工具一起工作，它们也应该能够与锤子一起工作。
- en: 'However, if you try the code, you get a compilation error:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你尝试运行代码，你会得到一个编译错误：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The problem here is that `Operator[HandTool]` is not a subtype of `Operator[Hammer]`,
    despite `Hammer` being a subtype of `HandTool`. In this case, we want `Operator[A]`
    to be a subtype of `Operator[B]` if `B` is a subtype of `A`. This is what contravariance
    is. We can tell the Scala compiler that `Operator[A]` is a contravariant on `A`
    as:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是`Operator[HandTool]`不是`Operator[Hammer]`的子类型，尽管`Hammer`是`HandTool`的子类型。在这种情况下，我们希望如果`B`是`A`的子类型，则`Operator[A]`是`Operator[B]`的子类型。这就是逆变。我们可以告诉Scala编译器`Operator[A]`在`A`上是逆变的，如下所示：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Invariance
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不变
- en: 'By default, type parameters are invariant because the compiler has no way of
    guessing what you intend to model with a given type. On the other hand, the compiler
    helps you by forbidding the definition of types that may be unsound. For example,
    if you declare the `Operator` class as a covariant, you get a compilation error:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，类型参数是不变的，因为编译器无法猜测你打算用给定的类型来建模什么。另一方面，编译器通过禁止定义可能不合理的类型来帮助你。例如，如果你将`Operator`类声明为协变的，你会得到一个编译错误：
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: By defining `Operator` to be covariant, you would say that an `Operator[Hammer]`
    could be used in place of an `Operator[HandTool]`. So, an operator capable of
    only using a `Hammer` would be able to operate on any `HandTool`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`Operator`定义为协变的，你会说`Operator[Hammer]`可以用作`Operator[HandTool]`的替代。所以，只能使用锤子的操作符能够操作任何`HandTool`。
- en: Looking at the definitions of `Box[+A]` and `Operator[-A]`, notice that type
    `A` only appears in the return type of methods of `Box[+A]` and only in the parameters
    of methods of `Operator[-A]`. So, a type that only produces values of type `A`
    can be made covariant on `A`, and a type that consumes values of type `A` can
    be made contravariant on `A`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到`Box[+A]`和`Operator[-A]`的定义，注意到类型`A`只出现在`Box[+A]`的方法的返回类型中，并且只出现在`Operator[-A]`的方法的参数中。因此，只产生类型`A`值的类型可以在`A`上变得协变，而消耗类型`A`值的类型可以在`A`上变得逆变。
- en: You can deduce by the previous points that mutable data types are necessarily
    invariant (they have `getters` and `setters`, so they both produce and consume
    values).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过前面的点推断出可变数据类型必然是不变的（它们有`getters`和`setters`，因此它们都产生和消费值）。
- en: 'In fact, Java has an issue with this, as Java arrays are covariant. This means
    that some code that is valid at compile time can fail at runtime. For example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Java在这方面存在问题，因为Java数组是协变的。这意味着一些在编译时有效的代码可能在运行时失败。例如：
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In Scala, most collections are covariant (for example, `List[+A]`). However,
    you may be wondering how the `::` methods and similar are implemented, since they
    may have a type in a contravariant position:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，大多数集合都是协变的（例如，`List[+A]`）。然而，你可能想知道`::`方法和类似方法是如何实现的，因为它们可能在逆变位置有一个类型：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Actually, methods such as `::` are implemented as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，像`::`这样的方法是这样实现的：
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This actually allows collections to always get parameterized on the more specific
    type they''re able to. Notice how the following list gets lifted to a list of
    `HandTool`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上允许集合始终在它们能够的更具体类型上参数化。注意以下列表是如何提升到`HandTool`列表的：
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Activity: Implementing Covariance and the Database for Tools'
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动：实现协变和工具数据库
- en: 'In this activity, we''ll be making our previous implementation of `Tree[A]`
    covariant on `A`. We also want to start building a database for the tools we''ve
    defined so far. We have extended the definition of tools to now have a weight
    and a price:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将使我们的`Tree[A]`之前的实现对`A`进行协变。我们还希望开始为我们定义的工具建立一个数据库。我们已经扩展了工具的定义，现在它们具有重量和价格：
- en: '[PRE31]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Start by defining `Tree` as `Tree[+A]`. You can now define `Empty` as a case
    object extending `Tree[Nothing]`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先定义`Tree`为`Tree[+A]`。你现在可以定义`Empty`为一个扩展`Tree[Nothing]`的案例对象。
- en: Define some comparison function for tools. For instance, you can compare tools
    by weight, by price, or by a combination of both. Experiment with the different
    comparison functions when creating trees.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一些工具的比较函数。例如，你可以按重量、按价格或两者的组合来比较工具。在创建树时，尝试不同的比较函数。
- en: 'Implement the `def merge[A](tree1: Tree[A], tree2: Tree[A], comp: (A, A) =>
    Boolean): Tr``ee[A]` function, which merges two trees into one.'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '实现一个`def merge[A](tree1: Tree[A], tree2: Tree[A], comp: (A, A) => Boolean):
    Tree[A]`函数，该函数将两个树合并为一个。'
- en: In this section, we've covered variance as a way to define subtyping relationships
    on types based on their component types.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了方差作为在类型上根据其组件类型定义子类型关系的方法。
- en: Advanced Types
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级类型
- en: If you have come from Java, most of these things may not be surprising. As such,
    let's look at some other features of Scala's type system.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自Java，这些事情可能不会让你感到惊讶。因此，让我们看看Scala类型系统的其他一些特性。
- en: Abstract Type Members
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象类型成员
- en: Abstract type members are type members of an object or class that are left abstract.
    They can provide some abstraction without the verbosity of type parameters. If
    a type is intended to be used existentially in most cases, we can cut some verbosity
    by using a type member instead of a parameter.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类型成员是对象或类中留下的抽象类型成员。它们可以在不使用类型参数的情况下提供一些抽象。如果一个类型在大多数情况下打算存在性地使用，我们可以通过使用类型成员而不是参数来减少冗余。
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can refer to an abstract type variable using the hash operator:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用哈希运算符来引用抽象类型变量。
- en: '[PRE33]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Structural Types
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构化类型
- en: 'Scala supports structural types: type requirements that are expressed by an
    interface structure instead of a concrete type. Structural typing provides a feature
    similar to what dynamic languages allow you to do when they support duck typing,
    but in a static typed implementation checked up at compile time. However, bear
    in mind that Scala uses reflection to call methods on structural types, and that
    this has a cost on performance:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Scala支持结构化类型：类型要求是通过接口结构而不是具体类型来表达的。结构化类型提供了一种类似于动态语言在支持鸭子类型时允许你做的事情的功能，但在静态类型实现中，这些功能在编译时进行检查。然而，请注意，Scala使用反射在结构化类型上调用方法，这会对性能产生成本：
- en: '[PRE34]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Structural types are not very common in Scala codebases.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化类型在 Scala 代码库中并不常见。
- en: Option
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Option
- en: We previously visited the `Null` type in the Scala hierarchy, but commented
    that null is rarely seen in Scala code. The reason behind this is the existence
    of the `Option` type in Scala's standard library. If you have worked with Java
    in the past, chances are you came across a `NullPointerException` at some point.
    That usually happens when some method returns `null` when the programmer was not
    expecting it to and not dealing with that possibility in the client code. Scala
    tries to solve the problem by making optional types explicit via the `Option[A]`
    trait. `Option[A]` is a container for an optional value of type `A`. If the value
    is present, then `Option[A]` is an instance of `Some[A]`, otherwise it is the
    `None o`bject. By making optional values explicit at the type level, there's no
    way to accidentally rely on the presence of a value that is really optional.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在 Scala 层次结构中讨论了 `Null` 类型，但评论说在 Scala 代码中很少看到 `null`。背后的原因是 Scala 标准库中存在
    `Option` 类型。如果你以前使用过 Java，那么你可能在某个时候遇到过 `NullPointerException`。这通常发生在某些方法返回 `null`
    时，而程序员没有预料到这一点，也没有在客户端代码中处理这种情况。Scala 通过通过 `Option[A]` 特质使可选类型显式化来尝试解决这个问题。`Option[A]`
    是类型为 `A` 的可选值的容器。如果值存在，则 `Option[A]` 是 `Some[A]` 的实例，否则它是 `None` 对象。通过在类型级别上使可选值显式化，就不可能意外地依赖于实际上可选的值的存在。
- en: 'You can create an `Option` using the `Some` case class or by assigning the
    `None` object. When working with Java libraries, you can use the factory method
    of the `Option` companion object that creates `None` if the given parameter is
    null, and wraps the parameter in a Some otherwise:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `Some` 情况类或通过分配 `None` 对象来创建一个 `Option`。当与 Java 库一起工作时，你可以使用 `Option`
    伴生对象的工厂方法，如果给定的参数为 `null`，则创建 `None`，否则将参数包装在 `Some` 中：
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `Option` trait defines a get method that returns the wrapped value in case
    of a Some, and throws a `NoSuchElementException` in case of a `None`. A safer
    method is `getOrElse`, which returns the wrapped value in case of a Some, but
    a default value in case of a None. Do note that the default value in the `getOrElse`
    method is a by-name-parameter, so it will only be evaluated in case of a `None`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`Option` 特质定义了一个 `get` 方法，在 `Some` 的情况下返回包装的值，在 `None` 的情况下抛出 `NoSuchElementException`。一个更安全的方法是
    `getOrElse`，在 `Some` 的情况下返回包装的值，但在 `None` 的情况下返回默认值。请注意，`getOrElse` 方法中的默认值是一个按名传递的参数，因此它只会在
    `None` 的情况下进行评估。'
- en: 'A convenient way to work with Options is by using pattern matching:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模式匹配是处理 `Option` 的便捷方式：
- en: '[PRE36]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: A nice feature of `Option` is that it extends `Traversable`, so you have all
    the `map`, `flatMap`, `fold`, `reduce`, and other methods we visited in the previous
    chapter.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`Option` 的一个优点是它扩展了 `Traversable`，因此你拥有了我们在上一章中提到的所有 `map`、`flatMap`、`fold`、`reduce`
    以及其他方法。'
- en: Higher Kind Types
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高阶类型
- en: 'Scala can abstract over types of a higher kind . You can think of it as types
    of types. A common use case for it is if you want to abstract over several types
    of containers for several types of data. You may want to define an interface for
    these containers without nailing down the value''s type:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 可以抽象化高阶类型。你可以将其视为类型的类型。它的一个常见用例是，如果你想要抽象化多个类型的容器，这些容器用于存储多种类型的数据。你可能想要为这些容器定义一个接口，而不必确定值的类型：
- en: '[PRE37]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Type Erasure
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型擦除
- en: 'To incur in no runtime overhead, the Java Virtual Machine performs type erasure.
    Among other things, type erasure replaces all type parameters in generic types
    with their bounds or `Object` if the type parameters are unbounded. This results
    in bytecode that only contains ordinary classes, interfaces, and methods, and
    makes sure that no new classes are created for parameterized types. This leads
    to some pitfalls when we attempt to match on generic type parameters:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了不产生运行时开销，Java 虚拟机执行类型擦除。在其他方面，类型擦除将泛型类型中的所有类型参数替换为其边界或 `Object`（如果类型参数未指定边界）。这导致字节码只包含普通类、接口和方法，并确保不会为参数化类型创建新类。这导致我们在尝试对泛型类型参数进行匹配时会出现一些陷阱：
- en: '[PRE38]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As such, you should always avoid matching on generic type parameters. If it
    is impossible to refactor the method that performs the pattern matching, try to
    control the type of value passed into the function by boxing the input which has
    a type parameter with a container that specifies the type parameter:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你应该始终避免对泛型类型参数进行匹配。如果无法重构执行模式匹配的方法，尝试通过将具有类型参数的输入装箱并指定类型参数的容器来控制传递给函数的值的类型：
- en: '[PRE39]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Activity: Finding an Element Based on a Given Predicate'
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动：基于给定谓词查找元素
- en: 'In this activity, we want to provide our `Tree` with functionality to find
    an element in it based on a given predicate. More concretely, we want to implement
    the `def find[A](tree: Tree[A], predicate: A => Boolean): Option[A]` function.
    The function should return `None` if no element is found that satisfies the predicate,
    or `Some` with the first element (in order) that satisfies it.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个活动中，我们希望为我们的`Tree`提供基于给定谓词查找元素的功能。更具体地说，我们希望实现`def find[A](tree: Tree[A],
    predicate: A => Boolean): Option[A]`函数。如果找不到满足谓词的元素，则该函数应返回`None`，或者返回满足谓词的第一个元素（按顺序）。'
- en: 'We want to return the first element in order, so we need to assume that the
    tree is a search tree and traverse it in order. Implement the `def inOrder[A](tree:
    Tree[A]): Iterator[A]` method that returns an `Iterator` with the in-order traversal
    of elements in the `Tree`.'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '我们希望按顺序返回第一个元素，因此我们需要假设该树是一个搜索树，并按顺序遍历它。实现`def inOrder[A](tree: Tree[A]): Iterator[A]`方法，该方法返回一个包含`Tree`中元素顺序遍历的`Iterator`。'
- en: Using the previously implemented method, now rely on the `find` method of `Iterator`
    to implement the `target` function.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用之前实现的方法，现在依靠`Iterator`的`find`方法来实现`target`函数。
- en: We want to find the cheapest tool with a weight below 100\. Implement the function
    that should be used when creating the tree, and the predicate to be used in the
    `find` method.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望找到重量低于100的最便宜的工具。实现创建树时应使用的函数，以及`find`方法中应使用的谓词。
- en: Summary
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the `type` system and polymorphism. We also covered
    the different types of variance which provide a way to constrain parameterized
    types. Finally, we covered some advanced `types` such as abstract type members,
    option, and so on.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了`type`系统和多态。我们还介绍了不同类型的变异性，它提供了一种约束参数化类型的方法。最后，我们介绍了某些高级`type`，例如抽象类型成员、选项等。
- en: In the next chapter, we will cover `implicits,` which will make working with
    external libraries more pleasant. We will cover implicit conversions and finally
    cover ad hoc polymorphism through the use of type classes.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍`implicits`，这将使使用外部库的工作更加愉快。我们将介绍隐式转换，并最终通过使用类型类来介绍特设多态。
