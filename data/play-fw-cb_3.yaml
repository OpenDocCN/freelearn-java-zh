- en: Chapter 3. Leveraging Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 利用模块
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下菜谱：
- en: Dependency injection with Spring
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring进行依赖注入
- en: Dependency injection using Guice
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Guice进行依赖注入
- en: Utilizing MongoDB
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用MongoDB
- en: Utilizing MongoDB and GridFS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用MongoDB和GridFS
- en: Utilizing Redis
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用Redis
- en: Integrating Play application with Amazon S3
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Play应用程序与Amazon S3集成
- en: Integrating Play application with Typesafe Slick
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Play应用程序与Typesafe Slick集成
- en: Utilizing play-mailer
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用play-mailer
- en: Integrating Bootstrap and WebJars
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成Bootstrap和WebJars
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we will look at utilizing Play and other third-party modules
    to address commonly required functionalities of modern web applications. As web
    applications and web application frameworks mature and evolve, the need for a
    modular and extensible system as part of the core web application framework becomes
    increasingly important. This is achievable and straightforward with Play Framework
    2.0.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何利用Play和其他第三方模块来处理现代Web应用程序的常见功能。随着Web应用程序和Web应用程序框架的成熟和演变，作为核心Web应用程序框架一部分的模块化和可扩展系统变得越来越重要。这可以通过Play
    Framework 2.0轻松实现。
- en: Dependency injection with Spring
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring进行依赖注入
- en: For this recipe, we will explore how to integrate the popular Spring Framework
    with a Play application. We will use Spring for bean instantiation and injection
    using Play controllers and service classes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将探讨如何将流行的Spring框架与Play应用程序集成。我们将使用Spring通过Play控制器和服务类进行bean实例化和注入。
- en: How to do it…
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'For Java, we need to take the following steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java，我们需要采取以下步骤：
- en: 'Run the `foo_java` application with Hot-Reloading enabled:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用热重载运行`foo_java`应用程序：
- en: '[PRE0]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Declare Spring as a project dependency in `build.sbt`:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`build.sbt`中将Spring声明为项目依赖项：
- en: '[PRE1]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a new admin controller in `foo_java/app/controllers/AdminController.java`
    with the following code:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_java/app/controllers/AdminController.java`中创建一个新的管理控制器，代码如下：
- en: '[PRE2]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create an admin service interface class in `foo_java/app/services/AdminServices.java`
    and a mock admin service implementation class in `foo_java/app/services/AdminServicesImpl.java`
    with the following content:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_java/app/services/AdminServices.java`中创建一个管理服务接口类，并在`foo_java/app/services/AdminServicesImpl.java`中创建一个模拟管理服务实现类，内容如下：
- en: '[PRE3]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add a new routes entry for the newly added action to `foo_java/conf/routes`:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_java/conf/routes`中为新增的操作添加一个新的路由条目：
- en: '[PRE4]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add a `Global` settings class to the `foo_java/app/Global.java` file with the
    following content:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_java/app/Global.java`文件中添加一个`Global`设置类，内容如下：
- en: '[PRE5]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add the Spring configuration class to `foo_java/app/SpringConfig.java` with
    the following content:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_java/app/SpringConfig.java`中添加Spring配置类，内容如下：
- en: '[PRE6]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Request our new route and examine the response body to confirm:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求我们的新路由并检查响应体以确认：
- en: '[PRE7]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For Scala, we need to take the following steps:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Scala，我们需要采取以下步骤：
- en: 'Run the `foo_scala` application with Hot-Reloading enabled:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用热重载运行`foo_scala`应用程序：
- en: '[PRE8]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Declare Spring as a project dependency in `build.sbt`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`build.sbt`中将Spring声明为项目依赖项：
- en: '[PRE9]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a new admin controller in `foo_scala/app/controllers/AdminController.scala`
    with the following content:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/app/controllers/AdminController.scala`中创建一个新的管理控制器，内容如下：
- en: '[PRE10]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create an admin service class in `foo_scala/app/services/AdminServices.scala`
    with the following content:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/app/services/AdminServices.scala`中创建一个管理服务类，内容如下：
- en: '[PRE11]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add a new routes entry for the newly added action to `foo_scala/conf/routes`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/conf/routes`中为新增的操作添加一个新的路由条目：
- en: '[PRE12]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add a `Global` settings class to the `foo_scala/app/Global.scala` with the
    following content:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/app/Global.scala`中添加一个`Global`设置类，内容如下：
- en: '[PRE13]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the Spring configuration class to `foo_scala/app/SpringConfig.scala` with
    the following content:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加Spring配置类到`foo_scala/app/SpringConfig.scala`，内容如下：
- en: '[PRE14]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Request our new route and examine the response body to confirm:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求我们的新路由并检查响应体以确认：
- en: '[PRE15]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works…
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we configured our Play application to utilize Dependency injection
    in our controllers and service classes using Spring. We configured Spring in the
    `Global` settings file and loaded the `SpringConfig` class, which will contain
    our Spring-specific configurations.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们配置了我们的Play应用程序，使用Spring在我们的控制器和服务类中进行依赖注入。我们在`Global`设置文件中配置了Spring，并加载了`SpringConfig`类，它将包含我们的Spring特定配置。
- en: Dependency injection using Guice
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Guice进行依赖注入
- en: For this recipe, we will explore how to integrate Google Guice with a Play application.
    We will use Guice for bean instantiation and injection using Play controllers
    and service classes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将探讨如何将Google Guice与Play应用程序集成。我们将使用Guice进行Bean实例化和通过Play控制器和服务类进行注入。
- en: How to do it…
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'For Java, we need to take the following steps:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java，我们需要采取以下步骤：
- en: 'Run the `foo_java` application with Hot-Reloading enabled:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用Hot-Reloading运行`foo_java`应用程序：
- en: '[PRE16]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Declare the `guice` module as a project dependency in `build.sbt`:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`build.sbt`中将`guice`模块声明为项目依赖项：
- en: '[PRE17]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Configure Guice by modifying the contents of the `Global` settings class:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过修改`Global`设置类的内容来配置Guice：
- en: '[PRE18]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a category controller in `foo_java/app/controllers/CategoryController.java`
    by adding the following content:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_java/app/controllers/CategoryController.java`中创建一个分类控制器，通过添加以下内容：
- en: '[PRE19]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a category service interface in `foo_java/app/services/CategoryService.java`
    by adding the following content:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_java/app/services/CategoryService.java`中创建一个分类服务接口，通过添加以下内容：
- en: '[PRE20]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a category service implementation class in `foo_java/app/services/CategoryServicesImpl.java`
    by adding the following content:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_java/app/services/CategoryServicesImpl.java`中创建一个分类服务实现类，通过添加以下内容：
- en: '[PRE21]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add a new routes entry for the newly added action to `foo_java/conf/routes`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_java/conf/routes`中为新增的操作添加一个新的路由条目：
- en: '[PRE22]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Request our new route and examine the response headers to confirm our modifications
    to the HTTP response header:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求我们的新路由并检查响应头以确认我们对HTTP响应头的修改：
- en: '[PRE23]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For Scala, we need to take the following steps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Scala，我们需要采取以下步骤：
- en: 'Run the `foo_scala` application with Hot-Reloading enabled:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用Hot-Reloading运行`foo_scala`应用程序：
- en: '[PRE24]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Declare the `securesocial` module as a project dependency in `build.sbt`:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`build.sbt`中将`securesocial`模块声明为项目依赖项：
- en: '[PRE25]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Configure Guice by modifying the contents of the `Global` settings class:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过修改`Global`设置类的内容来配置Guice：
- en: '[PRE26]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create a category controller in `foo_scala/app/controllers/CategoryController.scala`
    by adding the following content:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/app/controllers/CategoryController.scala`中创建一个分类控制器，通过添加以下内容：
- en: '[PRE27]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create a category service in `foo_scala/app/services/CategoryService.scala`
    by adding the following content:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/app/services/CategoryService.scala`中创建一个分类服务，通过添加以下内容：
- en: '[PRE28]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add a new routes entry for the newly added action to `foo_scala/conf/routes`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/conf/routes`中为新增的操作添加一个新的路由条目：
- en: '[PRE29]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Request our new route and examine the response headers to confirm our modifications
    to the HTTP response header:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求我们的新路由并检查响应头以确认我们对HTTP响应头的修改：
- en: '[PRE30]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works…
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we configured our Play application to utilize Dependency injection
    in our controllers and service classes using Google Guice. We configured Guice
    in the `Global` settings file, which will contain our Guice-specific configurations.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们配置了我们的Play应用程序，使用Google Guice在我们的控制器和服务类中实现依赖注入。我们在`Global`设置文件中配置了Guice，它将包含我们的Guice特定配置。
- en: Utilizing MongoDB
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用MongoDB
- en: For this recipe, we will explore how to utilize MongoDB, the popular NoSQL library,
    within a Play application. MongoDB is one of the most widely-used NoSQL databases,
    and it most certainly has been a viable option as a datastore for many modern
    web applications. We will be using the Scala module, play-plugins-salat, which
    is an Object relation mapping tool that uses the official MongoDB Scala driver
    Casbah. This will be a Scala-only recipe.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将探讨如何在Play应用程序中利用流行的NoSQL库MongoDB。MongoDB是最广泛使用的NoSQL数据库之一，它无疑已经成为许多现代Web应用程序的数据存储的有效选择。我们将使用Scala模块，play-plugins-salat，这是一个使用官方MongoDB
    Scala驱动程序Casbah的对象关系映射工具。这将是一个仅限Scala的菜谱。
- en: For more information about Casbah, please refer to [https://github.com/mongodb/casbah](https://github.com/mongodb/casbah).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Casbah的更多信息，请参阅[https://github.com/mongodb/casbah](https://github.com/mongodb/casbah)。
- en: How to do it…
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s take the following steps:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们采取以下步骤：
- en: 'Run the `foo_scala` application with Hot-Reloading enabled:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用Hot-Reloading运行`foo_scala`应用程序：
- en: '[PRE31]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Declare play-plugins-salat as a project dependency in `build.sbt`:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`build.sbt`中将play-plugins-salat声明为项目依赖项：
- en: '[PRE32]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add additional salat and MongoDB directives to `build.sbt`:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`build.sbt`中添加额外的salat和MongoDB指令：
- en: '[PRE33]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Declare the salat plugin in `foo_scala/conf/play.plugins`:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/conf/play.plugins`中声明salat插件：
- en: '[PRE34]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Declare the MongoDB instance information in `foo_scala/conf/application.conf`:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/conf/application.conf`中声明MongoDB实例信息：
- en: '[PRE35]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Modify `foo_scala/app/controllers/WarehouseController.scala` by adding the
    following content:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下内容修改`foo_scala/app/controllers/WarehouseController.scala`：
- en: '[PRE36]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add new routes for the newly added action to `foo_scala/conf/routes`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新添加的操作的新路由添加到 `foo_scala/conf/routes`：
- en: '[PRE37]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add the collection mapping for the warehouse model to `foo_scala/app/models/Warehouse.scala`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将仓库模型的集合映射添加到 `foo_scala/app/models/Warehouse.scala`：
- en: '[PRE38]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Add the Mongo context to `foo_scala/app/models/mongoContext.scala`:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Mongo 上下文添加到 `foo_scala/app/models/mongoContext.scala`：
- en: '[PRE39]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Add a new warehouse record by accessing the warehouse post endpoint using `curl`:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用 `curl` 访问仓库 post 端点来添加新的仓库记录：
- en: '[PRE40]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'View all warehouse records by accessing the warehouse index endpoint using
    `curl`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用 `curl` 访问仓库索引端点来查看所有仓库记录：
- en: '[PRE41]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works…
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we created a new URL route and action that will insert and
    retrieve warehouse records from a MongoDB instance. We used the Play module play-plugins-salat
    and configured the connection in `foo_scala/conf/application.conf`. We then mapped
    our Mongo collection in the warehouse model class:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了一个新的 URL 路由和操作，用于从 MongoDB 实例中插入和检索仓库记录。我们使用了 Play 模块 play-plugins-salat，并在
    `foo_scala/conf/application.conf` 中配置了连接。然后我们在仓库模型类中映射了我们的 Mongo 集合：
- en: '[PRE42]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we invoked the appropriate warehouse companion object methods from the
    warehouse controller:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从仓库控制器中调用了适当的仓库伴生对象方法：
- en: '[PRE43]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We also declared our JSON binders for the warehouse model and MongoDB''s `ObjectId`
    in the warehouse controller:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在仓库控制器中声明了我们的 JSON 绑定器，用于仓库模型和 MongoDB 的 `ObjectId`：
- en: '[PRE44]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Utilizing MongoDB and GridFS
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用 MongoDB 和 GridFS
- en: For this recipe, we will explore how to store and deliver files with Play applications
    by using MongoDB and GridFS. We will continue by adding to the previous recipe.
    As with the previous recipe, this recipe will be Scala only.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将探索如何通过使用 MongoDB 和 GridFS 来存储和交付文件，通过 Play 应用程序。我们将继续添加到之前的菜谱。与之前的菜谱一样，这个菜谱将只使用
    Scala。
- en: How to do it…
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s take the following steps:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们采取以下步骤：
- en: 'Run the `foo_scala` application with Hot-Reloading enabled:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以启用热重载的方式运行 `foo_scala` 应用程序：
- en: '[PRE45]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Modify `foo_scala/app/controllers/WarehouseController.scala` by adding the
    following content:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下内容修改 `foo_scala/app/controllers/WarehouseController.scala`：
- en: '[PRE46]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Add new routes for the newly added action to `foo_scala/conf/routes`:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新添加的操作的新路由添加到 `foo_scala/conf/routes`：
- en: '[PRE47]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Modify the collection mapping for the warehouse model in `foo_scala/app/models/Warehouse.scala`:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改仓库模型在 `foo_scala/app/models/Warehouse.scala` 中的集合映射：
- en: '[PRE48]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Upload a new warehouse asset file by accessing the warehouse upload endpoint
    using `curl`:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用 `curl` 访问仓库上传端点来上传新的仓库资产文件：
- en: '[PRE49]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Verify that our file delivery URL route is working by accessing the URL in
    a web browser that is part of the output of the previous step:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 Web 浏览器中访问前一步输出的 URL 来验证我们的文件交付 URL 路由是否正常工作：
- en: '[PRE50]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How it works…
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we created new URL routes and actions that will be used to
    upload and retrieve warehouse asset files in a MongoDB instance using GridFS.
    We added the GridFS reference to our collection mapping file in `foo_scala/app/models/Warehouse.scala`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了新的 URL 路由和操作，这些操作将用于在 MongoDB 实例中使用 GridFS 上传和检索仓库资产文件。我们在 `foo_scala/app/models/Warehouse.scala`
    中的集合映射文件中添加了 GridFS 引用：
- en: '[PRE51]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We then added the respective methods for file upload and retrieval:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加了文件上传和检索的相关方法：
- en: '[PRE52]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Next, we created the actions in `foo_scala/app/controllers/WarehouseController.scala`,
    which will handle the actual file upload and retrieval requests.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在 `foo_scala/app/controllers/WarehouseController.scala` 中创建了操作，这些操作将处理实际的文件上传和检索请求。
- en: Utilizing Redis
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用 Redis
- en: For this recipe, we will explore how Play applications integrate with Redis
    using Play cache. Redis is a widely used key-value database, usually utilized
    as an intermediary object cache for modern web applications. This recipe requires
    a running Redis instance that our Play 2 web application can interface with.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将探索 Play 应用程序如何通过 Play 缓存与 Redis 集成。Redis 是一个广泛使用的键值数据库，通常用作现代 Web
    应用程序的中介对象缓存。这个菜谱需要一个正在运行的 Redis 实例，我们的 Play 2 Web 应用程序可以与之交互。
- en: How to do it…
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'For Java, we need to take the following steps:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Java，我们需要采取以下步骤：
- en: 'Run the `foo_java` application with Hot-Reloading enabled:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以启用热重载的方式运行 `foo_java` 应用程序：
- en: '[PRE53]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Declare Redis as a project dependency in `build.sbt`:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `build.sbt` 中将 Redis 声明为项目依赖项：
- en: '[PRE54]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Declare the repository hosting Sedis, a library dependency of play-plugins-redis
    in `build.sbt`:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `build.sbt` 中声明托管 Sedis 的存储库，它是 play-plugins-redis 的库依赖项：
- en: '[PRE55]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Enable the play-mailer plugin by declaring it in `foo_java/conf/play.plugins`:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 `foo_java/conf/play.plugins` 中声明它来启用 play-mailer 插件：
- en: '[PRE56]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Specify your Redis host information in `foo_java/conf/application.conf`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `foo_java/conf/application.conf` 中指定您的 Redis 主机信息：
- en: '[PRE57]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Modify `foo_java/app/controllers/Application.java` by adding the following
    code:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 `foo_java/app/controllers/Application.java` 中添加以下代码来修改 `foo_java`：
- en: '[PRE58]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Add a new routes entry for the newly added action to `foo_java/conf/routes`:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `foo_java/conf/routes` 中为新增的动作添加一个新的路由条目：
- en: '[PRE59]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Request our new route and examine the response body to confirm that our `displayFromCache`
    action is setting the key value for the first time:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求我们的新路由并检查响应体以确认我们的 `displayFromCache` 动作是第一次设置键值：
- en: '[PRE60]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Request the `/cache` route again to be able to view the value of the cache
    key:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次请求 `/cache` 路由以查看缓存键的值：
- en: '[PRE61]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'For Scala, we need to take the following steps:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Scala，我们需要采取以下步骤：
- en: 'Run the `foo_scala` application with Hot-Reloading enabled:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用 Hot-Reloading 运行 `foo_scala` 应用程序：
- en: '[PRE62]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Declare Redis as a project dependency in `build.sbt`:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `build.sbt` 中声明 Redis 为项目依赖项：
- en: '[PRE63]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Declare the repository hosting Sedis, a library dependency of play-plugins-redis,
    in `build.sbt`:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `build.sbt` 中声明托管 Sedis 的仓库，它是 play-plugins-redis 的库依赖项：
- en: '[PRE64]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Enable the play-mailer plugin by declaring it in `foo_scala/conf/play.plugins`:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 `foo_scala/conf/play.plugins` 中声明启用 play-mailer 插件：
- en: '[PRE65]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Specify your Redis host information in `foo_scala/conf/application.conf`:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `foo_scala/conf/application.conf` 中指定您的 Redis 主机信息：
- en: '[PRE66]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Modify `foo_scala/app/controllers/Application.scala` by adding the following
    code:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 `foo_scala/app/controllers/Application.scala` 中添加以下代码来修改 `foo_scala`：
- en: '[PRE67]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Add a new routes entry for the newly added `action` to `foo_scala/conf/routes`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `foo_scala/conf/routes` 中为新增的 `action` 添加一个新的路由条目：
- en: '[PRE68]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Request our new route and examine the response body to confirm that our `displayFromCache`
    action is setting the key value for the first time:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求我们的新路由并检查响应体以确认我们的 `displayFromCache` 动作是第一次设置键值：
- en: '[PRE69]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Request the `/cache` route again to be able to view the value of the cache
    key:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次请求 `/cache` 路由以查看缓存键的值：
- en: '[PRE70]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: How it works…
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In this recipe, we created a new URL route and action that will interact with
    our Redis instance. To follow on with this recipe, you will need the following
    running Redis instance to connect to:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了一个新的 URL 路由和动作，它将与我们 Redis 实例交互。为了继续这个菜谱，你需要以下正在运行的 Redis 实例来连接：
- en: '[PRE71]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: For more information about installing and running a Redis server, please refer
    to [http://redis.io/topics/quickstart](http://redis.io/topics/quickstart).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有关安装和运行 Redis 服务器的更多信息，请参阅 [http://redis.io/topics/quickstart](http://redis.io/topics/quickstart)。
- en: 'We configured the Play Redis module by declaring the necessary dependencies
    and repository settings in `build.sbt`. We then configured the connection to the
    Redis instance in `conf/application.conf`. Finally, we loaded the Redis play-plugin
    in `conf/play.plugins`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 `build.sbt` 中声明必要的依赖项和仓库设置来配置了 Play Redis 模块。然后我们在 `conf/application.conf`
    中配置了到 Redis 实例的连接。最后，我们在 `conf/play.plugins` 中加载了 Redis play-plugin：
- en: '[PRE72]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `displayFromCache` action, when invoked, has two distinct functions. First,
    it attempts to retrieve a value from the cache. If it is able to retrieve a value
    from the Redis cache, it prints the contents of the value in the response body.
    If it is unable to retrieve a value from the Redis cache, it sets a random string
    value to the key and prints a status message in the response body.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `displayFromCache` 动作被调用时，有两个不同的功能。首先，它尝试从缓存中检索一个值。如果它能够从 Redis 缓存中检索到一个值，它将在响应体中打印该值的正文。如果它无法从
    Redis 缓存中检索到一个值，它将设置一个随机字符串值到键，并在响应体中打印一个状态消息。
- en: We then used `curl` to test out this new route and accessed the route twice;
    the action printed out two different messages in the response body.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后使用 `curl` 测试这条新路由，并访问了两次该路由；动作在响应体中打印出两条不同的消息。
- en: Integrating Play application with Amazon S3
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Play 应用程序与 Amazon S3 集成
- en: For this recipe, we will explore how Play applications can upload files directly
    to **Amazon Web Services** (**AWS**) S3, a popular cloud storage solution.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将探讨 Play 应用程序如何直接将文件上传到 **Amazon Web Services** (**AWS**) S3，这是一个流行的云存储解决方案。
- en: For more information about S3, please refer to [http://aws.amazon.com/s3/](http://aws.amazon.com/s3/).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 S3 的更多信息，请参阅 [http://aws.amazon.com/s3/](http://aws.amazon.com/s3/)。
- en: How to do it…
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'For Java, we need to take the following steps:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Java，我们需要采取以下步骤：
- en: 'Run the `foo_java` application with Hot-Reloading enabled:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用 Hot-Reloading 运行 `foo_java` 应用程序：
- en: '[PRE73]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Declare play-s3 as a project dependency in `build.sbt`:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `build.sbt` 中将 play-s3 声明为项目依赖项：
- en: '[PRE74]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Specify your AWS credentials in `foo_java/conf/application.conf`:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `foo_java/conf/application.conf` 中指定您的 AWS 凭据：
- en: '[PRE75]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Modify `foo_java/app/controllers/Application.java` by adding the following
    code:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下代码修改`foo_java/app/controllers/Application.java`：
- en: '[PRE76]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Add a new routes entry for the newly added action to `foo_java/conf/routes`:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_java/conf/routes`中为新增的动作添加新的路由条目：
- en: '[PRE77]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Add the S3 file upload submission View template to `foo_java/app/views/s3.scala.html`:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将S3文件上传提交视图模板添加到`foo_java/app/views/s3.scala.html`：
- en: '[PRE78]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'For Scala, we need to take the following steps:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Scala，我们需要采取以下步骤：
- en: 'Run the `foo_scala` application with Hot-Reloading enabled:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以启用热重载的方式运行`foo_scala`应用程序：
- en: '[PRE79]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Declare play-s3 as a project dependency in `build.sbt`:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`build.sbt`中将play-s3声明为项目依赖项：
- en: '[PRE80]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Declare the custom repository where the play-s3 module is hosted:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明play-s3模块托管的自定义仓库：
- en: '[PRE81]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Specify your AWS credentials in `foo_scala/conf/application.conf`:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/conf/application.conf`中指定您的AWS凭证：
- en: '[PRE82]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Modify `foo_scala/app/controllers/Application.scala` by adding the following
    code:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`foo_scala/app/controllers/Application.scala`文件，添加以下代码：
- en: '[PRE83]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Add a new routes entry for the newly added action to `foo_scala/conf/routes`:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/conf/routes`中为新增的动作添加新的路由条目：
- en: '[PRE84]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: How it works…
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In this recipe, we created a new URL route and action that received the uploaded
    file. We then pushed this file to Amazon S3 using the RhinoFly S3 module by supplying
    the S3 access and secret keys in `conf/application.conf`. We also specified our
    S3 bucket name in `conf/application.conf` for future use. We are able to retrieve
    this value by using Play''s configuration API:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们创建了一个新的URL路由和动作，用于接收上传的文件。然后我们通过在`conf/application.conf`中提供S3访问密钥和秘密密钥，使用RhinoFly
    S3模块将此文件推送到Amazon S3。我们还指定了`conf/application.conf`中的S3存储桶名称以供将来使用。我们可以通过使用Play的配置API来检索此值：
- en: '[PRE85]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We then printed the location of the uploaded file to the response body for
    easy verification:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后将上传文件的存储位置打印到响应体中，以便于验证：
- en: '[PRE86]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'You should now see the response in the web browser with the following text:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该在网页浏览器中看到以下文本的响应：
- en: '[PRE87]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'You can also use the AWS Management Console to verify the file upload in the
    S3 section:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用AWS管理控制台在S3部分验证文件上传：
- en: '![](img/Vt98tzVB.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Vt98tzVB.jpg)'
- en: Integrating with Play application Typesafe Slick
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Typesafe Slick集成到Play应用程序中
- en: In this recipe, we will explore how we can integrate Typesafe Slick with Play
    applications using the `play-slick` module. Typesafe Slick is a relational mapping
    tool built on Scala and is handy for managing database objects like native Scala
    types.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将探讨如何使用`play-slick`模块将Typesafe Slick与Play应用程序集成。Typesafe Slick是一个基于Scala构建的关系映射工具，对于管理类似原生Scala类型的数据库对象来说非常方便。
- en: How to do it…
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'We need to take the following steps:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要采取以下步骤：
- en: 'Run the `foo_scala` application with Hot-Reloading enabled:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以启用热重载的方式运行`foo_scala`应用程序：
- en: '[PRE88]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Declare play-slick as a project dependency in `build.sbt`:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`build.sbt`中将play-slick声明为项目依赖项：
- en: '[PRE89]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Specify your database host information in `foo_scala/conf/application.conf`:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/conf/application.conf`中指定您的数据库主机信息：
- en: '[PRE90]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Create the new supplier controller in `foo_scala/app/controllers/SupplierController.scala`
    with the following content:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下内容创建新的供应商控制器`foo_scala/app/controllers/SupplierController.scala`：
- en: '[PRE91]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Create a Slick mapping for suppliers in the `foo_scala/app/models/Suppliers.scala`
    file with the following content:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/app/models/Suppliers.scala`文件中创建供应商的Slick映射，内容如下：
- en: '[PRE92]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Add the new routes for the `Supplier` controller in `foo_scala/conf/routes`:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/conf/routes`中添加`Supplier`控制器的新的路由：
- en: '[PRE93]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Request the new `Post` route and examine the response headers and body to confirm
    that the record was inserted in the database:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求新的`Post`路由并检查响应头和体，以确认记录已插入数据库：
- en: '[PRE94]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Request the listing route and verify that it is, in fact, returning records
    from the database:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求列表路由并验证它确实正在从数据库返回记录：
- en: '[PRE95]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: How it works…
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we created a new URL route and action that will create and retrieve
    suppliers from the `H2` database. We used Typesafe Slick as the relational mapping
    tool for creating queries and inserts. We started by declaring the required dependencies
    in `build.sbt`. Next, we defined the mapping properties for suppliers in `foo_scala/app/models/Supplier.scala`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们创建了一个新的URL路由和动作，用于从`H2`数据库中创建和检索供应商。我们使用Typesafe Slick作为关系映射工具来创建查询和插入。我们首先在`build.sbt`中声明了所需的依赖项。接下来，我们在`foo_scala/app/models/Supplier.scala`中定义了供应商的映射属性。
- en: In the mapping file, we declared our case class supplier. We also declared our
    Slick table mapping class. Lastly, we added our suppliers object class that should
    ideally contain all the required functions for data insertion and querying. We
    added the appropriate routes to the `conf/routes` file and ran the database evolution.
    This allows Slick to automatically manage table creation and column syncing. To
    test our implementation, we used curl to request our `POST` and `GET` endpoints
    to be able to view the response headers and body.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在映射文件中，我们声明了我们的case class供应商。我们还声明了我们的Slick表映射类。最后，我们添加了我们的供应商对象类，该类应包含所有数据插入和查询所需的功能。我们将适当的路由添加到`conf/routes`文件中，并运行数据库演变。这允许Slick自动管理表创建和列同步。为了测试我们的实现，我们使用curl请求我们的`POST`和`GET`端点，以便能够查看响应头和正文。
- en: Utilizing play-mailer
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用play-mailer
- en: For this recipe, we will explore how Play applications can send e-mails. We
    will use the Play module play-mailer to achieve this. We will be utilizing Mandrill,
    a cloud e-mailer service, to send out e-mails. For more information about Mandrill,
    please refer to [https://mandrill.com/](https://mandrill.com/).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将探讨Play应用程序如何发送电子邮件。我们将使用Play模块play-mailer来实现这一点。我们将使用Mandrill，一个云电子邮件服务，来发送电子邮件。有关Mandrill的更多信息，请参阅[https://mandrill.com/](https://mandrill.com/)。
- en: How to do it…
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'For Java, we need to take the following steps:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java，我们需要采取以下步骤：
- en: 'Run the `foo_java` application with Hot-Reloading enabled:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用Hot-Reloading后运行`foo_java`应用程序：
- en: '[PRE96]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Declare play-mailer as a project dependency in `build.sbt`:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`build.sbt`中将play-mailer声明为项目依赖项：
- en: '[PRE97]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Enable the play-mailer plugin by declaring it in `foo_java/conf/play.plugins`:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`foo_java/conf/play.plugins`中声明它来启用play-mailer插件：
- en: '[PRE98]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Specify your `smtp` host information in `foo_java/conf/application.conf`:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_java/conf/application.conf`中指定你的`smtp`主机信息：
- en: '[PRE99]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Modify `foo_java/app/controllers/Application.java` by adding the following
    code:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`foo_java/app/controllers/Application.java`中添加以下代码来修改`foo_java/app/controllers/Application.java`：
- en: '[PRE100]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Add a new routes entry for the newly added action to `foo_java/conf/routes`:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_java/conf/routes`中为新增的操作添加一个新的路由条目：
- en: '[PRE101]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Request our new route and examine the response headers to confirm our modifications
    to the HTTP response header:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求我们的新路由并检查响应头以确认我们对HTTP响应头的修改：
- en: '[PRE102]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'For Scala, we need to take the following steps:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Scala，我们需要采取以下步骤：
- en: 'Run the `foo_scala` application with Hot-Reloading enabled:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用Hot-Reloading后运行`foo_scala`应用程序：
- en: '[PRE103]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Declare play-mailer as a project dependency in `build.sbt`:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`build.sbt`中将play-mailer声明为项目依赖项：
- en: '[PRE104]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Enable the play-mailer plugin by declaring it in `foo_scala/conf/play.plugins`:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`foo_scala/conf/play.plugins`中声明它来启用play-mailer插件：
- en: '[PRE105]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Specify your `smtp` host information in `foo_scala/conf/application.conf`:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/conf/application.conf`中指定你的`smtp`主机信息：
- en: '[PRE106]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Modify `foo_scala/app/controllers/Application.scala` by adding the following
    action:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`foo_scala/app/controllers/Application.scala`中添加以下操作来修改`foo_scala/app/controllers/Application.scala`：
- en: '[PRE107]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Add a new routes entry for the newly added action to `foo_scala/conf/routes`:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/conf/routes`中为新增的操作添加一个新的路由条目：
- en: '[PRE108]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Request our new route and examine the response headers to confirm our modifications
    to the HTTP response header:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求我们的新路由并检查响应头以确认我们对HTTP响应头的修改：
- en: '[PRE109]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: How it works…
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created a new URL route and action that will invoke our newly
    added `sendMail` function. We declared the module dependency in `foo_scala/build.sbt`
    and specified our `smtp` server settings in `foo_scala/conf/application.conf`.
    After this, we invoked the URL route using `curl` in the terminal to test out
    our e-mail sender. You should now receive the e-mail in your e-mail client software.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了一个新的URL路由和操作，该操作将调用我们新添加的`sendMail`函数。我们在`foo_scala/build.sbt`中声明了模块依赖，并在`foo_scala/conf/application.conf`中指定了我们的`smtp`服务器设置。之后，我们使用终端中的`curl`调用了URL路由来测试我们的电子邮件发送者。你现在应该能在你的电子邮件客户端软件中收到电子邮件。
- en: Integrating Bootstrap and WebJars
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成Bootstrap和WebJars
- en: For this recipe, we will explore how we can integrate and utilize the popular
    frontend framework Bootstrap with a Play 2 web application. We will integrate
    Bootstrap using WebJars, which is a tool to package frontend libraries into JAR
    files that can then be easily managed (in our case, by `sbt`).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将探讨如何将流行的前端框架Bootstrap与Play 2 Web应用程序集成和利用。我们将使用WebJars来集成Bootstrap，这是一个将前端库打包成JAR文件的工具，然后可以轻松管理（在我们的情况下，通过`sbt`）。
- en: How to do it…
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'For Java, we need to take the following steps:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java，我们需要采取以下步骤：
- en: 'Run the `foo_java` application with Hot-Reloading enabled:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用Hot-Reloading后运行`foo_java`应用程序：
- en: '[PRE110]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Declare Bootstrap and WebJars as a project dependency in `build.sbt`:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`build.sbt`中将Bootstrap和WebJars声明为项目依赖项：
- en: '[PRE111]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Modify `foo_java/app/controllers/Application.java` by adding the following
    code:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下代码修改`foo_java/app/controllers/Application.java`：
- en: '[PRE112]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Add the new route entries to `foo_java/conf/routes`:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的路由条目添加到`foo_java/conf/routes`：
- en: '[PRE113]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Create the new layout View template in `foo_java/app/views/mainLayout.scala.html`
    with the following content:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新的布局视图模板`foo_java/app/views/mainLayout.scala.html`，内容如下：
- en: '[PRE114]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Create the Bootstrapped View template in `foo_java/app/views/bootstrapped.scala.html`
    with the following content:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_java/app/views/bootstrapped.scala.html`中创建自举视图模板，内容如下：
- en: '[PRE115]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Request our new Bootstrapped route (`http://localhost:9000/bootstrapped`) using
    a web browser and examine the rendered page using a Bootstrap template:![](img/TwofsdMh.jpg)
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用网络浏览器请求我们的新自举路由（`http://localhost:9000/bootstrapped`）并检查使用Bootstrap模板渲染的页面：![图片](img/TwofsdMh.jpg)
- en: 'For Scala, we need to take the following steps:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Scala，我们需要采取以下步骤：
- en: 'Run the `foo_scala` application with Hot-Reloading enabled:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用热重载运行`foo_scala`应用程序：
- en: '[PRE116]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Declare Bootstrap and WebJars as a project dependency in `build.sbt`:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`build.sbt`中将Bootstrap和WebJars声明为项目依赖项：
- en: '[PRE117]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Modify `foo_scala/app/controllers/Application.scala` by adding the following
    action:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下操作修改`foo_scala/app/controllers/Application.scala`：
- en: '[PRE118]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Add the new route entries to `foo_scala/conf/routes`:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的路由条目添加到`foo_scala/conf/routes`：
- en: '[PRE119]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Create the new layout view template in `foo_scala/app/views/mainLayout.scala.html`
    with the following content:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新的布局视图模板`foo_scala/app/views/mainLayout.scala.html`，内容如下：
- en: '[PRE120]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Create the bootstrapped View template in `foo_scala/app/views/bootstrapped.scala.html`
    with the following content:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/app/views/bootstrapped.scala.html`中创建自举视图模板，内容如下：
- en: '[PRE121]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Request our new bootstrapped route (`http://localhost:9000/bootstrapped`) using
    a web browser and examine the rendered page using a Bootstrap template:![](img/Zhuvkkee.jpg)
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用网络浏览器请求我们的新自举路由（`http://localhost:9000/bootstrapped`）并检查使用Bootstrap模板渲染的页面：![图片](img/Zhuvkkee.jpg)
- en: How it works…
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: In this recipe, instead of downloading Bootstrap separately and managing different
    versions manually, we used the Play module and WebJars, declaring Bootstrap as
    a frontend dependency in `build.sbt`. We created the new View templates containing
    the Bootstrap template. We then created a new URL route that will utilize these
    new Bootstrap-based views.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们不是单独下载Bootstrap并手动管理不同版本，而是使用了Play模块和WebJars，在`build.sbt`中将Bootstrap声明为前端依赖。我们创建了包含Bootstrap模板的新视图模板。然后我们创建了一个新的URL路由，将利用这些基于Bootstrap的新视图。
