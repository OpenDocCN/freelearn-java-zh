- en: Optimizing the Sort - Making Code Professional
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化排序 - 使代码专业
- en: 'In this chapter, we will develop the sorting code and make it more general.
    We want to sort not only an array of Strings. Essentially, we will write a program
    that can sort anything that is sortable. That way, we will bring the coding to
    its full extent toward one of the major strengths of Java: *abstraction*.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开发排序代码并使其更加通用。我们不仅想要排序字符串数组。本质上，我们将编写一个可以排序任何可排序内容的程序。这样，我们将把编码推向其极限，朝着Java的一个主要优势：*抽象*。
- en: 'Abstraction, however, does not come without a price tag. When you have a class
    that sorts strings and you accidentally mix an integer or something else, which
    is not a string, into the sortable data, then the compiler will complain about
    it: Java does not allow you to put an `int` into a `String` array. When the code
    is more abstract, such programming errors may slip in. We will look at how to
    handle such exceptional cases catching and throwing Exceptions.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，抽象并不是没有代价的。当你有一个排序字符串的类，你意外地将一个整数或其他不是字符串的东西混合到可排序的数据中，编译器将会抱怨：Java不允许你将`int`放入`String`数组中。当代码更加抽象时，这样的编程错误可能会悄悄溜进来。我们将探讨如何通过捕获和抛出异常来处理这样的异常情况。
- en: To identify the bugs, we will use unit testing, applying the industry standard
    JUnit version 4\. As JUnit heavily uses annotation, and because annotations are
    important, you will learn about it a bit.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了识别错误，我们将使用单元测试，应用行业标准JUnit 4版本。由于JUnit大量使用注解，并且因为注解很重要，你将对其有所了解。
- en: After that, we will modify the code to use the *generics* feature of Java that
    was introduced into the language in version 5\. Using that possibility, we will
    catch the coding error during compilation time, which is better than during run
    time. The earlier a bug is identified, the cheaper it is to fix.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将修改代码以使用Java 5版本中引入的*泛型*特性。利用这个可能性，我们将在编译时捕获编码错误，这比在运行时更好。越早发现错误，修复成本就越低。
- en: For the build, we will still use Maven, but this time, we will split the code
    into small modules. Thus, we will have a multi-module project. We will have separate
    modules for the definition of a sorting module and for the different implementations.
    That way, we will look at how classes can extend each other and implement interfaces,
    and, generally, we will really start to program in the object-oriented way.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 对于构建，我们仍然会使用Maven，但这次，我们将代码拆分成小的模块。这样，我们将有一个多模块项目。我们将为排序模块的定义和不同的实现分别创建模块。这样，我们将研究类如何相互扩展并实现接口，并且，总的来说，我们将真正开始以面向对象的方式编程。
- en: 'We will also discuss **Test Driven Development** (**TDD**), and at the end
    of the section, we will start using the brand new feature of Java 9: module support.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将讨论**测试驱动开发**（**TDD**），在章节的结尾，我们将开始使用Java 9的新特性：模块支持。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Object-oriented programming principles
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程原则
- en: Unit testing practices
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试实践
- en: Algorithmic complexity and quick sort
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法复杂性和快速排序
- en: Exception handling
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理
- en: Recursive methods
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归方法
- en: Module support
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块支持
- en: The general sorting program
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用排序程序
- en: In the previous chapter, we implemented a simple sort algorithm. The code can
    sort elements of a `String` array. We did this to learn. For practical use, there
    is a ready cooked sort solution in the JDK that can sort members of `collections`,
    which are comparable.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们实现了一个简单的排序算法。这段代码可以排序`String`数组中的元素。我们这样做是为了学习。对于实际应用，JDK中有一个现成的排序解决方案，可以排序`collections`中的可比较成员。
- en: 'The JDK contains a utility class called `Collections`. This class contains
    a static `Collections.sort` method that is capable of sorting any `List` that
    has members that are `Comparable`. `List` and `Comparable` are interfaces defined
    in the JDK. Thus, if we want to sort a list of Strings, the simplest solution
    is as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: JDK中包含一个名为`Collections`的实用工具类。这个类包含一个静态的`Collections.sort`方法，能够对任何包含`Comparable`成员的`List`进行排序。`List`和`Comparable`是在JDK中定义的接口。因此，如果我们想对一个字符串列表进行排序，最简单的解决方案如下：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This code fragment is from a sample JUnit test, which is the reason we have
    the `@Test` annotation in front of the method. We will discuss that in detail
    later. To execute that test, you can issue the following command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段来自一个示例JUnit测试，这也是我们在方法前有`@Test`注解的原因。我们将在稍后详细讨论这一点。要执行这个测试，你可以输入以下命令：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This sort implementation, however, does not fit our needs. First of all, because
    it is there ready (no need to code) and using it does not need anything new that
    you have not learned in the previous chapters. Except for the annotation in front
    of the method, there is nothing new in the code that you cannot understand. You
    may refresh BY turning some pages back, or else consult the oracle online documentation
    of the JDK ([https://docs.oracle.com/javase/8/docs/api/](https://docs.oracle.com/javase/8/docs/api/)),
    but that is all. You already know these things.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个排序实现并不符合我们的需求。首先，因为它已经准备好了（无需编码）并且使用它不需要你在前几章中学到的新东西。除了方法前面的注解外，代码中没有你无法理解的新内容。你可以通过翻回一些页面来刷新，或者查阅JDK的在线文档（[https://docs.oracle.com/javase/8/docs/api/](https://docs.oracle.com/javase/8/docs/api/))，但这就足够了。你已经知道这些了。
- en: You may wonder why I wrote the URL for the Java version 8 API to the link. Well,
    then this is the moment of honesty and truth-when I wrote this book, the Java
    9 JDK was not available in its final form. I created most of the examples on my
    Mac Book using Java 8 and I only tested the features that are Java 9 specific.
    Support at the moment for Java 9 in the IDEs is not perfect. When you read this
    book, Java 9 will be available, so you can try and change that one single digit
    from 8 to 9 in the URL and get to the documentation of the version 9\. At the
    moment, I get HTTP ERROR 404.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道我为什么把Java版本8的API的URL写成了链接。嗯，那么这就是诚实和真实的时候——当我写这本书的时候，Java 9 JDK还没有最终形式。我大多数示例都是在我的Mac
    Book上使用Java 8创建的，我只测试了Java 9特有的功能。目前IDE对Java 9的支持并不完美。当你读这本书的时候，Java 9将会可用，所以你可以尝试将URL中的那个单个数字从8改为9，以获取版本9的文档。目前，我得到的是HTTP
    ERROR 404。
- en: Sometimes, you may need the documentation of older versions. You can use 3,
    4, 5, 6, or 7 instead of 8 in the URL. Documentation for 3 and 4 is not available
    to read online, but it can be downloaded. Hopefully, you will never need that
    anymore. Version 5, perhaps. Version 6 is still widely used at large corporations.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能需要查看旧版本的文档。你可以在URL中使用3、4、5、6或7代替8。3和4版本的文档无法在线阅读，但可以下载。希望你永远不会再需要它了。也许版本5会是这样。版本6在大公司中仍然被广泛使用。
- en: Although you can learn a lot from reading code that was written by other programmers,
    I do not recommend trying to learn from the JDK source code at this early stage
    of your studies. These blocks of code are heavily optimized, not meant to be tutorial
    codes, and old. They do not get rusted during the years, but they were not refactored
    to follow the coding styles of Java as it matured. At some places, you can find
    really ugly code in the JDK.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以从阅读其他程序员编写的代码中学到很多东西，但我不建议你在学习初期尝试从JDK源代码中学习。这些代码块经过了高度优化，不是教程代码，而且已经过时。它们在多年中并未生锈，但它们并没有被重构以遵循Java成熟后的编码风格。在某些地方，你可以在JDK中找到真正丑陋的代码。
- en: Okay, saying that we need to develop a new sort code because we can learn from
    it, is a bit contrived. The real reason why we need a sort implementation is that
    we want something that can sort not only `List` data types and a  `List` of something
    that implements the `Comparable` interface. We want to sort a bunch of objects.
    All we require is that the *bunch* containing the objects provides simple methods
    that are just enough to sort them and have a sorted *bunch*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，说我们需要开发一个新的排序代码，因为我们可以从中学到东西，这有点牵强。我们真正需要排序实现的原因是我们想要一个能够对不仅`List`数据类型和实现了`Comparable`接口的`List`进行排序的东西。我们想要对一组对象进行排序。我们唯一的要求是包含对象的这组提供简单的方法，这些方法足以对它们进行排序并得到一个排序后的组。
- en: Originally I wanted to use the word *collection* instead of *bunch*, but there
    is a `Collection` interface in Java and I wanted to emphasize that we are not
    talking about `java.util.Collection` of objects.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最初我想用“collection”这个词代替“bunch”，但Java中有一个`Collection`接口，我想强调我们不是在谈论`java.util.Collection`对象。
- en: We also do not want the objects to implement the `Comparable` interface. If
    we require the object to implement the `Comparable` interface, it may violate
    the **Single Responsibility Principle** (**SRP**).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也不希望对象实现`Comparable`接口。如果我们要求对象实现`Comparable`接口，可能会违反**单一职责原则**（**SRP**）。
- en: When we design a class, it should model some object class of the real world.
    We will model the problem space with classes. The class should implement the features
    that represent the behavior of the objects that it models. If we look at the example
    of students from the second chapter, then a `Student` class should represent the
    features that all students share, and is *important from the modeling point of
    view*. A `Student` object should be able to tell the name of the student, the
    age, the average scores of the last year, and so on. All students have feet, and
    certainly each of those feet have size so we may think that a `Student` class
    should also implement a method that returns the size of the student's foot (one
    for the left and one for the right just to be precise), but we do not. We do not,
    because the size of the foot is irrelevant from the model point of view. If we
    want to sort a list containing `Student` objects, the `Student` class has to implement
    the `Comparable` interface. But wait! How do you compare two students? By names,
    by age. or by the average score of them?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设计一个类时，它应该模拟现实世界中的某个对象类。我们将使用类来模拟问题空间。该类应该实现代表其模型对象行为的特征。如果我们看看第二章中的学生例子，那么一个`Student`类应该代表所有学生共有的特征，并且从建模角度来看是*重要的*。一个`Student`对象应该能够说出学生的名字、年龄、去年平均分数等等。所有学生都有脚，而且当然每只脚都有大小，所以我们可能会认为一个`Student`类也应该实现一个返回学生脚大小的方法（一只左脚和一只右脚，为了精确起见），但我们没有这么做。我们之所以没有这么做，是因为脚的大小从模型角度来看是不相关的。如果我们想要对一个包含`Student`对象的列表进行排序，`Student`类必须实现`Comparable`接口。但是等等！你怎么比较两个学生？是通过名字、年龄，还是通过他们的平均分数？
- en: Comparing a student to another is not a feature of the `Student`. Every class,
    or for that matter, package, library, or programming unit should have one responsibility
    and it should implement only that and nothing else. It is not exact. This is not
    mathematics. Sometimes, it is hard to tell if a feature fits into the responsibility
    or not. There are simple techniques. For example, in case of a student, you can
    ask the real person about his name and age, and probably they can also tell you
    their average score. If you ask one of them to `compareTo` (another student),
    as the `Comparable` interface requires this method, they will probably ask back,
    but by what attribute? Or how? Or just, what? In such a case, you can suspect
    that implementing the feature is probably not in the area of that class and this
    concern; the comparison should be segregated from the implementation of the original
    class. This is also called **Segregation of Concerns**, which is closely related
    to SRP.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个学生与另一个学生进行比较不是`Student`类的特征。每个类，或者更确切地说，每个包、库或编程单元都应该有一个职责，并且它应该只实现那个职责，不实现其他任何职责。这不是精确的。这不是数学。有时，很难判断一个特征是否适合于职责。有一些简单的技术。例如，在学生的例子中，你可以询问真实的人关于他的名字和年龄，他们可能也能告诉你他们的平均分数。如果你要求他们中的一个`compareTo`（另一个学生），正如`Comparable`接口所要求的这个方法，他们可能会反过来问，但是通过什么属性？或者怎么比较？或者只是，什么？在这种情况下，你可以怀疑实现这个特征可能不在该类和这个关注点的领域内；比较应该从原始类的实现中分离出来。这也被称为**关注点分离**，它与SRP密切相关。
- en: 'JDK developers were aware of this. `Collections.sort` that sorts a `List` of
    `Comparable` elements is not the only sorting method in this class. There is another
    that just sorts any `List` if you pass a second argument and object that implements
    the `Comparator` interface and is capable of comparing two elements of `List`.
    This is a clean pattern to separate the concerns. In some cases, separating the
    comparison is not needed. In other cases, it is desirable. The `Comparator` interface
    declares one single method that the implementing classes have to provide: `compare`.
    If the two arguments are equal, then this method returns `0`. If they are different,
    it should return a negative or a positive `int` depending on which argument precedes
    which one.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: JDK开发者对此有所了解。`Collections.sort`方法用于对一个包含`Comparable`元素的`List`进行排序，但这并不是这个类中唯一的排序方法。还有一个方法，如果你传递一个实现了`Comparator`接口的对象作为第二个参数，并且这个对象能够比较列表中的两个元素，那么它就可以对任何`List`进行排序。这是一种干净的分离关注点的模式。在某些情况下，不需要分离比较。在其他情况下，这是可取的。`Comparator`接口声明了一个实现类必须提供的一个单一方法：`compare`。如果两个参数相等，则此方法返回`0`。如果它们不同，则应根据哪个参数在前返回一个负数或正数`int`。
- en: There are also `sort` methods in the JDK class, `java.util.Arrays`. They sort
    arrays, or only a slice of an array. The method is a good example of method overloading.
    There are methods with the same name, but with different arguments to sort a whole
    array for each primitive type, for a slice of each, and also two for object array
    implementing the `Comparable` interface, and also for object array to be sorted
    using `Comparator`. As you see, there is a whole range of sort implementations
    available in the JDK, and in 99 percent of the cases, you will not need to implement
    a sort yourself. The sorts use the same algorithm, a stable merge sort with some
    optimization.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JDK 类 `java.util.Arrays` 中也有 `sort` 方法。它们可以排序数组，或者只排序数组的一部分。这个方法是方法重载的一个好例子。有同名的多个方法，但具有不同的参数，用于为每种原始类型排序整个数组，为每个切片排序，以及为实现了
    `Comparable` 接口的对象数组排序，还有为使用 `Comparator` 排序的对象数组排序。正如您所看到的，JDK 中有整个系列的排序实现可用，在
    99% 的情况下，您不需要自己实现排序。排序使用相同的算法，一种稳定的归并排序，并进行了优化。
- en: What we will implement is a general approach that can be used to sort lists,
    arrays, or just anything that has elements and it is possible to swap any two
    elements of it; the solution will be able to use the bubble sort that we have
    already developed and also other algorithms.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的是一个通用方法，可以用来排序列表、数组或任何具有元素且可以交换任意两个元素的东西；解决方案将能够使用我们已开发的冒泡排序以及其他算法。
- en: A brief overview of various sorting algorithms
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 各种排序算法的简要概述
- en: There are many different sorting algorithms. As I said, there are simpler and
    more complex algorithms and, in many cases, more complex algorithms are the ones
    that run faster. In this chapter, we will implement the bubble sort and quick
    sort. We have already implemented the bubble sort for strings in the previous
    chapter, so in this case, the implementation will mainly focus on the recoding
    for general sortable object sorting. Implementing quick sort will involve a bit
    of algorithmic interest.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的排序算法。正如我所说，有简单和复杂的算法，在许多情况下，更复杂的算法运行得更快。在本章中，我们将实现冒泡排序和快速排序。我们在上一章已经实现了字符串的冒泡排序，所以在这种情况下，实现将主要关注通用可排序对象排序的编码。实现快速排序将涉及一些算法兴趣。
- en: Be warned that this section is here to give you only a taste of algorithmic
    complexity. It is far from precise and I am in the vain hope that no mathematician
    reads this and puts a curse on me. Some of the explanations are vague. If you
    want to learn computer science in depth, then after reading this book, find some
    other books or visit online courses.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：本节旨在为您提供算法复杂性的初步了解。它远非精确，我抱有一种徒劳的希望，即没有数学家会阅读这篇文章并对我施加诅咒。一些解释可能比较模糊。如果您想深入学习计算机科学，那么在阅读这本书之后，请寻找其他书籍或访问在线课程。
- en: When we talk about the general sorting problem, we will think about some general
    set of objects that can be compared and any two of them can be swapped while we
    sort. We will also assume that this is an in-place sort; thus, we do not create
    another list or array to collect the original objects in sorted order. When we
    talk about the speed of an algorithm, we are talking about some abstract thing
    and not milliseconds. When we want to talk about milliseconds, actual real-world
    duration, we should already have some implementation in some programming language
    running on a real computer.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论通用排序问题时，我们会考虑一些可以比较的通用对象集，在排序过程中，任何两个对象都可以交换。我们还将假设这是一个就地排序；因此，我们不会创建另一个列表或数组来收集已排序的对象。当我们谈论算法的速度时，我们谈论的是一些抽象的东西，而不是毫秒。当我们想要谈论毫秒时，实际的现实世界持续时间，我们已经在某种编程语言中运行了一些实现，在真实的计算机上。
- en: Algorithms, in their abstract form, don't do that without implementation. Still,
    it is worth talking about the time and memory need of an algorithm. When we do
    that, we will usually investigate how the algorithm behaves for a large set of
    data. For a small set of data, most algorithms are just fast. Sorting two numbers
    is usually not an issue, is it?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在其抽象形式中，算法没有实现是不会那样做的。尽管如此，讨论算法的时间和内存需求仍然是有价值的。当我们这样做时，我们通常会研究算法在大量数据集上的行为。对于小数据集，大多数算法都运行得很快。排序两个数字通常不是问题，对吧？
- en: In case of sorting, we will usually examine how many comparisons are needed
    to sort a collection of *n* elements. Bubble sort needs approximately n² (n times
    *n*) comparisons. We cannot say that this is exactly *n*² because in case of *n=2*,
    the result is 1, for *n=3* it is 3, for *n=4* it is 6, and so on. However, as
    *n* starts to get larger, the actual number of comparisons needed and *n*² will
    asymptotically be of the same value. We say that the algorithmic complexity of
    the bubble sort is *O(n²)*. This is also called the big-O notation. If you have
    an algorithm that is *O(n²)* and it works just fine for 1,000 elements finishing
    in a second, then you should expect the same algorithm finishing for 1 million
    elements in around ten days or in a month. If the algorithm is linear, say *O(n)*,
    then finishing 1,000 element in one second should make you expect 1 million to
    be finished in 1,000 seconds. That is a bit longer than a coffee break and too
    short for lunch.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在排序的情况下，我们通常会检查排序*n*个元素集合需要多少比较。冒泡排序大约需要n²（n乘以n）次比较。我们不能说这正好是*n*²，因为当*n=2*时，结果是1，对于*n=3*它是3，对于*n=4*它是6，以此类推。然而，当*n*开始变得更大时，实际需要的比较次数和*n*²将趋于相同的值。我们说冒泡排序的算法复杂度是*O(n²)*。这也被称为大O符号。如果你有一个*O(n²)*的算法，并且它对于1,000个元素在1秒内运行良好，那么你应该预期这个算法在1百万个元素上大约需要10天或一个月。如果一个算法是线性的，即*O(n)*，那么在1秒内完成1,000个元素应该让你预期1百万个元素将在1,000秒内完成。这比咖啡休息时间长，但比午餐时间短。
- en: 'This makes it feasible that if we want some serious business sorting objects,
    we will need something better than bubble sort. That many unnecessary comparisons
    are not only wasting our time, but also CPU power, consuming energy, and polluting
    the environment. The question, however, is: how fast can a sort be? Is there a
    provable minimum that we cannot overcome?'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得如果我们想要进行一些严肃的商业排序对象，我们需要比冒泡排序更好的方法。这么多的不必要的比较不仅浪费我们的时间，还浪费CPU功率，消耗能源，污染环境。然而，问题是：排序可以有多快？是否存在一个无法克服的证明最小值？
- en: The answer is yes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是肯定的。
- en: When we implement any sorting algorithm, the implementation will execute comparisons
    and element swaps. That is the only way to sort a collection of objects. The outcome
    of a comparison can have two values. Say, these values are *0* or *1*. This is
    one bit of information. If the result of the comparison is *1*, then we swap,
    if the result is *0*, then we do not swap.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现任何排序算法时，实现将执行比较和元素交换。这是排序对象集合的唯一方法。比较的结果可以有两个值。比如说，这些值是*0*或*1*。这是一位信息。如果比较的结果是*1*，那么我们进行交换，如果结果是*0*，那么我们不交换。
- en: We can have the objects in different orders before we start the comparison and
    the number of different orders is *n!* (*n* factorial). That is, the numbers multiplied
    from 1 to *n*, in other words *n!*=1*2*3*...*(*n*-1)**n*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始比较之前，我们可以有不同顺序的对象，不同顺序的数量是*n!*（*n*的阶乘）。也就是说，从1乘到*n*的数，换句话说，*n!* = 1 * 2 *
    3 * ... * (*n*-1)**n*。
- en: Let's assume that we stored the result of the individual comparisons in a number
    as a series of bits for each possible input for the sort. Now, if we reverse the
    execution of the sort and run the algorithm starting from the sorted collection,
    control the swapping using the bits that described the results of the comparison,
    and we use the bits the other way around doing the last swap first and the one
    that was done first during the sorting first, we should get back the original
    order of the objects. This way, each original order is uniquely tied to a number
    expressed as an array of bits.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将单个比较的结果存储为一个数字，作为排序中每个可能输入的位序列。现在，如果我们反转排序的执行，从已排序的集合开始运行算法，使用描述比较结果的位来控制交换，并且我们以相反的方式使用这些位，即先进行最后一次交换，然后是排序过程中最先进行的交换，我们应该能够恢复对象的原始顺序。这样，每个原始顺序都与一个以位序列表示的数字唯一对应。
- en: 'Now, we can express the original question this way: how many bits are needed
    to describe *n* factorial different numbers? That is exactly the number of comparisons
    we will need to sort *n* elements. The number of bits is *log[2](n!)* . Using
    some mathematics, we will know that *log[2](n!)* is the same as *log[2](1)+ log[2](2)+...+
    log[2](n)*. If we look at this expression''s asymptotic value, then we can say
    that this is the same *O(n*log n)*. We should not expect any general sorting algorithm
    to be faster.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以这样表达原始问题：描述*n*阶乘的不同数字需要多少位？这正是我们需要对*n*个元素进行排序的比较次数。位数是*log[2](n!)*。通过一些数学运算，我们可以知道*log[2](n!)*等于*log[2](1)+
    log[2](2)+...+ log[2](n)*。如果我们观察这个表达式的渐近值，那么我们可以说这等同于*O(n*log n)*。我们不应该期望任何通用排序算法会更快。
- en: For special cases, there are faster algorithms. For example, if we want to sort
    1 million numbers that are each between one and 10, then we only need to count
    the number of the different numbers and then create a collection that contains
    that many ones, twos, and so on. This is an *O(n)* algorithm, but this is not
    applicable for the general case.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特殊情况，存在更快的算法。例如，如果我们想要对每个介于1到10之间的100万个数字进行排序，我们只需要计算不同数字的数量，然后创建一个包含这么多1、2等数字的集合。这是一个*O(n)*算法，但这种方法不适用于一般情况。
- en: Again, this was not a formal mathematical proof.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这并不是一个正式的数学证明。
- en: Quick sort
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速排序
- en: Sir Charles Antony Richard Hoare developed the quick sort algorithm in 1959\.
    It is a typical divide and conquer algorithm. To sort a long array, pick an element
    from the array that will be the pivot element. Then, partition the array so that
    the left side will contain all the elements that are smaller than the pivot and
    the right side will contain all the elements that are larger than, or equal to
    the pivot. When this is done, the left side and the right side of the array can
    be sorted by calling the sort recursively. To stop the recursion, when we have
    one single element in the array, we will declare it sorted.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 查尔斯·安东尼·理查德·霍华爵士于1959年开发了快速排序算法。这是一个典型的分而治之算法。为了对一个长数组进行排序，从数组中选取一个元素作为枢轴元素。然后，对数组进行分区，使得左侧将包含所有小于枢轴的元素，右侧将包含所有大于或等于枢轴的元素。完成此操作后，可以通过递归调用对数组的左侧和右侧进行排序。为了停止递归，当我们数组中只有一个元素时，我们将它声明为已排序。
- en: We talk about a recursive algorithm when the algorithm is defined partially
    using itself. The most famous recursive definition is the Fibonacci series that
    is 0 and 1 for the first two elements and any later element the *n*^(th) element
    is the sum of the (*n-1)*^(th) and the (*n-2)*^(th) element. Recursive algorithms
    are many times implemented in modern programming languages implementing a method
    that does some calculation but sometimes calls itself. When designing recursive
    algorithms, it is of utmost importance to have something that stops the recursive
    calls; otherwise, recursive implementation will allocate all memory available
    for the program stack and stop the program with error.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当算法部分地使用自身定义时，我们谈论递归算法。最著名的递归定义是斐波那契数列，前两个元素是0和1，任何后续元素的第*n*个元素是第(*n-1)*个元素和第(*n-2)*个元素的和。递归算法在现代编程语言中经常实现，通过一种执行某些计算但有时会调用自身的方。在设计递归算法时，拥有某种停止递归调用的机制至关重要；否则，递归实现将分配程序栈中所有可用的内存，并导致程序出错而停止。
- en: 'The partitioning algorithm goes the following way: we will start to read the
    array using two indices from the start and end. We will first start with the index
    that is small and increase the index until it is smaller than the large index,
    or until we find an element that is greater than or equal to the pivot. After
    this, we will start to decrease the larger index so long as it is greater than
    the small index and the element indexed is greater than or equal to the pivot.
    When we stop, we swap the two elements pointed by the two indices, if the indices
    are not the same, and we will start increasing and decreasing the small and large
    indices, respectively. If the indices are the same, then we are finished with
    the partitioning. The left side of the array is from the start to the index where
    the indices met minus one; the right side starts with the index and lasts until
    the end of the to-be-sorted array.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 分区算法的步骤如下：我们将从数组的开始和结束使用两个索引开始读取数组。我们首先从小的索引开始，增加索引直到它小于大的索引，或者直到我们找到一个大于或等于枢轴的元素。之后，我们将开始减少大的索引，只要它大于小的索引，并且索引处的元素大于或等于枢轴。当我们停止时，如果两个索引不相同，我们将交换两个索引指向的元素，然后分别开始增加和减少小和大索引。如果索引相同，那么分区就完成了。数组的左侧是从开始到两个索引相遇的索引减一；右侧从索引开始，一直持续到待排序数组的末尾。
- en: 'This algorithm is usually *O(n log n)*, but in some cases it can degrade to
    be *O(n²)*, depending on how the pivot is chosen. There are different approaches
    for the selection of the pivot. In this book, we will use the simplest: we will
    select the first element of the sortable collection as a pivot.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法通常是 *O(n log n)*，但在某些情况下可能会退化到 *O(n²)*，这取决于枢轴的选择。对于枢轴的选择有不同的方法。在这本书中，我们将使用最简单的方法：我们将选择可排序集合的第一个元素作为枢轴。
- en: Project structure and build tools
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目结构和构建工具
- en: 'The project this time will contain many modules. We will still use Maven in
    this chapter. We will set up a so-called multi-module project in Maven. In such
    a project, the directory contains the directories of the modules and `pom.xml`.
    There is no source code in this top-level directory. The `pom.xml` file in this
    directory serves the following two purposes:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这次的项目将包含许多模块。我们将在本章继续使用 Maven。我们将在 Maven 中设置一个所谓的多模块项目。在这样的项目中，目录包含模块的目录和 `pom.xml`
    文件。顶级目录中没有源代码。这个目录中的 `pom.xml` 文件有以下两个作用：
- en: It references the modules and can be used to compile, install, and deploy all
    the modules together
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它引用了模块，并且可以用来一起编译、安装和部署所有模块
- en: It defines parameters for the modules that are the same for all of them
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为所有模块定义了相同的参数
- en: 'Every `pom.xml` has a parent and this `pom.xml` is the parent of the `pom.xml`
    files in the module directories. To define the modules, the `pom.xml` file contains
    the following lines:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `pom.xml` 都有一个父级，这个 `pom.xml` 是模块目录中 `pom.xml` 文件的父级。为了定义模块，`pom.xml` 文件包含以下行：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'These are the names of the modules. These names are used as directory names
    and also as `artifactId` in the `pom.xml` module. The directories in this setup
    look as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是模块的名称。这些名称被用作目录名称，也用作 `pom.xml` 模块中的 `artifactId`。在这个设置中的目录看起来如下：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Maven dependency management
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maven 依赖管理
- en: 'Dependencies are also important in the POM file. The previous project did not
    have any dependency, but this time we will use JUnit. Dependencies are defined
    in `pom.xml` using the `dependencies` tag. For example, the bubble sort module
    contains the following piece of code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖关系在 POM 文件中也很重要。之前的项目没有依赖关系，但这次我们将使用 JUnit。依赖关系使用 `pom.xml` 中的 `dependencies`
    标签定义。例如，冒泡排序模块包含以下代码片段：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The actual `pom.xml` in the code set you can download will contain more code
    than this. In print, we often present a version or only a fraction that helps
    the understanding of the topic that we are discussing at that point.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以下载的代码集中的实际 `pom.xml` 将包含比这更多的代码。在印刷品中，我们经常展示一个版本或仅展示有助于理解我们当时讨论的主题的片段。
- en: It tells Maven that the module code uses classes, interfaces, and `enum` types
    that are defined in these modules that are available from some repository.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 它告诉 Maven，模块代码使用了在这些模块中定义的类、接口和 `enum` 类型，这些类型可以从某个仓库中获取。
- en: When you use Maven to compile the code, the libraries that are used by your
    code are available from repositories. When Ant was developed, the notion of repositories
    was not invented. At that time, the developers copied the used version of the
    library into a folder in the source code structure. Usually, the directory `lib`
    was used for the purpose. There were two problems with this approach. One is the
    size of the source code repository. If, for example, 100 different projects used
    JUnit, then the JAR file of the JUnit library was copied there 100 times. The
    other problem was to gather all the libraries. When a library used another library,
    the developers had to read the documentation of the library that described (many
    times outdated and not precise) what other libraries are needed to use this library.
    Those libraries had to be downloaded and installed the same way. This was time
    consuming and error prone. When a library was missing and the developers just
    did not notice it, the error was manifested during compile time when the compiler
    could not find the class or even only at runtime when the JVM was not able to
    load the class.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用 Maven 编译代码时，您的代码所使用的库可以从仓库中获取。当 Ant 被开发时，仓库的概念尚未发明。当时，开发者将库的所用版本复制到源代码结构中的一个文件夹中。通常，用于此目的的目录是
    `lib`。这种方法有两个问题。一个是源代码仓库的大小。例如，如果有 100 个不同的项目使用了 JUnit，那么 JUnit 库的 JAR 文件就被复制了
    100 次。另一个问题是收集所有库。当一个库使用了另一个库时，开发者必须阅读描述（许多时候过时且不精确）需要使用此库的其他库的库的文档。这些库必须以相同的方式下载和安装。这既耗时又容易出错。当一个库缺失时，开发者没有注意到，错误会在编译时显现，当编译器找不到类，甚至在运行时
    JVM 无法加载类时。
- en: To solve this issue, Maven comes with a built-in repository manager client.
    The repository is a storage that contains the libraries. As there can be other
    types of files in a repository, not only libraries, Maven terminology is artifact.
    The `groupId`, the `artifactId`, and the `version` number identify an artifact.
    There is a very strict requirement that an artifact can only be put into a repository
    once. Even if there is an error during the release process that is identified
    after the erroneous release was uploaded, the artifact cannot be overwritten.
    For the same `groupId`, `artifactId`, and `version`, there can only be one single
    file that will never change. If there was an error, then a new artifact is to
    be created with new version number and the erroneous artifact may be deleted but
    not replaced.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，Maven 内置了一个仓库管理器客户端。仓库是一个包含库的存储空间。由于仓库中可能包含其他类型的文件，而不仅仅是库，因此 Maven
    术语中使用了工件。`groupId`、`artifactId` 和 `version` 版本号用于标识一个工件。有一个非常严格的要求，即工件只能放入仓库一次。即使发布过程中出现了错误，在错误发布上传后才发现，该工件也不能被覆盖。对于相同的
    `groupId`、`artifactId` 和 `version`，只能有一个文件，该文件永远不会改变。如果出现错误，则需要创建一个新的工件，并使用新的版本号，错误的工件可以被删除但不能被替换。
- en: If the version number ends with `-SNAPSHOT`, then this uniqueness is not guaranteed
    or required. Snapshots are usually stored in separate repository and are not published
    for the world.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果版本号以 `-SNAPSHOT` 结尾，则这种唯一性没有保证或要求。快照通常存储在单独的仓库中，并且不会向全世界发布。
- en: Repositories contain the artifacts in directories that are organized in a defined
    way. When Maven runs, it can access different repositories using `https` protocol.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库包含在目录中组织得井井有条的工件。当 Maven 运行时，它可以使用 `https` 协议访问不同的仓库。
- en: Formerly, the `http` protocol was also used, and for non-paying customers, the
    central repository was available via `http` only. However, it was discovered that
    modules downloaded from the repository could be targets for men-in-the-middle
    security attacks and Sonatype ([http://www.sonatype.com](http://www.sonatype.com))
    changed the policy and used `https` protocol only. Never configure or use a repository
    with the `http` protocol. Never trust a file that you downloaded from HTTP.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，也使用了 `http` 协议，对于非付费客户，中央仓库只能通过 `http` 访问。然而，发现从仓库下载的模块可能成为中间人安全攻击的目标，Sonatype
    ([http://www.sonatype.com](http://www.sonatype.com)) 改变了政策，只使用 `https` 协议。永远不要配置或使用带有
    `http` 协议的仓库。永远不要信任从 HTTP 下载的文件。
- en: There is a local repository on the developer machine, usually under the `~/.m2/repository`
    directory. When you issue the `mvn install` command, Maven stores the created
    artifact here. Maven also stores an artifact here when it is downloaded from a
    repository via HTTPS. This way, subsequent compilations do not need to go out
    to the network for the artifacts.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者机器上有一个本地仓库，通常位于`~/.m2/repository`目录下。当你执行`mvn install`命令时，Maven会将创建的构件存储在这里。当通过HTTPS从仓库下载构件时，Maven也会在这里存储构件。这样，后续的编译就不需要从网络上获取构件。
- en: Companies usually set up their own repository manager (the one that Sonatype,
    the company backing Maven, is providing Nexus). These applications can be configured
    to communicate with several other repositories and collect the artifacts from
    there on demand, essentially implementing proxy functionality. Artifacts travel
    to the build from the far end repositories to the closer ones in a hierarchical
    structure to the local repo and essentially to the final artifact if the packaging
    type of the project is `war`, `ear`, or some other format that encloses the dependent
    artifacts. This is essentially file caching without revalidation and cache eviction.
    This can be done because of the strict rules of artifact uniqueness. This is the
    reason for such a strict rule.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 公司通常会设置自己的仓库管理器（由支持Maven的公司Sonatype提供的Nexus）。这些应用程序可以配置为与多个其他仓库通信，并按需从那里收集构件，本质上实现了代理功能。构件从远端仓库传输到本地仓库，再到更近的仓库，形成一个层次结构，如果项目的打包类型是`war`、`ear`或其他包含依赖构件的格式，最终传输到最终构件。这本质上是一种文件缓存，没有重新验证和缓存淘汰。这可以做到，因为构件唯一性的严格规则。这就是如此严格规则的原因。
- en: 'If the project bubble were a standalone project, and not part of a multi-module
    one, then the dependency would look like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目泡沫是一个独立的项目，而不是多模块项目的一部分，那么依赖关系看起来是这样的：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If `version` is not defined for a dependency, Maven will not be able to identify
    which artifact to use. In the case of a multi-module project, `version` can be
    defined in the parent and the modules can inherit the version. As the parent is
    not dependent on the actual dependency, it only defines the version attached to
    the `groupId` and `artifactId`; the XML tag is not `dependencies`, but `dependencyManagement/dependencies`
    under the top-level `project` tag as in the following example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有为依赖项定义`version`，Maven将无法识别要使用哪个构件。在多模块项目中，`version`可以在父项目中定义，模块可以继承这个版本。由于父项目不依赖于实际的依赖项，它只定义与`groupId`和`artifactId`关联的版本；XML标签不是`dependencies`，而是在顶级`project`标签下的`dependencyManagement/dependencies`，如下例所示：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If the parent POM uses the dependencies tag directly, Maven is not able to decide
    if the parent depends on that artifact or some modules. When the modules want
    to use `junit`, they need not specify the version. They will get it from the parent
    project defined as 4.12, which is the latest from *JUnit 4*. If ever there will
    be a new version 4.12.1, with some serious bugs fixed, then the only place to
    modify the version number is the parent POM, and the modules will use the new
    version starting with the next execution of the Maven compilation.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果父POM直接使用dependencies标签，Maven无法决定父项目是否依赖于该构件或某些模块。当模块想要使用`junit`时，它们不需要指定版本。它们将从定义为4.12的父项目中获取，这是JUnit
    4的最新版本。如果将来会有一个新版本4.12.1，修复了一些严重错误，那么唯一修改版本号的地方是父POM，模块将在下一次执行Maven编译时使用新版本。
- en: When the new version, *JUnit 5*, comes out, however, the modules will all have
    to be modified because *JUnit* is not just a new version. Version 5 of JUnit is
    split into several modules and, this way, `groupId` and `artifactId` will also
    change.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当新的版本JUnit 5发布时，所有模块都必须进行修改，因为JUnit不仅仅是一个新版本。JUnit 5被拆分为几个模块，因此`groupId`和`artifactId`也会发生变化。
- en: 'It is also worth noting that the modules that implement the interfaces from
    the `SortInterface` module are eventually dependent on this module. In this case,
    the version is defined as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，实现`SortInterface`模块接口的模块最终都会依赖于这个模块。在这种情况下，版本定义如下：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That seems to be a bit tautological (it is, actually). The `${project.version}`
    property is the version of the project and it is inherited by the `SortInterface`
    module. This is the version of the artifact that the other modules depend on.
    In other words, the modules always depend on the version that we are currently
    developing.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎有点自相矛盾（实际上确实如此）。`${project.version}`属性是项目的版本，并且由`SortInterface`模块继承。这是其他模块所依赖的工件版本。换句话说，模块总是依赖于我们目前正在开发的版本。
- en: Code the sort
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写排序代码
- en: To implement the sort, first, we will define the interfaces that a sort library
    should implement. Defining the interface before the actual coding is a good practice.
    When there are many implementations, it is sometimes recommended to first create
    a simple one and start using it so that the interface may evolve during the phase,
    and when the more complex implementations are due, then the interface to be implemented
    is already fixed, more or less.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现排序，首先，我们将定义一个排序库应该实现的接口。在实际编码之前定义接口是一个好习惯。当有多个实现时，有时建议首先创建一个简单的实现并开始使用它，这样接口可以在该阶段演变，当更复杂的实现即将到来时，要实现的接口已经大致确定。
- en: Creating the interfaces
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建接口
- en: The interface in our case is very simple.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，接口非常简单。
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The interface should do only one thing—sort something that is sortable. As we
    wanted to be very general in this approach, we also have to define what sortable
    is. To do so, we will need another interface.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接口应该只做一件事——对可排序的东西进行排序。由于我们希望这种方法非常通用，我们还需要定义什么是可排序的。为此，我们需要另一个接口。
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Creating BubbleSort
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建BubbleSort
- en: 'Now, we can start creating the bubble sort that implements the `Sort` interface:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始创建实现`Sort`接口的冒泡排序：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Normally, the algorithm to execute needs two operations that we implemented
    in the code last time specific to a `String` array: comparing two elements and
    swapping two elements. As this time the sort implementation itself does not know
    what type the elements are used and also does not know if the something it sorts
    is an array, a lists or something else, it needs something that does it for the
    sort when needed. More precisely, it needs a `comparator` object capable of comparing
    two elements and it needs a `swapper` object that is capable of swapping two elements
    in the collection.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，执行算法需要两个我们在上次代码中实现的操作，针对`String`数组特定：比较两个元素和交换两个元素。由于这次排序实现本身并不知道元素的类型是什么，也不知道它排序的是数组、列表还是其他什么，它需要某种在需要时进行排序的东西。更精确地说，它需要一个能够比较两个元素的`comparator`对象，以及一个能够交换集合中两个元素的`swapper`对象。
- en: To get those, we can implement two setter methods that can set the objects for
    the purpose before sort is invoked. As this is not specific to the bubble sort
    algorithm but is rather general, these two methods should also be made a part
    of the interface, so the implementation is overriding it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得这些，我们可以实现两个setter方法，在调用排序之前设置这些对象。由于这并不特定于冒泡排序算法，而是更通用的，这两个方法也应该成为接口的一部分，因此实现会覆盖它。
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `@Override` annotation signals for the Java compiler that the method is
    overriding a method of the parent class, or, as in this case, of the interface.
    A method can override a parent method without this annotation; however, if we
    use the annotation, the compilation fails if the method does actually not override
    something. This helps you discover during compile time that something was changed
    in the parent class or in the interface and we did not follow that change in the
    implementation, or that we just made some mistake thinking that we will override
    a method when we actually do not. As annotations are heavily used in unit tests,
    we will talk about annotations in a bit more detail later.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Override`注解向Java编译器指示该方法正在覆盖父类或接口中的方法。一个方法可以不使用此注解覆盖父方法；然而，如果我们使用此注解，如果方法实际上没有覆盖任何东西，编译将失败。这有助于我们在编译时发现父类或接口中发生了变化，而我们没有在实现中遵循这种变化，或者我们只是犯了一些错误，认为我们将覆盖一个方法，而实际上我们没有。由于注解在单元测试中大量使用，我们将在稍后更详细地讨论注解。'
- en: Amending the interfaces
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改接口
- en: 'The modified `Sort` interface will look like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的`Sort`接口将看起来像这样：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This also means that we will need two new interfaces: `Swapper` and `Comparator`.
    We are lucky that the Java runtime already defines a `Comparator` interface that
    just fits the purpose. You may have guessed that from the following import statement:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着我们需要两个新的接口：`Swapper` 和 `Comparator`。幸运的是，Java 运行时已经定义了一个 `Comparator` 接口，正好符合我们的需求。你可能已经从下面的导入语句中猜到了：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When you need something very basic, like a `comparator` interface, it is most
    probably defined in the runtime. It is advisable to consult the runtime before
    writing your own version. The `Swapper` interface, however, we will have to create.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要一些非常基本的东西，比如一个 `comparator` 接口时，它很可能已经在运行时定义了。在编写自己的版本之前咨询运行时是明智的。然而，`Swapper`
    接口我们却必须自己创建。
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As it is used to swap two elements specified by the indices in `SortableCollection`,
    there is a method, quite trivially named `swap` for the purpose. But, we are not
    ready yet. If you try to compile the preceding code, the compiler will complain
    about the `get` and `size` methods. They are needed by the algorithm to implement
    the sort, but they are not inherently part of the sorting itself. This is a responsibility
    that should not be implemented in the sort. As we do not know what type of collections
    we will sort, it is not only unadvisable but also impossible to implement these
    functionalities inside the sort. It seems that we just cannot sort anything. There
    are some restrictions we will have to set. The sorting algorithm must know the
    size of the collection we sort and also should have access to an element by index
    so that it can pass it on to the comparator.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它用于交换 `SortableCollection` 中指定索引的两个元素，因此有一个名为 `swap` 的方法，这个名字相当简单。但是，我们还没有准备好。如果你尝试编译前面的代码，编译器将会对
    `get` 和 `size` 方法提出抱怨。算法实现排序需要这些方法，但它们本身并不是排序的固有部分。这是一个不应该在排序中实现的责任。由于我们不知道我们将对什么类型的集合进行排序，因此在排序中实现这些功能不仅不妥，而且是不可能的。看起来我们根本无法对任何东西进行排序。我们必须设置一些限制。排序算法必须知道我们排序的集合的大小，并且应该能够通过索引访问元素，以便将其传递给比较器。
- en: These restrictions are expressed in the `SortableCollection` interface that
    we just left empty not knowing before the first sort implementation what is required
    to be there.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这些限制在 `SortableCollection` 接口中得到表达，我们之前在不知道第一次排序实现需要什么时，将其留空。
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, we are ready with the interfaces and the implementation and we can go on
    testing the code. But, before that, we will briefly reiterate what we did and
    why we did that.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好了接口和实现，可以继续测试代码。但在那之前，我们将简要回顾一下我们所做的工作以及为什么这样做。
- en: Architectural considerations
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构考虑
- en: We created an interface and a simple implementation of it. During the implementation,
    we discovered that the interface needs other interfaces and methods that are needed
    to support the algorithm. This usually happens during the architectural design
    of the code, before implementation. For didactical reasons, I followed the build-up
    of the interfaces while we developed the code. In real life, when I created the
    interfaces, I created them all in one step as I have enough experience. I wrote
    my first quick sort code around 1983 in Fortran. However, it does not mean that
    I hit the bull's eye with just any problem and come out with the final solution.
    It just happens that sort is a too well known problem. If you need to modify the
    interfaces or other aspects of your design during development, do not feel embarrassed.
    It is a natural consequence and a proof that you understand things better and
    better as time goes by. If the architecture needs change, it is better to be done
    than not, and the sooner it is, the better. In real life enterprise environments,
    we will design interfaces just to learn during development that there were some
    aspects that we forgot. They are very true and bit more complex operations than
    sorting a collection.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个接口及其简单的实现。在实现过程中，我们发现接口需要其他接口和方法来支持算法。这通常发生在代码的架构设计阶段，在实现之前。出于教学目的，我遵循了接口的构建过程，在我们开发代码的同时。在现实生活中，当我创建接口时，我一次创建所有接口，因为我有足够的经验。我大约在1983年用Fortran编写了我的第一个快速排序代码。然而，这并不意味着我只要遇到任何问题就能一击即中，并得出最终解决方案。只是恰好排序是一个太为人所知的问题。如果你在开发过程中需要修改接口或其他设计方面，不要感到尴尬。这是自然的结果，也是你随着时间的推移对事物理解越来越好的证明。如果架构需要改变，最好是进行改变，而且越早越好。在现实生活中的企业环境中，我们设计接口只是为了在开发过程中学习到我们忘记了一些方面。它们是非常真实且比排序集合更复杂的操作。
- en: In the case of the sorting problem, we abstracted the *something* we want to
    sort to the most possible extreme. The Java build in sort can sort arrays or lists.
    If you want to sort something that is not a list or an array, you have to create
    a class that implements the `java.util.List` interface with more than 24 methods
    it requires to wrap your sortable object to make it sortable by the JDK sort.
    To be honest, that is not too many, and in a real-world project, I would consider
    that as an option.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在排序问题的情况下，我们将我们想要排序的“某物”抽象到了最极端的可能。Java 内置的排序方法可以排序数组或列表。如果你想要排序的不是列表或数组，你必须创建一个类，该类实现了需要超过
    24 个方法的 `java.util.List` 接口，以便将你的可排序对象包装起来，使其可以通过 JDK 排序。说实话，这并不多，在一个实际的项目中，我会将其视为一个选项。
- en: However, we do not, and cannot know, what methods of the interface the built-in
    sort uses. Those that are used should be functionally implemented and those that
    are not, can contain a simple `return` statement because they are just never invoked.
    A developer can consult the source code of the JDK and see what methods are actually
    used, but that is not the contract of the search implementation. It is not guaranteed
    that a new version will still use *only* those methods. If a new version starts
    to use a method that we implemented with a single `return` statement, the sort
    will magically fail.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们并不知道，内置排序使用了接口的哪些方法。应该功能实现那些使用的方法，而没有使用的方法可以包含一个简单的 `return` 语句，因为它们根本不会被调用。开发者可以查阅
    JDK 的源代码，看看实际使用了哪些方法，但这不是搜索实现的合同。不能保证新版本仍然只会使用那些方法。如果新版本开始使用我们用单个 `return` 语句实现的方法，排序可能会神奇地失败。
- en: It is also an interesting performance question how the swapping of two elements
    is implemented by the search using only the `List` interface. There is no `put(int,
    Object)` method in the `List` interface. There is `add(int Object)`, but that
    inserts a new element and it may be extremely costly (burning CPU, disk, energy)
    to push all elements of the list up if the objects are stored, for example, on
    disk. Furthermore, the next step may be removing the element after the one we
    just inserted, doing the costly process of moving the tail of the list again.
    That is, the trivial implementation of `put(int,Object)` that the sort may or
    may not follow. Again, this is something that should not be assumed.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的问题是，如何仅使用 `List` 接口通过搜索来交换两个元素。`List` 接口中没有 `put(int, Object)` 方法。有 `add(int,
    Object)`，但它会插入一个新元素，如果对象存储在磁盘上，例如，那么将列表的所有元素向上推可能非常昂贵（消耗 CPU、磁盘、能源）。此外，下一步可能是删除我们刚刚插入的元素之后的一个元素，再次进行昂贵的移动列表尾部的操作。也就是说，排序可能或可能不会遵循的
    `put(int, Object)` 的简单实现。同样，这不应该被假设。
- en: When developers use libraries, classes, and methods from the JDK, open source,
    or commercial libraries, the developers may consult the source code but they should
    not rely on the implementation. You should rely only on the contract and the definition
    of the API that the library comes with. When you implement an interface from some
    external library, and you do not need to implement some part of it, and create
    some dummy methods, feel the danger in the air. It is an ambush. It is likely
    that either the library is poor quality or you did not understand how to use it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者使用 JDK、开源或商业库中的库、类和方法时，开发者可以查阅源代码，但他们不应该依赖于实现。你应该只依赖于库附带 API 的合同和定义。当你从某个外部库实现一个接口，并且你不需要实现它的某些部分，并创建一些虚拟方法时，感受到空气中的危险。这是一个伏击。很可能是库质量差，或者你没有理解如何使用它。
- en: In our case, we separated the swapping and the comparison from the sort. The
    collection should implement these operations and provide them for the sort. The
    contract is the interface, and to use the sort, you have to implement all methods
    of the interfaces we defined.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们将交换和比较从排序中分离出来。集合应该实现这些操作，并为排序提供它们。合同是接口，要使用排序，你必须实现我们定义的所有接口方法。
- en: The interface of `Sort` defines setters that set `Swapper` and `Comparator`.
    Having dependencies set that way may lead to a code that creates a new instance
    of a class implementing the `Sort` interface, but does not set `Swapper` and `Comparator`
    before invoking `Sort`. This will lead to `NullPointerException` the first time
    the `Comparator` is invoked (or when the `Swapper` is invoked in case the implementation
    invokes that first, which is not likely, but possible). The calling method should
    inject the dependencies before using the class. When it is done through setters,
    it is called **setter injection**. This terminology  is heavily used when we use
    frameworks such as Spring, Guice, or some other container. Creating these service
    classes and injecting the instance into our classes is fairly similar all the
    time.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sort`接口定义了设置`Swapper`和`Comparator`的设置器。以这种方式设置依赖可能会导致创建实现`Sort`接口的新实例的代码，但在调用`Sort`之前没有设置`Swapper`和`Comparator`。这将导致在第一次调用`Comparator`（或当实现首先调用`Swapper`时，这不太可能，但有可能）时抛出`NullPointerException`。调用方法应该在使用类之前注入依赖。当它通过设置器完成时，这被称为**设置器注入**。这个术语在我们使用Spring、Guice或其他容器等框架时被大量使用。创建这些服务类并将实例注入到我们的类中通常是相似的。'
- en: Container implementations contain the functionality in a general way and provide
    configuration options to configure what instances are to be injected into what
    other objects. Usually, this leads to shorter, more flexible, and more readable
    code. However, dependency injection is not exclusive to containers. When we write
    the testing code in the next section, and invoke the setters, we actually do dependency
    injection.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 容器实现以通用方式包含功能并提供配置选项来配置要注入到哪些其他对象中的实例。通常，这会导致代码更短、更灵活、更易读。然而，依赖注入并不局限于容器。当我们编写下一节的测试代码并调用设置器时，我们实际上是在进行依赖注入。
- en: There is another way of dependency injection that avoids the problem of dependencies
    not being set. This is called **constructor injection**. The dependencies are
    `final private` fields with no values. Remember that these fields should get their
    final values by the time the constructor finishes. Constructor injection passes
    the injected values to the constructor as arguments and the constructor sets the
    fields. This way, the fields are guaranteed to be set by the time the object was
    constructed. This injection, however, cannot be defined in an interface.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种依赖注入的方式可以避免依赖未设置的问题。这被称为**构造函数注入**。依赖是`final private`字段，没有值。记住，这些字段应该在构造函数完成时获得它们的最终值。构造函数注入将注入的值作为参数传递给构造函数，构造函数设置字段。这样，字段在对象构造时就被保证了。然而，这种注入不能定义在接口中。
- en: Now, we already have the code, and we know the considerations of how the interfaces
    were created. This is the time to do some testing.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有代码了，我们也知道接口是如何创建的考虑因素。这是进行一些测试的时候了。
- en: Creating unit tests
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建单元测试
- en: When we write code, we should test it. No code has ever gone into production
    before at least doing some test runs. There are different levels of tests having
    different aims, technologies, industry practices, and names.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写代码时，我们应该对其进行测试。没有任何代码在投入生产之前至少进行过一些测试运行。存在不同级别的测试，它们有不同的目标、技术、行业实践和名称。
- en: 'Unit tests, as the name suggests, test a unit of code. Integration tests test
    how the units integrate together. Smoke tests test a limited set of the features
    just to see that the code is not totally broken. There are other tests, until
    the final test, which is the proof of the work: user acceptance test. Proof of
    the pudding is eating it. A code is good if the user accepts it.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试，正如其名所示，测试代码的一个单元。集成测试测试单元如何集成在一起。冒烟测试测试有限的功能，只是为了看看代码是否完全损坏。还有其他测试，直到最后的测试，即工作的证明：用户验收测试。甜点的证明是吃它。如果用户接受它，代码就是好的。
- en: Many times, I tell juniors that the name user acceptance test is a bit misleading,
    because it is not the user who accepts the result of a project, but the customer.
    By definition, the customer is the person who pays the bill. Professional development
    is paid; otherwise, it is not professional. The terminology is, however, user
    acceptance test. It just happens that customers accept the project only if the
    users can use the program.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，我会告诉新手，用户验收测试这个名称有点误导性，因为接受项目结果的不是用户，而是客户。根据定义，客户是支付账单的人。专业发展需要付费；否则，就不算专业。然而，术语却是用户验收测试。只是碰巧客户只有在用户能够使用程序的情况下才会接受项目。
- en: When we develop in Java, unit test is testing standalone classes. In other words,
    in Java development, a unit is a class when we talk about unit tests. To furnish
    unit tests, we usually use the JUnit library. There are other libraries, such
    as TestNG, but JUnit is the most widely used, so we will use *JUnit*. To use it
    as a library, first, we will have to add it to the Maven POM as a dependency.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Java中开发时，单元测试是测试独立类。换句话说，在Java开发中，当我们谈论单元测试时，单元是一个类。为了提供单元测试，我们通常使用JUnit库。还有其他库，如TestNG，但JUnit是最广泛使用的，所以我们将使用*JUnit*。要将其作为库使用，首先，我们必须将其添加到Maven
    POM中作为依赖项。
- en: Adding JUnit as dependency
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加JUnit作为依赖项
- en: Recall that we have a multi-module project, and the dependency versions are
    maintained in the parent POM under the `dependencyManagement` tag.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们有一个多模块项目，依赖项版本在父POM的`dependencyManagement`标签下维护。
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The scope of the dependency is test, which means that this library is needed
    only to compile the test code and during the execution of the test. The JUnit
    library will not make its way to the final released product; there is no need
    for it. If you find the JUnit library in some deployed production **Web Archive**
    (**WAR**) file, suspect that somebody was not properly managing the scopes of
    the libraries.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项的作用域是测试，这意味着这个库只需要编译测试代码并在测试执行期间使用。JUnit库不会进入最终发布的产品；不需要它。如果你在某个部署的生产**Web
    Archive**（**WAR**）文件中找到JUnit库，怀疑有人没有正确管理库的作用域。
- en: Maven supports the compilation and the execution of JUnit tests in the lifecycle
    of the project. If we want to execute the tests, only we can issue the `mvn test`
    command. The IDEs also support the execution of the unit tests. Usually, the same
    menu item that can be used to execute a class that has a `public static main`
    method can be used. If the class is a unit test utilizing JUnit, the IDE will
    recognize it and execute the tests and usually give a graphical feedback on what
    test was executing fine and which ones failed, and how.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Maven支持在项目的生命周期中编译和执行JUnit测试。如果我们想执行测试，只有我们可以发出`mvn test`命令。IDEs也支持单元测试的执行。通常，可以用来执行具有`public
    static main`方法的类的相同菜单项可以用来执行。如果类是一个使用JUnit的单元测试，IDE将识别它并执行测试，通常会在图形界面上给出关于哪些测试执行良好以及哪些失败的反馈，以及失败的原因。
- en: Writing the BubbleSortTest class
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写BubbleSortTest类
- en: The test classes are separated from the production classes. They go into the
    `src/test/java` directory. When we have a class named, for example, `BubbleSort`,
    then the test will be named `BubbleSortTest`. This convention helps the executing
    environment to separate the tests from those classes that do not contain tests
    but are needed to execute the tests. To test the sort implementation we have just
    created, we can furnish a class that contains, for now, a single `canSortStrings`
    method.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类与生产类分开。它们放入`src/test/java`目录。当我们有一个名为，例如，`BubbleSort`的类时，测试将命名为`BubbleSortTest`。这个约定有助于执行环境将测试与那些不包含测试但需要执行测试的类分开。为了测试我们刚刚创建的排序实现，我们可以提供一个包含，目前只有一个`canSortStrings`方法的类。
- en: Unit test method names are used to document the functionality being tested.
    As the JUnit framework invokes each and every method that has the `@Test` annotation,
    the name of the test is not referenced anywhere in our code. We can bravely use
    arbitrary long method names; it will not hinder readability at the place where
    the method is invoked.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试方法名称用于记录正在测试的功能。由于JUnit框架调用每个带有`@Test`注解的方法，因此测试方法的名称在我们的代码中没有任何地方被引用。我们可以大胆地使用任意长的方法名；它不会妨碍在方法被调用处的可读性。
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The method contains `ArrayList` with the actual names that we have already gotten
    familiar with. As we have a sort implementation and interface that needs `SortableCollection`,
    we will create one backed up by `ArrayList`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 方法包含`ArrayList`，其中包含我们已经熟悉的实际名称。由于我们有一个需要`SortableCollection`的排序实现和接口，我们将创建一个由`ArrayList`支持的实现。
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We declared a new object that has the `SortableCollection` type, which is an
    interface. To instantiate something that implements `SortableCollection`, we will
    need a class. We cannot instantiate an interface. In this case, define the class
    in the place of the instantiation. This is called an anonymous class in Java.
    The name comes from the fact that the name of the new class is not defined in
    the source code. The Java compiler will automatically create a name for the new
    class, but that is not interesting for the programmers. We will simply write `new
    SortableCollection()` and provide the needed implementation immediately following
    between `{` and `}`. It is very convenient to define this anonymous class inside
    the method as, this way, it can access `ArrayList` without passing a reference
    to `ArrayList` in the class.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个具有`SortableCollection`类型的新对象，这是一个接口。为了实例化实现`SortableCollection`的对象，我们需要一个类。我们不能实例化一个接口。在这种情况下，在实例化的地方定义这个类。这在Java中被称为匿名类。这个名字来源于新类的名称在源代码中没有定义。Java编译器将自动为新类创建一个名称，但这对于程序员来说并不重要。我们将简单地写`new
    SortableCollection()`，并在大括号`{}`之间立即提供所需实现。在方法内部定义这个匿名类非常方便，这样它就可以访问`ArrayList`，而无需在类中传递`ArrayList`的引用。
- en: As a matter of fact, the reference is needed, but the Java compiler automatically
    does this. The Java compiler, in this case, also takes care that automatic reference
    passing this way can only be done using variables that were initialized and will
    not change during the execution of the code after the instantiation of the anonymous
    class. The variable `actualNames` was set and it should not be changed in the
    method later. As a matter of fact, we can even define `actualNames` to be final
    and this would have been a requirement if we used Java 1.7 or earlier. Starting
    with 1.8, the requirement is that the variable is effectively final, but you need
    not declare it to be final.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，需要引用，但Java编译器会自动完成这个操作。在这种情况下，Java编译器还会确保通过这种方式自动传递的引用只能用于在匿名类实例化后初始化且不会改变的变量。变量`actualNames`已被设置，并且在后续的方法中不应更改。实际上，我们甚至可以将`actualNames`定义为final，如果我们在Java
    1.7或更早版本中使用，这将是一个要求。从1.8版本开始，要求变量实际上是final的，但您不需要声明它为final。
- en: The next thing that we need is a `Swapper` implementation for `ArrayList`. In
    this case, we will define a whole class inside the method. It can also be an anonymous
    class, but this time I decided to use a named class to demonstrate that a class
    can be defined inside a method. Usually, we do not do that in production projects.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步我们需要的是`ArrayList`的`Swapper`实现。在这种情况下，我们将在方法内部定义整个类。它也可以是一个匿名类，但这次我决定使用一个命名类来展示一个类可以在方法内部定义。通常，在生产项目中我们不会这样做。
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Last, but not least, we will need a comparator before we can invoke the sort.
    As we have `String`s to compare, this is easy and straightforward.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，在调用排序之前，我们需要一个比较器。由于我们要比较的是`String`，这很简单且直接。
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Having everything prepared for the sorting, we will finally need an instance
    of the Sort implementation, set the `comparator` and the `swapper`, and invoke
    the sort.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在排序准备工作完成后，我们最终需要Sort实现的实例，设置`comparator`和`swapper`，然后调用排序。
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The last, but most important part of the test is to assert that the result is
    the one that we expect. JUnit helps us do that with the aid of the `Assert` class.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的最后一个，但最重要的部分是断言结果是我们预期的。JUnit通过`Assert`类帮助我们做到这一点。
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The call to `assertEquals` checks that the first argument, the expected result,
    equals the second argument, the sorted `actualNames`. If they differ, then `AssertionError`
    is thrown; otherwise, the test just finishes fine.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertEquals`的调用检查第一个参数，即预期结果，是否等于第二个参数，即排序后的`actualNames`。如果它们不同，则抛出`AssertionError`；否则，测试将正常结束。'
- en: Good unit tests
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 好的单元测试
- en: Is this a good unit test? If you read it in a tutorial book like this, it has
    to be. Actually, it is not. It is a good code to demonstrate some of the tools
    that JUnit provides and some Java language features, but as a real JUnit test,
    I will not use it in a real life project.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个好的单元测试吗？如果您在像这样的教程书中阅读它，它必须是。实际上，它不是。这是一段很好的代码，用于展示JUnit提供的一些工具和一些Java语言特性，但作为一个真正的JUnit测试，我将在实际项目中不会使用它。
- en: What makes a unit test good? To answer this question, we will have to find what
    the unit test is good for and what it is that we use it for.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是好的单元测试？为了回答这个问题，我们必须找到单元测试的好处以及我们用它来做什么。
- en: We will create unit tests to validate the operation of the units and to document.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建单元测试来验证单元的操作并记录文档。
- en: Unit tests are not to find bugs. Developers eventually use unit tests during
    debugging sessions but, many times, the testing code created for the debugging
    is a temporary one. When the bug is fixed, the code used to find it will not get
    into the source code. For every new bug, there should be a new test created that
    covers the functionality that was not properly working, but it is hardly the test
    code that is used to find the bug. This is because unit tests are mainly for documentation.
    You can document a class using *JavaDoc*, but the experience shows that the documentation
    often becomes outdated. The developers modify the code, but they do not modify
    the documentation, and the documentation becomes obsolete and misleading. Unit
    tests, however, are executed by the build system and if **Continuous Integration**
    (**CI**) is in use (and it should be, in a professional environment), then the
    build will be broken if a test fails, all developers will get mail notification
    about it, and it will drive the developer breaking the build to fix the code or
    the test. This way, the tests verify that continuous development did not break
    anything in the code or, at least, not something that can be discovered using
    unit tests.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试不是为了找bug。开发者最终会在调试会话中使用单元测试，但很多时候，为调试创建的测试代码是临时的。当bug被修复时，用于找到它的代码不会进入源代码。对于每个新的bug，都应该创建一个新的测试来覆盖那些没有正确工作的功能，但这几乎不是用来找到bug的测试代码。这是因为单元测试主要是为了文档。你可以使用*JavaDoc*来记录一个类，但经验表明，文档往往会过时。开发者修改了代码，但他们没有修改文档，文档变得过时且具有误导性。然而，单元测试是由构建系统执行的，如果使用**持续集成**（**CI**）（在专业环境中应该使用），那么如果测试失败，构建将会中断，所有开发者都会收到关于它的邮件通知，这将迫使破坏构建的开发者修复代码或测试。这样，测试可以验证持续开发没有在代码中破坏任何东西，或者至少不是可以用单元测试发现的东西。
- en: A good unit test is readable
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个好的单元测试是可读的
- en: Our test is far from being readable. A test case is readable if you look at
    it and in 15 seconds you can tell what it does. It assumes, of course, some experience
    in Java on behalf of the reader, but you get the point. Our test is cluttered
    with support classes that are not core to the test.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试远远达不到可读性。一个测试用例是可读的，如果你看它，在15秒内就能知道它做什么。当然，这假设读者有一些Java经验，但你的观点是明确的。我们的测试用例中充斥着非核心的辅助类。
- en: Our test also hardly validates that the code is working properly. It actually
    does not. There are some bugs in it that I put there deliberately, which we will
    locate and zap in the following sections. One single test that sorts a single
    `String` array is far from validating a sort implementation. If I were to extend
    this test to a real-world test, we would need methods that would have the name
    `canSortEmptyCollection`, `canSortOneElementCollection`, `canSortTwoElements`,
    `canSortReverseOrder`, or `canSortAlreadySorted`. If you look at the names, you
    will see what tests we need. Coming from the nature of the sort problem, an implementation
    may be reasonably sensitive to errors in these special cases.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试几乎不能验证代码是否正常工作。实际上，它并没有。其中有一些我故意放入的bug，我们将在下面的章节中找到并消除。一个单独的测试用例对单个`String`数组进行排序，远远不能验证排序实现。如果我要扩展这个测试到实际的测试，我们需要有名为`canSortEmptyCollection`、`canSortOneElementCollection`、`canSortTwoElements`、`canSortReverseOrder`或`canSortAlreadySorted`的方法。如果你看这些名字，你会看到我们需要哪些测试。从排序问题的本质来看，实现可能对特殊情况的错误非常敏感。
- en: What are the good points in our unit test, in addition to it being an acceptable
    demonstration tool?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们单元测试的优点是什么，除了它是一个可接受的演示工具之外？
- en: Unit tests are fast
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试是快速的
- en: Our unit test runs fast. As we execute unit tests each time, the CI fires up
    a build and the execution of the tests should not last long. You should not create
    a unit test sorting billions of elements. That is a kind of stability or load
    test and they should run in separate test periods and not every time the build
    is running. Our unit test sorts five elements that are reasonable.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的单元测试运行得很快。每次执行单元测试时，CI都会启动构建，测试的执行不应持续很长时间。你不应该创建一个对数十亿个元素进行排序的单元测试。那是一种稳定性或负载测试，它们应该在单独的测试期间运行，而不是每次构建运行时。我们的单元测试对五个合理的元素进行排序。
- en: Unit tests are deterministic
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试是确定的
- en: Our unit test is deterministic. Non-deterministic unit tests are the nightmare
    of the developers. If you are in a group where some builds break on the CI server,
    and when a build breaks, your fellow developer says that you just have to try
    it again; no way! If a unit test runs, it should run all times. If it fails, it
    should fail no matter how many times you start it. A non-deterministic unit test,
    in our case, will be to render random numbers and have them sorted. We will end
    up with different arrays in each test run and, in case there is some bug in the
    code that manifests for some array, we will not be able to reproduce it. Not to
    mention that the assertion that the code was running fine is also difficult.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的单元测试是确定的。非确定性的单元测试是开发者的噩梦。如果你在一个团队中，有些构建在CI服务器上失败，当一个构建失败时，你的同事说你需要再试一次；不可能！如果一个单元测试运行了，它应该每次都运行。如果它失败了，它应该无论你启动多少次都失败。在我们的案例中，一个非确定性的单元测试将是生成随机数并将它们排序。我们将在每次测试运行中结束于不同的数组，如果代码中存在某些数组会显示的bug，我们将无法重现它。更不用说断言代码运行良好也是困难的。
- en: If we sorted a random array in a unit test (something we do not), we could,
    hypothetically, assert that the array is sorted, comparing the elements one after
    the other checking that they are in ascending order. It would also be a totally
    wrong practice.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在单元测试中对一个随机数组进行排序（我们实际上并没有这样做），理论上我们可以断言数组已排序，通过逐个比较元素来检查它们是否按升序排列。这也会是一个完全错误的做法。
- en: Assertions should be as simple as possible
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言应该尽可能简单
- en: If the assertion is complex, the risk of introducing bugs in the assertion is
    higher. The more complex the assertion, the higher the risk. We will write the
    unit tests to ease our lives and not to have more code to debug.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果断言复杂，引入断言中的bug的风险更高。断言越复杂，风险越高。我们将编写单元测试来简化我们的生活，而不是增加更多的代码来调试。
- en: 'Additionally, one test should assert only one thing. This one assertion may
    be coded with multiple `Assert` class methods, one after the other. Still, the
    aim of these is to assert the correctness of one single feature of the unit. Remember
    the SRP: one test, one feature. A good test is like a good sniper: one shot, one
    kill.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一个测试应该只断言一件事。这个断言可能通过多个`Assert`类方法编码，一个接一个。然而，这些方法的目的是断言单元的一个单一特性的正确性。记住SRP：一个测试，一个特性。一个好的测试就像一个好的狙击手：一枪，一命。
- en: Unit tests are isolated
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试是隔离的
- en: When we test a unit *A*, any change in another unit *B*, or a bug in a different
    unit should not affect our unit test that is for the unit *A*. In our case, it
    was easy because we have only one unit. Later, when we develop the test for the
    quick sort, we will see that this separation is not that simple.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们测试单元*A*时，另一个单元*B*的任何变化或不同单元中的错误都不应该影响我们针对单元*A*的单元测试。在我们的案例中，这很容易，因为我们只有一个单元。稍后，当我们为快速排序开发测试时，我们会看到这种分离并不那么简单。
- en: If the unit tests are properly separated, a failing unit test clearly points
    out the location of the problem. It is in the unit where the unit test failed.
    If tests do not separate the units, then a failure in one test may be caused by
    a bug in a different unit than we expect. In this case, these tests are not really
    unit tests.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单元测试被正确地分离，一个失败的单元测试可以清楚地指出问题的位置。问题就在单元测试失败的单元中。如果测试没有分离单元，那么一个测试的失败可能是由我们预期的不同单元中的错误引起的。在这种情况下，这些测试实际上并不是单元测试。
- en: In practice, you should make a balance. If the isolation of the units will be
    too costly, you can decide to create integration tests; and, if they still run
    fast, have them executed by the *CI system*. At the same time, you should also
    try to find out why the isolation is hard. If you cannot easily isolate the units
    in the tests, it means that the units are too strongly coupled, which may not
    be a good design.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，你应该找到一个平衡点。如果单元的隔离成本过高，你可以决定创建集成测试；如果它们仍然运行得很快，可以让它们由*CI系统*执行。同时，你也应该试图找出隔离困难的原因。如果你不能轻易地在测试中隔离单元，这意味着单元之间的耦合太强，这可能不是一个好的设计。
- en: Unit tests cover the code
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试覆盖代码
- en: Unit tests should test all usual and also all special cases of the functionality.
    If there is a special case of code that is not covered by the unit test, the code
    is in danger. In case of a sort implementation, the general case is sorting, say
    five elements. The special cases are much more numerous usually. How does our
    code behave if there is only one element or if there are no elements? What if
    there are two? What if the elements are in reverse order? What if they are already
    sorted?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试应该测试所有常规情况以及所有功能性的特殊案例。如果存在某个代码的特殊案例没有被单元测试覆盖，那么代码就处于危险之中。在排序实现的例子中，一般情况是排序，比如五个元素。特殊案例通常更多。我们的代码在只有一个元素或没有元素的情况下会如何表现？如果有两个元素呢？如果元素是逆序的呢？如果它们已经排序了呢？
- en: Usually, the special cases are not defined in the specification. The programmer
    has to think about it before coding, and some special cases are discovered during
    coding. The hard thing is that you just cannot tell if you covered all special
    cases and the functionality of the code.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，特殊案例在规范中没有被定义。程序员在编码之前必须考虑它，并且在编码过程中可能会发现一些特殊案例。困难之处在于你根本无法确定是否覆盖了所有特殊案例和代码的功能。
- en: What you can tell is if all the lines of code were executed during the testing
    or not. If 90% of the code lines are executed during the tests, then the code
    coverage is 90%, which is fairly good in real life, but you should never be content
    with anything less than 100%.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以判断的是，在测试过程中是否执行了所有代码行。如果90%的代码行在测试中执行了，那么代码覆盖率就是90%，这在现实生活中已经相当不错了，但你永远不应该满足于低于100%的覆盖率。
- en: 'Code coverage is not the same as functional coverage, but there is a correlation.
    If the code coverage is less than 100%, then at least one of the following two
    statements is true:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率不等于功能覆盖率，但它们之间存在关联。如果代码覆盖率低于100%，那么以下两个陈述中的至少一个是真的：
- en: The functional coverage is not 100%
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能覆盖率不是100%
- en: There is unused code in the tested unit, which can just be deleted
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在被测试的单元中存在未使用的代码，这些代码可以直接删除
- en: The code coverage can be measured, the functional coverage cannot. The tools
    and IDEs support code coverage measurement. These measurements are integrated
    into the editor so you will not only get the percentage of the coverage, but the
    editor will show you exactly which lines are not covered by the coverage coloring
    the lines (in Eclipse, for example) or the gutter on the left side of the editor
    window (IntelliJ). The picture shows that in IntelliJ, the tests cover the lines
    indicated by a green color on the gutter. (In the print version this is just a
    grey rectangle).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率是可以测量的，而功能覆盖率则不行。工具和IDE支持代码覆盖率测量。这些测量被集成到编辑器中，所以你不仅会得到覆盖率百分比，编辑器还会显示哪些行没有被覆盖率覆盖，通过给这些行着色（例如在Eclipse中）或编辑器窗口左侧的空白区域（IntelliJ）。图片显示在IntelliJ中，测试覆盖了左侧空白区域上用绿色标出的行。（在打印版本中这只是一个灰色矩形）。
- en: '![](img/00037.jpeg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00037.jpeg)'
- en: Refactor the test
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化测试
- en: 'Now that we have discussed what a good unit test is, let''s improve our test.
    The first thing is to move the supporting classes to separate files. We will create
    `ArrayListSortableCollection`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了什么是好的单元测试，让我们改进我们的测试。首先，我们需要将辅助类移动到单独的文件中。我们将创建`ArrayListSortableCollection`：
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This class encapsulates `ArrayList` and then implements the `get` and `size`
    methods to `ArrayList` access. `ArrayList` itself is declared as `final`. Recall
    that a `final` field has to be defined by the time the constructor finishes. This
    guarantees that the field is there when we start to use the object and that it
    does not change during the object lifetime. Note, however, that the content of
    the object, in this case, the elements of `ArrayList`, may change. If it were
    not the case, we would not be able to sort it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类封装了`ArrayList`并实现了`get`和`size`方法以访问`ArrayList`。`ArrayList`本身被声明为`final`。回想一下，一个`final`字段必须在构造函数完成时定义。这保证了当我们开始使用对象时字段已经存在，并且在对象的生命周期内不会改变。然而，请注意，对象的内容，在这个例子中是`ArrayList`的元素，可能会改变。如果不是这样，我们就无法对其进行排序。
- en: 'The next class is `StringComparator`. This is so simple that I will not list
    it here; I will leave it to you to implement the `java.util.Comparator` interface
    that can compare two Strings. It should not be difficult, especially as this class
    was already a part of the previous version of the `BubbleSortTest` class (hint:
    it was an anonymous class that we stored in the variable named `stringCompare`).'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个类是`StringComparator`。这个类非常简单，所以我不会在这里列出它；我会留给你来实现一个可以比较两个字符串的`java.util.Comparator`接口。这不应该很难，特别是因为这个类已经是`BubbleSortTest`类前一个版本的组成部分（提示：它是一个存储在名为`stringCompare`的变量中的匿名类）。
- en: We also have to implement `ArrayListSwapper`, which also should not be a big
    surprise.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须实现`ArrayListSwapper`，这也不应该是一个大的惊喜。
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, our test will look this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的测试将看起来是这样的：
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now this is already a test that can be understood in 15 seconds. It documents
    well how to use a sort implementation that we defined. It still works and does
    not reveal any bug, as I promised.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这是一个可以在15秒内理解测试。它很好地记录了我们如何使用我们定义的排序实现。它仍然有效，并且没有揭示任何错误，正如我承诺的那样。
- en: Collections with wrong elements
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包含错误元素的集合
- en: The bug is not trivial, and as usual, this is not in the implementation of the
    algorithm, but rather in the definition, or the lack of it. What should the program
    do if there are not only strings in the collection that we sort?
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误不是微不足道的，而且像往常一样，这并不是算法的实现问题，而是在定义上，或者说是定义不足。如果我们在排序的集合中不仅有字符串，程序应该做什么呢？
- en: 'If I create a new test that starts with the following lines, it will throw
    `ClassCastException`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我创建一个新的测试，以以下行开始，它将抛出`ClassCastException`：
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The problem here is that Java collections can contain any type of elements.
    You cannot ever be sure that a collection, such as `ArrayList`, contains only
    the types that you expect. Even if you use generics (we have not learned that,
    but we will in this chapter), the chances of a bug somehow conjuring up some object
    of an inappropriate type into a collection, are smaller but are still there. Don't
    ask me how; I cannot tell you. This is the nature of the bugs—you cannot tell
    how they work until you zap them. The thing is that you have to be prepared for
    such an exceptional case.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题在于Java集合可以包含任何类型的元素。你永远不能确定一个集合，比如`ArrayList`，只包含你期望的类型。即使你使用泛型（我们还没有学习，但我们将在本章中学习），某种方式将不适当类型的对象意外地放入集合中的机会更小，但仍然存在。不要问我如何；我无法告诉你。这就是错误的本质——你无法知道它们是如何工作的，直到你解决了它们。关键是你要为这样的异常情况做好准备。
- en: Handling exceptions
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理异常
- en: Exceptional cases should be handled in Java using exceptions. The `ClassCastException`
    is there and it happens when the sort tries to compare `String` to `Integer` using
    `StringComparator`, and to do that, it tries to cast an `Integer` to `String`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，应该使用异常来处理异常情况。`ClassCastException`是存在的，当排序尝试使用`StringComparator`比较`String`和`Integer`时发生，为了做到这一点，它试图将一个`Integer`转换为`String`。
- en: When an exception is thrown by the program using the `throw` command, or by
    the Java runtime, the execution of the program stops at that point, and instead
    of executing the next command, it continues where the exception is caught. It
    can be in the same method, or in some calling method up in the call chain. To
    catch an exception, the code throwing the exception should be inside a `try` block,
    and the catch statement following the `try` block should specify an exception
    that is compatible with the exception thrown.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序使用`throw`命令或Java运行时抛出异常时，程序执行将在该点停止，而不是执行下一个命令，而是继续在异常被捕获的地方。它可能是在同一个方法中，或者在上面的调用链中的某个调用方法中。为了捕获异常，抛出异常的代码应该在一个`try`块内部，并且跟随`try`块的`catch`语句应该指定一个与抛出的异常兼容的异常。
- en: 'If the exception is not caught, then the Java runtime will print out the message
    of the exception along with a stack trace that will contain all the classes, methods,
    and line numbers on the call stack at the time of the exception. In our case,
    the `mvn test` command will produce the following trace in the output:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果异常没有被捕获，那么Java运行时会打印出异常的消息，以及一个包含所有在异常发生时调用栈上的类、方法和行号的堆栈跟踪。在我们的情况下，`mvn test`命令将在输出中产生以下跟踪：
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This stack trace is not really long. In the production environment in an application
    that runs on an application server, the stack trace may contain a few hundred
    elements. In this trace, you can see that Maven was starting the test execution,
    involved Maven surefire plugin, and then the JUnit executor, until we get through
    the test to the comparator, where the actual exception was thrown.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个堆栈跟踪并不长。在生产环境中，运行在应用服务器上的应用程序的堆栈跟踪可能包含几百个元素。在这个跟踪中，你可以看到 Maven 正在启动测试执行，涉及到
    Maven surefire 插件，然后是 JUnit 执行器，直到我们通过测试到达比较器，在那里实际异常被抛出。
- en: This exception was not printed by the Java runtime to the console. This exception
    is caught by the JUnit library code and the stack trace is logged out to the console
    using Maven logging facility.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个异常没有被 Java 运行时打印到控制台。这个异常被 JUnit 库代码捕获，并且使用 Maven 日志记录功能将堆栈跟踪记录到控制台。
- en: The problem with this approach is that the real issue is not the class casting
    failure. The real issue is that the collection contains mixed elements. It is
    only realized by the Java runtime when it tries to cast two incompatible classes.
    Our code can be smarter. We can amend the comparator.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是真正的问题不是类转换失败。真正的问题是集合中包含混合元素。只有在 Java 运行时尝试将两个不兼容的类进行转换时才会意识到这一点。我们的代码可以更智能。我们可以修改比较器。
- en: '[PRE28]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This code catches the `ClassCastException` and throws a new one. The advantage
    of throwing a new exception is that you can be sure that this exception is thrown
    from the comparator and that the problem really is that there are mixed elements
    in the collection. Class casting problems may happen at other places of the code
    as well, inside some of the sort implementations. Some application code may want
    to catch the exception and want to handle the case; for example, sending an application-specific
    error message and not dumping only a stack trace to the user. This code can catch
    `ClassCastException` as well, but it cannot be sure what the real cause of the
    exception is. On the other hand, `NonStringElementInCollectionException` is definite.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码捕获了 `ClassCastException` 并抛出了一个新的异常。抛出新异常的优势在于你可以确信这个异常是从比较器抛出的，并且真正的问题确实是集合中存在混合元素。类转换问题也可能发生在代码的其他地方，例如某些排序实现中。一些应用程序代码可能想要捕获异常并处理这种情况；例如，发送一个特定于应用程序的错误消息，而不仅仅是向用户显示堆栈跟踪。这段代码也可以捕获
    `ClassCastException`，但它不能确定异常的真正原因。另一方面，`NonStringElementInCollectionException`
    是确定的。
- en: 'The `NonStringElementInCollectionException` is an exception that does not exist
    in the JDK. We will have to create it. Exceptions are Java classes and our exception
    looks as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`NonStringElementInCollectionException` 是一个在 JDK 中不存在的异常。我们必须创建它。异常是 Java 类，我们的异常看起来如下：'
- en: '[PRE29]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Java has the notion of checked exceptions. It means that any exception that
    is not extending `RuntimeException` should be declared in the method definition.
    Suppose our exception was declared as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Java 有检查异常的概念。这意味着任何不扩展 `RuntimeException` 的异常都应该在方法定义中声明。假设我们的异常被声明如下：
- en: '[PRE30]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, we will have to declare the `compare` method as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须将 `compare` 方法声明如下：
- en: '[PRE31]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The problem is that the exception a method throws is part of the method signature,
    and this way `compare` will not override the `compare` method of the interface,
    and, that way, the class will not implement the `Comparator` interface. Thus,
    our exception has to be a runtime exception.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于方法抛出的异常是方法签名的一部分，因此这种方式 `compare` 不会覆盖接口的 `compare` 方法，并且，这样，类就不会实现 `Comparator`
    接口。因此，我们的异常必须是一个运行时异常。
- en: 'There can be a hierarchy of exceptions in an application, and often, novice
    programmers create huge hierarchies of them. If there is something you can do,
    it does not mean that you should do it. Hierarchies should be kept as flat as
    possible, and this is especially true for exceptions. If there is an exception
    in the JDK that describes the exceptional case, then use the readymade exception.
    Just as well as for any other class: if it is ready, do not implement it again.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中可能存在异常的层次结构，而且通常，新手程序员会创建大量的层次结构。如果你能做某事，并不意味着你应该做。层次结构应该尽可能保持扁平，这对于异常来说尤其如此。如果
    JDK 中有描述异常情况的异常，那么就使用现成的异常。就像对任何其他类一样：如果它是现成的，就不要再次实现它。
- en: It is also important to note that throwing an exception should only be done
    in exceptional cases. It is not to signal some normal operational condition. Doing
    that hinders readability of the code and also eats CPU. Throwing an exception
    is not an easy task for the JVM.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意的是，抛出异常只应在异常情况下进行。这不是为了表示某种正常操作条件。这样做会阻碍代码的可读性，并消耗CPU资源。对于JVM来说，抛出异常并不是一件容易的事情。
- en: 'It is not only the exception that can be thrown. The `throw` command can throw,
    and the `catch` command can catch anything that extends the `Throwable` class.
    There are two subclasses of `Throwable`: `Error`, and `Exception`. The `Error`
    exception is thrown if some error happened during the execution of the Java code.
    The two most infamous errors are `OutOfMemoryError` and `StackOverflowError`.
    If any of these happens, you cannot do anything reliably to catch the error.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅异常可以被抛出。`throw`命令可以抛出，`catch`命令可以捕获任何扩展`Throwable`类的对象。`Throwable`有两个子类：`Error`和`Exception`。如果在Java代码执行过程中发生某些错误，将抛出`Error`异常。最臭名昭著的错误是`OutOfMemoryError`和`StackOverflowError`。如果发生这些错误中的任何一个，你将无法可靠地捕获错误。
- en: There is also `InternalError` and `UnknownError` in the JVM, but since JVM is
    fairly stable, you will hardly ever meet these errors.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: JVM中也有`InternalError`和`UnknownError`，但由于JVM相当稳定，你几乎不会遇到这些错误。
- en: When any of those errors happen, try to debug the code and try to find out why
    you use that much memory or such deep method calls and try to optimize your solution.
    What I have just said about creating exception hierarchies is true again to catch
    errors. The fact that you can catch errors does not mean that you should. On the
    contrary, you should never catch an error and, especially, never ever catch a
    `Throwable`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些错误中的任何一个发生时，尝试调试代码并找出为什么你使用了这么多内存或如此深的调用方法，并尝试优化你的解决方案。我刚才提到的创建异常层次结构对于捕获错误也是适用的。你可以捕获错误这一事实并不意味着你应该这样做。相反，你永远不应该捕获一个错误，尤其是永远不应该捕获一个`Throwable`。
- en: This way, we handled this special case when some programmer accidentally writes
    42 among the names, but will it be nicer if the error was identified during compile
    time? To do that, we will introduce generics.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们处理了这种特殊情况，即当某个程序员不小心在名称中写下了42时，但在编译时识别错误会更好吗？为了做到这一点，我们将引入泛型。
- en: 'Just a last thought before we go there. What class behavior do we test with
    the `canNotSortMixedElements` unit test? The test is inside the `BubbleSortTest`
    test class, but the functionality is in the comparator implementation, `StringComparator`.
    This test checks something that is out of the scope of the unit test class. I
    can use it for demonstration purposes, but this is not a unit test. The real functionality
    of the sort implementation can be formulized this way: whatever exception the
    comparator throws is thrown by the sort implementation. You can try to write this
    unit test, or read on; we will have it in the next section.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，先思考一下。我们使用`canNotSortMixedElements`单元测试测试哪个类的行为？这个测试在`BubbleSortTest`测试类内部，但功能在比较器实现`StringComparator`中。这个测试检查的是单元测试类范围之外的东西。我可以用它来演示，但这不是一个单元测试。排序实现的真正功能可以这样表述：比较器抛出的任何异常都会由排序实现抛出。你可以尝试编写这个单元测试，或者继续阅读；我们将在下一节中介绍它。
- en: The `StringComparator` class does not have a test class because `StringComparator`
    is part of the test and we will never write a test for a test. Otherwise, we will
    sink into an endless rabbit hole.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringComparator`类没有测试类，因为`StringComparator`是测试的一部分，我们永远不会为测试编写测试。否则，我们将陷入无尽的兔子洞。'
- en: Generics
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型
- en: 'The generics feature was introduced into Java in version 5\. To start with
    an example, our `Sortable` interface until now was this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型特性是在Java 5版本中引入的。以一个例子开始，我们之前的`Sortable`接口是这样的：
- en: '[PRE32]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After introducing generics, it will be as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入泛型之后，它将如下所示：
- en: '[PRE33]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `E` identifier denotes a type. It can be any type. It says that a class
    is a sortable collection if it implements the interface, namely the two methods—
    `size` and `get`. The `get` method should return something that is of type `E`,
    whatever `E` is. This may not make too much sense up until now, but you will soon
    get the point. After all, generics is a difficult topic.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`E`标识符表示一个类型。它可以是指任何类型。它表示，如果一个类实现了该接口，即实现了两个方法——`size`和`get`，那么这个类就是一个可排序的集合。`get`方法应该返回一个类型为`E`的对象，无论`E`是什么。这可能现在还不太容易理解，但很快你就会明白。毕竟，泛型是一个复杂的话题。'
- en: 'The `Sort` interface will become the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sort`接口将变成以下形式：'
- en: '[PRE34]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This still does not provide much more value than the previous version without
    generics, but, at least, it does something. In the actual class implementing the
    `Sort` interface, `Comparator` should accept the same type that `SortableCollection`
    uses. It is not possible that `SortableCollection` works on strings and we inject
    a comparator for integers.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这与没有泛型的上一个版本相比，并没有提供更多的价值，但至少它做了些什么。在实际实现`Sort`接口的类中，`Comparator`应该接受与`SortableCollection`使用的相同类型。不可能`SortableCollection`在字符串上工作，而我们注入一个用于整数的比较器。
- en: 'The implementation of `BubbleSort` is as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`BubbleSort`的实现如下：'
- en: '[PRE35]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The real power of generics will come when we will write the tests. The first
    test does not change much, although with the generics, it is more definite.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型的真正力量将在我们编写测试时显现出来。第一个测试变化不大，尽管有了泛型，它更加明确。
- en: '[PRE36]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When we define `ArrayList`, we will also declare that the elements of the list
    will be strings. When we allocate the new `ArrayList`, there is no need to specify
    again that the elements are strings because it comes from the actual elements
    there. Each of them is a string; therefore, the compiler knows that the only thing
    that can come between the `<` and `>` character is `String`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义`ArrayList`时，我们也会声明列表的元素将是字符串。当我们分配新的`ArrayList`时，没有必要再次指定元素是字符串，因为它是从实际元素那里来的。每个元素都是一个字符串；因此，编译器知道在`<`和`>`字符之间只能出现`String`。
- en: The two characters `<` and `>`, without the type definition in between, is called
    **diamond operator**. The type is inferred. If you get used to generics, this
    code brings you more information on the types that the collections work on and
    the code becomes more readable. The readability and the extra information is not
    the only point.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 两个字符`<`和`>`，中间没有类型定义，被称为**菱形运算符**。类型是推断出来的。如果你习惯了泛型，这段代码会给你更多关于集合操作类型的信息，代码也变得更易读。可读性和额外信息并不是唯一的目的。
- en: As we know that the `Comparator` argument is `Comparator<String>` now, we can
    use advanced features of Java available since Java 8 and can pass the `String::compareTo`
    method reference to the comparator setter.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，现在的`Comparator`参数是`Comparator<String>`，我们可以使用自Java 8以来可用的Java高级特性，并将`String::compareTo`方法引用传递给比较器设置器。
- en: The second test is the important one for us now. This is the test which ensures
    that `Sort` does not interfere with the exception that the comparator throws.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试对我们来说现在很重要。这是确保`Sort`不会干扰比较器抛出的异常的测试。
- en: '[PRE37]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The thing is, that it does not even compile. The compiler says that it cannot
    infer the type of `ArrayList<>` on the third line. When all the arguments of the
    `asList` method were strings, the method returned a list of `String` elements
    and therefore the new operator was known to generate `ArrayList<String>`. This
    time, there is an integer, and thus, the compiler cannot infer that `ArrayList<>`
    is for `String` elements.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，它甚至无法编译。编译器表示它无法在第三行推断`ArrayList<>`的类型。当`asList`方法的全部参数都是字符串时，该方法返回一个包含`String`元素的列表，因此新操作符已知会生成`ArrayList<String>`。这次，有一个整数，因此编译器无法推断`ArrayList<>`是用于`String`元素的。
- en: 'To change the type definition from `ArrayList<>` to `ArrayList<String>` is
    not a cure. In that case, the compiler will complain about the value `42`. This
    is the power of generics. When you use classes that have type parameters, the
    compiler can detect when you provide a value of the wrong type. To get the value
    into `ArrayList` to check that the implementation really throws an exception,
    we will have to conjure the value into it. We can try to replace the value `42`
    with an empty `String` and then add the following line which will still not compile:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 将类型定义从`ArrayList<>`更改为`ArrayList<String>`并不是一个解决办法。在这种情况下，编译器会抱怨值`42`。这就是泛型的力量。当你使用有类型参数的类时，编译器可以检测到你提供了错误类型的值。为了将值放入`ArrayList`以检查实现是否真的抛出了异常，我们必须将值放入其中。我们可以尝试将值`42`替换为空字符串，然后添加以下行，这将仍然无法编译：
- en: '[PRE38]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The compiler will still know that the value you want to set in `ArrayList`
    is supposed to be `String`. To get the array with the `Integer` element, you will
    have to explicitly unlock the safety handle and pull the trigger, shooting yourself:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器仍然知道你想要在`ArrayList`中设置的值应该是`String`。为了得到包含`Integer`元素的数组，你必须显式解锁安全控制并扣动扳机，即自杀：
- en: '[PRE39]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, the test looks like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，测试看起来是这样的：
- en: '[PRE40]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We will set the Swapper to be null because it is never invoked. When I first
    wrote this code, it was evident to me. A few days later, I read the code and I
    stopped. *Why is swapper null?* Then I remembered in a second or two. But any
    time, when reading and understanding the code hicks up, I tend to think about
    refactoring.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置Swapper为null，因为它从未被调用。当我第一次写这段代码时，对我来说很明显。几天后，我阅读了代码，然后停了下来。*为什么swapper是null？*然后我几秒钟就回想起来了。但每次阅读和理解代码遇到困难时，我往往会考虑重构。
- en: I can add a comment to the line saying `//never invoked`, but comments tend
    to remain there even when functionality changes. I learned it the hard way in
    2006, when a wrong comment prevented me from seeing how the code was executing.
    I was reading the comment while debugging, instead of the code, and bug fixing
    took two days while the system was down.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以在表示`//never invoked`的行上添加注释，但注释往往会在功能改变后仍然存在。我在2006年学到了这一点，当时一个错误的注释阻止了我看到代码的执行方式。我在调试时阅读注释，而不是代码，修复错误花了两天时间，而系统一直处于关闭状态。
- en: Instead of a comment, I tend to use constructs that make the code express what
    happens. The extra variable may make the class file a few bytes bigger, but it
    is optimized out by the JIT compiler so the final code does not run slower.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是注释，我倾向于使用使代码表达所发生情况的构造。额外的变量可能会使类文件大几字节，但JIT编译器会将其优化掉，所以最终的代码不会运行得更慢。
- en: The comparator that throws an exception was provided as a lambda expression.
    Lambda expressions can be used in cases where an anonymous class or named class
    will be used having only one simple method. Lambda expressions are anonymous methods
    stored in variables or passed in argument for later invocation. We will discuss
    the details of lambda expressions in [Chapter 8](part0233.html), *Extending our
    E-Commerce Application*.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出异常的比较器被提供为一个lambda表达式。Lambda表达式可以在需要使用只有一个简单方法的匿名类或命名类的情况下使用。Lambda表达式是存储在变量中或作为参数传递以供稍后调用的匿名方法。我们将在[第8章](part0233.html)，*扩展我们的电子商务应用*中讨论lambda表达式的细节。
- en: For now, we will go on implementing `QuickSort`, and to do that, we will use
    the TDD methodology.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将继续实现`QuickSort`，为此，我们将使用TDD方法。
- en: Test Driven Development
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: 'Test Driven Development (TDD) is a code writing approach when the developers
    first write a test based on the specification and then write the code. This is
    just the opposite that the developer community got used to. The conventional approach
    that we followed was to write the code and then write tests for it. To be honest,
    the real practice many times was to write the code and test it with ad-hoc tests
    and no unit tests at all. Being a professional, you will never do that, by the
    way. You always write tests. (And now, write it down a hundred times: I will always
    write tests.)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发（TDD）是一种代码编写方法，其中开发者首先根据规范编写测试，然后编写代码。这与开发者社区习惯的做法正好相反。我们遵循的传统方法是先编写代码，然后为它编写测试。说实话，许多时候真正的实践是先编写代码，然后用即兴测试测试它，甚至没有单元测试。无论如何，作为一个专业人士，你永远不会那样做。你总是编写测试。（现在，把它写下百遍：我会总是编写测试。）
- en: One of the advantages of TDD is that the tests do not depend on the code. As
    the code does not exist at the creation of the test, developers cannot rely on
    the implementation of the unit and, thus, it cannot influence the test creation
    process. This is generally good. Unit tests should be black box tests as much
    as possible.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: TDD的一个优点是测试不依赖于代码。由于代码在测试创建时不存在，开发者不能依赖于单元的实现，因此它不能影响测试创建过程。这通常是好的。单元测试应该尽可能多地是黑盒测试。
- en: Black box test is a test that does not take into account the implementation
    of the tested system. If a system is refactored, implemented in a different way,
    but the interface it provides toward the external world is the same, then the
    black box tests should run just fine.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 黑盒测试是一种不考虑被测试系统实现的测试。如果一个系统被重构，以不同的方式实现，但提供给外部世界的接口相同，那么黑盒测试应该能够正常运行。
- en: A white box test depends on the internal working of the system tested. When
    the code changes the white box test, the code may also need tuning to follow the
    change. The advantage of a white box test can be the simpler test code. Not always.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 白盒测试依赖于被测试系统的内部工作。当代码发生变化时，白盒测试可能也需要调整以适应变化。白盒测试的优点可能是更简单的测试代码。并不总是这样。
- en: Gray box test is a mixture of the two.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 灰盒测试是两者的混合体。
- en: Unit tests should be black box tests, but, many times, it is not simple to write
    a black box test. Developers will write a test that they think is black box, but
    many times, this belief proves to be false. When the implementation changes, something
    is refactored and the test does not work anymore and it needs to be corrected.
    It just happens that knowing the implementation, the developers, especially those
    who wrote the unit, will write a test that depends on the internal working of
    the code. Writing the test before the code is a tool to prevent this. If there
    is no code, you cannot depend on it.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试应该是黑盒测试，但很多时候，编写黑盒测试并不简单。开发者会编写他们认为的黑盒测试，但很多时候，这种信念被证明是错误的。当实现发生变化时，某些东西被重构，测试不再工作，需要被修正。恰好知道实现，开发者，尤其是编写单元测试的开发者，会编写依赖于代码内部工作的测试。在编写代码之前编写测试是防止这种情况的工具。如果没有代码，你无法依赖它。
- en: TDD also says that the development should be an iterative approach. You write
    only one test at the start. If you run, it fails. Of course it fails! As there
    is no code yet, it has to fail. Then, you will write the code that fulfills this
    test. Nothing more, only the code that makes this test pass. Then, you will go
    on writing a new test for another part of the specification. You will run it and
    it fails. This proves that the new test does test something that was not developed
    yet. Then, you will develop the code to satisfy the new test and, possibly, you
    will also modify a block of code that you have already written in the previous
    iterations. When the code is ready, the tests will pass.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: TDD还表示开发应该是一个迭代的过程。你一开始只写一个测试。如果你运行它，它会失败。当然会失败！因为没有代码，它必须失败。然后，你将编写满足这个测试的代码。没有更多，只有使这个测试通过的代码。然后，你将继续为规范的其他部分编写一个新的测试。你将运行它，它会失败。这证明了新的测试确实测试了尚未开发的内容。然后，你将开发代码以满足新的测试，并且可能还需要修改之前迭代中已经编写的一段代码。当代码准备好时，测试将通过。
- en: Many times, developers are reluctant to modify the code. This is because they
    are afraid of breaking something that was already working. When you follow TDD,
    you should not, and at the same time, you need not be afraid of this. There are
    tests for all features that were already developed. If some of the code modification
    breaks some functionality, the tests will immediately signal the error. The key
    is that you run the tests as often as possible when the code is modified.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，开发者不愿意修改代码。这是因为他们害怕破坏已经正常工作的东西。当你遵循TDD时，你不应该这样做，同时，你也不必为此感到害怕。所有已开发的功能都有测试。如果某些代码修改破坏了某些功能，测试将立即发出错误信号。关键是，在代码修改时，尽可能频繁地运行测试。
- en: Implementing QuickSort
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现快速排序
- en: Quick sort, as we have already discussed, is made of two major parts. One is
    partitioning and the other one is doing the partitioning recursively until the
    whole array is sorted. To make our code modular and ready to demonstrate the Java
    9 module-handling feature, we will develop the partitioning and the recursive
    sorting into separate classes and in a separate package. The complexity of the
    code will not justify this separation.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，快速排序由两个主要部分组成。一个是分区，另一个是递归地进行分区，直到整个数组排序。为了使我们的代码模块化并准备好演示Java 9模块处理功能，我们将分区和递归排序开发成单独的类和单独的包。代码的复杂性不足以证明这种分离是合理的。
- en: The partitioning class
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分区类
- en: 'The partitioning class should provide a method that moves the elements of the
    collection based on a pivot element, and we will need to know the position of
    the pivot element after the method finishes. The signature of the method should
    look something like this:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 分区类应该提供一个方法，该方法根据枢轴元素移动集合中的元素，并且方法完成后我们需要知道枢轴元素的位置。方法的签名应该看起来像这样：
- en: '[PRE41]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The class should also have access to `Swapper` and `Comparator`. In this case,
    we defined a class and not an interface; therefore, we will use constructor injection.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 该类还应能够访问`Swapper`和`Comparator`。在这种情况下，我们定义了一个类而不是接口；因此，我们将使用构造函数注入。
- en: These constructs, like setters and constructor injectors, are so common and
    happen so frequently that IDEs support the generation of these. You will need
    to create the `final` fields in the code and use the *code generation* menu to
    create the constructor.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结构，如设置器和构造函数注入器，如此常见且频繁发生，以至于集成开发环境（IDEs）支持生成这些。你需要在代码中创建`final`字段，并使用*代码生成*菜单来创建构造函数。
- en: 'The partitioning class will look like the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 分区类将如下所示：
- en: '[PRE42]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This code does nothing, but that is how TDD starts. We will create the definition
    of a requirement providing the skeleton of the code and the test that will call
    it. To do that, we will need something that we can partition. The simplest choice
    is an `Integer` array. The `partition` method needs a object of type `SortableCollection<E>`,
    and we will need something that wraps the array and implements this interface.
    We name that class `ArrayWrapper`. This class serves a general purpose and it
    is not only for the test. Because of that, we create it as production code and
    as such we put it in the directory `main` and not in the directory `test`. As
    this wrapper is independent from the implementation of `Sort`, the proper position
    of this class is in a new `SortSupportClasses` module. We will create the new
    module as it is not part of the interface. Implementations depend on the interface,
    but not on the support classes. There can also be some application that uses our
    libraries and may need the interface module and some of the implementation but
    still does not need the support classes when they deliver the wrapping functionality
    themselves. After all, we cannot implement all possible wrapping functionality.
    The SRP also holds for the modules.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码没有任何作用，但这就是 TDD 的开始。我们将创建一个需求的定义，提供代码的骨架和将调用它的测试。为此，我们需要可以分割的东西。最简单的选择是
    `Integer` 数组。`partition` 方法需要一个 `SortableCollection<E>` 类型的对象，我们需要一个可以包装数组并实现此接口的东西。我们将这个类命名为
    `ArrayWrapper`。这个类具有通用目的，不仅用于测试。因此，我们将其作为生产代码创建，并将其放在 `main` 目录中，而不是 `test` 目录中。由于这个包装器与
    `Sort` 的实现无关，这个类的正确位置是在一个新的 `SortSupportClasses` 模块中。我们将创建新的模块，因为它不是接口的一部分。实现依赖于接口，但不依赖于支持类。也可能有一些应用程序使用我们的库，可能需要接口模块和一些实现，但仍然不需要支持类，当它们自己提供包装功能时。毕竟，我们不能实现所有可能的包装功能。SRP
    也适用于模块。
- en: Java libraries tend to contain unrelated functionalities. For the short run,
    it makes the use of the library simpler. You will only need to specify one dependency
    in your POM file and you will have all the classes and APIs that you need. In
    the long run, the application gets bigger, carrying a lot of classes that are
    part of some of the libraries but the application never uses them.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Java 库往往包含不相关的功能。从短期来看，这使得库的使用更加简单。你只需要在 POM 文件中指定一个依赖项，你就可以拥有所有需要的类和 API。从长远来看，应用程序会变得更大，携带许多库中的类，但应用程序永远不会使用它们。
- en: To add the new module, the module directory has to be created along with the
    source directories and the POM file. The module has to be added to the parent
    POM and it also has to be added to the `dependencyManagement` section so that
    the test code of the `QuickSort` module can use it without specifying the version.
    The new module depends on the interface module, so this dependency has to be added
    to the POM of the support classes.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加新模块，必须创建模块目录以及源目录和 POM 文件。该模块必须添加到父 POM 中，并且还必须添加到 `dependencyManagement`
    部分，以便 `QuickSort` 模块的测试代码可以使用它而无需指定版本。新模块依赖于接口模块，因此必须将其添加到支持类的 POM 中。
- en: The `ArrayWrapper` class is simple and general.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayWrapper` 类简单且通用。'
- en: '[PRE43]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `ArraySwapper` class, which we also need, comes into the same module. It
    is just as simple as the wrapper.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要 `ArraySwapper` 类，它也属于同一个模块。它和包装器一样简单。
- en: '[PRE44]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Having these classes, we can create our first test.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 有这些类后，我们可以创建我们的第一个测试。
- en: '[PRE45]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Before creating the `@Test` method, we will need two helper methods that make
    assertions. Assertions are not always simple, and in some cases, they may involve
    some coding. The general rule is that the test and the assertions in it should
    be as simple as possible; otherwise, they are just possible source of programming
    errors. Additionally, we created them to avoid programming errors, not to create
    new ones.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 `@Test` 方法之前，我们需要两个辅助方法来进行断言。断言并不总是简单的，在某些情况下，它们可能涉及一些编码。一般规则是，测试及其中的断言应该尽可能简单；否则，它们只是可能成为编程错误的来源。此外，我们创建它们是为了避免编程错误，而不是创造新的错误。
- en: The `assertSmallElements` method asserts that all elements before `cutIndex`
    are smaller than `pivot`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertSmallElements` 方法断言 `cutIndex` 之前的所有元素都小于 `pivot`。'
- en: '[PRE46]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `assertLargeElements` method makes sure that all elements following `cutIndex`
    are at least as large as `pivot`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertLargeElements` 方法确保所有在 `cutIndex` 之后的所有元素至少与 `pivot` 一样大。'
- en: '[PRE47]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The test uses a constant array of `Integers` and wraps it into an `ArrayWrapper`
    class.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 测试使用一个常量 `Integers` 数组，并将其包装在 `ArrayWrapper` 类中。
- en: '[PRE48]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'There is no `Comparator` for `Integer` type in the JDK, but it is easy to define
    one as a lambda function. Now we can write the `partition` method, as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 中没有为 `Integer` 类型定义 `Comparator`，但定义一个作为 lambda 函数很容易。现在我们可以编写 `partition`
    方法，如下所示：
- en: '[PRE49]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '![](img/00038.jpeg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00038.jpeg)'
- en: If we run the test, it runs fine. However, if we run the test with coverage,
    then the IDE tells us that the coverage is only 92%. The test covered only 13
    of the 14 lines of the `partition` method.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行测试，它会正常运行。然而，如果我们用覆盖率运行测试，IDE 会告诉我们覆盖率只有 92%。测试只覆盖了 `partition` 方法的 14
    行中的 13 行。
- en: There is a red rectangle on the gutter at line **28**. This is because the test
    array is already partitioned. There is no need to swap any element in it when
    the pivot value is `6`. It means that our test is good, but not good enough. What
    if there is an error on that line?
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 **28** 行的页边空白处有一个红色矩形。这是因为测试数组已经被分区了。当枢轴值是 `6` 时，不需要在其中交换任何元素。这意味着我们的测试是好的，但还不够好。如果那一行有错误怎么办？
- en: To amend this problem, we will extend the test, changing the test array from
    `{ 0, 7, 6 }` to `{ 0, 7, 6, 2}`. Run the test and it fails. Why? After some debugging,
    we will realize that we invoke the method `partition` with the fixed parameter
    `2` as the last index of the array. But, we made the array longer. Why did we
    write a constant there in the first place? It is a bad practice. Let's replace
    it with `partitionThis.length-1`. Now, it says that `cutIndex` is `2`, but we
    expected `1`. We forgot to adjust the assertion to the new array. Let's fix it.
    Now it works.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将扩展测试，将测试数组从 `{ 0, 7, 6 }` 改为 `{ 0, 7, 6, 2}`。运行测试，它失败了。为什么？经过一些调试后，我们会意识到我们使用固定参数
    `2` 作为数组的最后一个索引调用了 `partition` 方法。但是，我们使数组变长了。为什么一开始我们要在那里写一个常量呢？这是一个坏习惯。让我们将其替换为
    `partitionThis.length-1`。现在，它说 `cutIndex` 是 `2`，但我们期望的是 `1`。我们忘记调整断言以适应新的数组。让我们修复它。现在它工作了。
- en: The last thing is to rethink the assertions. The less code the better. The assertion
    methods are quite general, and we will use it for one single test array. The assertion
    methods are so complex that they deserve their own test. But, we do not write
    code to test. Instead of that, we can simply delete the methods and have the final
    version of the test.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要重新思考断言。代码越少越好。断言方法相当通用，我们将用它来对一个单一的测试数组进行测试。断言方法如此复杂，以至于它们值得拥有自己的测试。但是，我们没有编写测试代码。相反，我们可以简单地删除这些方法，并拥有测试的最终版本。
- en: '[PRE50]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: And then again, is this a black-box test? What if the partitioning returns `{2,
    1, 7, 6}`? It fits the definition. We can create more complex tests to cover such
    cases. But a more complex test may also have a bug in the test itself. As a different
    approach, we can create tests that may be simpler but rely on the internal structure
    of the implementation. These are not black-box tests and thus not ideal unit tests.
    I will go for the second one, but I will not argue if someone chooses the other.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这又是一个黑盒测试吗？如果分区返回 `{2, 1, 7, 6}` 呢？它符合定义。我们可以创建更复杂的测试来覆盖这种情况。但是，更复杂的测试本身也可能有错误。作为不同的方法，我们可以创建可能更简单但依赖于实现内部结构的测试。这些不是黑盒测试，因此不是理想的单元测试。我将选择第二种方法，但如果有人选择其他方法，我不会争论。
- en: Recursive sorting
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归排序
- en: 'We will implement the quick sort with an extra class that is in the `qsort`
    package along with the partitioning class, which is as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `qsort` 包中实现快速排序，该包包含分区类以及一个额外的类，如下所示：
- en: '[PRE51]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The method gets `SortableCollection<E>` and two index parameters. It does not
    sort the whole collection; it sorts only the elements between the `start` and
    the `end` index.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接收 `SortableCollection<E>` 和两个索引参数。它不会对整个集合进行排序；它只对 `start` 和 `end` 索引之间的元素进行排序。
- en: It is always important to be extremely precise with the indexing. Usually, there
    is no problem with the start index in Java, but a lot of bugs source from how
    the `end` index is interpreted.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 总是极其精确地处理索引非常重要。通常，Java 中的起始索引没有问题，但很多错误都源于如何解释 `end` 索引。
- en: In this method, the value of `end` can mean that the index is already not part
    of the to-be-sorted interval. In that case, the `partition` method should be invoked
    with `end-1` and the first recursive call with `cutIndex` as last parameter. It
    is a matter of taste. The important thing is to be precise and define the interpretation
    of index parameters.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，`end`的值可能意味着索引已经不再是待排序区间的部分。在这种情况下，应该使用`end-1`调用`partition`方法，并使用`cutIndex`作为最后一个参数进行第一次递归调用。这取决于个人喜好。重要的是要精确并定义索引参数的解释。
- en: If there is only one element `(start == end)`, then there is nothing to be sorted
    and the method returns. This is the end criterion of the recursion. The method
    also assumes that the `end` index is never smaller than the `start` index. As
    this method is used only inside the library that we are developing at the moment,
    such an assumption is not too risky to make.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只有一个元素（`start == end`），那么就没有东西要排序，方法返回。这是递归的结束条件。该方法还假设`end`索引永远不会小于`start`索引。由于这个方法只在我们目前正在开发的库中使用，这样的假设风险并不太大。
- en: If there is something to be sorted, then the method takes the first element
    of the to-be-sorted interval and uses it as pivot and calls the `partition` method.
    When the partition is done, the method recursively calls itself for the two halves.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有东西要排序，那么方法会取待排序区间的第一个元素作为枢轴，并调用`partition`方法。当分区完成后，方法会递归地对自己调用两次，分别针对两个半区。
- en: This algorithm is recursive. This means that the method calls itself. When a
    method call is executed, the processor allocates some memory in an area called
    **stack** and it stores the local variables there. This area that belongs to the
    method in the stack is called **stack frame**. When the method returns, this area
    is released and the stack is restored, simply moving the stack pointer where it
    was to the previous state. This way a method can continue its execution after
    calling another method; the local variables are there.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法是递归的。这意味着该方法会调用自身。当方法调用执行时，处理器在称为**栈**的区域分配一些内存，并将局部变量存储在那里。这个属于栈中的方法区域称为**栈帧**。当方法返回时，这个区域被释放，栈被恢复，简单地将栈指针移动到之前的状态。这样，方法可以在调用另一个方法后继续执行；局部变量仍然存在。
- en: When a method calls itself, it is not different. The local variables are local
    to the actual call of the method. When the method calls itself, it allocates space
    for the local variables again on the stack. In other words, these are new *instances*
    of the local variables.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个方法调用自身时，并没有什么不同。局部变量是方法实际调用的局部变量。当方法调用自身时，它会在栈上再次为局部变量分配空间。换句话说，这些都是局部变量的新**实例**。
- en: We will use recursive methods in Java, and in other programming languages, when
    the definition of the algorithm is recursive. It is extremely important to understand
    that when the processor code runs, it is not recursive any more. On that level,
    there are instructions, register stores, and memory loads and jumps. There is
    nothing like function or method and therefore, on that level, there is nothing
    like recursion.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当算法的定义是递归时，我们将在Java和其他编程语言中使用递归方法。极其重要的是要理解，当处理器代码运行时，它不再是递归的。在那个层面上，有指令、寄存器存储和内存加载和跳转。没有函数或方法，因此在那个层面上，也没有递归。
- en: If you get that, it is easy to understand that any recursion can be coded as
    a loop.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你明白了这一点，那么理解任何递归都可以编码为循环就很容易了。
- en: As a matter of fact, it is also true the other way around—every loop can be
    coded as recursion but that is not really interesting until you start functional
    programming.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，反过来也是真的——每个循环都可以编码为递归，但直到你开始函数式编程，这并不是很有趣。
- en: The problem with the recursion in Java, and in many other programming languages,
    is that it may run out of stack space. In the case of quick sort, this is not
    the case. You can safely assume that the stack for method calling in Java is a
    few hundreds of levels. Quick sort needs a stack that is approximately *log[2]n*
    deep, where *n* is the number of elements to be sorted. In the case of one billion
    elements, this is 30 that should just fit.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的递归问题，以及许多其他编程语言中的问题，是它可能会耗尽栈空间。在快速排序的情况下，这并不是问题。你可以安全地假设Java中方法调用的栈有几百层。快速排序需要一个深度大约为
    *log[2]n* 的栈，其中 *n* 是要排序的元素数量。对于十亿个元素，这是30层，刚好合适。
- en: Why is the stack not moved or resized? That is because the code that runs out
    of the stack space is usually bad style. They can be expressed more readable in
    form of some loop. A more robust stack implementation would only lure the novice
    programmer to do some less readable recursive coding.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么栈没有被移动或调整大小？这是因为耗尽栈空间的代码通常是不良的编程风格。它们可以用某种循环的形式表达得更易于阅读。一个更健壮的栈实现只会诱导新手程序员编写一些不太易于阅读的递归代码。
- en: There is a special case of recursion named tail recursion. A tail recursive
    method calls itself as the last instruction of the method. When the recursive
    call returns the code, executing the method does nothing else but release the
    stack frame that was used for this method invocation. In other words, we will
    keep the stack frame during the recursive call just to throw it away afterwards.
    Why not throw it away before the call? In that case, the actual frame, which has
    the same size and call, will allocate because this is just the same method that
    is kept and the recursive call is transformed into a jump instruction. This is
    an optimization that Java does not do. Functional languages are doing it, but
    Java is not really a functional language and therefore tail-recursive functions
    should rather be avoided and transformed to a loop in the Java source level.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 递归有一个特殊的案例，称为尾递归。尾递归方法在方法中的最后一个指令处调用自己。当递归调用返回代码时，执行该方法除了释放用于此方法调用的栈帧外，不再做其他任何事情。换句话说，我们将在递归调用期间保留栈帧，只是为了之后将其丢弃。为什么不在调用之前丢弃？在这种情况下，具有相同大小和调用的实际帧将分配，因为这只是保留的方法，递归调用被转换成跳转指令。这是一个Java没有做的优化。函数式语言正在这样做，但Java并不是真正的函数式语言，因此尾递归函数应该尽量避免，并在Java源级别转换为循环。
- en: Non-recursive sorting
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非递归排序
- en: 'To demonstrate that even non-tail recursive methods can be expressed in a non-recursive
    way, here is the quick sort that way:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明即使是非尾递归方法也可以用非递归的方式表达，这里以快速排序为例：
- en: '[PRE52]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This code implements a stack on the Java level. While it sees that there is
    still something scheduled to be sorted in `stack`, it fetched it from the stack
    and does the sort partitioning, and schedules the two parts for being sorted.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在Java级别实现了栈。当它看到`stack`中仍有待排序的内容时，它会从栈中取出它，进行排序分区，并为排序的两个部分安排排序。
- en: This code is more complex than the previous one and you have to understand the
    role of the `Stack` class and how it works. On the other hand, the program uses
    only one instance of the `Partitioner` class and it is also possible to use a
    thread pool to schedule the subsequent sorts instead of handling the tasks in
    a single process. This may speed up the sort when it is executed on a multi-CPU
    machine. However, this is a bit more complex task and this chapter contains a
    lot of new things without multitasking; therefore, we will look at multithread
    code in two chapters later only.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码比之前的更复杂，你必须理解`Stack`类的作用以及它是如何工作的。另一方面，程序只使用一个`Partitioner`类的实例，也可以使用线程池来安排后续的排序，而不是在单个进程中处理任务。这可能会在多CPU机器上执行排序时加快排序速度。然而，这是一个更复杂的任务，本章包含了许多新内容，没有多任务处理；因此，我们将在稍后的两章中仅查看多线程代码。
- en: In the very first version of the sort, I was coding it without the three lines
    that compare `cutIndex` against the interval start and increments it in the `if`
    branch. It is needed very much. But, the unit tests we created in this book do
    not discover the bug if we miss those lines. I recommend that you just delete
    those lines and try to write some unit tests that fail. Then try to understand
    what the special case is when those lines are vital and try to modify your unit
    test so that it is the simplest possible that still discovers that bug. (Finally,
    put the four lines back and see if the code works.)
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在排序的第一个版本中，我编写代码时没有包含比较`cutIndex`与区间起始和增加它的三条代码行。这非常必要。但是，我们在这本书中创建的单元测试如果没有这些行，就无法发现这个错误。我建议你直接删除这些行，并尝试编写一些失败的单元测试。然后尝试理解当这些行至关重要时的特殊情况，并尝试修改你的单元测试，使其尽可能简单但仍能发现这个错误。（最后，将这四行代码放回，看看代码是否还能工作。）
- en: Additionally, find some architectural reason why not to put this modification
    into the method `partition`. That method could just return `large+1` in case `large
    == start`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，找出一些架构上的原因，说明为什么不要将这个修改放入`partition`方法中。如果`large == start`，该方法只需返回`large+1`。
- en: Implementing the API class
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现API类
- en: Having done all this, the last thing we will need is to have `QuickSort` as
    a simple class (all the real work was already done in different classes).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 做了所有这些之后，我们最后需要的是将 `QuickSort` 作为一个非常简单的类（所有真正的工都已经在不同类中完成）。
- en: '[PRE53]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Do not forget that we also need a test! But, in this case, that is not much
    different than that of `BubbleSort`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记我们还需要一个测试！但是，在这种情况下，这并不比 `BubbleSort` 的测试有太大不同。
- en: '[PRE54]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This time, we used `String` array instead of `ArrayList`. This makes this test
    simpler and, this time, we already have the support classes.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们使用了 `String` 数组而不是 `ArrayList`。这使得这个测试更简单，这次我们已经有支持类了。
- en: You may recognize that this is not a unit test. In the case of `BubbleSort`,
    the algorithm was implemented in a single class. Testing that single class is
    a unit test. In the case of `QuickSort`, we separated the functionality into separate
    classes, and even into separate packages. A real unit test of the `QuickSort`
    class will disclose the dependency of that class on other classes. When this test
    runs, it involves the execution of `Partitioner` and also `Qsort`; therefore,
    it is not really a unit test.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会意识到这并不是一个单元测试。在 `BubbleSort` 的情况下，算法是在一个单独的类中实现的。测试这个单个类是一个单元测试。在 `QuickSort`
    的情况下，我们将功能分离到单独的类中，甚至分离到单独的包中。对 `QuickSort` 类的真实单元测试将揭示该类对其他类的依赖性。当这个测试运行时，它涉及到
    `Partitioner` 和 `Qsort` 的执行；因此，这并不是真正的单元测试。
- en: Should we bother about that? Not really. We want to create unit tests that involve
    a single unit to know where the problem is when a unit test fails. If there were
    only integration tests, a failing test case would not help a lot in pointing out
    where the problem is. All it says is that there is some problem in the classes
    that are involved in the test. In this case, there are only a limited number of
    classes (three) that are involved in this test and they are tied together. They
    are actually tied together and related to each other so closely that in the real
    production code, I would have implemented them in a single class. I separated
    them here to demonstrate how to test a single unit and also to demonstrate Java
    9 module support that needs a bit more than a single class in a JAR file.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该为此烦恼吗？实际上不必。我们想要创建涉及单个单元的单元测试，以便在单元测试失败时知道问题在哪里。如果只有集成测试，失败的测试用例在指出问题所在方面帮助不大。它所表明的只是测试中涉及的某些类中存在问题。在这种情况下，只有有限数量的类（三个）涉及到这个测试，并且它们是相互关联的。实际上，它们是如此紧密地相互关联，以至于在真正的生产代码中，我会将它们实现为一个单独的类。我在这里将它们分开，以展示如何测试单个单元，同时也展示需要比单个类在
    JAR 文件中更多支持的 Java 9 模块支持。
- en: Creating modules
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模块
- en: Module handling, also known as project **Jigsaw,** is a feature that was made
    available only in Java 9\. It was a long planned feature that the developers were
    waiting for. First it was planned for Java 7, but it was so complex that it got
    postponed to Java 8 and then to Java 9\. A year ago, it seemed that it would get
    postponed again, but finally, the project code got into the early releases and
    now nothing can stop from being part of the release.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 模块处理，也称为项目 **Jigsaw**，是仅在 Java 9 中提供的一项功能。这是一个开发者们期待已久的长期计划的功能。最初它计划在 Java 7
    中实现，但由于其复杂性，它被推迟到了 Java 8，然后又推迟到了 Java 9。一年前，它似乎还会再次被推迟，但最终，项目代码进入了早期发布，现在没有什么可以阻止它成为发布的一部分。
- en: Why modules are needed
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么需要模块
- en: We have already seen that there are four levels of access in Java. A method
    or field can be `private`, `protected`, `public`, or `default` (also known as
    package private) when no modifier is supplied. When you develop a complex library
    to be used in several projects, the library itself will contain many classes in
    many packages. There will certainly be classes and methods, fields in those that
    are used inside the library by other classes from different packages, but classes
    that are not to be used by the code outside the library. Making them anything
    less visible than `public` will render them unusable inside the library. Making
    them `public` will make them visible from outside.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，Java 中有四个访问级别。一个方法或字段可以是 `private`、`protected`、`public` 或 `default`（也称为包私有），如果没有提供修饰符。当你开发一个要在多个项目中使用的复杂库时，该库本身将包含许多包中的许多类。肯定会有一些类和方法、字段，这些是在库内部由来自不同包的其他类使用的，但不是要由库外部的代码使用的。使它们比
    `public` 更不可见将使它们在库内部不可用。使它们 `public` 将使它们对外可见。
- en: In our code, the Maven module `quick` compiled to a JAR can only be used if
    the method sort can invoke `qsort`. But, we do not want `qsort` to be used directly
    from outside. In the next version, we may want to develop a version of the sort
    that uses `qsort` from the `NonRecursiveQuickSort` class and we do not want complaining
    customers whose code does not compile or work because of a minor library upgrade.
    We can document that the internal methods and classes are still public but not
    for use, but in vain. Developers using our library do not read documentation.
    This is also why we do not write excessive comments. Nobody will read it, not
    even the processor executing the code.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，编译成 JAR 的 Maven 模块 `quick` 只能在方法 `sort` 可以调用 `qsort` 的情况下使用。但是，我们不希望
    `qsort` 被直接从外部使用。在下一个版本中，我们可能希望开发一个使用 `NonRecursiveQuickSort` 类中的 `qsort` 的排序版本，我们不希望因为库的微小升级而导致客户代码无法编译或工作而抱怨。我们可以记录内部方法和类仍然是公共的，但不建议使用，但这是徒劳的。使用我们库的开发者不会阅读文档。这也是我们不写过多注释的原因。没有人会阅读它，甚至执行代码的处理程序也不会。
- en: The most well-known and infamous example of this problem is the `sun.misc.Unsafe`
    class in the JDK. There is some really unsafe code in it, as the name implies.
    You can access memory out of heap, create objects without initialization, and
    so on. You should not. Why bother? You are a well-behaving developer and you just
    stick to the rules and you do not use that package. Whenever it changes in a new
    version of the JDK, your program is safe using only public and well-documented
    JDK API. Right?
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的最著名且臭名昭著的例子是 JDK 中的 `sun.misc.Unsafe` 类。正如其名所示，其中包含了一些非常不安全的代码。你可以访问堆外的内存，创建未初始化的对象等等。你不应该这样做。为什么费这个劲？你是一个行为良好的开发者，你只是遵守规则，不使用那个包。每当
    JDK 的新版本中有所改变，你的程序只使用公共和良好文档化的 JDK API，程序就是安全的，对吧？
- en: Wrong! Without being aware of this, you may use some libraries that depend on
    other libraries that use the package. Mockito and Spring Framework are only two
    of the numerous in danger. In addition, Java 9 will definitely come with a new
    version of this package. However, it will also come with module handling. While
    Java 9 will provide some useful API for the libraries that were using the `Unsafe`
    package because there was no provided API for the functionality they needed, it
    will deliver modules not to recreate the same problem again.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 错误！没有意识到这一点，你可能会使用一些依赖其他库的库，而这些库又使用了这个包。Mockito 和 Spring 框架只是众多处于危险中的库中的两个。此外，Java
    9 一定会带来这个包的新版本。然而，它也会带来模块处理。虽然 Java 9 将为使用 `Unsafe` 包的库提供一些有用的 API，因为这些库没有提供它们需要的功能，但它将提供模块来避免再次出现同样的问题。
- en: What is a Java module
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 Java 模块
- en: A Java module is a collection of classes in a JAR or in a directory that also
    contain a special class named `module-info`. If there is this file in a JAR or
    directory then it is a module, otherwise it is just a collection of classes that
    are on the `classpath` (or not). Java 8, and the earlier versions, will just ignore
    that class as it is never used as code. This way, using older Java, causes no
    harm and backward compatibility is maintained.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: Java 模块是一组类，这些类在一个 JAR 文件或目录中，同时包含一个名为 `module-info` 的特殊类。如果在 JAR 文件或目录中存在这个文件，那么它就是一个模块，否则它只是一个位于
    `classpath`（或不在）上的类的集合。Java 8 及更早的版本将忽略这个类，因为它永远不会被用作代码。这样，使用较旧的 Java 不会造成伤害，并且保持了向下兼容性。
- en: The module information defines what the module exports and what it requires.
    It has a special format. For example, we can place `module-info.java` in our `SortInterface`
    Maven module.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 模块信息定义了模块导出什么以及它需要什么。它有一个特殊的格式。例如，我们可以将 `module-info.java` 放入我们的 `SortInterface`
    Maven 模块中。
- en: '[PRE55]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This means that any class, which is `public` and inside the `packt.java9.by.example.ch03`
    package, can be used from outside. This package is exported from the module, but
    other classes from other packages are not visible from outside of the module even
    if they are `public`. The name of the module is same as the package, but this
    is mere convention in case there is only one package exported. The requirement
    is the same as in the case of packages: there should be a name that is not likely
    to collide with other module names. The reversed domain name is a good choice
    but it is not a must as you can see in this book. There is no top-level domain
    `packt`, yet.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着任何 `public` 类，位于 `packt.java9.by.example.ch03` 包内，都可以从外部使用。此包由模块导出，但来自其他包的其他类即使在它们是
    `public` 的情况下，也无法从模块外部可见。模块的名称与包的名称相同，但这仅是一种惯例，以防只有一个包被导出。要求与包的情况相同：应该有一个不太可能与其他模块名称冲突的名称。反向域名是一个不错的选择，但并非必须，正如你在本书中看到的那样。目前还没有顶级域名
    `packt`。
- en: We should also configure the parent POM to ensure that the compiler we use is
    Java 9,
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该配置父 POM，以确保我们使用的编译器是 Java 9，
- en: '[PRE56]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Older versions would be confused with the `module-info.java` file. (By the way,
    even the early access version of Java 9 I use for this book sometimes gives a
    hard time.)
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 旧版本可能会与 `module-info.java` 文件混淆。（顺便说一句，即使是这本书中使用的 Java 9 的早期访问版本有时也会给我带来麻烦。）
- en: 'We also create a `module-info.java` file in the Maven module, `quick`, which
    is as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在 Maven 模块 `quick` 中创建了一个 `module-info.java` 文件，内容如下：
- en: '[PRE57]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This module exports another package and requires the `packt.java9.by.example.ch03`
    module that we have just created. Now, we can compile the modules and the created
    JARs in the`./quick/target` and `./SortInterface/target` directories are now Java
    9 modules.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块导出另一个包，并需要我们刚刚创建的 `packt.java9.by.example.ch03` 模块。现在，我们可以编译模块和创建的 JAR 文件，位于
    `./quick/target` 和 `./SortInterface/target` 目录中的现在都是 Java 9 模块。
- en: 'As Maven does not fully support the modules yet, when I issue the `mvn install`
    command, I get the following error message:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Maven 尚未完全支持模块，当我发出 `mvn install` 命令时，我得到了以下错误信息：
- en: '`[ERROR] .../genericsort/quick/src/main/java/module-info.java:[3,40] module
    not found: packt.java9.by.example.ch03`'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`[ERROR] .../genericsort/quick/src/main/java/module-info.java:[3,40] 模块未找到：packt.java9.by.example.ch03`'
- en: Maven puts the compiled modules on `classpath`, but Java 9 seeks `modulepath`
    for modules. Maven does not handle `modulepath` yet. To hack `modulepath` to the
    compiler, we will have to add the following configuration lines to the parent
    POM to the `configuration` of the compiler plugin:`<compilerArgs>`
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 将编译的模块放在 `classpath` 上，但 Java 9 寻找 `modulepath` 以查找模块。Maven 尚未处理 `modulepath`。为了将
    `modulepath` 欺骗到编译器中，我们必须向父 POM 的编译器插件的 `configuration` 中添加以下配置行：`<compilerArgs>`
- en: '`<arg>-modulepath</arg>`'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`<arg>-modulepath</arg>`'
- en: '`<arg>${project.parent.basedir}/SortInterface/target/SortInterface-1.0.0-SNAPSHOT.jar:
    ...</arg>`'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`<arg>${project.parent.basedir}/SortInterface/target/SortInterface-1.0.0-SNAPSHOT.jar:
    ...</arg>`'
- en: '`</compilerArgs>`'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`</compilerArgs>`'
- en: The actual file should list all the colon separated JAR files that Maven generates,
    and on which some of the modules depend. These are the `SortInterface`, `quick`,
    and `SortSupportClasses`.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的文件应列出所有由 Maven 生成的以冒号分隔的 JAR 文件，以及一些模块所依赖的文件。这些是 `SortInterface`、`quick`
    和 `SortSupportClasses`。
- en: 'To test the functionality of module support, we will create another Maven module
    called `Main`. It has only one class, called `Main`, with a `public static void
    main` method:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试模块支持的功能，我们将创建另一个名为 `Main` 的 Maven 模块。它只有一个名为 `Main` 的类，其中包含一个 `public static
    void main` 方法：
- en: '[PRE58]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: It takes the first argument (without checking that there is one, which we should
    not use in a production code) and uses that as a file name. Then, it reads the
    lines of the file into a `String` array, sorts it, and prints it to the standard
    output.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受第一个参数（不检查是否存在一个，我们不应该在生产代码中使用它）并将其用作文件名。然后，它将文件的行读入一个 `String` 数组中，对其进行排序，并将其打印到标准输出。
- en: As the module support only works for modules, this Maven module also has to
    be a Java module and have a `module-info.java` file.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模块支持仅适用于模块，因此此 Maven 模块也必须是一个 Java 模块，并有一个 `module-info.java` 文件。
- en: '[PRE59]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Additionally, we will have to create a `module-info.java` file for the support
    module; otherwise, we will not be able to use it from our module.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要为支持模块创建一个 `module-info.java` 文件；否则，我们将无法从我们的模块中使用它。
- en: After compiling the modules using `mvn install`, we can run it to print out
    the parent POM.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `mvn install` 编译模块后，我们可以运行它以打印出父 POM。
- en: '[PRE60]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note that this is one line of command that print breaks into several lines.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这是一条命令行，它将输出内容分成多行。
- en: 'Now, if we try to access `Qsort` directly inserting the following line `Qsort<String>
    qsort = new Qsort<>(String::compareTo,new ArraySwapper<>(lineArray));` into the
    `main` method, Maven will complain because the module system hides it from our
    `Main` class:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试直接在 `main` 方法中插入以下行 `Qsort<String> qsort = new Qsort<>(String::compareTo,new
    ArraySwapper<>(lineArray));` 来访问 `Qsort`，Maven 将会抱怨，因为模块系统将其隐藏在我们的 `Main` 类中：
- en: '[PRE61]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The module system also supports the `java.util.ServiceLoader` based class-loading
    mechanism, which we will not discuss in this book. This is an old technology that
    is rarely used in an enterprise environment when Spring, Guice, or some other
    dependency injection framework is used. If you see a `module-info.java` file that
    contains the `uses` and `provides` keywords, then first consult with the Java
    documentation about the `ServiceLoader` class at [http://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html](http://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html),
    and then the Java 9 language documentation on module support ([http://openjdk.java.net/projects/jigsaw/quick-start](http://openjdk.java.net/projects/jigsaw/quick-start)).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 模块系统还支持基于 `java.util.ServiceLoader` 的类加载机制，我们在这本书中不会讨论这个机制。这是一个旧技术，在企业环境中当使用
    Spring、Guice 或其他依赖注入框架时很少使用。如果你看到一个包含 `uses` 和 `provides` 关键字的 `module-info.java`
    文件，那么首先查阅关于 [ServiceLoader 类](http://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html)
    的 Java 文档，然后查阅 Java 9 语言文档中的模块支持部分 ([http://openjdk.java.net/projects/jigsaw/quick-start](http://openjdk.java.net/projects/jigsaw/quick-start))。
- en: Summary
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we developed a general sorting algorithm implementing quick
    sort. We modified our project to be a multi-module Maven project and also to use
    Java module definitions. We were using JUnit to develop unit tests, and we developed
    the code using TDD. We converted the code from old style Java to new using generics,
    and we used exception handling. These are the basic tools that are needed for
    the coming chapters, where we will develop a guessing game. First we will develop
    a simpler version and in the subsequent chapter we will develop a version that
    uses parallel computing, and multiple proccessors.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开发了一个通用的排序算法，实现了快速排序。我们将我们的项目修改为多模块 Maven 项目，并使用 Java 模块定义。我们使用 JUnit
    开发单元测试，并使用 TDD 开发代码。我们将代码从旧式 Java 转换为新式，使用了泛型，并使用了异常处理。这些是接下来章节所需的基本工具，在这些章节中，我们将开发一个猜谜游戏。首先，我们将开发一个更简单的版本，然后在下一章中，我们将开发一个使用并行计算和多个处理器的版本。
