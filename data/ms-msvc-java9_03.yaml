- en: Domain-Driven Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域驱动设计
- en: This chapter sets the tone for the rest of the chapters by referring to one
    sample project. The sample project will be used to explain different microservices
    concepts from here onward. This chapter uses this sample project to drive through
    different combinations of functional and domain services, or applications to explain
    **domain-driven design** (**DDD**). It will help you to learn the fundamentals
    of DDD and its practical usage. You will also learn the concepts of designing
    domain models using REST services.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过参考一个样本项目来为接下来的章节定调。样本项目将被用来解释不同微服务概念。本章将通过这个样本项目来驱动不同的功能和领域服务或应用程序的组合，以解释
    **领域驱动设计**（**DDD**）。它将帮助你了解 DDD 的基础知识及实际应用。你还将学习使用 REST 服务设计领域模型的概念。
- en: 'This chapter covers the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Fundamentals of DDD
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DDD 的基础知识
- en: How to design an application using DDD
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 DDD 设计应用程序
- en: Domain models
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域模型
- en: A sample domain model design based on DDD
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 DDD 的样本领域模型设计
- en: A good software design is as much the key to the success of a product or services
    as the functionalities offered by it. It carries equal weight to the success of
    product; for example, `Amazon.com` provides the shopping platform, but its architecture
    design makes it different from other similar sites and contributes to its success.
    It shows how important a software or architecture design is for the success of
    a product/service. DDD is one of the software design practices, and we'll explore
    it with various theories and practical examples.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一个良好的软件设计对于产品或服务的成功同样重要。它与产品的功能一样重要。例如，`Amazon.com` 提供购物平台，但其架构设计使其与其他类似站点有所不同，并促成了它的成功。这显示了软件或架构设计对产品/服务成功的重要性。DDD
    是软件设计实践之一，我们将通过各种理论和实际示例来探讨它。
- en: DDD is a key design practice that helps to design the microservices of the product
    that you are developing. Therefore, we'll first explore DDD before jumping into
    microservices development. After studying this chapter, you will understand the
    importance of DDD for microservices development.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: DDD 是一个关键的设计实践，有助于设计正在开发的产品的微服务。因此，在深入微服务开发之前，我们将首先探讨 DDD。在学习本章之后，你将了解 DDD 对于微服务开发的重要性。
- en: Domain-driven design fundamentals
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域驱动设计基础知识
- en: An enterprise, or cloud application, solves business problems and other real-world
    problems. These problems cannot be resolved without knowledge of the domain. For
    example, you cannot provide a software solution for a financial system such as
    online stock trading if you don't understand the stock exchanges and their functioning.
    Therefore, having domain knowledge is a must for solving problems. Now, if you
    want to offer a solution using software or applications, you need to design it
    with the help of domain knowledge. When we combine the domain and software design,
    it offers a software design methodology known as DDD.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 企业或云应用程序解决业务问题和其他现实世界的问题。如果没有对领域的了解，这些问题是无法解决的。例如，如果你不了解股票交易所及其运作方式，就无法为在线股票交易等金融系统提供软件解决方案。因此，具备领域知识对于解决问题是必不可少的。现在，如果你想通过软件或应用程序提供解决方案，就需要借助领域知识进行设计。当我们将领域和软件设计结合起来时，就会提供一种被称为
    DDD 的软件设计方法论。
- en: When we develop software to implement real-world scenarios offering the functionalities
    of a domain, we create a model of the domain. A **model** is an abstraction, or
    a blueprint, of the domain.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开发软件来实现真实世界的场景，提供领域的功能时，我们就会创建一个领域的模型。一个**模型**是对领域的抽象或蓝图。
- en: 'Eric Evans coined the term DDD in his book *Domain-Driven Design: Tackling
    Complexity in the Heart of Software*, published in 2004.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 埃里克·埃文斯在他于2004年出版的书《领域驱动设计：攻克软件内在的复杂性》中创造了 DDD 这个词汇。
- en: Designing this model is not rocket science, but it does take a lot of effort,
    refining, and input from domain experts. It is the collective job of software
    designers, domain experts, and developers. They organize information, divide it
    into smaller parts, group them logically, and create modules. Each module can
    be taken up individually, and can be divided using a similar approach. This process
    can be followed until we reach the unit level, or when we cannot divide it any
    further. A complex project may have more of such iterations; similarly, a simple
    project could have just a single iteration of it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 设计这个模型并不是火箭科学，但它确实需要大量的努力、精炼和领域专家的投入。这是软件设计师、领域专家和开发人员共同的工作。他们组织信息，将其分成更小的部分，逻辑上进行分组，并创建模块。每个模块可以单独处理，可以使用类似的方法进行划分。这个过程可以一直持续到达到单元级别，或者无法再进行划分为止。一个复杂的项目可能会有更多的此类迭代；同样，一个简单的项目可能只会有此类迭代的单个实例。
- en: Once a model is defined and well documented, it can move onto the next stage
    - code design. So, here we have a **software design**—a domain model and code
    design, and code implementation of the domain model. The domain model provides
    a high level of the architecture of a solution (software/application), and the
    code implementation gives the domain model a life, as a working model.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦模型被定义并且文档齐全，它就可以进入下一阶段——代码设计。所以，我们这里有一个**软件设计**——领域模型和代码设计，以及领域模型的代码实现。领域模型提供了一个解决方案（软件/应用程序）的高级架构，而代码实现使领域模型成为一个活生生的模型。
- en: DDD makes design and development work together. It provides the ability to develop
    software continuously, while keeping the design up to date based on feedback received
    from the development. It solves one of the limitations offered by Agile and Waterfall
    methodologies, making software maintainable, including design and code, as well
    as keeping application minimum viable.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 领域驱动设计使设计和开发工作相结合。它提供了一种连续开发软件的能力，同时根据从开发过程中收到的反馈来更新设计。它解决了敏捷和瀑布方法论所提供的限制之一，使软件可维护，包括设计和代码，并保持应用程序的最小可行性。
- en: Design-driven development involves a developer from the initial stage, and all
    meetings where software designers discuss the domain with domain experts in the
    modeling process. It gives developers the right platform to understand the domain,
    and provides the opportunity to share early feedback of the domain model implementation.
    It removes the bottleneck that appears in later stages when stockholders wait
    for deliverables.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以设计为驱动的开发方式让开发者从项目初期就参与其中，所有软件设计师与领域专家在建模过程中讨论领域的会议都会涉及到。这种方式为开发者提供了一个理解领域的正确平台，并且提供了分享领域模型实现早期反馈的机会。它消除了在后期阶段，当各方等待可交付成果时出现的瓶颈问题。
- en: Fundamentals of DDD
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域驱动设计的基础知识
- en: 'To understand domain-driven design, we can broadly categorize these three concepts:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解领域驱动设计，我们可以将这些三个概念广泛地归类为：
- en: Ubiquitous language and unified model language (UML)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用语言和统一建模语言（UML）
- en: Multilayer architecture
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多层架构
- en: Artifacts (components)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工件（组件）
- en: The following sections explain the usage and importance of ubiquitous language
    and multilayer architecture. There will also be an explanation of the different
    artifacts to be used in the model-driven design.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将解释通用语言和多层架构的使用和重要性。还将解释在模型驱动设计中要使用的不同工件（组件）。
- en: Ubiquitous language
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用语言
- en: '**Ubiquitous language** is a common language to communicate within a project.
    As we have seen, designing a model is the collective effort of software designers,
    domain experts, and developers; therefore, it requires a common language to communicate
    with. DDD makes it necessary to use ubiquitous language. Domain models use ubiquitous
    language in their diagrams, descriptions, presentations, speeches, and meetings.
    It removes the misunderstanding, misinterpretation, and communication gap among
    them. Therefore, it must be included in all diagrams, description, presentations,
    meetings, and so on—in short, in everything.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**通用语言**是在项目中进行沟通的共同语言。正如我们所见，设计模型是软件设计师、领域专家和开发人员的共同努力；因此，它需要一种共同的语言来进行沟通。领域驱动设计使得使用通用语言成为必要。领域模型在其图表、描述、演示、演讲和会议中使用通用语言。它消除了他们之间的误解、误解释和沟通障碍。因此，它必须包括所有图表、描述、演示、会议等——简而言之，包括所有内容。'
- en: '**Unified Modeling Language** (**UML**) is widely used and very popular when
    creating models. It also has a few limitations; for example, when you have thousands
    of classes drawn from a paper, it''s difficult to represent class relationships
    and simultaneously understand their abstraction while taking a meaning from it.
    Also, UML diagrams do not represent the concepts of a model and what objects are
    supposed to do. Therefore, UML should always be used with other documents, code,
    or any other reference for effective communication.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**统一建模语言**（**UML**）在创建模型时被广泛使用并且非常受欢迎。它也存在一些局限性；例如，当你从一张纸上画出成千上万的类时，很难表示类之间的关系，同时在理解它们的抽象并从中获取意义。此外，UML图并不能表示模型的概念以及对象应该做什么。因此，UML总是应该与其他文档、代码或其他参考资料一起使用，以便有效沟通。'
- en: Other ways to communicate the domain model include the use of documents, code,
    and so on.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 传达领域模型的其他方式包括使用文档、代码等。
- en: Multilayered architecture
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多层架构
- en: 'Multilayered architecture is a common solution for DDD. It contains four layers:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 多层架构是DDD的常见解决方案。它包含四个层次：
- en: Presentation layer or **User Interface** (**UI**).
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展示层或**用户界面**（**UI**）。
- en: Application layer.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用层。
- en: Domain layer.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 领域层。
- en: Infrastructure layer.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基础设施层。
- en: '![](img/eb42878f-3e3d-4baa-a278-53c9d626d2d3.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb42878f-3e3d-4baa-a278-53c9d626d2d3.jpg)'
- en: Layered architecture
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 分层架构
- en: You can see here that only the **Domain** layer is responsible for the domain
    model, and others are related to other components such as UI, application logic,
    and so on. This layered architecture is very important. It keeps domain-related
    code separate from other layers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里可以看出，只有**领域**层负责领域模型，其他层与UI、应用逻辑等组件有关。这种分层架构非常重要。它将领域相关代码与其他层分开。
- en: In this multilayered architecture, each layer contains its respective code,
    and it helps to achieve loose coupling and avoids mixing code from different layers.
    It also helps the product/service's long-term maintainability and the ease of
    enhancements, as the change of one-layer code does not impact on other components
    if the change is intended for the respective layer only. Each layer can be switched
    with another implementation easily with multi-tier architecture.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种多层架构中，每一层都包含相应的代码，它有助于实现松耦合，并避免不同层代码的混合。它还有助于产品/服务的长期可维护性和易于增强，因为如果改变仅针对相应层，则一层代码的变化不会影响其他组件。在多层架构中，每一层都可以容易地与其他实现交换。
- en: Presentation layer
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展示层
- en: This layer represents the UI, and provides the user interface for the interaction
    and information display. This layer could be a web application, mobile application,
    or a third-party application consuming your services.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这一层代表了用户界面（UI），并为交互和信息展示提供用户界面。这一层可能是一个网络应用、移动应用，或者是消耗你服务的第三方应用。
- en: Application layer
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用层
- en: This layer is responsible for application logic. It maintains and coordinates
    the overall flow of the product/service. It does not contain business logic or
    UI. It may hold the state of application objects, like tasks in progress. For
    example, your product **REST services** would be part of this application layer.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这一层负责应用逻辑。它维护和协调产品/服务的整体流程。它不包含业务逻辑或UI。它可能持有应用对象的状态，如进行中的任务。例如，你的产品**REST服务**将是这一应用层的一部分。
- en: Domain layer
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域层
- en: The domain layer is a very important layer, as it contains the domain information
    and business logic. It holds the state of the business object. It persists the
    state of the business objects, and communicates these persisted states to the
    infrastructure layer.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 领域层是一个非常重要的层，因为它包含领域信息和业务逻辑。它持有业务对象的状态。它持久化业务对象的状态，并将这些持久化的状态传达给基础设施层。
- en: Infrastructure layer
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设施层
- en: This layer provides support to all the other layers and is responsible for communication
    among the other layers. It contains the supporting libraries that are used by
    the other layers. It also implements the persistence of business objects.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这一层为其他所有层提供支持，负责层与层之间的通信。它包含了其他层使用的支持库。它还实现了业务对象的持久化。
- en: To understand the interaction of the different layers, let us use an example
    of table booking at a restaurant. The end user places a request for a table booking
    using UI. The UI passes the request to the application layer. The application
    layer fetches the domain objects, such as the restaurant, the table, a date, and
    so on, from the domain layer. The domain layer fetches these existing persisted
    objects from the infrastructure, and invokes relevant methods to make the booking
    and persist them back to the infrastructure layer. Once domain objects are persisted,
    the application layer shows the booking confirmation to the end user.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解不同层次之间的交互，让我们以餐厅订桌为例。最终用户通过用户界面（UI）提交订桌请求。UI将请求传递给应用层。应用层从领域层获取餐厅、餐桌、日期等域对象。领域层从基础设施层获取这些已持久化的对象，并调用相关方法进行订桌并将其持久化回基础设施层。一旦领域对象被持久化，应用层就会向最终用户显示预订确认信息。
- en: Artifacts of domain-driven design
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域驱动设计工件（Artifacts of domain-driven design）
- en: 'There are seven different artifacts used in DDD to express, create, and retrieve
    domain models:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 领域驱动设计中有七个不同的工具有助于表达、创建和检索领域模型：
- en: Entities
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体（Entities）
- en: Value objects
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值对象（Value objects）
- en: Services
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务（Services）
- en: Aggregates
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合（Aggregates）
- en: Repository
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓库（Repository）
- en: Factory
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂（Factory）
- en: Module
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块（Module）
- en: Entities
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体（Entities）
- en: Entities are certain types of objects that are identifiable and remain the same
    throughout the states of the products/services. These objects are not identified
    by their attributes, but by their identity and thread of continuity. These type
    of objects are known as **entities**.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 实体（Entities）是能够被识别并在产品/服务状态变化中保持不变的一类对象。这些对象不是通过属性来识别，而是通过其身份和持续性线索来识别。这类对象被称为**实体**。
- en: It sounds pretty simple, but it carries complexity. You need to understand how
    we can define the entities. Let's take an example of a table booking system, where
    we have a `restaurant` class with attributes such as restaurant name, address,
    phone number, establishment data, and so on. We can take two instances of the
    `restaurant` class that are not identifiable using the restaurant name, as there
    could be other restaurants with the same name. Similarly, if we go by any other
    single attribute, we will not find any attributes that can singularly identify
    a unique restaurant. If two restaurants have all the same attribute values, they
    are therefore the same and are interchangeable with each other. Still, they are
    not the same entities, as both have different references (memory addresses).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来很简单，但它包含了复杂性。我们需要理解我们如何定义实体。让我们以一个订桌系统为例，其中有一个`restaurant`类，具有餐厅名称、地址、电话号码、成立日期等属性。我们可以取`restaurant`类的两个实例，它们不能通过餐厅名称来识别，因为可能有其他拥有相同名称的餐厅。同样，如果我们根据任何其他单一属性来识别，我们也找不到可以单独识别唯一餐厅的属性。如果两个餐厅具有所有相同的属性值，它们因此相同，并且可以相互替换。然而，它们并不是相同的实体，因为两者具有不同的引用（内存地址）。
- en: Conversely, let's take a class of US citizens. Each citizen has his or her own
    social security number. This number is not only unique, but remains unchanged
    throughout the life of the citizen and assures continuity. This `citizen` object
    would exist in the memory, would be serialized, and would be removed from the
    memory and stored in the database. It even exists after the person is deceased.
    It will be kept in the system for as long as the system exists. A citizen's social
    security number remains the same irrespective of its representation.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，让我们考虑一组美国公民。每个公民都有自己的社会安全号码。这个号码不仅是唯一的，而且在其公民的一生中保持不变，并确保连续性。这个`citizen`对象将存在于内存中，将被序列化，并将从内存中移除并存储在数据库中。即使人死后，它仍然存在。只要系统存在，它就会在系统中保持。公民的社会安全号码与其表示形式无关，保持不变。
- en: Therefore, creating entities in a product means creating an **identity**. So,
    now give an identity to any restaurant in the previous example, then either use
    a combination of attributes such as restaurant name, establishment date, and street,
    or add an identifier such as `restaurant_id` to identify it. The basic rule is
    that two identifiers cannot be the same. Therefore, when we introduce an identifier
    for an entity, we need to be sure of it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在产品中创建实体意味着创建一个**身份**。现在给前例中的任何餐厅一个身份，然后使用诸如餐厅名称、成立日期和街道等属性的组合来识别它，或者添加一个标识符如`restaurant_id`来识别它。基本规则是两个标识符不能相同。因此，当我们为实体引入一个标识符时，我们需要确切知道它。
- en: 'There are different ways to create a unique identity for objects, described
    as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为对象创建唯一身份有多种方法，如下所述：
- en: Using the **primary key** in a table.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用表中的**主键**。
- en: Using an **automated generated ID** by a domain module. A domain program generates
    the identifier and assigns it to objects that are being persisted among different
    layers.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用领域模块生成的**自动生成ID**。领域程序生成标识符并将其分配给在不同层次之间被持久化的对象。
- en: A few real-life objects carry **user-defined identifiers** themselves. For example,
    each country has its own country codes for dialing ISD calls.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些现实生活中的对象本身携带**用户定义的标识符**。例如，每个国家都有它自己的国际直拨电话代码。
- en: '**Composite key.** This is a combination of attributes that can also be used
    for creating an identifier, as explained for the preceding `restaurant` object.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复合键**。这是可以用于创建标识符的一组属性，正如前面所述的`restaurant`对象。'
- en: '*Entities are very important for domain models. Therefore, they should be defined
    from the initial stage of the modeling process*.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 实体对于领域模型非常重要，因此，它们应该从建模过程的初始阶段开始定义。
- en: When an object can be identified by its identifier and not by its attributes,
    a class representing these objects should have a simple definition, and care should
    be taken with the life cycle continuity and identity. It's imperative to identify
    objects in this class that have the same attribute values. A defined system should
    return a unique result for each object if queried. Designers should ensure that
    the model defines what it means to be the same thing.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个对象可以通过其标识符而不是属性来识别时，代表这些对象的类应该有一个简单的定义，并且要小心生命周期连续性和身份。务必识别具有相同属性值的此类对象。定义良好的系统应对每个对象查询返回唯一结果。设计师应确保模型定义什么是同一事物。
- en: Value objects
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值对象
- en: '**Value objects (VOs)** simplify the design. Entities have traits such as identity,
    a thread of continuity, and attributes that do not define their identity. In contrast
    to entities, value objects have only attributes and no conceptual identity. A
    best practice is to keep value objects as immutable objects. If possible, you
    should even keep entity objects immutable too.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**值对象（VOs）**简化了设计。实体具有诸如身份、生命周期连续性以及不定义其身份的属性等特征。与实体相反，值对象只有属性，没有概念上的身份。最佳实践是将值对象保持为不可变对象。如果可能，实体对象也应该保持不可变。'
- en: Entity concepts may bias you to keep all objects as entities, as a uniquely
    identifiable object in the memory or database with life cycle continuity, but
    there has to be one instance for each object. Now, let's say you are creating
    customers as entity objects. Each customer object would represent the restaurant
    guest, and this cannot be used for booking orders for other guests. This may create
    millions of customer entity objects in the memory if millions of customers are
    using the system. Not only are there millions of uniquely identifiable objects
    that exist in the system, but each object is being tracked. Tracking as well as
    creating an identity is complex. A highly credible system is required to create
    and track these objects, which is not only very complex, but also resource heavy.
    It may result in system performance degradation. Therefore, it is important to
    use value objects instead of using entities. The reasons are explained in the
    next few paragraphs.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 实体概念可能会让你倾向于将所有对象都当作实体来处理，即在内存或数据库中具有生命周期连续性和唯一可识别性的对象，但每个对象必须有一个实例。现在，假设你在创建客户实体对象。每个客户对象将代表餐厅的客人，这不能用于为其他客人预订订单。如果系统中有百万客户，可能会在内存中创建数百万客户实体对象。系统中不仅存在数百万个唯一可识别的对象，而且每个对象都在被跟踪。跟踪以及创建身份都是复杂的。需要一个高度可信的系统来创建和跟踪这些对象，这不仅非常复杂，而且资源消耗大。这可能会导致系统性能下降。因此，使用值对象而不是实体对象是很重要的。接下来的几段将解释原因。
- en: Applications don't always need to have to be trackable and have an identifiable
    customer object. There are cases when you just need to have some or all attributes
    of the domain element. These are the cases when value objects can be used by the
    application. It makes things simple and improves the performance.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序并不总是需要可追踪和可识别的客户对象。有时只需某些或所有领域元素的属性。在这些情况下，应用程序可以使用值对象。这使事情变得简单并提高了性能。
- en: Value objects can easily be created and destroyed, owing to the absence of identity.
    This simplifies the design—it makes value objects available for garbage collection
    if no other object has referenced them.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于价值对象没有身份，所以可以很容易地创建和销毁，这简化了设计——如果没有任何其他对象引用它们，价值对象就可以被垃圾回收。
- en: Let's discuss the value object's immutability. Value objects should be designed
    and coded as immutable. Once they are created, they should never be modified during
    their life-cycle. If you need a different value of the VO, or any of its objects,
    then simply create a new value object, but don't modify the original value object.
    Here, immutability carries all the significance from **object-oriented programming**
    (**OOP**). A value object can be shared and used without impacting on its integrity
    if, and only if, it is immutable.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下价值对象的不可变性。应该设计并编写价值对象为不可变的。一旦它们被创建，在其生命周期内不应该被修改。如果你需要不同价值的VO，或其任何对象，那么简单地创建一个新的价值对象，但不要修改原来的价值对象。在这里，不可变性继承了**面向对象编程**（**OOP**）的所有重要性。如果一个价值对象是不可变的，那么它可以在不破坏其完整性的情况下被共享和使用。
- en: FAQs
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题解答 (FAQs)
- en: Can a value object contain another value object?
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 价值对象可以包含另一个价值对象吗？
- en: Yes, it can
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是的，可以 (Yes, it can)
- en: Can a value object refer to another value object or entity?
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 价值对象可以引用另一个价值对象或实体吗？
- en: Yes, it can
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是的，可以 (Yes, it can)
- en: Can I create a value object using the attributes of different value objects
    or entities?
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我可以用不同价值对象或实体的属性创建一个价值对象吗？
- en: Yes, you can
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是的，你可以 (Yes, you can)
- en: Services
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务 (Services)
- en: While creating the domain model, you may encounter various situations where
    behavior may not be related to any object specifically. These behaviors can be
    accommodated in **service objects**.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建领域模型的过程中，你可能会遇到各种情况，其中行为可能与任何特定对象无关。这些行为可以容纳在**服务对象**中。
- en: Service objects are part of domain layer that does not have any internal state.
    The sole purpose of service objects is to provide behavior to the domain that
    does not belong to a single entity or value object.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 服务对象是领域层的一部分，没有内部状态。服务对象的唯一目的是向领域提供不属于单一实体或价值对象的行为。
- en: Ubiquitous language helps you to identify different objects, identities, or
    value objects with different attributes and behaviors during the process of domain
    modeling. During the course of creating the domain model, you may find different
    behaviors or methods that do not belong to any specific object. Such behaviors
    are important, and so cannot be neglected. Neither can you add them to entities
    or value objects. It would spoil the object to add behavior that does not belong
    to it. Keep in mind, that behavior may impact on various objects. The use of object-oriented
    programming makes it possible to attach to some objects; this is known as a **service**.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通用语言能帮助你在领域建模的过程中识别不同的对象、身份或价值对象，以及它们不同的属性和行为。在创建领域模型的过程中，你可能会发现不同的行为或方法不属于任何一个特定的对象。这些行为很重要，因此不能忽视。你也不能把它们添加到实体或价值对象中。给一个对象添加不属于它的行为会破坏这个对象。要记住，这种行为可能会影响各种对象。面向对象编程的使用使得能够将行为附加到一些对象上，这被称为**服务**。
- en: Services are common in technical frameworks. These are also used in domain layers
    in DDD. A service object does not have any internal state; the only purpose of
    it is to provide a behavior to the domain. Service objects provide behaviors that
    cannot be related to specific entities or value objects. Service objects may provide
    one or more related behaviors to one or more entities or value objects. It is
    a practice to define the services explicitly in the domain model.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 技术框架中常见服务。在 DDD 中，它们也用于领域层。服务对象没有内部状态；它的唯一目的是向领域提供行为。服务对象提供的行为不能与特定的实体或价值对象相关联。服务对象可能为一个或多个相关实体或价值对象提供一种或多种行为。在领域模型中明确定义服务是一种实践。
- en: 'While creating the services, you need to tick all of the following points:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建服务时，你需要勾选以下所有要点：
- en: Service objects' behavior performs on entities and value objects, but it does
    not belong to entities or value objects
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务对象的行为对实体和价值对象进行操作，但不属于实体或价值对象。
- en: Service objects' behavior state is not maintained, and hence, they are stateless
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务对象的行为状态不被维护，因此它们是无状态的 (Stateless)
- en: Services are part of the domain model
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务是领域模型的一部分
- en: Services may also exist in other layers. It is very important to keep domain-layer
    services isolated. It removes the complexities and keeps the design decoupled.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 服务也可能存在于其他层中。保持领域层服务的隔离非常重要。它消除了复杂性，并使设计解耦。
- en: Let's take an example where a restaurant owner wants to see the report of his
    monthly table bookings. In this case, he will log in as an admin and click the
    **Display Report** button after providing the required input fields, such as duration.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，餐厅老板想要查看他每月的餐桌预订报告。在这种情况下，他需要以管理员身份登录，在提供必要的输入字段（如持续时间）后点击**显示报告**按钮。
- en: Application layers pass the request to the domain layer that owns the report
    and templates objects, with some parameters such as report ID, and so on. Reports
    get created using the template, and data is fetched from either the database or
    other sources. Then the application layer passes through all the parameters, including
    the report ID to the business layer. Here, a template needs to be fetched from
    the database or another source to generate the report based on the ID. This operation
    does not belong to either the report object or the template object. Therefore,
    a service object is used that performs this operation to retrieve the required
    template from the database.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层将请求传递给拥有报告和模板对象的领域层，传递一些参数，如报告ID等。使用模板创建报告，并从数据库或其他来源获取数据。然后应用层将所有参数（包括报告ID）传递给业务层。在这里，需要从数据库或另一个来源获取模板来根据ID生成报告。这个操作不属于报告对象或模板对象。因此，使用一个服务对象来执行这个操作，从数据库中获取所需的模板。
- en: Aggregates
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合
- en: Aggregate domain pattern is related to the object's life cycle, and defines
    ownership and boundaries.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合领域模式与对象的生命周期相关，定义了所有权和边界。
- en: When you reserve a table at your favorite restaurant online using an application,
    you don't need to worry about the internal system and process that takes place
    to book your reservation, including searching for available restaurants, then
    for available tables on the given date, time, and so on and so forth. Therefore,
    you can say that a reservation application is an **aggregate** of several other
    objects, and works as a **root** for all the other objects for a table reservation
    system.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当您通过应用程序在线预订您最喜欢的餐厅的餐桌时，您不需要担心内部系统发生的预订过程，包括搜索可用的餐厅，然后在给定日期、时间和等等上查找可用的餐桌。因此，您可以说预订应用程序是多个其他对象的**聚合**，并为餐桌预订系统中的所有其他对象充当**根**。
- en: This root should be an entity that binds collections of objects together. It
    is also called the **aggregate root**. This root object does not pass any reference
    of inside objects to external worlds, and protects the changes performed within
    internal objects.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个根实体应该是一个将对象集合绑在一起的实体，也称为**聚合根**。这个根对象不向外部世界传递内部对象的任何引用，并保护内部对象执行的更改。
- en: We need to understand why aggregators are required. A domain model can contain
    large numbers of domain objects. The bigger the application functionalities and
    size and the more complex its design, the greater number of objects present. A
    relationship exists between these objects. Some may have a many-to-many relationship,
    a few may have a one-to-many relationship, and others may have a one-to-one relationship.
    These relationships are enforced by the model implementation in the code, or in
    the database that ensures that these relationships among the objects are kept
    intact. Relationships are not just unidirectional; they can also be bidirectional.
    They can also increase in complexity.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要理解为什么需要聚合器。领域模型可能包含大量的领域对象。应用程序的功能和大小越大，设计越复杂，存在的对象数量就越多。这些对象之间存在关系。一些可能具有多对多关系，一些可能具有单对多关系，其他可能具有单对一关系。这些关系在代码中的模型实现或数据库中得到强制执行，确保对象之间的关系保持不变。这些关系不仅仅是单向的，也可能是双向的。它们还可以变得更加复杂。
- en: The designer's job is to simplify these relationships in the model. Some relationships
    may exist in a real domain, but may not be required in the domain model. Designers
    need to ensure that such relationships do not exist in the domain model. Similarly,
    multiplicity can be reduced by these constraints. One constraint may do the job
    where many objects satisfy the relationship. It is also possible that a bidirectional
    relationship could be converted into a unidirectional relationship.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 设计者的任务是简化模型中的这些关系。一些关系在现实领域中可能存在，但在领域模型中可能不需要。设计师需要确保领域模型中不存在此类关系。同样，通过这些约束可以减少多义性。一个约束可以完成许多对象满足关系的工作。也可能将双向关系转换为单向关系。
- en: No matter how much simplification you input, you may still end up with relationships
    in the model. These relationships need to be maintained in the code. When one
    object is removed, the code should remove all the references to this object from
    other places. For example, a record removal from one table needs to be addressed
    wherever it has references in the form of foreign keys and such, to keep the data
    consistent and maintain its integrity. Also, invariants (rules) need to be forced
    and maintained whenever data changes.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你输入多少简化，你最终可能还是会得到模型中的关系。这些关系需要在代码中维护。当一个对象被移除时，代码应该从其他地方删除对这个对象的所有引用。例如，从一个表中删除记录需要在它以外键等形式被引用的地方进行处理，以保持数据一致性并维护其完整性。另外，在数据变化时，需要强制执行不变量（规则）。
- en: Relationships, constraints, and invariants bring a complexity that requires
    an efficient handling in code. We find the solution by using the aggregate represented
    by the single entity known as the root**,** which is associated with the group
    of objects that maintains consistency with regards to data changes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 关系、约束和不变量带来了复杂性，需要在代码中有效地处理。我们通过使用由单一实体表示的聚合**根**来找到解决方案，这个实体与一组保持数据变化一致性的对象相关联。
- en: This root is the only object that is accessible from outside, so this root element
    works as a boundary gate that separates the internal objects from the external
    world. Roots can refer to one or more inside objects, and these inside objects
    can have references to other inside objects that may or may not have relationships
    with the root. However, outside objects can also refer to the root, and not to
    any inside objects.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个根元素是唯一可以从外部访问的对象，因此它充当了一个边界门，将内部对象与外部世界隔开。根可以引用一个或多个内部对象，而这些内部对象又可以引用其他可能有或没有与根的关系的内部对象。然而，外部对象也可以引用根，但不会引用任何内部对象。
- en: An aggregate ensures data integrity and enforces the invariant. Outside objects
    cannot make any change to inside objects; they can only change the root. However,
    they can use the root to make a change inside the object by calling exposed operations.
    The root should pass the value of inside objects to outside objects if required.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合确保数据完整性并强制执行不变量。外部对象不能对内部对象做任何更改；他们只能更改根。然而，他们可以通过调用公开操作，使用根对对象内部进行更改。如果需要，根应该将内部对象的值传递给外部对象。
- en: If an aggregate object is stored in the database, then the query should only
    return the aggregate object. Traversal associations should be used to return the
    object when it is internally linked to the aggregate root. These internal objects
    may also have references to other aggregates.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果聚合对象存储在数据库中，那么查询应该只返回聚合对象。遍历关联应该在聚合根内部链接时返回对象。这些内部对象也可能引用其他聚合。
- en: An aggregate root entity holds its global identity, and holds local identities
    inside their entities.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合根实体保持其全局身份，并在其实体内部保持局部身份。
- en: A simple example of an aggregate in the table booking system is the customer.
    Customers can be exposed to external objects, and their root object contains their
    internal object address and contact information.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在表预订系统中，聚合的一个简单示例是客户。客户可以暴露给外部对象，而它们的根对象包含它们的内部对象地址和联系信息。
- en: 'When requested, the value object of internal objects, such as address, can
    be passed to external objects:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求时，内部对象的价值对象，如地址，可以传递给外部对象：
- en: '![](img/813a40c6-d3de-48ee-af15-123cafde5086.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/813a40c6-d3de-48ee-af15-123cafde5086.jpg)'
- en: The customer as an aggregate
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 客户作为聚合根
- en: Repository
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仓库
- en: In a domain model, at a given point in time, many domain objects may exist.
    Each object may have its own life-cycle, from the creation of objects to their
    removal or persistence. Whenever any domain operation needs a domain object, it
    should retrieve the reference of the requested object efficiently. It would be
    very difficult if you didn't maintain all of the available domain objects in a
    central object. A central object carries the references of all the objects, and
    is responsible for returning the requested object reference. This central object
    is known as the **repository**.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在领域模型中，在给定的时间点，可能存在许多领域对象。每个对象可能都有自己的生命周期，从对象的创建到它们的移除或持久化。每当领域操作需要一个领域对象时，它应该有效地检索所需对象的引用。如果你没有维护所有可用的领域对象，那将会非常困难。一个中心对象携带所有对象的引用，并负责返回请求的对象引用。这个中心对象被称为**仓库**。
- en: The repository is a point that interacts with infrastructures such as the database
    or file system. A repository object is the part of the domain model that interacts
    with storage such as the database, external sources, and so on, to retrieve the
    persisted objects. When a request is received by the repository for an object's
    reference, it returns the existing object's reference. If the requested object
    does not exist in the repository, then it retrieves the object from storage. For
    example, if you need a customer, you would query the repository object to provide
    the customer with ID `31`. The repository would provide the requested customer
    object if it is already available in the repository, and if not, it would query
    the persisted stores such as the database, fetch it, and provide its reference.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库是与数据库或文件系统等基础架构交互的点。仓库对象是领域模型中与存储（如数据库）、外部源等交互以检索持久化对象的部分。当仓库收到对对象引用的请求时，它返回现有对象的引用。如果请求的对象在仓库中不存在，那么它从存储中检索该对象。例如，如果您需要一个客户，您会查询仓库对象以提供具有ID
    `31`的客户。如果对象在仓库中已经存在，仓库将提供请求的客户对象，如果不存在，它将查询持久化存储，如数据库，获取它，并提供其引用。
- en: The main advantage of using the repository is having a consistent way to retrieve
    objects where the requestor does not need to interact directly with the storage
    such as the database.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用仓库的主要优点是有一种一致的方法来检索对象，其中请求者不需要直接与存储（如数据库）交互。
- en: 'A repository may query objects from various storage types, such as one or more
    databases, filesystems, or factory repositories, and so on. In such cases, a repository
    may have strategies that also point to different sources for different object
    types or categories:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库可能查询来自各种存储类型的对象，如一个或多个数据库、文件系统或工厂仓库等。在这种情况下，仓库可能有指向不同来源的不同对象类型或类别的策略：
- en: '![](img/b8f1ce0c-5528-4b86-9b3c-78c58bcfedfd.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8f1ce0c-5528-4b86-9b3c-78c58bcfedfd.jpg)'
- en: Repository object flow
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库对象流程
- en: As shown in the repository object flow diagram, the r**epository** interacts
    with the i**nfrastructure layer,** and this interface is part of the **domain
    layer**. The **requestor** may belong to a domain layer, or an application layer.
    The r**epository** helps the system to manage the life cycle of domain objects.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，仓库对象流程图与基础架构层**交互**，并且这一接口属于**领域层**。**请求者**可能属于领域层，或者应用层。仓库帮助系统管理领域对象的**生命周期**。
- en: Factory
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂
- en: A **factory** is required when a simple constructor is not enough to create
    the object. It helps to create complex objects, or an aggregate that involves
    the creation of other related objects.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**工厂**在简单构造函数不足以创建对象时是必需的。它帮助创建复杂对象，或者涉及创建其他相关对象的聚合。'
- en: A factory is also a part of the life cycle of domain objects, as it is responsible
    for creating them. Factories and repositories are in some way related to each
    other, as both refer to domain objects. The factory refers to newly created objects,
    whereas the repository returns the already existing objects either from the memory,
    or from external storage.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂也是领域对象生命周期的组成部分，因为它是负责创建它们的部分。工厂和仓库在某种程度上是相关的，因为两者都指的是领域对象。工厂指的是新创建的对象，而仓库从内存或外部存储中返回已经存在的对象。
- en: Let's see how control flows, by using a user creation process application. Let's
    say that a user signs up with a username `user1`. This user creation first interacts
    with the factory, which creates the name `user1` and then caches it in the domain
    using the repository, which also stores it in the storage for persistence.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用一个用户创建过程应用程序来查看控制是如何流动的。假设一个用户使用用户名`user1`进行注册。这个用户创建首先与工厂交互，创建了名字`user1`，然后使用仓库在领域中缓存它，该仓库还将其存储在用于持久化的存储中。
- en: When the same user logs in again, the call moves to the repository for a reference.
    This uses the storage to load the reference and pass it to the requestor.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当同一用户再次登录时，调用会移动到仓库进行引用。这使用存储来加载引用并将其传递给请求者。
- en: 'The requestor may then use this `user1` object to book the table in a specified
    restaurant, and at a specified time. These values are passed as parameters, and
    a table booking record is created in storage using the repository:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请求者然后可以使用这个`user1`对象在指定餐厅和指定时间预订桌子。这些值作为参数传递，并使用仓库在存储中创建了桌子预订记录：
- en: '![](img/3e0af162-b03b-49e1-8570-c8ad9657db94.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e0af162-b03b-49e1-8570-c8ad9657db94.jpg)'
- en: Repository object flow
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库对象流程
- en: The factory may use one of the object-oriented programming patterns, such as
    the factory or abstract factory pattern, for object creation.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂可能会使用面向对象编程模式中的一种，例如工厂或抽象工厂模式，用于对象创建。
- en: Modules
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: '**Modules** are the best way to separate related business objects. These are
    best suited to large projects where the size of domain objects is bigger. For
    the end user, it makes sense to divide the domain model into modules and set the
    relationship between these modules. Once you understand the modules and their
    relationship, you start to see the bigger picture of the domain model, thus it''s
    easier to drill down further and understand the model.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块**是将相关业务对象分离的最佳方式。这对于大型项目来说非常合适，其中领域对象的规模更大。对于最终用户来说，将领域模型划分为模块并设置这些模块之间的关系是有意义的。一旦你理解了模块及其关系，你开始看到领域模型的更大图景，因此更容易深入理解模型。'
- en: Modules also help in code that is highly cohesive, or that maintains low coupling.
    Ubiquitous language can be used to name these modules. For the table booking system,
    we could have different modules, such as user-management, restaurants and tables,
    analytics and reports, and reviews, and so on.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 模块还有助于高度凝聚的代码，或者保持低耦合的代码。通用语言可以用来为这些模块命名。对于预订表格系统，我们可以有不同的模块，比如用户管理、餐厅和桌子、分析和报告、评论等。
- en: Strategic design and principles
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 战略设计和原则
- en: An enterprise model is usually very large and complex. It may be distributed
    among different departments in an organization. Each department may have a separate
    leadership team, so working and designing together can create difficulty and coordination
    issues. In such scenarios, maintaining the integrity of the domain model is not
    an easy task.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 企业模型通常非常大且复杂。它可能分布在组织中的不同部门。每个部门可能有一个单独的领导团队，因此共同工作和设计可能会产生困难和协调问题。在这种情况下，维护领域模型的完整性并不是一件容易的事。
- en: In such cases, working on a unified model is not the solution, and large enterprise
    models need to be divided into different submodels. These submodels contain the
    predefined accurate relationship and contract in minute detail. Each submodel
    has to maintain the defined contracts without any exception.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，统一模型并不是解决方案，大型企业模型需要划分为不同的子模型。这些子模型包含了预定义的准确关系和合同，并且非常详细。每个子模型都必须无例外地维持定义的合同。
- en: 'There are various principles that could be followed to maintain the integrity
    of the domain model, and these are listed as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种原则可以遵循以维护领域模型的完整性，这些原则如下：
- en: Bounded context
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边界上下文
- en: Continuous integration
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成
- en: Context map
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文映射
- en: Shared kernel
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享核心
- en: Customer-supplier
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户-供应商
- en: Conformist
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顺从者
- en: Anticorruption layer
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防腐层
- en: Separate ways
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分道扬镳
- en: Open Host Service
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放主机服务
- en: Distillation
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提炼
- en: Bounded context
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边界上下文
- en: When you have different submodels, it is difficult to maintain the code when
    all submodels are combined. You need to have a small model that can be assigned
    to a single team. You might need to collect the related elements and group them.
    Context keeps and maintains the meaning of the domain term defined for its respective
    submodel by applying this set of conditions.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有不同的子模型时，当所有子模型组合在一起时，很难维护代码。你需要一个小模型，可以分配给一个单一团队。你可能需要收集相关元素并将它们分组。上下文通过应用这组条件来保持和维护为其相应子模型定义的领域术语的意义。
- en: These domain terms define the scope of the model that creates the boundaries
    of the context.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这些领域术语定义了创建上下文边界的模型的范围。
- en: Bounded context seems very similar to the module that you learned about in the
    previous section. In fact, the module is part of the bounded context that defines
    the logical frame where a submodel takes place and is developed. Whereas, the
    module organizes the elements of the domain model, and is visible in the design
    document and the code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 边界上下文似乎与前面章节中你学到的模块非常相似。实际上，模块是定义子模型发生和发展的逻辑框架的一部分。而模块负责组织领域模型的元素，并在设计文档和代码中可见。
- en: Now, as a designer, you would have to keep each submodel well-defined and consistent.
    In this way, you can refactor each model independently without affecting the other
    submodels. This gives the software designer the flexibility to refine and improve
    it at any point in time.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，作为一名设计师，你必须确保每个子模型都有明确的定义并且保持一致。这样，你就可以独立地重构每个模型，而不会影响到其他的子模型。这使得软件设计师能够在任何时候精细和改进模型。
- en: 'Now, let''s examine the table reservation example we''ve been using. When you
    started designing the system, you would have seen that the guest would visit the
    application, and would request a table reservation at a selected restaurant, date,
    and time. Then, there is the backend system that informs the restaurant about
    the booking information, and similarly, the restaurant would keep their system
    updated in regard to table bookings, given that tables can also be booked by the
    restaurant themselves. So, when you look at the system''s finer points, you can
    see two domain models:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来分析我们一直在使用的表格预订示例。当您开始设计系统时，您会发现客人会访问应用程序，并在选定的餐厅、日期和时间请求表格预订。然后，后端系统会通知餐厅预订信息，同样，餐厅也会更新他们的系统关于表格预订的信息，因为餐厅也可以自己预订表格。所以，当您关注系统的细微之处时，可以看到两个领域模型：
- en: The online table reservation system
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线预订表格系统
- en: The offline restaurant management system
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 离线餐厅管理系统
- en: Both have their own bounded context and you need to make sure that the interface
    between them works fine.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都有自己的边界上下文，您需要确保它们之间的接口运行良好。
- en: Continuous integration
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成
- en: When you are developing, the code is scattered among many teams and various
    technologies. This code may be organized into different modules, and has applicable
    bounded context for respective submodels.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在开发时，代码分布在许多团队和各种技术中。这些代码可能被组织成不同的模块，并为各自的子模型提供了适用的边界上下文。
- en: This sort of development may bring with it a certain level of complexity with
    regard to duplicate code, a code break, or maybe broken-bounded context. It happens
    not only because of the large size of code and domain model, but also because
    of other factors, such as changes in team members, new members, or not having
    a well-documented model, to name just a few of them.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这种开发方式可能会带来一定级别的复杂性，例如代码重复、代码断裂或破坏性边界上下文。这不仅是因为代码量大和领域模型大，还因为其他因素，如团队成员变化、新成员加入，或者没有完善的文档模型等。
- en: When systems are designed and developed using DDD and Agile methodologies, domain
    models are not designed fully before coding starts, and the domain model and its
    elements evolve over a period of time with continuous improvements and refinement
    happening gradually.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用DDD和敏捷方法论设计和开发系统时，在编码开始之前并不会完全设计领域模型，领域模型及其元素会在一段时间内随着持续的改进和细化而发展。
- en: Therefore, integration continues, and this is currently one of the key reasons
    for development today, so it plays a very important role. In **continuous integration**,
    the code is merged frequently to avoid any breaks and issues with the domain model.
    Merged code not only gets deployed, but it is also tested on a regular basis.
    There are various continuous integration tools available in the market that merge,
    build, and deploy the code at scheduled times. These days, organizations put more
    emphasis on the automation of continuous integration. Hudson, TeamCity, and Jenkins
    CI are a few of the popular tools available today for continuous integration.
    Hudson and Jenkins CI are open source tools, and TeamCity is a proprietary tool.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，集成继续进行，这是当今开发的关键原因之一，因此它扮演着非常重要的角色。在**持续集成**中，代码频繁合并，以避免任何断裂和领域模型问题。合并的代码不仅被部署，而且它还定期进行测试。市场上有很多可用的持续集成工具，它们在预定时间合并、构建和部署代码。如今，组织更加重视持续集成的自动化。Hudson、TeamCity和Jenkins
    CI是市场上一些流行的持续集成工具。Hudson和Jenkins CI是开源工具，而TeamCity是商业工具。
- en: Having a test suite attached to each build confirms the consistency and integrity
    of the model. A test suite defines the model from a physical point of view, whereas
    UML does it logically. It informs you of any error or unexpected outcome that
    requires a code change. It also helps to identify errors and anomalies in a domain
    model early on.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个与每个构建关联的测试套件可以确认模型的连贯性和完整性。测试套件从物理角度定义模型，而UML则是从逻辑角度。它会告知您任何错误或意外结果，这需要更改代码。它还有助于尽早识别领域模型中的错误和异常。
- en: Context map
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文映射
- en: The context map helps you to understand the overall picture of a large enterprise
    application. It shows how many bounded contexts are present in the enterprise
    model, and how they are interrelated. Therefore, we can say that any diagram or
    document that explains the bounded contexts and relationship between them is called
    a **context** **map**.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文图帮助你理解大型企业应用程序的整体情况。它显示了企业模型中有多少个边界上下文，以及它们是如何相互关联的。因此，我们可以说任何解释边界上下文及其之间关系的图表或文档都称为**上下文**
    **图**。
- en: Context maps help all team members, whether they are on the same team or in
    a different team, to understand the high-level enterprise model in the form of
    various parts (bounded context or submodels) and relationships.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文图帮助所有团队成员，无论他们是在同一个团队还是不同的团队，都以各种部分（边界上下文或子模型）和关系的形式理解高层次的企业模型。
- en: 'This gives individuals a clearer picture about the tasks one performs, and
    may allow him or her to raise any concern/question about the model''s integrity:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得个人对自己执行的任务有了更清晰的了解，并可能允许他或她就模型的完整性提出任何担忧/问题：
- en: '![](img/5347ac92-4666-4d87-99d8-12aa816036da.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5347ac92-4666-4d87-99d8-12aa816036da.jpg)'
- en: Context map example
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文地图示例
- en: The context map example diagram is a sample of a context map. Here, **Table1**
    and **Table2** both appear in the **Table Reservation Context** and also in the
    **Restaurant Ledger Context**. The interesting thing is that **Table1** and **Table2**
    have their own respective concept in each bounded context. Here, ubiquitous language
    is used to name the bounded context as **table reservation** and **restaurant
    ledger**.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文地图例图是上下文图的一个样本。在这里，**Table1**和**Table2**都出现在**Table Reservation Context**和**Restaurant
    Ledger Context**中。有趣的是，**Table1**和**Table2**在各自的边界上下文中都有各自的概念。在这里，通用语言用于将边界上下文命名为**table
    reservation**和**restaurant ledger**。
- en: In the following section, we will explore a few patterns that can be used to
    define the communication between different contexts in the context map.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨几个可以用以来定义上下文图中不同上下文之间通信的模式。
- en: Shared kernel
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享核心
- en: 'As the name suggests, one part of the bounded context is shared with the other''s
    bounded context. As you can see in the following figure, the **Restaurant** entity
    is being shared between the **Table Reservation Context** and the **Restaurant
    Ledger Context**:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名，边界上下文的一部分与其他的边界上下文共享。正如下面的图表所示，**Restaurant**实体在**Table Reservation Context**和**Restaurant
    Ledger Context**之间共享：
- en: '![](img/66176460-3b14-45e0-bd1d-986c37b642b6.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66176460-3b14-45e0-bd1d-986c37b642b6.jpg)'
- en: Shared kernel
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 共享核心
- en: Customer-supplier
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户-供应商
- en: The customer-supplier pattern represents the relationship between two bounded
    contexts, when the output of one bounded context is required for the other bounded
    context. That is, one supplies the information to the other (known as the customer),
    who consumes the information.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 客户-供应商模式代表了两个边界上下文之间的关系，当一个边界上下文的输出需要被另一个边界上下文使用时。也就是说，一方向另一方（称为客户）提供信息。
- en: In a real-world example, a car dealer could not sell cars until the car manufacturer
    delivers them. Hence, in this domain model, the car manufacturer is the supplier
    and the dealer is the customer. This relationship establishes a customer-supplier
    relationship, because the output (car) of one bounded context (car-manufacturer)
    is required by the other bounded context (dealer).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个现实世界的例子中，汽车经销商在汽车制造商交付汽车之前是无法销售汽车的。因此，在这个领域模型中，汽车制造商是供应商，经销商是客户。这种关系建立了一个客户-供应商关系，因为一个边界上下文（汽车制造商）的输出（汽车）被另一个边界上下文（经销商）所需要。
- en: Here, both customer and supplier teams should meet regularly to establish a
    contract and form the right protocol to communicate with each other.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，客户和供应商团队应定期会面，以建立合同并形成适当的协议来相互沟通。
- en: Conformist
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遵从者
- en: This pattern is similar to that of the customer and the supplier, where one
    needs to provide the contract and information while the other needs to use it.
    Here, instead of bounded context, actual teams are involved in having an upstream/downstream
    relationship.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式与客户和供应商的模式相似，其中一方需要提供合同和信息，而另一方需要使用它们。在这里，涉及实际的团队在具有上下游关系的过程中，而不是边界上下文。
- en: Moreover, upstream teams do not provide for the needs of the downstream team,
    because of their lack of motivation. Therefore, it is possible that the downstream
    team may need to plan and work on items that will never be available. To resolve
    such cases, the customer team could develop their own models if the supplier provides
    information that is not worth enough. If the supplier provided information that
    is really of worth or of partial worth, then the customer can use the interface
    or translators that can be used to consume the supplier-provided information with
    the customer's own models.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，上游团队由于缺乏动力，没有为下游团队提供所需的支持。因此，下游团队可能需要计划和处理永远无法获得的项目。为了解决这种情况，如果供应商提供的不够有价值的信息，客户团队可以开发自己的模型。如果供应商提供真正有价值或部分有价值的信息，那么客户可以使用接口或翻译器来消耗供应商提供信息与客户自己的模型。
- en: Anticorruption layer
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反向腐蚀层
- en: The **anticorruption layer** remains part of a domain and it is used when a
    system needs data from external systems, or from their own legacy systems. Here,
    anticorruption is the layer that interacts with external systems and uses external
    system data in the domain model without affecting the integrity and originality
    of the domain model.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**反向腐蚀层**仍然是领域的一部分，当系统需要从外部系统或自己的遗留系统获取数据时使用。在这里，反向腐蚀层是与外部系统交互并使用外部系统数据在领域模型中，而不会影响领域模型的完整性和原始性。'
- en: For the most part, a service can be used as an anticorruption layer that may
    use a facade pattern with an adapter and translator to consume external domain
    data within the internal model. Therefore, your system would always use the service
    to retrieve the data. The service layer can be designed using the facade pattern.
    This would make sure that it would work with the domain model to provide the required
    data in a given format. The service could then also use the adapter and translator
    patterns that would make sure that, whatever format and hierarchy the data is
    sent in, by external sources, the service would be provided in the desired format
    and the hierarchy would use adapters and translators.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，服务可以作为反向腐蚀层使用，该层可能会使用外观模式与适配器和翻译器一起消耗内部模型外的外部领域数据。因此，您的系统总是使用服务来获取数据。服务层可以使用外观模式进行设计。这将确保它与领域模型协同工作，以提供给定格式的所需数据。服务还可以使用适配器和翻译器模式，以确保无论数据以何种格式和层次结构从外部来源发送，服务都能以所需的格式提供数据，并使用适配器和翻译器来处理层次结构。
- en: Separate ways
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分手
- en: When you have a large enterprise application and a domain where different domains
    have no common elements, and it's made of large submodels that can work independently,
    this still works as a single application for an end user.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个大型企业应用程序和一个领域时，其中不同的领域没有共同元素，并且它由可以独立工作的较大子模型组成，这仍然可以作为一个单一应用程序为最终用户工作。
- en: In such cases, a designer could create separate models that have no relationship,
    and develop a small application on top of them. These small applications become
    a single application when merged together.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，设计师可以创建没有关系的独立模型，并在其上开发小型应用程序。当这些小型应用程序合并在一起时，它们成为一个单一的应用程序。
- en: An employer's intranet application that offers various small applications, such
    as those that are HR-related, issue trackers, transport, or intra-company social
    networks, is one such application where a designer could use the **separate ways**
    pattern.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 提供各种小型应用程序的雇主内部应用程序，例如与人力资源相关的小应用程序、问题跟踪器、交通或公司内部社交网络，是设计师可以使用**分手**模式的一种应用程序。
- en: It would be very challenging and complex to integrate applications that were
    developed using separate models. Therefore, you should take care before implementing
    this pattern.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 集成使用不同模型开发的应用程序将非常具有挑战性和复杂。因此，在实施此模式之前应该小心。
- en: Open Host Service
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开主机服务
- en: A translation layer is used when two submodels interact with each other. This
    translation layer is used when you integrate models with an external system. This
    works fine when you have one submodel that uses this external system. The Open
    Host Service is required when this external system is being used by many submodels
    to remove the extra and duplicated code, because then you need to write a translation
    layer for each submodels external system.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个子模型相互交互时，使用翻译层。当你将模型与外部系统集成时，使用此翻译层。当你有一个子模型使用这个外部系统时，这种方式工作得很好。当这个外部系统被许多子模型使用时，需要去除额外的和重复的代码，因此需要为每个子模型的外部系统编写一个翻译层。
- en: An Open Host Service provides the services of an external system using a wrapper
    to all sub-models.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 开放主机服务通过封装所有子模型来提供外部系统的服务。
- en: Distillation
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蒸馏
- en: As you know, **distillation** is the process of purifying liquid. Similarly,
    in DDD, distillation is the process that filters out the information that is not
    required, and keeps only the meaningful information. It helps you to identify
    the core domain and the essential concepts for your business domain. It helps
    you to filter out the generic concepts until you get the core domain concept.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，**蒸馏**是净化液体的过程。同样，在DDD中，蒸馏是过滤掉不必要的信息，只保留有意义信息的过程。它帮助你识别核心领域和业务领域的关键概念。它帮助你过滤掉通用概念，直到获得核心领域概念。
- en: Core domain should be designed, developed, and implemented with the highest
    attention to detail, using the developers and designers, as it is crucial to the
    success of the whole system.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 核心领域应该由开发人员和设计师高度关注细节地进行设计、开发和实现，因为这对于整个系统的成功至关重要。
- en: In our table reservation system example, which is not a large or complex domain
    application, it is not difficult to identify the core domain. The core domain
    here exists to share the real-time accurate vacant tables in the restaurants,
    and allows the user to reserve them in a hassle-free process.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的表格预订系统示例中，这是一个不大或复杂的领域应用程序，识别核心领域并不困难。这里的核心领域存在是为了共享餐厅的实时准确空闲桌子信息，并允许用户以无麻烦的过程进行预订。
- en: Sample domain service
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例域名服务
- en: Let us create a sample domain service based on our table reservation system.
    As discussed in this chapter, the importance of an efficient domain layer is the
    key to successful products or services. Projects developed based on the domain
    layer are more maintainable, highly cohesive, and decoupled. They provide high
    scalability in terms of business requirement changes, and have a low impact on
    the design of other layers.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们基于我们的表格预订系统创建一个示例域名服务。正如本章所讨论的，高效的领域层是成功产品或服务的关键。基于领域层开发的项目更易于维护，高度凝聚，且松耦合。它们在业务需求变化方面提供高度可扩展性，对其他层的设计影响较低。
- en: Domain-driven development is based on domain, hence it is not recommended that
    you use a top-down approach where the UI would be developed first, followed by
    the rest of the layers, and finally the persistence layer. Nor should you use
    a bottom-up approach, where the persistence layer like the DB is designed first,
    followed by the rest of the layers, with the UI last.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 领域驱动开发基于领域，因此不建议使用自上而下的方法，其中首先开发UI，然后是其他层，最后是持久化层。也不建议使用自下而上的方法，其中首先设计持久化层（如数据库），然后是其他层，最后是UI。
- en: Having a domain model developed first, using the patterns described in this
    book, gives clarity to all team members functionality-wise, and an advantage to
    the software designer to build a flexible, maintainable, and consistent system
    that helps the organization to launch a world-class product with fewer maintenance
    costs.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 首先开发一个领域模型，使用本书中描述的模式，可以在功能上为所有团队成员提供清晰度，并使软件设计师具有构建灵活、可维护且一致的系统的优势，这有助于组织以更低的维护成本推出世界级的产品。
- en: Here, you will create a restaurant service that provides the feature to add
    and retrieve restaurants. Based on implementation, you can add other functionalities,
    such as finding restaurants based on cuisine or ratings.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将创建一个餐厅服务，提供添加和检索餐厅的功能。根据实现情况，你可以添加其他功能，例如根据菜系或评分查找餐厅。
- en: Start with the entity. Here, the restaurant is our entity, as each restaurant
    is unique and has an identifier. You can use an interface, or set of interfaces,
    to implement the entity in our table reservation system. Ideally, if you go by
    the interface segregation principle, you will use a set of interfaces rather than
    a single interface.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 从实体开始。在这里，餐厅是我们的实体，因为每个餐厅都是独一无二的，并且有一个标识符。你可以使用一个接口，或一系列接口，来实现在我们的表格预订系统中的实体。理想情况下，如果你遵循接口分离原则，你会使用一系列接口而不是一个单一的接口。
- en: The **Interface Segregation Principle** (**ISP**) states that clients should
    not be forced to depend upon interfaces that they do not use.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口分离原则**（**ISP**）指出，客户不应该被强制依赖于他们不使用的接口。'
- en: Entity implementation
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体实现
- en: For the first interface, you could have an abstract class or interface that
    is required by all the entities. For example, if we consider ID and name, attributes
    would be common for all entities.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个接口，你可以有一个抽象类或接口，该接口被所有实体所必需。例如，如果我们考虑ID和名称，属性对所有实体来说都是共通的。
- en: 'Therefore, you could use the abstract class `Entity` as an abstraction of the
    entity in your domain layer:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以使用抽象类`Entity`作为领域层中实体的抽象：
- en: '[PRE0]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Based on that, you can also have another `abstract` class that inherits `Entity`,
    an abstract class:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个，你还可以有一个继承自`Entity`的另一个`abstract`类，一个抽象类：
- en: '[PRE1]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Based on the preceding abstractions, we could create the `Restaurant` entity
    for restaurant management.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 基于前面的抽象，我们可以为餐厅管理创建`Restaurant`实体。
- en: Now, since we are developing the table reservation system, `Table` is another
    important entity in terms of the domain model. So, if we go by the aggregate pattern,
    `Restaurant` would work as a root, and the `Table` entity would be internal to
    the `Restaurant` entity. Therefore, the `Table` entity would always be accessible
    using the `Restaurant` entity.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于我们正在开发表格预订系统，`Table`在领域模型中是另一个重要的实体。所以，如果我们遵循聚合模式，`Restaurant`将作为根工作，而`Table`实体将位于`Restaurant`实体内部。因此，`Table`实体总是通过`Restaurant`实体来访问。
- en: 'You can create the `Table` entity using the following implementation, and you
    can add attributes as you wish. For demonstration purposes only, basic attributes
    are used:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下实现创建`Table`实体，并且可以添加你想要的属性。仅为了演示，使用了基本属性：
- en: '[PRE2]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we can implement the aggregator `Restaurant` class shown as follows. Here,
    only basic attributes are used. You could add as many as you want, and you may
    also add other features:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实现聚合器`Restaurant`类，如下所示。在这里，只使用了基本属性。你可以添加尽可能多的属性，也可以添加其他功能：
- en: '[PRE3]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Repository implementation
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仓库实现
- en: 'Now we can implement the repository pattern, as learned in this chapter. To
    start with, you will first create the two interfaces `Repository` and `ReadOnlyRepository`.
    The `ReadOnlyRepository` interface will be used to provide an abstraction for
    read-only operations, whereas `Repository` abstraction will be used to perform
    all types of operations:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以实现仓库模式，正如本章所学习的那样。首先，你将创建两个接口`Repository`和`ReadOnlyRepository`。`ReadOnlyRepository`接口将用于提供只读操作的抽象，而`Repository`抽象将用于执行所有类型的操作：
- en: '[PRE4]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Based on this interface, we could create the abstraction of the `Repository`,
    which would execute additional operations such as adding, removing, and updating:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个接口，我们可以创建`Repository`的抽象，执行诸如添加、删除和更新的额外操作：
- en: '[PRE5]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `Repository` abstraction, as defined previously, could be implemented,
    in a way that suits you, to persist your objects. The change in persistence code,
    which is a part of the infrastructure layer, won''t impact on your domain layer
    code, as the contract and abstraction are defined by the domain layer. The domain
    layer uses the abstraction classes and interfaces that remove the use of direct
    concrete class, and provides the loose coupling. For demonstration purposes, we
    could simply use the map that remains in the memory to persist the objects:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 前面定义的`Repository`抽象，可以按照适合你的方式来实现，以持久化你的对象。基础设施层中的持久化代码的变化不会影响到领域层代码，因为合同和抽象是由领域层定义的。领域层使用移除直接具体类的抽象类和接口，提供松耦合。为了演示目的，我们完全可以使用留在内存中的映射来持久化对象：
- en: '[PRE6]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Service implementation
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务实现
- en: 'In the same way as the preceding approach, you could divide the abstraction
    of domain service into two parts—main service abstraction and read-only service
    abstraction:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一种方法相同，你可以将领域服务的抽象分为两部分——主要服务抽象和只读服务抽象：
- en: '[PRE7]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we could use this `ReadOnlyBaseService` to create the `BaseService`. Here,
    we are using the dependency inject pattern via a constructor to map the concrete
    objects with abstraction:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用这个`ReadOnlyBaseService`来创建`BaseService`。在这里，我们通过构造函数使用依赖注入模式将具体对象与抽象对象映射：
- en: '[PRE8]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, after defining the service abstraction services, we could implement the
    `RestaurantService` in the following way:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在定义了服务抽象之后，我们可以像下面这样实现`RestaurantService`：
- en: '[PRE9]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Similarly, you could write the implementation for other entities. This code
    is a basic implementation, and you might add various implementations and behaviors
    in the production code.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以为其他实体编写实现。这段代码是一个基本实现，你可能会在生产代码中添加各种实现和行为。
- en: We can write an application class that would execute and test the sample domain
    model code that we have just written.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个应用类，用来执行和测试我们刚刚编写的示例领域模型代码。
- en: 'The `RestaurantApp.java` file will look something like this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`RestaurantApp.java`文件看起来可能像这样：'
- en: '[PRE10]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To execute this program, either execute directly from IDE, or run using Maven.
    It prints the following output:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此程序，可以直接从IDE执行，或使用Maven运行。它会打印出以下输出：
- en: '[PRE11]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have learned the fundamentals of DDD. You have also explored
    multilayered architecture and different patterns that can be used to develop software
    using DDD. By this time, you should be aware that the domain model design is very
    important for the success of the software. To conclude, we demonstrated one domain
    service implementation using the restaurant table reservation system.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经学习了DDD的基础知识。你也探索了多层架构和不同的模式，这些模式可以用DDD来开发软件。到这个时候，你应该已经意识到领域模型设计对软件成功的非常重要。总之，我们通过餐厅桌位预订系统演示了一个领域服务实现。
- en: In the next chapter, you will learn how to use the design to implement the sample
    project. The explanation of the design of this sample project is derived from
    the last chapter, and the DDD will be used to build the microservices. This chapter
    not only covers the coding, but also the different aspects of the microservices,
    such as build, unit testing, and packaging. By the end of the next chapter, the
    sample microservice project will be ready for deployment and consumption.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何使用设计来实现示例项目。这个示例项目的说明来源于上一章，将使用DDD来构建微服务。这一章不仅涵盖了编码，还包括微服务的不同方面，比如构建、单元测试和打包。到下一章结束时，示例微服务项目将准备好部署和使用。
