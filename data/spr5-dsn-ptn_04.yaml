- en: Wiring Beans using the Dependency Injection Pattern
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用依赖注入模式连接Wiring Beans
- en: In the previous chapter, you learned about the **Gang of Four** (**GOF**) design
    patterns with examples and use cases of each. Now, we will go into more detail
    about injecting beans and the configuration of dependencies in a Spring application,
    where you will see the various ways of configuring dependencies in a Spring application.
    This includes configuration with XML, Annotation, Java, and Mix.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你通过示例和使用案例学习了**四人帮**（**GOF**）设计模式。现在，我们将更详细地探讨在Spring应用程序中注入Bean和配置依赖项，你将看到配置Spring应用程序依赖项的各种方法。这包括使用XML、注解、Java和混合配置。
- en: Everyone loves movies, right? Well, if not movies, how about plays, or dramas,
    or theatre? Ever wondered what would happen if the different team members didn't
    speak to each other? By team I don't just mean the actors, but the sets team,
    make-up personnel, audio-visual guys, sound system guys, and so on. It is needless
    to say that every member has an important contribution towards the end product,
    and an immense amount of coordination is required between these teams.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都喜欢看电影，对吧？嗯，如果不喜欢电影，那戏剧、剧集或者剧院呢？有没有想过如果团队成员之间不交流会发生什么？我说的是团队，不仅仅是演员，还有布景团队、化妆人员、视听人员、音响系统人员等等。不用说，每个成员都对最终产品有重要的贡献，并且这些团队之间需要大量的协调。
- en: A blockbuster movie is a product of hundreds of people working together toward
    a common goal. Similarly, great software is an application where several objects
    work together to meet some business target. As a team, every object must be aware
    of the other, and communicate with each other to get their jobs done.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一部大片是数百人共同努力实现共同目标的产品。同样，优秀的软件是几个对象共同工作以满足某些商业目标的应用程序。作为一个团队，每个对象都必须意识到其他对象，并相互沟通以完成他们的工作。
- en: In a banking system, the money transfer service must be aware of the account
    service, and the account service must be aware of the accounts repository, and
    so on. All these components work together to make the banking system workable.
    In [Chapter 1](18f63847-961b-45a2-bef0-30602dcabed3.xhtml), *Getting Started with
    Framework 5.0 and Design Patterns*, you saw the same banking example created with
    the traditional approach, that is, creating objects using construction and direct
    object initiation. This traditional approach leads to complicated code, is difficult
    to reuse and unit test, and is also highly coupled to one another.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在银行系统中，转账服务必须了解账户服务，账户服务必须了解账户存储库，等等。所有这些组件共同工作，使银行系统可行。在[第1章](18f63847-961b-45a2-bef0-30602dcabed3.xhtml)，*使用框架5.0和设计模式入门*中，你看到了使用传统方法创建的相同银行示例，即使用构造和直接对象初始化创建对象。这种传统方法导致代码复杂，难以重用和单元测试，并且与其他代码高度耦合。
- en: But in Spring, objects have a responsibility to do their jobs without the need
    to find and create the other dependent objects that are required in their jobs.
    The Spring container takes the responsibility to find or create the other dependent
    objects, and to collaborate with their dependencies. In the previous example of
    the banking system, the transfer service depends on the account service, but it
    doesn't have to create the account service, so the dependency is created by the
    container, and is handed over to the dependent objects in the application.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 但在Spring中，对象有责任在没有必要寻找和创建他们工作中所需的依赖对象的情况下完成他们的工作。Spring容器负责寻找或创建其他依赖对象，并与它们的依赖项协作。在之前的银行系统示例中，转账服务依赖于账户服务，但它不必创建账户服务，因此依赖项由容器创建，并传递给应用程序中的依赖对象。
- en: In this chapter, we will discuss the behind-the-scenes story of the Spring-based
    application with reference to the **dependency injection** (**DI**) pattern, and
    how it works. By the end of this chapter, you will understand how the objects
    of your Spring-based application create associations between them, and how Spring
    wires these objects for a job done. You will also learn many ways to wire beans
    in Spring.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论基于Spring的应用程序背后的故事，参考**依赖注入**（**DI**）模式，以及它是如何工作的。在本章结束时，你将了解你的基于Spring的应用程序中的对象是如何相互建立关联的，以及Spring是如何为完成任务连接这些对象的。你还将学习许多在Spring中连接Bean的方法。
- en: 'This chapter will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The dependency injection pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入模式
- en: Types of dependency injection patterns
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入模式的类型
- en: Resolving dependency using the Abstract Factory pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用抽象工厂模式解决依赖关系
- en: Lookup-method injection pattern
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找方法注入模式
- en: Configuring beans using the Factory pattern
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工厂模式配置Bean
- en: Configuring dependencies
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置依赖
- en: Common best practices for configuring dependencies in an application
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序中配置依赖的常见最佳实践
- en: The dependency injection pattern
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入模式
- en: In any enterprise application, coordination between the working objects is very
    important for a business goal. The relationship between objects in an application
    represents the dependency of an object, so each object would get the job done
    with coordination of the dependent objects in the application. Such required dependencies
    between the objects tend to be complicated and with tight-coupled programming
    in the application. Spring provides a solution to the tight-coupling code of an
    application by using the dependency injection pattern. Dependency injection is
    a design pattern, which promotes the loosely coupled classes in the application.
    This means that the classes in the system depend on the behavior of others, and
    do not depend on instantiation of object of the classes. The dependency injection
    pattern also promotes programming to interface instead of programming to implementation.
    Object dependencies should be on an interface, and not on concrete classes, because
    a loosely coupled structure offers you greater reusability, maintainability, and
    testability.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何企业应用程序中，为了实现业务目标，工作对象之间的协调非常重要。应用程序中对象之间的关系代表了对象的依赖性，因此每个对象都会通过应用程序中依赖对象的协调来完成工作。这种对象之间所需的依赖关系往往很复杂，并且与应用程序中的紧密耦合编程相关。Spring通过使用依赖注入模式提供了解决应用程序紧密耦合代码的方案。依赖注入是一种设计模式，它促进了应用程序中松耦合的类。这意味着系统中的类依赖于其他类的行为，而不是依赖于类的对象实例化。依赖注入模式还促进了面向接口编程而不是面向实现编程。对象依赖应该基于接口，而不是具体类，因为松耦合的结构为你提供了更大的可重用性、可维护性和可测试性。
- en: Solving problems using the dependencies injection pattern
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用依赖注入模式解决问题
- en: In any enterprise application, a common problem to handle is how to configure
    and wire together the different elements to achieve a business goal--for example,
    how to bind together the controllers at the web layer with the services and repository
    interfaces written by different members of the team without knowing about the
    controllers of the web layers. So, there are a number frameworks that provide
    a solution for this problem by using lightweight containers to assemble the components
    from different layers. Examples of such types of frameworks are PicoContainer
    and Spring Framework.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何企业应用程序中，一个常见的问题是如何配置和连接不同的元素以实现业务目标——例如，如何将不同成员编写的Web层控制器与服务和仓库接口绑定在一起，而不了解Web层的控制器。因此，有一些框架通过使用轻量级容器组装来自不同层的组件来解决这个问题。这类框架的例子有PicoContainer和Spring框架。
- en: The containers of PicoContainer and Spring use a number of design patterns to
    solve the problem of assembling the different components of different layers.
    Here, I am going to discuss one of these design patterns--the dependency injection
    pattern. Dependency injection provides us with a decoupled and loosely coupled
    system. It ensures construction of the dependent object. In the following example,
    we'll demonstrate how the dependency injection pattern solves the common problems
    related to collaboration between the various layered components.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: PicoContainer和Spring容器使用多种设计模式来解决不同层不同组件的组装问题。在这里，我将讨论其中之一——依赖注入模式。依赖注入为我们提供了一个解耦和松耦合的系统。它确保了依赖对象的构建。在下面的例子中，我们将演示依赖注入模式如何解决与不同层组件协作相关的常见问题。
- en: Without dependency injection
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有依赖注入
- en: 'In the following Java example, first of all, let''s see what is a dependency
    between two classes? Take a look at the following class diagram:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的Java示例中，首先让我们看看两个类之间的依赖关系是什么？请看以下类图：
- en: '![](img/83147f64-2d22-4553-b1d9-a3fb6118fd9f.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/83147f64-2d22-4553-b1d9-a3fb6118fd9f.png)'
- en: TransferService has dependencies with AccountRepository and TransferRepository
    for transferAmount() method with Direct Instantiation of repositories classes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: TransferService方法transferAmount()与AccountRepository和TransferRepository有依赖关系，这些依赖关系是通过直接实例化仓库类实现的。
- en: 'As seen in the preceding diagram, the **TransferService** class contains two
    member variables, **AccountRepository** and **TransferRepository.** These are
    initialized by the **TransferService** constructor. **TransferService** controls
    which implementation of the repositories is used. It also controls their construction.
    In this situation, **TransferService** is said to have a hard-coded dependency
    on the following example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，`TransferService`类包含两个成员变量，**AccountRepository**和**TransferRepository**。这些变量由`TransferService`构造函数初始化。**TransferService**控制使用哪个仓库实现。它还控制它们的构建。在这种情况下，**TransferService**被认为在以下示例中有一个硬编码的依赖：
- en: 'Following is the `TransferServiceImpl.java` file:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`TransferServiceImpl.java`文件：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, the `TransferServiceImpl` class has dependencies of
    two classes, that is `AccountRepository` and `TransferRepository`. The `TransferServiceImpl`
    class has two member variables of the dependent classes, and initializes them
    through its constructor by using the JDBC implementation of repositories such
    as `JdbcAccountRepository` and `JdbcTransferRepository`. The `TransferServiceImpl`
    class is tightly coupled with the JDBC implementation of repositories; in case
    the JDBC implementation is changed to a JPA implementation, you have to change
    your `TransferServiceImpl` class as well.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`TransferServiceImpl`类依赖于两个类，即`AccountRepository`和`TransferRepository`。`TransferServiceImpl`类有两个依赖类的成员变量，并通过其构造函数使用JDBC实现的仓库，如`JdbcAccountRepository`和`JdbcTransferRepository`来初始化它们。`TransferServiceImpl`类与仓库的JDBC实现紧密耦合；如果将JDBC实现更改为JPA实现，您还必须更改您的`TransferServiceImpl`类。
- en: According to the SOLID (Single Responsibility Principle, Open Closed Principle,
    Liskov's Substitution Principle, Interface Segregation Principle, Dependency Inversion
    Principle) principles, a class should have a single responsibility in the application,
    but in the preceding example, the `TransferServiceImpl` class is also responsible
    for constructing the objects of `JdbcAccountRepository` and `JdbcTransferRepository`
    classes. We can't use direction instantiation of objects in the class.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 根据SOLID原则（单一职责原则、开闭原则、里氏替换原则、接口隔离原则、依赖倒置原则），一个类在应用中应该只有一个职责，但在前面的例子中，`TransferServiceImpl`类还负责构建`JdbcAccountRepository`和`JdbcTransferRepository`类的对象。我们无法在类中使用直接实例化对象。
- en: 'In our first attempt to avoid the direct instantiation logic in the `TransferServiceImpl`
    class, we can use a `Factory` class that creates instances of `TransferServiceImpl`.
    According to this idea, `TransferServiceImpl` minimizes the dependency from `AccountRepository`
    and `TransferRepository`--earlier we had a tightly coupled implementation of the
    repositories, but now it refers only to the interface, as shown in the following
    diagram:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们第一次尝试避免在`TransferServiceImpl`类中直接实例化逻辑时，我们可以使用一个创建`TransferServiceImpl`实例的`Factory`类。根据这个想法，`TransferServiceImpl`最小化了`AccountRepository`和`TransferRepository`的依赖——之前我们有一个紧密耦合的仓库实现，但现在它只引用接口，如以下图所示：
- en: '![](img/e37d550f-2329-49ce-a6f7-d7dfd3f42b95.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e37d550f-2329-49ce-a6f7-d7dfd3f42b95.png)'
- en: TransferService has dependencies with AccountRepository and TransferRepository
    for transferAmount() method with Factory of repositories classes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: TransferService类在`transferAmount()`方法中依赖于`AccountRepository`和`TransferRepository`，使用的是仓库类的`Factory`。
- en: But the `TransferServiceImpl` class is, again, tightly coupled with the implementation
    of the `RepositoryFactory` class. Moreover, this process is not suitable for cases
    where we have more number of dependencies, which increases either the `Factory`
    classes or the complexity of the `Factory` class. The repository classes can also
    have other dependencies.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，`TransferServiceImpl`类再次与`RepositoryFactory`类的实现紧密耦合。此外，这个过程不适合我们拥有更多依赖项的情况，这会增加`Factory`类或`Factory`类的复杂性。仓库类也可能有其他依赖。
- en: 'The following code uses the `Factory` class to get the `AccountRepository`
    and `TransferRepository` classes:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用`Factory`类来获取`AccountRepository`和`TransferRepository`类：
- en: 'Following is the `TransferServiceImpl.java` file:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`TransferServiceImpl.java`文件：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code example, we have minimized tight coupling, and removed
    direction object instantiation from the `TransferServiceImpl` class, but this
    is not the optimal solution.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们已经最小化了紧密耦合，并从`TransferServiceImpl`类中移除了直接对象实例化，但这不是最佳解决方案。
- en: With dependency injection pattern
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用依赖注入模式
- en: The Factory idea avoids direct instantiation of an object of a class, and we
    also have to create another module that is responsible for wiring the dependencies
    between classes. This module is known as a **dependency injector**, and is based
    on the **Inversion of Control** (**IoC**) pattern. According to the IoC Framework,
    the Container it is responsible for object instantiation, and to resolve the dependencies
    among classes in the application. This module has its own life cycle of construction
    and destruction for the object defined under its scope.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式避免了直接实例化一个类的对象，我们还需要创建另一个模块来负责连接类之间的依赖。这个模块被称为 **依赖注入器**，它基于 **控制反转**（**IoC**）模式。根据
    IoC 框架，容器负责对象的实例化，以及解决应用程序中类之间的依赖。这个模块为其作用域下定义的对象具有自己的构建和销毁生命周期。
- en: 'In the following diagram, we have used the dependency injection pattern to
    resolve the dependencies of the `TransferServiceImpl` class:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，我们使用了依赖注入模式来解决 `TransferServiceImpl` 类的依赖：
- en: '![](img/ea8d76c4-43fb-4780-8434-8d772021c8e5.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea8d76c4-43fb-4780-8434-8d772021c8e5.png)'
- en: Using dependency injection design pattern to resolve dependencies for TransferService.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用依赖注入设计模式来解决 TransferService 的依赖。
- en: 'In the following example, we have used an interface to resolve the dependencies:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们使用了一个接口来解决依赖：
- en: 'Following is the `TransferServiceImpl.java` file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为 `TransferServiceImpl.java` 文件：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the `TransferServiceImpl` class, we passed references of the `AccountRepository`
    and `TransferRepository` interfaces to the constructor. Now the `TransferServiceImpl`
    class is loosely coupled with the implementation repository class (use any flavor,
    either JDBC or JPA implementation of repository interfaces), and the framework
    is responsible for wiring the dependencies with the involved dependent class.
    Loose coupling offers us greater reusability, maintainability, and testability.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `TransferServiceImpl` 类中，我们将 `AccountRepository` 和 `TransferRepository` 接口的引用传递给了构造函数。现在
    `TransferServiceImpl` 类与实现仓库类的实现（使用任何风味，无论是 JDBC 还是 JPA 仓库接口的实现）松散耦合，框架负责将依赖项与相关的依赖类连接起来。松耦合为我们提供了更高的可重用性、可维护性和可测试性。
- en: The Spring Framework implements the dependency injection pattern to resolve
    dependencies among the classes in a Spring application. Spring DI is based on
    the IoC concept, that is, the Spring Framework has a container where it creates,
    manages, and destructs the objects; it is known as a Spring IoC container. The
    objects lying within the Spring container are known as **Spring beans**. There
    are many ways to wire beans in a Spring application. Let's take a look at the
    three most common approaches for configuring the Spring container.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 框架实现了依赖注入模式来解决 Spring 应用程序中类之间的依赖。Spring DI 基于IoC概念，即Spring框架有一个容器，它创建、管理和销毁对象；它被称为Spring
    IoC容器。位于Spring容器内的对象被称为 **Spring beans**。在Spring应用程序中连接beans的方式有很多。让我们看看配置Spring容器的三种最常见方法。
- en: In the following section, we'll look at the types of the dependency injection
    pattern; you can configure the dependencies by using either one of them.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，我们将探讨依赖注入模式的类型；你可以使用其中任何一个来配置依赖。
- en: Types of dependency injection patterns
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入模式的类型
- en: 'The following are the types of dependency injections that could be injected
    into your application:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以注入到你的应用程序中的依赖注入类型：
- en: Constructor-based dependency injection
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于构造函数的依赖注入
- en: Setter-based dependency injection
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于设置器的依赖注入
- en: Constructor-based dependency injection pattern
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于构造函数的依赖注入模式
- en: Dependency injection is a design pattern to resolve the dependencies of dependent
    classes, and dependencies are nothing but object attributes. The injector has
    to be constructed for the dependent objects by using one of the ways constructor
    injection or setter injection. A constructor injection is one of the ways of fulfilling
    these object attributes at the time of creation to instantiate the object. An
    object has a public constructor that takes dependent classes as constructor arguments
    to inject the dependencies. You can declare more than one constructor into the
    dependent class. Earlier, only the PicoContainer Framework is used a constructor-based
    dependency injection to resolve dependencies. Currently, the Spring Framework
    also supports constructor injections to resolve dependencies.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入是一种设计模式，用于解决依赖类之间的依赖关系，而依赖关系不过是对象属性。注入器必须通过使用构造函数注入或设置器注入中的一种方式来为依赖对象构造。构造函数注入是在创建对象时满足这些对象属性的一种方式，以实例化对象。一个对象有一个公共构造函数，它接受依赖类作为构造函数参数以注入依赖。你可以在依赖类中声明多个构造函数。以前，仅使用
    PicoContainer 框架进行基于构造函数的依赖注入来解决问题。目前，Spring 框架也支持构造函数注入来解决依赖关系。
- en: '**Advantages of the constructor injection pattern**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**构造函数注入模式的优点**'
- en: 'The following are the advantages if you use a constructor injection in your
    Spring application:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Spring 应用程序中使用构造函数注入，以下是一些优点：
- en: Constructor-based dependency injection is more suitable for mandatory dependencies,
    and it makes a strong dependency contract
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于构造函数的依赖注入更适合强制依赖，并且它创建了一个强依赖合同
- en: Constructor-based dependency injection provides a more compact code structure
    than others
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于构造函数的依赖注入比其他方式提供了更紧凑的代码结构
- en: It supports testing by using the dependencies passed as constructor arguments
    to the dependent class
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持通过将作为构造函数参数传递给依赖类的依赖项进行测试
- en: It favors the use of immutable objects, and does not break the information hiding
    principle
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它倾向于使用不可变对象，并且不会破坏信息隐藏原则
- en: '**Disadvantages of constructor injection pattern**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**构造函数注入模式的缺点**'
- en: 'The following is the only drawback of this constructor-based injection pattern:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是基于构造函数的这种注入模式的唯一缺点：
- en: It may cause circular dependency. (Circular dependency means that the dependent
    and the dependency class are also dependents on each other, for example, class
    A depends on Class B and Class B depends on Class A)
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能会导致循环依赖。（循环依赖意味着依赖类和依赖类之间也是相互依赖的，例如，类 A 依赖于类 B，而类 B 也依赖于类 A）
- en: '**Example of constructor-based dependency injection** **pattern**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于构造函数的依赖注入模式示例**'
- en: 'Let''s see the following example for constructor-based dependency injection.
    In the following code, we have a `TransferServiceImpl` class, and its constructor
    takes two arguments:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下基于构造函数的依赖注入的示例。在以下代码中，我们有一个 `TransferServiceImpl` 类，它的构造函数接受两个参数：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The repositories will also be managed by the Spring container, and, as such,
    will have the `datasource` object for database configuration injected into them
    by the container, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库也将由 Spring 容器管理，因此容器将按照以下方式将用于数据库配置的 `datasource` 对象注入到它们中：
- en: 'Following is the `JdbcAccountRepository.java` file:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `JdbcAccountRepository.java` 文件：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Following is the `JdbcTransferRepository.java` file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `JdbcTransferRepository.java` 文件：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can see in the preceding code the JDBC implementation of the repositories
    as `AccountRepository` and `TransferRepository`. These classes also have one argument
    constructor to inject the dependency with the `DataSource` class.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在前面的代码中看到，作为 `AccountRepository` 和 `TransferRepository` 的仓库的 JDBC 实现。这些类也具有一个参数的构造函数，用于通过
    `DataSource` 类注入依赖。
- en: Let's see another way of implementing a dependency injection in the enterprise
    application, which is setter injection.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在企业应用程序中实现依赖注入的另一种方式，即设置器注入。
- en: Setter-based dependency injection
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于设置器的依赖注入
- en: The injector of the container has another way to wire the dependency of the
    dependent object. In setter injection, one of the ways to fulfil these dependencies
    is by providing a setter method in the dependent class. Object has a public setter
    methods that takes dependent classes as method arguments to inject dependencies.
    For setter-based dependency injection, the constructor of the dependent class
    is not required. There are no changes required if you change the dependencies
    of the dependent class. Spring Framework and PicoContainer Framework support setter
    injection to resolve the dependencies.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 容器注入器有另一种方式来连接依赖对象。在setter注入中，满足这些依赖关系的一种方式是在依赖类中提供一个setter方法。对象有公开的setter方法，该方法接受依赖类作为方法参数以注入依赖项。对于基于setter的依赖注入，依赖类的构造器不是必需的。如果你更改依赖类的依赖项，不需要进行任何更改。Spring框架和PicoContainer框架支持setter注入以解决依赖关系。
- en: '**Advantages of setter injection**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**setter注入的优势**'
- en: 'The following are the advantages if you use the setter injection pattern in
    your Spring application:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Spring应用程序中使用setter注入模式，以下是其优势：
- en: Setter injection is more readable than the constructor injection
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Setter注入比构造器注入更易读
- en: Setter injection solves the circular dependency problem in the application
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Setter注入解决了应用程序中的循环依赖问题
- en: Setter injection allows costly resources or services to be created as late as
    possible, and only when required
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Setter注入允许在尽可能晚的时候创建昂贵的资源或服务，并且仅在需要时
- en: Setter injection does not require the constructor to be changed, but dependencies
    are passed through public properties that are exposed
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Setter注入不需要更改构造器，但依赖项通过公开的属性传递，这些属性是公开的
- en: '**Disadvantage of the setter injection**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**setter注入的缺点**'
- en: 'The following are the drawbacks of the setter injection pattern:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为setter注入模式的缺点：
- en: Security is lesser in the setter injection pattern, because it can be overridden
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在setter注入模式中，安全性较低，因为它可以被覆盖
- en: A setter-based dependency injection does not provide a code structure as compact
    as the constructor injection
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于setter的依赖注入不提供与构造器注入一样紧凑的代码结构
- en: Be careful whenever you use setter injection, because it is not a required dependency
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用setter注入时，务必小心，因为它不是必需的依赖项
- en: '**Example of a setter-based dependency injection**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于setter的依赖注入示例**'
- en: 'Let''s see the following example for setter-based dependency injection. The
    following `TransferServiceImpl` class, has setter methods with one argument of
    the repository type:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下基于setter的依赖注入的示例。以下`TransferServiceImpl`类，具有一个参数的setter方法，该参数为存储库类型：
- en: 'Following is the `TransferServiceImpl.java` file:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`TransferServiceImpl.java`文件：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Similarly, let''s define a setter for the repositories'' implementations as
    follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，让我们定义以下存储库实现的setter，如下所示：
- en: 'Following is the `JdbcAccountRepository.java` file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`JdbcAccountRepository.java`文件：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Following is the `JdbcTransferRepository.java` file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`JdbcTransferRepository.java`文件：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can see in the preceding code the JDBC implementation of the repositories
    as `AccountRepository` and `TransferRepository`. These classes have a setter method
    with one argument to inject the dependency with the `DataSource` class.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在前面的代码中看到作为`AccountRepository`和`TransferRepository`的存储库的JDBC实现。这些类有一个setter方法，接受一个参数以注入`DataSource`类的依赖项。
- en: '**Constructor versus setter injection and best practices**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**构造器注入与setter注入及最佳实践**'
- en: The Spring Framework provides support for both types of dependency injection
    patterns. Both, the constructor and setter injection pattern, assemble the elements
    in the system. The choice between the setter and constructor injections depends
    on your application requirement, and the problem at hand. Let's see the following
    table, which lists some differences between the constructor and setter injections,
    and some best practices to select which one is suitable in your application.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架为这两种依赖注入模式提供支持。构造器和setter注入模式都在系统中组装元素。setter注入和构造器注入之间的选择取决于你的应用程序需求和处理的问题。让我们看看以下表格，其中列出了构造器和setter注入之间的一些差异，以及一些选择适合你应用程序的最佳实践。
- en: '| **Constructors injection** | **Setter injection** |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| **构造器注入** | **setter注入** |'
- en: '| A class with constructor takes arguments; it is very compact sometimes, and
    clear to understand what it creates. | Here, the object is constructed, but it
    is not clear whether its attributes are initialized or not. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 具有构造函数参数的类；有时它非常紧凑，并且清楚地表明它创建的内容。 | 这里，对象被构建了，但并不清楚其属性是否已初始化。 |'
- en: '| This is a better choice when the dependency is mandatory. | This is suitable
    when the dependency is not mandatory. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 当依赖项是必需的时候，这是一个更好的选择。 | 当依赖项不是必需的时候，这更适合。 |'
- en: '| It allows you to hide the object attributes that are immutable, because it
    does not have setters for these object attributes. To ensure the immutable nature
    of the object, use the constructor injection pattern instead of the setter injection.
    | It doesn''t ensure the immutable nature of the object. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 它允许你隐藏不可变的对象属性，因为它没有为这些对象属性提供setter。为了确保对象的不可变性，请使用构造函数注入模式而不是setter注入。 |
    它不能确保对象的不可变性。 |'
- en: '| It creates circular dependency in your application. | It solves the problem
    of circular dependency in your application. In this case, the setter injection
    is a better choice than constructor. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 它会在你的应用程序中创建循环依赖。 | 它解决了应用程序中循环依赖的问题。在这种情况下，setter注入比构造函数更好。 |'
- en: '| It is not suitable for scalar value dependencies in the application. | If
    you have simple parameters such as strings and integers as dependencies, the setter
    injection is better to use, because each setter name indicates what the value
    is supposed to do. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 在应用中，这不适用于标量值依赖。 | 如果你有字符串和整数等简单的参数作为依赖项，则使用setter注入更好，因为每个setter名称都表明了该值应该做什么。
    |'
- en: In the next section, you'll learn how to configure the injector to find the
    beans and wire them together, and how the injector manages the beans. Here, I
    will use the Spring configuration for the dependency injection pattern.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习如何配置注入器以查找bean并将它们连接起来，以及注入器如何管理bean。在这里，我将使用Spring配置来实现依赖注入模式。
- en: Configuring the dependency injection pattern with Spring
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring配置依赖注入模式
- en: 'In this section, I will explain the process required to configure dependencies
    in an application. The mainstream injectors are Google Guice, Spring, and Weld.
    In this chapter, I am using the Spring Framework, so, we will see the Spring configuration
    here. The following diagram is a high-level view of how Spring works:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将解释在应用程序中配置依赖关系所需的过程。主流的注入器有Google Guice、Spring和Weld。在本章中，我使用Spring框架，因此，我们将在这里看到Spring配置。以下图表是Spring工作的高级视图：
- en: '![](img/a7eab42c-5110-40fe-a583-bd11022f3c74.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7eab42c-5110-40fe-a583-bd11022f3c74.png)'
- en: How Spring works using dependency injection pattern
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用依赖注入模式如何工作
- en: In the preceding diagram, the **Configuration Instruction** is the meta configuration
    of your application. Here, we define the dependencies in **Your Application Classes
    (POJOs)**, and initialize the Spring container to resolve the dependency by combining
    the POJOs and **Configuration Instructions**, and finally, you have a fully configured
    and executable system or application.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，**配置指令**是应用程序的元配置。在这里，我们在**你的应用程序类（POJOs）**中定义依赖关系，初始化Spring容器，通过结合POJOs和**配置指令**来解析依赖关系，最终，你将有一个完全配置和可执行的系统或应用程序。
- en: As you have seen in the preceding diagram, the Spring container creates the
    beans in your application, and assembles them for relationships between those
    objects via the DI pattern. The Spring container creates the beans based on the
    configuration that we give to the framework, so, it's your responsibility to tell
    Spring which beans to create, and how to wire them together.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的图表中所看到的，Spring容器创建你的应用程序中的bean，并通过DI模式组装它们之间的关系。Spring容器根据我们提供给框架的配置来创建bean，因此，告诉Spring创建哪些bean以及如何将它们连接在一起是你的责任。
- en: 'Spring is very flexible in configuring the dependency of Spring beans. The
    following are three ways to configure the metadata of your application:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Spring在配置Spring bean的依赖关系方面非常灵活。以下是你应用程序元数据配置的三个方法：
- en: '**Dependency injection pattern with Java-based configuration**—it is an explicit
    configuration in Java.'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**基于Java配置的依赖注入模式**——这是一个在Java中显式配置。'
- en: '**Dependency injection pattern with Annotation-based configuration**—it is
    an implicit bean discovery, and automatic wiring.'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**基于注解配置的依赖注入模式**——这是一个隐式bean发现和自动连接。'
- en: '**Dependency injection pattern with XML-based configuration**—it is an explicit
    configuration in XML.'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**基于 XML 的依赖注入模式**——它是在 XML 中的显式配置。'
- en: Spring provides three choices to wire beans in Spring. You must select one of
    the choices, but no single choice is the best match for any application. It depends
    on your application, and you can also mix and match these choices into a single
    application. Let's now discuss the dependency injection pattern with Java-based
    configuration in detail.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 提供了三种在 Spring 中连接豆的选择。你必须选择其中之一，但没有一个选择是任何应用程序的最佳匹配。这取决于你的应用程序，你也可以将这些选择混合匹配到一个单一的应用程序中。现在让我们详细讨论基于
    Java 配置的依赖注入模式。
- en: Dependency injection pattern with Java-based configuration
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于Java配置的依赖注入模式
- en: As of Spring 3.0, it provides a Java-based Spring configuration to wire the
    Spring beans. Take a look at the following Java configuration class (`AppConfig.java`)
    to define the Spring bean and their dependencies. The Java-based configuration
    for dependency injection is a better choice, because it is more powerful and type-safe.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Spring 3.0 开始，它提供了一个基于 Java 的 Spring 配置来连接 Spring 豆类。看看以下基于 Java 的配置类 (`AppConfig.java`)，以定义
    Spring 豆类及其依赖关系。基于 Java 的配置对于依赖注入是一个更好的选择，因为它更强大且类型安全。
- en: Creating a Java configuration class - AppConfig.java
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个 Java 配置类 - AppConfig.java
- en: 'Let''s create an `AppConfig.java` configuration class for our example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的示例创建一个 `AppConfig.java` 配置类：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding `AppConfig` class is annotated with the `@Configuration` annotation,
    which indicates that it is a configuration class of the application that contains
    the details on bean definitions. This file will be loaded by the Spring application
    context to create beans for your application.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `AppConfig` 类被 `@Configuration` 注解标记，这表示它是一个包含豆定义详细信息的应用程序配置类。该文件将由 Spring
    应用程序上下文加载以创建应用程序的豆。
- en: Let's now see how you can declare the `TransferService`, `AccountRepository`
    and `TransferRepository` beans in `AppConfig`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何在 `AppConfig` 中声明 `TransferService`、`AccountRepository` 和 `TransferRepository`
    这三个豆类。
- en: Declaring Spring beans into configuration class
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在配置类中声明 Spring 豆
- en: 'To declare a bean in a Java-based configuration, you have to write a method
    for the desired type object creation in the configuration class, and annotate
    that method with `@Bean`. Let''s see the following changes made in the `AppConfig`
    class to declare the beans:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于 Java 的配置中声明豆时，你必须编写一个在配置类中创建所需类型对象的方 法，并使用 `@Bean` 注解该方法。让我们看看在 `AppConfig`
    类中做出的以下更改来声明豆类：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding configuration file, I declared three methods to create instances
    for `TransferService`, `AccountRepository`, and `TransferRepository`. These methods
    are annotated with the `@Bean` annotation to indicate that they are responsible
    for instantiating, configuring, and initializing a new object to be managed by
    the Spring IoC container. Each bean in the container has a unique bean ID; by
    default, a bean has an ID same as the `@Bean` annotated method name. In the preceding
    case, the beans will be named as `transferService`, `accountRepository`, and `transferRepository`.
    You can also override that default behavior by using the name attribute of the
    `@Bean` annotation as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配置文件中，我声明了三个方法来创建 `TransferService`、`AccountRepository` 和 `TransferRepository`
    的实例。这些方法被 `@Bean` 注解标记，表示它们负责实例化、配置和初始化一个将被 Spring IoC 容器管理的新对象。容器中的每个豆都有一个唯一的豆
    ID；默认情况下，豆的 ID 与 `@Bean` 注解的方法名相同。在前面的例子中，豆将被命名为 `transferService`、`accountRepository`
    和 `transferRepository`。你也可以通过使用 `@Bean` 注解的 name 属性来覆盖默认行为，如下所示：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now `"service"` is the bean name of that bean `TransferService`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `"service"` 是该豆 `TransferService` 的豆名。
- en: Let's see how you can inject dependencies for the `TransferService`, `AccountRepository`,
    and `TransferRepository` beans in `AppConfig`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在 `AppConfig` 中为 `TransferService`、`AccountRepository` 和 `TransferRepository`
    豆类注入依赖关系。
- en: Injecting Spring beans
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注入 Spring 豆类
- en: 'In the preceding code, I declared the beans `TransferService`, `AccountRepository`,
    and `TransferRepository`; these beans had no dependencies. But, actually, the
    `TransferService` bean depends on `AccountRepository` and `TransferRepository`.
    Let''s see the following changes made in the `AppConfig` class to declare the
    beans:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我声明了 `TransferService`、`AccountRepository` 和 `TransferRepository` 这三个豆类；这些豆类没有依赖关系。但实际上，`TransferService`
    豆类依赖于 `AccountRepository` 和 `TransferRepository`。让我们看看在 `AppConfig` 类中做出的以下更改来声明这些豆类：
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding example, the simplest way to wire up beans in a Java-based
    configuration is to refer to the referenced bean's method. The `transferService()`
    method constructs the instance of the `TransferServiceImpl` class by calling the
    arguments constructor that takes `AccountRepository` and `TransferRepository`.
    Here, it seems that the constructor of the `TransferServiceImpl` class is calling
    the `accountRepository()` and `transferRepository()` methods to create instances
    of `AccountRepository` and `TransferRepository` respectively, but it is not an
    actual call to create instances. The Spring container creates instances of `AccountRepository`
    and `TransferRepository`, because the `accountRepository()` and `transferRepository()`
    methods are annotated with the `@Bean` annotation. Any call to the bean method
    by another bean method will be intercepted by Spring to ensure the default singleton
    scope (this will be discussed further in [Chapter 5](d0375506-d940-4fe5-bc09-d1033eed2986.xhtml),
    *Understanding the Bean Life cycle and Used Patterns*) of the Spring beans by
    that method is returned rather than allowing it to be invoked again.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，在基于Java的配置中连接豆子的最简单方法是通过引用所引用的bean的方法。`transferService()`方法通过调用接受`AccountRepository`和`TransferRepository`作为参数的构造函数来构建`TransferServiceImpl`类的实例。在这里，似乎`TransferServiceImpl`类的构造函数通过调用`accountRepository()`和`transferRepository()`方法来分别创建`AccountRepository`和`TransferRepository`的实例，但这并不是实际创建实例的调用。Spring容器创建了`AccountRepository`和`TransferRepository`的实例，因为`accountRepository()`和`transferRepository()`方法被注解了`@Bean`。任何其他bean方法对bean方法的调用都将被Spring拦截，以确保通过该方法返回Spring
    beans的默认单例作用域（这将在[第5章](d0375506-d940-4fe5-bc09-d1033eed2986.xhtml)，*理解Bean生命周期和使用的模式*）而不是允许它再次被调用。
- en: Best approach to configure the dependency injection pattern with Java
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Java配置依赖注入模式的最佳方法
- en: 'In the previous configuration example, I declared the `transferService()` bean
    method to construct an instance of the `TransferServiceImpl` class by using its
    arguments constructor. The bean methods, `accountRepository()` and `transferRepository()`,
    are passed as arguments of the constructor. But in an enterprise application,
    a lot of configuration files depend on the layers of the application architecture.
    Suppose the service layer and the infrastructure layer have their own configuration
    files. That means that the `accountRepository()` and `transferRepository()` methods
    may be in different configuration files, and the `transferService()` bean method
    may be in another configuration file. Passing bean methods into the constructor
    is not a good practice for configuration of the dependency injection pattern with
    Java. Let''s see a different and the best approach to configuring the dependency
    injection:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配置示例中，我声明了`transferService()`bean方法通过使用其参数构造函数来构建`TransferServiceImpl`类的实例。bean方法`accountRepository()`和`transferRepository()`作为构造函数的参数传递。但在企业应用中，许多配置文件依赖于应用程序架构的层。假设服务层和基础设施层有自己的配置文件。这意味着`accountRepository()`和`transferRepository()`方法可能位于不同的配置文件中，而`transferService()`bean方法可能位于另一个配置文件中。将bean方法传递给构造函数不是使用Java进行依赖注入模式配置的好做法。让我们看看配置依赖注入的最佳不同方法：
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, the `transferService()` method asks for `AccountRepository`
    and `TransferRepository` as parameters. When Spring calls `transferService()`
    to create the `TransferService` bean, it autowires `AccountRepository` and `TransferRepository`
    into the configuration method. With this approach, the `transferService()` method
    can still inject `AccountRepository` and `TransferRepository` into the constructor
    of `TransferServiceImpl` without explicitly referring to the `accountRepository()`
    and `transferRepository()``@Bean` methods.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`transferService()`方法请求`AccountRepository`和`TransferRepository`作为参数。当Spring调用`transferService()`来创建`TransferService`bean时，它会自动将`AccountRepository`和`TransferRepository`注入到配置方法中。使用这种方法，`transferService()`方法仍然可以将`AccountRepository`和`TransferRepository`注入到`TransferServiceImpl`的构造函数中，而不需要明确引用`accountrepository()`和`transferrepository()``@Bean`方法。
- en: Let's now take a look at dependency injection pattern with XML-based configuration.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看基于XML的配置的依赖注入模式。
- en: Dependency injection pattern with XML-based configuration
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于XML的配置的依赖注入模式
- en: Spring provides dependency injection with XML-based configuration from the very
    beginning. It is the primary way of configuring a Spring application. According
    to me, every developer should have an understanding of how to use XML with a Spring
    application. In this section, I am going to explain the same example as discussed
    in the previous section of Java-based configuration with reference to XML-based
    configuration.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 从一开始就提供了基于 XML 的配置依赖注入。这是配置 Spring 应用程序的主要方式。据我所知，每个开发者都应该了解如何使用 XML
    与 Spring 应用程序一起使用。在本节中，我将参考基于 XML 的配置，解释与前面基于 Java 配置的章节中讨论的相同示例。
- en: Creating an XML configuration file
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 XML 配置文件
- en: 'In the section on Java-based configuration, we had created an `AppConfig` class
    annotated with the `@Configuration` annotation. Similarly, for XML-based configuration,
    we will now create an `applicationContext.xml` file rooted with a `<beans>` element.
    The following simplest possible example shows the basic structure of XML-based
    configuration metadata:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于 Java 配置的章节中，我们创建了一个带有 `@Configuration` 注解的 `AppConfig` 类。同样，对于基于 XML 的配置，我们现在将创建一个以
    `<beans>` 元素为根的 `applicationContext.xml` 文件。以下最简单的示例显示了基于 XML 的配置元数据的基本结构：
- en: 'Following is the `applicationContext.xml` file:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 `applicationContext.xml` 文件：
- en: '[PRE14]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding XML file is a configuration file of the application which contains
    the details on bean definitions. This file is also loaded by the XML-flavored
    implementation of `ApplicationContext` to create beans for your application. Let's
    see how you can declare the `TransferService`, `AccountRepository` and `TransferRepository`
    beans in the preceding XML file.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 XML 文件是应用程序的配置文件，其中包含有关 Bean 定义的具体信息。此文件也由 `ApplicationContext` 的 XML 风格实现加载，以为您应用程序创建
    Bean。让我们看看如何在前面提到的 XML 文件中声明 `TransferService`、`AccountRepository` 和 `TransferRepository`
    Bean。
- en: Declaring Spring beans in an XML file
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 XML 文件中声明 Spring Bean
- en: 'As with Java, we have to declare a class as a Spring bean into Spring''s XML-based
    configuration by using an element of the Spring-beans schema as a `<bean>` element.
    The `<bean>` element is the XML analogue to JavaConfig''s `@Bean` annotation.
    We add the following configuration to the XML-based configuration file:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Java 一样，我们必须通过使用 Spring 的基于 XML 的配置中的 Spring-beans 架构元素作为 `<bean>` 元素来将一个类声明为
    Spring Bean。`<bean>` 元素是 JavaConfig 的 `@Bean` 注解的 XML 类似物。我们向基于 XML 的配置文件添加以下配置：
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code, I have created a very simple bean definition. In this
    configuration, the `<bean>` element has an `id` attribute to identify the individual
    bean definition. The `class` attribute is expressed as the fully qualified class
    name to create this bean. The value of the `id` attribute refers to collaborating
    objects. So let's see how to configure the collaborating beans to resolve the
    dependencies in the application.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我创建了一个非常简单的 Bean 定义。在这个配置中，`<bean>` 元素有一个 `id` 属性来标识单个 Bean 定义。`class`
    属性表示为完全限定的类名，以创建此 Bean。`id` 属性的值指的是协作对象。因此，让我们看看如何配置协作 Bean 以解决应用程序中的依赖关系。
- en: Injecting Spring beans
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注入 Spring Bean
- en: 'Spring provides these two ways to define the DI pattern to inject the dependency
    with the dependent bean in an application:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 提供了这两种方式来定义 DI 模式，以在应用程序中将依赖项注入到依赖 Bean 中：
- en: Using constructor injection
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用构造函数注入
- en: Using setter injection
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用设置器注入
- en: Using constructor injection
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用构造函数注入
- en: 'For the DI pattern with the construction injection, Spring provides you two
    basic options as the `<constructor-arg>` element and c-namespace introduced in
    Spring 3.0\. c-namespace has less verbosity in the application, which is the only
    difference between them--you can choose any one. Let''s inject the collaborating
    beans with the construction injection as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于构造函数注入的 DI 模式，Spring 提供了两个基本选项，即 `<constructor-arg>` 元素和 Spring 3.0 中引入的 c-namespace。c-namespace
    在应用程序中具有更少的冗余，这是它们之间的唯一区别--你可以选择任何一个。以下是如何使用构造函数注入注入协作 Bean 的示例：
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding configuration, the `<bean>` element of `TransferService` has
    two `<constructor-arg>.` This tells it to pass a reference to the beans whose
    IDs are `accountRepository` and `transferRepository` to the constructor of `TransferServiceImpl`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配置中，`TransferService` 的 `<bean>` 元素有两个 `<constructor-arg>`。这表示它需要将 ID 为
    `accountRepository` 和 `transferRepository` 的 Bean 的引用传递给 `TransferServiceImpl`
    的构造函数。
- en: 'As of Spring 3.0, the c-namespace, similarly, has a more succinct way of expressing
    constructor args in XML. For using this namespace, we have to add its schema in
    the XML file, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 Spring 3.0，c-namespace 类似地，在 XML 中表达构造函数参数有更简洁的方式。为了使用此命名空间，我们必须在 XML 文件中添加其模式，如下所示：
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let's see how to set up these dependencies with the setter injection.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用设置注入来设置这些依赖项。
- en: Using setter injection
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用设置注入
- en: 'Using the injection, Spring also provides you with two basic options as the
    `<property>` element and p-namespace introduced in Spring 3.0\. The p-namespace
    also reduced verbosity of code in the application, which is the only difference
    between them, you can choose any one. Let''s inject the collaborating beans with
    the setter injection as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用注入，Spring 还提供了两种基本选项，即 `<property>` 元素和 Spring 3.0 中引入的 p-namespace。p-namespace
    还减少了应用程序中的代码冗余，这是它们之间的唯一区别，您可以选择任何一个。让我们按照以下方式使用设置注入注入协作 bean：
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the preceding configuration, the `<bean>` element of `TransferService` has
    two `<property>` elements which tell it to pass a reference to the beans whose
    IDs are `accountRepository` and `transferRepository` to the setter methods of
    `TransferServiceImpl`, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配置中，`TransferService` 的 `<bean>` 元素有两个 `<property>` 元素，它告诉它将 `accountRepository`
    和 `transferRepository` 这两个 ID 的 bean 的引用传递给 `TransferServiceImpl` 的设置方法，如下所示：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding file, if you use this Spring bean without setter methods, the
    properties `accountRepository` and `transferRepository` will be initialized as
    null without injecting the dependency.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的文件中，如果您使用此 Spring bean 而没有设置方法，则 `accountRepository` 和 `transferRepository`
    属性将被初始化为 null，而没有注入依赖项。
- en: 'As of Spring 3.0, the p-namespace, similarly, has a more succinct way of expressing
    property in XML. For using this namespace, we have to add its schema in the XML
    file as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 Spring 3.0，p-namespace 类似地，在 XML 中表达属性有更简洁的方式。为了使用此命名空间，我们必须在 XML 文件中添加其模式，如下所示：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Let's now take a look at the dependency injection pattern with Annotation-based
    configuration.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看基于注解配置的依赖注入模式。
- en: Dependency injection pattern with Annotation-based configuration
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于注解的配置的依赖注入模式
- en: As discussed in the previous two sections, we defined the DI pattern with Java-and
    XML-based configurations, and these two options define dependencies explicitly.
    It creates the Spring beans by using either the `@Bean` annotated method in the
    `AppConfig` Java file, or the `<bean>` element tag in the XML configuration file.
    By these methods, you can also create the bean for those classes which lie outside
    the application, that is, classes that exist in third-party libraries. Now let's
    discuss another way to create Spring beans, and define the dependencies between
    them by using implicit configuration through the Stereotype annotations.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如前两个部分所讨论的，我们定义了基于 Java 和 XML 配置的 DI 模式，这两个选项明确定义了依赖关系。它通过在 `AppConfig` Java
    文件中使用 `@Bean` 注解的方法或 XML 配置文件中的 `<bean>` 元素标签来创建 Spring bean。通过这些方法，您还可以为那些位于应用程序之外的类创建
    bean，即存在于第三方库中的类。现在让我们讨论另一种创建 Spring bean 的方法，通过使用类型注解的隐式配置来定义它们之间的依赖关系。
- en: What are Stereotype annotations?
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是类型注解？
- en: 'The Spring Framework provides you with some special annotations. These annotations
    are used to create Spring beans automatically in the application context. The
    main stereotype annotation is `@Component`. By using this annotation, Spring provides
    more Stereotype meta annotations such as `@Service`, used to create Spring beans
    at the Service layer, `@Repository`, which is used to create Spring beans for
    the repositories at the DAO layer, and `@Controller`, which is used to create
    Spring beans at the controller layer. This is depicted in the following diagram:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 框架为您提供了一些特殊的注解。这些注解用于在应用程序上下文中自动创建 Spring bean。主要的类型注解是 `@Component`。通过使用此注解，Spring
    提供了更多类型元注解，如 `@Service`，用于在服务层创建 Spring bean，`@Repository`，用于在 DAO 层创建用于存储库的 Spring
    bean，以及 `@Controller`，用于在控制层创建 Spring bean。这在上面的图中有所展示：
- en: '![](img/6fd97786-73e6-4b3d-841d-8954bd1658b4.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6fd97786-73e6-4b3d-841d-8954bd1658b4.png)'
- en: 'By using these annotations, Spring creates automatic wiring in these two ways:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这些注解，Spring 以以下两种方式创建自动连接：
- en: '**Component scanning:** In this, Spring automatically searches the beans to
    be created in the Spring IoC container'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件扫描**：在这种情况下，Spring 会自动搜索 Spring IoC 容器中要创建的 bean'
- en: '**Autowiring:** In this, Spring automatically searches the bean dependencies
    in the Spring IoC container'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动装配**：在这个中，Spring 会自动在 Spring IoC 容器中搜索 bean 依赖项'
- en: Implicitly, the DI pattern configuration reduces the verbosity of an application,
    and minimizes explicit configuration. Let's demonstrate component scanning and
    autowiring in the same example as discussed previously. Here, Spring will create
    the beans for `TransferService`, `TransferRepository`, and `AccountRepository`
    by discovering them, and automatically inject them to each other as per the defined
    dependencies.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式地，DI 模式配置减少了应用的冗余，并最小化了显式配置。让我们通过之前讨论的相同示例来演示组件扫描和自动装配。在这里，Spring 将通过发现它们来创建
    `TransferService`、`TransferRepository` 和 `AccountRepository` 的 bean，并按照定义的依赖关系自动将它们注入到对方。
- en: Creating auto searchable beans using Stereotype annotations
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Stereotype 注解创建可自动搜索的 bean
- en: 'Let''s see the following `TransferService` interface. Its implementation is
    annotated with `@Component`. Please refer to the following code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的 `TransferService` 接口。它的实现使用了 `@Component` 注解。请参考以下代码：
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding interface is not important for this approach of configuration--I
    have taken it just for loose coupling in the application. Let''s see its implementation,
    which is as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的接口对于这种配置方法并不重要--我只是为了在应用中实现松耦合而取的。让我们看看它的实现，如下所示：
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can see in the preceding code that `TransferServiceImpl` is annotated with
    the `@Component` annotation. This annotation is used to identify this class as
    a component class, which means, it is eligible to scan and create a bean of this
    class. Now there is no need to configure this class explicitly as a bean either
    by using XML or Java configuration--Spring is now responsible for creating the
    bean of the `TransferServiceImpl` class, because it is annotated with `@Component`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在前面的代码中看到 `TransferServiceImpl` 使用了 `@Component` 注解。这个注解用于标识这个类为一个组件类，这意味着，它有资格被扫描并创建这个类的
    bean。现在没有必要通过使用 XML 或 Java 配置来显式配置这个类作为一个 bean 了--Spring 现在负责创建 `TransferServiceImpl`
    类的 bean，因为它使用了 `@Component` 注解。
- en: 'As mentioned earlier, Spring provides us meta annotations for the `@Component`
    annotation as `@Service`, `@Repository`, and `@Controller`. These annotations
    are based on a specific responsibility at different layers of the application.
    Here, `TransferService` is the service layer class; *as a best practice of Spring
    configuration*, we have to annotate this class with the specific annotation, `@Service`,
    rather than with the generic annotation, `@Component`, to create the bean of this
    class. The following is the code for the same class annotated with the `@Service`
    annotation:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Spring 为 `@Component` 注解提供了元注解，如 `@Service`、`@Repository` 和 `@Controller`。这些注解基于应用不同层的特定责任。在这里，`TransferService`
    是服务层类；*作为 Spring 配置的最佳实践*，我们必须使用特定的注解 `@Service` 来标注这个类，而不是使用通用的注解 `@Component`
    来创建这个类的 bean。以下是这个类使用 `@Service` 注解的代码：
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Let's see other classes in the application--these are the `implementation` classes
    of `AccountRepository`--and the `TransferRepository` interfaces are the repositories
    working at the DAO layer of the application. *As a best practice**,* these classes
    should be annotated with the `@Repository` annotation rather than using the `@Component`
    annotation as shown next.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看应用中的其他类--这些是 `AccountRepository` 的实现类--以及 `TransferRepository` 接口是应用 DAO
    层工作的仓库。*作为最佳实践**，这些类应该使用 `@Repository` 注解而不是像下面展示的那样使用 `@Component` 注解。
- en: '`JdbcAccountRepository.java` implements the `AccountRepository` interface:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`JdbcAccountRepository.java` 实现了 `AccountRepository` 接口：'
- en: '[PRE24]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And `JdbcTransferRepository.java` implements the `TransferRepository` interface:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 并且 `JdbcTransferRepository.java` 实现了 `TransferRepository` 接口：
- en: '[PRE25]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In Spring, you have to enable component scanning in your application, because
    it is not enabled by default. You have to create a configuration Java file, and
    annotate it with `@Configuration` and `@ComponentScan`. This class is used to
    search out classes annotated with `@Component`, and to create beans from them.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spring 中，你必须在你的应用中启用组件扫描，因为它默认是禁用的。你必须创建一个配置 Java 文件，并使用 `@Configuration`
    和 `@ComponentScan` 注解它。这个类用于搜索带有 `@Component` 注解的类，并从它们中创建 bean。
- en: Let's see how Spring scans the classes which are annotated with any stereotype
    annotations.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Spring 如何扫描带有任何 stereotypes 注解的类。
- en: Searching beans using component scanning
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组件扫描搜索 bean
- en: 'The following minimum configuration is required to search beans using component
    scanning in a Spring application:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组件扫描在 Spring 应用程序中搜索豆类所需的最小配置如下：
- en: '[PRE26]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `AppConfig` class defines a Spring wiring configuration class same as the
    Java-based Spring configuration in the previous section. There is one thing to
    be observed here--the `AppConfig` file has one more `@ComponentScan`, as earlier
    it had only the `@Configuration` annotation. The configuration file `AppConfig`
    is annotated with `@ComponentScan` to enable component scanning in Spring. The
    `@ComponentScan` annotation scans those classes that are annotated with `@Component`
    by default in the same package as the configuration class. Since the `AppConfig`
    class is in the `com.packt.patterninspring.chapter4.bankapp.config` package, Spring
    will scan only this package and its sub packages. But our component application
    classes are in the `com.packt.patterninspring.chapter1.bankapp.service` and `com.packt.patterninspring.chapter4.bankapp.repository.jdbc`
    packages, and these are not subpackages of `com.packt.patterninspring.chapter4.bankapp.config`.
    In this case, Spring allows to override the default package scanning of the `@ComponentScan`
    annotation by setting a base package for component scanning. Let''s specify a
    different base package. You only need to specify the package in the `value` attribute
    of `@ComponentScan`, as shown here:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppConfig` 类定义了一个与上一节中基于 Java 的 Spring 配置相同的 Spring 连接配置类。这里有一点需要注意--`AppConfig`
    文件有一个额外的 `@ComponentScan`，因为之前它只有 `@Configuration` 注解。配置文件 `AppConfig` 被注解为 `@ComponentScan`
    以启用 Spring 中的组件扫描。`@ComponentScan` 注解默认扫描与配置类同一包下被 `@Component` 注解的类。由于 `AppConfig`
    类位于 `com.packt.patterninspring.chapter4.bankapp.config` 包中，Spring 将仅扫描此包及其子包。但我们的组件应用程序类位于
    `com.packt.patterninspring.chapter1.bankapp.service` 和 `com.packt.patterninspring.chapter4.bankapp.repository.jdbc`
    包中，而这些不是 `com.packt.patterninspring.chapter4.bankapp.config` 的子包。在这种情况下，Spring
    允许通过设置组件扫描的基础包来覆盖 `@ComponentScan` 注解的默认包扫描。让我们指定一个不同的基础包。你只需要在 `@ComponentScan`
    的 `value` 属性中指定包，如下所示：'
- en: '[PRE27]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Or you can define the base packages with the `basePackages` attribute, as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用 `basePackages` 属性定义基础包，如下所示：
- en: '[PRE28]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the `@ComponentScan` annotation, the `basePackages` attribute can accept
    an array of Strings, which means that we can define multiple base packages to
    scan component classes in the application. In the previous configuration file,
    Spring will scan all classes of `com.packt.patterninspring.chapter4.bankapp package`,
    and all the subpackages underneath this package. *As a best practice,* always
    define the specific base packages where the components classes exist. For example,
    in the following code, I define the base packages for the service and repository
    components:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `@ComponentScan` 注解中，`basePackages` 属性可以接受一个字符串数组，这意味着我们可以定义多个基础包以扫描应用程序中的组件类。在之前的配置文件中，Spring
    将扫描 `com.packt.patterninspring.chapter4.bankapp` 包下的所有类，以及此包下的所有子包。*作为最佳实践，* 总是定义组件类存在的基础包。例如，在以下代码中，我定义了服务和存储库组件的基础包：
- en: '[PRE29]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now Spring scans only `com.packt.patterninspring.chapter4.bankapp.repository.jdbc`
    and `com.packt.patterninspring.chapter4.bankapp.service packages`, and its subpackages
    if they exist. instead of doing a wide range scanning like in the earlier examples.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Spring 只扫描 `com.packt.patterninspring.chapter4.bankapp.repository.jdbc` 和
    `com.packt.patterninspring.chapter4.bankapp.service` 包，以及如果存在的话，它们的子包。而不是像早期示例中那样进行广泛的扫描。
- en: 'Rather than specify the packages as simple String values of the `basePackages`
    attribute of `@ComponentScan`, Spring allows you to specify them via classes or
    interfaces as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 与将 `@ComponentScan` 的 `basePackages` 属性指定为简单的字符串值相比，Spring 允许你通过以下方式指定它们：
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see in the preceding code, the `basePackages` attribute has been
    replaced with `basePackageClasses`. Now Spring will identify the component classes
    in those packages where `basePackageClasses` will be used as the base package
    for component scanning.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，`basePackages` 属性已被替换为 `basePackageClasses`。现在 Spring 将识别那些将使用 `basePackageClasses`
    作为组件扫描基础包的包中的组件类。
- en: 'It should find the `TransferServiceImpl`, `JdbcAccountRepository`, and `JdbcTransferRepository`
    classes, and automatically create the beans for these classes in the Spring container.
    Explicitly, there is no need to define the bean methods for these classes to create
    Spring beans. Let''s turn on component scanning via XML configuration, then you
    can use the `<context:component-scan>` element from Spring''s context namespace.
    Here is a minimal XML configuration to enable component scanning:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该找到`TransferServiceImpl`、`JdbcAccountRepository`和`JdbcTransferRepository`类，并在Spring容器中自动创建这些类的bean。明确地说，没有必要为这些类定义创建Spring
    bean的方法。让我们通过XML配置打开组件扫描，然后你可以使用Spring的context命名空间中的`<context:component-scan>`元素。以下是一个启用组件扫描的最小XML配置：
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding XML file, the `<context:component-scan>` element is same the
    `@ComponentScan` annotation in the Java-based configuration for component scanning.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的XML文件中，`<context:component-scan>`元素与基于Java的配置中的`@ComponentScan`注解相同。
- en: Annotating beans for autowiring
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为自动连接注解bean
- en: Spring provides support for automatic bean wiring. This means that Spring automatically
    resolves the dependencies that are required by the dependent bean by finding other
    collaborating beans in the application context. Bean Autowiring is another way
    of DI pattern configuration. It reduces verbosity in the application, but the
    configuration is spread throughout the application. Spring's `@Autowired` annotation
    is used for auto bean wiring. This `@Autowired` annotation indicates that autowiring
    should be performed for this bean.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了自动bean连接的支持。这意味着Spring会通过在应用上下文中查找其他协作bean来自动解决依赖bean所需的依赖。Bean自动连接是DI模式配置的另一种方式。它减少了应用程序的冗余，但配置分散在整个应用程序中。Spring的`@Autowired`注解用于自动bean连接。这个`@Autowired`注解表示应该为这个bean执行自动连接。
- en: 'In our example, we have `TransferService` which has dependencies of `AccountRepository`
    and `TransferRepository`. Its constructor is annotated with `@Autowired` indicating
    that when Spring creates the `TransferService` bean, it should instantiate that
    bean by using its annotated constructor, and pass in two other beans, `AccountRepository`
    and `TransferRepository`, which are dependencies of the `TransferService` bean.
    Let''s see the following code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们有一个`TransferService`，它依赖于`AccountRepository`和`TransferRepository`。它的构造函数被`@Autowired`注解，表示当Spring创建`TransferService`bean时，它应该通过使用注解的构造函数来实例化这个bean，并传入两个其他bean，即`AccountRepository`和`TransferRepository`，它们是`TransferService`bean的依赖。让我们看看以下代码：
- en: '[PRE32]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note--As of Spring 4.3, the `@Autowired` annotation is no more required if you
    define only one construct with arguments in that class. If class has multiple
    argument constructors, then you have to use the `@Autowired` annotation on any
    one of them.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 注意--截至Spring 4.3版本，如果你在那个类中只定义了一个带有参数的构造函数，那么就不再需要`@Autowired`注解。如果一个类有多个参数构造函数，那么你必须在这其中的任何一个上使用`@Autowired`注解。
- en: The `@Autowired` annotation is not limited to the construction; it can be used
    with the setter method, and can also be used directly in the field, that is, an
    `autowired` class property directly. Let's see the following line of code for
    setter and field injection.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Autowired`注解不仅限于构造函数；它可以与setter方法一起使用，也可以直接在字段中使用，即一个`autowired`类属性直接。让我们看看以下代码行，用于setter和字段注入。'
- en: Using @Autowired with setter method
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用setter方法`@Autowired`
- en: 'Here you can annotate the setter method''s `setAccountRepository` and `setTransferRepository`
    with the `@Autowired` annotation. This annotation can be used with any method.
    There is no specific reason to use it with the setter method only. Please refer
    to the following code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以使用`@Autowired`注解来注释setter方法`setAccountRepository`和`setTransferRepository`。这个注解可以用于任何方法。没有特别的原因只能用它来注释setter方法。请参考以下代码：
- en: '[PRE33]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Using @Autowired with the fields
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`@Autowired`注解字段
- en: 'Here you can annotate those class properties which are required for this class
    to achieve a business goal. Let''s see the following code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以注释那些对于实现业务目标所必需的类属性。让我们看看以下代码：
- en: '[PRE34]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the preceding code, the `@Autowired` annotation resolves the dependency
    by `type` and then by `name` if the property name is the same as the bean name
    in the Spring container. By default, the `@Autowired` dependency is a required
    dependency--it raises an exception if the dependency is not resolved, it doesn''t
    matter whether we have used it with a constructor or with the setter method. You
    can override the required behavior of the `@Autowired` annotation by using the
    `required` attribute of this annotation. You can set this attribute with the Boolean
    value `false` as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`@Autowired` 注解通过 `type` 解析依赖关系，如果属性名称与 Spring 容器中 bean 的名称相同，则通过 `name`
    解析。默认情况下，`@Autowired` 依赖关系是一个必需的依赖关系——如果依赖关系未解析，则会抛出异常，无论我们是否使用构造函数或设置方法。您可以通过使用此注解的
    `required` 属性来覆盖 `@Autowired` 注解的必需行为。您可以通过将此属性设置为布尔值 `false` 来设置此属性，如下所示：
- en: '[PRE35]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding code, we have set the required attribute with the Boolean value
    `false`. In this case, Spring will attempt to perform autowiring, but if there
    are no matching beans, it will leave the bean unwired. But as a best practice
    of code, you should avoid setting its value as false until it is absolutely necessary.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的代码中，我们已经将 `required` 属性设置为布尔值 `false`。在这种情况下，Spring 将尝试执行自动装配，但如果没有匹配的
    bean，它将保留 bean 未连接。但作为代码的最佳实践，您应该避免将其值设置为 `false`，除非绝对必要。 '
- en: The Autowiring DI pattern and disambiguation
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动装配依赖注入模式及消除歧义
- en: 'The `@Autowiring` annotation reduces verbosity in the code, but it may create
    some problems when two of the same type of beans exist in the container. Let''s
    see what happens in that situation, with the following example:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Autowiring` 注解减少了代码的冗余，但当容器中存在两个相同类型的 bean 时，可能会产生一些问题。让我们看看在这种情况下会发生什么，以下是一个示例：'
- en: '[PRE36]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The preceding snippet of code shows that the `TransferServiceImpl` class has
    a dependency with a bean of type `AccountRepository`, but the Spring container
    contains two beans of the same type, that is, the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段显示，`TransferServiceImpl` 类依赖于一个类型为 `AccountRepository` 的 bean，但 Spring
    容器中包含两个相同类型的 bean，即以下内容：
- en: '[PRE37]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As seen from the preceding code, there are two implementations of the `AccountRepository`
    interface--one is `JdbcAccountRepository` and another is `JpaAccountRepository`.
    In this case, the Spring container will throw the following exception at startup
    time of the application:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的代码所示，存在 `AccountRepository` 接口的两个实现——一个是 `JdbcAccountRepository`，另一个是 `JpaAccountRepository`。在这种情况下，Spring
    容器将在应用程序启动时抛出以下异常：
- en: '[PRE38]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Resolving disambiguation in Autowiring DI pattern
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动装配依赖注入模式中的消除歧义
- en: 'Spring provides one more annotation, `@Qualifier`, to overcome the problem
    of disambiguation in autowiring DI. Let''s see the following snippet of code with
    the `@Qualifier` annotation:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 提供了一个额外的注解 `@Qualifier`，以克服自动装配依赖注入中的歧义问题。让我们看看以下带有 `@Qualifier` 注解的代码片段：
- en: '[PRE39]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now I have wired the dependency by name rather than by type by using the `@Qualifier`
    annotation. So, Spring will search the bean dependency with the name `"jdbcAccountRepository"`
    for the `TransferServiceImpl` class. I have given the names of the beans as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经通过使用 `@Qualifier` 注解按名称而不是按类型连接了依赖关系。因此，Spring 将为 `TransferServiceImpl`
    类搜索名为 `"jdbcAccountRepository"` 的 bean 依赖关系。我已经给出了以下 bean 名称：
- en: '[PRE40]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`@Qualifier`, also available with the method injection and field injection
    component names, should not show implementation details unless there are two implementations
    of the same interface.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Qualifier`，也适用于方法注入和字段注入的组件名称，除非存在相同接口的两个实现，否则不应显示实现细节。'
- en: Let's now discuss some best practices to choose the DI pattern configuration
    for your Spring application.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在讨论一些最佳实践，以选择适合您的 Spring 应用程序的 DI 模式配置。
- en: '**Resolving dependency with Abstract Factory pattern**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用抽象工厂模式解决依赖关系**'
- en: If you want to add the `if...else` conditional configuration for a bean, you
    can do so, and also add some custom logic if you are using Java configuration.
    But in the case of an XML configuration, it is not possible to add the `if...then...else`
    conditions. Spring provides the solution for conditions in an XML configuration
    by using the Abstract Factory Pattern. Use a factory to create the bean(s) you
    want, and use any complex Java code that you need in the factory's internal logic.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想为Bean添加`if...else`条件配置，你可以这样做，如果你使用Java配置，还可以添加一些自定义逻辑。但在XML配置的情况下，无法添加`if...then...else`条件。Spring通过使用抽象工厂模式为XML配置中的条件提供了解决方案。使用工厂创建你想要的Bean，并在工厂的内部逻辑中使用任何复杂的Java代码。
- en: Implementing the Abstract Factory Pattern in Spring (FactoryBean interface)
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Spring中实现抽象工厂模式（FactoryBean接口）
- en: The Spring Framework provides the `FactoryBean` interface as an implementation
    of the Abstract Factory Pattern. A `FactoryBean` is a pattern to encapsulate interesting
    object construction logic in a class. The `FactoryBean` interface provides a way
    to customize the Spring IoC container's instantiation logic. You can implement
    this interface for objects that are themselves factories. Beans implementing `FactoryBean`
    are auto-detected.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架提供了`FactoryBean`接口作为抽象工厂模式的实现。`FactoryBean`是一种封装有趣对象构建逻辑的模式的类。`FactoryBean`接口提供了一种定制Spring
    IoC容器实例化逻辑的方式。你可以为自身是工厂的对象实现此接口。实现`FactoryBean`接口的Bean会被自动检测。
- en: 'The definition of this interface is as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口的定义如下：
- en: '[PRE41]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As per the preceding definition of this interface, the dependency injection
    using the FactoryBean and it causes `getObject()` to be invoked transparently.
    The `isSingleton()` method returns `true` for singleton, else it returns `false`.
    The `getObjectType()` method returns the object type of the object returned by
    the `getObject()` method.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 根据此接口的前面定义，使用FactoryBean进行依赖注入会导致`getObject()`方法透明地被调用。`isSingleton()`方法对于单例返回`true`，否则返回`false`。`getObjectType()`方法返回`getObject()`方法返回的对象类型。
- en: Implementation of FactoryBean interface in Spring
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring中FactoryBean接口的实现
- en: '`FactoryBean` is widely used within Spring as the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`FactoryBean`在Spring中被广泛使用，如下所示：'
- en: '`EmbeddedDatabaseFactoryBean`'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EmbeddedDatabaseFactoryBean`'
- en: '`JndiObjectFactoryBean`'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JndiObjectFactoryBean`'
- en: '`LocalContainerEntityManagerFactoryBean`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalContainerEntityManagerFactoryBean`'
- en: '`DateTimeFormatterFactoryBean`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DateTimeFormatterFactoryBean`'
- en: '`ProxyFactoryBean`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProxyFactoryBean`'
- en: '`TransactionProxyFactoryBean`'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TransactionProxyFactoryBean`'
- en: '`MethodInvokingFactoryBean`'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MethodInvokingFactoryBean`'
- en: Sample implementation of FactoryBean interface
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FactoryBean接口的示例实现
- en: 'Suppose you have a `TransferService` class whose definition is thus:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个`TransferService`类，其定义如下：
- en: '[PRE42]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'And you have a `FactoryBean` whose definition is thus:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个定义如下`FactoryBean`：
- en: '[PRE43]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You could wire up an `AccountRepository` instance using a hypothetical `AccountRepositoryFactoryBean`
    like this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用假设的`AccountRepositoryFactoryBean`像这样连接`AccountRepository`实例：
- en: '[PRE44]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the preceding example, the `TransferService` class depends on the `AccountRepository`
    bean, but in the XML file, we have defined `AccountRepositoryFactoryBean` as an
    `accountRepository` bean. The `AccountRepositoryFactoryBean` class implements
    the `FactoryBean` interface of Spring. The result of the `getObject` method of
    `FactoryBean` will be passed, and not the actual `FactoryBean` itself. Spring
    injects that object returned by `FactoryBean`'s `getObjectType()` method, and
    the object type returned by `FactoryBean`'s `getObjectType()`; the scope of this
    bean is decided by the `FactoryBean`'s `isSingleton()` method.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`TransferService`类依赖于`AccountRepository` Bean，但在XML文件中，我们已将`AccountRepositoryFactoryBean`定义为`accountRepository`
    Bean。`AccountRepositoryFactoryBean`类实现了Spring的`FactoryBean`接口。`FactoryBean`的`getObject`方法的结果将被传递，而不是实际的`FactoryBean`本身。Spring通过注入`FactoryBean`的`getObjectType()`方法返回的对象，以及`FactoryBean`的`getObjectType()`方法返回的对象类型；此Bean的作用域由`FactoryBean`的`isSingleton()`方法决定。
- en: 'The following is the same configuration for the `FactoryBean` interface in
    a Java Configuration:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在Java配置中`FactoryBean`接口的相同配置：
- en: '[PRE45]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As other normal beans in the Spring container, the Spring `FactoryBean` also
    has all the other characteristics of any other Spring bean, including the life
    cycle hooks and services that all beans in the Spring container enjoy.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Spring容器中的其他正常Bean，Spring的`FactoryBean`也具有任何其他Spring Bean的所有其他特性，包括所有Spring容器中的Bean都享有的生命周期钩子和服务。
- en: Best practices for configuring the DI pattern
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置DI模式的最佳实践
- en: 'The following are the best practices for configuring the DI pattern:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为配置DI模式的最佳实践：
- en: Configuration files should be separated categorically. Application beans should
    be separate from infrastructure beans. Currently, it's a bit difficult to follow.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文件应按类别分开。应用bean应与基础设施bean分开。目前，这有点难以遵循。
- en: '![](img/0eb74c9e-0a6f-4709-8d4b-76723d2651c5.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0eb74c9e-0a6f-4709-8d4b-76723d2651c5.png)'
- en: Always specify the component name; never rely on generated names by the container.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是指定组件名称；永远不要依赖容器生成的名称。
- en: It is a best practice to give a name along with a description of what the pattern
    does, where to apply it, and the problems it addresses.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给出模式的功能描述、应用位置和解决的问题的名称是一个最佳实践。
- en: 'The best practices for component scanning are as follows:'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件扫描的最佳实践如下：
- en: The components are scanned at startup, and it scans the JAR dependencies as
    well.
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件在启动时扫描，并且它还扫描JAR依赖项。
- en: '**Bad practice:** It scans all the packages of `com` and `org`. It increases
    the startup time of the application. Avoid such type of component scanning:'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不良实践：**它扫描了`com`和`org`的所有包。这增加了应用程序的启动时间。避免此类组件扫描：'
- en: '[PRE46]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '**Optimized:** It scans only the specific packages as defined by us.'
  id: totrans-276
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化：**它只扫描我们定义的特定包。'
- en: '[PRE47]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Best practices in choosing implicit configuration:'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择隐式配置的最佳实践：
- en: Choose annotation-based configurations for frequently changing beans
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为经常更改的bean选择基于注解的配置
- en: It allows for very rapid development
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许非常快速的开发
- en: It is a single place to edit the configuration
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个编辑配置的单一点
- en: 'Best practices in choosing explicit via Java configuration:'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Java配置选择显式的最佳实践：
- en: It is centralized in one place
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它集中在一个地方
- en: Strong type checking enforced by the compiler
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器强制执行的强类型检查
- en: Can be used for all classes
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以用于所有类
- en: 'Spring XML Best Practices: XML has been around for a long time, there are many
    shortcuts and useful techniques available in XML configuration as well, they are
    listed follow:'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring XML最佳实践：XML已经存在很长时间了，XML配置中有很多快捷方式和有用的技术，它们如下列出：
- en: factory-method and factory-bean attributes
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂方法（factory-method）和工厂bean（factory-bean）属性
- en: Bean Definition Inheritance
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bean定义继承
- en: Inner Beans
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部Bean
- en: p and c namespaces
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: p和c命名空间
- en: Using collections as Spring beans
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将集合用作Spring Bean
- en: Summary
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: After reading this chapter, you should now have a good idea about DI design
    patterns, and the best practices for applying those patterns. Spring deals with
    the plumbing part, so, you can focus on solving the domain problem by using the
    dependency injection pattern. The DI pattern frees the object of the burden of
    resolving its dependencies. Your object is handed everything that it needs to
    work. The DI pattern simplifies your code, improves code reusability, and testability.
    It promotes programming to interfaces, and conceals the implementation details
    of dependencies. The DI pattern allows for centralized control over the object's
    life cycle. You can configure DI via two ways--explicit configuration and implicit
    configuration. Explicit configuration can be configured through XML-or Java-based
    configuration; it provides centralized configuration. But implicit configuration
    is based on annotations. Spring provides stereotype annotations for Annotation-based
    configuration. This configuration reduces the verbosity of code in the application,
    but it spreads out across the application files.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章之后，你现在应该对DI设计模式以及应用这些模式的最佳实践有一个很好的了解。Spring处理管道部分，因此，你可以通过使用依赖注入模式来专注于解决领域问题。DI模式释放了对象解决其依赖关系的负担。你的对象得到了它工作所需的一切。DI模式简化了你的代码，提高了代码的可重用性和可测试性。它促进了面向接口的编程，并隐藏了依赖项的实现细节。DI模式允许集中控制对象的生命周期。你可以通过两种方式配置DI——显式配置和隐式配置。显式配置可以通过XML或基于Java的配置进行配置；它提供集中式配置。但隐式配置基于注解。Spring为基于注解的配置提供了类型化注解。这种配置减少了应用程序中代码的冗长性，但它分散在应用程序文件中。
- en: In the upcoming [Chapter 5](d0375506-d940-4fe5-bc09-d1033eed2986.xhtml), *Understanding
    the Bean Life Cycle and Used Patterns*, we will explore the life cycle of the
    Spring bean in the container.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在即将到来的[第5章](d0375506-d940-4fe5-bc09-d1033eed2986.xhtml)《理解Bean生命周期和使用的模式》中，我们将探讨Spring容器中Spring
    bean的生命周期。
