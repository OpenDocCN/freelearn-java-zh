- en: Chapter 1. Learning Java 9 Underlying Performance Improvements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章：学习 Java 9 的底层性能改进
- en: Just when you think you have a handle on lambdas and all the performance-related
    features of Java 8, along comes Java 9\. What follows are several of the capabilities
    that made it into Java 9 that you can use to help improve the performance of your
    applications. These go beyond byte-level changes like for string storage or garbage
    collection changes, which you have little control over. Also, ignore implementation
    changes like those for faster object locking, since you don't have to do anything
    differently and you automatically get these improvements. Instead, there are new
    library features and completely new command-line tools that will help you create
    apps quickly.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当你认为你已经掌握了 lambda 和 Java 8 中所有与性能相关的特性时，Java 9 就出现了。以下是一些被纳入 Java 9 的功能，你可以使用它们来帮助提高应用程序的性能。这些功能不仅限于字节级别的变化，如字符串存储或垃圾回收的变化，这些变化你几乎无法控制。此外，忽略那些针对更快对象锁定的实现变化，因为你不需要做任何不同的事情，你将自动获得这些改进。相反，有新的库功能和全新的命令行工具，可以帮助你快速创建应用程序。
- en: 'In this lesson, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，我们将涵盖以下主题：
- en: Modular development and its impact on performance
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化开发及其对性能的影响
- en: Various string-related performance improvements, including compact string and
    indify string concatenation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多种与字符串相关的性能改进，包括紧凑字符串和 indify 字符串连接
- en: Advancement in concurrency
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发性的进步
- en: Various underlying compiler improvements, such as tiered attribution and **Ahead-of-Time**
    (**AOT**) compilation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种底层编译器改进，例如分层属性和**即时编译**（**AOT**）
- en: Security manager improvements
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全管理器的改进
- en: Enhancements in graphics rasterizers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形光栅化器的增强
- en: Introducing the New Features of Java 9
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Java 9 的新特性
- en: In this lesson, we will explore many under the cover improvements to performance
    that you automatically get by just running your application in the new environment.
    Internally, string changes also drastically reduce memory footprint requirements
    for times when you don't need full-scale Unicode support in your character strings.
    If most of your strings can be encoded either as ISO-8859-1 or Latin-1 (1 byte
    per character), they'll be stored much more efficiently in Java 9\. So, let's
    dive deep into the core libraries and learn the underlying performance improvements.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，我们将探讨许多在新的环境中运行应用程序时自动获得的性能改进。内部，字符串的变化也极大地减少了在不需要全面 Unicode 支持的字符字符串时的内存占用需求。如果你的大多数字符串可以编码为
    ISO-8859-1 或 Latin-1（每个字符 1 个字节），它们在 Java 9 中将存储得更加高效。因此，让我们深入核心库，了解底层性能改进。
- en: Modular Development and Its Impact
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化开发及其影响
- en: In software engineering, modularity is an important concept. From the point
    of view of performance as well as maintainability, it is important to create autonomous
    units called **modules**. These modules can be tied together to make a complete
    system. The modules provides encapsulation where the implementation is hidden
    from other modules. Each module can expose distinct APIs that can act as connectors
    so that other modules can communicate with it. This type of design is useful as
    it promotes loose coupling, helps focus on singular functionality to make it cohesive,
    and enables testing it in isolation. It also reduces system complexity and optimizes
    application development process. Improving performance of each module helps improving
    overall application performance. Hence, modular development is a very important
    concept.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程中，模块化是一个重要的概念。从性能和可维护性的角度来看，创建称为**模块**的独立单元非常重要。这些模块可以组合在一起形成一个完整的系统。模块提供了封装，其中实现被隐藏在其他模块中。每个模块都可以暴露独特的
    API，这些 API 可以作为连接器，以便其他模块可以与之通信。这种设计很有用，因为它促进了松散耦合，有助于关注单一功能以使其具有凝聚力，并允许在隔离状态下进行测试。它还减少了系统复杂性并优化了应用程序开发过程。提高每个模块的性能有助于提高整体应用程序的性能。因此，模块化开发是一个非常重要的概念。
- en: I know you may be thinking, wait a minute, isn't Java already modular? Isn't
    the object-oriented nature of Java already providing modular operation? Well,
    object-oriented certainly imposes uniqueness along with data encapsulation. It
    only recommends loose coupling but does not strictly enforce it. In addition,
    it fails to provide identity at the object level and also does not have any versioning
    provision for the interfaces. Now you may be asking, what about JAR files? Aren't
    they modular? Well, although JARs provide modularization to some extent, they
    don't have the uniqueness that is required for modularization. They do have a
    provision to specify the version number, but it is rarely used and also hidden
    in the JAR's manifest file.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你可能正在想，等等，Java不是已经模块化了吗？Java的面向对象特性不是已经提供了模块化操作吗？嗯，面向对象确实在数据封装的同时强加了唯一性。它只推荐松耦合，但并不强制执行。此外，它未能提供对象级别的标识，也没有为接口提供任何版本控制方案。现在你可能想知道，关于JAR文件呢？它们不是模块化的吗？嗯，尽管JAR文件在某种程度上提供了模块化，但它们没有模块化所需的唯一性。它们确实有指定版本号的方案，但这很少使用，并且隐藏在JAR的清单文件中。
- en: So we need a different design from what we already have. In simple terms, we
    need a modular system in which each module can contain more than one package and
    offers robust encapsulation compared to the standard JAR files.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要一个与我们已有的不同的设计。简单来说，我们需要一个模块化系统，其中每个模块可以包含多个包，并且与标准JAR文件相比提供更强大的封装。
- en: This is what Java 9's modular system offers. In addition to this, it also replaces
    the fallible classpath mechanism by declaring dependencies explicitly. These enhancements
    improve the overall application performance as developers can now optimize the
    individual self-contained unit without affecting the overall system.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Java 9模块系统提供的内容。除此之外，它还通过显式声明依赖项来替换了易出错的类路径机制。这些增强提高了整体应用程序的性能，因为开发者现在可以优化单个自包含单元，而不会影响整个系统。
- en: This also makes the application more scalable and provides high integrity.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这也使得应用程序更具可扩展性并提供高完整性。
- en: 'Let''s look at some of the basics of the module system and how it is tied together.
    To start off with, you can run the following commands to see how the module system
    is structured:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看模块系统的一些基本概念以及它是如何整合在一起的。首先，你可以运行以下命令来查看模块系统的结构：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![Modular Development and Its Impact](img/01_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![模块化开发和其影响](img/01_01.jpg)'
- en: 'If you are interested in a particular module, you can simply add the module
    name at the end of the command, as shown in the following command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对某个特定模块感兴趣，你只需在命令末尾添加模块名称即可，如下面的命令所示：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![Modular Development and Its Impact](img/01_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![模块化开发和其影响](img/01_02.jpg)'
- en: The earlier command will show all the exports in packages from the base module.
    Java base is the core of the system.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将显示来自基本模块的包中的所有导出项。Java的基本模块是系统的核心。
- en: 'This will show all the graphical user interface packages. This will also show
    `requires` which are the dependencies:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示所有图形用户界面包。这也会显示`requires`，即依赖项：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![Modular Development and Its Impact](img/01_03.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![模块化开发和其影响](img/01_03.jpg)'
- en: So far so good, right? Now you may be wondering, I got my modules developed
    but how to integrate them together? Let's look into that. Java 9's modular system
    comes with a tool called **JLink**. I know you can guess what I am going to say
    now. You are right, it links a set of modules and creates a runtime image. Now
    imagine the possibilities it can offer. You can create your own executable system
    with your own custom modules. Life is going to be a lot more fun for you, I hope!
    Oh, and on the other hand, you will be able to control the execution and remove
    unnecessary dependencies.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利，对吧？现在你可能想知道，我已经开发了我的模块，但如何将它们集成在一起呢？让我们来看看。Java 9的模块系统附带了一个名为**JLink**的工具。我知道你现在可以猜到我接下来要说什么。你说对了，它将一组模块链接起来并创建一个运行时镜像。现在想象一下它所能提供的可能性。你可以创建自己的可执行系统，并使用自己的自定义模块。我希望你的生活将变得更加有趣！哦，另一方面，你将能够控制执行并移除不必要的依赖项。
- en: 'Let''s see how to link modules together. Well, it''s very simple. Just run
    the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将模块链接在一起。嗯，这非常简单。只需运行以下命令：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This linker command will link all the modules for you and create a runtime image.
    You need to provide a module path and then add the module that you want to generate
    a figure and give a name. Isn't it simple?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个链接器命令将为你链接所有模块并创建一个运行时镜像。你需要提供一个模块路径，然后添加你想要生成图像的模块，并给出一个名称。这不是很简单吗？
- en: 'Now, let''s check whether the previous command worked properly or not. Let''s
    verify the modules from the figure:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查之前的命令是否正确执行。让我们验证图中的模块：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output looks like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来像这样：
- en: '![Modular Development and Its Impact](img/01_04.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![模块化开发及其影响](img/01_04.jpg)'
- en: With this, you will now be able to distribute a quick runtime with your application.
    It is awesome, isn't it? Now you can see how we moved from a somewhat monolithic
    design to a self-contained cohesive one. Each module contains its own exports
    and dependencies and JLink allows you to create your own runtime. With this, we
    got our modular platform.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，你现在将能够与你的应用程序一起分发一个快速的运行时。这真是太棒了，不是吗？现在你可以看到我们是如何从一个相对单一的设计转变为一个自包含且一致的设计。每个模块都包含自己的导出和依赖项，JLink
    允许你创建自己的运行时。有了这个，我们就得到了我们的模块化平台。
- en: Note that the aim of this section is to just introduce you to the modular system.
    There is a lot more to explore but that is beyond the scope of this book. In this
    book, we will focus on the performance enhancement areas.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本节的目的只是向你介绍模块化系统。还有很多东西可以探索，但这超出了本书的范围。在本书中，我们将关注性能提升的领域。
- en: Quick Introduction to Modules
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块快速入门
- en: I am sure that after reading about the modular platform, you must be excited
    to dive deep into the module architecture and see how to develop one. Hold your
    excitement please, I will soon take you on a journey to the exciting world of
    modules.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信，在了解了模块化平台之后，你一定很兴奋地想要深入了解模块架构，看看如何开发一个模块。请保持你的兴奋，我很快就会带你进入模块的精彩世界。
- en: 'As you must have guessed, every module has a property `name` and is organized
    by packages. Each module acts as a self-contained unit and may have native code,
    configurations, commands, resources, and so on. A module''s details are stored
    in a file named `module-info.java`, which resides in the root directory of the
    module source code. In that file, a module can be defined as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，每个模块都有一个属性 `name`，并且按照包进行组织。每个模块作为一个自包含的单元，可能包含原生代码、配置、命令、资源等等。模块的详细信息存储在一个名为
    `module-info.java` 的文件中，该文件位于模块源代码的根目录下。在该文件中，模块可以被定义为如下：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In order to understand it better, let''s go through an example. Let''s say,
    our module name is `PerformanceMonitor`. The purpose of this module is to monitor
    the application performance. The input connectors will accept method names and
    the required parameters for that method. This method will be called from our module
    to monitor the module''s performance. The output connectors will provide performance
    feedback for the given module. Let''s create a `module-info.java` file in the
    root directory of our performance application and insert the following section:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解它，让我们通过一个例子来讲解。假设，我们的模块名称是 `PerformanceMonitor`。这个模块的目的是监控应用程序的性能。输入连接器将接受方法名称和该方法的所需参数。这个方法将从我们的模块中调用以监控模块的性能。输出连接器将为给定模块提供性能反馈。让我们在我们的性能应用程序的根目录下创建一个
    `module-info.java` 文件，并插入以下部分：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Awesome! You got your first module declaration. But wait a minute, it does
    not do anything yet. Don''t worry, we have just created a skeleton for this. Let''s
    put some flesh on the skeleton. Let''s assume that our module needs to communicate
    with our other (magnificent) modules, which we have already created and named--`PerformanceBase`,
    `StringMonitor`, `PrimitiveMonitor`, `GenericsMonitor`, and so on. In other words,
    our module has an external dependency. You may be wondering, how would we define
    this relationship in our module declaration? Ok, be patient, this is what we will
    see now:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你已经完成了第一个模块声明。但是等等，它现在还没有做任何事情。别担心，我们只是为它创建了一个骨架。让我们在这个骨架上添加一些内容。假设我们的模块需要与我们的其他（出色的）模块进行通信，这些模块我们已经创建并命名为--`PerformanceBase`、`StringMonitor`、`PrimitiveMonitor`、`GenericsMonitor`等等。换句话说，我们的模块有一个外部依赖。你可能想知道，我们如何在模块声明中定义这种关系？好吧，请耐心等待，这就是我们现在要看到的：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Yes, I know you have spotted two clauses, that is, `exports` and `requires`.
    And I am sure you are curious to know what they mean and why we have them there.
    We''ll first talk about these clauses and what they mean when used in the module
    declaration:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我知道你已经注意到了两个子句，那就是 `exports` 和 `requires`。我敢肯定你对它们的意义以及为什么要在那里使用它们感到好奇。我们将首先讨论这些子句及其在模块声明中的含义：
- en: '`exports`: This clause is used when your module has a dependency on another
    module. It denotes that this module exposes only public types to other modules
    and none of the internal packages are visible. In our case, the module `com.java9highperformance.PerformanceMonitor`
    has a dependency on `com.java9highperformance.StringMonitor`, `com.java9highperformance.PrimitiveMonitor`,
    and `com.java9highperformance.GenericsMonitor`. These modules export their API
    packages `com.java9highperformance.StringMonitor`, `com.java9highperformance.PrimitiveMonitor`,
    and `com.java9highperformance.GenericsMonitor`, respectively.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exports`：当你的模块依赖于另一个模块时使用这个子句。它表示此模块仅向其他模块公开公共类型，且内部包不可见。在我们的例子中，模块 `com.java9highperformance.PerformanceMonitor`
    依赖于 `com.java9highperformance.StringMonitor`、`com.java9highperformance.PrimitiveMonitor`
    和 `com.java9highperformance.GenericsMonitor`。这些模块分别导出它们的 API 包 `com.java9highperformance.StringMonitor`、`com.java9highperformance.PrimitiveMonitor`
    和 `com.java9highperformance.GenericsMonitor`。'
- en: '`requires`: This clause denotes that the module depends upon the declared module
    at both compile and runtime. In our case, `com.java9highperformance.PerformanceBase`,
    `com.java9highperformance.PerformanceStat`, and `com.java9highperformance.PerformanceIO`
    modules are required by our `com.java9highperformance.PerformanceMonitor` module.
    The module system then locates all the observable modules to resolve all the dependencies
    recursively. This transitive closure gives us a module graph which shows a directed
    edge between two dependent modules.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requires`：这个子句表示模块在编译和运行时都依赖于声明的模块。在我们的例子中，`com.java9highperformance.PerformanceBase`、`com.java9highperformance.PerformanceStat`
    和 `com.java9highperformance.PerformanceIO` 模块被我们的 `com.java9highperformance.PerformanceMonitor`
    模块所需要。模块系统随后定位所有可观察的模块以递归地解决所有依赖关系。这个传递闭包给我们一个模块图，它显示了两个依赖模块之间的有向边。'
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: Every module is dependent on `java.base` even without explicitly
    declaring it. As you already know, everything in Java is an object.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：每个模块即使没有明确声明，也依赖于 `java.base`。正如你所知道的那样，Java 中的所有东西都是一个对象。'
- en: Now you know about the modules and their dependencies. So, let's draw a module
    representation to understand it better. The following figure shows the various
    packages that are dependent on `com.java9highperformance.PerformanceMonitor`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了模块及其依赖关系。那么，让我们绘制一个模块表示图来更好地理解它。以下图显示了依赖于 `com.java9highperformance.PerformanceMonitor`
    的各种包。
- en: '![Quick Introduction to Modules](img/01_05.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![模块快速入门](img/01_05.jpg)'
- en: Modules at the bottom are `exports` modules and modules on the right are `requires`
    modules.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 底部的模块是 `exports` 模块，右边的模块是 `requires` 模块。
- en: Now let's explore a concept called **readability relationship**. Readability
    relationship is a relationship between two modules where one module is dependent
    on another module. This readability relationship is a basis for reliable configuration.
    So in our example, we can say `com.java9highperformance.PerformanceMonitor` reads
    `com.java9highperformance.PerformanceStat`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们探索一个称为 **可读性关系** 的概念。可读性关系是两个模块之间的关系，其中一个模块依赖于另一个模块。这种可读性关系是可靠配置的基础。所以，在我们的例子中，我们可以说
    `com.java9highperformance.PerformanceMonitor` 读取 `com.java9highperformance.PerformanceStat`。
- en: 'Let''s look at `com.java9highperformance.PerformanceStat` module''s description
    file `module-info.java`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `com.java9highperformance.PerformanceStat` 模块的描述文件 `module-info.java`：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This module depends on the `java.lang module`. Let''s look at the `PerformanceStat`
    module in detail:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块依赖于 `java.lang` 模块。让我们详细看看 `PerformanceStat` 模块：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this case, `com.java9highperformance.PerformanceMonitor` only depends on
    `com.java9highperformance.PerformanceStat` but `com.java9highperformance.PerformanceStat`
    depends on `java.lang`. The `com.java9highperformance.PerformanceMonitor` module
    is not aware of the `java.lang` dependency from the `com.java9highperformance.PerformanceStat`
    module. This type of problem is taken care of by the module system. It has added
    a new modifier called **transitive**. If you look at `com.java9highperformance.PerformanceStat`,
    you will find it requires transitive `java.lang`. This means that any one depending
    on `com.java9highperformance.PerformanceStat` reads on `java.lang`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`com.java9highperformance.PerformanceMonitor` 只依赖于 `com.java9highperformance.PerformanceStat`，但
    `com.java9highperformance.PerformanceStat` 依赖于 `java.lang`。`com.java9highperformance.PerformanceMonitor`
    模块没有意识到来自 `com.java9highperformance.PerformanceStat` 模块的 `java.lang` 依赖。这种类型的问题由模块系统处理。它增加了一个新的修饰符，称为
    **transitive**。如果你查看 `com.java9highperformance.PerformanceStat`，你会发现它需要传递的 `java.lang`。这意味着任何依赖于
    `com.java9highperformance.PerformanceStat` 的模块都会读取 `java.lang`。
- en: 'See the following graph which shows the readability graph:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 看以下图，它显示了可读性图：
- en: '![Quick Introduction to Modules](img/01_06.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![模块快速介绍](img/01_06.jpg)'
- en: Now, in order to compile the `com.java9highperformance.PerformanceMonitor` module,
    the system must be able to resolve all the dependencies. These dependencies can
    be found from the module path. That's obvious, isn't that? However, don't misunderstand
    the classpath with the module path. It is a completely different breed. It doesn't
    have the issues that the packages have.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了编译`com.java9highperformance.PerformanceMonitor`模块，系统必须能够解决所有依赖项。这些依赖项可以从模块路径中找到。这很明显，不是吗？然而，不要将类路径与模块路径混淆。它们是完全不同的类型。它没有包所存在的问题。
- en: String Operations Performance
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串操作性能
- en: If you are not new to programming, string must be your best friend so far. In
    many cases, you may like it more than your spouse or partner. As we all know,
    you can't live without string, in fact, you can't even complete your application
    without a single use of string. OK, enough has been expressed about string and
    I am already feeling dizzy by the string usage just like JVM in the earlier versions.
    Jokes apart, let's talk about what has changed in Java 9 that will help your application
    perform better. Although this is an internal change, as an application developer,
    it is important to understand the concept so you know where to focus for performance
    improvements.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不是编程新手，字符串必须是你迄今为止最好的朋友。在许多情况下，你可能比配偶或伴侣更喜欢它。众所周知，没有字符串你无法生活，实际上，没有使用字符串你甚至无法完成你的应用程序。好吧，关于字符串我们已经说得够多了，我甚至已经因为字符串的使用而感到头晕，就像早期版本的JVM一样。玩笑归玩笑，让我们谈谈Java
    9中发生了哪些变化，这将有助于你的应用程序性能提升。尽管这是一个内部变化，但作为一个应用程序开发者，了解这个概念是很重要的，这样你知道在哪里集中精力进行性能改进。
- en: Java 9 has taken a step toward improving string performance. If you have ever
    come across JDK 6's failed attempt `UseCompressedStrings`, then you must be looking
    for ways to improve string performance. Since `UseCompressedStrings` was an experimental
    feature that was error prone and not designed very well, it was removed in JDK
    7\. Don't feel bad about it, I know it's terrible but as always the golden days
    eventually come. The JEP team has gone through immense pain to add a compact string
    feature that will reduce the footprint of string and its related classes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9朝着提高字符串性能迈出了第一步。如果你曾经遇到过JDK 6的失败尝试`UseCompressedStrings`，那么你一定在寻找提高字符串性能的方法。由于`UseCompressedStrings`是一个实验性特性，容易出错，并且设计得不是很好，它在JDK
    7中被移除了。对此不要感到难过，我知道它很糟糕，但就像往常一样，黄金时代最终会到来。JEP团队经历了巨大的痛苦，添加了一个紧凑字符串特性，这将减少字符串及其相关类的占用空间。
- en: Compact strings will improve the footprint of string and help in using memory
    space efficiently. It also preserves compatibility for all related Java and native
    interfaces. The second important feature is **Indify String Concatenation**, which
    will optimize a string at runtime.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 紧凑字符串将改善字符串的占用空间，并有助于高效地使用内存空间。它还保留了与所有相关Java和本地接口的兼容性。第二个重要特性是**Indify字符串连接**，它将在运行时优化字符串。
- en: In this section, we will take a closure look at these two features and their
    impact on overall application performance.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入探讨这两个特性及其对整体应用程序性能的影响。
- en: Compact String
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 紧凑字符串
- en: Before we talk about this feature, it is important to understand why we even
    care about this. Let's dive deep into the underworld of JVM (or as any star wars
    fan would put it, the dark side of the Force). Let's first understand how JVM
    treats our beloved string and that will help us understand this new shiny compact
    string improvement. Let's enter into the magical world of heap. And as a matter
    of fact, no performance book is complete without a discussion of this mystical
    world.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论这个特性之前，了解我们为什么关心这一点是很重要的。让我们深入JVM（或者像任何星球大战粉丝可能会说的，力量的黑暗面）的地下世界。首先，让我们了解JVM是如何处理我们心爱的字符串的，这将帮助我们理解这个新的闪亮的紧凑字符串改进。让我们进入堆的神奇世界。事实上，没有关于这个神秘世界的讨论，任何性能书籍都是不完整的。
- en: The World of Heap
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆的世界
- en: Each time JVM starts, it gets some memory from the underlining operating system.
    It is separated into two distinct regions called **heap space** and **Permgen**.
    These are home to all your application's resources. And as always with all good
    things in life, this home is limited in size. This size is set during the JVM
    initialization; however, you can increase or decrease this by specifying the JVM
    parameters, `-Xmx`, and `-XX:MaxPermSize`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 每次JVM启动时，它从底层操作系统获取一些内存。这些内存被分为两个不同的区域，称为**堆空间**和**Permgen**。这些区域是所有应用程序资源的家。正如生活中所有美好的事物一样，这个家的大小是有限的。这个大小是在JVM初始化时设置的；然而，你可以通过指定JVM参数`-Xmx`和`-XX:MaxPermSize`来增加或减少这个大小。
- en: The heap size is divided into two areas, the nursery or young space and the
    old space. As the name suggests, the young space is home to new objects. This
    all sounds great but every house needs a cleanup. Hence, JVM has the most efficient
    cleaner called **garbage collector** (most efficient? Well... let's not get into
    that just yet). As any productive cleaner would do, the garbage collector efficiently
    collects all the unused objects and reclaims memory. When this young space gets
    filled up with new objects, the garbage collector takes charge and moves any of
    those who have lived long enough in the young space to the old space. This way,
    there is always room for more objects in the young space.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 堆大小被分为两个区域，即幼年空间或年轻空间和旧空间。正如其名所示，年轻空间是新生对象的家园。这一切听起来都很棒，但每个房子都需要清理。因此，JVM有最有效的清洁工，称为**垃圾收集器**（最有效？好吧……让我们先不谈这个）。像任何有生产力的清洁工一样，垃圾收集器有效地收集所有未使用的对象并回收内存。当年轻空间因新对象而填满时，垃圾收集器接管并移动那些在年轻空间中存活足够长的时间的对象。这样，年轻空间中总是有空间容纳更多对象。
- en: And in the same way, if the old space becomes filled up, the garbage collector
    reclaims the memory used.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，如果旧空间被填满，垃圾收集器将回收使用的内存。
- en: Why Bother Compressing Strings?
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么需要压缩字符串？
- en: 'Now you know a little bit about heap, let''s look at the `String` class and
    how strings are represented on heap. If you dissect the heap of your application,
    you will notice that there are two objects, one is the Java language `String`object
    that references the second object `char[]` that actually handles the data. The
    `char` datatype is UTF-16 and hence takes up to 2 bytes. Let''s look at the following
    example of how two different language strings look:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对堆有了一些了解，让我们看看`String`类以及字符串在堆上的表示方式。如果你剖析你的应用程序的堆，你会注意到有两个对象，一个是Java语言的`String`对象，它引用第二个对象`char[]`，后者实际处理数据。`char`数据类型是UTF-16，因此占用多达2个字节。让我们看看以下示例，看看两种不同语言的字符串是如何表示的：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So you can see that `Latin1 String` only consumes 1 byte, and hence we are losing
    about 50% of the space here. There is an opportunity to represent it in a more
    dense form and improve the footprint, which will eventually help in speeding up
    garbage collection as well.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可以看到，`Latin1 String`只占用1个字节，因此我们在这里损失了大约50%的空间。有机会以更密集的形式表示它并改进占用空间，这最终有助于加快垃圾回收的速度。
- en: Now, before making any changes to this, it is important to understand its impact
    on real-life applications. It is essential to know whether applications use 1
    byte per `char[]` strings or 2 bytes per `char[]` strings.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在对这一部分进行任何更改之前，了解其对实际应用的影响非常重要。了解应用程序是否使用每个`char[]`字符串1个字节或2个字节是至关重要的。
- en: To get an answer to this, the JPM team analyzed a lot of heap dumps of real-world
    data. The result highlighted that a majority of heap dumps have around 18 percent
    to 30 percent of the entire heap consumed by `chars[]`, which come from string.
    Also, it was prominent that most strings were represented by a single byte per
    `char[]`. So, it is clear that if we try to improve the footprint for strings
    with a single byte, it will give significant performance boost to many real-life
    applications.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到这个答案，JPM团队分析了大量真实世界数据的堆转储。结果显示，大多数堆转储中大约有18%到30%的整个堆被`chars[]`消耗，这些`chars[]`来自字符串。此外，很明显，大多数字符串都是由每个`char[]`的单个字节表示的。因此，很明显，如果我们尝试通过单个字节来改进字符串的占用空间，这将显著提高许多实际应用的性能。
- en: What Did They Do?
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 他们做了什么？
- en: After having gone through a lot of different solutions, the JPM team has finally
    decided to come up with a strategy to compress string during its construction.
    First, optimistically try to compress in 1 byte and if it is not successful, copy
    it as 2 bytes. There are a few shortcuts possible, for example, the use of a special
    case encoder like ISO-8851-1, which will always spit 1 byte.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在经过许多不同的解决方案之后，JPM 团队最终决定在字符串构建过程中采用压缩策略。首先，乐观地尝试以1字节压缩，如果失败，则将其复制为2字节。有一些可能的捷径，例如，使用特殊的ISO-8851-1编码器，它将始终输出1字节。
- en: This implementation is a lot better than JDK 6's `UseCompressedStrings` implementation,
    which was only helpful to a handful of applications as it was compressing string
    by repacking and unpacking on every single instance. Hence the performance gain
    comes from the fact that it can now work on both the forms.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现比JDK 6的`UseCompressedStrings`实现要好得多，后者仅对少数应用程序有帮助，因为它在每次实例上重新打包和拆包字符串进行压缩。因此，性能提升来自于它现在可以处理这两种形式。
- en: What is the Escape Route?
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是逃生路线？
- en: 'Even though it all sounds great, it may affect the performance of your application
    if it only uses 2 byte per `char[]`string. In that case, it make sense not to
    use the earlier mentioned, check, and directly store string as 2 bytes per `char[]`.
    Hence, the JPM team has provided a kill switch `--XX: -CompactStrings` using which
    you can disable this feature.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '尽管听起来很棒，但如果它只使用2字节来表示每个`char[]`字符串，它可能会影响应用程序的性能。在这种情况下，不使用之前提到的检查，直接以每个`char[]`的2字节存储字符串是有意义的。因此，JPM团队提供了一个“关闭开关”`--XX:
    -CompactStrings`，使用它可以禁用此功能。'
- en: What is the Performance Gain?
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是性能提升？
- en: The previous optimization affects the heap as we saw earlier that the string
    is represented in the heap. Hence, it is affecting the memory footprint of the
    application. In order to evaluate the performance, we really need to focus on
    the garbage collector. We will explore the garbage collection topic later, but
    for now, let's just focus on the run-time performance.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的优化会影响堆，因为我们之前看到字符串是在堆中表示的。因此，它正在影响应用程序的内存占用。为了评估性能，我们真的需要关注垃圾收集器。我们将在稍后探讨垃圾收集主题，但现在，让我们只关注运行时性能。
- en: Indify String Concatenation
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简化字符串连接
- en: 'I am sure you must be thrilled by the concept of the compact string feature
    we just learned about. Now let''s look at the most common usage of string, which
    is concatenation. Have you ever wondered what really happens when we try to concatenate
    two strings? Let''s explore. Take the following example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信您一定对刚刚学到的紧凑字符串功能感到兴奋。现在让我们看看字符串最常见的使用方式，即连接。您是否曾经想过当我们尝试连接两个字符串时，实际上会发生什么？让我们来探索。以下是一个例子：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding example, we are trying to concatenate a few strings with the
    `int` value. The compiler will then take your awesome strings, initialize a new
    `StringBuilder` instance, and then append all these individuals strings. Take
    a look at the following bytecode generation by `javac`. I have used the **ByteCode
    Outline** plugin for **Eclipse** to visualize the disassembled bytecode of this
    method. You may download it from [http://andrei.gmxhome.de/bytecode/index.html](http://andrei.gmxhome.de/bytecode/index.html):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们正在尝试使用`int`值连接几个字符串。然后编译器将初始化一个新的`StringBuilder`实例，并将所有这些单独的字符串附加到它上面。看看以下由`javac`生成的字节码。我使用了**ByteCode
    Outline**插件来可视化此方法的反汇编字节码。您可以从[http://andrei.gmxhome.de/bytecode/index.html](http://andrei.gmxhome.de/bytecode/index.html)下载它：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Quick Note: How do we interpret this?'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 快速笔记：我们如何解释这个？
- en: '`INVOKESTATIC`: This is useful for invoking static methods'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INVOKESTATIC`: 这对于调用静态方法很有用'
- en: '`INVOKEVIRTUAL`: This uses of dynamic dispatch for invoking public and protected
    non-static methods'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INVOKEVIRTUAL`: 这用于调用公共和受保护的非静态方法，使用动态调度'
- en: '`INVOKEINTERFACE`: This is very similar to `INVOKEVIRTUAL` except that the
    method dispatch is based on an interface type'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INVOKEINTERFACE`: 这与`INVOKEVIRTUAL`非常相似，只是方法调度是基于接口类型的'
- en: '`INVOKESPECIAL`: This is useful for invoking constructors, methods of a superclass,
    and private methods'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INVOKESPECIAL`: 这对于调用构造函数、超类的方法和私有方法很有用'
- en: However, at runtime, due to the inclusion of `-XX:+-OptimizeStringConcat` into
    the JIT compiler, it can now identify the append of `StringBuilder` and the `toString`
    chains. In case the match is identified, produce low-level code for optimum processing.
    Compute all the arguments' length, figure out the final capacity, allocate the
    storage, copy the strings, and do the in place conversion of primitives. After
    this, handover this array to the `String` instance without copying. It is a profitable
    optimization.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在运行时，由于JIT编译器中包含了`-XX:+OptimizeStringConcat`，它现在可以识别`StringBuilder`的追加和`toString`链。如果匹配被识别，将生成用于最佳处理的低级代码。计算所有参数的长度，确定最终容量，分配存储空间，复制字符串，并对原始数据进行就地转换。之后，无需复制即可将此数组传递给`String`实例。这是一个有利可图的优化。
- en: But this also has a few drawbacks in terms of concatenation. One example is
    that in case of a concatenating string with long or double, it will not optimize
    properly. This is because the compiler has to do `.getChar` first which adds overhead.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 但在连接方面也存在一些缺点。一个例子是，对于包含长字符串或双精度浮点数的连接字符串，它无法正确优化。这是因为编译器必须首先执行 `.getChar`，这增加了开销。
- en: Also, if you are appending `int` to `String`, then it works great; however,
    if you have an incremental operator like `i++`, then it breaks. The reason behind
    this is that you need to rewind to the beginning of the expression and re-execute,
    so you are essentially doing `++` twice. And now the most important change in
    Java 9 compact string. The length spell like `value.length >> coder`; `C2` cannot
    optimize it as it does not know about the IR.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你将`int`追加到`String`，那么它工作得很好；然而，如果你有一个增量运算符，如`i++`，那么它就会失效。背后的原因是你需要回滚到表达式的开头并重新执行，所以你实际上是在做`++`两次。现在，Java
    9紧凑字符串最重要的变化。长度拼写为`value.length >> coder`；`C2`无法像处理IR那样优化它。
- en: Hence, to solve the problem of compiler optimization and runtime support, we
    need to control the bytecode, and we cannot expect `javac` to handle that.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了解决编译器优化和运行时支持的问题，我们需要控制字节码，我们不能期望`javac`来处理这个问题。
- en: 'We need to delay the decision of which concatenation can be done at runtime.
    So can we have just method `String.concat` which will do the magic. Well, don''t
    rush into this yet as how would you design the method `concat`. Let''s take a
    look. One way to go about this is to accept an array of the `String` instance:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要延迟在运行时可以执行哪种连接的决定。我们是否可以有这样一个`String.concat`方法，它将完成魔法般的操作。好吧，不要急于行动，因为你怎么设计`concat`方法。让我们看看。一种方法是可以接受一个`String`实例的数组：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'However, this approach will not work with primitives as you now need to convert
    each primitive to the `String`instance and also, as we saw earlier, the problem
    is that long and double string concatenation will not allow us to optimize it.
    I know, I can sense the glow on your face like you got a brilliant idea to solve
    this painful problem. You are thinking about using the `Object` instance instead
    of the `String` instance, right? As you know the `Object`instance is catch all.
    Let''s look at your brilliant idea:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法不适用于原始数据类型，因为你现在需要将每个原始数据类型转换为`String`实例，而且，正如我们之前看到的，问题是长字符串和双精度浮点数连接将不允许我们优化它。我知道，我能感觉到你脸上的光芒，就像你得到了一个解决这个痛苦问题的绝妙想法。你是在想用`Object`实例而不是`String`实例，对吧？正如你所知，`Object`实例是通用的。让我们看看你的绝妙想法：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, if you are using the `Object` instance, then the compiler needs to do
    autoboxing. Additionally, you are passing in the `varargs` array, so it will not
    perform optimally. So, are we stuck here? Does it mean we cannot use the preeminent
    compact string feature with string concatenation? Let's think a bit more; maybe
    instead of using the method `runtime`, let `javac` handle the concatenation and
    just give us the optimized bytecode. That sounds like a good idea. Well, wait
    a minute, I know you are thinking the same thing. What if JDK 10 optimizes this
    further? Does that mean, when I upgrade to the new JDK, I have to recompile my
    code again and deploy it again? In some cases, its not a problem, in other cases,
    it is a big problem. So, we are back to square one.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果你使用`Object`实例，那么编译器需要进行自动装箱。此外，你正在传递一个`varargs`数组，所以它不会表现最佳。所以，我们是不是陷入了僵局？这意味着我们无法使用字符串连接的突出紧凑字符串功能？让我们再思考一下；也许我们可以让`javac`处理连接，只给我们优化后的字节码。这听起来是个好主意。等等，我知道你也在想同样的事情。如果JDK
    10进一步优化这个功能，这意味着什么？这意味着当我升级到新JDK时，我必须重新编译我的代码并重新部署它吗？在某些情况下，这不是问题，在其他情况下，这是一个大问题。所以，我们又回到了起点。
- en: We need something that can be handled at runtime. Ok, so that means we need
    something which will dynamically invoke the methods. Well, that rings a bell.
    If we go back in our time machine, at the dawn of the era of JDK 7 it gave us
    `invokedynamic`. I know you can see the solution, I can sense the sparkle in your
    eyes. Yes, you are right, `invokedynamic` can help us here. If you are not aware
    of `invokedynamic`, let's spend some time to understand it. For those who have
    already mastered the topic, you could skip it, but I would recommend you go through
    this again.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要能够在运行时处理的东西。好吧，这意味着我们需要能够动态调用方法的东西。嗯，这让我想起了什么。如果我们回到JDK 7时代的起点，它给了我们`invokedynamic`。我知道你能看到解决方案，我能感觉到你眼中的光芒。是的，你是对的，`invokedynamic`可以帮我们解决这个问题。如果你不了解`invokedynamic`，让我们花点时间来理解它。对于那些已经掌握了这个主题的人来说，你可以跳过这部分，但我建议你再次阅读。
- en: Invokedynamic
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Invokedynamic
- en: The `invokedynamic` feature is the most notable feature in the history of Java.
    Rather than having a limit to JVM bytecode, we now can define our own way for
    operations to work. So what is `invokedynamic`? In simple terms, it is the user-definable
    bytecode. This bytecode (instead of JVM) determines the execution and optimization
    strategies. It offers various method pointers and adapters which are in the form
    of method handling APIs. The JVM then work on the pointers given in the bytecode
    and use reflection-like method pointers to optimize it. This way, you, as a developer,
    can get full control over the execution and optimization of code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`invokedynamic`特性是Java历史上最显著的特征。我们不再受限于JVM字节码，现在我们可以定义自己的操作方式。那么什么是`invokedynamic`呢？简单来说，它是由用户定义的字节码。这个字节码（而不是JVM）决定了执行和优化策略。它提供了各种方法指针和适配器，这些指针以方法处理API的形式存在。然后JVM根据字节码中给出的指针进行工作，并使用类似反射的方法指针来优化它。这样，作为开发者的你，可以完全控制代码的执行和优化。'
- en: It is essentially a mix of user-defined bytecode (which is known as **bytecode
    + bootstrap**) and method handles. I know you are also wondering about the method
    handles--what are they and how to use them? Ok, I heard you, let's talk about
    method handles.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 它本质上是由用户定义的字节码（被称为**字节码 + 引导**)和方法句柄混合而成的。我知道你也在想关于方法句柄的问题——它们是什么，如何使用？好吧，我听到了你的声音，让我们来谈谈方法句柄。
- en: Method handles provide various pointers, including field, array, and method,
    to pass data and get results back. With this, you can do argument manipulation
    and flow control. From JVM's point of view, these are native instructions that
    it can optimize as if it were bytecode. However, you have the option to programmatically
    generate this bytecode.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 方法句柄提供各种指针，包括字段、数组和方法，用于传递数据和返回结果。有了这个，你可以进行参数操作和流程控制。从JVM的角度来看，这些是原生指令，它可以像字节码一样进行优化。然而，你可以选择程序性地生成这种字节码。
- en: Let's zoom in to the method handles and see how it all ties up together. The
    main package's name is `java.lang.invoke`, which has `MethodHandle`, `MethodType`,
    and `MethodHandles`. `MethodHandle` is the pointer that will be used to invoke
    the function. `MethodType` is a representation of a set of arguments and return
    value coming from the method. The utility class `MethodHandles` will act as a
    pointer to a method which will get an instance of `MethodHandle` and map the arguments.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们放大方法句柄，看看它们是如何相互关联的。主包的名称是`java.lang.invoke`，它包含`MethodHandle`、`MethodType`和`MethodHandles`。`MethodHandle`是用于调用函数的指针。`MethodType`是方法中参数集合和返回值的表示。实用类`MethodHandles`将作为指向方法的指针，它将获取`MethodHandle`的实例并映射参数。
- en: We won't be going in deep for this section, as the aim was just to make you
    aware of what the `invokedynamic` feature is and how it works so you will understand
    the string concatenation solution. So, this is where we get back to our discussion
    on string concatenation. I know, you were enjoying the `invokedynamic` discussion,
    but I guess I was able to give you just enough insight to make you understand
    the core idea of Indify String Concatenation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨这一部分，因为我们的目标只是让你了解`invokedynamic`特性是什么以及它是如何工作的，这样你就能理解字符串连接解决方案。所以，这就是我们回到关于字符串连接讨论的地方。我知道，你在享受`invokedynamic`的讨论，但我猜我给你提供了足够的洞察力，让你理解Indify字符串连接的核心思想。
- en: Let's get back on the concatenation part where we were looking for a solution
    to concatenate our awesome compact strings. For concatenating the compact strings,
    we need to take care of types and the number of types of methods and this is what
    the `invokedynamic` gives us.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们寻找解决方案以连接我们出色的紧凑字符串的部分。为了连接紧凑字符串，我们需要注意类型和方法的数量，这正是 `invokedynamic` 给我们的。
- en: So let's use `invokedynamic` for `concat`. Well, not so quick, my friend. There
    is a fundamental problem with this approach. We cannot just use `invokedynamic`
    as it is to solve this problem. Why? Because there is a circular reference. The
    `concat` function needs `java.lang.invoke`, which uses `concat`. This continues,
    and eventually you will get `StackOverflowError`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们为 `concat` 使用 `invokedynamic`。嗯，别那么快，我的朋友。这种方法有一个基本问题。我们不能简单地使用 `invokedynamic`
    来解决这个问题。为什么？因为存在循环引用。`concat` 函数需要 `java.lang.invoke`，它又使用了 `concat`。这样继续下去，最终你会得到
    `StackOverflowError`。
- en: 'Take a look at the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的代码：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'So if we were to use `invokedynamic` here, the `invokedynamic` call would look
    like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果我们在这里使用 `invokedynamic`，`invokedynamic` 调用将看起来像这样：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There is a need to break the circular reference. However, in the current JDK
    implementation, you cannot control what `java.invoke` calls from the complete
    JDK library. Also, removing the complete JDK library reference from `java.invoke`
    has severe side effects. We only need the `java.base` module for Indify String
    Concatenation, and if we can figure out a way to just call the `java.base` module,
    then it will significantly improve the performance and avoid unpleasant exceptions.
    I know what you are thinking. We just studied the coolest addition to Java 9,
    **Project Jigsaw**. It provides modular source code and now we can only accept
    the `java.base` module. This solves the biggest problem we were facing in terms
    of concatenating two strings, primitives, and so on.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 需要打破循环引用。然而，在当前的 JDK 实现中，你无法控制 `java.invoke` 从完整的 JDK 库中调用什么。此外，从 `java.invoke`
    中移除完整的 JDK 库引用会产生严重的副作用。我们只需要 `java.base` 模块来进行 Indify 字符串连接，如果我们能找到一种方法只调用 `java.base`
    模块，那么这将显著提高性能并避免不愉快的异常。我知道你在想什么。我们刚刚学习了 Java 9 中最酷的新增功能，**Project Jigsaw**。它提供了模块化源代码，现在我们只能接受
    `java.base` 模块。这解决了我们在连接两个字符串、原始数据等方面面临的最大问题。
- en: 'After going through a couple of different strategies, the Java Performance
    Management team has settled on the following strategy:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 经过几个不同的策略后，Java 性能管理团队已经确定以下策略：
- en: Make a call to the `toString()` method on all reference args.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对所有引用参数调用 `toString()` 方法。
- en: Make a call to the `tolength()` method or since all the underlying methods are
    exposed, just call `T.stringSize(T t)` on every args.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `tolength()` 方法，或者由于所有底层方法都已公开，只需在每个参数上调用 `T.stringSize(T t)`。
- en: Figure out the coders and call `coder()` for all reference args.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出编码者并对所有引用参数调用 `coder()`。
- en: Allocate `byte[]` storage and then copy all args. And then, convert primitives
    in-place.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配 `byte[]` 存储空间，然后复制所有参数。然后，就地转换原始数据。
- en: Invoke a private constructor `String` by handing over the array for concatenation.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过传递用于连接的数组来调用私有的 `String` 构造函数。
- en: With this, we are able to get an optimized string concat in the same code and
    not in `C2 IR`. This strategy gives us 2.9x better performance and 6.4x less garbage.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们能够在相同的代码中而不是在 `C2 IR` 中获得优化的字符串连接。这种策略给我们带来了2.9倍的性能提升和6.4倍的垃圾减少。
- en: Storing Interned Strings in CDS Archives
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 CDS 存档中存储内部字符串
- en: The main goal of this feature is to reduce memory footprint caused by creating
    new instances of string in every JVM process. All the classes that are loaded
    in any JVM process can be shared with other JVM processes via **Class Data Sharing**
    (**CDS**) archives.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性的主要目标是减少由在每一个 JVM 进程中创建新的字符串实例所造成的内存占用。在任何 JVM 进程中加载的所有类都可以通过 **Class Data
    Sharing** (**CDS**) 存档与其他 JVM 进程共享。
- en: Oh, I did not tell you about CDS. I think it's important to spend some time
    to understand what CDS is, so you can understand the underlying performance improvement.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，我没有告诉你关于 CDS 的信息。我认为花些时间了解 CDS 是很重要的，这样你才能理解底层性能提升。
- en: Many times, small applications in particular spend a comparatively long time
    on startup operations. To reduce this startup time, a concept called CDS was introduced.
    CDS enables sharing of a set of classes loaded from the system JAR file into a
    private internal representation during the JRE installation. This helps a lot
    as then any further JVM invocations can take advantage of these loaded classes'
    representation from the shared archive instead of loading these classes again.
    The metadata related to these classes is shared among multiple JVM processes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，特别是小型应用程序在启动操作上花费的时间相对较长。为了减少启动时间，引入了一个称为 CDS 的概念。CDS 允许在 JRE 安装期间将系统 JAR
    文件中加载的一组类共享到一个私有的内部表示中。这非常有帮助，因为这样任何进一步的 JVM 调用都可以利用这些已加载类的表示，而不是再次加载这些类。这些类的相关元数据在多个
    JVM 进程之间共享。
- en: CDS stores strings in the form of UTF-8 in the constant pool. When a class from
    these loaded classes begins the initialization process, these UTF-8 strings are
    converted into `String` objects on demand. In this structure, every character
    in every confined string takes 2 bytes in the `String` object and 1 byte to 3
    bytes in the UTF-8, which essentially wastes memory. Since these strings are created
    dynamically, different JVM processes cannot share these strings.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: CDS 以 UTF-8 的形式在常量池中存储字符串。当从这些加载的类开始初始化过程时，这些 UTF-8 字符串会根据需要转换为 `String` 对象。在这个结构中，每个受限字符串中的每个字符在
    `String` 对象中占用 2 个字节，在 UTF-8 中占用 1 到 3 个字节，这实际上浪费了内存。由于这些字符串是动态创建的，不同的 JVM 进程无法共享这些字符串。
- en: Shared strings need a feature called **pinned regions** in order to make use
    of the garbage collector. Since the only HotSpot garbage collector that supports
    pinning is G1; it only works with the G1 garbage collector.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 共享字符串需要一个称为**固定区域**的功能才能利用垃圾收集器。由于唯一支持固定功能的 HotSpot 垃圾收集器是 G1；它只与 G1 垃圾收集器一起工作。
- en: Concurrency Performance
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发性能
- en: Multithreading is a very popular concept. It allows programs to run multiple
    tasks at the same time. These multithreaded programs may have more than one unit
    which can run concurrently. Every unit can handle a different task keeping the
    use of available resources optimal. This can be managed by multiple threads that
    can run in parallel.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程是一个非常流行的概念。它允许程序同时运行多个任务。这些多线程程序可能有多个可以并发运行的单元。每个单元可以处理不同的任务，保持可用资源的最佳使用。这可以通过并行运行的多个线程来管理。
- en: Java 9 improved contended locking. You may be wondering what is contended locking.
    Let's explore. Each object has one monitor that can be owned by one thread at
    a time. Monitors are the basic building blocks of concurrency. In order for a
    thread to execute a block of code marked as synchronized on an object or a synchronized
    method declared by an object, it must own this object's monitor. Since there are
    multiple threads trying to get access to the mentioned monitor, JVM needs to orchestrate
    the process and only allow one thread at a time. It means the rest of threads
    go in a wait state. This monitor is then called contended. Because of this provision,
    the program wastes time in the waiting state.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 改进了竞争锁。你可能想知道什么是竞争锁。让我们来探讨一下。每个对象都有一个可以被一个线程一次拥有的监视器。监视器是并发的基石。为了使一个线程能够执行在对象上标记为同步的代码块或对象声明的同步方法，它必须拥有这个对象的监视器。由于有多个线程试图访问提到的监视器，JVM
    需要协调这个过程，并且一次只允许一个线程访问。这意味着其余的线程进入等待状态。这个监视器因此被称为竞争的。因为这个规定，程序在等待状态下浪费了时间。
- en: Also, **Java Virtual Machine** (**JVM**) does some work orchestrating the lock
    contention. Additionally, it has to manage threads, so once the existing thread
    finishes its execution, it can allow a new thread to go in. This certainly adds
    overhead and affects performance adversely. Java 9 has taken a few steps to improve
    in this area. The provision refines the JVM's orchestration, which will ultimately
    result in performance improvement in highly contested code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，**Java 虚拟机**（**JVM**）在协调锁竞争方面做了一些工作。此外，它还需要管理线程，所以一旦现有线程完成其执行，它就可以允许一个新的线程进入。这无疑增加了开销，并会对性能产生不利影响。Java
    9 已经采取了一些步骤来改进这个领域。这个规定细化了 JVM 的协调，这将最终导致在高度竞争的代码中性能的提高。
- en: 'The following benchmarks and tests can be used to check the performance improvements
    of contented Java object monitors:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下基准测试和测试可以用来检查竞争的 Java 对象监视器的性能改进：
- en: '`CallTimerGrid` (This is more of a stress test than a benchmark)'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CallTimerGrid`（这更像是一个压力测试而不是基准测试）'
- en: '`Dacapo-bach` (earlier dacapo2009)'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dacapo-bach`（早期的 dacapo2009）'
- en: '`_ avrora`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_ avrora`'
- en: '`_ batik`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_ batik`'
- en: '`_ fop`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_ fop`'
- en: '`_ h2`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_ h2`'
- en: '`_ luindex`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_ luindex`'
- en: '`_ lusearch`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_ lusearch`'
- en: '`_ pmd`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_ pmd`'
- en: '`_ sunflow`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_ sunflow`'
- en: '`_ tomcat`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_ tomcat`'
- en: '`_ tradebeans`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_ tradebeans`'
- en: '`_ tradesoap`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_ tradesoap`'
- en: '`_ xalan`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_ xalan`'
- en: '`DerbyContentionModelCounted`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DerbyContentionModelCounted`'
- en: '`HighContentionSimulator`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`高冲突模拟器`'
- en: '`LockLoops-JSR166-Doug-Sept2009` (earlier LockLoops)'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LockLoops-JSR166-Doug-Sept2009`（早期版本LockLoops）'
- en: '`PointBase`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PointBase`'
- en: '`SPECjbb2013-critical` (earlier specjbb2005)'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SPECjbb2013-critical`（早期版本specjbb2005）'
- en: '`SPECjbb2013-max`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SPECjbb2013-max`'
- en: '`specjvm2008`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`specjvm2008`'
- en: '`volano29` (earlier volano2509)'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volano29`（早期版本volano2509）'
- en: Compiler Improvements
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译器改进
- en: Several efforts have been made to improve the compiler's performance. In this
    section, we will focus on the improvements to the compiler side.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 已经做出了几项努力来提高编译器的性能。在本节中，我们将重点关注编译器方面的改进。
- en: Tiered Attribution
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 层级归因
- en: The first and foremost change providing compiler improvement is related to **Tiered
    Attribution** (**TA**). This change is more related to lambda expressions. At
    the moment, the type checking of poly expression is done by type checking the
    same tree multiple times against different targets. This process is called **Speculative
    Attribution** (**SA**), which enables the use of different overload resolution
    targets to check a lambda expression.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 提供编译器改进的第一个和最重要的变化与**层级归因**（**TA**）相关。这个变化更多地与lambda表达式相关。目前，多态表达式的类型检查是通过多次对同一棵树进行不同目标类型检查来完成的。这个过程被称为**推测性归因**（**SA**），它允许使用不同的重载解析目标来检查lambda表达式。
- en: This way of type checking, although a robust technique, adversely affects performance
    significantly. For example, with this approach, *n* number of overload candidates
    check against the same argument expression up to *n * 3* once per overload phase,
    strict, loose, and varargs. In addition to this, there is one final check phase.
    Where lambda returns a poly method call results in combinatorial explosion of
    attribution calls, this causes a huge performance problem. So we certainly need
    a different method of type checking for poly expressions.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型检查的方式，虽然是一种稳健的技术，但会对性能产生显著的不利影响。例如，采用这种方法，每个重载候选者都会在重载阶段对相同的参数表达式进行一次检查，直到重载的严格、宽松和可变参数阶段，检查次数达到
    *n * 3。此外，还有一个最终的检查阶段。当lambda返回多态方法调用结果时，会导致归因调用组合爆炸，这会引起巨大的性能问题。因此，我们确实需要为多态表达式寻找不同的类型检查方法。
- en: The core idea is to make sure that a method call creates bottom-up structural
    types for each poly argument expression with every single details, which will
    be needed to execute the overload resolution applicability check before performing
    the overload resolution.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 核心思想是确保每次方法调用都为每个多态参数表达式创建自下而上的结构化类型，这些类型将用于在执行重载解析适用性检查之前。
- en: So in summary, the performance improvement was able to achieve an attribute
    of a given expression by decreasing the total number of tries.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，性能提升能够通过减少尝试的总次数来实现给定表达式的属性。
- en: Ahead-of-Time Compilation
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预编译
- en: The second noticeable change for compiler improvement is Ahead-of-Time compilation.
    If you are not familiar with the term, let's see what AOT is. As you probably
    know, every program in any language needs a runtime environment to execute. Java
    also has its own runtime which is known as **Java Virtual Machine** (**JVM**).
    The typical runtime that most of us use is a bytecode interpreter, which is JIT
    compiler as well. This runtime is known as **HotSpot JVM**.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器改进的第二个显著变化是预编译。如果你不熟悉这个术语，让我们看看AOT是什么。正如你可能知道的，任何语言的每个程序都需要一个运行时环境来执行。Java也有自己的运行时，被称为**Java虚拟机**（**JVM**）。我们大多数人使用的典型运行时是一个字节码解释器，它也是一个即时编译器。这个运行时被称为**HotSpot
    JVM**。
- en: This HotSpot JVM is famous for improving performance by JIT compilation as well
    as adaptive optimization. So far so good. However, this does not work well in
    practice for every single application. What if you have a very light program,
    say, a single method call? In this case, JIT compilation will not help you much.
    You need something that will load up faster. This is where AOT will help you.
    With AOT as opposed to JIT, instead of compiling to bytecode, you can compile
    into native machine code. The runtime then uses this native machine code to manage
    calls for new objects into mallocs as well as file access into system calls. This
    can improve performance.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个HotSpot JVM因其通过即时编译（JIT）以及自适应优化来提高性能而闻名。到目前为止一切顺利。然而，这并不是每个应用程序在实践中的最佳选择。假设你有一个非常轻的程序，比如说一个单独的方法调用？在这种情况下，即时编译对你帮助不大。你需要一些能更快加载的东西。这就是AOT能帮到你的地方。与JIT相反，你不仅可以编译成字节码，还可以编译成本地机器码。然后运行时会使用这个本地机器码来管理新对象的malloc调用以及文件访问的系统调用。这可以提高性能。
- en: Security Manager Improvements
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全管理器改进
- en: Ok, let's talk about security. If you are not one of those who cares about application
    security over pushing more features in a release, then the expression on your
    face may be like **Uh! What's that?** If you are one those, then let's first understand
    the importance of security and find a way to consider this in your application
    development tasks. In today's SaaS-dominated world, everything is exposed to the
    outside world. A determined individual (a nice way of saying, a **malicious hacker**),
    can get access to your application and exploit the security holes you may have
    introduced through your negligence. I would love to talk about application security
    in depth as this is another area I am very much interested in. However, application
    security is out of the scope of this book. The reason we are talking about it
    here is that the JPM team has taken an initiative to improve the existing security
    manager. Hence, it is important to first understand the importance of security
    before talking about the security manager.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们谈谈安全。如果你不是那些在发布新功能时更关心应用程序安全而不是安全的人，那么你脸上的表情可能就是**啊！那是什么？**如果你是那些人之一，那么让我们首先了解安全的重要性，并找到一种方法将其纳入你的应用程序开发任务中。在当今以SaaS主导的世界里，一切都被暴露在外部世界。一个有决心的个人（用一种好听的方式来说，就是一个**恶意黑客**），可以访问你的应用程序并利用你因疏忽而引入的安全漏洞。我很乐意深入讨论应用程序安全，因为这又是一个我非常感兴趣的领域。然而，应用程序安全不在这个书的范围之内。我们在这里谈论它的原因是因为JPM团队已经采取了一项改进现有安全管理器的举措。因此，在谈论安全管理器之前，首先了解安全的重要性是很重要的。
- en: Hopefully, this one line of description may have generated secure programming
    interest in you. However, I do understand that sometimes you may not have enough
    time to implement a complete secure programming model due to tight schedules.
    So, let's find a way which can fit with your tight schedule. Let's think for a
    minute; is there any way to automate security? Can we have a way to create a blueprint
    and ask our program to stay within the boundaries? Well, you are in luck, Java
    does have a feature called **security manager**. It is nothing but a policy manager
    that defines a security policy for the application. It sounds exciting, doesn't
    it? But what does this policy look like? And what does it contain? Both are fair
    questions to ask. This security policy basically states actions that are dangerous
    or sensitive in nature. If your application does not comply with this policy,
    then the security manager throws `SecurityException`. On the other side, you can
    have your application call this security manager to learn about the permitted
    actions. Now, let's look at the security manager in detail.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这一行描述能激发你对安全编程的兴趣。然而，我明白有时你可能因为时间紧迫而没有足够的时间来实现一个完整的安全编程模型。所以，让我们找到一个适合你紧张日程的方法。让我们思考一下；有没有自动化的安全方法？我们能否有一种创建蓝图并要求我们的程序在边界内运行的方法？好吧，你很幸运，Java确实有一个叫做**安全管理器**的功能。它不过是一个定义应用程序安全策略的策略管理器。听起来很吸引人，不是吗？但是这个策略看起来是什么样子？它包含什么？这两个问题都是合理的。这个安全策略基本上声明了那些本质上是危险或敏感的操作。如果你的应用程序不遵守这个策略，那么安全管理器会抛出`SecurityException`。另一方面，你可以让应用程序调用这个安全管理器来了解允许的操作。现在，让我们详细看看安全管理器。
- en: In case of a web applet, a security manager is provided by the browser, or the
    Java Web Start plugin runs this policy. In many cases, applications other than
    web applets run without a security manager unless those applications implement
    one. It's a no brainer to say that if there is no security manager and no security
    policy attached, the application acts without restrictions.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络小程序的情况下，浏览器提供安全管理者，或者Java Web Start插件运行此策略。在许多情况下，除了网络小程序之外的应用程序在没有安全管理者的情况下运行，除非那些应用程序实现了它。如果既没有安全管理者也没有安全策略附加，应用程序将无限制地运行。
- en: Now we know a little about the security manager, let's look at the performance
    improvement in this area. As per the Java team, there may be a possibility that
    an application running with a security manager installed degrades performance
    by 10 percent to 15 percent. However, it is not possible to remove all the performance
    bottlenecks but narrowing this gap can assist in improving not only security but
    also performance.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对安全管理者有了一些了解，让我们看看这个领域的性能改进。据Java团队所说，一个运行带有安全管理者安装的应用程序可能会降低10%到15%的性能。然而，不可能完全消除所有性能瓶颈，但缩小这个差距不仅可以提高安全性，还可以提高性能。
- en: The Java 9 team looked at some of the optimizations, including the enforcement
    of security policy and the evaluation of permissions, which will help improve
    the overall performance of using a security manager. During the performance testing
    phase, it was highlighted that even though the permission classes are thread safe,
    they show up as a HotSpot. Numerous improvements have been made to decrease thread
    contention and improve throughput.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9团队考虑了一些优化，包括执行安全策略和权限评估，这将有助于提高使用安全管理器的整体性能。在性能测试阶段，突出指出尽管权限类是线程安全的，但它们在HotSpot中显示出来。已经做出了许多改进，以减少线程竞争并提高吞吐量。
- en: Computing the `hashcode` method of `java.security.CodeSource` has been improved
    to use a string form of the code source URL to avoid potentially expensive DNS
    lookups. Also, the `checkPackageAccess` method of `java.lang.SecurityManager`,
    which contains the package checking algorithm, has been improved.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.security.CodeSource`的`hashCode`方法已经改进，使用代码源URL的字符串形式来避免可能昂贵的DNS查找。此外，包含包检查算法的`java.lang.SecurityManager`的`checkPackageAccess`方法也得到了改进。'
- en: 'Some other noticeable changes in security manager improvements are as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 安全管理者改进的其他一些显著变化如下：
- en: The first noticeable change is that using `ConcurrentHashMap` in place of `Collections.synchronizedMap`
    helps improving throughput of the `Policy.implie` method. Look at the following
    graph, taken from the OpenJDK site, which highlights the significant increase
    in the throughput with `ConcurrentHashMap`:![Security Manager Improvements](img/01_07.jpg)
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个明显的改变是，用`ConcurrentHashMap`代替`Collections.synchronizedMap`有助于提高`Policy.implie`方法的吞吐量。请看以下来自OpenJDK网站的图表，它突出了使用`ConcurrentHashMap`后吞吐量的显著提升：![安全管理者改进](img/01_07.jpg)
- en: In addition to this, `HashMap`, which had been used for maintaining internal
    collection of `CodeSource` in `java.security.SecureClassLoader`, has been replaced
    by `ConcurrentHashMap`.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，`HashMap`，它一直被用于在`java.security.SecureClassLoader`中维护`CodeSource`的内部集合，已经被`ConcurrentHashMap`所取代。
- en: There are a few other small improvements like an improvement in the throughput
    by removing the compatibility code from the `getPermissions` method (`CodeSource`),
    which synchronizes on identities.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有一些其他的小改进，比如通过从`getPermissions`方法（`CodeSource`）中移除兼容性代码来提高吞吐量，该方法在身份上进行了同步。
- en: Another significant gain in performance is achieved using `ConcurrentHashMap`
    instead of `HashMap` surrounded by synchronized blocks in the permission checking
    code, which yielded in greater thread performance.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ConcurrentHashMap`而不是在权限检查代码中用同步块包围的`HashMap`，实现了性能的显著提升，这带来了更高的线程性能。
- en: Graphics Rasterizers
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形光栅化器
- en: If you are into Java 2D and using OpenJDK, you will appreciate the efforts taken
    by the Java 9 team. Java 9 is mainly related to a graphics rasterizer, which is
    part of the current JDK. OpenJDK uses Pisces, whereas Oracle JDK uses Ductus.
    Oracle's closed-source Ductus rasterizer performs better than OpenJDK's Pisces.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你热衷于Java 2D并且使用OpenJDK，你会赞赏Java 9团队所做的努力。Java 9主要与图形光栅化器相关，它是当前JDK的一部分。OpenJDK使用Pisces，而Oracle
    JDK使用Ductus。Oracle的闭源Ductus光栅化器比OpenJDK的Pisces性能更好。
- en: These graphics rasterizers are useful for anti-aliased rendering except fonts.
    Hence, for a graphics-intensive application, the performance of this rasterizer
    is very important. However, Pisces is failing in many fronts and its performance
    problems are very visible. Hence, the team has decided to replace this with a
    different rasterizer called Marlin Graphics Renderer.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图形光栅化器对抗锯齿渲染很有用，除了字体。因此，对于图形密集型应用程序，这个光栅化器的性能非常重要。然而，Pisces 在许多方面都失败了，其性能问题非常明显。因此，团队决定用名为
    Marlin 图形渲染器的不同光栅化器来替换它。
- en: Marlin is developed in Java and, most importantly, it is the fork of the Pisces
    rasterizer. Various tests have been done on it and the results are very promising.
    It consistently performs better than Pisces. It demonstrates multithreaded scalability
    and even outperforms the closed-source Ductus rasterizer for a single-threaded
    application.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Marlin 是用 Java 开发的，最重要的是，它是 Pisces 光栅化器的分支。对它进行了各种测试，结果非常令人鼓舞。它始终比 Pisces 表现得更好。它展示了多线程的可伸缩性，甚至在单线程应用程序中优于闭源
    Ductus 光栅化器。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this lesson, we have seen some of the exciting features that will improve
    your application's performance without making any effort from your end.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，我们看到了一些令人兴奋的特性，这些特性将提高您的应用程序性能，而无需您做出任何努力。
- en: In the next lesson, we will learn about JShell and the **Ahead-of-Time** (**AOT**)
    compiler. We will also learn about **Read-Eval-Print Loop** (**REPL**) tool.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一课中，我们将学习关于 JShell 和 **即时编译器**（**AOT**）（**AOT**）以及 **读取-评估-打印循环**（**REPL**）工具。
- en: Assessments
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: JLink is a ___________ of Java 9 modular system.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JLink 是 Java 9 模块化系统的 _________。
- en: What is the relationship between two modules where one module is dependent on
    another module?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个模块之间的关系是什么，其中一个模块依赖于另一个模块？
- en: Readability relationship
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可读性关系
- en: Operability relationship
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可操作性关系
- en: Modular relationship
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块关系
- en: Entity relationship
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实体关系
- en: 'State whether True or False: Each time JVM starts, it gets some memory from
    the underlining operating system.'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断以下陈述是对还是错：每次 JVM 启动时，它从底层操作系统获取一些内存。
- en: Which of the following perform some work orchestrating the lock contention?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个执行了一些协调锁竞争的工作？
- en: Pinned regions
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 锁定区域
- en: Readability relationship
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可读性关系
- en: Java Virtual Machine
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java 虚拟机
- en: Class data sharing
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类数据共享
- en: Which of the following enables the use of different overload resolution targets
    to check a lambda expression?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个允许使用不同的重载解析目标来检查 lambda 表达式？
- en: Tiered attribution
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分层分配
- en: HotSpot JVM
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: HotSpot JVM
- en: Speculative attribution
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 投机性分配
- en: Permgen
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Permgen
