- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Class File Structure
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类文件结构
- en: Within the intricate tapestry of **Java virtual machine** (**JVM**) internals,
    the class file structure is a vital guide, leading us through the intricate dance
    of bytecode, constant pools, and class loading. As we delve into this chapter,
    our focus sharpens on unraveling the binary intricacies encoded within Java class
    files, shedding light on the mechanisms orchestrating the seamless execution of
    Java applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java虚拟机（**JVM**）内部的错综复杂的结构中，类文件结构是一个至关重要的指南，引导我们穿越字节码、常量池和类加载的复杂舞蹈。随着我们深入本章，我们的焦点将集中在揭示编码在Java类文件中的二进制复杂性上，揭示协调Java应用程序无缝执行机制。
- en: At its core, bytecode serves as the silent conductor, translating the high-level
    language of Java into a form understandable to the JVM. This chapter dissects
    the bytecode architecture, exploring how it encapsulates program logic and bridges
    the semantic gap between developers and the JVM. Parallelly, we unveil the symbolic
    repository known as the constant pool, delving into its role as a keeper of constants,
    strings, and other symbolic elements. Additionally, we explore class loading,
    the dynamic gateway shaping the runtime environment, and its pivotal role in bringing
    Java classes to life within the JVM. This chapter will teach you the components
    of a class file so that you have all the knowledge to convert Java files to class
    files in the next chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，字节码充当无声的指挥者，将Java的高级语言翻译成JVM可理解的形式。本章剖析了字节码架构，探讨了它是如何封装程序逻辑并弥合开发者和JVM之间的语义差距。同时，我们揭示了被称为常量池的符号存储库，深入研究其在保存常量、字符串和其他符号元素中的作用。此外，我们探讨了类加载，这个塑造运行时环境的动态门户，以及它在将Java类在JVM中激活中的关键作用。本章将教会你类文件的组成部分，以便你在下一章中拥有将Java文件转换为类文件所需的所有知识。
- en: 'In this chapter, we’ll explore the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Decoding class files
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解码类文件
- en: Understanding the headers of class file
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解类文件头
- en: Fields and data repositories
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段和数据存储库
- en: Methods of the Java class file
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java类文件的方法
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will require the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要以下要求：
- en: Java 21
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 21
- en: Git
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git
- en: Maven
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven
- en: Any preferred IDE
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何首选的IDE
- en: This chapter’s GitHub repository, found at - [https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-02](https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-02)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的GitHub仓库，位于 - [https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-02](https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-02)
- en: Decoding class files
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解码类文件
- en: The class file structure is the linchpin in the symbiotic relationship between
    compiled Java code and the JVM. In JVM execution, where platform independence
    is paramount, the class file format emerges as a standardized, hardware-agnostic
    binary representation of compiled Java code. This format is a pivotal bridge,
    allowing developers to express their intent through high-level Java code (and
    even other languages such as Kotlin) while ensuring the JVM can understand and
    execute it seamlessly across diverse hardware and operating systems.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 类文件结构是编译Java代码和JVM之间共生关系中的关键纽带。在JVM执行中，平台独立性至关重要，类文件格式成为了一种标准化的、硬件无关的二进制表示形式。这种格式是一个关键的桥梁，允许开发者通过高级Java代码（甚至其他语言如Kotlin）表达他们的意图，同时确保JVM可以无缝地在不同的硬件和操作系统上理解和执行它。
- en: This structured format is not merely a binary translation of Java source code;
    it is a meticulous blueprint that the JVM relies upon to navigate the intricacies
    of bytecode, constant pools, and class loading. By adhering to the class file
    structure, the JVM gains a universal understanding of how to interpret and execute
    Java programs. Moreover, the class file format encapsulates critical details,
    such as byte ordering, which might vary in platform-specific object file formats.
    This precision becomes indispensable in guaranteeing consistent execution, irrespective
    of the underlying hardware or operating system, emphasizing the pivotal role of
    the class file structure in upholding the cross-platform compatibility foundational
    to Java’s promise of “*write once, run anywhere*.” The class file structure is
    the Rosetta Stone that ensures the harmonious translation of Java’s high-level
    abstractions into the language comprehensible to the JVM, fostering a realm where
    Java’s portability and versatility come to life.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构化格式不仅仅是Java源代码的二进制翻译；它是一个JVM依赖的精心蓝图，用于导航字节码、常量池和类加载的复杂性。通过遵循类文件结构，JVM获得了对如何解释和执行Java程序的全局理解。此外，类文件格式封装了关键细节，如字节序，这在特定平台的对象文件格式中可能有所不同。这种精确性在保证一致执行方面变得不可或缺，无论底层硬件或操作系统如何，强调了类文件结构在维护Java“*一次编写，到处运行*”跨平台兼容性基础中的关键作用。类文件结构是罗塞塔石碑，确保Java的高级抽象与JVM可理解的语言之间和谐翻译，营造了一个Java的可移植性和多功能性得以实现的领域。
- en: Java class files, the binary blueprints of compiled Java code, adhere to a structured
    format crucial for the JVM to interpret and execute programs seamlessly. Each
    element uniquely encapsulates the information necessary for the JVM to execute
    Java programs, from headers to fields and methods. This section provides an overarching
    view of the class file structure, laying the foundation for a deeper understanding
    of its components.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Java类文件，编译后Java代码的二进制蓝图，遵循一种对JVM（Java虚拟机）解释和无缝执行程序至关重要的结构化格式。每个元素都独特地封装了JVM执行Java程序所需的信息，从头部到字段和方法。本节提供了一个对类文件结构的总体看法，为更深入理解其组件奠定了基础。
- en: '*Figure 2**.1* vividly illustrates the transformative journey of a Java file
    into its corresponding class file structure. The process initiates with a pristine
    Java file, symbolized by a clear and concise code snippet. This raw representation
    encapsulates the developer’s logic, intentions, and functionalities, serving as
    the blueprint for a Java program.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.1*生动地描绘了Java文件转化为相应类文件结构的转变过程。这个过程从一份纯净的Java文件开始，象征着一个清晰简洁的代码片段。这种原始表示封装了开发者的逻辑、意图和功能，作为Java程序的蓝图。'
- en: The next phase unfolds as a compilation stage, where a compiler, depicted as
    a dynamic conversion engine, translates the human-readable Java code into an intermediate
    form known as bytecode. This bytecode, represented in a series of compact, platform-independent
    instructions, mirrors the abstract operations of the original Java code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的阶段是编译阶段，其中编译器被描绘为一个动态转换引擎，将可读的Java代码翻译成一种称为字节码的中间形式。这种字节码，以一系列紧凑、平台无关的指令表示，反映了原始Java代码的抽象操作。
- en: The figure further evolves to showcase the assembly of the class file structure.
    Here, the bytecode is meticulously organized, encapsulating the compiled instructions
    and metadata, such as method signatures, access modifiers, and data structures.
    These elements collectively construct the intricate framework of the class file,
    a binary representation optimized for execution within the JVM.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图像进一步发展，展示了类文件结构的组装。在这里，字节码被精心组织，封装了编译指令和元数据，如方法签名、访问修饰符和数据结构。这些元素共同构建了类文件的复杂框架，这是一种针对JVM执行优化的二进制表示。
- en: 'As the visual journey concludes, the transition from Java code to class file
    structure becomes a testament to the cross-platform capabilities of Java. This
    process ensures that the compiled Java program can seamlessly execute in diverse
    environments, maintaining the essence of the developer’s logic while adhering
    to the platform-independent nature of the JVM. *Figure 2**.1* encapsulates the
    elegance and efficiency of the compilation process, where the abstract ideas coded
    in Java materialize into a structured and executable form within the Java class
    file. Let us look at the following figure to understand this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当视觉之旅结束时，从Java代码到类文件结构的转变成为Java跨平台能力的见证。这个过程确保了编译后的Java程序可以在不同的环境中无缝执行，同时保持开发者逻辑的本质并遵循JVM的平台无关性。*图2.1*封装了编译过程的优雅和效率，其中Java中编码的抽象思想在Java类文件中变成了结构化和可执行的形式。让我们看一下以下这张图来理解这一点：
- en: '![Figure 2.1: The process of converting Java source code into a class file](img/B22030_02_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1：将Java源代码转换为类文件的过程](img/B22030_02_01.jpg)'
- en: 'Figure 2.1: The process of converting Java source code into a class file'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：将Java源代码转换为类文件的过程
- en: 'The elegant structure of the JVM class file is precisely defined. It begins
    with the **magic** number and minor and major version details and then moves on
    to the constant pool, a linguistic repository essential for runtime interpretation.
    The access flags, class hierarchy, and interfaces are then listed, paving the
    way for fields and methods to encapsulate data and behavior. This streamlined
    structure ensures the seamless execution of Java applications, where each component
    is a vital note in the symphony of bytecode transformation within the JVM. The
    following code block shows the overall picture of bytecode transformation:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: JVM类文件的优雅结构被精确定义。它以**魔数**和次要及主要版本细节开始，然后转向常量池，这是运行时解释所必需的语言存储库。接着列出访问标志、类层次结构和接口，为字段和方法封装数据和行为的道路铺平。这种简化的结构确保了Java应用程序的无缝执行，其中每个组件都是JVM内部字节码转换交响乐中的关键音符。以下代码块展示了字节码转换的整体图景：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In our quest to unravel the inner workings of Java class files, a crucial juncture
    emerges as we focus on the examination of headers, fields, and methods. These
    elements constitute the fabric of the class file structure, each playing a distinct
    role in shaping the landscape through which the JVM navigates. The journey begins
    with exploring class file headers, akin to the preamble setting the stage for
    a performance. Headers harbor essential metadata, providing the JVM with crucial
    information to orchestrate the execution of Java programs. Following this, we
    delve into fields and data repositories within class files. Understanding the
    organization and types of fields illuminates the data architecture that underlies
    Java classes. Finally, our odyssey concludes with examining methods and the engines
    that drive program execution. Here, we dissect how methods encode the logic of
    Java programs, enabling their dynamic and seamless interpretation by the JVM.
    This exploration promises to demystify the intricate relation between headers,
    fields, and methods, unlocking the gateway to a deeper comprehension of Java class
    files.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们揭开Java类文件内部运作的奥秘的过程中，当我们专注于检查头信息、字段和方法时，一个关键节点出现了。这些元素构成了类文件结构的本质，每个都在塑造JVM导航的景观中扮演着独特的角色。这次旅程从探索类文件头开始，类似于为表演设定的序言。头信息承载着重要的元数据，为JVM提供关键信息以协调Java程序的执行。随后，我们深入到类文件中的字段和数据存储库。理解字段的组织和类型，可以阐明Java类背后的数据架构。最后，我们的探险以检查方法和驱动程序执行引擎结束。在这里，我们剖析了方法如何编码Java程序的逻辑，使它们能够被JVM动态且无缝地解释。这次探索有望揭开头信息、字段和方法之间复杂关系的神秘面纱，开启深入理解Java类文件的门户。
- en: In unraveling the intricate layers of Java class files, we’ve navigated through
    the architectural nuances that define the heart of Java programs. From the distinctive
    magic signature to the orchestrated dance of fields and methods, each component
    plays a pivotal role in shaping the functionality and structure of a class. As
    we conclude this session, the journey seamlessly extends into the next, where
    we will delve into the headers of class files. Understanding these headers is
    akin to deciphering the preamble to execution, unlocking the foundational elements
    that guide the JVM in interpreting and executing code. Join us in the next session
    as we explore the vital information encapsulated in class file headers, bridging
    the gap between high-level Java code and the dynamic realm of the JVM.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在解开Java类文件的复杂层面前，我们已经探索了定义Java程序核心的架构细微差别。从独特的魔数到字段和方法的有组织舞蹈，每个组件都在塑造类的功能结构和作用中扮演关键角色。随着我们结束这次会议，旅程无缝地延伸到下一个阶段，我们将深入探讨类文件的头信息。理解这些头信息就像解读执行序言，解锁指导JVM解释和执行代码的基础元素。请加入我们下一期的会议，我们将探索封装在类文件头信息中的关键信息，弥合高级Java代码和JVM动态领域之间的差距。
- en: Understanding the headers of class file
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解类文件的头信息
- en: Headers serve as the introductory notes, containing metadata crucial for the
    JVM. This section explores the header’s role in setting the stage for Java program
    execution. The class file header serves as the gatekeeper, guiding the JVM through
    the intricacies of the bytecode that follows. It houses details such as the Java
    version compatibility defining the language features the class file relies upon.
    Additionally, the header declares the class’ constant pool, a symbolic repository
    that references strings, types, and other constants, further shaping the semantic
    landscape for program interpretation. A nuanced understanding of class file headers
    is essential for developers, as it forms the basis for the JVM’s decisions during
    the loading and execution phases, ensuring the harmonious translation of high-level
    Java code into the binary language comprehensible to the virtual machine. As we
    navigate this pivotal section, we will unravel the significance of each byte within
    the header, unlocking the door to a deeper appreciation of how class files lay
    the groundwork for the seamless execution of Java programs within the JVM.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 头信息充当介绍性注释，包含对JVM至关重要的元数据。本节探讨了头信息在为Java程序执行奠定基础方面的作用。类文件头充当守门人，引导JVM通过后续字节码的复杂性。它包含诸如定义类文件所依赖的语言特性的Java版本兼容性等详细信息。此外，头信息还声明了类的常量池，这是一个符号存储库，引用字符串、类型和其他常量，进一步塑造了程序解释的语义景观。对类文件头信息的深刻理解对于开发者至关重要，因为它构成了JVM在加载和执行阶段做出决策的基础，确保高级Java代码能够和谐地转换为虚拟机可理解的二进制语言。随着我们进入这个关键部分，我们将揭示头信息中每个字节的含义，开启对类文件如何为在JVM中无缝执行Java程序奠定基础的深入欣赏之门。
- en: 'Within the class file header, a trove of vital information is meticulously
    encoded, serving as the cornerstone for the JVM’s understanding and execution
    of Java programs. Let’s delve into the critical elements housed within this preamble:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在类文件头信息中，大量关键信息被精心编码，为JVM理解和执行Java程序奠定基石。让我们深入探讨这个序言中的关键要素：
- en: '**Magic number**: At the very outset of the header lies the magic number, a
    distinctive set of bytes that uniquely identifies a file as a Java class file.
    With the hexadecimal value of **0xCAFEBABE**, this cryptographic signature is
    the JVM’s first verification step, ensuring it deals with a valid class file.
    The presence of this magic number is akin to a secret handshake, allowing the
    JVM to confidently proceed with the interpretation and execution of the associated
    bytecode. It is an unmistakable mark, signaling the file’s legitimacy and setting
    the foundation for a secure and accurate runtime environment within the JVM.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**魔数**：在头信息的起始处，是魔数，这是一组独特的字节，唯一标识一个文件为Java类文件。具有**0xCAFEBABE**的十六进制值，这个加密签名是JVM的第一个验证步骤，确保它处理的是一个有效的类文件。这个魔数的存在就像一个秘密握手，允许JVM自信地继续解释和执行相关的字节码。这是一个不容置疑的标记，标志着文件的合法性，为JVM中安全准确的运行环境奠定了基础。'
- en: '`minor_version` and `major_version` delineates incremental changes in the compiler
    and signifies major milestones in Java’s evolution. To illuminate this journey,
    the following table unfolds the correlation between `major_version` and the corresponding
    Java SE releases, spanning from the inception of JDK 1.1 to the latest innovations
    in Java SE 21\. This comprehensive roadmap encapsulates the symbiotic relationship
    between class files and Java versions, showcasing how the JVM dynamically adapts
    to the nuanced evolution of the Java language, ensuring seamless compatibility
    and execution across a spectrum of releases:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minor_version` 和 `major_version` 区分了编译器的增量变化，并标志着 Java 进化的重大里程碑。为了阐明这一旅程，以下表格展示了
    `major_version` 与相应的 Java SE 版本之间的关联，从 JDK 1.1 的诞生到 Java SE 21 的最新创新。这个全面的路线图封装了类文件与
    Java 版本之间的共生关系，展示了 JVM 如何动态适应 Java 语言的细微演变，确保跨多个版本的无缝兼容性和执行：'
- en: '| **major_version** | **Java release** |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| **major_version** | **Java release** |'
- en: '| --- | --- |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 45 | JDK 1.1 |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 45 | JDK 1.1 |'
- en: '| 46 | JDK 1.2 |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 46 | JDK 1.2 |'
- en: '| 47 | JDK 1.3 |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 47 | JDK 1.3 |'
- en: '| 48 | JDK 1.4 |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 48 | JDK 1.4 |'
- en: '| 49 | J2SE 5.0 |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 49 | J2SE 5.0 |'
- en: '| 50 | Java SE 6 |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 50 | Java SE 6 |'
- en: '| 51 | Java SE 7 |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 51 | Java SE 7 |'
- en: '| 52 | Java SE 8 |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 52 | Java SE 8 |'
- en: '| 53 | Java SE 9 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 53 | Java SE 9 |'
- en: '| 54 | Java SE 10 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 54 | Java SE 10 |'
- en: '| 55 | Java SE 11 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 55 | Java SE 11 |'
- en: '| 56 | Java SE 12 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 56 | Java SE 12 |'
- en: '| 57 | Java SE 13 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 57 | Java SE 13 |'
- en: '| 58 | Java SE 14 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 58 | Java SE 14 |'
- en: '| 59 | Java SE 15 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 59 | Java SE 15 |'
- en: '| 60 | Java SE 16 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 60 | Java SE 16 |'
- en: '| 61 | Java SE 17 |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 61 | Java SE 17 |'
- en: '| 62 | Java SE 18 |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 62 | Java SE 18 |'
- en: '| 63 | Java SE 19 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 63 | Java SE 19 |'
- en: '| 64 | Java SE 20 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 64 | Java SE 20 |'
- en: '| 65 | Java SE 21 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 65 | Java SE 21 |'
- en: 'Table 2.1: The class file version'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.1：类文件版本
- en: By analyzing these version numbers, the JVM ensures it interprets the bytecode
    with the appropriate language specifications, fostering compatibility between
    the Java class file and the runtime environment. This nuanced versioning system
    allows for the seamless evolution of Java, ensuring backward compatibility while
    accommodating new language enhancements introduced in successive releases.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分析这些版本号，JVM 确保它使用适当的语言规范来解释字节码，促进 Java 类文件与运行时环境之间的兼容性。这种细微的版本控制系统允许 Java
    无缝地发展，确保向后兼容性，同时适应在后续版本中引入的新语言增强。
- en: '**Constant pool reference**: Nestled within the intricate tapestry of the class
    file structure, the constant pool emerges as a symbolic treasure trove, encompassing
    references to strings, classes, field names, method names, and other pivotal constants
    crucial for the interpretation and execution of Java programs. In specifying that
    the class file header *references the start of the constant pool*, we denote that
    this header contains vital information indicating the initiation point of the
    constant pool within the overall class file architecture. This nuanced detail
    is a guiding beacon for the JVM, directing it to the dynamic repository of symbolic
    information. It’s akin to a map, ensuring the JVM efficiently navigates and interprets
    the constant pool, unlocking the foundational elements essential for accurately
    executing Java code.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常量池引用**：在类文件结构的复杂织锦中，常量池成为了一个象征性的宝藏库，包括对字符串、类、字段名、方法名和其他关键常量的引用，这些常量对于解释和执行
    Java 程序至关重要。在指定类文件头 *引用常量池的开始* 时，我们表明这个头包含指示常量池在整体类文件架构中起始点的关键信息。这个细微的细节是 JVM
    的指南针，引导它指向符号信息的动态存储库。它就像一张地图，确保 JVM 高效地导航和解释常量池，解锁准确执行 Java 代码的基础元素。'
- en: This reference is a crucial link that connects the class file’s binary representation
    to the rich semantic world of the Java programming language. Each entry in the
    constant pool serves as a linguistic building block, enabling the JVM to comprehend
    and execute the bytecode accurately.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个引用是连接类文件二进制表示与 Java 编程语言丰富语义世界的关键链接。常量池中的每个条目都作为语言构建块，使 JVM 能够准确理解和执行字节码。
- en: 'Let’s take a simple Java class as an example to illustrate the constant pool
    reference:'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们以一个简单的 Java 类为例来说明常量池的引用：
- en: '[PRE1]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this snippet, the constant pool would include entries for the following:'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个片段中，常量池将包括以下条目：
- en: '**SampleClass**: A symbolic representation of the class itself'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SampleClass**: 类本身的符号表示'
- en: '**main**: A reference to the method name'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**main**: 方法的引用'
- en: '**String**: A reference to the **`****String`** class'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**String**: 对 **`****String`** 类的引用'
- en: '**"Hello, Java!"**: A reference to the string literal'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**"Hello, Java!"**: 对字符串字面量的引用'
- en: The constant pool reference in the class file header points to the beginning
    of this pool, allowing the JVM to access and utilize these symbolic entities efficiently
    during program execution. Understanding this linkage sheds light on how the JVM
    translates high-level Java constructs into the binary language encapsulated within
    class files.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类文件头中的常量池引用指向此池的起始位置，允许 JVM 在程序执行期间有效地访问和利用这些符号实体。理解这种链接有助于了解 JVM 如何将高级 Java
    构造转换为类文件中封装的二进制语言。
- en: '**Access flags**: Encoded within the class file header, access flags are a
    set of binary values that convey essential information about the accessibility
    and nature of a Java class. These flags define the class’ characteristics, such
    as whether it is public, final, abstract, or possesses other attributes. Access
    flags serve as blueprints for the JVM to enforce access control and comprehend
    the structural nuances of the class during program execution.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问标志**：编码在类文件头中，访问标志是一组二进制值，传达了关于 Java 类的可访问性和本质的基本信息。这些标志定义了类的特征，例如它是否是公共的、最终的、抽象的或具有其他属性。访问标志作为
    JVM 在程序执行期间执行访问控制和理解类结构细微差别的蓝图。'
- en: 'The following are some common access flags:'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是一些常见的访问标志：
- en: '**ACC_PUBLIC (0x0001)**: Indicates that the class is public and can be accessed
    from other packages'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ACC_PUBLIC (0x0001)**: 表示该类是公共的，可以从其他包中访问'
- en: '**ACC_FINAL (0x0010)**: Denotes that the class cannot be subclassed, providing
    a level of restriction to its inheritance'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ACC_FINAL (0x0010)**: 表示该类不能被继承，为其继承提供了一定程度的限制'
- en: '**ACC_SUPER (0x0020)**: Historically used to indicate that the **invokespecial**
    instruction should be used rather than **invokevirtual** when invoking methods
    on the superclass'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ACC_SUPER (0x0020)**: 历史上用来指示在调用超类方法时应该使用 **invokespecial** 指令而不是 **invokevirtual**'
- en: '**ACC_INTERFACE (0x0200)**: Signals that the class is an interface rather than
    a regular class'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ACC_INTERFACE (0x0200)**: 表示该类是一个接口而不是一个普通类'
- en: '**ACC_ABSTRACT (0x0400)**: Marks the class as abstract, implying that it cannot
    be instantiated independently'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ACC_ABSTRACT (0x0400)**: 将类标记为抽象的，意味着它不能独立实例化'
- en: '**ACC_SYNTHETIC (0x1000)**: Indicates that a compiler generated the class and
    is not in the source code'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ACC_SYNTHETIC (0x1000)**: 表示该类是由编译器生成的，不在源代码中'
- en: '**ACC_ANNOTATION (0x2000)**: Denotes that the class is an annotation type'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ACC_ANNOTATION (0x2000)**: 表示该类是一个注解类型'
- en: '**ACC_ENUM (0x4000)**: Marks the class as an enumerated type'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ACC_ENUM (0x4000)**: 标记该类为一个枚举类型'
- en: 'Consider the following Java class as an example:'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑以下 Java 类作为示例：
- en: '[PRE2]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this illustrative example, we have the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们有以下内容：
- en: '**ACC_PUBLIC**: Signals the class’ declaration as public, allowing its accessibility
    from other classes'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ACC_PUBLIC**: 表示类的声明为公共的，允许其他类访问'
- en: '**ACC_FINAL**: Imposes finality on the class, inhibiting inheritance and ensuring
    its structure remains unaltered'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ACC_FINAL**: 对类施加最终性，阻止继承并确保其结构保持不变'
- en: '**ACC_SUPER**: Automatically configured by the compiler, this flag ensures
    the invocation of superclass methods is performed efficiently'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ACC_SUPER**: 由编译器自动配置，此标志确保调用超类方法时执行效率高'
- en: '**ACC_SYNTHETIC**: Indicates the absence of synthetic elements in this straightforward
    class, providing transparency in code understanding'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ACC_SYNTHETIC**: 表示此简单类中不存在合成元素，提供代码理解的透明度'
- en: While shedding light on the intricacies of the code undoubtedly holds value,
    it is paramount to embark on a more comprehensive exploration. It entails going
    beyond surface-level explanations and explicitly articulating the invaluable advantages
    that come with a deep understanding of each class’ distinctive characteristics.
    By delving deeper into the significance of these access modifiers, we illuminate
    what is happening in the code and why it matters. Understanding the nature of
    each class and its associated flags fosters a more transparent comprehension of
    the codebase, promoting effective collaboration among developers and ensuring
    robust, maintainable, and transparent software development practices.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然揭示代码的复杂性无疑具有价值，但进行更全面的探索至关重要。这包括超越表面解释，并明确阐述深入理解每个类的独特特性所带来的宝贵优势。通过更深入地探讨这些访问修饰符的重要性，我们阐明了代码中发生的事情及其重要性。理解每个类的本质及其相关标志，有助于更清晰地理解代码库，促进开发者之间的有效协作，并确保稳健、可维护和透明的软件开发实践。
- en: Understanding these flags provides insights into the nature of the class but
    also enables the JVM to enforce access control and execute the Java program with
    precision.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些标志有助于了解类的本质，同时也使JVM能够执行访问控制和精确执行Java程序。
- en: '**This class and superclass information**: The header includes indices pointing
    to the constant pool entries representing the current class and its superclass.
    This information establishes the class hierarchy, allowing the JVM to navigate
    the inheritance structure during execution.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**此类及其超类信息**：头文件包括指向表示当前类及其超类的常量池条目的索引。这些信息建立了类层次结构，使JVM在执行期间能够导航继承结构。'
- en: '**Interfaces, fields, and methods counts**: Counts of interfaces, fields, and
    methods declared in the class follow in the header. These values provide the JVM
    with a blueprint of the class structure, enabling efficient memory allocation
    and execution planning.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口、字段和方法计数**：类中声明的接口、字段和方法计数紧随其后。这些值向JVM提供了类结构的蓝图，使其能够进行有效的内存分配和执行计划。'
- en: Understanding these details encoded within the header is akin to deciphering
    the DNA of a Java class file. It forms the basis for the JVM’s decisions during
    class loading, verification, and execution, ensuring a seamless and accurate translation
    of high-level Java code into executable bytecode. The header, therefore, stands
    not just as a preamble but as a critical guidepost, steering the JVM through the
    intricate landscape of class file interpretation and execution.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 理解头文件中编码的这些细节，就像解读Java类文件的DNA一样。它构成了JVM在类加载、验证和执行期间做出决策的基础，确保将高级Java代码无缝且准确地转换为可执行的字节码。因此，头文件不仅是一篇序言，而且是一个关键的指南，引导JVM穿越类文件解释和执行的复杂景观。
- en: In exploring the Java class file header, we’ve decoded the essential elements
    that initiate the JVM’s journey into the binary world of bytecode. From the unmistakable
    magic number affirming the file’s legitimacy to the nuanced details of Java version
    compatibility and access flags, the header serves as the preamble to execution,
    guiding the JVM through the intricacies of class file interpretation. The constant
    pool reference acts as a symbolic gateway, connecting the binary representation
    to the rich semantic world of Java.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索Java类文件头时，我们已经解码了启动JVM进入字节码二进制世界的必要元素。从确认文件合法性的明显魔术数字到Java版本兼容性和访问标志的细微细节，头文件作为执行的序言，引导JVM通过类文件解释的复杂性。常量池引用充当象征性的门户，将二进制表示与Java丰富的语义世界连接起来。
- en: As we conclude our exploration into the headers of Java class files, let’s take
    a moment to recap the insights gained thus far. We’ve deciphered the symbolic
    treasure trove encapsulated within the constant pool, understanding its pivotal
    role in referencing strings, classes, field names, and method names, which are
    essential for the interpretation and execution of Java programs. Recognizing the
    dynamic nature of this repository, we’ve examined how the class file header serves
    as a guiding beacon, referencing the commencement of the constant pool within
    the overall class file structure.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束对Java类文件头部的探索之后，让我们花点时间回顾一下迄今为止获得的见解。我们已经解读了常量池中封装的符号宝藏，理解了它在引用字符串、类、字段名和方法名中的关键作用，这些对于Java程序的解析和执行至关重要。认识到这个存储库的动态性质，我们检查了类文件头部如何作为引导灯塔，在整体类文件结构中引用常量池的起始位置。
- en: The knowledge acquired in this chapter unveils the intricate architecture of
    Java class files and lays the foundation for a more profound comprehension of
    the code’s execution. Understanding the headers is akin to decoding the preamble
    to execution, providing crucial insights into the initiation and navigation of
    the constant pool, a fundamental aspect of Java’s dynamic behavior.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 本章获得的知识揭示了Java类文件的复杂架构，并为对代码执行有更深入的理解奠定了基础。理解头部就像解码执行的前言，提供了关于常量池的启动和导航的关键见解，这是Java动态行为的基本方面。
- en: As we transition into the next section, we carry with us the awareness of a
    class file’s symbolic foundation and its significance in ensuring the accurate
    execution of Java programs. Join us in the upcoming exploration, where we will
    delve into the nuanced details of access flags, interfaces, fields, and methods,
    further enriching our understanding of Java’s class file structure.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们过渡到下一部分时，我们带着对类文件符号基础的认识及其在确保Java程序准确执行中的重要性。加入我们即将进行的探索，我们将深入研究访问标志、接口、字段和方法等细微细节，进一步丰富我们对Java类文件结构的理解。
- en: Fields and data repositories
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字段和数据存储库
- en: In the unfolding exploration of class file intricacies, we now delve into the
    section dedicated to fields and data repositories. This pivotal section dissects
    the dynamic nexus where code and data converge within Java classes. Fields, the
    information custodians, transcend the realm of mere variables, encapsulating the
    very essence of data storage. As we navigate this section, we will unravel the
    diversity of field types, from instance variables to class variables, and decode
    their role in shaping the architecture of Java classes. Join us in uncovering
    the harmonious interplay between fields and the constant pool, where symbolic
    references enrich the language and contribute to the dynamic layer of data representation
    within the class files. This session serves as a gateway to the beating heart
    of Java programs, showcasing how fields become the dynamic vessels through which
    code transforms into executable realities within the JVM.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在对类文件复杂性的展开探索中，我们现在深入到专门介绍字段和数据存储库的部分。这一关键部分剖析了代码和数据在Java类中汇聚的动态联系。字段，作为信息守护者，超越了仅仅是变量的领域，封装了数据存储的本质。随着我们浏览这一部分，我们将揭示字段类型的多样性，从实例变量到类变量，并解码它们在塑造Java类架构中的作用。加入我们，共同揭示字段和常量池之间的和谐互动，其中符号引用丰富了语言，并为类文件中的数据表示的动态层做出了贡献。这次会议是通往Java程序核心的门户，展示了字段如何成为代码在JVM中转化为可执行现实的动态载体。
- en: The declaration of a field involves specifying its data type, a unique identifier,
    and optional modifiers that define its visibility, accessibility, and behavior.
    By dissecting the syntax of field declarations, developers gain insight into how
    these containers store and organize data, creating a symbiotic link between the
    high-level code and the binary representation within class files. This nuanced
    understanding allows for effective utilization of fields, enhancing the clarity
    and efficiency of data management in Java programs.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 字段的声明涉及指定其数据类型、一个唯一的标识符以及可选的修饰符，这些修饰符定义了其可见性、可访问性和行为。通过剖析字段声明的语法，开发者可以深入了解这些容器如何存储和组织数据，在高级代码和类文件中的二进制表示之间建立共生联系。这种细微的理解使得有效利用字段成为可能，增强了Java程序中数据管理的清晰度和效率。
- en: 'Beyond their syntax, fields exhibit diversity through various types, each serving
    distinct roles within Java classes. Two primary categories are instance variables
    and class variables:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 除了它们的语法之外，字段通过各种类型展现多样性，每种类型在Java类中扮演着不同的角色。两个主要类别是实例变量和类变量：
- en: '**Instance variables**: These fields are associated with an instance of a class
    and have a unique set of values for each object. Instance variables encapsulate
    the state of individual objects, defining their characteristics and attributes.
    Understanding the distinctions and nuances of instance variables is crucial for
    modeling the dynamic properties of objects within the broader class structure.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实例变量**：这些字段与类的实例相关联，并为每个对象提供一组独特的值。实例变量封装了单个对象的状态，定义了它们的特性和属性。理解实例变量的区别和细微差别对于在更广泛的类结构中模拟对象的动态属性至关重要。'
- en: '**Class variables**: Unlike instance variables, class variables are shared
    among all class instances. These fields are denoted with the **static** keyword,
    indicating that they belong to the class rather than individual instances. Class
    variables are well suited for representing characteristics or properties common
    to all objects instantiated from the class. Navigating the scopes and distinctions
    between instance and class variables lays a foundational understanding for effective
    data management, influencing the behavior of Java programs.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类变量**：与实例变量不同，类变量在所有类实例之间共享。这些字段使用**静态**关键字表示，表明它们属于类而不是单个实例。类变量非常适合表示从类实例化的所有对象共有的特性和属性。了解实例变量和类变量之间的作用域和区别为有效数据管理奠定了基础，影响Java程序的行为。'
- en: Developers can architect robust and adaptable class structures by comprehending
    the intricacies of field declarations and the diversity of field types. This foundational
    knowledge empowers them to design Java programs that elegantly balance the dynamic
    nature of data with the structured code, ensuring efficient and purposeful data
    management within the JVM.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解字段声明和字段类型的多样性，开发者可以构建强大且适应性强类的结构。这种基础知识使他们能够设计出优雅地平衡数据动态性和结构化代码的Java程序，确保在JVM内高效且目的明确的数据管理。
- en: Within the intricate architecture of Java class files, the connection between
    fields and the constant pool is a symbiotic link that enriches the language’s
    capacity for dynamic and symbolic data representation. The constant pool is a
    repository for symbolic references, encompassing strings, class names, method
    signatures, and other constants essential for Java program interpretation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java类文件的复杂架构中，字段与常量池之间的联系是一种共生关系，丰富了语言在动态和符号数据表示方面的能力。常量池是一个符号引用的存储库，包括字符串、类名、方法签名和其他对Java程序解释至关重要的常量。
- en: In the context of fields, the constant pool becomes a reservoir of references,
    enhancing the versatility of data representation within class files. When a field
    is declared, its name and type are stored as entries in the constant pool. It
    allows for efficient and symbolic referencing of field names and types during
    runtime, enabling the JVM to interpret and manage data dynamically.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在字段的概念下，常量池成为了一个参考的宝库，增强了类文件中数据表示的灵活性。当声明一个字段时，它的名称和类型被存储为常量池中的条目。它允许在运行时高效和符号地引用字段名称和类型，使JVM能够动态地解释和管理数据。
- en: 'A practical example becomes invaluable to grasping the significance of the
    constant pool connection. Consider a scenario where a class includes a field with
    a complex data type, such as a custom object or a string literal. The constant
    pool stores the reference to the field and efficiently manages the relations to
    the field’s data type, as shown in the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一个实际例子对于理解常量池连接的重要性变得非常有价值。考虑一个场景，其中类包含一个具有复杂数据类型的字段，例如自定义对象或字符串字面量。常量池存储了对字段的引用，并有效地管理了与字段数据类型的关联，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, the string literal `"Hello, Java!"` is stored in the constant
    pool, and the field `message` references this constant. This linkage facilitates
    streamlined access and interpretation of data during program execution. Through
    this sample, developers witness how the constant pool serves as a dynamic repository,
    enhancing the efficiency and interpretability of Java class files.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，字符串字面量`"Hello, Java!"`存储在常量池中，字段`message`引用了这个常量。这种链接简化了程序执行期间数据的访问和解释。通过这个示例，开发者见证了常量池如何作为一个动态存储库，提高了Java类文件的效率和可解释性。
- en: Understanding this connection is pivotal for developers aiming to optimize data
    storage and access within their Java programs. It not only ensures the seamless
    execution of code but also exemplifies the elegance with which Java leverages
    symbolic references for dynamic data representation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这种联系对于旨在优化Java程序中数据存储和访问的开发者至关重要。它不仅确保了代码的无缝执行，而且展示了Java如何优雅地利用符号引用进行动态数据表示。
- en: Fields within Java class files serve as dynamic repositories, seamlessly bridging
    the realms of code and data. Our exploration has unveiled the syntax and semantics
    of field declarations, emphasizing their role in encapsulating variables and attributes.
    The nuanced understanding of field types, from instance to class variables, forms
    a cornerstone for effective data management in Java programs. This connection
    between fields and the constant pool enriches the language’s capacity for dynamic
    interpretation, showcasing the synergy that enhances the versatility of data representation
    within class files.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Java类文件中的字段作为动态存储库，无缝地连接了代码和数据的世界。我们的探索揭示了字段声明的语法和语义，强调了它们在封装变量和属性中的作用。对字段类型的细微理解，从实例变量到类变量，是Java程序有效数据管理的基础。字段与常量池之间的这种联系丰富了语言的动态解释能力，展示了增强数据表示灵活性的协同作用。
- en: Building upon this foundation, our journey continues with the exploration of
    **methods**. Just as fields encapsulate data, methods encapsulate behavior within
    Java classes. Join us in the next segment to unravel the intricacies of method
    declarations, parameter passing, and the dynamic execution of code. Together,
    we will deepen our understanding of how methods contribute to the functional essence
    of Java programs within the JVM.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个基础上，我们的旅程继续深入探索**方法**。正如字段封装数据一样，方法在Java类中封装行为。请加入我们下一部分，揭示方法声明、参数传递和代码动态执行的复杂性。我们将共同深化对方法如何贡献于JVM中Java程序功能本质的理解。
- en: Methods in the class file
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类文件中的方法
- en: Let’s embark on an in-depth exploration of the heart of Java class files—methods.
    These dynamic components serve as the architects of behavior within classes, shaping
    the very essence of Java programs and orchestrating the precise execution of code
    within the JVM. In this session, we’ll peel back the layers to unravel the intricacies
    of method declarations, parameter passing, and the dynamic execution of code.
    We aim to provide you with a solid foundational understanding of how methods fundamentally
    contribute to Java classes’ structural integrity and functionality.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探索Java类文件的核心——方法。这些动态组件作为类中行为的建筑师，塑造了Java程序的本质，并精确地协调JVM内代码的执行。在本节中，我们将层层揭开，揭示方法声明、参数传递和代码动态执行的复杂性。我们的目标是为您提供关于方法如何从根本上贡献于Java类结构完整性和功能性的坚实基础理解。
- en: Within class files, a method’s return type is key to understanding the nature
    of the data generated during execution. This critical element acts as a guiding
    beacon for the JVM, enabling it to anticipate the expected outcomes of each method.
    Whether a method yields an `int`, `String`, or any other data type, the return
    type encapsulates this vital information, enriching our grasp of how methods fit
    into the broader program structure.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在类文件中，方法的返回类型是理解执行期间生成数据性质的关键。这个关键元素作为JVM的引导灯塔，使其能够预测每个方法的预期结果。无论方法返回`int`、`String`还是任何其他数据类型，返回类型封装了这些关键信息，丰富了我们对方法如何融入更广泛程序结构的理解。
- en: We will delve even deeper into the nuances of methods in the following chapters,
    providing you with a more comprehensive understanding of their role and significance
    in the world of Java programming.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将更深入地探讨方法的细微差别，为您提供关于它们在Java编程世界中的角色和重要性的更全面理解。
- en: Summary
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In exploring methods within the intricate landscape of Java class files, we’ve
    uncovered their pivotal role as the architects of program behavior. The class
    file structure encapsulates crucial information about return types, access modifiers,
    and parameters, guiding the JVM in executing code dynamically and efficiently.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索 Java 类文件错综复杂的结构中，我们发现它们在程序行为架构中的关键作用。类文件结构封装了关于返回类型、访问修饰符和参数的关键信息，指导 JVM
    动态且高效地执行代码。
- en: As we conclude this part of our exploration, the journey through class file
    intricacies continues into the next chapter. The upcoming topic delves into the
    essence of bytecode, serving as the intermediary language that bridges high-level
    Java code with the platform-independent execution environment of the JVM. Together,
    we will unravel the bytecode layer, understanding how it transforms method logic
    into executable instructions, ensuring the portability and universality of Java
    programs. This exploration into bytecodes promises to deepen our understanding
    of Java’s cross-platform capabilities, providing insights into the magic that
    enables Java code to run seamlessly across diverse environments.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束这一部分的探索时，对类文件复杂性的旅程将继续到下一章。即将到来的主题将深入探讨字节码的本质，作为连接高级 Java 代码与 JVM 平台无关执行环境的中间语言。我们将一起揭开字节码层，了解它是如何将方法逻辑转换为可执行指令，确保
    Java 程序的可移植性和通用性。对字节码的探索将加深我们对 Java 跨平台能力的理解，揭示使 Java 代码能够在不同环境中无缝运行的秘密。
- en: Questions
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章知识的了解：
- en: What is the purpose of the “Magic” number in the Java class file header?
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java 类文件头中的“魔数”的主要目的是什么？
- en: It identifies the developer who wrote the code
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它确定了编写代码的开发者
- en: It identifies the file as being a Java class file
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它确定了文件是一个 Java 类文件
- en: It marks the end of the constant pool
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它标志着常量池的结束
- en: It determines the class hierarchy
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它决定了类层次结构
- en: Which section of the class file structure stores symbolic references, strings,
    and constants?
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个部分存储了符号引用、字符串和常量？
- en: Fields
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字段
- en: Access flags
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问标志
- en: Constant pool
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 常量池
- en: Methods
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法
- en: What does the **interfaces_count** field in the class file structure represent?
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类文件结构中的 **interfaces_count** 字段代表什么？
- en: The number of methods in the class
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类中的方法数量
- en: The number of interfaces implemented by the class
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类实现的接口数量
- en: The access flags for interfaces
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接口的访问标志
- en: The total size of the constant pool
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 常量池的总大小
- en: What do fields and methods represent in the context of class files?
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类文件的上下文中，字段和方法代表什么？
- en: Variables and attributes
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量和属性
- en: Linguistic repositories
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 语言库
- en: Cryptographic seals
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加密封印
- en: Access modifiers
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问修饰符
- en: What is the primary purpose of the attributes section in the class file structure?
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类文件结构中属性部分的 主要目的是什么？
- en: Determines the class version
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定类版本
- en: Stores symbolic references
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储符号引用
- en: Manages bytecode execution
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管理字节码执行
- en: Provides additional information about the class
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供了关于类的额外信息
- en: Answers
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Here are the answers to this chapter’s questions:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是本章问题的答案：
- en: B. It identifies the file as being a Java class file
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B. 它确定了文件是一个 Java 类文件
- en: C. Constant pool
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C. 常量池
- en: B. The number of interfaces implemented by the class
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B. 类实现的接口数量
- en: A. Variables and attributes
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A. 变量和属性
- en: D. Provides additional information about the class
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: D. 提供了关于类的额外信息
