- en: String Matching Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串匹配算法
- en: String matching algorithms are quite common in text-editing programs. These
    kind of programs frequently need to find all occurrences of a pattern in the text,
    where the text is usually the document being edited and the pattern is a word
    supplied by the user. Since text-editing programs aim to be responsive, having
    efficient algorithms to solve the string matching problem is fundamental.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串匹配算法在文本编辑程序中相当常见。这类程序通常需要找到文本中所有模式的匹配项，其中文本通常是正在编辑的文档，而模式是用户提供的单词。由于文本编辑程序旨在响应，因此拥有高效的算法来解决字符串匹配问题是基本的。
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: List common string matching algorithms
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出常见的字符串匹配算法
- en: Solve the string matching problem
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决字符串匹配问题
- en: Devise a naive algorithm to solve the string matching problem
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个简单的算法来解决字符串匹配问题
- en: Implement the Boyer-Moore string search algorithm to carry out string search
    in literature
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现Boyer-Moore字符串搜索算法以在文献中进行字符串搜索
- en: Naive Search Algorithm
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单搜索算法
- en: 'The string matching problem has two inputs, as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串匹配问题有两个输入，如下：
- en: An array *T[1, 2, ...n]* of length *n*
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '长度为*n*的数组*T[1, 2, ...n]* '
- en: An *array* *P[1, 2, ...m]* of length *m (<= n)*
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '长度为*m (<= n)*的数组*P[1, 2, ...m]* '
- en: The elements of `T` and `P` are characters from the same finite alphabet (usually
    called ∑).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`T`和`P`的元素来自相同的有限字母表（通常称为∑）。'
- en: For instance, we may be searching in binary strings, in which case our alphabet
    is *{0, 1}*, or we may be searching in strings of lowercase letters, in which
    case our alphabet is *{a, b… z}*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能在二进制字符串中搜索，在这种情况下，我们的字母表是*{0, 1}*，或者我们可能在小写字母的字符串中搜索，在这种情况下，我们的字母表是*{a,
    b… z}*。
- en: 'The following diagram represents this terminology:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表表示了这个术语：
- en: '![](img/7a430fdb-bbbf-4f5c-b989-72740e7d2fc0.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7a430fdb-bbbf-4f5c-b989-72740e7d2fc0.png)'
- en: 'Figure 5.1: Representation of text array T, pattern array P, and finite alphabet
    ∑'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：文本数组T、模式数组P和有限字母表∑的表示
- en: The character arrays `P` and `T` are usually called "strings of characters".
    We're interested in finding occurrences of pattern `P` in text `T`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 字符数组`P`和`T`通常被称为“字符字符串”。我们感兴趣的是在文本`T`中找到模式`P`的匹配项。
- en: We say that pattern `P` occurs in text `T` if we can align the pattern `P` with
    text `T` so that all characters in `P` match the ones in `T`. When aligning, we
    need to shift pattern `P` zero or more times to the right.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以将模式`P`与文本`T`对齐，使得`P`中的所有字符都与`T`中的字符匹配，我们就说模式`P`在文本`T`中出现。在对齐时，我们需要将模式`P`向右移动零次或多次。
- en: Therefore, in the string matching problem, we're interested in valid shifts
    with which pattern `P` occurs in text `T`. We say that the pattern `P` occurs
    with a shift *s* in text `T` if the pattern `P` occurs beginning at position `s
    + 1` in text `T`. In other words, we need to shift `P` from the start of text
    `T s` times to the right, in order to find a match. In its essence, the string
    matching problem aims to find all valid shifts with which pattern `P` occurs in
    a given text `T`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在字符串匹配问题中，我们感兴趣的是模式`P`在文本`T`中出现的有效位移。我们说模式`P`在文本`T`中以位移`s`出现，如果模式`P`在文本`T`中的位置`s
    + 1`开始出现。换句话说，我们需要将`P`从文本`T`的起始位置向右移动`s`次，以找到匹配项。本质上，字符串匹配问题旨在找到模式`P`在给定文本`T`中出现的所有有效位移。
- en: Two common examples, besides text-editing programs, are finding patterns in
    DNA sequences and finding web pages that are relevant to queries in internet search
    engines.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 除了文本编辑程序之外，还有两个常见的例子，即寻找DNA序列中的模式和寻找与互联网搜索引擎查询相关的网页。
- en: Now that we've formalized the string matching problem, let's look at the naive algorithm
    to solve it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经形式化了字符串匹配问题，让我们看看解决它的简单算法。
- en: Implementing Naive Search
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现简单搜索
- en: As we described the string matching problem, we said that we were interested
    in finding all valid shifts with which pattern `P` occurs in a given text `T`.
    If we translate that notion directly into an algorithm, we're able to arrive at
    the naive string matching algorithm.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们描述的字符串匹配问题，我们说我们感兴趣的是找到模式`P`在给定文本`T`中出现的所有有效位移。如果我们直接将这个概念转化为算法，我们就能得到简单的字符串匹配算法。
- en: Developing the String Matching Algorithm in Java
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Java中开发字符串匹配算法
- en: The aim is to write a code in Java to apply a naive string matching algorithm.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是编写Java代码以应用简单的字符串匹配算法。
- en: We need to build the naive string matching algorithm. For this algorithm, we
    need to return all valid starting positions (or shifts) in the text `T` in which
    the pattern `P` occurs.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要构建朴素字符串匹配算法。对于此算法，我们需要返回文本 `T` 中模式 `P` 发生的所有有效起始位置（或位移）。
- en: 'Perform the following steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Implement the `match()` method of the `NaiveStringMatching` class, which
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `NaiveStringMatching` 类的 `match()` 方法，
- en: 'available on GitHub at the following path:'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下路径的GitHub上可用：
- en: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson5/activity/naivestringmatching/NaiveStringMatching.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson5/activity/naivestringmatching/NaiveStringMatching.java)'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson5/activity/naivestringmatching/NaiveStringMatching.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson5/activity/naivestringmatching/NaiveStringMatching.java)'
- en: Repeatedly shift pattern `P` along text `T`, matching all the characters in
    it with the characters aligned in `T`.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复将模式 `P` 沿文本 `T` 移动，匹配其中的所有字符与 `T` 中对齐的字符。
- en: When a match occurs, keep track of the index in `T` where it did.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当发生匹配时，记录在 `T` 中匹配的索引。
- en: The implementation of the naive string matching algorithm is an almost direct
    translation of the problem statement. We want to go through all possible shifts
    for `P` and check which ones are valid by comparing each element of `P` with the
    corresponding shifted elements of `T`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 朴素字符串匹配算法的实现几乎是问题声明的直接翻译。我们想要遍历 `P` 的所有可能的位移，并通过比较 `P` 的每个元素与 `T` 中相应位移的元素来检查哪些是有效的。
- en: 'A possible solution for this problem is in the following snippet:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 该问题的可能解决方案如下片段所示：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Snippet 5.1: Solution to the naive string matching problem. Source class name:
    solution.NaiveStringMatching'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第5.1节片段：朴素字符串匹配问题的解决方案。源类名：solution.NaiveStringMatching
- en: Go to [https://goo.gl/PmEFws](https://goo.gl/PmEFws) to access this code.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://goo.gl/PmEFws](https://goo.gl/PmEFws) 访问此代码。
- en: Rationalization of the Naive Search Algorithm
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化朴素搜索算法
- en: The naive search algorithm takes *O((n - m + 1)m)* time, which is a tight bound
    on the worst case. We can imagine a worst case of the naive search algorithm if
    we have a text string with the character a repeating for *n* times, that is, an
    (such as *a5 = "aaaaa"*), and the pattern am (for *m <= n*). In this case, we
    have to execute the inner loop *m* times to validate the shift.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 朴素搜索算法需要 *O((n - m + 1)m)* 的时间，这是最坏情况下的紧界。我们可以想象一个朴素搜索算法的最坏情况，如果我们有一个字符 a 重复
    *n* 次的文本字符串，即一个（例如 *a5 = "aaaaa"*），和模式 am（对于 *m <= n*）。在这种情况下，我们必须执行内循环 *m* 次来验证位移。
- en: The naive search algorithm can be improved if we know that all characters in
    pattern `P` are different. In this case, whenever we fail validating a shift because
    *P[j]* doesn't match *T[i + j]*, we don't need to backtrack. Instead, we can start
    validating the next shift on *(i + j)*, therefore reducing the running time of
    the algorithm to *O(n)*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道模式 `P` 中的所有字符都不同，则可以改进朴素搜索算法。在这种情况下，每当验证位移失败，因为 *P[j]* 不匹配 *T[i + j]*
    时，我们不需要回溯。相反，我们可以在 *(i + j)* 上开始验证下一个位移，从而将算法的运行时间降低到 *O(n)*。
- en: For example, if *P = "abcd"* and *T = "abcaabcd"*, when *i = 0* and *j = 3*,
    we find a mismatch *('a' != 'd')*. Instead of repeating the comparisons for *i
    = 1*, we can start on *i = 3*, because we're sure there's no other a between *i
    = 0* and *i = 3* (remember that all characters of `P` are different). These kinds
    of observations on the pattern `P` are the basis of the Boyer-Moore algorithm.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果 *P = "abcd"* 且 *T = "abcaabcd"*，当 *i = 0* 和 *j = 3* 时，我们发现一个不匹配 *('a'
    != 'd')*。我们不需要重复进行 *i = 1* 的比较，我们可以从 *i = 3* 开始，因为我们确信在 *i = 0* 和 *i = 3* 之间没有其他
    a（记住 `P` 的所有字符都是不同的）。这些关于模式 `P` 的观察结果是 Boyer-Moore 算法的基础。
- en: In this first section, we introduced the string matching problem and solved
    it using a naive algorithm. In the following section, we'll introduce a much more
    efficient algorithm to solve this problem—the Boyer-Moore algorithm.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了字符串匹配问题，并使用朴素算法解决了它。在下一节中，我们将介绍一个更有效的算法来解决此问题——Boyer-Moore 算法。
- en: Getting Started with the Boyer-Moore String Searching Algorithm
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 Boyer-Moore 字符串搜索算法
- en: The Boyer-Moore string searching algorithm was introduced by Robert S. Boyer
    and J. Strother Moore in 1977, and builds upon the naive search algorithm by intelligently
    skipping certain sections of the text.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Boyer-Moore字符串搜索算法由Robert S. Boyer和J. Strother Moore于1977年提出，并在朴素搜索算法的基础上，通过智能地跳过文本的某些部分来提高其运行时间。
- en: One key feature of the algorithm is that it matches the pattern from right to
    left, instead of left to right, using to its advantage a couple of shift rules
    that improve its running time. To understand the effect of these rules, let's
    build the Boyer-Moore algorithm from our naive search algorithm.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的一个关键特性是它从右向左匹配模式，而不是从左向右匹配，利用其优势的几个位移规则来提高其运行时间。为了理解这些规则的效果，让我们从我们的朴素搜索算法构建Boyer-Moore算法。
- en: 'We''ll start by modifying the matching on the pattern so that it operates from
    right to left. The following code demonstrates this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先修改模式上的匹配，使其从右向左操作。以下代码演示了这一点：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Snippet 5.2: Modifying the inner loop from Snippet 5.1 for algorithm to operate
    from right to left C'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 段5.2：修改段5.1的内循环以使算法从右向左操作C
- en: Using the naive string matching algorithm as the base, let's look at some rules
    that allow us to intelligently skip certain shifts.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以朴素字符串匹配算法为基础，让我们看看一些规则，这些规则允许我们智能地跳过某些位移。
- en: The Bad Character Rule
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 坏字符规则
- en: 'The idea of the bad character rule is to identify mismatches between a character
    in the pattern and a character in the text so that we can safely skip certain
    shifts. To identify the occurrence of a bad character, let''s look at the example
    in the following table:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 坏字符规则的想法是识别模式中的字符和文本中的字符之间的不匹配，以便我们可以安全地跳过某些位移。为了识别坏字符的出现，让我们看看以下表格中的示例：
- en: '| **i** | 0 | 1 | 2 | 3 | **4** | **5** | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13
    | 14 | 15 | 16 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| **i** | 0 | 1 | 2 | 3 | **4** | **5** | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13
    | 14 | 15 | 16 |'
- en: '| **T** | H | C | B | *B* | **A** | **H** | C | C | A | B | A | H | A | H |
    B | C | C |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| **T** | H | C | B | *B* | **A** | **H** | C | C | A | B | A | H | A | H |
    B | C | C |'
- en: '| **P** | A | B | A | *H* | **A** | **H** |  |  |  |  |  |  |  |  |  |  |  |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **P** | A | B | A | *H* | **A** | **H** |  |  |  |  |  |  |  |  |  |  |  |'
- en: 'Table 5.1: Identifying bad characters'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.1：识别坏字符
- en: 'In the example provided in *Table 5.1*, we successfully matched the suffix
    *AH*, but then arrived at a bad character, since *B != H*. Whenever this happens,
    we''re sure that it will only be possible to find a valid shift starting from
    the next shift that solves this mismatch. This means that we can shift `P` until
    either of the following conditions are true:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在表5.1中提供的示例中，我们成功匹配了后缀*A*H*，但随后遇到了一个坏字符，因为*B != H*。每当这种情况发生时，我们都可以确定，只有从下一个解决这个不匹配的位移开始，才能找到有效的位移。这意味着我们可以将`P`位移，直到以下任一条件成立：
- en: The mismatch is turned into a match
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不匹配被转换为匹配
- en: The pattern moves past the mismatched character
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式移动过不匹配的字符
- en: 'We can turn a mismatch into a match whenever the pattern has characters to
    the left of the mismatched character that match the character in the text. Otherwise,
    we must move the pattern past the mismatched character. In the example provided
    in *Table 5.1*, we have another *B* at *P[1]*, so we can shift *P* until *P[1]*
    aligns with *T[3]* as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当模式在不匹配字符的左侧有与文本中的字符匹配的字符时，我们可以将不匹配转换为匹配。否则，我们必须将模式移动到不匹配字符之后。在表5.1中提供的示例中，我们在*P[1]*处还有一个*B*，因此我们可以将*P*位移，直到*P[1]*与*T[3]*对齐，如下所示：
- en: '| **i** | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 |
    15 | 16 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **i** | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 |
    15 | 16 |'
- en: '| **T** | H | C | B | B | A | H | C | C | A | B | A | H | A | H | B | C | C
    |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **T** | H | C | B | B | A | H | C | C | A | B | A | H | A | H | B | C | C
    |'
- en: '| **P** |  |  | A | B | A | H | A | *H* |  |  |  |  |  |  |  |  |  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| **P** |  |  | A | B | A | H | A | *H* |  |  |  |  |  |  |  |  |  |'
- en: 'Table 5.1.1: Using the bad character rule to skip a shift'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.1.1：使用坏字符规则跳过位移
- en: We've safely skipped the check for *1* shift. Now, we have a mismatch right
    in the first character. Let's try to apply the bad character rule. First, let's
    see if we can turn the mismatch into a match.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经安全地跳过了对*1*位移的检查。现在，我们第一个字符就出现了不匹配。让我们尝试应用坏字符规则。首先，让我们看看是否可以将不匹配转换为匹配。
- en: 'Unfortunately, that is not possible because the character *C* is absent from
    *P*. In this case, we shift the pattern past the mismatched character as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这是不可能的，因为字符*C*在*P*中不存在。在这种情况下，我们将模式位移到不匹配的字符之后，如下所示：
- en: '| **i** | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 |
    15 | 16 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **i** | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 |
    15 | 16 |'
- en: '| **T** | H | C | B | B | A | H | C | C | **A** | **B** | **A** | **H** | **A**
    | **H** | B | C | C |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| **T** | H | C | B | B | A | H | C | C | **A** | **B** | **A** | **H** | **A**
    | **H** | B | C | C |'
- en: '| **P** |  |  |  |  |  |  |  |  | **A** | **B** | **A** | **H** | **A** | **H**
    |  |  |  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **P** |  |  |  |  |  |  |  |  | **A** | **B** | **A** | **H** | **A** | **H**
    |  |  |  |'
- en: 'Table 5.1.2: Pattern moving past a mismatched character'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.1.2：模式在错配字符之后移动
- en: We've successfully skipped checking five shifts and have arrived at a valid
    shift.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功跳过了检查五个移位，并到达了一个有效的移位。
- en: 'The bad character rule will help us optimize the naive string matching algorithm,
    but only if we can efficiently find the correct number of times to shift. Let''s
    assume we have access to a two-dimensional array *[1...m][1...e]*, *e* being the
    size of our alphabet. For convenience, let''s call this array left and assume
    that *left[i][j]* gives us the closest index *k* of character *j* in *P* so that
    *k < i*, or is *-1* if character *j* isn''t found to the left of *i* in *P*. If
    we''re able to build such an array, we could improve our naive string search algorithm
    by considering possibly larger skips (given by the information in left). The following
    code snippet shows how we can use the left array to improve our naive string searching
    algorithm as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 不良字符规则将帮助我们优化朴素字符串匹配算法，但前提是我们能够高效地找到正确的移位次数。假设我们能够访问一个二维数组 *[1...m][1...e]*，其中
    *e* 是我们字母表的大小。为了方便，让我们称这个数组为 left，并假设 *left[i][j]* 给出字符 *j* 在 *P* 中的最接近索引 *k*，使得
    *k < i*，或者如果字符 *j* 在 *P* 中没有找到到 *i* 左边的索引，则为 *-1*。如果我们能够构建这样的数组，我们就可以通过考虑可能更大的跳过（由
    left 中的信息给出）来改进我们的朴素字符串搜索算法。以下代码片段展示了我们如何使用 left 数组来改进我们的朴素字符串搜索算法：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Snippet 5.3: Using the bad character rule to improve our skips'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 5.3 片段：使用不良字符规则改进跳过
- en: Go to [https://goo.gl/cCYnfp](https://goo.gl/cCYnfp) to access this code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://goo.gl/cCYnfp](https://goo.gl/cCYnfp) 访问此代码。
- en: We're left to filling in the `left` array, which will be performed in the next
    activity.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们剩下填充 `left` 数组，这将在下一个活动中完成。
- en: 'Activity: Implementing the Bad Character Rule'
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：实现不良字符规则
- en: '**Scenario**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: 'We have to preprocess string *P* to build the `left` array that allows us to
    use the bad character rule efficiently. Recall that *left[i][j]* should return
    either of the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须预处理字符串 *P* 来构建允许我们高效使用不良字符规则的 `left` 数组。回想一下，*left[i][j]* 应该返回以下之一：
- en: The largest index *k* so that *k <= i* and *P[k] == j*
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大的索引 *k*，使得 *k <= i* 且 *P[k] == j*
- en: '*-1*, if *j* isn''t found in *P*'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*-1*，如果 *j* 在 *P* 中未找到'
- en: '**Aim**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: To build an array that allows us to use the bad character rule efficiently.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个允许我们高效使用不良字符规则的数组的步骤。
- en: '**Steps for Completion**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: 'Implement the commented part of the `match()` method of the class `BadCharacterRule`,
    which is available on GitHub at the following path:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `BadCharacterRule` 类中 `match()` 方法的注释部分，该类可在 GitHub 上的以下路径找到：
- en: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson5/activity/badcharacterrule/BadCharacterRule.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson5/activity/badcharacterrule/BadCharacterRule.java)'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson5/activity/badcharacterrule/BadCharacterRule.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson5/activity/badcharacterrule/BadCharacterRule.java)'
- en: Assume that the alphabet of strings *P* and *T* consists only of lowercase letters of
    the English alphabet.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设字符串 *P* 和 *T* 的字母表仅由英语字母表的小写字母组成。
- en: The Good Suffix Rule
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 良好后缀规则
- en: 'The good suffix rule presents a complementary method to enhance our search for
    valid shifts. To identify when the good suffix rule is applicable, let''s look
    at the example given in the following table:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 良好后缀规则提供了一种补充方法来增强我们搜索有效移位的搜索。为了确定何时可以使用良好后缀规则，让我们看看以下表格中给出的示例：
- en: '| **i** | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 |
    15 | 16 | 17 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| **i** | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 |
    15 | 16 | 17 |'
- en: '| **T** | A | A | B | A | B | A | B | A | C | B | A | C | A | B | B | C | A
    | B |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| **T** | A | A | B | A | B | A | B | A | C | B | A | C | A | B | B | C | A
    | B |'
- en: '| **P** | A | A | C | C | A | C | C | A | C |  |  |  |  |  |  |  |  |  |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| **P** | A | A | C | C | A | C | C | A | C |  |  |  |  |  |  |  |  |  |'
- en: 'Table 5.2: Illustration of the good suffix rule'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.2：良好后缀规则的说明
- en: 'When found in a situation where we have matched a suffix of *P* but have found
    a mismatch, using the good suffix rule, and considering *t* as the matched suffix,
    we can try to find the next shift that solves the mismatch by carrying out either
    of the following cases:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在匹配了 *P* 的后缀但发现不匹配的情况下使用良好后缀规则，并将 *t* 作为匹配的后缀时，我们可以尝试通过执行以下任一情况来找到解决不匹配的下一个移动：
- en: Find another occurrence of *t* to the left in *P*
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *P* 中找到左侧的另一个 *t* 出现
- en: Find a prefix of *P* which matches a suffix of *t*
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到与 *t* 的后缀匹配的 *P* 的前缀
- en: Move *P* past *t*
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 *P* 移动到 *t* 之后
- en: Considering case 1, we can try to shift *P* by three to align other occurrences
    of *t* in *P* (starting at *P[4]*). As we can see, the letter to the left of that
    occurrence of *t* (in *P[3]*) is *C*, which is exactly the same as the one that
    provoked the mismatch. Therefore, we should always try to find a *t* that is followed,
    on the left, by a character that is different from the one that provoked the mismatch.
    A variant of the good suffix rule which ignores the character on the left of *t*
    is called the weak good suffix rule.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到情况 1，我们可以尝试将 *P* 向右移动三位，以对齐 *P* 中其他 *t* 的出现（从 *P[4]* 开始）。正如我们所看到的，*t* 出现左侧的字母（在
    *P[3]*）是 *C*，这与引起不匹配的字母完全相同。因此，我们应该始终尝试找到一个 *t*，它在左侧跟随的字符与引起不匹配的字符不同。忽略 *t* 左侧字符的良好的后缀规则变体被称为弱良好后缀规则。
- en: The good suffix rule takes into account that the character on the left of *t*
    is also called the strong good suffix rule.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 良好后缀规则考虑了 *t* 左侧的字符，也称为强良好后缀规则。
- en: 'If we can''t find another occurrence of *t* in *P*, the best we can do with
    this rule is to find a prefix of *P* that matches a suffix of *t*, entering case
    2\. *Table 5.3* illustrates this case:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法在 *P* 中找到另一个 *t* 出现，那么我们可以用这个规则做的最好的事情就是找到一个与 *t* 的后缀匹配的 *P* 的前缀，进入案例
    2。*表 5.3* 说明了这种情况：
- en: '| **i** | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| **i** | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |'
- en: '| **T** | A | *A* | **B** | **A** | **B** | A | B | A | C | B | A |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| **T** | A | *A* | **B** | **A** | **B** | A | B | A | C | B | A |'
- en: '| **P** | A | B | **B** | **A** | **B** |  |  |  |  |  |  |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| **P** | A | B | **B** | **A** | **B** |  |  |  |  |  |  |'
- en: 'Table 5.3: Finding prefix of P matching the suffix of T'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.3：寻找与 T 的后缀匹配的 P 的前缀
- en: In this case, we found a mismatch at *P[1]*, but we can't find another occurrence
    of *BAB* to the left of it. We can, however, find a prefix of *AB* that matches
    a suffix of *t AB* and shift *P* so that these align.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们在 *P[1]* 处找到了一个不匹配，但我们无法找到它左侧的另一个 *BAB* 出现。然而，我们可以找到一个与 *t AB* 的后缀匹配的
    *AB* 的前缀，并将 *P* 移动，以便这些对齐。
- en: Whenever we can neither find another occurrence nor a prefix of *t*, we're left
    with moving *P* past *t* in *T*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们既找不到另一个出现位置，也找不到 *t* 的前缀时，我们就只能将 *P* 在 *T* 中移动到 *t* 之后。
- en: The implementation of the good suffix rule also requires some preprocessing
    on *P*. To understand the preprocessing that is necessary, we need to introduce
    the concept of a border and proper prefix and suffix. A prefix of string *S* is
    a substring of *S* that occurs at the beginning of *S*. A proper prefix of string
    *S* is a prefix of *S* that is different than *S* (consider that *S* is always
    a prefix of *S*).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 良好后缀规则的实现也需要对 *P* 进行一些预处理。为了理解必要的预处理，我们需要引入边界和正确前缀以及后缀的概念。字符串 *S* 的一个前缀是 *S*
    的一个子串，它出现在 *S* 的开头。字符串 *S* 的一个正确前缀是不同于 *S* 的前缀（考虑到 *S* 总是 *S* 的前缀）。
- en: 'A suffix of string *S* is a substring of *S* that occurs at the end of *S*.
    A proper suffix of string *S* is a suffix of *S* that is different from *S* (consider
    that *S* is always a suffix of *S*). A border is a substring of a given string
    that is both a proper prefix and a proper suffix. For example, given the string
    *ccacc*, there are two borders: *c* and *cc. cca* is not a border.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串 *S* 的一个后缀是出现在 *S* 结尾的子串。字符串 *S* 的一个正确后缀是不同于 *S* 的后缀（考虑到 *S* 总是 *S* 的后缀）。边界是给定字符串的一个子串，它既是正确前缀也是正确后缀。例如，给定字符串
    *ccacc*，有两个边界：*c* 和 *cc*。*cca* 不是一个边界。
- en: 'The preprocessing step for the good suffix rule is divided into two steps:
    one for case 1 of the rule, and another for case 2.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 良好后缀规则的预处理步骤分为两个步骤：一个用于规则的案例 1，另一个用于案例 2。
- en: In case 1, the matching suffix is a border of a suffix of a pattern. For example,
    if *P = AACCACCAC* and we have *t = AC* (a suffix of *P*), then we need to find
    a suffix of *P* that has *AC* as a prefix (constituting a border of the suffix).
    The string *ACCAC* is a suffix of *P* and has *AC* as a border.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在情况 1 中，匹配后缀是模式后缀的边界。例如，如果 *P = AACCACCAC* 并且我们有 *t = AC*（*P* 的后缀），那么我们需要找到一个后缀
    *P*，它以 *AC* 为前缀（构成后缀的边界）。字符串 *ACCAC* 是 *P* 的后缀，并且以 *AC* 为边界。
- en: Therefore, we need to find the borders of the suffixes of the pattern. But,
    even after finding them, we need to be able to map a given border to the shortest
    suffix that has this border so that we're able to shift accordingly. Moreover,
    to follow the strong good suffix rule, the border cannot be extended to the left
    by the same symbol that caused the mismatch.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要找到模式后缀的边界。但是，即使找到了它们，我们还需要能够将给定的边界映射到具有该边界的最短后缀，这样我们才能相应地移动。此外，为了遵循强良好后缀规则，边界不能被与导致不匹配的相同符号向左扩展。
- en: 'The preprocessing algorithm for case 1 is displayed in the following snippet:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 情况 1 的预处理算法如下所示：
- en: '[PRE3]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Snippet 5.4: Preprocessing algorithm for Case 1 of the good suffix rule. Source
    class name: GoodSuffixRule'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段 5.4：良好后缀规则情况 1 的预处理算法。源类名：GoodSuffixRule
- en: Go to [https://goo.gl/WzGuVG](https://goo.gl/WzGuVG) to access this code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [https://goo.gl/WzGuVG](https://goo.gl/WzGuVG) 以获取此代码。
- en: To better understand the preprocessing algorithm for case 1, put some `println`
    statements on the relevant steps of the algorithm and run it using some sample
    input. You can use string `ABBABAB`, whose output is shown in *Table 5.4*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解情况 1 的预处理算法，在算法的相关步骤上添加一些 `println` 语句，并使用一些示例输入运行它。您可以使用字符串 `ABBABAB`，其输出显示在
    *表 5.4* 中。
- en: '[PRE4]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To better understand what this algorithm produces, let''s look at its output
    for string *ABBABAB*, which is shown in the following table:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这个算法产生的结果，让我们看看字符串 *ABBABAB* 的输出，如下表所示：
- en: '| **i** | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| **i** | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |'
- en: '| **P** | A | B | B | A | B | A | B |  |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| **P** | A | B | B | A | B | A | B |  |'
- en: '| **f** | 5 | 6 | 4 | 5 | 6 | 7 | 7 | 8 |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| **f** | 5 | 6 | 4 | 5 | 6 | 7 | 7 | 8 |'
- en: '| **s** | 0 | 0 | 0 | 0 | 2 | 0 | 4 | 1 |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| **s** | 0 | 0 | 0 | 0 | 2 | 0 | 4 | 1 |'
- en: 'Table 5.4: Output of the preprocessing algorithm for Case 1 of the good suffix
    rule with string ABBABAB'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.4：对于字符串 ABBABAB 的良好后缀规则情况 1 的预处理算法输出
- en: The widest border of suffix *BABAB*, which starts at *2*, is *BAB*, which starts
    at *4*, and therefore *f[2] = 4*. The widest border of suffix *AB*, which starts
    at *5*, is "", which starts at *7*. Therefore, *f[5] = 7*. The suffix *BABAB*,
    whose widest border is *BAB*, cannot be extended to the left (since *P[1] != P[3]*).
    Therefore, the shift distance of *BAB* is matched and then a mismatch occurs,
    which is *s[4] = 4 - 2 = 2*. The suffix *BABAB* has border *B* as well, which
    also cannot be extended to left, which ensures that *s[6] = 6 - 2 = 4*. The suffix
    *B* beginning at position *6* has border "", beginning at position *7*; therefore,
    *s[7] = 7 - 6 = 1*, which corresponds to the shift distance if nothing has matched.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 后缀 *BABAB* 的最宽边界从 *2* 开始，是 *BAB*，从 *4* 开始，因此 *f[2] = 4*。后缀 *AB* 的最宽边界从 *5* 开始，是空字符串，从
    *7* 开始。因此，*f[5] = 7*。最宽边界为 *BAB* 的后缀 *BABAB* 不能向左扩展（因为 *P[1] != P[3]*）。因此，*BAB*
    的移位距离匹配后发生不匹配，即 *s[4] = 4 - 2 = 2*。后缀 *BABAB* 还有一个边界 *B*，也不能向左扩展，这确保了 *s[6] =
    6 - 2 = 4*。从位置 *6* 开始的后缀 *B* 的边界为空字符串，从位置 *7* 开始；因此，*s[7] = 7 - 6 = 1*，这对应于如果没有匹配时的移位距离。
- en: 'In case 2, a suffix of the matching suffix of the pattern occurs at the beginning
    of the pattern, which constitutes a border of the pattern. Therefore, the pattern
    can be shifted as far as its widest border allows. What we need to do for the
    preprocessing step for case 2 is to find, for each suffix, the widest border of
    the pattern that is contained in that suffix. We can build upon the *f* array
    that was previously computed to do that. The following snippet illustrates this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在情况 2 中，匹配后缀的模式后缀出现在模式的开头，这构成了模式的边界。因此，模式可以移动到其最宽边界允许的最大范围。对于情况 2 的预处理步骤，我们需要为每个后缀找到包含在该后缀中的模式的最宽边界。我们可以基于之前计算出的
    *f* 数组来完成这项工作。以下代码片段说明了这一点：
- en: '[PRE5]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Snippet 5.5: Preprocessing algorithm for Case 2 of the good suffix rule. Source
    class name: GoodSuffixRule'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段 5.5：良好后缀规则情况 2 的预处理算法。源类名：GoodSuffixRule
- en: Go to [https://goo.gl/ckoTu6](https://goo.gl/ckoTu6) to access this code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [https://goo.gl/ckoTu6](https://goo.gl/ckoTu6) 以获取此代码。
- en: The widest border of the pattern is stored at *f[0]*. The idea of the preprocessing
    algorithm for case 2 is to use that value until the pattern becomes shorter than
    *f[0]*, in which case we go with the next wider border of the pattern *(f[j])*.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 模式的最宽边界存储在*f[0]*中。对于情况2的预处理算法的想法是使用该值，直到模式短于*f[0]*，在这种情况下，我们使用模式的下一个更宽的边界*(f[j])*。
- en: 'Integrating the good suffix case with the naive search algorithm allows us
    to improve on the skips performed, as shown in the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将好后缀情况与朴素搜索算法集成可以让我们改进跳过的执行，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Snippet 5.6: The Boyer-Moore algorithm using only the good suffix rule. Source
    class name: Goodsuffixrule'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 'Snippet 5.6: 仅使用好后缀规则的Boyer-Moore算法。源类名：Goodsuffixrule'
- en: Go to [https://goo.gl/1uCgeh](https://goo.gl/1uCgeh) to access this code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[https://goo.gl/1uCgeh](https://goo.gl/1uCgeh)访问此代码。
- en: Application of the Boyer-Moore Algorithm
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Boyer-Moore算法的应用
- en: The Boyer-Moore algorithm is typically used with one or both the bad character
    and good suffix rule. When used with both rules, the shift that is to occur is
    the biggest one produced by the rules. The Boyer-Moore algorithm improves the
    naive search algorithm in the average case, but is still *O(nm)* in the worst
    case (that case being the same described in the previous section, that is, a repeated
    group of characters both in the pattern and in the text).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Boyer-Moore算法通常与一个或两个坏字符和好后缀规则一起使用。当与两个规则一起使用时，要发生的位移是规则产生的最大位移。Boyer-Moore算法在平均情况下改进了朴素搜索算法，但在最坏情况下仍然是*O(nm)*（这种情况与上一节中描述的情况相同，即模式和文本中都有重复的字符组）。
- en: Implementing the Boyer-Moore Algorithm
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Boyer-Moore算法
- en: The aim is to write a code in Java to implement the Boyer-Moore algorithm.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是用Java编写代码以实现Boyer-Moore算法。
- en: We need to integrate the bad character rule with the good suffix rule to produce
    the complete Boyer-Moore algorithm. The idea here is to use the rule that gives
    us the better (or biggest) shift in each situation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将坏字符规则与好后缀规则集成以产生完整的Boyer-Moore算法。这里的想法是使用在每个情况下给出更好（或最大）位移的规则。
- en: 'Perform the following steps:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Implement the `match()` method of the `BoyerMoore` class, which is available
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`BoyerMoore`类的`match()`方法，该方法可用
- en: 'on the following path:'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下路径上：
- en: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson5/activity/boyermoore/BoyerMoore.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson5/activity/boyermoore/BoyerMoore.java)'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson5/activity/boyermoore/BoyerMoore.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson5/activity/boyermoore/BoyerMoore.java)'
- en: Combine the snippets and change the skip logic to choose the best of both rules.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码片段合并并更改跳过逻辑以选择两种规则的最好者。
- en: 'The following snippet shows how the combined matching can be implemented as
    a solution:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何将组合匹配实现为一个解决方案：
- en: '[PRE7]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Snippet 5.7: Implementation of the boyer-moore algorithm. Source class: BoyerMoore'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 'Snippet 5.7: Boyer-Moore算法的实现。源类：BoyerMoore'
- en: Go to [https://goo.gl/71mXd6](https://goo.gl/71mXd6) to access this code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[https://goo.gl/71mXd6](https://goo.gl/71mXd6)访问此代码。
- en: In this section, we've introduced the Boyer-Moore algorithm as an improvement
    over the naive search algorithm. By preprocessing the pattern to skip unnecessary
    shifts, we can decrease the average runtime complexity of the string matching
    algorithm. In the following section, we will list some other string matching algorithms,
    listing their applicability, but without going into much detail about their implementation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了Boyer-Moore算法作为对朴素搜索算法的改进。通过预处理模式以跳过不必要的位移，我们可以降低字符串匹配算法的平均运行时间复杂度。在下一节中，我们将列出一些其他字符串匹配算法，列出它们的适用性，但不会深入其实现细节。
- en: Introducing Other String Matching Algorithms
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍其他字符串匹配算法
- en: 'Even though the Boyer-Moore string search algorithm is the standard benchmark
    for practical string search literature, there are other string matching algorithms
    that are also suitable for different purposes. In this small section, we present
    the following three, which are the most famous ones:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Boyer-Moore字符串搜索算法是实际字符串搜索文献的标准基准，但还有其他字符串匹配算法也适合不同的目的。在本小节中，我们介绍了以下三个最著名的算法：
- en: Rabin-Karp
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rabin-Karp
- en: Knuth-Morris-Pratt
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Knuth-Morris-Pratt
- en: Aho-Corasick
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Aho-Corasick
- en: However, only give out the implementation of Rabin-Karp.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅提供Rabin-Karp的实现。
- en: Rabin-Karp
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rabin-Karp
- en: In 1987, Richard M. Karp and Michael O. Rabin proposed a string matching algorithm
    that performs well in practice and generalizes string matching against a set of
    patterns. The Rabin-Karp algorithm takes *O(m)* time in its preprocessing stage
    and its worst-case running time is *O((n - m + 1)m)*, similar to Boyer-Moore's.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在1987年，理查德·M·卡普和迈克尔·O·拉宾提出了一种字符串匹配算法，该算法在实际应用中表现良好，并能将字符串匹配推广到一组模式。Rabin-Karp算法在其预处理阶段需要*O(m)*时间，其最坏情况运行时间是*O((n
    - m + 1)m)*，与Boyer-Moore算法相似。
- en: To better introduce the Rabin-Karp algorithm, let's assume that our alphabet
    ∑ is composed only of decimal digits *(∑ = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9})*, so
    that we can view a string of *k* characters as a decimal number with length *k*.
    Therefore, string 12345 corresponds to number 12345\. Given a pattern *P[0...m]*
    and a substring from text *T[i...i + m]*, if we convert both those strings to
    their correspondent decimal number, so that we have numbers *p* and *t[i]*, then
    *p = t[i]* only if *P[0...m] = T[i...i + m]*, and therefore *i* is only a valid
    shift if *p = t[i]*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地介绍Rabin-Karp算法，让我们假设我们的字母表∑仅由十进制数字组成*(∑ = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9})*，这样我们就可以将*个字符的字符串视为长度为*k*的十进制数。因此，字符串12345对应于数字12345。给定一个模式*P[0...m]*和文本中的子串*T[i...i
    + m]*，如果我们将这两个字符串转换为它们对应的十进制数，那么我们就有数字*p*和*t[i]*，那么*p = t[i]*仅当*P[0...m] = T[i...i
    + m]*，因此*i*仅是一个有效的位移，如果*p = t[i]*。
- en: If we could compute p in *O(m)* time and all the t[i] values in *O(n - m + 1)*
    time, then we could determine all valid shifts in *O(n)* time by comparing p with
    each of the *t[i]* values. The problem with this is when *p* and *t[i]* are too
    large to work with. If the numbers are too large, then we can work with them modulo
    *q*, for a suitable modulus *q*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能在*O(m)*时间内计算p，并在*O(n - m + 1)*时间内计算所有t[i]值，那么我们就可以通过将p与每个t[i]值进行比较，在*O(n)*时间内确定所有有效的位移。这个问题在于当*p*和*t[i]*太大而无法处理时。如果数字太大，那么我们可以使用模*q*来处理它们，对于合适的模数*q*。
- en: Let's leave the choice of a suitable modulus *q* for later. How we can generalize
    this to work with other alphabets? For example, what if we want to use characters
    that are not decimal digits?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍后再考虑选择合适的模数*q*。我们如何将此推广到处理其他字母表？例如，如果我们想使用不是十进制数字的字符怎么办？
- en: Consider that, in the case of our original alphabet, to convert a string 12345
    into a number, we would perform the operation *10⁴*1+10³*2+10²*3+10¹*4+10⁰*5*.
    If we have a D-ary alphabet *{0, 1… d - 1}*, then we could use the same strategy,
    but replace 10 by *d*. One other consideration to have is that, when we have computed
    *t[i]* and we want to compute *t[i+1]*, then we can simply remove the leftmost
    digit, shift everything to the left, and add the newest digit, that is, *t[i+1]
    = ((t[i] - T[i]*d[m-1])*d + T[i + 1]) % q*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到，在我们的原始字母表中，要将字符串12345转换为数字，我们会执行操作*10⁴*1+10³*2+10²*3+10¹*4+10⁰*5*。如果我们有一个D进制字母表*{0,
    1… d - 1}*，那么我们可以使用相同的策略，但将10替换为*d*。另一个需要考虑的是，当我们已经计算了*t[i]*并想要计算*t[i+1]*时，我们可以简单地移除最左边的数字，将所有内容向左移动，并添加最新的数字，即*t[i+1]
    = ((t[i] - T[i]*d[m-1])*d + T[i + 1]) % q*。
- en: One final consideration to have is that working with modulo *q* is not perfect.
    *t[i] = p (mod q)* does not imply that *t[i] = p*. But if *t[i] != p* *(mod q)*,
    then *t[i] != p*. We can therefore use this as a fast heuristic test to rule out
    invalid shifts.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个需要考虑的是，使用模*q*并不完美。*t[i] = p (mod q)*并不一定意味着*t[i] = p*。但如果*t[i] != p* *(mod
    q)*，那么*t[i] != p*。因此，我们可以将其用作快速启发式测试，以排除无效的位移。
- en: Applying the Rabin-Karp Algorithm
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用Rabin-Karp算法
- en: The aim here is to develop a code in Java for implementing the Rabin-Karp algorithm
    for matching a string from a set of alphabetical characters that have decimal
    digits.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的目标是开发一个Java代码，以实现Rabin-Karp算法，用于匹配一组具有十进制数字的字母字符集中的字符串。
- en: 'Perform the following steps:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Convert the text and pattern strings into digits.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文本和模式字符串转换为数字。
- en: Use if and for loops to calculate the number of matching characters.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用if和for循环来计算匹配字符的数量。
- en: 'Put everything together to implement the Rabin-Karp algorithm. The following
    *Snippet 5.9* shows the pre-compute part of the algorithm:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有内容组合起来以实现Rabin-Karp算法。以下*片段5.9*显示了算法的预计算部分：
- en: '[PRE8]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Snippet 5.9: Implementation of the Rabin-Karp algorithm. Source class name: RabinKarp'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 片段5.9：Rabin-Karp算法的实现。源类名：RabinKarp
- en: Go to [https://goo.gl/w7yzPA](https://goo.gl/w7yzPA) to access this code.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[https://goo.gl/w7yzPA](https://goo.gl/w7yzPA)以获取此代码。
- en: In the previous implementation, we chose *q* as a large prime number (using
    the `BigInteger` API). We did that so that we have a good hash function and avoided
    the most of false positives from the *p = t[i]* comparison. This is a similar
    technique to the one we saw in the remainder method for hash tables in [Chapter
    3](05da549e-383b-475e-86f2-043f47a226a1.xhtml), *Hash Tables and Binary Search
    Trees*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的实现中，我们选择*q*为一个大的质数（使用`BigInteger` API）。我们这样做是为了有一个好的哈希函数，并避免*p = t[i]*比较中的大多数误报。这与我们在[第3章](05da549e-383b-475e-86f2-043f47a226a1.xhtml)中看到的哈希表余数方法中的类似技术。
- en: Despite being outside the scope of this book, the Rabin-Karp algorithm generalizes
    well to having a set of patterns to be found in the same text. For that purpose,
    it is frequently used in plagiarism detection.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这超出了本书的范围，但Rabin-Karp算法很好地推广到在相同文本中查找一组模式。为此，它经常用于剽窃检测。
- en: Knuth–Morris–Pratt
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Knuth–Morris–Pratt
- en: The **Knuth-Morris-Pratt** (**KMP**) algorithm is a single-pattern string searching
    algorithm conceived by Donald Knuth and Vaughan Pratt in 1970, and independently
    by James H. Morris, being jointly published by the three in 1977\. When compared
    to the Boyer-Moore algorithm, KMP employs the observation that, when a mismatch
    occurs, the pattern embodies sufficient information to determine where the next
    match could begin.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**Knuth-Morris-Pratt**（**KMP**）算法是由唐纳德·克努特和瓦奥恩·普拉特在1970年构思的单模式字符串搜索算法，由詹姆斯·H·莫里斯独立提出，三人于1977年共同发表。与Boyer-Moore算法相比，KMP算法利用了这样一个观察：当发生不匹配时，模式包含足够的信息来确定下一次匹配可能开始的位置。'
- en: It is similar to Boyer-Moore in the sense that it efficiently skips unnecessary
    comparisons. The KMP algorithm has a running time of *O(n)*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 它与Boyer-Moore算法类似，因为它能够有效地跳过不必要的比较。KMP算法的时间复杂度为*O(n)*。
- en: Aho–Corasick
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Aho–Corasick
- en: The Aho-Corasick algorithm is a string searching algorithm invented by Alfred
    V. Aho and Margaret J. Corasick. Similar to the extended version of the Rabin-Karp
    algorithm, it is capable of matching elements of a dictionary (set of words) within
    an input text. The idea behind it is to build a finite state machine that enables
    matching all strings of the dictionary simultaneously. The algorithm is linear
    in the length of the strings, plus the length of the searched text, plus the number
    of output matches. If *n* is the length of the searched text, *m* is the sum of
    the length of all words in the dictionary, and *z* is the total number of occurrences
    of words in the text.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Aho-Corasick算法是由阿尔弗雷德·V·阿霍和玛格丽特·J·科拉斯克发明的一种字符串搜索算法。类似于Rabin-Karp算法的扩展版本，它能够在输入文本中匹配字典（单词集合）中的元素。其背后的思想是构建一个有限状态机，能够同时匹配字典中的所有字符串。算法的时间复杂度是字符串长度、搜索文本长度以及输出匹配次数的总和。如果*n*是搜索文本的长度，*m*是字典中所有单词长度的总和，*z*是文本中单词的总出现次数。
- en: Therefore, the time complexity of the Aho-Corasick algorithm is *O(n + m + z)*.
    In this small section, we've looked at three other famous string matching algorithms.
    Without going into much detail about them, we've seen their applicability on different
    problems other than the one the Boyer-Moore algorithm solves. In particular, we've
    noted that there are algorithms specialized for the finding of a set of patterns
    in a text.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Aho-Corasick算法的时间复杂度为*O(n + m + z*)。在本小节中，我们探讨了三种其他著名的字符串匹配算法。我们没有深入探讨它们的细节，但已经看到了它们在除了Boyer-Moore算法解决的问题之外的其他问题上的适用性。特别是，我们注意到有一些算法专门用于在文本中查找一组模式。
- en: In 1979, Zvi Galil introduced an important optimization, called the Galil rule, that
    speeds up the comparisons done at each shift by skipping sections that are known
    to match. Using the Galil rule, the Boyer-Moore algorithm achieves linear time
    complexity in the worst case.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在1979年，Zvi Galil引入了一个重要的优化，称为Galil规则，通过跳过已知匹配的部分来加快每次移位时的比较速度。使用Galil规则，Boyer-Moore算法在最坏情况下实现了线性时间复杂度。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have introduced the string matching problem. We've started
    from the naive search algorithm and improved it by using the rules introduced
    by Boyer and Moore. We've seen how these rules improve the average runtime complexity
    of our algorithm. We've also explored some other string matching algorithms without going
    into too much detail about them. In the next chapter, we will be exploring graphs and
    their applications
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了字符串匹配问题。我们从朴素搜索算法开始，通过使用Boyer和Moore提出的规则对其进行了改进。我们看到了这些规则如何提高我们算法的平均运行时间复杂度。我们还探索了一些其他字符串匹配算法，而没有对这些算法的细节进行过多讨论。在下一章中，我们将探讨图及其应用。
