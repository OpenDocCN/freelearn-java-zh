- en: Multicasting, Replaying, and Caching
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多播、重放和缓存
- en: We have seen the hot and cold `Observable` in action throughout this book, although
    most of our examples have been cold Observables (even ones using `Observable.interval()`).
    As a matter of fact, there are a lot of subtleties in the hotness and coldness
    of Observables, which we will look at in this chapter. When you have more than
    one `Observer`, the default behavior is to create a separate stream for each one.
    This may or may not be desirable, and we need to be aware of when to force an
    `Observable` to be hot by multicasting using a `ConnectableObservable`. We got
    a brief introduction to the `ConnectableObservable` in [Chapter 2](7fea3844-94e9-442e-9d54-239d146a8250.xhtml),
    *Observables and Subscribers*, but we will look at it in deeper context within
    an entire `Observable` chain of operators.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中已经看到了热和冷`Observable`的实际应用，尽管我们的大部分例子都是冷`Observable`（甚至包括使用`Observable.interval()`的例子）。事实上，在`Observable`的热和冷特性中有很多细微之处，我们将在本章中探讨。当你有多个`Observer`时，默认行为是为每个`Observer`创建一个单独的流。这可能是或可能不是期望的，我们需要意识到何时需要通过多播使用`ConnectableObservable`来强制`Observable`变为热。我们在[第二章](7fea3844-94e9-442e-9d54-239d146a8250.xhtml)，*Observables
    and Subscribers*中简要介绍了`ConnectableObservable`，但我们将在一个完整的`Observable`操作符链的更深入背景下探讨它。
- en: In this chapter, we will learn about multicasting with `ConnectableObservable`
    in detail and uncover its subtleties. We will also learn about replaying and caching,
    both of which multicast and leverage the `ConnectableObservable`. Finally, we
    will learn about Subjects, a utility that can be useful for decoupling while multicasting but
    should be used conservatively for only certain situations. We will cover the different
    flavors of subjects as well as when and when not to use them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细学习使用`ConnectableObservable`进行多播，并揭示其细微之处。我们还将学习重放和缓存，这两者都进行多播并利用`ConnectableObservable`。最后，我们将学习Subjects，这是一个在多播时可能很有用的工具，但应该谨慎使用，仅适用于特定情况。我们将涵盖不同类型的Subjects，以及何时以及何时不应使用它们。
- en: 'Here is a broad outline of what to expect:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个预期的概要：
- en: Understanding multicasting
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解多播
- en: Automatic connection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动连接
- en: Replaying and caching
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重放和缓存
- en: Subjects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Subjects
- en: Understanding multicasting
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解多播
- en: 'We have used the `ConnectableObservable` earlier in [Chapter 2](7fea3844-94e9-442e-9d54-239d146a8250.xhtml), *Observables
    and Subscribers*. Remember how cold Observables, such as `Observable.range()`,
    will regenerate emissions for each `Observer`? Let''s take a look at the following
    code:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第二章](7fea3844-94e9-442e-9d54-239d146a8250.xhtml)，*Observables and Subscribers*中之前已经使用过`ConnectableObservable`。还记得冷`Observable`，例如`Observable.range()`，会为每个`Observer`重新生成发射吗？让我们看一下以下代码：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output is as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, `Observer One` received all three emissions and called `onComplete()`.
    After that, `Observer Two` received the three emissions (which were regenerated
    again) and called `onComplete()`. These were two separate streams of data generated
    for two separate subscriptions. If we wanted to consolidate them into a single
    stream of data that pushes each emission to both Observers simultaneously, we
    can call `publish()` on `Observable`, which will return a `ConnectableObservable`.
    We can set up the Observers in advance and then call `connect()` to start firing
    the emissions so both Observers receive the same emissions simultaneously. This
    will be indicated by the printing of each `Observer` interleaving here:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Observer One`接收了所有三个发射并调用了`onComplete()`。之后，`Observer Two`接收了三个发射（这些发射再次被生成）并调用了`onComplete()`。这些是为两个不同的订阅生成的两个单独的数据流。如果我们想将它们合并成一个数据流，同时将每个发射推送到两个Observer，我们可以在`Observable`上调用`publish()`，这将返回一个`ConnectableObservable`。我们可以在事先设置好Observer后，然后调用`connect()`来开始发射，这样两个Observer将同时接收相同的发射。这将通过以下打印的每个`Observer`的交错来表示：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output is as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using `ConnectableObservable` will force emissions from the source to become
    hot, pushing a single stream of emissions to all Observers at the same time rather
    than giving a separate stream to each `Observer`. This idea of stream consolidation
    is known as multicasting, but there are nuances to it, especially when operators
    become involved. Even when you call `publish()`and use a `ConnectableObservable`,
    any operators that follow can create separate streams again. We will take a look
    at this behavior and how to manage it next.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ConnectableObservable` 将迫使源发射变为热发射，将单个发射流同时推送到所有观察者，而不是为每个 `Observer` 提供单独的流。这种流合并的想法被称为多播，但其中有一些细微差别，尤其是在操作符介入时。即使你调用
    `publish()` 并使用 `ConnectableObservable`，任何后续的操作符也可以再次创建单独的流。我们将探讨这种行为以及如何管理它。
- en: Multicasting with operators
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用操作符进行多播
- en: To see how multicasting works within a chain of operators, we are going to use `Observable.range()`
    and then map each emission to a random integer. Since these random values will
    be nondeterministic and different for each subscription, this will provide a good
    means to see whether our multicasting is working because Observers should receive
    the same numbers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看操作符链中的多播是如何工作的，我们将使用 `Observable.range()` 并将每个发射映射到一个随机整数。由于这些随机值将是非确定性的，并且对于每个订阅都是不同的，这将为我们提供一个很好的方法来查看我们的多播是否工作，因为观察者应该接收到相同的数字。
- en: 'Let''s start with emitting the numbers 1 through 3 and map each one to a random
    integer between 0 and 100,000\. If we have two Observers, we can expect different
    integers for each one. Note that your output will be different than mine due to
    the random number generation and just acknowledge that both Observers are receiving
    different random integers:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从发射数字 1 到 3 开始，并将每个数字映射到 0 到 100,000 之间的一个随机整数。如果我们有两个观察者，我们可以预期每个观察者都会得到不同的整数。请注意，由于随机数生成，你的输出将不同于我的输出，只是承认两个观察者都在接收不同的随机整数：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output is as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'What happens here is that the `Observable.range()` source will yield two separate
    emission generators, and each will coldly emit a separate stream for each `Observer`.
    Each stream also has its own separate `map()` instance, hence each `Observer`
    gets different random integers. You can visually see this structure of two separate
    streams in the following figure:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 发生在这里的是，`Observable.range()` 源将产生两个独立的发射生成器，并且每个生成器将为每个 `Observer` 冷发射一个单独的流。每个流也有它自己的单独的
    `map()` 实例，因此每个 `Observer` 都得到不同的随机整数。你可以在以下图中直观地看到这两个单独的流的结构：
- en: '![](img/1177eebf-3c77-4e22-b990-12dcfd877448.png)**Figure 5.1** - Two separate
    streams of operations are created for each Observer'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/1177eebf-3c77-4e22-b990-12dcfd877448.png)**图 5.1** - 为每个观察者创建了两个独立的操作流'
- en: 'Say, you want to emit the same three random integers to both Observers. Your
    first instinct might be to call `publish()` after `Observable.range()` to yield
    a `ConnectableObservable`. Then, you may call the `map()` operator on it, followed
    by the Observers and a `connect()` call. But you will see that this does not achieve
    our desired result. Each `Observer` still gets three separate random integers:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要向两个观察者发射相同的三个随机整数。你的第一个直觉可能是调用 `publish()` 在 `Observable.range()` 之后，以产生一个
    `ConnectableObservable`。然后，你可以在它上面调用 `map()` 操作符，接着是观察者和一个 `connect()` 调用。但你将看到这并没有达到我们期望的结果。每个
    `Observer` 仍然得到三个不同的随机整数：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This occurred because we multicast *after* `Observable.range()`, but the multicasting
    happens before the `map()` operator. Even though we consolidated to one set of
    emissions coming from `Observable.range()`, each `Observer` is still going to
    get a separate stream at `map()`. Everything before `publish()` was consolidated
    into a single stream (or more technically, a single proxy `Observer`). But after
    `publish()`, it will fork into separate streams for each `Observer` again, as
    shown in the following figure:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们在 `Observable.range()` 之后进行了多播，但多播发生在 `map()` 操作符之前。尽管我们合并了来自 `Observable.range()`
    的一组发射，但每个观察者仍然会在 `map()` 时得到一个单独的流。`publish()` 之前的一切都被合并到一个单独的流中（或者更技术地说，一个单独的代理
    `Observer`）。但在 `publish()` 之后，它将再次为每个观察者分叉成单独的流，如图所示：
- en: '![](img/c5e50532-6875-466d-8773-3a92168cc253.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c5e50532-6875-466d-8773-3a92168cc253.png)'
- en: Figure 5.2 - Mulitcasting after Observable.range() will consolidate the interval
    emissions into a single stream before publish(), but will still fork to two separate
    streams after publish() for each Observer.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 - 在 `Observable.range()` 之后进行多播将合并间隔发射到一个单独的流，但在 `publish()` 之后仍将为每个观察者分叉成两个单独的流。
- en: 'If we want to prevent the `map()` operator from yielding two separate streams
    for each `Observer`, we need to call `publish()` after `map()` instead:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要防止`map()`操作符为每个`Observer`产生两个独立的数据流，我们需要在`map()`之后调用`publish()`：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'That is better! Each `Observer` got the same three random integers, and we
    have effectively multicast the entire operation right before the two Observers,
    as shown in the following figure. We now have a single stream instance throughout
    the entire chain since `map()` is now behind, not in front, of `publish()`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更好！每个`Observer`都得到了相同的三个随机整数，我们有效地在两个`Observer`之前多播了整个操作，如下面的图所示。现在，由于`map()`现在在`publish()`之后，整个链中只有一个流实例：
- en: '![](img/5dc580de-2dd5-4c4b-8606-a471a3f8840b.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5dc580de-2dd5-4c4b-8606-a471a3f8840b.png)'
- en: Figure 5.3 - A fully multicast operation that guarantees both Observers get
    the same emissions since all operators are behind the publish() call
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 - 一个完全多播的操作，保证两个`Observer`都能接收到相同的排放，因为所有操作都在`publish()`调用之后
- en: When to multicast
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时进行多播
- en: Multicasting is helpful in preventing redundant work being done by multiple
    Observers and instead makes all Observers subscribe to a single stream, at least
    to the point where they have operations in common. You may do this to increase
    performance, reducing memory and CPU usage, or simply because your business logic
    requires pushing the same emissions to all Observers.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 多播有助于防止多个`Observer`执行冗余工作，并且使所有`Observer`订阅单个数据流，至少在它们有共同操作这一点上是这样。你可能这样做是为了提高性能，减少内存和CPU使用，或者仅仅因为你的业务逻辑需要将相同的排放推送到所有`Observer`。
- en: Data-driven cold Observables should only be multicast when you are doing so
    for performance reasons and have multiple Observers receiving the same data simultaneously.
    Remember that multicasting creates hot `ConnectableObservables`, and you have
    to be careful and time the `connect()` call so data is not missed by Observers.
    Typically in your API, keep your cold Observables cold and call `publish()` when
    you need to make them hot.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 数据驱动的冷`Observable`只有在出于性能原因并且有多个`Observer`同时接收相同数据时才应该进行多播。记住，多播会创建热`ConnectableObservables`，你必须小心并适时调用`connect()`，以确保数据不会被`Observer`错过。通常在你的API中，保持你的冷`Observable`为冷状态，并在需要将其变为热状态时调用`publish()`。
- en: Even if your source `Observable` is hot (such as a UI event in JavaFX or Android),
    putting operators against that `Observable` can cause redundant work and listeners.
    It is not necessary to multicast when there is only a single `Observer` (and multicasting
    can cause unnecessary overhead). But if there are multiple Observers, you need
    to find the proxy point where you can multicast and consolidate the upstream operations.
    This point is typically the boundary where Observers have common operations upstream and
    diverge into different operations downstream.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你的源`Observable`是热的（例如JavaFX或Android中的UI事件），对该`Observable`应用操作符也可能导致冗余工作和监听器。当只有一个`Observer`时（并且多播可能引起不必要的开销），没有必要进行多播。但是如果有多个`Observer`，你需要找到可以进行多播和整合上游操作的代理点。这个点通常是`Observer`在上游有共同操作而下游分叉的不同操作的边界。
- en: 'For instance, you may have one `Observer` that prints the random integers but
    another one that finds the sum with `reduce()`. At this point, that single stream
    should, in fact, fork into two separate streams because they are no longer redundant
    and doing different work, as shown in the following code snippet:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能有一个`Observer`用于打印随机整数，另一个`Observer`使用`reduce()`来计算总和。在这个阶段，实际上这个单一的数据流应该分成两个独立的数据流，因为它们不再冗余，正在执行不同的任务，如下面的代码片段所示：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is a visual diagram showing the common operations being multicasted:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个显示正在多播的常见操作的视觉图：
- en: '**![](img/b0fc9938-a5c9-4d07-899c-7346de057c9f.png)**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/b0fc9938-a5c9-4d07-899c-7346de057c9f.png)**'
- en: Figure 5.4 - Common operations that are shared between both Observers are put
    behind publish(), but divergent operations happen after publish()
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 - 两个`Observer`之间共享的常见操作放在`publish()`之后，而分叉操作发生在`publish()`之后
- en: With a thorough understanding of `ConnectableObservable` and multicasting under
    our belt, we will move on to some convenience operators that help streamline multicasting.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在对`ConnectableObservable`和多播有充分理解的基础上，我们将继续探讨一些有助于简化多播的便利操作符。
- en: Automatic connection
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动连接
- en: There are definitely times you will want to manually call `connect()` on `ConnectableObservable`
    to precisely control when the emissions start firing. There are convenient operators
    that automatically call `connect()` for you, but with this convenience, it is
    important to have awareness of their subscribe timing behaviors. Allowing an `Observable`
    to dynamically connect can backfire if you are not careful, as emissions can be
    missed by Observers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 确实有需要手动在`ConnectableObservable`上调用`connect()`的时候，以便精确控制发射开始触发的时间。有一些方便的操作符会自动为你调用`connect()`，但有了这种便利，了解它们的订阅时间行为就很重要了。如果你不小心，允许`Observable`动态连接可能会适得其反，因为Observers可能会错过发射。
- en: autoConnect()
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: autoConnect()
- en: 'The `autoConnect()` operator on `ConnectableObservable` can be quite handy.
    For a given `ConnectableObservable<T>`, calling `autoConnect()` will return an
    `Observable<T>` that will automatically call `connect()` after a specified number
    of Observers are subscribed. Since our previous example had two Observers, we
    can streamline it by calling `autoConnect(2)` immediately after `publish()`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConnectableObservable`上的`autoConnect()`操作符非常方便。对于给定的`ConnectableObservable<T>`，调用`autoConnect()`将返回一个`Observable<T>`，该`Observable<T>`将在指定数量的Observers订阅后自动调用`connect()`。由于我们之前的例子有两个Observers，我们可以在`publish()`之后立即调用`autoConnect(2)`来简化流程：'
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output is as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This saved us the trouble of having to save `ConnectableObservable` and call
    its `connect()` method later. Instead, it will start firing when it gets `2` subscriptions,
    which we have planned and specified as an argument in advance. Obviously, this
    does not work well when you have an unknown number of Observers and you want all
    of them to receive all emissions.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这避免了我们需要保存`ConnectableObservable`并稍后调用其`connect()`方法的问题。相反，它将在获得`2`个订阅时开始触发，这是我们提前计划和指定的参数。显然，当你有一个未知数量的Observers并且你希望他们都能接收到所有发射时，这不会很好地工作。
- en: 'Even when all downstream Observers finish or dispose, `autoConnect()` will
    persist its subscription to the source. If the source is finite and disposes,
    it will not subscribe to it again when a new `Observer` subscribes downstream.
    If we add a third `Observer` to our example but keep `autoConnect()` specified
    at `2` instead of `3`, it is likely that the third `Observer` is going to miss
    the emissions:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 即使所有下游Observers完成或销毁，`autoConnect()`也会持续其对源的订阅。如果源是有限的并且被销毁，那么当新的`Observer`在下游订阅时，它将不会再次订阅它。如果我们向我们的例子中添加第三个`Observer`，但将`autoConnect()`指定为`2`而不是`3`，那么第三个`Observer`很可能会错过发射：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output is as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Note that if you pass no argument for `numberOfSubscribers`, it will default
    to `1`. This can be helpful if you want it to start firing on the first subscription
    and do not care about any subsequent Observers missing previous emissions. Here,
    we `publish` and `autoConnect` the `Observable.interval()`. The first `Observer`
    starts the firing of emissions, and 3 seconds later, another `Observer` comes
    in but misses the first few emissions. But it does receive the live emissions
    from that point on:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你没有为`numberOfSubscribers`传递任何参数，它将默认为`1`。如果你希望它在第一次订阅时开始触发，并且不关心后续的Observers错过之前的发射，这可能会很有帮助。在这里，我们`publish`并`autoConnect`了`Observable.interval()`。第一个`Observer`开始触发发射，3秒后，另一个`Observer`到来，但错过了最初的几次发射。但从那时起，它确实接收到了实时的发射：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you pass `0` to `autoConnect()` for the `numberOfSubscribers` argument, it
    will start firing immediately and not wait for any `Observers`. This can be handy
    to start firing emissions immediately without waiting for any Observers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将`autoConnect()`函数的`numberOfSubscribers`参数传递为`0`，它将立即开始触发，而不等待任何`Observers`。这可以在不等待任何Observers的情况下立即开始触发发射非常有用。
- en: refCount() and share()
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: refCount() 和 share()
- en: The `refCount()` operator on `ConnectableObservable` is similar to `autoConnect(1)`,which
    fires  after getting one subscription. But there is one important difference;
    when it has no Observers anymore, it will dispose of itself and start over when
    a new one comes in. It does not persist the subscription to the source when it
    has no more Observers, and when another `Observer` follows, it will essentially
    "start over".
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConnectableObservable`上的`refCount()`操作符类似于`autoConnect(1)`，它在获得一个订阅后触发。但有一个重要的区别；当它不再有任何Observers时，它会销毁自己，并在新的一个到来时重新开始。当它没有更多的Observers时，它不会持续对源的订阅，当另一个`Observer`跟随时，它将基本上“重新开始”。'
- en: 'Look at this example: we have `Observable.interval()` emitting every second,
    and it is multicast with `refCount()`. `Observer 1` takes five emissions, and
    `Observer 2` takes two emissions. We stagger their subscriptions with our `sleep()`
    function to put three-second gaps between them. Because these two subscriptions
    are finite due to the `take()` operators, they should be terminated by the time
    `Observer 3` comes in, and there should no longer be any previous Observers. Note
    how `Observer 3` has started over with a fresh set of intervals starting at `0`!
    Let''s take a look at the following code snippet:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 看这个例子：我们有一个每秒发射一次的 `Observable.interval()`，它通过 `refCount()` 进行多播。`Observer 1`
    接收了五个发射，而 `Observer 2` 接收了两个发射。我们使用 `sleep()` 函数将它们的订阅错开，它们之间有3秒的间隔。由于这两个订阅由于
    `take()` 操作符而有限，它们应该在 `Observer 3` 来之前终止，并且不应该再有之前的观察者。注意 `Observer 3` 是从 `0`
    开始的全新间隔重新开始的！让我们看一下以下代码片段：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Using `refCount()` can be helpful to multicast between multiple Observers but
    dispose of the upstream connection when no downstream Observers are present anymore.
    You can also use an alias for `publish().refCount()` using the `share()` operator.
    This will accomplish the same result:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `refCount()` 可以在多个观察者之间多播，但在没有下游观察者时销毁上游连接。您还可以使用 `share()` 操作符为 `publish().refCount()`
    创建别名。这将达到相同的结果：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Replaying and caching
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新播放和缓存
- en: Multicasting also allows us to cache values that are shared across multiple
    Observers. This may sound surprising, but when you think about it long enough,
    you may realize this makes sense. If we are sharing data across multiple Observers,
    it makes sense that any caching feature would be shared across Observers too.
    Replaying and caching data is a multicasting activity, and we will explore how
    to do it safely and efficiently with RxJava.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 多播还允许我们在多个观察者之间缓存共享的值。这听起来可能有些令人惊讶，但当你仔细思考时，你可能会意识到这是有道理的。如果我们正在多个观察者之间共享数据，那么任何缓存功能也应该在观察者之间共享。重新播放和缓存数据是一种多播活动，我们将探讨如何使用
    RxJava 安全且高效地完成它。
- en: Replaying
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新播放
- en: The `replay()` operator is a powerful way to hold onto previous emissions within
    a certain scope and re-emit them when a new `Observer` comes in. It will return
    a `ConnectableObservable` that will both multicast emissions as well as emit previous
    emissions defined in a scope. Previous emissions it caches will fire immediately
    to a new `Observer` so it is caught up, and then it will fire current emissions
    from that point forward.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`replay()` 操作符是一种强大的方式，可以在一定范围内保留之前的发射，并在新的 `Observer` 加入时重新发射它们。它将返回一个 `ConnectableObservable`，它将多播发射以及发射在范围内定义的之前发射。它缓存的之前发射将立即触发新的
    `Observer` 以使其跟上，然后它将从该点开始触发当前发射。'
- en: 'Let''s start with a `replay()` with no arguments. This will replay all previous
    emissions to tardy Observers, and then emit current emissions as soon as the tardy
    `Observer` is caught up. If we use `Observable.interval()` to emit every second,
    we can call `replay()` on it to multicast and replay previous integer emissions.
    Since `replay()` returns `ConnectableObservable`, let''s use `autoConnect()` so
    it starts firing on the first subscription. After 3 seconds, we will bring in
    a second `Observer`. Look closely at what happens:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从不带参数的 `replay()` 开始。这将重新播放所有之前的发射给延迟的观察者，然后一旦延迟的 `Observer` 跟上，就立即发射当前的发射。如果我们使用
    `Observable.interval()` 每秒发射一次，我们可以在它上面调用 `replay()` 来多播和重新播放之前的整数发射。由于 `replay()`
    返回 `ConnectableObservable`，让我们使用 `autoConnect()` 以便它在第一次订阅时开始发射。3秒后，我们将引入第二个 `Observer`。仔细观察发生了什么：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Did you see that? After 3 seconds, `Observer 2` came in and immediately received
    the first three emissions it missed: `0`, `1`, and `2`. After that, it receives
    the same emissions as `Observer 1` going forward. Just note that this can get
    expensive with memory, as `replay()` will keep caching all emissions it receives.
    If the source is infinite or you only care about the last previous emissions,
    you might want to specify a `bufferSize` argument to limit only replaying a certain
    number of last emissions. If we called `replay(2)` on our second `Observer` to
    cache the last two emissions, it will not get 0, but it will receive `1` and `2`.
    The `0` fell out of that window and was released from the cache as soon as `2`
    came in.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了吗？在 3 秒后，`Observer 2` 进入并立即接收到了它错过的前三个排放：`0`、`1` 和 `2`。之后，它接收到的排放与 `Observer
    1` 相同。请注意，这可能会因为内存而变得昂贵，因为 `replay()` 会持续缓存它接收到的所有排放。如果源是无限的，或者你只关心最后的前排放，你可能想指定一个
    `bufferSize` 参数来限制只重放一定数量的最后排放。如果我们对第二个观察者调用 `replay(2)` 来缓存最后两个排放，它将不会得到 `0`，但它将接收到
    `1` 和 `2`。`0` 落出了那个窗口，并在 `2` 进入时从缓存中释放。
- en: 'The output is as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note that if you always want to persist the cached values in your `replay()`even
    if there are no subscriptions, use it in conjunction with `autoConnect()`, not
    `refCount()`. If we emit our `Alpha` through `Epsilon` strings and use `replay(1).autoConnect()`
    to hold on to the last value, our second `Observer` will only receive the last
    value, as expected:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你总是想在 `replay()` 中持久化缓存的值，即使没有订阅，也要与 `autoConnect()` 一起使用，而不是 `refCount()`。如果我们通过
    `Epsilon` 字符串发出 `Alpha` 并使用 `replay(1).autoConnect()` 来保留最后一个值，我们的第二个 `Observer`
    将只会接收到预期的最后一个值：
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output is as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Make a modification here to use `refCount()` instead of `autoConnect()` and
    see what happens:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里进行修改，使用 `refCount()` 而不是 `autoConnect()`，看看会发生什么：
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output is as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE27]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: What happened here is that `refCount()` causes the cache (and the entire chain)
    to dispose of and reset the moment `Observer 1` is done, as there are no more
    Observers. When `Observer 2` came in, it starts all over and emits everything
    just like it is the first Observer, and another cache is built. This may not be
    desirable, so you may consider using `autoConnect()` to persist the  state of `replay()` and
    not have it dispose of when no Observers are present.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的情况是，`refCount()` 导致缓存（以及整个链）在 `Observer 1` 完成时销毁并重置，因为没有更多的观察者。当 `Observer
    2` 进入时，它从头开始，就像它是第一个观察者一样，并构建另一个缓存。这可能不是期望的结果，因此你可能考虑使用 `autoConnect()` 来持久化 `replay()`
    的状态，而不是在没有观察者时销毁它。
- en: 'There are other overloads for `replay()`, particularly a time-based window
    you can specify. Here, we construct an `Observable.interval()` that emits every
    300 milliseconds and subscribe to it. We also map each emitted consecutive integer
    into the elapsed milliseconds. We will replay only the last 1 second of emissions
    for each new `Observer`, which we will bring in after 2 seconds:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`replay()` 有其他重载，特别是你可以指定的时间窗口。在这里，我们构建了一个每 300 毫秒发出一次的 `Observable.interval()`
    并订阅它。我们还映射每个发出的连续整数到已过毫秒数。我们将只重放每个新 `Observer` 的最后 1 秒的排放，我们将在 2 秒后引入它：'
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE29]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Look closely at the output, and you will see that when `Observer 2` comes in,
    it immediately receives emissions that happened in the last second, which were
    1500 and 1800\. After these two values are replayed, it receives the same emissions
    as `Observer 1` from that point on.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察输出，你会看到当 `Observer 2` 进入时，它立即接收到了上一秒发生的排放，即 1500 和 1800。在这两个值重放之后，它从那时起接收到的排放与
    `Observer 1` 相同。
- en: 'You can also specify a `bufferSize` argument on top of a time interval, so
    only a certain number of last emissions are buffered within that time period.
    If we modify our example to only replay one emission that occurred within the
    last second, it should only replay `1800` to `Observer 2`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在时间间隔之上指定 `bufferSize` 参数，这样在那一时间段内只缓冲一定数量的最后排放。如果我们修改我们的示例，只重放最后 1 秒内发生的排放，它应该只重放
    `1800` 给 `Observer 2`：
- en: '[PRE30]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE31]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Caching
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存
- en: 'When you want to cache all emissions indefinitely for the long term and do
    not need to control the subscription behavior to the source with `ConnectableObservable`,
    you can use the `cache()` operator. It will subscribe to the source on the first
    downstream `Observer` that subscribes and hold all values indefinitely. This makes
    it an unlikely candidate for infinite Observables or large amounts of data that
    could tax your memory:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要无限期地缓存所有排放物以供长期使用，并且不需要使用 `ConnectableObservable` 控制对源订阅的行为时，你可以使用 `cache()`
    操作符。它将在第一个下游 `Observer` 订阅时订阅源并无限期地保留所有值。这使得它不太可能成为无限观察者或可能耗尽你内存的大量数据的候选者：
- en: '[PRE32]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can also call `cacheWithInitialCapacity()` and specify the number of elements
    to be expected in the cache. This will optimize the buffer for that size of elements
    in advance:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以调用 `cacheWithInitialCapacity()` 并指定缓存中预期的元素数量。这将提前优化该大小元素的缓冲区：
- en: '[PRE33]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Again, do not use `cache()` unless you really want to hold all elements indefinitely
    and do not have plans to dispose it at any point. Otherwise, prefer `replay()`
    so you can more finely control cache sizing and windows as well as disposal policies.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，除非你真的想无限期地保留所有元素且没有计划在任何时候销毁它们，否则不要使用 `cache()`。否则，最好使用 `replay()`，这样你可以更精细地控制缓存大小和窗口以及销毁策略。
- en: Subjects
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Subjects
- en: Before we discuss Subjects, it would be remiss to not highlight, they have use
    cases but beginners often use them for the wrong ones, and end up in convoluted
    situations. As you will learn, they are both an `Observer` and an `Observable`**,**
    acting as a proxy mulitcasting device (kind of like an event bus). They do have
    their place in reactive programming, but you should strive to exhaust your other
    options before utilizing them. Erik Meijer, the creator of ReactiveX, described
    them as the "*mutable variables of reactive programming*". Just like mutable variables
    are necessary at times even though you should strive for immutability, Subjects
    are sometimes a necessary tool to reconcile imperative paradigms with reactive
    ones.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论 `Subject` 之前，如果不强调它们有使用场景，那就有些疏忽了。初学者经常错误地使用它们，最终陷入复杂的情况。正如你将要学习的，它们既是
    `Observer` 也是 `Observable`**，充当一个代理多播设备（有点像事件总线）。它们在响应式编程中确实有自己的位置，但在使用它们之前，你应该尽力用完其他选项。ReactiveX
    的创造者 Erik Meijer 将它们描述为响应式编程的“可变变量”。就像可变变量有时是必要的，尽管你应该努力追求不可变性一样，`Subject` 有时是调和命令式范式与响应式范式的一个必要工具。
- en: But before we discuss when to and when not to use them, let's take a look at
    what they exactly do.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们讨论何时以及何时不使用它们之前，让我们先看看它们究竟做了什么。
- en: PublishSubject
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PublishSubject
- en: There are a couple implementations of `Subject`, which is an abstract type that
    implements both `Observable` and `Observer`. This means that you can manually
    call `onNext()`, `onComplete()`, and `onError()` on a `Subject`**,** and it will,
    in turn, pass those events downstream toward its Observers.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subject` 有几种实现方式，它是一个抽象类型，实现了 `Observable` 和 `Observer`。这意味着你可以在 `Subject`
    上手动调用 `onNext()`、`onComplete()` 和 `onError()`，然后它将把这些事件逐级传递给它的观察者。'
- en: The simplest `Subject` type is the `PublishSubject`, which, like all Subjects,
    hotly broadcasts to its downstream Observers. Other `Subject` types add more behaviors,
    but `PublishSubject` is the "vanilla" type, if you will.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的 `Subject` 类型是 `PublishSubject`，它像所有 `Subject` 一样，向其下游观察者热切地广播。其他 `Subject`
    类型增加了更多行为，但 `PublishSubject` 是“原味”类型，如果你愿意这样称呼的话。
- en: 'We can declare a `Subject<String>`, create an `Observer` that maps its lengths
    and subscribes to it, and then call `onNext()` to pass three strings. We can also
    call `onComplete()` to communicate that no more events will be passed through
    this `Subject`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以声明一个 `Subject<String>`，创建一个映射其长度并订阅它的 `Observer`，然后调用 `onNext()` 来传递三个字符串。我们还可以调用
    `onComplete()` 来传达没有更多事件将通过这个 `Subject` 传递：
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output is as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This shows Subjects act like magical devices that can bridge imperative programming
    with reactive programming, and you would be right. Next, let's look at cases of
    when to and when not to use Subjects.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明 `Subject` 像神奇的设备一样，可以连接命令式编程和响应式编程，你是对的。接下来，让我们看看何时以及何时不使用 `Subject` 的案例。
- en: When to use Subjects
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用 `Subject`
- en: 'More likely, you will use Subjects to eagerly subscribe to an unknown number
    of multiple source Observables and consolidate their emissions as a single `Observable`.
    Since Subjects are an `Observer`, you can pass them to a `subscribe()` method
    easily. This can be helpful in modularized code bases where decoupling between
    Observables and Observers takes place and executing `Observable.merge()` is not
    that easy. Here, I use `Subject` to merge and multicast two `Observable` interval
    sources:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 更可能的是，你会使用`Subject`来积极订阅多个未知数量的源观察者，并将它们的发射合并为一个单一的`Observable`。由于`Subject`是一个`Observer`，你可以轻松地将它们传递给`subscribe()`方法。这在模块化代码库中可能很有帮助，在这些代码库中，观察者和观察者之间的解耦发生，并且执行`Observable.merge()`并不那么容易。在这里，我使用`Subject`来合并和广播两个`Observable`间隔源：
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE37]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Of course, I could use `Observable.merge()` to accomplish this (and technically
    for this case, I should). But when you have modularized code managed through dependency
    injection or other decoupling mechanisms, you may not have your `Observable` sources
    prepared in advance to put in `Observable.merge()`. For example, I could have
    a JavaFX application that has a refresh event coming from a menu bar, button,
    or a keystroke combination. I can declare these event sources as Observables and
    subscribe them to a `Subject` in a backing class to consolidate the event streams
    without any hard coupling.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我可以用`Observable.merge()`来完成这个任务（并且技术上我应该这样做）。但是，当你通过依赖注入或其他解耦机制管理模块化代码时，你可能没有提前准备好`Observable`源来放入`Observable.merge()`。例如，我可能有一个JavaFX应用程序，它有一个来自菜单栏、按钮或按键组合的刷新事件。我可以将这些事件源声明为观察者，并在后端类中将它们订阅到`Subject`上，以合并事件流，而不需要任何硬耦合。
- en: Another note to make is that the first `Observable` to call `onComplete()` on
    `Subject` is going to cease other `Observables` from pushing their emissions,
    and downstream cancellation requests are ignored. This means that you will most
    likely use Subjects for infinite, event-driven (that is, user action-driven) Observables.
    That being said, we will next look at cases where Subjects become prone to abuse.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意的是，第一个在`Subject`上调用`onComplete()`的`Observable`将停止其他`Observable`推送它们的发射，并且忽略下游的取消请求。这意味着你很可能会使用`Subject`来处理无限的事件驱动（即用户动作驱动）观察者。话虽如此，我们接下来将探讨`Subject`容易受到滥用的情况。
- en: When Subjects go wrong
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当`Subject`出错时
- en: 'Hopefully, you will feel that our earlier `Subject` example emitting `Alpha`,
    `Beta`, and `Gamma` is counterintuitive and backward considering how we have architected
    our reactive applications so far, and you would be right to think that way. We
    did not define the source emissions until the end after all the Observers are
    set up, and the process no longer reads left-to-right, top-to-bottom. Since Subjects
    are hot, executing the `onNext()` calls before the Observers are set up would
    result in these emissions being missed with our `Subject`. If you move the `onNext()`
    calls like this, you will not get any output because the `Observer` will miss
    these emissions:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你能感觉到，我们之前关于`Subject`的例子，发出`Alpha`、`Beta`和`Gamma`，在考虑到我们迄今为止如何架构我们的响应式应用时，可能显得有些反直觉和落后。你这样想是有道理的。我们是在所有观察者都设置完毕之后，才定义了源发射，这个过程不再是从左到右、从上到下读取。由于`Subject`是活跃的，在观察者设置之前执行`onNext()`调用会导致这些发射在我们的`Subject`中被遗漏。如果你像这样移动`onNext()`调用，你将不会得到任何输出，因为`Observer`会错过这些发射：
- en: '[PRE38]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This shows that Subjects can be somewhat haphazard and dangerous, especially
    if you expose them to your entire code base and any external code can call `onNext()`
    to pass emissions. For instance, say our `Subject` was exposed to an external
    API and something can arbitrarily pass the emission `Puppy` on top of `Alpha`,
    `Beta`, and `Gamma`. If we want our source to only emit these Greek letters, it
    is prone to receiving accidental or unwanted emissions. Reactive programming only
    maintains integrity when source Observables are derived from a well-defined and
    predictable source. Subjects are not disposable either, as they have no public
    `dispose()` method and will not release their sources in the event that `dispose()`
    is called downstream.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明`Subject`可能有些随意且危险，尤其是如果你将它们暴露给整个代码库，并且任何外部代码都可以调用`onNext()`来传递发射。例如，假设我们的`Subject`被暴露给一个外部API，并且可以任意地将发射`Puppy`放在`Alpha`、`Beta`和`Gamma`之上。如果我们希望我们的源只发射这些希腊字母，那么它很容易接收到意外的或不受欢迎的发射。响应式编程只有在源观察者来自一个定义良好且可预测的源时才能保持完整性。`Subject`也不是可丢弃的，因为它们没有公共的`dispose()`方法，并且当`dispose()`在下游被调用时，它们不会释放它们的源。
- en: It is much better to keep data-driven sources like this cold and to multicast
    using `publish()` or `replay()` if you want to make them hot. When you need to
    use `Subject`, cast it down to `Observable` or just do not expose it at all. You
    can also wrap a `Subject` inside a class of some sorts and have methods pass the
    events to it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让这样的数据驱动源保持冷状态，并使用`publish()`或`replay()`进行多播以使它们变得热，那就好得多。当你需要使用`Subject`时，将其转换为`Observable`或者根本不暴露它。你也可以将一个`Subject`包裹在某种类的内部，并让方法将事件传递给它。
- en: Serializing Subjects
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化Subject
- en: 'A critical *gotcha* to note with Subjects is this: the `onSubscribe()`, `onNext()`,
    `onError()`, and `onComplete()` calls are not threadsafe!  If you have multiple
    threads calling these four methods, emissions could start to overlap and break
    the `Observable` contract, which demands that emissions happen sequentially. If
    this happens, a good practice to adopt is to call `toSerialized()` on `Subject`
    to yield a  safely serialized `Subject` implementation (backed by the private
    `SerializedSubject`). This will safely sequentialize concurrent event calls so
    no train wrecks occur downstream:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在Subject上需要注意的一个关键问题：`onSubscribe()`、`onNext()`、`onError()`和`onComplete()`调用不是线程安全的！如果你有多个线程调用这四个方法，发射可能会开始重叠并破坏`Observable`契约，该契约要求发射按顺序发生。如果发生这种情况，一个良好的做法是在`Subject`上调用`toSerialized()`以产生一个安全序列化的`Subject`实现（由私有的`SerializedSubject`支持）。这将安全地序列化并发事件调用，以确保不会发生灾难性的后果：
- en: '[PRE39]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Unfortunately, due to limitations with the Java compiler (including Java 8),
    we have to explicitly declare the type parameter `String` for our `create()` factory
    earlier. The compiler's type inference does not cascade beyond more than one method
    invocation, so having two invocations as previously demonstrated would have a
    compilation error without an explicit type declaration.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，由于Java编译器的限制（包括Java 8），我们不得不在`create()`工厂中提前显式声明类型参数`String`。编译器的类型推断不会超过一个方法调用，所以像之前演示的那样有两个调用将会有编译错误，没有显式类型声明。
- en: BehaviorSubject
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BehaviorSubject
- en: 'There are a few other flavors of Subjects. Aside from the commonly used `PublishSubject`,
    there is also `BehaviorSubject`. It behaves almost the same way as `PublishSubject`,
    but it will replay the last emitted item to each new `Observer` downstream. This
    is somewhat like putting `replay(1).autoConnect()` after a `PublishSubject`, but
    it consolidates these operations into a single optimized `Subject` implementation
    that subscribes eagerly to the source:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几种Subject的其他风味。除了常用的`PublishSubject`之外，还有`BehaviorSubject`。它的行为几乎与`PublishSubject`相同，但它会将最后发射的项目回放给每个新的下游`Observer`。这有点像在`PublishSubject`之后放置`replay(1).autoConnect()`，但它将这些操作合并为一个单一的优化`Subject`实现，该实现会积极订阅源：
- en: '[PRE40]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output is as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE41]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, you can see that `Observer 2` received the last emission `Gamma` even
    though it missed the three emissions that `Observer 1` received. If you find yourself
    needing a `Subject` and want to cache the last emission for new Observers, you
    will want to use a `BehaviorSubject`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到`Observer 2`即使错过了`Observer 1`接收到的三个发射，仍然接收到了最后的`Gamma`发射。如果你发现自己需要一个`Subject`并想要为新观察者缓存最后的发射，你将想要使用一个`BehaviorSubject`。
- en: ReplaySubject
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReplaySubject
- en: '`ReplaySubject` is similar to `PublishSubject` followed by a `cache()` operator. It
    immediately captures emissions regardless of the presence of downstream Observers and
    optimizes the caching to occur inside the `Subject` itself:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReplaySubject`类似于`PublishSubject`后跟一个`cache()`操作符。它立即捕获发射，无论是否存在下游观察者，并优化在`Subject`本身内部发生缓存：'
- en: '[PRE42]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output is as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE43]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Obviously, just like using a parameterless `replay()` or a `cache()` operator,
    you need to be wary of using this with a large volume of emissions or infinite
    sources because it will cache them all and take up memory.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，就像使用无参数的`replay()`或`cache()`操作符一样，你需要小心使用它，因为如果发射量很大或来源无限，它将缓存所有内容并占用内存。
- en: AsyncSubject
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AsyncSubject
- en: '`AsyncSubject` has a highly tailored, finite-specific behavior: it will only
    push the last value it receives, followed by an `onComplete()` event:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncSubject`具有高度定制、有限特定的行为：它将只推送它接收到的最后一个值，然后是一个`onComplete()`事件：'
- en: '[PRE44]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The output is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE45]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As you can tell from the preceding command, the last value to be pushed to `AsyncSubject`
    was `Gamma` before `onComplete()` was called. Therefore, it only emitted `Gamma`
    to all Observers. This is a `Subject` you do not want to use with infinite sources
    since it only emits when `onComplete()` is called.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的命令中可以看出，在调用 `onComplete()` 之前，最后推送到 `AsyncSubject` 的值是 `Gamma`。因此，它只向所有
    `Observer` 发射了 `Gamma`。这种 `Subject` 你不希望与无限源一起使用，因为它只在调用 `onComplete()` 时发射。
- en: '`AsyncSubject` resembles `CompletableFuture` from Java 8 as it will do a computation
    that you can choose to observe for completion and get the value. You can also
    imitate `AsyncSubject` using `takeLast(1).replay(1)` on an `Observable`. Try to
    use this approach first before resorting to `AsyncSubject`.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncSubject` 与 Java 8 的 `CompletableFuture` 类似，它将执行一个你可以选择观察其完成并获取值的计算。你还可以通过在
    `Observable` 上使用 `takeLast(1).replay(1)` 来模仿 `AsyncSubject`。在求助于 `AsyncSubject`
    之前，首先尝试使用这种方法。'
- en: UnicastSubject
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UnicastSubject
- en: 'An interesting and possibly helpful kind of `Subject` is `UnicastSubject`.
    A `UnicastSubject`, like all Subjects, will be used to observe and subscribe to
    the sources. But it will buffer all the emissions it receives until an `Observer`
    subscribes to it, and then it will release all these emissions to the `Observer`
    and clear its cache:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一种有趣且可能有用的 `Subject` 类型是 `UnicastSubject`。与所有 `Subject` 一样，`UnicastSubject`
    将被用来观察和订阅源。但它将缓冲它接收到的所有发射数据，直到有 `Observer` 订阅它，然后它会将这些发射数据全部释放给 `Observer` 并清空其缓存：
- en: '[PRE46]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output is as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE47]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: When you run this code, you will see that after 2 seconds, the first six emissions
    are released immediately to the `Observer` when it subscribes. Then, it will receive
    live emissions from that point on. But there is one important property of `UnicastSubject`;
    it will only work with one `Observer` and will throw an error for any subsequent
    ones. Logically, this makes sense because it is designed to release buffered emissions
    from its internal queue once it gets an `Observer`. But when these cached emissions
    are released, they cannot be released again to a second `Observer` since they
    are already gone. If you want a second `Observer` to receive missed emissions,
    you might as well use `ReplaySubject`. The benefit of `UnicastSubject` is that
    it clears its buffer, and consequently frees the memory used for that buffer,
    once it gets an `Observer`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行此代码时，你将看到在 2 秒后，前六个发射数据在 `Observer` 订阅时立即释放。然后，它将从那个点开始接收实时发射的数据。但 `UnicastSubject`
    有一个重要的属性；它只与一个 `Observer` 一起工作，并且对于后续的任何 `Observer` 都会抛出错误。从逻辑上讲，这是有道理的，因为它设计成在获得
    `Observer` 后释放其内部队列中的缓冲发射数据。但是，当这些缓存的发射数据被释放后，它们不能再次释放给第二个 `Observer`，因为它们已经消失了。如果你想让第二个
    `Observer` 接收已错过的发射数据，你不妨使用 `ReplaySubject`。`UnicastSubject` 的好处是它在获得 `Observer`
    后会清空其缓冲区，从而释放用于该缓冲区的内存。
- en: 'If you want to support more than one `Observer` and just let subsequent Observers
    receive the live emissions without receiving the missed emissions, you can trick
    it by calling `publish()` to create a single `Observer` proxy that multicasts
    to more than one `Observer` as shown in the following code snippet:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要支持多个 `Observer` 并且只让后续的 `Observer` 接收实时发射的数据而不接收已错过发射的数据，你可以通过调用 `publish()`
    来创建一个单例 `Observer` 代理，该代理可以将数据多播给多个 `Observer`，如下面的代码片段所示：
- en: '[PRE48]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output is as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE49]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered multicasting using `ConnectableObservable` and `Subject`.
    The biggest takeaway is that `Observable` operators result in separate streams
    of events for each `Observer` that subscribes. If you want to consolidate these
    multiple streams into a single stream to prevent redundant work, the best way
    is to call `publish()` on an `Observable` to yield `ConnectableObservable`. You
    can then manually call `connect()` to fire emissions once your Observers are set
    up or automatically trigger a connection using `autoConnect()`or `refCount()`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了使用 `ConnectableObservable` 和 `Subject` 进行多播。最大的收获是 `Observable` 操作符为每个订阅的
    `Observer` 生成单独的事件流。如果你想将这些多个流合并为单个流以避免重复工作，最佳方式是在 `Observable` 上调用 `publish()`
    以生成 `ConnectableObservable`。然后你可以手动调用 `connect()` 来在观察者设置完毕后触发发射，或者使用 `autoConnect()`
    或 `refCount()` 自动触发连接。
- en: Mutlicasting also enables replaying and caching, so tardy Observers can receive
    missed emissions. Subjects provide a means to multicast and cache emissions as
    well, but you should only utilize them if existing operators cannot achieve what
    you want.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 多播还支持回放和缓存，因此迟到的 `Observer` 可以接收已错过的发射数据。`Subject` 提供了一种多播和缓存发射数据的方式，但你应该只在现有操作符无法实现你的需求时才使用它们。
- en: In the next chapter, we will start working with concurrency. This is where RxJava
    truly shines and is often the selling point of reactive programming.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始学习并发编程。这正是RxJava真正发光发热的地方，也是响应式编程的卖点之一。
