- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Assembling the Application
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组装应用程序
- en: Now that we have implemented some use cases, web adapters, and persistence adapters,
    we need to assemble them into a working application. As discussed in [*Chapter
    4*](B19916_04.xhtml#_idTextAnchor037), *Organizing Code*, we rely on a **dependency
    injection** mechanism to instantiate our classes and wire them together at start-up
    time. In this chapter, we’ll discuss some approaches to doing this with plain
    Java and the Spring and Spring Boot frameworks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了一些用例、Web适配器和持久化适配器，我们需要将它们组装成一个可工作的应用程序。如[*第4章*](B19916_04.xhtml#_idTextAnchor037)中所述，*组织代码*，我们依赖于依赖注入机制在启动时实例化我们的类并将它们连接起来。在本章中，我们将讨论一些使用纯Java和Spring以及Spring
    Boot框架来实现这一点的途径。
- en: Why even care about assembly?
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么甚至要关心组装？
- en: 'Why aren’t we just instantiating the use cases and adapters when and where
    we need them? Because we want to keep the code dependencies pointed in the right
    direction. Remember: all dependencies should point inward, toward the domain code
    of our application, so that the domain code doesn’t have to change when something
    in the outer layers changes.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们不在需要的时候和需要的地方实例化用例和适配器呢？因为我们希望保持代码依赖指向正确的方向。记住：所有依赖都应该指向内部，指向我们应用程序的领域代码，这样当外部层发生变化时，领域代码就不需要改变。
- en: If a use case needs to call a persistence adapter and just instantiates it itself,
    we have created a code dependency in the wrong direction.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个用例需要调用持久化适配器，并且自己实例化它，那么我们就创建了一个错误方向的代码依赖。
- en: This is why we created outgoing port interfaces. The use case only knows the
    interface and is provided an implementation of this interface at runtime.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们创建了输出端口接口。用例只知道接口，并在运行时提供了一个该接口的实现。
- en: A nice side effect of this programming style is that the code we’re creating
    is much easier to test. If we can pass all objects a class needs into its constructor,
    we can choose to pass in mocks instead of the real objects, which makes it easy
    to create an isolated unit test for the class.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编程风格的一个很好的副作用是，我们创建的代码更容易测试。如果我们能够将一个类需要的所有对象传递给它的构造函数，我们可以选择传递模拟对象而不是真实对象，这使得为该类创建一个隔离的单元测试变得容易。
- en: So, who’s responsible for creating our object instances? And how do we do it
    without violating the **Dependency Rule**?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，谁负责创建我们的对象实例？我们如何在不违反**依赖规则**的情况下完成它？
- en: The answer is that there must be a configuration component that is neutral to
    our architecture and that has a dependency to all classes in order to instantiate
    them, as shown in *Figure 10**.1*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，必须有一个中立于我们架构的配置组件，并且它对所有类都有依赖关系，以便实例化它们，如图*图10**.1*所示。
- en: '![Figure 10.1 – A neutral configuration component may access all classes in
    order to instantiate them](img/Figure_10.1_B19916.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 中立配置组件可以访问所有类以实例化它们](img/Figure_10.1_B19916.jpg)'
- en: Figure 10.1 – A neutral configuration component may access all classes in order
    to instantiate them
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 中立配置组件可以访问所有类以实例化它们
- en: In the *Clean Architecture* introduced in [*Chapter 3*](B19916_03.xhtml#_idTextAnchor029),
    *Inverting Dependencies*, this configuration component would be in the outermost
    circle, which may access all inner layers, as defined by the Dependency Rule.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B19916_03.xhtml#_idTextAnchor029)中引入的*反转依赖*的*整洁架构*中，这个配置组件会在最外层圆圈，可以访问所有内层，如依赖规则所定义。
- en: 'The configuration component is responsible for assembling a working application
    from the parts we provided. It must do the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 配置组件负责将我们提供的各个部分组装成一个可工作的应用程序。它必须执行以下操作：
- en: Create web adapter instances.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Web适配器实例。
- en: Ensure that HTTP requests are actually routed to the web adapters.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保HTTP请求实际上被路由到Web适配器。
- en: Create use case instances.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用例实例。
- en: Provide web adapters with use case instances.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供带有用例实例的Web适配器。
- en: Create persistence adapter instances.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建持久化适配器实例。
- en: Provide use cases with persistence adapter instances.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供带有持久化适配器实例的用例。
- en: Ensure that the persistence adapters can actually access the database.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保持久化适配器实际上可以访问数据库。
- en: Besides that, the configuration component should be able to access certain sources
    of configuration parameters, such as configuration files or command-line parameters.
    During application assembly, the configuration component then passes these parameters
    on to the application components to control behavior such as which database to
    access or which server to use to send emails.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，配置组件应该能够访问某些配置参数的来源，例如配置文件或命令行参数。在应用程序组装期间，配置组件将这些参数传递给应用程序组件，以控制行为，例如访问哪个数据库或使用哪个服务器发送电子邮件。
- en: 'These are a lot of responsibilities (read: reasons to change). Aren’t we violating
    the **Single Responsibility Principle** here? Yes, we are, but if we want to keep
    the rest of the application clean, we need an outside component that takes care
    of the wiring. And this component has to know all the moving parts to assemble
    them into a working application.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些责任很多（即：改变的原因）。我们这里不是违反了**单一职责原则**吗？是的，我们是，但如果我们想保持应用程序的其他部分干净，我们需要一个外部组件来处理连接。而这个组件必须了解所有移动部件，以便将它们组装成一个可工作的应用程序。
- en: Assembling via plain code
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过纯代码进行组装
- en: 'There are several ways to implement a configuration component responsible for
    assembling the application. If we’re building an application without the support
    of a dependency injection framework, we can create such a component with plain
    code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 实现负责组装应用程序的配置组件有几种方法。如果我们正在构建一个没有依赖注入框架支持的应用程序，我们可以使用纯代码创建这样一个组件：
- en: '![](img/code-10.1.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/code-10.1.jpg)'
- en: This code snippet is a simplified example of how such a configuration component
    might look. In Java, an application is started from the `main` method. Within
    this method, we instantiate all the classes we need, from the web controller to
    the persistence adapter, and wire them together.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段是一个简化的示例，展示了这样一个配置组件可能的样子。在Java中，应用程序是从`main`方法启动的。在这个方法中，我们实例化所有需要的类，从Web控制器到持久化适配器，并将它们连接在一起。
- en: Finally, we call the mystic method `startProcessingWebRequests()`, `w`hich exposes
    the web controller via HTTP.[1](#footnote-034) The application is then ready to
    process requests.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用神秘的方法`startProcessingWebRequests()`，它通过HTTP公开了Web控制器。[1](#footnote-034)
    然后，应用程序就准备好处理请求了。
- en: '[1](#footnote-034-backlink) The method `startProcessingWebRequests()`is just
    a placeholder for any bootstrapping logic that is necessary to expose our web
    adapters via HTTP. We don’t really want to implement this ourselves. In a real-world
    application, a framework does that for us.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[1](#footnote-034-backlink) `startProcessingWebRequests()`方法只是一个占位符，用于任何必要的引导逻辑，以便通过HTTP公开我们的Web适配器。我们并不真的想自己实现它。在实际的应用程序中，一个框架会为我们做这件事。'
- en: 'This plain code approach is the most basic way of assembling an application.
    It has some drawbacks, however:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这种纯代码方法是最基本的组装应用程序的方式。然而，它也有一些缺点：
- en: First of all, the preceding code is for an application that has only a single
    web controller, use case, and persistence adapter. Imagine how much code like
    this we would have to produce to bootstrap a full-blown enterprise application!
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，前面的代码是为只有一个Web控制器、用例和持久化适配器的应用程序编写的。想象一下，为了引导一个完整的商业应用程序，我们还需要编写多少类似的代码！
- en: Second, since we’re instantiating all classes ourselves from outside of their
    packages, those classes all need to be public. This means, for example, that the
    Java compiler doesn’t prevent a use case from directly accessing a persistence
    adapter since it’s public. It would be nice if we could avoid unwanted dependencies
    like this by using package-private visibility.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，由于我们是从它们的包外部实例化所有类的，因此这些类都必须是公开的。这意味着，例如，Java编译器不会阻止直接访问公开的持久化适配器，因为它公开了。如果我们能通过使用包私有可见性来避免这种不想要的依赖，那将很棒。
- en: Luckily, there are dependency injection frameworks that can do the dirty work
    for us while still maintaining package-private dependencies. The Spring framework
    is currently the most popular one in the Java world. Spring also provides web
    and database support, among a lot of other things, so we don’t have to implement
    the mystic `startProcessingWebRequests()` method after all.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一些依赖注入框架可以为我们做脏活，同时仍然保持包私有依赖。Spring框架目前在Java世界中是最受欢迎的。Spring还提供了许多其他功能，包括Web和数据库支持，因此我们最终不必实现神秘的`startProcessingWebRequests()`方法。
- en: Assembling via Spring’s classpath scanning
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过Spring的类路径扫描进行组装
- en: If we use the Spring framework to assemble our application, the result is called
    the **application context**. The application context contains all objects that
    together make up the application (**beans** in Java lingo).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 Spring 框架来组装我们的应用程序，结果被称为 **应用程序上下文**。应用程序上下文包含构成应用程序的所有对象（在 Java 术语中称为
    **bean**）。
- en: 'Spring offers several approaches to assemble an application context, each having
    its own advantages and drawbacks. Let’s start by discussing the most popular (and
    most convenient) approach: **classpath scanning**.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 提供了多种方法来组装应用程序上下文，每种方法都有其自身的优缺点。让我们先从最流行（也是最方便）的方法开始讨论：**类路径扫描**。
- en: 'With classpath scanning, Spring goes through all classes that are available
    in a certain slice of the classpath and searches for classes that are annotated
    with the `@Component` annotation. The framework then creates an object from each
    of these classes. The classes should have a constructor that takes all required
    fields as an argument, like our `AccountPersistenceAdapter` from [*Chapter 7*](B19916_07.xhtml#_idTextAnchor062)*,
    Implementing a* *Persistence Adapter*:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类路径扫描，Spring 会遍历类路径中某个片段中所有可用的类，并搜索带有 `@Component` 注解的类。框架随后会从这些类中创建对象。这些类应该有一个接受所有必需字段作为参数的构造函数，就像我们来自
    [*第 7 章*](B19916_07.xhtml#_idTextAnchor062)*，实现* *持久化适配器* *的 `AccountPersistenceAdapter`
    类一样：
- en: '![](img/code-10.2.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/code-10.2.jpg)'
- en: In this case, we didn’t even write the constructor ourselves, but instead let
    the Lombok library do it for us using the `@RequiredArgsConstructor` annotation,
    which creates a constructor that takes all `final` fields as arguments.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们甚至没有自己编写构造函数，而是使用 Lombok 库的 `@RequiredArgsConstructor` 注解来为我们完成这项工作，该注解创建了一个接受所有
    `final` 字段作为参数的构造函数。
- en: Spring will find this constructor and search for `@Component`-annotated classes
    of the required argument types and instantiate them in a similar manner to add
    them to the application context. Once all required objects are available, it will
    finally call the constructor of `AccountPersistenceAdapter` and add the resulting
    object to the application context as well.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 会找到这个构造函数，并搜索带有 `@Component` 注解的、所需参数类型的类，并以类似的方式实例化它们，将它们添加到应用程序上下文中。一旦所有必需的对象都可用，它最终会调用
    `AccountPersistenceAdapter` 的构造函数，并将生成的对象添加到应用程序上下文中。
- en: Classpath scanning is a very convenient way of assembling an application. We
    only have to sprinkle some `@Component` annotations across the code base and provide
    the right constructors.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 类路径扫描是组装应用程序的一种非常方便的方法。我们只需要在代码库中添加一些 `@Component` 注解，并确保提供正确的构造函数。
- en: 'We can also create our own stereotype annotation for Spring to pick up. We
    could, for example, create a `@``PersistenceAdapter` annotation:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以为 Spring 创建自己的 stereotypes 注解以便它能够识别。例如，我们可以创建一个 `@PersistenceAdapter`
    注解：
- en: '![](img/code-10.3.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/code-10.3.jpg)'
- en: This annotation is meta-annotated with `@Component` to let Spring know that
    it should be picked up during classpath scanning. We could now use `@PersistenceAdapter`
    instead of `@Component` to mark our persistence adapter classes as parts of our
    application. With this annotation, we have made our architecture more evident
    to people reading the code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个注解通过 `@Component` 进行了元注解，以便 Spring 知道在类路径扫描期间应该选择它。现在，我们可以使用 `@PersistenceAdapter`
    而不是 `@Component` 来标记我们的持久化适配器类作为应用程序的一部分。通过这个注解，我们已经使我们的架构对阅读代码的人更加明显。
- en: The classpath scanning approach has its drawbacks, however. First, it’s invasive
    in that it requires us to add a framework-specific annotation to our classes.
    If you’re a Clean Architecture hardliner, you’d say that this is forbidden as
    it binds our code to a specific framework.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，类路径扫描方法也有其缺点。首先，它是侵入性的，因为它要求我们在类中添加一个特定框架的注解。如果你是一个 Clean Architecture 的坚定支持者，你会说这是被禁止的，因为它将我们的代码绑定到了一个特定的框架。
- en: I’d say that in usual application development, a single annotation on a class
    is not such a big deal and can easily be refactored, if at all necessary.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以说，在通常的应用程序开发中，一个类上的单个注解并不是什么大问题，并且可以很容易地进行重构，如果确实需要的话。
- en: In other contexts, however, like when building a library or a framework for
    other developers to use, this might be a no-go since we don’t want to encumber
    our users with a dependency on the Spring framework.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在其他上下文中，例如当为其他开发者构建库或框架时，这可能会是一个不可行的选择，因为我们不希望让我们的用户依赖于 Spring 框架。
- en: Another potential drawback of the classpath scanning approach is that magic
    things might happen. And by *magic*, I mean the bad kind of magic causing inexplicable
    effects that might take days to figure out if you’re not a Spring expert.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 类路径扫描方法的一个潜在缺点是可能会发生一些神奇的事情。这里的“神奇”指的是那种不良的魔法，它会导致难以解释的效果，如果你不是Spring专家，可能需要花费数天时间才能弄清楚。
- en: Magic happens because classpath scanning is a very blunt weapon to use for application
    assembly. We simply point Spring at the parent package of our application and
    tell it to go looking for `@Component`-annotated classes within this package.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类路径扫描是应用组装中一个非常钝的武器，所以会发生魔法。我们只需将Spring指向我们应用程序的父包，并告诉它在这个包内寻找带有`@Component`注解的类。
- en: Do you know every single class that exists within your application by heart?
    Probably not. There are bound to be some classes that we don’t actually want to
    have in the application context. Perhaps this class even manipulates the application
    context in evil ways, causing errors that are hard to track.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你能记住你应用程序中存在的每一个类吗？可能不会。肯定有一些我们实际上不希望在应用程序上下文中存在的类。也许这个类甚至以邪恶的方式操纵应用程序上下文，导致难以追踪的错误。
- en: Let’s look at an alternative approach that gives us a little more control.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一种提供更多控制的方法。
- en: Assembling via Spring’s Java Config
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过Spring的Java配置进行组装
- en: While classpath scanning is the cudgel of application assembly, Spring’s Java
    Config is the scalpel.[2](#footnote-033) This approach is similar to the plain
    code approach introduced earlier in this chapter, but it’s less messy and provides
    us with a framework so that we don’t have to code everything by hand.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然类路径扫描是应用组装的棍棒，但Spring的Java配置是手术刀。[2](#footnote-033) 这种方法与本章前面介绍的直接代码方法类似，但它更整洁，并为我们提供了一个框架，这样我们就不必手动编写所有代码。
- en: '[2](#footnote-033-backlink) Cudgel versus scalpel: if you don’t spend far too
    many hours of your life killing monsters in role-playing video games like me and
    don’t know what a cudgel is, a cudgel is a stick with a weighted end that can
    be used as a weapon. It’s a very blunt weapon that can do a lot of damage without
    having to aim particularly well.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[2](#footnote-033-backlink) 棍棒与手术刀：如果你没有像我一样在角色扮演视频游戏中花费大量时间杀怪物，并且不知道什么是棍棒，那么棍棒是一种带有重锤头的棍子，可以用作武器。它是一种非常钝的武器，可以在不需要特别瞄准的情况下造成大量伤害。'
- en: In this approach, we create configuration classes, each responsible for constructing
    a set of beans that are to be added to the application context.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们创建配置类，每个配置类负责构建一组要添加到应用程序上下文中的bean。
- en: 'For example, we could create a configuration class that is responsible for
    instantiating all our persistence adapters:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以创建一个配置类，该类负责实例化我们所有的持久化适配器：
- en: '![](img/code-10.4.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例](img/code-10.4.jpg)'
- en: The `@Configuration` annotation marks this class as a configuration class to
    be picked up by Spring’s classpath scanning. So, in this case, we’re still using
    classpath scanning, but we only pick up our configuration classes instead of every
    single bean, which reduces the chance of evil magic happening.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Configuration`注解将此类标记为配置类，以便Spring的类路径扫描器可以识别。因此，在这种情况下，我们仍然使用类路径扫描，但我们只选择我们的配置类而不是每个单个bean，这减少了发生邪恶魔法的机会。'
- en: The beans themselves are created within the `@Bean`-annotated factory methods
    of our configuration classes. In the preceding case, we add a persistence adapter
    to the application context. It needs two repositories and a mapper as input to
    its constructor. Spring automatically provides these objects as input to the factory
    methods.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些bean本身是在配置类的`@Bean`注解的工厂方法中创建的。在前面的例子中，我们向应用程序上下文添加了一个持久化适配器。它需要两个仓库和一个映射器作为构造函数的输入。Spring会自动将这些对象作为输入提供给工厂方法。
- en: But where does Spring get the repository objects from? If they are created manually
    in a factory method of another configuration class, then Spring will automatically
    provide them as parameters to the factory methods of the preceding code example.
    In this case, however, they are created by Spring itself, triggered by the `@EnableJpaRepositories`
    annotation. If Spring Boot finds this annotation, it will automatically provide
    implementations for all Spring Data repository interfaces we have defined.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 但Spring从哪里获取仓库对象呢？如果它们是在另一个配置类的工厂方法中手动创建的，那么Spring会自动将这些对象作为参数提供给前面代码示例中的工厂方法。然而，在这种情况下，它们是由Spring本身创建的，由`@EnableJpaRepositories`注解触发。如果Spring
    Boot发现这个注解，它将自动为我们定义的所有Spring Data仓库接口提供实现。
- en: If you’re familiar with Spring Boot, you might know that we could have added
    the `@EnableJpa` **Repositories** annotation to the main application class instead
    of our custom configuration class. Yes, this is possible, but it will activate
    JPA repositories every time the application is started up, even if we start the
    application within a test that doesn’t actually need persistence. So, by moving
    such “feature annotations” into a separate configuration “module,” we’ve just
    become much more flexible and can start up parts of our application instead of
    always having to start the whole thing.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 Spring Boot，你可能知道我们可以在主应用程序类中添加 `@EnableJpa` **Repositories** 注解，而不是我们的自定义配置类。是的，这是可能的，但每次启动应用程序时，它都会激活
    JPA 存储库，即使我们在不需要持久化的测试中启动应用程序。因此，通过将此类“功能注解”移动到单独的配置“模块”，我们变得更加灵活，可以启动应用程序的某些部分，而无需总是启动整个应用程序。
- en: With the `PersistenceAdapterConfiguration` class, we have created a tightly
    scoped persistence module that instantiates all objects we need in our persistence
    layer. It will be automatically picked up by Spring’s classpath scanning while
    we still have full control over which beans are actually added to the application
    context.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `PersistenceAdapterConfiguration` 类，我们创建了一个紧密作用域的持久化模块，它实例化了我们在持久化层中需要的所有对象。当我们在仍然完全控制哪些豆类被添加到应用程序上下文的同时，它将被
    Spring 的类路径扫描自动识别。
- en: Similarly, we could create configuration classes for web adapters, or for certain
    modules within our application layer. We can now create an application context
    that contains certain modules but mocks the beans of other modules, which gives
    us great flexibility in tests. We could even push the code of each of those modules
    into its own code base, package, or JAR file without much refactoring.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以为网络适配器或应用程序层中的某些模块创建配置类。现在，我们可以创建一个包含某些模块的应用程序上下文，同时模拟其他模块的豆类，这在测试中提供了很大的灵活性。我们甚至可以将每个模块的代码推送到其自己的代码库、包或
    JAR 文件中，而无需进行太多重构。
- en: Also, this approach does not force us to sprinkle `@Component` annotations all
    over our code base, like the classpath scanning approach does. So, we can keep
    our application layer clean without any dependency on the Spring framework (or
    any other framework, for that matter).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这种方法不会强迫我们在代码库中到处添加 `@Component` 注解，就像类路径扫描方法那样。因此，我们可以保持应用程序层的清洁，而不依赖于 Spring
    框架（或任何其他框架）。
- en: There is a catch with this solution, however. If the configuration class is
    not within the same package as the classes of the beans it creates (the persistence
    adapter classes in this case), those classes must be public. To restrict visibility,
    we can use packages as module boundaries and create a dedicated configuration
    class within each package. This way, we cannot use sub-packages, though, as will
    be discussed in [*Chapter 12*](B19916_12.xhtml#_idTextAnchor105), *Enforcing*
    *Architecture Boundaries*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个解决方案有一个问题。如果配置类不在创建豆类（在这种情况下是持久化适配器类）的类所在的同一包中，那些类必须是公共的。为了限制可见性，我们可以使用包作为模块边界，并在每个包中创建一个专门的配置类。这样，我们无法使用子包，正如将在[*第
    12 章*](B19916_12.xhtml#_idTextAnchor105)中讨论的，*强制* *架构边界*。
- en: How does this help me build maintainable software?
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这如何帮助我构建可维护的软件？
- en: Spring and Spring Boot (and similar frameworks) provide a lot of features that
    make our lives easier. One of the main features is assembling the application
    out of the parts (classes) that we, as application developers, provide.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 和 Spring Boot（以及类似的框架）提供了许多使我们的工作更轻松的功能。其中一个主要功能是从我们作为应用程序开发者提供的部分（类）组装应用程序。
- en: Classpath scanning is a very convenient feature. We only have to point Spring
    to a package and it assembles an application from the classes it finds. This allows
    for rapid development, with us not having to think about the application as a
    whole.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 类路径扫描是一个非常方便的功能。我们只需将 Spring 指向一个包，它就会从找到的类中组装一个应用程序。这允许我们快速开发，无需考虑应用程序的整体结构。
- en: Once the code base grows, however, this quickly leads to a lack of transparency.
    We don’t know which beans exactly are loaded into the application context. Also,
    we cannot easily start up isolated parts of the application context to use in
    tests.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦代码库增长，这很快就会导致缺乏透明度。我们不知道哪些豆类确切地被加载到应用程序上下文中。此外，我们无法轻松启动应用程序上下文的孤立部分以用于测试。
- en: 'By creating a dedicated configuration component responsible for assembling
    our application, we can liberate our application code from this responsibility
    (read: “reason for change” – remember the “S” in “SOLID”?). We’re rewarded with
    highly cohesive modules that we can start up in isolation from each other and
    that we can easily move around within our code base. As usual, this comes at the
    price of spending some extra time to maintain this configuration component.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个专门负责组装我们应用程序的配置组件，我们可以将应用程序代码从这个责任中解放出来（读作：“变化的原因”——记得“SOLID”中的“S”吗？）。作为回报，我们得到了高度凝聚的模块，我们可以将它们彼此独立启动，并且可以轻松地在代码库中移动。通常，这需要我们额外花费一些时间来维护这个配置组件。
- en: We’ve talked a lot about different options of how to do things “the right way”
    in this and the previous chapters. However, sometimes “the right way” is not feasible.
    In the next chapter, we’ll talk about shortcuts, the price we pay for them, and
    when they’re worth taking.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这章和上一章中已经讨论了很多关于如何“正确地”做事的不同选项。然而，有时“正确的方式”并不可行。在下一章中，我们将讨论捷径、我们为此付出的代价，以及何时值得采取这些捷径。
