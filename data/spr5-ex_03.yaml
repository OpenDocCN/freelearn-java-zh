- en: Persistence with Spring Data and Reactive Fashion
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring Data 和反应式方式实现持久化
- en: In the previous chapter, we created our **Content Management System** (**CMS**)
    application. We also introduced **REST** (**Representational State Transfer**)
    support in Spring, which enabled us to develop a simple web application. Also,
    we learned how dependency injection works in the Spring Framework, which is probably
    the most famous feature of the framework.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了我们的**内容管理系统**（**CMS**）应用程序。我们还介绍了 Spring 中的 **REST**（**表示状态传输**）支持，这使得我们能够开发一个简单的
    Web 应用程序。此外，我们还学习了 Spring 框架中依赖注入的工作原理，这可能是框架最著名的特性。
- en: In this chapter, we will add more features to our application. Systems in the
    real world need to persist their data on a real database; this is an essential
    characteristic for a production-ready application. Also, based on our model, we
    need to choose the correct data structure to achieve performance and avoid the
    impedance mismatch.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为我们的应用程序添加更多功能。现实世界中的系统需要在真实数据库上持久化其数据；这对于一个生产就绪的应用程序是一个基本特性。此外，根据我们的模型，我们需要选择正确的数据结构以实现性能并避免阻抗不匹配。
- en: In the first part of this chapter, we will use the traditional SQL database
    as a store for our application. We will deep dive on the Spring Data **JPA** (**Java
    Persistence API**) to achieve the persistence for our CMS application. We will
    understand how to enable transactions with this amazing Spring module.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，我们将使用传统的 SQL 数据库作为我们应用程序的存储。我们将深入研究 Spring Data **JPA**（**Java 持久化
    API**）以实现 CMS 应用程序的持久化。我们将了解如何使用这个令人惊叹的 Spring 模块启用事务。
- en: After that, we will change to a more modern type of database called **NoSQL**
    **technologies**. In this field, we will use the famous database document model
    called **MongoDB** and then we will create the final solution for our CMS application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将转向一种更现代的数据库类型，称为 **NoSQL** **技术**。在这个领域，我们将使用著名的数据库文档模型，即 **MongoDB**，然后我们将为我们的
    CMS 应用程序创建最终的解决方案。
- en: MongoDB offers a fantastic solution for our application because it has support
    for a document storage model and enables us to store our objects in the form of
    JSON, which makes our data more readable. Also, MongoDB is schema-less, which
    is a fantastic feature because one collection can store different documents. It
    means records can have different fields, content, and sizes. The other important
    characteristic from MongoDB is the query model. It offers a document-based query
    that is easy to understand, and, based on JSON notations, our queries will be
    more readable than any other database can be.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 为我们的应用程序提供了一个出色的解决方案，因为它支持文档存储模型，并允许我们将对象以 JSON 的形式存储，这使得我们的数据更易于阅读。此外，MongoDB
    是无模式的，这是一个非常出色的特性，因为一个集合可以存储不同的文档。这意味着记录可以有不同的字段、内容和大小。MongoDB 的另一个重要特性是查询模型。它提供了一个易于理解的基于文档的查询，并且基于
    JSON 标记，我们的查询将比任何其他数据库都更容易阅读。
- en: 'Finally, we will add the most important feature present in Spring 5.0: support
    for Reactive Streams. Our application will be transformed into a modern web application
    which has some important requirements.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加 Spring 5.0 中最重要的特性：对反应式流的支持。我们的应用程序将转变为一个具有一些重要要求的现代 Web 应用程序。
- en: 'Here''s an overview of what you will learn in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是本章你将学习的内容概述：
- en: Implementing the Spring Data JPA
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 Spring Data JPA
- en: Creating repositories with Spring Data Reactive MongoDB
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring Data Reactive MongoDB 创建仓库
- en: Learning the Reactive Spring
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习反应式 Spring
- en: Understand the Project Reactor
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Project Reactor
- en: Learning the basics of Docker
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习 Docker 的基础知识
- en: We learned about Docker concepts in [Chapter 1](45a65572-53a1-42bd-aa7a-d1437e65a58f.xhtml),
    *Journey to the Spring World*. Now, it is time to test our knowledge and put it
    into practice. In the first part of this chapter, we will start MongoDB and Postgres instances
    to serve as a database for our application. We will configure connection settings
    in the application.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在《第 1 章》中，我们学习了 Docker 概念，*Spring 世界的旅程*。现在，是时候测试我们的知识并将其付诸实践了。在本章的第一部分，我们将启动
    MongoDB 和 Postgres 实例，作为我们应用程序的数据库。我们将在应用程序中配置连接设置。
- en: In the last part of this chapter, we will introduce the Maven plugin which provides
    an easy way to create Docker images via `pom.xml` with a couple of configurations
    on file. Finally, we will run our application in a Docker container.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将介绍 Maven 插件，它提供了一个通过 `pom.xml` 创建 Docker 镜像的简单方法，只需在文件中进行一些配置。最后，我们将在
    Docker 容器中运行我们的应用程序。
- en: Preparing  MongoDB
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备 MongoDB
- en: Let's create our MongoDB container. We will use the official image provided
    by the Docker Hub.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的 MongoDB 容器。我们将使用 Docker Hub 提供的官方镜像。
- en: 'First, we need to pull the image:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要拉取镜像：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Then, we will see the Docker Engine downloading the image contents.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将看到 Docker 引擎正在下载镜像内容。
- en: To create an isolation from our containers, we will create a separated network
    for our application and database. The network should use the bridge driver to
    allow the container communications.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从我们的容器中创建隔离，我们将为我们的应用程序和数据库创建一个单独的网络。该网络应使用桥接驱动程序以允许容器通信。
- en: 'Let''s create a `docker network`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个 `docker network`：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The command output should be an ID of a created network. Your ID will probably
    be different compared to mine:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 命令输出应该是一个创建的网络 ID。您的 ID 可能与我的不同：
- en: '![](img/6ef52923-37c6-446d-9e6a-371ac525bce9.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ef52923-37c6-446d-9e6a-371ac525bce9.png)'
- en: To check if the network was created successfully, the `docker network ls` command can
    help us.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查网络是否成功创建，可以使用 `docker network ls` 命令来帮助我们。
- en: We will start our MongoDB. The network should be `cms-application`, but we will
    map the database port to a host port. For debugging purposes, we will connect
    a client to a running database, but please don't do this in a non-development
    environment.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将启动我们的 MongoDB。该网络应该是 `cms-application`，但我们将数据库端口映射到主机端口。出于调试目的，我们将连接一个客户端到正在运行的数据库，但请不要在非开发环境中这样做。
- en: Exposing a port over host is not a best practice. Hence, we use a Docker container,
    which is one of the main advantages is process isolation. In this case, we will
    have no control over the network. Otherwise, we may cause some port conflicts.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在主机上暴露端口不是最佳实践。因此，我们使用 Docker 容器，这是其主要优势之一是进程隔离。在这种情况下，我们将无法控制网络。否则，我们可能会引起一些端口冲突。
- en: 'To start, type the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，输入以下命令：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Also, we can stop the Docker MongoDB container using `docker stop mongodb` and start
    our container again by using the following command: `docker start mongodb`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用 `docker stop mongodb` 命令停止 Docker MongoDB 容器，然后通过以下命令重新启动我们的容器：`docker
    start mongodb`。
- en: The output will be a hash which represents the ID of the container.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是一个哈希值，代表容器的 ID。
- en: 'The parameter instructions are:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 参数说明如下：
- en: '`-d`: This instructs Docker to run the container in a background mode'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d`：这指示 Docker 以后台模式运行容器'
- en: '`--name`: The container name; it will be a kind of hostname in our network'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--name`：容器名称；它将在我们的网络中充当主机名'
- en: '`--net`: The network where the container will be attached'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--net`：容器将要连接的网络'
- en: '`-p`: The host port and container port, which will be mapped to a container
    on a host interface'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p`：主机端口和容器端口，它们将被映射到主机接口上的一个容器'
- en: Now, we have a pretty standard MongoDB instance running on our machines, and
    we can start to add a persistence in our CMS application. We will do that soon.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在机器上运行了一个相当标准的 MongoDB 实例，我们可以开始在我们的 CMS 应用程序中添加持久性。我们很快就会这样做。
- en: Preparing a PostgreSQL database
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备 PostgreSQL 数据库
- en: Like MongoDB, we will prepare a PostgreSQL instance for our CMS application.
    We will change our persistence layer to demonstrate how Spring Data abstracts
    it for developers. Then, we need to prepare a Docker Postgres instance for that.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与 MongoDB 类似，我们将为我们的 CMS 应用程序准备一个 PostgreSQL 实例。我们将更改我们的持久层以展示 Spring Data 如何为开发者抽象化它。然后，我们需要为它准备一个
    Docker Postgres 实例。
- en: 'We will use the version 9.6.6 of Postgres and use the `alpine` tag because
    it is smaller than other Postgres images. Let''s pull our image. The command should
    be like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Postgres 的 9.6.6 版本并使用 `alpine` 标签，因为它比其他 Postgres 镜像更小。让我们拉取我们的镜像。命令应该是这样的：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Then, wait until the download ends.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，等待下载完成。
- en: 'In the previous section, we created our Docker network called `cms-application`.
    Now, we will start our Postgres instance on that network as we did for MongoDB.
    The command to start the Postgres should be the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们创建了一个名为 `cms-application` 的 Docker 网络。现在，我们将像为 MongoDB 所做的那样，在该网络上启动我们的
    Postgres 实例。启动 Postgres 的命令应该是以下这样的：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The list of parameters is the same as we passed for MongoDB. We want to run
    it in background mode and attach it to our custom network. As we can see, there
    is one more new parameter in the `docker run` command. Let''s understand it:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 参数列表与我们为 MongoDB 传递的相同。我们希望以后台模式运行它并将其连接到我们的自定义网络。正如我们所见，`docker run` 命令中还有一个新的参数。让我们来理解它：
- en: '`-e`: This enables us to pass environment variables for a container. In this
    case, we want to change the password value.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-e`：这使我们能够为容器传递环境变量。在这种情况下，我们想更改密码值。'
- en: Good job. We have done our infrastructure requirements. Let's understand the
    persistence details right now.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好。我们已经完成了我们的基础设施需求。现在让我们立即了解持久化的细节。
- en: Spring Data project
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Data项目
- en: The Spring Data project is an umbrella project that offers a familiar way to
    create our data access layer on a wide range of database technologies. It means
    there are high-level abstractions to interact with different kinds of data structures,
    such as the document model, column family, key-value, and graphs. Also, the JPA
    specification is fully supported by the Spring Data JPA project.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data项目是一个伞形项目，它提供了一种熟悉的方式来在广泛的数据库技术上创建我们的数据访问层。这意味着有高级抽象来与不同类型的数据结构交互，例如文档模型、列族、键值和图。此外，Spring
    Data JPA项目完全支持JPA规范。
- en: These modules offer powerful object-mapping abstractions for our domain model.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模块为我们领域模型提供了强大的对象映射抽象。
- en: 'There is support for different types of data structures and databases. There
    is a set of sub-modules to keep the framework modularity. Also, there are two
    categories of these sub-modules: the first one is a subset of projects supported
    by the Spring Framework Team and the second one is a subset of sub-modules provided
    by the community.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 支持不同类型的数据结构和数据库。有一组子模块来保持框架的模块化。此外，这些子模块分为两大类：第一类是Spring框架团队支持的项目子集，第二类是社区提供的子模块子集。
- en: 'Projects supported by the Spring Team include:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Spring团队支持的项目包括：
- en: Spring Data Commons
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data Commons
- en: Spring Data JPA
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data JPA
- en: Spring Data MongoDB
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data MongoDB
- en: Spring Data Redis
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data Redis
- en: Spring Data for Apache Cassandra
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data for Apache Cassandra
- en: 'Projects supported by the community include:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 社区支持的项目包括：
- en: Spring Data Aerospike
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data Aerospike
- en: Spring Data ElasticSearch
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data ElasticSearch
- en: Spring Data DynamoDB
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data DynamoDB
- en: Spring Data Neo4J
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data Neo4J
- en: The base of the repositories interfaces chain is the `Repository` interface.
    It is a marker interface, and the general purpose is to store the type information.
    The type will be used for other interfaces that extend it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库接口链的基础是`Repository`接口。这是一个标记接口，其一般目的是存储类型信息。这个类型将被用于扩展它的其他接口。
- en: There is also a `CrudRepository` interface. It is the most important, and the
    name is self-explanatory; it provides a couple of methods to perform CRUD operations,
    and it provides some utility methods, such as `count()`, `exists()`, and `deleteAll()`.
    Those are the most important base interfaces for the repository implementations.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个`CrudRepository`接口。这是最重要的，名字本身就说明了它的作用；它提供了一些执行CRUD操作的方法，并提供了一些实用方法，如`count()`、`exists()`和`deleteAll()`。这些是仓库实现最重要的基本接口。
- en: Spring Data JPA
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Data JPA
- en: The Spring Data JPA provides an easy way to implement a data access layer using
    the JPA specification from Java EE. Usually, these implementations had a lot of
    boilerplate and repetitive code and it was hard to maintain the changes in the
    database code. The Spring Data JPA is trying to resolve these issues and provides
    a comprehensible way to do that without boilerplate and repetitive code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data JPA提供了一个简单的方式来使用Java EE中的JPA规范实现数据访问层。通常，这些实现有很多样板代码和重复代码，维护数据库代码中的更改也很困难。Spring
    Data JPA试图解决这些问题，并提供了一种无需样板代码和重复代码的直观方式来做到这一点。
- en: The JPA specification provides an abstraction layer to interact with different
    database vendors that have been implemented. Spring adds one more layer to the
    abstraction in a high-level mode. It means the Spring Data JPA will create a repositories
    implementation and encapsulate the whole JPA implementation details. We can build
    our persistence layer with a little knowledge of the JPA spec.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: JPA规范提供了一个抽象层，用于与已经实现的不同数据库供应商交互。Spring在高级模式上添加了一个抽象层。这意味着Spring Data JPA将创建一个仓库实现，并封装整个JPA实现细节。我们可以用对JPA规范的了解很少来构建我们的持久化层。
- en: The *JPA Specification* was created by the **JCP** (**Java Community Process**)
    to help developers to persist, access, and manage data between Java classes and
    relational databases. There are some vendors that implement this specification.
    The most famous implementation is Hibernate ([http://hibernate.org/orm/](http://hibernate.org/orm/)),
    and by default, Spring Data JPA uses Hibernate as the JPA implementation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*JPA规范*是由**JCP（Java社区进程**）创建的，旨在帮助开发者在Java类和关系数据库之间持久化、访问和管理数据。一些供应商实现了这个规范。最著名的实现是Hibernate
    ([http://hibernate.org/orm/](http://hibernate.org/orm/))，默认情况下，Spring Data JPA使用Hibernate作为JPA实现。'
- en: Say goodbye to the **DAO** (**Data Access Object**) pattern and implementations.
    The Spring Data JPA aims to solve this problem with a well-tested framework and
    with some production-ready features.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 再见，**DAO**（**数据访问对象**）模式和实现。Spring Data JPA 旨在通过经过良好测试的框架和一些生产就绪功能来解决此问题。
- en: Now, we have an idea of what the Spring Data JPA is. Let's put it into practice.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经了解了 Spring Data JPA 是什么。让我们将其付诸实践。
- en: Configuring pom.xml for Spring Data JPA
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 pom.xml 以使用 Spring Data JPA
- en: Now, we need to put the correct dependencies to work with Spring Data JPA. There
    are a couple of dependencies to configure in our `pom.xml` file.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要添加正确的依赖项以与 Spring Data JPA 一起工作。在我们的 `pom.xml` 文件中需要配置几个依赖项。
- en: The first one is the Spring Data JPA Starter, which provides a lot of auto-configuration
    classes which permits us to bootstrap the application quickly. The last one is
    the PostgreSQL JDBC driver, and it is necessary because it contains the JDBC implementation
    classes to connect with the PostgreSQL database.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是一个 Spring Data JPA Starter，它提供了许多自动配置类，使我们能够快速启动应用程序。最后一个依赖项是 PostgreSQL
    JDBC 驱动程序，它是必需的，因为它包含了连接 PostgreSQL 数据库的 JDBC 实现类。
- en: 'The new dependencies are:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 新的依赖项包括：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Simple and pretty easy.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 简单且相当容易。
- en: Configuring the Postgres connections
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Postgres 连接
- en: To connect our application with our recently created database, we need to configure
    a couple of lines in the `application.yaml` file. Once again, thanks to Spring
    Data Starter, our connection will be configured automatically.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的应用程序与最近创建的数据库连接起来，我们需要在 `application.yaml` 文件中配置几行。再次感谢 Spring Data Starter，我们的连接将自动配置。
- en: We can produce the connection objects using the `@Bean` annotations as well,
    but there are many objects to configure. We will go forward with the configuration
    file. It is more simple and straightforward to understand as well.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 `@Bean` 注解来生成连接对象，但有许多对象需要配置。我们将继续使用配置文件。它更简单、更易于理解。
- en: To configure the database connections, we need to provide the Spring Framework
    a couple of attributes, such as the database URL, database username, password,
    and also a driver class name to instruct the JPA framework about the full path
    of the JDBC class.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置数据库连接，我们需要向 Spring 框架提供一些属性，例如数据库 URL、数据库用户名、密码，以及一个驱动类名，以指导 JPA 框架关于 JDBC
    类的完整路径。
- en: 'The `application.yaml` file should be like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`application.yaml` 文件应该是这样的：'
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the `datasource` section, we have configured the database credentials connections
    and database host as well.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `datasource` 部分中，我们已配置了数据库凭据连接以及数据库主机。
- en: The JPA section in `application.yaml` can be used to configure the JPA framework.
    In this part, we configured to log SQL instructions in the console. This is helpful
    to debug and perform troubleshooting. Also, we have configured the JPA framework
    to create our tables in a database when the application gets the startup process.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`application.yaml` 中的 JPA 部分可以用来配置 JPA 框架。在这一部分，我们配置了在控制台记录 SQL 指令。这有助于调试和进行故障排除。此外，我们还配置了
    JPA 框架，以便在应用程序启动过程中在数据库中创建我们的表。'
- en: Awesome, the JPA infrastructure is configured. Well done! Now, we can map our
    models in the JPA style. Let's do that in the following section.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，JPA 基础设施已配置。做得好！现在，我们可以以 JPA 风格映射我们的模型。让我们在下一节中这样做。
- en: Mapping the models
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射模型
- en: We have configured the database connections successfully. Now, we are ready
    to map our models using the JPA annotations. Let's start with our `Category` model.
    It is a pretty simple class, which is good because we are interested in Spring
    Data JPA stuff.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功配置数据库连接。现在，我们准备使用 JPA 注解来映射我们的模型。让我们从我们的 `Category` 模型开始。这是一个相当简单的类，这很好，因为我们对
    Spring Data JPA 的内容感兴趣。
- en: 'Our first version of the `Category` model should be like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 `Category` 模型的第一个版本应该是这样的：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We need to change some model classes to adapt to the JPA specification. We can
    find the model classes on GitHub at: [https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter03/cms-postgres/src/main/java/springfive/cms/domain/models](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter03/cms-postgres/src/main/java/springfive/cms/domain/models).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更改一些模型类以适应 JPA 规范。我们可以在 GitHub 上找到模型类：[https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter03/cms-postgres/src/main/java/springfive/cms/domain/models](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter03/cms-postgres/src/main/java/springfive/cms/domain/models)。
- en: There is some new stuff here. The `@Entity` annotation instructs the JPA framework
    that the annotated class is an entity, in our case, the `Category` class, and
    then the framework will correlate it with a database table. The `@Table` annotation
    is used to name the table in the database. These annotations are inserted on the
    class level, which means on top of the class declaration.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些新内容。`@Entity` 注解指示 JPA 框架，被注解的类是一个实体，在我们的例子中，是 `Category` 类，然后框架将与之关联一个数据库表。`@Table`
    注解用于在数据库中命名表。这些注解是在类级别插入的，这意味着在类声明之上。
- en: The `@Id` annotation instructs the JPA as to which annotated field is the primary
    key of the database table. It is not a good practice to generate IDs sequentially
    for entities, especially if you are creating the APIs. It helps hackers to understand
    the logic about the IDs and makes the attacks easier. So, we will generate UUIDs
    (Universally Unique IDentifiers) instead of simple sequentially IDs. The `@GenericGenerator`
    annotation instructs Hibernate, which is a JPA specification implementation vendor,
    to generate random UUIDs.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Id` 注解指示 JPA 哪个注解字段是数据库表的键。为实体生成顺序 ID 不是一种好做法，尤其是如果你正在创建 API。这有助于黑客理解 ID
    的逻辑，使得攻击更容易。因此，我们将生成 UUID（通用唯一标识符）而不是简单的顺序 ID。`@GenericGenerator` 注解指示 Hibernate（一个
    JPA 规范实现供应商）生成随机 UUID。'
- en: Adding the JPA repositories in the CMS application
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 CMS 应用程序中添加 JPA 存储库
- en: Once the whole infrastructure and JPA mappings are done, we can add our repositories
    to our projects. In the Spring Data project, there are some abstractions, such
    as `Repository`, `CrudRepository`, and `JpaRepository`. We will use the `JpaRepository`
    because it supports the paging and sorting features.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦整个基础设施和 JPA 映射完成，我们就可以将我们的存储库添加到项目中。在 Spring Data 项目中，有一些抽象，例如 `Repository`、`CrudRepository`
    和 `JpaRepository`。我们将使用 `JpaRepository`，因为它支持分页和排序功能。
- en: Our repository will be pretty simple. There are a couple of standard methods,
    such as `save()`, `update()`, and `delete()`, and we will take a look at some
    DSL query methods which allow developers to create custom queries based on attribute
    names. We created an `AbstractRepository` to help us to store the objects in memory.
    It is not necessary anymore. We can remove it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的存储库将会相当简单。有几个标准方法，例如 `save()`、`update()` 和 `delete()`，我们还将查看一些 DSL 查询方法，这些方法允许开发者根据属性名称创建自定义查询。我们创建了一个
    `AbstractRepository` 来帮助我们存储对象在内存中。这已经不再必要了。我们可以将其删除。
- en: 'Let''s create our first JPA repository:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的第一个 JPA 存储库：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we can see, the `JpaRepository` interface is typed with the desired entity
    and the type of ID of the entity as well. There is no secret to this part. This
    amazing thing happens to support the custom queries based on attribute names.
    In the `Category` model, there is an attribute called `name`**.** We can create
    custom methods in our `CategoryRepository` using the `Category` model attributes
    using the `By` instruction. As we can see, above `findByName(String name)`, Spring
    Data Framework will create the correct query to look up categories by name. It
    is fantastic.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，`JpaRepository` 接口使用所需的实体类型以及实体的 ID 类型进行类型化。这部分没有秘密。这个惊人的事情发生是为了支持基于属性名称的自定义查询。在
    `Category` 模型中，有一个名为 `name` 的属性**。**我们可以使用 `By` 指令在我们的 `CategoryRepository` 中创建自定义方法，使用
    `Category` 模型属性。正如我们所见，在 `findByName(String name)` 上，Spring Data 框架将创建正确的查询来按名称查找类别。这太棒了。
- en: 'There are many keywords supported by the custom query methods:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义查询方法支持许多关键字：
- en: '| **Logical Keyword** | **Logical Expressions** |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| **逻辑关键字** | **逻辑表达式** |'
- en: '| `AND` | `And` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `AND` | `And` |'
- en: '| `OR` | `Or` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `OR` | `Or` |'
- en: '| `AFTER` | `After`, `IsAfter` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `AFTER` | `After`, `IsAfter` |'
- en: '| `BEFORE` | `Before`, `IsBefore` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `BEFORE` | `Before`, `IsBefore` |'
- en: '| `CONTAINING` | `Containing`, `IsContaining`, `Contains` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `CONTAINING` | `Containing`, `IsContaining`, `Contains` |'
- en: '| `BETWEEN` | `Between`, `IsBetween` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `BETWEEN` | `Between`, `IsBetween` |'
- en: '| `ENDING_WITH` | `EndingWith`, `IsEndingWith`, `EndsWith` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `ENDING_WITH` | `EndingWith`, `IsEndingWith`, `EndsWith` |'
- en: '| `EXISTS` | `Exists` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `EXISTS` | `Exists` |'
- en: '| `FALSE` | `False`, `IsFalse` |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `FALSE` | `False`, `IsFalse` |'
- en: '| `GREATER_THAN` | `GreaterThan`, `IsGreaterThan` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `GREATER_THAN` | `GreaterThan`, `IsGreaterThan` |'
- en: '| `GREATHER_THAN_EQUALS` | `GreaterThanEqual`, `IsGreaterThanEqual` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `GREATHER_THAN_EQUALS` | `GreaterThanEqual`, `IsGreaterThanEqual` |'
- en: '| `IN` | `In`, `IsIn` |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `IN` | `In`, `IsIn` |'
- en: '| `IS` | `Is`, `Equals`, (or no keyword) |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `IS` | `Is`, `Equals`, (or no keyword) |'
- en: '| `IS_EMPTY` | `IsEmpty`, `Empty` |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `IS_EMPTY` | `IsEmpty`, `Empty` |'
- en: '| `IS_NOT_EMPTY` | `IsNotEmpty`, `NotEmpty` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `IS_NOT_EMPTY` | `IsNotEmpty`, `NotEmpty` |'
- en: '| `IS_NOT_NULL` | `NotNull`, `IsNotNull` |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `IS_NOT_NULL` | `NotNull`, `IsNotNull` |'
- en: '| `IS_NULL` | `Null`, `IsNull` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `IS_NULL` | `Null`, `IsNull` |'
- en: '| `LESS_THAN` | `LessThan`, `IsLessThan` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `LESS_THAN` | `LessThan`, `IsLessThan` |'
- en: '| `LESS_THAN_EQUAL` | `LessThanEqual`, `IsLessThanEqual` |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `LESS_THAN_EQUAL` | `LessThanEqual`, `IsLessThanEqual` |'
- en: '| `LIKE` | `Like`, `IsLike` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `LIKE` | `Like`, `IsLike` |'
- en: '| `NEAR` | `Near`, `IsNear` |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `NEAR` | `Near`, `IsNear` |'
- en: '| `NOT` | `Not`, `IsNot` |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `NOT` | `Not`, `IsNot` |'
- en: '| `NOT_IN` | `NotIn`, `IsNotIn` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `NOT_IN` | `NotIn`, `IsNotIn` |'
- en: '| `NOT_LIKE` | `NotLike`, `IsNotLike` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `NOT_LIKE` | `NotLike`, `IsNotLike` |'
- en: '| `REGEX` | `Regex`, `MatchesRegex`, `Matches` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `REGEX` | `Regex`, `MatchesRegex`, `Matches` |'
- en: '| `STARTING_WITH` | `StartingWith`, `IsStartingWith`, `StartsWith` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `STARTING_WITH` | `StartingWith`, `IsStartingWith`, `StartsWith` |'
- en: '| `TRUE` | `True`, `IsTrue` |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `TRUE` | `True`, `IsTrue` |'
- en: '| `WITHIN` | `Within`, `IsWithin` |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `WITHIN` | `Within`, `IsWithin` |'
- en: There are many ways to create a query based on attributes names. We can combine
    the keywords using keywords as well, such as `findByNameAndId`, for instance.
    The Spring Data JPA provides a consistent way to create queries.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 基于属性名称创建查询有许多方法。我们可以使用关键字组合关键字，例如 `findByNameAndId`。Spring Data JPA 提供了一种创建查询的一致方法。
- en: Configuring transactions
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置事务
- en: 'When we use the JPA specification, most of the applications need to have support
    for transactions as well. Spring has excellent support for transactions even in
    other modules. This support is integrated with Spring Data JPA, and we can take
    advantage of it. Configuring transactions in Spring is a piece of cake; we need
    to insert the `@Transactional` annotation whenever needed. There are some different
    use cases to use it. We will use the `@Transactional` in our services layer and
    then we will put the annotation in our service classes. Let''s see our `CategoryService`
    class:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 JPA 规范时，大多数应用程序还需要支持事务。Spring 在其他模块中也有出色的交易支持。这种支持与 Spring Data JPA 集成，我们可以利用它。在
    Spring 中配置事务非常简单；我们只需在需要时插入 `@Transactional` 注解即可。有一些不同的用例可以使用它。我们将在服务层使用 `@Transactional`，然后我们将注解放在我们的服务类中。让我们看看我们的
    `CategoryService` 类：
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There are many `@Transactional` annotations in the `CategoryService` class.
    The first annotation at class level instructs the framework to configure the `readOnly`
    for all methods present in those classes, except the methods configured with `@Transactional`.
    In this case, the class-level annotation will be overridden with `readOnly=false`.
    This is the default configuration when the value is omitted.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `CategoryService` 类中存在许多 `@Transactional` 注解。类级别的第一个注解指示框架为那些类中所有存在的方法配置 `readOnly`，除了配置了
    `@Transactional` 的方法。在这种情况下，类级别的注解将被覆盖为 `readOnly=false`。当省略值时，这是默认配置。
- en: Installing and configuring pgAdmin3
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和配置 pgAdmin3
- en: To connect on our PostgreSQL instance, we will use pgAdmin 3, which is the free
    tool provided by the Postgres team.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到我们的 PostgreSQL 实例，我们将使用 pgAdmin 3，这是 Postgres 团队提供的免费工具。
- en: 'To install pgAdmin 3, we can use the following command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 pgAdmin 3，我们可以使用以下命令：
- en: '[PRE10]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will install pgAdmin 3 on our machine.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的机器上安装 pgAdmin 3。
- en: After installation, open pgAdmin 3 and then click on Add a connection to a server.
    The button looks like this***:***
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，打开 pgAdmin 3，然后点击添加服务器连接。按钮看起来像这样***：***
- en: '![](img/1dd5adeb-ebbf-47b8-a707-d01201e5e74f.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1dd5adeb-ebbf-47b8-a707-d01201e5e74f.png)'
- en: 'Then, fill in the information, as shown in the following screenshot:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，填写以下截图所示的信息：
- en: '![](img/fe9cc957-3670-4483-8475-6fc0265a1ef2.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe9cc957-3670-4483-8475-6fc0265a1ef2.png)'
- en: The password should be: `cms@springfive.`
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 密码应该是：`cms@springfive.`。
- en: Awesome, our pgAdmin 3 tool is configured.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，我们的 pgAdmin 3 工具已配置完成。
- en: Checking the data on the database structure
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查数据库结构中的数据
- en: The whole application structure is ready. Now, we can check the database to
    get our persisted data. There are many open source Postgres clients. We will use
    pgAdmin 3, as previously configured.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 整个应用程序结构已准备就绪。现在，我们可以检查数据库以获取我们的持久化数据。有许多开源的 Postgres 客户端。我们将使用之前配置的 pgAdmin
    3。
- en: The first time you open the application, you will be asked about the credentials
    and host. We must put the same information as we configured on the `application.yaml`
    file. Then, we are able to make instructions in the database.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次打开应用程序时，您将被要求输入凭据和主机。我们必须输入与我们在 `application.yaml` 文件中配置的信息相同。然后，我们就可以在数据库中发出指令了。
- en: Before checking the database, we can use Swagger to create some categories in
    our CMS system. We can use the instructions provided in [Chapter 2](8b857b24-87be-4066-acb3-daa9a596b61e.xhtml),
    *Starting in the Spring World – The CMS Application,* to create some data.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查数据库之前，我们可以使用 Swagger 在我们的 CMS 系统中创建一些分类。我们可以参考[第 2 章](8b857b24-87be-4066-acb3-daa9a596b61e.xhtml)，*从
    Spring 世界开始 – CMS 应用程序*中提供的说明来创建一些数据。
- en: 'After that, we can execute the following SQL instruction in the database:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在数据库中执行以下 SQL 指令：
- en: '[PRE11]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And the result should be the categories created on Swagger calls. In my case,
    I have created two categories, `sports`, and `movies`. The result will be like
    the ones shown in the following screenshot:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该是 Swagger 调用中创建的分类。在我的情况下，我创建了两个分类，`sports` 和 `movies`。结果将类似于以下截图所示：
- en: '![](img/c77ce367-0276-46c9-844e-c609c52369f6.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c77ce367-0276-46c9-844e-c609c52369f6.png)'
- en: Awesome work, guys. The application is fully operational.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 了不起的工作，伙计们。应用程序已完全运行。
- en: Now, we will create our final solution for the repositories. We have learned
    the basics of the Spring Data project and in the next section, we will change
    the persistence layer to a modern database.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为存储库创建我们的最终解决方案。我们已经学习了 Spring Data 项目的基础知识，在下一节中，我们将把持久层改为现代数据库。
- en: Creating the final data access layer
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建最终的数据访问层
- en: We have played with the Spring Data JPA project, and we have seen how easy it
    can be. We learned how to configure the database connections to persist the real
    data on the Postgres database. Now, we will create the final solution for the
    data access layer for our application. The final solution will use MongoDB as
    a database and will use the Spring Data MongoDB project, which provides support
    for MongoDB repositories.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经玩过 Spring Data JPA 项目，并看到了它有多简单。我们学习了如何配置数据库连接，以便在 Postgres 数据库上持久化真实数据。现在，我们将为我们的应用程序创建数据访问层的最终解决方案。最终解决方案将使用
    MongoDB 作为数据库，并使用提供 MongoDB 存储库支持的 Spring Data MongoDB 项目。
- en: We will see some similarities with the Spring Data JPA projects. It is amazing because
    we can prove the power of Spring Data abstractions in practice. With a couple
    of changes, we can move to another database model.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到与 Spring Data JPA 项目的一些相似之处。这很令人惊讶，因为我们可以在实践中证明 Spring Data 抽象的力量。通过一些更改，我们可以迁移到另一个数据库模型。
- en: Let's understand the new project and put it into practice in the following sections.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下章节中了解新项目并将其付诸实践。
- en: Spring Data MongoDB
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Data MongoDB
- en: The Spring Data MongoDB provides integration with our domain objects and the
    MongoDB document. With a couple of annotations, our entity class is ready to be
    persisted in the database. The mapping is based on a **POJO** (**Plain Old Java
    Object**) pattern, which is known by all Java developers.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data MongoDB 为我们的领域对象和 MongoDB 文档提供了集成。通过几个注解，我们的实体类就准备好在数据库中持久化了。映射基于
    **POJO** （**普通的 Java 对象**）模式，这是所有 Java 开发者都熟知的。
- en: There are two levels of abstraction supplied by the module. The first one is
    a high-level abstraction. It increases the developer productivity. This level
    provides a couple of annotations to instruct the framework to convert the domain
    objects in MongoDB documents and vice versa. The developer does not need to write
    any code about the persistence; it will be managed by the Spring Data MongoDB
    framework. There are more exciting things at this level, such as the rich mapping
    configurations provided by the Spring Conversion Service. The Spring Data projects
    provide a rich DSL to enable developers to create queries based on the attribute
    names.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块提供了两个抽象级别。第一个是高级抽象。它提高了开发者的生产力。这个级别提供了一些注解，以指导框架将领域对象转换为 MongoDB 文档，反之亦然。开发者不需要编写任何关于持久性的代码；它将由
    Spring Data MongoDB 框架管理。在这个级别上还有更多令人兴奋的事情，例如 Spring Conversion Service 提供的丰富映射配置。Spring
    Data 项目提供了一个丰富的 DSL，使开发者能够根据属性名称创建查询。
- en: The second level of abstraction is the low-level abstraction. At this level,
    behaviors are not automatically managed by the framework. The developers need
    to understand a little bit more about the Spring and MongoDB document model. The
    framework provides a couple of interfaces to enable developers to take control
    of the read and write instructions. This can be useful for scenarios where the
    high-level abstraction does not fit well. In this case, the control should be
    more granular in the entities mapping.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象的第二层是低级抽象。在这一层，行为不是由框架自动管理的。开发者需要稍微了解一些Spring和MongoDB文档模型。框架提供了一些接口，以使开发者能够控制读写指令。这在高级抽象不适合的场景中可能很有用。在这种情况下，实体的映射控制应该更加细致。
- en: Again, Spring provides the power of choice for developers. The high-level abstraction
    improves the developer performance and the low-level permits developers to take
    more control.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，Spring为开发者提供了选择权。高级抽象提高了开发者的性能，而低级抽象允许开发者有更多的控制权。
- en: Now, we will add mapping annotation to our model. Let's do it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为我们的模型添加映射注解。让我们开始吧。
- en: Removing the PostgreSQL and Spring Data JPA dependencies
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除PostgreSQL和Spring Data JPA依赖项
- en: 'We will convert our project to use the brand new Spring Data Reactive MongoDB
    repositories. After that, we will not use the Spring Data JPA and PostgreSQL drivers
    anymore. Let''s remove these dependencies from our `pom.xml`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的项目转换为使用全新的Spring Data Reactive MongoDB存储库。在那之后，我们将不再使用Spring Data JPA和PostgreSQL驱动程序。让我们从我们的`pom.xml`中移除这些依赖项：
- en: '[PRE12]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And then, we can add the following dependency:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以添加以下依赖项：
- en: '[PRE13]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The final version of `pom.xml` can be found on GitHub at [https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter03/cms-mongo-non-reactive/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter03/cms-mongo-non-reactive/pom.xml).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`pom.xml`的最终版本可以在GitHub上找到：[https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter03/cms-mongo-non-reactive/pom.xml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter03/cms-mongo-non-reactive/pom.xml)。'
- en: Mapping the domain model
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射领域模型
- en: 'We will add mapping annotations on our domain model. The Spring Data MongoDB
    will use these annotations to persist our objects in the MongoDB collections.
    We will start with the `Category` entity, which should be like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的领域模型上添加映射注解。Spring Data MongoDB将使用这些注解来将我们的对象持久化到MongoDB集合中。我们将从`Category`实体开始，它应该像这样：
- en: '[PRE14]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We added two new annotations in the `Category` class. The `@Document` from Spring
    Data MongoDB enables us to configure the collection name. Collections in MongoDB
    are similar to tables in SQL databases.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Category`类中添加了两个新的注解。来自Spring Data MongoDB的`@Document`注解使我们能够配置集合名称。MongoDB中的集合类似于SQL数据库中的表。
- en: The `@Id` annotation is from the Spring Data Commons project. It is interesting
    because, as we can see, it is not specific for MongoDB mappings. The field annotation
    with this will be converted in the `_id` field on MongoDB collection.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Id`注解来自Spring Data Commons项目。它很有趣，因为我们可以看到，它并不是特定于MongoDB映射的。带有此注解的字段注解将在MongoDB集合的`_id`字段上转换。'
- en: With these few annotations, the `Category` class is configured to be persisted
    on MongoDB. In the following section, we will create our repository classes.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些注解，`Category`类被配置为在MongoDB上持久化。在下一节中，我们将创建我们的存储库类。
- en: We need to do the same task for our other entities. The `User` and `News` need
    to be configured in the same way as we did for the `Category` class. The full
    source code can be found on GitHub at: [https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter03/cms-mongo-non-reactive/src/main/java/springfive/cms/domain/models](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter03/cms-mongo-non-reactive/src/main/java/springfive/cms/domain/models).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对其他实体执行相同的任务。`User`和`News`需要以与`Category`类相同的方式进行配置。完整的源代码可以在GitHub上找到：[https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter03/cms-mongo-non-reactive/src/main/java/springfive/cms/domain/models](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter03/cms-mongo-non-reactive/src/main/java/springfive/cms/domain/models)。
- en: Configuring the database connection
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置数据库连接
- en: Before we create our repositories, we will configure the MongoDB connection.
    The repository layer abstracts the driver implementation, but is necessary to
    configure the driver correctly.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建我们的存储库之前，我们将配置MongoDB连接。存储库层抽象了驱动实现，但正确配置驱动是必要的。
- en: On the resources directory, we will change the `application.yaml` file, previously
    configured for the Spring Data JPA. The Spring Framework supports the configuration
    through the YAML file. This kind of file is more readable for humans and has a
    kind of hierarchy. These features are the reason to choose this extension.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在资源目录中，我们将更改之前为 Spring Data JPA 配置的 `application.yaml` 文件。Spring 框架支持通过 YAML
    文件进行配置。这种文件对人类来说更易于阅读，并且具有某种层次结构。这些特性是选择这种扩展的原因。
- en: 'The `application.yaml` file should be like the following example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`application.yaml` 文件应该像以下示例所示：'
- en: '[PRE15]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `application.yaml` file for MongoDB can be found on GitHub ([https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter03/cms-mongo-non-reactive/src/main/resources/application.yaml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter03/cms-mongo-non-reactive/src/main/resources/application.yaml)).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 的 `application.yaml` 文件可以在 GitHub 上找到 ([https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter03/cms-mongo-non-reactive/src/main/resources/application.yaml](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter03/cms-mongo-non-reactive/src/main/resources/application.yaml)).
- en: The file is quite simple for now. There is a `database` tag for configuring
    the database name. The `host` and `port` tags are about the address that the MongoDB
    instance is running.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 目前这个文件很简单。有一个 `database` 标签用于配置数据库名称。`host` 和 `port` 标签是关于 MongoDB 实例运行地址的。
- en: We also can configure the connections programmatically with a couple of objects,
    but it requires us to code a lot of boilerplate code. Spring Boot offers it out
    of the box for us. Let's enjoy it.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用几个对象以编程方式配置连接，但这需要我们编写大量的样板代码。Spring Boot 为我们提供了现成的解决方案。让我们享受它吧。
- en: Excellent, the connection was configured successfully. The infrastructure requirements
    are solved. Let's go on to implement our repositories.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，连接配置成功。基础设施需求已解决。让我们继续实现我们的仓库。
- en: Spring Boot Framework supports profiles in `application.properties`or`application.yaml`.
    This means that if the application was configured in a properties file style,
    we could use `application-<profile>.properties`. Then, these properties will be
    applied to the required profile. In YAML style, we can use only one file with
    multiples profiles.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 框架支持在 `application.properties` 或 `application.yaml` 中配置配置文件。这意味着如果应用程序以属性文件样式配置，我们可以使用
    `application-<profile>.properties`。然后，这些属性将应用于所需的配置文件。在 YAML 风格中，我们可以使用一个包含多个配置文件的单一文件。
- en: Adding the repository layer
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加仓库层
- en: Once the entities have been mapped, and the connections are done, it's time
    to create our repositories. The Spring Data Framework provides some interfaces
    that can be used in different use cases. We will use the specialization for the
    MongoDB database, which is `MongoRepository`. It extends the `PagingAndSortingRepository`
    and `QueryByExampleExecutor`. The first is about pagination and sorting features,
    and the other is about queries by example.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实体被映射，并且建立了连接，就是时候创建我们的仓库了。Spring Data 框架提供了一些接口，可以在不同的用例中使用。我们将使用 MongoDB
    数据库的特化，即 `MongoRepository`。它扩展了 `PagingAndSortingRepository` 和 `QueryByExampleExecutor`。前者关于分页和排序功能，后者关于示例查询。
- en: In some cases, the database query result set can be very large. This can cause
    some application performance issues because we will fetch a lot of database records.
    We can limit the number of records fetched from the database and configure limits
    for that. This technique is called **Pagination**. We can find the full documentation
    at *Spring Data Commons Documentation* ([https://docs.spring.io/spring-data/commons/docs/current/reference/html/](https://docs.spring.io/spring-data/commons/docs/current/reference/html/)).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，数据库查询结果集可能非常大。这可能会引起一些应用程序性能问题，因为我们将会获取大量的数据库记录。我们可以限制从数据库中获取的记录数，并为此配置限制。这种技术称为
    **分页**。我们可以在 *Spring Data Commons 文档* 中找到完整的文档 ([https://docs.spring.io/spring-data/commons/docs/current/reference/html/](https://docs.spring.io/spring-data/commons/docs/current/reference/html/))。
- en: This interface offers a lot of built-in methods for convenience. There are a
    couple of methods to insert one or more instances, methods for listing all instances
    of requested entities, methods to remove one or more instances, and many more
    features, such as ordering and paging.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口提供了许多内置方法以方便使用。有几个方法可以插入一个或多个实例，有列出请求实体所有实例的方法，有删除一个或多个实例的方法，以及许多其他功能，如排序和分页。
- en: It enables developers to create repositories without code or even without a
    deep knowledge of MongoDB. However, some knowledge of MongoDB is necessary to
    troubleshoot various errors.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 它使开发者能够无需代码甚至无需深入了解MongoDB就能创建仓库。然而，为了排除各种错误，对MongoDB的一些了解是必要的。
- en: We will start by creating the `CategoryRepository`. Change the type of `CategoryRepository`
    to an interface instead of a class. The code in this interface is not necessary.
    The Spring container will inject the correct implementation when the application
    starts.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建`CategoryRepository`。将`CategoryRepository`的类型从类改为接口。这个接口中的代码不是必要的。Spring容器将在应用程序启动时注入正确的实现。
- en: 'Let''s create our first concrete repository, which means the repository will
    persist the data on the MongoDB we previously configured. The `CategoryRepository`
    needs to be like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的第一个具体仓库，这意味着这个仓库将持久化我们在之前配置的MongoDB上的数据。`CategoryRepository`需要是这样的：
- en: '[PRE16]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The type is an `interface`.Repositories do not have any stereotypes anymore. The
    Spring container can identify the implementation because it extends the `MongoRepository`
    interface.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 类型是`interface`。仓库不再有任何 stereotypes。Spring 容器可以通过它扩展的`MongoRepository`接口来识别实现。
- en: The `MongoRepository` interface should be parameterized. The first argument
    is the type of model that it represents. In our case, it represents a repository
    for the `Category` class. The second parameter is about the type of ID of the
    model. We will use the string type for that.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`MongoRepository`接口应该被参数化。第一个参数是它所表示的模型类型。在我们的例子中，它表示`Category`类的仓库。第二个参数是关于模型ID的类型。我们将使用字符串类型。'
- en: Now, we need to do the same for the other entities, `User`, and `News`. The
    code is quite similar to the preceding code. You can find the full source code
    on GitHub at: [https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter03/cms-mongo-non-reactive/src/main/java/springfive/cms/domain/repository](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter03/cms-mongo-non-reactive/src/main/java/springfive/cms/domain/repository).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要对其他实体`User`和`News`做同样的事情。代码与前面的代码非常相似。你可以在GitHub上找到完整的源代码：[https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter03/cms-mongo-non-reactive/src/main/java/springfive/cms/domain/repository](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter03/cms-mongo-non-reactive/src/main/java/springfive/cms/domain/repository)。
- en: In the next section, we will check the database to assert that the rows are
    persisted correctly.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将检查数据库以断言行是否正确持久化。
- en: Checking the persistence
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查持久性
- en: Now, we can test the persistence and all layers of the application. We will
    provide the API documentation for that. Let's open the Swagger documentation and
    create some records in our CMS application.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以测试应用程序的持久性和所有层。我们将提供相应的API文档。让我们打开Swagger文档，并在我们的CMS应用程序中创建一些记录。
- en: 'Creating sample categories on Swagger:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swagger上创建示例类别：
- en: '![](img/19e4c9c0-2dd1-4672-893c-0893ec51560e.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/19e4c9c0-2dd1-4672-893c-0893ec51560e.png)'
- en: Fill in the category JSON, as shown in the preceding screenshot, and then click
    on Try it out!. It will invoke the Category API and persist the category on the
    database. Now, we can check it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 填写类别JSON，如前面的截图所示，然后点击“Try it out!”。它将调用类别API并将类别持久化到数据库中。现在，我们可以检查它。
- en: To connect to the MongoDB instance and check the collection, we will use the
    `mongo-express` tool. It is a web-based tool written in NodeJS to interact with
    our database instance.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到MongoDB实例并检查集合，我们将使用`mongo-express`工具。这是一个基于NodeJS编写的Web工具，用于与我们的数据库实例交互。
- en: 'The tool can be installed, but we will run the tool on a Docker container. The
    Docker tool will help us in this part. Let''s start the container:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 工具可以安装，但我们将在一个Docker容器上运行工具。Docker工具将帮助我们完成这部分。让我们启动容器：
- en: '[PRE17]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It instructs Docker to spin up a container with the `mongo-express` tool and
    connect to the desired instance. The `--link` argument instructs Docker to create
    a kind of *hostname* for our MongoDB instance. Remember the name of our instance
    is `mongodb`; we did it on the run command previously.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 它指示Docker启动一个带有`mongo-express`工具的容器并连接到所需的实例。`--link`参数指示Docker为我们的MongoDB实例创建一个类似*hostname*的东西。记住我们的实例名称是`mongodb`；我们在之前的运行命令中已经这样做了。
- en: 'Good job. Go to `http://localhost:8081` and we will see this page:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好。前往`http://localhost:8081`，我们将看到这个页面：
- en: '![](img/612df25d-1ee2-4b1e-9242-782e95554648.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/612df25d-1ee2-4b1e-9242-782e95554648.png)'
- en: 'There are a couple of databases. We are interested in the CMS database. Click
    on the View button next to cms. Then, the tool will present the collections of
    the selected database; in our case, the CMS database. The view should be like
    this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个数据库。我们感兴趣的是 CMS 数据库。点击旁边的“查看”按钮旁边的 cms。然后，工具将展示所选数据库的集合；在我们的案例中，是 CMS 数据库。视图应该如下所示：
- en: '![](img/06842b34-47ef-433d-a742-d7961996a368.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/06842b34-47ef-433d-a742-d7961996a368.png)'
- en: 'The category is presented as a collection. We can View, Export, and export
    as JSON, but for now, we are interested in checking if our CMS application persisted
    the data properly. So, click on the View button. We will use the MongoDB collection
    data like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 类别以集合的形式呈现。我们可以查看、导出，并以 JSON 格式导出，但就目前而言，我们感兴趣的是检查我们的 CMS 应用程序是否正确地持久化了数据。因此，点击“查看”按钮。我们将使用
    MongoDB 集合数据如下：
- en: '![](img/ca8b9aca-8cd4-4077-8617-f34e4e83df0f.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ca8b9aca-8cd4-4077-8617-f34e4e83df0f.png)'
- en: As we can see, the data was stored in MongoDB as expected. There are two categories
    in the database—sports and travel. There is a `_class` field that helps Spring
    Data to convert domain classes.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，数据已按预期存储在 MongoDB 中。数据库中有两个类别——体育和旅行。有一个 `_class` 字段，它帮助 Spring Data 将域类进行转换。
- en: Awesome job, the CMS application is up and running, and also persisting the
    data in MongoDB. Now, our application is almost production ready, and the data
    is persisted outside in the amazing document datastore.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好，CMS 应用程序已启动并运行，并且正在 MongoDB 中持久化数据。现在，我们的应用程序几乎已准备好投入生产，数据已在外部的出色文档数据存储中持久化。
- en: In the following section, we will create our Docker image, and then we will
    run the CMS application with Docker commands. It will be interesting.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将创建我们的 Docker 镜像，然后我们将使用 Docker 命令运行 CMS 应用程序。这将很有趣。
- en: Creating the Docker image for CMS
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 CMS 创建 Docker 镜像
- en: We are doing an awesome job. We created an application with the Spring Boot
    Framework. The application has been using the Spring REST, Spring Data, and Spring
    DI.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在做一件了不起的工作。我们使用 Spring Boot 框架创建了一个应用程序。该应用程序已经使用了 Spring REST、Spring Data
    和 Spring DI。
- en: Now we will go a step forward and create our Docker image. It will be useful
    to help us to deliver our application for production. There are some advantages,
    and we can run the application on-premise or on any cloud providers because Docker
    abstracts the operating system layer. We do not need Java to be installed on the
    application host, and it also allows us to use different Java versions on the
    hosts. There are so many advantages involved in adopting Docker for delivery.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将更进一步，创建我们的 Docker 镜像。这将有助于我们交付我们的应用程序到生产环境中。有一些优势，我们可以在本地或任何云服务提供商上运行应用程序，因为
    Docker 抽象了操作系统层。我们不需要在应用程序主机上安装 Java，它还允许我们在主机上使用不同的 Java 版本。采用 Docker 进行交付涉及许多优势。
- en: We are using Maven as a build tool. Maven has an excellent plugin to helps us
    to create Docker images. In the following section, we will learn how Maven can
    help us.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Maven 作为构建工具。Maven 有一个出色的插件可以帮助我们创建 Docker 镜像。在下一节中，我们将了解 Maven 如何帮助我们。
- en: Configuring the docker-maven-plugin
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 docker-maven-plugin
- en: There is an excellent Maven plugin provided by fabric8 ([https://github.com/fabric8io/docker-maven-plugin](https://github.com/fabric8io/docker-maven-plugin)).
    It is licensed under the Apache-2.0 license, which means we can use it without
    any worries.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: fabric8 提供了一个出色的 Maven 插件（[https://github.com/fabric8io/docker-maven-plugin](https://github.com/fabric8io/docker-maven-plugin)）。它遵循
    Apache-2.0 许可协议，这意味着我们可以无忧无虑地使用它。
- en: We will configure our project to use it, and after image creation, we will push
    this image on Docker Hub. It is a public Docker registry.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将配置我们的项目以使用它，并在镜像创建后，将其推送到 Docker Hub。这是一个公共 Docker 仓库。
- en: 'The steps are:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤如下：
- en: Configure the plugin
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置插件
- en: Push the Docker image
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推送 Docker 镜像
- en: Configure the Docker Spring profile
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 Docker Spring 配置文件
- en: Then, it is show time. Let's go.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，是时候展示成果了。让我们开始吧。
- en: Adding the plugin on pom.xml
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 pom.xml 中添加插件
- en: 'Let''s configure the Maven plugin. It is necessary to add a plugin to the plugin
    section on our `pom.xml` and add some configurations. The plugin should be configured
    as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们配置 Maven 插件。在 `pom.xml` 上的插件部分添加一个插件并添加一些配置是必要的。插件应该配置如下：
- en: '[PRE18]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There are a couple of new configurations here. Let's start with the `<name>`
    tag—it configures the repository and Docker image name to push to Docker Hub.
    For this book, we will use `springfivebyexample` as a Docker ID. We can see there
    is a *slash* as a separator for the repository and image name. The image name
    for us will be the final project name. Then, we need to configure it.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些新的配置。让我们从`<name>`标签开始——它配置了要推送到Docker Hub的仓库和Docker镜像名称。对于这本书，我们将使用`springfivebyexample`作为Docker
    ID。我们可以看到，仓库和镜像名称之间使用`*斜杠*`作为分隔符。对于我们来说，镜像名称将是最终的项目名称。然后，我们需要进行配置。
- en: The Docker ID is free to use, which can be used to access some Docker services,
    such as Docker Store, Docker Cloud, and Docker Hub. We can find more information
    at Docker Page ([https://docs.docker.com/docker-id/](https://docs.docker.com/docker-id/)).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Docker ID是免费使用的，可以用来访问一些Docker服务，如Docker Store、Docker Cloud和Docker Hub。我们可以在Docker页面找到更多信息（[https://docs.docker.com/docker-id/](https://docs.docker.com/docker-id/)）。
- en: 'This configuration should be the same as shown in the following code snippet:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置应与以下代码片段中显示的相同：
- en: '[PRE19]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Another important tag is `<entrypoint>`. This is an exec system call instruction
    when we use the `docker run` command. In our case, we expected the application
    to run when the container bootstraps. We will execute `java -jar` passing the
    container as an active profile for Spring.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的标签是`<entrypoint>`。这是当我们使用`docker run`命令时的一个exec系统调用指令。在我们的情况下，我们期望应用程序在容器引导时运行。我们将执行`java
    -jar`，将容器作为Spring的活跃配置文件传递。
- en: We need to pass the full path of the Java artifact. This path will be configured
    on the `<assembly>` tag with the `<basedir>` parameter. It can be any folder name.
    Also, there is a configuration to the Java artifact path. Usually, this is the
    target folder which is the result of the compilation. It can be configured in
    the `<source>` tag.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要传递Java构件的完整路径。此路径将在`<assembly>`标签的`<basedir>`参数中配置。可以是任何文件夹名称。此外，还有一个针对Java构件路径的配置。通常，这是编译的结果文件夹，可以在`<source>`标签中进行配置。
- en: Finally, we have the `<port>` configuration. The port of the application will
    be exposed using this tag.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`<port>`配置。应用程序的端口将通过此标签暴露。
- en: 'Now, we will create a Docker image by using the following instruction:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用以下指令创建一个Docker镜像：
- en: '[PRE20]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It should be executed in the root folder of the project. The goal of the `docker:build`
    command is to build a Docker image for our project. After the build ends, we can
    check if the Docker image has been created successfully.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 应在项目的根目录下执行。`docker:build`命令的目标是为我们的项目构建一个Docker镜像。构建完成后，我们可以检查Docker镜像是否已成功创建。
- en: 'Then, type the following command:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，输入以下命令：
- en: '[PRE21]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `springfivebyexample/cms` image should be present, as shown in the following
    screenshot:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，应该存在`springfivebyexample/cms`镜像：
- en: '![](img/fb420ba4-fd31-4f1c-9c8a-f6b3002071b1.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fb420ba4-fd31-4f1c-9c8a-f6b3002071b1.png)'
- en: Good. The image is ready. Let's push to the Docker Hub.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。镜像已准备好。让我们将其推送到Docker Hub。
- en: Pushing the image to Docker Hub
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推送镜像到Docker Hub
- en: The Docker Hub is a public repository to store Docker images. It is free, and
    we will use it for this book. Now, we will push our image to the Docker Hub registry.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub是一个公共仓库，用于存储Docker镜像。它是免费的，我们将为此书使用它。现在，我们将把我们的镜像推送到Docker Hub注册表。
- en: 'The command for that is pretty simple. Type:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令相当简单。输入：
- en: '[PRE22]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: I have used the `springfivebyexample` user that I have created. You can test
    the `docker push` command creating by your own user on Docker Hub and changing
    the user on the `docker push` command. You can create your Docker ID at Docker
    Hub ([https://cloud.docker.com/](https://cloud.docker.com/)).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了我自己创建的`springfivebyexample`用户。你可以在Docker Hub上用自己的用户测试`docker push`命令，并在`docker
    push`命令中更改用户。你可以在Docker Hub上创建你的Docker ID（[https://cloud.docker.com/](https://cloud.docker.com/)）。
- en: Then, the image will be sent to the registry. That is it.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，镜像将被发送到注册表。就是这样。
- en: We can find the image at Docker Hub ([https://store.docker.com/community/images/springfivebyexample/cms](https://store.docker.com/community/images/springfivebyexample/cms)).
    If you have used your own user, the link will probably change.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Docker Hub上找到该镜像（[https://store.docker.com/community/images/springfivebyexample/cms](https://store.docker.com/community/images/springfivebyexample/cms)）。如果你使用了你自己的用户，链接可能会改变。
- en: Configuring the Docker Spring profile
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Docker Spring配置文件
- en: Before we run our application in a Docker container, we need to create a YAML
    file to configure a container profile. The new YAML file should be named as `application-container.yaml`
    because we will use the container profile to run it. Remember, we configured the
    `entrypoint` on `pom.xml` in the previous section.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行 Docker 容器中的应用程序之前，我们需要创建一个 YAML 文件来配置容器配置文件。新的 YAML 文件应命名为 `application-container.yaml`，因为我们将会使用容器配置文件来运行它。记住，我们在上一节中在
    `pom.xml` 上配置了 `entrypoint`。
- en: 'Let''s create our new file. The file should be the same content as described
    in the following snippet:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的新文件。该文件应与以下片段中描述的内容相同：
- en: '[PRE23]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The host must be changed for MongoDB. We have been running the MongoDB container
    with this name in the *Preparing a MongoDB* section. It is an important configuration,
    and we need to pay attention at this point. We cannot use localhost anymore because
    the application is running in the Docker container now. The localhost in that
    context means it is in the same container, and we do not have MongoDB in the CMS
    application container. We need to have one application per container and avoid
    multiple responsibilities for one container.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 主机必须更改以用于 MongoDB。我们在“准备 MongoDB”部分中已经使用此名称运行了 MongoDB 容器。这是一个重要的配置，我们需要在此点注意。我们不能再使用
    localhost，因为应用程序现在正在 Docker 容器中运行。在这个上下文中，localhost 意味着它在同一个容器中，而 CMS 应用程序容器中没有
    MongoDB。我们需要每个容器一个应用程序，避免一个容器承担多个职责。
- en: Done. In the following section, we will run our first application in the Docker
    container. It will be amazing. Let's do it.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 完成。在下一节中，我们将运行我们的第一个 Docker 容器中的应用程序。这将非常棒。让我们行动起来。
- en: Running the Dockerized CMS
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行 Docker 化的 CMS
- en: In the previous section, we have created our file to configure the container
    profile properly. Now, it is time to run our container. The command is quite simple,
    but we need to pay attention to the arguments.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们已经创建了文件来正确配置容器配置文件。现在，是时候运行我们的容器了。命令相当简单，但我们需要注意参数。
- en: 'The instruction we run should be the same as the following code:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行的指令应该与以下代码相同：
- en: '[PRE24]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We have been setting the link for the MongoDB container. Remember, we made this
    configuration in the YAML file, in the `host` property. During the bootstrapping
    phase, the application will look for MongoDB instance named `mongodb`. We solved
    this by using the link command. It will work perfectly.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了 MongoDB 容器的链接。记住，我们在 YAML 文件中的 `host` 属性中进行了此配置。在引导阶段，应用程序将寻找名为 `mongodb`
    的 MongoDB 实例。我们通过使用链接命令解决了这个问题。它将完美工作。
- en: 'We can check if our application is healthy by using the `docker ps` command.
    The output should be like this:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `docker ps` 命令来检查我们的应用程序是否健康。输出应该如下所示：
- en: '![](img/fa2019c6-2585-4fdb-aee0-97d8d59cd286.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa2019c6-2585-4fdb-aee0-97d8d59cd286.png)'
- en: In the first line, we have our application container. It is up and running.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们有我们的应用程序容器。它已经启动并运行。
- en: Awesome work. Our application is fully containerized and ready to deploy anywhere
    we want.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 了不起的工作。我们的应用程序已经完全容器化，随时可以部署到我们想要的地方。
- en: Putting in Reactive fashion
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以响应式的方式实现
- en: We have been creating an amazing application with Spring Boot. The application
    was built on the traditional web stack present on Spring Framework. It means the
    application uses the web servers based on Servlet APIs.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在使用 Spring Boot 创建一个了不起的应用程序。该应用程序是在 Spring 框架上存在的传统 Web 栈上构建的。这意味着应用程序使用基于
    Servlet API 的 Web 服务器。
- en: The servlet specification was built with the blocking semantics or one-request-per-thread
    model. Sometimes, we need to change the application architecture because of non-functional
    requirements. For example, if the application was bought by a huge company, and
    that company wanted to create a plan to launch the application for the entire
    world, the volume of requests would probably increase a lot. So, we need to change
    the architecture to adapt the application structure for cloud environments.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Servlet 规范是使用阻塞语义或每线程一个请求的模型构建的。有时，我们需要因为非功能性需求而更改应用程序架构。例如，如果应用程序被一家大公司收购，并且该公司想要为全球推出应用程序，请求量可能会大幅增加。因此，我们需要更改架构以适应云环境中的应用程序结构。
- en: Usually, in a cloud environment, the machines are smaller than traditional data
    centers. Instead of a big machine, it is popular to use many small machines and
    try to scale applications horizontally. In this scenario, the servlet spec can
    be switched to an architecture created upon Reactive Streams. This kind of architecture
    fits better than servlet for the cloud environments.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在云环境中，机器的规模比传统数据中心要小。在这种情况下，人们更倾向于使用许多小机器，并尝试水平扩展应用程序。在这种情况下，可以将 servlet
    规范切换到基于 Reactive Streams 的架构。这种架构比 servlet 更适合云环境。
- en: Spring Framework has been creating the Spring WebFlux to helps developers to
    create Reactive Web Applications. Let's change our application architecture to
    reactive and learn the pretty new Spring WebFlux component.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 框架一直在创建 Spring WebFlux，以帮助开发者创建反应式 Web 应用程序。让我们改变我们的应用程序架构，转向反应式，并学习
    Spring WebFlux 组件的新颖之处。
- en: Reactive Spring
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reactive Spring
- en: The Reactive Stream Spec is the specification that provides a standard for asynchronous
    programming for stream processing. It is becoming popular in the programming world
    nowadays, and Spring introduces it on the framework.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: Reactive Stream Spec 是提供流处理异步编程标准的规范。如今，它在编程界越来越受欢迎，Spring 在框架中引入了它。
- en: This style of programming is more efficient regarding resources usage and fits
    amazingly with the new generation of machines with multiple cores.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编程风格在资源使用效率上更高，并且与多核的新一代机器非常契合。
- en: Spring reactive uses the Project Reactor as the implementation for the Reactive
    Streams. The Project Reactor is powered by Pivotal and has the very good implementation
    of the Reactive Streams Spec.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Spring reactive 使用 Project Reactor 作为 Reactive Streams 的实现。Project Reactor 由
    Pivotal 支持，对 Reactive Streams Spec 的实现非常好。
- en: Now, we will deep dive in the reactive module for Spring Boot and create an
    amazing reactive API and try the new style of the Spring Framework.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将深入探讨 Spring Boot 的反应式模块，创建一个令人惊叹的反应式 API，并尝试 Spring 框架的新风格。
- en: Project Reactor
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Project Reactor
- en: The Project Reactor was created by the Spring and Pivotal teams. This project
    is an implementation of Reactive Streams for JVM.  It is a fully non-blocking
    foundation and helps developers to create a non-blocking application in the JVM
    ecosystem.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Project Reactor 是由 Spring 和 Pivotal 团队创建的。这个项目是 JVM 的 Reactive Streams 实现。它是一个完全非阻塞的基础，帮助开发者创建
    JVM 生态系统中的非阻塞应用程序。
- en: There is a restriction to using Reactor in our application. The project runs
    on Java 8 and above. It is important because we will use many lambda expressions
    in our examples and projects.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中使用 Reactor 有一定的限制。项目运行在 Java 8 及以上版本。这很重要，因为我们的示例和项目中将使用许多 lambda 表达式。
- en: The Spring Framework internally uses the Project Reactor as an implementation
    of Reactive Streams.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 框架内部使用 Project Reactor 作为 Reactive Streams 的实现。
- en: Components
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件
- en: 'Let''s look at the different components of the Project Reactor:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 Project Reactor 的不同组件：
- en: '**Publishers**:The publishers are responsible for pushing data elements to
    the stream. It notifies the subscribers that a new piece of data is coming to
    the stream.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布者**：发布者负责将数据元素推送到流中。它通知订阅者，有新的数据即将进入流。'
- en: 'The publisher interface is defined in the following code snippet:'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 发布者接口定义在以下代码片段中：
- en: '[PRE25]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Subscribers**: The subscribers are responsible for making the data flow in
    the stream. When the publisher starts to send the piece of data on the data flow,
    the piece of data will be collected by the `onNext(T instance)` method, which is
    the parametrized interface.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订阅者**：订阅者负责使数据在流中流动。当发布者开始在数据流中发送数据块时，数据块将通过 `onNext(T instance)` 方法被收集，这是一个参数化接口。'
- en: 'The subscriber interface is defined in the following code snippet:'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 订阅者接口定义在以下代码片段中：
- en: '[PRE26]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Hot and cold
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 热和冷
- en: 'There are two categories of reactive sequences—hot and cold. These functions
    affect the usage of the implementation directly. Hence, we need to understand
    them:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 存在两种类型的反应式序列——热和冷。这些函数直接影响实现的使用。因此，我们需要了解它们：
- en: '**Cold**: The cold publishers start to generate data only if it receives a
    new subscription. If there are no subscriptions, the data never comes to the flow.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冷**：冷发布者只有在接收到新的订阅时才开始生成数据。如果没有订阅，数据永远不会进入流程。'
- en: '**Hot**: The hot publishers do not need any subscribers to generate the data
    flow. When the new subscriber is registered, the subscriber will only get the
    new data elements emitted.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**热**：热发布者不需要任何订阅者来生成数据流。当新订阅者注册时，订阅者将只获取新发射的数据元素。'
- en: Reactive types
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式类型
- en: There are two reactive types which represent the reactive sequences. The `Mono` objects
    represent a single value or empty 0|1\. The `Flux` objects represent a sequence
    of 0|N items.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种反应式类型代表反应式序列。`Mono`对象代表单个值或空0|1。`Flux`对象代表0|N个项目的序列。
- en: We will find many references in our code. The Spring Data reactive repository
    uses these abstractions in their methods. The `findOne()` method returns the `Mono<T>` object
    and the `findAll()` returns a `Flux<T>`. The same behavior we will be found in
    our REST resources.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码中会找到许多引用。Spring Data reactive仓库在其方法中使用这些抽象。`findOne()`方法返回`Mono<T>`对象，而`findAll()`返回一个`Flux<T>`。在我们的REST资源中也会找到相同的行为。
- en: Let's play with the Reactor
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们来玩一玩Reactor。
- en: To understand it better, let's play with the Reactor. We will implement and
    understand the difference between hot and cold publishers in practice.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，让我们玩一玩Reactor。我们将实际实现并理解热发布者和冷发布者之间的区别。
- en: '**Cold** publishers do not produce any data until a new subscription arrives.
    In the following code, we will create a cold publisher and the `System.out:println`
    will never be executed because it does not have any subscribers. Let''s test the
    behavior:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**冷**发布者在新的订阅到达之前不会产生任何数据。在下面的代码中，我们将创建一个冷发布者，并且`System.out:println`永远不会被执行，因为它没有任何订阅者。让我们测试这个行为：'
- en: '[PRE27]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As we can see, the method `subscribe()` is not present in this snippet. When
    we execute the code, we will not see any data on the standard print output.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，`subscribe()`方法并不在这个片段中。当我们执行代码时，我们将在标准输出上看到任何数据。
- en: 'We can execute the method on the IDE. We will able to see the output of this
    test. The output should be like this:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在IDE中执行这个方法。我们将能够看到这个测试的输出。输出应该是这样的：
- en: '![](img/0e2ea25e-3922-45d7-b0fc-beddae937856.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e2ea25e-3922-45d7-b0fc-beddae937856.png)'
- en: The process has finished, the test passed, and we will not be able to see the
    print. That is the cold publisher's behavior.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 流程已经完成，测试通过，我们将无法看到打印输出。这就是冷发布者的行为。
- en: Now, we will subscribe the publisher and the data will be sent on the data flow.
    Let's try this.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将订阅发布者，数据将通过数据流发送。让我们试试这个。
- en: 'We will insert the subscribe instruction after `doOnNext()`. Let''s change
    our code:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`doOnNext()`之后插入`subscribe`指令。让我们更改我们的代码：
- en: '[PRE28]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output should be like this:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是这样的：
- en: '![](img/bcfef033-e11d-4d1d-9b4b-d9cdb2ac69b3.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bcfef033-e11d-4d1d-9b4b-d9cdb2ac69b3.png)'
- en: In the preceding screenshot, we can see that the publisher pushes the data on
    the stream after the stream got subscribed. That is the cold publisher behavior
    after the subscription.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图上，我们可以看到发布者在流被订阅后推数据到流上。这是订阅后的冷发布者行为。
- en: 'Hot publishers do not depend on any subscribers. The hot publisher will publish
    data, even if there is no subscriber to receive the data. Let''s see an example:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 热发布者不依赖于任何订阅者。即使没有订阅者接收数据，热发布者也会发布数据。让我们看看一个例子：
- en: '[PRE29]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Let's understand what happens here. The `UnicastProcessor` is a processor that
    allows only one `Subscriber`.The processor replays notifications when the subscriber
    requests. It will emit some data on a stream. The first subscription will capture
    all the categories, as we will see, because it was registered before the event
    emissions. The second subscription will capture only the last events because it
    was registered before the last two emissions.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解这里发生了什么。`UnicastProcessor`是一个只允许一个`Subscriber`的处理程序。当订阅者请求时，处理程序会重放通知。它将在流上发射一些数据。第一个订阅将捕获所有类别，正如我们将看到的，因为它是在事件发射之前注册的。第二个订阅将只捕获最后的事件，因为它是在最后两个发射之前注册的。
- en: 'The output of the preceding code should be:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出应该是：
- en: '![](img/47ec7d59-37b9-4c73-9997-cc6cad4ecc34.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](img/47ec7d59-37b9-4c73-9997-cc6cad4ecc34.png)'
- en: Awesome. This is the hot publisher's behavior.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了。这是热发布者的行为。
- en: Spring WebFlux
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring WebFlux
- en: The traditional Java enterprise web applications are based on the servlet specification.
    The servlet specification before 3.1 is synchronous, which means it was created
    with blocking semantics. This model was good at the time because computers were
    big with a powerful CPU and hundreds of gigabytes of memory. Usually, the applications
    at the time were configured with a big thread pool with hundreds of threads because
    the computer was designed for this. The primary deployment model at that time
    was the replica. There are some machines with the same configuration and application
    deployments.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的Java企业级Web应用程序基于servlet规范。3.1之前的servlet规范是同步的，这意味着它是用阻塞语义创建的。在当时，由于计算机体积大，拥有强大的CPU和数百GB的内存，这种模型是好的。当时的应用程序通常配置有大量的线程池，因为计算机是为这种用途设计的。当时的首要部署模型是副本。有一些机器配置和应用程序部署相同。
- en: The developers have been creating applications like this for many years.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者已经多年在创建这类应用程序。
- en: Nowadays, most of the applications are deployed in cloud vendors. There are
    no big machines anymore because the price is much higher. Instead of big machines,
    there are a number of small machines. It is much cheaper and these machines have
    a reasonable CPU power and memory.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，大多数应用程序都部署在云服务提供商上。再也没有大机器了，因为价格要高得多。而不是大机器，有许多小机器。这要便宜得多，这些机器有合理的CPU功率和内存。
- en: In this new scenario, the application with the huge thread pools is not effective
    anymore, because the machine is small and it does not have the power to handle
    all these threads.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新场景中，拥有巨大线程池的应用程序不再有效，因为机器体积小，没有足够的处理所有这些线程的能力。
- en: The Spring Team added the support for the Reactive Streams in the framework.
    This model of programming changes the application deployment and the way to build
    applications.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Spring团队在框架中增加了对反应式流的支持。这种编程模型改变了应用程序的部署方式和构建应用程序的方式。
- en: Instead of a thread-per-request model, the applications are created with the
    event-loop model. This model requires a small number of threads and is more efficient
    regarding resource usage.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 与线程-per-请求模型不同，应用程序使用事件循环模型创建。这种模型需要较少的线程，并且在资源使用方面更有效。
- en: Event-loop model
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件循环模型
- en: 'Popularized by the NodeJS language, this model is based on event-driven programming.
    There are two central concepts: the events which will be enqueued on a queue,
    and the handlers which keep track of and process these events.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 由NodeJS语言推广的这种模型基于事件驱动编程。有两个核心概念：将在队列上入队的事件，以及跟踪和处理这些事件的处理器。
- en: There are some advantages of adopting this model. The first one is the ordering.
    The events are enqueued and dispatched in the same order in which the events are
    coming. In some uses cases, this is an important requirement.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种模型有一些优势。第一个是排序。事件按事件到达的顺序入队和分发。在某些用例中，这是一个重要的要求。
- en: The other one is the synchronization. The event-loop must be executed on only
    one thread. This makes the states easy to handle and avoids the shared state problems.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个是同步。事件循环必须在单个线程上执行。这使得状态易于处理，并避免了共享状态问题。
- en: There is an important piece of advice here. The handlers must not be synchronous.
    Otherwise, the application will be blocked until the handlers end their workload.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一条重要的建议。处理器不能是同步的。否则，应用程序将被阻塞，直到处理器完成其工作负载。
- en: Spring Data for Reactive Extensions
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Data反应式扩展
- en: The Spring Data projects have some extensions to work with a reactive foundation.
    The project provides a couple of implementations based on asynchronous programming.
    It means the whole stack is asynchronous since database drivers are as well.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data项目有一些扩展，可以与反应式基础一起工作。该项目提供了一些基于异步编程的实现。这意味着整个堆栈都是异步的，因为数据库驱动程序也是异步的。
- en: The Spring reactive repository supports Cassandra, MongoDB, and Redis as database
    stores. The repository implementations offer the same behaviors as the non-reactive
    implementation. There is a **DSL** (**Domain-Specific Language**) to create domain-specific
    query methods.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: Spring反应式仓库支持Cassandra、MongoDB和Redis作为数据库存储。仓库实现提供了与非反应式实现相同的行为。有一个**DSL（领域特定语言**）用于创建特定领域的查询方法。
- en: The module uses the Project Reactor as a reactive foundation implementation,
    but is possible to change the implementation to RxJava as well. Both libraries
    are production-ready and are adopted by the community. One point to be aware of
    is that if we change to RxJava, we need to ensure our method returns to `Observable`
    and `Single`.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块使用Project Reactor作为反应式基础实现，但也可能将其实现更改为RxJava。这两个库都是生产就绪的，并且被社区采用。需要注意的一点是，如果我们更改为RxJava，我们需要确保我们的方法返回`Observable`和`Single`。
- en: Spring Data Reactive
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Data 反应式
- en: The Spring Data Project has support for the reactive data access. Until now,
    Spring has support for MongoDB, Apache Cassandra, and Redis, all of which have
    reactive drivers.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data 项目支持反应式数据访问。到目前为止，Spring 支持MongoDB、Apache Cassandra 和 Redis，它们都提供了反应式驱动程序。
- en: In our CMS application, we will use the MongoDB reactive drivers to give the
    reactive characteristics for our repositories. We will use the new reactive interface
    provided by the Spring Data reactive. Also, we need to change the code a little
    bit. In this chapter, we will do that step by step. Let's start.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的CMS应用程序中，我们将使用MongoDB反应式驱动程序来为我们的存储库提供反应式特性。我们将使用Spring Data反应式提供的新反应式接口。此外，我们还需要稍微修改一下代码。在本章中，我们将一步步进行。让我们开始吧。
- en: Reactive repositories in practice
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践中的反应式存储库
- en: Before we start, we can check out the full source code at GitHub, or we can
    perform the following steps.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们可以在GitHub上查看完整的源代码，或者我们可以执行以下步骤。
- en: Now, we are ready to build our new reactive repositories. The first thing that
    we need to do is add the Maven dependencies to our project. This can be done using
    `pom.xml`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好构建我们的新反应式存储库。我们需要做的第一件事是将Maven依赖项添加到我们的项目中。这可以通过`pom.xml`来完成。
- en: 'Let''s configure our new dependency:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们配置我们的新依赖项：
- en: '[PRE30]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Our project is ready to use reactive MongoDB repositories.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目现在可以使用反应式MongoDB存储库了。
- en: Creating the first Reactive repository
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建第一个反应式存储库
- en: We have a couple of repositories in our CMS project. Now, we need to convert
    these repositories to reactive ones. The first thing we will do is remove the
    extension from `CrudRepository`, which is not necessary anymore. Now, we want
    the reactive version of that.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的CMS项目中，我们有一些存储库。现在，我们需要将这些存储库转换为反应式存储库。我们将要做的第一件事是从`CrudRepository`中移除扩展，因为现在不再需要它了。现在，我们想要那个反应式的版本。
- en: 'We will update the `ReactiveMongoRepository` interface. The parameters of the
    interface are the same as the ones we inserted before. The interface should be
    like this:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新`ReactiveMongoRepository`接口。接口的参数与之前插入的相同。接口应该是这样的：
- en: '[PRE31]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is quite similar to the one we created before. We need to extend the new
    `ReactiveMongoRepository` interface, which contains methods for the CRUD operations
    and much more. The interface returns `Mono<Category>` or `Flux<Category>`.  The
    methods do not return the entities anymore. It is a common way of programming
    when the Reactive Stream is adopted.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前创建的相当相似。我们需要扩展新的`ReactiveMongoRepository`接口，该接口包含CRUD操作和其他许多方法。该接口返回`Mono<Category>`或`Flux<Category>`。方法不再返回实体。当采用反应式流时，这是一种常见的编程方式。
- en: We need to change the other repositories as well. You can find the full source
    code on GitHub at: [https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter03/cms-mongodb/src/main/java/springfive/cms/domain/repository](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter03/cms-mongodb/src/main/java/springfive/cms/domain/repository).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改其他存储库。您可以在GitHub上找到完整的源代码：[https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter03/cms-mongodb/src/main/java/springfive/cms/domain/repository](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter03/cms-mongodb/src/main/java/springfive/cms/domain/repository)。
- en: Now, we need to change the service layer. Let's do that.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要修改服务层。让我们来做这件事。
- en: Fixing the service layer
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复服务层
- en: We need to change the service layer to adopt the new reactive programming style.
    We changed the repository layer, so now we need to fix the compilation problem
    result because of this change. The application needs to be reactive. Any point
    of the application can be blocked because we are using the event-loop model. If
    we do not do this, the application will be getting blocked.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将服务层修改为采用新的反应式编程风格。我们已经修改了存储库层，因此现在我们需要修复由于这种更改而产生的编译问题。应用程序需要是反应式的。应用程序的任何一点都可能因为我们在使用事件循环模型而被阻塞。如果我们不这样做，应用程序将会被阻塞。
- en: Changing the CategoryService
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改CategoryService
- en: Now, we will fix the `CategoryService` class. We will change the return type
    of a couple of methods. Before, we could return the model class, but now we need
    to change to return `Mono` or `Flux`, similar to what we did in the repository
    layer.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将修复 `CategoryService` 类。我们将更改几个方法的返回类型。之前，我们可以返回模型类，但现在我们需要改为返回 `Mono`
    或 `Flux`，类似于我们在存储库层所做的那样。
- en: 'The new `CategoryService` should be like the implementation shown in the following
    code snippet:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `CategoryService` 应该像以下代码片段中所示的实现一样：
- en: '[PRE32]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As we can see, the return types changed in the methods.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，方法的返回类型已经更改。
- en: The important thing here is that we need to follow the reactive principles.
    When the method returns only one instance, we need to use `Mono<Category>`. When
    the method returns one or more instances, we should use `Flux<Category>`. This
    is essential to follow because developers and Spring containers can then interpret
    the code correctly.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的是我们需要遵循反应式原则。当方法只返回一个实例时，我们需要使用 `Mono<Category>`。当方法返回一个或多个实例时，我们应该使用 `Flux<Category>`。这是非常重要的，因为这样开发者以及
    Spring 容器才能正确地解释代码。
- en: The `update()` method has an interesting call: `flatMap()`. The project reactor
    allows us to use a kind of DSL to compose calls. It is very interesting and very
    useful as well. It helps developers to create code that is easier to understand
    than before. The `flatMap()` method is usually used to convert the data emitted
    by `Mono` or `Flux`. In this context, we need to set the new name of the category
    on the category retrieved from the database.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`update()` 方法有一个有趣的调用：`flatMap()`。项目 Reactor 允许我们使用一种 DSL 来组合调用。这非常有趣，也非常有用。它帮助开发者创建比以前更容易理解的代码。`flatMap()`
    方法通常用于转换 `Mono` 或 `Flux` 发出的数据。在这个上下文中，我们需要将数据库检索到的分类的新名称设置为分类的新名称。'
- en: Changing the REST layer
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改 REST 层
- en: We will make some fixes on the REST layer as well. We changed the service layer,
    and it caused some compilation problems in our resources classes.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将对 REST 层进行一些修复。我们更改了服务层，这导致我们的资源类中出现了一些编译问题。
- en: We need to add the new dependency, `spring-web-reactive`. This supports the
    `@Controller` or `@RestController` annotations for the reactive non-blocking engine.
    The Spring MVC does not support the reactive extensions, and this module enables
    developers to use reactive paradigms, as they did before.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加新的依赖项 `spring-web-reactive`。这个依赖支持 `@Controller` 或 `@RestController` 注解用于反应式非阻塞引擎。Spring
    MVC 不支持反应式扩展，这个模块使得开发者能够使用与之前相同的反应式范式。
- en: '`spring-web-reactive` will change many contracts on the Spring MVC foundations,
    such as `HandlerMapping`, and `HandlerAdapter`, to enable reactive foundations
    on these components.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`spring-web-reactive` 将更改 Spring MVC 基础设施上的许多合约，例如 `HandlerMapping` 和 `HandlerAdapter`，以在这些组件上启用反应式基础。'
- en: 'The following image can help us to better understand the Spring HTTP layers:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像可以帮助我们更好地理解 Spring HTTP 层：
- en: '![](img/1890e6e7-c0ca-4eb5-a423-dec9beea51ed.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1890e6e7-c0ca-4eb5-a423-dec9beea51ed.png)'
- en: As we can see, `@Controller` and `@RequestMapping` can be used for different
    approaches in the Spring MVC traditional applications, or by using the Spring
    web reactive module.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`@Controller` 和 `@RequestMapping` 可以在 Spring MVC 传统应用程序中使用不同的方法，或者通过使用
    Spring WebReactive 模块。
- en: Before we start to change our REST layer, we need to remove the Spring Fox dependencies
    and annotations in our project. At present, the Spring Fox has no support for
    reactive applications yet.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始更改我们的 REST 层之前，我们需要从我们的项目中移除 Spring Fox 依赖项和注解。目前，Spring Fox 还不支持反应式应用程序。
- en: 'The dependencies to remove are:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 需要移除的依赖项包括：
- en: '[PRE33]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: After that, we need to remove the annotations from the Swagger packages, such
    as `@Api` and `@ApiOperation`.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要从 Swagger 包中移除注释，例如 `@Api` 和 `@ApiOperation`。
- en: Now, let's adjust our REST layer.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们调整我们的 REST 层。
- en: Adding the Spring WebFlux dependency
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 Spring WebFlux 依赖项
- en: Before we start to change our REST layer, we need to add the new dependency
    to our `pom.xml`.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始更改我们的 REST 层之前，我们需要将新的依赖项添加到我们的 `pom.xml` 文件中。
- en: 'First, we will remove the Spring MVC traditional dependencies. To do this,
    we need to remove the following dependency:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将移除 Spring MVC 传统依赖项。为此，我们需要移除以下依赖项：
- en: '[PRE34]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We do not need this dependency anymore. Our application will be reactive now.
    Then, we need to add the new dependencies described in the following code snippet:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要这个依赖项了。我们的应用程序现在将是反应式的。然后，我们需要添加以下代码片段中描述的新依赖项：
- en: '[PRE35]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`spring-boot-starter-webflux`is a kind of syntax sugar for dependencies. It
    has the `spring-boot-starter-reactor-netty` dependency, which is the Reactor Netty,
    as embedded in the reactive HTTP server.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`spring-boot-starter-webflux` 是一种依赖项的语法糖。它包含了 `spring-boot-starter-reactor-netty`
    依赖项，即 Reactor Netty，它是内嵌在响应式 HTTP 服务器中的。'
- en: Awesome, our project is ready to convert the REST layer. Let's transform our
    application into a fully reactive application.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，我们的项目已经准备好将 REST 层转换为响应式应用。让我们将我们的应用程序转换为一个完全响应式的应用程序。
- en: Changing the CategoryResource
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改分类资源
- en: We will change the `CategoryResource` class. The idea is pretty simple. We will
    convert our `ResponseEntity`, which is parametrized with the models class to `ResponseEntity`
    using `Mono` or `Flux`.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改 `CategoryResource` 类。这个想法很简单。我们将使用 `Mono` 或 `Flux` 将我们的 `ResponseEntity`（使用模型类参数化）转换为
    `ResponseEntity`。
- en: 'The new version of the `CategoryResource` should be like this:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本的 `CategoryResource` 应该是这样的：
- en: '[PRE36]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The code is quite similar to what we did before. We have used the  `@RequestBody`
    annotation in the method argument; otherwise, the JSON converter will not work.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与我们之前所做的是相当相似的。我们在方法参数中使用了 `@RequestBody` 注解；否则，JSON 转换器将无法工作。
- en: The other important characteristic here is the `return` method. It returns `Mono`
    or `Flux`, which are parameterized types for `ResponseEntity`.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这里另一个重要的特性是 `return` 方法。它返回 `Mono` 或 `Flux`，这是 `ResponseEntity` 的参数化类型。
- en: 'We can test the reactive implementation by using the command line. It will
    persist the `Category` object on MongoDB. Type the following command on the Terminal:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用命令行来测试响应式实现。它将在 MongoDB 上持久化 `Category` 对象。在终端中输入以下命令：
- en: '[PRE37]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And then, we can use the following command to check the database. Using the
    browser, go to `http://localhost:8080/api/category`. The following result should
    be presented:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下命令来检查数据库。使用浏览器，访问 `http://localhost:8080/api/category`。以下结果应该会显示：
- en: '![](img/6236f06f-38ed-46f9-9b97-68d12de94b78.png)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6236f06f-38ed-46f9-9b97-68d12de94b78.png)'
- en: Awesome, our reactive implementation is working as expected. Well done!!!
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，我们的响应式实现按预期工作。做得好！！！
- en: Summary
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned a lot of Spring concepts. We have introduced
    you to Spring Data projects, which help developers to create data access layers
    as we have never seen before. We saw how easy it is to create repositories with
    this project.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了大量的 Spring 概念。我们向您介绍了 Spring Data 项目，这些项目帮助开发者创建我们以前从未见过的数据访问层。我们看到了使用这个项目创建仓库是多么容易。
- en: Also, we presented some relatively new projects, such as Spring WebFlux, which
    permits developers to create modern web applications, applying the Reactive Streams
    foundations and reactive programming style in projects.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还介绍了一些相对较新的项目，例如 Spring WebFlux，它允许开发者创建现代网络应用程序，在项目中应用响应式流和响应式编程风格。
- en: We have finished our CMS application. The application has the characteristics
    of a production-ready application, such as database connections, and services
    which have been well-designed with single responsibilities. Also, we introduced
    the `docker-maven-plugin`, which provides a reasonable way to create images using
    the `pom.xml` configurations.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了我们的 CMS 应用程序。该应用程序具有生产就绪应用程序的特征，如数据库连接，以及具有单一职责的良好设计的服务。我们还引入了 `docker-maven-plugin`，它提供了一个使用
    `pom.xml` 配置创建镜像的合理方式。
- en: In the next chapter, we will create a new application using the *Reactive Manifesto*
    based on message-driven applications. See you there.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将创建一个新的应用程序，基于基于消息驱动的应用程序的 *Reactive Manifesto*。在那里见。
