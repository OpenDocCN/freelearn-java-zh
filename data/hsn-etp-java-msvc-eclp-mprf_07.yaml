- en: MicroProfile Metrics and OpenTracing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile Metrics和OpenTracing
- en: 'Once developers have written code and it is put into production, there is a
    need to observe what the code is doing, how well it is performing, and what resources
    it is using. MicroProfile has created two specifications to deal with these concerns:
    Metrics and (integration with) OpenTracing.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开发人员编写了代码并将其投入生产，就需要观察代码在做什么，表现如何，以及使用了哪些资源。MicroProfile为解决这些问题创建了两个规范：Metrics和（与）OpenTracing的集成。
- en: 'Starting off with the Metrics section, we will discuss the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从Metrics部分开始，我们将讨论以下主题：
- en: The rationale behind specifications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制定规范的依据
- en: Exposition formats of metrics on an enabled server
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用服务器上指标的暴露格式
- en: Providing metrics from within your application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从您的应用程序内部提供指标
- en: Using Prometheus, a cloud-native time series database, to retrieve and analyze
    metric data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Prometheus，一个云原生的时间序列数据库，来检索和分析指标数据
- en: 'In the OpenTracing section, we will discuss the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenTracing部分，我们将讨论以下内容：
- en: An introduction to the tracing domain
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪领域简介
- en: Configuration properties ...
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置属性...
- en: MicroProfile Metrics
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile Metrics
- en: MicroProfile Metrics exposes the metric data (often called **telemetry**) of
    the running server, for example, CPU and memory usage, and the thread count. This
    data is then often fed into charting systems to visualize metrics over time or
    to serve capacity-planning purposes; of course, they also serve to notify DevOps
    people when the values go outside a predefined threshold range.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile Metrics暴露运行服务器的指标数据（通常称为**遥测**），例如CPU和内存使用情况，以及线程计数。然后，这些数据通常被输入到图表系统中，以随时间可视化指标或为容量规划目的服务；当然，当值超出预定义的阈值范围时，它们也用于通知DevOps人员在阈值范围内。
- en: The Java Virtual Machine had a way to expose data for a long time via MBeans
    and the MBeanServer. Java SE 6 saw the introduction of an (RMI-based) remote protocol
    for all VMs defining how to access the MBean Server from remote processes. Dealing
    with this protocol is difficult and does not fit in with today's HTTP-based interactions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Java虚拟机长期以来一直通过MBeans和MBeanServer暴露数据。Java SE 6见证了所有虚拟机定义如何从远程进程访问MBean服务器的（基于RMI）远程协议的引入。处理此协议是困难的，并且与今天的基于HTTP的交互不符。
- en: The other pain point is that many globally existing servers have different properties
    exposed under different names. It is thus not easy to set up monitoring of different
    kinds of server.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个痛点是许多全球存在的服务器在不同的名称下暴露不同的属性。因此，设置不同类型服务器的监控并不容易。
- en: MicroProfile has created a monitoring specification that addresses these two
    points via an HTTP-based API permitting access by monitoring agents and a Java
    API that allows application-specific metrics to be exported on top of a set of
    servers and JVM metrics.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile通过一个基于HTTP的API，允许监控代理访问，以及一个Java API，允许在服务器和JVM指标之上导出应用程序特定指标，创建了一个监控规范，解决了这两个问题。
- en: MicroProfile Metrics is developing the 2.x version of the specification that
    has some breaking changes to 1.x. The following sections talk about 1.x – the
    changes in 2.0 are discussed in the *New in MP-Metrics 2.0* section.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile Metrics正在开发2.x版本的规范，其中有一些对1.x的破坏性变化。以下部分讨论1.x - 2.0中的变化在*MP-Metrics
    2.0中的新特性*部分讨论。
- en: 'The specification defines three scopes for metrics:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 规范定义了指标的三种作用域：
- en: 'Base: These are metrics, mostly JVM statistics, that every compliant vendor
    has to support.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础：这些指标主要是JVM统计数据，每个合规的供应商都必须支持。
- en: 'Vendor: Optional vendor-specific metrics that are not portable.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 供应商：可选的供应商特定指标，这些指标是不可移植的。
- en: 'Application: Optional metrics from deployed applications. The Java API will
    be shown in the *Supplying application-specific metrics* section.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用：来自已部署应用程序的可选指标。Java API将在*提供应用程序特定指标*部分中展示。
- en: Another issue with the classic JMX approach, which MicroProfile Metrics addresses,
    is the lack of metadata information about the semantics of a metric.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 经典JMX方法的另一个问题，MicroProfile Metrics解决了，就是关于指标语义的元数据信息不足。
- en: Metadata
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元数据
- en: Metadata is a very important part of MicroProfile Metrics. While it is possible
    to expose a metric `foo` with a value of `142`, it is not self-describing. An
    operator seeing that metric can't tell what this is about, what the unit is, and
    whether `142` is a good value or not.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据是MicroProfile Metrics中的一个非常重要的部分。虽然暴露一个名为`foo`的指标，其值为`142`是可能的，但这个指标并不具有自描述性。看到这个指标的运营商无法判断这是关于什么的，单位是什么，以及`142`是否是一个好值。
- en: 'Metadata is used to provide units and also a description of the metric so that
    the preceding could now be `foo: runtime; 142` seconds. This now allows for correct
    scaling on the display to *two minutes and 22 seconds*. And the user receiving
    an alert relating to this metric can understand that it refers to some runtime
    timing.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '元数据用于提供单位和度量的描述，这样前述的现在可以是`foo: runtime; 142`秒。这现在允许在显示上正确缩放至*两分钟和22秒*。而收到与这个度量相关的警报的用户可以理解它指的是某些运行时计时。'
- en: Retrieving metrics from the server
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从服务器检索度量
- en: MicroProfile Metrics exposes metrics via a REST interface, by default, under
    the `/metrics` context root. You can find the code at [https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter05-metrics](https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter05-metrics).
    Follow the `README.md` file to build the code, run it, and hit the [http://localhost:8080/book-metrics/hello](http://localhost:8080/book-metrics/hello)
    and [http://localhost:8080/book-metrics](http://localhost:8080/book-metrics) endpoints
    a few times with your browser to generate some data.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 微Profile度量通过一个REST接口暴露度量指标，默认情况下，在`/metrics`上下文根下。你可以找到代码在[https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter05-metrics](https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter05-metrics)。按照`README.md`文件来构建代码，运行它，并用浏览器访问几遍`[http://localhost:8080/book-metrics/hello](http://localhost:8080/book-metrics/hello)`和`[http://localhost:8080/book-metrics](http://localhost:8080/book-metrics)`端点来生成一些数据。
- en: As of MicroProfile 1.3/2.0, there is nothing in the specifications about securing
    that endpoint. This is thus left to the individual implementation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 截至MicroProfile 1.3/2.0，规范中没有关于保护该端点的任何内容。因此留给个别实现自行处理。
- en: 'Using this REST interface, it is easy to retrieve the data, for example, via
    the following `curl` command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个REST接口，很容易检索数据，例如，通过以下`curl`命令：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This command shows the Metrics 1.x output in Prometheus text format (abbreviated):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令显示了Prometheus文本格式（缩写）中的Metrics 1.x输出：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you do not provide a media type, the default output format is the Prometheus
    text format (which can also be rendered nicely in the browser). The Prometheus
    format exposes additional metadata to the values in the `# TYPE` and `# HELP`
    lines. You can also see in the previous example how the scopes (base, vendor,
    and application) are prepended to the actual metrics name.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有提供媒体类型，默认输出格式是Prometheus文本格式（也可以在浏览器中很好地渲染）。Prometheus格式向值中的`# TYPE`和`#
    HELP`行暴露附加元数据。你也可以在前一个示例中看到作用域（基本、供应商和应用程序）是如何被添加到实际度量名称之前的。
- en: 'Alternatively, it is possible to retrieve data in the JSON format by providing
    an `HAccept` header (again abbreviated):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，通过提供一个`HAccept`头（再次缩写）来检索JSON格式的数据是可能的：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This command results in the following output:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令导致以下输出：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this case, the pure data is exposed; the scopes form a top level, and respective
    metrics are nested inside. Matching metadata can be retrieved via an HTTP `XOPTIONS`
    call:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，纯净数据被暴露出来；作用域构成了一个顶级层次，相应的度量指标被嵌套在其中。可以通过一个HTTP `XOPTIONS`调用检索匹配的元数据：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output now contains the metadata as a map:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 输出现在包含元数据作为一个映射：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we have seen how we can retrieve different types of data and metadata,
    we will have a quick look at how we can limit retrieval to specific scopes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了如何检索不同类型的数据和元数据，我们将快速查看如何限制检索到特定的作用域。
- en: Accessing specific scopes
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问特定作用域
- en: 'It is also possible to retrieve data for only a single scope by appending the
    scope name to the path. In the following example, we only retrieve metrics for
    the base scope:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在路径后附加作用域名称，也可以只检索单个作用域的数据。在以下示例中，我们只检索基本作用域的度量指标：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This now only shows metrics for the base scope:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只显示基本作用域的度量指标：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this section, we have seen how to retrieve metrics from a MicroProfile Metrics-enabled
    server. Metrics in base and vendor scopes are predefined by the server. Metrics
    in the application scope can be defined by the user, which we are going to explore
    in the next section. ...
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何从启用了MicroProfile Metrics的服务器检索度量。基本和供应商作用域中的度量由服务器预定义。应用程序作用域中的度量可以由用户定义，这是我们将在下一节中探索的内容...
- en: Supplying application-specific metrics
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供应用程序特定的度量
- en: Applications can choose to expose metric data via a CDI programming model. This
    model was inspired by DropWizard Metrics, so that it is easier to transition applications
    to MP-Metrics. It also uses the annotations from DropWizard Metrics, which have
    been augmented to support metadata.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以选择通过CDI编程模型暴露度量数据。这个模型受到了DropWizard Metrics的启发，以便更容易将应用程序过渡到MP-Metrics。它还使用了来自DropWizard
    Metrics的注解，这些注解已经被增强以支持元数据。
- en: 'Let’s start with an example by defining a counter that is then incremented
    in code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个例子开始，定义一个计数器然后在代码中递增：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this example, we are registering a counter by getting it injected into the
    `hCount` variable:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过将计数器注入到`hCount`变量中来注册计数器：
- en: The `@Metric` annotation provides additional information, such as the description,
    and also indicates that the name is the variable name without an additional package
    (`absolute=true`).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Metric`注解提供了额外信息，例如描述，同时也指出名称是变量名而不是额外的包名（`absolute=true`）。'
- en: 'In the following example, we let the implementation do the counting for us.
    This implements the common use case of counting the number of invocations of a
    method or REST endpoint:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们让实现来自动计数。这个实现代表了计数一个方法或REST端点的常见用例：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `monotonic` attribute of `@Counted` says to keep increasing the counter,
    otherwise it will be decreased when leaving the method.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Counted`的`monotonic`属性表示要不断增加计数器，否则当离开方法时它会减少。'
- en: More types of metric
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多类型的度量
- en: Counters are only one type of metric that can be exposed and, very often, more
    complex types are needed, for example, to record the distribution of the duration
    of method calls.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 计数器是唯一可以暴露的度量类型，并且经常需要更复杂的类型，例如，记录方法调用持续时间的分布。
- en: Let's have a quick look at these. Most follow the pattern of `@Counted`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快速看一下这些。大多数遵循`@Counted`的模式。
- en: Gauges
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仪表器
- en: 'A gauge is a metric whose value arbitrarily goes up and down. Gauges are always
    backed by a method that supplies the value of the gauge:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表器是一个值任意上升和下降的度量。仪表器总是由一个提供仪表器值的方法支持：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The gauge's value is computed, like all other values, when a client requests
    the values. This requires the implementation of the gauge method to be very quick,
    so that a caller is not blocked.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表器的值在客户端请求值时计算，就像所有其他值一样。这要求实现仪表器方法非常快，以便调用者不会被阻塞。
- en: Meter
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仪表器
- en: 'A meter measures the rate at which the decorated method is called over time.
    For a JAX-RS endpoint, this would be the number of requests per second. Meters
    can be declared via an annotation:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表器测量随着时间的推移被装饰方法调用的速率。对于JAX-RS端点，这就是每秒的请求数。可以通过注解声明仪表器：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When a client requests the data from the meter, the server supplies the mean
    rate, as well as one-, five-, and fifteen-minute moving averages. The latter may
    be familiar to some readers from the Unix/Linux `uptime` command.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端请求从仪表器中数据时，服务器提供平均速率，以及一、五、十五分钟的移动平均值。后者对一些读者来说可能熟悉，来自Unix/Linux的`uptime`命令。
- en: Histograms
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直方图
- en: 'A histogram is a type of metric that samples the distribution of data. It is
    mostly used to record the distribution of the time it takes to execute the decorated
    method. Histograms cannot be declared via dedicated annotation, unlike other types,
    but a timer, for example, includes histogram data. To use a histogram on its own,
    you need to register and update it in code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图是一种度量类型，它样本数据的分布。它主要用于记录被装饰方法执行所需时间的分布。直方图不能像其他类型那样通过专用注解声明，但例如，计时器包含直方图数据。要单独使用直方图，您需要在代码中注册并更新它：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This way of using metrics in code is feasible for the other types as well.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在代码中使用度量的方式对其他类型也是可行的。
- en: Timers
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计时器
- en: 'A timer basically is a combination of a histogram and a meter and can again
    be declared via an annotation:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器基本上是直方图和仪表器的组合，也可以通过注解声明：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The code in this example waits for a small random amount of time to make the
    output a bit more interesting.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中的代码等待一小段时间的随机量，使输出更有趣。
- en: Tagging
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标记
- en: Tags or labels are a way to additionally organize information. These became
    popular with Docker and Kubernetes. Within MicroProfile Metrics 1.x, they are
    directly forwarded to the output without further ado and do not serve to distinguish
    metrics. MicroProfile Metrics supports server-wide and per-metrics tags, which
    are then merged together in the output.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 标签或标签是组织信息的一种方式。这些在Docker和Kubernetes中变得流行。在MicroProfile Metrics 1.x中，它们会被直接传递到输出中，而不会进一步处理，并不能用来区分指标。MicroProfile
    Metrics支持服务器级和每个指标的标签，然后会在输出中合并在一起。
- en: Server-wide tags
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器级标签
- en: 'Server-wide tags are set via the environment variable, `MP_METRICS_TAGS`, as
    shown:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器级标签是通过环境变量`MP_METRICS_TAGS`设置的，如下所示：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: These tags will be added to all metrics defined in the server and also added
    to the respective output format.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标签将被添加到服务器中定义的所有指标中，并添加到相应的输出格式中。
- en: 'So, given the preceding command, a counter, `@Counted(absolute=true) int myCount;`,
    would end up in Prometheus as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在之前的命令下，一个名为`@Counted(absolute=true) int myCount;`的计数器，最终会在Prometheus中显示如下：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Per-metrics tags
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个指标的标签
- en: 'Tags can also be supplied on a per-metric basis:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 标签也可以基于每个指标提供：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This example defines two labels, `version=v1` and `commit=abcde`, on the metric
    with the name `doSomething`. Those will be merged with the global tags for the
    output. With the preceding global tag, there would thus be three tags in the output.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例在名为`doSomething`的指标上定义了两个标签，`version=v1`和`commit=abcde`。这些将与全局标签合并用于输出。有了之前的全局标签，输出中就会有三个标签。
- en: In this section, we have seen how to add labels to metrics to provide additional
    metadata. These can be global, for all metrics exposed from a server, or application-specific,
    for one single metric.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了如何向指标添加标签以提供附加元数据。这些可以是全局的，适用于服务器暴露的所有指标，也可以是特定于应用程序的，适用于单个指标。
- en: Using Prometheus to retrieve metrics
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Prometheus检索指标
- en: Now that we have seen what metrics are exposed and how we can define our own,
    let's have a look at how we can collect them in a **time series database** (**TSDB**).
    For this purpose, we use Prometheus, a CNCF ([https://www.cncf.io/](https://www.cncf.io/))
    project that has gained widespread adoption in the cloud-native world.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了暴露的指标以及如何定义我们自己的指标，现在让我们来看看我们如何可以在一个**时间序列数据库**（**TSDB**）中收集它们。为此，我们使用Prometheus，一个CNCF（[https://www.cncf.io/](https://www.cncf.io/)）项目，在云原生世界中得到了广泛采用。
- en: You can download Prometheus from [https://prometheus.io](https://prometheus.io/)
    or on macOS via `brew install prometheus`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://prometheus.io](https://prometheus.io/)下载Prometheus，或者在macOS上通过`brew
    install prometheus`安装。
- en: 'Once Prometheus is downloaded, we need a configuration file that defines which
    targets to scrape and can then start the server. For our purposes, we will use
    the following simple file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦下载了Prometheus，我们需要一个配置文件来定义要抓取的目标，然后可以启动服务器。对于我们来说，我们将使用以下简单的文件：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: New in MP-Metrics 2.0
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新增于MP-Metrics 2.0
- en: 'NOTE: MicroProfile Metrics 2.0 may not be released when you read this, and
    the content may have changed slightly depending on feedback from early users/implementors.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您在读到这些内容时，MicroProfile Metrics 2.0可能还没有发布，而且内容可能会根据早期用户/实施者的反馈略有变化。
- en: Change for counters – introducing ConcurrentGauge
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对计数器的更改——引入ConcurrentGauge
- en: 'Counters in Metrics 1.x had two functions:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Metrics 1.x中，计数器有两个功能：
- en: To provide a measure for the number of concurrent invocations
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了提供一个并发调用次数的测量指标
- en: As a metric that can count up to the number of transactions committed, for example
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一个可以计数提交事务数量的指标，例如
- en: Unfortunately, the first way was the default when using the annotation without
    specifying the `monotonic` keyword, which is unexpected and was confusing a lot
    of users. The second version of this also had its issues, as a counter value could
    also decrease at will, which violates the understanding that a counter is a monotonically
    increasing metric.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，当使用没有指定`monotonic`关键词的注解时，第一种方法是默认的，这是出乎意料的，也让很多用户感到困惑。这种方法的第二个版本也有其问题，因为计数器的值也可以随意减少，这违反了计数器是一个单调递增指标的理解。
- en: For this reason, the Metrics working group has decided to change the behavior
    of counters so they only work as monotonically increasing metrics and to defer
    the ...
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，度量工作组决定更改计数器的行为，使它们只作为单调递增的指标工作，并将推迟...
- en: Tagging
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标记
- en: 'Tags now also serve to distinguish metrics with the same name and type, but
    different tags. They could be used to support many metrics `result_code` on a
    REST endpoint to count the number of (un)successful calls:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 标签现在也用于区分具有相同名称和类型但不同标签的指标。它们可以用来支持许多指标`result_code`在REST端点上，以计算(未)成功的调用次数：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Under the covers, metrics are no longer only keyed by name and type, but also
    by their tags. For this, new `MetricID` has been introduced to host the name and
    the tags.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，指标不再仅按名称和类型进行标识，还按它们的标签进行标识。为此，引入了新的`MetricID`来容纳名称和标签。
- en: Changes in data output format
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据输出格式的变化
- en: The introduction of multi-tag metrics in MicroProfile Metrics 2.0 necessitated
    changes in the format of metric data that is made available to clients.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在MicroProfile Metrics 2.0中引入多标签指标需要对提供给客户端的指标数据格式进行更改。
- en: 'The Prometheus format also had some inconsistencies, so we decided to revamp
    the formats in sometimes incompatible ways:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus格式也存在一些不一致之处，因此我们决定以有时不兼容的方式重新设计这些格式：
- en: The colon (:) as a separator between the scope and metric name has been changed
    to an underscore (_).
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作用域和指标名称之间的冒号(:)分隔符已更改为下划线(_)。
- en: The Prometheus output format no longer requires that camelCase is turned into
    snake_case.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prometheus输出格式不再需要将camelCase转换为snake_case。
- en: The format of the base metrics for garbage collectors has changed and now uses
    tags for the various garbage collectors.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾收集器的基础指标格式已更改，现在使用各种垃圾收集器的标签。
- en: Please consult the release notes in the MicroProfile 2.0 specification at [https://github.com/eclipse/microprofile-metrics/releases/tag/2.0
    ...](https://github.com/eclipse/microprofile-metrics/releases/tag/2.0)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅MicroProfile 2.0规范中的发布说明：[https://github.com/eclipse/microprofile-metrics/releases/tag/2.0
    ...](https://github.com/eclipse/microprofile-metrics/releases/tag/2.0)
- en: MicroProfile OpenTracing
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile OpenTracing
- en: In the modern world of microservices, a single request can traverse multiple
    processes running on different machines, data centers, or even geographical regions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务构成的现代世界中，一个请求可能会穿过在不同机器、数据中心，甚至地理位置上运行的多个进程。
- en: The observability of such systems is a challenging task but, when done right,
    it allows us to *tell the story* about each individual request as opposed to the
    overall state of the system derived from signals such as metrics and logs. In
    this chapter, we will introduce you to distributed tracing and explain OpenTracing
    with its integration in MicroProfile OpenTracing 1.3.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此类系统的可观测性是一项具有挑战性的任务，但当正确实现时，它允许我们*讲述每个单独请求的故事*，而不是从指标和日志等信号派生出的系统的总体状态。在本章中，我们将向您介绍分布式追踪，并解释MicroProfile
    OpenTracing 1.3中的OpenTracing集成。
- en: In the previous section, we learned about metrics and how they observe an application
    or each individual component. This information is no doubt very valuable and provides
    a macro view of the system, but, at the same time, it says very little about each
    individual request that traverses multiple components. Distributed tracing shows
    a micro view of what happened with a request end to end so that we can retrospectively
    understand the behavior of each individual component of the application.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们学习了关于指标以及它们如何观察应用程序或每个单独的组件。这些信息无疑非常有价值，并为系统提供了宏观视图，但同时，它很少提到穿越多个组件的每个单独请求。分布式追踪提供了关于请求端到端发生的微观视图，使我们能够回顾性地理解应用程序的每个单独组件的行为。
- en: 'Distributed tracing is action-based; in other words, it records everything
    related to an action in the system. For example, it captures detailed information
    of a request and all causally related activities. We will not go through the details
    of how this tracing works, but, in a nutshell, we can state the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式追踪是基于动作的；换句话说，它记录了系统中的所有与动作相关的信息。例如，它捕获了请求的详细信息及其所有因果相关活动。我们不会详细介绍这种追踪是如何工作的，但简而言之，我们可以得出以下结论：
- en: The tracing infrastructure attaches contextual metadata to each request, typically,
    a set of unique IDs – `traceId`, `spanId`, and `parentId`.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 追踪基础架构为每个请求附加了上下文元数据，通常是唯一标识符集合——`traceId`、`spanId`和`parentId`。
- en: The instrumentation layer records profiling data and propagates metadata inside
    and between processes.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观测层记录剖析数据并在进程内部及进程之间传播元数据。
- en: The captured profiling data contains metadata and causality references to preceding
    events.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获的剖析数据包含元数据和对先前事件的因果引用。
- en: 'Based on the captured data, distributed tracing systems usually offer the following
    functionality:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 根据捕获的数据，分布式跟踪系统通常提供以下功能：
- en: Root-cause analysis
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根本原因分析
- en: Latency optimization – critical path analysis
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟优化——关键路径分析
- en: Distributed context propagation – baggage
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式上下文传播——行李
- en: Contextualized logging
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文化日志记录
- en: Service dependency analysis
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务依赖分析
- en: Before we delve into MicroProfile OpenTracing, let's briefly look at OpenTracing
    so that we can better understand what the API offers.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨MicroProfile OpenTracing之前，让我们简要地看看OpenTracing，以便我们能更好地理解它提供的API是什么。
- en: OpenTracing project
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenTracing项目
- en: The OpenTracing project ([https://opentracing.io](https://opentracing.io/))
    provides a vendor-neutral specification [(https://github.com/opentracing/specification)](https://github.com/opentracing/specification) and
    polyglot APIs for describing distributed transactions. Vendor neutrality is important
    because code instrumentation is the most time-consuming and challenging task when
    enabling distributed tracing in large organizations. We would like to stress that
    OpenTracing is just an API. A real deployment will require a plugged tracer implementation
    that runs inside the monitored process and sends data to a tracing system.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTracing项目（[https://opentracing.io](https://opentracing.io/)）提供了一个中立的规范[(https://github.com/opentracing/specification)](https://github.com/opentracing/specification)和多语言API，用于描述分布式事务。中立性很重要，因为在大规模组织中启用分布式跟踪时，代码instrumentation是最耗时和最具挑战性的任务。我们想强调的是OpenTracing只是一个API。实际部署将需要一个运行在监控进程内部的plugged跟踪器实现，并将数据发送到跟踪系统。
- en: 'From an API perspective, there are three key concepts: Tracer, Span, and SpanContext.
    Tracer is a singleton object available to the application that can be used to
    model a ...'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 从API角度来看，有三个关键概念：跟踪器、跨度、和跨度上下文。跟踪器是应用程序中可用的单例对象，可以用来建模一个...
- en: Configuration properties
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置属性
- en: OpenTracing is vendor-neutral and can, therefore, work with any vendor's tracing
    implementation that uses this API. Each tracer implementation will be configured
    differently. Therefore, the configuration is outside the scope of the MicroProfile
    OpenTracing specification. However, the specification itself exposes a couple
    of configuration properties to adjust the tracing scope or generated data. The
    configuration leverages the MicroProfile Config specification to provide a consistent
    means for all supported configuration options.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTracing是中立且可以与使用此API的任何供应商的跟踪实现配合使用。每个跟踪器实现将配置不同。因此，配置超出了MicroProfile OpenTracing规范的范围。然而，规范本身暴露了几个配置属性，以调整跟踪范围或生成数据。配置利用了MicroProfile
    Config规范，为所有支持的配置选项提供了一种一致的方法。
- en: 'Currently, the specification exposes the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，规范暴露了以下内容：
- en: '`mp.opentracing.server.skip-pattern`: A skip pattern to avoid the tracing of
    selected REST endpoints.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mp.opentracing.server.skip-pattern`：一个跳过模式，用于避免跟踪选定的REST端点。'
- en: '`mp.opentracing.server.operation-name-provider`: This specifies the operation
    name provider for server spans. Possible values are `http-path` and `class-method`.
    The default value is `class-method`, which fully uses a qualified class name concatenated
    with a method name; for example, `GET:org.eclipse.Service.get`. The `http-path`
    uses a value of `@Path` annotation as an operation name.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mp.opentracing.server.operation-name-provider`：这指定了服务器跨度操作名称提供程序。可能的值有`http-path`和`class-method`。默认值是`class-method`，它完全使用一个限定类名与方法名拼接；例如，`GET:org.eclipse.Service.get`。`http-path`使用`@Path`注解的值作为操作名称。'
- en: Automatic instrumentation
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动 instrumentation
- en: The motivation here is to have tracing automatically capture all crucial performance
    information and also automatically propagate tracing context between runtimes.
    The second part is especially crucial because it ensures that traces are not broken
    and we are able to investigate end-to-end invocation. For successful tracing,
    every communication technology between runtimes has to be instrumented. In the
    case of MicroProfile, it is JAX-RS and MicroProfile Rest Client.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的动机是自动捕获所有关键性能信息，并在运行时之间自动传播跟踪上下文。第二部分尤其重要，因为它确保了跟踪不会中断，我们能够调查端到端的调用。为了成功跟踪，必须在运行时之间的每种通信技术上进行instrumentation。在MicroProfile的情况下，是JAX-RS和MicroProfile
    Rest Client。
- en: JAX-RS
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JAX-RS
- en: MicroProfile OpenTracing automatically traces all inbound JAX-RS endpoints.
    However, the JAX-RS client side is more tricky and requires the registration API, `org.eclipse.microprofile.opentracing.ClientTracingRegistrar.configure(ClientBuilder
    clientBuilder)`, to be called to add tracing capability. MicroProfile implementation
    can enable tracing for all client interfaces globally; however, it is recommended
    to use the registration API for better portability.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 微Profile OpenTracing 自动追踪所有入站的 JAX-RS 端点。然而，JAX-RS 客户端一侧更加复杂，需要调用注册 API，`org.eclipse.microprofile.opentracing.ClientTracingRegistrar.configure(ClientBuilder
    clientBuilder)`，以添加追踪能力。微Profile 实现可以为所有客户端接口全局启用追踪；然而，建议使用注册 API 以获得更好的可移植性。
- en: 'The default tracing behavior can be modified by disabling the tracing of specific
    requests or changing operation names of produced server spans. For more information,
    refer to the *Configuration properties* section later in this chapter. The instrumentation
    layer automatically adds the following request-scoped information to each span:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过禁用特定请求的追踪或更改生成的服务器跨度的操作名称来修改默认的追踪行为。有关更多信息，请在本章后面的*配置属性*部分查阅。instrumentation
    层自动向每个跨度添加以下请求范围的信息：
- en: '`http.method`: The HTTP method of the request.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http.method`：请求的 HTTP 方法。'
- en: '`http.status_code`: The status code of the request.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http.status_code`：请求的状态代码。'
- en: '`http.url`: The URL of the request.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http.url`：请求的 URL。'
- en: '`component`: The name of the instrumented component, `jaxrs`.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`component`：被 instrumented 组件的名称，`jaxrs`。'
- en: '`span.kind`: The client or server.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`span.kind`：客户端或服务器。'
- en: '`error` – `true` or `false`. This is optional and, if present, instrumentation
    also adds an exception as `error.object` to span logs.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error` – `true` 或 `false`。这是可选的，如果存在，instrumentation 还将在跨度日志中添加一个异常作为 `error.object`。'
- en: 'All these tags can be used to query data via the tracing system user interface,
    or they can be used for data analytics jobs that many tracing systems provide.
    Additional metadata can be added to the current active span via an injected tracer
    instance. This can be conducted globally in filters or locally in rest handlers,
    as shown in the following code example, by adding a user agent header to the server
    span (1):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些标签都可以用于通过追踪系统用户界面查询数据，或者它们可以用于许多追踪系统提供数据分析作业。可以通过注入的追踪器实例向当前活动的跨度添加额外元数据。这可以在过滤器中全局执行或在
    rest 处理程序中局部执行，如下面的代码示例所示，通过向服务器跨度添加用户代理头（1）：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: By default, server-side spans have the operation name `http_method:package.className.method`.
    However, this can be changed locally by using the `@Traced` annotation (2), or
    globally via the configuration property (refer to the configuration section).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，服务器端跨度操作名称为 `http_method:package.className.method`。然而，这可以通过使用 `@Traced`
    注解（2）或通过配置属性（参考配置部分）在本地或全局更改。
- en: MicroProfile Rest Client
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微Profile Rest Client
- en: As was mentioned in the previous section, all REST client interfaces are, by
    default, automatically traced with no additional configuration required. This
    behavior can be changed by applying the `@Traced` annotation to the interface
    or method to disable tracing. When applied to the interface, all methods are skipped
    from tracing. Note that the tracing context is not being propagated. Therefore,
    if the request continues to an instrumented runtime, a new trace is started.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一部分所述，所有 REST 客户端接口默认情况下都会自动追踪，无需额外的配置。要更改此行为，请将 `@Traced` 注解应用于接口或方法以禁用追踪。当应用于接口时，所有方法都将从追踪中跳过。请注意，追踪上下文不会被传播。因此，如果请求继续到
    instrumented runtime，将开始新的追踪。
- en: Explicit instrumentation
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显式 instrumentation
- en: Sometimes, the automatic instrumentation does not capture all critical timing
    information and, therefore, additional trace points are needed. For example, we
    would like to trace an invocation of a business layer or initialize third-party
    instrumentation provided by the OpenTracing project ([https://github.com/opentracing-contrib](https://github.com/opentracing-contrib)).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，自动 instrumentation 并没有捕获所有关键的计时信息，因此需要额外的追踪点。例如，我们希望追踪业务层的调用或初始化由 OpenTracing
    项目提供的三方 instrumentation（[https://github.com/opentracing-contrib](https://github.com/opentracing-contrib)）。
- en: 'The explicit instrumentation can be done in three ways:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 显式地 instrumentation 可以通过三种方式进行：
- en: Add the `@Traced` annotation on **Context and Dependency Injection** (**CDI**)
    beans.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**上下文和依赖注入**（**CDI**）bean 上添加 `@Traced` 注解。
- en: Inject the tracer and create spans manually.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入追踪器并手动创建跨度。
- en: Initialize third-party instrumentation. The initialization of external instrumentation
    depends on its own initialization requirements. MicroProfile just has to provide
    a tracer instance, which is covered in the previous bullet point.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化第三方仪器。外部仪器的初始化取决于其自己的初始化要求。MicroProfile只需要提供一个跟踪器实例，这在之前的要点中已经涵盖。
- en: Let's now discuss these in detail.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在详细讨论这些内容。
- en: '@Traced annotation'
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@Traced注解'
- en: MicroProfile OpenTracing defines an `@Traced` annotation that can be used to
    enable tracing on CDI beans or disable tracing on automatically traced interfaces.
    The annotation can also be used to override the operation name on other automatically
    traced components – JAX-RS endpoints.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile OpenTracing定义了一个`@Traced`注解，可以用于启用CDI豆的跟踪，或禁用自动跟踪接口的跟踪。该注解还可以用于重写其他自动跟踪组件的操作名称——JAX-RS端点。
- en: 'The following code example shows how the `@Traced` annotation can be used to
    enable tracing on a CDI bean. `(1)` enables tracing for all methods the bean defines.
    `(2)` overrides the default operation name (`package.className.method`) to `get_all_users`.
    `(3)` disables tracing of the health method:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码示例显示了如何使用`@Traced`注解来启用CDI豆的跟踪。`(1)`为豆定义的所有方法启用跟踪。`(2)`重写了默认操作名称（`package.className.method`）为`get_all_users`。`(3)`禁用了健康方法的跟踪：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Tracer injection
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪器注入
- en: The application can inject an `io.opentracing.Tracer` bean that exposes the
    full OpenTracing API. This allows application developers to leverage more advanced
    use cases, such as adding metadata to the currently active span, manually creating
    spans, using baggage for context propagation, or initializing additional third-party
    instrumentation.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以注入一个`io.opentracing.Tracer`豆，暴露出完整的OpenTracing API。这允许应用程序开发者利用更高级的使用案例，例如向当前活动的跨度添加元数据，手动创建跨度，使用行李进行上下文传播，或初始化额外的第三方仪器。
- en: 'The following code shows how the tracer is used to attach data to the currently
    active span, `(1)`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码显示了如何使用跟踪器将数据附加到当前活动的跨度，`(1)`：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This can be useful for adding business-related data to spans, but also to log
    exceptions or any other profiling information.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用于向跨度添加业务相关数据，但也用于记录异常或其他分析信息。
- en: Tracing with Jaeger
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jaeger进行跟踪
- en: So far, we have only talked about different aspects of the instrumentation.
    However, to run the full tracing infrastructure, we need a tracing backend. In
    this section, we will use Jaeger ([https://www.jaegertracing.io/](https://www.jaegertracing.io/))
    to demonstrate how collected tracing data is presented in a tracing system. We
    have chosen Jaeger because Thorntail provides direct integration with Jaeger.
    Other vendors can provide integrations with other systems, for instance, Zipkin,
    and Instana. Almost every tracing system offers a Gannt chart style view (or timeline)
    of a trace. This view might be overwhelming for tracing novices, but it is a great
    tool to systematically analyze an invocation in a distributed system.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只谈论了仪器仪表的不同方面。然而，要运行完整的跟踪基础设施，我们需要一个跟踪后端。在本节中，我们将使用Jaeger([https://www.jaegertracing.io/](https://www.jaegertracing.io/))来展示收集的跟踪数据如何在跟踪系统中呈现。我们选择Jaeger是因为Thorntail提供了与Jaeger的直接集成。其他供应商可以提供与其他系统的集成，例如Zipkin和Instana。几乎每个跟踪系统都提供了一个类似于甘特图的视图（或时间线）来查看跟踪。这种视图对于跟踪新手来说可能有些令人不知所措，但它是一个分析分布式系统中调用的系统化工具。
- en: The following screenshot shows ...
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕快照显示了...
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about the observability of servers and applications.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了关于服务器和应用程序的可观测性。
- en: Metrics, or telemetry, can help to pinpoint the performance characteristics
    of a server or an application. MicroProfile offers, via the Metrics specification,
    a way to export Metrics in standardized ways. Application writers can use MicroProfile
    Metrics to expose their data to monitoring clients decoratively via annotations
    or via calls to the Metrics API.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 指标，或遥测，可以帮助确定服务器或应用程序的性能特性。MicroProfile通过Metrics规范提供了一种以标准化方式导出指标的方法。应用程序编写者可以使用MicroProfile
    Metrics将他们的数据以注解或通过调用Metrics API的方式装饰性地暴露给监控客户端。
- en: The chapter further explained how OpenTracing integration in MicroProfile provides
    an end-to-end view for each individual transaction going through the system. We
    went through the configuration properties, showcasing tracing for JAX-RS, and
    finally investigating data in the Jaeger system.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 本章进一步解释了MicroProfile中OpenTracing集成如何为通过系统的每个单独事务提供端到端的视图。我们讨论了配置属性，展示了JAX-RS的跟踪，最后调查了Jaeger系统中的数据。
- en: In the next chapter, we will learn how to document (REST) APIs via OpenAPI and
    call those APIs via the type-safe REST client.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习如何通过OpenAPI文档化（REST）API，并通过类型安全的REST客户端调用这些API。
- en: Questions
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between distributed tracing and metrics?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分布式追踪和指标之间的区别是什么？
- en: What functionality do distributed tracing systems usually provide?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分布式追踪系统通常提供哪些功能？
- en: What parts of the system are automatically traced in MicroProfile OpenTracing?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在MicroProfile OpenTracing中，系统哪些部分会自动被追踪？
- en: Which tags are added for every REST request by MicroProfile OpenTracing?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MicroProfile OpenTracing为每个REST请求添加了哪些标签？
- en: How can explicit instrumentation be added to the business code?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在业务代码中添加显式 instrumentation？
- en: What are scopes in Metrics and what is their rationale?
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Metrics中的作用域是什么，它们的理由是什么？
- en: What determines the output format of a REST request to the Metrics API?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么决定了REST请求到Metrics API的输出格式？
- en: What ways are available to export metrics within a user application?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户应用程序中可用的哪些方法可以导出指标？
