- en: Type Classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型类
- en: In this chapter, you will learn about concepts that are built on top of Scala.
    The concepts in this chapter will be abstract, and they will require some concentration
    to understand; do not feel bad if you do not get it right away. Each individual
    part is relatively easy to understand, but when you put them all together, things
    can get complicated.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解建立在Scala之上的概念。本章中的概念将是抽象的，并且理解它们可能需要一些集中注意力；如果你一开始没有完全理解，请不要感到沮丧。每个单独的部分相对容易理解，但当你把它们全部放在一起时，事情可能会变得复杂。
- en: We will be focusing on type classes, with a definition for each one. They will
    be followed by an example illustrating how type classes can be useful in typical
    programs. As these concepts can be difficult, we also suggest some optional exercises
    that can strengthen your understanding. You do not have to do them to be able
    to follow the rest of the chapter. The solutions to the exercises are available
    on GitHub.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于类型类，并为每个类型类提供一个定义。它们将随后通过一个示例来说明类型类如何在典型程序中发挥作用。由于这些概念可能难以理解，我们还建议一些可选练习，这些练习可以加强你的理解。你不必完成它们就能理解本章的其余部分。练习的解决方案可在GitHub上找到。
- en: The majority of type classes presented here come from a library called Cats,
    created by Typelevel.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的大多数类型类都来自一个名为Cats的库，由Typelevel创建。
- en: 'In this chapter, we will cover the following type classes:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下类型类：
- en: scala.math.Ordering
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: scala.math.Ordering
- en: org.scalactic.Equality
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: org.scalactic.Equality
- en: cats.Semigroup
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cats.Semigroup
- en: cats.Monoid
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cats.Monoid
- en: cats.Functor
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cats.Functor
- en: cats.Apply
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cats.Apply
- en: cats.Applicative
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cats.Applicative
- en: cats.Monad
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cats.Monad
- en: Understanding type classes
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解类型类
- en: A **type class** represents a group of types that share a common behavior. A
    type class is to a type what a class is to an object. As with traditional classes,
    a type class can define methods. These methods can be invoked on all types that
    belong to the type class.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型类**代表了一组具有共同行为的类型。类型类对于类型来说，就像类对于对象一样。与传统的类一样，类型类可以定义方法。这些方法可以在属于类型类的所有类型上调用。'
- en: Type classes were introduced in the Haskell programming language. However, thanks
    to the power of implicits, we can also use them in Scala. In Scala, type classes
    are not built-in language constructs (like they are in Haskell) and, as a result,
    we need to write a bit of boilerplate code to define them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 类型类是在Haskell编程语言中引入的。然而，多亏了隐式的力量，我们也可以在Scala中使用它们。在Scala中，类型类不是内置的语言结构（就像在Haskell中那样），因此我们需要编写一些样板代码来定义它们。
- en: 'In Scala, we declare a type class by using `trait`, which accepts a type parameter.
    For instance, let''s define a `Combine` type class that allows for combining two
    objects into one, as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，我们通过使用`trait`来声明类型类，它接受一个类型参数。例如，让我们定义一个允许将两个对象合并为一个的`Combine`类型类，如下所示：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we can define two type class instances for `Combine`, as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以为`Combine`定义两个类型类实例，如下所示：
- en: One for `Int`, which will add the two arguments
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于`Int`，它将两个参数相加
- en: One for `String`, which will concatenate them
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于`String`，它将它们连接起来
- en: 'The code definition is as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 代码定义如下：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: First, we define an `apply` constructor for our type class, which just returns
    the implicit argument. Then, we declare the type class instances by using `implicit
    val`. This way, the compiler will be able to automatically discover them by using
    the implicit resolution rules that we saw in the previous section.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为我们的类型类定义一个`apply`构造函数，它仅返回隐式参数。然后，我们通过使用`implicit val`声明类型类实例。这样，编译器将能够通过使用我们在上一节中看到的隐式解析规则自动发现它们。
- en: 'Now, we can instantiate and use our type class, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实例化和使用我们的类型类，如下所示：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When we call `Combine[Int]`, we actually call `Combine.apply[Int]`. Since our
    `apply` function accepts an implicit parameter of the type `Combine[Int]`, the
    compiler tries to find it. One of the implicit resolution rules is to search in
    the companion object of the argument's type.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`Combine[Int]`时，实际上我们调用的是`Combine.apply[Int]`。由于我们的`apply`函数接受类型为`Combine[Int]`的隐式参数，编译器会尝试找到它。隐式解析规则之一是在参数类型的伴生对象中搜索。
- en: As we declared `combineInt` in the companion object of `Combine`, the compiler
    uses it as the argument for `Combine.apply`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在`Combine`的伴生对象中声明了`combineInt`，编译器将其用作`Combine.apply`的参数。
- en: Once we have obtained an instance of the `Combine` type class, we can invoke
    its method, `combine`. When we call it with two `Int` it will sum them, and when
    we call it with two `String` it will concatenate them.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了`Combine`类型类的实例，我们就可以调用它的方法，`combine`。当我们用两个`Int`调用它时，它会将它们相加，当我们用两个`String`调用它时，它会将它们连接起来。
- en: So far, so good; but, this is a bit cumbersome to use. It would be more practical
    to call `combine` as if it were a method on `Int` or `String`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利；但是，这有点繁琐。如果我们可以像调用`Int`或`String`上的方法一样调用`combine`，那就更实用了。
- en: 'As you saw in the previous section, we can define an implicit class inside
    of the `Combine` object, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前一节中看到的，我们可以在`Combine`对象内部定义一个隐式类，如下所示：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This implicit class allows us to call `combine` on any type `A` that has a
    type class instance `Combine[A]`. Therefore, we can now call `combine` on `Int`
    or `String`, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个隐式类允许我们在任何具有类型类实例`Combine[A]`的类型`A`上调用`combine`。因此，我们现在可以像下面这样调用`combine`：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It might not look impressive; you might say that we merely gave another name
    to the `+` method. The key benefit of using type classes is that we can make the
    `combine` method available for any other type, without having to change it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能看起来并不令人印象深刻；你可能会说我们只是给`+`方法起了另一个名字。使用类型类的关键好处是，我们可以使`combine`方法对任何其他类型都可用，而无需更改它。
- en: In traditional object-oriented programming, you would have to change all classes
    and make them extend a trait, which is not always possible.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的面向对象编程中，你必须更改所有类并使它们扩展一个特质，这并不总是可能的。
- en: Type classes allow us to morph a type into another one on demand (in our example,
    from `Int` to `Combine`). This is what we call **ad hoc polymorphism**.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 类型类允许我们在需要时将一个类型转换为另一个类型（在我们的例子中，从`Int`到`Combine`）。这就是我们所说的**特定多态**。
- en: 'Another key benefit is that by using `implicit def`, we can generate type class
    instances for parameterized types, such as `Option` or `Vector`. All we have to
    do is add them in the `Combine` companion object:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关键好处是，通过使用`implicit def`，我们可以为参数化类型生成类型类实例，例如`Option`或`Vector`。我们只需将它们添加到`Combine`伴生对象中即可：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As long as we have an implicit `Combine[A]` for a type parameter `A`, our function, `combineOption`,
    can generate `Combine[Option[A]]`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们有一个类型参数`A`的隐式`Combine[A]`，我们的函数`combineOption`就可以生成`Combine[Option[A]]`。
- en: This pattern is extremely powerful; it lets us generate type class instances
    by using other type class instances! The compiler will automatically find the
    right generator, based on its return type.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式非常强大；它允许我们通过使用其他类型类实例来生成类型类实例！编译器将根据其返回类型自动找到正确的生成器。
- en: 'This is so common that Scala provides some syntactic sugar to simplify the
    definitions of such functions. We can rewrite `combineOption` as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常常见，以至于Scala提供了一些语法糖来简化此类函数的定义。我们可以将`combineOption`重写如下：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Having a function that has a type parameter declared with `A: MyTypeClass`
    is equivalent to having an implicit parameter of the type `MyTypeClass[A]`.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '具有一个声明了类型参数`A: MyTypeClass`的函数，等同于有一个类型`MyTypeClass[A]`的隐式参数。'
- en: However, when we use this syntax, we do not have a name for that implicit; we
    just have it in the current scope. Having it in scope is sufficient to call any
    other function that accepts an implicit parameter of the type `MyTypeClass[A]`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们使用这种语法时，我们没有为那个隐式指定名称；我们只是在当前作用域中拥有它。拥有它就足够调用任何接受类型`MyTypeClass[A]`的隐式参数的其他函数。
- en: 'That is why we can call `Combine.apply[A]` in the preceding example. With this
    `combineOption` definition, we can now call `combine` on `Option`, too:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为我们可以在前面的例子中调用`Combine.apply[A]`。有了这个`combineOption`定义，我们现在也可以在`Option`上调用`combine`：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Exercise: Define a type class instance for `Combine[Vector[A]]` that concatenates
    two vectors.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：为`Combine[Vector[A]]`定义一个类型类实例，该实例可以连接两个向量。
- en: Exercise: Define a type class instance for `Combine[(A, B)]` that combines the
    first and second elements of two tuples. For instance, `(1, "Hello ") combine
    (2, "World")` should return `(3, "Hello World")`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：为`Combine[(A, B)]`定义一个类型类实例，该实例将两个元组的第一个和第二个元素组合起来。例如，`(1, "Hello ") combine
    (2, "World")`应该返回`(3, "Hello World")`。
- en: Type class recipe
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型类配方
- en: 'To summarize, if we want to create a type class, we have to perform the following
    steps:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，如果我们想创建一个类型类，我们必须执行以下步骤：
- en: Create `trait`, `MyTypeClass[A]`, that accepts a parameterized type `A`. It
    represents the type class interface.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`trait`，`MyTypeClass[A]`，它接受一个参数化类型`A`。它代表类型类接口。
- en: Define an `apply[A]` function in the companion object of `MyTypeClass`, in order
    to facilitate the instantiation of type class instances.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MyTypeClass` 的伴生对象中定义一个 `apply[A]` 函数，以便于类型类实例的实例化。
- en: Provide implicit instances of `trait` for all of the desired types (`Int`, `String`,
    `Option`, and so on).
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为所有期望的类型（`Int`、`String`、`Option` 等）提供 `trait` 的隐式实例。
- en: Define an implicit conversion to an `Ops` class, so that we can call methods
    of the type class as if they were declared in the target type (like you saw previously,
    with `2.combine(3)`).
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个到 `Ops` 类的隐式转换，这样我们就可以像在目标类型中声明一样调用类型类的函数（就像您之前看到的，使用 `2.combine(3)`）。
- en: 'These definitions can be written manually, like in the previous section. Alternatively,
    you can use **simulacrum** to generate some of them for you. This has the double
    benefit of reducing boilerplate code and ensuring some consistency. You can check
    it out here: [https://github.com/mpilquist/simulacrum](https://github.com/mpilquist/simulacrum).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义可以像上一节那样手动编写。或者，您可以使用 **simulacrum** 生成其中的一些。这有两个好处：减少样板代码并确保一致性。您可以在这里查看它：[https://github.com/mpilquist/simulacrum](https://github.com/mpilquist/simulacrum)。
- en: 'Exercise: Use simulacrum to define the `Combine` type class.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：使用 simulacrum 定义 `Combine` 类型类。
- en: Common type classes
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见类型类
- en: In a typical project, you will not create many of your own type classes. Since
    type classes capture behaviors that are common across several types, it is likely
    that someone else has already implemented a type class similar to what you need,
    located in a library. It is usually more productive to reuse type classes defined
    in the SDK (or in third-party libraries) than to try and define your own.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个典型的项目中，您不会创建很多自己的类型类。由于类型类捕获了跨多个类型的常见行为，因此很可能有人已经实现了与您所需类似的一个类型类，位于库中。通常，重用
    SDK（或第三方库）中定义的类型类比尝试定义自己的类型类更有效率。
- en: In general, these libraries define predefined instances of a type class for
    the SDK types (`String`, `Int`, `Option`, and so on). You would typically reuse
    these instances to derive instances for your own types.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这些库为 SDK 类型（`String`、`Int`、`Option` 等）定义了类型类的预定义实例。您通常会重用这些实例来为您自己的类型推导实例。
- en: In this section, we will present the type classes that you are most likely to
    encounter, and how to use them to solve day-to-day programming challenges.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍您最有可能遇到的类型类，以及如何使用它们来解决日常编程挑战。
- en: scala.math.Ordering
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: scala.math.Ordering
- en: '`Ordering` is an SDK type class that represents a strategy to sort the instances
    of a type. The most common use case is to sort the elements of a collection, as
    follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ordering` 是一个 SDK 类型类，它表示对类型实例进行排序的策略。最常见的用例是按如下方式对集合的元素进行排序：'
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you look at the declaration of `sorted`, you will see that it accepts an
    implicit, `Ordering[B]`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看 `sorted` 的声明，您将看到它接受一个隐式参数，即 `Ordering[B]`：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When we called `sorted` on our `Vector[Int]`, the compiler found an implicit
    value of the type `Ordering[Int]` to pass to the function. This implicit was found
    in the companion object of `Ordering`, which also defines instances for `String`,
    `Long`, `Option`, `Tuples`, and so on.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 `Vector[Int]` 上调用 `sorted` 时，编译器找到了一个类型为 `Ordering[Int]` 的隐式值，并将其传递给函数。这个隐式值在
    `Ordering` 的伴生对象中找到，它还定义了 `String`、`Long`、`Option`、`Tuples` 等实例。
- en: 'We can define an instance of the type class for `LocalDate`, so that we can
    compare dates, or sort them more easily:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义 `LocalDate` 类型类的实例，这样我们就可以比较日期，或者更容易地对它们进行排序：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With `Ordering[LocalDate]` and `Ordering.Implicits` in scope, we can use the
    `<` operator to compare dates. `Ordering.Implicits` also defines other useful
    pimped methods, such as `<`, `>`, `<=`, `>=`, `max`, and `min`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在作用域内有 `Ordering[LocalDate]` 和 `Ordering.Implicits`，我们可以使用 `<` 操作符来比较日期。"Ordering.Implicits"
    还定义了其他有用的改进方法，例如 `<`、`>`、`<=`、`>=`、`max` 和 `min`。
- en: We can also easily sort `Vector[LocalDate]` in reverse order by using a reversed
    `Ordering[LocalDate]`. This is more efficient than sorting in ascending order
    and then reversing the vector.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过使用反转的 `Ordering[LocalDate]` 来轻松地对 `Vector[LocalDate]` 进行逆序排序。这比先按升序排序然后反转向量更有效。
- en: 'Exercise: Define an `Ordering[Person]` that can order instances of `case class
    Person(name: String, age: Int)` from the oldest to the youngest. You will need
    to use `Ordering.by`.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '练习：定义一个 `Ordering[Person]`，它可以按从老到小的顺序对 `case class Person(name: String, age:
    Int)` 的实例进行排序。您将需要使用 `Ordering.by`。'
- en: org.scalactic.Equality
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: org.scalactic.Equality
- en: 'The `Equality` type class is used by ScalaTest unit tests whenever you write
    assertions, such as the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`Equality` 类型类被 ScalaTest 单元测试使用，每当你在断言中写入时，例如以下内容：'
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Most of the time, you will not have to worry about it; the default instance
    compares types by using the `equals` method. However, whenever you compare double
    values or classes that contain double attributes, it becomes necessary to provide
    a different `Equality` instance.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，你不必担心它；默认实例通过使用 `equals` 方法比较类型。然而，每当比较双精度值或包含双精度属性的类时，提供不同的 `Equality`
    实例就变得必要了。
- en: 'Consider the following unit test:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下单元测试：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This test should pass, right? Wrong! Try to run it; the assertion fails, as
    follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试应该通过，对吧？错了！尝试运行它；断言失败，如下所示：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is because `Double` is an IEEE754 double-precision floating point number.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `Double` 是一个 IEEE754 双精度浮点数。
- en: 'As such, some decimal numbers cannot be represented exactly with `Double`.
    To make our test pass, we need to provide an `Equality[Double]` instance that
    will return true if the absolute difference between the two numbers is less than
    a certain tolerance:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一些十进制数字无法用 `Double` 准确表示。为了使我们的测试通过，我们需要提供一个 `Equality[Double]` 实例，该实例将在两个数字的绝对差小于某个容差时返回
    true：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Run the test again; it will pass.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试；它将通过。
- en: 'Exercise: Implement a type class derivation, `Equality[Vector[A]]`, so that
    we can compare two `Vector[Double]` instances with a tolerance.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：实现一个类型类推导，`Equality[Vector[A]]`，这样我们就可以使用容差比较两个 `Vector[Double]` 实例。
- en: 'The following is the declaration of the equality instance that you have to
    implement in the exercise:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的声明是你必须在练习中实现的等价实例：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once you have done the exercise, it should make the test pass, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了练习，测试应该会通过，如下所示：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For more information about floating point number encoding, please refer to [https://www.javaworld.com/article/2077257/learn-java/floating-point-arithmetic.html](https://www.javaworld.com/article/2077257/learn-java/floating-point-arithmetic.html).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 关于浮点数编码的更多信息，请参阅 [https://www.javaworld.com/article/2077257/learn-java/floating-point-arithmetic.html](https://www.javaworld.com/article/2077257/learn-java/floating-point-arithmetic.html)。
- en: cats.Semigroup
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cats.Semigroup
- en: In the type class introduction, we defined a `Combine` type class. It turns
    out that this type class is already defined in the Cats library. Its name is `Semigroup`;
    this name comes from the mathematical representation of this algebraic structure.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型类介绍中，我们定义了一个 `Combine` 类型类。结果发现，这个类型类已经在 Cats 库中定义了。它的名字是 `Semigroup`；这个名字来源于这种代数结构的数学表示。
- en: 'Open it in IntelliJ to see how it is defined:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IntelliJ 中打开它，看看它是如何定义的：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `@sp` annotation is an optimization to avoid the boxing/unboxing of primitive
    types. Apart from that, the definition of `Semigroup` is the same as our `Combine`
    type class.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`@sp` 注解是一种优化，用于避免原始类型的装箱/拆箱。除此之外，`Semigroup` 的定义与我们的 `Combine` 类型类相同。'
- en: Laws
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定律
- en: 'The documentation mentions a very important point: the instances of the type
    class must implement an associative combine function.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 文档提到一个非常重要的观点：类型类的实例必须实现一个结合函数的关联性。
- en: 'This means that they must verify the following law:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着它们必须验证以下定律：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Most type classes in Cats have their own specific laws. The library guarantees
    that the type class instances that it defines verify this law. However, if you
    implement your own instance of a type class, it is your responsibility to verify
    that it does not break any law.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Cats 中的大多数类型类都有自己的特定定律。库保证它定义的类型类实例验证这个定律。然而，如果你实现了类型类的自己的实例，那么验证它没有违反任何定律是你的责任。
- en: A user of a type class instance expects that it verifies all of the laws of
    the type class; it is part of the type class’s contract.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 类型类实例的用户期望它验证类型类的所有定律；这是类型类合约的一部分。
- en: A type class contract is the type class trait plus the laws.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 类型类合约是类型类特质加上定律。
- en: When a type class verifies certain laws, you can reason about generic code more
    easily, and you can confidently apply some transformations.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类型类验证了某些定律时，你可以更容易地推理泛型代码，并且可以自信地应用一些变换。
- en: 'For instance, if you know that the associativity law is verified, you can evaluate
    `a combine b combine c combine d` in parallel: one thread can evaluate `(a combine
    b)`, while another one evaluates `(c combine d)`.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你知道结合性定律已经得到验证，你可以并行评估 `a combine b combine c combine d`：一个线程可以评估 `(a combine
    b)`，而另一个线程可以评估 `(c combine d)`。
- en: Cats provide a `laws` module to help check your type class instances. You can
    check that your type class respects the laws by writing unit tests. This will
    not be detailed in this book; if you are interested in more information, you can
    go to [https://typelevel.org/cats/typeclasses/lawtesting.html](https://typelevel.org/cats/typeclasses/lawtesting.html).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Cats提供了一个`laws`模块来帮助检查你的类型类实例。你可以通过编写单元测试来检查你的类型类是否遵守等价律。本书中不会详细介绍这一点；如果你对更多信息感兴趣，可以访问[https://typelevel.org/cats/typeclasses/lawtesting.html](https://typelevel.org/cats/typeclasses/lawtesting.html)。
- en: Usage examples
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用示例
- en: Cats provide several derivations of the `Semigroup` type class. It also declares
    a `|+|` operator in `SemigroupOps`, which is an alias for `combine`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Cats提供了`Semigroup`类型类的几个推导。它还在`SemigroupOps`中声明了一个`|+|`运算符，它是`combine`的别名。
- en: 'Some examples are as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Thanks to the built-in derivations brought up with `import cats.implicits._`,
    we can combine `Int`, `String`, `Tuple2`, and `Tuple3`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了`import cats.implicits._`引入的内置推导，我们可以组合`Int`、`String`、`Tuple2`和`Tuple3`。
- en: 'We can also combine some parameterized types, such as `Option` and `Vector`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以组合一些参数化类型，例如`Option`和`Vector`：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For `Option`, notice that an empty `Option` is ignored whenever we combine it
    with a non-empty `Option`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Option`，请注意，当我们将其与非空`Option`组合时，空`Option`将被忽略。
- en: In [Chapter 3](f7fa24eb-8f31-4201-ba7c-c1e32518df8b.xhtml), *Handling Errors*,
    you saw that `Option` was one way of handling errors, and you learned that whenever
    an error message is needed, you can use `Either` instead of `Option`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](f7fa24eb-8f31-4201-ba7c-c1e32518df8b.xhtml)，“处理错误”中，你看到了`Option`是处理错误的一种方式，并且你了解到每当需要错误消息时，你可以使用`Either`而不是`Option`。
- en: 'What happens, then, if we call `combine` on `Either`? Consider the following
    code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们对`Either`调用`combine`会发生什么？考虑以下代码：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `|+|` (or `combine`) function returns the first argument of type `Left`.
    If all the combined values are of type Right, their values are combined and put
    in `Right`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`|+|`（或`combine`）函数返回类型为`Left`的第一个参数。如果所有组合的值都是类型`Right`，它们的值将组合并放入`Right`中。'
- en: In the first line, all the combined values are of type `Right`, hence the result
    is a `Right(3)`, because `3`  is the result of `combine` applied to `1` and `2`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，所有组合的值都是类型`Right`，因此结果是`Right(3)`，因为`3`是`1`和`2`应用`combine`操作的结果。
- en: In the second line, the first combined value of type `Left` is `Left("error")`,
    hence the result is also `Left("error")`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行，第一个组合值为类型`Left`的`Left("error")`，因此结果也是`Left("error")`。
- en: In the third line, the first combined value of type `Left` is  `Left("error1")`,
    hence the result is `Left("error1")`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三行，第一个组合值为类型`Left`的`Left("error1")`，因此结果是`Left("error1")`。
- en: 'Exercise: Use the `|+|` operator to combine instances of `ValidatedNel[String,
    Int]`.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：使用`|+|`运算符组合`ValidatedNel[String, Int]`的实例。
- en: What happens when you combine several invalid values?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当你组合几个无效值时会发生什么？
- en: cats.Monoid
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cats.Monoid
- en: A `Monoid` is `Semigroup` with an additional `empty` function, also called an
    **identity element**.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`Monoid`是一个带有额外`empty`函数的`Semigroup`，也称为**单位元素**。'
- en: 'The following is an extract of this trait''s definition in Cats:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从Cats中这个特质的定义中提取的内容：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `Monoid` trait extends the `Semigroup` trait. As such, it has all of the
    methods of `Semigroup`, plus this additional `empty` method. We have already seen
    several examples of the `combine` operation of `Semigroup`'s for different types.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Monoid`特质扩展了`Semigroup`特质。因此，它具有`Semigroup`的所有方法，加上这个额外的`empty`方法。我们已经看到了`Semigroup`的`combine`操作在不同类型上的几个示例。'
- en: 'Let’s see what happens when we call `empty` for the same types, as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们对相同类型调用`empty`时会发生什么，如下所示：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For each type, the `empty` element is quite natural: `0` for `Int`, `None`
    for `Option`, and so on.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种类型，`empty`元素相当自然：对于`Int`是`0`，对于`Option`是`None`，等等。
- en: Laws
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等价律
- en: 'We can see why this `empty` function is called the identity element; if you
    combine any object with the identity element, it returns the same object, as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以理解为什么这个`empty`函数被称为单位元素；如果你将任何对象与单位元素组合，它将返回相同的对象，如下所示：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This property is formally defined by the identity laws, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 该属性通过以下等价律正式定义：
- en: 'Left identity: For all `x` of type `A`, `Monoid[A].empty |+| x == x`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左恒等性：对于所有类型为`A`的`x`，`Monoid[A].empty |+| x == x`
- en: 'Right identity: For all `x` of type `A`, `x |+| Monoid[A].empty == x`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右恒等性：对于所有类型为`A`的`x`，`x |+| Monoid[A].empty == x`
- en: Usage examples
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用示例
- en: 'This is interesting—how can we use `Monoid` in our day-to-day programs? The
    most compelling use case is to fold data structures. When you have `Monoid[A]`,
    it is trivial to combine all of the elements of `Vector[A]` to obtain one `A`.
    For instance, we can get the sum of all of the elements of `Vector[Int]`, as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有趣——我们如何在日常程序中使用 `Monoid`？最引人注目的用例是折叠数据结构。当你有 `Monoid[A]` 时，将 `Vector[A]`
    的所有元素组合起来获得一个 `A` 是非常简单的。例如，我们可以得到 `Vector[Int]` 中所有元素的总和，如下所示：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is equivalent to calling `foldLeft` on `Vector`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于在 `Vector` 上调用 `foldLeft`：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Indeed, `foldLeft` accepts two arguments, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`foldLeft` 接受两个参数，如下所示：
- en: A start value, for which we can pass the monoid's empty value
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个起始值，我们可以传递单例的空值
- en: A function, for which we can pass the monoid's `combine` function
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个函数，我们可以传递单例的 `combine` 函数
- en: 'Cats also provide a `foldMap` function, which lets you transform the elements
    of a collection into `Monoid` before folding them:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Cats 还提供了一个 `foldMap` 函数，它允许你在折叠之前将集合的元素转换为 `Monoid`：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Exercise: Implement an instance of `Monoid[Int]` to multiply all of the elements
    of a `Vector[Int]`.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：实现一个 `Monoid[Int]` 的实例，用于乘以 `Vector[Int]` 中所有元素。
- en: 'Exercise: Use `foldMap` to compute the average of `Vector[Double]`.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：使用 `foldMap` 计算平均值的 `Vector[Double]`。
- en: 'Hint: The return type of the call to `foldMap` should be `(Int, Double)`.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：`foldMap` 调用的返回类型应该是 `(Int, Double)`。
- en: Higher-kinded types
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶类型
- en: Before exploring other type classes, it would be useful to be familiar with
    the concept of **higher-kinded** types and **arities**.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索其他类型类之前，熟悉 **高阶类型** 和 **arity** 的概念会有所帮助。
- en: You are already familiar with values and functions. A value is a literal or
    an object, such as `1`, `false`, or `"hello world"`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经熟悉了值和函数。一个值是一个字面量或对象，例如 `1`，`false`，或 `"hello world"`。
- en: Arity
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Arity
- en: A function takes one or many values as parameters and returns another value.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 函数接受一个或多个值作为参数并返回另一个值。
- en: The **arity** of a function is the number of parameters it takes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的 **arity** 是它接受的参数数量。
- en: 'For instance:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: A **nullary** (arity 0) function does not take any parameter
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **一元**（arity 0）函数不接受任何参数
- en: A **unary** (arity 1) function takes only one parameter
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **一元**（arity 1）函数只接受一个参数
- en: A **binary** (arity 2) function takes two parameters
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **二元**（arity 2）函数接受两个参数
- en: A **type constructor** is a type that accepts parameters. It is called type
    constructor, because it constructs a concrete type when we pass a concrete type
    to it. For instance, `Option[A]` is a type constructor. When we pass a concrete
    type `Int` to it, we obtain a concrete type `Option[Int]`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 **类型构造器** 是接受参数的类型。它被称为类型构造器，因为它在我们传递一个具体类型给它时构建一个具体类型。例如，`Option[A]` 是一个类型构造器。当我们传递一个具体类型
    `Int` 给它时，我们获得一个具体类型 `Option[Int]`。
- en: 'As type constructors can accept 0 to n arguments, the concept or arity also
    applies here:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类型构造器可以接受 0 到 n 个参数，arity 的概念也适用于这里：
- en: A nullary type does not take any parameter. It is a concrete type—`Int`, `Boolean`,
    and many more
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **零元**类型不接受任何参数。它是一个具体类型——`Int`，`Boolean` 以及更多
- en: A unary type takes one parameter—`Option[A]`, `Vector[A]`
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一元类型接受一个参数——`Option[A]`，`Vector[A]`
- en: A binary type takes two parameters—`Either[L, R]`, `Map[K, V]`
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二元类型接受两个参数——`Either[L, R]`，`Map[K, V]`
- en: A ternary type takes three parameters—`Tuple3[A, B, C]`
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三元类型接受三个参数——`Tuple3[A, B, C]`
- en: Higher-order function
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶函数
- en: 'The **order** of a function is the nesting depth of function arrows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的 **order** 是函数箭头的嵌套深度：
- en: Order 0—values, for instance, `1`, `false` or `"hello"`
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零级——值，例如，`1`，`false` 或 `"hello"`
- en: 'Order 1—functions `A => B`, for instance `def addOne: Int => Int = x => x +
    1`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '第一级——函数 `A => B`，例如 `def addOne: Int => Int = x => x + 1`'
- en: 'Order 2—higher-order functions `A => B => C`, for instance:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二级——高阶函数 `A => B => C`，例如：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Order 3—higher-order functions `A => B => C => D`
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三级——高阶函数 `A => B => C => D`
- en: Any function of an order strictly greater than `1` is a higher-order function.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 任何阶数严格大于 `1` 的函数都是高阶函数。
- en: Higher-kinded types
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶类型
- en: 'It turns out that similar concepts exist with types and **kinds**:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，与类型和 **类型类** 存在类似的概念：
- en: The kind of ordinary types such as `Int` or `Boolean` is `*`
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 普通类型，如 `Int` 或 `Boolean` 的类型是 `*`
- en: The kind of unary type constructors is `* -> *`, for instance, `Option` or `List`
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一元类型构造器的类型是 `* -> *`，例如，`Option` 或 `List`
- en: The kind of binary type constructors is `(*, *) -> *`, for instance, `Either`
    or `Map`
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二元类型构造器的类型是 `(*, *) -> *`，例如，`Either` 或 `Map`
- en: 'Similarly to functions and order, we can order kinds by the number of type
    arrow `->` they have:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于函数和级别，我们可以通过类型箭头 `->` 的数量来对类型进行排序：
- en: 'Order 0 (`*`): Ordinary types such as `Int`, `Boolean`, or `String`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第0级（`*`）：普通类型，如 `Int`、`Boolean` 或 `String`
- en: 'Order 1 (`* -> *` or `(*, *) -> *`): Type constructors `Option`, `Vector`,
    `Map`, and many more'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第1级（`* -> *` 或 `(*, *) -> *`）：类型构造器 `Option`、`Vector`、`Map` 以及更多
- en: 'Order 2 (`(* -> *) -> *`): Higher-kinded types `Functor`, `Monad`, and many
    more'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第2级（`(* -> *) -> *`）：高阶类型 `Functor`、`Monad` 以及更多
- en: A **higher-kinded** type is a type constructor that has strictly more than one
    arrow `->`. In the following section, we are going to explore type classes that
    are defined using higher-kinded types.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**高阶**类型是一个具有严格多于一个箭头 `->` 的类型构造器。在下一节中，我们将探讨使用高阶类型定义的类型类。'
- en: cats.Functor
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cats.Functor
- en: '`Functor` is a **higher-kinded** **type** of **arity** one. It accepts a unary
    type parameter `F[_]`. In other words, its type parameter must be a type that
    has a type parameter itself; for instance, `Option[A]`, `Vector[A]`, `Future[A]`,
    and so on. It declares a `map` method that can transform the elements inside of
    `F`. Here is a simplified definition of `cats.Functor`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`Functor` 是一个**一元**的**高阶**类型。它接受一个一元类型参数 `F[_]`。换句话说，其类型参数必须是一个具有类型参数的类型；例如，`Option[A]`、`Vector[A]`、`Future[A]`
    等等。它声明了一个 `map` 方法，可以转换 `F` 内部的元素。以下是 `cats.Functor` 的简化定义：'
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This should be familiar. We have already seen several classes of the SDK that
    define a `map` function doing the same thing: `Vector`, `Option`, and so on. Hence,
    you might wonder why you would ever need to use an instance of `Functor[Option]`
    or `Functor[Vector]`; they would only define a `map` function that is already
    available.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该很熟悉。我们已经看到了 SDK 中定义了执行相同操作的 `map` 函数的几个类：`Vector`、`Option` 等等。因此，你可能会想知道为什么你需要使用
    `Functor[Option]` 或 `Functor[Vector]` 的实例；它们只会定义一个已经可用的 `map` 函数。
- en: 'One advantage of having this `Functor` abstraction in Cats is that it lets
    us write more generic functions:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cats 中拥有这种 `Functor` 抽象的一个优点是它让我们能够编写更通用的函数：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This function adds `1` for any `F[Int]` that has a `Functor` type class instance.
    The only thing I know about `F` is that it has a `map` operation. Hence, this
    function will work for many parameterized types such as `Option` or `Vector`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数为任何具有 `Functor` 类型类实例的 `F[Int]` 添加 `1`。我对 `F` 的唯一了解是它有一个 `map` 操作。因此，此函数将适用于许多参数化类型，例如
    `Option` 或 `Vector`：
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Our function, `addOne`, applies the principle of the least power; given a choice
    of solutions, it picks the least powerful solution capable of solving your problem.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的功能函数 `addOne` 应用最小功率原则；在给定解决方案的选择中，它选择能够解决你问题的最弱解决方案。
- en: 'We use a parameter type that is more generic, and hence, less powerful (it
    only has one `map` function). This makes our function more reusable, easier to
    read, and easier to test:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个更通用的参数类型，因此更弱（它只有一个 `map` 函数）。这使得我们的函数更可重用，更易读，更易测试：
- en: '**More reusable**: The same function can be used with `Option` or `Vector`
    or `List`, or anything that has a `Functor` type class instance.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更可重用**：相同的函数可以用 `Option`、`Vector`、`List` 或任何具有 `Functor` 类型类实例的东西使用。'
- en: '**Easier to read**: When you read the signature of `addOne`, you know that
    the only thing it can do is transform the elements inside of the `F`. It cannot,
    for instance, shuffle the order of the elements, nor can it drop some elements.
    This is guaranteed by the `Functor` laws. Therefore, you do not have to read its
    implementation to make sure that it does not get into any mischief.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更易读**：当你阅读 `addOne` 的签名时，你知道它唯一能做的就是转换 `F` 内部的元素。例如，它不能重新排列元素的顺序，也不能删除某些元素。这是由
    `Functor` 法律保证的。因此，你不需要阅读其实现来确保它不会陷入任何麻烦。'
- en: '**Easier to test**: You can test the function with the simplest type that has
    a `Functor` instance, which is `cats.Id`. the code coverage will be the same.
    A simple test would be, for instance, `addOne[cats.Id](1) == 2`.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更容易测试**：你可以使用具有 `Functor` 实例的最简单类型来测试函数，即 `cats.Id`。代码覆盖率将相同。一个简单的测试可以是，例如，`addOne[cats.Id](1)
    == 2`。'
- en: Laws
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 法律
- en: In order to be `Functor`, the `Functor` instance's `map` function must satisfy
    two laws.  In the rest of this chapter, we will define our laws in terms of an
    equality: `left_expression == right_expression`. These equalities must be true
    for any types and instances specified.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成为 `Functor`，`Functor` 实例的 `map` 函数必须满足两个法律。在本章的其余部分，我们将使用等式来定义我们的法律：`left_expression
    == right_expression`。这些等式必须对任何指定的类型和实例都成立。
- en: 'Given a type `F` that has a `Functor[F]` instance, for any type `A` and any
    instance `fa: F[A]`, the following equalities must be satisfied:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '给定一个具有 `Functor[F]` 实例的类型 `F`，对于任何类型 `A` 和任何实例 `fa: F[A]`，必须满足以下等式：'
- en: '**Identity preservation**: `fa.map(identity) == fa`. The identity function
    always returns its argument. Mapping with this function should not change `fa`.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**恒等性保持**：`fa.map(identity) == fa`。恒等函数总是返回其参数。使用此函数进行映射不应改变 `fa`。'
- en: '**Composition preservation**: For any function `f` and `g`, `fa.map(f).map(g)
    == fa.map(f andThen g)`. Mapping `f` and `g` successively is the same as mapping
    with a composition of these functions. This law allows us to optimize code. When
    we find ourselves calling `map` many times on a large vector, we know that we
    can replace all of the `map` calls with a single one.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合保持**：对于任何函数 `f` 和 `g`，`fa.map(f).map(g) == fa.map(f andThen g)`。依次映射 `f`
    和 `g` 与使用这些函数的组合映射相同。这个定律允许我们优化代码。当我们发现自己多次在大型向量上调用 `map` 时，我们知道我们可以用单个调用替换所有的
    `map` 调用。'
- en: 'Exercise: Write an instance of `Functor[Vector]` that breaks the identity preservation
    law.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：编写一个违反恒等性保持定律的 `Functor[Vector]` 实例。
- en: 'Exercise: Write an instance of `Functor[Vector]` that breaks the composition
    preservation law.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：编写一个违反组合保持定律的 `Functor[Vector]` 实例。
- en: Usage examples
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用示例
- en: 'Whenever you have a function `A => B`, you can lift it to make a function `F[A]
    => F[B]`, as long as you have a `Functor[F]` instance in scope, as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你有一个 `A => B` 的函数时，只要你有一个作用域内的 `Functor[F]` 实例，你就可以将其提升为一个函数 `F[A] => F[B]`，如下所示：
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Another handy function is `fproduct`, which tuples value with the result of
    applying a function:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个实用的函数是 `fproduct`，它将值与函数应用的结果组合成元组：
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We created `Vector[(String, Int)]` by using `fproduct`, and then converted it
    to `Map`. We obtain `Map` (keyed with a word) whose associated value is the number
    of characters of the word.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用 `fproduct` 创建了 `Vector[(String, Int)]`，然后将其转换为 `Map`。我们得到了一个以单词为键的 `Map`，其关联的值是该单词的字符数。
- en: cats.Apply
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cats.Apply
- en: '`Apply` is a subclass of `Functor`. It declares an additional `ap` function.
    Here is a simplified definition of `cats.Apply`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`Apply` 是 `Functor` 的子类。它声明了一个额外的 `ap` 函数。以下是 `cats.Apply` 的简化定义：'
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This signature means that for a given context `F`, if we have a function `A
    => B` inside of `F`, we can apply it to `A` inside of another `F` to obtain `F[B]`.
    We can also use `ap` alias operator, `<*>`. Let''s try it out with different `F`
    contexts, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这个签名意味着对于给定的上下文 `F`，如果我们有一个在 `F` 内部的 `A => B` 函数，我们可以将其应用于另一个 `F` 内部的 `A` 以获得
    `F[B]`。我们还可以使用 `ap` 别名操作符 `<*>`。让我们用不同的 `F` 上下文尝试一下，如下所示：
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: For `F = Option`, `ap` returns a nonempty `Option` only if both arguments are
    nonempty.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `F = Option`，`ap` 仅在两个参数都不为空时才返回一个非空 `Option`。
- en: 'For `F = Vector`, we get the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `F = Vector`，我们得到以下结果：
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the case of `Vector`, `ap` takes each element for the first `Vector` and
    applies it to each element of the second `Vector`. Hence, we obtain all of the
    combinations of applying every function to every element.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Vector` 的情况下，`ap` 对第一个 `Vector` 的每个元素进行操作，并将其应用于第二个 `Vector` 的每个元素。因此，我们获得了将每个函数应用于每个元素的所有组合。
- en: 'Exercise: Use `ap` with `Future`.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：使用 `ap` 与 `Future`。
- en: Laws
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 法则
- en: As with other Cats type classes, an `Apply` instance must obey certain laws.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他 Cats 类型类一样，`Apply` 实例必须遵守某些定律。
- en: 'Given a type `F` that has an `Apply[F]` instance, for all types `A`, given
    an instance `fa: F[A]`, the following equalities must be verified:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '给定一个具有 `Apply[F]` 实例的类型 `F`，对于所有类型 `A`，给定一个实例 `fa: F[A]`，必须验证以下等式：'
- en: '**Product associativity**: For all `fb: F[B]` and `fc: F[C]`, the following
    applies:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**乘积结合律**：对于所有 `fb: F[B]` 和 `fc: F[C]`，以下适用：'
- en: '[PRE37]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can change the parenthesis and hence the evaluation order without changing
    the result.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以改变括号，从而改变求值顺序，而不改变结果。
- en: '**`ap` function composition**: For all types `B` and `C`, given the instances
    `fab: F[A => B]` and `fbc: F[B => C]`, the following applies:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`ap` 函数组合**：对于所有类型 `B` 和 `C`，给定实例 `fab: F[A => B]` 和 `fbc: F[B => C]`，以下适用：'
- en: '[PRE38]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is similar to the function composition law that we saw in the `Functor`
    section: `fa.map(f).map(g) == fa.map(f andThen g)`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在 `Functor` 部分看到的函数组合定律相似：`fa.map(f).map(g) == fa.map(f andThen g)`。
- en: Do not get lost in reading this law; the `<*>` function is applied right to
    left, and the `andThen` used for a function is `.compose[A]` for `Functor`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在阅读这个定律时迷失方向；`<*>` 函数是从右到左应用的，用于函数的 `andThen` 是 `Functor` 的 `.compose[A]`。
- en: 'Exercise: Verify the product associativity for `F = Option`. You can use specific
    values for `fa`, `fc`, and `fc`, for instance `val (fa, fb, fc) = (Option(1),
    Option(2), Option(3))`.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：验证 `F = Option` 的 `product` 结合性。你可以为 `fa`、`fc` 和 `fc` 使用特定的值，例如 `val (fa,
    fb, fc) = (Option(1), Option(2), Option(3))`。
- en: 'Exercise: Verify the `ap` function composition for `F = Option`. As before,
    you can use specific values for `fa`, `fab`, and `fbc`.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：验证 `ap` 函数的 `F = Option` 上的组合。和之前一样，你可以为 `fa`、`fab` 和 `fbc` 使用特定的值。
- en: Usage examples
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用示例
- en: 'This is all good, but in practice, I rarely put functions inside of contexts.
    I find that the function `map2` in `Apply` is more useful. It is defined in `Apply` by
    using `product` and `map`. The `product` defines itself, using `ap` and `map`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这都很好，但在实践中，我很少在上下文中放置函数。我发现 `Apply` 中的 `map2` 函数更有用。它通过使用 `product` 和 `map`
    在 `Apply` 中定义。`product` 通过使用 `ap` 和 `map` 来定义自己：
- en: '[PRE39]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `map2` object allows for applying a function to two values inside of an
    `F` context. This can be used to combine two values inside `F`, as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`map2` 对象允许在 `F` 上下文中应用一个函数到两个值。这可以用来在 `F` 内部组合两个值，如下所示：'
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding example, for `F = Option`, `map2` lets us call the function
    `/` if both values are nonempty.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，对于 `F = Option`，`map2` 允许我们在两个值都不为空时调用函数 `/`。
- en: 'Cats also provide an `Apply` instance for `F = Either[E, ?]`. Therefore, we
    can change the signature of `parseIntOpt` to return `Either[Throwable, Int]`,
    and the rest of the code will be the same:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Cats 还为 `F = Either[E, ?]` 提供了一个 `Apply` 实例。因此，我们可以将 `parseIntOpt` 的签名更改为返回
    `Either[Throwable, Int]`，其余的代码将保持不变：
- en: '[PRE41]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This `map2` function works well for two elements, but what if we have three,
    four, or *N* elements? `Apply` does not define a `map3` or `map4` function, but
    fortunately, Cats defines a `mapN` function on tuples:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `map2` 函数对两个元素工作得很好，但如果我们有三个、四个或 *N* 个元素怎么办？`Apply` 没有定义 `map3` 或 `map4`
    函数，但幸运的是，Cats 在元组上定义了一个 `mapN` 函数：
- en: '[PRE42]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In [Chapter 3](f7fa24eb-8f31-4201-ba7c-c1e32518df8b.xhtml), *Handling Errors*,
    we saw that `Either` is used when we want to stop at the first error. This is
    what we saw in the previous example: the error mentions that `"abc"` cannot be
    parsed, but it does not mention anything about `"def"`.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](f7fa24eb-8f31-4201-ba7c-c1e32518df8b.xhtml)，*处理错误* 中，我们看到当我们要在第一个错误处停止时使用
    `Either`。这就是我们在上一个例子中看到的情况：错误提到 `"abc"` 无法解析，但没有提到 `"def"`。
- en: 'Applying what we just learned, if we want to accumulate all errors, we can
    use `ValidatedNel`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 应用我们刚刚学到的知识，如果我们想累积所有错误，我们可以使用 `ValidatedNel`：
- en: '[PRE43]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Exercise: Use `mapN` with `Future[Int]`. This allows you to run several computations
    in parallel, and to process their results when they are complete.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：使用 `mapN` 与 `Future[Int]`。这允许你并行运行多个计算，并在它们完成时处理它们的结果。
- en: 'Exercise: Use `mapN` with `Vector[Int]`.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：使用 `mapN` 与 `Vector[Int]`。
- en: cats.Applicative
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cats.Applicative
- en: '`Applicative` is a subclass of `Apply`. It declares an additional function,
    called `pure`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`Applicative` 是 `Apply` 的一个子类。它声明了一个额外的函数，称为 `pure`：'
- en: '[PRE44]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `pure` function puts any value of type `A` into the `F` context. A type
    `F` that has an instance of `Applicative[F]` and that respects the associated
    laws is called an **Applicative Functor**.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 将任何类型的 `A` 放入 `F` 上下文的 `pure` 函数。一个具有 `Applicative[F]` 实例并且遵守相关法则的类型 `F` 被称为
    **Applicative Functor**。
- en: 'Let''s try this new `pure` function with different `F` contexts, as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用不同的 `F` 上下文来使用这个新的 `pure` 函数，如下所示：
- en: '[PRE45]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In most cases, `pure` is equivalent to the `apply` constructor. We can call
    it by using the function declared on the `Applicative` trait, or by calling `.pure[F]`
    on any type.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，`pure` 等同于 `apply` 构造函数。我们可以通过使用在 `Applicative` 特质上声明的函数来调用它，或者通过在任意类型上调用
    `.pure[F]` 来调用它。
- en: Laws
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 法则
- en: As you would expect, `Applicative` must conform to some laws.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所预期，`Applicative` 必须遵守某些法则。
- en: 'Given a type `F` that has an `Applicative[F]` instance, for all types `A` given
    an instance `fa: F[A]`, the following equalities must be verified:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '给定一个具有 `Applicative[F]` 实例的类型 `F`，对于所有类型 `A`，给定一个实例 `fa: F[A]`，以下等式必须得到验证：'
- en: 'The Applicative identity is as follows:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Applicative` 的恒等式如下：'
- en: '[PRE46]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: When we put the `identity` function in a `F` context using `pure` and call `<*>`
    on `fa`, it does not change `fa`. It is similar to the identity law in `Functor`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `pure` 将 `identity` 函数放入 `F` 上下文并调用 `fa` 上的 `<*>` 时，它不会改变 `fa`。这类似于 `Functor`
    中的恒等律。
- en: 'The Applicative composition, given the instances `fab: F[A => B]` and `fbc:
    F[B => C]`, is as follows:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '给定实例 `fab: F[A => B]` 和 `fbc: F[B => C]` 的 `Applicative` 组合如下：'
- en: '[PRE47]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: It is similar to the composition preservation in `Functor` . By using `compose`,
    we can change the parenthesis around the `<*>` expressions without changing the
    result.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 它与`Functor`中的组合保持相似。通过使用`compose`，我们可以改变`<*>`表达式周围的括号，而不会改变结果。
- en: 'The `Applicative` homomorphism is as follows:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Applicative`同态如下所示：'
- en: '[PRE48]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: When we call `pure(f)` and then `<*>` , it is the same as applying `f` and then
    calling `pure`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`pure(f)`然后`<*>`，它等同于应用`f`然后调用`pure`。
- en: 'The `Applicative` interchange, given the instance `fab: F[A => B]`, is as follows:'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '给定实例`fab: F[A => B]`的`Applicative`交换如下所示：'
- en: '[PRE49]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We can flip the `fab` argument of `<*>`, provided that we wrap `a` on the left
    side of the equality, or `f(a)` on the right side of the equality.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在等式的左侧包裹`a`，或者在等式的右侧包裹`f(a)`，我们可以翻转`<*>`的`fab`参数。
- en: As an exercise, I encourage you to open the `cats.laws.ApplicativeLaws` class
    from the Cats source code. There are a few other laws to discover, as well as
    the implementations of all of the tests.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，我鼓励你打开Cats源代码中的`cats.laws.ApplicativeLaws`类。还有其他一些定律要发现，以及所有测试的实现。
- en: Usage examples
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用示例
- en: In the section *cats.Apply* about `Apply`, you saw that we can combine many
    values in an `F` context by using `mapN`. However, what if the values that we
    want to combine are in a collection instead of a tuple?
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于`Apply`的*cats.Apply*部分，你看到我们可以通过使用`mapN`在`F`上下文中组合许多值。但是，如果我们想要组合的值在一个集合中而不是一个元组中怎么办？
- en: In that case, we can use the `Traverse` type class. Cats provide instances of
    this type class for many collection types, such as `List`, `Vector`, and `SortedMap`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在那种情况下，我们可以使用`Traverse`类型类。Cats为许多集合类型提供了这个类型类的实例，例如`List`、`Vector`和`SortedMap`。
- en: 'The following is a simplified definition of `Traverse`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对`Traverse`的简化定义：
- en: '[PRE50]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This signature means that I can call it with a collection, `fa: F[A]` (for
    instance, `Vector[String]`), and a function that takes `A` and returns `G[B]`,
    `G` being `Applicative Functor` (for instance, `Option[Int]`). It will run the
    `f` function on all of the values inside the `F`, and will return `F[B]` in a
    `G` context.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '这个签名意味着我可以使用一个集合，`fa: F[A]`（例如，`Vector[String]`），和一个函数来调用`A`并返回`G[B]`，其中`G`是`Applicative
    Functor`（例如，`Option[Int]`）。它将在`F`中的所有值上运行`f`函数，并以`G`上下文返回`F[B]`。'
- en: 'Let’s see it in action with concrete examples, as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过具体的例子来看一下它的实际应用，如下所示：
- en: '[PRE51]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We can safely parse `Vector[String]` to return `Option[Vector[Int]]`. The result
    will be `None` if any value cannot be parsed. In this example, we called `Traverse`
    with `F = Vector`, `G = Option`, `A = String`, and `B = Int`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以安全地将`Vector[String]`解析为返回`Option[Vector[Int]]`。如果任何值无法解析，结果将是`None`。在这个例子中，我们使用`Traverse`，其中`F
    = Vector`、`G = Option`、`A = String`和`B = Int`。
- en: 'If we want to keep some details about the parsing error, we can use `G = ValidatedNel`,
    as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要保留一些解析错误的详细信息，我们可以使用`G = ValidatedNel`，如下所示：
- en: '[PRE52]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Exercise: Use `Traverse` with `G = Future`. This will let you run a function
    in parallel for each element of the collection.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：使用`Traverse`，其中`G = Future`。这将允许你并行运行集合中每个元素的函数。
- en: Another common use case is to flip a structure `F[G[A]]` into an `F[G[A]]`,
    using `sequence`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的用例是使用`sequence`将结构`F[G[A]]`翻转成`F[G[A]]`。
- en: 'The following is the definition of `sequence` in the `cats.Traverse` trait:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在`cats.Traverse`特质中`sequence`的定义：
- en: '[PRE53]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We can see that `sequence` is actually implemented using `traverse`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`sequence`实际上是通过`traverse`实现的。
- en: 'The following is an example, with `F = Vector` and `G = Option`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个例子，其中`F = Vector`和`G = Option`：
- en: '[PRE54]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'And here is another example, with `F = List` and `G = Future`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是另一个例子，其中`F = List`和`G = Future`：
- en: '[PRE55]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The call to `sequence` returns `Future` which will complete only when the three
    futures inside of `vecFut` complete.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`sequence`的调用返回`Future`，它只会在`vecFut`中的三个future完成时完成。'
- en: cats.Monad
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cats.Monad
- en: '`Monad` is a subclass of `Applicative`. It declares an additional function, `flatMap`,
    as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`Monad`是`Applicative`的子类。它声明了一个额外的函数，`flatMap`，如下所示：'
- en: '[PRE56]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This signature tells us that in order to produce `F[B]`, `flatMap` will somehow
    have to extract `A` inside `fa: F[A]`, and then call the function, `f`.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '这个签名告诉我们，为了产生`F[B]`，`flatMap`必须以某种方式从`fa: F[A]`中提取`A`，然后调用函数`f`。'
- en: 'Previously, you saw that `Applicative` and `mapN` allow us to process several
    `F[A]` values in parallel, and combine them into a single `F[B]`. What `Monad`
    adds is the capability of processing `F[]` values in sequence: `flatMap` must
    process the `F` effect first, then call the `f` function.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，你看到 `Applicative` 和 `mapN` 允许我们并行处理多个 `F[A]` 值，并将它们组合成一个单一的 `F[B]`。`Monad`
    添加的是处理 `F[]` 值的顺序能力：`flatMap` 必须首先处理 `F` 效应，然后调用 `f` 函数。
- en: Similar to `Functor` and `map`, many classes of the SDK already have a `flatMap`
    method, such as `Option`, `Vector`, `Future`, and so on. One advantage of having
    this `Monad` abstraction is that we can write functions that accept `Monad` so
    that it can be reused with different types.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Functor` 和 `map` 类似，SDK中的许多类已经有一个 `flatMap` 方法，例如 `Option`、`Vector`、`Future`
    等。拥有这种 `Monad` 抽象的一个优点是我们可以编写接受 `Monad` 的函数，这样它就可以与不同类型重用。
- en: Laws
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 法律
- en: 'Given a type `F` that has a `Monad[F]` instance, for all types `A` given an
    instance `fa: F[A]`, the following equalities must be verified:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '给定一个具有 `Monad[F]` 实例的类型 `F`，对于所有类型 `A` 给定一个实例 `fa: F[A]`，以下等式必须得到验证：'
- en: '**All of the laws from the super traits**: See `Applicative`, `Apply`, and `Functor`.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**所有来自超特质的法律**：参见 `Applicative`、`Apply` 和 `Functor`。'
- en: '**FlatMap associativity**: Given two types `B` and `C`, and two functions `f:
    A => F[B]` and `g: B => F[C]`, the following applies:'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FlatMap 结合律**：给定两个类型 `B` 和 `C`，以及两个函数 `f: A => F[B]` 和 `g: B => F[C]`，以下适用：'
- en: '[PRE57]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '**Left identity**: Given a type `B`, a value `a: A`, and a function `f: A =>
    F[B]`, the following applies:'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左单位元**：给定一个类型 `B`，一个值 `a: A`，和一个函数 `f: A => F[B]`，以下适用：'
- en: '[PRE58]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Bringing a value in the `F` context and calling `flatMap f` should provide the
    same result as calling the function `F` directly.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `F` 上下文中引入一个值并调用 `flatMap f` 应该提供与直接调用函数 `F` 相同的结果。
- en: '**Right identity**:'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**右单位元**：'
- en: '[PRE59]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `fa` object should not change when we call `flatMap` and `pure`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `flatMap` 和 `pure` 时，`fa` 对象不应该改变。
- en: Usage examples
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用示例
- en: 'Suppose that you are building a program to manage a shop''s inventory. The
    following is a simplified API to manage the items:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在构建一个用于管理商店库存的程序。以下是一个简化版的API来管理项目：
- en: '[PRE60]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The API is parametrized with an `F` context. This allows you to have different
    implementations of your API, as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 该API使用一个 `F` 上下文进行参数化。这允许你有不同的API实现，如下所示：
- en: In your unit tests, you would use `class TestItemApi extends ItemApi[cats.Id]`.
    If you look for the definition of `Id`, you will find `type Id[A] = A`. This means
    that this `TestItemApi` can directly return `Vector[Item]` in `findAllItems`,
    and `Unit` in `saveItem`.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的单元测试中，你会使用 `class TestItemApi extends ItemApi[cats.Id]`。如果你寻找 `Id` 的定义，你会找到
    `type Id[A] = A`。这意味着这个 `TestItemApi` 可以直接在 `findAllItems` 中返回 `Vector[Item]`，在
    `saveItem` 中返回 `Unit`。
- en: In your production code, you will need access to a database, or to call a remote
    REST service. These actions take time and can fail; hence, you will need to use
    something like `F = Future`, or maybe `F = cats.effects.IO`. You will, for instance,
    define `class DbItemApi extends ItemApi[Future]`.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的生产代码中，你需要访问数据库，或者调用远程REST服务。这些操作需要时间并且可能会失败；因此，你需要使用类似 `F = Future` 或 `F
    = cats.effects.IO` 的东西。例如，你可以定义 `class DbItemApi extends ItemApi[Future]`。
- en: The `Future` class in the SDK has some issues and breaks some laws. I encourage
    you to use better abstractions, such as `cats.effects.IO` ([https://typelevel.org/cats-effect/datatypes/io.html](https://typelevel.org/cats-effect/datatypes/io.html))
    or `monix.eval.Task` ([https://monix.io/docs/2x/eval/task.html](https://monix.io/docs/2x/eval/task.html)).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: SDK中的 `Future` 类有一些问题并违反了一些法律。我鼓励你使用更好的抽象，例如 `cats.effects.IO` ([https://typelevel.org/cats-effect/datatypes/io.html](https://typelevel.org/cats-effect/datatypes/io.html))
    或 `monix.eval.Task` ([https://monix.io/docs/2x/eval/task.html](https://monix.io/docs/2x/eval/task.html))。
- en: 'Equipped with this API, we can implement some business logic. The following
    is the implementation of a function that applies a discount to all items:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 配置了这个API后，我们可以实现一些业务逻辑。以下是一个应用折扣到所有项目的函数实现：
- en: '[PRE61]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `F[_]: Monad` type parameter constraint implies that we can call `startSalesSeason`
    with any `ItemApi[F]`, as long as `F` has a `Monad` instance. The presence of
    this implicit in scope allows us to call `map` and `flatMap` on an instance `F[A]`.
    Since a `for` comprehension is transformed by the compiler into a combination
    of `map`/`flatMap`, we can use a `for` comprehension to make our function more
    readable. In the section *cats.Applicative*, about `Applicative`, you saw that
    we can call `traverse` on `Vector`, as long as the function returns `F` which
    has an `Applicative[F]` instance. Since `Monad` extends `Applicative`, we could
    use `traverse` to iterate through the items and save each of them.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`F[_]: Monad`类型参数约束意味着我们可以用任何`ItemApi[F]`调用`startSalesSeason`，只要`F`有一个`Monad`实例。这个隐式参数的存在允许我们在`F[A]`实例上调用`map`和`flatMap`。由于编译器将`for`推导式转换为`map`/`flatMap`的组合，我们可以使用`for`推导式使我们的函数更易读。在*cats.Applicative*部分关于`Applicative`，你看到我们可以对`Vector`调用`traverse`，只要函数返回具有`Applicative[F]`实例的`F`。由于`Monad`扩展了`Applicative`，我们可以使用`traverse`遍历项目并保存每个项目。'
- en: If you squint at this code, it looks very similar to what an imperative implementation
    would look like. We managed to write a purely functional function while keeping
    readability. The advantage of this technique is that we can easily unit test the
    logic of `startSalesSeason` with `F = Id`, without having to deal with `Futures`.
    In the production code, the same code can use `F = Future`, or even `F = Future[Either[Exception,
    ?]]`, and gracefully handle the process in multiple threads.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你眯着眼睛看这段代码，它看起来非常类似于命令式实现的模样。我们设法编写了一个纯函数，同时保持了可读性。这种技术的优势在于，我们可以轻松地对`startSalesSeason`的逻辑进行单元测试，使用`F
    = Id`，而无需处理`Futures`。在生产代码中，相同的代码可以使用`F = Future`，甚至`F = Future[Either[Exception,
    ?]]`，并在多线程中优雅地处理流程。
- en: 'Exercise: Implement `TestItemApi`, which extends `ItemApi[Id]`. You can use
    a mutable `Map` to store the items. After that, write a unit test for `startSalesSeason`.
    Then, implement a production version of the API that extends `ItemApi[Future]`.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：实现`TestItemApi`，它扩展了`ItemApi[Id]`。你可以使用可变的`Map`来存储项目。之后，为`startSalesSeason`编写单元测试。然后，实现一个生产版本的API，它扩展了`ItemApi[Future]`。
- en: This approach is known as **tagless final encoding**. You can find more information
    about this pattern at [https://www.beyondthelines.net/programming/introduction-to-tagless-final/](https://www.beyondthelines.net/programming/introduction-to-tagless-final/).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法被称为**无标签最终编码**。您可以在[https://www.beyondthelines.net/programming/introduction-to-tagless-final/](https://www.beyondthelines.net/programming/introduction-to-tagless-final/)找到更多关于此模式的信息。
- en: Summary
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We covered some challenging concepts in this chapter. Type classes are also
    used in other functional programming languages, such as Haskell.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中介绍了一些具有挑战性的概念。类型类也用于其他函数式编程语言，如Haskell。
- en: 'For convenience, the following table summarizes the type classes that we enumerated
    in this chapter:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，以下表格总结了我们在本章中列举的类型类：
- en: '| Name | Method | Law(s) | Example(s) |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 方法 | 法律 | 示例 |'
- en: '| `Semigroup` | `def combine(` `x: A, y: A) : A` | Associativity |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| `Semigroup` | `def combine(` `x: A, y: A) : A` | 结合律 |'
- en: '[PRE62]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '|'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Monoid` | `def empty: A` | Identity |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| `Monoid` | `def empty: A` | 标识符 |'
- en: '[PRE63]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '|'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Functor` | `def map[A, B]` `(fa: F[A])`'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Functor` | `def map[A, B]` `(fa: F[A])`'
- en: '`(f: A => B): F[B]` | Identity, Composability |'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`(f: A => B): F[B]` | 标识符，可组合性 |'
- en: '[PRE65]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '|'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Apply` | `def ap[A, B]` `(ff: F[A => B])`'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Apply` | `def ap[A, B]` `(ff: F[A => B])`'
- en: '`(fa: F[A]): F[B]`'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`(fa: F[A]): F[B]`'
- en: alias `<*>` | Associativity, Composability |
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 别名 `<*>` | 结合律，可组合性 |
- en: '[PRE67]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '|'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Applicative` | `def pure[A]` `(x: A): F[A]` | Identity, Composability,'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Applicative` | `def pure[A]` `(x: A): F[A]` | 标识符，可组合性，'
- en: Homomorphism,
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 同态，
- en: Interchange |
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 交换 |
- en: '[PRE69]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '|'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Monad` | `def flatMap[A, B]` `(fa: F[A])`'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Monad` | `def flatMap[A, B]` `(fa: F[A])`'
- en: '`(f: A =>F[B]): F[B]` | Identity, Associativity,'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`(f: A => F[B]): F[B]` | 标识符，结合律，'
- en: Composability,
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 可组合性，
- en: Homomorphism,
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 同态，
- en: Interchange |
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 交换 |
- en: '[PRE70]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '|'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: If you would like to explore type classes in more detail, I encourage you to
    view the Cats documentation at [https://typelevel.org/cats](https://typelevel.org/cats).
    I have also found it very helpful to read the source code and tests in the SDK,
    or in libraries such as Cats.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更详细地了解类型类，我鼓励你查看Cats文档[https://typelevel.org/cats](https://typelevel.org/cats)。我也发现阅读SDK中的源代码和测试，或者在Cats等库中阅读源代码和测试非常有帮助。
- en: Cats is the main library of the Typelevel initiative, but there are many more
    fascinating projects hosted under this umbrella, as shown at [https://typelevel.org/projects/](https://typelevel.org/projects/).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: Cats 是 Typelevel 创新计划的主要库，但在这个旗下还有许多更多令人着迷的项目，如[https://typelevel.org/projects/](https://typelevel.org/projects/)所示。
- en: In the next chapter, we will implement a cart for a shopping website, using
    frameworks that are popular in the Scala community.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用在 Scala 社区中流行的框架来实现一个购物网站的购物车。
