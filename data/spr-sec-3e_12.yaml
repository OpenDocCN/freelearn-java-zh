- en: Fine-Grained Access Control
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 细粒度访问控制
- en: In this chapter, we will first examine two ways to implement fine-grained authorization-authorization
    that may affect portions of a page of the application. Next, we will look at Spring
    Security's approach to securing the business tier through method annotation and
    the use of interface-based proxies to accomplish AOP. Then, we will review an
    interesting capability of annotation-based security that allows for role-based
    filtering on collections of data. Last, we will look at how class-based proxies
    differ from interface-based proxies.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先将探讨两种实现细粒度授权的方法-可能影响应用程序页面部分的内容。接下来，我们将查看Spring Security通过方法注解和使用基于接口的代理来实现业务层安全的方法。然后，我们将回顾注解
    based安全的一个有趣功能，它允许基于角色的数据过滤。最后，我们将查看类 based代理与接口 based代理的区别。
- en: 'During the course of this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的进程中，我们将介绍以下主题：
- en: Configuring and experimenting with different methods of performing in-page authorization
    checks on content, given the security context of a user request
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置并在不同的方法上进行实验，以实现在页面上根据用户请求的安全上下文进行内容授权检查
- en: Performing configuration and code annotation to make caller preauthorization
    a key part of our application's business-tier security
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行配置和代码注解，使调用者预授权成为我们应用程序业务层安全的关键部分
- en: Several alternative approaches to implement method-level security, and reviewing
    the pros and cons of each type
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现方法级安全性的几种不同方法，并回顾每种类型的优缺点
- en: Implementing data-based filters on collections and arrays using method-level
    annotations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在集合和数组上使用方法级注解实现数据过滤
- en: Implementing method-level security on our Spring MVC controllers to avoid configuring
    `antMatcher()` methods and `<intercept-url>` elements
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Spring MVC控制器上实现方法级安全，避免配置`antMatcher()`方法和`<intercept-url>`元素
- en: Gradle dependencies
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gradle依赖项
- en: 'There are a number of optional dependencies that may be required, depending
    on what features you decide to use. Many of these dependencies are commented as
    Spring Boot includes them already in the starter parent. You will find that our
    `build.gradle` file already includes all of the following dependencies:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多可选依赖项可能需要，这取决于您决定使用哪些功能。许多这些依赖项已在Spring Boot的启动父级中注释掉。您会发现我们的`build.gradle`文件已经包括了以下所有依赖项：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Integrating Spring Expression Language (SpEL)
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成Spring表达式语言（SpEL）
- en: 'Spring Security leverages **Spring Expression Language** (**SpEL**) integration
    in order to easily articulate various authorization requirements. If you recall,
    we have already looked at the use of SpEL in [Chapter 2](02.html), *Getting Started
    with Spring Security*, when we defined our `antMatcher()` method:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security利用**Spring表达式语言**（**SpEL**）集成，以便轻松阐述各种授权要求。如果您还记得，我们在[第2章](02.html)
    *开始使用Spring Security*中已经查看了SpEL的使用，当时我们定义了我们的`antMatcher()`方法：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Spring Security provides an `o.s.s.access.expression.SecurityExpressionRoot`
    object that provides the methods and objects available for use, in order to make
    an access control decision. For example, one of the methods available to use is
    `hasRole` method, which accepts a string. This corresponds to the value of the
    access attribute (in the preceding code snippet). In fact, there are a number
    of other expressions available, as shown in the following table:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security提供了一个`o.s.s.access.expression.SecurityExpressionRoot`对象，提供了可用于做出访问控制决策的方法和对象。例如，可以使用的一个方法是接受一个字符串的`hasRole`方法。这与前面代码片段中访问属性的值相对应。实际上，还有许多其他表达式可供使用，如下表所示：
- en: '| **Expression** | **Description** |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** | **描述** |'
- en: '| `hasRole(String role)``hasAuthority(String role)` | Returns `true` if the
    current user has the specified authority. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `hasRole(String role)``hasAuthority(String role)` | 如果当前用户具有指定的权限，则返回`true`。
    |'
- en: '| `hasAnyRole(String... role)``hasAnyAuthority(String... authority)` | Returns
    `true` if the current user has any of the specified authorities. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `hasAnyRole(String... role)``hasAnyAuthority(String... authority)` | 如果当前用户具有任何指定的权限，则返回`true`。
    |'
- en: '| `principal` | Allows access to the current `Authentication` object''s principal
    attribute. As discussed in [Chapter 3](03.html), *Custom Authentication*, this
    will often be an instance of `UserDetails`. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `principal` | 允许访问当前`Authentication`对象的principal属性的权限。正如在[第3章](03.html) *自定义认证*中讨论的，这通常是一个`UserDetails`实例。
    |'
- en: '| `authentication` | Obtains the current `Authentication` object from the `SecurityContext`
    interface returned by the `getContext()` method of the `SecurityContextHolder`
    class. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `authentication` | 从 `SecurityContext` 接口返回的 `SecurityContextHolder` 类的 `getContext()`
    方法获取当前 `Authentication` 对象。 |'
- en: '| `permitAll` | Always returns `true`. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `permitAll` | 总是返回 `true`。 |'
- en: '| `denyAll` | Always returns `false`. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `denyAll` | 总是返回 `false`。 |'
- en: '| `isAnonymous()` | Returns true if the current principal is anonymous (is
    not authenticated). |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `isAnonymous()` | 如果当前主体是匿名（没有认证），则返回 true。 |'
- en: '| `isRememberMe()` | Returns `true` if the current principal was authenticated
    using the remember-me feature. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `isRememberMe()` | 如果当前主体是使用记住我功能进行认证的，则返回 `true`。 |'
- en: '| `isAuthenticated()` | Returns `true` if the user is not an anonymous user
    (that is, they are authenticated). |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `isAuthenticated()` | 如果用户不是匿名用户（也就是说，他们已经认证），则返回 `true`。 |'
- en: '| `isFullyAuthenticated()` | Returns `true` if the user is authenticated through
    a means other than remember me. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `isFullyAuthenticated()` | 如果用户通过记住我以外的其他方式进行认证，则返回 `true`。 |'
- en: '| `hasPermission(Object target, Object permission)` | Returns `true` if the
    user has permission to access the specified object for the given permission. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `hasPermission(Object target, Object permission)` | 如果用户有权限访问给定权限的指定对象，则返回
    `true`。 |'
- en: '| `hasPermission( String targetId, String targetType, Object permission)` |
    Returns `true` if the user has permission to access the specified identifier for
    a given type and permission. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `hasPermission( String targetId, String targetType, Object permission)` |
    如果用户有权限访问给定类型和权限的指定标识符，则返回 `true`。 |'
- en: 'We have provided some examples of using these SpEL expressions in the following
    code snippet. Keep in mind that we will go into more detail throughout this and
    the next chapter:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一些使用这些 SpEL 表达式的示例代码。请记住，我们将在本章和下一章中详细介绍：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The WebSecurityExpressionRoot class
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`WebSecurityExpressionRoot` 类'
- en: 'The `o.s.s.web.access.expression.WebSecurityExpressionRoot` class makes a few
    additional properties available to us. These properties, along with the standard
    properties already mentioned, are made available in the access attribute of the
    `antMatchers()` method and in the JSP/Thymeleaf `access` attribute of the `<sec:authorize>`
    tag, as we will discuss shortly:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`o.s.s.web.access.expression.WebSecurityExpressionRoot` 类为我们提供了一些额外的属性。这些属性，连同前面提到的标准属性，可以在
    `antMatchers()` 方法的访问属性中以及 JSP/Thymeleaf 的 `<sec:authorize>` 标签的 `access` 属性中使用，我们稍后会讨论这些：'
- en: '| **Expression** | **Description** |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** | **描述** |'
- en: '| `request` | The current `HttpServletRequest` method. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `request` | 当前的 `HttpServletRequest` 方法。 |'
- en: '| `hasIpAddress(String... ipAddress)` | Returns `true` if the current IP address
    matches the `ipAddress` value. This can be an exact IP address or the IP address/network
    mask. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `hasIpAddress(String... ipAddress)` | 如果当前IP地址匹配 `ipAddress` 值，则返回 `true`。这可以是一个确切的IP地址或者IP地址/子网掩码。
    |'
- en: Using the request attribute
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用请求属性
- en: 'The `request` attribute is fairly self-explanatory, but we have provided a
    few examples in the following code. Remember, any of these examples could be placed
    in the `antMatchers()` method''s access attribute or the `<sec:authorize>` element''s
    access attribute:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`request` 属性相对容易理解，但我们提供了一些示例代码。请记住，这些示例都可以放在 `antMatchers()` 方法的访问属性中或者 `<sec:authorize>`
    元素的访问属性中：'
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using the hasIpAddress method
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 hasIpAddress 方法
- en: 'The `hasIpAddress` method is not quite as clear-cut as the `request` attribute.
    The `hasIpAddress` will easily match an exact IP address; for example, the following
    code would allow access if the current user''s IP address was `192.168.1.93`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`hasIpAddress` 方法并没有 `request` 属性那么简单明了。`hasIpAddress` 会很容易匹配一个确切的IP地址；例如，以下代码如果当前用户IP地址是
    `192.168.1.93`，则允许访问：'
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, this is not all that useful. Instead, we can define the following
    code, which would also match our IP address and any other IP address in our subnet:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是非常有用。相反，我们可以定义以下代码，这也将匹配我们的IP地址以及我们子网中的任何其他IP地址：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The question is: how is this calculated? The key is to understand how to calculate
    the network address and its mask. To learn how to do this, we can take a look
    at a concrete example. We launch `ifconfig` from our Linux Terminal to view our
    network information (Windows users can use enter `ipconfig /all` into the Command
    Prompt):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是：这是如何计算的？关键是要理解如何计算网络地址及其掩码。要了解如何进行计算，我们可以看一个具体的例子。我们从 Linux 终端启动 `ifconfig`
    来查看我们的网络信息（Windows 用户可以在命令提示符中输入 `ipconfig /all`）：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Take a look at the following diagram:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下图表：
- en: '![](img/e2c7a7d2-5944-4bce-a054-d54ad9df8a0b.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2c7a7d2-5944-4bce-a054-d54ad9df8a0b.png)'
- en: 'We can see that the first three octets of our mask are **255**. This means
    that the first three octets of our **IP Address** belong to the network address.
    In our calculation, this means that the remaining octets are **0**:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的掩码的前三个八位字节是**255**。这意味着我们的**IP地址**的前三个八位字节属于网络地址。在我们的计算中，这意味着剩下的八位字节是**0**：
- en: '![](img/13bb5b29-556c-4a5c-8662-8f5857a14289.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13bb5b29-556c-4a5c-8662-8f5857a14289.png)'
- en: We can then calculate the mask by first transforming each octet into a binary
    number, and then count how many ones there are. In our instance, we get `24`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以通过首先将每个八位字节转换为二进制数，然后计算其中有多少个一来进行掩码计算。在我们的实例中，得到`24`。
- en: This means our IP address will match `192.168.1.0/24`. A good site for additional
    information on netmasks is Cisco's documentation, available at [http://www.cisco.com/c/en/us/support/docs/ip/routing-information-protocol-rip/13788-3.html](http://www.cisco.com/c/en/us/support/docs/ip/routing-information-protocol-rip/13788-3.html).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的IP地址将匹配`192.168.1.0/24`。有关更多信息的良好资源是思科的文档，可在[http://www.cisco.com/c/en/us/support/docs/ip/routing-information-protocol-rip/13788-3.html](http://www.cisco.com/c/en/us/support/docs/ip/routing-information-protocol-rip/13788-3.html)找到。
- en: The MethodSecurityExpressionRoot class
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法访问控制表达式根类
- en: 'Method SpEL expressions also provide a few additional properties that can be
    used through the `o.s.s.access.expression.method.MethodSecurityExpressionRoot`
    class:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 方法访问控制表达式（SpEL）还提供了一些额外的属性，可以通过`o.s.s.access.expression.method.MethodSecurityExpressionRoot`类使用：
- en: '| **Expression** | **Description** |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** | **描述** |'
- en: '| `target` | Refers to `this` or the current object being secured. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `target` | 指的是`this`或被保护的当前对象。 |'
- en: '| `returnObject` | Refers to the object returned by the annotated method. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `returnObject` | 指的是注解方法的返回对象。 |'
- en: '| `filterObject` | Can be used on a collection or array in conjunction with
    `@PreFilter` or `@PostFilter`, to only include the elements that match the expression.
    The `filterObject` object represents the loop variable of the collection or array.
    |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `filterObject` | 可以在与`@PreFilter`或`@PostFilter`结合使用时，用于集合或数组上，只包含与表达式匹配的元素。`filterObject`对象代表集合或数组的循环变量。
    |'
- en: '| `#<methodArg>` | Any argument to a method can be referenced by prefixing
    the argument name with `#`. For example, a method argument named `id` can be referred
    to using `#id`. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `#<methodArg>` | 可以通过在参数名称前加上`#`来引用任何方法参数。例如，一个名为`id`的方法参数可以使用`#id`来引用。 |'
- en: If the description of these expressions appears a bit brief, don't worry; we'll
    work through a number of examples later in this chapter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些表达式的描述看起来有点简略，不用担心；我们将在本章后面通过一些例子来详细说明。
- en: We hope that you have a decent grasp of the power of Spring Security's SpEL
    support. To learn more about SpEL, refer to the Spring reference documentation
    at [https://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html](https://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望您已经对Spring Security的SpEL支持的力量有了大致的了解。要了解更多关于SpEL的信息，请参考Spring的参考文档：[https://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html](https://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html)。
- en: Page-level authorization
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 页面级授权
- en: Page-level authorization refers to the availability of application features
    based on the context of a particular user's request. Unlike coarse-grained authorization
    that we explored in [Chapter 2](02.html), *Getting Started with Spring Security*,
    fine-grained authorization typically refers to the selective availability of the
    portions of a page, rather than restricting access to a page entirely. Most real-world
    applications will spend a considerable amount of time on the details of fine-grained
    authorization planning.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 页面级授权指的是基于特定用户请求上下文的应用程序功能的可用性。与我们在[第2章](02.html) *开始使用Spring Security*中探讨的粗粒度授权不同，细粒度授权通常指的是页面的部分内容的的选择性可用性，而不是完全限制访问页面。大多数现实世界的应用程序将在细粒度授权计划的细节上花费相当多的时间。
- en: 'Spring Security provides us with the following three methods of selective display
    functionality:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security为我们提供了以下三种选择性显示功能的方法：
- en: Spring Security JSP tag libraries allow conditional access declarations to be
    placed within a page declaration itself, using the standard JSP tag library syntax.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Security JSP标签库允许将条件访问声明放置在页面声明本身中，使用标准的JSP标签库语法。
- en: Thymeleaf Spring Security tag libraries allow conditional access declarations
    to be placed within a page declaration itself, using the standard Thymeleaf tag
    library syntax.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Thymeleaf Spring Security标签库允许在页面声明本身内放置基于条件的访问声明，使用标准的Thymeleaf标签库语法。
- en: Checking user authorization in an MVC application's controller layer allows
    the controller to make an access decision and bind the results of the decision
    to the model data provided to the view. This approach relies on standard JSTL
    conditional page rendering and data binding, and is slightly more complicated
    than Spring Security tag libraries; however, it is more in line with the standard
    web application MVC logical design.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在MVC应用程序的控制器层检查用户授权允许控制器做出访问决策，并将决策结果绑定到提供给视图的模型数据。这种方法依赖于标准的JSTL条件页面渲染和数据绑定，比Spring
    Security标签库稍微复杂一些；然而，它更符合标准Web应用程序MVC逻辑设计。
- en: Any of these approaches are perfectly valid when developing fine-grained authorization
    models for a web application. Let's explore how each approach is implemented through
    a JBCP calendar use case.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法在为Web应用程序开发细粒度授权模型时都是完全有效的。让我们探讨每个方法是如何通过JBCP日历用例来实现的。
- en: Conditional rendering with the Thymeleaf Spring Security tag library
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Thymeleaf Spring Security标签库的有条件渲染
- en: The most common functionality used in the Thymeleaf Spring Security tag library
    is to conditionally render portions of the page based on authorization rules.
    This is done with the `< sec:authorize*>` tag that functions similarly to the
    `<if>` tag in the core JSTL library, in that the tag's body will render depending
    on the conditions provided in the tag attributes. We have already seen a very
    brief demonstration of how the Spring Security tag library can be used to restrict
    the viewing of content if the user is not logged in.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在Thymeleaf Spring Security标签库中最常用的功能是基于授权规则有条件地渲染页面的部分。这是通过`< sec:authorize*>`标签实现的，该标签与核心JSTL库中的`<if>`标签类似，即标签体的渲染取决于标签属性中提供的条件。我们已经看到了一个非常简短的演示，介绍了如何使用Spring
    Security标签库来限制用户未登录时查看内容。
- en: Conditional rendering based on URL access rules
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于URL访问规则的有条件渲染
- en: The Spring Security tag library provides functionality to render content based
    on the existing URL authorization rules that are already defined in the security
    configuration file. This is done via the use of the `authorizeRequests()` method
    and the `antMatchers()` method.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security标签库提供了根据已经在安全配置文件中定义的URL授权规则来渲染内容的功能。这是通过使用`authorizeRequests()`方法和`antMatchers()`方法来实现的。
- en: If there are multiple HTTP elements, the `authorizeRequests()` method uses the
    currently matched HTTP element's rules.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个HTTP元素，`authorizeRequests()`方法将使用当前匹配的HTTP元素的规则。
- en: 'For example, we could ensure that the All Events link is displayed only when
    appropriate, that is, for users who are administrators-recall that the access
    rules we''ve previously defined are as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以确保所有事件链接只在适当的时候显示，即对于管理员用户——回想一下我们之前定义的访问规则如下：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Update the `header.html` file to utilize this information and conditionally
    render the link to the All Events page:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`header.html`文件以利用此信息，并根据条件渲染到所有事件页面的链接：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will ensure that the content of the tag is not displayed unless the user
    has sufficient privileges to access the stated URL. It is possible to further
    qualify the authorization check using the HTTP method, by including the method
    attribute before the URL, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保除非用户有足够的权限访问所声明的URL，否则不显示标签的内容。进一步细化授权检查是可能的，通过在URL之前包含方法属性，如下所示：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Using the `authorize-url` attribute to define authorization checks on blocks
    of code is convenient because it abstracts the knowledge of the actual authorization
    checks from your pages and keeps it in your security configuration file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`authorize-url`属性在代码块上定义授权检查是方便的，因为它将实际授权检查的知识从您的页面抽象出来，并将其保存在您的安全配置文件中。
- en: Be aware that the HTTP method should match the case specified in your security
    `antMatchers()` method, otherwise they may not match as you expect. Also, note
    that the URL should always be relative to the web application context root (as
    your URL access rules are).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，HTTP方法应与您安全`antMatchers()`方法中指定的大小写相匹配，否则它们可能不会像您期望的那样匹配。另外，请注意URL应始终相对于Web应用程序上下文根（如您的URL访问规则）。
- en: For many purposes, the use of the `<sec>` tag's `authorize-url` attribute will
    suffice to correctly display link- or action-related content only when the user
    is allowed to see it. Remember that the tag need not only surround a link; it
    could even surround a whole form if the user doesn't have permission to submit
    it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多目的来说，使用`<sec>`标签的`authorize-url`属性足以正确地仅当用户被允许查看时显示与链接或操作相关的内容。记住，这个标签不仅仅需要包围一个链接；如果用户没有权限提交它，它甚至可以包围整个表单。
- en: Conditional rendering using SpEL
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SpEL的条件渲染
- en: 'An additional, more flexible method of controlling the display of JSP content
    is available when the `<sec>` tag is used in conjunction with a SpEL expression.
    Let''s review what we learned in [Chapter 2](02.html), *Getting Started with Spring
    Security*. We could hide the My Events link from any unauthenticated users by
    changing our `header.html` file, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当与`<sec>`标签一起使用时，可以控制JSP内容的显示，这是一种更灵活的方法。让我们回顾一下我们在[第2章](02.html)*Spring Security入门*中学到的内容。我们可以通过更改我们的`header.html`文件，如下所示，将我的事件链接隐藏在任何未认证的用户中：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The SpEL evaluation is performed by the same code behind the scenes as the expressions
    utilized in the `antMatchers()` method access declaration rules (assuming the
    expressions have been configured). Hence, the same set of built-in functions and
    properties are accessible from the expressions built using the `<sec>` tag.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: SpEL评估是由与`antMatchers()`方法访问声明规则中使用的表达式相同的代码在后台执行的（假设已经配置了表达式）。因此，从使用`<sec>`标签构建的表达式中可以访问相同的内置函数和属性集。
- en: Both of these methods of utilizing the `<sec>` tag provide powerful, fine-grained
    control over the display of page content based on security authorization rules.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种使用`<sec>`标签的方法为基于安全授权规则的页面内容显示提供了强大、细粒度的控制。
- en: Go ahead and start up the JBCP calendar application. Visit `https://localhost:8443`
    and log in with the user `user1@example.com` and the password `user1`. You will
    observe that the My Events link is displayed, but the All Events link is hidden.
    Log out and log in as the user `admin1@example.com` with the password
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 继续启动JBCP日历应用程序。访问`https://localhost:8443`，使用用户`user1@example.com`和密码`user1`登录。你会观察到我的事件链接被显示，但所有事件链接被隐藏。登出并使用用户`admin1@example.com`和密码登录
- en: '`admin1`. Now both links are visible.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`admin1`。现在两个链接都可见。'
- en: You should start with the code from `chapter11.01-calendar`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该从`chapter11.01-calendar`的代码开始。
- en: Using controller logic to conditionally render content
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用控制器逻辑条件性地渲染内容
- en: In this section, we will demonstrate how we can use Java-based code to determine
    if we should render some content. We can choose to only show the Create Event
    link on the Welcome page to users who have a username that contains `user`. This
    will hide the Create Event link on the Welcome page from users who are not logged
    in as administrators.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将演示如何使用基于Java的代码来确定是否应渲染某些内容。我们可以选择只在用户名包含`user`的用户的欢迎页面上显示创建事件链接，这样未登录为管理员的用户在欢迎页面上就看不到创建事件链接。
- en: 'The welcome controller from the sample code for this chapter has been updated
    to populate the model with an attribute named `showCreateLink`, derived from the
    method name, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 本章示例代码中的欢迎控制器已更新，使用以下方式从方法名派生一个名为`showCreateLink`的属性来填充模型：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You may notice that Spring MVC can automatically obtain the `Authentication`
    object for us. This is because Spring Security maps our current `Authentication`
    object to the `HttpServletRequest.getPrincipal()` method. Since Spring MVC will
    automatically resolve any object of the `java.security.Principal` type to the
    value of `HttpServletRequest.getPrincipal()`, specifying `Authentication` as an
    argument to our controller is an easy way to access the current `Authentication`
    object. We could also decouple the code from Spring Security by specifying an
    argument of the `Principal` type instead. However, we chose `Authentication` in
    this scenario to help demonstrate how everything connects.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到Spring MVC可以自动获取`Authentication`对象。这是因为Spring Security将我们当前的`Authentication`对象映射到`HttpServletRequest.getPrincipal()`方法。由于Spring
    MVC将自动解析任何`java.security.Principal`类型的对象为`HttpServletRequest.getPrincipal()`的值，将`Authentication`作为控制器的一个参数是一个轻松访问当前`Authentication`对象的方法。我们也可以通过指定`Principal`类型的参数来解耦代码与Spring
    Security。然而，在这个场景中我们选择了`Authentication`，以帮助说明一切是如何相互关联的。
- en: If we were working in another framework that did not know how to do this, we
    could obtain the `Authentication` object using the `SecurityContextHolder` class,
    as we did in [Chapter 3](03.html), *Custom Authentication*. Also note that if
    we were not using Spring MVC, we could just set the `HttpServletRequest` attribute
    directly rather than populating it on the model. The attribute that we populated
    on the request would then be available to our JSP, just as it is when using a
    `ModelAndView` object with Spring MVC.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在另一个不知道如何做到这一点的其他框架中工作，我们可以使用`SecurityContextHolder`类获取`Authentication`对象，就像我们在第[3]章*自定义认证*中做的那样。同时请注意，如果我们不是使用Spring
    MVC，我们完全可以直接设置`HttpServletRequest`属性，而不是在模型中填充它。我们在请求中填充的属性随后将可用于我们的JSP，就像在使用带有Spring
    MVC的`ModelAndView`对象时一样。
- en: 'Next, we will need to use the `HttpServletRequest` attribute in our `index.html`
    file to determine if we should display the Create Event link. Update `index.html`,
    as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在我们的`index.html`文件中使用`HttpServletRequest`属性来确定是否应显示创建活动的链接。更新`index.html`，如下所示：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, start the application, log in using `admin1@example.com` as the username
    and `admin1` as the password, and visit the All Events page. You should no longer
    see the Create Events link in the main navigation (although it will still be present
    on the page).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动应用程序，使用`admin1@example.com`作为用户名，`admin1`作为密码登录，然后访问所有活动页面。你应该再也看不到主导航中的创建活动链接了（尽管它仍然在页面上）。
- en: 'Your code should look like this: `chapter11.02-calendar`.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码应该看起来像这样：`chapter11.02-calendar`。
- en: The WebInvocationPrivilegeEvaluator class
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`WebInvocationPrivilegeEvaluator`类'
- en: 'There may be times when an application will not be written using JSPs and will
    need to be able to determine access based upon a URL, as we did with `<... sec:authorize-url="/events/">`.
    This can be done by using the `o.s.s.web.access.WebInvocationPrivilegeEvaluator`
    interface, which is the same interface that backs the JSP tag library. In the
    following code snippet, we demonstrate its use by populating our model with an
    attribute named `showAdminLink`. We are able to obtain `WebInvocationPrivilegeEvaluator`
    using the `@Autowired` annotation:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有时应用程序可能不会使用JSP编写，需要能够根据URL确定访问权限，就像我们用`<... sec:authorize-url="/events/">`做的那样。这可以通过使用`o.s.s.web.access.WebInvocationPrivilegeEvaluator`接口来实现，这个接口也是JSP标签库背后的同一个接口。在下面的代码片段中，我们通过用名为`showAdminLink`的属性填充我们的模型来演示它的使用。我们可以使用`@Autowired`注解来获取`WebInvocationPrivilegeEvaluator`：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If the framework you are using is not being managed by Spring, `@Autowire`
    will not be able to provide you with `WebInvocationPrivilegeEvaluator`. Instead,
    you can use Spring''s `org.springframework.web.context.WebApplicationContextUtils`
    interface to obtain an instance of `WebInvocationPrivilegeEvaluator`, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用的框架不是由Spring管理的，`@Autowire`将无法为你提供`WebInvocationPrivilegeEvaluator`。相反，你可以使用Spring的`org.springframework.web.context.WebApplicationContextUtils`接口来获取`WebInvocationPrivilegeEvaluator`的一个实例，如下所示：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To try it out, go ahead and update `index.html` to use the `showAdminLink`
    request attribute, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试一下，更新`index.html`以使用`showAdminLink`请求属性，如下所示：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Restart the application and view the Welcome page before you have logged in.
    The H2 link should not be visible. Log in as `admin1@example.com`/`admin1`, and
    you should see it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动应用程序并在登录之前查看欢迎页面。H2链接应该是不可见的。以`admin1@example.com`/`admin1`的身份登录，你应该就能看到它。
- en: Your code should look like `chapter11.03-calendar`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码应该看起来像`chapter11.03-calendar`。
- en: What is the best way to configure in-page authorization?
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在页面内进行授权配置的最佳方式是什么？
- en: 'Major advances in the Thymeleaf Spring Security `<sec>` tag in Spring Security
    4 removed many of the concerns about the use of this tag in previous versions
    of the library. In many cases, the use of the `authorize-url` attribute of the
    tag can appropriately isolate the code from changes in authorization rules. You
    should use the `authorize-url` attribute of the tag in the following scenarios:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Security 4中，Thymeleaf Spring Security `<sec>`标签的重大进展消除了许多关于在库先前版本中使用此标签的担忧。在许多情况下，标签的`authorize-url`属性能适当地隔离代码，使其不受授权规则变化的影响。你应该在以下场景中使用标签的`authorize-url`属性：
- en: The tag is preventing display functionality that can be clearly identified by
    a single URL
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个标签阻止了可以通过单个URL明确识别的显示功能
- en: The contents of the tag can be unambiguously isolated to a single URL
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签的内容可以明确地隔离到一个单独的URL
- en: Unfortunately, in a typical application, the likelihood that you will be able
    to use the `authorize-url` attribute of the tag frequently is somewhat low. The
    reality is that applications are usually much more complex than this, and require
    more involved logic when deciding to render portions of a page.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在典型的应用程序中，你能够频繁使用标签的`authorize-url`属性的可能性相当低。现实情况是，应用程序通常比这更复杂，在决定渲染页面的部分时需要更复杂的逻辑。
- en: 'It''s tempting to use the Thymeleaf Spring Security tag library to declare
    bits of rendered pages as off-limits based on security criteria in other methods.
    However, there are a number of reasons why (in many cases) this isn''t a great
    idea, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Thymeleaf Spring Security标签库来基于安全标准声明渲染页面的部分区域是很有诱惑力的。然而，（在许多情况下）这样做并不是一个好主意，原因如下：
- en: Complex conditions beyond role membership are not supported by the tag library.
    For example, if our application incorporated customized attributes on the `UserDetails`
    implementation, IP filters, geolocation, and so on, none of these would be supported
    by the standard `<sec>` tag.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签库不支持复杂条件超出角色成员。例如，如果我们的应用程序在`UserDetails`实现中包含了自定义属性、IP过滤器、地理位置等，这些都不支持标准的`<sec>`标签。
- en: These could, however, conceivably be supported by the custom tags or using SpEL
    expressions. Even in this case, the page is more likely to be directly tied to
    business logic rather than what is typically encouraged.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些可能会通过自定义标签或使用SpEL表达式来支持。即使在這種情況下，页面也更可能直接与业务逻辑相关联，而不是通常所鼓励的。
- en: The `<sec>` tag must be referenced on every page that it's used in. This leads
    to potential inconsistencies between the rulesets that are intended to be common,
    but may be spread across different physical pages. A good object-oriented system
    design would suggest that conditional rule evaluations be located in only one
    place, and logically referred to from where they should be applied.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<sec>`标签必须在每页中引用它被使用的页面。这可能导致预期为公共规则集之间潜在的不一致，这些规则集可能分布在不同的物理页面之间。一个好的面向对象系统设计建议将条件规则评估放在一个地方，从应该应用的地方逻辑上引用。'
- en: It is possible (and we illustrate this using our common header page include)
    to encapsulate and reuse portions of pages to reduce the occurrence of this type
    of problem, but it is virtually impossible to eliminate in a complex application.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有可能（并且我们通过包含常用的页面头部的示例来说明）封装和复用页面的一部分以减少这类问题的发生，但在复杂的应用程序中几乎不可能完全消除。
- en: There is no way to validate the correctness of rules stated at compile time.
    Whereas compile-time constants can be used in typical Java-based, object-oriented
    systems, the tag library requires (in typical use) hardcoded role names where
    a simple typo might go undetected for some time.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有办法在编译时验证规定的规则的正确性。虽然在典型的基于Java的对象导向系统中可以使用编译时常量，但标签库在典型使用中要求硬编码角色名称，而简单的拼写错误可能会在一段时间内未被发现。
- en: To be fair, such typos could be caught easily by comprehensive functional tests
    on the running application, but they are far easier to test using a standard Java
    component unit testing techniques.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公平地说，这样的错误可以通过对运行中的应用程序进行全面的函数测试轻松捕捉到，但使用标准的Java组件单元测试技术来测试它们要容易得多。
- en: We can see that, although the **template-based** approach for conditional content
    rendering is convenient, there are some significant downsides.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以看到，尽管基于**模板的**条件内容渲染方法很方便，但存在一些显著的缺点。
- en: All of these issues can be solved by the use of code in controllers that can
    be used to push data into the application view model. Additionally, performing
    advanced authorization determinations in code allows for the benefits of reuse,
    compile-time checks, and proper logical separation of the model, view, and controller.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些问题都可以通过在控制器中使用代码来解决，该代码可用于将数据推送到应用程序视图模型。此外，在代码中执行高级授权确定允许重用、编译时检查以及模型、视图和控制器之间的适当逻辑分离。
- en: Method-level security
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法级安全
- en: Our primary focus up to this point in the book has been on securing the web-facing
    portion of the JBCP calendar application; however, in real-world planning of secured
    systems, equal attention should be paid to securing the service methods that allow
    users access to the most critical part of any system-its data.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书的主要关注点是保护JBCP日历应用程序的面向网络的部分；然而，在实际规划安全系统时，应同样关注保护允许用户访问系统最核心部分的服务方法——即数据。
- en: Why we secure in layers?
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么我们要分层保护？
- en: Let's take a minute to see why it is important to secure our methods, even though
    we have already secured our URLs. Start the JBCP calendar application up. Log
    in using `user1@example.com` as the username and `user1` as the password, and
    visit the All Events page. You will see the custom Access Denied page. Now, add
    `.json` to the end of the URL in the browser so that the URL is now `https://localhost:8443/events/.json`.
    You will now see a JSON response with the same data as the HTML All Events page.
    This data should only be visible to an administrator, but we have bypassed it
    by finding a URL that was not configured properly.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花一分钟来了解为什么即使我们已经保护了我们的 URL，确保方法的安全也是重要的。启动 JBCP 日历应用程序。使用 `user1@example.com`
    作为用户名和 `user1` 作为密码登录，然后访问所有事件页面。你会看到自定义的访问被拒绝页面。现在，在浏览器的 URL 末尾添加 `.json`，使 URL
    变为 `https://localhost:8443/events/.json`。你现在会看到一个带有与 HTML 所有事件页面相同数据的 JSON 响应。这部分数据只应由管理员可见，但我们通过找到一个配置不正确的
    URL 来绕过它。
- en: We can also view the details of an event that we do not own and are not invited
    to. Change `.json` with `102` so that the URL is now `https://localhost:8443/events/102`.
    You will now see a Lunch event that is not listed on your My Events page. This
    should not be visible to us because we are not an administrator and this is not
    our event.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以查看我们不拥有且未受邀的活动的详细信息。将 `.json` 替换为 `102`，使 URL 变为 `https://localhost:8443/events/102`。你现在会看到一个在“我的活动”页面中未列出的午餐事件。这不应该对我们可见，因为我们不是管理员，而且这不是我们的活动。
- en: As you can see, our URL rules are not quite strong enough to entirely secure
    our application. These exploits do not even need to take advantage of more complex
    problems, such as differences in how containers handle URL normalization. In short,
    there are often ways to bypass URL-based security. Let's see how adding a security
    layer to our business tier can help with our new security vulnerability.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的 URL 规则不足以完全保护我们的应用程序。这些攻击甚至不需要利用更复杂的问题，例如容器处理 URL 标准化方式的差异。简而言之，通常存在绕过基于
    URL 的安全性的方法。让我们看看向我们的业务层添加安全层如何帮助我们解决新的安全漏洞。
- en: Securing the business tier
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护业务层
- en: Spring Security has the ability to add a layer of authorization (or authorization-based
    data pruning) to the invocation of any Spring-managed bean in your application.
    While many developers focus on web-tier security, business-tier security is arguably
    just as important, as a malicious user may be able to penetrate the security of
    your web tier or access services exposed through a non-UI frontend, such as a
    web service.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring Security** 具备为应用程序中任何由 Spring 管理的 bean 调用添加一层授权（或基于授权的数据修剪）的能力。虽然许多开发者关注的是网络层的安全性，但业务层的安全性同样重要，因为恶意用户可能能够穿透网络层的安全或通过非
    UI 前端（如 Web 服务）访问服务。'
- en: 'Let''s examine the following logical diagram to see why we''re interested in
    applying a secondary layer of security:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看以下逻辑图，了解为什么我们感兴趣于应用第二层安全：
- en: '![](img/357835b8-4d31-4cce-8b41-c5d7c70c0909.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/357835b8-4d31-4cce-8b41-c5d7c70c0909.png)'
- en: 'Spring Security has the following two main techniques for securing methods:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 用于保护方法的主要技术有以下两种：
- en: '**Preauthorization**: This technique ensures that certain constraints are satisfied
    prior to the execution of a method that is being allowed, for example, if a user
    has a particular `GrantedAuthority`, such as `ROLE_ADMIN`. Failure to satisfy
    the declared constraints means that the method call will fail.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预授权**：这种技术确保在允许执行的方法执行之前满足某些约束条件，例如，如果用户具有特定的 `GrantedAuthority`，如 `ROLE_ADMIN`。未能满足声明的约束条件意味着方法调用将失败。'
- en: '**Postauthorization**: This technique ensures that the calling principal still
    satisfies declared constraints after the method returns. This is rarely used but
    can provide an extra layer of security around some complex, interconnected business
    tier methods.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后授权**：这种技术确保在方法返回后，调用者仍然满足声明的约束条件。这种方法很少使用，但可以为一些复杂、相互连接的业务层方法提供额外的安全层。'
- en: The preauthorization and postauthorization techniques provide formalized support
    for what are generally called preconditions and postconditions in a classic, object-oriented
    design. Preconditions and postconditions allow a developer to declare through
    runtime checks that certain constraints around a method's execution must always
    hold true. In the case of security preauthorization and postauthorization, the
    business tier developer makes a conscious decision about the security profile
    of particular methods by encoding expected runtime conditions as part of an interface
    or class API declaration. As you may imagine, this requires a great deal of forethought
    to avoid unintended consequences!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 预授权和后授权技术为在经典、面向对象设计中通常称为前提条件和后置条件提供了正式化的支持。前提条件和后置条件允许开发者在运行时检查，声明方法执行过程中某些约束必须始终成立。在安全预授权和后授权的情况下，业务层开发者通过将期望的运行时条件作为接口或类API声明的一部分来编码，对特定方法的安全配置有一个明确的决策。正如你所想象的，这需要大量的深思熟虑，以避免意想不到的后果！
- en: Adding the @PreAuthorize method annotation
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加@PreAuthorize方法注解
- en: 'Our first design decision will be to augment method security at the business
    tier by ensuring that a user must be logged in as an `ADMIN` user before he/she
    is allowed to access the `getEvents()` method. This is done with a simple annotation
    added to the method in the service interface definition, as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个设计决策将是通过确保用户必须以`ADMIN`用户身份登录后才能访问`getEvents()`方法，在业务层增强方法安全性。这是通过在服务接口定义中的方法上添加一个简单的注解来完成的，如下所示：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is all that is required to ensure that anyone invoking our `getEvents()`
    method is an administrator. Spring Security will use a runtime **Aspect Oriented
    Programming** (**AOP**) pointcut to execute `BeforeAdvice` on the method, and
    throw `o.s.s.access.AccessDeniedException` if the security constraints aren't
    met.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是确保调用我们`getEvents()`方法的人是管理员所需要的一切。Spring Security将在运行时使用**面向切面编程**（**AOP**）的**BeforeAdvice**切入点在方法上执行，如果安全约束不被满足，将抛出`o.s.s.access.AccessDeniedException`。
- en: Instructing Spring Security to use method annotations
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指导Spring Security使用方法注解
- en: 'We''ll also need to make a one-time change to `SecurityConfig.java`, where
    we''ve got the rest of our Spring Security configuration. Simply add the following
    annotation to the class declaration:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要对`SecurityConfig.java`进行一次性的更改，我们在那里有剩下的Spring Security配置。只需在类声明中添加以下注解：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Validating method security
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证方法安全性
- en: Don't believe it was that easy? Log in with `user1@example.com` as the username
    and `user1` as the password, and try accessing `https://localhost:8443/events/.json`.
    You should see the Access Denied page now.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你相信就这样容易吗？用用户名`user1@example.com`和密码`user1`登录，尝试访问`https://localhost:8443/events/.json`。现在你应该看到访问被拒绝的页面。
- en: Your code should look like `chapter11.04-calendar`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码应该看起来像`chapter11.04-calendar`。
- en: 'If you look at the Tomcat console, you''ll see a very long stack trace, starting
    with the following output:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看Tomcat控制台，你会看到一个非常长的堆栈跟踪，以以下输出开始：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Based on the Access Denied page, and the stack trace clearly pointing to the
    `getEvents` method invocation, we can see that the user was appropriately denied
    access to the business method because it lacked the `GrantedAuthority` of `ROLE_ADMIN`.
    If you run the same with the username `admin1@example.com` and the password `admin1`,
    you will discover that access will be granted.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 基于访问被拒绝页面，以及堆栈跟踪明确指向`getEvents`方法的调用，我们可以看出用户因为缺少`ROLE_ADMIN`的`GrantedAuthority`而被适当地拒绝了访问业务方法的权限。如果你用用户名`admin1@example.com`和密码`admin1`来运行相同的操作，你会发现访问将被授予。
- en: Isn't it amazing that with a simple declaration in our interface, we're able
    to ensure that the method in question is secure? But how does AOP work?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在接口中简单声明，我们就能够确保所讨论的方法是安全的，这难道不令人惊叹吗？但是AOP是如何工作的呢？
- en: Interface-based proxies
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于接口的代理
- en: 'In the given example from the previous section, Spring Security used an interface-based
    proxy to secure our `getEvents` method. Let''s take a look at the simplified pseudocode
    of what happened to understand how this works:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中给出的示例中，Spring Security使用基于接口的代理来保护我们的`getEvents`方法。让我们看看简化后的伪代码，了解这是如何工作的：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can see that Spring creates the original `CalendarService` just as it normally
    does. However, it instructs our code to use another implementation of `CalendarService`
    that performs a security check before returning the result of the original method.
    The secure implementation can be created with no prior knowledge of our interface
    because Spring uses Java's `java.lang.reflect.Proxy` APIs to dynamically create
    new implementations of the interface. Note that the object returned is no longer
    an instance of `DefaultCalendarService`, since it is a new implementation of `CalendarService`,
    that is, it is an anonymous implementation of `CalendarService`. This means that
    we must program against an interface in order to use the secure implementation,
    otherwise, a `ClassCastException` exception will occur. To learn more about Spring
    AOP, refer to the Spring reference documentation at [http://static.springsource.org/spring/docs/current/spring-framework-reference/html/aop.html#aop-introduction-proxies](http://static.springsource.org/spring/docs/current/spring-framework-reference/html/aop.html#aop-introduction-proxies).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到Spring创建了原始的`CalendarService`，就像它通常做的那样。然而，它指示我们的代码使用另一个实现`CalendarService`，在返回原始方法的结果之前执行安全检查。安全实现可以在不事先了解我们接口的情况下创建，因为Spring使用Java的`java.lang.reflect.Proxy`
    API动态创建接口的新实现。请注意，返回的对象不再是`DefaultCalendarService`的实例，因为它是一个新的`CalendarService`实现，即它是`CalendarService`的一个匿名实现。这意味着我们必须针对接口编程以使用安全实现，否则会发生`ClassCastException`异常。要了解更多关于Spring
    AOP的信息，请参阅[http://static.springsource.org/spring/docs/current/spring-framework-reference/html/aop.html#aop-introduction-proxies](http://static.springsource.org/spring/docs/current/spring-framework-reference/html/aop.html#aop-introduction-proxies)的Spring参考文档。
- en: In addition to the `@PreAuthorize` annotation, there are several other ways
    of declaring security preauthorization requirements on methods. We can examine
    these different ways of securing methods and then evaluate their pros and cons
    in different circumstances.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`@PreAuthorize`注解之外，还有几种其他方法可以在方法上声明安全预授权要求。我们可以研究这些不同的方法来保护方法，然后评估在不同情况下它们的优缺点。
- en: JSR-250 compliant standardized rules
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSR-250兼容的标准化规则
- en: '**JSR-250 Common Annotations** for the Java platform defines a series of annotations,
    some that are security-related, which are intended to be portable across JSR-250
    compliant runtime environments. The Spring Framework became compliant with JSR-250
    as part of the Spring 2.x release, including the Spring Security framework.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSR-250通用注解**为Java平台定义了一系列注解，其中一些与安全相关，旨在在JSR-250兼容的运行时环境中可移植。Spring Framework作为Spring
    2.x版本的的一部分，包括Spring Security框架，变得与JSR-250兼容。'
- en: While JSR-250 annotations are not as expressive as Spring native annotations,
    they have the benefit that the declarations they provide are compatible across
    implementing Java EE application servers such as Glassfish or service-oriented
    runtime frameworks such as **Apache Tuscany**. Depending on your application's
    needs and requirements for portability, you may decide that the trade-off of reduced
    specificity is worth the portability of the code.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管JSR-250注解不如Spring原生注解表达能力强，但它们的优点是它们提供的声明在实现Java EE应用服务器的不同环境中是兼容的，例如Glassfish或服务导向的运行时框架，如**Apache
    Tuscany**。根据您的应用程序的需求和可移植性要求，您可能决定减少特异性与代码的可移植性之间的权衡是值得的。
- en: 'To implement the rule we specified in the first example, we make a few changes
    by performing the following steps:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们第一个示例中指定的规则，我们通过执行以下步骤进行一些更改：
- en: 'First, we need to update our `SecurityConfig` file to use the JSR-250 annotations:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要更新我们的`SecurityConfig`文件以使用JSR-250注解：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Lastly, the `@PreAuthorize` annotation needs to change to the `@RolesAllowed`
    annotation. As we might anticipate, the `@RolesAllowed` annotation does not support
    SpEL expressions, so we edit `CalendarService` as follows:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，需要将`@PreAuthorize`注解更改为`@RolesAllowed`注解。正如我们所预期的，`@RolesAllowed`注解不支持SpEL表达式，因此我们按照如下方式编辑`CalendarService`：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Restart the application, log in as `user1@example.com`/`user1`, and try to access
    `http://localhost:8080/events/.json`. You should see the Access Denied page again.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动应用程序，以`user1@example.com`/`user1`的身份登录，尝试访问`http://localhost:8080/events/.json`。您应该再次看到访问被拒绝的页面。
- en: 'Your code should look like this: `chapter11.05-calendar`.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码应如下所示：`chapter11.05-calendar`。
- en: 'Note that it''s also possible to provide a list of allowed `GrantedAuthority`
    names using the standard Java 5 String array annotation syntax:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，还可以使用Java 5标准字符串数组注解语法提供允许的`GrantedAuthority`名称列表：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There are also two additional annotations specified by JSR-250, namely `@PermitAll`
    and `@DenyAll`, which function as you might expect, permitting and denying all
    requests to the method in question.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 还有JSR-250指定的两个额外的注解，分别是`@PermitAll`和`@DenyAll`，它们的功能如你所料，允许或拒绝所有对所述方法的请求。
- en: '**Annotations at the class level**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**类级别的注解**'
- en: Be aware that method-level security annotations can be applied at the class
    level as well! Method-level annotations, if supplied, will always override annotations
    specified at the class level. This can be helpful if your business needs to dictate
    the specification of security policies for an entire class. Take care to use this
    functionality in conjunction with good comments and coding standards, so that
    developers are very clear about the security characteristics of the class and
    its methods.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，方法级别的安全注解也可以应用于类级别！如果提供，方法级别的注解将始终覆盖类级别指定的注解。这在你需要为整个类指定安全策略时很有帮助。在使用此功能时，请确保与良好的注释和编码标准相结合，以便开发人员非常清楚类及其方法的安全特性。
- en: Method security using Spring's @Secured annotation
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring的@Secured注解的方法安全
- en: 'Spring itself provides a simpler annotation style that is similar to the JSR-250
    `@RolesAllowed` annotation. The `@Secured` annotation is functionally and syntactically
    the same as `@RolesAllowed`. The only notable differences are that it does not
    require the external dependency, cannot be processed by other frameworks, and
    the processing of these annotations must be explicitly enabled with another attribute
    on the `@EnableGlobalMethodSecurity` annotation:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Spring本身提供了一种更简单的注解风格，与JSR-250的`@RolesAllowed`注解类似。`@Secured`注解在功能和语法上与`@RolesAllowed`相同。唯一的显著差异是它不需要外部依赖，不能被其他框架处理，并且这些注解的处理必须通过`@EnableGlobalMethodSecurity`注解的另一个属性明确启用：
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As `@Secured` functions in the same way as the JSR standard `@RolesAllowed`
    annotation, there's no real compelling reason to use it in new code, but you may
    run across it in older Spring code.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`@Secured`函数与JSR标准`@RolesAllowed`注解相同，所以在新的代码中没有真正的强制性理由使用它，但在较老的Spring代码中可能会遇到它。
- en: Method security rules incorporating method parameters
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包含方法参数的方法安全规则
- en: 'Logically, writing rules that refer to method parameters in their constraints
    seem sensible for certain types of operations. For example, it might make sense
    for us to restrict the `findForUser(int userId)` method to meet the following
    constraints:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 从逻辑上讲，在约束中引用方法参数的编写规则对于某些类型的操作来说似乎是合理的。例如，对我们来说限制`findForUser(int userId)`方法以满足以下约束可能是合理的：
- en: The `userId` argument must be equal to the current user's ID
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`userId`参数必须等于当前用户的ID'
- en: The user must be an administrator (in this case, it is valid for the user to
    see any event)
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户必须是管理员（在这种情况下，用户可以看到任何事件）
- en: While it's easy to see how we could alter the rule to restrict the method invocation
    only to administrators, it's not clear how we would determine if the user is attempting
    to change their own password.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以很容易地看到如何修改规则，以限制方法调用仅限于管理员，但不清如何确定用户是否正在尝试更改自己的密码。
- en: 'Fortunately, SpEL binding, used by the Spring Security method annotations,
    supports more sophisticated expressions, including expressions that incorporate
    method parameters. You will also want to ensure that you have enabled pre- and
    post-annotations in the `SecurityConfig` file, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Spring Security方法注解使用的SpEL绑定支持更复杂的表达式，包括包含方法参数的表达式。你还需要确保已经在`SecurityConfig`文件中启用了前缀和后缀注解，如下所示：
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can see here that we've augmented the SpEL directive we used in the first
    exercise with a check against the ID of the principal and against the `userId`
    method parameter (`#userId`, the method parameter name, is prefixed with a `#`
    symbol). The fact that this powerful feature of method parameter binding is available
    should get your creative juices flowing and allow you to secure method invocations
    with a very precise set of logical rules.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们已经用我们在第一个练习中使用的SpEL指令增强了对主体的ID和`userId`方法参数的检查（`#userId`，方法参数名称前缀有一个`#`符号）。这个强大的方法参数绑定的特性应该能激发你的创造力，并允许你用非常精确的逻辑规则来保护方法调用。
- en: Our principal is currently an instance of `CalendarUser` due to the custom authentication
    setup from [Chapter 3](03.html), *Custom Authentication*. This means that the
    principal has all of the properties that our `CalendarUser` application has on
    it. If we had not done this customization, only the properties of the `UserDetails`
    object would be available.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于自[第3章](03.html)以来的自定义身份验证设置，我们的主体目前是一个`CalendarUser`实例 *自定义身份验证*。这意味着主体具有我们`CalendarUser`应用程序上的所有属性。如果我们没有进行这种自定义，只有`UserDetails`对象的属性才可用。
- en: 'SpEL variables are referenced with the hash (`#`) prefix. One important note
    is that in order for method argument names to be available at runtime, debugging
    symbol table information must be retained after compilation. Common methods to
    retain the debugging symbol table information are listed as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: SpEL变量使用哈希（`#`）前缀引用。一个重要的注意事项是，为了在运行时可用，必须在编译后保留调试符号表信息。保留调试符号表信息的常用方法如下所示：
- en: If you are using the `javac` compiler, you will need to include the `-g` flag
    when building your classes
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您正在使用`javac`编译器，您在构建类时需要包含`-g`标志。
- en: When using the `<javac>` task in Ant, add the attribute `debug="true"`
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用Ant中的`<javac>`任务时，添加属性`debug="true"`。
- en: In Gradle, ensure to add `--debug` when running the main method, or the `bootRun`
    task
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Gradle中，确保在运行主方法或`bootRun`任务时添加`--debug`。
- en: In Maven, ensure the `maven.compiler.debug=true` property (the default is `true`)
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Maven中，确保`maven.compiler.debug=true`属性（默认值为`true`）。
- en: Consult your compiler, build tool, or IDE documentation for assistance on configuring
    this same setting in your environment.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 查阅您的编译器、构建工具或IDE文档，以获取在您的环境中配置相同设置的帮助。
- en: Start up your application and try logging in with `user1@example.com` as the
    username and `user1` as the password. On the Welcome page, request the My Events
    (`email=admin1@example.com`) link to see an Access Denied page. Try again with
    My Events (`email=user1@example.com`) to see it work. Note that the displayed
    user on the My Events page matches the currently logged-in user. Now, try the
    same steps and log in as `admin1@example.com`/`admin1`. You will be able to see
    both pages since you are logged in as a user with the `ROLE_ADMIN` permission.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 启动你的应用程序，并尝试使用`user1@example.com`作为用户名和`user1`作为密码登录。在欢迎页面，请求`My Events`（`email=admin1@example.com`）链接以看到“访问被拒绝”的页面。再次尝试`My
    Events`（`email=user1@example.com`）以使其工作。请注意，在“我的事件”页面上显示的用户与当前登录的用户匹配。现在，尝试相同的步骤并以`admin1@example.com`/`admin1`登录。你将能够看到两个页面，因为你是以具有`ROLE_ADMIN`权限的用户登录。
- en: Your code should look like `chapter11.06-calendar`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码应该看起来像`chapter11.06-calendar`。
- en: Method security rules incorporating returned values
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包含返回值的方法安全规则。
- en: 'Just as we were able to leverage the parameters to the method, we can also
    leverage the returned value of the method call. Let''s update the `getEvent` method
    to meet the following constraints on the returned value:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们能够利用方法的参数一样，我们也可以利用方法调用的返回值。让我们更新`getEvent`方法，以满足返回值的以下约束：
- en: The attendee's ID must be the current user's ID
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参与者的ID必须是当前用户的ID。
- en: The owner'sID must be the current user's ID
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有者的ID必须是当前用户的ID。
- en: The user must be an administrator (in this case, it is valid for the user to
    see any event)
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户必须是管理员（在这种情况下，用户可以看到任何事件是有效的）。
- en: 'Add the following code to the `CalendarService` interface:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`CalendarService`接口中：
- en: '[PRE26]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, try logging in with the username `user1@example.com` and the password `user1`.
    Next, try accessing the Lunch event using the link on the Welcome page. You should
    now see the Access Denied page. If you log in using the username `user2@example.com`
    and the password `user2`, the event will display as expected since `user2@example.com`
    is the attendee at the Lunch event.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试使用用户名`user1@example.com`和密码`user1`登录。接下来，尝试通过欢迎页面的链接访问午餐事件。你现在应该会看到“访问被拒绝”的页面。如果你使用用户名`user2@example.com`和密码`user2`登录，由于`user2@example.com`是午餐事件的参与者，事件将如预期显示。
- en: Your code should look like `chapter11.07-calendar`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码应该看起来像`chapter11.07-calendar`。
- en: Securing method data using role-based filtering
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基于角色的过滤来保护方法数据。
- en: The two final Spring Security-dependent annotations are `@PreFilter` and `@PostFilter`,
    which are used to apply security-based filtering rules to collections or arrays
    (with `@PostFilter` only). This type of functionality is referred to as security
    trimming or security pruning and involves using the security credentials of `principal`
    at runtime to selectively remove members from a set of objects. As you might expect,
    this filtering is performed using SpEL expression notation within the annotation
    declaration.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个依赖于Spring Security的注解是`@PreFilter`和`@PostFilter`，它们用于将安全过滤规则应用于集合或数组（仅限`@PostFilter`）。这种功能被称为安全修剪或安全修剪，涉及在运行时使用`principal`的安全凭证来有选择地从一组对象中移除成员。正如你所期望的，这种过滤是使用注解声明中的SpEL表达式完成的。
- en: 'We''ll work through an example with JBCP calendar, as we want to filter the
    `getEvents` method to only return the events that this user is allowed to see.
    In order to do this, we remove any existing security annotations and add the `@PostFilter`
    annotation to our `CalendarService` interface, as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个JBCP日历的例子来工作，因为我们想要过滤`getEvents`方法，使其只返回这个用户被允许看到的活动。为了做到这一点，我们移除了任何现有的安全注解，并在我们的`CalendarService`接口中添加了`@PostFilter`注解，如下所示：
- en: '[PRE27]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Your code should look like this: `chapter11.08-calendar`.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码应该看起来像这样：`chapter11.08-calendar`。
- en: Remove the `antMatchers()` method, restricting access to `/events/URL` so that
    we can test our annotation. Start up the application and view the All Events page
    when logged in with the username `user1@example.com` and password `user1`. You
    will observe that only the events that are associated with our user are displayed.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 删除`antMatchers()`方法，限制对`/events/URL`的访问，以便我们可以测试我们的注解。启动应用程序，登录使用用户名`user1@example.com`和密码`user1`后查看所有活动页面，你会观察到只显示与我们用户相关联的活动。
- en: With `filterObject` acting as the loop variable that refers to the current event,
    Spring Security will iterate over the `List<Event>` returned by our service and
    modify it to only contain the `Event` objects that match our SpEL expression.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`filterObject`作为循环变量，指的是当前活动，Spring Security将遍历我们服务返回的`List<Event>`，并修改它，使其只包含匹配我们的SpEL表达式的`Event`对象。'
- en: In general, the `@PostFilter` method behaves in the following way. For brevity,
    we refer to the collection as the method return value, but be aware that `@PostFilter`
    works with either collection or array method return types.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`@PostFilter`方法的行为如下。为了简洁起见，我们称集合为方法返回值，但请注意`@PostFilter`既适用于集合也适用于数组方法返回类型。
- en: The `filterObject` object is rebound to the SpEL context for each element in
    the collection. This means that if your method is returning a collection with
    100 elements, the SpEL expression will be evaluated for each.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`filterObject`对象被重新绑定到SpEL上下文中，对于集合中的每个元素。这意味着如果你的方法返回一个包含100个元素的集合，SpEL表达式将对每个元素进行评估。'
- en: The SpEL expression must return a Boolean value. If the expression evaluates
    to true, the object will remain in the collection, while if the expression evaluates
    to false, the object will be removed.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: SpEL表达式必须返回一个布尔值。如果表达式计算结果为真，对象将保留在集合中，而如果表达式计算结果为假，对象将被移除。
- en: In most cases, you'll find that collection post filtering saves you from the
    complexity of writing boilerplate code that you would likely be writing anyway.
    Take care that you understand how `@PostFilter` works conceptually; unlike `@PreAuthorize`,
    `@PostFilter` specifies method behavior and not a precondition. Some object-oriented
    purists may argue that `@PostFilter` isn't appropriate for inclusion as a method
    annotation, and such filtering should instead be handled through code in a method
    implementation.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你会发现集合后过滤可以节省你编写样板代码的复杂性，这些代码你本来可能就会写。注意你要理解`@PostFilter`是如何工作的概念；与`@PreAuthorize`不同，`@PostFilter`指定方法行为，而不是预条件。一些面向对象纯洁主义者可能会认为`@PostFilter`不适合作为方法注解包含在内，而这样的过滤应该通过方法实现中的代码来处理。
- en: Safety of collection filtering
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 集合过滤的安全性
- en: Be aware that the actual collection returned from your method will be modified!
    In some cases, this isn't desirable behavior, so you should ensure that your method
    returns a collection that can be safely modified. This is especially important
    if the returned collection is an ORM-bound one, as post-filter modifications could
    inadvertently be persisted to the ORM data store!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您方法返回的实际集合将被修改！在某些情况下，这不是期望的行为，所以您应该确保您的方法返回一个可以安全修改的集合。如果返回的集合是一个ORM绑定的集合，这一点尤为重要，因为后过滤修改可能会无意中持久化到ORM数据存储！
- en: Spring Security also offers functionality to prefilter method parameters that
    are collections; let's try implementing that now.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security还提供了预过滤方法参数的功能；我们现在尝试实现这个功能。
- en: Prefiltering collections with @PreFilter
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用@PreFilter预过滤集合
- en: 'The `@PreFilter` annotation can be applied to a method to filter collection
    elements that are passed into a method based on the current security context.
    Functionally, once it has a reference to a collection, this annotation behaves
    exactly the same as the `@PostFilter` annotation, with a couple of exceptions,
    as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`@PreFilter`注解可以应用于一个方法，根据当前的安全上下文过滤传递给方法的集合元素。功能上，一旦它有一个集合的引用，这个注解的行为与`@PostFilter`注解完全相同，有几个例外：'
- en: The `@PreFilter` annotation supports only collection arguments and does not
    support array arguments.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@PreFilter`注解只支持集合参数，不支持数组参数。'
- en: The `@PreFilter` annotation takes an additional, optional `filterTarget` attribute
    which is used to specifically identify the method parameter and filter it when
    the annotated method has more than one argument.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@PreFilter`注解有一个额外的可选`filterTarget`属性，用于特定地标识方法参数，并在注解的方法有多个参数时对其进行过滤。'
- en: As with `@PostFilter`, keep in mind that the original collection passed to the
    method is permanently modified. This may not be desirable behavior, so ensure
    that callers know that the collection's security may be trimmed after the method
    is invoked!
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与`@PostFilter`类似，请记住传递给方法的原集合会被永久修改。这可能不是期望的行为，所以要确保调用者知道在方法被调用后集合的安全性可能会被剪裁！
- en: 'Imagine if we had a `save` method that accepted a collection of event objects,
    and we wanted to only allow the saving of events that were owned by the currently
    logged in user. We could do this as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 想象如果我们有一个`save`方法，它接受一个事件对象的集合，我们只想允许保存当前登录用户拥有的事件。我们可以这样做：
- en: '[PRE28]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Much like our `@PostFilter` method, this annotation causes Spring Security to
    iterate over each event with the loop variable `filterObject`. It then compares
    the current user's ID against the event owner's ID. If they match, the event is
    retained. If they do not match, the result is discarded.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的`@PostFilter`方法类似，这个注解导致Spring Security遍历每个事件，循环变量`filterObject`。然后，它将当前用户的ID与事件所有者的ID进行比较。如果它们匹配，保留该事件。如果不匹配，则丢弃结果。
- en: Comparing method authorization types
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较方法授权类型
- en: 'The following quick reference chart may assist you in selecting a type of method
    authorization check to use:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下快速参考图表可能有助于您选择使用哪种方法授权检查类型：
- en: '| **Method authorization type** | **Specified as** | **JSR standard** | **Allows
    SpEL expressions** |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| **方法授权类型** | **指定为** | **JSR标准** | **允许SpEL表达式** |'
- en: '| `@PreAuthorize``@PostAuthorize` | Annotation | No | Yes |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `@PreAuthorize``@PostAuthorize` | 注解 | 否 | 是 |'
- en: '| `@RolesAllowed`, `@PermitAll`, `@DenyAll` | Annotation | Yes | No |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `@RolesAllowed`, `@PermitAll`, `@DenyAll` | 注解 | 是 | 否 |'
- en: '| `@Secure` | Annotation | No | No |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `@Secure` | 注解 | 否 | 否 |'
- en: '| `protect-pointcut` | XML | No | No |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `protect-pointcut` | XML | 否 | 否 |'
- en: Most Java 5 consumers of Spring Security will probably opt to use the JSR-250
    annotations for maximum compatibility and reuse their business classes (and relevant
    constraints) across an IT organization. Where needed, these basic declarations
    can be replaced with the annotations that tie the code to the Spring Security
    implementation itself.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数使用Spring Security的Java 5消费者可能会选择使用JSR-250注解，以实现最大程度的兼容性，并在IT组织中重用他们的业务类（和相关约束）。在需要时，这些基本声明可以被与代码绑定到Spring
    Security实现的注解所替代。
- en: If you are using Spring Security in an environment that doesn't support annotations
    (Java 1.4 or previous), unfortunately, your choices are somewhat limited to method
    security enforcement. Even in this situation, the use of AOP provides a reasonably
    rich environment in which we can develop basic security declarations.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在支持注解的环境中使用Spring Security（Java 1.4或更早），不幸的是，您的选择相当有限，只能使用方法安全强制。即使在这种情况，AOP的使用为我们提供了一个相当丰富的环境，我们可以开发基本的安全声明。
- en: Practical considerations for annotation-based security
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于注解的安全性实际考虑
- en: One thing to consider is that when returning a collection of real-world applications,
    there is likely to be some sort of paging. This means that our `@PreFilter` and
    `@PostFilter` annotations cannot be used as the sole means of selecting which
    objects to return. Instead, we need to ensure that our queries only select the
    data that the user is allowed to access. This means that the security annotations
    become redundant checks. However, it is important to remember our lesson at the
    beginning of this chapter; we want to secure layers in case one layer is able
    to be bypassed.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的一件事是，当返回现实世界应用的集合时，很可能会有某种形式的分页。这意味着我们的`@PreFilter`和`@PostFilter`注解不能作为选择返回哪些对象的唯手段。相反，我们需要确保我们的查询只选择用户允许访问的数据。这意味着安全注解变成了重复检查。然而，重要的是要记住我们在这章开头学到的教训；我们希望保护层，以防一个层能够被绕过。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered most of the remaining areas in standard Spring
    Security implementations that deal with authorization. We've learned enough to
    take a thorough pass through the JBCP calendar application and verify that proper
    authorization checks are in place in all tiers of the application, to ensure that
    malicious users cannot manipulate or access data to which they do not have access.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经涵盖了标准Spring Security实现中处理授权的大部分剩余领域。我们已经学到了足够多的知识，可以彻底检查JBCP日历应用程序，并验证在应用程序的所有层中是否已经设置了适当的授权检查，以确保恶意用户无法操纵或访问他们无法访问的数据。
- en: We developed two techniques for micro-authorization, namely filtering out in-page
    content based on authorization or other security criteria using the Thymeleaf
    Spring Security tag library and Spring MVC controller data binding. We also explored
    several methods of securing business functions and data in the business tier of
    our application and supporting a rich, declarative security model that was tightly
    integrated with the code. We also learned how to secure our Spring MVC controllers
    and the differences between interface and class proxy objects
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开发了两种微授权技术，分别是使用Thymeleaf Spring Security标签库和Spring MVC控制器数据绑定，基于授权或其他安全标准过滤页面内容。我们还探索了几种方法，在应用程序的业务层中保护业务功能和数据，并支持一个紧密集成到代码中的丰富声明式安全模型。我们还学习了如何保护我们的Spring
    MVC控制器以及接口和类代理对象之间的区别。
- en: At this point, we've wrapped up coverage of much of the important Spring Security
    functionality that you're likely to encounter in most standard, secure web application
    development scenarios.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，我们已经涵盖了大多数在标准、安全的网络应用开发场景中可能遇到的Spring Security功能。
- en: In the next chapter, we will discuss the ACL (domain object model) module of
    Spring Security. This will allow us to explicitly declare authorization, rather
    than relying on existing data.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论Spring Security的ACL（域对象模型）模块。这将允许我们显式声明授权，而不是依赖现有数据。
- en: Access Control Lists
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问控制列表
- en: In this chapter, we will address the complex topic of **access control lists**
    (**ACL**), which can provide a rich model of domain object instance-level authorization.
    Spring Security ships with a robust, but complicated, access control list module
    that can serve the needs of small to medium-sized implementations reasonably well.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论复杂的话题**访问控制列表**（**ACL**），它可以提供一个丰富的域对象实例级授权模型。Spring Security附带了一个健壮但复杂的访问控制列表模块，可以满足小型到中型实现的合理需求。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Understanding the conceptual model of ACL
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解ACL的概念模型
- en: Reviewing the terminology and application of ACL concepts in the Spring Security
    ACL module
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾Spring Security ACL模块中ACL概念的术语和应用
- en: Building and reviewing the database schema required to support Spring ACL
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和支持Spring ACL所需的数据库架构
- en: Configuring JBCP calendar to use ACL secured business methods via annotations
    and Spring beans
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过注解和Spring Bean配置JBCP日历以使用ACL安全的企业方法
- en: Performing advanced configuration, including customized ACL permissions, ACL-enabled
    JSP tag checks and method security, mutable ACLs, and smart caching
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行高级配置，包括自定义ACL权限、ACL启用的JSP标签检查和方法安全、可变ACL和智能缓存
- en: Examining architectural considerations and planning scenarios for ACL deployment
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查ACL部署的架构考虑和计划场景
- en: The conceptual module of ACL
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ACL的概念模块
- en: The final piece of the non-web tier security puzzle is security at the business
    object level, applied at or below the business tier. Security at this level is
    implemented using a technique known as ACL, or ACLs. Summing up the objective
    of ACLs in a single sentence-ACLs allow specification of a set of group permissions
    based on the unique combination of a group, business object, and logical operation.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 非网络层安全拼图的最后一块是业务对象级别的安全，应用于或低于业务层。在这个层次上，使用一种称为ACL的技术实现安全。用一句话总结ACL的目标-ACL允许基于组、业务对象和逻辑操作的独特组合指定一组权限。
- en: 'For example, an ACL declaration for JBCP calendar might declare that a given
    user has to write access to his or her own event. This can be shown as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，JBCP日历的ACL声明可能声明给定用户对其自己的事件具有写入权限。这可以表示如下：
- en: '| **Username** | **Group** | **Object** | **Permissions** |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| **用户名** | **组** | **对象** | **权限** |'
- en: '| `mick` |  | `event_01` | `read`, `write` |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `mick` |  | `event_01` | `read`, `write` |'
- en: '|  | `ROLE_USER` | `event_123` | `read` |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '|  | `ROLE_USER` | `event_123` | `read` |'
- en: '|  | `ANONYMOUS` | Any event | `none` |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '|  | `ANONYMOUS` | 任何事件 | `none` |'
- en: You can see that this ACL is eminently readable by a human-`mick` has `read`
    and `write` access to his own event (`event_01`); other registered users can read
    the events of `mick`, but anonymous users cannot. This type of rule matrix is,
    in a nutshell, what ACL attempts to synthesize about a secured system and its
    business data into a combination of code, access checking, and metadata. Most
    true ACL-enabled systems have extremely complex ACL lists, and may conceivably
    have millions of entries across the entire system. Although this sounds frighteningly
    complex, proper up-front reasoning and implementation with a capable security
    library can make ACL management quite feasible.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，这个ACL对人类来说是极易读的-`mick`有读取和写入自己事件（`event_01`）的权限；其他注册用户可以读取`mick`的事件，但匿名用户不能。这种规则矩阵，简而言之，就是ACL试图将安全系统及其业务数据合成代码、访问检查和元数据的组合。大多数真正的ACL支持系统具有极其复杂的ACL列表，在整个系统可能会有数百万条记录。尽管这听起来非常复杂，但使用有能力的安全库进行适当的预先推理和实施可以使ACL管理变得可行。
- en: 'If you use a Microsoft Windows or Unix/Linux-based computer, you experience
    the magic of ACLs every single day. Most modern computer operating systems use
    ACL directives as part of their file storage systems, allowing permission granting
    based on a combination of a user or group, file or directory, and permission.
    In Microsoft Windows, you can view some of the ACL capabilities of a file by right-clicking
    on a file and examining its security properties (Properties | Security), as shown
    in the following screenshot:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Microsoft Windows或Unix/Linux-based计算机，您每天都会体验到ACL的魔力。大多数现代计算机操作系统在其文件存储系统中使用ACL指令，允许基于用户或组、文件或目录以及权限的组合来授予权限。在Microsoft
    Windows中，您可以通过右键单击文件并查看其安全属性（属性 | 安全）来查看文件的一些ACL功能，如下面的屏幕截图所示：
- en: '![](img/83387a1a-85dd-4ca8-be30-b6a071debe15.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/83387a1a-85dd-4ca8-be30-b6a071debe15.png)'
- en: You will be able to see that the combinations of inputs to the ACL are visible
    and intuitive as you navigate through the various groups or users and permissions.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 您将能够看到，ACL的输入组合在您通过各种组或用户和权限导航时是可见且直观的。
- en: Access control lists in Spring Security
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security中的访问控制列表（ACL）
- en: Spring Security supports ACL-driven authorization checks against access to individual
    domain objects by individual users of the secured system. Much as in the OS filesystem
    example, it is possible to use the Spring Security ACL components to build logical
    tree structures of both business objects and groups or principals. The intersection
    of permissions (inherited or explicit) on both the requestor and the requestee
    is used to determine allowed access.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security支持针对 secured system中个别用户的个别域对象的ACL驱动的授权检查。就像在OS文件系统示例中一样，可以使用Spring
    Security ACL组件构建逻辑树结构，包括业务对象和组或主体。请求者和请求对象上权限（继承或明确）的交集用于确定允许的访问。
- en: It's quite common for users approaching the ACL capability of Spring Security
    to be overwhelmed by its complexity, combined with a relative dearth of documentation
    and examples. This is compounded by the fact that setting up the ACL infrastructure
    can be quite complicated, with many interdependencies and reliance on bean-based
    configuration mechanisms, which are quite unlike much of the rest of Spring Security
    (as you'll see in a moment when we set up the initial configuration).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 用户在接触Spring Security的ACL（访问控制列表）功能时，常常会因其复杂性而感到不知所措，加上相关文档和示例的相对匮乏，这种情况更是加剧。这还因为设置ACL基础架构可能相当复杂，有许多相互依赖性，并且依赖于基于bean的配置机制，这与Spring
    Security的其他部分大不相同（正如您在设置初始配置时所看到的）。
- en: The Spring Security ACL module was written to be a reasonable baseline, but
    users intending to build extensively on the functionality will likely run into
    a series of frustrating limitations and design choices, which have gone (for the
    most part) uncorrected as they were first introduced in the early days of Spring
    Security. Don't let these limitations discourage you! The ACL module is a powerful
    way to embed rich access controls in your application, and further scrutinize
    and secure user actions and data.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security ACL模块是为了提供一个合理的基线而编写的，但是打算在功能上进行大量扩展的用户可能会遇到一系列令人沮丧的限制和设计选择，这些限制和设计选择在Spring
    Security的早期阶段首次引入后（在很大程度上）一直没有得到纠正。不要让这些限制让您气馁！ACL模块是一种在您的应用程序中嵌入丰富访问控制的有效方式，并进一步审视和保护用户行为和数据。
- en: Before we dig into configuring Spring Security ACL support, we need to review
    some key terminology and concepts.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入配置Spring Security ACL支持之前，我们需要回顾一些关键的术语和概念。
- en: The main unit of secured actor identity in the Spring ACL system is the **Security
    Identity** (**SID**). The SID is a logical construct that can be used to abstract
    the identity of either an individual principal or a group (`GrantedAuthority`).
    The `SIDs` object defined by the ACL data model you construct are used as the
    basis for explicit and derived access control rules, when determining the allowed
    level of access for a particular principal.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring ACL系统中，安全身份的主要单位是**安全身份**（**SID**）。SID是一个逻辑构造，可以用来抽象单个主题或组（`GrantedAuthority`）的身份。您构建的ACL数据模型中定义的`SIDs`对象用作确定特定主体的允许访问级别的明确和派生访问控制规则的基础。
- en: If `SIDs` are used to define actors in the ACL system, the opposite half of
    the security equation is the definition of the secured objects themselves. The
    identification of individual secured objects is called (unsurprisingly) an object
    identity. The default Spring ACL implementation of an object identity requires
    ACL rules to be defined at the individual object instance level, which means,
    if desired, every object in the system can have an individual access rule.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`SIDs`在ACL系统中定义参与者，那么安全方程的另一部分就是被保护对象本身的定义。单个受保护对象的识别称为对象身份（unsurprisingly）。默认的Spring
    ACL实现要求在单个对象实例级别定义ACL规则，这意味着，如果需要，系统中的每个对象都可以有各自的访问规则。
- en: 'Individual access rules are known as **Access Control Entries** (**ACEs**).
    An ACE is the combination of the following factors:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 个别访问规则被称为**访问控制条目**（**ACEs**）。一个ACE是以下因素的组合：
- en: The SID for the actor to which the rule applies
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于演员的SID
- en: The object identity to which the rule applies
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规则适用的对象身份
- en: The permission that should be applied to the given `SID` and the stated object
    identity
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应应用于给定`SID`和所述对象身份的权限
- en: Whether or not the stated permission should be allowed or denied for the given
    `SID` and object identity
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否应该允许或拒绝给定`SID`和对象身份的声明权限
- en: The purpose of the Spring ACL system as a whole is to evaluate each secured
    method invocation and determine whether the object or objects being acted on in
    the method should be allowed as per the applicable ACEs. Applicable ACEs are evaluated
    at runtime, based on the caller and the objects in play.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Spring ACL系统的整体目的是评估每个受保护的方法调用，并根据适用的ACE确定是否应该允许被方法操作的对象或对象。适用的ACE在运行时根据调用者和参与其中的对象进行评估。
- en: Spring Security ACL is flexible in its implementation. Although the majority
    of this chapter details the out-of-the-box functionality of the Spring Security
    ACL module, keep in mind, however, that many of the rules indicated represent
    default implementations, which in many cases can be overridden based on more complex
    requirements.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security ACL在其实现中是灵活的。尽管本章的大部分内容详细介绍了Spring Security ACL模块的默认功能，但请记住，许多指示的规则代表默认实现，在许多情况下可以根据更复杂的要求进行覆盖。
- en: 'Spring Security uses helpful value objects to represent the data associated
    with each of these conceptual entities. These are listed in the following table:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security使用有用的值对象来表示与这些概念实体相关的数据。这些如下表所示：
- en: '| **ACL conceptual object** | **Java object** |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| **ACL概念对象** | **Java对象** |'
- en: '| SID | `o.s.s.acls.model.Sid` |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| SID | `o.s.s.acls.model.Sid` |'
- en: '| Object identity | `o.s.s.acls.model.ObjectIdentity` |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| 对象身份 | `o.s.s.acls.model.ObjectIdentity` |'
- en: '| ACL | `o.s.s.acls.model.Acl` |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| ACL | `o.s.s.acls.model.Acl` |'
- en: '| ACE | `o.s.s.acls.model.AccessControlEntry` |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| ACE | `o.s.s.acls.model.AccessControlEntry` |'
- en: Let's work through the process of enabling Spring Security ACL components for
    a simple demonstration in the JBCP calendar application.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过启用Spring Security ACL组件的过程，对JBCP日历应用程序进行简单的演示。
- en: Basic configuration of Spring Security ACL support
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本配置Spring Security ACL支持
- en: Although we hinted previously that configuring ACL support in Spring Security
    requires bean-based configuration (which it does), you can use ACL support while
    retaining the simpler security XML namespace configuration if you choose. In the
    remaining examples in this chapter, we will be focusing on Java-based configuration.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们之前暗示过，在Spring Security中配置ACL支持需要基于bean的配置（确实如此），但如果你愿意，你可以保留更简单的安全XML命名空间配置同时使用ACL支持。在本章的剩余示例中，我们将关注基于Java的配置。
- en: Gradle dependencies
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gradle依赖关系
- en: 'As with most of the chapters, we will need to add some dependencies in order
    to use the functionality in this chapter. A list of the dependencies we have added
    with comments about when they are needed can be checked as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书的大部分章节一样，我们需要添加一些依赖项才能使用本章的功能。可以查看以下内容，了解我们添加的依赖项及其需要的时机：
- en: '[PRE29]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Defining a simple target scenario
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义一个简单的目标场景
- en: Our simple target scenario is to grant `user2@example.com` read access to only
    the birthday party event. All other users will not have any access to any events.
    You will observe that this differs from our other examples, since `user2@example.com`
    is not otherwise associated with the birthday party event.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的简单目标场景是只授予`user2@example.com`对生日派对事件的阅读权限。其他所有用户将无法访问任何事件。你会注意到这与我们其他例子有所不同，因为`user2@example.com`与其他任何事件都没有关联。
- en: Although there are several ways to set up ACL checking, our preference is to
    follow the annotation-based approach that we used in this chapter's method-level
    annotations. This nicely abstracts the use of ACLs away from the actual interface
    declarations and allows for replacement (if you want) of the role declarations
    with something other than ACLs at a later date (should you so choose).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然设置ACL检查有几种方法，但我们更喜欢遵循本章中方法级注解使用的基于注解的方法。这很好地将ACL的使用从实际的接口声明中抽象出来，并允许在稍后的日期（如果你愿意）用其他东西替换角色声明（如果你选择的话）。
- en: 'We''ll add an annotation to the `CalendarService.getEvents` method, which filters
    each event based upon the current user''s permission to the event:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向`CalendarService.getEvents`方法添加一个注解，根据当前用户对事件的权限过滤每个事件：
- en: '[PRE30]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You should be starting with `chapter12.00-calendar`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该从`chapter12.00-calendar`开始。
- en: Adding ACL tables to the H2 database
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向H2数据库添加ACL表
- en: The first thing we'll need to do is add the required tables and data to support
    persistent ACL entries in our in-memory H2 database. To do this, we'll add a new
    SQL DDL file and the corresponding data to our embedded-database declaration in
    `schema.sql`. We will break down each of these files later in the chapter.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要做的是向我们的内存中添加所需的支持持久ACL条目的表和数据。为此，我们将添加一个新的SQL DDL文件及其对应的数据到`schema.sql`中的嵌入式数据库声明。我们将在本章后面分解这些文件。
- en: 'We have included the following `schema.sql` file with this chapter''s source
    code, which is based upon the schema files included in the Spring Security reference''s
    Appendix, *Additional Reference Material*:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在此章节的源代码中包括了以下`schema.sql`文件，该文件基于Spring Security参考附录中的架构文件，即*附加参考材料*：
- en: '[PRE31]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The preceding code will result in the following database schema:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将导致以下数据库架构：
- en: '![](img/8267833a-9f6b-47fe-ab50-c901d55ac3fe.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8267833a-9f6b-47fe-ab50-c901d55ac3fe.png)'
- en: You can see how the concepts of `SIDs`, `OBJECT_IDENTITY`, and ACEs map directly
    to the database schema. Conceptually, this is convenient, as we can map our mental
    model of the ACL system and how it is enforced directly to the database.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`SIDs`、`OBJECT_IDENTITY`和ACEs的概念是如何直接映射到数据库架构的。从概念上讲，这是方便的，因为我们可以将我们对ACL系统的心理模型以及它是如何执行的直接映射到数据库。
- en: 'If you''ve cross-referenced this with the H2 database schema supplied with
    the Spring Security documentation, you''ll note that we''ve made a few tweaks
    that commonly bite users. These are as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将此与随Spring Security文档提供的H2数据库架构进行了交叉引用，你会注意到我们做了一些常见的用户陷阱的调整。这些如下：
- en: Change the `ACL_CLASS.CLASS` column to `500` characters, from the default value
    of `100`. Some long, fully qualified class names don't fit in `100` characters.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`ACL_CLASS.CLASS`列更改为`500`个字符，默认值为`100`。一些长完全限定类名不适合`100`个字符。
- en: Name the foreign keys with something meaningful so that failures are more easily
    diagnosed.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给外键命名一些有意义的名称，以便故障诊断更加容易。
- en: If you are using another database, such as Oracle, you'll have to translate
    the DDL into DDL and data types specific to your database.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用其他数据库，如Oracle，您将不得不将DDL翻译成特定于您数据库的DDL和数据类型。
- en: Once we configure the remainder of the ACL system, we'll return to the database
    to set up some basic ACEs to prove the ACL functionality in its most primitive
    form.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们配置了ACL系统的其余部分，我们将回到数据库中设置一些基本的ACE，以最原始的形式证明ACL功能。
- en: Configuring SecurityExpressionHandler
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置SecurityExpressionHandler
- en: We'll need to configure `<global-method-security>` to enable annotations (where
    we'll annotate based on the expected ACL privilege), and reference a custom access
    decision manager.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要配置`<global-method-security>`以启用注解（我们将基于预期的ACL权限进行注解），并引用一个自定义的访问决策管理器。
- en: 'We will also need to provide an `o.s.s.access.expression.SecurityExpressionHandler`
    implementation that is aware of how to evaluate permissions. Update your `SecurityConfig.java`
    configuration, as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要提供一个`o.s.s.access.expression.SecurityExpressionHandler`实现，使其知道如何评估权限。更新您的`SecurityConfig.java`配置，如下所示：
- en: '[PRE32]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is a bean reference to the `DefaultMethodSecurityExpressionHandler` object
    that we have defined in `AclConfig.java` file for you, as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对我们在`AclConfig.java`文件中定义的`DefaultMethodSecurityExpressionHandler`对象的bean引用，如下所示：
- en: '[PRE33]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'With even a relatively straightforward ACL configuration, as we have in our
    scenario, there are a number of required dependencies to set up. As we mentioned
    previously, the Spring Security ACL module comes out of the box with a number
    of components that you can assemble to provide a decent set of ACL capabilities.
    Note that all of the components that we''ll reference in the following diagram
    are part of the framework:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在我们 scenario 中有一个相对简单的ACL配置，也有许多必须设置的依赖项。如我们之前提到的，Spring Security ACL模块默认包含一组组件，您可以组装这些组件以提供一套不错的ACL功能。请注意，以下图表中引用的所有组件都是框架的一部分：
- en: '![](img/3d48ab85-ba85-4e90-bfe8-127df7e137a4.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3d48ab85-ba85-4e90-bfe8-127df7e137a4.png)'
- en: The AclPermissionCacheOptimizer object
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AclPermissionCacheOptimizer对象
- en: 'The `DefaultMethodSecurityExpressionHandler` object has two dependencies. The
    `AclPermissionCacheOptimizer` object is used to prime the cache with all of the
    ACLs for a collection of objects in a single JDBC select statement. The relatively
    simple configuration included with this chapter can be checked, as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`DefaultMethodSecurityExpressionHandler` 对象有两个依赖。`AclPermissionCacheOptimizer`
    对象用于用单个 JDBC 选择语句为对象集合的所有 ACL 填充缓存。本章包含的相对简单的配置可以按照如下方式进行检查：'
- en: '[PRE34]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Optimizing AclPermission Cache
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化 AclPermission 缓存
- en: 'The `DefaultMethodSecurityExpressionHandler` object then delegates to a `PermissionEvalulator`
    instance. For the purposes of this chapter, we are using ACLs so that the bean
    we will use `AclPermissionEvaluator`, which will read the ACLs that we define
    in our database. You can view the provided configuration for `permissionEvaluator`,
    as follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 `DefaultMethodSecurityExpressionHandler` 对象委派给一个 `PermissionEvalulator` 实例。在本章中，我们使用
    ACL 以便我们使用的 bean `AclPermissionEvaluator`，它将读取我们在数据库中定义的 ACL。您可以查看提供的 `permissionEvaluator`
    配置，如下所示：
- en: '[PRE35]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The JdbcMutableAclService object
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`JdbcMutableAclService` 对象'
- en: 'At this point, we have seen a reference to `th` with the `aclService` ID twice.
    The `aclService` ID resolves to an implementation of `o.s.s.acls.model.AclService`
    that is responsible (through delegation) for translating information about the
    object being secured by ACLs into expected ACEs:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在此点，我们看到了两次带有 `aclService` ID 的 `th` 引用。`aclService` ID 解析为一个负责将有关通过 ACL 受保护的对象的信息翻译成预期
    ACE 的 `o.s.s.acls.model.AclService` 实现：
- en: '[PRE36]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We'll use `o.s.s.acls.jdbc.JdbcMutableAclService`, which is the default implementation
    of `o.s.s.acls.model.AclService`. This implementation comes out of the box and
    is ready to use the schema that we defined in the last step of this exercise.
    The `JdbcMutableAclService` object will additionally use recursive SQL and post-processing
    to understand object and `SID` hierarchies and ensure that representations of
    these hierarchies are passed back to `AclPermissionEvaluator`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `o.s.s.acls.jdbc.JdbcMutableAclService`，这是 `o.s.s.acls.model.AclService`
    的默认实现。这个实现开箱即用，准备好使用我们在本练习的最后一步定义的架构。`JdbcMutableAclService` 对象还将使用递归 SQL 和后处理来理解对象和
    `SID` 层次结构，并确保这些层次结构的表示被传递回 `AclPermissionEvaluator`。
- en: The BasicLookupStrategy class
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本查找策略类
- en: 'The `JdbcMutableAclService` class uses the same JDBC `dataSource` instance
    that we''ve defined with the embedded database declaration, and it also delegates
    to an implementation of `o.s.s.acls.jdbc.LookupStrategy`, which is solely responsible
    for actually making database queries and resolving requests for ACLs. The only
    `LookupStrategy` implementation supplied with Spring Security is `o.s.s.acls.jdbc.BasicLookupStrategy`,
    and is defined as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`JdbcMutableAclService` 类使用了与我们定义的嵌入式数据库声明相同的 JDBC `dataSource` 实例，并且它还委派给
    `o.s.s.acls.jdbc.LookupStrategy` 的一个实现，该实现专门负责实际执行数据库查询和解析 ACL 请求。Spring Security
    提供的唯一 `LookupStrategy` 实现是 `o.s.s.acls.jdbc.BasicLookupStrategy`，如下定义：'
- en: '[PRE38]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, `BasicLookupStrategy` is a relatively complex beast. Remember that its
    purpose is to translate a list of the `ObjectIdentity` declarations to be protected
    into the actual, applicable ACE list from the database. As `ObjectIdentity` declarations
    can be recursive, this proves to be quite a challenging problem, and a system
    which is likely to experience heavy use should consider the SQL that's generated
    for performance impact on the database.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`BasicLookupStrategy` 是一个相当复杂的生物。记住它的目的是将需要保护的 `ObjectIdentity` 声明列表翻译成实际适用的数据库中的
    ACE 列表。由于 `ObjectIdentity` 声明可以是递归的，这证明是一个非常具有挑战性的问题，并且一个可能会经历大量使用的系统应考虑生成的 SQL
    对数据库性能的影响。
- en: Querying with the lowest common denominator
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用最低公倍数查询
- en: Be aware that `BasicLookupStrategy` is intended to be compatible with all databases
    by strictly sticking with standard ANSI SQL syntax, notably `left [outer] joins`.
    Some older databases (notably, **Oracle8i**) did not support this join syntax,
    so ensure that you verify that the syntax and structure of SQL is compatible with
    your particular database!
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`BasicLookupStrategy` 旨在通过严格遵循标准 ANSI SQL 语法与所有数据库兼容，特别是 `left [outer] joins`。一些较老的数据库（特别是
    **Oracle8i**）不支持这种连接语法，所以请确保您验证 SQL 的语法和结构与您特定的数据库兼容！
- en: There are also most certainly more efficient database-dependent methods of performing
    hierarchical queries using non-standard SQL, for example, Oracle's `CONNECT BY`
    statement and the **Common Table Expression** (**CTE**) capability of many other
    databases, including PostgreSQL and Microsoft SQL Server.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 肯定还有更多高效的数据库依赖方法执行层次查询，使用非标准SQL，例如，Oracle的`CONNECT BY`语句和其他许多数据库（包括PostgreSQL和Microsoft
    SQL Server）的**公共表表达式**（**CTE**）功能。
- en: Much as you learned in the example in [Chapter 4](04.html), *JDBC-Based Authentication*,
    using a custom schema for the `JdbcDaoImpl` implementation of the `UserDetailsService`
    properties are exposed to allow for configuration of the SQL utilized by `BasicLookupStrategy`.
    Consult the Javadoc and the source code itself to see how they are used so that
    they can be correctly applied to your custom schema.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[第4章](04.html)的例子中学习到的，*基于JDBC的认证*，使用自定义架构为`JdbcDaoImpl`实现的`UserDetailsService`属性暴露出来，允许配置`BasicLookupStrategy`使用的SQL。查阅Javadoc和源代码本身，看看它们是如何使用的，这样它们就可以正确地应用到你的自定义架构上。
- en: We can see that `LookupStrategy` requires a reference to the same JDBC `dataSource`
    instance that AclService utilizes. The other three references bring us almost
    to the end of the dependency chain.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`LookupStrategy`需要引用与AclService使用的相同的JDBC`dataSource`实例。其他三个引用让我们几乎到达依赖链的末端。
- en: EhCacheBasedAclCache
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`EhCacheBasedAclCache`'
- en: The `o.s.s.acls.model.AclCache` interface declares an interface for a caching
    `ObjectIdentity` to ACL mappings, to prevent redundant (and expensive) database
    lookups. Spring Security ships with only one implementation of `AclCache`, using
    the third-party library `Ehcache`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`o.s.s.acls.model.AclCache`接口声明了一个缓存`ObjectIdentity`到ACL映射的接口，以防止重复（且昂贵）的数据库查询。Spring
    Security只包含一个`AclCache`的实现，使用了第三方库`Ehcache`。'
- en: '`Ehcache` is an open source, memory and disk-based caching library that is
    widely used in many open source and commercial Java products. As mentioned earlier
    in the chapter, Spring Security ships with a default implementation of ACL caching,
    which relies on the availability of a configured `Ehcache` instance, which it
    uses to store ACL information in preference to reading ACLs from the database.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ehcache`是一个开源的基于内存和磁盘的缓存库，在许多开源和商业Java产品中被广泛使用。正如本章前面提到的，Spring Security包含一个ACL缓存的默认实现，它依赖于一个配置好的`Ehcache`实例，它使用这个实例来存储ACL信息，而不是从数据库中读取ACL。'
- en: While deep configuration of `Ehcache` is not something we want to cover in this
    section, we'll cover how Spring ACL uses the cache and walk you through a basic
    default configuration.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然深入配置`Ehcache`不是我们本节想要覆盖的内容，但我们会介绍Spring ACL如何使用缓存，并带你走过一个基本的默认配置。
- en: 'Setting up `Ehcache` is simple-we''ll simply declare `o.s.s.acls.domain.EhCacheBasedAclCache`
    along with its two dependent beans from Spring Core that manage `Ehcache` instantiation
    and expose several helpful configuration properties. Like our other beans, we
    have already provided the following configuration in `AclConfig.java`:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`Ehcache`很简单——我们只需声明`o.s.s.acls.domain.EhCacheBasedAclCache`以及从Spring Core中它的两个依赖bean，这些bean管理`Ehcache`的实例化和暴露几个有用的配置属性。像我们的其他bean一样，我们在`AclConfig.java`中已经提供了以下的配置：
- en: '[PRE39]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The ConsoleAuditLogger class
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`ConsoleAuditLogger`类'
- en: 'The next simple dependency hanging off of `o.s.s.acls.jdbc.BasicLookupStrategy`
    is an implementation of the `o.s.s.acls.domain.AuditLogger` interface, which is
    used by the `BasicLookupStrategy` class to audit ACL and ACE lookups. Similar
    to the `AclCache` interface, only one implementation is supplied with Spring Security
    that simply logs to the console. We''ll configure it with another one-line bean
    declaration:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 悬挂在`o.s.s.acls.jdbc.BasicLookupStrategy`上的下一个简单依赖是一个`o.s.s.acls.domain.AuditLogger`接口的实现，该接口由`BasicLookupStrategy`类用于审计ACL和ACE查询。与`AclCache`接口类似，Spring
    Security只提供了一个简单的日志到控制台的实现。我们将通过另一个单行bean声明来配置它：
- en: '[PRE40]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The AclAuthorizationStrategyImpl interface
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`AclAuthorizationStrategyImpl`接口'
- en: 'The final dependency to resolve is to an implementation of the `o.s.s.acls.domain.AclAuthorizationStrategy`
    interface, which actually has no immediate responsibility at all during the load
    of the ACL from the database. Instead, the implementation of this interface is
    responsible for determining whether a runtime change to an ACL or ACE is allowed,
    based on the type of change. We''ll explain more on this later when we cover mutable
    ACLs, as the logical flow is both somewhat complicated and not pertinent to getting
    our initial configuration complete. The final configuration requirements are as
    follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 需要解决的最后依赖关系是对`o.s.s.acls.domain.AclAuthorizationStrategy`接口的实现，该接口在从数据库加载ACL时实际上没有任何直接的职责。相反，实现此接口负责确定是否允许对ACL或ACE进行运行时更改，具体取决于更改的类型。我们稍后会在讲解可变ACL时解释更多，因为逻辑流程既有点复杂，又与完成初始配置无关。最终的配置要求如下：
- en: '[PRE41]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You might wonder what the reference to the bean with ID `adminAuthority` is
    for-`AclAuthorizationStrategyImpl` provides the ability to specify `GrantedAuthority`
    that is required to allow specific operations at runtime on mutable ACLs. We'll
    cover these later in this chapter.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道ID为`adminAuthority`的bean的引用是做什么的-`AclAuthorizationStrategyImpl`提供了指定在可变ACL上允许特定操作的`GrantedAuthority`的能力。我们将在本章后面覆盖这些内容。
- en: 'Lastly, we need to update our `SecurityConfig.java` file to load our `AclConfig.java`
    file, as follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更新我们的`SecurityConfig.java`文件，以加载我们的`AclConfig.java`文件，如下所示：
- en: '[PRE42]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We're finally done with the basic configuration of an out-of-the-box Spring
    Security ACL implementation. The next and final step requires that we insert a
    simple ACL and ACE into the H2 database and test it out!
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于完成了Spring Security ACL实现的初始配置。下一步也是最后一步，要求我们将一个简单的ACL和ACE插入到H2数据库中并测试它！
- en: Creating a simple ACL entry
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建简单ACL条目
- en: Recall that our very simple scenario is to only allow `user2@example.com` access
    to the birthday party event and ensure that no other events are accessible. You
    may find it helpful to refer back several pages to the database schema diagram
    to follow which data we are inserting and why.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们非常简单的场景是只允许`user2@example.com`访问生日派对事件，并确保其他事件无法访问。您可能发现回顾几页到数据库架构图有助于了解我们要插入的数据以及原因。
- en: We have already included a file named `data.sql` in the sample application.
    All of the SQL explained in this section will be from the file-you may feel free
    to experiment and add more test cases based on the sample SQL we've provided-in
    fact, we'd encourage that you experiment with sample data!
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在示例应用程序中包含了一个名为`data.sql`的文件。本节中解释的所有SQL都将来自该文件-您可以自由地基于我们提供的示例SQL进行实验和添加更多测试用例-实际上，我们鼓励您使用示例数据进行实验！
- en: 'Let''s take a look at the following steps for creating a simple ACL entry:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看创建简单ACL条目的以下步骤：
- en: 'First, we''ll need to populate the `ACL_CLASS` table with any or all of the
    domain object classes, which may have ACL rules-in the case of our example, this
    is simply our `Event` class:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要为任何或所有具有ACL规则的域对象类填充`ACL_CLASS`表-在我们示例的情况下，这仅仅是我们的`Event`类：
- en: '[PRE43]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We chose to use primary keys that are between `10` to `19` for the `ACL_CLASS`
    table, `20` to `29` for the `ACL_SID` table, and so on. This will help to make
    it easier to understand which data associates to which table. Note that our `Event`
    table starts with a primary key of `100`. These conveniences are done for example
    purposes and are not suggested for production purposes.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择为`ACL_CLASS`表使用主键10到19的数字，为`ACL_SID`表使用20到29的数字，以此类推。这将有助于更容易理解哪些数据与哪个表相关联。请注意，我们的`Event`表以主键100开始。这些便利措施仅为例证目的，不建议在生产环境中使用。
- en: Next, the `ACL_SID` table is seeded with `SIDs` that will be associated with
    the ACEs. Remember that `SIDs` can either be roles or users-we'll populate the
    roles and `user2@example.com` here.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，`ACL_SID`表用与ACE关联的`SID`进行初始化。请记住`SID`可以是角色或用户-我们在这里填充角色和`user2@example.com`。
- en: 'While the `SID` object for roles is straightforward, the `SID` object for a
    user is not quite as clear-cut. For our purposes, the username is used for the
    `SID`. To learn more about how the `SIDs` are resolved for roles and users, refer
    to `o.s.s.acls.domain.SidRetrievalStrategyImpl`. If the defaults do not meet your
    needs, a custom `o.s.s.acls.model.SidRetrievalStrategy` default can be injected
    into `AclPermissionCacheOptimizer` and `AclPermissionEvaluator`. We will not need
    this sort of customization for our example, but it is good to know that it is
    available if necessary:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然角色的`SID`对象很简单，但用户的`SID`对象并不是那么清晰。对我们来说，用户名用于`SID`。要了解更多关于如何为角色和用户解析`SID`，请参阅`o.s.s.acls.domain.SidRetrievalStrategyImpl`。如果默认值不符合您的需求，可以将自定义的`o.s.s.acls.model.SidRetrievalStrategy`默认值注入到`AclPermissionCacheOptimizer`和`AclPermissionEvaluator`中。在我们的示例中，我们不需要这种自定义，但是如果需要，知道它是可用的：
- en: '[PRE44]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The table where things start getting complicated is the `ACL_OBJECT_IDENTITY`
    table that is used to declare individual domain object instances, their parent
    (if any), and owning `SID`. For example, this table represents the `Event` objects
    that we are securing. We''ll insert a row with the following properties:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 事情开始变得复杂的是`ACL_OBJECT_IDENTITY`表，该表用于声明个别域对象实例、其父（如果有）和所有者`SID`。例如，这个表代表了我们要保护的`Event`对象。我们将插入具有以下属性的行：
- en: Domain object of type `Event` that is a foreign key, `10`, to our `ACL_CLASS`
    table via the `OBJECT_ID_CLASS` column.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型为`Event`的域对象，通过`OBJECT_ID_CLASS`列连接到我们的`ACL_CLASS`表，外键`10`。
- en: Domain object primary key of `100` (the `OBJECT_ID_IDENTITY` column). This is
    a foreign key (although not enforced with a database constraint) to our `Event`
    object.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 域对象的主键`100`（`OBJECT_ID_IDENTITY`列）。这是连接到我们的`Event`对象的外键（尽管不是通过数据库约束强制执行）。
- en: Owner `SID` of `user2@example.com`, which is a foreign key, `20`, to `ACL_SID`
    via the `OWNER_SID` column.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有者`SID`为`user2@example.com`，这是一个外键，`20`，通过`OWNER_SID`列连接到`ACL_SID`。
- en: 'The SQL to represent our events with IDs of `100` (birthday event), `101`,
    and `102` is as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 表示具有`100`（生日事件）、`101`和`102` ID的事件的SQL如下：
- en: '[PRE45]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Keep in mind that the owning `SID` could also represent a role-both types of
    rules function equally well as far as the ACL system is concerned.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，拥有的`SID`也可能代表一个角色-就ACL系统而言，这两种规则功能是相等的。
- en: 'Finally, we''ll add an ACE-related to this object instance, which declares
    that `user2@example.com` is allowed read access to the birthday event:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将向此对象实例添加一个与ACE相关的内容，声明`user2@example.com`被允许读取生日事件的权限：
- en: '[PRE46]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `MASK` column here represents a bitmask, which is used to grant permission
    assigned to the stated `SID` on the object in question. We'll explain the details
    of this later in this chapter-unfortunately, it doesn't tend to be as useful as
    it may sound.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`MASK`列代表一个位掩码，它用于授予分配给所述`SID`在问题对象上的权限。我们将在本章后面详细解释这一点-不幸的是，它可能没有听起来那么有用。
- en: Now, we can start the application and run through our sample scenario. Try logging
    in with `user2@example.com`/`user2` and accessing the All Events page. You will
    see that only the birthday event is listed. When logged in with `admin1@example.com`/`admin1`
    and viewing the All Events page, no events will be displayed. However, if we navigated
    directly to an event, it would not be protected. Can you figure out how to secure
    direct access to an event based on what you learned in this chapter?
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以启动应用程序并运行示例场景。尝试使用`user2@example.com`/`user2`登录并访问所有事件页面。您将看到只列出了生日事件。当使用`admin1@example.com`/`admin1`登录并查看所有事件页面时，将不会显示任何事件。但是，如果我们直接导航到某个事件，它将不受保护。您能根据本章学到的知识想出如何保护直接访问事件的方法吗？
- en: 'If you have not figured it out yet, you can secure direct access to an event
    by making the following update to `CalendarService`, as follows:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有弄清楚，您可以通过对`CalendarService`进行以下更新来保护直接访问事件：
- en: '[PRE47]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We now have a basic working setup of ACL-based security (albeit, a very simple
    scenario). Let's move on to some more explanation about concepts we saw during
    this walkthrough, and then review a couple of considerations in a typical Spring
    ACL implementation that you should consider before using it.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有了基于ACL的安全性的基本工作设置（尽管是一个非常简单的场景）。让我们继续解释一下我们在这次演练中看到的概念，然后回顾一下在典型 Spring
    ACL 实现中你应该考虑的几个问题。
- en: Your code should look like `chapter12.01-calendar`.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码应如下所示`chapter12.01-calendar`。
- en: 'It is worth noting that we have not created new ACL entries when we create
    events. Thus, in the current state, if you create an event, you will receive an
    error similar to the following:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们在创建事件时并没有创建新的ACL条目。因此，在当前状态下，如果您创建一个事件，您将收到一个类似于以下的错误：
- en: '`Exception during execution of Spring Security application! Unable to find
    ACL information for object identity org.springframework.security.acls.domain.ObjectIdentityImpl[Type:
    com.packtpub.springsecurity.domain.Event; Identifier: 103]`.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '`在Spring Security应用程序执行期间发生异常！无法为对象身份org.springframework.security.acls.domain.ObjectIdentityImpl[Type:
    com.packtpub.springsecurity.domain.Event; Identifier: 103]找到ACL信息`。'
- en: Advanced ACL topics
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级ACL主题
- en: Some high-level topics that we skimmed over during the configuration of our
    ACL environment had to do with ACE permissions and the use of the `GrantedAuthority`
    indicators to assist the ACL environment in determining whether certain types
    of runtime changes to ACLs were allowed. Now that we have a working environment,
    we'll review these more advanced topics.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在配置ACL环境时简要介绍的一些高级主题与ACE权限及使用`GrantedAuthority`指示器来帮助ACL环境确定是否允许对ACL进行某些类型的运行时更改有关。现在我们已经有了一个工作环境，我们将回顾这些更高级的主题。
- en: How permissions work
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 权限是如何工作的
- en: Permissions are no more than single logical identifiers represented by bits
    in an integer. An access control entry grants permissions to `SIDs` based on the
    bitmask, which comprises the logical AND of all permissions applicable to that
    access control entry.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 权限不过是表示为整数中的位的单个逻辑标识符。访问控制条目根据位掩码向`SIDs`授予权限，该位掩码是适用于该访问控制条目的所有权限的逻辑与。
- en: The default permission implementation, `o.s.s.acls.domain.BasePermission`, defines
    a series of integer values representing common ACL authorization verbs. These
    integer values correspond to single bits set in an integer, so a value of `BasePermission`,
    `WRITE`, with integer value `1` has a bitwise value of `21` or `2`.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的权限实现，`o.s.s.acls.domain.BasePermission`，定义了一系列代表常见ACL授权动词的整数值。这些整数值对应于整数中的单个位设置，所以一个值为`BasePermission`，`WRITE`，整数值为`1`的位掩码值为`21`或`2`。
- en: 'These are illustrated in the following diagram:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表进行了说明：
- en: '![](img/cde17926-2e18-4572-86a0-c523cd36964f.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cde17926-2e18-4572-86a0-c523cd36964f.png)'
- en: We can see that the **Sample** permission bitmask would have an integer value
    of **3**, due to the application of both the **Read** and **Write** permissions
    to the permission value. All of the standard integer single permission values
    shown in the preceding diagram are defined in the `BasePermission` object as static
    constants.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，**示例**权限位掩码的整数值为**3**，这是由于将**读取**和**写入**权限应用到权限值上。前面图表中显示的所有标准整数单个权限值都是在`BasePermission`对象中作为静态常量定义的。
- en: The logical constants that are included in `BasePermission` are just a sensible
    baseline of commonly used permissions in ACE, and have no semantic meaning within
    the Spring Security framework. It's quite common for very complex ACL implementations
    to invent their own custom permissions, augmenting best practice examples with
    domain- or business-dependent ones.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`BasePermission`中包含的逻辑常量只是ACE中常用权限的一个合理基线，并且在Spring Security框架内没有语义意义。在非常复杂的ACL实现中，通常会发明自己的自定义权限，用领域或业务依赖的权限来补充最佳实践示例。'
- en: One issue that often confuses users is how the bitmasks are used in practice,
    given that many databases either do not support bitwise logic or do not support
    it in a scalable way. Spring ACL intends to solve this problem by putting more
    of the load of calculating appropriate permissions related to bitmasks on the
    application rather than on the database.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 经常让用户感到困惑的一个问题是，在实际应用中位掩码是如何使用的，因为许多数据库要么不支持位逻辑，要么不支持以可扩展的方式实现位逻辑。Spring ACL旨在通过将计算与位掩码相关的适当权限的更多负载放在应用程序上，而不是放在数据库上，来解决这一问题。
- en: It's important to review the resolution process, where we see how `AclPermissionEvaluator`
    resolves permissions declared on the method itself (in our example, with the `@PostFilter`
    annotation) to real ACL permissions.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要回顾解析过程，在这个过程中我们看到`AclPermissionEvaluator`是如何解析声明在方法本身上的权限（在我们的例子中，使用`@PostFilter`注解）以得到真实的ACL权限的。
- en: 'The following diagram illustrates the process that Spring ACL performs to evaluate
    the declared permission against the relevant ACEs for the requesting principal:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了Spring ACL执行的过程，以将声明的权限与请求主体的相关ACEs进行评估：
- en: '![](img/3aace789-7e8e-437e-b33d-56dff2233b27.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3aace789-7e8e-437e-b33d-56dff2233b27.png)'
- en: We see that `AclPermissionEvaluator` relies on classes implementing two interfaces,
    `o.s.s.acls.model.ObjectIdentityRetrievalStrategy` and `o.s.s.acls.model.SidRetrievalStrategy`,
    to retrieve `ObjectIdentity` and `SIDs` appropriate for the authorization check.
    The important thing to note about these strategies is how the default implementation
    classes actually determine the `ObjectIdentity` and `SIDs` objects to return,
    based on the context of the authorization check.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现`AclPermissionEvaluator`依赖于实现两个接口的类，`o.s.s.acls.model.ObjectIdentityRetrievalStrategy`和`o.s.s.acls.model.SidRetrievalStrategy`，以检索适合授权检查的`ObjectIdentity`和`SIDs`。关于这些策略的重要一点是，默认实现类实际上是如何根据授权检查的上下文确定要返回的`ObjectIdentity`和`SIDs`对象的。
- en: The `ObjectIdentity` object has two properties, `type` and `identifier`, that
    are derived from the object being checked at runtime, and used to declare ACE
    entries. The default `ObjectIdentityRetrievalStrategy` interface uses the fully-qualified
    class name to populate the `type` property. The `identifier` property is populated
    with the result of a method with the signature `Serializable getId()`, invoked
    on the actual object instance.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObjectIdentity`对象有两个属性，`type`和`identifier`，它们是从运行时检查的对象派生的，并用于声明ACE条目。默认的`ObjectIdentityRetrievalStrategy`接口使用完全限定类名来填充`type`属性。`identifier`属性用实际对象实例上调用具有`Serializable
    getId()`签名的方法的返回值填充。'
- en: As your object isn't required to implement an interface to be compatible with
    ACL checks, the requirement to implement a method with a specific signature can
    be surprising for developers implementing Spring Security ACL. Plan ahead and
    ensure that your domain objects contain this method! You may also implement your
    own `ObjectIdentityRetrievalStrategy` class (or subclass the out-of-the-box implementation)
    to call a method of your choice. The name and type signature of the method is,
    unfortunately, not configurable.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你的对象不需要实现接口以与ACL检查兼容，开发人员实现Spring Security ACL时对需要实现具有特定签名的方法的惊讶是可以理解的。提前规划并确保你的领域对象包含这个方法！你也可以实现自己的`ObjectIdentityRetrievalStrategy`类（或继承内置实现）以调用你选择的方法。不幸的是，方法的名字和类型签名是不可配置的。
- en: Unfortunately, the actual implementation of `AclImpl` directly compares the
    permission specified in our SpEL expression specified in our `@PostFilter` annotation,
    and the permission stored on the ACE in the database, without using bitwise logic.
    The Spring Security community is in debate about whether this is unintentional
    or working as intended, but regardless, you will need to take care when declaring
    a user with a combination of permissions, as either `AclEntryVoter` must be configured
    with all combinations of permission, or the ACEs need to ignore the fact that
    the permission field is intended to store multiple values and instead store a
    single permission per ACE.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`AclImpl`的实际实现直接比较了我们`@PostFilter`注解中指定的SpEL表达式中的权限和我们数据库中存储的ACE上的权限，而没有使用位逻辑。Spring
    Security社区正在争论这是否是无意中发生的还是按预期工作的，但无论如何，当你声明具有多种权限组合的用户时，你必须小心，因为要么必须为`AclEntryVoter`配置所有权限的组合，要么ACE需要忽略权限字段是用来存储多个值的意图，而每个ACE存储一个权限。
- en: 'If you want to verify this with our simple scenario, change the `READ` permission
    we granted to the `user2@example.com` SID to the bitmask combination of `Read`
    and `Write`, which translates to a value of `3`. This would be updated in the
    `data.sql` file, as follows:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想用我们简单的场景来验证这一点，将我们授予`user2@example.com` SID的`READ`权限更改为位掩码组合`Read`和`Write`，这翻译为一个值为`3`。这将在`data.sql`文件中更新，如下所示：
- en: '[PRE48]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Your code should look like `chapter12.02-calendar`.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码应该看起来像`chapter12.02-calendar`。
- en: The custom ACL permission declaration
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义ACL权限声明
- en: As stated in the earlier discussion on permission declarations, permissions
    are nothing but logical names for integer bit values. As such, it's possible to
    extend the `o.s.s.acls.domain.BasePermission` class and declare your own permissions.
    We'll cover a very straightforward scenario here, where we create a new ACL permission
    called `ADMIN_READ`. This is a permission that will be granted only to administrative
    users and will be assigned to protect resources that only administrators could
    read. Although a contrived example for the JBCP calendar application, this type
    of use of custom permissions occurs quite often in situations dealing with personally
    identifiable information (for example, social security number, and so on-recall
    that we covered PII in [Chapter 1](01.html), *Anatomy of an Unsafe Application*).
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，权限声明中的权限不过是整数值的逻辑名称。因此，可以扩展`o.s.s.acls.domain.BasePermission`类并声明您自己的权限。在这里，我们将讨论一个非常简单的场景，即创建一个名为`ADMIN_READ`的新ACL权限。这是一个仅授予管理员的权限，用于保护只有管理员才能读取的资源。虽然这个例子对于JBCP日历应用程序来说有些牵强，但在处理个人可识别信息（例如，社会保障号码等——回想我们在[第1章](01.html)，*不安全应用程序的解剖学*中讨论的PII）的情况下，这种自定义权限的使用是非常常见的。
- en: 'Let''s get started making the changes required to support this by performing
    the following steps:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始进行支持此更改所需的更改，执行以下步骤：
- en: 'The first step is to extend the `BasePermission` class with our own `com.packtpub.springsecurity.acls.domain.CustomPermission`
    class, as follows:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是扩展`BasePermission`类，用我们自己的`com.packtpub.springsecurity.acls.domain.CustomPermission`类，如下所示：
- en: '[PRE49]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, we will need to configure the `o.s.s.acls.domain.PermissionFactory` default
    implementation, `o.s.s.acls.domain.DefaultPermissionFactory`, to register our
    custom permission logical value. The role of `PermissionFactory` is to resolve
    permission bitmasks into logical permission values (which can be referenced by
    the constant value, or by name, such as `ADMIN_READ`, in other areas of the application).
    The `PermissionFactory` instance requires that any custom permission is registered
    with it for proper lookup. We have included the following configuration that registers
    our `CustomPermission` class, as follows:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要配置`o.s.s.acls.domain.PermissionFactory`默认实现，`o.s.s.acls.domain.DefaultPermissionFactory`，以注册我们的自定义权限逻辑值。`PermissionFactory`的作用是将权限位掩码解析为逻辑权限值（在其他应用程序区域中可以通过常量值或名称，如`ADMIN_READ`来引用）。`PermissionFactory`实例需要任何自定义权限都向其注册以进行正确的查找。我们已包含以下配置，注册了我们的`CustomPermission`类，如下所示：
- en: '[PRE50]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, we will need to override the default `PermissionFactory` instance for
    our `BasicLookupStrategy` and `AclPermissionEvaluator` interfaces with the customized
    `DefaultPermissionFactory` interface. Make the following updates to your `security-acl.xml`
    file:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要覆盖我们`BasicLookupStrategy`和`AclPermissionEvaluator`接口的默认`PermissionFactory`实例，使用自定义的`DefaultPermissionFactory`接口。请按照以下步骤更新您的`security-acl.xml`文件：
- en: '[PRE51]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We also need to add the SQL query to utilize the new permission to grant access
    to the conference call (`acl_object_identity ID of 31`) event to `admin1@example.com`.
    Make the following updates to `data.sql`:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要添加SQL查询，以利用新权限向`admin1@example.com`授予对会议电话（`acl_object_identity ID为31`）事件的访问权限。请对`data.sql`进行以下更新：
- en: '[PRE52]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We can see that the new integer bitmask value of `32` has been referenced in
    the ACE data. This intentionally corresponds to our new `ADMIN_READ ACL` permission,
    as defined in Java code. The conference call event is referenced by its primary
    key (stored in the `object_id_identity` column) value of `31`, in the `ACL_OBJECT_IDENTITY`
    table.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，新的整数位掩码值`32`已在ACE数据中引用。这故意对应于我们在Java代码中定义的新`ADMIN_READ ACL`权限。在`ACL_OBJECT_IDENTITY`表中，会议电话事件通过其主键（存储在`object_id_identity`列）值`31`来引用。
- en: 'The last step is to update our `CalendarService''s getEvents()` method to utilize
    our new permission, as follows:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是更新我们的`CalendarService的getEvents()`方法，以利用我们的新权限，如下所示：
- en: '[PRE53]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'With all of these configurations in place, we can start up the site again and
    test out the custom ACL permission. Based on the sample data we have configured,
    here is what should happen when the various available users click on categories:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些配置就绪之后，我们可以重新启动网站并测试自定义ACL权限。根据我们配置的示例数据，当各种可用用户点击类别时，会发生以下情况：
- en: '| **Username/password** | **Birthday party event** | **Conference call event**
    | **Other events** |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| **用户名/密码** | **生日派对事件** | **电话会议事件** | **其他事件** |'
- en: '| `user2@example.com`/`user2` | Allowed via `READ` | Denied | Denied |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '```'
- en: '| `admin1@example.com`/`admin1` | Denied | Allowed via `ADMIN_READ` | Denied
    |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '```'
- en: '| `user1@example.com`/`user1` | Denied | Denied | Denied |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '```'
- en: We can see that even with the use of our simple cases, we've now been able to
    extend the Spring ACL functionality in a very limited way to illustrate the power
    of this fine-grained access control system.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，即使在我们使用简单示例的情况下，我们现在也能够在非常有限的方式上扩展Spring ACL功能，以说明这个细粒度访问控制系统的力量。
- en: Your code should look like `chapter12.03-calendar`.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码应该看起来像`chapter12.03-calendar`。
- en: Enabling ACL permission evaluation
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用ACL权限评估
- en: We saw in [Chapter 2](02.html), *Getting Started with Spring Security*, that
    the Spring Security JSP tag library offers functionality to expose authentication-related
    data to the user and to restrict what the user can see based on a variety of rules.
    So far in this book, we have used the Thymeleaf Security tag libraries that are
    built on top of Spring Security.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](02.html)中看到了Spring Security JSP标签库提供了将认证相关数据暴露给用户的功能，以及基于多种规则限制用户能看到的内容。在这本书中，我们一直使用的是建立在Spring
    Security之上的Thymeleaf安全标签库。
- en: 'The very same tag library can also interact with an ACL-enabled system right
    out of the box! From our simple experiments, we have configured a simple ACL authorization
    scenario around the first two categories in the list on the home page. Let''s
    take a look at the following steps and learn how to enable ACL permission evaluation
    in our Thymeleaf pages:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这个相同的标签库也可以与ACL启用的系统无缝交互！从我们的简单实验中，我们已经围绕主页上的前两个类别配置了一个简单的ACL授权场景。让我们来看看以下步骤，学习如何在Thymeleaf页面中启用ACL权限评估：
- en: 'First, we will need to remove our `@PostFilter` annotation from the `getEvents()`
    method in our `CalendarService` interface in order to give our JSP tag library
    a chance to filter out the events that are not allowed for display. Go ahead and
    remove `@PostFilter` now, as follows:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要从我们的`CalendarService`接口中的`getEvents()`方法移除`@PostFilter`注解，以便给我们的JSP标签库一个过滤掉不允许显示的事件的机会。现在就移除`@PostFilter`，如下所示：
- en: '[PRE54]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now that we have removed `@PostFilter`, we can utilize the `<sec:authorize-acl>`
    tag to hide the events that the user doesn't actually have access to. Refer to
    the table in the preceding section as a refresher of the access rules we've configured
    up to this point!
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经移除了`@PostFilter`，我们可以使用`<sec:authorize-acl>`标签来隐藏用户实际上没有访问权限的事件。回顾一下前一部分的表格，作为对我们迄今为止配置的访问规则的刷新！
- en: 'We''ll wrap the display of each event with the **`<sec:authorize-acl>`** tag,
    declaring the list of permissions to check on the object to be displayed:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将用**`<sec:authorize-acl>`**标签包裹每个事件的显示，声明要检查的对象的权限列表：
- en: '[PRE55]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Think for a moment about what we want to occur here-we want the user to see
    only the items to which they actually have the `READ` or `ADMIN_READ` (our custom
    permission) access. However, to use the tag library, we need to use the permission
    mask, which can be referenced from the following table:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 思考一下这里想要发生的事情-我们想要用户只看到他们实际具有`READ`或`ADMIN_READ`（我们的自定义权限）访问的项。然而，为了使用标签库，我们需要使用权限掩码，该掩码可以从以下表格中引用：
- en: '| **Name** | **Mask** |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '```'
- en: '| `READ` | `1` |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '```'
- en: '| `WRITE` | `2` |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '```'
- en: '| `ADMIN_READ` | `32` |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '```'
- en: Behind the scenes, the tag implementation utilizes the same `SidRetrievalStrategy`
    and `ObjectIdentityRetrievalStrategy` interfaces discussed earlier in this chapter.
    So, the computation of access checking follows the same workflow as it does with
    ACL-enabled voting on method security. As we will see in a moment, the tag implementation
    will also use the same `PermissionEvaluator`.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，标签实现利用了本章早些时候讨论过的相同的`SidRetrievalStrategy`和`ObjectIdentityRetrievalStrategy`接口。因此，访问检查的计算遵循与ACL启用的方法安全投票相同的
    workflow。正如我们即将看到的，标签实现还将使用相同的`PermissionEvaluator`。
- en: We have already configured our `GlobalMethodSecurityConfiguration` configuration
    with an `expressionHandler` element that references `DefaultMethodSecurityExpressionHandler`.
    The `DefaultMethodSecurityExpressionHandler` implementation is aware of our `AclPermissionEvaluator`
    interface, but we must also make Spring Security's web tier aware of `AclPermissionEvalulator`.
    If you think about it, this symmetry makes sense, since securing methods and HTTP
    requests are protecting two very different resources. Fortunately, Spring Security's
    abstractions make this rather simple.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经用一个引用`DefaultMethodSecurityExpressionHandler`的`expressionHandler`元素配置了我们的`GlobalMethodSecurityConfiguration`。`DefaultMethodSecurityExpressionHandler`实现认识我们的`AclPermissionEvaluator`接口，但我们还必须让Spring
    Security的web层认识`AclPermissionEvaluator`。如果你仔细思考，这种对称性是合理的，因为保护和HTTP请求是保护两种非常不同的资源。幸运的是，Spring
    Security的抽象使这一切变得相当简单。
- en: 'Add a `DefaultWebSecurityExpressionHandler` handler that references the bean
    with the ID as `permissionEvaluator` that we have already defined:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个引用我们已经定义的ID为`permissionEvaluator`的bean的`DefaultWebSecurityExpressionHandler`处理器：
- en: '[PRE56]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, update `SecurityConfig.java` to refer to our `webExpressionHandler` implementation,
    as follows:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更新`SecurityConfig.java`以引用我们的`webExpressionHandler`实现，如下所示：
- en: '[PRE57]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: You can see how these steps are very similar to how we added support for permission
    handling to our method security. This time, it was a bit simpler, since we were
    able to reuse the same bean with ID as `PermissionEvaluator` that we already configured.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这些步骤与我们向方法安全添加权限处理的方式非常相似。这次简单一些，因为我们能够重用已经配置的具有`PermissionEvaluator` ID的相同bean。
- en: Start up our application and try accessing the All Events page as different
    users. You will find that the events that are not allowed for a user are now hidden
    using our tag library instead of the `@PostFilter` annotation. We are still aware
    that accessing an event directly would allow a user to see it. However, this could
    easily be added by combining what you learned in this chapter with what you learned
    about the `@PostAuthorize` annotation in this chapter.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 启动我们的应用程序，并以不同的用户身份尝试访问所有事件页面。你会发现，不允许用户查看的事件现在使用我们的标签库隐藏，而不是`@PostFilter`注解。我们知道，直接访问事件会让用户看到它。然而，这可以通过将本章中学到的内容与本章中学到的关于`@PostAuthorize`注解的内容相结合轻松实现。
- en: Your code should look like `chapter12.04-calendar`.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码应该看起来像`chapter12.04-calendar`。
- en: Mutable ACLs and authorization
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变ACL和授权
- en: Although the JBCP calendar application doesn't implement full user administration
    functionality, it's likely that your application will have common features, such
    as new user registration and administrative user maintenance. To this point, lack
    of these features-which we have worked around using SQL inserts at application
    startup-hasn't stopped us from demonstrating many of the features of Spring Security
    and Spring ACL.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管JBCP日历应用程序没有实现完整的用户管理功能，但您的应用程序很可能会有常见功能，例如新用户注册和行政用户维护。到目前为止，这些功能的缺失（我们通过在应用程序启动时使用SQL插入解决了这个问题）并没有阻止我们演示Spring
    Security和Spring ACL的许多功能。
- en: However, the proper handling of runtime changes to declared ACLs, or the addition
    or removal of users in the system, is critical to maintaining the consistency
    and security of the ACL-based authorization environment. Spring ACL solves this
    issue through the concept of the mutable ACL (`o.s.s.acls.model.MutableAcl`).
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正确处理声明ACL的运行时更改，或系统中的用户添加或删除，对于维护ACL基础授权环境的完整性和安全性至关重要。Spring ACL通过可变ACL（`o.s.s.acls.model.MutableAcl`）的概念解决了这个问题。
- en: Extending the standard ACL interface, the `MutableAcl` interface allows for
    runtime manipulation of ACL fields in order to change the in-memory representation
    of a particular ACL. This additional functionality includes the ability to create,
    update, or delete ACEs, change ACL ownership, and other useful functions.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展标准ACL接口，`MutableAcl`接口允许在运行时操纵ACL字段，以改变特定ACL的内存表示。这包括创建、更新或删除ACE的能力，更改ACL所有者，以及其他有用功能。
- en: We might expect, then, that the Spring ACL module would come out of the box
    with a way to persist runtime ACL changes to the JDBC datastore, and indeed it
    does. The `o.s.s.acls.jdbc.JdbcMutableAclService` class may be used to create,
    update, and delete the `MutableAcl` instances in the database, as well as to do
    general maintenance on the other supporting tables for ACLs (handling `SIDs`,
    `ObjectIdentity`, and domain object class names).
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能期望，Spring ACL模块会默认提供一种将运行时ACL更改持久化到JDBC数据存储的方法，的确如此。可以使用`o.s.s.acls.jdbc.JdbcMutableAclService`类来创建、更新和删除数据库中的`MutableAcl`实例，以及执行ACL的其他支持表的一般维护（处理`SIDs`、`ObjectIdentity`和域对象类名）。
- en: 'Recall from earlier in the chapter that the `AclAuthorizationStrategyImpl`
    class allows us to specify the administrative role for actions on mutable ACLs.
    These are supplied to the constructor as part of the bean configuration. The constructor
    arguments and their meaning are as follows:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的早期部分提到，`AclAuthorizationStrategyImpl`类允许我们为可变ACL上的操作指定管理角色。这些是在bean配置中作为构造函数的一部分提供的。构造函数参数及其含义如下：
- en: '| **Arg #** | **What it does?** |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '| **参数编号** | **它做什么？** |'
- en: '| 1 | Indicates the authority that a principal is required to have in order
    to take ownership of an ACL-protected object at runtime |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 表示主体需要具有的权限，以在运行时获取ACL保护对象的所有权 |'
- en: '| 2 | Indicates the authority that a principal is required to have in order
    to change the auditing of an ACL-protected object at runtime |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 表示主体需要具有的权限，以在运行时更改ACL保护对象的审计|'
- en: '| 3 | Indicates the authority that a principal is required to have in order
    to make any other kind of change (create, update, and delete) to an ACL-protected
    object at runtime |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 表示主体需要具有的权限，以在运行时对ACL保护的对象进行任何其他类型的更改（创建、更新和删除）|'
- en: It may be confusing that we only specified a single constructor argument when
    there are three arguments listed. The AclAuthorizationStrategyImpl class can also
    accept a single `GrantedAuthority`, which will then be used for all three arguments.
    This is convenient if we want the same `GrantedAuthority` to be used for all of
    the operations.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有所困惑，我们只指定了一个构造函数参数，尽管列出了三个参数。`AclAuthorizationStrategyImpl`类还可以接受一个`GrantedAuthority`，然后将其用于所有三个参数。如果我们要对所有操作使用相同的`GrantedAuthority`，这非常方便。
- en: The JdbcMutableAclService interface contains a number of methods used to manipulate
    ACL and ACE data at runtime. While the methods themselves are fairly understandable
    (`createAcl`, `updateAcl`, and `deleteAcl`), the correct way to configure and
    use `JdbcMutableAclService` is often difficult for even advanced Spring Security
    users.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '`JdbcMutableAclService`接口包含用于在运行时操作ACL和ACE数据的一系列方法。尽管这些方法本身相对容易理解（`createAcl`、`updateAcl`和`deleteAcl`），但即使是高级Spring
    Security用户，配置和使用`JdbcMutableAclService`的正确方式也往往很难掌握。'
- en: Let's modify `CalendarService` to create a new ACL for newly created events.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改`CalendarService`以创建新事件的新的ACL。
- en: Adding ACLs to newly created events
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向新创建的事件添加ACL
- en: Currently, if a user creates a new event, it will not be visible to the user
    in the All Events view, since we are using the `<sec:authorize-acl>` tag to only
    display event objects that the user has access to. Let's update our `DefaultCalendarService`
    interface so that when a user creates a new event, they are granted read access
    to that event and it will be displayed for them on the All Events page.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如果用户创建了一个新事件，它将不会在所有事件视图中显示给用户，因为我们使用`<sec:authorize-acl>`标签只显示用户有权访问的事件对象。让我们更新我们的`DefaultCalendarService`接口，以便当用户创建一个新事件时，他们被授予读取该事件的权限，并且它将显示在所有事件页面上。
- en: 'Let''s take a look at the following steps to add ACLs to newly created events:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看以下步骤，以将ACL添加到新创建的事件中：
- en: 'The first step is to update our constructor to accept `MutableAclService and
    UserContext`:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是更新我们的构造函数以接受`MutableAclService和UserContext`：
- en: '[PRE58]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then, we need to update our `createEvent` method to also create an ACL for
    the current user. Make the following changes:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要更新我们的`createEvent`方法，以也为当前用户创建ACL。进行以下更改：
- en: '[PRE59]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `JdbcMutableAclService` interface uses the current user as the default owner
    for the created `MutableAcl` interface. We chose to explicitly set the owner again
    to demonstrate how this can be overridden.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`JdbcMutableAclService`接口使用当前用户作为创建的`MutableAcl`接口的默认所有者。我们选择再次显式设置所有者，以展示如何覆盖此设置。'
- en: We then add a new ACE and save our ACL. That's all there is to it.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们添加一个新的ACE并保存我们的ACL。就是这样。
- en: Start the application and log in with `user1@example.com`/`user1`.
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动应用程序，使用`user1@example.com`/`user1`登录。
- en: Visit the All Events page and see that there are no events currently listed.
    Then, create a new event and it will be displayed the next time you visit the
    All Events page. If you log in as any other user, the event will not be visible
    on the All Events page. However, it will potentially be visible to the user, since
    we have not applied security to other pages. Again, we encourage you to attempt
    to secure these pages on your own.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问“所有事件”页面，发现目前没有列出任何事件。然后，创建一个新事件，下次访问“所有事件”页面时它将显示出来。如果你以其他任何用户身份登录，事件将不会在“所有事件”页面上显示。但是，对于其他用户来说，它可能是可见的，因为我们还没有对其他页面应用安全性。再次强调，我们鼓励你自己尝试保护这些页面。
- en: Your code should look like `chapter12.05-calendar`.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码应该看起来像`chapter12.05-calendar`。
- en: Considerations for a typical ACL deployment
  id: totrans-462
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 典型ACL部署的考虑因素
- en: Actually deploying Spring ACL in a true business application tends to be quite
    involved. We wrap up coverage of Spring ACL with some considerations that arise
    in most Spring ACL implementation scenarios.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在真正的商业应用程序中部署Spring ACL往往相当复杂。我们总结了Spring ACL的覆盖范围，并提出了一些在大多数Spring ACL实现场景中出现的问题。
- en: ACL scalability and performance modeling
  id: totrans-464
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ACL的可扩展性与性能建模
- en: For small and medium-sized applications, the addition of ACLs is quite manageable,
    and while it adds overhead to database storage and runtime performance, the impact
    is not likely to be significant. However, depending on the granularity with which
    ACLs and ACEs are modeled, the numbers of database rows in a medium- to the large-sized
    application can be truly staggering and can task even the most seasoned database
    administrator.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 对于中小型应用程序，添加ACL是相当可管理的，尽管它增加了数据库存储和运行时性能的开销，但影响可能不是很大。然而，根据ACL和ACE建模的粒度，中型到大型应用程序的数据库行数可能非常惊人，甚至让最有经验的数据库管理员都感到任务繁重。
- en: 'Let''s assume we were to extend ACLs to cover an extended version of the JBCP
    calendar application. Let''s assume that users can manage accounts, post pictures
    to events, and administer (add/remove users) from an event. We''ll model the data
    as follows:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们要将ACL扩展到JBCP日历应用程序的扩展版本。假设用户可以管理账户，向事件发布图片，以及从一个事件中添加/删除用户。我们将按照以下方式建模数据：
- en: All users have accounts.
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有用户都有账户。
- en: 10% of users are able to administer an event. The average number of events that
    a user can administer will be two.
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10%的用户能够管理一个事件。平均每个用户能够管理的事件数量将是两个。
- en: Events will be secured (read-only) per customer, but also need to be accessible
    (read/write) by administrators.
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件将按客户 secured（只读），但还需要由管理员（读写）访问。
- en: 10 percent of all customers will be allowed to post pictures. The average number
    of posts per user will be 20.
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有客户的10%将被允许发布图片。每个用户的平均发布数量将是20。
- en: Posted pictures will be secured (read-write) per user, as well as administrators.
    Posted pictures will be read-only for all other users.
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布的图片将按用户 secured（读写），以及管理员。发布的图片对所有其他用户将是只读的。
- en: 'Given what we know about the ACL system, we know that the database tables have
    the following scalability attributes:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们对ACL系统的了解，我们知道数据库表具有以下可扩展性属性：
- en: '| **Table** | **Scales with data** | **Scalability notes** |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '| **表格** | **与数据相关联** | **可扩展性说明** |'
- en: '| `ACL_CLASS` | No | One row is required per domain class. |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| `ACL_CLASS` | 否 | 每种域类需要一行。 |'
- en: '| `ACL_SID` | Yes (users) | One row is required per role (`GrantedAuthority`).
    One row is required for each user account (if individual domain objects are secured
    per user). |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '| `ACL_SID` | 是（用户） | 每个角色（`GrantedAuthority`）需要一行。如果按用户账户个别域对象进行安全保护，则每个用户账户需要一行。
    |'
- en: '| `ACL_OBJECT_IDENTITY` | Yes (domain class instances per class) | One row
    is required per instance of a secured domain object. |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
  zh: '| `ACL_OBJECT_IDENTITY` | 是（按类的安全域对象实例） | 每个安全域对象实例需要一行。 |'
- en: '| `ACL_ENTRY` | Yes (domain object instances individual ACE entries) | One
    row is required per ACE; may require multiple rows for a single domain object.
    |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '| `ACL_ENTRY` | 是（按域对象实例个别ACL条目） | 每个ACL条目需要一行；对于单个域对象可能需要多行。 |'
- en: We can see that `ACL_CLASS` doesn't really have scalability concerns (most systems
    will have fewer than 1,000 domain classes). The `ACL_SID` table will scale linearly
    based on the number of users in the system. This is probably not a matter of concern
    because other user-related tables will scale in this fashion as well (user account,
    and so on).
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`ACL_CLASS`实际上并没有可扩展性担忧（大多数系统将具有少于1,000个域类）。`ACL_SID`表将根据系统中的用户数量线性扩展。这可能不是一个问题，因为其他与用户相关的表也将以这种方式扩展（用户帐户等）。|
- en: 'The two tables of concern are `ACL_OBJECT_IDENTITY` and `ACL_ENTRY`. If we
    model the estimated rows required to model an order for an individual customer,
    we come up with the following estimates:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 关注的两个表是`ACL_OBJECT_IDENTITY`和`ACL_ENTRY`。如果我们为个别客户建模订单所需的估计行数，我们得出以下估计：|
- en: '| **Table** | **ACL data per event** | **ACL data per picture post** |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
  zh: '| **Table** | **每个事件的ACL数据** | **每个图片帖子的ACL数据** |'
- en: '| `ACL_OBJECT_IDENTITY` | One row is required for a single event. | One row
    is required for a single post. |'
  id: totrans-481
  prefs: []
  type: TYPE_TB
  zh: '| `ACL_OBJECT_IDENTITY` | 每个事件需要一行。 | 每个帖子需要一行。 |'
- en: '| `ACL_ENTRY` | Three rows-one row is required for read access by the owner
    (the user `SID`), two rows are required (one for read access, one for write access)
    for the administrative group `SID`. | Four rows-one row is required for read access
    by the user group `SID`, one row is required for write access by the owner, two
    rows are required for the administrative group `SID` (as with events) |'
  id: totrans-482
  prefs: []
  type: TYPE_TB
  zh: '| `ACL_ENTRY` | 对于所有者（用户`SID`）的读取访问需要三行，其中一行是必需的（对于管理组`SID`的读取访问需要两行，对于事件也是如此）|
    四行-一行对于用户组`SID`的读取访问是必需的，所有者需要一行写入访问，管理组`SID`需要两行（与事件一样）|'
- en: 'We can then take the usage assumptions from the previous page and calculate
    the following ACL scalability matrix as follows:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以从前一页的使用假设中获取数据，并以下方式计算ACL可扩展性矩阵：|
- en: '| **Table/Object** | **Scale factor** | **Estimates (Low)** | **Estimates (High)**
    |'
  id: totrans-484
  prefs: []
  type: TYPE_TB
  zh: '| **Table/Object** | **扩展因子** | **估计（低）** | **估计（高）** |'
- en: '| `Users` |  | `10,000` | `1,000,000` |'
  id: totrans-485
  prefs: []
  type: TYPE_TB
  zh: '| `Users` |  | `10,000` | `1,000,000` |'
- en: '| `Events` | `# Users * 0.1 * 2` | `2,000` | `200,000` |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
  zh: '| `Events` | `# Users * 0.1 * 2` | `2,000` | `200,000` |'
- en: '| `Picture Posts` | `# Users * 0.1 * 20` | `20,000` | `2,000,000` |'
  id: totrans-487
  prefs: []
  type: TYPE_TB
  zh: '| `Picture Posts` | `# Users * 0.1 * 20` | `20,000` | `2,000,000` |'
- en: '| `ACL_SID` | `# Users` | `10,000` | `1,000,000` |'
  id: totrans-488
  prefs: []
  type: TYPE_TB
  zh: '| `ACL_SID` | `# Users` | `10,000` | `1,000,000` |'
- en: '| `ACL_OBJECT_IDENTITY` | `# Events + # Picture Posts` | `220,000` | `2,200,000`
    |'
  id: totrans-489
  prefs: []
  type: TYPE_TB
  zh: '| `ACL_OBJECT_IDENTITY` | `# Events + # Picture Posts` | `220,000` | `2,200,000`
    |'
- en: '| `ACL_ENTRY` | `(# Events * 3) + (# Picture Posts * 4)` | `86,000` | `8,600,000`
    |'
  id: totrans-490
  prefs: []
  type: TYPE_TB
  zh: '| `ACL_ENTRY` | `(# Events * 3) + (# Picture Posts * 4)` | `86,000` | `8,600,000`
    |'
- en: From these projections based on only a subset of the business objects likely
    to be involved and secured in a typical ACL implementation, you can see that the
    number of database rows devoted to storing ACL information is likely to grow linearly
    (or faster) in relation to your actual business data. Especially in large system
    planning, forecasting the amount of ACL data that you are likely to use is extremely
    important. It is not uncommon for very complex systems to have hundreds of millions
    of rows related to ACL storage.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些基于典型ACL实现中可能涉及和受保护的业务对象子集的预测，您可以看到，用于存储ACL信息的数据库行的数量可能会与您的实际业务数据线性增长（或更快）。特别是在大型系统规划中，预测您可能使用的ACL数据量非常重要。在非常复杂的系统中，与ACL存储相关的数百万行数据是很常见的。|
- en: Do not discount custom development costs
  id: totrans-492
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要低估定制开发成本|
- en: 'Utilizing a Spring ACL-secured environment often requires significant development
    work above and beyond the configuration steps we''ve described to this point.
    Our sample configuration scenario has the following limitations:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring ACL安全环境中使用通常需要大量的开发工作，超出我们迄今为止描述的配置步骤。我们示例配置场景有以下限制：|
- en: No facility is provided for responding to the manipulation modification of events
    or modification of permissions
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有提供响应事件或修改权限的操作修改的设施|
- en: Not all of the application is using permissions. For example, the My Events
    page and directly navigating to an event are both not secured
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并非所有的应用程序都在使用权限。例如，我的事件页面和直接导航到事件都不受保护|
- en: The application does not effectively use ACL hierarchies. These limitations
    would significantly impact the functionality were we to roll out ACL security
    to the whole site. This is why it is critical that when planning Spring ACL rollout
    across an application, you must carefully review all of the places where the domain
    data is manipulated and ensure that these locations correctly update ACL and ACE
    rules, and invalidate caches. Typically, the securing of methods and data takes
    place at the service or business application layer, and the hooks required to
    maintain ACLs and ACEs occur at the data access layer.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序没有有效地使用ACL层次结构。如果我们为整个网站实施ACL安全，这些限制将对功能产生重大影响。这就是为什么在计划在整个应用程序中实施Spring
    ACL时，你必须仔细审查所有操作领域数据的地方，并确保这些地方正确更新ACL和ACE规则，以及无效化缓存。通常，方法和数据的保护发生在服务或业务应用程序层，而维护ACL和ACE所需的生命周期钩子发生在数据访问层。
- en: '![](img/85ea63ba-90df-4dea-bf21-fcb02a8a96e2.png)'
  id: totrans-497
  prefs: []
  type: TYPE_IMG
  zh: '![](img/85ea63ba-90df-4dea-bf21-fcb02a8a96e2.png)'
- en: If you are dealing with a reasonably standard application architecture, with
    proper isolation and encapsulation of functionality, it's likely that there's
    an easily identified central location for these changes. On the other hand, if
    you're dealing with an architecture that has devolved (or was never designed well
    in the first place), then adding ACL functionality and supporting hooks in data
    manipulation code can prove to be very difficult.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你处理的是一个相对标准的应用程序架构，并且功能得到了适当的隔离和封装，那么这些更改很可能有一个容易识别的中心位置。另一方面，如果你处理的架构已经退化（或者最初就没有设计好），那么在数据操作代码中添加ACL功能和支持钩子可能会非常困难。
- en: As previously hinted, it's important to keep in mind that the Spring ACL architecture
    hasn't changed significantly since the days of Acegi 1.x. During that time, many
    users have attempted to implement it, and have logged and documented several important
    restrictions, many of which are captured in the Spring Security JIRA repository
    ([http://jira.springframework.org/](http://jira.springframework.org/)). Issue
    `SEC-479` functions as a useful entry point for some of the key limitations, many
    of which remain unaddressed with Spring Security 3, and (if they are applicable
    to your situation) can require significant custom coding to work around.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 如之前所暗示的，重要的是要记住Spring ACL架构自Acegi 1.x时代以来并没有发生显著变化。在那段时间里，许多用户尝试实现它，并在Spring
    Security JIRA存储库([http://jira.springframework.org/](http://jira.springframework.org/))中记录和文档化了几个重要的限制，其中许多在Spring
    Security 3中仍未得到解决。对于这些问题（如果它们适用于你的情况），可能需要进行大量的自定义编码才能绕过。
- en: 'The following are some of the most important and commonly encountered issues:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些最重要且常见遇到的问题：
- en: The ACL infrastructure requires a numeric primary key. For applications that
    use a GUID or UUID primary key (which occurs more frequently due to more efficient
    support in modern databases), this can be a significant limitation.
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ACL基础架构需要一个数值主键。对于使用GUID或UUID主键的应用程序（这在现代数据库中更常见，因为它们在支持方面更有效率），这可能是一个重大限制。
- en: At the time of writing this, the JIRA issue, SEC-1140, documents the issue that
    the default ACL implementation does not correctly compare permission bitmasks
    using bitwise operators. We covered this earlier in the section on permissions.
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在撰写此内容时，JIRA问题SEC-1140记录了默认ACL实现不正确使用位运算符比较权限位掩码的问题。我们在权限部分的章节中已经讨论过这个问题。
- en: Several inconsistencies exist between the method of configuring Spring ACL and
    the rest of Spring Security. In general, it is likely that you will run into areas
    where class delegates or properties are not exposed through DI, necessitating
    an override and rewrite strategy that can be time consuming and expensive to maintain.
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在配置Spring ACL方法和Spring Security其他部分之间存在几处不一致。通常，你可能会在类委托或属性未通过DI暴露的区域遇到问题，这需要一个耗时且维护成本高昂的重写和覆盖策略。
- en: The permission bitmask is implemented as an integer, and thus has 32 possible
    bits. It's somewhat common to expand the default bit assignments to indicate permissions
    on individual object properties (for example, assigning a bit to read the social
    security number of an employee). Complex deployments may have well over 32 properties
    per domain object, in which case the only alternative would be to remodel your
    domain objects around this limitation.
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 权限位掩码实现为整数，因此有32个可能的位。将默认位分配扩展以表示单个对象属性的权限（例如，为读取员工的社会安全号码分配一个位）是比较常见的。复杂的部署可能会使每个领域对象有超过32个属性，在这种情况下，唯一的选择就是围绕这个限制重新设计您的领域对象。
- en: Depending on your specific application's requirements, it is likely that you
    will encounter additional issues, especially with regards to the number of classes
    requiring change when implementing certain types of customizations.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您特定应用程序的要求，您很可能会遇到额外的问题，尤其是在实现某些类型的自定义时需要更改的类数量方面。
- en: Should I use Spring Security ACL?
  id: totrans-506
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我应该使用Spring Security ACL吗？
- en: Just like the details of applying Spring Security as a whole are highly business
    dependent, so is the application of Spring ACL support. In fact, this tends to
    be even more true of ACL support due to its tight coupling to business methods
    and domain objects. We hope that this guide to Spring ACL explained the important
    high-level and low-level configurations and concepts required to analyze Spring
    ACL for use in your application and can assist you in determining and matching
    its capabilities to real-world use.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 正如整体应用Spring Security的细节高度依赖于业务场景一样，Spring ACL支持的应用也同样如此。实际上，由于Spring ACL支持与业务方法和领域对象紧密耦合，这种依赖性在Spring
    ACL支持方面往往更为明显。我们希望本章关于Spring ACL的指南能够解释分析Spring ACL在应用程序中使用所需的重要高级和低级配置与概念，并帮助您确定并将其功能与现实世界的使用相匹配。
- en: Summary
  id: totrans-508
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we focused on security based on ACL and the specific details
    of how this type of security is implemented by the Spring ACL module.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们重点讨论了基于ACL的安全以及Spring ACL模块如何实现这种安全类型的具体细节。
- en: We reviewed the basic concept of ACL, and many reasons why they can be very
    effective solutions to authorization. Also, you learned the key concepts related
    to the Spring ACL implementation, including ACEs, SIDs, and object identity. We
    examined the database schema and logical design required to support a hierarchical
    ACL system. We configured all the required Spring beans to enable the Spring ACL
    module and enhanced one of the service interfaces to use annotated method authorization.
    We then tied the existing users in our database, and business objects used by
    the site itself, into a sample set of ACE declarations and supporting data. We
    reviewed the concepts around Spring ACL permission handling. We expanded our knowledge
    of the Spring Security Thymeleaf tag library and SpEL expression language (for
    method security) to utilize ACL checks. We discussed the mutable ACL concept and
    reviewed the basic configuration and custom coding required in a mutable ACL environment.
    We developed a custom ACL permission and configured the application to demonstrate
    its effectiveness. We configured and analyzed the use of the `Ehcache` cache manager
    to reduce the database impact of Spring ACL. We analyzed the impact and design
    considerations of using the Spring ACL system in a complex business application.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回顾了ACL的基本概念，以及它们在授权方面可能非常有效的许多原因。此外，您还学习了与Spring ACL实现相关的关键概念，包括ACEs、SIDs和对象身份。我们检查了支持分层ACL系统的数据库模式和逻辑设计。我们配置了所有必需的Spring
    beans以启用Spring ACL模块，并增强了一个服务接口以使用注解方法授权。然后，我们将我们数据库中现有的用户和网站本身使用的业务对象与一组示例ACE声明和支持数据相连接。我们回顾了Spring
    ACL权限处理的概念。我们扩展了对Spring Security Thymeleaf标签库和SpEL表达式语言（用于方法安全）的了解，以利用ACL检查。我们讨论了可变ACL概念，并回顾了在可变ACL环境中所需的基本配置和自定义代码。我们开发了一个自定义ACL权限并配置应用程序以展示其有效性。我们配置并分析了使用`Ehcache`缓存管理器以减少Spring
    ACL对数据库的影响。我们分析了在复杂业务应用程序中使用Spring ACL系统的影响和设计考虑。
- en: This wraps up our discussion about Spring Security ACLs. In the next chapter,
    we'll dig a bit further into how Spring Security works.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们关于Spring Security ACL的讨论。在下一章中，我们将更深入地了解Spring Security是如何工作的。
