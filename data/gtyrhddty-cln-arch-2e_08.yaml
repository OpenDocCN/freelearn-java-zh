- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Testing Architecture Elements
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试架构元素
- en: In many projects I’ve witnessed, especially projects that have been around for
    a while and have rotated in and out many developers over time, automated testing
    is a mystery. Everyone writes tests as they see fit because it’s required by some
    dusty rule documented in a wiki, but no one can answer targeted questions about
    a team’s testing strategy.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我见证的许多项目中，尤其是那些存在了一段时间并且随着时间的推移轮换了许多开发者的项目，自动化测试是一个谜。每个人都根据他们认为合适的方式编写测试，因为这是由某个尘封的规则所要求的，但没有人能回答关于团队测试策略的针对性问题。
- en: This chapter provides a testing strategy for a Hexagonal Architecture. For each
    element of our architecture, we’ll discuss the type of test to cover it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了一种针对六边形架构的测试策略。对于我们架构的每个元素，我们将讨论覆盖它的测试类型。
- en: The test pyramid
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试金字塔
- en: Let’s start the discussion about testing along the lines of the **test pyramid**[1](#footnote-031)
    in *Figure 8**.1*, which is a metaphor that helps us to decide on how many tests
    of which type we should aim for.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从**测试金字塔**[1](#footnote-031)的讨论开始，如图8.1所示，这是一个帮助我们决定我们应该追求多少种类型测试的隐喻。
- en: '[1](#footnote-031-backlink) The test pyramid can be traced back to Mike Cohn’s
    book *Succeeding with Agile* from 2009.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[1](#footnote-031-backlink) 测试金字塔可以追溯到2009年迈克·科恩的书籍《敏捷成功》。'
- en: '![Figure 8.1 – According to the test pyramid, we should create many cheap tests
    and fewer expensive ones](img/Figure_08.1._B19916.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 根据测试金字塔，我们应该创建许多低成本测试和较少的高成本测试](img/Figure_08.1._B19916.jpg)'
- en: Figure 8.1 – According to the test pyramid, we should create many cheap tests
    and fewer expensive ones
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 根据测试金字塔，我们应该创建许多低成本测试和较少的高成本测试
- en: The basic statement of the pyramid is that we should have high coverage of fine-grained
    tests that are cheap to build, easy to maintain, fast-running, and stable. These
    are unit tests that verify that a single unit (usually a class) works as expected.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 金字塔的基本陈述是我们应该有高覆盖率的细粒度测试，这些测试易于构建、易于维护、运行速度快且稳定。这些是验证单个单元（通常是一个类）按预期工作的单元测试。
- en: Once tests combine multiple units and go across unit boundaries, architectural
    boundaries, or even system boundaries, they tend to become more expensive to build,
    slower to run, and more brittle (failing due to some configuration error instead
    of a functional error). The pyramid tells us that the more expensive those tests
    become, the less we should aim for high coverage of these tests because, otherwise,
    we’ll spend too much time building tests instead of new functionality.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦测试组合了多个单元并跨越了单元边界、架构边界甚至系统边界，它们往往变得更昂贵来构建、运行速度更慢、更脆弱（由于某些配置错误而不是功能错误而失败）。金字塔告诉我们，这些测试变得越昂贵，我们就越不应该追求对这些测试的高覆盖率，否则我们将花费太多时间构建测试而不是新功能。
- en: Depending on the context, the test pyramid is often shown with different layers.
    Let’s take a look at the layers I chose to discuss testing our Hexagonal Architecture.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上下文，测试金字塔通常以不同的层次展示。让我们看看我选择讨论测试我们的六边形架构的层次。
- en: Note
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The definitions of *unit test*, *integration test*, and *system test* vary with
    context. In one project, they may mean a different thing than in another.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*单元测试*、*集成测试*和*系统测试*的定义随着上下文的不同而变化。在一个项目中，它们可能意味着与另一个项目不同的事情。'
- en: 'The following are interpretations of different test types as we’ll use them
    in this chapter:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将在本章中使用的不同测试类型的解释：
- en: '**Unit tests** are the base of the pyramid. A unit test usually instantiates
    a single class and tests its functionality through its interface. If the class
    under test has non-trivial dependencies on other classes, we can replace those
    dependencies with mock objects that simulate the behavior of the real objects,
    as required by the test.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**是金字塔的基础。单元测试通常实例化一个类并通过其接口测试其功能。如果被测试的类对其他类有非平凡的依赖，我们可以用模拟对象替换这些依赖，模拟对象模拟真实对象的行为，以满足测试的要求。'
- en: '**Integration tests** form the next layer of the pyramid. These tests instantiate
    a network of multiple units and verify whether this network works as expected,
    by sending some data into it through the interface of an entry class. In our interpretation,
    integration tests will cross the boundary between two layers, so the network of
    objects is not complete or must work against mocks at some point.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**构成了金字塔的下一层。这些测试实例化一个由多个单元组成的网络，并通过将一些数据通过入口类的接口发送到网络中，来验证这个网络是否按预期工作。在我们的解释中，集成测试将跨越两个层之间的边界，因此对象网络可能不完整或必须在某些点上与模拟对象交互。'
- en: '**System tests**, finally, spin up the whole network of objects that make up
    our application and verify whether a certain use case works as expected through
    all the layers of the application.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，**系统测试**启动构成我们应用程序的整个对象网络，并验证某个用例是否在应用程序的所有层中按预期工作。
- en: Above the system tests, there might be a layer of end-to-end tests that include
    the UI of the application. We’ll not consider end-to-end tests here since we’re
    only discussing a backend architecture in this book.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统测试之上，可能有一层端到端测试，包括应用程序的用户界面。在这里我们不会考虑端到端测试，因为我们只在本书中讨论后端架构。
- en: Note
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The test pyramid, like any other guidance, is not a silver bullet for your test
    strategy. It’s a good default, but if, in your context, you can create and maintain
    integration or system tests cheaply, you can and should create more of those tests,
    as they are less vulnerable to changes in implementation details than unit tests.
    This would make the sides of the pyramid steeper, or maybe even invert them.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 测试金字塔，像任何其他指导一样，并不是你测试策略的万能钥匙。它是一个好的默认选择，但如果你在你的环境中可以廉价地创建和维护集成或系统测试，你可以也应该创建更多的这些测试，因为它们比单元测试更不容易受到实现细节变化的影响。这会使金字塔的侧面更陡峭，甚至可能颠倒它们。
- en: Now that we have defined some test types, let’s see which type of test fits
    best with each of the layers of our Hexagonal Architecture.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了一些测试类型，让我们看看哪种类型的测试最适合我们六边形架构的每一层。
- en: Testing a domain entity with unit tests
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单元测试测试领域实体
- en: We will start by looking at a domain entity at the center of our architecture.
    Let’s recall the `Account` entity from [*Chapter 5*](B19916_05.xhtml#_idTextAnchor044),
    *Implementing a Use Case*. The state of `Account` consists of a balance an account
    had at a certain point in the past (the baseline balance) and a list of deposits
    and withdrawals (activities) made since then.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从查看我们架构中心的领域实体开始。让我们回顾一下来自[*第5章*](B19916_05.xhtml#_idTextAnchor044)，*实现用例*中的`Account`实体。`Account`的状态由一个账户在过去的某个时间点所拥有的余额（基线余额）以及自那时起所进行的存款和取款（活动）列表组成。
- en: 'We now want to verify that the `withdraw()` method works as expected:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想验证`withdraw()`方法是否按预期工作：
- en: '![](img/code-8.1.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/code-8.1.jpg)'
- en: The preceding test is a plain unit test that instantiates an `Account` in a
    specific state, calls its `withdraw()` method, and verifies that the withdrawal
    was successful and had the expected side effects on the state of the `Account`
    object under test.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试是一个简单的单元测试，它实例化了一个处于特定状态的`Account`，调用其`withdraw()`方法，并验证取款是否成功以及它对正在测试的`Account`对象的状态产生了预期的副作用。
- en: The test is rather easy to set up, is easy to understand, and runs very fast.
    Tests don’t come much simpler than this. Unit tests such as these are our best
    bet to verify the business rules encoded within our domain entities. We don’t
    need any other type of test since domain entity behavior has little to no dependencies
    on other classes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 测试设置相当简单，易于理解，并且运行非常快。测试没有比这更简单了。这样的单元测试是我们验证编码在我们领域实体中的业务规则的最佳选择。我们不需要任何其他类型的测试，因为领域实体的行为与其他类几乎没有任何依赖。
- en: Testing a use case with unit tests
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单元测试测试用例
- en: 'Going a layer outward, the next architecture element to test is the use cases
    implemented as domain services. Let’s look at a test for `SendMoneyService`, discussed
    in [*Chapter 5*](B19916_05.xhtml#_idTextAnchor044), *Implementing a Use Case*.
    The *Send money* use case withdraws money from the source account and deposits
    it into the target account. We want to verify that everything works as expected
    when the transaction succeeds:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 向外扩展一层，下一个要测试的架构元素是作为领域服务实现的用例。让我们看看在[*第5章*](B19916_05.xhtml#_idTextAnchor044)，*实现用例*中讨论的`SendMoneyService`测试。*发送金钱*用例从源账户取款并将其存入目标账户。我们想验证当交易成功时，一切是否按预期工作：
- en: '![](img/code-8.2.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/code-8.2.jpg)'
- en: To make the test a little more readable, it’s structured into `given`/`when`/`then`
    sections, which are commonly used in **Behavior-Driven Development**.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使测试更易于阅读，它被结构化为`given`/`when`/`then`部分，这在**行为驱动开发**中是常用的。
- en: In the `given` section, we create the source and target `Account` objects and
    put them into the correct state with some methods whose names start with `given...()`.
    We also create a `SendMoneyCommand` object to act as input to the use case. In
    the `when` section, we simply call the `sendMoney()` method to invoke the use
    case. The `then` section asserts that the transaction was successful and verifies
    that certain methods have been called on the source and target `Account` objects.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在`given`部分，我们创建源和目标`Account`对象，并使用以`given...()`开头的某些方法将它们置于正确的状态。我们还创建了一个`SendMoneyCommand`对象，作为用例的输入。在`when`部分，我们简单地调用`sendMoney()`方法来调用用例。在`then`部分，我们断言交易成功，并验证源和目标`Account`对象上是否调用了某些方法。
- en: Under the hood, the test makes use of the Mockito library to create `given...()`
    methods.[2](#footnote-030) Mockito also provides the `then()` method to verify
    whether a certain method has been called on a mock object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，测试使用Mockito库来创建`given...()`方法。[2](#footnote-030) Mockito还提供了`then()`方法来验证是否在模拟对象上调用过某个方法。
- en: '[2](#footnote-030-backlink) Mockito: [https://site.mockito.org/](https://site.mockito.org/).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[2](#footnote-030-backlink) Mockito: [https://site.mockito.org/](https://site.mockito.org/).'
- en: Note
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If used too much, mocking can give a false sense of security. Mocks may behave
    differently from the real thing, causing issues in production even though our
    tests are green. If you can use real objects instead of mocks without too much
    extra effort, you should probably do it. In the preceding example, we might choose
    to work with real `Account` objects instead of mocks, for example. This shouldn’t
    prove much more effort because the `Account` class is a domain model class that
    doesn’t have any complicated dependencies on other classes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果过度使用模拟，可能会产生虚假的安全感。模拟的行为可能与真实对象不同，即使在测试结果为绿色的情况下，也可能在生产中引发问题。如果你可以不花费太多额外努力就使用真实对象而不是模拟对象，那么你可能应该这样做。在前面的例子中，我们可能会选择与真实的`Account`对象而不是模拟对象一起工作，例如。这不应该需要更多的努力，因为`Account`类是一个领域模型类，它不依赖于其他类的任何复杂依赖。
- en: Since the use case service under test is stateless, we cannot verify a certain
    state in the `then` section. Instead, the test verifies that the service has interacted
    with certain methods on its (mocked) dependencies. This means that the test is
    vulnerable to changes in the structure of the code under test and not only its
    behavior. This, in turn, means that there is a higher chance that the test has
    to be modified if the code under test is refactored.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于被测试的使用案例服务是无状态的，我们无法在`then`部分验证某个状态。相反，测试验证服务是否与其（模拟的）依赖项上的某些方法进行了交互。这意味着测试容易受到被测试代码结构变化的影响，而不仅仅是其行为。这反过来意味着，如果被测试代码重构，测试需要修改的可能性更高。
- en: With this in mind, we should think hard about which interactions we actually
    want to verify in the test. It might be a good idea not to verify all interactions
    as we did in the preceding test and instead focus on the most important ones.
    Otherwise, we have to change the test with every single change to the class under
    test, undermining the value of the test.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们应该仔细思考在测试中我们实际上想要验证哪些交互。可能一个好的主意不是像前面测试中那样验证所有交互，而是专注于最重要的那些。否则，我们必须随着被测试类的每一次更改而更改测试，这会削弱测试的价值。
- en: While this test is still a unit test, it borders on being an integration test
    because we test the interaction on dependencies. However, it’s easier to create
    and maintain than a full-blown integration test because we’re working with mocks
    and don’t have to manage the real dependencies.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个测试仍然是一个单元测试，但它接近于集成测试，因为我们测试了依赖项上的交互。然而，由于我们使用模拟并且不需要管理真实依赖项，所以它比完整的集成测试更容易创建和维护。
- en: Testing a web adapter with integration tests
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用集成测试测试Web适配器
- en: Moving outward another layer, we arrive at our adapters. Let’s discuss testing
    a web adapter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 向外移动另一层，我们到达了我们的适配器。让我们讨论如何测试Web适配器。
- en: Recall that a web adapter takes input, for example, in the form of JSON strings,
    via HTTP, might do some validation on it, maps the input to the format a use case
    expects, and then passes it to that use case. It then maps the result of the use
    case back to JSON and returns it to the client via an HTTP response.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，一个Web适配器通过HTTP接收输入，例如JSON字符串形式的输入，可能对其进行一些验证，将输入映射到用例期望的格式，然后将它传递给那个用例。然后它将用例的结果映射回JSON，并通过HTTP响应将其返回给客户端。
- en: 'In the test for a web adapter, we want to make certain that all those steps
    work as expected:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在对Web适配器的测试中，我们想要确保所有这些步骤都按预期工作：
- en: '![](img/code-8.3.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![代码-8.3.jpg](img/code-8.3.jpg)'
- en: The preceding test is a standard integration test for a web controller named
    `SendMoneyController`, built with the Spring Boot framework. In the `testSendMoney()`
    method, we send a mock HTTP request to the web controller to trigger a transaction
    from one account to another.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试是对名为`SendMoneyController`的Web控制器的标准集成测试，该控制器是用Spring Boot框架构建的。在`testSendMoney()`方法中，我们向Web控制器发送一个模拟HTTP请求，以触发从一个账户到另一个账户的交易。
- en: With the `isOk()` method, we then verify that the status of the HTTP response
    is `200`, and we verify that the mocked use case class has been called.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`isOk()`方法，我们验证HTTP响应的状态是`200`，并验证模拟的用例类已被调用。
- en: Most responsibilities of a web adapter are covered by this test.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试覆盖了Web适配器的大多数职责。
- en: We’re not actually testing via the HTTP protocol since we’re mocking that away
    with the `MockMvc` object. We trust that the framework translates everything to
    and from HTTP properly. There’s no need to test the framework.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上并没有通过HTTP协议进行测试，因为我们用`MockMvc`对象模拟了它。我们相信框架能够正确地将一切转换为HTTP协议。没有必要测试框架。
- en: However, the whole path from mapping the input from JSON into a `SendMoneyCommand`
    object is covered. If we build the `SendMoneyCommand` object as a self-validating
    command, as explained in [*Chapter 5*](B19916_05.xhtml#_idTextAnchor044), *Implementing
    a Use Case*, we even make sure that this mapping produces syntactically valid
    input to the use case. Also, we have verified that the use case is actually called
    and that the HTTP response has the expected status.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从将输入从JSON映射到`SendMoneyCommand`对象的全过程都被覆盖了。如果我们像在[*第五章*](B19916_05.xhtml#_idTextAnchor044)“实现用例”中解释的那样，将`SendMoneyCommand`对象构建为一个自我验证的命令，我们甚至可以确保这种映射产生了对用例而言语法上有效的输入。此外，我们还验证了用例确实被调用，并且HTTP响应具有预期的状态。
- en: So, why is this an integration test and not a unit test? Even though it seems
    that we only test a single web controller class in this test, there’s a lot more
    going on under the hood. With the `@WebMvcTest` annotation, we tell Spring to
    instantiate a whole network of objects that is responsible for responding to certain
    request paths, mapping between Java and JSON, validating HTTP input, and so on.
    And in this test, we verify that our web controller works as a part of this network.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么这是一个集成测试而不是单元测试呢？尽管在这个测试中似乎我们只测试了一个单一的Web控制器类，但在引擎盖下还有更多的事情在进行。通过使用`@WebMvcTest`注解，我们告诉Spring实例化一个负责响应特定请求路径、在Java和JSON之间进行映射、验证HTTP输入等的整个对象网络。在这个测试中，我们验证我们的Web控制器作为这个网络的一部分是否正常工作。
- en: Since the web controller is heavily coupled to the Spring framework, it makes
    sense to test it when integrated into this framework instead of testing it in
    isolation. If we tested the web controller with a plain unit test, we’d lose coverage
    of all the mapping, validation, and HTTP stuff, and we could never be sure whether
    it actually worked in production, where it’s just a cog in the mechanics of the
    framework.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Web控制器与Spring框架紧密耦合，因此当它集成到这个框架中进行测试时是有意义的，而不是在隔离状态下进行测试。如果我们用普通的单元测试来测试Web控制器，我们就会失去对所有映射、验证和HTTP内容的覆盖，并且我们永远无法确定它是否在生产环境中实际工作，在那里它只是框架机械结构中的一个齿轮。
- en: Testing a persistence adapter with integration tests
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用集成测试测试持久化适配器
- en: For a similar reason, it makes sense to cover persistence adapters with integration
    tests instead of unit tests since we not only want to verify the logic within
    the adapter but also the mapping into the database.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于同样的原因，用集成测试而不是单元测试来覆盖持久化适配器是有意义的，因为我们不仅想要验证适配器内部的逻辑，还要验证其映射到数据库的过程。
- en: 'We want to test the persistence adapter we built in [*Chapter 7*](B19916_07.xhtml#_idTextAnchor062),
    *Implementing a Persistence Adapter*. The adapter has two methods, one to load
    an `Account` entity from the database and another to save new account activities
    to the database:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想测试我们在 [*第 7 章*](B19916_07.xhtml#_idTextAnchor062)，*实现持久性适配器* 中构建的持久性适配器。适配器有两个方法，一个是从数据库中加载
    `Account` 实体，另一个是将新的账户活动保存到数据库中：
- en: '![](img/code-8.4.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例](img/code-8.4.jpg)'
- en: With `@DataJpaTest`, we tell Spring to instantiate the network of objects that
    are needed for database access, including our Spring Data repositories that connect
    to the database. We use the `@Import` annotation to import some additional configurations
    to make sure that certain objects are added to that network. These objects are
    needed by the adapter under test to map incoming domain objects into database
    objects, for instance.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `@DataJpaTest`，我们告诉 Spring 实例化数据库访问所需的网络对象，包括连接到数据库的我们的 Spring Data 仓库。我们使用
    `@Import` 注解导入一些额外的配置，以确保某些对象被添加到该网络中。这些对象是测试中的适配器所需的，以便将传入的领域对象映射到数据库对象，例如。
- en: In the test for the `loadAccount()` method, we put the database into a certain
    state using an SQL script with the name `AccountPersistenceAdapterTest.sql`. Then,
    we simply load the account through the adapter API and verify that it has the
    state that we would expect it to have, given the database state in the SQL script.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在对 `loadAccount()` 方法的测试中，我们使用名为 `AccountPersistenceAdapterTest.sql` 的 SQL 脚本将数据库置于某种状态。然后，我们简单地通过适配器
    API 加载账户，并验证它具有我们根据 SQL 脚本中的数据库状态所期望的状态。
- en: The test for `updateActivities()` goes the other way around. We create an `Account`
    object with a new account activity and pass it to the adapter to persist. Then,
    we check whether the activity has been saved to the database through the API of
    `ActivityRepository`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `updateActivities()` 的测试，方向相反。我们创建一个带有新账户活动的 `Account` 对象，并将其传递给适配器以持久化。然后，我们检查该活动是否已通过
    `ActivityRepository` 的 API 保存到数据库中。
- en: An important aspect of these tests is that we’re not mocking away the database.
    The tests actually hit the database. Had we mocked the database away, the tests
    would still cover the same lines of code, producing the same high coverage of
    lines of code. However, despite this high coverage, the tests would still have
    a rather high chance of failing in a setup with a real database, due to errors
    in SQL statements or unexpected mapping errors between database tables and Java
    objects.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试的一个重要方面是我们没有模拟数据库。测试实际上击中了数据库。如果我们模拟了数据库，测试仍然会覆盖相同的代码行，产生相同的代码行高覆盖率。然而，尽管有这种高覆盖率，由于
    SQL 语句中的错误或数据库表与 Java 对象之间意外的映射错误，测试在真实数据库的设置中仍然有相当高的失败概率。
- en: Note that, by default, Spring will spin up an in-memory database to use during
    tests. This is very practical, as we don’t have to configure anything, and the
    tests will work out of the box. However, since this in-memory database is most
    probably not the database we use in production, there is still a significant chance
    of something going wrong with the real database even when the tests work perfectly
    against the in-memory database. Database vendors love to implement their own flavor
    of SQL, for instance.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，默认情况下，Spring 将启动一个内存数据库以在测试期间使用。这非常实用，因为我们不需要进行任何配置，测试将直接工作。然而，由于这个内存数据库很可能不是我们在生产中使用的数据库，即使在内存数据库上测试工作完美，仍然有相当大的可能性在真实数据库上出现问题。例如，数据库供应商喜欢实现他们自己的
    SQL 版本。
- en: For this reason, persistence adapter tests should run against the real database.
    Libraries such as **Testcontainers** are a great help in this regard, spinning
    up a Docker container with a database on demand.[3](#footnote-029)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，持久性适配器测试应该针对真实数据库运行。在这方面，**Testcontainers** 等库非常有帮助，可以根据需要启动一个包含数据库的 Docker
    容器。[3](#footnote-029)
- en: '[3](#footnote-029-backlink) Testcontainers: [https://www.testcontainers.org/](https://www.testcontainers.org/).'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[3](#footnote-029-backlink) Testcontainers: [https://www.testcontainers.org/](https://www.testcontainers.org/).'
- en: Running against the real database has the added benefit that we don’t have to
    take care of two different database systems. If we use the in-memory database
    during tests, we might have to configure it in a certain way, or we might have
    to create separate versions of database migration scripts for each database, which
    is a big hit on the maintainability of our tests.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对真实数据库进行测试的好处是，我们不必处理两个不同的数据库系统。如果我们使用测试期间的内存数据库，我们可能需要以某种方式配置它，或者我们可能需要为每个数据库创建数据库迁移脚本的单独版本，这对我们测试的可维护性是一个很大的打击。
- en: Testing main paths with system tests
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用系统测试测试主要路径
- en: At the top of the pyramid are what I call **system tests**. A system test starts
    up the whole application and runs requests against its API, verifying that all
    our layers work in concert.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在金字塔的顶部是我所说的**系统测试**。系统测试启动整个应用，并对其API运行请求，验证我们所有的层是否协同工作。
- en: Hexagonal Architecture is all about creating a well-defined boundary between
    our application and the outside world. Doing so makes our application boundaries
    very testable by design. To test our application locally, we just need to swap
    out the adapters with mock adapters, as outlined in *Figure 8**.2*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 六角架构的核心是创建一个清晰定义的应用与外部世界之间的边界。这样做使得我们的应用边界在设计上非常易于测试。为了在本地测试我们的应用，我们只需按照*图8.2*中概述的方法，用模拟适配器替换适配器即可。
- en: '![Figure 8.2 – By replacing the adapters with mocks, we can run and test our
    application without dependencies on the outside world](img/Figure_08.2._B19916.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 通过用模拟替换适配器，我们可以运行和测试我们的应用，而不依赖于外部世界](img/Figure_08.2._B19916.jpg)'
- en: Figure 8.2 – By replacing the adapters with mocks, we can run and test our application
    without dependencies on the outside world
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 通过用模拟替换适配器，我们可以运行和测试我们的应用，而不依赖于外部世界
- en: On the left, we can replace the input adapters with a test driver that calls
    the application’s input ports to interact with it. The test driver can implement
    certain test scenarios that simulate user behavior during an automated test.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，我们可以用测试驱动器替换输入适配器，该驱动器调用应用输入端口以与之交互。测试驱动器可以实施某些测试场景，模拟自动化测试期间的用户行为。
- en: On the right, we can replace the output adapters with mock adapters that simulate
    the behavior of a real adapter and return previously specified values.[4](#footnote-028)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧，我们可以用模拟适配器替换输出适配器，该适配器模拟真实适配器的行为并返回先前指定的值。[4](#footnote-028)
- en: '[4](#footnote-028-backlink) Mocks: depending on who you ask and what you’re
    doing in your test, instead of calling it a “mock”, you should call it a “fake”
    or “stub”. Each term seems to have a slightly different semantic, but in the end,
    they all replace a “real” thing with a “mock” thing to be used in tests. I’m usually
    a fan of naming things just right, but in this case, I don’t see value in discussing
    the nuances between where a mock ends and a stub starts. Or is it the other way
    around?'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[4](#footnote-028-backlink) 模拟：根据你询问的对象和你在测试中做的事情，你最好将之称为“伪造”或“存根”，而不是“模拟”。每个术语似乎都有略微不同的语义，但最终，它们都是用“模拟”的事物来替换“真实”的事物，以便在测试中使用。我通常喜欢给事物取一个恰当的名字，但在这个情况下，我认为讨论模拟结束和存根开始之间的细微差别没有价值。或者，情况是否相反？'
- en: This way, we can create “application tests” that cover the “hexagon” of our
    application from the input ports, through our domain services and entities, to
    the output ports.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以创建“应用测试”，它覆盖了从输入端口到我们的领域服务和实体，再到输出端口的“六边形”应用。
- en: I would argue, however, that, instead of writing “application tests” that mock
    away the input and output adapters, we should aim to write “system tests” that
    cover the whole path from a real input adapter to a real output adapter. These
    tests uncover many subtle bugs that we wouldn’t catch if we mocked away the input
    and output adapters. These bugs include mapping errors between the layers, or
    simply wrong expectations between the application and the outside systems it’s
    talking to.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我认为，我们不应该编写模拟输入和输出适配器的“应用测试”，而应该旨在编写覆盖从真实输入适配器到真实输出适配器整个路径的“系统测试”。这些测试揭示了如果我们模拟输入和输出适配器，我们可能无法捕捉到的许多微妙错误。这些错误包括层之间的映射错误，或者简单地是应用与它所交流的外部系统之间的错误期望。
- en: A “system test” such as this requires that we can spin up the real external
    systems our application talks to in a test setup.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的“系统测试”要求我们能够在测试设置中启动应用所交流的真实外部系统。
- en: On the input side, we need to make sure that we can make real HTTP calls to
    our application, for example, so that the requests go through our real web adapter.
    That should be rather easy, however, since we just need to start our application
    locally and let it listen to HTTP calls like it would in a production environment.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入端，我们需要确保我们可以向应用程序发出真实的 HTTP 请求，例如，使请求通过我们的真实 Web 适配器。然而，这应该相当简单，因为我们只需在本地启动我们的应用程序，让它像在生产环境中一样监听
    HTTP 请求。
- en: On the output side, we need to spin up a real database, for example, so that
    our tests go through the real persistence adapter. Most databases make that easy
    today by providing a Docker image that we can spin up locally. If our application
    talks to a third-party system that is not a database, we should still try to find
    (or create) a Docker image that contains that system so we can test our application
    against it by spinning up a local Docker container.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出端，我们需要启动一个真实的数据库，例如，以便我们的测试可以通过真实持久化适配器进行。如今，大多数数据库都通过提供我们可以本地启动的 Docker
    镜像来简化这一点。如果我们的应用程序与不是数据库的第三方系统通信，我们仍然应该尝试找到（或创建）一个包含该系统的 Docker 镜像，这样我们就可以通过启动本地
    Docker 容器来测试我们的应用程序。
- en: If no Docker image is available for a given external system, we can write a
    custom mock output adapter that simulates the real thing. Hexagonal Architecture
    makes it easy for us to replace the real output adapter with this mock for the
    purpose of our tests. And if a Docker image becomes available, we can switch to
    the real output adapter without too much effort.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有可用的 Docker 镜像来模拟外部系统，我们可以编写一个自定义的模拟输出适配器来模拟真实情况。六角架构使我们能够轻松地将真实输出适配器替换为这个模拟适配器，以便于我们的测试。如果
    Docker 镜像变得可用，我们也可以轻松地切换到真实输出适配器。
- en: There are valid reasons to test against mock adapters instead of real adapters,
    of course. If our application runs in multiple profiles, for example, and each
    profile uses a different (real) input or output adapter implemented against the
    same input and output ports, we might want to have tests that isolate errors in
    the application from errors in the adapters. Application tests that cover only
    our hexagon are exactly the tool we want, then. However, for a standard web application
    with a database, where the input and output adapters are rather static, we probably
    want to focus on system tests instead.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，测试模拟适配器而不是真实适配器有合理的理由。例如，如果我们的应用程序在多个配置文件中运行，并且每个配置文件使用不同的（真实）输入或输出适配器，这些适配器针对相同的输入和输出端口实现，我们可能希望有隔离应用程序错误和适配器错误的测试。那么，只覆盖我们六角的应用程序测试正是我们想要的工具。然而，对于具有数据库的标准
    Web 应用程序，其中输入和输出适配器相对静态，我们可能更希望专注于系统测试。
- en: What would a system test look like? In a system test for the *Send money* use
    case, we send an HTTP request to the application and validate the response as
    well as the new balance of the account.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 系统测试看起来会是什么样子？在一个针对 *发送金钱* 用例的系统测试中，我们向应用程序发送一个 HTTP 请求，并验证响应以及账户的新余额。
- en: 'In the Java and Spring world, this is what it might look like:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 和 Spring 世界中，它可能看起来是这样的：
- en: '![](img/code-8.5a.jpg)![](img/code-8.5b.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![代码 8.5a](img/code-8.5a.jpg)![代码 8.5b](img/code-8.5b.jpg)'
- en: With `@SpringBootTest`, we tell Spring to start up the whole network of objects
    that makes up the application. We also configure the application to expose itself
    on a random port.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `@SpringBootTest`，我们告诉 Spring 启动构成应用程序的对象网络。我们还配置应用程序在随机端口上公开自己。
- en: In the test method, we simply create a request, send it to the application,
    and then check the response status and the new balance of the accounts.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试方法中，我们只需创建一个请求，将其发送到应用程序，然后检查响应状态和账户的新余额。
- en: We use a `TestRestTemplate` to send the request, and not `MockMvc`, as we did
    earlier in the web adapter test. This means that the test makes real HTTP calls,
    bringing the test a little closer to a production environment.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `TestRestTemplate` 发送请求，而不是之前在 Web 适配器测试中使用的 `MockMvc`。这意味着测试会进行真实的 HTTP
    调用，使测试更接近生产环境。
- en: Just as we go over real HTTP, we go through the real output adapters. In our
    case, this is only a persistence adapter that connects the application to a database.
    In an application that talks to other systems, we would have additional output
    adapters in place. It’s not always feasible to have all these third-party systems
    up and running, even for a system test, so we might mock them away, after all.
    Our Hexagonal Architecture makes this as easy as it can be for us since we only
    have to stub out a couple of output port interfaces.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们处理真实的HTTP一样，我们通过真实的输出适配器。在我们的案例中，这只是一个将应用程序连接到数据库的持久性适配器。在一个与其他系统通信的应用程序中，我们会放置额外的输出适配器。对于系统测试来说，并不是总是可行让所有这些第三方系统都运行起来，所以最终我们可能需要模拟它们。我们的六边形架构使我们能够尽可能容易地做到这一点，因为我们只需要模拟几个输出端口接口。
- en: Note that I went out of my way to make the test as readable as possible. I hid
    every bit of ugly logic within helper methods. These methods now form a domain-specific
    language that we can use to verify the state of things.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我特意使测试尽可能易于阅读。我将所有丑陋的逻辑都隐藏在辅助方法中。这些方法现在形成了一个特定领域语言，我们可以用它来验证事物的状态。
- en: While a domain-specific language such as this is a good idea in any type of
    test, it’s even more important in system tests. System tests simulate the real
    users of the application much better than unit or integration tests can, so we
    can use them to verify the application from the viewpoint of the user. This is
    much easier with a suitable vocabulary at hand. This vocabulary also enables domain
    experts, who are best suited to embody a user of the application and probably
    aren’t programmers, to reason about the tests and give feedback. There are whole
    libraries for behavior-driven development, such as JGiven[5](#footnote-027), that
    provide a framework to create a vocabulary for your tests.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管像这样的特定领域语言在任何类型的测试中都是一个好主意，但在系统测试中它更为重要。系统测试比单元测试或集成测试更好地模拟了应用程序的真实用户，因此我们可以从用户的角度验证应用程序。有了合适的词汇，这会容易得多。这个词汇库还使领域专家能够对测试进行推理并提供反馈，这些专家最适合体现应用程序的用户，而且可能不是程序员。有专门的库用于行为驱动开发，例如JGiven[5](#footnote-027)，它提供了一个框架来为您的测试创建词汇。
- en: '[5](#footnote-027-backlink) JGiven: [https://jgiven.org/](https://jgiven.org/).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[5](#footnote-027-backlink) JGiven: [https://jgiven.org/](https://jgiven.org/).'
- en: If we create unit and integration tests as described in the previous sections,
    the system tests will cover a lot of the same code. Do they even provide any additional
    benefits? Yes, they do. Usually, they flush out other types of bugs than the unit
    and integration tests do. Some mapping between the layers could be off, for instance,
    which we would not notice with the unit and integration tests alone.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们像前几节描述的那样创建单元测试和集成测试，系统测试将覆盖大量相同的代码。它们甚至提供任何额外的优势吗？是的，它们确实提供了。通常，它们会清除单元测试和集成测试之外的其他类型的错误。例如，某些层之间的映射可能不正确，而这仅凭单元测试和集成测试我们是无法注意到的。
- en: System tests play out their strength best if they combine multiple use cases
    to create scenarios. Each scenario represents a certain path a user might typically
    take through the application. If the most important scenarios are covered by passing
    system tests, we can assume that we haven’t broken them with our latest modifications
    and are ready to ship.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统测试结合多个用例来创建场景，它们就能发挥最大的优势。每个场景代表用户可能通过应用程序的某个特定路径。如果最重要的场景通过系统测试得到覆盖，我们可以假设我们最新的修改并没有破坏它们，并且可以准备发货。
- en: How much testing is enough?
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多少测试才算足够？
- en: A question many project teams I’ve been part of couldn’t answer is how much
    testing we should do. Is it enough if our tests cover 80% of our lines of code?
    Should it be higher than that?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我参与过的许多项目团队都无法回答的一个问题是我们应该进行多少测试。如果我们的测试覆盖了80%的代码行数，这足够了吗？应该更高吗？
- en: Line coverage is a bad metric to measure test success. Any goal other than 100%
    is completely meaningless because important parts of the code base might not be
    covered at all.[6](#footnote-026) And even at 100%, we still can’t be sure that
    every bug has been squashed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 行覆盖率不是一个衡量测试成功的良好指标。除了100%之外的其他任何目标都是完全没有意义的，因为代码库的重要部分可能根本未被覆盖。[6](#footnote-026)
    即使在100%的情况下，我们仍然不能确定每个错误都已被消除。
- en: '[6](#footnote-026-backlink) Test coverage: if you want to read more about 100%
    test coverage, have a look at my article with the tongue-in-cheek title Why you
    should enforce 100% code coverage at [https://reflectoring.io/100-percent-test-coverage/](https://reflectoring.io/100-percent-test-coverage/).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[6](#footnote-026-backlink) 测试覆盖率：如果你想了解更多关于100%测试覆盖率的信息，请查看我那带有讽刺意味标题的文章《为什么你应该强制执行100%代码覆盖率》，链接为[https://reflectoring.io/100-percent-test-coverage/](https://reflectoring.io/100-percent-test-coverage/)。'
- en: I suggest measuring test success by how comfortable we feel shipping the software.
    If we trust the tests enough to ship after having executed them, we’re good. The
    more often we ship, the more trust we have in our tests. If we only ship twice
    a year, no one will trust the tests because they only prove themselves twice a
    year.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议通过我们感觉有多舒服地发布软件来衡量测试的成功。如果我们对测试足够信任，在执行它们之后发布软件，那么我们就做得很好。我们发布得越频繁，我们对测试的信任就越多。如果我们一年只发布两次，没有人会信任测试，因为它们一年只证明自己两次。
- en: This requires a leap of faith the first couple of times we ship, but if we make
    it a priority to fix and learn from bugs in production, we’re on the right track.
    For each production bug, we should ask the question, *“Why didn’t our tests catch
    this bug?”*, document the answer, and then add a test that covers it. Over time,
    this will make us comfortable with shipping, and the documentation will even provide
    a metric for gauging our improvement over time.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要我们在前几次发布时跳出一个信仰的飞跃，但如果我们把修复和从生产中的错误中学习作为优先事项，我们就走上了正确的道路。对于每个生产错误，我们应该问自己，“为什么我们的测试没有捕捉到这个错误？”记录下答案，然后添加一个覆盖它的测试。随着时间的推移，这将使我们感到发布软件很舒服，而且文档甚至提供了一个衡量我们随着时间的推移改进的指标。
- en: 'It helps, however, to start with a strategy that defines the tests we should
    create. One such strategy for our Hexagonal Architecture is this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从定义我们应该创建的测试的策略开始是有帮助的。我们六边形架构的一个这样的策略是：
- en: While implementing a domain entity, cover it with a unit test.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实现领域实体时，用单元测试来覆盖它。
- en: While implementing a use case service, cover it with a unit test.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实现用例服务时，用单元测试来覆盖它。
- en: While implementing an adapter, cover it with an integration test.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实现适配器时，用集成测试来覆盖它。
- en: Cover the most important paths a user can take through the application with
    a system test.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用系统测试覆盖用户可以通过应用程序采取的最重要路径。
- en: Note the phrase *while implementing* – when tests are done during the development
    of a feature and not after, they become a development tool and no longer feel
    like a chore.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到短语“while implementing”——当测试在开发功能期间完成而不是之后，它们就变成了一个开发工具，不再感觉像是一项任务。
- en: However, if we have to spend an hour fixing tests every time we add a new field,
    we’re doing something wrong. Probably, our tests are too vulnerable to structural
    changes in the code, and we should look at how to improve that. Tests lose their
    value if we have to modify them for each refactoring.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们每次添加一个新字段时都必须花一个小时来修复测试，那么我们做错了。很可能，我们的测试对代码的结构变化过于脆弱，我们应该看看如何改进。如果我们不得不为每次重构修改测试，测试就会失去价值。
- en: How does this help me build maintainable software?
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这如何帮助我构建可维护的软件？
- en: The Hexagonal Architecture style cleanly separates domain logic and outward-facing
    adapters. This helps us to define a clear testing strategy that covers the central
    domain logic with unit tests and the adapters with integration tests.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 六边形架构风格清晰地分离了领域逻辑和外部适配器。这有助于我们定义一个清晰的测试策略，用单元测试覆盖中心领域逻辑，用集成测试覆盖适配器。
- en: The input and output ports provide very visible mocking points in tests. For
    each port, we can decide to mock it or use the real implementation. If the ports
    are each very small and focused, mocking them is a breeze instead of a chore.
    The fewer methods a port interface provides, the less confusion there is about
    which of the methods we have to mock in a test.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 输入和输出端口为测试提供了非常明显的模拟点。对于每个端口，我们可以决定模拟它或使用真实实现。如果端口每个都非常小且专注，模拟它们就像轻松完成任务一样，而不是一项任务。端口接口提供的方法越少，我们在测试中必须模拟的方法就越少混淆。
- en: If it becomes too much of a burden to mock things away, or if we don’t know
    which kind of test we should use to cover a certain part of the code base, that's
    a warning sign. In this regard, our tests have the additional responsibility of
    being a canary – to warn us about flaws in the architecture and steer us back
    on the path to creating a maintainable code base.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模拟某些事物变得过于繁重，或者如果我们不知道应该使用哪种测试来覆盖代码库的某个部分，那么这就是一个警告信号。在这方面，我们的测试有额外的责任，即充当一个“金丝雀”——提醒我们关于架构中的缺陷，并将我们引回创建可维护代码库的正确道路。
- en: So far, we have talked about our use cases and our adapters mostly in isolation.
    How do they communicate with each other? In the next chapter, we’ll take a look
    at some strategies for how to design data models that make up the common language
    between them.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要独立地讨论了我们的用例和适配器。它们之间是如何相互通信的呢？在下一章中，我们将探讨一些设计数据模型的方法，这些模型构成了它们之间的通用语言。
