- en: Chapter 1. REST – Where It Begins
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。REST - 从哪里开始
- en: Web services in the traditional SOA formats have been around for a long time
    to implement heterogeneous communication between applications. One way to support
    this kind of communication is to use the **Simple Object Access Protocol** (**SOAP**)/**Web
    Services Description Language** (**WSDL**) approach. SOAP/WSDL is an XML-based
    standard and works well when there is a strict contract between the services.
    We are now in the era of distributed services where different clients from the
    Web, mobile, as well as other services (internal or external), can make use of
    APIs exposed by different vendors and open source platforms. This requirement
    enforces the need for easier exchange of information between distributed services
    along with predictable, robust, well-defined interfaces.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 传统SOA格式的Web服务已经存在很长时间，用于实现应用程序之间的异构通信。支持这种通信的一种方式是使用**简单对象访问协议**（**SOAP**）/**Web服务描述语言**（**WSDL**）方法。SOAP/WSDL是一种基于XML的标准，在服务之间存在严格的合同时运行良好。我们现在处于分布式服务的时代，Web、移动客户端以及其他服务（内部或外部）可以利用不同供应商和开源平台提供的API。这种要求强调了分布式服务之间信息交换的需求，以及可预测、健壮、明确定义的接口。
- en: HTTP 1.1 is defined in RFC 2616, and is ubiquitously used as the standard protocol
    for distributed, collaborative hypermedia information systems. **Representational
    State Transfer** (**REST**) is inspired by HTTP and can be used wherever HTTP
    is used. This chapter will go over the basics of the RESTful services design and
    show how to produce and consume RESTful services, based on the standard Java API.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 1.1在RFC 2616中定义，并且被广泛用作分布式协作超媒体信息系统的标准协议。**表述状态转移**（**REST**）受到HTTP的启发，可以在任何使用HTTP的地方使用。本章将介绍RESTful服务设计的基础知识，并展示如何基于标准Java
    API生成和消费RESTful服务。
- en: This chapter covers the following topics.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题。
- en: Introduction to REST
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST介绍
- en: Safety and idempotence
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性和幂等性
- en: Design principles for building RESTful services
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建RESTful服务的设计原则
- en: Java Standard API for RESTful services
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RESTful服务的Java标准API
- en: Best practices when designing RESTful services
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计RESTful服务的最佳实践
- en: Introduction to REST
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST介绍
- en: 'REST is an architectural style that conforms to the web standards such as using
    HTTP verbs and URIs. It is bound by the following principles:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: REST是一种符合Web标准的架构风格，例如使用HTTP动词和URI。它受以下原则约束：
- en: All resources are identified by the URIs
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有资源都由URI标识
- en: All resources can have multiple representations
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有资源都可以有多种表示
- en: All resources can be accessed/modified/created/deleted by standard HTTP methods
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有资源都可以通过标准HTTP方法进行访问/修改/创建/删除
- en: There is no state information on the server
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器上没有状态信息
- en: REST and statelessness
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST和无状态性
- en: REST is bound by the principle of **statelessness**. Each request from the client
    to the server must have all the details to understand the request. This helps
    to improve visibility, reliability, and scalability for requests.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: REST受**无状态性**原则约束。客户端到服务器的每个请求必须具有理解请求的所有细节。这有助于提高请求的可见性、可靠性和可扩展性。
- en: '**Visibility** is improved, as the system monitoring the requests does not
    have to look beyond one request to get details. **Reliability** is improved as
    there is no check-pointing/resuming in case of partial failures. **Scalability**
    is improved because the number of requests that can be processed by the server
    increases, as the server is not responsible for storing any state.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**可见性**得到改善，因为监视请求的系统不必查看超出一个请求以获取详细信息。**可靠性**得到改善，因为在部分故障的情况下不需要检查点/恢复。**可扩展性**得到改善，因为服务器可以处理的请求数量增加，因为服务器不负责存储任何状态。'
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: Roy Fielding's dissertation on the REST architectural style provides details
    on the statelessness of REST. Check [http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm](http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm)
    for more information.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Roy Fielding关于REST架构风格的论文详细介绍了REST的无状态性。请访问[http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm](http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm)获取更多信息。
- en: With this initial introduction to the basics of REST, we shall cover the different
    maturity levels and how REST falls in it in the following section.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对REST的基础知识进行初步介绍，我们将在下一节中介绍不同的成熟度级别以及REST在其中的位置。
- en: The Richardson Maturity Model
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Richardson成熟度模型
- en: 'The **Richardson Maturity Model** is a model developed by Leonard Richardson.
    It talks about the basics of REST in terms of resources, verbs, and hypermedia
    controls. The starting point for the maturity model is to use the HTTP layer as
    the transport. This is shown in the following diagram:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**Richardson成熟度模型**是由Leonard Richardson开发的模型。它从资源、动词和超媒体控制的角度讨论了REST的基础知识。成熟度模型的起点是使用HTTP层作为传输。如下图所示：'
- en: '![The Richardson Maturity Model](img/7963OS_01_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![Richardson成熟度模型](img/7963OS_01_01.jpg)'
- en: Level 0 – Remote Procedure Invocation
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 0级 - 远程过程调用
- en: Level 0 contains SOAP or XML-RPC sending data as **Plain Old XML** (**POX**).
    Only the `POST` methods are used. This is the most primitive way of building SOA
    applications with a single `POST` method and using XML to communicate between
    services.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 0级包含将数据作为**普通旧XML**（**POX**）发送的SOAP或XML-RPC。只使用`POST`方法。这是构建具有单个`POST`方法的SOA应用程序的最原始方式，并使用XML在服务之间进行通信。
- en: Level 1 – REST resources
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1级 - REST资源
- en: Level 1 uses the `POST` methods and instead of using a function and passing
    arguments it uses the REST URIs. So, it still uses only one HTTP method. It is
    better than Level 0 as it breaks a complex functionality into multiple resources
    with the use of one `POST` method to communicate between services.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 1级使用`POST`方法，而不是使用函数和传递参数，而是使用REST URI。因此，它仍然只使用一个HTTP方法。它比0级更好，因为它将复杂功能分解为多个资源，并使用一个`POST`方法在服务之间进行通信。
- en: Level 2 – more HTTP verbs
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2级 - 更多的HTTP动词
- en: Level 2 uses other HTTP verbs such as `GET`, `HEAD`, `DELETE`, and `PUT` along
    with the `POST` methods. Level 2 is the real use case of REST, which advocates
    using different verbs based on the HTTP request methods and the system can have
    multiple resources.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Level 2使用其他HTTP动词，如“GET”、“HEAD”、“DELETE”和“PUT”，以及“POST”方法。 Level 2是REST的真正用例，它倡导根据HTTP请求方法使用不同的动词，系统可以具有多个资源。
- en: Level 3 – HATEOAS
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Level 3 – HATEOAS
- en: '**Hypermedia as the Engine of Application State** (**HATEOAS**) is the most
    mature level of Richardson''s model. The responses to the client requests contain
    hypermedia controls, which can help the client decide what is the next action
    they can take. Level 3 encourages easy discoverability and makes it easy for the
    responses to be self-explanatory. There is debate about whether HATEOAS is truly
    RESTful because the representation contains more information beyond just describing
    the resource. We will show details on how some platforms such as PayPal have implemented
    HATEOAS as part of their APIs in [Chapter 5](ch05.html "Chapter 5. Advanced Design
    Principles"), *Advanced Design Principles*.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**超媒体作为应用状态的引擎**（**HATEOAS**）是Richardson模型的最成熟级别。对客户端请求的响应包含超媒体控件，这可以帮助客户端决定下一步可以采取什么行动。
    Level 3鼓励易于发现，并使响应易于自我解释。关于HATEOAS是否真正符合RESTful存在争议，因为表示包含了除了描述资源之外的更多信息。我们将展示一些平台如PayPal如何在其API的一部分中实现HATEOAS的详细信息在[第5章](ch05.html
    "第5章.高级设计原则")，“高级设计原则”中。'
- en: The next section covers safety and idempotence, the two important terminologies
    when dealing with RESTful services.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节涵盖了安全性和幂等性，这是处理RESTful服务时的两个重要术语。
- en: Safety and idempotence
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性和幂等性
- en: The following section discusses in detail what are safe and idempotent methods.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将详细讨论什么是安全和幂等方法。
- en: Safe methods
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全方法
- en: Safe methods are methods that do not change the state on the server. For example,
    `GET /v1/coffees/orders/1234` is a safe method.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 安全方法是不会改变服务器状态的方法。例如，“GET /v1/coffees/orders/1234”是一个安全方法。
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Safe methods can be cached. `GET` and `HEAD` are safe methods.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 安全方法可以被缓存。“GET”和“HEAD”是安全方法。
- en: The `PUT` method is not safe as it will create or modify a resource on the server.
    The `POST` method is not safe for the same reasons. The `DELETE` method is not
    safe as it deletes a resource on the server.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: “PUT”方法不安全，因为它会在服务器上创建或修改资源。“POST”方法由于相同的原因也不安全。“DELETE”方法不安全，因为它会删除服务器上的资源。
- en: Idempotent methods
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 幂等方法
- en: An idempotent method is a method that will produce the same results irrespective
    of how many times it is called.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 幂等方法是一种无论调用多少次都会产生相同结果的方法。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `GET` method is idempotent, as multiple calls to the `GET` resource will
    always return the same response.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: “GET”方法是幂等的，因为对“GET”资源的多次调用将始终返回相同的响应。
- en: The `PUT` method is idempotent as calling the `PUT` method multiple times will
    update the same resource and not change the outcome.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: “PUT”方法是幂等的，多次调用“PUT”方法将更新相同的资源并且不会改变结果。
- en: '`POST` is not idempotent and calling the `POST` method multiple times can have
    different results and will result in creating new resources. `DELETE` is idempotent
    because once the resource is deleted, it is gone and calling the method multiple
    times will not change the outcome.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: “POST”不是幂等的，多次调用“POST”方法可能会产生不同的结果，并且会导致创建新资源。“DELETE”是幂等的，因为一旦资源被删除，它就消失了，多次调用该方法不会改变结果。
- en: Design principles for building RESTful services
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建RESTful服务的设计原则
- en: 'Here is the process of designing, developing, and testing RESTful services.
    We will cover each of these in detail in this chapter:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是设计、开发和测试RESTful服务的过程。我们将在本章中详细介绍每个过程：
- en: Identifying the resource URIs
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别资源URI
- en: This process involves deciding what nouns will represent your resource.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程涉及决定名词将代表您的资源。
- en: Identifying the methods supported by the resource
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别资源支持的方法
- en: This process involves using the various HTTP methods for CRUD operations.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程涉及使用各种HTTP方法进行CRUD操作。
- en: Identifying the different representations supported by the resource
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别资源支持的不同表示
- en: This step involves choosing whether the resource representation should be JSON,
    XML, HTML, or plain text.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤涉及选择资源表示应该是JSON、XML、HTML还是纯文本。
- en: Implementing the RESTful services using JAX-RS APIs
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JAX-RS API实现RESTful服务
- en: The API needs to be implemented based on the JAX-RS specification
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: API需要基于JAX-RS规范实现
- en: Deploying the RESTful services
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署RESTful服务
- en: Deploy the service on an application container such as Tomcat, Glassfish, and
    WildFly. The samples show how to create a WAR file and deploy on Glassfish 4.0
    and it can work with any JavaEE 7-compliant container.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将服务部署在诸如Tomcat、Glassfish和WildFly之类的应用容器上。示例展示了如何创建WAR文件并在Glassfish 4.0上部署，它可以与任何符合JavaEE
    7标准的容器一起使用。
- en: Testing the RESTful services
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试RESTful服务
- en: Write the client API for testing the services or use curl-or-browser-based tools
    to test the REST requests.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 编写客户端API以测试服务，或使用curl或基于浏览器的工具来测试REST请求。
- en: Identifying the resource URIs
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别资源URI
- en: RESTful resources are identified by resource URIs. REST is extensible due to
    the use of URIs for identifying resources.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful资源由资源URI标识。由于使用URI来标识资源，REST是可扩展的。
- en: 'The following table shows sample URIs, which can represent different resources
    in the system:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了示例URI，可以表示系统中的不同资源：
- en: '| URI | Description of the URI |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| URI | URI的描述 |'
- en: '| --- | --- |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `/v1/library/books` | This is used to represent a collection of book resources
    in a library |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `/v1/library/books` | 用于表示图书馆中的一组图书资源 |'
- en: '| `/v1/library/books/isbn/12345678` | This is used to represent a single book
    identified by its ISBN "12345678" |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `/v1/library/books/isbn/12345678` | 用于表示由其ISBN“12345678”标识的单本书 |'
- en: '| `/v1/coffees` | This is used to represent all the coffees that are sold by
    a coffee shop |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `/v1/coffees` | 用于表示咖啡店出售的所有咖啡 |'
- en: '| `/v1/coffees/orders` | This is used to represent all the coffees that are
    ordered |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `/v1/coffees/orders` | 这用于表示所有已订购的咖啡 |'
- en: '| `/v1/coffees/orders/123` | This is used to represent a single order of coffee
    identified by "123" |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `/v1/coffees/orders/123` | 这用于表示由“123”标识的咖啡订单 |'
- en: '| `/v1/users/1235` | This is used to represent a user in a system identified
    by "1235" |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `/v1/users/1235` | 这用于表示系统中由“1235”标识的用户 |'
- en: '| `/v1/users/5034/books` | This is used to represent all the books for a user
    identified by "5034" |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `/v1/users/5034/books` | 这用于表示由“5034”标识的用户的所有书籍 |'
- en: 'All the preceding samples show a clear readable pattern, which can be interpreted
    by the client. All these resources could have multiple representations. These
    examples of resources shown in the preceding table can be represented by JSON,
    XML, HTML, or plain text and can be manipulated by HTTP methods: `GET`, `PUT`,
    `POST`, and `DELETE`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前面的示例都显示了一个清晰可读的模式，客户端可以解释。所有这些资源都可以有多个表示。在前面的表中显示的这些资源示例可以由JSON、XML、HTML或纯文本表示，并且可以通过HTTP方法`GET`、`PUT`、`POST`和`DELETE`进行操作。
- en: Identifying the methods supported by the resource
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别资源支持的方法
- en: HTTP verbs comprise a major portion of the uniform interface constraint, which
    defines the association between the actions identified by the verb, to the noun-based
    REST resource.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP动词占据了统一接口约束的主要部分，该约束定义了动词识别的操作与基于名词的REST资源之间的关联。
- en: The following table summarizes HTTP methods and descriptions for the actions
    taken on the resource with a simple example of a collection of books in a library.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了HTTP方法和对资源采取的操作的描述，以图书馆中书籍集合的简单示例为例。
- en: '| HTTP method | Resource URI | Description |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| HTTP方法 | 资源URI | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `GET` | `/library/books` | This gets a list of books |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/library/books` | 这获取书籍列表 |'
- en: '| `GET` | `/library/books/isbn/12345678` | This gets a book identified by ISBN
    "12345678" |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/library/books/isbn/12345678` | 这获取由ISBN“12345678”标识的书籍 |'
- en: '| `POST` | `/library/books` | This creates a new book order |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | `/library/books` | 这创建一个新的书籍订单 |'
- en: '| `DELETE` | `/library/books/isbn/12345678` | This deletes a book identified
    by ISBN "12345678" |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | `/library/books/isbn/12345678` | 这将删除由ISBN“12345678”标识的书籍 |'
- en: '| `PUT` | `/library/books/isbn/12345678` | This updates a specific book identified
    by ISBN "12345678'' |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | `/library/books/isbn/12345678` | 这将更新由ISBN“12345678”标识的特定书籍 |'
- en: '| `PATCH` | `/library/books/isbn/12345678` | This can be used to do a partial
    update for a book identified by ISBN "12345678" |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | `/library/books/isbn/12345678` | 这可用于对由ISBN“12345678”标识的书籍进行部分更新
    |'
- en: The next section will cover the semantics of each HTTP verb in the context of
    REST.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将介绍每个HTTP动词在REST上下文中的语义。
- en: HTTP verbs and REST
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP动词和REST
- en: HTTP verbs inform the server what to do with the data sent as part of the URL.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP动词告诉服务器如何处理作为URL一部分发送的数据。
- en: GET
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取
- en: The `GET` method is the simplest verb of HTTP, which enables us to get access
    to a resource. Whenever the client clicks a URL in the browser, it sends a `GET`
    request to the address specified by the URL. `GET` is safe and idempotent. The
    `GET` requests are cached. Query parameters can be used in `GET` requests.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET`方法是HTTP的最简单动词，它使我们能够访问资源。每当客户端在浏览器中点击URL时，它会向URL指定的地址发送`GET`请求。`GET`是安全和幂等的。`GET`请求被缓存。`GET`请求中可以使用查询参数。'
- en: 'For example, a simple `GET` request to retrieve all active users is as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，检索所有活动用户的简单`GET`请求如下所示：
- en: '[PRE0]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: POST
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: POST
- en: '`POST` is used to create a resource. The `POST` requests are neither idempotent
    nor safe. Multiple invocations of the `POST` requests can create multiple resources.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST`用于创建资源。`POST`请求既不是幂等的，也不是安全的。多次调用`POST`请求可以创建多个资源。'
- en: The `POST` requests should invalidate a cache entry if it exists. Query parameters
    with the `POST` requests are not encouraged.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在缓存条目，`POST`请求应该使缓存条目无效。不鼓励在`POST`请求中使用查询参数。
- en: 'For example, a `POST` request to create a user can be as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，创建用户的`POST`请求可以如下所示：
- en: '[PRE1]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: PUT
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 放置
- en: '`PUT` is used to update a resource. `PUT` is idempotent but not safe. Multiple
    invocations of the `PUT` requests should produce the same results by updating
    the resource.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUT`用于更新资源。`PUT`是幂等的，但不安全。多次调用`PUT`请求应该通过更新资源产生相同的结果。'
- en: The `PUT` requests should invalidate the cache entry if it exists.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在缓存条目，`PUT`请求应该使缓存条目无效。
- en: 'For example, a `PUT` request to update a user can be as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，更新用户的`PUT`请求可以如下所示：
- en: '[PRE2]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: DELETE
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: DELETE
- en: '`DELETE` is used to delete a resource. `DELETE` is idempotent but not safe.
    This is idempotent because based on the RFC 2616, the side effects of N > 0 requests
    is the same as for a single request. This means once the resource is deleted,
    calling `DELETE` multiple times will get the same response.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`DELETE`用于删除资源。`DELETE`是幂等的，但不安全。这是幂等的，因为根据RFC 2616，N > 0请求的副作用与单个请求相同。这意味着一旦资源被删除，多次调用`DELETE`将获得相同的响应。'
- en: 'For example, a request to delete a user can be as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，删除用户的请求可以如下所示：
- en: '[PRE3]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: HEAD
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 头
- en: '`HEAD` is similar to the `GET` request. The difference is that only HTTP headers
    are returned and no content is returned. `HEAD` is idempotent and safe.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`HEAD`类似于`GET`请求。不同之处在于只返回HTTP标头，不返回内容。`HEAD`是幂等和安全的。'
- en: 'For example, a request to send a `HEAD` request with curl is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用curl发送`HEAD`请求的请求如下所示：
- en: '[PRE4]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It can be useful to send a `HEAD` request to see if the resource has changed
    before trying to get a large representation using a `GET` request.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试使用`GET`请求获取大型表示之前，发送`HEAD`请求以查看资源是否已更改可能很有用。
- en: PUT versus POST
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PUT与POST
- en: According to RFC, the difference between `PUT` and `POST` is in the Request
    URI. The URI identified by `POST` defines the entity that will handle the `POST`
    request. The URI in the `PUT` request includes the entity in the request.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 根据RFC，`PUT`和`POST`之间的区别在于请求URI。由`POST`标识的URI定义将处理`POST`请求的实体。`PUT`请求中的URI包括请求中的实体。
- en: So, `POST /v1/coffees/orders` means to create a new resource and return an identifier
    to describe the resource. In contrast, `PUT /v1/coffees/orders/1234` means to
    update a resource identified by `"1234"` if it exists; else create a new order
    and use the `orders/1234` URI to identify it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`POST /v1/coffees/orders`表示创建一个新资源并返回一个标识符来描述该资源。相反，`PUT /v1/coffees/orders/1234`表示更新由“1234”标识的资源（如果存在）；否则创建一个新订单并使用`orders/1234`
    URI来标识它。
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`PUT` and `POST` can both be used to create or update methods. The usage of
    the method depends on the idempotence behavior expected from the method as well
    as the location of the resource to identify it.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUT`和`POST`都可以用于创建或更新方法。方法的使用取决于期望从方法获得的幂等行为以及用于标识资源的位置。'
- en: The next section will cover how to identify the different representations of
    the resource.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将介绍如何识别资源的不同表示形式。
- en: Identifying the different representations of the resource
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别资源的不同表示形式
- en: The RESTful resources are abstract entities, which need to be serialized to
    a representation before they can be communicated to the client. The common representations
    for a resource can be XML, JSON, HTML, or plain text. A resource can provide the
    representation to the client based on what the client can handle. A client can
    specify which language and media type it prefers. This is known as **content negotiation**.
    [Chapter 2](ch02.html "Chapter 2. Resource Design"), *Resource Design*, covers
    the content negotiation topic in detail.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful资源是抽象实体，需要在与客户端通信之前被序列化为表示。资源的常见表示可以是XML、JSON、HTML或纯文本。资源可以根据客户端的处理能力向客户端提供表示。客户端可以指定它偏好的语言和媒体类型。这被称为**内容协商**。[第2章](ch02.html
    "第2章。资源设计")，“资源设计”，详细介绍了内容协商主题。
- en: Implementing the APIs
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现API
- en: 'Now that we have some idea on designing RESTful resources and associating HTTP
    verbs to take actions on the resources, we will cover what it takes to implement
    the APIs and build a RESTful service. This section will cover the following topic:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对设计RESTful资源和将HTTP动词与资源上的操作关联有了一些了解，我们将介绍实现API和构建RESTful服务所需的内容。本节将涵盖以下主题：
- en: Java API for RESTful Services (JAX-RS)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于RESTful服务的Java API（JAX-RS）
- en: The Java API for RESTful Services (JAX-RS)
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于RESTful服务的Java API（JAX-RS）
- en: The Java API for RESTful services provides portable APIs for building and developing
    applications based on the REST architectural style. Using JAX-RS, Java POJOs can
    be exposed as RESTful web resources, which are independent of the underlying technology
    and use a simple annotation-based API.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 用于RESTful服务的Java API提供了用于构建和开发基于REST架构风格的应用程序的可移植API。使用JAX-RS，Java POJO可以作为RESTful
    web资源公开，这些资源独立于底层技术，并使用基于注释的简单API。
- en: 'JAX-RS 2.0 is the latest version of the specification and has newer features
    compared to its predecessor JAX-RS 1.0, especially in the following areas:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS 2.0是规范的最新版本，与其前身JAX-RS 1.0相比，在以下领域特别是具有更新的功能：
- en: Bean validation support
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bean验证支持
- en: Client API support
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端API支持
- en: Asynchronous invocation support
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步调用支持
- en: Jersey is the implementation of JAX-RS specification.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Jersey是JAX-RS规范的实现。
- en: 'We will cover all these topics in detail in the subsequent chapters. We are
    demonstrating a simple coffee shop example where you can create a REST resource
    called `CoffeesResource`, which can do the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在随后的章节中详细介绍所有这些主题。我们正在演示一个简单的咖啡店示例，您可以在其中创建一个名为`CoffeesResource`的REST资源，该资源可以执行以下操作：
- en: Give details of the orders placed
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供已下订单的详细信息
- en: Create new orders
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新订单
- en: Get details on a specific order
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取特定订单的详细信息
- en: 'To create a RESTful resource, we begin with a POJO called `CoffeesResource`.
    An example of a JAX-RS resource is shown as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个RESTful资源，我们从一个名为`CoffeesResource`的POJO开始。以下是JAX-RS资源的示例：
- en: '[PRE5]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As shown in the preceding code, we create a small POJO called `CoffeesResource`.
    We annotate the class with `@Path("v1/coffees")`, which identifies the URI path
    this class serves requests for.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前面的代码所示，我们创建了一个名为`CoffeesResource`的小型POJO。我们使用`@Path("v1/coffees")`对类进行注释，该注释标识了该类为请求提供服务的URI路径。
- en: 'Next, we define a method called `getCoffeeList()`. This method has the following
    annotations:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一个名为`getCoffeeList()`的方法。该方法具有以下注释：
- en: '`@GET`: This indicates that the annotated method represents a HTTP `GET` request.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@GET`：这表示被注释的方法代表一个HTTP `GET`请求。'
- en: '`@PATH`: In this example, the `GET` requests for `v1/coffees/orders` will be
    handled by this `getCoffeeList()` method.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@PATH`：在此示例中，`GET`请求`v1/coffees/orders`将由`getCoffeeList()`方法处理。'
- en: '`@Produces`: This defines the media types produced by this resource. In our
    preceding snippet, we define the `MediaType.APPLICATION_JSON` that has the `application/json`
    value.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Produces`：这定义了此资源生成的媒体类型。在我们之前的片段中，我们定义了`MediaType.APPLICATION_JSON`，其值为`application/json`。'
- en: 'Another method to create an order is as follows:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一种创建订单的方法如下：
- en: '[PRE6]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For the second method of creating an order, we defined a method called `addCoffee()`.
    This method has the following annotations:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于创建订单的第二种方法，我们定义了一个名为`addCoffee()`的方法。该方法具有以下注释：
- en: '`@POST`: This indicates that the annotated method represents the HTTP `POST`
    request.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@POST`：这表示被注释的方法代表HTTP `POST`请求。'
- en: '`@Consumes`: This defines the media types consumed by this resource. In our
    preceding snippet, we define the `MediaType.APPLICATION_JSON` that has the `application/json`
    value.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Consumes`：这定义了此资源消耗的媒体类型。在我们之前的片段中，我们定义了`MediaType.APPLICATION_JSON`，其值为`application/json`。'
- en: '`@Produces`: This defines the media types produced by this resource. In our
    preceding snippet, we define the `MediaType.APPLICATION_JSON` that has the `application/json`
    value.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Produces`：这定义了此资源生成的媒体类型。在我们之前的片段中，我们定义了`MediaType.APPLICATION_JSON`，其值为`application/json`。'
- en: '`@ValidateOnExecution`: This specifies which methods should have their parameters
    or return values validated on execution. More details on the `@ValidateOnExecution`
    and `@Valid` annotations will be covered in [Chapter 3](ch03.html "Chapter 3. Security
    and Traceability"), *Security and Traceability*.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ValidateOnExecution`：这指定了应在执行时验证其参数或返回值的方法。有关`@ValidateOnExecution`和`@Valid`注释的更多详细信息将在[第3章](ch03.html
    "第3章。安全性和可追溯性")*安全性和可追溯性*中介绍。'
- en: Thus, we saw with a simple sample on how easy it is to convert a simple POJO
    to a REST resource. Now, we will cover the `Application` subclass, which will
    define the components of a JAX-RS application including the metadata.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们看到了一个简单示例，说明了将简单的POJO转换为REST资源有多么容易。现在，我们将介绍`Application`子类，该子类将定义JAX-RS应用程序的组件，包括元数据。
- en: 'The following is the code for a sample `Application` subclass named `CoffeeApplication`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是名为`CoffeeApplication`的示例`Application`子类的代码：
- en: '[PRE7]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As shown in the preceding code snippet, the `getClasses()` method has been overridden
    and we add the `CoffeesResource` class to the `Application` subclass. The `Application`
    classes can be part of `WEB-INF/classes` or `WEB-INF/lib` in the WAR file.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，`getClasses()`方法已被重写，并且我们将`CoffeesResource`类添加到`Application`子类中。`Application`类可以是WAR文件中的`WEB-INF/classes`或`WEB-INF/lib`的一部分。
- en: Deploying the RESTful services
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署RESTful服务
- en: Once we have created the resource and added the meta-information to the Application
    subclass, the next step is to build the WAR file .The WAR file can be deployed
    on any servlet container.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了资源并将元信息添加到Application子类中，下一步就是构建WAR文件。WAR文件可以部署在任何servlet容器上。
- en: The source for the samples is available as part of the downloadable bundle with
    this book, which will have detailed steps to deploy and run the samples.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 示例的源代码作为本书的可下载捆绑包的一部分提供，其中将详细介绍部署和运行示例的步骤。
- en: Test the RESTful services
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试RESTful服务
- en: We can then use the Client API functionality provided by JAX-RS 2.0 to access
    the resources.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用JAX-RS 2.0提供的Client API功能来访问资源。
- en: 'This section will cover the following topics:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将涵盖以下主题：
- en: Client API with JAX-RS 2.0
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JAX-RS 2.0的Client API
- en: Accessing RESTful resources using curl, or a browser-based extension called
    Postman
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用curl或名为Postman的基于浏览器的扩展访问RESTful资源
- en: The Client API with JAX-RS 2.0
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JAX-RS 2.0的Client API
- en: JAX-RS 2.0 had newer Client APIs for accessing RESTful resources. The entry
    point of the client API is `javax.ws.rs.client.Client`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS 2.0为访问RESTful资源提供了更新的Client API。客户端API的入口点是`javax.ws.rs.client.Client`。
- en: 'With the newly introduced Client API in JAX-RS 2.0, the endpoint can be accessed
    as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JAX-RS 2.0中新引入的Client API，可以访问端点如下：
- en: '[PRE8]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As shown in the preceding snippet, the default instance of the client is obtained
    using the `ClientFactory.newClient()` method. Using the `target` method, we create
    a `WebTarget` object. These target objects are then used to prepare the request
    by adding the method and the query parameters.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，使用`ClientFactory.newClient()`方法获取了客户端的默认实例。使用`target`方法，我们创建了一个`WebTarget`对象。然后使用这些目标对象通过添加方法和查询参数来准备请求。
- en: 'Prior to these APIs, the way we would get access to REST resources was like
    this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些API之前，我们访问REST资源的方式是这样的：
- en: '[PRE9]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Thus, we can see how there has been an improvement in the JAX-RS 2.0 Client-side
    API support to avoid using `HTTPURLConnection` and instead use the fluent Client
    API.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到JAX-RS 2.0客户端API支持已经改进，以避免使用`HTTPURLConnection`，而是使用流畅的客户端API。
- en: 'If the request is a `POST` request:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求是`POST`请求：
- en: '[PRE10]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `WebTarget.request()` method returns a `javax.ws.rs.client.InvocationBuilder`,
    which takes a `post()` method to invoke a HTTP `POST` request. The `post()` method
    takes an entity from the `Coffee` instance and specifies that the media type is
    `"APPLICATION_XML"`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebTarget.request()`方法返回一个`javax.ws.rs.client.InvocationBuilder`，它使用`post()`方法来调用HTTP
    `POST`请求。`post()`方法使用`Coffee`实例的实体，并指定媒体类型为`"APPLICATION_XML"`。'
- en: A `MessageBodyReaderWriter` implementation is registered with the client. More
    on `MessageBodyReader` and `MessageBodyWriter` will be covered in [Chapter 2](ch02.html
    "Chapter 2. Resource Design"), *Resource Design*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageBodyReaderWriter`实现已在客户端中注册。有关`MessageBodyReader`和`MessageBodyWriter`的更多信息将在[第2章](ch02.html
    "第2章。资源设计")*资源设计*中介绍。'
- en: The following table summarizes some of the main JAX-RS classes/annotations we
    covered so far.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了到目前为止我们所涵盖的一些主要JAX-RS类/注释。
- en: '| Name of annotation | Description |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 注释名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `javax.ws.rs.Path` | This identifies the URI path that the resource serves
    a method for |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `javax.ws.rs.Path` | 这标识了资源为方法提供的URI路径 |'
- en: '| `javax.ws.rs.ApplicationPath` | This is used by a subclass of `Application`
    as a base URI for all URIs supplied by the resources in application |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `javax.ws.rs.ApplicationPath` | 这被`Application`的子类用作应用程序中所有资源提供的所有URI的基本URI
    |'
- en: '| `javax.ws.rs.Produces` | This defines the media type that the resource can
    produce |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `javax.ws.rs.Produces` | 这定义了资源可以生成的媒体类型 |'
- en: '| `javax.ws.rs.Consumes` | This defines the media type that the resource can
    consume |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `javax.ws.rs.Consumes` | 这定义了资源可以消耗的媒体类型 |'
- en: '| `javax.ws.rs.client.Client` | This defines the entry point for client requests
    |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `javax.ws.rs.client.Client` | 这定义了客户端请求的入口点 |'
- en: '| `javax.ws.rs.client.WebTarget` | This defines a resource target identified
    by the URI |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `javax.ws.rs.client.WebTarget` | 这定义了由URI标识的资源目标 |'
- en: Note
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Clients are heavyweight objects that help facilitate the client-side communication
    infrastructure. It is therefore advised to construct only a small number of client
    instances in the application, as initialization as well as disposal of a client
    instance may be a rather expensive operation. Additionally, client instances must
    be properly closed before being disposed to avoid leaking resources.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端是帮助简化客户端通信基础设施的重量级对象。因此，建议在应用程序中仅构建少量客户端实例，因为初始化和处理客户端实例可能是一个相当昂贵的操作。此外，必须在处理之前正确关闭客户端实例，以避免资源泄漏。
- en: Accessing RESTful resources
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问RESTful资源
- en: The following section covers the different ways REST resources can be accessed
    and tested by clients.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分涵盖了客户端可以访问和测试REST资源的不同方式。
- en: cURL
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: cURL
- en: 'cURL is a popular command-line tool for testing REST APIs. The cURL library
    and the cURL command give the user the ability to create a request, put it on
    the pipe, and explore the response. The following are a few samples of `curl`
    requests for some basic functions:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: cURL是一个用于测试REST API的流行命令行工具。cURL库和cURL命令使用户能够创建请求，将其放在管道上，并探索响应。以下是一些用于一些基本功能的`curl`请求的示例：
- en: '| curl request | Description |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| curl请求 | 描述 |'
- en: '| --- | --- |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `curl http://api.foo.com/v1/coffees/1` | This is a simple `GET` request |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `curl http://api.foo.com/v1/coffees/1` | 这是一个简单的`GET`请求 |'
- en: '| `curl -H "foo:bar" http://api.foo.com/v1/coffees` | This is an example of
    a `curl` request for adding request headers using `-H` |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `curl -H "foo:bar" http://api.foo.com/v1/coffees` | 这是一个使用`-H`添加请求头的`curl`请求的示例
    |'
- en: '| `curl -i http://api.foo.com/v1/coffees/1` | This is an example of a `curl`
    command to view response headers using `-i` |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `curl -i http://api.foo.com/v1/coffees/1` | 这是一个使用`-i`查看响应头的`curl`命令的示例 |'
- en: '| `curl –X POST -d''{"name":"John Doe","username":"jdoe", "phone":"412-344-5644"}
    http://api.foo.com/v1/users` | This is an example of a `curl` request for a `POST`
    method to create a user |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `curl –X POST -d''{"name":"John Doe","username":"jdoe", "phone":"412-344-5644"}
    http://api.foo.com/v1/users` | 这是一个用于创建用户的`POST`方法的`curl`请求的示例 |'
- en: Even though cURL is extremely powerful, it has a lot of options to remember
    and use. Sometimes, it helps to use a browser-based tool to develop REST API such
    as Postman or Advanced REST client.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管cURL非常强大，但有很多选项需要记住和使用。有时，使用基于浏览器的工具来开发REST API，如Postman或高级REST客户端，会有所帮助。
- en: Postman
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Postman
- en: Postman on the Chrome browser is an excellent tool to test and develop REST
    API. It has a JSON and XML viewer for rendering the data. It can also allow previewing
    HTTP 1.1 requests, replay, and organize requests for future use. Postman shares
    the same environment as the browser and can display browser cookies too.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome浏览器上的Postman是一个非常好的测试和开发REST API的工具。它具有用于呈现数据的JSON和XML查看器。它还可以允许预览HTTP
    1.1请求，重播，并组织请求以供将来使用。Postman与浏览器共享相同的环境，也可以显示浏览器cookie。
- en: An advantage of Postman over cURL is that there is a nice user interface for
    entering parameters so that the user does not need to deal with commands or scripts.
    Various authorization schemes such as a basic user authentication and digest access
    authentication are also supported.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Postman相对于cURL的优势在于有一个很好的用户界面，可以输入参数，用户不需要处理命令或脚本。还支持各种授权方案，如基本用户认证和摘要访问认证。
- en: 'The following is a screenshot, which shows how to send queries in Postman:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一张截图，显示了如何在Postman中发送查询：
- en: '![Postman](img/7963OS_01_02.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![Postman](img/7963OS_01_02.jpg)'
- en: As shown in the preceding screenshot, we see the Postman application. A simple
    way to test Postman is to launch the Postman Application from Chrome.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，我们看到了Postman应用程序。测试Postman的一个简单方法是从Chrome启动Postman应用程序。
- en: Then, select the HTTP method `GET` and paste the `api.postcodes.io/random/postcodes`
    URL. (PostCodes is a free, open source service based on geodata.)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，选择HTTP方法`GET`并粘贴`api.postcodes.io/random/postcodes` URL。（PostCodes是一个基于地理数据的免费开源服务。）
- en: 'You will see a JSON response like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一个JSON响应，类似于这样：
- en: '[PRE11]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Tip
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)购买的Packt图书的帐户中下载示例代码文件。如果您在其他地方购买了本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便直接通过电子邮件接收文件。
- en: On the left pane of the preceding screenshot are different queries, which have
    been added to a collection like getting all the coffee orders, getting a specific
    order, creating orders, and so on based on testing the various samples in this
    book. You can create custom collections of queries similarly.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面截图的左侧窗格中有不同的查询，这些查询已经根据本书中的各种示例添加到了一个集合中，例如获取所有咖啡订单，获取特定订单，创建订单等等。您也可以类似地创建自定义查询集合。
- en: Note
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more details, check [http://www.getpostman.com/](http://www.getpostman.com/).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多详情，请访问[http://www.getpostman.com/](http://www.getpostman.com/)。
- en: Other tools
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 其他工具
- en: Here are some additional tools, which can be very useful when working with REST
    resources.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些在处理REST资源时非常有用的其他工具。
- en: Advanced REST Client
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 高级REST客户端
- en: Advanced REST Client is another Chrome extension based on Google WebToolkit,
    which allows the user to test and develop REST API.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 高级REST客户端是另一个基于Google WebToolkit的Chrome扩展，允许用户测试和开发REST API。
- en: JSONLint
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: JSONLint
- en: JSONLint is a simple online validator that ensures the JSON is valid. When sending
    JSON data as part of requests, it is useful to validate if the format of the data
    conforms to the JSON specification. In such cases, the client can validate the
    input using JSONLint. For more details, check [http://jsonlint.com/](http://jsonlint.com/).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: JSONLint是一个简单的在线验证器，可确保JSON有效。在发送JSON数据作为请求的一部分时，验证数据格式是否符合JSON规范是有用的。在这种情况下，客户端可以使用JSONLint验证输入。要了解更多详情，请访问[http://jsonlint.com/](http://jsonlint.com/)。
- en: Best practices when designing resources
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计资源时的最佳实践
- en: 'The following section highlights some of the best practices when designing
    RESTful resources:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分突出显示了设计RESTful资源时的一些最佳实践：
- en: The API developer should use nouns to understand and navigate through resources
    and verbs with the HTTP method, for example, the /user/1234/books is better than
    /user/1234/getBook URI.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API开发者应该使用名词来理解和浏览资源，使用HTTP方法和动词，例如，/user/1234/books比/user/1234/getBook URI更好。
- en: Use associations in the URIs to identify subresources. For example, to get the
    authors for book 5678, for user 1234, use the following `/user/1234/books/5678/authors`
    URI.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在URI中使用关联来标识子资源。例如，要获取用户1234的书籍5678的作者，使用以下URI：`/user/1234/books/5678/authors`。
- en: For specific variations, use query parameters. For example, to get all the books
    with 10 reviews, use `/user/1234/books?reviews_counts=10`.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于特定的变化，使用查询参数。例如，要获取所有具有10条评论的书籍，使用`/user/1234/books?reviews_counts=10`。
- en: Allow partial responses as part of query parameters if possible. An example
    of this case is to get only the name and age of a user, the client can specify,
    ?fields as a query parameter and specify the list of fields that should be sent
    by the server in the response using the `/users/1234?fields=name,age` URI.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可能，允许部分响应作为查询参数的一部分。例如，在获取用户的姓名和年龄时，客户端可以指定`?fields`作为查询参数，并使用`/users/1234?fields=name,age`
    URI指定应该由服务器在响应中发送的字段列表。
- en: Have defaults for the output format for the response in case the client does
    not specify which format it is interested in. Most API developers choose to send
    JSON as the default response mime type.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端没有指定感兴趣的格式时，为响应的输出格式设置默认值。大多数API开发人员选择将JSON作为默认响应MIME类型发送。
- en: Have camelCase or use `_` for attribute names.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用camelCase或使用“_”作为属性名称。
- en: Support a standard API for counts, for example `users/1234/books/count`, in
    case of collections so that the client can get an idea of how many objects can
    be expected in the response.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持标准API以获取计数，例如`users/1234/books/count`，以便客户端可以了解响应中可以期望多少对象。
- en: This will also help the client with pagination queries. More details on pagination
    will be covered in [Chapter 5](ch05.html "Chapter 5. Advanced Design Principles"),
    *Advanced Design Principles*.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这也将帮助客户端进行分页查询。关于分页的更多细节将在[第5章](ch05.html "第5章.高级设计原则")中涵盖，*高级设计原则*。
- en: Support a pretty printing option, `users/1234?pretty_print`. Also, it is a good
    practice to not cache queries with a pretty print query parameter.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持漂亮打印选项，`users/1234?pretty_print`。另外，不缓存带有漂亮打印查询参数的查询是一个良好的实践。
- en: Avoid chattiness by being as verbose as possible in the response. This is because
    if the server does not provide enough details in the response, the client needs
    to make more calls to get additional details. That is a waste of network resources
    as well as counts against the client's rate limits. More details on rate limiting
    are covered in [Chapter 5](ch05.html "Chapter 5. Advanced Design Principles"),
    *Advanced Design Principles*.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量详细地避免啰嗦。这是因为如果服务器在响应中没有提供足够的细节，客户端需要进行更多的调用以获取额外的细节。这不仅浪费了网络资源，还会影响客户端的速率限制。关于速率限制的更多细节在[第5章](ch05.html
    "第5章.高级设计原则")中有所涵盖，*高级设计原则*。
- en: Recommended reading
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推荐阅读
- en: 'The following links may be useful to review for more details:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下链接可能对查看更多细节有用：
- en: '**RFC 2616**: [http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html](http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html)'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RFC 2616**：[http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html](http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html)'
- en: '**Richardson Maturity Model**: [http://www.crummy.com/writing/speaking/2008-QCon/act3.html](http://www.crummy.com/writing/speaking/2008-QCon/act3.html)'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Richardson成熟度模型**：[http://www.crummy.com/writing/speaking/2008-QCon/act3.html](http://www.crummy.com/writing/speaking/2008-QCon/act3.html)'
- en: '**Jersey implementation of JAX-RS**: [https://jersey.java.net/](https://jersey.java.net/)'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JAX-RS的Jersey实现**：[https://jersey.java.net/](https://jersey.java.net/)'
- en: '**InspectB.in**: [http://inspectb.in/](http://inspectb.in/)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**InspectB.in**: [http://inspectb.in/](http://inspectb.in/)'
- en: '**Postman**: [http://www.getpostman.com/](http://www.getpostman.com/)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Postman**：[http://www.getpostman.com/](http://www.getpostman.com/)'
- en: '**Advanced REST Client**: [https://code.google.com/p/chrome-rest-client/](https://code.google.com/p/chrome-rest-client/)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级REST客户端**：[https://code.google.com/p/chrome-rest-client/](https://code.google.com/p/chrome-rest-client/)'
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the fundamentals of REST, CRUD API, and how to design
    RESTful resources. We worked with JAX-RS 2.0-based annotations that can represent
    HTTP methods and Client APIs that can be used to target the resources. Additionally,
    we iterated the best practices when designing RESTful services.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了REST、CRUD API的基础知识以及如何设计RESTful资源。我们使用了基于JAX-RS 2.0的注解来表示HTTP方法，以及可以用于定位资源的客户端API。此外，我们还总结了设计RESTful服务时的最佳实践。
- en: The next chapter will dig deeper into the concepts covered here. We will also
    cover topics such as content negotiation, entity providers in JAX-RS 2.0, error
    handling, versioning schemes, and response codes in REST. We will look into techniques
    the server can use to send responses to the client using Streaming or Chunking.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将更深入地探讨这里涵盖的概念。我们还将涵盖诸如内容协商、JAX-RS 2.0中的实体提供者、错误处理、版本控制方案和REST中的响应代码等主题。我们将探讨服务器可以使用流式传输或分块传输向客户端发送响应的技术。
