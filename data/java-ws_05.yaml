- en: 5\. Exceptions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. 异常
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter discusses how exceptions are dealt with in Java. You will first
    learn how to identify the situations that produce exceptions in your code. This
    knowledge will simplify the process of handling these exceptions by alerting you
    to those circumstances in which they are most likely to arise. In this endeavor,
    this chapter also provides a list of best practices guiding you through common
    scenarios and the best methods of either catching exceptions or throwing them
    to the calling class, logging their details as you go. You will further learn
    to differentiate between different types of exceptions, and practice the techniques
    for handling each. By the end of the chapter, you will even be able to create
    your own exception class, capable of logging each type of exception in order of
    severity.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了Java中异常的处理方式。你将首先学习如何识别代码中产生异常的情况。这种知识将简化处理这些异常的过程，因为它会提醒你在最有可能出现这些异常的情况下。在此过程中，本章还提供了一份最佳实践列表，指导你通过常见场景和最佳方法来捕获异常或将其抛给调用类，并在执行过程中记录其详细信息。你还将学习区分不同类型的异常，并练习处理每种异常的技术。到本章结束时，你甚至能够创建自己的异常类，能够按照严重程度顺序记录每种类型的异常。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Exceptions are not errors, or, more accurately, exceptions are not bugs, even
    if you might perceive them to be when they crash your programs. Exceptions are
    situations that occur in your code when there is a mismatch between the data you
    are handling and the method or command you are using to process it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 异常不是错误，或者更准确地说，异常不是bug，即使它们可能在你程序崩溃时让你觉得它们是。异常是在你的代码中发生的情况，当处理的数据与用于处理它的方法或命令不匹配时。
- en: In Java, there is a class that is dedicated to errors. Errors are unexpected
    situations that affect programs on the **Java Virtual Machine** (**JVM**) level.
    For example, if you fill-up the program stack through an unconventional use of
    memory, then your whole JVM will crash. Unlike errors, exceptions are situations
    that your code, when properly designed, can catch on the fly.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，有一个类是专门用于错误的。错误是影响程序在**Java虚拟机**（**JVM**）层面的意外情况。例如，如果你通过非传统方式使用内存填满程序栈，那么整个JVM都会崩溃。与错误不同，异常是当你的代码设计得当，可以即时捕获的情况。
- en: Exceptions are not as drastic as errors, even if the result for you, the developer,
    will be the same—that is, a non-working program. In this chapter, we are inviting
    you to make your programs crash by intentionally provoking exceptions that you
    will later learn how to catch (that is, handle) and avoid. Depending on how you
    develop the catch mechanism, you can decide whether to get your program to recover
    and continue operating or to gracefully end its execution with a human-readable
    error message.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 异常并不像错误那样严重，即使对你这个开发者来说结果可能相同——也就是说，一个无法工作的程序。在本章中，我们邀请你通过故意引发你将后来学习如何捕获（即处理）并避免的异常来让你的程序崩溃。根据你如何开发捕获机制，你可以决定是让程序恢复并继续运行，还是优雅地结束其执行，并显示一个人类可读的错误消息。
- en: A Simple Exception Example
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单异常示例
- en: 'Start by provoking a simple exception in your code. First, type in the following
    program in the **Integrated Development Environment** (**IDE**) and execute it:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在你的代码中引发一个简单的异常。首先，在**集成开发环境**（**IDE**）中输入以下程序并执行它：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is the output:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The previous code listing shows how the program starts executing a command
    that works fine. The sentence `Go Java Go!` is printed on the console, but then
    a `NullPointerException` shows up, highlighting that something exceptional happened.
    In this case, we tried to print the length of a string initiated to null by calling
    `text.length()`. Since there is no length to be calculated (that is, we don''t
    even have an empty string), either `System.out.println()` or `text.length()` provoked
    the exception. Additionally, there was an error at that point, so the program
    exited and the final call to `System.out.println("done")` was not executed. You
    could try to separate both commands to see what the outcome will be:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码列表显示了程序开始执行一个运行良好的命令。在控制台上打印了“Go Java Go!”这句话，但随后出现了一个`NullPointerException`，突出显示发生了异常情况。在这种情况下，我们尝试通过调用`text.length()`来打印一个由null初始化的字符串的长度。由于没有长度可以计算（也就是说，我们甚至没有空字符串），`System.out.println()`或`text.length()`触发了异常。此外，在那个点还有一个错误，所以程序退出了，最后的`System.out.println("done")`调用没有执行。你可以尝试将这两个命令分开，看看结果会怎样：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is the output:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you check the line numbers in the IDE, you will see that the exception takes
    place on the line where we are trying to get the length of the string. Now that
    we know the cause of the problem, there are two ways around this issue: either
    we fix the data (note that there will be situations where this will be impossible),
    or we include a countermeasure in our code to detect the exceptions and then handle
    or ignore them. The action of handling an unexpected event is what we call catching
    the exception. On the other hand, bypassing the event is called throwing the exception.
    Later in the chapter, we will explore different ways of doing both of these actions,
    as well as good practices for when writing code-handling exceptions.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查IDE中的行号，你会看到异常发生在我们尝试获取字符串长度的那一行。既然我们已经知道了问题的原因，就有两种方法可以解决这个问题：要么修复数据（注意，有些情况下这是不可能的），要么在我们的代码中包含一种对策来检测异常，然后处理或忽略它们。处理意外事件的行为就是我们所说的捕获异常。另一方面，绕过事件的行为被称为抛出异常。在章节的后面，我们将探讨执行这两种行为的不同方法，以及编写代码处理异常时的良好实践。
- en: However, before learning about how to avoid or handle exceptions, let's provoke
    some more. Almost every Java API includes the definition of an exception that
    can help to propagate errors towards the main class, and thus the developer. In
    that way, it will be possible to avoid situations where the code will break in
    front of the user's eyes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在了解如何避免或处理异常之前，让我们再引发一些异常。几乎每个Java API都包含了异常的定义，这有助于将错误传播到主类，从而传递给开发者。这样，就可以避免代码在用户面前崩溃的情况。
- en: 'The exceptions covered by the Java APIs are what we call built-in exceptions.
    It is also possible to create your own when you define a class. Talking about
    classes, let''s try to get a character from a non-existing location within an
    object instantiated from `String` and see what happens:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Java API涵盖的异常就是我们所说的内置异常。当定义一个类时，你也可以创建自己的异常。谈到类，让我们尝试从一个由`String`实例化的对象中获取一个不存在位置的字符，看看会发生什么：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The IDE will respond with the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: IDE将做出以下响应：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that the text variable is only 12 characters long. When trying to extract
    the 15th character, the IDE will issue an exception and terminate the program.
    In this case, we got one called `StringOutOfBoundsException`. There are many different
    types of built-in exceptions.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，文本变量只有12个字符长。当尝试提取第15个字符时，IDE将抛出异常并终止程序。在这种情况下，我们得到了一个名为`StringOutOfBoundsException`的异常。存在许多不同类型的内置异常。
- en: 'Here''s a list of the various types of exceptions:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是各种异常类型的一个列表：
- en: '`NullPointerException`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NullPointerException`'
- en: '`StringOutOfBoundsException`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StringOutOfBoundsException`'
- en: '`ArithmeticException`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ArithmeticException`'
- en: '`ClassCastException`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClassCastException`'
- en: '`IllegalArgumentException`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IllegalArgumentException`'
- en: '`IndexOutOfBoundsException`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IndexOutOfBoundsException`'
- en: '`NumberFormatException`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NumberFormatException`'
- en: '`IllegalAccessException`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IllegalAccessException`'
- en: '`InstantiationException`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InstantiationException`'
- en: '`NoSuchMethodException`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NoSuchMethodException`'
- en: 'As you can see, the names of the different exceptions are quite descriptive.
    When you get one, it should be quite easy to figure out where to find more information
    about it within the Java documentation in order to mitigate the problem. We classify
    exceptions as checked or unchecked:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，不同异常的名称相当具有描述性。当你遇到一个异常时，应该很容易在Java文档中找到更多关于它的信息，以便减轻问题。我们将异常分为检查型或非检查型：
- en: '**Checked exceptions**: These are highlighted during compilation. In other
    words, your program will not make it to the end of the compilation process, and
    therefore you will not be able to run it.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查型异常**：这些在编译期间会被突出显示。换句话说，你的程序将无法完成编译过程，因此你将无法运行它。'
- en: '`NullPointerException` and `StringOutOfBoundsException`) are both unchecked.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NullPointerException`和`StringOutOfBoundsException`都是非检查型。'
- en: Why Two Types of Exception?
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为什么有两种类型的异常？
- en: 'There are two possibilities for exceptions: either we, as developers, make
    a mistake and don''t realize that our way of handling data is going to produce
    an error (such as when we are trying to get the length of an empty string or when
    we are dividing a number by zero), or the error happens because we are uncertain
    about the nature of the data we will be gathering during an exchange with something
    external to our program (such as when getting parameters from the CLI and they
    are of the wrong type). In cases like the first one, checked exceptions make more
    sense. The second scenario is the reason why we need unchecked exceptions. In
    this second case, we should develop strategies to handle potential threats to
    the proper execution of the program.'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 异常有两种可能性：要么我们作为开发者犯错，没有意识到我们处理数据的方式会产生错误（例如，当我们试图获取空字符串的长度或当我们除以零时），要么错误发生是因为我们对与程序外部交换的数据的性质不确定（例如，从CLI获取参数且类型错误）。在第一种情况下，检查异常更有意义。第二种场景是我们需要未检查异常的原因。在这种情况下，我们应该制定策略来处理可能威胁程序正确执行的风险。
- en: 'Making an example of a checked exception is slightly more complicated because
    we have to anticipate things that will not be introduced in depth until a later
    chapter. However, we consider that the following example, which displays an example
    of `IOException`, is simple enough even if it includes a couple of classes that
    haven''t been touched on in the book yet:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个检查异常的例子稍微复杂一些，因为我们必须预测一些直到稍后的章节才会深入介绍的内容。然而，我们认为以下示例，它展示了`IOException`的例子，即使它包含了一些书中尚未涉及到的类，也足够简单：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The newest thing in this code listing is the use of `java.nio.file.*`. This
    is an API that includes classes and methods to manage files, among other things.
    The goal of this program is to read a whole text file called readme.txt into a
    list that will then be printed using an iterator, as we saw in *Chapter 4*, *Collections,
    Lists, and Java's Built-In APIs*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码列表中最新的是`java.nio.file.*`的使用。这是一个包括用于管理文件等内容的类和方法的API。这个程序的目标是将整个名为readme.txt的文本文件读入一个列表中，然后使用迭代器打印出来，正如我们在*第4章*，*集合、列表和Java内置API*中看到的。
- en: This is a case where a checked exception could occur when calling `Files.readAllLines()`
    if there is no file to be read because of, for example, having a wrongly declared
    filename. The IDE knows this and, therefore, it flags that there is a potential
    risk.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在调用`Files.readAllLines()`时可能发生检查异常的情况，因为没有文件可读，例如，由于文件名声明错误。IDE知道这一点，因此它会标记存在潜在风险。
- en: 'Note how the IDE displays a warning from the moment we write the code. Furthermore,
    when trying to compile the program, the IDE will respond with the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意IDE从我们编写代码的那一刻起就显示警告。此外，当我们尝试编译程序时，IDE将响应如下：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Catching** and **throwing** are the two strategies that you can use to avoid
    exceptions. We will talk about them in more detail later in the chapter.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**捕获**和**抛出**是你可以用来避免异常的两种策略。我们将在本章后面更详细地讨论它们。'
- en: NullPointerException – Have No Fear
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NullPointerException – 不要害怕
- en: We presented the concept of `null` within Java in a previous chapter. As you
    may recall, `null` is the value that is implicitly assigned to an object upon
    creation, that is, unless you assign a different value to it. Related to `null`
    is the `NullPointerException` value. This is a very common event that can and
    will happen to you for a variety of reasons. In this section, we will highlight
    some of the most common scenarios of this in an effort to introduce you to a different
    way of thinking when dealing with any type of exception in your code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的一章中介绍了Java中的`null`概念。你可能还记得，`null`是在创建对象时隐式分配给对象的值，除非你给它分配不同的值。与`null`相关的是`NullPointerException`值。这是一个非常常见的事件，可能会发生，原因有很多。在本节中，我们将突出一些最常见的场景，以便让你在处理代码中的任何类型异常时有一个不同的思维方式。
- en: 'In *Example01*, we examined the process of trying to perform operations on
    an object that was pointing to `null`. Let''s look at some other possible cases:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Example01*中，我们检查了尝试对指向`null`的对象执行操作的过程。让我们看看一些其他可能的案例：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The outcome of this example would be the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的结果将是以下内容：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You could have prevented this exception if you had written your code to compare
    the existing variable with the potentially `null` one instead.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你本可以防止这个异常，如果你在编写代码时将现有变量与可能为`null`的变量进行比较的话。
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding code will produce the following result:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生以下结果：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, there is no conceptual difference between the examples; however,
    there is a difference at the code level. This difference is enough for your code
    to issue an exception upon compilation. This is because the `equals()` method
    for the `String` class is prepared to handle the situation of its parameter being
    `null`. On the other hand, a `String` variable that is initialized to `null` cannot
    have access to the `equals()` method.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这些示例在概念上没有区别；然而，在代码级别上存在差异。这种差异足以在编译时使你的代码引发异常。这是因为`String`类的`equals()`方法已经准备好处理其参数为`null`的情况。另一方面，初始化为`null`的`String`变量无法访问`equals()`方法。
- en: 'A very common situation for provoking a `NullPointerException` occurs when
    trying to call non-static methods from an object initialized to `null`. The following
    example shows a class with two methods that you can call to see whether they produce
    the exception. You can do this by simply commenting or uncommenting each of the
    lines calling the methods from `main()`. Copy the code in the IDE and try the
    two cases:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试从一个初始化为`null`的对象调用非静态方法时，会引发`NullPointerException`的非常常见的情况。以下示例展示了一个包含两个方法的类，你可以调用这些方法来查看它们是否会产生异常。你可以通过简单地注释或取消注释`main()`中调用这些方法的每一行来实现这一点。将代码复制到IDE中并尝试两种情况：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There are other cases when this exception can appear, but let's focus on how
    to deal with exceptions. The following sections will describe different mechanisms
    you can use to enable your programs to recover from unexpected situations.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种异常出现时，还有其他情况，但让我们专注于如何处理异常。以下章节将描述你可以使用的不同机制来使你的程序能够从意外情况中恢复。
- en: Catching Exceptions
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获异常
- en: 'As mentioned earlier, there are two ways to handle exceptions: catching and
    throwing. In this section, we will deal with the first of these methods. Catching
    an exception requires encapsulating the code that might generate an unwanted result
    into a specific statement, as shown in the following code snippet:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，处理异常有两种方式：捕获和抛出。在本节中，我们将处理这些方法中的第一种。捕获异常需要将可能产生不期望结果的代码封装到特定的语句中，如下面的代码片段所示：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can put this code to test with any of the previous examples. Let''s demonstrate
    how we could stop the exception we found in the first example of the chapter,
    where we tried to check the length of a string that was initialized to null:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用之前的任何示例来测试这段代码。让我们演示如何停止章节第一个示例中发现的异常，在那个示例中，我们尝试检查一个初始化为`null`的字符串的长度：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see, we have wrapped the potentially broken code inside a `try-catch`
    statement. The result of this code listing is very different from the result that
    we saw previously:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们将可能出错的代码包裹在一个`try-catch`语句中。这段代码列表的结果与我们之前看到的结果非常不同：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Mainly, we find that the program is not interrupted until the end. The `try`
    section of the program detects the arrival of the exception, and the `catch` part
    will execute a specific code if the exception is of the `NullPointerException`
    type.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 主要，我们发现程序直到结束都不会被中断。程序的`try`部分检测到异常的到来，如果异常是`NullPointerException`类型，`catch`部分将执行特定的代码。
- en: 'Several `catch` statements can be placed in sequence after the call to `try`
    as a way to detect different types of exceptions. To try this out, let''s go back
    to the example where we were trying to open a non-existing file and try to catch
    the reason for `readAllLines()` stopping the program:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在`try`调用之后按顺序放置多个`catch`语句，作为检测不同类型异常的一种方式。为了尝试这一点，让我们回到我们尝试打开一个不存在的文件并尝试捕获`readAllLines()`停止程序的例子里：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As we saw earlier in the chapter, we have made a program that tries to open
    a non-existing file. The exception that we got then was `IOException`. In reality,
    that exception is triggered by `NoSuchFileException`, which is escalated and triggers
    `IOException`. Therefore, we get that exception on the IDE. When implementing
    the multiple try-catch statements, as shown in the previous example, we get the
    following outcome:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在本章前面所见，我们编写了一个尝试打开一个不存在的文件的程序。我们当时得到的异常是`IOException`。实际上，这个异常是由`NoSuchFileException`触发的，它被升级并触发`IOException`。因此，我们在IDE中得到了这个异常。在实现多个`try-catch`语句，如前例所示时，我们得到以下结果：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This means that the program detects the `NoSuchFileException` and, therefore,
    prints the message included in the corresponding catch statement. However, if
    you want to see the full sequence of exceptions triggered by the non-existing
    readme.txt file, you can use a method called `printStackTrace()`. This will send
    to the output everything that was on the way to the proper execution of the program.
    To see this, simply add the following highlighted changes to the previous example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着程序检测到`NoSuchFileException`，因此打印出相应的捕获语句中的消息。然而，如果你想看到由不存在的readme.txt文件触发的异常的完整序列，你可以使用一个名为`printStackTrace()`的方法。这将向输出发送程序正确执行过程中的一切。要查看这一点，只需将以下突出显示的更改添加到前面的示例中：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output of the program will now include a full printout of the different
    exceptions triggered during program execution. You will see the output of the
    stack is inverted: first, you will see the reason why the program stopped (`NoSuchFileException`),
    and it will end with the method that starts the process that provokes the exception
    (`readAllLines`). This is due to the way exceptions are built. As we will discuss
    later, there are many different types of exceptions. Each one of these types is
    defined as a class of exceptions, which may be extended by several other subclasses
    of exceptions. If an extension of a certain type occurs, then the class that it
    is extending will also appear when printing out the stack. In our case, `NoSuchFileException`
    is a subclass of `IOException`.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出现在将包括程序执行期间触发的不同异常的完整打印输出。你会看到堆栈输出是倒置的：首先，你会看到程序停止的原因（`NoSuchFileException`），然后它将以引发异常的过程开始的方法结束（`readAllLines`）。这是由于异常构建的方式。正如我们稍后将要讨论的，有许多不同类型的异常。每一种类型都被定义为异常类，这些类可以由几个其他异常子类扩展。如果发生某种类型的扩展，那么它所扩展的类也会在打印堆栈时出现。在我们的例子中，`NoSuchFileException`是`IOException`的子类。
- en: Note
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Depending on your operating system, the different nested exceptions for dealing
    with opening a file will probably be called differently.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的操作系统，处理打开文件的不同嵌套异常可能被称为不同的名称。
- en: 'We have been catching two different exceptions – one nested inside the other.
    It should also be possible to handle exceptions coming from different classes,
    such as `IOException` and `NullPointerException`. The following example demonstrates
    how to do this. If you are dealing with exceptions that are not a subclass of
    one another, it is possible to catch both exceptions using a logical OR operator:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经捕获了两种不同的异常——一个嵌套在另一个内部。也应该能够处理来自不同类别的异常，例如`IOException`和`NullPointerException`。以下示例演示了如何做到这一点。如果你正在处理不是彼此子类的异常，你可以使用逻辑或运算符来捕获这两个异常：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see, it is possible to handle both exceptions in a single `catch`
    statement. However, if you want to handle the exceptions differently, you will
    have to work with the object containing the information about the exception, which,
    in this case, is `ex`. The keyword you need to distinguish the between the exceptions
    that you may be handling simultaneously is `instanceof`, as shown in the following
    modification of the previous example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以在单个`catch`语句中处理这两个异常。然而，如果你想以不同的方式处理异常，你必须与包含异常信息的对象一起工作，在这个例子中是`ex`。你需要区分你可能同时处理的异常的关键字是`instanceof`，如下面前面示例的修改所示：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How Many Different Exceptions Can You Catch in a Single Try?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个单独的`try`块中你能捕获多少种不同的异常？
- en: The fact is that you can daisy chain as many catch statements as you need to.
    If you use the second method that we discussed in this chapter (that is, using
    the OR statement), then you should remember that it is not possible to have a
    subclass together with its parent class. For example, it is not possible to have
    NoSuchFileException and IOException together in the same statement – they should
    be placed in two different catch statements.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，你可以根据需要将尽可能多的`catch`语句链接起来。如果你使用本章讨论的第二种方法（即使用OR语句），你应该记住，不可能同时有一个子类及其父类。例如，不可能在同一个语句中将`NoSuchFileException`和`IOException`放在一起——它们应该放在两个不同的`catch`语句中。
- en: 'Exercise 1: Logging Exceptions'
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1：记录异常
- en: 'There are two main actions that you can perform when catching exceptions aside
    from any type of creative coding you may want to do to respond to the situation;
    these actions are logging or throwing. In this exercise, you will learn how to
    log the exception. In a later exercise, you will learn how to throw it instead.
    As we will reiterate in the *Best Practices for Handling Exceptions* section of
    this chapter, you should never do both at once:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在捕获异常时，除了您可能想要执行以响应情况的任何类型的创造性编码之外，您还可以执行两种主要操作；这些操作是记录或抛出。在本练习中，您将学习如何记录异常。在后续练习中，您将学习如何抛出它。正如我们将在本章的“异常处理最佳实践”部分中重申的那样，您永远不应该同时执行这两者：
- en: Create a new Java project in IntelliJ using the template for CLI. Name it LoggingExceptions.
    You will be creating classes inside it that you can then use later in other programs.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在IntelliJ中使用CLI模板创建一个新的Java项目。将其命名为LoggingExceptions。您将在其中创建类，以后可以在其他程序中使用它们。
- en: 'In the code, you need to import the logging API by issuing the following command:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码中，您需要通过以下命令导入日志API：
- en: '[PRE21]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Declare an object that you will be using to log the data into. This object
    will be printed to the terminal upon program termination; therefore, you don''t
    need to worry about where it will end up at this point:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个您将用于记录数据的对象。此对象将在程序终止时打印到终端；因此，您无需担心它此时会出现在哪里：
- en: '[PRE22]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Provoke an exception, as follows:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式引发异常：
- en: '[PRE23]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'At the time of catching the exception, send the data to the logger object using
    the `log()` method:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在捕获异常时，使用`log()`方法将数据发送到日志对象：
- en: '[PRE24]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Your full program should read as follows:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的完整程序应如下所示：
- en: '[PRE25]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When you execute the code, the output should be as follows:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您执行代码时，输出应如下所示：
- en: '[PRE26]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, the exception is logged at the determined `SEVERE` level, but
    the code ends without an error code because we were able to handle the exception.
    The log is useful because it tells us where the exception happened in the code
    and, additionally, helps us to find the place of where we can dig deeper into
    the code and fix any potential issues.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，异常被记录在确定的`SEVERE`级别，但由于我们能够处理异常，代码结束时没有错误代码。日志很有用，因为它告诉我们异常发生在代码的哪个位置，并且还帮助我们找到可以进一步深入代码并修复任何潜在问题的位置。
- en: Throws and Throw
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抛出和抛出
- en: 'You can choose not to deal with some caught exceptions in your code at a low
    level, as described in the previous section. It could be interesting to filter
    out an exception''s parent class and focus on detecting a subclass that might
    be of more importance to us. The `throws` keyword is used in the definition of
    the method you are creating and where the exception may occur. In the following
    case, which is a modification of *Example 09*, we should call throws in the definition
    of `main()`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择不在代码的低级别处理一些捕获的异常，如前所述。过滤掉异常的父类并关注检测对我们可能更有重要性的子类可能很有趣。`throws`关键字用于您正在创建的方法的定义以及可能发生异常的地方。在以下情况下，这是对*示例
    09*的修改，我们应该在`main()`的定义中调用`throws`：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As you can see, we are throwing any `IOException` that is occurring during
    runtime. In this way, we can focus on catching the one that actually happens:
    `NoSuchFileException`. It is possible to throw more than one exception type in
    this way by separating them using commas.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在运行时抛出了任何`IOException`。这样，我们可以专注于捕获实际发生的异常：`NoSuchFileException`。通过使用逗号分隔，可以以这种方式抛出多个异常类型。
- en: 'An example of such a method definition is as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法定义的一个例子如下：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The one thing that is not possible is having an exception class and its subclass
    being thrown in the same method definition – just as we saw when trying to catch
    more than one exception in a single `catch` statement. It is also interesting
    to see that `throws` is operating at a certain scope; for example, we could disregard
    a certain exception within a method in a class but not a different one.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一件不可能的事情是在同一个方法定义中抛出异常类及其子类——正如我们在尝试在单个`catch`语句中捕获多个异常时所看到的那样。还有一点也很有趣，即`throws`在某个范围内操作；例如，我们可以在类的方法中忽略某个异常，但不能在另一个类中忽略。
- en: 'On the other hand, there is yet another keyword that you will find relevant
    for dealing with exceptions as you advance in your understanding of the term.
    The `throw` keyword (note that this is not `throws`) will explicitly invoke an
    exception. You can use this to create your own exceptions and try them out in
    your code. We will demonstrate in a later section how you can create your own
    exception, and then we will use `throw` as part of the example to also see how
    exceptions propagate. The main reason to use `throw` is if you want your code
    to hand over an exception occurring within your class to another one higher up
    in the hierarchy. For the sake of learning about how this works, let''s look at
    the following example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，随着你对术语理解的深入，你还会发现另一个关键字对于处理异常非常有用。`throw` 关键字（注意这不同于 `throws`）将显式地引发一个异常。你可以使用它来创建自己的异常并在代码中尝试它们。我们将在后面的部分演示如何创建自己的异常，然后我们将使用
    `throw` 作为示例的一部分来查看异常是如何传播的。使用 `throw` 的主要原因是如果你想让你的代码将类内部发生的异常传递给层次结构中的另一个类。为了了解这是如何工作的，让我们看看以下示例：
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this case, we reproduce the `NullPointerException` example we saw earlier
    by trying to call the `length()` method on a string initialized as `null`. However,
    if you run this code, you will see that the exception that is being displayed
    is `RuntimeException`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们通过尝试在初始化为 `null` 的字符串上调用 `length()` 方法来重现我们之前看到的 `NullPointerException`
    示例。然而，如果你运行此代码，你会看到显示的异常是 `RuntimeException`：
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The reason for this is the call to `throw new RuntimeException()` that we issued
    in the `catch` block. As you can see, when dealing with the exception, we are
    provoking a different exception. This can be very useful for catching exceptions
    and piping them through your own exceptions, or simply catching the exception,
    giving a meaningful message to help the user understand what went down, and then
    letting the exception continue its own path, and eventually crashing the program
    if the exception is not handled at a higher level in the code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们在 `catch` 块中发出的 `throw new RuntimeException()` 调用。正如你所看到的，在处理异常时，我们正在引发一个不同的异常。这可以非常有助于捕获异常并将它们通过你自己的异常传递，或者简单地捕获异常，给出一个有意义的消息来帮助用户理解发生了什么，然后让异常继续其自己的路径，如果异常没有被代码中的更高层次处理，最终导致程序崩溃。
- en: 'Exercise 2: Breaking the Law (and Fixing It)'
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2：违反规则（并修复它）
- en: 'In this example, you will create your own checked exception class. You will
    define a class and then experiment by provoking that exception, logging its results,
    and then analyzing them:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你将创建自己的检查异常类。你将定义一个类，然后通过引发该异常、记录其结果并分析它们来进行实验：
- en: Create a new Java project in IntelliJ using the template for CLI. Name it `BreakingTheLaw`.
    You will be creating classes inside it that you can use later in other programs.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 IntelliJ 中使用 CLI 模板创建一个新的 Java 项目。将其命名为 `BreakingTheLaw`。你将在其中创建类，稍后可以在其他程序中使用这些类。
- en: 'In the code, create a new class to describe your exception. This class should
    extend the base `Exception` class. Call it `MyException` and include the empty
    constructor:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码中创建一个新的类来描述你的异常。这个类应该扩展基本 `Exception` 类。命名为 `MyException` 并包含一个空构造函数：
- en: '[PRE31]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Your constructor should include all the possibilities to be thrown. This implies
    that the constructor needs to contemplate several different cases:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的构造函数应该包含所有可能抛出的异常。这意味着构造函数需要考虑几个不同的案例：
- en: '[PRE32]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This will allow us to now wrap any exception with our newly formed exception.
    However, there are a couple of modifications that we should apply to our program
    in order for it to compile. First, we need to make the exception class static
    for it to work in the context we are using it in:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将允许我们现在将任何异常包裹在我们的新形成的异常中。然而，我们需要对我们的程序进行一些修改，以便它能够编译。首先，我们需要将异常类设置为静态，以便在当前使用它的上下文中工作：
- en: '[PRE33]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, you need to make sure that the main class is throwing your new exception
    since you are going to be issuing that exception in the code:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你需要确保主类正在抛出你新创建的异常，因为你将在代码中发出这个异常：
- en: '[PRE34]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, you need to generate some code that will provoke an exception, such
    as `NullPointerException`, when trying to get the length of a `String` initialized
    to `null`, `catch` it, and then `throw` it away using our newly created class:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你需要生成一些代码，当尝试获取初始化为 `null` 的 `String` 的长度时，将引发异常，例如 `NullPointerException`，然后捕获它，并使用我们新创建的类将其丢弃：
- en: '[PRE35]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The result of running this code is as follows:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行此代码的结果如下：
- en: '[PRE36]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can now experiment with the call to `throw` by using any other of the constructors
    in the class. We just tried one that includes our own error message, so let''s
    add the stack trace for the exception:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以通过使用类中的任何其他构造函数来实验`throw`的调用。我们刚刚尝试了一个包含我们自己的错误消息的例子，所以让我们添加异常的堆栈跟踪：
- en: '[PRE37]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'What will make the output slightly more informative is that it will now include
    information about the exception that generated our own `NullPointerException`:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将使输出稍微更有信息量的，是它现在将包括有关生成我们自己的`NullPointerException`的异常的信息：
- en: '[PRE38]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You have now learned how to use throw to wrap an exception into your own exception
    class. This can be very handy when dealing with a large codebase and having to
    look for the exceptions generated by your code in a long log file, or similar.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你现在已经学会了如何使用`throw`将异常包装到自己的异常类中。当处理大型代码库并需要在长日志文件中查找由你的代码生成的异常时，这会非常有用。
- en: Note
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'The final code can be referred at: [https://packt.live/2VVdy2f](https://packt.live/2VVdy2f).'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终代码可以参考：[https://packt.live/2VVdy2f](https://packt.live/2VVdy2f)。
- en: The finally Block
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`finally`块'
- en: 'The `finally` block can be used to execute some common code after any of the
    `catch` blocks used to handle a series of different exceptions in the code. Going
    back to our example where we tried to open a non-existing file, a modified version
    of it including a `finally` statement would look like the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`finally`块在代码中用于处理一系列不同异常的任何`catch`块之后执行一些通用代码。回到我们尝试打开一个不存在的文件的例子，包括一个`finally`语句的修改版本如下：
- en: '[PRE39]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output of the preceding example is as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例的输出如下：
- en: '[PRE40]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: After the `catch` block detecting the `NoSuchFileException`, the handling mechanism
    jumps into the `finally` block and executes whatever is in it, which, in this
    case, implies printing yet another line of text to the output.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在检测到`NoSuchFileException`的`catch`块之后，处理机制跳入`finally`块并执行其中的任何内容，在这种情况下，意味着向输出打印另一行文本。
- en: 'Activity 1: Designing an Exception Class Logging Data'
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动一：设计一个记录数据的异常类
- en: 'We have seen examples of how to log exceptions and how to throw them. We have
    also learned how to create exception classes and throw them. With all that information,
    the goal of this activity is to create your own exception class that should log
    the different exceptions in terms of severity. You should make an application
    that is based on the arguments to the program, and the program will respond to
    the logging exceptions in different ways. Just to have a common ground, use the
    following standard:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何记录异常和抛出异常的例子。我们还学习了如何创建异常类并抛出它们。有了所有这些信息，这个活动的目标是创建一个自己的异常类，该类应该根据严重程度记录不同的异常。你应该制作一个基于程序参数的应用程序，程序将以不同的方式响应记录的异常。为了有一个共同的基础，使用以下标准：
- en: If the input is number 1, issue the `NullPointerException` with a severity level
    of SEVERE.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果输入是数字1，则抛出`NullPointerException`，严重程度为SEVERE。
- en: If the input is number 2, issue the `NoSuchFileException` with a severity level
    of WARNING.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果输入是数字2，则抛出`NoSuchFileException`，严重程度为WARNING。
- en: If the input is number 3, issue the `NoSuchFileException` with a severity level
    of INFO.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果输入是数字3，则抛出`NoSuchFileException`，严重程度为INFO。
- en: 'In order to make this program, you will need to consider making your own methods
    for issuing exceptions, such as the following:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了制作这个程序，你需要考虑创建自己的异常抛出方法，例如以下内容：
- en: '[PRE41]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 540.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第540页找到。
- en: Best Practices for Handling Exceptions
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理异常的最佳实践
- en: 'Dealing with exceptions in your code requires following a set of best practices
    in order to avoid deeper issues when writing your programs. This list of common
    practices is of relevance to your code in order to keep some degree of professional
    programming consistency:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码中处理异常需要遵循一系列最佳实践，以避免在编写程序时出现更深层的问题。这个常见实践列表对你的代码来说很重要，以保持一定程度的专业编程一致性：
- en: 'The first piece of advice is to avoid throwing or catching the main `Exception`
    class. You need to be as specific as possible when dealing with an exception.
    Therefore, a case like the following is not recommended:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条建议是避免抛出或捕获主`Exception`类。处理异常时，你需要尽可能具体。因此，以下情况是不推荐的：
- en: '[PRE42]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This code listing will catch any exception, with no granularity. So, how are
    you supposed to properly handle the exception this way?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将捕获任何异常，没有粒度。那么，你应该如何以这种方式正确处理异常呢？
- en: In the following section, we will do a quick recap of where the Exception class
    is located within the Java API structure. We will examine how it hangs from the
    Throwable class at the same level as the Error class. Therefore, if you were to
    catch the Throwable class, you would mask possible errors occurring in your code
    and not only exceptions. Remember that errors are those situations when your code
    should be exited because they alert to a real malfunction that could lead to the
    misuse of JVM resources.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将快速回顾Exception类在Java API结构中的位置。我们将检查它如何与Error类在同一级别悬挂在Throwable类上。因此，如果你捕获了Throwable类，你可能会掩盖代码中发生的可能错误，而不仅仅是异常。记住，错误是那些你的代码应该退出的情况，因为它们会警告到可能导致JVM资源误用的真实故障。
- en: 'Masking such a scenario behind a catch could stall the whole JVM. Therefore,
    avoid code like the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在`catch`块后面掩盖这样的场景可能会使整个JVM停滞。因此，避免以下代码：
- en: '[PRE43]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In *Exercise 2*, *Breaking the Law (and Fixing It)* you saw how to make your
    own exception class. As discussed, it is possible to redirect exceptions toward
    others by using `throw`. It is good practice to not disregard the stack trace
    of the original exception since it will help you to debug the source of the issue
    in a better way. Therefore, when catching the original exception, you should consider
    passing over the whole stack trace as a parameter to the exception constructor:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在*练习2*，*违法（并修复它）*中，你看到了如何创建自己的异常类。正如讨论的那样，通过使用`throw`可以将异常重定向到其他地方。不忽视原始异常的堆栈跟踪是一种好习惯，因为它将帮助你更好地调试问题的来源。因此，在捕获原始异常时，你应该考虑将整个堆栈跟踪作为参数传递给异常构造函数：
- en: '[PRE44]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the same exercise, when making your own exception, you learned how to use
    the system''s log to store the information of the exception. You should avoid
    both logging the exception and throwing it once more. You should try to log at
    the highest level possible in your code. Otherwise, you will get duplicated information
    about the situation inside your log, making the debugging a lot more complicated.
    Therefore, we recommend that you use the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在同样的练习中，当你自己创建异常时，你学习了如何使用系统日志来存储异常信息。你应该避免记录异常和再次抛出它。你应该尽量在代码中记录最高级别的信息。否则，你的日志中会出现关于情况的重复信息，使得调试变得更加复杂。因此，我们建议你使用以下方法：
- en: '[PRE45]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Alternatively, you can use the following inside the same `catch` block, but
    not for both:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在同一个`catch`块中使用以下内容，但不能同时使用：
- en: '[PRE46]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Additionally, when logging information, try to use a single call to the system''s
    log. As your code grows bigger, there will be multiple processes working in parallel,
    thus a lot of different sources will be issuing log commands:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在记录信息时，尽量使用系统日志的单次调用。随着你的代码越来越大，会有多个进程并行工作，因此会有很多不同的来源发出日志命令：
- en: '[PRE47]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This will most likely not show up as two consecutive lines in the log, but
    as two lines that are far apart. Instead, you should do something like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这很可能不会在日志中显示为连续的两行，而是显示为间隔较远的两行。相反，你应该这样做：
- en: '[PRE48]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'When dealing with multiple exceptions, some being subclasses of others, you
    should catch them in order, starting from the most specific. We have seen this
    in some of the examples in this chapter when, for example, dealing with `NoSuchFileException`
    and `IOException`. Your code should look like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理多个异常时，一些是其他异常的子类，你应该按照顺序捕获它们，从最具体的开始。我们在本章的一些示例中看到了这一点，例如处理`NoSuchFileException`和`IOException`。你的代码应该看起来像这样：
- en: '[PRE49]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If you are not planning to catch the exception at all, but you are still forced
    to use the try block for the code to compile, use a finally block to close whatever
    actions were initiated prior to the exception. An example of this is opening a
    file that should be closed prior to leaving the method, which will happen because
    of the exception:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你根本不打算捕获异常，但仍然被迫使用`try`块来编译代码，请使用`finally`块来关闭在异常之前启动的所有操作。一个例子是打开一个在离开方法之前应该关闭的文件，这将会因为异常而发生：
- en: '[PRE50]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `throw` keyword is a very powerful tool, as you have noticed. Being able
    to redirect exceptions allows you to create your own strategy for handling different
    situations and, additionally, it means that you don't have to rely on the strategy
    provided by default by the JVM. However, you should be careful with placing `throw`
    in some of the blocks when catching. You should avoid using `throw` inside a `finally`
    block as it will mask the original reason for the exception.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`throw` 关键字是一个非常强大的工具，正如你所注意到的。能够重定向异常允许你为不同的情境创建自己的策略，并且此外，这意味着你不必依赖于JVM默认提供的策略。然而，你在捕获时应该小心放置
    `throw` 在某些块中。你应该避免在 `finally` 块中使用 `throw`，因为这会掩盖异常的原始原因。'
- en: In a way, this is in line with the "throw early, catch late" principle when
    dealing with Java exceptions. Imagine that you are doing a low-level operation
    that is part of a larger method. For example, you are opening a file as part of
    a piece of code that will parse its contents and look for patterns. If the action
    of opening the file fails due to an exception, it is a better option to simply
    `throw` that exception to the following method for it to put in context and be
    able to decide at a higher level how to proceed with the whole task. You should
    handle the exceptions only when you can make final decisions at a higher level.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理Java异常时，这在某种程度上遵循了“尽早抛出，晚些捕获”的原则。想象一下，你正在进行一个低级操作，它是更大方法的一部分。例如，你正在打开一个文件，作为解析其内容并查找模式的一段代码的一部分。如果打开文件的操作由于异常而失败，那么简单地
    `throw` 该异常给后续的方法，以便它能够将其置于上下文中，并能够在更高层次上决定如何继续整个任务，这是一个更好的选择。你应该只在能够做出最终决策的更高层次上处理异常。
- en: We saw the use of `printStackTrace()` throughout the previous examples as a
    way to see the full source of an exception. While it is very interesting to be
    able to see that when debugging some code, it is also almost irrelevant when not
    being in that mindset. Therefore, you should make sure to either delete or comment
    away all the `printStackTrace()` commands you might have been using. Other developers
    will have to determine where they want to put their probes when analyzing the
    code later if that is ever needed.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的例子中看到了 `printStackTrace()` 的使用，作为一种查看异常完整来源的方法。虽然当调试代码时能够看到这一点非常有趣，但如果不处于那种心态，它几乎是没有关系的。因此，你应该确保删除或注释掉你可能使用过的所有
    `printStackTrace()` 命令。如果以后需要，其他开发者将不得不在分析代码时确定他们想要放置探针的位置。
- en: 'In a similar manner, when dealing with exceptions in whatever way inside your
    methods, you should remember to document things properly in your Javadoc. You
    should add an `@throws` declaration to clarify what kind of exception arrives
    and whether it is handled, passed over, or what:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，当你在方法内部以任何方式处理异常时，你应该记得在Javadoc中正确地记录事情。你应该添加一个 `@throws` 声明来明确指出哪种异常到达，以及它是被处理、传递还是其他什么情况：
- en: '[PRE51]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Where Do Exceptions Come from?
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常从何而来？
- en: Moving away from the more-pragmatic approach we have followed in this chapter,
    it is now time to put things into perspective and understand where things come
    from in the larger schema of the Java API. Exceptions, as mentioned in a previous
    section, hang from the `Throwable` class, which is part of the `java.lang` package.
    They are on the same level as errors (which we explained earlier). In other words,
    both `Exception` and `Error` are subclasses of `Throwable`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 离开我们在本章中遵循的更实际的途径，现在是时候从更宏观的角度来看待问题，并理解在Java API的更大框架中事物从何而来。正如前一个部分提到的，异常悬挂在
    `Throwable` 类上，它是 `java.lang` 包的一部分。它们与错误（我们之前解释过）处于同一级别。换句话说，`Exception` 和 `Error`
    都是 `Throwable` 的子类。
- en: Only object instances of the `Throwable` class can be thrown by the Java `throw`
    statement; therefore, the way we had to define our own exception implied using
    this class as a point of departure. As stated in the Java documentation for the
    `Throwable` class, this includes a snapshot of the execution stack at the time
    of creation. This allows you to look for the source of the exception (or the error)
    because it includes the state of computer memory at that time. A throwable object
    can contain the reason for which it was constructed. This is what is known as
    the chained exception facility because one exceptional event might be caused by
    a certain chain of exceptions. This is something we have seen when analyzing the
    stack traces in some of the programs in this chapter.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 只有`Throwable`类的对象实例可以通过Java的`throw`语句抛出；因此，我们必须使用这个类作为起点来定义自己的异常。正如Java文档中关于`Throwable`类的说明，这包括创建时的执行栈快照。这允许您查找异常（或错误）的来源，因为它包括了当时计算机内存的状态。可抛出对象可以包含构建它的原因。这就是所谓的链式异常功能，因为一个异常事件可能是由一系列异常引起的。这是我们分析本章中某些程序堆栈跟踪时看到的情况。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have taken a very hands-on approach with this chapter. We started by making
    your code break in different ways, and then explained the differences between
    an error and an exception. We focused on ways to handle the latter because those
    are the only ones that should not make your program crash immediately.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中采用了非常实际的方法。我们首先让您的代码以不同的方式出错，然后解释了错误和异常之间的区别。我们专注于处理后者，因为这些是唯一不应该立即使您的程序崩溃的情况。
- en: Exceptions can be handled by catching or throwing. The former is done by observing
    the different exceptions and defining different strategies to respond to the situations
    by means of a try-catch statement. You have the option of either resending the
    exception to a different class with the `throw` or responding within the `catch`
    block. Independently of what strategy you follow, you can set the system to execute
    some final lines of code after handling the exception using the `finally` block.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 异常可以通过捕获或抛出进行处理。前者是通过观察不同的异常并定义不同的策略，通过try-catch语句来应对这些情况。您可以选择将异常重新发送到不同的类中使用`throw`，或者在`catch`块中响应。无论您遵循哪种策略，您都可以通过`finally`块设置系统在处理异常后执行一些最后的代码行。
- en: This chapter also included a series of recommendations on how to deal with exceptions
    on a more conceptual level. You have a list of best practices that any professional
    programmer will follow.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还包括了一系列关于如何在更概念层面上处理异常的建议。您有一份最佳实践清单，任何专业程序员都会遵循。
- en: Finally, at the practical level, you worked on a number of exercises that guided
    you through classic scenarios of dealing with exceptions, and you have seen different
    tools that you can use to debug your code, such as logs and `printStackTrace()`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在实践层面，您完成了一系列练习，这些练习引导您通过处理异常的经典场景，并且您已经看到了可以用来调试代码的不同工具，例如日志和`printStackTrace()`。
