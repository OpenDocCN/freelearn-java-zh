- en: Spring Cloud
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud
- en: 'In this chapter, we will look at some of the important patterns related to
    developing Cloud-Native applications and implementing them using projects under
    the umbrella of Spring Cloud. We will look at the following features:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍与开发云原生应用程序和使用Spring Cloud伞下的项目实现相关的一些重要模式。我们将介绍以下功能：
- en: Implementing centralized microservice configuration with Spring Cloud Config
    Server
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Config Server实现集中式微服务配置
- en: Using Spring Cloud Bus to synchronize configuration across microservice instances
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Bus同步微服务实例的配置
- en: Using Feign to create declarative REST clients
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Feign创建声明性REST客户端
- en: Implementing client-side load balancing using Ribbon
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ribbon实现客户端负载均衡
- en: Implementing the Name server using Eureka
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Eureka实现名称服务器
- en: Implementing API Gateway using Zuul
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Zuul实现API网关
- en: Implementing distributed tracing using Spring Cloud Sleuth and Zipkin
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Sleuth和Zipkin实现分布式跟踪
- en: Using Hystrix to implement fault tolerance
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Hystrix实现容错
- en: Introducing Spring Cloud
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Spring Cloud
- en: 'In [Chapter 4](c4e1908a-b086-428c-8862-6474eb92f04a.xhtml), *Evolution toward
    Microservices and Cloud-Native Applications*, we discussed the problems with monolithic
    applications and how architectures evolved toward microservices. However, microservices
    have their own sets of challenges:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](c4e1908a-b086-428c-8862-6474eb92f04a.xhtml)中，*向微服务和云原生应用的演进*，我们讨论了单片应用程序的问题以及架构如何演变为微服务。然而，微服务也有自己的一系列挑战：
- en: Organizations adopting microservice architectures also need to make challenging
    decisions around the consistency of microservices without affecting the innovation
    capabilities of the microservice teams.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用微服务架构的组织还需要在不影响微服务团队创新能力的情况下，就微服务的一致性做出具有挑战性的决策。
- en: Smaller applications mean more builds, releases, and deployments. This is usually
    addressed using more automation.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更小的应用意味着更多的构建、发布和部署。通常会使用更多的自动化来解决这个问题。
- en: Microservice architectures are built based on a large number of smaller, fine-grained
    services. There are challenges associated with managing configuration and availability
    of these services.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构是基于大量更小、细粒度服务构建的。管理这些服务的配置和可用性存在挑战。
- en: Debugging issues becomes more difficult because of the distributed nature of
    applications.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于应用程序的分布式特性，调试问题变得更加困难。
- en: To reap maximum benefits from microservice architectures, microservices should
    be Cloud-Native--easily deployable on the Cloud. In [Chapter 4](c4e1908a-b086-428c-8862-6474eb92f04a.xhtml),
    *Evolution toward Microservices and Cloud-Native Applications*, we discussed the
    characteristics of Twelve-Factor Apps--patterns that are typically considered
    good practices in Cloud-Native applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从微服务架构中获得最大的好处，微服务应该是Cloud-Native——可以轻松部署在云上。在[第4章](c4e1908a-b086-428c-8862-6474eb92f04a.xhtml)中，*向微服务和云原生应用的演进*，我们讨论了十二要素应用的特征——这些模式通常被认为是云原生应用中的良好实践。
- en: 'Spring Cloud aims to provide solutions to some commonly encountered patterns
    when building systems on the Cloud. Some of the important features include the
    following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud旨在提供一些在构建云上系统时常见的模式的解决方案。一些重要的特性包括以下内容：
- en: Solutions to manage distributed microservice configuration
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理分布式微服务配置的解决方案
- en: Service registration and discovery using Name servers
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用名称服务器进行服务注册和发现
- en: Load balancing across multiple instances of microservices
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个微服务实例之间进行负载均衡
- en: More fault-tolerant services using circuit breakers
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用断路器实现更具容错性的服务
- en: API Gateways for aggregation, routing, and caching
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于聚合、路由和缓存的API网关
- en: Distributed tracing across microservices
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨微服务的分布式跟踪
- en: It is important to understand that Spring Cloud is not a single project. It
    is a group of subprojects aimed at solving the problems associated with applications
    deployed on the Cloud.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解Spring Cloud不是一个单一的项目。它是一组旨在解决部署在云上的应用程序所面临问题的子项目。
- en: 'Some important Spring Cloud subprojects are as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一些重要的Spring Cloud子项目如下：
- en: '**Spring Cloud Config**: Enables centralized external configuration across
    different microservices across different environments.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring Cloud Config**：实现了在不同环境下不同微服务之间的集中外部配置。'
- en: '**Spring Cloud Netflix**: Netflix is one of the early adopters of microservice
    architecture. A number of internal Netflix projects were open sourced under the
    umbrella of Spring Cloud Netflix. Examples include Eureka, Hystrix, and Zuul.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring Cloud Netflix**：Netflix是微服务架构的早期采用者之一。在Spring Cloud Netflix的支持下，许多内部Netflix项目开源了。例如Eureka、Hystrix和Zuul。'
- en: '**Spring Cloud Bus**: Makes it easier to build the integration of microservices
    with a lightweight message broker.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring Cloud Bus**：使得与轻量级消息代理集成微服务更加容易。'
- en: '**Spring Cloud Sleuth**: Along with Zipkin, this provides distributed tracing
    solutions.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring Cloud Sleuth**：与Zipkin一起，提供了分布式跟踪解决方案。'
- en: '**Spring Cloud Data Flow**: Provides capabilities for building orchestration
    around microservice applications. Provides a DSL, GUI, and REST API.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring Cloud Data Flow**：提供了构建围绕微服务应用程序的编排能力。提供DSL、GUI和REST API。'
- en: '**Spring Cloud Stream**: Provides a simple declarative framework to integrate
    Spring-based (and Spring Boot)-based applications with message brokers such as
    Apache Kafka or RabbitMQ.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring Cloud Stream**：提供了一个简单的声明性框架，用于将基于Spring（和Spring Boot）的应用程序与诸如Apache
    Kafka或RabbitMQ之类的消息代理集成。'
- en: 'A few things are common to all projects under the Spring Cloud umbrella:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud伞下的所有项目都有一些共同点：
- en: They solve some of the common problems with developing applications on the Cloud
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们解决了在云上开发应用程序时的一些常见问题
- en: They provide great integration with Spring Boot
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们与Spring Boot集成得很好
- en: They are typically configured with simple annotations
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们通常配置简单的注解
- en: They make extensive use of auto-configuration
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们广泛使用自动配置
- en: Spring Cloud Netflix
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud Netflix
- en: 'Netflix is one of the first organizations to start making the switch from monolithic
    to microservice architectures. Netflix has been very open about documenting this
    experience. Some of the internal Netflix frameworks are open sourced under the
    umbrella of Spring Cloud Netflix. As defined on the Spring Cloud Netflix website
    ([https://cloud.spring.io/spring-cloud-netflix/](https://cloud.spring.io/spring-cloud-netflix/)):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix是第一批开始从单片到微服务架构转变的组织之一。Netflix一直非常开放地记录这一经验。一些内部Netflix框架在Spring Cloud
    Netflix的支持下开源。如在Spring Cloud Netflix网站上所定义的([https://cloud.spring.io/spring-cloud-netflix/](https://cloud.spring.io/spring-cloud-netflix/))：
- en: Spring Cloud Netflix provides Netflix OSS integrations for Spring Boot apps
    through autoconfiguration and binding to the Spring environment and other Spring
    programming model idioms.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Netflix通过自动配置和绑定到Spring环境以及其他Spring编程模型习语，为Spring Boot应用程序提供了Netflix
    OSS集成。
- en: 'Some of the important projects under the Spring Cloud Netflix umbrella are
    as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Netflix支持的一些重要项目如下：
- en: '**Eureka**: The Name server that provides service registration and discovery
    capabilities for microservices.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Eureka**: 提供微服务的服务注册和发现功能的名称服务器。'
- en: '**Hystrix**: Capabilities to build fault-tolerant microservices through circuit
    breakers. Also provides a dashboard.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Hystrix**: 通过断路器构建容错微服务的能力。还提供了一个仪表板。'
- en: '**Feign**: Declarative REST Client makes it easy to call services created with
    JAX-RS and Spring MVC.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Feign**: 声明式REST客户端，使调用使用JAX-RS和Spring MVC创建的服务变得容易。'
- en: '**Ribbon**: Provides client-side load balancing capabilities.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ribbon**: 提供客户端负载均衡能力。'
- en: '**Zuul**: Provides typical API Gateways capabilities, such as routing, filtering,
    authentication, and security. It can be extended with custom rules and filters.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Zuul**: 提供典型的API网关功能，如路由、过滤、认证和安全。它可以通过自定义规则和过滤器进行扩展。'
- en: Demo microservices setup
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演示微服务设置
- en: 'We will use two microservices to demonstrate concepts in this chapter:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两个微服务来演示本章的概念：
- en: '**Microservice A**: A simple microservice exposing two services--one to retrieve
    a message from the configuration file and another `random service` providing a
    list of random numbers.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务A**: 一个简单的微服务，公开了两个服务--一个用于从配置文件中检索消息，另一个`random service`提供了一个随机数列表。'
- en: '**Service consumer microservice**: A simple microservice exposing a simple
    calculation service called the `add` service. The `add` service consumes the `random
    service` from **Microservice A** and adds the numbers up.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务消费者微服务**: 一个简单的微服务，公开了一个称为`add`服务的简单计算服务。`add`服务从**微服务A**中消费了`random service`并将数字相加。'
- en: 'The following figure shows the relationship between the microservices and the
    services that are exposed:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了微服务之间以及公开的服务之间的关系：
- en: '![](img/1f95530f-f378-4100-8d83-68178a2f2052.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1f95530f-f378-4100-8d83-68178a2f2052.png)'
- en: Let's quickly set up these microservices.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速设置这些微服务。
- en: Microservice A
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务A
- en: 'Let''s use Spring Initializr ([https://start.spring.io](https://start.spring.io))
    to get started with Microservice A. Choose GroupId, ArtifactId, and the frameworks,
    as shown in the following screenshot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Spring Initializr ([https://start.spring.io](https://start.spring.io))来开始使用微服务A。选择GroupId、ArtifactId和框架，如下面的截图所示：
- en: '![](img/e5c2a4b9-d95c-4bfb-a393-60b6f51486ee.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5c2a4b9-d95c-4bfb-a393-60b6f51486ee.png)'
- en: 'We will create a service to expose a set of random numbers:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个服务来公开一组随机数：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Important things to note are as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一些重要事项如下：
- en: '`@RequestMapping("/random") public List<Integer> random()`: Random service
    returns a list of random numbers'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RequestMapping("/random") public List<Integer> random()`: 随机服务返回一个随机数列表'
- en: '`private int generateRandomNumber() {`: Generates random numbers between 0
    and 1000'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private int generateRandomNumber() {`: 生成0到1000之间的随机数'
- en: 'The following snippet shows a sample response from the service at `http://localhost:8080/random`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段显示了从`http://localhost:8080/random`服务的示例响应：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next, we would want to create a service to return a simple message from the
    application configuration in `application.properties`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望创建一个服务，从`application.properties`中的应用程序配置返回一个简单的消息。
- en: 'Let''s define a simple application configuration with one property--`message`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个简单的应用程序配置，其中包含一个属性--`message`：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A few important things to note are as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些重要事项需要注意：
- en: '`@ConfigurationProperties("application")`: Defines a class defining `application.properties`.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ConfigurationProperties("application")`: 定义了一个定义`application.properties`的类。'
- en: '`private String message`: Defines one property--`message`. The value can be
    configured in `application.properties` with `application.message` as the key.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private String message`: 定义了一个属性--`message`。该值可以在`application.properties`中使用`application.message`作为键进行配置。'
- en: 'Let''s configure `application.properties`, as shown in the following snippet:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们根据下面的片段配置`application.properties`：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A couple of important things to note are as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一些重要事项如下：
- en: '`spring.application.name=microservice-a`: `spring.application.name` is used
    to give a name to the application'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring.application.name=microservice-a`: `spring.application.name`用于为应用程序命名'
- en: '`application.message=Default Message`: Configures a default message for `application.message`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application.message=Default Message`: 为`application.message`配置了默认消息'
- en: 'Let''s create a controller to read the message and return it, as shown in the
    following snippet:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个控制器来读取消息并返回它，如下面的片段所示：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Important things to note are as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的重要事项如下：
- en: '`@Autowired private ApplicationConfiguration configuration`: Autowires `ApplicationConfiguration`
    to enable reading the configured message value.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Autowired private ApplicationConfiguration configuration`: 自动装配`ApplicationConfiguration`以启用读取配置消息值。'
- en: '`@RequestMapping("/message") public Map<String, String> welcome()`: Exposes
    a simple service at the URI/`message`.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RequestMapping("/message") public Map<String, String> welcome()`: 在URI/`message`上公开一个简单的服务。'
- en: '`map.put("message", configuration.getMessage())`: The service returns a map
    with one entry. It has a key message and the value is picked up from the `ApplicationConfiguration`.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map.put("message", configuration.getMessage())`：服务返回一个具有一个条目的映射。它有一个键消息，值是从`ApplicationConfiguration`中获取的。'
- en: 'When the service is executed at `http://localhost:8080/message`, we get the
    following response:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当在`http://localhost:8080/message`执行服务时，我们得到以下响应：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Service consumer
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务消费者
- en: 'Let''s set up another simple microservice to consume the `random service` exposed
    by Microservice A. Let''s use Spring Initializr ([https://start.spring.io](https://start.spring.io))
    to initialize the microservice, as shown in the following screenshot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置另一个简单的微服务来消费微服务A公开的`random service`。让我们使用Spring Initializr ([https://start.spring.io](https://start.spring.io))来初始化微服务，如下面的屏幕截图所示：
- en: '![](img/40200b6e-6840-47ea-94e5-41933a590a89.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/40200b6e-6840-47ea-94e5-41933a590a89.png)'
- en: 'Let''s add the service to consume `random service`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加消费`random service`的服务：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Important things to note are as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的重要事项如下：
- en: '`@Value("${number.service.url}") private String numberServiceUrl`: We would
    want the number service URL to be configurable in application properties.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Value("${number.service.url}") private String numberServiceUrl`：我们希望数字服务的URL在应用程序属性中可配置。'
- en: '`@RequestMapping("/add") public Long add()`: Exposes a service at the URI `/add`.
    The `add` method calls the number service using `RestTemplate` and has the logic
    to sum the numbers returned in the response.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RequestMapping("/add") public Long add()`: 在URI`/add`上公开一个服务。`add`方法使用`RestTemplate`调用数字服务，并具有对返回的数字求和的逻辑。'
- en: 'Let''s configure `application.properties`, as shown in the following snippet:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们配置`application.properties`，如下面的片段所示：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Important things to note are as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的重要事项如下：
- en: '`spring.application.name=service-consumer`: Configures a name for the Spring
    Boot application'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring.application.name=service-consumer`：为Spring Boot应用程序配置名称'
- en: '`server.port=8100`: Uses `8100` as the port for service consumer'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`server.port=8100`：使用`8100`作为服务消费者的端口'
- en: '`number.service.url=http://localhost:8080/random`: Configures the number service
    URL for use in the add service'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number.service.url=http://localhost:8080/random`：配置用于add服务的数字服务URL'
- en: 'When the service is called at the URL `http://localhost:8100/add`, the following
    response is returned:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当在URL`http://localhost:8100/add`调用服务时，将返回以下响应：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following is an extract from the log of Microservice A:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是微服务A日志的摘录：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The log shows that `random service` from Microservice A returned `5` numbers.
    The `add` service in the service consumer added them up and returned a result
    `2890`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 日志显示，来自微服务A的`random service`返回了`5`个数字。服务消费者中的`add`服务将它们相加并返回结果`2890`。
- en: We now have our example microservices ready. In the next steps, we will add
    Cloud-Native features to these microservices.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有我们的示例微服务准备好了。在接下来的步骤中，我们将为这些微服务添加云原生功能。
- en: Ports
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端口
- en: In this chapter, we will create six different microservices applications and
    components. To keep things simple, we will use specific ports for specific applications.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建六个不同的微服务应用程序和组件。为了保持简单，我们将为特定应用程序使用特定的端口。
- en: 'The following table shows the ports that we would reserve for use by the different
    applications created in this chapter:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了我们在本章中创建的不同应用程序所保留的端口：
- en: '| **Microservice component** | **Port(s) used** |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| **微服务组件** | **使用的端口** |'
- en: '| Microservice A | `8080` and `8081` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 微服务A | `8080` 和 `8081` |'
- en: '| Service consumer microservice | `8100` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 服务消费者微服务 | `8100` |'
- en: '| Config Server (Spring Cloud Config) | `8888` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 配置服务器（Spring Cloud Config） | `8888` |'
- en: '| Eureka server (Name server) | `8761` |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| Eureka服务器（名称服务器） | `8761` |'
- en: '| Zuul API Gateway Server | `8765` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| Zuul API网关服务器 | `8765` |'
- en: '| Zipkin Distributed Tracing Server | `9411` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| Zipkin分布式跟踪服务器 | `9411` |'
- en: We have two of our microservices ready. We are ready to Cloud-enable our microservices.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的两个微服务已经准备好了。我们准备为我们的微服务启用云功能。
- en: Centralized microservice configuration
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集中式微服务配置
- en: Spring Cloud Config provides solutions to externalize the configuration of a
    microservice. Let's first understand the need to externalize microservice configuration.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Config提供了外部化微服务配置的解决方案。让我们首先了解外部化微服务配置的需求。
- en: Problem statement
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题陈述
- en: In microservice architectures, we typically have a number of small microservices
    interacting with each other instead of a set of big monolithic applications. Each
    microservice is typically deployed in multiple environments--development, testing,
    load test, staging, and production. In addition, there can be multiple instances
    of microservices in different environments. For example, a specific microservice
    might be handling heavy load. There might be multiple production instances for
    that microservice in production.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，我们通常有许多小型微服务相互交互，而不是一组大型的单片应用程序。每个微服务通常部署在多个环境中--开发、测试、负载测试、暂存和生产。此外，不同环境中可能有多个微服务实例。例如，特定的微服务可能正在处理大量负载。在生产环境中可能有多个该微服务的实例。
- en: 'The configuration of an application typically contains the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的配置通常包括以下内容：
- en: '**Database configuration**: Details needed to connect to the database'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库配置**：连接到数据库所需的详细信息'
- en: '**Message broker configuration**: Any configuration needed to connect to AMQP
    or similar resources'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息代理配置**：连接到AMQP或类似资源所需的任何配置'
- en: '**External services configuration**: Other services that the microservice needs'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部服务配置**：微服务需要的其他服务'
- en: '**Microservice configuration**: Typical configuration related to the business
    logic of the microservice'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务配置**：与微服务的业务逻辑相关的典型配置'
- en: Each instance of a microservice can have its own configuration--different databases,
    different external services it consumes, among others. For example, if a microservice
    is deployed in five environments and there are four instances in each environment,
    the microservice can have a total of 20 different configurations.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务实例都可以有自己的配置--不同的数据库，不同的外部服务等。例如，如果一个微服务在五个环境中部署，并且每个环境中有四个实例，则该微服务可以拥有总共20个不同的配置。
- en: 'The following figure shows typical configurations needed for Microservice A.
    We are looking at two instances in development, three instances in QA, one instance
    in the stage, and four instances in production:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了Microservice A所需的典型配置。我们正在查看开发中的两个实例，QA中的三个实例，阶段中的一个实例以及生产中的四个实例：
- en: '![](img/45098e73-511a-4ffa-b328-1d75af0ed801.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/45098e73-511a-4ffa-b328-1d75af0ed801.png)'
- en: Solution
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: Maintaining configurations for different microservices separately would make
    it difficult for the operations team. The solution, as shown in the following
    figure, is to create a centralized **Configuration Server:**
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为不同的微服务单独维护配置会使运维团队难以处理。如下图所示的解决方案是创建一个集中式**配置服务器**：
- en: '![](img/8e0b5e0b-9d9f-43c0-9b90-f45f180b24a8.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e0b5e0b-9d9f-43c0-9b90-f45f180b24a8.png)'
- en: The centralized **Configuration Server** holds all the configuration belonging
    to all the different microservices. This helps in keeping the configuration separate
    from the application deployable.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 集中式**配置服务器**保存了所有不同微服务的配置。这有助于将配置与应用程序部署分开。
- en: The same deployable (EAR or WAR) can be used in different environments. However,
    all configuration (things that vary between different environments) will be stored
    in the centralized configuration server.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的可部署文件（EAR或WAR）可以在不同的环境中使用。但是，所有配置（在不同环境之间变化的内容）将存储在集中式配置服务器中。
- en: An important decision that needs to be made would be to decide whether there
    are separate instances of centralized configuration servers for different environments.
    Typically, you would want access to your production configuration to be more restrictive
    compared to other environments. At a minimum, we recommend a separate centralized
    configuration server for production. Other environments can share one instance
    of the configuration server.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 需要做出的一个重要决定是决定是否为不同的环境有单独的集中配置服务器实例。通常，您希望对生产配置的访问比其他环境更受限制。至少，我们建议为生产环境使用单独的集中配置服务器。其他环境可以共享一个配置服务器实例。
- en: Options
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选项
- en: 'The following screenshot shows the options provided in Spring Initializer for
    Cloud Config Servers:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了Spring Initializer提供的Cloud Config Servers选项：
- en: '![](img/7de9ab8a-1b96-4a33-8537-ffa0e4ccf592.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7de9ab8a-1b96-4a33-8537-ffa0e4ccf592.png)'
- en: In this chapter, we will configure a Cloud Config Server using Spring Cloud
    Config.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Spring Cloud Config配置Cloud Config Server。
- en: Spring Cloud Config
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud Config
- en: 'Spring Cloud Config provides support for centralized microservice configuration.
    It is a combination of two important components:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Config提供了对集中式微服务配置的支持。它是两个重要组件的组合：
- en: '**Spring Cloud Config Server**: Provides support for exposing centralized configuration
    backed up by a version control repository--GIT or subversion'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud Config Server：提供支持，通过版本控制仓库（GIT或子版本）公开集中配置
- en: '**Spring Cloud Config Client**: Provides support for applications to connect
    to Spring Cloud Config Server'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud Config Client：提供应用连接到Spring Cloud Config Server的支持
- en: 'The following figure shows a typical microservice architecture using Spring
    Cloud Config. The configuration for multiple microservices is stored in a single
    **GIT** repository:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了使用Spring Cloud Config的典型微服务架构。多个微服务的配置存储在单个**GIT**仓库中：
- en: '![](img/79fd2b15-8bbf-4ed8-aad9-ff7e3d01615f.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79fd2b15-8bbf-4ed8-aad9-ff7e3d01615f.png)'
- en: Implementing Spring Cloud Config Server
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Spring Cloud Config Server
- en: 'The following figure shows the updated implementation of Microservice A and
    service consumer with Spring Cloud Config. In the following figure, we will integrate
    Microservice A with Spring Cloud Config in order to retrieve its configuration
    from the local Git repository:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了使用Spring Cloud Config更新Microservice A和服务消费者的实现。在下图中，我们将Microservice A与Spring
    Cloud Config集成，以从本地Git仓库中检索其配置：
- en: '![](img/f6c0b98f-7daf-4148-93f0-7ccb6a9969c2.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6c0b98f-7daf-4148-93f0-7ccb6a9969c2.png)'
- en: 'Implementing Spring Cloud Config needs the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 实现Spring Cloud Config需要以下内容：
- en: Setting up the Spring Cloud Config server.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置Spring Cloud Config服务器。
- en: Setting up a local Git repository and connecting it to Spring Cloud Config server.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置本地Git仓库并将其连接到Spring Cloud Config服务器。
- en: Updating Microservice A to use the configuration from Cloud Config Server--using
    Spring Cloud Config Client.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新Microservice A以使用来自Cloud Config Server的配置--使用Spring Cloud Config Client。
- en: Setting up Spring Cloud Config Server
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Spring Cloud Config Server
- en: 'Let''s set up the Cloud Config Server using Spring Initializr ([http://start.spring.io](http://start.spring.io)).
    The following screenshot shows GroupId and ArtifactId to choose. Make sure that
    you select Config Server as a dependency:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Spring Initializr（[http://start.spring.io](http://start.spring.io)）设置Cloud
    Config Server。以下截图显示了要选择的GroupId和ArtifactId。确保选择Config Server作为依赖项：
- en: '![](img/13a42290-1416-41f5-a85b-bbdaeb6d73ce.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13a42290-1416-41f5-a85b-bbdaeb6d73ce.png)'
- en: 'If you want to add the Config Server to an existing application, use the dependency
    shown here:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要将Config Server添加到现有应用程序中，请使用此处显示的依赖项：
- en: '[PRE10]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once the project is created, the first step is to add the `EnableConfigServer`
    annotation. The following snippet shows the annotation added to `ConfigServerApplication`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 项目创建后，第一步是添加`EnableConfigServer`注解。以下代码片段显示了将注解添加到`ConfigServerApplication`中：
- en: '[PRE11]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Connecting Spring Cloud Config Server to a local Git repository
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Spring Cloud Config Server连接到本地Git仓库
- en: The Config Server needs to be connected to a Git repository. To keep things
    simple, let's connect to a local Git repository.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 配置服务器需要连接到一个Git存储库。为了保持简单，让我们连接到一个本地Git存储库。
- en: You can install Git for your specific operating system from [https://git-scm.com](https://git-scm.com).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://git-scm.com](https://git-scm.com)为您的特定操作系统安装Git。
- en: The following commands help you set a simple local Git repository.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令可帮助您设置一个简单的本地Git存储库。
- en: 'Switch to a directory of your choice after installing Git. Execute the following
    commands on a terminal or Command Prompt:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Git后切换到您选择的目录。在终端或命令提示符上执行以下命令：
- en: '[PRE12]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a file called `microservice-a.properties` in the `git-localconfig-repo`
    folder with the content shown here:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在`git-localconfig-repo`文件夹中创建一个名为`microservice-a.properties`的文件，内容如下：
- en: '[PRE13]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Execute the following commands to add and commit `microservice-a.properties`
    to a local Git repository:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令将`microservice-a.properties`添加并提交到本地Git存储库：
- en: '[PRE14]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now that we have the local Git repository ready with our configuration, we
    would need to connect the Config Server to it. Let''s configure `application.properties`
    in `config-server`, as shown here:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了具有我们配置的本地Git存储库，我们需要将配置服务器连接到它。让我们按照这里所示配置`config-server`中的`application.properties`：
- en: '[PRE15]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Some important things to note are as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一些重要的事项如下：
- en: '`server.port=8888`: Configures the port for Config Server. `8888` is typically
    the most commonly used port for Config Server.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`server.port=8888`：配置配置服务器的端口。`8888`通常是配置服务器最常用的端口。'
- en: '`spring.cloud.config.server.git.uri=file:///in28Minutes/Books/MasteringSpring/git-localconfig-repo`:
    Configures the URI to the local Git repository. If you want to connect to a remote
    Git repository, you can configure the URI of the Git repository here.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring.cloud.config.server.git.uri=file:///in28Minutes/Books/MasteringSpring/git-localconfig-repo`：配置到本地Git存储库的URI。如果要连接到远程Git存储库，可以在这里配置Git存储库的URI。'
- en: 'Start the server. When you hit the URL `http://localhost:8888/microservice-a/default`,
    you will see the following response:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 启动服务器。当您访问URL`http://localhost:8888/microservice-a/default`时，您将看到以下响应：
- en: '[PRE16]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Some important things to understand are as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一些重要的事项如下：
- en: '`http://localhost:8888/microservice-a/default`: The URI format is `/{application-name}/{profile}[/{label}]`.
    Here, the `application-name` is `microservice-a` and the profile is `default`.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8888/microservice-a/default`：URI格式为`/{application-name}/{profile}[/{label}]`。这里，`application-name`是`microservice-a`，配置文件是`default`。'
- en: The service returns the configuration from `microservice-a.properties` since
    we are using the default profile. You can see it in the response in the `propertySources`>`name`
    field.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们使用默认配置文件，该服务将从`microservice-a.properties`返回配置。您可以在`propertySources`>`name`字段的响应中看到它。
- en: '`"source":{"application.message":"Message From Default Local Git Repository"}`:
    The content of the response is the content of the property file.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"source":{"application.message":"Message From Default Local Git Repository"}`：响应的内容是属性文件的内容。'
- en: Creating an environment-specific configuration
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建特定于环境的配置
- en: Let's create a specific configuration for Microservice A for the `dev` environment.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`dev`环境为Microservice A创建一个特定的配置。
- en: 'Create a new file in `git-localconfig-repo` with the name `microservice-a-dev.properties`
    with the content shown here:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在`git-localconfig-repo`中创建一个名为`microservice-a-dev.properties`的新文件，内容如下：
- en: '[PRE17]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Execute the following commands to `add` and `commit` `microservice-a-dev.properties`
    to the local Git repository:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令将`microservice-a-dev.properties`添加并提交到本地Git存储库：
- en: '[PRE18]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When you hit the URL `http://localhost:8888/microservice-a/dev`, you will see
    the following response:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当您访问URL`http://localhost:8888/microservice-a/dev`时，您将看到以下响应：
- en: '[PRE19]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The response contains the `dev` configuration from `microservice-a-dev.properties`.
    The configuration from the default property file (`microservice-a.properties`)
    is also returned. Properties configured in `microservice-a-dev.properties` (environment-specific
    properties) have higher priority than the defaults configured in `microservice-a.properties`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 响应包含来自`microservice-a-dev.properties`的`dev`配置。还返回了默认属性文件（`microservice-a.properties`）中的配置。在`microservice-a-dev.properties`中配置的属性（特定于环境的属性）优先级高于在`microservice-a.properties`中配置的默认属性。
- en: Similar to `dev`, a separate configuration for Microservice A can be created
    for different environments. If there is a need for multiple instances in a single
    environment, a tag can be used to differentiate. A URL of the format `http://localhost:8888/microservice-a/dev/{tag}`
    can be used to retrieve configuration based on the specific tag.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`dev`，可以为不同的环境创建Microservice A的单独配置。如果在单个环境中需要多个实例，可以使用标签进行区分。可以使用格式为`http://localhost:8888/microservice-a/dev/{tag}`的URL来根据特定标签检索配置。
- en: The next step is to connect Microservice A to the Config Server.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将Microservice A连接到配置服务器。
- en: Spring Cloud Config Client
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud配置客户端
- en: 'We will use Spring Cloud Config Client to connect `Microservice A` to `Config
    Server`. The dependency is shown here. Add the following code to the `pom.xml`
    file of `Microservice A`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Spring Cloud配置客户端将`Microservice A`连接到`配置服务器`。依赖项如下所示。将以下代码添加到`Microservice
    A`的`pom.xml`文件中：
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Dependencies for Spring Cloud are managed differently from Spring Boot. We
    will use dependency management to manage dependencies. The following snippet will
    ensure that the correct version of all Spring Cloud dependencies is used:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud的依赖项与Spring Boot的管理方式不同。我们将使用依赖项管理来管理依赖项。以下代码段将确保使用所有Spring Cloud依赖项的正确版本：
- en: '[PRE21]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Rename `application.properties` in `Microservice A` to `bootstrap.properties`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Microservice A`中的`application.properties`重命名为`bootstrap.properties`。
- en: 'Configure it as shown here:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这里所示进行配置：
- en: '[PRE22]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since we would want `Microservice A` to connect to `Config Server`, we provide
    the URI of `Config Server` using `spring.cloud.config.uri`. Cloud Config Server
    is used to retrieve the configuration for microservice A. Hence, the configuration
    is provided in `bootstrap.properties`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望`微服务A`连接到`Config Server`，因此我们使用`spring.cloud.config.uri`提供`Config Server`的URI。
    Cloud Config Server用于检索微服务A的配置。因此，配置在`bootstrap.properties`中提供。
- en: '**Spring Cloud Context**: Spring Cloud introduces a few important concepts
    for the Spring application deployed in the Cloud. The Bootstrap Application Context
    is an important concept. It is the parent context for the microservice application.
    It is responsible for loading an external configuration (for example, from Spring
    Cloud Config Server) and Decrypting Configuration Files (external and local).
    The Bootstrap context is configured using bootstrap.yml or bootstrap.properties.
    We had to change the name of application.properties to bootstrap.properties in
    Microservice A earlier because we want Microservice A to use the Config Server
    for bootstrapping.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring Cloud Context**：Spring Cloud为部署在云中的Spring应用程序引入了一些重要概念。引导应用程序上下文是一个重要概念。它是微服务应用程序的父上下文。它负责加载外部配置（例如，来自Spring
    Cloud Config Server）和解密配置文件（外部和本地）。引导上下文使用bootstrap.yml或bootstrap.properties进行配置。我们之前必须将application.properties的名称更改为Microservice
    A中的bootstrap.properties，因为我们希望Microservice A使用Config Server进行引导。'
- en: 'An extract from the log when Microservice A is restarted is shown here:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Microservice A重新启动时日志中的提取如下所示：
- en: '[PRE23]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `Microservice A` service is using the configuration from `Spring Config
    Server` at `http://localhost:8888`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`微服务A`服务正在使用来自`Spring Config Server`的配置，地址为`http://localhost:8888`。'
- en: 'The following is the response when `Message Service` at `http://localhost:8080/message`
    is invoked:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`http://localhost:8080/message`上的`消息服务`时，以下是响应：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The message is picked up from the `localconfig-repo/microservice-a.properties`
    file.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 消息是从`localconfig-repo/microservice-a.properties`文件中提取的。
- en: 'You can set the active profile to `dev` to pick up the dev configuration:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将活动配置设置为`dev`以获取dev配置：
- en: '[PRE25]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The configuration for the service consumer microservice can also be stored in
    `local-config-repo` and exposed using Spring Config Server.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 服务消费者微服务的配置也可以存储在`local-config-repo`中，并使用Spring Config Server公开。
- en: Spring Cloud Bus
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud Bus
- en: Spring Cloud Bus makes it seamless to connect microservices to lightweight message
    brokers, such as Kafka and RabbitMQ.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Bus使得将微服务连接到轻量级消息代理（如Kafka和RabbitMQ）变得轻松。
- en: The need for Spring Cloud Bus
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud Bus的需求
- en: 'Consider an example of making a configuration change in a microservice. Let''s
    assume that there are five instances of `Microservice A` running in production.
    We would need to make an emergency configuration change. For example, let''s make
    a change in `localconfig-repo/microservice-a.properties`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个在微服务中进行配置更改的例子。假设在生产环境中有五个运行中的`微服务A`实例。我们需要进行紧急配置更改。例如，让我们在`localconfig-repo/microservice-a.properties`中进行更改：
- en: '[PRE26]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For `Microservice A` to pick up this configuration change, we need to invoke
    a `POST` request on `http://localhost:8080/refresh`. The following command can
    be executed at command prompt to send a `POST` request:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`微服务A`获取此配置更改，我们需要在`http://localhost:8080/refresh`上调用`POST`请求。可以在命令提示符处执行以下命令以发送`POST`请求：
- en: '[PRE27]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You will see the configuration change reflected at `http://localhost:8080/message`.
    The following is the response from the service:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在`http://localhost:8080/message`看到配置更改的反映。以下是服务的响应：
- en: '[PRE28]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We have five instances of Microservice A running. The change in configuration
    is reflected only for the instance of the Microservice A where the URL is executed.
    The other four instances will not receive the configuration change until the refresh
    request is executed on them.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有五个运行中的Microservice A实例。配置更改仅对执行URL的Microservice A实例反映。其他四个实例在执行刷新请求之前将不会接收配置更改。
- en: If there are a number of instances of a microservice, then executing the refresh
    URL for each instance becomes cumbersome since you would need to do this for every
    configuration change.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个微服务实例，则对每个实例执行刷新URL变得很麻烦，因为您需要对每个配置更改执行此操作。
- en: Propogating configuration changes using Spring Cloud Bus
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Bus传播配置更改
- en: The solution is to use Spring Cloud Bus to propagate the configuration change
    to multiple instances over a message broker such as RabbitMQ.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是使用Spring Cloud Bus通过消息代理（如RabbitMQ）向多个实例传播配置更改。
- en: 'The following figure shows how different instances of a microservice (actually,
    they can be completely different microservices as well) are connected to a message
    broker using Spring Cloud Bus:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了不同实例的微服务（实际上，它们也可以是完全不同的微服务）如何使用Spring Cloud Bus连接到消息代理：
- en: '![](img/be9ea549-8fe5-4744-be5a-3a007351da74.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be9ea549-8fe5-4744-be5a-3a007351da74.png)'
- en: Each microservice instance will register with the Spring Cloud Bus at application
    startup.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务实例将在应用程序启动时向Spring Cloud Bus注册。
- en: When refresh is called on one of the microservice instances, Spring Cloud Bus
    will propagate a change event to all the microservice instances. The microservice
    instances will request the updated configuration from the configuration server
    on receiving the change event.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当刷新调用一个微服务实例时，Spring Cloud Bus将向所有微服务实例传播更改事件。微服务实例在接收更改事件时将从配置服务器请求更新的配置。
- en: Implementation
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: We will use RabbitMQ as the message broker. Ensure that you have installed and
    started up RabbitMQ before proceeding further.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用RabbitMQ作为消息代理。在继续之前，请确保已安装并启动了RabbitMQ。
- en: Installation instructions for RabbitMQ are provided at [https://www.rabbitmq.com/download.html](https://www.rabbitmq.com/download.html).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ的安装说明请参见[https://www.rabbitmq.com/download.html](https://www.rabbitmq.com/download.html)。
- en: 'The next step is to add connectivity to Spring Cloud Bus for `Microservice
    A`. Let''s add the following dependency in the `pom.xml` file of Microservice
    A:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为`Microservice A`添加与Spring Cloud Bus的连接。让我们在Microservice A的`pom.xml`文件中添加以下依赖项：
- en: '[PRE29]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can run `Microservice A` on different ports by providing the port as one
    of the startup VM arguments. The following screenshot shows how you can configure
    the server port as the VM argument in Eclipse. The value configured is `-Dserver.port=8081`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将端口作为启动VM参数之一来在不同端口上运行`Microservice A`。以下屏幕截图显示了如何在Eclipse中将服务器端口配置为VM参数。配置的值为`-Dserver.port=8081`：
- en: '![](img/40b004ac-c709-40f6-8f50-9b0b4b602ac5.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/40b004ac-c709-40f6-8f50-9b0b4b602ac5.png)'
- en: 'We will run Microservice A on ports `8080` (default) and `8081`. The following
    is an extract from the log when Microservice A is restarted:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在端口`8080`（默认）和`8081`上运行Microservice A。以下是在重新启动Microservice A时日志的摘录：
- en: '[PRE30]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: All instances of `Microservice A` are registered with `Spring Cloud Bus` and
    listen to events on the Cloud Bus. The default configuration of RabbitMQ Connection
    is a result of the magic of autoconfiguration.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`Microservice A`的实例都已在`Spring Cloud Bus`中注册，并监听Cloud Bus上的事件。RabbitMQ连接的默认配置是自动配置的魔术结果。
- en: 'Let''s update `microservice-a.properties` with a new message now:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更新`microservice-a.properties`中的新消息：
- en: '[PRE31]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Commit the file and fire a request to refresh the configuration on one of the
    instances, let''s say port `8080`, using the URL `http://localhost:8080/bus/refresh`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 提交文件并发送请求以刷新其中一个实例的配置，比如端口`8080`，使用URL`http://localhost:8080/bus/refresh`：
- en: '[PRE32]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following is an extract from the log of the second instance of `Microservice
    A` running on port `8081`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是运行在端口`8081`上的第二个`Microservice A`实例的日志摘录：
- en: '[PRE33]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can see that even though the refresh URL is not called on port `8081`, the
    updated message is picked up from the Config Server. This is because all instances
    of Microservice A are listening on the Spring Cloud Bus for change events. As
    soon as the refresh URL is called on one of the instances, it triggers a change
    event and all other instances pick up the changed configuration.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，即使刷新URL未在端口`8081`上调用，更新的消息仍然从配置服务器中获取。这是因为Microservice A的所有实例都在Spring
    Cloud Bus上监听更改事件。一旦在其中一个实例上调用刷新URL，它就会触发更改事件，所有其他实例都会获取更改后的配置。
- en: 'You will see the configuration change reflect in both instances of Microservice
    A at `http://localhost:8080/message` and `http://localhost:8081/message`. The
    following is the response from the service:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到配置更改反映在Microservice A的两个实例中，分别是`http://localhost:8080/message`和`http://localhost:8081/message`。以下是服务的响应：
- en: '[PRE34]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Declarative REST Client - Feign
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明式REST客户端 - Feign
- en: Feign helps us create REST clients for REST services with minimum configuration
    and code. All you need to define is a simple interface and use proper annotations.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Feign帮助我们使用最少的配置和代码创建REST服务的REST客户端。您只需要定义一个简单的接口并使用适当的注释。
- en: '`RestTemplate` is typically used to make REST service calls. Feign helps us
    write REST clients without the need for `RestTemplate` and the logic around it.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`RestTemplate`通常用于进行REST服务调用。Feign帮助我们编写REST客户端，而无需`RestTemplate`和围绕它的逻辑。'
- en: Feign integrates well with Ribbon (client-side load balancing) and Eureka (Name
    server). We will look at this integration later in the chapter.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Feign与Ribbon（客户端负载平衡）和Eureka（名称服务器）很好地集成。我们将在本章后面看到这种集成。
- en: 'To use Feign, let''s add the Feign starter to the `pom.xml` file of service
    consumer microservice:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Feign，让我们将Feign starter添加到服务消费者微服务的`pom.xml`文件中：
- en: '[PRE35]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We need to add `dependencyManagement` for Spring Cloud to the `pom.xml` file
    as this is the first Cloud dependency that service consumer microservice is using:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将Spring Cloud的`dependencyManagement`添加到`pom.xml`文件中，因为这是服务消费者微服务使用的第一个Cloud依赖项：
- en: '[PRE36]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The next step is to add the annotation in order to enable scanning for Feign
    clients to `ServiceConsumerApplication`. The following snippet shows the usage
    of the `@EnableFeignClients` annotation:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加注释以启用对`ServiceConsumerApplication`中Feign客户端的扫描。以下代码片段显示了`@EnableFeignClients`注释的用法：
- en: '[PRE37]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We need to define a simple interface to create a Feign client for a `random
    service`. The following snippet shows the details:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义一个简单的接口来创建一个`random service`的Feign客户端。以下代码片段显示了详细信息：
- en: '[PRE38]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Some important things to note are as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一些重要事项如下：
- en: '`@FeignClient(name ="microservice-a", url="localhost:8080")`: The `FeignClient`
    annotation is used to declare that a REST client with the given interface needs
    to be created. We are hardcoding the URL of `Microservice A` for now. Later, we
    will look at how we can connect this to a Name server and eliminate the need for
    hardcoding.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@FeignClient(name ="microservice-a", url="localhost:8080")`: `FeignClient`注解用于声明需要创建具有给定接口的REST客户端。我们现在正在硬编码`Microservice
    A`的URL。稍后，我们将看看如何将其连接到名称服务器并消除硬编码的需要。'
- en: '`@RequestMapping(value = "/random", method = RequestMethod.GET)`: This specific
    GET service method is exposed at the URI `/random`.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RequestMapping(value = "/random", method = RequestMethod.GET)`: 此特定的GET服务方法在URI`/random`上公开。'
- en: '`public List<Integer> getRandomNumbers()`: This defines the interface of the
    service method.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public List<Integer> getRandomNumbers()`: 这定义了服务方法的接口。'
- en: 'Let''s update `NumberAdderController` to use `RandomServiceProxy` in order
    to call the service. The following snippet shows the important details:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新`NumberAdderController`以使用`RandomServiceProxy`来调用服务。以下代码片段显示了重要细节：
- en: '[PRE39]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'A couple of important things to note are as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一些重要事项如下：
- en: '`@Autowired private RandomServiceProxy randomServiceProxy`: `RandomServiceProxy`
    is autowired in.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Autowired private RandomServiceProxy randomServiceProxy`: `RandomServiceProxy`被自动装配。'
- en: '`List<Integer> numbers = randomServiceProxy.getRandomNumbers()`: Look at how
    simple it is to use the Feign client. No playing around with `RestTemplate` anymore.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<Integer> numbers = randomServiceProxy.getRandomNumbers()`: 看看使用Feign客户端是多么简单。不再需要使用`RestTemplate`。'
- en: 'When we invoke the `add` service in service consumer microservice at `http://localhost:8100/add`,
    you will get the following response:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在服务消费者微服务中调用`add`服务时，您将获得以下响应：
- en: '[PRE40]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'GZIP compression can be enabled on Feign requests by configuring it, as shown
    in the following snippet:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过配置来启用Feign请求的GZIP压缩，如下所示：
- en: '[PRE41]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Load balancing
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 负载均衡
- en: Microservices are the most important building blocks of Cloud-Native architectures.
    Microservice instances are scaled up and down based on the load of a specific
    microservice. How do we ensure that the load is equally distributed among the
    different instances of microservices? That's where the magic of load balancing
    comes in. Load balancing is important in order to ensure that the load is equally
    distributed among the different instances of microservices.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是云原生架构中最重要的构建模块。微服务实例根据特定微服务的负载进行扩展和缩减。我们如何确保负载在不同微服务实例之间均匀分布？这就是负载均衡的魔力所在。负载均衡对于确保负载在不同微服务实例之间均匀分布至关重要。
- en: Ribbon
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ribbon
- en: 'As shown in the following figure, Spring Cloud Netflix Ribbon provides client-side
    load balancing using round robin execution among the different instances of a
    microservice:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，Spring Cloud Netflix Ribbon提供了客户端负载均衡，使用轮询执行在不同微服务实例之间。
- en: '![](img/cb2fee3a-ecb1-46be-acaa-6e61b51f88f7.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb2fee3a-ecb1-46be-acaa-6e61b51f88f7.png)'
- en: Implementation
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: We will add Ribbon to service consumer microservice. The service consumer microservice
    will distribute the load among two instances of Microservice A.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在服务消费者微服务中添加Ribbon。服务消费者微服务将在两个`微服务A`实例之间分发负载。
- en: 'Let''s start with adding the Ribbon dependency to the `pom.xml` file of service
    consumer microservice:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在服务消费者微服务的`pom.xml`文件中添加Ribbon依赖开始：
- en: '[PRE42]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we can configure the URLs for the different instances of Microservice
    A. Add the following configuration to `application.properties` in service consumer
    microservice:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以配置不同`微服务A`实例的URL。在服务消费者微服务的`application.properties`中添加以下配置：
- en: '[PRE43]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We will then specify the `@RibbonClient` annotation on the service proxy--`RandomServiceProxy`
    in this example. The `@RibbonClient` annotation is used to specify declarative
    configuration for a ribbon client:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将在服务代理`RandomServiceProxy`上指定`@RibbonClient`注解。`@RibbonClient`注解用于指定ribbon客户端的声明性配置：
- en: '[PRE44]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When you restart the service consumer microservice and hit the add service
    at `http://localhost:8100/add`, you will get the following response:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当您重新启动服务消费者微服务并访问`http://localhost:8100/add`上的添加服务时，您将获得以下响应：
- en: '[PRE45]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This request is handled by an instance of `Microservice A` running on port
    `8080`, An extract from the log is shown here:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这个请求由运行在端口`8080`上的`微服务A`实例处理，日志中显示了一部分内容：
- en: '[PRE46]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'When we hit the add service again at the same URL, `http://localhost:8100/add`
    we get the following response:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们再次在相同的URL`http://localhost:8100/add`上访问添加服务时，我们会得到以下响应：
- en: '[PRE47]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'However, this time, the request is handled by an instance of `Microservice
    A` running on port `8081`. An extract from the log is shown here:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这次请求由运行在端口`8081`上的`微服务A`实例处理。日志中显示了一部分内容：
- en: '[PRE48]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We have now successfully distributed the load among the different instances
    of `Microservice A`. While this can be improved further, this is a good start.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经成功地将负载分布在不同的`微服务A`实例之间。虽然这还有待进一步改进，但这是一个很好的开始。
- en: 'While round robin (`RoundRobinRule`) is the default algorithm used by Ribbon,
    there are other options available:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然轮询（`RoundRobinRule`）是Ribbon使用的默认算法，但还有其他选项可用：
- en: '`AvailabilityFilteringRule` will skip servers that are down and that have a
    number of concurrent connections.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AvailabilityFilteringRule`将跳过宕机的服务器和具有大量并发连接的服务器。'
- en: '`WeightedResponseTimeRule` will pick the server based on the response times.
    If a server takes a long time to respond, it will get fewer requests.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WeightedResponseTimeRule`将根据响应时间选择服务器。如果服务器响应时间长，它将获得更少的请求。'
- en: 'The algorithm to be used can be specified in the application configuration:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在应用程序配置中指定要使用的算法：
- en: '[PRE49]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `microservice-a` is the name of the service we specified in the `@RibbonClient(name="microservice-a")`
    annotation.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`microservice-a`是我们在`@RibbonClient(name="microservice-a")`注解中指定的服务名称。'
- en: 'The following figure shows the architecture for the components we have set
    up already:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了我们已经设置的组件的架构：
- en: '![](img/420f239b-4d07-43cf-9da0-45c96c08afd5.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](img/420f239b-4d07-43cf-9da0-45c96c08afd5.png)'
- en: The Name server
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 名称服务器
- en: Microservice architectures involve a number of smaller microservices interacting
    with each other. Adding to this, there can be multiple instances of each microservice.
    Maintaining the external service connections and configurations manually would
    be difficult as new instances of microservices are dynamically created and destroyed.
    Name servers provide features of service registration and service discovery. Name
    servers allow microservices to register themselves and also discover the URLs
    to other microservices they want to interact with.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构涉及许多较小的微服务相互交互。除此之外，每个微服务可能有多个实例。手动维护外部服务连接和配置将会很困难，因为新的微服务实例是动态创建和销毁的。名称服务器提供了服务注册和服务发现的功能。名称服务器允许微服务注册自己，并发现它们想要与之交互的其他微服务的URL。
- en: Limitations of hard coding microservice URLs
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬编码微服务URL的限制
- en: 'In the previous example, we added the following configuration to `application.properties`
    in the service consumer microservice:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们在服务消费者微服务的`application.properties`中添加了以下配置：
- en: '[PRE50]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This configuration represents all instances of Microservice A. Take a look
    at these situations:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置代表了所有`微服务A`的实例。看看这些情况：
- en: A new instance of Microservice A is created
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个新的`微服务A`实例
- en: An existing instance of Microservice A is no longer available
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有的`微服务A`实例不再可用
- en: Microservice A is moved to a different server
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`微服务A`被移动到不同的服务器'
- en: In all these instances, the configuration needs to be updated and the microservices
    refreshed in order to pick up the changes.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些实例中，需要更新配置并刷新微服务以获取更改。
- en: Workings of Name server
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 名称服务器的工作原理
- en: 'The Name server is an ideal solution for the preceding situation. The following
    diagram shows how Name servers work:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 名称服务器是前述情况的理想解决方案。以下图表显示了名称服务器的工作原理：
- en: '![](img/22015697-765e-438b-a8f4-5e285ca86d00.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22015697-765e-438b-a8f4-5e285ca86d00.png)'
- en: All microservices (different microservices and all their instances) will register
    themselves with the Name server as each microservice starts up. When a service
    consumer wants to get the location of a specific microservice, it requests the
    Name server.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 所有微服务（不同的微服务及其所有实例）将在每个微服务启动时注册到名称服务器。当服务消费者想要获取特定微服务的位置时，它会请求名称服务器。
- en: A unique microservice ID is assigned to each microservice. This is used as a
    key in the register request and the lookup request.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个微服务分配一个唯一的微服务ID。这将用作注册请求和查找请求中的键。
- en: Microservices can automatically register and unregister themselves. Whenever
    a service consumer looks up the Name server with a microservice ID, it will get
    the list of the instances of that specific microservice.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务可以自动注册和注销。每当服务消费者使用微服务ID查找名称服务器时，它将获得该特定微服务实例的列表。
- en: Options
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选项
- en: 'The following screenshot shows the different options available for service
    discovery in Spring Initializr ([http://start.spring.io](http://start.spring.io)):'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了Spring Initializr（[http://start.spring.io](http://start.spring.io)）中用于服务发现的不同选项：
- en: '![](img/2e421967-7dbf-41d7-b286-de6c55fe5371.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e421967-7dbf-41d7-b286-de6c55fe5371.png)'
- en: We are going to use Eureka as the Name server for service discovery in our example.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在示例中使用Eureka作为服务发现的名称服务器。
- en: Implementation
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: 'The implementation of Eureka for our example involves the following:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例中Eureka的实现涉及以下内容：
- en: Setting up `Eureka Server`.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`Eureka Server`。
- en: Updating `Microservice A` instances to register with `Eureka Server`.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新“微服务A”实例以注册到“Eureka Server”。
- en: Updating service consumer microservice to use the Microservice A instances registered
    with `Eureka Server`.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新服务消费者微服务以使用Eureka Server中注册的“微服务A”实例。
- en: Setting up a Eureka Server
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Eureka Server
- en: 'We will use Spring Initializr ([http://start.spring.io](http://start.spring.io))
    to set up a new project for Eureka Server. The following screenshot shows the
    GroupId, ArtifactId, and Dependencies to be selected:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Spring Initializr（[http://start.spring.io](http://start.spring.io)）为Eureka
    Server设置一个新项目。以下截图显示了要选择的GroupId、ArtifactId和Dependencies：
- en: '![](img/34156e01-00c7-40d9-b4f6-7a0d97564ee1.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](img/34156e01-00c7-40d9-b4f6-7a0d97564ee1.png)'
- en: 'The next step is to add the `EnableEurekaServer` annotation to the `SpringBootApplication`
    class. The following snippet shows the details:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将`EnableEurekaServer`注解添加到`SpringBootApplication`类中。以下片段显示了详细信息：
- en: '[PRE51]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The following snippet shows the configuration in `application.properties`:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段显示了`application.properties`中的配置：
- en: '[PRE52]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We are using port `8761` for `Eureka Naming Server`. Launch `EurekaServerApplication`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用端口`8761`作为`Eureka Naming Server`。启动`EurekaServerApplication`。
- en: 'A screenshot of the Eureka dashboard at `http://localhost:8761` is shown here:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: Eureka仪表板的截图在`http://localhost:8761`中显示如下：
- en: '![](img/bae8f703-7072-4d30-9565-3856e9361326.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bae8f703-7072-4d30-9565-3856e9361326.png)'
- en: As of now, there are no applications registered with Eureka. In the next step,
    let's register `Microservice A` and other services with Eureka.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，没有应用程序注册到Eureka。在下一步中，让我们注册“微服务A”和其他服务到Eureka。
- en: Registering microservices with Eureka
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Eureka注册微服务
- en: 'To register any microservice with the Eureka Name server, we would need to
    add the dependency on Eureka Starter project. The following dependency needs to
    be added to the `pom.xml` file of Microservice A:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 要将任何微服务注册到Eureka名称服务器，我们需要在Eureka Starter项目中添加依赖项。需要将以下依赖项添加到“Microservice A”的`pom.xml`文件中：
- en: '[PRE53]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The next step is to add `EnableDiscoveryClient` to the `SpringBootApplication`
    classes. An example of `MicroserviceAApplication` is shown here:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将`EnableDiscoveryClient`添加到`SpringBootApplication`类中。这里显示了`MicroserviceAApplication`的示例：
- en: '[PRE54]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Spring Cloud Commons hosts the common classes used in different Spring Cloud
    implementations. A good example is the `@EnableDiscoveryClient` annotation. Different
    implementations are provided by Spring Cloud Netflix Eureka, Spring Cloud Consul
    Discovery, and Spring Cloud Zookeeper Discovery.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Commons托管了在不同Spring Cloud实现中使用的公共类。一个很好的例子是`@EnableDiscoveryClient`注解。Spring
    Cloud Netflix Eureka、Spring Cloud Consul Discovery和Spring Cloud Zookeeper Discovery提供了不同的实现。
- en: 'We will configure the URL of the naming server in the application configuration.
    For Microservice A, the application configuration is in the local Git repository
    file, `git-localconfig-repomicroservice-a.properties`:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在应用程序配置中配置命名服务器的URL。对于Microservice A，应用程序配置在本地Git存储库文件`git-localconfig-repomicroservice-a.properties`中：
- en: '[PRE55]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'When both instances of `Microservice A` are restarted, you will see these messages
    in the log of `Eureka Server`:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个“微服务A”的实例都重新启动时，您将在“Eureka Server”的日志中看到以下消息：
- en: '[PRE56]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'A screenshot of the Eureka Dashboard at `http://localhost:8761` is shown as
    follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: Eureka仪表板的截图在`http://localhost:8761`中显示如下：
- en: '![](img/a7a2ac1a-75f3-4e97-9c80-acdc3626c287.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7a2ac1a-75f3-4e97-9c80-acdc3626c287.png)'
- en: Two instances of `Microservice A` are now registered with `Eureka Server`. Similar
    updates can be done on `Config Server` in order to connect it to `Eureka Server`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有两个“微服务A”的实例已经注册到“Eureka Server”中。类似的更新也可以在“Config Server”上进行，以便将其连接到“Eureka
    Server”。
- en: In the next step, we would want to connect the service consumer microservice
    to pick up URLs of instances of Microservice A from the Eureka server.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们希望连接服务消费者微服务，以从Eureka服务器中获取“微服务A”的实例的URL。
- en: Connecting the service consumer microservice with Eureka
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将服务消费者微服务连接到Eureka
- en: 'The Eureka starter project needs to be added as a dependency in the `pom.xml`
    file of the service consumer microservice:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 需要将Eureka starter项目添加为服务消费者微服务的`pom.xml`文件中的依赖项：
- en: '[PRE57]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Currently, the URLs of the different instances of `Microservice A` are hardcoded
    in the service consumer microservice, as shown here, in `application.properties`:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，“微服务A”的不同实例的URL在服务消费者微服务中是硬编码的，如下所示，在`application.properties`中：
- en: '[PRE58]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'However, now we would not want to hardcode Microservice A URLs. We would want
    the service consumer microservice to get the URLs from `Eureka Server`. We do
    that by configuring the URL of `Eureka Server` in the `application.properties`
    of the service consumer microservice. We will comment out the hardcoding of the
    Microservice A URLs:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在我们不想硬编码微服务A的URL。我们希望服务消费者微服务从`Eureka Server`获取URL。我们通过在服务消费者微服务的`application.properties`中配置`Eureka
    Server`的URL来实现这一点。我们将注释掉对微服务A URL的硬编码：
- en: '[PRE59]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Next, we will add `EnableDiscoveryClient` on the `ServiceConsumerApplication`
    class, as shown here:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在`ServiceConsumerApplication`类上添加`EnableDiscoveryClient`，如下所示：
- en: '[PRE60]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Once the service consumer microservice is restarted, you will see that it will
    register itself with `Eureka Server`. The following is an extract from the log
    of `Eureka Server`:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务消费者微服务重新启动，您将看到它会在`Eureka Server`中注册自己。以下是从`Eureka Server`日志中提取的内容：
- en: '[PRE61]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In `RandomServiceProxy`, we have already configured a name for `microservice-a`
    on the Feign client, as shown here:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RandomServiceProxy`中，我们已经在Feign客户端上为`microservice-a`配置了一个名称，如下所示：
- en: '[PRE62]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The service consumer microservice will use this ID (Microservice A) to query
    `Eureka Server` for instances. Once it gets the URLs from `Eureka Service`, it
    will invoke the service instance selected by Ribbon.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 服务消费者微服务将使用此ID（微服务A）查询`Eureka Server`以获取实例。一旦从`Eureka Service`获取URL，它将调用Ribbon选择的服务实例。
- en: When the `add` service is invoked at `http://localhost:8100/add`, it returns
    an appropriate response.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 当在`http://localhost:8100/add`调用`add`服务时，它会返回适当的响应。
- en: 'Here''s a quick review of the different steps involved:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是涉及的不同步骤的快速回顾：
- en: As each instance of Microservice A starts up, it registers with `Eureka Name
    Server`.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个微服务A实例启动时，都会向`Eureka Name Server`注册。
- en: The service consumer microservice requests `Eureka Name Server` for instances
    of Microservice A.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务消费者微服务请求`Eureka Name Server`获取微服务A的实例。
- en: The service consumer microservice uses the Ribbon client-side load balancer
    to decide the specific instance of Microservice A to call.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务消费者微服务使用Ribbon客户端负载均衡器来决定调用微服务A的特定实例。
- en: The service consumer microservice calls a specific instance of Microservice
    A.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务消费者微服务调用特定实例的微服务A。
- en: The biggest advantage of `Eureka Service` is that service consumer microservice
    is now decoupled from Microservice A. Whenever new instances of Microservice A
    come up or an existing instance goes down, the service consumer microservice does
    not need to be reconfigured.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`Eureka Service`的最大优势是服务消费者微服务现在与微服务A解耦。每当新的微服务A实例启动或现有实例关闭时，服务消费者微服务无需重新配置。'
- en: API Gateways
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API网关
- en: 'Microservices have a number of cross-cutting concerns:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务有许多横切关注点：
- en: '**Authentication, authorization, and security**: How do we ensure that the
    microservice consumers are who they claim to be? How do we ensure that the consumers
    have the right access to microservices?'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证、授权和安全**：我们如何确保微服务消费者是他们声称的人？我们如何确保消费者对微服务有正确的访问权限？'
- en: '**Rate limits** : There might be different kinds of API plans for consumers
    and different limits (the number of microservice invocations) for each plan. How
    do we enforce the limits on a specific consumer?'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速率限制**：消费者可能有不同类型的API计划，每个计划的限制（微服务调用次数）也可能不同。我们如何对特定消费者强制执行限制？'
- en: '**Dynamic routing**: Specific situations (for example, a microservice is down)
    might need dynamic routing.'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态路由**：特定情况（例如，一个微服务宕机）可能需要动态路由。'
- en: '**Service aggregation**: The UI needs for a mobile are different from the desktop.
    Some microservice architectures have service aggregators tailored for a specific
    device.'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务聚合**：移动设备的UI需求与桌面设备不同。一些微服务架构具有针对特定设备定制的服务聚合器。'
- en: '**Fault tolerance**: How do we ensure that failure in one microservice does
    not cause the entire system to crash?'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容错性**：我们如何确保一个微服务的失败不会导致整个系统崩溃？'
- en: When microservices talk directly with each other, these concerns have to be
    addressed by individual microservices. This kind of architecture might be difficult
    to maintain because each microservice might handle these concerns differently.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 当微服务直接相互通信时，这些问题必须由各个微服务单独解决。这种架构可能难以维护，因为每个微服务可能以不同的方式处理这些问题。
- en: 'One of the most common solutions is to use an API Gateway. All service calls
    to and between microservices should go through an API Gateway. API Gateway typically
    provide these features for microservices:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的解决方案之一是使用API网关。所有对微服务的服务调用都应该通过API网关进行。API网关通常为微服务提供以下功能：
- en: Authentication and security
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证和安全
- en: Rate limiting
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速率限制
- en: Insights and monitoring
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 洞察和监控
- en: Dynamic routing and static response handling
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态路由和静态响应处理
- en: Load shedding
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载限制
- en: Aggregation of responses from multiple services
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合多个服务的响应
- en: Implementing client-side load balancing with Zuul
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Zuul实现客户端负载平衡
- en: Zuul is part of the Spring Cloud Netflix project. It is an API Gateway service
    that provides the capabilities of dynamic routing, monitoring, filtering, security,
    and more.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: Zuul是Spring Cloud Netflix项目的一部分。它是一个API网关服务，提供动态路由、监控、过滤、安全等功能。
- en: 'Implementing Zuul as an API Gateway involves the following:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 实现Zuul作为API网关涉及以下内容：
- en: Setting up a new Zuul API Gateway Server.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置新的Zuul API网关服务器。
- en: Configuring Service Consumer to use Zuul API Gateway.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置服务消费者以使用Zuul API网关。
- en: Setting up a new Zuul API Gateway Server
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置新的Zuul API网关服务器
- en: 'We will use Spring Initializr ([http://start.spring.io](http://start.spring.io))
    to set up a new project for Zuul API Gateway. The following screenshot shows the
    GroupId, ArtifactId, and Dependencies to be selected:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Spring Initializr（[http://start.spring.io](http://start.spring.io)）为Zuul
    API网关设置一个新项目。以下屏幕截图显示了要选择的GroupId、ArtifactId和Dependencies：
- en: '![](img/1245756e-84eb-45bb-968b-6f3f1a365335.png)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1245756e-84eb-45bb-968b-6f3f1a365335.png)'
- en: 'The next step is to enable Zuul proxy on the Spring Boot application. This
    is done by adding the `@EnableZuulProxy` annotation on the `ZuulApiGatewayServerApplication`
    class. The following snippet shows the details:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在Spring Boot应用程序上启用Zuul代理。这是通过在`ZuulApiGatewayServerApplication`类上添加`@EnableZuulProxy`注解来完成的。以下代码片段显示了详细信息：
- en: '[PRE63]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We will run Zuul Proxy on port `8765`. The following snippet shows the configuration
    needed in `application.properties`:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在端口`8765`上运行Zuul代理。以下代码片段显示了`application.properties`中所需的配置：
- en: '[PRE64]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We are configuring the port for Zuul proxy and connecting it to the Eureka Name
    server as well.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在配置Zuul代理的端口，并将其连接到Eureka Name服务器。
- en: Zuul custom filters
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Zuul自定义过滤器
- en: 'Zuul provides options to create custom filters to implement typical API Gateway
    functionality, such as authentication, security, and tracing. In this example,
    we will create a simple logging filter to log every request. The following snippet
    shows the details:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: Zuul提供了创建自定义过滤器以实现典型API网关功能（如身份验证、安全性和跟踪）的选项。在本例中，我们将创建一个简单的日志记录过滤器来记录每个请求。以下代码片段显示了详细信息：
- en: '[PRE65]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'A few important things to note are as follows:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一些重要事项如下：
- en: '`SimpleLoggingFilter extends ZuulFilter`: `ZuulFilter` is the base abstract
    class to create filters for Zuul. Any filter should implement the four methods
    listed here.'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SimpleLoggingFilter extends ZuulFilter`: `ZuulFilter`是创建Zuul过滤器的基本抽象类。任何过滤器都应实现此处列出的四种方法。'
- en: '`public String filterType()`: Possible return values are `"pre"` for prerouting
    filtering, `"route"` for routing to an origin, `"post"` for postrouting filters,
    and `"error"` for error handling. In this example, we would want to filter before
    the request is executed. We return a value `"pre"`.'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public String filterType()`: 可能的返回值是`"pre"`表示预路由过滤，`"route"`表示路由到原始位置，`"post"`表示后路由过滤，`"error"`表示错误处理。在本例中，我们希望在执行请求之前进行过滤。我们返回值`"pre"`。'
- en: '`public int filterOrder()`: Defines the precedence for a filter.'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public int filterOrder()`: 定义过滤器的优先级。'
- en: '`public boolean shouldFilter()`: If the filter should only be executed in certain
    conditions, the logic can be implemented here. If you would want the filter to
    always be executed, return `true`.'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public boolean shouldFilter()`: 如果过滤器只应在某些条件下执行，可以在此处实现逻辑。如果要求过滤器始终执行，则返回`true`。'
- en: '`public Object run()`: The method to implement the logic for the filter. In
    our example, we are logging the request method and the URL of the request.'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public Object run()`: 实现过滤器逻辑的方法。在我们的示例中，我们正在记录请求方法和请求的URL。'
- en: 'When we start up the Zuul server by launching `ZuulApiGatewayServerApplication`
    as a Java application, you will see the following log in `Eureka Name Server`:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过启动`ZuulApiGatewayServerApplication`作为Java应用程序来启动Zuul服务器时，您将在`Eureka Name
    Server`中看到以下日志：
- en: '[PRE66]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This shows that `Zuul API gateway` is up and running. `Zuul API gateway` is
    also registered with `Eureka Server`. This allows microservice consumers to talk
    to the Name server to get details about `Zuul API gateway`.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明`Zuul API网关`正在运行。`Zuul API网关`也已注册到`Eureka Server`。这允许微服务消费者与名称服务器通信，以获取有关`Zuul
    API网关`的详细信息。
- en: 'The following figure shows the Eureka dashboard at `http://localhost:8761`.
    You can see that instances of `Microservice A`, `service consumer`, and `Zuul
    API Gateway` are now registered with `Eureka Server`:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了`http://localhost:8761`上的Eureka仪表板。您可以看到`Microservice A`、`service consumer`和`Zuul
    API Gateway`的实例现在已注册到`Eureka Server`：
- en: '![](img/f0c5df38-8927-4286-8d5a-1ee980808a23.png)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f0c5df38-8927-4286-8d5a-1ee980808a23.png)'
- en: 'The following is an extract from the `Zuul API gateway` log:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从`Zuul API网关`日志中提取的内容：
- en: '[PRE67]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: By default, all services in Microservice A and the service consumer microservice
    are enabled for reverse proxying by Zuul.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Zuul会为Microservice A中的所有服务和服务消费者微服务启用反向代理。
- en: Invoking microservices through Zuul
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过Zuul调用微服务
- en: Let's invoke `random service` through the service proxy now. The direct URL
    to a random microservice is `http://localhost:8080/random`. This is exposed by
    Microservice A, whose application name is `microservice-a`.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过服务代理调用`random service`。随机微服务的直接URL是`http://localhost:8080/random`。这是由应用程序名称为`microservice-a`的Microservice
    A公开的。
- en: 'The URL structure to call a service through `Zuul API Gateway` is `http://localhost:{port}/{microservice-application-name}/{service-uri}`.
    So, the `Zuul API Gateway` URL for `random service` is `http://localhost:8765/microservice-a/random`.
    When you invoke `random service` through API Gateway, you get a response shown
    here. The response is similar to what you would typically get when directly calling
    the random service:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`Zuul API Gateway`调用服务的URL结构是`http://localhost:{port}/{microservice-application-name}/{service-uri}`。因此，`random
    service`的`Zuul API Gateway` URL是`http://localhost:8765/microservice-a/random`。当您通过API
    Gateway调用`random service`时，您会得到下面显示的响应。响应类似于直接调用random service时通常会得到的响应：
- en: '[PRE68]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The following is an extract from the `Zuul Api Gateway` log. You can see that
    the `SimpleLoggingFilter` that we created in `Zuul API Gateway` is executed for
    the request:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从`Zuul Api Gateway`日志中提取的内容。您可以看到我们在`Zuul API Gateway`中创建的`SimpleLoggingFilter`已被执行：
- en: '[PRE69]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The `add` service is exposed by service consumer, whose application name is
    service-consumer and the service URI is `/add`. So, the URL to execute the `add`
    service through the API Gateway is `http://localhost:8765/service-consumer/add`.
    The response from the service is shown here. The response is similar to what you
    would typically get when directly calling the `add` service:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`服务由服务消费者公开，其应用程序名称为service-consumer，服务URI为`/add`。因此，通过API Gateway执行`add`服务的URL是`http://localhost:8765/service-consumer/add`。来自服务的响应如下所示。响应类似于直接调用`add`服务时通常会得到的响应：'
- en: '[PRE70]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The following is an extract from the `Zuul API Gateway` log. You can see that
    the initial `add` service call is going through the API Gateway:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从`Zuul API Gateway`日志中提取的内容。您可以看到初始的`add`服务调用是通过API网关进行的：
- en: '[PRE71]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `add` service calls `random service` on `Microservice A`. While the initial
    call to add service goes through the API Gateway, the call from add service (service
    consumer microservice) to `random service` (Microservice A) is not routed through
    API Gateway. In an ideal world, we would want all the communication to take place
    through API Gateway.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`服务调用`Microservice A`上的`random service`。虽然对add服务的初始调用通过API网关进行，但从add服务（服务消费者微服务）到`random
    service`（Microservice A）的调用并未通过API网关路由。在理想情况下，我们希望所有通信都通过API网关进行。'
- en: In the next step, let's make the requests from the service consumer microservice
    go through the API Gateway as well.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，让我们也让服务消费者微服务的请求通过API网关进行。
- en: Configuring service consumer to use Zuul API gateway
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置服务消费者以使用Zuul API网关
- en: 'The following code shows the existing configuration of `RandomServiceProxy`,
    which is used to call `random service` on `Microservice A`. The name attribute
    in the `@FeignClient` annotation is configured to use the application name of
    Microservice A. The request mapping uses the `/random` URI:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了`RandomServiceProxy`的现有配置，用于调用`Microservice A`上的`random service`。`@FeignClient`注解中的name属性配置为使用Microservice
    A的应用名称。请求映射使用了`/random` URI：
- en: '[PRE72]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now, we want the call to go through the API Gateway. We would need to use the
    application name of the API Gateway and the new URI of `random service` in the
    request mapping. The following snippet shows the updated `RandomServiceProxy`
    class:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望调用通过API网关进行。我们需要使用API网关的应用名称和`random service`的新URI在请求映射中。以下片段显示了更新的`RandomServiceProxy`类：
- en: '[PRE73]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'When we invoke the add service at `http://localhost:8765/service-consumer/add`,
    we will see the typical response:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`http://localhost:8765/service-consumer/add`调用add服务时，我们将看到典型的响应：
- en: '[PRE74]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'However, now we will see more things happen on `Zuul API gateway`. The following
    is an extract from the `Zuul API gateway` log. You can see that the initial add
    service call on the service consumer, as well as the `random service` call on
    `Microservice A`, are now being routed through the API Gateway:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在我们将在`Zuul API网关`上看到更多的事情发生。以下是从`Zuul API网关`日志中提取的内容。您可以看到服务消费者上的初始add服务调用，以及对Microservice
    A上的`random service`的调用，现在都通过API网关进行路由：
- en: '[PRE75]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We saw a basic implementation of a simple logging filter on `Zuul API Gateway`.
    A similar approach can be used to implement filters for other cross-cutting concerns.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了在`Zuul API Gateway`上实现简单日志过滤器的基本实现。类似的方法可以用于实现其他横切关注点的过滤器。
- en: Distributed tracing
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式跟踪
- en: 'In typical microservice architectures, there are a number of components involved.
    A few of them are listed here:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的微服务架构中，涉及许多组件。以下是其中一些：
- en: Different microservices
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的微服务
- en: API Gateway
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API网关
- en: Naming server
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名服务器
- en: Configuration server
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置服务器
- en: 'A typical call may involve more than four or five components. These are the
    important questions to ask:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的调用可能涉及四五个以上的组件。这些是需要问的重要问题：
- en: How can we debug issues?
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何调试问题？
- en: How can we find out the root cause of a specific problem?
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何找出特定问题的根本原因？
- en: A typical solution is centralized logging with a dashboard. Have all microservice
    logs consolidated in one place and offer a dashboard on top of it.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的解决方案是具有仪表板的集中式日志记录。将所有微服务日志汇总到一个地方，并在其上提供仪表板。
- en: Distributed tracing options
  id: totrans-445
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式跟踪选项
- en: 'The following screenshot shows the options for distributed tracing on the Spring
    Initializr website:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了Spring Initializr网站上分布式跟踪的选项：
- en: '![](img/f0c33890-b5cd-4c97-8ced-c4743479d3d1.png)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f0c33890-b5cd-4c97-8ced-c4743479d3d1.png)'
- en: In this example, we will use a combination of Spring Cloud Sleuth and Zipkin
    Server to implement Distributed Tracing.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用Spring Cloud Sleuth和Zipkin Server的组合来实现分布式跟踪。
- en: Implementing Spring Cloud Sleuth and Zipkin
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Spring Cloud Sleuth和Zipkin
- en: '**Spring Cloud Sleuth** provides features to uniquely trace a service call
    across different microservice components. **Zipkin** is a distributed tracing
    system that''s used to gather data needed to troubleshoot latency issues in microservices.
    We will be implementing a combination of Spring Cloud Sleuth and Zipkin to implement
    Distributed Tracing.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring Cloud Sleuth**提供了在不同微服务组件之间唯一跟踪服务调用的功能。**Zipkin**是一个分布式跟踪系统，用于收集微服务中需要用于排除延迟问题的数据。我们将实现Spring
    Cloud Sleuth和Zipkin的组合来实现分布式跟踪。'
- en: 'The following are the steps involved:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及的步骤如下：
- en: Integrate Microservice A, API Gateway, and the service consumer with Spring
    Cloud Sleuth.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Microservice A、API网关和服务消费者与Spring Cloud Sleuth集成。
- en: Set up Zipkin Distributed Tracing Server.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置Zipkin分布式跟踪服务器。
- en: Integrate Microservice A, API Gateway, and the service consumer with Zipkin.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Microservice A、API网关和服务消费者与Zipkin集成。
- en: Integrating microservice components with Spring Cloud Sleuth
  id: totrans-455
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将微服务组件与Spring Cloud Sleuth集成
- en: When we call the add service on the service consumer, it will invoke Microservice
    A through API Gateway. To be able to track the service call across different components,
    we would need something unique assigned to the request flow across components.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在服务消费者上调用add服务时，它将通过API网关调用Microservice A。为了能够跟踪服务调用跨不同组件，我们需要为请求流程分配一个唯一的东西。
- en: Spring Cloud Sleuth provides options to track a service call across different
    components using a concept called **span**. Each span has a unique 64-bit ID.
    The unique ID can be used to trace the call across components.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Sleuth提供了跟踪服务调用跨不同组件的选项，使用了一个称为**span**的概念。每个span都有一个唯一的64位ID。唯一ID可用于跟踪调用跨组件的情况。
- en: 'The following snippet shows the dependency for `spring-cloud-starter-sleuth`:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段显示了`spring-cloud-starter-sleuth`的依赖项：
- en: '[PRE76]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We need to add the preceding dependency on Spring Cloud Sleuth to the following
    three projects listed:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在以下列出的三个项目中添加Spring Cloud Sleuth的前置依赖：
- en: Microservice A
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microservice A
- en: Service consumer
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务消费者
- en: Zuul API Gateway Server
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zuul API 网关服务器
- en: 'We will start with tracing all the service requests across microservices. To
    be able to trace all the requests, we will need to configure an `AlwaysSampler`
    bean, as shown in the following snippet:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从跟踪所有微服务之间的服务请求开始。为了能够跟踪所有请求，我们需要配置一个`AlwaysSampler` bean，如下面的代码片段所示：
- en: '[PRE77]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The `AlwaysSampler` bean needs to be configured in the following microservice
    application classes:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '`AlwaysSampler` bean 需要在以下微服务应用程序类中进行配置：'
- en: '`MicroserviceAApplication`'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MicroserviceAApplication`'
- en: '`ServiceConsumerApplication`'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServiceConsumerApplication`'
- en: '`ZuulApiGatewayServerApplication`'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZuulApiGatewayServerApplication`'
- en: 'When we invoke the `add` service at `http://localhost:8765/service-consumer/add`,
    we will see the typical response:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`http://localhost:8765/service-consumer/add`调用`add`服务时，我们将看到典型的响应：
- en: '[PRE78]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'However, you will start to see a few more details in the log entries. A simple
    entry from the service consumer microservice log is shown here:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您将开始在日志条目中看到更多细节。这里显示了来自服务消费者微服务日志的简单条目：
- en: '[PRE79]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '`[service-consumer,d8866b38c3a4d69c,d8866b38c3a4d69c,true]`: The first value
    `service-consumer` is the application name. The key part is the second value--`d8866b38c3a4d69c`.
    This is the value that can be used to trace this request across other microservice
    components.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '`[service-consumer,d8866b38c3a4d69c,d8866b38c3a4d69c,true]`：第一个值`service-consumer`是应用程序名称。关键部分是第二个值--`d8866b38c3a4d69c`。这是可以用来跟踪此请求在其他微服务组件中的值。'
- en: 'The following are some other entries from the `service consumer` log:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`service consumer`日志中的一些其他条目：
- en: '[PRE80]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The following is an extract from the `Microservice A` log:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Microservice A`日志的摘录：
- en: '[PRE81]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The following is an extract from the `Zuul API Gateway` log:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Zuul API Gateway`日志的摘录：
- en: '[PRE82]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: As you can see in the preceding log extracts, we can use the second value in
    the log--called span ID--to trace the service call across microservice components.
    In this example, the span ID is `d8866b38c3a4d69c`.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的日志摘录中所看到的，我们可以使用日志中的第二个值--称为span ID--来跟踪跨微服务组件的服务调用。在本例中，span ID 是`d8866b38c3a4d69c`。
- en: However, this requires searching through logs of all the microservice components.
    One option is to implement a centralized log using something like an **ELK** (**Elasticsearch**,
    **Logstash**, and **Kibana**) stack. We will take the simpler option of creating
    a Zipkin Distributed Tracing service in the next step.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这需要搜索所有微服务组件的日志。一种选择是使用类似**ELK**（**Elasticsearch**，**Logstash**和**Kibana**）堆栈实现集中式日志。我们将采用更简单的选择，在下一步中创建一个Zipkin分布式跟踪服务。
- en: Setting up Zipkin Distributed Tracing Server
  id: totrans-483
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Zipkin分布式跟踪服务器
- en: 'We will use Spring Initializr ([http://start.spring.io](http://start.spring.io))
    to set up a new project. The following screenshot shows the GroupId, ArtifactId,
    and Dependencies to be selected:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Spring Initializr ([http://start.spring.io](http://start.spring.io))来设置一个新项目。以下截图显示了要选择的
    GroupId、ArtifactId 和 Dependencies：
- en: '![](img/5b420b0f-5cb4-428f-a65a-e10742c7db39.png)'
  id: totrans-485
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b420b0f-5cb4-428f-a65a-e10742c7db39.png)'
- en: 'Dependencies include the following:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项包括以下内容：
- en: '**Zipkin Stream**: Multiple options exist to configure a Zipkin server. In
    this example, we will keep it simple by creating a standalone service listening
    on events and storing information in the memory.'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Zipkin Stream**：存在多种选项来配置Zipkin服务器。在本例中，我们将通过创建一个独立的服务监听事件并将信息存储在内存中来保持简单。'
- en: '**Zipkin UI**: Provides a dashboard with the search functionality.'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Zipkin UI**：提供带有搜索功能的仪表板。'
- en: '**Stream Rabbit**: Used to bind the Zipkin stream with a RabbitMQ service.'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Stream Rabbit**：用于将Zipkin流与RabbitMQ服务绑定。'
- en: In production, you would want to have a more robust infrastructure. One option
    is to connect a permanent data store to the Zipkin Stream Server.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，您可能希望拥有更健壮的基础设施。一种选择是将永久数据存储连接到Zipkin Stream 服务器。
- en: 'Next, we will add the `@EnableZipkinServer` annotation to the `ZipkinDistributedTracingServerApplication`
    class to enable auto-configuration for the Zipkin server. The following snippet
    shows the details:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在`ZipkinDistributedTracingServerApplication`类中添加`@EnableZipkinServer`注解，以启用Zipkin服务器的自动配置。以下代码片段显示了详细信息：
- en: '[PRE83]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We will use port `9411` to run the tracing server. The following snippet shows
    the configuration that needs to be added in the `application.properties` file:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用端口`9411`来运行跟踪服务器。以下代码片段显示了需要添加到`application.properties`文件中的配置：
- en: '[PRE84]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'You can launch the Zipkin UI dashboard at `http://localhost:9411/`. The following
    is a screenshot of that. There is no data shown, as none of the microservices
    are connected to Zipkin yet:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`http://localhost:9411/`上启动Zipkin UI 仪表板。以下是该仪表板的截图。由于没有任何微服务连接到Zipkin，因此没有显示任何数据：
- en: '![](img/4233d9fb-0328-42ed-80aa-6511bdf7ba01.png)'
  id: totrans-496
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4233d9fb-0328-42ed-80aa-6511bdf7ba01.png)'
- en: Integrating microservice components with Zipkin
  id: totrans-497
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将微服务组件与Zipkin集成
- en: 'We will need to connect all the microservice components that we want to trace
    with `Zipkin server`. Here is the list of components we will start with:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要连接我们想要跟踪的所有微服务组件与`Zipkin服务器`。以下是我们将开始的组件列表：
- en: Microservice A
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microservice A
- en: Service consumer
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务消费者
- en: Zuul API Gateway Server
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zuul API 网关服务器
- en: 'All we need to do is add dependencies on `spring-cloud-sleuth-zipkin` and `spring-cloud-starter-bus-amqp`
    to the `pom.xml` file of the preceding projects:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要在前述项目的`pom.xml`文件中添加对`spring-cloud-sleuth-zipkin`和`spring-cloud-starter-bus-amqp`的依赖：
- en: '[PRE85]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Go ahead and execute the `add` service at `http://localhost:8100/add`. You
    can now see the details on the Zipkin dashboard. The following screenshot shows
    some of the details:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 继续执行`http://localhost:8100/add`上的`add`服务。现在您可以在Zipkin仪表板上看到详细信息。以下截图显示了一些详细信息：
- en: '![](img/1d8762f1-b0e0-480f-b201-64c3f10e556f.png)'
  id: totrans-505
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1d8762f1-b0e0-480f-b201-64c3f10e556f.png)'
- en: 'The first two rows show the failed requests. The third row shows the details
    of a successful request. We can further dig in by clicking on the successful row.
    The following screenshot shows the details displayed:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行显示了失败的请求。第三行显示了成功请求的详细信息。我们可以通过点击成功的行来进一步挖掘。以下截图显示了显示的详细信息：
- en: '![](img/252a0775-6164-4905-8a47-8dc2daafedd8.png)'
  id: totrans-507
  prefs: []
  type: TYPE_IMG
  zh: '![](img/252a0775-6164-4905-8a47-8dc2daafedd8.png)'
- en: 'pent on each service. You can further dig in by clicking on the service bar.
    The following screenshot shows the details displayed:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个服务上都有一个花费的时间。您可以通过点击服务栏进一步了解。以下截图显示了显示的详细信息：
- en: '![](img/98dae146-dfd7-48ad-b66d-9dc7a5a59e16.png)'
  id: totrans-509
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98dae146-dfd7-48ad-b66d-9dc7a5a59e16.png)'
- en: In this section, we added distributed tracing for our microservices. We will
    now be able to visually track everything that is happening with our microservices.
    This will make it easy to track down and debug issues.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们为我们的微服务添加了分布式跟踪。现在我们将能够直观地跟踪我们的微服务中发生的一切。这将使得追踪和调试问题变得容易。
- en: Hystrix - fault tolerance
  id: totrans-511
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hystrix - 容错
- en: Microservice architectures are built with a number of microservice components.
    What if one microservice goes down? Would all dependent microservices fail and
    make the entire system collapse? Or would the error be gracefully handled and
    a degraded minimum functionality provided to the user? These questions decide
    the success of microservice architectures.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构是由许多微服务组件构建的。如果一个微服务出现故障会怎么样？所有依赖的微服务都会失败并使整个系统崩溃吗？还是错误会被优雅地处理，并为用户提供降级的最小功能？这些问题决定了微服务架构的成功。
- en: Microservice architectures should be resilient and be able to handle service
    errors gracefully. Hystrix provides fault-tolerant capabilities to microservices.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构应该是有弹性的，并且能够优雅地处理服务错误。Hystrix为微服务提供了容错能力。
- en: Implementation
  id: totrans-514
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: We will add Hystrix to our service consumer microservice and enhance the add
    service to return a basic response even when Microservice A is down.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在服务消费者微服务中添加Hystrix，并增强add服务，即使Microservice A宕机也能返回基本响应。
- en: 'We will start with adding Hystrix Starter to the `pom.xml` file of service
    consumer microservice. The following snippet shows the dependency details:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从向服务消费者微服务的`pom.xml`文件中添加Hystrix Starter开始。以下代码片段显示了依赖项的详细信息：
- en: '[PRE86]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Next, we would enable Hystrix auto-configuration by adding the `@EnableHystrix`
    annotation to the `ServiceConsumerApplication` class. The following snippet shows
    the details:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过向`ServiceConsumerApplication`类添加`@EnableHystrix`注解来启用Hystrix自动配置。以下代码片段显示了详细信息：
- en: '[PRE87]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '`NumberAdderController` exposes a service with request mapping `/add`. This
    uses `RandomServiceProxy` to fetch random numbers. What if this service fails?
    Hystrix provides a fallback. The following snippet shows how we can add a fallback
    method to a request mapping. All we need to do is add the `@HystrixCommand` annotation
    to the `fallbackMethod` attribute, defining the name of the fallback method--in
    this example, `getDefaultResponse`:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '`NumberAdderController`公开了一个请求映射为`/add`的服务。这使用`RandomServiceProxy`来获取随机数。如果这个服务失败了怎么办？Hystrix提供了一个回退。以下代码片段显示了如何向请求映射添加一个回退方法。我们只需要向`@HystrixCommand`注解添加`fallbackMethod`属性，定义回退方法的名称--在这个例子中是`getDefaultResponse`：'
- en: '[PRE88]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Next, we define the `getDefaultResponse()` method with the same return type
    as the `add()` method. It returns a default hardcoded value:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了`getDefaultResponse()`方法，其返回类型与`add()`方法相同。它返回一个默认的硬编码值：
- en: '[PRE89]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Let''s bring down Microservice A and invoke `http://localhost:8100/add`. You
    will get the following response:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关闭微服务A并调用`http://localhost:8100/add`。您将得到以下响应：
- en: '[PRE90]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: When `Microservice A` fails, the service consumer microservice handles it gracefully
    and offers reduced functionality.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Microservice A`失败时，服务消费者微服务会优雅地处理它并提供降级功能。
- en: Summary
  id: totrans-527
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Spring Cloud makes it easy to add Cloud-Native features to your microservices.
    In this chapter, we looked at some of the important patterns in developing Cloud-Native
    applications and implemented them using various Spring Cloud projects.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud使得向微服务添加云原生功能变得容易。在本章中，我们看了一些开发云原生应用程序中的重要模式，并使用各种Spring Cloud项目来实现它们。
- en: It is important to remember that the field of developing Cloud-Native applications
    is still in its inception phase--in its first few years. It would need more time
    to mature. Expect some evolution in patterns and frameworks in the years to come.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，开发云原生应用程序的领域仍处于起步阶段--在最初的几年。它需要更多的时间来成熟。预计未来几年模式和框架会有一些演变。
- en: In the next chapter, we will shift our attention to Spring Data Flow. Typical
    use cases on the cloud include real-time data analytics and data pipelines. These
    use cases involve the flow of data between multiple microservices. Spring Data
    Flow provides patterns and best practices for distributed streaming and data pipelines.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把注意力转向Spring Data Flow。云上的典型用例包括实时数据分析和数据管道。这些用例涉及多个微服务之间的数据流动。Spring
    Data Flow提供了分布式流和数据管道的模式和最佳实践。
