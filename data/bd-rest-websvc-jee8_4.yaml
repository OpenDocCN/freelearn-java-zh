- en: Building Asynchronous Web Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建异步Web服务
- en: In this chapter, we'll talk about the motivations and reasons for asynchronous
    processing. Then, we'll see the basic implementation of asynchronous web services
    with JAX-RS. Then, we will have a look at improving our implementation using `ManagedExecutorService`
    and server-side callbacks. Finally, we will use the asynchronous JAX-RS API client
    to make REST calls, and explore the benefits and usage scenarios of asynchronous
    processing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论异步处理的动机和原因。然后，我们将看到使用JAX-RS的基本异步Web服务实现。然后，我们将探讨使用`ManagedExecutorService`和服务器端回调来改进我们的实现。最后，我们将使用异步JAX-RS
    API客户端进行REST调用，并探讨异步处理的好处和用例。
- en: 'This chapter includes the following sections:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下部分：
- en: Benefits and usage scenarios of asynchronous processing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步处理的好处和用例
- en: Implementing asynchronous web services
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现异步Web服务
- en: Using ManagedExecutorService and server-side callbacks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ManagedExecutorService`和服务器端回调
- en: Implementing asynchronous web service clients
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现异步Web服务客户端
- en: Benefits and usage scenarios of asynchronous processing
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步处理的好处和用例
- en: In this section, we're going to take a look at the motivations and reasons for
    asynchronous request processing and why this matters to you. One thing I need
    to tell you is that *the free lunch is over! concurrency counts*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨异步请求处理的动机和原因以及为什么这对您很重要。我需要告诉您的是，*免费午餐结束了！并发很重要*。
- en: 'Let''s take a look at the following diagram:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下图表：
- en: '![](img/a1e8bd82-c2a7-4114-a74c-22c12256f700.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a1e8bd82-c2a7-4114-a74c-22c12256f700.png)'
- en: We can see that the number of transistors on a processor is constantly rising;
    however, the clock speed pretty much stayed constant since 2004. This means you
    need to be more concurrent in order to get more speed, and we usually do this
    by using threads.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到处理器上的晶体管数量一直在增加；然而，自2004年以来，时钟速度基本上保持不变。这意味着您需要更并发才能获得更多速度，我们通常通过使用线程来实现这一点。
- en: By default, the request processing on the server usually works in a synchronous
    mode, which means that each request is processed in a single HTTP thread. This
    is what we are used to; we had one thread and we performed request responses in
    it. Unfortunately, threads are very expensive, so under a high load with a lot
    of concurrent connections, there is a lot of wasted resources and the server does
    not scale that well. Fortunately, we have asynchronous processing options.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，服务器上的请求处理通常以同步模式工作，这意味着每个请求都在单个HTTP线程中处理。这是我们习惯的；我们有一个线程，并在其中执行请求响应。不幸的是，线程非常昂贵，所以在高负载和大量并发连接的情况下，有很多浪费的资源，服务器扩展得并不好。幸运的是，我们有异步处理选项。
- en: Basic idea
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本思想
- en: The basic idea of asynchronous processing is to separate our request I/O threads
    and the request processing threads by using different thread pools. This basically
    frees up our I/O threads to receive new connections while we do the processing
    on different threads.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 异步处理的基本思想是使用不同的线程池来分离我们的请求I/O线程和请求处理线程。这基本上让我们的I/O线程在处理不同线程上的处理时接收新的连接。
- en: Goal
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目标
- en: The ultimate goal is to save memory and improve the performance of our applications
    by using or reducing context-switching, and we can also improve the throughput
    by basically separating the request I/O from the request-processing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最终目标是通过对或减少上下文切换的使用来节省内存并提高我们应用程序的性能，我们还可以通过基本上将请求I/O与请求处理分离来提高吞吐量。
- en: These are the main motivations and reasons. In the next section, we will talk
    about implementing asynchronous web services.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是主要动机和原因。在下一节中，我们将讨论实现异步Web服务。
- en: Implementing asynchronous web services
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现异步Web服务
- en: In this section, we're going to take a look at implementing asynchronous REST
    resources. We'll see the basic usage of the `@Suspended` annotation and the `AsyncResponse`
    class. We'll have a look at processing and resuming on an `AsyncResponse` instance
    in a different thread, and we will also talk about the basic timeout-handling
    for asynchronous responses.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨实现异步REST资源。我们将看到`@Suspended`注解和`AsyncResponse`类的基本用法。我们将查看在另一个线程中处理和恢复`AsyncResponse`实例，并且我们还将讨论异步响应的基本超时处理。
- en: 'Let''s get started and switch to code. As usual, we prepare a few templates
    for us to get started. First up, I want to show you the basic structure of an
    asynchronous resource—have a look at the signature. All you need to do is implement
    a `public void` method that has at least one parameter that uses the `@Suspended`
    annotation. As a type, it uses the `AsyncResponse` class that''s provided by the
    JAX-RS API:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始并切换到代码。像往常一样，我们准备了一些模板以开始。首先，我想向你展示异步资源的基本结构——看看签名。你所需要做的就是实现一个至少有一个参数使用`@Suspended`注解的`public
    void`方法。作为类型，它使用由JAX-RS API提供的`AsyncResponse`类：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's start with the implementation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实现开始。
- en: 'We want to do some heavy processing in a separate thread. First up, we''ll
    start a new thread and do the calculation within the thread. To simulate some
    heavy processing, we''ll have it sleep for three seconds, then we''ll produce
    some output. To do that, we return the request thread (`requestThreadName`). We
    also need the name of the current thread, and we get that using `getCurrentThreadName`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在单独的线程中做一些重量级的处理。首先，我们将启动一个新线程，并在该线程中进行计算。为了模拟一些重量级的处理，我们将让它休眠三秒钟，然后产生一些输出。为此，我们返回请求线程（`requestThreadName`）。我们还需要当前线程的名称，我们使用`getCurrentThreadName`来获取它：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, we construct a `response` from `requestThread` and `responseThread`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们从`requestThread`和`responseThread`构建一个`response`：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is the basic structure of an asynchronous REST resource. We spawn a new
    thread, process it, construct a `response`, and finally, we call the `resume`
    method on the `response`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是异步REST资源的结构基础。我们启动一个新线程，处理它，构建一个`response`，最后，我们在`response`上调用`resume`方法。
- en: 'To be slightly more sophisticated, we can use `BlockingQueue` and we have a
    method called `lock`, which takes the `@Suspended` asynchronous response. We want
    to save the asynchronous response to the queue:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了稍微复杂一些，我们可以使用`BlockingQueue`，并且有一个名为`lock`的方法，它接受带有`@Suspended`注解的异步响应。我们希望将异步响应保存到队列中：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Down here in the `AsyncResource` class, we have an `unlock` method where we
    want to resume the processing on this currently-locked response. We take `asyncResponse`
    from the queue—this pulls the asynchronous response from the queue—and then we
    call the `resume` method on `response`. This will basically resume the previously
    locked request:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AsyncResource`类中，我们有一个`unlock`方法，我们想在当前锁定响应上恢复处理。我们从队列中获取`asyncResponse`——这将从队列中拉出异步响应——然后我们在`response`上调用`resume`方法。这将基本上恢复之前锁定的请求：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we want to add some timeout behavior and we can set a specific timeout
    on `asyncResponse`. If the timeout is exceeded, an HTTP 403 status code is returned:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们想添加一些超时行为，并且我们可以在`asyncResponse`上设置一个特定的超时。如果超时被超过，将返回HTTP 403状态码：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you want to test this, switch to your REST client. First, we send a `GET`
    request for the API thread, then we implement it. As we can see here, `"requestThread"`
    is `http-listener(3)` and `"responseThread"` is a completely different thread:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想测试这个，切换到你的REST客户端。首先，我们向API线程发送一个`GET`请求，然后我们实现它。正如我们所看到的，`"requestThread"`是`http-listener(3)`，而`"responseThread"`是另一个完全不同的线程：
- en: '![](img/6d39e0ec-460b-4640-868d-4f02f6e1f784.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6d39e0ec-460b-4640-868d-4f02f6e1f784.png)'
- en: 'We do the same thing for the asynchronous `GET` request; we issue a `GET` request,
    which will be blocked. We call the unlock (`DELETE`) method and get our 204 No
    Content, as shown in the following screenshot:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于异步`GET`请求，我们做同样的事情；我们发出一个`GET`请求，这将导致阻塞。我们调用解锁（`DELETE`）方法，并得到如以下截图所示的204无内容：
- en: '![](img/0d8db691-aace-40e1-b0a5-c291b8d49d3e.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0d8db691-aace-40e1-b0a5-c291b8d49d3e.png)'
- en: 'If we switch to the already issued `GET` request, we get 503 Service Unavailable,
    as in this case we waited for too long, as shown in the following screenshot:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们切换到已经发出的`GET`请求，我们会得到503服务不可用，因为在这种情况下我们等待时间过长，如以下截图所示：
- en: '![](img/611dc3d2-ee32-4685-bcc5-41f5c09b12ee.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/611dc3d2-ee32-4685-bcc5-41f5c09b12ee.png)'
- en: 'Now, if we call the `DELETE` method and the `GET` method, we see that the `"currentThread"`
    is `http-listener(6)`, as shown in the following screenshot:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们调用`DELETE`方法和`GET`方法，我们会看到`"currentThread"`是`http-listener(6)`，如以下截图所示：
- en: '![](img/caa80767-9038-4b6c-9499-b0de0104b69d.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/caa80767-9038-4b6c-9499-b0de0104b69d.png)'
- en: That's it for this section.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这节的内容就到这里。
- en: In the next section, we'll see how you can use `ManagedExecutorService` and
    server-side callbacks.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何使用`ManagedExecutorService`和服务器端回调。
- en: Using ManagedExecutorService and server-side callbacks
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`ManagedExecutorService`和服务器端回调
- en: In this section, we're going to take a look at using a `ManagedExecutorService`
    instance for asynchronous request processing. I'm going to show you how to use
    `CompletableFuture` to run and resume asynchronous requests. We will talk about
    using a `TimeoutHandler` instance for fine-grained timer control, and we'll be
    using `CompletionCallback` and `ConnectionCallback` instances for even further
    control of the request processing.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨使用`ManagedExecutorService`实例进行异步请求处理。我将向你展示如何使用`CompletableFuture`来运行和恢复异步请求。我们将讨论使用`TimeoutHandler`实例进行细粒度计时器控制，并且我们将使用`CompletionCallback`和`ConnectionCallback`实例来进一步控制请求处理。
- en: 'Let''s get started and switch to code. As usual, we prepare a template project
    to get started. The first thing we want to do is use a `ManagedExecutorService`
    instance. Thus, we will inject this instance into our REST resource:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始并切换到代码。像往常一样，我们准备一个模板项目开始。我们首先想做的事情是使用一个`ManagedExecutorService`实例。因此，我们将把这个实例注入到我们的REST资源中：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, we want to use this `ManagedExecutorService` instance to do some heavy
    processing, such as processing Fibonacci numbers. We will use the `ManagedExecutorService`
    instance and call the `execute` method on it. In this `execute` method, we then
    call `asyncResponse.resume` to resume the asynchronous response and we provide `Response`, which
    in our case is the requested Fibonacci number:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们想使用这个`ManagedExecutorService`实例来进行一些重处理，比如处理斐波那契数。我们将使用`ManagedExecutorService`实例并调用它的`execute`方法。在这个`execute`方法中，我们调用`asyncResponse.resume`来恢复异步响应，并提供`Response`，在我们的例子中是请求的斐波那契数：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'What else can we do? We should provide and specify the timeout to use, as we
    saw in [Chapter 3](b73054eb-e78a-4e76-8a06-8d24aff44801.xhtml), *Content Marshalling
    with JSON-B and JSON-P*. For this case, we specify a timeout of 10 seconds. We
    also want to specify a specific timeout behavior, since maybe we do not want to
    answer with an HTTP status code of 503 in this case. Since we want to specify
    something different, we can use a `setTimeoutHandler` instance. We will register `setTimeoutHandler`
    on the asynchronous response, and in case the timeout fires, we resume the response
    with HTTP status code 202, which is accepted and we just send back a random `UUID`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还能做什么呢？我们应该提供并指定要使用的超时时间，就像我们在[第3章](b73054eb-e78a-4e76-8a06-8d24aff44801.xhtml)，“使用JSON-B和JSON-P进行内容打包”中看到的那样。在这种情况下，我们指定了10秒的超时时间。我们还想指定特定的超时行为，因为我们可能不希望在这种情况下用HTTP状态码503来回答。由于我们想指定不同的东西，我们可以使用一个`setTimeoutHandler`实例。我们将`setTimeoutHandler`注册在异步响应上，如果超时触发，我们将使用HTTP状态码202恢复响应，这是可接受的，我们只需发送一个随机的`UUID`：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can also register additional callbacks. There are two types of callbacks:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以注册额外的回调。有两种类型的回调：
- en: '`CompletionCallback`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletionCallback`'
- en: '`ConnectionCallback`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConnectionCallback`'
- en: We will look at both of them in detail.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细探讨这两种类型。
- en: CompletionCallback
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`CompletionCallback`'
- en: '`CompletionCallback` is the first callback. It is called by the JAX-RS runtime
    once the request is completed. The only method you need to implement is `onComplete`.
    In case of an error, you will be passed the `throwable` error and the `"Completed
    processing."` parameter, and we can do the required logic in here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompletionCallback`是第一个回调。当请求完成时，JAX-RS运行时会调用它。你需要实现的方法只有一个，即`onComplete`。在出错的情况下，你会收到`throwable`错误和`"Completed
    processing."`参数，我们可以在其中执行所需的逻辑：'
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ConnectionCallback
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`ConnectionCallback`'
- en: 'The second type of callback that is optionally supported is `ConnectionCallback`.
    Here, you can specify a custom implementation. Currently, the only method you
    need to implement is the `onDisconnect` method, which is passed the actual `AsyncResponse`.
    This method is called if the client is connected prematurely. According to JSR
    339, the support for `ConnectionCallback` is optional:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 可选支持的第二种回调类型是`ConnectionCallback`。在这里，你可以指定一个自定义实现。目前，你需要实现的方法只有一个，即`onDisconnect`方法，它接收实际的`AsyncResponse`。如果客户端提前连接，这个方法会被调用。根据JSR
    339，对`ConnectionCallback`的支持是可选的：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Registering callbacks
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册回调
- en: 'Once we''ve implemented the two callbacks, you can register them with the asynchronous
    response. You can call `asyncResponse.register` and pass it the class of those
    callbacks:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们实现了这两个回调，你就可以将它们注册到异步响应上。你可以调用`asyncResponse.register`并将这些回调的类传递给它：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: CompletableFuture
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`CompletableFuture`'
- en: 'Finally, we can use `CompletableFuture` as an alternative syntactic sugar way
    of using those asynchronous REST APIs. Again, we use a `ManagedExecutorService`
    instance here. The next thing we want to do is use `CompletableFuture` to run
    the Fibonacci calculation asynchronously and then apply the `asyncResponse::resume`
    method. The code will look as follows. Using `CompletableFuture`, we call the
    `runAsync` method, run our Fibonacci calculation using the supplied `executorService`,
    and then apply the `asyncResponse::resume` method:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`CompletableFuture`作为使用那些异步REST API的替代语法糖。再次强调，这里我们使用一个`ManagedExecutorService`实例。接下来，我们想要做的是使用`CompletableFuture`来异步运行斐波那契计算，然后应用`asyncResponse::resume`方法。代码如下。使用`CompletableFuture`，我们调用`runAsync`方法，使用提供的`executorService`运行斐波那契计算，然后应用`asyncResponse::resume`方法：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s see what this looks like in action. Let''s switch to our REST client.
    First, we call a Fibonacci of 9, which is 34, as shown in the following screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何在实际中运行的。让我们切换到我们的REST客户端。首先，我们调用9的斐波那契数，即34，如下截图所示：
- en: '![](img/a9a9d6d7-90eb-4e51-8557-dc697ea107c1.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a9a9d6d7-90eb-4e51-8557-dc697ea107c1.png)'
- en: 'The same goes for Fibonacci at 17, which is 1,597, and so on and so forth.
    The Fibonacci of 42 takes slightly longer as it is a really long number. We can
    see what happens if we call the Fibonacci of 49; this is a really big number and
    it should trigger the timeout of 10 seconds—we expect an HTTP status code of 202
    Accepted, which you can see here, and we get sent back a random UUID response:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于17的斐波那契数，即1,597，等等。42的斐波那契数稍微长一些，因为它是一个非常长的数字。我们可以看到，如果我们调用49的斐波那契数会发生什么；这是一个非常大的数字，它应该触发10秒的超时——我们期望得到202已接受的状态码，您可以看到这里，并且我们得到一个随机的UUID响应：
- en: '![](img/6adeaf3e-6f9f-4246-a6e1-f3c82095d2a2.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6adeaf3e-6f9f-4246-a6e1-f3c82095d2a2.png)'
- en: In the next section, we will talk about implementing asynchronous web service
    clients.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论实现异步Web服务客户端的方法。
- en: Implementing asynchronous web service clients
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现异步Web服务客户端
- en: In this section, we're going to take a look at the basic usage of asynchronous
    JAX-RS client APIs. We're using `InvocationCallback` instances to react to completed
    and failed calls. We'll also see how to do invocation-chaining of asynchronous
    client requests with `CompletableFuture`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨异步JAX-RS客户端API的基本用法。我们使用`InvocationCallback`实例来响应完成和失败的调用。我们还将看到如何使用`CompletableFuture`进行异步客户端请求的调用链。
- en: Let's get started and switch to code. As usual, we prepared a small template
    project to get started. We'll be using a JUnit test to showcase the JAX-RS client
    APIs. We're going to set up the JAX-RS `client` instance and the JAX-RS `webTarget`
    instance for the previously implemented asynchronous service API. As you might
    remember, in the previous section, we used Fibonacci number calculations asynchronously.
    We'll rewrite the test using the asynchronous JAX-RS client APIs against our REST
    API.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始并切换到代码。像往常一样，我们准备了一个小模板项目来开始。我们将使用JUnit测试来展示JAX-RS客户端API。我们将设置JAX-RS `client`实例和JAX-RS
    `webTarget`实例，用于之前实现的自异步服务API。如您所记，在上一节中，我们使用了斐波那契数计算的异步方式。我们将使用异步JAX-RS客户端API重写测试，针对我们的REST
    API。
- en: 'Let''s open the `AsyncWebServiceClientIntegrationTest` class and start our
    tests; the first test should be pretty easy. We want to construct an asynchronous
    request and we do this the way we did it before. We use `webTarget.path` and we
    request `TEXT_PLAIN_TYPE`. Now comes the real difference: we call the `.async()`
    method and then call `.get(Long.class)`. As you can see, the return type of this
    call is `Future<long>`. Let''s rename it from `longFuture` to `fibonacci` and
    call the `assertEquals` method on that one:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开`AsyncWebServiceClientIntegrationTest`类并开始我们的测试；第一个测试应该相当简单。我们想要构建一个异步请求，我们像以前一样这样做。我们使用`webTarget.path`并请求`TEXT_PLAIN_TYPE`。现在来真正不同的一点：我们调用`.async()`方法，然后调用`.get(Long.class)`。如您所见，这个调用的返回类型是`Future<long>`。让我们将其重命名为`fibonacci`并在其上调用`assertEquals`方法：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is pretty much all there is to using asynchronous APIs, though there is
    slightly more. You can register an invocation callback with `get` to be notified
    on completed and failed events. Then, we''ll see how we implement those callbacks.
    As you can see, instead of calling `get` for the actual `(Long.class)` type, as
    we did previously, we call the `get` of `InvocationCallback<Long>`. We can implement
    the `completed` method for a successful execution and the `failed` method for
    a failure. Again, we''ll return `Future<Long>` for a Fibonacci number and we can
    then call the `get` method on this `Future`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是使用异步API的所有内容，尽管还有一些其他内容。您可以使用`get`注册调用回调，以便在完成和失败事件上接收通知。然后，我们将看到如何实现这些回调。如您所见，我们不再像之前那样为实际的`(Long.class)`类型调用`get`，而是调用`InvocationCallback<Long>`的`get`。我们可以为成功的执行实现`completed`方法，为失败实现`failed`方法。再次强调，我们将为斐波那契数返回`Future<Long>`，然后我们可以在这个`Future`上调用`get`方法：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we''ll see how to do invocation-chaining using `CompletableFuture`.
    This is quite interesting because we can chain several JAX-RS client calls using
    a `CompletableFuture` fluent API. Imagine we want to calculate the Fibonacci numbers
    3, 4, 5, 6, 8, and 21 and do all that in one chain call. This is what it could
    look like:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将看到如何使用`CompletableFuture`进行调用链。这很有趣，因为我们可以使用`CompletableFuture`流畅API链式调用几个JAX-RS客户端调用。想象一下，我们想要计算斐波那契数3、4、5、6、8和21，并且在一个链式调用中完成所有这些。这可能看起来是这样的：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, we do the first call and we use the `.async()` method, which
    returns `Future`. We'll convert this `Future` to a `CompletableFuture`, and then
    for the next calls, we use `thenApply` and we'll do that for the next one and
    so on and so forth. This will ultimately make seven calls.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们执行了第一次调用，并使用了`.async()`方法，它返回`Future`。我们将这个`Future`转换为`CompletableFuture`，然后在接下来的调用中，我们使用`thenApply`，我们将对下一个进行同样的操作，以此类推。这最终将进行七次调用。
- en: Let's run this test to make sure everything's ready and it'll compile our tests.
    We can see that the first three are already successful; the `Fibonacci49WithCallback`
    should result in a 202, and then we're done.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这个测试以确保一切准备就绪并且测试能够编译。我们可以看到前三个已经成功；`Fibonacci49WithCallback`应该得到一个202，然后我们就完成了。
- en: 'That''s all the magic behind the JAX-RS asynchronous line API, as shown in
    the following screenshot:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是JAX-RS异步行API背后的所有魔法，如下面的截图所示：
- en: '![](img/0207a312-af5c-476e-b2a0-9a213190db2e.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0207a312-af5c-476e-b2a0-9a213190db2e.png)'
- en: Output showing asynchronous tests running successfully
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示异步测试运行成功
- en: Summary
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we talked about the motivation and benefits of luminous web
    services, and how they ultimately save memory and improve the performance and
    throughput of our REST API. We then talked about the basic usage of the `@Suspended`
    annotation and the `AsyncResponse` class. We learned how to use `TimeoutHandler`
    and server-side callback instances for fine-grained control. We then used `ManagedExecutorService`
    and `CompletableFuture` for some more syntactic sugar. Finally, we talked about
    the usage of asynchronous JAX-RS client APIs.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了发光Web服务的动机和好处，以及它们如何最终节省内存并提高我们REST API的性能和吞吐量。然后，我们讨论了`@Suspended`注解和`AsyncResponse`类的基本用法。我们学习了如何使用`TimeoutHandler`和服务器端回调实例进行细粒度控制。然后，我们使用了`ManagedExecutorService`和`CompletableFuture`来添加一些语法糖。最后，我们讨论了异步JAX-RS客户端API的用法。
- en: In the next chapter, we'll talk about using server-sent events.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将讨论使用服务器发送事件。
