- en: Overview of Spring 5 and Spring Security 5
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring 5和Spring Security 5概述
- en: This book expects readers to be conversant with Spring Framework (any version)
    and Spring Security (any version). This is an ice-breaker chapter that introduces
    the reader to some of the most important concepts; we will expand on them in subsequent
    chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书希望读者熟悉Spring框架（任何版本）和Spring Security（任何版本）。这是一个引子章节，介绍了一些最重要的概念；我们将在后续章节中扩展这些概念。
- en: The chapter will introduce you to new application requirements and then to reactive
    programming concepts. It touches on application security and how Spring Security
    addresses security concerns in an application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向你介绍新的应用需求，然后介绍反应式编程概念。它涉及应用安全以及Spring Security如何解决应用程序中的安全问题。
- en: We'll continue with Spring Security and then close the chapter by explaining
    how the examples in this chapter are structured. This is quite important as I
    expect readers to be comfortable whenever a new concept is introduced in code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用Spring Security，然后通过解释本章中示例的结构来结束本章。这非常重要，因为我希望读者在引入新概念时感到舒适。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: New-generation application requirements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新一代应用需求
- en: Reactive programming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式编程
- en: Reactive applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式应用
- en: Spring Framework
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring框架
- en: Reactive landscape in Java
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java中的反应式景观
- en: Spring Framework and reactive applications
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring框架和反应式应用程序
- en: Application security
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用安全
- en: Spring Security
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Security
- en: Spring Security's core features
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Security的核心功能
- en: Spring Security 5's new features
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Security 5的新功能
- en: The working of Spring Security
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Security的工作原理
- en: Core Spring Security modules
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心Spring Security模块
- en: How examples are structured
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例的结构
- en: 'It''s important that you understand how we will be using examples in this book.
    Since the book tries to give lots of detail on Spring Security 5 and its reactive
    aspects, we will not have a single use case throughout the book. Instead, we will
    keep creating small projects to help you understand each of the core concepts
    covered. Here are some of the important aspects of the code base within this book:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，你要理解我们在这本书中将如何使用示例。由于本书试图详细介绍Spring Security 5及其反应性方面，我们不会在整本书中只有一个用例。相反，我们将不断创建小型项目，以帮助你理解所涵盖的每个核心概念。以下是本书中代码库的一些重要方面：
- en: Most concepts will be covered using a standalone Spring Boot project.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数概念将使用独立的Spring Boot项目进行介绍。
- en: At times, we will use the famous Spring Initializr ([https://start.spring.io/](https://start.spring.io/))
    to bootstrap our sample Spring Boot application. In other cases, we will start
    with a base project that we already have and introduce more concepts through code.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，我们将使用著名的Spring Initializr ([https://start.spring.io/](https://start.spring.io/))来启动我们的示例Spring
    Boot应用程序。在其他情况下，我们将从我们已经拥有的基础项目开始，并通过代码引入更多概念。
- en: Generally, we will be using Java configuration. At times, we might use XML-based
    configurations.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，我们将使用Java配置。有时，我们可能会使用基于XML的配置。
- en: We will keep our examples as simple as possible so that we don't lose focus
    on the core concept being introduced.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将尽可能简化示例，以便不会偏离引入的核心概念。
- en: Even though this book is focused on reactive applications, we will not be covering
    this each time it is introduced. At times, we will just be doing plain, old imperative
    programming as it is more important to know reactive programming and use it when
    required. It's not that we have to use reactive code everywhere possible, just
    use it where you see fit.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管本书侧重于反应式应用程序，但我们不会在每次引入时都进行覆盖。有时，我们只会进行普通的命令式编程，因为了解反应式编程并在需要时使用它更为重要。并不是说我们必须在所有可能的地方都使用反应式代码，只需在适当的地方使用即可。
- en: We will be using VS Code for all the projects, and we'll be using the extensions
    available in VS Code to the fullest. We will also be using the Spring Initializr
    extension rather than using online Spring Initializr.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将为所有项目使用VS Code，并充分利用VS Code中的扩展。我们还将使用Spring Initializr扩展，而不是使用在线Spring Initializr。
- en: We will be using Maven most of the time in this book. There might be a case
    where we try Gradle.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本书中，我们将大部分时间使用Maven。可能会有一种情况，我们会尝试使用Gradle。
- en: Sometimes, we might use IntelliJ IDE and you'll see some screenshots showing
    this.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，我们可能会使用IntelliJ IDE，你会看到一些屏幕截图显示这一点。
- en: We'll be using the latest Spring Boot release version, namely **2.0.0\. RELEASE**.
    This is the latest release version of Spring Boot at the time of writing this
    book.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用最新的Spring Boot发布版本，即**2.0.0. RELEASE**。这是撰写本书时Spring Boot的最新发布版本。
- en: New-generation application requirements
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新一代应用需求
- en: 'Here are some of the core new application requirements:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些核心的新应用需求：
- en: '**Highly scalable**: The social platform has grown exponentially over the last
    decade and people are more tech-savvy than ever.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高度可扩展**：社交平台在过去十年里呈指数级增长，人们比以往任何时候都更懂技术。'
- en: '**Resilient, fault-tolerant, and highly available**: downtime in your application
    is something which enterprises are not ready to take in modern times; downtime
    of even seconds is now creating huge losses for many big businesses.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性、容错和高可用性**：在现代时代，企业不愿意接受应用程序的停机时间；即使是几秒钟的停机时间也会给许多大型企业带来巨大的损失。'
- en: '**High performance**: If your site is slow, people have a tendency to leave
    and search for alternatives. People have a short attention span and will not stay
    or come back if your website performs poorly.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高性能**：如果你的网站速度慢，人们就有离开并寻找替代方案的倾向。人们的注意力很短，如果你的网站表现不佳，他们就不会停留或回来。'
- en: '**Hyper-personalization**: Users need personalized websites rather than generic
    websites, and this puts huge pressure on servers to do many intensive analyses
    in real time.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超个性化**：用户需要个性化的网站而不是通用的网站，这给服务器带来了巨大的压力，需要实时进行许多密集的分析。'
- en: With technology in everyone's hands (in some form or another, most people use
    technology), users are quite well-versed in privacy policies and application security.
    They are aware of most of the security requirements, and companies take time to
    educate users about the importance of security and the ways they should look for
    security flaws in applications. You might already know that if a site runs on
    HTTP as opposed to HTTPS (SSL) and Chrome tags, these sites quite clearly show
    the users as Not Secure in the address bar. With more people becoming knowledgeable
    about technology, these aspects are well-known among the majority of users and
    security has become one of the most talked about subjects in the IT landscape.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 随着技术进入了每个人的手中（以某种形式，大多数人都在使用技术），用户对隐私政策和应用程序安全非常熟悉。他们了解大多数安全要求，公司花时间教育用户安全的重要性以及他们应该如何寻找应用程序中的安全漏洞。你可能已经知道，如果一个网站使用HTTP而不是HTTPS（SSL）和Chrome标签，这些网站在地址栏中会清楚地显示给用户为不安全。随着越来越多的人对技术有了更多了解，这些方面在大多数用户中都是众所周知的，安全已成为IT领域中最受关注的话题之一。
- en: Another important aspect is data privacy. Some users are not concerned about
    sharing their data but some are quite reticent. Many governments recognize this
    fear and have started making many rules and regulations in this space. One such
    data privacy rule is the well-known **General Data Protection Regulation** (**GDPR**),
    which has been enforced since May 25th, 2018.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要方面是数据隐私。一些用户不担心分享他们的数据，但有些用户则非常谨慎。许多政府意识到了这种担忧，并开始在这个领域制定许多规则和法规。其中一个数据隐私规则就是著名的**通用数据保护条例**（**GDPR**），自2018年5月25日起生效。
- en: The **European Union** (**EU**) GDPR replaces the Data Protection Directive
    95/46/EC and was designed to harmonize data privacy laws across Europe, to protect
    and empower all EU citizen's data privacy and to reshape the way organizations
    across the region approach data privacy. For more information, you can check this
    link: [https://gdpr-info.eu/art-99-gdpr/](https://gdpr-info.eu/art-99-gdpr/).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**欧洲联盟**（**EU**）GDPR取代了《数据保护指令95/46/EC》，旨在协调欧洲各地的数据隐私法律，保护和赋予所有欧盟公民数据隐私权，并重塑该地区组织处理数据隐私的方式。更多信息，请查看此链接：[https://gdpr-info.eu/art-99-gdpr/](https://gdpr-info.eu/art-99-gdpr/)。'
- en: Modern browsers have also given us enough tools to look at many aspects of a
    web application in a more detailed manner with regards to security. In addition,
    browsers have been enhanced with more and more features (for example, a cookie
    was once one of the options for storing data, but now we have other options, such
    as **localStorage** and i**ndexedDB**), making it more vulnerable to security
    breaches and attacks from an ever-open hacker sitting on the sidelines.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器也为我们提供了足够的工具，以更详细的方式查看Web应用程序的许多方面，特别是安全方面。此外，浏览器还增加了越来越多的功能（例如，曾经cookie是存储数据的选项之一，但现在我们有其他选项，比如**localStorage**和**indexedDB**），使其更容易受到来自一直在观望的黑客的安全漏洞和攻击。
- en: To achieve these various application requirements, organizations go to public
    cloud providers instead of their own on-premise datacenters. This puts applications
    in a more vulnerable state and security aspects come to the forefront. The various
    components that constitute the application need to be highly secured and nonhackable.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足这些各种应用程序要求，组织会选择公共云提供商而不是自己的本地数据中心。这使应用程序处于更加脆弱的状态，安全方面成为首要问题。构成应用程序的各个组件需要高度安全和不可被黑客攻击。
- en: The technological landscape is constantly growing, with new technologies popping
    up and getting adopted by the developer community. Because of this and the various
    technology improvements it brings in, many organizations have to adopt these technologies
    to be compete within the market. This again puts huge pressure on security, as
    these shiny new technologies may not have concentrated enough effort on making
    security a major requirement.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 技术领域不断发展，新技术不断涌现并被开发者社区所采纳。由于这个原因和它带来的各种技术改进，许多组织不得不采用这些技术来在市场中竞争。这再次给安全带来了巨大压力，因为这些闪亮的新技术可能没有足够的努力将安全作为主要要求。
- en: All in, having rigid security in an application is a no-brainer requirement
    and organizations, and end users, are well aware of this fact.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 全面而言，在应用程序中具有严格的安全性是一个不言而喻的要求，组织和最终用户都很清楚这一事实。
- en: Reactive programming
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式编程
- en: Over the last few years, JavaScript has become one of the most used languages,
    and you have already heard of the term **reactive** in the world of JavaScript,
    both in a backend and a frontend context.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，JavaScript已成为最常用的语言之一，你可能已经在JavaScript的世界中听说过**reactive**这个术语，无论是在后端还是前端的上下文中。
- en: So, *What exactly is reactive programming?*—It's a programming paradigm that
    has asynchronous data streams at its core. The data flows through various parts
    of the program in the form of a message. The message is produced by a `Producer` and
    works in a fire-and-forget manner in which the program produces a message and
    forgets it. The `Subscriber` who has subscribed (shown interest) to such messages,
    gets the message, processes it, and passes on the output as a message for other
    parts of the program to consume.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，*什么是响应式编程？*—这是一种以异步数据流为核心的编程范式。数据以消息的形式在程序的各个部分之间流动。消息由`Producer`产生，并以一种“发出即忘记”的方式工作，程序产生一条消息然后忘记它。已订阅（表现出兴趣）此类消息的`Subscriber`会收到消息，处理它，并将输出作为消息传递给程序的其他部分来消费。
- en: In the world of databases, NoSQL presented a huge shift from relational databases.
    Similarly, this programming paradigm is a huge shift from the conventional programming
    paradigm (imperative programming). The good thing is that without much knowledge,
    you have already been coding a bit of reactive code in your day-to-day coding
    life. Wherever you see the word **stream**, you are indirectly using a piece of
    reactive code. Such programming has a name of its own and this aspect has become
    more mainstream in the industry. Many languages understand the advantages this
    brings and they have started to natively support this paradigm of programming.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库领域，NoSQL从关系数据库中产生了巨大变革。同样，这种编程范式是从传统的编程范式（命令式编程）中产生了巨大变革。好消息是，即使不太了解，您在日常编码生活中已经编写了一些反应式代码。只要您看到**流**这个词，您就间接地使用了一小部分反应式代码。这种编程有自己的名称，并且这一方面在行业中变得更加主流。许多语言都理解了这带来的优势，并开始原生支持这种编程范式。
- en: Reactive applications
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式应用
- en: In the earlier section of this chapter, we covered how application requirements
    have drastically changed over the last decade. To cater to this, there is a concept
    of application development named reactive applications.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前一部分，我们讨论了过去十年应用程序需求的巨大变化。为了满足这一需求，出现了一种名为反应式应用的应用开发概念。
- en: It is important to understand the difference between reactive programming and
    reactive applications. Employing reactive programming doesn't produce reactive
    applications, but concepts of reactive programming can definitely aid in building
    reactive applications.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 了解反应式编程和反应式应用之间的区别很重要。采用反应式编程并不会产生反应式应用，但是反应式编程的概念肯定可以帮助构建反应式应用。
- en: Knowing the Reactive Manifesto will help you understand reactive applications/systems
    because the manifesto clearly dictates each and every aspect of reactive applications.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 了解反应式宣言将有助于您理解反应式应用/系统，因为宣言清楚地规定了反应式应用的每个方面。
- en: Reactive Manifesto
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式宣言
- en: A **manifesto** is a public declaration of intentions, opinions, objectives,
    or motives, as one issued by a government, sovereign, or organization ([http://www.dictionary.com/browse/manifesto](http://www.dictionary.com/browse/manifesto)).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**宣言**是一项公开宣布的意图、观点、目标或动机，如政府、主权国家或组织发布的宣言（[http://www.dictionary.com/browse/manifesto](http://www.dictionary.com/browse/manifesto)）。'
- en: The **Reactive Manifesto** clearly articulates the views of the issuer, following
    which an application can be developed to be reactive.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**反应式宣言**清楚地阐述了发布者的观点，根据这一宣言可以开发出反应式应用。'
- en: According to the Reactive Manifesto ([https://www.reactivemanifesto.org/](https://www.reactivemanifesto.org/)),
    a reactive system should be responsive, resilient, elastic, and message-driven.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 根据反应式宣言（[https://www.reactivemanifesto.org/](https://www.reactivemanifesto.org/)），反应式系统应该是响应式的、弹性的、具有弹性和消息驱动的。
- en: Let's get into each of these terms in a bit more detail. Most of the text in
    this section is from the online Reactive Manifesto and then slightly modified
    to convey the concepts in more easily digestible terms for the readers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解这些术语。本节大部分内容来自在线反应式宣言，稍作修改以便更容易理解。
- en: Responsive
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式
- en: In case of problems, responsive systems can quickly detect them and effectively
    deal with them. These systems also give consistent response times and also establish
    upper bounds, guaranteeing a minimum **Quality of Service** (**QoS**). Because
    of such characteristics, these systems build end user confidence, simplify error
    handling, and encourage more interaction from end users.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在出现问题的情况下，响应系统可以快速检测到问题并有效处理。这些系统还能够提供一致的响应时间，并建立上限，保证最低的**服务质量**（**QoS**）。由于这些特点，这些系统能够建立终端用户的信心，简化错误处理，并鼓励终端用户更多的互动。
- en: Resilient
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性
- en: 'In the case of failure, resilient systems stay responsive and interactable.
    **Resilience** in an application can be achieved by:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在失败的情况下，弹性系统保持响应和可交互。应用程序中的**弹性**可以通过以下方式实现：
- en: '**Replication**: Running the same component in more than one place, so that
    if one fails, another could handle it and the application can function in a normal
    fashion.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复制**：在多个地方运行相同的组件，以便如果一个失败，另一个可以处理，并且应用程序可以正常运行。'
- en: '**Containment/isolation**: Issues of a particular component are contained and
    isolated within that component and don''t interfere with other components or other
    similar components spun up as part of replication.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装/隔离**：特定组件的问题被包含和隔离在该组件内部，并且不会干扰其他组件或作为复制的其他相似组件。'
- en: '**Delegation**: In the case of an issue in a component, without much deliberation,
    the control is transferred to another similar component that is running in a completely
    different context.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**委托**：在组件出现问题的情况下，控制会立即转移到另一个运行在完全不同上下文中的相似组件。'
- en: Elastic
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性
- en: Elastic systems can easily autoscale (increase or decrease resources) as the
    input rate increases or decreases. Such systems don't have any contention points
    and can replicate components at will, distributing the increase in load. The way
    these systems are designed makes sure that when scaling is required, it can be
    done in a very cost-effective manner by adding on more commodity hardware and
    software platforms as opposed to expensive hardware and licensed software platforms.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性系统可以在输入速率增加或减少时轻松自动扩展（增加或减少资源）。这种系统没有任何争用点，并且可以随意复制组件，分发负载增加。这些系统的设计方式确保了在需要扩展时，可以通过增加更多的商品硬件和软件平台来以非常具有成本效益的方式进行，而不是使用昂贵的硬件和许可软件平台。
- en: Message-driven
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息驱动
- en: In reactive applications, one of the main aspects is the usage of asynchronous
    messages to pass data from one component to another. This brings loose coupling
    between components and aids in achieving location transparency (as long as the
    component is reachable/discoverable, it can reside in a single node or a cluster
    of nodes anywhere). Create a message, publish, and forget. Registered subscribers
    receive the message, process it, and broadcast the message for the other subscribes
    to do their jobs. This is one of the core aspects of reactive programming and
    it is one of the fundamental aspects needed for a reactive system. This fire-and-forget
    concept brings in a non-blocking way of communication, resulting in highly scalable
    applications.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应式应用中，主要方面之一是使用异步消息将数据从一个组件传递到另一个组件。这带来了组件之间的松耦合，并有助于实现位置透明性（只要组件是可到达/可发现的，它可以位于任何地方的单个节点或节点集群中）。创建消息，发布并忘记。注册的订阅者接收消息，处理它，并广播消息以便其他订阅者完成其工作。这是响应式编程的核心方面之一，也是响应式系统所需的基本方面之一。这种“发射和忘记”的概念带来了一种非阻塞的通信方式，从而产生了高度可扩展的应用程序。
- en: 'The following diagram (*Figure 1*) clearly shows the Reactive Manifesto in
    a pictorial fashion. It also clearly shows the relationship between the main concepts
    on the Reactive Manifesto:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表（*图1*）清楚地以图形方式展示了响应式宣言。它还清楚地展示了响应式宣言中主要概念之间的关系：
- en: '![](img/0c837321-50ac-422f-993a-c12aece10ded.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c837321-50ac-422f-993a-c12aece10ded.png)'
- en: 'Figure 1: Reactive Manifesto'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：响应式宣言
- en: Since reactive applications are responsive, resilient, elastic, and message-driven,
    these applications are inherently highly flexible, highly scalable, loosely coupled,
    and fault-tolerant.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于响应式应用是响应式、弹性、可伸缩和消息驱动的，这些应用本质上是高度灵活、高度可扩展、松耦合和容错的。
- en: 'Mateusz Gajewski, in one of his presentations shared on `www.slideshare.net`,
    sums up the Reactive Manifesto in a very nice way:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Mateusz Gajewski在`www.slideshare.net`上分享的一个演示中，以非常好的方式总结了响应式宣言：
- en: '![](img/f2dc861f-ce23-40b4-9240-691ca42cee51.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2dc861f-ce23-40b4-9240-691ca42cee51.png)'
- en: 'Figure 2: Reactive Manifesto as conceived by Mateusz Gajewski'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：Mateusz Gajewski构想的响应式宣言
- en: Spring Framework
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring框架
- en: '**Spring Framework** is the de facto standard for building Java applications.
    Over the last decade, it has matured with every major release. Spring Framework
    5 became generally available as 5.0.0\. in September 2017; this is an important
    release (major) for the framework since its previous version, which was released
    in 2013.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring框架**是构建Java应用程序的事实标准。在过去的十年中，它随着每个主要版本的发布而不断成熟。 Spring框架5于2017年9月作为5.0.0版正式发布；这是自2013年发布的上一个版本以来对框架的重要（主要）发布。'
- en: One of the major additions to Spring 5 is the introduction of a functional web
    framework, Spring WebFlux, built on the core reactive foundation. Reactive programming
    is slowly creeping into the framework and many core modules within the framework
    are inherently supporting reactive programming in a big way. Since the framework
    has started supporting reactive programming natively, core aspects of this programming
    are fully implemented and followed by many of the modules. Also, many reactive
    concepts have become common language within the framework.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 5的一个重大新增功能是引入了一个基于核心响应式基础构建的功能性Web框架Spring WebFlux。响应式编程正在悄悄地渗透到框架中，并且框架内的许多核心模块在很大程度上都在本质上支持响应式编程。由于框架已经开始原生支持响应式编程，因此这种编程的核心方面已经得到完全实现，并且许多模块都遵循了这种编程方式。此外，许多响应式概念已经成为框架内的通用语言。
- en: It's important to note that Spring's reactive concepts have been taken as is
    from Java 8's **Reactor Core library**, which implements the reactive programming
    paradigm. Reactor Core is built on top of *Reactive Streams Specification*, which
    is the industry standard for building reactive applications in the Java world.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，Spring的响应式概念是直接从Java 8的**Reactor Core库**中提取的，该库实现了响应式编程范式。 Reactor Core是建立在*Reactive
    Streams规范*之上的，这是在Java世界中构建响应式应用的行业标准。
- en: Another important feature is the inclusion of new way by which such applications
    can be tested. We have a dedicated chapter for Spring WebFlux in ([Chapter 5](df488f9c-24a7-4d0f-ac82-1d126a391fcc.xhtml),
    *Integrating with Spring WebFlux*) where these aspects will be covered in more
    detail.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要特性是包括了一种新的方式来测试这种应用程序。我们在（[第5章](df488f9c-24a7-4d0f-ac82-1d126a391fcc.xhtml)，*与Spring
    WebFlux集成*）中有一个专门的章节介绍Spring WebFlux，其中将更详细地介绍这些方面。
- en: Being a major release, it has loads of stuff either added or enhanced. But we
    are not going to list all of its features. The full list can be found at this
    link: [https://github.com/spring-projects/spring-framework/wiki/What%27s-New-in-Spring-Framework-5.x](https://github.com/spring-projects/spring-framework/wiki/What%27s-New-in-Spring-Framework-5.x)*.*
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个重大发布，它增加或增强了大量内容。但我们不打算列出其所有功能。完整列表可以在此链接找到：[https://github.com/spring-projects/spring-framework/wiki/What%27s-New-in-Spring-Framework-5.x](https://github.com/spring-projects/spring-framework/wiki/What%27s-New-in-Spring-Framework-5.x)*.*
- en: Reactive Landscape in Java
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java中的响应式景观
- en: It's hard to wrap your head around reactive concepts when you're coming from
    a traditional programming model. Some of the subsequent sections are aimed at
    introducing you to reactive concepts and how they evolved into their present state.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从传统的编程模型转变过来时，很难理解响应式概念。随后的一些部分旨在向您介绍响应式概念以及它们如何演变为现在的状态。
- en: Reactive Streams and Reactive Streams Specifications
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式流和响应式流规范
- en: The official document for Reactive Streams ([http://www.reactive-streams.org/](http://www.reactive-streams.org/))
    says that—*Reactive Streams is an initiative to provide a standard for asynchronous
    stream processing with non-blocking back pressure. This encompasses efforts aimed
    at runtime environments (JVM and JavaScript) as well as network protocols.*
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Reactive Streams的官方文档（[http://www.reactive-streams.org/](http://www.reactive-streams.org/)）表示：*Reactive
    Streams是提供异步流处理和非阻塞背压的标准的一个倡议。这包括针对运行时环境（JVM和JavaScript）以及网络协议的努力。*
- en: It started as an initiative between a group of companies in 2013\. In April
    2015, 1.0 of the specification was released and there were a number of implementations
    (such as Akka Streams and Vert.x) available at the same time. The specification
    was initiated with a target to get it included in the official Java standard library
    and in 2017, with the release of JDK9, it made it's way into it officially. As
    with any specification, the ultimate aim is to have a number of implementations
    conforming to the specification, and over time, the specification evolves. The
    specification consists of some core interfaces, some rules around these, and a
    **Technology Compatibility Kit** (**TCK**).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 它始于2013年一群公司的倡议。2015年4月，1.0版规范发布，同时有多个实现（如Akka Streams和Vert.x）可用。该规范的目标是将其纳入官方Java标准库，并在2017年，随着JDK9的发布，它正式进入其中。与任何规范一样，最终目标是有多个符合规范的实现，并随着时间的推移，规范会不断发展。规范包括一些核心接口，围绕这些接口的一些规则，以及一个**技术兼容性测试套件**（**TCK**）。
- en: TCK is a suite of tests that will be executed to check the correctness/compliance
    of a **Java Specification Request** (**JSR**) implementation. In **Java Community
    Process** (**JCP**), TCK is one of the three required components for ratifying
    a JSR. The other two are JSR specification and JSR reference implementation. The
    TCK for the Java platform is called **Java Compatibility Kit** (**JCK**).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: TCK是一套测试，用于检查**Java规范请求**（**JSR**）实现的正确性/符合性。在**Java社区流程**（**JCP**）中，TCK是批准JSR所需的三个组成部分之一。另外两个是JSR规范和JSR参考实现。Java平台的TCK称为**Java兼容性测试套件**（**JCK**）。
- en: 'Being a specification, it enables any implementation respecting the specification
    to cooperate and interoperate with each other. For example, an implementation
    written in Akka can talk to the Vert.x implementation over the Reactive Streams
    protocol without any trouble. Adoption is growing and, as we speak, more implementations
    that conform to the specifications written in different languages are being released:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项规范，它使得尊重规范的任何实现都能相互合作和互操作。例如，使用Akka编写的实现可以在不出现问题的情况下通过反应流协议与Vert.x实现进行通信。采用情况正在增加，目前，符合规范的更多实现正在以不同语言编写的形式发布：
- en: '![](img/889be598-8a2a-46ac-b42d-e926af183090.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/889be598-8a2a-46ac-b42d-e926af183090.png)'
- en: 'Figure 3: Reactive Streams Specification/API'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：反应流规范/API
- en: 'The preceding figure clearly shows the **Reactive Streams Specification**.
    Some of the important specification rules are as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 前述图清楚地显示了**反应流规范**。以下是一些重要的规范规则：
- en: The calls from `Publisher` to `Subscriber` and `Subscriber` to `Publisher` shouldn't
    be concurrent in nature.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “发布者”到“订阅者”和“订阅者”到“发布者”的调用不应该是并发的。
- en: The `Subscriber` can perform its job synchronously or asynchronously but always
    has to be non-blocking in nature.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “订阅者”可以同步或异步执行其工作，但始终必须是非阻塞的。
- en: From `Publisher` to `Subscriber` there should be an upper bound defined. After
    that defined bound, buffer overflows occur and could result in errors.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从“发布者”到“订阅者”应该定义一个上限。在定义的边界之后，缓冲区溢出会发生，并可能导致错误。
- en: Apart from **NullPointerException** (**NPE**), no other exception can be raised.
    In the case of NPE, `Publisher` calls the `onError` method and `Subscriber` cancels
    the `Subscription`.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了**NullPointerException**（**NPE**）之外，不会引发其他异常。在NPE的情况下，“发布者”调用`onError`方法，“订阅者”取消“订阅”。
- en: In the preceding definition of Reactive Streams, there are some very important
    terms, namely **non-blocking** and **backpressure**, which we'll explore a bit
    more to understand the core concepts of Reactive Streams.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述对反应流的定义中，有一些非常重要的术语，即**非阻塞**和**反压**，我们将更深入地探讨一下，以了解反应流的核心概念。
- en: Non-blocking
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非阻塞
- en: '**Non-blocking** means threads never block. If the thread needs to block, the
    code is written in such a way that the thread gets notified at the right time
    and the process continues. Reactive programming lets you implement a non-blocking,
    declarative, and event-driven architecture.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**非阻塞**意味着线程永远不会被阻塞。如果线程需要阻塞，代码会以一种使线程在正确时间得到通知并继续进行的方式编写。反应式编程让您实现非阻塞、声明式和事件驱动的架构。'
- en: 'One of the approaches to writing non-blocking applications is by using messages
    as the means of sending data. A thread sends the request and soon after that,
    the thread is being used for something else. When the response is ready, it is
    delivered back using another thread and the requesting party is notified so that
    further processing can continue:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 写非阻塞应用程序的一种方法是使用消息作为发送数据的手段。一个线程发送请求，然后很快，该线程被用于其他事情。当响应准备好时，它会使用另一个线程传递回来，并通知请求方，以便进一步处理可以继续进行：
- en: '![](img/1323eef4-40e3-40e8-895a-fe526156fa6e.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1323eef4-40e3-40e8-895a-fe526156fa6e.png)'
- en: 'Figure 4: Non-blocking'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：非阻塞
- en: The non-blocking concept is already implemented by well-known frameworks, such
    as Node.js and Akka. The approach that Node.js uses is a single thread that sends
    data in a multiplexing aspect.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 非阻塞概念已经被众所周知的框架实现，如Node.js和Akka。Node.js使用的方法是单个线程以多路复用的方式发送数据。
- en: In telecommunications and computer networks, multiplexing (sometimes contracted
    to muxing) is a method by which multiple analog or digital signals are combined
    into one signal over a shared medium. The aim is to share an expensive resource.
    For more information about multiplexing, you can visit the following link: [http://www.icym.edu.my/v13/about-us/our-news/general/722-multiplexing.html](http://www.icym.edu.my/v13/about-us/our-news/general/722-multiplexing.html).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在电信和计算机网络中，多路复用（有时缩写为muxing）是一种将多个模拟或数字信号合并成一个信号的方法，通过共享介质。其目的是共享昂贵的资源。有关多路复用的更多信息，您可以访问以下链接：[http://www.icym.edu.my/v13/about-us/our-news/general/722-multiplexing.html](http://www.icym.edu.my/v13/about-us/our-news/general/722-multiplexing.html)。
- en: Backpressure
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反压
- en: In an ideal scenario, every message produced by the `Producer` is passed to
    the `Subscriber` as and when the message is produced without any delay. There
    is a chance that the `Subscriber` is unable to handle the messages at the same
    rate as they are produced and this can cramp its resources.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想情况下，`生产者`产生的每条消息都会在产生时立即传递给`订阅者`，而不会有任何延迟。有可能`订阅者`无法以与产生速率相同的速度处理消息，这可能会使其资源受到压制。
- en: '**Backpressure** is a method by which the `Subscriber` can tell the `Producer`
    to send messages at a slower rate to give the `Subscriber` time to handle these
    messages properly without putting too much pressure on its resources.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**背压**是一种方法，通过该方法`订阅者`可以告诉`生产者`以较慢的速度发送消息，以便给`订阅者`时间来正确处理这些消息，而不会对其资源施加太大压力。'
- en: Since this is the first chapter, we are just introducing you to these important
    reactive concepts. Code examples will be covered in subsequent chapters.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是第一章，我们只是向您介绍了这些重要的响应式概念。代码示例将在后续章节中介绍。
- en: Now that we have a brief idea of Reactive Streams and Reactive Streams Specification,
    we will go into next important reactive concept in Java, namely Reactive Extensions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对响应式流和响应式流规范有了一个简要的了解，我们将进入Java中的下一个重要的响应式概念，即响应式扩展。
- en: Reactive Extensions
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式扩展
- en: '**Reactive Extensions** (**Rx or ReactiveX**) ([https://msdn.microsoft.com](https://msdn.microsoft.com))
    is a library for composing asynchronous and event-based programs using observable
    sequences and LINQ-style query operators. Data sequences can take many forms,
    such as a stream of data from a file or web service, web services requests, system
    notifications, or a series of events such as user inputs.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应式扩展**（**Rx或ReactiveX**）（[https://msdn.microsoft.com](https://msdn.microsoft.com)）是一个使用可观察序列和LINQ风格查询操作来组合异步和基于事件的程序的库。数据序列可以采用多种形式，例如来自文件或网络服务的数据流、网络服务请求、系统通知或一系列事件，例如用户输入。'
- en: 'As stated in the preceding definition, these are APIs that allow stream composition
    using the Observer pattern. It''s my duty to introduce you to the Observer pattern
    before going any further. The following is the definition of this pattern and
    it''s quite intuitive:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述定义所述，这些是允许使用观察者模式进行流组合的API。在继续之前，我有责任向您介绍观察者模式。以下是这种模式的定义，它非常直观：
- en: The Observer pattern defines a provider (also known as a subject or an observable)
    and zero, one, or more observers (`Subscriber`). Observers register with the provider,
    and whenever a predefined condition, event, or state change occurs, the provider
    automatically notifies all observers by calling one of their methods. For more
    information about the Observer pattern, you can refer to this link: [https://docs.microsoft.com/en-us/dotnet/standard/events/observer-design-pattern](https://docs.microsoft.com/en-us/dotnet/standard/events/observer-design-pattern).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式定义了一个提供者（也称为主题或可观察者）和零个、一个或多个观察者（订阅者）。观察者向提供者注册，每当预定义的条件、事件或状态发生变化时，提供者会自动通过调用观察者的方法来通知所有观察者。有关观察者模式的更多信息，您可以参考此链接：[https://docs.microsoft.com/en-us/dotnet/standard/events/observer-design-pattern](https://docs.microsoft.com/en-us/dotnet/standard/events/observer-design-pattern)。
- en: Data can flow in a number of forms, such as streams or events. Reactive Extensions
    lets you convert this dataflow into observables and aids you in programming reactive
    code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以以多种形式流动，例如流或事件。响应式扩展让您将这些数据流转换为可观察对象，并帮助您编写响应式代码。
- en: Rx is implemented in a variety of languages, including Java (RxJava). A full
    list of implemented languages and more detail on Rx can be found at [http://reactivex.io/](http://reactivex.io/).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Rx在多种语言中实现，包括Java（RxJava）。可以在[http://reactivex.io/](http://reactivex.io/)找到已实现的语言的完整列表和有关Rx的更多详细信息。
- en: RxJava
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RxJava
- en: '**RxJava** is a Java VM implementation of ReactiveX—a library for composing
    asynchronous and event-based programs by using observable sequences.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**RxJava**是ReactiveX的Java VM实现，它是通过使用可观察序列来组合异步和基于事件的程序的库。'
- en: RxJava was ported from .NET to the world of Java by Netflix. After almost two
    years of development, a stable release of the API was made available in 2014\.
    This stable release targets Java (Version 6 and above), Scala, JRuby, Kotlin,
    and Clojure.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava是由Netflix将.NET移植到Java世界的。经过近两年的开发，API的稳定版本于2014年发布。此稳定版本针对Java（版本6及以上）、Scala、JRuby、Kotlin和Clojure。
- en: RxJava is a single-JAR, lightweight library and focuses on Observable abstraction.
    It facilitates integration with a variety of external libraries, making the library
    align with reactive principles. Some examples are `rxjava-jdbc` (database calls
    using JDBC with RxJava Observables) and Camel RX (Camel support for Reactive Extensions
    using RxJava).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava是一个单一的JAR轻量级库，专注于Observable抽象。它便于与各种外部库集成，使库与响应式原则保持一致。一些例子是`rxjava-jdbc`（使用RxJava
    Observables进行数据库调用）和Camel RX（使用RxJava的Reactive Extensions支持Camel）。
- en: Reactive Streams and RxJava
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式流和RxJava
- en: RxJava 2.x is a complete rewrite from its predecessor, RxJava 1.x.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava 2.x是从其前身RxJava 1.x进行了完全重写。
- en: RxJava 1.x was created before Reactive Streams Specification, and because of
    this it doesn't implement it. RxJava 2.x, on the other hand, is written on top
    of Reactive Streams Specification and fully implements it, and also targets Java
    8+. RxJava types in RxJava 1.x have been fully tweaked to comply with the specification
    and suffered heavy changes when the rewrite took place. It's good to note that
    there exists a bridge library ([https://github.com/ReactiveX/RxJavaReactiveStreams](https://github.com/ReactiveX/RxJavaReactiveStreams))
    that bridges between RxJava 1.x types and Reactive Streams, allowing RxJava 1.x
    to pass the Reactive Streams TCK-compliance tests.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava 1.x是在Reactive Streams规范之前创建的，因此它没有实现它。另一方面，RxJava 2.x是基于Reactive Streams规范编写的，并完全实现了它，还针对Java
    8+。RxJava 1.x中的类型已经完全调整以符合规范，并在重写时经历了重大变化。值得注意的是，存在一个桥接库（[https://github.com/ReactiveX/RxJavaReactiveStreams](https://github.com/ReactiveX/RxJavaReactiveStreams)），它在RxJava
    1.x类型和Reactive Streams之间建立桥梁，使RxJava 1.x能够通过Reactive Streams TCK兼容性测试。
- en: In RxJava 2.x, many concepts remain intact but names have been changed to comply
    with the spec.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在RxJava 2.x中，许多概念保持不变，但名称已更改以符合规范。
- en: We will not be going deep into RxJava as it is a big topic and there are plenty
    of books available that dive deep into RxJava.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入研究RxJava，因为这是一个庞大的主题，有很多书籍可以深入了解RxJava。
- en: JDK 9 additions
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JDK 9的新增内容
- en: As part of concurrency updates to JDK 9 (JEP 266), Reactive Streams was added
    to the Java standard library. Reactive Streams was initiated in 2013 by some of
    the well-known organizations that wanted to standardize the approach by which
    asynchronous data can be exchanged between software components. Soon, the concept
    became adopted by the industry and there evolved a number of implementations that
    all had similar core concepts but lacked standard nomenclature and terminologies,
    especially as regards interfaces and package naming. To avoid multiple nomenclatures
    and to enable interoperability between implementations, JDK 9 included basic interfaces
    as part of the **Flow Concurrency** library. This made applications want to implement
    Reactive Streams to depend on this library but not include specific implementations
    into the code base. Thus it is very easy to swap between implementations without
    any trouble.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 作为JDK 9的并发更新的一部分（JEP 266），Reactive Streams被添加到了Java标准库中。Reactive Streams于2013年由一些知名组织发起，他们希望标准化异步数据在软件组件之间交换的方法。很快，这个概念被行业采纳，并出现了许多实现，它们都有类似的核心概念，但缺乏标准的命名和术语，特别是接口和包命名方面。为了避免多种命名方式，并实现不同实现之间的互操作性，JDK
    9包含了基本接口作为Flow Concurrency库的一部分。这使得应用程序想要实现Reactive Streams依赖于这个库，而不是将特定的实现包含到代码库中。因此，很容易在不产生任何麻烦的情况下在不同实现之间切换。
- en: These interfaces are coded as static interfaces within the `java.util.concurrent.Flow`
    class.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些接口被编码为`java.util.concurrent.Flow`类中的静态接口。
- en: Important interfaces
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重要接口
- en: Reactive Streams specifications in Java 9 revolve around just four interfaces—`Publisher`,
    `Subscriber`, `Subscription`, and `Processor`. The library also includes a `Publisher`
    implementation—`SubmissionPublisher`. All of these are included within the `java.util.concurrent` package
    in the Java standard library. We will touch upon these interfaces in the following
    subsections.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9中的Reactive Streams规范围仅涉及四个接口——`Publisher`、`Subscriber`、`Subscription`和`Processor`。该库还包括一个`Publisher`实现——`SubmissionPublisher`。所有这些都包含在Java标准库的`java.util.concurrent`包中。我们将在以下子章节中介绍这些接口。
- en: The Publisher Interface
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布者接口
- en: 'The definition of this interface is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口的定义如下：
- en: '[PRE0]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, `Publisher` allows the `Subscriber` interface to subscribe to
    it so as to receive the message when `Publisher` produces it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`Publisher`允许`Subscriber`接口订阅它，以便在`Publisher`产生消息时接收消息。
- en: The Subscriber Interface
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅者接口
- en: 'The definition of this interface is as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口的定义如下：
- en: '[PRE1]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, the `Subscriber` interface's `onSubscribe` method allows `Subscriber`
    to be notified when `Publisher` accepts the `Subscription`. The `onNext` method
    is invoked when new items get published. As the name suggests, the `onError` method
    is invoked when there's an error and the `onComplete` method gets invoked when
    `Publisher` has completed its function.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`Subscriber`接口的`onSubscribe`方法允许`Subscriber`在`Publisher`接受`Subscription`时得到通知。当新项目发布时，`onNext`方法被调用。正如其名称所示，当出现错误时，将调用`onError`方法，当`Publisher`完成其功能时，将调用`onComplete`方法。
- en: The Subscription interface
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅接口
- en: 'The definition of this interface is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口的定义如下：
- en: '[PRE2]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The method request is for accepting requests for items and method cancel is
    for when `Subscription` is cancelled.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请求方法用于接受项目的请求，取消方法用于取消`Subscription`。
- en: The Processor interface
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理器接口
- en: 'The definition of this interface is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口的定义如下：
- en: '[PRE3]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It inherits from both the `Publisher` and `Subscriber` interfaces and therefore
    inherits all the methods of these interfaces. The main aspect is that the `Publisher`
    can produce an item but the `Subscriber` can consume a different item than that
    produced by the `Publisher`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 它继承自`Publisher`和`Subscriber`接口，因此继承了这些接口的所有方法。主要的方面是`Publisher`可以产生一个项目，但`Subscriber`可以消耗与`Publisher`产生的项目不同的项目。
- en: Spring Framework and reactive applications
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring框架和响应式应用
- en: Spring Framework adopted reactive in 2013 (the same time reactive was born and
    became more mainstream) with the release of Version 1.0 of Reactor. This was the
    time when Spring Framework Version 4.0 was released and Spring got itself engaged
    with **Pivotal**. In 2016, Spring's 4.3 Version was released with Reactor's Version
    3.0\. Around this period, the work on Spring's Version 5.0 (major version) was
    actively under construction.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架在2013年采用了响应式（与响应式诞生并变得更加主流的同时），发布了Reactor 1.0版本。这是Spring框架4.0版本发布并与Pivotal合作的时候。2016年，Spring的4.3版本与Reactor的3.0版本一起发布。在这个时期，Spring
    5.0版本的开发也在积极进行中。
- en: With new-generation application requirements, many conventional coding practices
    were challenged. One of the main aspects was to get rid of blocking IO and to
    find an alternative to conventional imperative programming.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新一代应用程序的需求，许多传统的编码实践受到了挑战。其中一个主要方面是摆脱阻塞IO，并找到替代传统命令式编程的方法。
- en: 'Web applications backed by a Servlet container are inherently blocking, and
    Spring 5 did a great deal in web application development by introducing a fresh
    web application framework based on reactive programming: Spring WebFlux.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由Servlet容器支持的Web应用程序在本质上是阻塞的，Spring 5通过引入基于响应式编程的全新Web应用程序框架Spring WebFlux，在Web应用程序开发方面做出了很大贡献。
- en: Spring also has embraced Rx and has used it in many ways within Spring 5\. With
    Spring 5, reactive features are baked into it in many aspects, helping developers
    to embrace reactive programming easily in a slow-paced manner.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Spring也采用了Rx，并在Spring 5中以多种方式使用了它。在Spring 5中，响应式特性在许多方面都已经内置，帮助开发人员以渐进的方式轻松采用响应式编程。
- en: Pivotal is heavily invested in Reactor but has exposed APIs, allowing developers
    to choose the library of their choice between Reactor and RxJava.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Pivotal在Reactor上投入了大量资源，但也暴露了API，允许开发人员在Reactor和RxJava之间选择他们喜欢的库。
- en: 'The following diagram depicts Spring 5''s reactive programming support:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示了Spring 5对响应式编程的支持：
- en: '![](img/d655fc0b-14d0-4f74-a358-9d23692d570a.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d655fc0b-14d0-4f74-a358-9d23692d570a.png)'
- en: 'Figure 5: Spring Framework + Reactor + Rx'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：Spring Framework + Reactor + Rx
- en: Reactor is Pivotal's (**SpringSource**) answer to implementing Reactive Streams
    Specification. As mentioned earlier, Spring is heavily invested in Reactor and
    this section aims to delve a bit deeper into Reactor.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor是Pivotal（**SpringSource**）对实现Reactive Streams规范的回应。如前所述，Spring在Reactor上投入了大量资源，本节旨在深入了解Reactor。
- en: Reactor is a fourth-generation reactive library for building non-blocking applications
    on the JVM based on the Reactive Streams Specification.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor是第四代基于Reactive Streams规范在JVM上构建非阻塞应用程序的响应式库。
- en: 'An overview of the history of **Project Reactor** can be pictorially represented
    in the following figure:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**Project Reactor**历史概述可以用以下图示表示：'
- en: '![](img/dac8af45-ddb4-4573-bf79-0c71571f4115.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dac8af45-ddb4-4573-bf79-0c71571f4115.png)'
- en: 'Figure 6: Project Reactor history'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图6：Project Reactor历史
- en: The figure above shows the major releases of Project Reactor. The project kick
    started in the year 2013 (1.x version) and the major release of 3.x was released
    in the year 2016\. As of writing this book, the core module of the framework is
    at version 3.1.8.RELEASE.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 上图显示了Project Reactor的主要发布版本。该项目于2013年启动（1.x版本），3.x的主要发布版本于2016年发布。截至撰写本书时，该框架的核心模块版本为3.1.8.RELEASE。
- en: Now that we have a brief understanding of Spring Framework and its connection
    with reactive programming, lets dive a bit deep into Project Reactor.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对Spring Framework及其与响应式编程的关系有了简要的了解，让我们深入了解一下Project Reactor。
- en: Modules in Reactor
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reactor中的模块
- en: With the latest release of Reactor 3.0 the project has been structured with
    modularity in mind. Reactor 3.0 consists of four major components namely Core,
    IO, Addons, and Reactive Streams Commons.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Reactor 3.0的最新发布，该项目已经考虑到了模块化。Reactor 3.0由四个主要组件组成，分别是Core、IO、Addons和Reactive
    Streams Commons。
- en: '**Reactor Core** ([https://github.com/reactor/reactor-core](https://github.com/reactor/reactor-core)):
    The main library within Reactor. It provides foundational, non-blocking JVM-compliant
    Reactive Streams Specification implementations. It also contains code for Reactor
    types, such as `Flux` and `Mono`.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Reactor Core** ([https://github.com/reactor/reactor-core](https://github.com/reactor/reactor-core))：Reactor中的主要库。它提供了基础的、非阻塞的JVM兼容的Reactive
    Streams规范实现。它还包含了Reactor类型的代码，如`Flux`和`Mono`。'
- en: '**Reactor IO** ([https://github.com/reactor/reactor-ipc](https://github.com/reactor/reactor-ipc)):
    It contains backpressure-ready components that can be used to encode, decode,
    send (unicast, multicast, or request/response), and then serve connections. It
    also contains support for **Kafka** ([https://kafka.apache.org/](https://kafka.apache.org/)),
    **Netty** ([http://netty.io/](http://netty.io/)), and **Aeron** ([https://github.com/real-logic/aeron](https://github.com/real-logic/aeron)).'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Reactor IO** ([https://github.com/reactor/reactor-ipc](https://github.com/reactor/reactor-ipc))：它包含了支持背压的组件，可用于编码、解码、发送（单播、多播或请求/响应），然后服务连接。它还包含了对**Kafka**
    ([https://kafka.apache.org/](https://kafka.apache.org/))、**Netty** ([http://netty.io/](http://netty.io/))和**Aeron**
    ([https://github.com/real-logic/aeron](https://github.com/real-logic/aeron))的支持。'
- en: '**Addons** ([https://github.com/reactor/reactor-addons](https://github.com/reactor/reactor-addons)):
    As the name suggests, these are add-ons that consist of three components:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Addons** ([https://github.com/reactor/reactor-addons](https://github.com/reactor/reactor-addons))：顾名思义，这些是由三个组件组成的附加组件：'
- en: '`reactor-adapter`: Contains a bridge to RxJava 1 or 2 types, such as Observable,
    Completable, Single, Maybe, and Mono/Flux back and forth.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reactor-adapter`：包含了与RxJava 1或2类型的桥接，如Observable、Completable、Single、Maybe和Mono/Flux来回转换。'
- en: '`reactor-logback`: Supports logback over asynchronous reactor-core processors.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reactor-logback`：支持异步reactor-core处理器上的logback。'
- en: '`reactor-extra`: Contains more operations for `Flux`, which include mathematical
    operations such as sum and average.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reactor-extra`：包含了`Flux`的更多操作，包括求和和平均值等数学运算。'
- en: '**Reactive Streams Commons **([https://github.com/reactor/reactive-streams-commons](https://github.com/reactor/reactive-streams-commons)):
    A collaboration experiment project between Spring''s Reactor and RxJava. It also
    contains Reactor-Streams-compliant operators that both projects implement. Issues
    fixed on one project are also fixed on the other.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Reactive Streams Commons** ([https://github.com/reactor/reactive-streams-commons](https://github.com/reactor/reactive-streams-commons))：Spring的Reactor和RxJava之间的协作实验项目。它还包含了两个项目都实现的Reactor-Streams兼容操作符。在一个项目上修复的问题也会在另一个项目上修复。'
- en: Reactive types in Reactor Core
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reactor Core中的响应式类型
- en: Reactor provided two reactive types, `Flux` and `Mono`, that implement Rx extensively.
    They can be represented as a timeline in which elements are sequenced according
    to how they arrived. It is important that you get the hang of these two types.
    Let's do that in the following subsections.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor提供了两种响应式类型，`Flux`和`Mono`，它们广泛实现了Rx。它们可以被表示为一个时间线，其中元素按照它们到达的顺序进行排序。重要的是要掌握这两种类型。让我们在以下小节中做到这一点。
- en: The Flux reative type
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flux响应式类型
- en: 'A Reactive Streams publisher with Rx operators that emits *0* to *N* elements,
    and then completes (successfully or with an error). For more information, you
    can check the following link: [https://projectreactor.io](https://projectreactor.io)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有Rx操作符的Reactive Streams发布者，它会发出*0*到*N*个元素，然后完成（成功或出现错误）。更多信息，请查看以下链接：[https://projectreactor.io](https://projectreactor.io)
- en: '`Flux<T>` is a `Publisher<T>` with basic flow operations and supports *0.*.*n*
    elements.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flux<T>`是一个带有基本流操作的`Publisher<T>`，支持*0.*.*n*个元素。'
- en: 'The definition of `Flux` is as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flux`的定义如下：'
- en: '[PRE4]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following figure, as depicted in the `Flux` documentation, explains the
    working of `Flux` in more detail:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如`Flux`文档中所示的以下图示更详细地解释了`Flux`的工作原理：
- en: '![](img/5e2ee3fa-4291-4813-9457-d4404fec9a26.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5e2ee3fa-4291-4813-9457-d4404fec9a26.png)'
- en: 'Figure 7: Working of Flux'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图7：`Flux`的工作原理
- en: Flux support is in Spring 5 and a variety of other important modules, including
    Spring Security. Operators acting on `Flux` would create new publishers.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Flux支持在Spring 5和其他重要模块中，包括Spring Security。对`Flux`进行操作将创建新的发布者。
- en: 'Please refer to the Reactor Flux documentation for more information: [https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html).'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅Reactor Flux文档：[https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html)。
- en: 'Now, let''s have a look at some code examples where usage of `Flux` is shown:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一些代码示例，展示了`Flux`的用法：
- en: 'Creating empty `Flux`:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建空的`Flux`：
- en: '[PRE5]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Creating `Flux` with items in it:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建带有项目的`Flux`：
- en: '[PRE6]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Creating `Flux` from an existing list:'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从现有列表创建`Flux`：
- en: '[PRE7]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Creating `Flux` that emits every `x` milliseconds in an infinite manner:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建以无限方式每隔`x`毫秒发出的`Flux`：
- en: '[PRE8]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Creating `Flux` that emits an exception:'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建发出异常的`Flux`：
- en: '[PRE9]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The Mono reactive type
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Mono`反应式类型'
- en: A Reactive Streams Publisher with basic Rx operators that completes successfully
    by emitting an element, or with an error.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有基本Rx运算符的Reactive Streams Publisher，通过发出一个元素或出现错误来成功完成。
- en: – Mono JavaDoc
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '- Mono JavaDoc'
- en: '`Mono<T>` is a `Publisher<T>` that supports *0*..*1* elements.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mono<T>`是支持*0*..*1*个元素的`Publisher<T>`。'
- en: 'The definition of `Mono` is as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mono`的定义如下：'
- en: '[PRE10]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As detailed in the documentation, the following figure shows the workings of
    `Mono`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如文档中所述，以下图显示了`Mono`的工作原理：
- en: '![](img/fcab5a6e-6e9e-40b6-a689-b0d0abe4ed0a.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fcab5a6e-6e9e-40b6-a689-b0d0abe4ed0a.png)'
- en: 'Figure 08: Working of Mono'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图08：`Mono`的工作原理
- en: '`Mono<Void>` should be used for a `Publisher` that completes with no value.
    The documentation explains each method and how it works using a marble diagram,
    which is self-explanatory. Again, this type is also supported by Spring 5 and
    Spring Security.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mono<Void>`应该用于没有值完成的`Publisher`。文档使用了一个自解释的大理石图解释了每种方法及其工作原理。同样，这种类型也受到Spring
    5和Spring Security的支持。'
- en: 'JavaDoc for `Mono` contains more information: [https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mono`的JavaDoc包含更多信息：[https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html)。'
- en: 'Let''s have a look at some examples:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些例子：
- en: Creating empty `Mono:`
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建空的`Mono`：
- en: '[PRE11]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Creating `Mono` with a value in it:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建带有值的`Mono`：
- en: '[PRE12]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Creating `Mono` that emits an exception:'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建发出异常的`Mono`：
- en: '[PRE13]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Data stream types
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据流类型
- en: 'Broadly, data streams can be categorized into two types:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 广义上，数据流可以分为两种类型：
- en: '**Cold data streams**: There are a number of names by which this is known,
    such as **Cold Source**, **Cold Observable**, and **Cold Publisher**. These emit
    data only when one subscribes to it and because of this, all messages produced
    from start are delivered to the subscriber. If a new `Subscriber` connects to
    it, the messages are replayed in ascending order and this is same for any new
    `Subscriber`. The `Subscriber` also has a provision to dictate the rate at which
    the `Publisher` should emit messages. These data streams are good candidates for
    applying reactive backpressure (`request(n)`), for example, a database cursor
    or file stream (reading a file).'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冷数据流**：这有许多名称，比如**冷源**，**冷可观察对象**和**冷发布者**。它们只在有人订阅时才发出数据，因此从开始产生的所有消息都会传递给订阅者。如果新的`Subscriber`连接到它，消息将按升序重放，对于任何新的`Subscriber`也是如此。`Subscriber`还可以规定`Publisher`应该发出消息的速率。这些数据流是应用反应式背压（`request(n)`）的良好候选者，例如数据库游标或文件流（读取文件）。'
- en: '**Hot data streams**: Again, this has a number of different names, such as
    **Hot Source**, **Hot Observable**, and **Hot Publisher**. These emit data irrespective
    of any subscribers connected. When a new `Subscriber` connects, it just emits
    the messages from that point in time and cannot replay messages from the start.
    These cannot pause message emissions, so an alternate mechanism is required to
    control flow, such as a buffer. Examples of this stream include mouse events and
    stock prices.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**热数据流**：这又有许多不同的名称，比如**热源**，**热可观察对象**和**热发布者**。它们发出数据，而不管是否连接了任何订阅者。当新的`Subscriber`连接时，它只会从那个时间点开始发出消息，并且不能重放从头开始的消息。它们不能暂停消息的发出，因此需要另一种机制来控制流量，比如缓冲区。这种流的例子包括鼠标事件和股票价格。'
- en: It's important to note that operators on a stream can change their property,
    going from cold to hot and vice versa. Also, there are times when a merge between
    hot and cold can happen and their properties change.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，流上的运算符可以改变它们的属性，从冷到热，反之亦然。此外，有时会发生热和冷之间的合并，它们的属性也会改变。
- en: Reactor and RxJava
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reactor和RxJava
- en: One of the main aspects between the two is RxJava 2.x which is Java 6+ compatible,
    but Reactor is Java 8+ compatible. If you are going with Spring 5, I urge you
    to use a Reactor. If you are comfortable with RxJava 2.x, there is no need to
    migrate to Reactor. Reactor is an implementation of the Reactive Streams Specification,
    so you can remain agnostic of what the underlying implementation is.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 两者之间的主要区别之一是RxJava 2.x兼容Java 6+，而Reactor兼容Java 8+。如果您选择Spring 5，我建议您使用Reactor。如果您对RxJava
    2.x感到满意，就没有必要迁移到Reactor。Reactor是Reactive Streams规范的实现，因此您可以保持对底层实现的不可知性。
- en: Reactive Web Application
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式Web应用程序
- en: Spring 5 has brought reactive concepts into the world of web application development
    with the inclusion of a number of important components. Let's cover them here.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 5将反应式概念引入了Web应用程序开发的世界，并包括了许多重要组件。让我们在这里介绍它们。
- en: Spring WebFlux
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring WebFlux
- en: Spring 5 has a reactive stack baked into it, using which, web applications can
    be built on top of Reactive Streams capable of running on new non-blocking servers,
    such as Netty, Undertow, and Servlet containers, running on Servlet specifications
    greater than 3.1.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 5内置了一个响应式堆栈，使用它可以构建基于Reactive Streams的Web应用程序，可以在新的非阻塞服务器上运行，例如Netty、Undertow和Servlet容器，运行在大于3.1的Servlet规范上。
- en: Existing web application frameworks, such as Spring MVC, are built for Servlet
    containers from the outset, but Spring 5 brings with it a new web application
    framework, Spring WebFlux, created with reactive in mind. We have a dedicated
    chapter in this book covering Spring WebFlux ([Chapter 5](df488f9c-24a7-4d0f-ac82-1d126a391fcc.xhtml),
    *Integrating with Spring WebFlux*), so I won't be delving deep into this here.
    It's good to know that Spring 5 has serious thoughts on reactive and that it is
    reflected clearly in all these new additions.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的Web应用程序框架，如Spring MVC，从一开始就是为Servlet容器构建的，但是Spring 5带来了一个新的Web应用程序框架，Spring
    WebFlux，专为响应式而创建。本书中有一个专门的章节涵盖了Spring WebFlux（[第5章](df488f9c-24a7-4d0f-ac82-1d126a391fcc.xhtml)，*与Spring
    WebFlux集成*），所以我不会在这里深入讨论。值得知道的是，Spring 5对响应式有着严肃的思考，并且这在所有这些新的添加中都得到了清晰的体现。
- en: Spring WebFlux requires Reactor to be included as one of its core dependencies.
    But, as always, it does allow you to switch implementations quite easily, if needs
    be.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux需要将Reactor作为其核心依赖之一。但是，与往常一样，如果需要，它确实可以让您轻松切换实现。
- en: Reactive Spring Web
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reactive Spring Web
- en: The **Spring Web Module** ([https://github.com/spring-projects/spring-framework/tree/master/spring-web](https://github.com/spring-projects/spring-framework/tree/master/spring-web))
    has many foundational pieces used to build reactive web applications. It allows
    you to do operations pertaining to the server and the client.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring Web模块**（[https://github.com/spring-projects/spring-framework/tree/master/spring-web](https://github.com/spring-projects/spring-framework/tree/master/spring-web)）有许多用于构建响应式Web应用程序的基础组件。它允许您执行与服务器和客户端相关的操作。'
- en: 'The capabilities that it provides on the server are divided into two areas:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 它在服务器端提供的功能分为两个方面：
- en: '**HTTP**: Contained within the `org.springframework.http` package in `spring-web`
    and contains various APIs for HTTP request handling for supported servers'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP**：包含在`spring-web`的`org.springframework.http`包中，包含用于受支持服务器的HTTP请求处理的各种API'
- en: '**Web**: Contained within the `org.springframework.web` package in `spring-web`
    and contains various APIs for request processing'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web**：包含在`spring-web`的`org.springframework.web`包中，包含用于请求处理的各种API'
- en: This module also contains message codecs that work on the client and aid in
    encoding and decoding requests and responses. These codecs can also be used on
    the server.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块还包含在客户端上工作的消息编解码器，用于对请求和响应进行编码和解码。这些编解码器也可以在服务器上使用。
- en: WebClient
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebClient
- en: The interface `org.springframework.web.reactive.function.client.WebClient` is
    a reactive web client introduced in Spring 5 that can be used to perform web requests.
    Similarly there is `org.springframework.test.web.reactive.server.WebTestClient`
    interface, which is a special `WebClient`—used to write unit tests within your
    application. `WebClient` is the reactive version of `RestTemplate`, which works
    over the HTTP/1.1 protocol. They are packaged as part of the `spring-webflux`
    module.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`org.springframework.web.reactive.function.client.WebClient`接口是Spring 5中引入的一种响应式Web客户端，可用于执行Web请求。类似地，还有`org.springframework.test.web.reactive.server.WebTestClient`接口，它是一个特殊的`WebClient`，用于在应用程序中编写单元测试。`WebClient`是`RestTemplate`的响应式版本，它使用HTTP/1.1协议。它们作为`spring-webflux`模块的一部分打包。'
- en: WebSockets
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebSockets
- en: The `spring-webflux` module also has reactive WebSocket implementation. **WebSocket**
    allows us to establish a two-way connection between the client and server, and
    usage of this is becoming more mainstream in new-generation applications.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`spring-webflux`模块还具有响应式WebSocket实现。**WebSocket**允许我们在客户端和服务器之间建立双向连接，这种用法在新一代应用程序中变得越来越普遍。'
- en: Application security
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序安全
- en: '**Application security** is composed of various processes put in place to find,
    fix, and prevent security vulnerabilities in an application.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序安全**由各种流程组成，旨在发现、修复和防止应用程序中的安全漏洞。'
- en: We are living in the world of **Development + Operations** (**DevOps**) where
    we bring engineering and operational staff together. DevOps advocates automation
    and monitoring at all levels. With security becoming a very important consideration,
    a new term, **DevSecOps**, is becoming prominent—this is where we bring in security
    as a first-class citizen.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生活在**开发+运维**（**DevOps**）的世界中，在这里我们将工程和运营人员聚集在一起。DevOps倡导在各个层面进行自动化和监控。随着安全变得非常重要，一个新术语**DevSecOps**变得突出——这是我们将安全作为一等公民的地方。
- en: For an application, security comes under the nonfunctional requirements. Due
    to its importance in an application, most organizations have dedicated teams that
    test applications for potential security flaws. It's a very important aspect to
    be considered, as in this modern world, a security breach can seriously ruin an
    organization's brand.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个应用程序，安全属于非功能性要求。由于它在应用程序中的重要性，大多数组织都有专门的团队来测试潜在的安全漏洞。这是一个非常重要的方面需要考虑，因为在这个现代世界中，安全漏洞可能严重破坏组织的品牌。
- en: Security is a very broad term and encompasses many aspects. In this book, we
    will look at some of the fundamental security concerns using the Spring Framework
    module—Spring Security. After covering some of the core security concerns, we
    will also look at some of the low-level security problems and how Spring Security
    can help deal with them.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 安全是一个非常广泛的术语，涵盖了许多方面。在本书中，我们将使用Spring Framework模块Spring Security来查看一些基本的安全问题。在涵盖了一些核心安全问题之后，我们还将看一些低级安全问题以及Spring
    Security如何帮助解决这些问题。
- en: Since we will be focusing on Spring, we will be delving deep into security concerns
    with respect to a Java web application development.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将专注于Spring，我们将深入探讨与Java Web应用程序开发相关的安全问题。
- en: Spring Security
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security
- en: Spring Security is a powerful and highly customizable authentication and access-control
    framework. It is the de facto standard for securing Spring-based applications.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security是一个功能强大且高度可定制的身份验证和访问控制框架。它是保护基于Spring的应用程序的事实标准。
- en: – Spring by Pivotal
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: – Spring by Pivotal
- en: Spring Security 5 is the new version of the framework and will be the main focus
    of this book. Spring Security enables you to take care of authentication and authorization
    of your application in all aspects. It also has top-level projects to deal specifically
    with a number of authentication mechanisms, such as **LDAP**, **OAuth**, and **SAML**.
    Spring Security also gives you enough mechanisms to deal with common security
    attacks, such as **Session Fixation**, **Clickjacking**, and **Cross-Site Request
    Forgery**. Moreover, it has very good integration with a number of Spring Framework
    projects, such as Spring MVC, Spring WebFlux, Spring Data, Spring Integration,
    and Spring Boot.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 5是该框架的新版本，也是本书的主要关注点。Spring Security使您能够全面处理应用程序的身份验证和授权。它还有顶级项目，专门处理多种身份验证机制，如**LDAP**、**OAuth**和**SAML**。Spring
    Security还提供了足够的机制来处理常见的安全攻击，如**会话固定**、**点击劫持**和**跨站点请求伪造**。此外，它与许多Spring Framework项目（如Spring
    MVC、Spring WebFlux、Spring Data、Spring Integration和Spring Boot）有很好的集成。
- en: Spring Security terminologies
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security术语
- en: 'It''s important to understand some of the most important Spring Security terminologies.
    Let''s look at some of them:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 了解一些最重要的Spring Security术语非常重要。让我们来看看其中一些：
- en: '**Principal**: Any user, device, or system (application) that would like to
    interact with your application.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主体**：希望与您的应用程序交互的任何用户、设备或系统（应用程序）。'
- en: '**Authentication**: A process by which your application makes sure that the
    principal is who they claim to be.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份验证**：确保主体是其所声称的过程'
- en: '**Credentials**: When a principal tries to interact with your application,
    the authentication process kicks in and challenges the principal to pass on some
    values. One such example is a username/password combination and these values are
    called credentials. The authentication process validates the principal''s passed-in
    credentials against a data store and replies back with the appropriate result.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**凭据**：当主体尝试与您的应用程序交互时，身份验证过程开始并挑战主体传递一些值。一个例子是用户名/密码组合，这些值称为凭据。身份验证过程验证主体传递的凭据与数据存储中的凭据是否匹配，并回复适当的结果。'
- en: '**Authorization**: After successful authentication, the principal is checked
    again for actions that it can perform on your application. This process of checking
    rights for a principal and then granting necessary permissions is called authorization.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**：成功认证后，将再次检查主体在应用程序上可以执行的操作。这个检查主体权限并授予必要权限的过程称为授权。'
- en: '**Secured item/resource**: The item or resource that is marked as secured and
    requires the principal (user) to successfully complete both authentication and
    authorization.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受保护的项目/资源**：标记为受保护并要求主体（用户）成功完成身份验证和授权的项目或资源。'
- en: '**GrantedAuthority**: A Spring Security object (`org.springframework.security.core.GrantedAuthority`
    interface) that contains/holds permissions/access-right details of a principal.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GrantedAuthority**：Spring Security对象（`org.springframework.security.core.GrantedAuthority`接口），包含/保存主体的权限/访问权限详细信息。'
- en: '**SecurityContext**: A Spring Security object that holds a principal''s authentication
    details.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SecurityContext**：Spring Security对象，保存主体的身份验证详细信息。'
- en: Spring Security's core features
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security的核心功能
- en: Spring Security provides a number of security features for your application.
    The two main features for which Spring Security is well-known are it's **support
    for a variety of authentication** and **authorization methodologies**. In this
    section, we will delve deeply into these core features in more detail.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security为您的应用程序提供了许多安全功能。Spring Security以其对各种身份验证和授权方法的支持而闻名。在本节中，我们将更详细地深入探讨这些核心功能。
- en: Authentication
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证
- en: Spring Security provides a number of approaches by which your application can
    authenticate. It also allows you to write a custom authentication mechanism if
    these provided default approaches don't fit your requirements. Because of this
    extensibility, you can even use the legacy application against which authentication
    can be done. The book has a dedicated chapters ([Chapter 3](69913c59-1186-44b2-8707-dceca721e206.xhtml), *Authentication
    Using SAML, LDAP, and OAuth/OIDC* and [Chapter 4](5bccc5ce-c067-46ee-a91c-02ee11dd9fc7.xhtml),
    *Authentication Using CAS and JAAS*) where we will cover various authentications
    mechanisms, such as OAuth, LDAP, and SAML, in more detail.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security提供了多种方法，您的应用程序可以进行身份验证。它还允许您编写自定义身份验证机制，如果这些提供的默认方法不符合您的要求。由于这种可扩展性，甚至可以使用旧应用程序进行身份验证。本书有专门的章节（[第3章](69913c59-1186-44b2-8707-dceca721e206.xhtml)、*使用SAML、LDAP和OAuth/OIDC进行身份验证*和[第4章](5bccc5ce-c067-46ee-a91c-02ee11dd9fc7.xhtml)、*使用CAS和JAAS进行身份验证*），我们将更详细地介绍各种身份验证机制，如OAuth、LDAP和SAML。
- en: Authorization
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权
- en: 'Spring Security allows you, as an application developer, many choices by which
    you can authorize user''s access to various parts of your application. Here are
    some of the approaches:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security允许您作为应用程序开发人员选择多种方式来授权用户访问应用程序的各个部分。以下是一些方法：
- en: '**Web URL**: Based on a URL or URL pattern, you can control access'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web URL**：基于URL或URL模式，您可以控制访问'
- en: '**Method invocation**: Even a method in a Java Bean can be access-controlled
    if needs be'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法调用**：如果需要，甚至可以对Java Bean中的方法进行访问控制'
- en: '**Domain instance**: One of the very cool features is to control access to
    specific data by having access control of certain needed domain objects within
    your application'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域实例**：通过在应用程序中控制对特定数据的访问，可以控制对某些需要的领域对象的访问控制。'
- en: '**Web service**: Allows you to secure exposed web services in your application'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web服务**：允许您保护应用程序中暴露的Web服务'
- en: In the next chapter, we will get into these aspects in a bit more detail with
    more code snippets.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更详细地讨论这些方面，并提供更多的代码片段。
- en: Spring Security 5's new features
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security 5的新功能
- en: 'Spring Security 5 provides a number of new features along with support for
    Spring 5\. Some of the important new features introduced as part of this release
    are:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 5提供了许多新功能，同时支持Spring 5。作为此版本的一部分引入的一些重要新功能包括：
- en: '**Support for OAuth 2.0 and OpenID Connect (OIDC) 1.0**: Allows users to log
    in to your application using their existing OAuth provider (for example, GitHub)
    or OIDC provider (for example, Google). OAuth is implemented using Authorization
    Code Flow. We will delve deep into this in subsequent chapters.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持OAuth 2.0和OpenID Connect（OIDC）1.0**：允许用户使用其现有的OAuth提供程序（例如GitHub）或OIDC提供程序（例如Google）登录到您的应用程序。OAuth是使用授权码流实现的。我们将在后续章节中深入探讨这个问题。'
- en: '**Reactive support**: Spring 5 introduced a new reactive web application framework—Spring
    WebFlux. Spring Security made sure that this web application framework is fully
    supported in all aspects (authentication and authorization) using reactive concepts.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应式支持**：Spring 5引入了一个新的响应式Web应用程序框架——Spring WebFlux。Spring Security确保在所有方面（身份验证和授权）完全支持这个Web应用程序框架，使用响应式概念。'
- en: '**Improved password encoding**: The introduction of the password-encoding delegation
    allows usage of more than one algorithm for encoding various passwords. The way
    Spring identifies the algorithm is by reading the prefix of the encoded password,
    which contains the algorithm used to encode the password. The format is `{algorithm}encoded_password`.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改进的密码编码**：引入密码编码委托允许使用多种算法对各种密码进行编码。Spring识别算法的方式是通过读取编码密码的前缀，其中包含用于编码密码的算法。格式为`{algorithm}encoded_password`。'
- en: Working of Spring Security
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security的工作
- en: In this section, we will look at how Spring Security works. We will first explain
    the core concepts and then look at various classes the request goes through to
    perform security.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看Spring Security的工作原理。我们将首先解释核心概念，然后看看请求经过的各种类来执行安全性。
- en: Servlet Filter
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Servlet过滤器
- en: It's quite important to understand Servlet Filter so you can understand Spring
    Security internals. The following figure clearly explains a Servlet Filter in
    action. It comes before the request reaches the actual resource and also before
    the response if sent back to the consumer. It's a pluggable component that can
    be introduced at any time with configuration in the web configuration file (`web.xml`).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 了解Servlet过滤器非常重要，这样您就可以了解Spring Security的内部工作。下图清楚地解释了Servlet过滤器的工作原理。它在请求到达实际资源之前以及在响应返回给消费者之前起作用。它是一个可插拔的组件，可以随时在Web配置文件（`web.xml`）中进行配置。
- en: '![](img/88799858-7e56-4fe9-92b4-039eb75ddc96.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88799858-7e56-4fe9-92b4-039eb75ddc96.png)'
- en: 'Figure 9: Working of Servlet Filter'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图9：Servlet过滤器的工作
- en: Filter Chain
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤器链
- en: You can embed any number of Servlet Filters before they reach the actual resource.
    The filters are fired according to the order in which they are declared in `web.xml`.
    This chaining of the Servlet Filter is called **Filter Chain**. Spring Security
    works on a number of Servlet Filters arranged as a Filter Chain, each filter performing
    a single responsibility, then handing it over to the next one, and so on. Most
    of the built-in filters are good enough for most applications. If needs be, you
    can write your own filters and place them wherever you want them to be executed.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在到达实际资源之前嵌入任意数量的Servlet过滤器。根据它们在`web.xml`中声明的顺序触发过滤器。这种Servlet过滤器的链接称为**过滤器链**。Spring
    Security依赖于一系列作为过滤器链排列的Servlet过滤器，每个过滤器执行单一的责任，然后将其交给下一个过滤器，依此类推。大多数内置过滤器对大多数应用程序来说已经足够好了。如果需要，您可以编写自己的过滤器，并将它们放在希望它们执行的位置。
- en: Security Interceptor (DelegatingFilterProxy)
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全拦截器（DelegatingFilterProxy）
- en: 'When any request reaches an application that is secured using Spring Security,
    there is a gate the request goes through. This interceptor does all the magic
    and if things don''t look good, it errors out and goes back to the caller, as
    shown in the following figure:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何请求到达使用Spring Security进行保护的应用程序时，请求会经过一个门。这个拦截器完成所有的魔术，如果情况不妙，它会出错并返回给调用者，如下图所示：
- en: '![](img/023819ce-1ee5-40a6-9366-716cf9c6dcb9.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/023819ce-1ee5-40a6-9366-716cf9c6dcb9.png)'
- en: 'Figure 10: Working of Security Interceptor'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图10：安全拦截器的工作
- en: 'The Security Interceptor makes sure that, according to various security configurations
    set up for your application, it delegates the work to appropriate parties and
    makes sure that everyone is happy before actually reaching the resource requested
    by the caller. To do the actual job, the Security Interceptor employs a number
    of managers, each entrusted to do a single job. The following figure lists some
    of the important managers the Security Interceptor works with to perform the function:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 安全拦截器确保根据为应用程序设置的各种安全配置，将工作委托给适当的方，并确保在实际到达调用者请求的资源之前，每个人都满意。为了执行实际工作，安全拦截器使用了许多管理器，每个管理器都负责执行单一的工作。下图列出了安全拦截器与之合作执行功能的一些重要管理器：
- en: '![](img/be0f39f5-a970-440b-9014-9cc92ce1a762.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be0f39f5-a970-440b-9014-9cc92ce1a762.png)'
- en: 'Figure 11: Security Interceptor and associated managers'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图11：安全拦截器和相关管理器
- en: In Spring Security, the Security Interceptor is accomplished by `DelegatingFilterProxy`.
    For any request that reaches the web application, this proxy makes sure to delegate
    the request to Spring Security, and when things go well, it makes sure that the
    request is taken to the right resource within the web application.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Security中，安全拦截器由`DelegatingFilterProxy`完成。对于到达Web应用程序的任何请求，此代理确保将请求委托给Spring
    Security，并且当事情顺利进行时，它确保将请求传递到Web应用程序中的正确资源。
- en: '`DelegatingFilterProxy` is a Servlet Filter that has to be configured in your
    `web.xml` file, which then delegates to a Spring-managed bean (`@Bean`) that implements
    a `ServletFilter` interface.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`DelegatingFilterProxy`是一个Servlet过滤器，必须在您的`web.xml`文件中进行配置，然后委托给一个实现`ServletFilter`接口的Spring管理的bean（`@Bean`）。'
- en: 'The following code snippet shows how to configure `DelegatingProxyFilter` in
    `web.xml`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了如何在`web.xml`中配置`DelegatingProxyFilter`：
- en: '[PRE14]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, all the requests to the web application (`/* mapping`)
    would go through the `DelegatingProxyFilter` filter. It's important to note that
    the name of this filter should be `springSecurityFilterChain` as Spring Security
    looks for this default filter name to configure itself. The proxy filter just
    passes/delegates the control to a bean named `springSecuirtyFilterChain`. If you
    are using the default Spring Security setup, the request would then be received
    by `FilterChainProxy`. `FilterChainProxy` is responsible for passing the request
    through the various Servlet Filters configured as part of Spring Security. The `springSecuirtyFilterChain` bean
    need not be explicitly declared, instead, it is taken care of by the framework
    which is transparent to the developer.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，所有对Web应用程序（`/* mapping`）的请求都将通过`DelegatingProxyFilter`过滤器进行。重要的是要注意，这个过滤器的名称应该是`springSecurityFilterChain`，因为Spring
    Security会寻找这个默认的过滤器名称来配置自己。代理过滤器只是将控制权传递/委托给一个名为`springSecuirtyFilterChain`的bean。如果您正在使用默认的Spring
    Security设置，请求将被`FilterChainProxy`接收。`FilterChainProxy`负责将请求通过配置为Spring Security的一部分的各种Servlet过滤器传递。`springSecuirtyFilterChain`
    bean不需要显式声明，而是由框架处理，对开发人员透明。
- en: 'Now that we''ve looked at all the core concepts of Spring Security, let''s
    come back to the working of Spring Security as pictorially represented in the
    following diagram. It contains two important security aspects –Authentication
    and Authorization:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过了Spring Security的所有核心概念，让我们回到以下图表中以图形方式表示的Spring Security的工作方式。它包含两个重要的安全方面-身份验证和授权：
- en: '![](img/ad01cc0a-91da-4c35-9cf5-dd8cf2722f0a.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ad01cc0a-91da-4c35-9cf5-dd8cf2722f0a.png)'
- en: 'Figure 12: Working of Spring Security'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图12：Spring Security的工作方式
- en: The request from the caller reaches `DelegatingFilterProxy`, which delegates
    to `FilterChainProxy` (Spring Bean), which in turn passes the request through
    a number of filters, and after successful execution, grants access to the secured
    resource the caller has asked for.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 来自调用者的请求到达`DelegatingFilterProxy`，它委托给`FilterChainProxy`（Spring Bean），后者通过多个过滤器传递请求，并在成功执行后，授予调用者对所请求的受保护资源的访问权限。
- en: 'For the complete list of Servlet Filters and their functions, I urge you to
    go through the Spring Security reference: [https://docs.spring.io/spring-security/site/docs/current/reference/html/security-filter-chain.html](https://docs.spring.io/spring-security/site/docs/current/reference/html/security-filter-chain.html).'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Servlet过滤器及其功能的完整列表，请参阅Spring Security参考文档：[https://docs.spring.io/spring-security/site/docs/current/reference/html/security-filter-chain.html](https://docs.spring.io/spring-security/site/docs/current/reference/html/security-filter-chain.html)。
- en: 'With all these details, the following figure sums up how Spring Security takes
    care of Authentication and Authorization for your web application:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 有了所有这些细节，下图总结了Spring Security如何为您的Web应用程序处理身份验证和授权：
- en: '![](img/ef2f262d-a6e6-4e88-9131-9f321aa9bf14.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ef2f262d-a6e6-4e88-9131-9f321aa9bf14.png)'
- en: 'Figure 13: Authentication and Authorization in Spring Security using a database'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图13：Spring Security在使用数据库进行身份验证和授权
- en: When a caller sends a request to a web application protected by Spring Security,
    it first goes through the Security Interceptor managers, such as **Authentication
    Manager** (responsible for authentication) and **Access Decision Manager** (responsible
    for authorization), and after executing these successfully, gives the caller access
    to the secured resource.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用者向受Spring Security保护的Web应用程序发送请求时，首先经过安全拦截器管理器，如**身份验证管理器**（负责身份验证）和**访问决策管理器**（负责授权），并在成功执行这些操作后，允许调用者访问受保护的资源。
- en: For reactive applications, these concepts are all valid. There are equivalent
    reactive classes and the way we code is the only thing that changes. These are
    easy to understand and implement.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 对于响应式应用程序，这些概念都是有效的。有等效的响应式类，我们编码的方式是唯一改变的。这些都很容易理解和实现。
- en: In [Chapter 2](e43a2e26-5b28-4d37-a7f8-d3c992a07bc2.xhtml), *Deep Diving into
    Spring Security*, we will cover Authentication, and in [Chapter 3](69913c59-1186-44b2-8707-dceca721e206.xhtml), *Authentication
    Using SAML, LDAP, and OAuth/OIDC*, we will cover Authorization in detail and delve
    a bit more deeply into its internals.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](e43a2e26-5b28-4d37-a7f8-d3c992a07bc2.xhtml)中，*深入了解Spring Security*，我们将介绍身份验证，在[第3章](69913c59-1186-44b2-8707-dceca721e206.xhtml)中，*使用SAML、LDAP和OAuth/OIDC进行身份验证*，我们将详细介绍授权，并深入了解其内部情况。
- en: Core Spring Security modules
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心Spring Security模块
- en: 'In Spring Framework, Spring Security is a top-level project. Within the Spring
    Security project ([https://github.com/spring-projects/spring-security](https://github.com/spring-projects/spring-security)),
    there are a number of sub-modules:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Framework中，Spring Security是一个顶级项目。在Spring Security项目（[https://github.com/spring-projects/spring-security](https://github.com/spring-projects/spring-security)）中，有许多子模块：
- en: '**Core** (`spring-security-core`): Spring security''s core classes and interfaces
    on authentication and access control reside here.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Core**（`spring-security-core`）：Spring安全的核心类和接口在这里进行身份验证和访问控制。'
- en: '**Remoting** (`spring-security-remoting`): In case you need Spring Remoting,
    this is the module with the necessary classes.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Remoting**（`spring-security-remoting`）：如果您需要Spring Remoting，这是具有必要类的模块。'
- en: '**Aspect** (`spring-security-aspects`): **Aspect-Oriented Programming** (**AOP**)
    support within Spring Security.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Aspect**（`spring-security-aspects`）：Spring Security内的**面向方面的编程**（**AOP**）支持。'
- en: '**Config** (`spring-security-config`): Provides XML and Java configuration
    support.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Config**（`spring-security-config`）：提供XML和Java配置支持。'
- en: '**Crypto** (`spring-security-crypto`): Contains cryptography support.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码学（`spring-security-crypto`）：包含密码学支持。
- en: '**Data** (`spring-security-data`): Integration with Spring Data.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据（`spring-security-data`）：与Spring Data集成。
- en: '**Messaging** (`spring-security-messaging`)'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息传递（`spring-security-messaging`）
- en: '**OAuth2**: Support for OAuth 2.x support within Spring Security:'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth2：在Spring Security中支持OAuth 2.x。
- en: '**Core** (`spring-security-oauth2-core`)'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心（`spring-security-oauth2-core`）
- en: '**Client** (`spring-security-oauth2-client`)'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端（`spring-security-oauth2-client`）
- en: '**JOSE** (`spring-security-oauth2-jose`)'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JOSE（`spring-security-oauth2-jose`）
- en: '**OpenID** (`spring-security-openid`): OpenID web-authentication support.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenID（`spring-security-openid`）：OpenID Web身份验证支持。
- en: '**CAS** (`spring-security-cas`): CAS (Central Authentication Service) client
    integration.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CAS（`spring-security-cas`）：CAS（中央认证服务）客户端集成。
- en: '**TagLib** (`spring-security-taglibs`): Various tag libraries regarding Spring
    Security.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TagLib（`spring-security-taglibs`）：关于Spring Security的各种标签库。
- en: '**Test** (`spring-security-test`): Testing support.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试（`spring-security-test`）：测试支持。
- en: '**Web** (`spring-security-web`): Contains web security infrastructure code,
    such as various filters and other Servlet API dependencies.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web（`spring-security-web`）：包含Web安全基础设施代码，如各种过滤器和其他Servlet API依赖项。
- en: 'These are the top-level projects within Spring Framework that are strongly
    linked to Spring Security:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是与Spring Security密切相关的Spring Framework中的顶级项目：
- en: '`spring-ldap`: Simplifying **Lightweight Directory Access Protocol** (**LDAP**)
    programming in Java.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-ldap`：简化Java中的轻量级目录访问协议（LDAP）编程。'
- en: '`spring-security-oauth`: Easy programming with OAuth 1.x and OAuth 2.x protocols.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-security-oauth`：使用OAuth 1.x和OAuth 2.x协议进行轻松编程。'
- en: '`spring-security-saml`: Bringing the SAML 2.0 service provider capabilities
    to Spring applications.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-security-saml`：为Spring应用程序提供SAML 2.0服务提供者功能。'
- en: '`spring-security-kerberos`: Bringing easy integration of Spring application
    with Kerberos protocol.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-security-kerberos`：将Spring应用程序与Kerberos协议轻松集成。'
- en: '**Security Assertion Markup Language** (**SAML**) is an XML-based framework
    for ensuring that transmitted communications are secure. SAML defines mechanisms
    to exchange authentication, authorization, and non-repudiation information, allowing
    single sign-on capabilities for Web services.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 安全断言标记语言（SAML）是一种基于XML的框架，用于确保传输通信的安全性。SAML定义了交换身份验证、授权和不可否认信息的机制，允许Web服务具有单一登录功能。
- en: The **Lightweight Directory Access Protocol** (**LDAP**) is a directory service
    protocol that runs on a layer above the TCP/IP stack. Its based on a client-server
    model and provides a mechanism used to connect to, search, and modify Internet
    directories.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 轻量级目录访问协议（LDAP）是在TCP/IP协议栈的一层上运行的目录服务协议。它基于客户端-服务器模型，并提供了用于连接、搜索和修改Internet目录的机制。
- en: '**Kerberos** is a network authentication protocol. It is designed to provide
    strong authentication for client/server applications by using secret key cryptography.
    A free implementation of this protocol is available from MIT and it is also available
    in many commercial products.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Kerberos是一种网络身份验证协议。它旨在通过使用秘密密钥加密为客户端/服务器应用程序提供强身份验证。麻省理工学院提供了该协议的免费实现，并且它也可以在许多商业产品中使用。
- en: 'For more information about SAML, LDAP, and Kerberos, you can check the following
    links:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 有关SAML、LDAP和Kerberos的更多信息，您可以查看以下链接：
- en: '[https://www.webopedia.com/TERM/S/SAML.html](https://www.webopedia.com/TERM/S/SAML.html)'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.webopedia.com/TERM/S/SAML.html](https://www.webopedia.com/TERM/S/SAML.html)'
- en: '[https://msdn.microsoft.com/en-us/library/aa367008(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/aa367008(v=vs.85).aspx)'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/library/aa367008(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/aa367008(v=vs.85).aspx)'
- en: '[https://web.mit.edu/kerberos/](https://web.mit.edu/kerberos/)'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://web.mit.edu/kerberos/](https://web.mit.edu/kerberos/)'
- en: Summary
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced you to new application requirements and then
    moved to some of the core reactive concepts. We looked at the Reactive Manifesto
    and reactive programming. We then moved our attention to Spring 5 and Spring Security
    5, and touched on some of the new features in it, especially regarding reactive
    programming. We then looked briefly at Spring's reactive programming efforts by
    introducing you to Project Reactor. After that, we explored Spring Security in
    a bit more detail to refresh your thoughts on this subject. Finally, we closed
    this chapter by giving you an idea of how examples would be structured in this
    book and what coding practices we will be using.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向您介绍了新的应用程序要求，然后转向了一些核心的响应式概念。我们看了看响应式宣言和响应式编程。然后，我们将注意力转向了Spring 5和Spring
    Security 5，并触及了其中的一些新功能，特别是关于响应式编程的。然后，我们简要地介绍了Spring的响应式编程工作，通过向您介绍Project Reactor。之后，我们更详细地探讨了Spring
    Security，以便您能够重新思考这个主题。最后，我们通过向您介绍本书中示例的结构以及我们将使用的编码实践，来结束了本章。
- en: You should now have a good grasp on reactive programming, and on Spring Security
    and how it works. You should also have a clear understanding of how to go through
    the rest of the chapters, especially the example code.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该对响应式编程以及Spring Security及其工作原理有了很好的了解。您还应该清楚地了解如何浏览其余章节，特别是示例代码。
