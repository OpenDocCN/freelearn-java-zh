- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Observability, Monitoring, and Application Management
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可观测性、监控和应用管理
- en: Monitoring and observability are crucial aspects of managing and maintaining
    the health, performance, and reliability of modern applications. In microservices-oriented
    applications, with multiple instances of different services running at the same
    time to deliver a solution, observability and monitoring help in understanding
    the interactions between these services and identifying issues.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 监控和可观测性是管理和维护现代应用程序健康、性能和可靠性的关键方面。在面向微服务应用程序中，有多个不同服务的实例同时运行以提供解决方案，可观测性和监控有助于理解这些服务之间的交互并识别问题。
- en: Monitoring plays a crucial role in large environments, enabling resource utilization
    and performance metrics to be tracked. This, in turn, facilitates dynamically
    scaling resources to effectively meet the demands of the system. This is especially
    useful in cloud computing environments, where you pay for the resources used and
    where you can adapt your application resources to the real demands of your users.
    Without monitoring, how do you know if your application is running at 100% CPU
    and the response time is so slow that your users abandon your application?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型环境中，监控发挥着至关重要的作用，能够跟踪资源利用率和性能指标。这反过来又促进了资源动态扩展，以有效满足系统的需求。这在云计算环境中特别有用，在那里您为使用的资源付费，并且您可以根据用户的实际需求调整应用程序资源。没有监控，您如何知道您的应用程序是否以100%的CPU运行，响应时间如此之慢以至于用户放弃使用您的应用程序？
- en: When you have multiple microservices running in your application and there’s
    an issue, observability is crucial in identifying the failing component and the
    context in which errors occur.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的应用程序中运行着多个微服务并且出现问题时，可观测性对于识别失败的组件和错误发生的上下文至关重要。
- en: Observability and monitoring are also very important for continuous improvement.
    You can use the insights gained from monitoring to make data-driven decisions,
    enhance performance, and refine the solution over time.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 可观测性和监控对于持续改进也非常重要。您可以使用从监控中获得的知识来做出数据驱动的决策，提高性能，并在一段时间内完善解决方案。
- en: Spring Boot, through Actuator, provides not only monitoring but also management
    capabilities that allow you to interact with the application in production environments.
    This capability not only allows you to detect potential issues in the application
    but also helps in troubleshooting at runtime.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot通过Actuator不仅提供监控功能，还提供管理能力，允许您在生产环境中与应用程序交互。这种能力不仅允许您检测应用程序中的潜在问题，还有助于在运行时进行故障排除。
- en: In this chapter, you will gain insights into activating observability and monitoring
    features within your Spring Boot applications. We’ll start by providing health
    checks in your application. Here, you’ll learn how to leverage the data that’s
    generated by your application through popular open source solutions. This chapter
    will also cover creating traces within your system, allowing you to correlate
    activities across different microservices and explore them using Zipkin. Additionally,
    you will learn how to monitor the exposed metrics of your application using Prometheus
    and Grafana. Beyond the standard metrics provided by Spring Boot and its associated
    components, you will generate custom metrics tailored to your application’s specifics
    and monitor them. Once your application becomes both monitorable and observable,
    you can also integrate with commercial tools while considering the plethora of
    powerful monitoring solutions available in the market that are well-suited for
    production environments. Finally, you will learn how to change application settings
    at runtime so that you can troubleshoot your application.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将深入了解在Spring Boot应用程序中激活可观测性和监控功能。我们将从在您的应用程序中提供健康检查开始。在这里，您将学习如何利用应用程序通过流行的开源解决方案生成数据。本章还将涵盖在您的系统中创建跟踪，使您能够关联不同微服务之间的活动并使用Zipkin进行探索。此外，您还将学习如何使用Prometheus和Grafana监控应用程序公开的指标。除了Spring
    Boot及其相关组件提供的标准指标之外，您还将生成针对应用程序特定情况的定制指标并对其进行监控。一旦您的应用程序既可监控又可观测，您还可以在考虑市场上众多适合生产环境的强大监控解决方案的同时，将其与商业工具集成。最后，您将学习如何在运行时更改应用程序设置，以便您可以排除应用程序的故障。
- en: 'In this chapter, we’re going to cover the following recipes:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Adding Actuator to your application
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Actuator添加到您的应用程序中
- en: Creating a custom Actuator endpoint
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义Actuator端点
- en: Using probes and creating a custom health check
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用探针和创建自定义健康检查
- en: Implementing distributed tracing
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现分布式跟踪
- en: Accessing standard metrics
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问标准度量
- en: Creating your own metrics
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建您自己的度量
- en: Integrating your application with Prometheus and Grafana
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您的应用程序与 Prometheus 和 Grafana 集成
- en: Changing the settings of a running application
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改运行中应用程序的设置
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we’ll need to run different tools, such as Prometheus, Grafana,
    and Zipkin. As usual, the simplest way to run them on your computer is using Docker.
    You can get Docker from its product page: [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/).
    I will explain how to deploy each tool in its corresponding recipe.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们需要运行不同的工具，例如 Prometheus、Grafana 和 Zipkin。通常，在您的计算机上运行它们的最简单方法是使用 Docker。您可以从其产品页面获取
    Docker：[https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/)。我将解释如何在其对应的配方中部署每个工具。
- en: 'All the recipes that will be demonstrated in this chapter can be found at:
    [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter3](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter3).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中将展示的所有配方都可以在以下位置找到：[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter3](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter3)。
- en: Adding Actuator to your application
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Actuator 添加到您的应用程序中
- en: So, you plan to develop a new RESTful API to complete your football-related
    suite of services. You are concerned about the responsiveness of your application
    and our aim to provide a resilient service. For that reason, you are very interested
    in monitoring your application health properly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您计划开发一个新的 RESTful API 来完成您与足球相关的服务套件。您担心应用程序的响应性以及我们提供弹性服务的目标。因此，您非常关注正确监控应用程序的健康状况。
- en: Before you start to monitor your application, your application should be monitorable.
    For that, you have decided to start using **Spring** **Boot Actuator**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在您开始监控应用程序之前，您的应用程序应该是可监控的。为此，您决定开始使用 **Spring** **Boot Actuator**。
- en: Spring Boot Actuator comprises a set of production-ready functionalities packaged
    with the Spring Framework. It incorporates various built-in tools and endpoints
    that are designed to allow you to monitor, manage, and interact with Spring Boot
    applications within a production setting. Actuator simplifies the process of comprehending
    and resolving runtime behaviors in Spring Boot applications.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot Actuator 包含了一组与 Spring 框架打包的生产就绪功能。它集成了各种内置工具和端点，旨在允许您在生产环境中监控、管理和与
    Spring Boot 应用程序交互。Actuator 简化了理解并解决 Spring Boot 应用程序运行时行为的过程。
- en: The Actuator module exposes multiple endpoints, including `health`, `metrics`,
    `info`, `dump`, and `env`, among others, offering operational insights into the
    running application. Once this dependency is included, you have a lot of out-of-the-box
    endpoints available. Customizing and extending these endpoints can easily be achieved
    and provides flexibility in terms of configuration.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Actuator 模块公开了多个端点，包括 `health`、`metrics`、`info`、`dump` 和 `env` 等，为运行中的应用程序提供操作洞察。一旦包含了这个依赖项，您就有很多开箱即用的端点可用。自定义和扩展这些端点很容易实现，并在配置方面提供了灵活性。
- en: In this recipe, you will learn how to include Spring Boot Actuator in your project
    and use some of the endpoints that are provided out of the box.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您将学习如何将 Spring Boot Actuator 包含到您的项目中，并使用一些开箱即用的端点。
- en: Getting ready
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we’ll create an application using the *Spring Initializr* tool.
    As you did in previous chapters of this book, you can use the tool in your browser
    by going to [https://start.spring.io](https://start.spring.io) or integrating
    it into your favorite code editor.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用 *Spring Initializr* 工具创建一个应用程序。正如您在本书的先前章节中所做的那样，您可以通过访问 [https://start.spring.io](https://start.spring.io)
    或将其集成到您最喜欢的代码编辑器中来使用此工具。
- en: How to do it…
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let’s create a project with Actuator enabled and start exploring the endpoints
    provided:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个启用了 Actuator 的项目，并开始探索提供的端点：
- en: 'Create a project using the *Spring Initializr* tool. Open [https://start.spring.io](https://start.spring.io)
    and use the same parameters that you used in the *Creating a RESTful API recipe*
    of [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020), except change the following
    options:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 *Spring Initializr* 工具创建一个项目。打开 [https://start.spring.io](https://start.spring.io)
    并使用与 [*第 1 章*](B21646_01.xhtml#_idTextAnchor020) 中的 *创建 RESTful API 配方* 相同的参数，除了更改以下选项：
- en: For `fooballobs`
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `fooballobs`
- en: For **Dependencies**, select **Spring Web** and **Spring** **Boot Actuator**
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于**依赖项**，选择**Spring Web**和**Spring Boot Actuator**
- en: Download the template that was generated with *Spring Initializr* and unzip
    the content to your working directory.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载使用 *Spring Initializr* 生成的模板，并将其内容解压到您的工作目录中。
- en: 'If you run the application now, you can access the health endpoint at `/actuator/health`.
    Before running the application, we’ll expose some endpoints. For that, create
    an `application.yml` file in the `resources` folder and add the following content:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您现在运行应用程序，您可以通过/actuator/health访问健康端点。在运行应用程序之前，我们将暴露一些端点。为此，在`resources`文件夹中创建一个`application.yml`文件，并添加以下内容：
- en: '[PRE0]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'http://localhost:8080/actuator/env: This endpoint returns the environment variables
    of the application.'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[http://localhost:8080/actuator/env](http://localhost:8080/actuator/env)：此端点返回应用程序的环境变量。'
- en: '`http://localhost:8080/actuator/metrics`: This endpoint returns a list that
    contains the metrics that have been exposed by the application. You can get the
    values of any of the metrics that have been exposed by appending the name to the
    metrics endpoint. For instance, to get `process.cpu.usage`, you can request http://localhost:8080/actuator/metrics/process.cpu.usage.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/actuator/metrics`：此端点返回一个包含应用程序已暴露的度量值的列表。您可以通过将名称附加到度量端点来获取任何已暴露的度量值的值。例如，要获取`process.cpu.usage`，您可以请求http://localhost:8080/actuator/metrics/process.cpu.usage。'
- en: '`http://localhost:8080/actuator/beans`: This endpoint returns a list with the
    beans registered in the IoC container – that is, a list of beans that can be injected
    into other beans.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/actuator/beans`：此端点返回一个包含在IoC容器中注册的bean的列表——即可以注入到其他bean中的bean列表。'
- en: '`http://localhost:8080/actuator/loggers`: This endpoint returns the list of
    log levels and loggers of the application. It also allows to modify the log level
    at runtime.'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/actuator/loggers`：此端点返回应用程序的日志级别和日志记录器的列表。它还允许在运行时修改日志级别。'
- en: In this recipe, you exposed just some of the available endpoints. You can find
    the full list of built-in endpoints at [https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints](https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints).
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个菜谱中，您只暴露了一些可用的端点。您可以在[https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints](https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints)找到内置端点的完整列表。
- en: How it works…
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you integrate Actuator into your application, it provides a set of endpoints
    that can be used for monitoring your application and managing its behavior. In
    addition to the built-in endpoints, it lets you add your own.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将Actuator集成到您的应用程序中时，它提供了一组端点，可用于监控您的应用程序和管理其行为。除了内置端点之外，它还允许您添加自己的端点。
- en: Endpoints can be enabled or disabled. By default, all endpoints are enabled
    except the shutdown endpoint – as its name suggests, you can use it to gracefully
    shut down the application. Then, the endpoints can be exposed, meaning that they
    can be accessed remotely using HTTP requests or JMX. By default, only the health
    endpoint is exposed. In this book, we’ll mostly focus on HTTP as it can be used
    with standard monitoring tools not specific to the Java ecosystem. HTTP is only
    available for web applications; if you’re developing another type of application,
    you will need to use JMX.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 端点可以被启用或禁用。默认情况下，除了关闭端点之外，所有端点都是启用的——正如其名称所暗示的，您可以使用它来优雅地关闭应用程序。然后，端点可以被暴露，这意味着它们可以通过HTTP请求或JMX远程访问。默认情况下，只有健康端点是暴露的。在这本书中，我们将主要关注HTTP，因为它可以与标准监控工具一起使用，这些工具不是针对Java生态系统的。HTTP仅适用于Web应用程序；如果您正在开发其他类型的应用程序，您将需要使用JMX。
- en: Depending on the components you use, more data will be exposed. For instance,
    when you include Spring Data JPA, the Spring Data metrics become available, so
    you will have to configure the number of open connections and other relevant metrics
    for Spring Data monitoring.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您使用的组件，将暴露更多数据。例如，当您包含Spring Data JPA时，Spring Data度量值变得可用，因此您将需要配置Spring Data监控的相关度量值，如打开连接数。
- en: There’s more…
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Some of the endpoints provided by Actuator may expose very sensitive information.
    So, the health endpoint is the only one that’s exposed by default. If your applications
    can only be accessed inside a virtual network or protected with a firewall, maybe
    you can keep endpoints open. Whether your application is publicly exposed or you
    simply want to control who accesses your Actuator endpoint, you may want to protect
    them, as explained in [*Chapter 2*](B21646_02.xhtml#_idTextAnchor066). For instance,
    a security configuration could look as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Actuator 提供的一些端点可能会暴露非常敏感的信息。因此，健康端点是默认暴露的唯一端点。如果您的应用程序只能在虚拟网络内部访问或受到防火墙的保护，也许您可以保持端点开放。无论您的应用程序是否公开暴露，或者您只是想控制谁可以访问您的
    Actuator 端点，您可能希望像在[*第 2 章*](B21646_02.xhtml#_idTextAnchor066)中解释的那样保护它们。例如，安全配置可能如下所示：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can refer to Spring Boot’s official documentation at [https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints.security](https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints.security)
    for more details.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考 Spring Boot 的官方文档[https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints.security](https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints.security)以获取更多详细信息。
- en: See also
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: In addition to endpoints provided by Spring Boot and the components used, Actuator
    provides a flexible implementation that allows you to create your own endpoints.
    Later in this chapter, you will learn how to create your own Actuator endpoint,
    metrics, and custom health checks.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Spring Boot 提供的端点和使用的组件外，Actuator 还提供了一个灵活的实现，允许您创建自己的端点。在本章的后面部分，您将学习如何创建自己的
    Actuator 端点、指标和自定义健康检查。
- en: See the *Creating a custom Actuator endpoint*, *Creating a custom health check*,
    and *Creating your own metrics* recipes for more information.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下食谱以获取更多信息：*创建自定义 Actuator 端点*、*创建自定义健康检查*和*创建您自己的指标*。
- en: Creating a custom Actuator endpoint
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义 Actuator 端点
- en: In our example, we are developing a new RESTful API that requires a file to
    be loaded from blob storage. That file doesn’t change frequently, which means
    it’s loaded in memory at application startup and is not reloaded again automatically.
    You need to know which version of the file is loaded, and you want to force a
    reload when there is a new version.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们正在开发一个新的 RESTful API，该 API 需要从 blob 存储加载一个文件。该文件不经常更改，这意味着它在应用程序启动时加载到内存中，并且不会自动重新加载。您需要知道加载的文件版本，并且希望在出现新版本时强制重新加载。
- en: To implement this feature, you will use a custom Actuator endpoint. This endpoint
    will have a `GET` operation to return the current file version, and a `POST` method
    to reload the file.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现此功能，您将使用自定义 Actuator 端点。此端点将有一个 `GET` 操作来返回当前文件版本，以及一个 `POST` 方法来重新加载文件。
- en: Getting ready
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, you will reuse the application you created in the *Adding Actuator
    to your application* recipe. I’ve prepared a working version in this book’s GitHub
    repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
    It can be found in the `chapter3/recipe3-2/start` folder.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，您将重用您在 *将 Actuator 添加到您的应用程序* 食谱中创建的应用程序。我在本书的 GitHub 仓库中准备了一个工作版本，该版本位于
    [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/)。您可以在
    `chapter3/recipe3-2/start` 文件夹中找到它。
- en: How to do it…
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let’s modify the RESTful API so that it loads a file from a folder and returns
    some results. Once you’ve done this, you’ll need to create a custom Actuator endpoint
    that returns the file that’s been loaded. You will also need to configure the
    endpoint to reload the file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改 RESTful API，使其从文件夹中加载文件并返回一些结果。完成此操作后，您需要创建一个自定义 Actuator 端点，该端点返回已加载的文件。您还需要配置端点以重新加载文件：
- en: 'Start by creating a class that loads a file and keeps the content in memory:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个类来加载文件并保持内容在内存中：
- en: 'Let’s name it `FileLoader` and add the following code:'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将其命名为 `FileLoader` 并添加以下代码：
- en: '[PRE2]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To load the file and keep the content in memory, add the following code:'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要加载文件并保持内容在内存中，请添加以下代码：
- en: '[PRE3]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, add a public method so that you can load the first file that’s found in
    the folder that’s passed in the constructor:'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个公共方法，以便您可以加载在构造函数中传入的文件夹中找到的第一个文件：
- en: '[PRE4]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, create a class annotated with `@Endpoint` to define the custom Actuator
    endpoint. Name it `FootballCustomEndpoint`:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个带有 `@Endpoint` 注解的类来定义自定义 Actuator 端点。将其命名为 `FootballCustomEndpoint`：
- en: '[PRE5]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This class receives a `FileLoader` object in the constructor to perform the
    necessary actions.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此类在构造函数中接收一个`FileLoader`对象以执行必要的操作。
- en: 'Now, create the custom endpoint operations in `FootballCustomEndpoint`:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`FootballCustomEndpoint`中创建自定义端点操作：
- en: 'Create a method annotated with `@ReadOperation` to retrieve the file version
    in use:'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有`@ReadOperation`注解的方法来检索正在使用的文件版本：
- en: '[PRE6]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a method annotated with `@WriteOperation` to refresh the file:'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有`@WriteOperation`注解的方法来刷新文件：
- en: '[PRE7]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, you need to create a bean for both the `FileLoader` and `FootballCustom``Endpoint`
    classes:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您需要为`FileLoader`和`FootballCustomEndpoint`类创建bean：
- en: 'Create a class named `FootballConfiguration` and annotate it with `@Configuration`:'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`FootballConfiguration`的类，并使用`@Configuration`注解：
- en: '[PRE8]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that there is a field annotated with `@Value`. It will load the folder
    path containing the file to load from the configuration.
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意有一个字段带有`@Value`注解。它将从配置中加载要加载的文件的文件夹路径。
- en: 'Create a method that produces a bean for `FileLoader`:'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个生成`FileLoader` bean的方法：
- en: '[PRE9]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, create a method that produces `FootballCustomEndpoint`:'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个生成`FootballCustomEndpoint`的方法：
- en: '[PRE10]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Since `FileLoader` needs to load the file by using the `loadFile` method, you
    will need to create a class that implement an `ApplicationRunner` interface:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`FileLoader`需要通过`loadFile`方法加载文件，因此您需要创建一个实现`ApplicationRunner`接口的类：
- en: '[PRE11]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Modify the `application.yml` file in the `resources` folder:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`resources`文件夹中的`application.yml`文件：
- en: 'Add a setting that provides a path to the folder containing the file to load:'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个设置，提供要加载的文件的文件夹路径：
- en: '[PRE12]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the new Actuator endpoint:'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加新的执行器端点：
- en: '[PRE13]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a sample RESTful controller that returns the content that’s loaded in
    memory by the `FileLoader` class:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个示例RESTful控制器，返回由`FileLoader`类加载到内存中的内容：
- en: '[PRE14]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The service is now ready to test. Execute the application and perform the following
    requests:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务现在已准备好测试。执行应用程序并执行以下请求：
- en: 'Get the current file version using the custom Actuator endpoint. For that,
    open your terminal and execute the following `curl` request:'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用自定义执行器端点获取当前文件版本。为此，打开您的终端并执行以下`curl`请求：
- en: '[PRE15]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You will receive the filename as a response – that is, `teams/1.0.0.json`.
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将收到文件名作为响应 - 即`teams/1.0.0.json`。
- en: 'Let’s create a new version of the file. Rename the file `1.0.1.json` and add
    a new element to the `teams` array, like so:'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建文件的新版本。将文件重命名为`1.0.1.json`，并在`teams`数组中添加一个新元素，如下所示：
- en: '[PRE16]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, use the custom Actuator endpoint to refresh the file in the application.
    For that, in your terminal, execute the following `curl` request:'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用自定义执行器端点刷新应用程序中的文件。为此，在您的终端中执行以下`curl`请求：
- en: '[PRE17]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Check the current file version again; you will now get `teams/1.0.``.json`.
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次检查当前文件版本；你现在将得到`teams/1.0.0.json`。
- en: You can also use a RESTful API to validate that the results correspond with
    the content of the file.
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以使用RESTful API验证结果是否与文件内容相符。
- en: How it works…
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: By creating a bean with the `@Endpoint` annotation, Actuator exposes all methods
    annotated with `@ReadOperation`, `@WriteOperation`, and `@DeleteOperation` over
    JMX and HTTP. This example is not much different from a regular RESTful endpoint,
    but the purpose is different as it’s used to manage the application or library
    you developed. Of course, you can implement your custom Actuator endpoint, but
    usually, Actuator endpoints are provided as part of a component that is used by
    others and may require some internal information or behavior to be exposed. For
    instance, database drivers such as PostgreSQL, database connection pool managers
    such as HikariCP, and caching systems such as Redis usually provide Actuator endpoints.
    If you plan to create some kind of system or library that will be used by others
    and you are interested in exposing some internals to facilitate management in
    runtime, Actuator endpoints are a great solution.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个带有`@Endpoint`注解的bean，Actuator通过JMX和HTTP公开所有带有`@ReadOperation`、`@WriteOperation`和`@DeleteOperation`注解的方法。此示例与常规RESTful端点没有太大区别，但目的不同，因为它用于管理您开发的应用程序或库。当然，您可以实现自己的自定义执行器端点，但通常Actuator端点作为其他组件的一部分提供，可能需要公开一些内部信息或行为。例如，数据库驱动程序（如PostgreSQL）、数据库连接池管理器（如HikariCP）和缓存系统（如Redis）通常提供Actuator端点。如果您计划创建某种将被他人使用的系统或库，并且您对在运行时便于管理某些内部信息感兴趣，Actuator端点是一个很好的解决方案。
- en: An `ApplicationRunner` is a component that is executed right after the application
    starts. When Spring Boot executes, the `ApplicationRunner` isn’t ready to accept
    requests yet. You can define more than one `ApplicationRunner`. Once all the `ApplicationRunner`
    components are executed, the application is ready to accept requests.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApplicationRunner` 是一个在应用程序启动后立即执行组件。当 Spring Boot 执行时，`ApplicationRunner`
    还未准备好接受请求。你可以定义多个 `ApplicationRunner`。一旦所有 `ApplicationRunner` 组件执行完毕，应用程序就准备好接受请求。'
- en: Using probes and creating a custom health check
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用探针和创建自定义健康检查
- en: Your new football trading service is getting readily adopted by football fans.
    This service is used to exchange stickers with football players’ pictures on them
    between fans. To accelerate the process, the service caches some data in the application’s
    memory. You need to ensure that the cache is filled before you start serving requests.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新足球交易服务正被足球迷们迅速采用。这个服务用于在球迷之间交换带有足球运动员照片的贴纸。为了加速这个过程，该服务在应用程序的内存中缓存了一些数据。在你开始处理请求之前，你需要确保缓存已填充。
- en: Under normal conditions, the football trading service works fine; however, under
    heavy load, the application instances start degrading and after some instability,
    they end up being unresponsive. To counteract this, you prepare some stress tests
    in the lab environment. However, you realize that the application starts degrading
    because you have issues connecting to the database. At the same time, you realize
    that those kinds of issues happen when the application has more than 90 pending
    orders. While you find a definitive solution, you decide to expose when the application
    is unable to process more requests and create a health check that verifies if
    it can connect to the database.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，足球交易服务运行良好；然而，在负载过重的情况下，应用程序实例开始退化，经过一些不稳定后，最终变得无响应。为了应对这种情况，你在实验室环境中准备了一些压力测试。然而，你意识到应用程序开始退化的原因是连接数据库时出现问题。同时，你意识到当应用程序有超过90个待处理订单时，这类问题就会发生。在你找到最终解决方案的同时，你决定在应用程序无法处理更多请求时暴露出来，并创建一个健康检查来验证它是否能够连接到数据库。
- en: Probes are mostly used by container orchestrators, such as Kubernetes, to verify
    that the application is ready to accept requests and when it is already working
    to indicate that it’s alive. In Kubernetes, they are known as readiness and liveness
    probes.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 探针主要用于容器编排器，如 Kubernetes，以验证应用程序是否准备好接受请求，以及当它已经开始工作时指示它处于活动状态。在 Kubernetes
    中，它们被称为就绪和存活探针。
- en: A health check is a mechanism to verify that the application has everything
    ready to work – for instance, it’s able to connect to a database.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查是一种验证应用程序是否已准备好工作的机制——例如，它能够连接到数据库。
- en: In this recipe, you will learn how to expose a readiness check, how to change
    your liveness state, and how to create a custom health check that can be used
    by the hosting platform or a monitoring system to determine the health of your
    application instances and when your application is ready to accept requests.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何暴露就绪检查，如何更改你的存活状态，以及如何创建一个自定义健康检查，该检查可以被托管平台或监控系统用来确定应用程序实例的健康状况以及应用程序何时准备好接受请求。
- en: Getting ready
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, you will reuse the application you created in the *Creating
    a custom Actuator endpoint* recipe. I’ve prepared a working version in this book’s
    GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
    It can be found in the `chapter3/recipe3-3/start` folder.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将重用你在 *创建自定义 Actuator 端点* 菜谱中创建的应用程序。我在本书的 GitHub 仓库中准备了一个工作版本，位于 [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/)。你可以在
    `chapter3/recipe3-3/start` 文件夹中找到它。
- en: 'In this recipe, you will verify that the application can connect to the application
    database. We’ll use PostgreSQL as a database. To run PostgreSQL locally, we’ll
    use Docker. You can download and start the database just by executing the following
    command in your terminal:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将验证应用程序是否能够连接到应用程序数据库。我们将使用 PostgreSQL 作为数据库。为了在本地运行 PostgreSQL，我们将使用
    Docker。你只需在终端中执行以下命令即可下载并启动数据库：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you created any database in [*Chapter 5*](B21646_05.xhtml#_idTextAnchor203),
    you can reuse it here. This recipe doesn’t perform any real queries – it just
    verifies it can connect. If you don’t have a database created in the container,
    you can create a database using the **psql** tool. For that, execute the following
    command in your terminal:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在[*第5章*](B21646_05.xhtml#_idTextAnchor203)中创建了任何数据库，您可以在此处重用它。这个菜谱不执行任何真实查询——它只是验证它是否可以连接。如果您在容器中没有创建数据库，您可以使用**psql**工具创建数据库。为此，在您的终端中执行以下命令：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You will be prompted for a password. Specify `packt` and press **intro**. You
    will be connected to a PostgreSQL terminal. Execute the following command to create
    a database:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被提示输入密码。指定`packt`并按**intro**。您将连接到PostgreSQL终端。执行以下命令以创建数据库：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, you can exit the database by executing the `quit;` command.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过执行`quit;`命令退出数据库。
- en: How to do it…
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this recipe, you’ll configure your application so that it can manage probes
    and create a custom health check to verify that the application can connect to
    the database:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，您将配置您的应用程序，使其能够管理探针并创建一个自定义的健康检查来验证应用程序是否可以连接到数据库：
- en: 'Start by updating the `application.yml` file in the `resources` folder so that
    it can enable readiness and liveness probes. For that, include the following:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，更新`resources`文件夹中的`application.yml`文件，以便它能够启用准备就绪和存活探针。为此，包括以下内容：
- en: '[PRE21]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, create a class that emulates the football trading service. Name it `TradingService`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个模拟足球交易服务的类。命名为`TradingService`：
- en: '[PRE22]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This class will manage the trading requests. When trading a request, if it
    detects that there are more than 90 pending orders, it will notify you that the
    application cannot manage more requests. For that, it will use `ApplicationEventPublisher`,
    which will be injected into the constructor:'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此类将管理交易请求。在交易请求时，如果它检测到有超过90个挂起的订单，它将通知您应用程序无法处理更多请求。为此，它将使用`ApplicationEventPublisher`，该对象将被注入到构造函数中：
- en: '[PRE23]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, define a method that returns the number of pending orders. We’ll simulate
    this by returning a random number between 0 and 100:'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，定义一个返回挂起订单数量的方法。我们将通过返回0到100之间的随机数来模拟：
- en: '[PRE24]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, you can create a method that manages the trading operations. If there
    are more than 90 pending orders, it will change the state of the application:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，您可以创建一个管理交易操作的方法。如果有超过90个挂起的订单，它将改变应用程序的状态：
- en: '[PRE25]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, configure the connection to the database:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，配置数据库连接：
- en: 'Add Spring Data JDBC and PostgreSQL dependencies. For that, in the `pom.xml`
    file, add the following dependencies:'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加Spring Data JDBC和PostgreSQL依赖项。为此，在`pom.xml`文件中添加以下依赖项：
- en: '[PRE26]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add the following configuration to the `application.yml` file in the `resources`
    folder:'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下配置添加到`resources`文件夹中的`application.yml`文件中：
- en: '[PRE27]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, let’s create a health indicator:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个健康指标：
- en: 'For that, create a class named `FootballHealthIndicator` that implements the
    `HealthIndicator` interface:'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了做到这一点，创建一个名为`FootballHealthIndicator`的类，该类实现了`HealthIndicator`接口：
- en: '[PRE28]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As it will connect to the database, inject `JdbcTemplate` into the constructor:'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于它将连接到数据库，请在构造函数中注入`JdbcTemplate`：
- en: '[PRE29]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, override the health method so that you can perform connectivity checking:'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，重写健康方法，以便您可以执行连接性检查：
- en: '[PRE30]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Before testing the application, you can modify the `FileLoader` class, simulating
    it so that it takes a few seconds to load the file. You can do this by modifying
    the `loadFile` method by adding the following code. This will make the application
    wait 10 seconds before it loads the file:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试应用程序之前，您可以修改`FileLoader`类，模拟它，使其加载文件需要几秒钟。您可以通过修改`loadFile`方法并添加以下代码来实现这一点。这将使应用程序在加载文件之前等待10秒：
- en: '[PRE31]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, let’s test the application’s readiness:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们测试应用程序的准备就绪状态：
- en: 'Before running the application, execute the following command in your terminal:'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行应用程序之前，在您的终端中执行以下命令：
- en: '[PRE32]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This command will execute a request to the readiness probe every second.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令将每秒执行一次就绪探针的请求。
- en: 'Start the application. You will see that the output of the `watch` command
    changes. First, it will appear as **OUT_OF_SERVICE**:'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动应用程序。您将看到`watch`命令的输出会发生变化。首先，它将显示为**OUT_OF_SERVICE**：
- en: '![Figure 3.1: Readiness status set to OUT_OF_SERVICE](img/B21646_03_1.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1：准备状态设置为OUT_OF_SERVICE](img/B21646_03_1.jpg)'
- en: 'Figure 3.1: Readiness status set to OUT_OF_SERVICE'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：准备状态设置为OUT_OF_SERVICE
- en: 'After 10 seconds or the time you configured in *Step 5*, it will change to
    **UP**:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在10秒或您在*步骤5*中配置的时间后，它将变为**UP**：
- en: '![Figure 3.2: Readiness status changed to UP](img/B21646_03_2.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2：就绪状态变为UP](img/B21646_03_2.jpg)'
- en: 'Figure 3.2: Readiness status changed to UP'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：就绪状态变为UP
- en: 'Now, test the application’s liveness:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，测试应用程序的存活状态：
- en: 'Again, execute a `watch` command, but this time, make requests to the liveness
    probe’s endpoint:'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次执行一个`watch`命令，但这次，向存活探针的端点发送请求：
- en: '[PRE33]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Remember that if there are more than 90 pending requests, it will mark itself
    as failing. Since a random number between 0 and 100 is selected, there’s a 10%
    possibility it will fail.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住，如果有超过90个挂起的请求，它将标记自己为失败。由于选择的是0到100之间的随机数，因此有10%的可能性它会失败。
- en: 'You will see that the readiness endpoint returns `watch` command for the Actuator
    health endpoint:'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会看到就绪端点返回Actuator健康端点的`watch`命令：
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'it will return **UP** every time. To verify that it detects when it cannot
    connect to the database, stop the PostgreSQL container. To do so, run the following
    command:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它会每次都返回**UP**。为了验证它是否能够检测到无法连接到数据库的情况，停止PostgreSQL容器。为此，请运行以下命令：
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You will see that the Actuator endpoint will take longer to respond and that
    the response will be **DOWN**.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到Actuator端点响应时间会更长，并且响应将是**DOWN**。
- en: How it works…
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Readiness and liveness probes are enabled automatically when Spring Boot detects
    it’s running on Kubernetes, but you can enable them manually. In this recipe,
    we enabled them explicitly, but if you run the application on Kubernetes, this
    will be done automatically.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当Spring Boot检测到它在Kubernetes上运行时，会自动启用就绪和存活探针，但你也可以手动启用它们。在本菜谱中，我们明确启用了它们，但如果你在Kubernetes上运行应用程序，这将自动完成。
- en: Readiness and liveness probes should not check any external component. They
    should verify that the application is ready internally and that it’s capable of
    responding. On the other hand, health checks should verify that all dependent
    components are available.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 就绪和存活探针不应检查任何外部组件。它们应该验证应用程序内部是否就绪，并且能够响应。另一方面，健康检查应该验证所有依赖组件是否可用。
- en: The Spring Boot application life cycle goes through different states, and it
    generates events every time it changes its state. I won’t explain all possible
    application states here; instead, I’ll focus on the relevant states during readiness
    probes. The first state is `starting`. Once Spring Boot initializes the components,
    it changes to `started`. At this point, it’s not ready yet, so it needs to run
    all `ApplicationRunner` and `CommandLineRunner` instances defined in the application.
    Once all of them are executed, it changes to `ready`. In this recipe, we introduced
    a delay of 10 seconds in the `loadFile` method. During this period, the readiness
    status was **OUT_OF_SERVICE**. Once it had loaded the file, it changed to **UP**.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot应用程序的生命周期会经历不同的状态，并且每次状态改变时都会生成事件。在这里，我不会解释所有可能的应用程序状态；相反，我将专注于就绪探针期间的相关状态。第一个状态是`starting`。一旦Spring
    Boot初始化了组件，它就会变为`started`。在这个时候，它还没有准备好，因此需要运行应用程序中定义的所有`ApplicationRunner`和`CommandLineRunner`实例。一旦它们全部执行完毕，它就会变为`ready`。在这个菜谱中，我们在`loadFile`方法中引入了10秒的延迟。在这段时间内，就绪状态是**OUT_OF_SERVICE**。一旦它加载了文件，它就会变为**UP**。
- en: 'If you want to learn more, take a look at the following Spring Boot documentation:
    [https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.spring-application.application-events-and-listeners](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.spring-application.application-events-and-listeners).'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多，请查看以下Spring Boot文档：[https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.spring-application.application-events-and-listeners](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.spring-application.application-events-and-listeners)。
- en: Be careful while checking other components. First, if it is another service,
    such as the one we created in this recipe, it will likely also have probes and
    health checks. Checking this via your service can be redundant. Second, try to
    make light checks; otherwise, you may generate too much load, which can cause
    performance issues. In this recipe, the SQL command we used was `SELECT 1`. This
    command connects to the database but doesn’t require computing resources from
    the database engine out of the connection itself.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查其他组件时要小心。首先，如果它是另一个服务，例如我们在本菜谱中创建的服务，它可能也会有探针和健康检查。通过你的服务进行检查可能是多余的。其次，尝试进行轻量级检查；否则，你可能会生成过多的负载，这可能导致性能问题。在本菜谱中，我们使用的SQL命令是`SELECT
    1`。这个命令连接到数据库，但不需要从连接本身获取数据库引擎的计算资源。
- en: See also
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: Health checks should not necessarily imply that you check the health of all
    the dependencies of your application. Rather, you should check if your application
    has any problems that could be solved by reducing the load or by rebooting. If
    your application depends on an unresponsive service and you mark your application
    as unhealthy, the application instance will be restarted. However, if your problem
    is in another application, the problem won’t disappear, and the application will
    be restarted again and again without solving the problem. For that kind of scenario,
    consider implementing a *circuit breaker* solution. See [https://spring.io/guides/gs/cloud-circuit-breaker/](https://spring.io/guides/gs/cloud-circuit-breaker/)
    for guidance on how to implement this using Spring Cloud.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查不一定意味着你需要检查你应用程序的所有依赖项的健康状况。相反，你应该检查你的应用程序是否有任何可以通过减少负载或重启来解决的问题。如果你的应用程序依赖于一个无响应的服务，并且你将你的应用程序标记为不健康，应用程序实例将被重新启动。然而，如果你的问题在另一个应用程序中，问题不会消失，应用程序将一次又一次地重新启动，而不会解决问题。对于这种情况，考虑实现一个*断路器*解决方案。请参阅[https://spring.io/guides/gs/cloud-circuit-breaker/](https://spring.io/guides/gs/cloud-circuit-breaker/)以获取有关如何使用Spring
    Cloud实现此功能的指导。
- en: Implementing distributed tracing
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现分布式跟踪
- en: So far, you’ve created a solution with two microservices, the football trading
    microservice and the client microservice. Among other features, the trading microservice
    provides the ranking of players. The client microservice enhances the list of
    players by adding the ranking that was obtained from the trading microservice.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经创建了一个包含两个微服务的解决方案，即足球交易微服务和客户端微服务。除了其他功能外，交易微服务提供了球员排名。客户端微服务通过添加从交易微服务获得的排名来增强球员列表。
- en: Distributed tracing emerges as a crucial tool as it offers a systematic approach
    to monitoring, analyzing, and optimizing the flow of requests between microservices.
    Distributed tracing is a method of monitoring and visualizing the flow of requests
    as they propagate through various components of a distributed system, providing
    insights into performance, latency, and dependencies between services.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式跟踪作为一个关键工具出现，因为它提供了一种系统化的方法来监控、分析和优化微服务之间请求的流动。分布式跟踪是一种监控和可视化请求在分布式系统各个组件之间传播的方法，提供了关于性能、延迟和服务之间依赖性的见解。
- en: In this recipe, you will learn how to enable distributed tracing for your microservices,
    export the data to Zipkin, and access the results.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何为你的微服务启用分布式跟踪，将数据导出到Zipkin，并访问结果。
- en: Zipkin is an open source distributed tracing system that helps developers trace,
    monitor, and visualize the paths of requests as they travel through various microservices
    in a distributed system, providing valuable insights into performance and dependencies.
    What you will learn about Zipkin in this recipe can be easily adapted to other
    tools.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Zipkin是一个开源的分布式跟踪系统，它帮助开发者跟踪、监控和可视化请求在分布式系统中的各种微服务之间的路径，为性能和依赖提供有价值的见解。在这个菜谱中你将了解的Zipkin知识可以轻松地适应其他工具。
- en: Getting ready
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we’ll visualize the traces using Zipkin. You can deploy it
    on your computer using Docker. For that, open your terminal and execute the following
    command:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用Zipkin可视化跟踪。你可以使用Docker在你的计算机上部署它。为此，打开你的终端并执行以下命令：
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The preceding command will download an image with an OpenZipkin server, if you
    don’t have one already, and start the server.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将下载一个包含OpenZipkin服务器的镜像，如果你还没有，然后启动服务器。
- en: We’ll reuse the trading service we created in the *Using probes and creating
    a custom health check* recipe. If you haven’t completed it yet, don’t worry –
    I’ve prepared a working version in this book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
    It can be found in the `chapter3/recipe3-4/start` folder.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用我们在*使用探针和创建自定义健康检查*菜谱中创建的交易服务。如果你还没有完成，不要担心——我已经在这个书的GitHub仓库中准备了一个工作版本，网址为[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/)。它可以在`chapter3/recipe3-4/start`文件夹中找到。
- en: How to do it…
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let’s enable distributed tracing in the existing trading service and create
    the new client service. For the new client service, we’ll need to ensure that
    distributed tracing is enabled as well. Before starting, ensure that your OpenZipkin
    server is running, as explained in the *Getting* *ready* section:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在现有的交易服务中启用分布式跟踪并创建新的客户端服务。对于新的客户端服务，我们需要确保也启用了分布式跟踪。在开始之前，请确保您的OpenZipkin服务器正在运行，如*准备*部分中所述：
- en: 'Start by enabling distributed tracing in the trading microservice you created
    in the *Using probes and creating a custom health* *check* recipe:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在您在*使用探针和创建自定义健康检查*配方中创建的交易微服务中启用分布式跟踪：
- en: 'For that, open the `pom.xml` file and add the following dependencies:'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此，打开`pom.xml`文件并添加以下依赖项：
- en: '[PRE37]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The first dependency is a bridge between `application.yml` file in the `resources`
    folder and add the following setting:'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个依赖项是`resources`文件夹中的`application.yml`文件之间的桥梁，并添加以下设置：
- en: '[PRE38]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: By default, sampling is only set to 10%. This means that only 10% of traces
    are sent. With this change, you will send 100% of the traces.
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，采样率仅设置为10%。这意味着只有10%的跟踪被发送。通过此更改，您将发送100%的跟踪。
- en: 'In the same `application.yml` file, add the following configuration:'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的`application.yml`文件中，添加以下配置：
- en: '[PRE39]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This change is not mandatory but helps identify the service in distributed tracing.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此更改不是强制性的，但有助于在分布式跟踪中识别服务。
- en: 'Next, create the ranking endpoint in the football trading microservice that
    will be consumed by the client microservice. For that, in `FootballController`,
    create the following method:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在将被客户端微服务消费的足球交易微服务中创建排名端点。为此，在`FootballController`中创建以下方法：
- en: '[PRE40]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: To simulate random errors, this method throws an exception when a random number
    from 0 to 99 is greater than 97 – that is, 2% of the time.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了模拟随机错误，此方法在从0到99的随机数大于97时抛出异常——也就是说，2%的时间。
- en: 'Next, create a new application that will act as the client application. As
    usual, you can create the template using the *Spring* *Initializr* tool:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个新的应用程序，该应用程序将充当客户端应用程序。像往常一样，您可以使用*Spring Initializr*工具创建模板：
- en: 'Open [https://start.spring.io](https://start.spring.io) and use the same parameters
    that you did in the *Creating a RESTful API* recipe of [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020),
    except change the following options:'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开[https://start.spring.io](https://start.spring.io)，使用与[*第一章*](B21646_01.xhtml#_idTextAnchor020)中*创建RESTful
    API*配方中相同的参数，但更改以下选项：
- en: For `fooballclient`
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`fooballclient`：
- en: 'For `pom.xml` file and add the following dependencies:'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`pom.xml`文件，添加以下依赖项：
- en: '[PRE41]'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the client application, add a RESTful controller:'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端应用程序中添加一个RESTful控制器：
- en: 'Name it `PlayersController`:'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名为`PlayersController`：
- en: '[PRE42]'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This application must call the trading service. For that, it will use `RestTemplate`.
    To achieve the correlation between service calls, you should use `RestTemplateBuilder`
    to create `RestTemplate`. Then, inject `RestTemplateBuilder` into the controller’s
    constructor:'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此应用程序必须调用交易服务。为此，它将使用`RestTemplate`。为了实现服务调用的关联，您应该使用`RestTemplateBuilder`来创建`RestTemplate`。然后，将`RestTemplateBuilder`注入到控制器的构造函数中：
- en: '[PRE43]'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, you can create the controller method that calls the trading service of
    the other application:'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以创建调用其他应用程序交易服务的控制器方法：
- en: '[PRE44]'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Configure client application tracing in the `application.yml` file:'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`application.yml`文件中配置客户端应用程序跟踪：
- en: '[PRE45]'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As you did in the trading service, you should set `sampling` to `1.0` so that
    100% of the traces will be recorded. To distinguish the client application from
    the trading service application, set the `spring.application.name` property to
    `football-client`.
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与在交易服务中一样，您应该将`sampling`设置为`1.0`，以便记录100%的跟踪。为了区分客户端应用程序和交易服务应用程序，将`spring.application.name`属性设置为`football-client`。
- en: 'To avoid port conflicts with the trading application, configure the client
    application so that it uses port `8090`. To do that, add the following parameter
    to the `application.yml` file:'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了避免与交易应用程序的端口冲突，配置客户端应用程序，使其使用端口`8090`。为此，将以下参数添加到`application.yml`文件中：
- en: '[PRE46]'
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, you can test the application. Call the client application; it will make
    multiple calls to the trading service. To make continuous requests to the client
    application, you can execute the following command in your terminal:'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，您可以测试应用程序。调用客户端应用程序；它将对交易服务进行多次调用。要向客户端应用程序发送连续请求，您可以在终端中执行以下命令：
- en: '[PRE47]'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, open Zipkin to see the traces. For that, go to `http://localhost:9411/`
    in your browser:'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，打开Zipkin查看跟踪。为此，请在浏览器中转到`http://localhost:9411/`：
- en: '![Figure 3.3: The Zipkin home page](img/B21646_03_3.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3：Zipkin 主页](img/B21646_03_3.jpg)'
- en: 'Figure 3.3: The Zipkin home page'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3：Zipkin 主页
- en: 'On the home page, click **RUN QUERY** to see the traces that have been generated:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在主页面上，点击 **运行查询** 以查看已生成的跟踪：
- en: '![Figure 3.4: Root traces in Zipkin](img/B21646_03_4.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4：Zipkin 中的根跟踪](img/B21646_03_4.jpg)'
- en: 'Figure 3.4: Root traces in Zipkin'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4：Zipkin 中的根跟踪
- en: 'On this page, you will see that the traces from the client application are
    root traces. Since we introduced a random error, you will see that there are failed
    and successful traces. If you click the **SHOW** button for any of these traces,
    you will see the traces of both RESTful APIs. There will be a main request for
    the client service and nested requests for the trading service:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个页面上，您将看到客户端应用程序的跟踪是根跟踪。由于我们引入了一个随机错误，您将看到有失败和成功的跟踪。如果您点击任何这些跟踪的 **显示** 按钮，您将看到两个
    RESTful API 的跟踪。将有一个针对客户端服务的请求和针对交易服务的嵌套请求：
- en: '![Figure 3.5: Trace details, including nested traces](img/B21646_03_5.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5：跟踪细节，包括嵌套跟踪](img/B21646_03_5.jpg)'
- en: 'Figure 3.5: Trace details, including nested traces'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5：跟踪细节，包括嵌套跟踪
- en: 'You can also view the dependencies between services by clicking on the **Dependencies**
    link on the top bar:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过点击顶部栏上的 **依赖关系** 链接来查看服务之间的依赖关系：
- en: '![Figure 3.6: Viewing the dependencies between services in Zipkin](img/B21646_03_6.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6：在 Zipkin 中查看服务之间的依赖关系](img/B21646_03_6.jpg)'
- en: 'Figure 3.6: Viewing the dependencies between services in Zipkin'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6：在 Zipkin 中查看服务之间的依赖关系
- en: Here, you can see the dependencies between the `football-client` application
    and the `trading-service` application.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以查看 `football-client` 应用程序和 `trading-service` 应用程序之间的依赖关系。
- en: How it works…
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: '*Micrometer* is a library that allows you to instrument your application without
    dependencies with specific vendors. This means that your code won’t change if
    you decide to use another tool, such as *Wavefront*, instead of Zipkin.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*Micrometer* 是一个库，允许您在不依赖特定供应商的情况下对应用程序进行仪表化。这意味着如果您决定使用其他工具，如 *Wavefront*
    而不是 Zipkin，您的代码将不会改变。'
- en: 'The `io.micrometer:micrometer-tracing-bridge-otel` dependency creates a bridge
    between *Micrometer* and *OpenTelemetry*, after which the `io.opentelemetry: opentelemetry-exporter-zipkin`
    dependency exports from *OpenTelemetry* to *Zipkin*. If you want to use another
    tool to monitor your traces, you just need to change these dependencies, without
    any additional code changes.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.micrometer:micrometer-tracing-bridge-otel` 依赖项在 *Micrometer* 和 *OpenTelemetry*
    之间创建了一个桥梁，之后 `io.opentelemetry:opentelemetry-exporter-zipkin` 依赖项将 *OpenTelemetry*
    导出至 *Zipkin*。如果您想使用其他工具来监控跟踪，只需更改这些依赖项，无需进行任何额外的代码更改。'
- en: The default address to send traces to Zipkin is `http://localhost:9411`. That’s
    why we didn’t need to configure it explicitly. In a production environment, you
    can use the `management.zipkin.tracing.endpoint` property.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 默认将跟踪发送到 Zipkin 的地址是 `http://localhost:9411`。这就是为什么我们不需要显式配置它。在生产环境中，您可以使用 `management.zipkin.tracing.endpoint`
    属性。
- en: In this recipe, we used `RestTemplateBuilder`. This is important as it configures
    `RestTemplate` by adding the tracing headers to the outgoing requests. Then, the
    target service gathers the tracing headers that can be used to nest the traces
    in the called application to the root trace from the client application. In reactive
    applications, you should use `WebClient.Builder` instead of `RestTemplateBuilder`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用了 `RestTemplateBuilder`。这很重要，因为它通过向出站请求添加跟踪头来自定义配置 `RestTemplate`。然后，目标服务收集可用于将调用应用程序中的嵌套跟踪从客户端应用程序的根跟踪中收集的跟踪头。在响应式应用程序中，您应该使用
    `WebClient.Builder` 而不是 `RestTemplateBuilder`。
- en: In this recipe, we configured 100% sampling. This means that we send all traces
    to the tracing server. We did this for learning purposes; normally, you shouldn’t
    do this in production as you can overload the tracing server by, for example,
    deploying a server via Zipkin or ingesting a lot of data if you’re using a managed
    service in the cloud. The amount of data that’s ingested directly affects monitoring
    systems – that is, the more data you ingest, the more it will cost you. However,
    even if you deploy your own tracing server, you will need to scale up as well.
    So, either way, it can increase your overall cost. In a large-scale system, having
    a sampling rate of 10% is more than enough to detect issues between services as
    well as understand the dependencies between the components.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们配置了100%的采样率。这意味着我们将所有跟踪发送到跟踪服务器。我们这样做是为了学习目的；通常，您不应该在生产环境中这样做，因为您可以通过部署服务器（例如，通过Zipkin）或使用云中的托管服务时摄入大量数据来超载跟踪服务器。摄入的数据量直接影响监控系统——也就是说，您摄入的数据越多，成本就越高。然而，即使您部署自己的跟踪服务器，您也需要进行扩展。所以，无论哪种方式，它都可能增加您的总体成本。在一个大规模系统中，拥有10%的采样率就足以检测服务之间的问题以及了解组件之间的依赖关系。
- en: There’s more…
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Micrometer tracing creates spans – that is, units of work or segments of a distributed
    trace that represent the execution of a specific operation, for each request.
    Spans capture information about the duration, context, and any associated metadata
    related to the respective operation.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Micrometer跟踪创建跨度——也就是说，代表特定操作执行的工作单元或分布式跟踪的片段，对于每个请求。跨度捕获有关持续时间、上下文以及与相应操作相关的任何关联元数据的信息。
- en: You can create a span by starting an observation using the `ObservationRegistry`
    component. For instance, say `TradingService` has different important parts that
    you want to trace, such as *Collect data* and *Process data*. You can create different
    spans for those in your code.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用`ObservationRegistry`组件启动观察来创建跨度。例如，假设`TradingService`有不同的重要部分，您希望跟踪，例如*收集数据*和*处理数据*。您可以在代码中为这些创建不同的跨度。
- en: 'To implement this, you will need to inject `ObservationRegistry` into your
    controller using the Spring Boot dependency container. For that, you need to define
    the `ObservationRegistry` parameter in the controller’s constructor:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，您需要使用Spring Boot依赖容器将`ObservationRegistry`注入到您的控制器中。为此，您需要在控制器构造函数中定义`ObservationRegistry`参数：
- en: '[PRE48]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, you must create the observations in the code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您必须在代码中创建观察结果：
- en: '[PRE49]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note that the observations include the player with `lowCardinalityKeyValue`
    to facilitate finding spans through this data.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，观察结果包括具有`lowCardinalityKeyValue`的玩家，以便通过这些数据找到跨度。
- en: Note
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Some parts of the code have been removed for brevity. You can find the full
    version in this book’s GitHub repository at https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁，已删除部分代码。您可以在本书的GitHub仓库中找到完整版本，网址为https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/。
- en: 'Now, in Zipkin, you can see the custom spans nested in `trading-service`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在Zipkin中，您可以看到嵌套在`trading-service`中的自定义跨度：
- en: '![Figure 3.7: Custom spans in Zipkin](img/B21646_03_7.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图3.7：Zipkin中的自定义跨度](img/B21646_03_7.jpg)'
- en: 'Figure 3.7: Custom spans in Zipkin'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7：Zipkin中的自定义跨度
- en: The `trading-service` span contains two nested spans, and both have a custom
    tag that specifies the player’s name.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`trading-service`跨度包含两个嵌套跨度，并且两者都有一个自定义标签，指定了玩家的名字。'
- en: Accessing standard metrics
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问标准指标
- en: Your Football Trading service continues to grow by being adopted by football
    fans. You need to understand how it performs better so that you can adapt to demand
    while optimizing the resources that are used to provide the service.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 您的足球交易服务通过被足球迷采用而持续增长。您需要了解它如何表现更好，以便您可以在优化提供服务的资源的同时适应需求。
- en: You can use the standard metrics provided by Spring Boot Actuator and its related
    components for real-time insights into your application’s behavior. For instance,
    you can find out how much CPU and memory has been used by your application or
    the time spent in **garbage collection** (**GC**). These are the basic metrics
    that give you a general understanding of the performance of the application.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Spring Boot Actuator及其相关组件提供的标准指标，以实时洞察您的应用程序的行为。例如，您可以了解您的应用程序使用了多少CPU和内存，或者在垃圾收集（**GC**）中花费了多长时间。这些是基本的指标，可以帮助您了解应用程序的性能。
- en: Other metrics are more subtle, such as the metrics provided by the web container,
    Tomcat – for instance, the number of active sessions, the number of sessions rejected,
    and the number of sessions that have expired. Similarly, the database connection
    pool, which is `hikaricp` by default, also exposes some metrics. For instance,
    you can view the number of active sessions, the number of waiting sessions, or
    the number of sessions that have been rejected. These types of metrics can be
    an indicator of problems in your application that aren’t easy to detect just by
    using classic metrics such as CPU and memory utilization.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 其他指标可能更为微妙，例如由 Web 容器 Tomcat 提供的指标——例如，活跃会话的数量、拒绝的会话数量以及已过期的会话数量。同样，默认为 `hikaricp`
    的数据库连接池也暴露了一些指标。例如，您可以查看活跃会话的数量、等待会话的数量或被拒绝的会话数量。这类指标可以成为您应用程序中问题的指示器，这些问题仅通过使用如
    CPU 和内存利用率等经典指标难以检测。
- en: In this recipe, you will learn how to access standard metrics and how to detect
    some common application issues. You will also learn how to perform a load test
    using JMeter, but it’s not the main purpose of this recipe.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，您将学习如何访问标准指标以及如何检测一些常见应用程序问题。您还将学习如何使用 JMeter 进行负载测试，但这不是本食谱的主要目的。
- en: Getting ready
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In this recipe, you will reuse the applications you created in the *Implementing
    distributed tracing* recipe. If you haven’t completed that recipe yet, I’ve prepared
    a working version that you can find in this book’s GitHub repository at https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/,
    in the `chapter3/recipe3-5/start` folder. These applications depend on PostgreSQL
    and also export activities to Zipkin, as explained in the previous recipe. Both
    PostgreSQL and Zipkin can be run locally using Docker.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，您将重用 *实现分布式跟踪* 食谱中创建的应用程序。如果您还没有完成该食谱，我已准备了一个工作版本，您可以在本书的 GitHub 仓库中找到，网址为
    https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/，在 `chapter3/recipe3-5/start`
    文件夹中。这些应用程序依赖于 PostgreSQL，并且如前一个食谱中所述，将活动导出到 Zipkin。PostgreSQL 和 Zipkin 都可以使用
    Docker 在本地运行。
- en: In this recipe, we’ll perform some load tests using JMeter, a popular load-testing
    tool. You can download JMeter from the project website at [https://jmeter.apache.org/download_jmeter.cgi](https://jmeter.apache.org/download_jmeter.cgi).
    Here, you can download a ZIP file containing JMeter binaries and unzip it; no
    further installation is required. To run JMeter, go to the folder where you unzipped
    the binaries and open the `bin` folder. Here, you will find different scripts
    to launch JMeter, depending on your operating system. For Unix-based operating
    systems, you can run the `jmeter.sh` script, while for Windows, you can run the
    `jmeter.bat` script.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用 JMeter，一个流行的负载测试工具，进行一些负载测试。您可以从项目网站 [https://jmeter.apache.org/download_jmeter.cgi](https://jmeter.apache.org/download_jmeter.cgi)
    下载 JMeter。在这里，您可以下载包含 JMeter 二进制文件的 ZIP 文件，并将其解压；无需进一步安装。要运行 JMeter，请转到您解压二进制文件的文件夹，打开
    `bin` 文件夹。在这里，您将找到根据您的操作系统启动 JMeter 的不同脚本。对于基于 Unix 的操作系统，您可以运行 `jmeter.sh` 脚本，而对于
    Windows，您可以运行 `jmeter.bat` 脚本。
- en: I’ve created two JMeter scripts to create some load against the application.
    You can find them in this book’s GitHub repository, in the `chapter3/recipe3-5/jmeter`
    folder.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我已创建了两个 JMeter 脚本，用于对应用程序施加一些负载。您可以在本书的 GitHub 仓库中找到它们，在 `chapter3/recipe3-5/jmeter`
    文件夹中。
- en: How to do it…
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In this recipe, we’ll use the JMeter scripts mentioned in the *Getting ready*
    section to generate a workload for the football application. Then, we’ll observe
    the metrics provided by Spring Boot and its related components. Follow these steps:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用 *准备就绪* 部分中提到的 JMeter 脚本来为足球应用程序生成工作负载。然后，我们将观察 Spring Boot 及其相关组件提供的指标。按照以下步骤操作：
- en: 'Before running the first load test, ensure that the trading application is
    running and the `metrics` endpoint is exposed. As explained in the *Adding Actuator
    to your application* recipe, this can be done by adding the `metrics` value to
    the `management.endpoints.web.exposure.include` parameter. If you followed the
    previous recipes or used the working version I’ve prepared, as explained in the
    *Getting ready* section, the `application.yml` file should look like this:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行第一个负载测试之前，请确保交易应用程序正在运行，并且 `metrics` 端点已公开。如 *将 Actuator 添加到您的应用程序* 食谱中所述，这可以通过将
    `metrics` 值添加到 `management.endpoints.web.exposure.include` 参数来完成。如果您遵循了前面的食谱或使用了我在
    *准备就绪* 部分中解释的工作版本，则 `application.yml` 文件应如下所示：
- en: '[PRE50]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '![Figure 3.8: The number of threads in JMeter](img/B21646_03_8.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8：JMeter 中的线程数量](img/B21646_03_8.jpg)'
- en: 'Figure 3.8: The number of threads in JMeter'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8：JMeter中的线程数
- en: If you want to adjust the number of threads, click **Main Thread Group** and
    adjust **Number of** **Threads (users)**.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想调整线程数，请点击**主线程组**并调整**线程数（用户）**。
- en: Once the application is ready, you can run the JMeter script.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序准备就绪，你可以运行JMeter脚本。
- en: 'Let’s observe the metrics of the application. Go to `http://localhost:8080/actuator/metrics`
    to see the full list of exposed metrics. You can get any of these metrics by appending
    the metric’s name to the `/actuator/metrics` path. Typically, you will get the
    CPU and memory-related counters:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们观察应用程序的指标。转到`http://localhost:8080/actuator/metrics`以查看暴露的指标完整列表。你可以通过将指标名称附加到`/actuator/metrics`路径来获取任何这些指标。通常，你会得到与CPU和内存相关的计数器：
- en: With `http://localhost:8080/actuator/metrics/process.cpu.usage`, you will get
    the percentage of CPU being used by the application process
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`http://localhost:8080/actuator/metrics/process.cpu.usage`，你可以得到应用程序进程正在使用的CPU百分比
- en: With http://localhost:8080/actuator/metrics/system.cpu.usage, you will get the
    percentage of CPU being used by the system
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`http://localhost:8080/actuator/metrics/system.cpu.usage`，你可以得到系统正在使用的CPU百分比
- en: With `http://localhost:8080/actuator/metrics/jvm.memory.used` you will get the
    amount of memory being used by your application
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`http://localhost:8080/actuator/metrics/jvm.memory.used`，你可以得到应用程序正在使用的内存量
- en: 'As an example, the result of the `process.cpu.usage` metric looks like this:'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，`process.cpu.usage`指标的结果如下所示：
- en: '[PRE51]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Stop the test – you need to create a new endpoint to access the database. For
    that, follow these steps:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止测试 - 你需要创建一个新的端点来访问数据库。为此，请按照以下步骤操作：
- en: 'Create a new `DataService` class and inject `JdbcTemplate` into the constructor:'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`DataService`类并将`JdbcTemplate`注入到构造函数中：
- en: '[PRE52]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, create a method that makes a call to the database. To simulate a slow
    database query, you can use the `pg_sleep` PostgreSQL command. This command waits
    for a given number of seconds or fraction of seconds:'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个调用数据库的方法。为了模拟慢速数据库查询，你可以使用`pg_sleep` PostgreSQL命令。此命令等待指定数量的秒数或秒数的分数：
- en: '[PRE53]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Finally, run another JMeter script that makes a request to the same `/football`
    path and returns a list of teams, as well as the new path, `/stats/{player}`,
    which performs a long request to the database. Again, 30 threads are running these
    requests infinitely.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，运行另一个JMeter脚本，对该相同的`/football`路径发起请求并返回一个球队列表，以及新的路径`/stats/{player}`，它执行对数据库的长请求。再次，30个线程无限运行这些请求。
- en: How it works…
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the first load test, we can see that there is a bottleneck in the application’s
    CPU. In a real-world scenario, the CPU metric can be used to scale the application
    automatically, such as by adding new instances of the application. That’s the
    kind of bottleneck that we could expect under heavy loads.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次负载测试中，我们可以看到应用程序的CPU存在瓶颈。在现实场景中，可以使用CPU指标来自动扩展应用程序，例如通过添加应用程序的新实例。这就是在重负载下我们可能预期的瓶颈类型。
- en: In the second load test, there is no physical resource bottleneck, but there’s
    a query that takes a long time and blocks a connection that cannot be reused for
    other requests. In a real-world scenario, you could increase the number of available
    connections in the connection pool, but only up to a certain limit, since this
    is a very expensive and finite resource.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次负载测试中，没有物理资源瓶颈，但有一个耗时较长的查询并阻塞了一个无法用于其他请求的连接。在现实场景中，你可以增加连接池中可用的连接数，但只能增加到一定限制，因为这是一个非常昂贵且有限的资源。
- en: If you look at `system.cpu.usage` and `process.cpu.usage`, you will see that
    the values are much lower than `1.0`, which we observed in the previous load test.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`system.cpu.usage`和`process.cpu.usage`，你会看到值远低于前一次负载测试中观察到的`1.0`。
- en: 'You can also look at the metrics related to the database connection pool. The
    default database connection pool in Spring Data is HikariCP, and all the metrics
    related to this component are `hikaricp.*`. Let’s consider the following metrics:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以查看与数据库连接池相关的指标。Spring Data中的默认数据库连接池是HikariCP，与此组件相关的所有指标都是`hikaricp.*`。让我们考虑以下指标：
- en: '`hikaricp.connections.max`: This value specifies the maximum number of real
    database connections that `hikaricp` will open in the PostgreSQL server. This
    number won’t change during the execution of the test as the value is static during
    the application life cycle. By default, it’s set to `10`.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hikaricp.connections.max`: 此值指定`hikaricp`将在PostgreSQL服务器中打开的最大真实数据库连接数。在测试执行期间，此数值不会改变，因为在应用程序生命周期中该值是静态的。默认情况下，它设置为`10`。'
- en: '`hikaricp.connections.active`: This is the number of active connections – that
    is, the connections that are executing something in the database server. Under
    light loads, the number will be less than the maximum. Since the database operation
    is long (up to 1 second), and there are 30 concurrent threads for only 10 maximum
    connections, this number will be 10 or near 10 during the execution of the JMeter
    script.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hikaricp.connections.active`: 这是活动连接数——即正在数据库服务器中执行某些操作的连接。在轻负载下，此数字将小于最大值。由于数据库操作时间较长（长达1秒），并且只有10个最大连接就有30个并发线程，因此在JMeter脚本的执行期间，此数字将是10或接近10。'
- en: '`hikaricp.connections.pending`: When there are no available connections in
    the connection pool, this metric queues the requests. This metric specifies the
    number of connections waiting for an available connection. This number will be
    greater than 1 during the JMeter script’s execution.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hikaricp.connections.pending`: 当连接池中没有可用的连接时，此指标将请求排队。此指标指定了等待可用连接的连接数。在JMeter脚本的执行期间，此数字将大于1。'
- en: '`hikaricp.connections.timeout`: If a request is waiting for more than a given
    amount of time –30 seconds by default – it will time out. After executing the
    JMeter script, you will see that this metric will be more than 1.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hikaricp.connections.timeout`: 如果一个请求等待超过给定的时间——默认为30秒——它将超时。在执行JMeter脚本后，你会看到这个指标将大于1。'
- en: Opening a physical database connection is an expensive operation. To avoid the
    overhead of creating a connection, there is a mechanism known as a database connection
    pool that keeps some already created connections ready to be used. When a process
    needs to connect to the database, it gets the connection from the pool and returns
    it to the pool once the operation is finished. In the second stress test, there
    were no connections as they took a long time to complete, so they took a long
    time to return to the pool. When there are no available connections, the connection
    pool enqueues the connection until one is released. That’s why you saw `pending`
    connections. After some time, you will see timeout connections. Those are the
    connections that were enqueued for more than 30 seconds.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 打开物理数据库连接是一项昂贵的操作。为了避免创建连接的开销，存在一种称为数据库连接池的机制，它保持一些已创建的连接以供使用。当进程需要连接到数据库时，它会从池中获取连接，一旦操作完成，就将其返回到池中。在第二次压力测试中，由于它们完成时间较长，因此没有连接，它们花费了很长时间才返回到池中。当没有可用连接时，连接池将排队连接，直到其中一个被释放。这就是为什么你会看到`pending`连接的原因。过了一段时间，你会看到超时连接。这些是排队超过30秒的连接。
- en: This situation also impacts the web container. By default, the number of threads
    to serve HTTP requests is finite and there is also a pool. When there are no more
    available threads, the web container – in this case, Tomcat – will enqueue the
    requests. In this kind of situation, when an HTTP request is mostly waiting for
    a dependency to complete, it appears the Reactive framework. In this case, the
    application uses special kinds of threads – non-blocking threads – that are intended
    for I/O operations. These types of threads allow the application to continue processing
    other tasks while waiting for responses from external services.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况也会影响Web容器。默认情况下，服务HTTP请求的线程数是有限的，也存在一个线程池。当没有更多可用的线程时，Web容器（在这种情况下，是Tomcat）将排队请求。在这种情况下，当一个HTTP请求主要在等待依赖项完成时，它似乎出现了响应式框架。在这种情况下，应用程序使用特殊类型的线程——非阻塞线程——这些线程旨在进行I/O操作。这些类型的线程允许应用程序在等待外部服务响应的同时继续处理其他任务。
- en: See also
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: You can visualize your metrics with standard monitoring tools. In the *Integrating
    your application with Prometheus and Grafana* recipe, you will learn how to integrate
    application metrics with Prometheus and visualize them with Grafana. These are
    two popular open source tools that are part of the **Cloud Native Computing**
    **Foundation** (**CNCF**).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用标准的监控工具来可视化你的指标。在*将应用与Prometheus和Grafana集成*的菜谱中，你将学习如何将应用指标与Prometheus集成，并使用Grafana进行可视化。这些是两个流行的开源工具，它们是**云原生计算基金会**（**CNCF**）的一部分。
- en: Creating your own metrics
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自己的指标
- en: So far, you’ve created a new feature in your Football Trading service where
    users can list a card for exchange and another user can bid for the traded card.
    When a new bid is received, it is queued in memory until it is committed as it
    requires a bunch of complex validations. There are a lot of expectations for this
    new feature, and you want to be sure it works well. For that reason, you want
    to monitor the bids that are received, how many bids are pending to be committed,
    and the duration of this process.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你在你的足球交易服务中创建了一个新功能，用户可以列出一张卡片进行交换，另一个用户可以对该交易卡片进行竞标。当收到新的竞标时，它将在内存中排队，直到提交，因为它需要一系列复杂的验证。人们对这个新功能有很多期望，你想要确保它运行良好。因此，你想要监控收到的竞标，有多少竞标正在等待提交，以及这个过程持续了多长时间。
- en: In this recipe, you will learn how to create custom metrics using **Micrometer**.
    Micrometer is an open source metrics collection library for Java applications
    that is very well integrated with Spring Boot Actuator. Other libraries can use
    the telemetry data generated by Micrometer to export to different monitoring systems.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何使用**Micrometer**创建自定义指标。Micrometer是一个开源的Java应用指标收集库，它与Spring Boot
    Actuator集成得非常好。其他库可以使用Micrometer生成的遥测数据导出到不同的监控系统。
- en: 'There are different types of metrics:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同类型的指标：
- en: '**Counter**: As the name suggests, it counts how many times something happened.
    We can use this type of metric to find out how many bids were received.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计数器**：正如其名所示，它计算某事发生的次数。我们可以使用这种类型的指标来找出收到了多少竞标。'
- en: '**Gauge**: This metric provides a value in a given moment. We can use it to
    find out how many bids are waiting to be processed.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仪表**：这个指标在给定时刻提供一个值。我们可以用它来找出有多少竞标正在等待处理。'
- en: '**Timer**: This metric measures the duration of a given operation. We can use
    it to find out the time spent per bid.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计时器**：这个指标测量给定操作的持续时间。我们可以用它来找出每个竞标花费的时间。'
- en: Getting ready
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we’ll reuse the projects from the *Accessing standard metrics*
    recipe. I’ve prepared a working version if you haven’t completed that recipe yet.
    You can find it in this book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/),
    in the `chapter3/recipe3-6/start` folder.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将重用*访问标准指标*菜谱中的项目。如果你还没有完成那个菜谱，我已经准备了一个工作版本。你可以在本书的GitHub仓库中找到它，在[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/)的`chapter3/recipe3-6/start`文件夹中。
- en: To simulate a workload for the new feature, I’ve created a JMeter script. You
    can find it in this book’s GitHub repository, in the `chapter3/recipe3-6/jmeter`
    folder. You can download JMeter from the project website at [https://jmeter.apache.org/download_jmeter.cgi](https://jmeter.apache.org/download_jmeter.cgi).
    Here, you can download a ZIP file that contains JMeter binaries and unzip it –
    no further installation is required. To run JMeter, go to the folder where you
    unzipped the binaries, then open the `bin` folder. Here, you can find different
    scripts to launch JMeter, depending on your operating system. For Unix, you can
    run the `jmeter.sh` script, while for Windows, you can run the `jmeter.bat` script.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟新功能的工作负载，我创建了一个JMeter脚本。你可以在本书的GitHub仓库中找到它，在`chapter3/recipe3-6/jmeter`文件夹中。你可以从项目网站[https://jmeter.apache.org/download_jmeter.cgi](https://jmeter.apache.org/download_jmeter.cgi)下载JMeter。在这里，你可以下载一个包含JMeter二进制的ZIP文件，并将其解压——不需要进一步的安装。要运行JMeter，请转到您解压二进制的文件夹，然后打开`bin`文件夹。在这里，您可以找到根据您的操作系统启动JMeter的不同脚本。对于Unix，您可以运行`jmeter.sh`脚本，而对于Windows，您可以运行`jmeter.bat`脚本。
- en: How to do it…
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this recipe, you’ll incorporate your custom metrics into the football trading
    application. This enhancement will offer improved insights into your application’s
    performance during runtime:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将把你自定义的指标集成到足球交易应用中。这个增强功能将提供对应用在运行时性能的更深入了解：
- en: 'Go to your trading application and create a new service class named `AuctionService`:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往你的交易应用程序并创建一个名为`AuctionService`的新服务类：
- en: 'Inject `MeterRegistry` into the constructor. In the same constructor, create
    a counter for the bids received, a timer for the duration of the bid to be processed,
    and a gauge for the bids waiting to be confirmed. The class should look like this:'
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MeterRegistry`注入到构造函数中。在同一个构造函数中，创建一个用于收到的竞标的计数器，一个用于处理竞标持续时间的计时器，以及一个用于等待确认的竞标的仪表。
- en: '[PRE54]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note that `gauge` returns the size of the map that’s used to keep the bids that
    have been received in memory.
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，`gauge`返回用于在内存中保持已收到的竞标的映射的大小。
- en: Now, create a method to process the bids. In this method, you will use the `bidDuration`
    timer to measure the duration of the operation and increase the number of bids
    received using `bidReceivedCounter`.
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个处理竞标的方法。在这个方法中，你将使用`bidDuration`计时器来测量操作持续时间，并使用`bidReceivedCounter`增加收到的竞标数量。
- en: 'Use the `ordersTradedCounter` and `tradedDuration` metrics in a new method
    named `tradeCards`. The method should look like this:'
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为`tradeCards`的新方法中使用`ordersTradedCounter`和`tradedDuration`指标。该方法应如下所示：
- en: '[PRE55]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next, expose this feature in the `FootballController` class:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`FootballController`类中公开此功能：
- en: 'Inject your new `AuctionService` into the constructor:'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的新`AuctionService`注入到构造函数中：
- en: '[PRE56]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note that all the other parameters and fields have been omitted for simplicity.
    Since we are reusing the same project from previous recipes, you should have more
    parameters in the constructor, and you should have other fields as well.
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，为了简化，所有其他参数和字段都已省略。由于我们正在重用之前菜谱中的相同项目，你应在构造函数中拥有更多参数，并且还应拥有其他字段。
- en: 'Create a new method that will present bids for players using the new service:'
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的方法，该方法将使用新服务展示球员的竞标：
- en: '[PRE57]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Now, you can run the application and start generating some load. To do this,
    open the `loadBids.jmx` file in JMeter. You can find this file in this book’s
    GitHub repository at https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/,
    in the `chapter3/recipe3-6/jmeter` folder. Then, run the script in JMeter and
    keep it running while you observe the metrics.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以运行应用程序并开始生成一些负载。为此，在JMeter中打开`loadBids.jmx`文件。你可以在这个书的GitHub仓库中找到此文件，网址为https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/，在`chapter3/recipe3-6/jmeter`文件夹中。然后，在JMeter中运行脚本并保持运行，同时观察指标。
- en: 'Observe the counters you created:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察你创建的计数器：
- en: 'If you open the Actuator metrics endpoint at `http://localhost:8080/actuator/metrics`,
    you will see the new metrics that have been created: `football.bids.duration`,
    `football.bids.pending`, and `football.bids.receieved`. If you append the names
    of these metrics to the Actuator metrics endpoint, you will get the values of
    each metric.'
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你打开`http://localhost:8080/actuator/metrics`上的Actuator指标端点，你会看到已创建的新指标：`football.bids.duration`、`football.bids.pending`和`football.bids.received`。如果你将这些指标的名称附加到Actuator指标端点，你将得到每个指标的价值。
- en: Open `http://localhost:8080/actuator/metrics/football.bids.received` to get
    the number of bids that have been received. You will see the total number of bids.
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开`http://localhost:8080/actuator/metrics/football.bids.received`以获取已收到的竞标数量。你会看到竞标总数。
- en: Open `http://localhost:8080/actuator/metrics/football.bids.duration` to get
    the bids processing duration.
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开`http://localhost:8080/actuator/metrics/football.bids.duration`以获取竞标处理持续时间。
- en: Open `http://localhost:8080/actuator/metrics/football.bids.pending` to get the
    number of bids that are pending.
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开`http://localhost:8080/actuator/metrics/football.bids.pending`以获取待处理的竞标数量。
- en: For counters and duration, normally, the monitoring tools also provide a rate
    that’s calculated from the total values and based on the frequency of observation.
    It’s more interesting in terms of performance analysis to know the bid processing
    rate than the total number. The same goes for the duration.
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于计数器和持续时间，通常，监控工具也会提供一个基于总值和观察频率计算出的速率。在性能分析方面，了解竞标处理速率比总数量更有趣。同样，这也适用于持续时间。
- en: Stop the JMeter script.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止JMeter脚本。
- en: How it works…
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `MeterRegistry` class registers the metrics, after which they are automatically
    exposed in the Actuator metrics endpoint.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`MeterRegistry`类注册指标，之后它们将自动在Actuator指标端点中公开。'
- en: '`gauge` calls the delegate that’s been assigned to the metric. This delegate
    will be executed according to the observation frequency. In this recipe, we call
    the endpoint explicitly. If you use a monitoring tool, it will be observed periodically.
    Keep in mind that this operation should be as lightweight as possible because
    it will be called frequently.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`gauge`调用分配给指标的代理。此代理将根据观察频率执行。在本食谱中，我们显式地调用端点。如果您使用监控工具，它将定期被观察。请注意，此操作应尽可能轻量，因为它将被频繁调用。'
- en: Timer metrics measure the time spent on the execution of the delegate provided.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 计时指标衡量了提供给代理执行所花费的时间。
- en: A counter metric increments the value of the counter. If you don’t provide a
    value when calling the `increment` method, as we did in this recipe, it just increments
    by 1\. You can provide a number as a parameter of method increment, at which point
    it will increment the counter value by the number provided. This number should
    always be positive.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 计数器指标增加计数器的值。如果您在调用`increment`方法时没有提供值，就像我们在本食谱中所做的那样，它将只增加1。您可以将一个数字作为方法增加的参数，此时它将根据提供的数字增加计数器的值。这个数字始终应该是正数。
- en: There’s more…
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can create metrics by using a more declarative approach with `ObservedAspect`
    bean.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`ObservedAspect` bean以更声明性的方式创建指标。
- en: 'To add the dependency to the *AOP starter*, include the following in your `pom.xml`
    file:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 要将依赖项添加到*AOP starter*，请在您的`pom.xml`文件中包含以下内容：
- en: '[PRE58]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To configure the `ObserverAspect` bean, add the following method to the `Football``Configuration`
    class:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置`ObserverAspect` bean，请将以下方法添加到`Football`配置类中：
- en: '[PRE59]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'At this point, you can use the `@Observed` annotation in your code to generate
    metrics automatically. For instance, in this recipe, we could annotate the `AuctionService`
    class with `@Observed`:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您可以在代码中使用`@Observed`注解来自动生成指标。例如，在本食谱中，我们可以用`@Observed`注解`AuctionService`类：
- en: '[PRE60]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Then, you can simplify the class as you don’t need to explicitly create the
    counters in the constructor. In the `addBidAOP` method, you only need to focus
    on the application logic:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以简化类，因为您不需要在构造函数中显式创建计数器。在`addBidAOP`方法中，您只需要关注应用逻辑：
- en: '[PRE61]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'When you run the application and `AuctionService` is used (the metrics are
    created lazily the first time the methods are used), you will see that there are
    two new metrics in the Actuator metrics endpoint:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行应用程序并且使用`AuctionService`（第一次使用方法时指标是延迟创建的）时，您将看到Actuator指标端点中有两个新的指标：
- en: '`football.auction`: Provides general counters for the methods defined in your
    annotated class'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`football.auction`：为您的注解类中定义的方法提供通用计数器'
- en: '`football.auction.active`: Provides counters for active executions for the
    methods defined in your annotated class'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`football.auction.active`：为您的注解类中定义的方法提供活动执行的计数器'
- en: 'The following is a sample of the `football.auction` metric that was obtained
    from `http://localhost:8080/actuator/endpoint/football.auction`:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从`http://localhost:8080/actuator/endpoint/football.auction`获取的`football.auction`指标的示例：
- en: '[PRE62]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You can get metrics for a specific method using tags. For instance, to get
    the metrics of the `addBidAOP` method, you can perform the following request:
    `http://localhost:8080/actuator/metrics/football.auction?tag=method:addBidAOP`.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用标签获取特定方法的指标。例如，要获取`addBidAOP`方法的指标，您可以执行以下请求：`http://localhost:8080/actuator/metrics/football.auction?tag=method:addBidAOP`。
- en: 'This service is implemented in this book’s GitHub repository at `https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook`,
    in the `chapter3/recipe3-8/end` folder. As mentioned previously, the metric is
    created lazily, so you should invoke this service to make it available. You can
    do this by executing the following `curl` request in your terminal:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务在本书的GitHub仓库中实现，位于`https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook`的`chapter3/recipe3-8/end`文件夹中。如前所述，该指标是延迟创建的，因此您应该调用此服务以使其可用。您可以通过在终端中执行以下`curl`请求来实现：
- en: '[PRE63]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Integrating your application with Prometheus and Grafana
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将您的应用程序与Prometheus和Grafana集成
- en: You have a successful Football Trading application, and you can observe it by
    calling the various Actuator endpoints. However, this way of observing the application
    is too manual. So, you want a system that allows you to automate how your application
    is monitored.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 您拥有一个成功的足球交易应用，并且可以通过调用各种Actuator端点来观察它。然而，这种方式观察应用过于手动。因此，您希望有一个系统允许您自动化应用监控的方式。
- en: In this recipe, you will learn how to expose the metrics of your application
    using a format that can be used by **Prometheus**, after which you will use the
    Prometheus data as a source for **Grafana**. Prometheus is an open source monitoring
    solution that collects and aggregates metrics as time series data, then stores
    the events in real time so that the events can be used to monitor your application.
    Grafana is an open source tool for visualization that allows you to create custom
    dashboards, graphs, and even alerts. One of the sources Grafana can use is the
    data collected by Prometheus. The combination of both tools is a very popular
    choice due to its ease of use, flexibility, and scalability.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，您将学习如何使用 **Prometheus** 可以使用的格式公开您的应用程序指标，之后您将使用 Prometheus 数据作为 **Grafana**
    的数据源。Prometheus 是一个开源的监控解决方案，它收集和聚合指标作为时间序列数据，然后实时存储事件，以便事件可以用于监控您的应用程序。Grafana
    是一个开源的可视化工具，允许您创建自定义仪表板、图表，甚至警报。Grafana 可以使用的数据源之一是 Prometheus 收集的数据。由于易于使用、灵活性和可扩展性，这两个工具的组合是一个非常受欢迎的选择。
- en: Getting ready
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, you will reuse the outcome of the *Creating your own metrics*
    recipe. I’ve prepared a working version of this in case you haven’t completed
    it yet. You can find it in this book’s GitHub repository at https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/,
    in the `chapter3/recipe3-7/start` folder.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，您将重用 *创建您自己的指标* 食谱的结果。如果您还没有完成它，我已经准备了一个工作版本。您可以在本书的 GitHub 仓库 https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/
    中找到它，在 `chapter3/recipe3-7/start` 文件夹中。
- en: You will use Prometheus and Grafana servers. As usual, the easiest way to run
    Prometheus and Grafana on your local computer is by using Docker.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用 Prometheus 和 Grafana 服务器。像往常一样，在您的本地计算机上运行 Prometheus 和 Grafana 最简单的方法是使用
    Docker。
- en: 'To download and start Prometheus, run the following command in your terminal:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载并启动 Prometheus，请在您的终端中运行以下命令：
- en: '[PRE64]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This command uses the `-v` parameter to mount a volume to a file named `prometheus.yml`.
    This file contains the configuration for Prometheus. The configuration will be
    described and created as part of this recipe in the *How to do* *it…* section.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令使用 `-v` 参数将卷挂载到名为 `prometheus.yml` 的文件中。此文件包含 Prometheus 的配置。配置将在 *如何做* *它…*
    部分作为本食谱的一部分进行描述和创建。
- en: 'To download and start Grafana, run the following command in your terminal:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载并启动 Grafana，请在您的终端中运行以下命令：
- en: '[PRE65]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: To simulate a workload for the new feature, I’ve created a JMeter script. You
    can find it in this book’s GitHub repository, in the `chapter3/recipe3-7/jmeter`
    folder. You can download JMeter from the project’s website at [https://jmeter.apache.org/download_jmeter.cgi](https://jmeter.apache.org/download_jmeter.cgi).
    From here, download a ZIP file containing JMeter binaries and unzip it; no further
    installation is required. To run JMeter, go to the folder where you unzipped the
    binaries, then open the `bin` folder. Here, you will find different scripts to
    launch JMeter, depending on your operating system. For Unix, you can run the `jmeter`
    script, while for Windows, you can run the `jmeter.bat` script.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟新功能的工作负载，我创建了一个 JMeter 脚本。您可以在本书的 GitHub 仓库中找到它，在 `chapter3/recipe3-7/jmeter`
    文件夹中。您可以从项目的网站 [https://jmeter.apache.org/download_jmeter.cgi](https://jmeter.apache.org/download_jmeter.cgi)
    下载 JMeter。从这里，下载包含 JMeter 二进制文件的 ZIP 文件，并将其解压；不需要进一步安装。要运行 JMeter，请转到您解压二进制文件的文件夹，然后打开
    `bin` 文件夹。在这里，您将找到不同的脚本以启动 JMeter，具体取决于您的操作系统。对于 Unix，您可以运行 `jmeter` 脚本，而对于 Windows，您可以运行
    `jmeter.bat` 脚本。
- en: How to do it…
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'First, we’ll configure our application so that it exposes a Prometheus endpoint.
    Afterward, we’ll set up Prometheus and Grafana so that we can ingest the data
    provided by our application:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将配置我们的应用程序，使其公开 Prometheus 端点。之后，我们将设置 Prometheus 和 Grafana，以便我们可以摄取应用程序提供的数据：
- en: 'Let’s start by exposing a Prometheus endpoint to the trading application. For
    that, two steps are necessary:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从向交易应用程序公开 Prometheus 端点开始。为此，需要两个步骤：
- en: 'Add the following dependency to the `pom.xml` file:'
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下依赖项添加到 `pom.xml` 文件中：
- en: '[PRE66]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Expose the Prometheus endpoint. To do so, open the `application.yml` file in
    the `resources` folder and add the following highlighted properties:'
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 公开 Prometheus 端点。为此，打开 `resources` 文件夹中的 `application.yml` 文件，并添加以下突出显示的属性：
- en: '[PRE67]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: You can run the application and open the Prometheus endpoint at http://localhost:8080/actuator/prometheus.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以运行应用程序并打开 Prometheus 端点 http://localhost:8080/actuator/prometheus。
- en: 'The next step is running Prometheus and configuring it to consume the newly
    exposed endpoint. You can configure Prometheus by creating a `.yaml` configuration
    file and mounting it on the Prometheus Docker image:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是运行 Prometheus 并配置它以消费新暴露的端点。你可以通过创建一个 `.yaml` 配置文件并将其挂载到 Prometheus Docker
    镜像上来配置 Prometheus：
- en: 'Prometheus will be hosted on Docker, while the application will be hosted on
    your computer, the Docker host. The first task is obtaining the IP address of
    your computer. On Linux, you can run the following command in your Terminal:'
  id: totrans-367
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Prometheus 将托管在 Docker 上，而应用程序将托管在你的计算机上，即 Docker 主机。第一个任务是获取你计算机的 IP 地址。在 Linux
    上，你可以在终端中运行以下命令：
- en: '[PRE68]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'On Windows, you can run the following command in your terminal:'
  id: totrans-369
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Windows 上，你可以在你的终端中运行以下命令：
- en: '[PRE69]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: If you run your application in `ip addr show` in a WSL terminal.
  id: totrans-371
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在一个 WSL 终端中运行你的应用程序的 `ip addr show`。
- en: For instance, the IP of my interface is `172.26.109.186` when I run `ip addr
    show`. I will use this value to configure the Prometheus YAML file.
  id: totrans-372
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，当我运行 `ip addr show` 时，我接口的 IP 地址是 `172.26.109.186`。我将使用这个值来配置 Prometheus
    YAML 文件。
- en: 'Let’s continue by creating the configuration file using the IP address we obtained
    in the previous step. In the project’s root directory, create an application named
    `prometheus.yml` with the following content:'
  id: totrans-373
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续，使用上一步中获得的 IP 地址创建配置文件。在项目的根目录下，创建一个名为 `prometheus.yml` 的应用程序，内容如下：
- en: '[PRE70]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Note that we configured the metrics path exposed by our application, and the
    target is the IP address and port of our application.
  id: totrans-375
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，我们配置了应用程序暴露的指标路径，目标是我们的应用程序的 IP 地址和端口。
- en: 'Now, run the Prometheus container using the configuration file. For that, in
    the same directory you created the configuration file, execute the following command
    in your terminal:'
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用配置文件运行 Prometheus 容器。为此，在创建配置文件的同一目录中，在终端中执行以下命令：
- en: '[PRE71]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, Prometheus should be working and *scrapping* your application to get observability
    data. To verify it’s working, you can open Prometheus at http://localhost:9090,
    then open the **Status** menu and select **Targets**:![Figure 3.9: Prometheus
    targets](img/B21646_03_9.jpg)'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，Prometheus 应该正在运行并**抓取**你的应用程序以获取可观察性数据。要验证它是否正常工作，你可以在 http://localhost:9090
    打开 Prometheus，然后打开**状态**菜单并选择**目标**：![图 3.9：Prometheus 目标](img/B21646_03_9.jpg)
- en: 'Figure 3.9: Prometheus targets'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9：Prometheus 目标
- en: Verify that the status of your target is working. It should be **UP**.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 验证你的目标状态是否正常工作。它应该是**UP**。
- en: 'You can use Prometheus to visualize the data from your application. Go to the
    Prometheus home page, search for any metric, and click on **Execute** to see the
    data. If you select the **Graph** tab, you will see the data in graphical form:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用 Prometheus 来可视化你应用程序的数据。转到 Prometheus 主页，搜索任何指标，然后点击**执行**以查看数据。如果你选择**图形**选项卡，你将看到图形形式的数据：
- en: '![Figure 3.10: Visualizing data in Prometheus](img/B21646_03_10.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10：在 Prometheus 中可视化数据](img/B21646_03_10.jpg)'
- en: 'Figure 3.10: Visualizing data in Prometheus'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10：在 Prometheus 中可视化数据
- en: 'The visualization capabilities that are available in Prometheus are a bit limited,
    but we can use Grafana and connect it to Prometheus to achieve better visualization:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Prometheus 中可用的可视化功能有点有限，但我们可以使用 Grafana 并将其连接到 Prometheus 以实现更好的可视化：
- en: 'Ensure that Grafana is running. As explained in the *Getting ready* section,
    you can run Grafana using Docker by executing the following command in your terminal:'
  id: totrans-385
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保Grafana正在运行。如*准备就绪*部分所述，你可以在终端中执行以下命令来运行 Grafana：
- en: '[PRE72]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now, you can open Grafana by opening the following address in your browser:
    `http://localhost:3000`. You will be asked for your credentials. You can use the
    default credentials – that is, user set to `admin` and password set to `admin`.'
  id: totrans-387
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以在浏览器中打开以下地址来打开 Grafana：`http://localhost:3000`。你将需要输入你的凭证。你可以使用默认凭证——即用户设置为
    `admin`，密码设置为 `admin`。
- en: 'Next, you will need to connect Prometheus as a Grafana data source. At this
    point, both containers are running in Docker:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你需要将 Prometheus 作为 Grafana 数据源连接。此时，两个容器都在 Docker 中运行：
- en: 'First, you will need to obtain the Prometheus IP address in Docker. You can
    get this information by inspecting the container. Execute the following commands
    to get the IP address of the container:'
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要获取 Docker 中的 Prometheus IP 地址。你可以通过检查容器来获取此信息。执行以下命令以获取容器的 IP 地址：
- en: 'To retrieve the container ID, run the following command:'
  id: totrans-390
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要检索容器 ID，运行以下命令：
- en: '[PRE73]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'My container ID was `5affa2883c43`. Replace this with your container ID when
    running the following command:'
  id: totrans-392
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的容器ID是`5affa2883c43`。在运行以下命令时，用你的容器ID替换它：
- en: '[PRE74]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'My terminal looks like this:'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我的终端看起来像这样：
- en: '![Figure 3.11: Using docker inspect to get the container’s IP address](img/B21646_03_11.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![图3.11：使用docker inspect获取容器的IP地址](img/B21646_03_11.jpg)'
- en: 'Figure 3.11: Using docker inspect to get the container’s IP address'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11：使用docker inspect获取容器的IP地址
- en: 'Now, open the menu on the left and select **Connections** | **Data sources**:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开左侧菜单并选择**连接** | **数据源**：
- en: '![Figure 3.12: Opening Data sources](img/B21646_03_12.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![图3.12：打开数据源](img/B21646_03_12.jpg)'
- en: 'Figure 3.12: Opening Data sources'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12：打开数据源
- en: 'Click `Prometheus` in the search bar:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在搜索栏中点击`Prometheus`：
- en: '![Figure 3.13: Selecting Prometheus as a data source](img/B21646_03_13.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
  zh: '![图3.13：选择Prometheus作为数据源](img/B21646_03_13.jpg)'
- en: 'Figure 3.13: Selecting Prometheus as a data source'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13：选择Prometheus作为数据源
- en: 'Then, configure the `172.17.0.3`, but you likely have another value. The port
    is `9090`:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，配置`172.17.0.3`，但你的值可能不同。端口号是`9090`：
- en: '![Figure 3.14: Configuring the Prometheus server URL property](img/B21646_03_14.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![图3.14：配置Prometheus服务器URL属性](img/B21646_03_14.jpg)'
- en: 'Figure 3.14: Configuring the Prometheus server URL property'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14：配置Prometheus服务器URL属性
- en: You can keep the default value for the rest of the parameters. At the bottom
    of the page, you’ll find the **Save & Test** button. Click on it. At this point,
    you can start visualizing data by building a dashboard.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其余参数，你可以保留默认值。在页面底部，你会找到**保存并测试**按钮。点击它。此时，你可以通过构建仪表板来开始可视化数据。
- en: 'Finally, create a dashboard to visualize the number of pending bids. Go to
    `football_bids_pending`, and then click **Run queries**. Change the time range
    to the last 30 minutes. Finally, click **Save**:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个仪表板来可视化待处理竞标的数量。转到`football_bids_pending`，然后点击**运行查询**。将时间范围更改为过去30分钟。最后，点击**保存**：
- en: '![Figure 3.15: Configuring a panel](img/B21646_03_15.jpg)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![图3.15：配置面板](img/B21646_03_15.jpg)'
- en: 'Figure 3.15: Configuring a panel'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15：配置面板
- en: Now, save your dashboard. Name it `Pending Bids`.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，保存你的仪表板。将其命名为`待处理竞标`。
- en: 'Run a load test to see how metrics are visualized in the panel. You can use
    the JMeter script I created to generate some traffic. You can find it in this
    book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/),
    in the `chapter3/recipe3-7/jmeter` folder. The Grafana panel should look like
    this:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行负载测试以查看指标如何在面板中可视化。你可以使用我创建的JMeter脚本来生成一些流量。你可以在本书的GitHub仓库中找到它，在`chapter3/recipe3-7/jmeter`文件夹中。[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/)。Grafana面板应该看起来像这样：
- en: '![Figure 3.16: Pending bids visualized in Grafana](img/B21646_03_16.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![图3.16：在Grafana中可视化的待处理竞标](img/B21646_03_16.jpg)'
- en: 'Figure 3.16: Pending bids visualized in Grafana'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.16：在Grafana中可视化的待处理竞标
- en: With that, you’ve learned how to visualize your metrics in powerful tools such
    as Grafana.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，你已经学会了如何在Grafana等强大工具中可视化你的指标。
- en: How it works…
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Prometheus is an extensible tool that can use exporters. These exporters are
    jobs that run in Prometheus and can get data from external sources if they’re
    exposed using the appropriate format. This recipe’s job scrapes the data, meaning
    that it gets the data from the external source periodically. In this recipe, we
    configured our application to export the data in a format that Prometheus can
    understand, after which we configured a target to retrieve that data.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus是一个可扩展的工具，可以使用导出器。这些导出器是在Prometheus中运行的作业，如果它们使用适当的格式公开，可以从外部源获取数据。本食谱的作业定期从外部源抓取数据。在本食谱中，我们配置了我们的应用程序以导出Prometheus可以理解的数据格式，然后我们配置了一个目标来检索这些数据。
- en: 'Some of the benefits of using Prometheus are as follows:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Prometheus的一些好处如下：
- en: It can take metrics from multiple sources – not only applications but also infrastructure
    components.
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以从多个来源获取指标——不仅限于应用程序，还包括基础设施组件。
- en: It allows PromQL to be used, a language for querying and aggregating data. You
    can combine this data from multiple sources to extract relevant information for
    monitoring.
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许使用PromQL，这是一种用于查询和聚合数据的语言。你可以将来自多个来源的数据组合起来，以提取用于监控的相关信息。
- en: You can create alerts based on queries and the thresholds you define. For instance,
    we could use CPU usage thresholds or our pending bids to send an alert.
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以根据查询和定义的阈值创建警报。例如，我们可以使用CPU使用率阈值或我们的待处理竞标来发送警报。
- en: Grafana can take data from different sources; one of them is Prometheus. This
    combination is very popular for monitoring solutions. Grafana can be used for
    advanced visualizations, and it also allows you to create alerts and send notifications.
    This is very important as it improves the monitoring automation process.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: Grafana可以从不同的来源获取数据；其中之一是Prometheus。这种组合在监控解决方案中非常受欢迎。Grafana可以用于高级可视化，它还允许你创建警报并发送通知。这非常重要，因为它提高了监控自动化过程。
- en: In this recipe, we used these popular open source tools, but the same approach
    can be used with other commercial tools. Usually, monitoring tools manage tracing,
    logging, and metrics, adding capabilities for visualization, such as dashboards
    and alerting by different channels.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用了这些流行的开源工具，但相同的做法也可以用于其他商业工具。通常，监控工具管理跟踪、日志和指标，并添加可视化功能，如仪表板和通过不同渠道的警报。
- en: An important thing to think about is when you should use traces or metrics for
    monitoring. Traces are very useful in showing the relationship between services
    and finding the specific operations using data from the transaction itself. This
    is very helpful in finding the root cause of an issue. The main issue with traces
    is that in scenarios with a high volume of operations, the amount of data that’s
    generated can be huge, and usually, the traces are sampled so that all the data
    that’s been generated can be processed and the cost can be controlled.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的一个重要问题是，在何时应该使用跟踪或指标进行监控。跟踪在显示服务之间的关系以及使用事务本身的数据查找特定操作方面非常有用。这有助于找到问题的根本原因。跟踪的主要问题是，在高操作量的场景中，生成的大量数据可能非常庞大，通常，跟踪会被采样，以便所有生成的数据都可以被处理，并且成本可以得到控制。
- en: On the other hand, the metrics aggregate the measurements, and they just export
    those aggregated measurements periodically to create the time series data. Then,
    the data that’s generated is constant, regardless of the traffic managed by the
    target system. The main advantage of metrics is that they don’t require sampling
    and the data that’s generated is quite precise. For that reason, the metrics are
    more appropriate for certain types of alerts. However, when you need to find the
    root cause of an issue, traces are more appropriate.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，指标汇总测量值，并且它们定期导出这些汇总测量值以创建时间序列数据。然后，生成的数据是恒定的，无论目标系统管理的流量如何。指标的主要优势是它们不需要采样，生成数据相当精确。因此，指标更适合某些类型的警报。然而，当你需要找到问题的根本原因时，跟踪更适合。
- en: Changing the settings of a running application
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改正在运行的应用程序的设置
- en: So far, you’ve added logging to your successful football trading application,
    and it receives quite a lot of traffic. The program creates logs in different
    places. These logs can help you figure out what the program did while it was running.
    Not every log is equally important. So, the program uses various log levels, ranging
    from debugging to error logs. Sorting logs by their level prevents an excessive
    number of logs from being created. However, you want to ensure you can change
    the minimum level of logs to be processed without restarting or redeploying your
    application.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经为你的成功的足球交易应用程序添加了日志，并且它接收了相当多的流量。程序在不同的地方创建日志。这些日志可以帮助你了解程序在运行时做了什么。并非每个日志都同等重要。因此，程序使用各种日志级别，从调试到错误日志。按日志级别排序可以防止创建过多的日志。然而，你想要确保可以在不重新启动或重新部署应用程序的情况下更改要处理的日志的最小级别。
- en: Some Spring Boot Actuator endpoints allow you to make changes in runtime, with
    no need to restart the application. The logging endpoint is one of those endpoints
    as it allows you to change the minimum level of logging.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Spring Boot Actuator端点允许你在运行时进行更改，无需重新启动应用程序。日志端点是这些端点之一，因为它允许你更改日志的最小级别。
- en: In this recipe, you will learn how to change the logging level of a running
    application.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何更改正在运行的应用程序的日志级别。
- en: Getting ready
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, you will reuse the outcome of the *Integrating your application
    with Prometheus and Grafana* recipe. I’ve prepared a working version in case you
    haven’t completed it yet. You can find it in this book’s GitHub repository at
    https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/, in the `chapter3/recipe3-8/start`
    folder.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将重用*将你的应用程序与Prometheus和Grafana集成*菜谱的结果。如果你还没有完成它，我已经准备了一个工作版本。你可以在本书的GitHub仓库中找到它，网址为https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/，在`chapter3/recipe3-8/start`文件夹中。
- en: How to do it…
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this recipe, you’ll adapt the football trading application so that it generates
    logs with different levels of importance. Once you’ve done this you’ll learn how
    to change the level at runtime:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，你将调整足球交易应用程序，使其生成不同重要级别的日志。一旦完成，你将学习如何在运行时更改级别：
- en: 'First, let’s add some logs to the `TradingService` class:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们向`TradingService`类添加一些日志：
- en: 'Create a logger for the class. You can define a static member for this purpose:'
  id: totrans-434
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为该类创建一个日志记录器。你可以为此定义一个静态成员：
- en: '[PRE75]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Then, add debug and information logging to the `getPendingOrders` method:'
  id: totrans-436
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，向`getPendingOrders`方法添加调试和信息日志记录：
- en: '[PRE76]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'You can also add some logging for the `tradeCards` method:'
  id: totrans-438
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以为`tradeCards`方法添加一些日志记录：
- en: '[PRE77]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now, you can perform some requests and validate that the information is being
    logged. You can execute the following command in your terminal to execute a request
    every second:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以执行一些请求并验证信息是否被记录。你可以在你的终端中执行以下命令来每秒执行一个请求：
- en: '[PRE78]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'You will see that only `INFO` and `WARN` logs are processed:'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会看到只有`INFO`和`WARN`日志被处理：
- en: '![Figure 3.17: Only INFO and WARN logs are processed](img/B21646_03_17.jpg)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.17：只有 INFO 和 WARN 日志被处理](img/B21646_03_17.jpg)'
- en: 'Figure 3.17: Only INFO and WARN logs are processed'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.17：只有 INFO 和 WARN 日志被处理
- en: This is because the default level is `INFO`. This means that only `INFO` or
    higher priority levels are logged.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为默认级别是`INFO`。这意味着只有`INFO`或更高优先级的级别会被记录。
- en: You can verify the log level by calling the Actuator `loggers` endpoint. Go
    to http://localhost:8080/actuator/loggers. You will see the available log levels,
    as well as the loggers that are defined in your application. You will see that
    there is a logger for your service class, `com.packt.footballobs.service.TradingService`,
    and that the effective level is `INFO`.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过调用Actuator的`loggers`端点来验证日志级别。访问http://localhost:8080/actuator/loggers。你会看到可用的日志级别，以及你应用程序中定义的日志记录器。你会看到有一个为你服务类`com.packt.footballobs.service.TradingService`的日志记录器，并且有效级别是`INFO`。
- en: 'Let’s say you’ve detected an issue in the application, and you want to activate
    the `DEBUG` level. Let’s change it by using the Actuator `loggers` endpoint. For
    that, you just need to perform the following request:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你已经在应用程序中检测到一个问题，并且你想激活`DEBUG`级别。让我们通过使用Actuator的`loggers`端点来更改它。为此，你只需要执行以下请求：
- en: '[PRE79]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'You will see that it now generates logs for `DEBUG` as well:'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会看到它现在还生成了`DEBUG`级别的日志：
- en: '![Figure 3.18: DEBUG and higher critical logs are generated](img/B21646_03_18.jpg)'
  id: totrans-450
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.18：生成 DEBUG 和更高优先级的临界日志](img/B21646_03_18.jpg)'
- en: 'Figure 3.18: DEBUG and higher critical logs are generated'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.18：生成 DEBUG 和更高优先级的临界日志
- en: 'If you verify the `loggers` endpoint, as explained in *Step 3*, you will see
    that the `TradingService` class now has two attributes:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你验证了*步骤 3*中解释的`loggers`端点，你会看到`TradingService`类现在有两个属性：
- en: '`configuredLevel`: `DEBUG`'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configuredLevel`: `DEBUG`'
- en: '`effectiveLevel`: `DEBUG`'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`effectiveLevel`: `DEBUG`'
- en: 'Now that you’ve verified the logs, you decide to change the log level to `WARN`
    by running the following command since too much noise is generated by `DEBUG`
    and `INFO` logs:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经验证了日志，你决定将日志级别更改为`WARN`，因为`DEBUG`和`INFO`日志产生了太多的噪音，你可以运行以下命令：
- en: '[PRE80]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: If you verify the `loggers` endpoint, as explained in *Step 3*, you will see
    that the `TradingService` level is `WARN`. If you continue making requests, you
    will see that only `WARN` logs are emitted.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你验证了*步骤 3*中解释的`loggers`端点，你会看到`TradingService`的级别是`WARN`。如果你继续发送请求，你会看到只有`WARN`日志被输出。
- en: How it works…
  id: totrans-458
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: As we saw in the *Creating a custom Actuator endpoint* recipe, some endpoints
    implement update and delete operations. The `loggers` endpoint allows you to change
    the log level. This is a very helpful feature when you need to find issues in
    production as you no longer need to restart your application.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*创建自定义Actuator端点*的配方中看到的，一些端点实现了更新和删除操作。`loggers`端点允许你更改日志级别。当你需要在生产环境中查找问题时，这是一个非常有用的功能，因为你不再需要重新启动你的应用程序。
- en: In an application with high traffic, you will usually want to have a high log
    level, such as `WARN`. This is the warning level and is typically used to indicate
    that there is a potential issue or anomaly that should be noted. It signifies
    a situation that may not necessarily be an error, but it could lead to problems
    if it’s not addressed. The reason for using higher log levels, such as `WARN`,
    is that the logs are usually saved by the monitoring system. If the application
    generates too many logs, it requires more resources to process and retain them,
    and that can be costly. At the same time, `DEBUG` and `INFO` logs are not critical
    and they can generate too much information, making it more difficult to find the
    root cause of the problems.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在高流量应用中，你通常会希望设置较高的日志级别，例如`WARN`。这是警告级别，通常用于指示存在潜在问题或异常，应该引起注意。它表示的情况可能不一定是一个错误，但如果未解决，可能会导致问题。使用更高日志级别，如`WARN`的原因是日志通常由监控系统保存。如果应用生成太多日志，处理和保留它们需要更多资源，这可能会造成成本增加。同时，`DEBUG`和`INFO`日志不是关键的，它们可能会生成过多信息，使得找到问题的根本原因变得更加困难。
- en: There’s more…
  id: totrans-461
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Other standard endpoints are part of Spring Boot that allow you to make changes
    at runtime. For instance, the `sessions` endpoint allows you to retrieve and delete
    user sessions.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 其他标准端点是Spring Boot的一部分，允许你在运行时进行更改。例如，`sessions`端点允许你检索和删除用户会话。
