- en: Chapter 5. Testing Your Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 测试你的应用程序
- en: In the chapters so far, we bootstrapped our application using Activator, developed
    our web application using Scala and the Play framework, and added a Reactive microservice
    call using RxScala for data flow computations. Now we will go ahead and enter
    the unit test and controller testing using the BDD and Play framework.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在到目前为止的章节中，我们使用Activator启动了我们的应用程序，使用Scala和Play框架开发了我们的Web应用程序，并使用RxScala添加了一个响应式微服务调用以进行数据流计算。现在我们将继续进行单元测试和控制器测试，使用BDD和Play框架。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Unit testing principles
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试原则
- en: Testing Scala applications with JUnit
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JUnit测试Scala应用程序
- en: Behavior-driven development principles
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为驱动开发原则
- en: Testing with ScalaTest
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ScalaTest进行测试
- en: Testing Play framework applications with ScalaTest
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ScalaTest测试Play框架应用程序
- en: Running tests in Activator / SBT
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Activator / SBT中运行测试
- en: The need for `testingTest` is a fundamental and very important part of software
    development. Without tests, we cannot be sure that our code works. We should perform
    tests on almost all the code we produce. There are things that don't make sense
    for testing, for instance, case classes and classes that just represent structural
    objects, or, in other words, classes without functions. If you have code that
    applies computations, transformations, and validations, you definitely want to
    test this code with a good code coverage, which refers to features or any important
    code that is not just structural.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`testingTest`的需求是软件开发的一个基本且非常重要的部分。没有测试，我们无法确保我们的代码是正确的。我们应该对我们产生的几乎所有代码进行测试。有些东西不适合测试，例如，案例类和仅代表结构对象的类，换句话说，没有函数的类。如果你有应用计算、转换和验证的代码，你肯定希望使用良好的代码覆盖率来测试这些代码，这指的是功能或任何重要的代码，而不仅仅是结构性的。'
- en: Test coverage is important, because it allows us to do refactoring (improve
    application code quality by reducing code, creating generic code, or even deleting
    code) with trust. This is because, if you have tests and if you do something wrong
    by accident, your tests will let you know. This is all about having short cycles
    of feedback. The earlier the better; you want to know if you have introduced bugs
    as soon, and as close to development, as possible. Nobody likes to discover bugs
    that could be caught by a simple test in production.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 测试覆盖率很重要，因为它允许我们带着信任进行重构（通过减少代码、创建通用代码，甚至删除代码来提高应用程序代码质量）。这是因为，如果你有测试，并且你意外地做错了什么，你的测试会告诉你。这全部关于拥有短周期的反馈。越早越好；你希望尽早、尽可能接近开发地发现你引入的bug。没有人喜欢在生产中发现那些可以通过简单测试捕获的bug。
- en: Unit testing principles
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试原则
- en: Unit testing is the smallest unit of testing that you could possibly apply.
    You need to apply it at the class level. So a unit test will cover your class
    with all the functions you have there. But hold on a minute, a class often has
    dependencies, and these dependencies might have other dependencies, so how do
    you test that? We need to have mocks, simple dumb objects that simulate other
    classes' behavior. This is an important technique to isolate code and allow unit
    testing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是你可能应用的最小测试单元。你需要将其应用于类级别。因此，一个单元测试将覆盖你拥有的所有函数的类。但是，等等，一个类通常有依赖项，而这些依赖项可能有其他的依赖项，那么你该如何测试呢？我们需要有模拟，简单的哑对象，它们模拟其他类的行为。这是隔离代码并允许单元测试的重要技术。
- en: Making code testable
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使代码可测试
- en: 'Unit testing is simple: basically, we call a function by passing arguments
    to it, and then we check the output to see if it matches our expectations. This
    is also called asserts or assertions. So, unit testing is about asserts. Sometimes,
    your code might not be testable. For instance, let''s say you have a function
    that returns a unit and has no parameters. This is very tough to test, because
    it implies that the function is full of side-effects. If you remember what we
    discussed in [Chapter 1](part0015.xhtml#aid-E9OE1 "Chapter 1. Introduction to
    FP, Reactive, and Scala"), *Introduction to FP, Reactive, and Scala*, this is
    against FP principles. So, if we have this case, we need to refactor the code
    to make the function return something, and then we can test it.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试很简单：基本上，我们通过向函数传递参数来调用它，然后检查输出是否与我们的预期相符。这也被称为断言或断言。因此，单元测试是关于断言的。有时，你的代码可能不可测试。例如，假设你有一个没有参数且返回单位的函数。这非常难以测试，因为它意味着函数充满了副作用。如果你还记得我们在[第1章](part0015.xhtml#aid-E9OE1
    "第1章。函数式编程、响应式编程和Scala简介")中讨论的内容，*函数式编程、响应式编程和Scala简介*，这是违反函数式编程原则的。因此，如果我们遇到这种情况，我们需要重构代码，使函数返回某些内容，然后我们才能对其进行测试。
- en: Isolation and self-contained tests
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隔离和自包含测试
- en: Unit tests should be self-contained, which means that a unit test's classes
    should not depend on any particular order of execution. Let's say you have a unit
    test class with two test functions. So, each test should test just one function
    at a time, and both functions should be able to run in any order whatsoever. Otherwise,
    the tests will be fragile and hard to maintain in the long run.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试应该是自包含的，这意味着单元测试中的类不应该依赖于任何特定的执行顺序。假设你有一个包含两个测试函数的单元测试类。因此，每个测试应该一次只测试一个函数，并且这两个函数应该能够以任何顺序运行。否则，测试将变得脆弱，长期维护起来也会很困难。
- en: Effective naming
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有效的命名
- en: 'Effective naming is essential. The test function needs to say exactly what
    the test does. This is important because, when the test fails, it is easier to
    figure out what went wrong and why. Following the same idea, when you do assertions,
    you should assert just one thing at a time. Imagine that you need to test whether
    a web service returns a valid JSON. This particular JSON could have two fields:
    first name and last name. So, you will make one assert for the name and an other
    for the last name. This way, it will be easier to understand what the test does,
    and to troubleshoot when the test fails.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的命名是至关重要的。测试函数需要确切地说明测试做了什么。这很重要，因为当测试失败时，更容易找出出错的原因和原因。遵循同样的思路，当你进行断言时，你应该一次只断言一件事情。想象一下，你需要测试一个网络服务是否返回有效的JSON。这个特定的JSON可能有两个字段：名字和姓氏。因此，你将为一个名字进行一次断言，为姓氏进行另一次断言。这样，将更容易理解测试做了什么，以及当测试失败时如何进行故障排除。
- en: Levels of testing
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试层次
- en: When we run tests, we often do it in layers. Unit testing is the basic level;
    however, there are other levels such as controller tests, integration tests, UI
    tests, End-to-End tests, stress tests, and so many others. For this book, we will
    cover unit tests, controller tests, and UI tests using Junit and `ScalaTest`,Play's
    framework support.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行测试时，我们通常分层进行。单元测试是基本层；然而，还有其他层次，如控制器测试、集成测试、UI测试、端到端测试、压力测试，等等。对于这本书，我们将使用JUnit和`ScalaTest`，Play框架的支持，来介绍单元测试、控制器测试和UI测试。
- en: Testing with Junit
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JUnit进行测试
- en: If you come from a Java background, it is highly possible that you have already
    worked with Junit. It's possible to test with Junit using the Scala and Play framework.
    However, this is not the best practice when we are creating applications with
    the Play framework, since it favors **Behavior Driven Development** (**BDD**)
    testing with Scala Spec. For this chapter, we will cover how to perform all sorts
    of test using BDD and Play. Right now, let's take a look at how we can do unit
    testing with Junit before we move to BDD.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自Java背景，你很可能已经使用过JUnit。你可以使用Scala和Play框架进行JUnit测试。然而，当我们使用Play框架创建应用程序时，这并不是最佳实践，因为它更倾向于使用Scala
    Spec进行**行为驱动开发**（**BDD**）测试。对于本章，我们将介绍如何使用BDD和Play进行各种测试。现在，在我们转向BDD之前，让我们看看如何使用JUnit进行单元测试。
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: So what we have in the preceding code is a class that extends `PlaySpec`, and
    adds a trait called `AssertionForJunit`. Why don't we have the classical Junit
    class here? Because the Play framework is set up to run Scala tests, so this bridge
    allows us to run Junit by `ScalaTest` Play framework constructs.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在前面代码中，我们有一个扩展 `PlaySpec` 并添加了一个名为 `AssertionForJunit` 的特质的类。为什么这里没有经典的 JUnit
    类？因为 Play 框架已经设置为运行 Scala 测试，所以这个桥梁允许我们通过 `ScalaTest` Play 框架构造来运行 JUnit。
- en: Then we have a test function called `testBaseServer` , which uses the `@Test`
    annotation from JUnit. Inside the test method, we create an instance of `ProductService`,
    and then we call the function `findAll`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一个名为 `testBaseServer` 的测试函数，它使用 JUnit 的 `@Test` 注解。在测试方法内部，我们创建一个 `ProductService`
    实例，然后调用 `findAll` 函数。
- en: Finally, we have assertions that will check if the result is what we are expecting.
    So we don't have products, because we did not insert them earlier. Hence, we expect
    to have `None` as the response, and the result should also not be `null`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有断言将检查结果是否符合我们的预期。因此，我们没有产品，因为我们之前没有插入它们。因此，我们期望响应为 `None`，结果也不应该是 `null`。
- en: 'You can run this in your console using the following command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令在您的控制台中运行此操作：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You will see the result shown in the next screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在下一张截图看到结果：
- en: '![Testing with Junit](img/image00273.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Junit 进行测试](img/image00273.jpeg)'
- en: 'As you can see, our test was executed without any issues. It''s also possible
    to run this test and a normal test in Junit using the Eclipse IDE. You just right-click
    on the file and select  ****Run As: Scala Junit Test**;** refer to the following
    screenshot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的测试执行没有任何问题。您也可以在 Eclipse IDE 中使用 Junit 运行此测试和正常测试。您只需右键单击文件，然后选择 **运行方式：Scala
    Junit 测试**；**，请参考以下截图：
- en: '![Testing with Junit](img/image00274.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Junit 进行测试](img/image00274.jpeg)'
- en: Behavior-Driven Development - BDD
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为驱动开发 - BDD
- en: '**Behavior-Driven Development** (**BDD**) is an agile development technique,
    that focuses on the engagement between developers and non-technical people such
    as product owners from the business. The idea is pretty simple: use the same language
    as the business uses in order to extract the reason why the code you are building
    exists in the first place. BDD ends up minimizing the translation between tech
    language and business language, creating more synergy and less noise between information
    technology and business.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**行为驱动开发** (**BDD**) 是一种敏捷开发技术，它关注开发人员与非技术人员（如业务的产品负责人）之间的互动。这个想法很简单：使用业务使用的相同语言来提取你正在构建的代码最初存在的原因。BDD
    最终最小化了技术语言与业务语言之间的翻译，创造了更多协同作用，减少了信息技术与业务之间的噪音。'
- en: BDD tests describe what the application needs to do, and how it behaves. It's
    very common to write down these tests using pair programing between business people
    and developers. `ScalaTest` is a BDD framework. Play framework has a great integration
    with `ScalaTest`. Let's get started with `ScalaTest` and Play right now.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: BDD 测试描述了应用程序需要做什么，以及它的行为。使用业务人员和开发人员之间的结对编程来编写这些测试是非常常见的。`ScalaTest` 是一个 BDD
    框架。Play 框架与 `ScalaTest` 集成得很好。让我们现在就开始使用 `ScalaTest` 和 Play 吧。
- en: MyFirstPlaySpec.scala - First BDD with ScalaTest and the Play framework
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MyFirstPlaySpec.scala - 使用 ScalaTest 和 Play 框架的首次 BDD
- en: 'The `MyFirstPlaySpec.scala` class should contain the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyFirstPlaySpec.scala` 类应包含以下代码：'
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'So, you create a class called `MyFirstPlaySpec`, and we extend it from `PlaySpec`
    in order to get Play framework `ScalaTest` support. Then we create two functions
    to test the sum of two numbers. In the first test, `1 +1` should be `2`, and in
    the second, `-1 + 1` should be `0`. When we execute `mustBe`, it is the same thing
    as doing an assert in Junit. The main difference here is that the test has behavior
    explicitly on the Spec. Now we can run the test by typing the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您创建了一个名为 `MyFirstPlaySpec` 的类，并从 `PlaySpec` 扩展它以获取 Play 框架 `ScalaTest` 支持。然后我们创建了两个测试两个数字之和的函数。在第一个测试中，`1
    + 1` 应该等于 `2`，在第二个测试中，`-1 + 1` 应该等于 `0`。当我们执行 `mustBe` 时，它与在 JUnit 中进行断言相同。这里的主要区别是测试在
    Spec 上有明确的行为。现在我们可以通过键入以下内容来运行测试：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You will see the following result:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下结果：
- en: '![MyFirstPlaySpec.scala - First BDD with ScalaTest and the Play framework](img/image00275.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![MyFirstPlaySpec.scala - 使用 ScalaTest 和 Play 框架的首次 BDD](img/image00275.jpeg)'
- en: Testing with Play framework support
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Play 框架支持进行测试
- en: Now we will continue building our application. Let's add BDD tests in our application.
    We will start doing tests for your services. We have to test `ProductService`,
    `ImageService`, and `ReviewService`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将继续构建我们的应用程序。让我们在我们的应用程序中添加BDD测试。我们将开始对你的服务进行测试。我们必须测试`ProductService`、`ImageService`和`ReviewService`。
- en: 'Your `ProductServiceTestSpec.scala file` should contain the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`ProductServiceTestSpec.scala`文件应该包含以下代码：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For this test, we are testing all public functions available in `ProductService`.
    The tests are pretty straightforward: we call a specific service operation, such
    as `findById`, and then we check the result to make sure that all the data that
    is supposed to be there is present.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这次测试，我们正在测试`ProductService`中所有可用的公共函数。测试非常直接：我们调用特定的服务操作，例如`findById`，然后我们检查结果以确保所有应该存在的数据都存在。
- en: There are scenarios where the service should return an exception, for instance,
    if you try to remove something that does not exist. If you take a look at the
    last test function called `"not remove because does not exist"`, we should get
    an exception. However, there is a bug in the service code. Run the tests, and
    then you will see it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些场景下，服务应该返回一个异常，例如，如果你尝试删除一个不存在的东西。如果你看一下最后一个测试函数`"not remove because does
    not exist"`，我们应该得到一个异常。然而，服务代码中有一个bug。运行测试，然后你就会看到它。
- en: ProductService.scala - FIX the code issue
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ProductService.scala - 修复代码问题
- en: 'That''s the great thing about tests: they show issues in our code so that we
    can fix them before the code goes to production and affects the user experience.
    To fix the last test, we need to go to the `ProductService` class and fix a method.
    This is how we fix it:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的伟大之处在于：它们可以显示我们代码中的问题，这样我们就可以在代码进入生产环境并影响用户体验之前修复它们。为了修复最后一个测试，我们需要进入`ProductService`类并修复一个方法。这就是我们修复它的方法：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: All set now, everything is okay. The Play framework supports testing for expected
    exceptions using the intercept function to pass the expected exception, Let's
    run the test in the console using the `activator` command.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都准备好了，一切都正常。Play框架支持使用`intercept`函数测试预期的异常，让我们使用`activator`命令在控制台中运行测试。
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After executing this command, we get the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令后，我们得到以下结果：
- en: '![ProductService.scala - FIX the code issue](img/image00276.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![ProductService.scala - 修复代码问题](img/image00276.jpeg)'
- en: ImageServiceTestSpec.scala - ImageService Test
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ImageServiceTestSpec.scala - ImageService 测试
- en: 'Alright, Now we can add tests for `ImageService` as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们可以添加`ImageService`的测试，如下所示：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So these are the BDD tests for `ImageService`. We have covered all the available
    functions on the service. Like in the `ProductService` class, we also have tests
    for unfortunate scenarios where we expect exceptions to happen.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这些是`ImageService`的BDD测试。我们已经覆盖了服务上所有可用的函数。就像在`ProductService`类中一样，我们也有针对不幸场景的测试，在这些场景中我们期望发生异常。
- en: Sometimes, we need to call more than one function to test a specific function
    or a specific test case. For example, in `"remove 1 image"`, we first delete an
    image. Our test case checks for an image that does not exist. Let's run the tests
    on the Activator console.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们需要调用多个函数来测试特定的函数或特定的测试用例。例如，在`"删除1张图片"`中，我们首先删除一张图片。我们的测试用例检查是否存在图片。让我们在Activator控制台中运行测试。
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following result will be obtained:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 将获得以下结果：
- en: '![ImageServiceTestSpec.scala - ImageService Test](img/image00277.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![ImageServiceTestSpec.scala - ImageService 测试](img/image00277.jpeg)'
- en: ReviewServiceTestSpec.scala - ReviewService test
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ReviewServiceTestSpec.scala - ReviewService 测试
- en: Next, we need add tests for the review service. Here we go.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为审查服务添加测试。这里我们开始。
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Alright, we have tests for the review service. We can run them now.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经有了审查服务的测试。我们现在可以运行它们了。
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here is the output:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出结果：
- en: '![ReviewServiceTestSpec.scala - ReviewService test](img/image00278.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![ReviewServiceTestSpec.scala - ReviewService 测试](img/image00278.jpeg)'
- en: Testing routes
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试路由
- en: The Play framework allows us to test routes as well. This is good, because as
    our application grows and we refactor the code, we can be 100% sure that our routes
    are functioning. Route testing could be easily confused with controller testing.
    The main difference is that, with routing testing, we should test if we are able
    to reach the routes and that's it. After route testing, we will cover controller
    testing in detail.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Play框架允许我们测试路由。这是好事，因为随着我们的应用程序的增长和代码的重构，我们可以100%确信我们的路由正在正常工作。路由测试很容易与控制器测试混淆。主要区别在于，在路由测试中，我们应该测试我们是否能够到达路由，仅此而已。在路由测试之后，我们将详细介绍控制器测试。
- en: RoutesTestingSpec.scala - Play framework route testing
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RoutesTestingSpec.scala - Play 框架路由测试
- en: 'Your `RoutesTestingSpec.scala` file should contain the following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 `RoutesTestingSpec.scala` 文件应该包含以下代码：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So here we have tests for all our main controllers, which are root, product,
    review, and image. `RootController` is the controller of the main page when you
    visit `http://localhost:9000`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里我们有对所有主要控制器的测试，这些控制器是根、产品、评论和图像。`RootController` 是当你访问 `http://localhost:9000`
    时的主页控制器。
- en: There is a special helper function called `route` in the Play framework, which
    helps us to test routes. Then we use `FakeRequest` pass the path to the route.
    It's possible to test the status code and content type of the page to which the
    router routed our request.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Play 框架中有一个特殊的辅助函数叫做 `route`，它帮助我们测试路由。然后我们使用 `FakeRequest` 将路径传递给路由。我们可以测试路由器将我们的请求路由到的页面的状态码和内容类型。
- en: For product, image, and review controllers, you can see we are trying to call
    an item that does not exist. That's why we have the try...catch, because we expect
    to have an exception happening there.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于产品、图像和评论控制器，你可以看到我们正在尝试调用一个不存在的项目。这就是为什么我们有 try...catch，因为我们预计那里会发生异常。
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Executing this preceding command produces the following result:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的命令会产生以下结果：
- en: '![RoutesTestingSpec.scala - Play framework route testing](img/image00279.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![RoutesTestingSpec.scala - Play 框架路由测试](img/image00279.jpeg)'
- en: Controller testing
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器测试
- en: We did unit tests, we did route tests, and now is the time to add controller
    tests. Controller tests are similar to routes tests, but they are not the same.
    For instance, our controller always respond to UI pages, so we expected to create
    specific HTML pages based on each method. The Play framework has integration with
    Selenium, which is a testing framework for UIs, and a controllers that allows
    you to simulate web browsers, and you can do pretty much the same as you would
    by clicking on the pages like a real user.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行了单元测试，进行了路由测试，现在是添加控制器测试的时候了。控制器测试与路由测试类似，但它们并不相同。例如，我们的控制器总是响应 UI 页面，因此我们预计将为每个方法创建特定的
    HTML 页面。Play 框架与 Selenium 集成，Selenium 是一个用于 UI 的测试框架，它允许你模拟网络浏览器，你可以做很多事情，就像一个真实用户点击页面一样。
- en: So let's get started. First, we will start with `RndDoubleGeneratorControllerTestSpec`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧。首先，我们将从 `RndDoubleGeneratorControllerTestSpec` 开始。
- en: RndDoubleGeneratorControllerTestSpec.scala - RndDoubleGeneratorController tests
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RndDoubleGeneratorControllerTestSpec.scala - RndDoubleGeneratorController 测试
- en: 'The `RndDoubleGeneratorControllerTestSpec.scala` file should contain the following
    code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`RndDoubleGeneratorControllerTestSpec.scala` 文件应该包含以下代码：'
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This class has some interesting things. For instance, we inject `WSClient` using
    Google Guice with `GuiceApplicationBuilder`. Secondly, we assume that the `ng-microservice` 
    we created in the previous chapter is down, so we can predict the response coming
    from the fallback.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有一些有趣的东西。例如，我们使用 `GuiceApplicationBuilder` 通过 Google Guice 注入 `WSClient`。其次，我们假设我们在上一章中创建的
    `ng-microservice` 已经关闭，因此我们可以预测来自回退的响应。
- en: 'We call the controller using `WSClient`, and then we map the response to return
    the body content as a string. So this will be an Async Future, and in order to
    get the result, we use `Await` to wait five seconds for the response to come back.
    Once the response is back, we make sure the result is 2.3\. If the result does
    not come back in 15s, the test will fail. Run the following command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `WSClient` 调用控制器，然后将响应映射回返回的正文内容作为字符串。所以这将是一个异步未来，为了获取结果，我们使用 `Await` 等待五秒钟以等待响应返回。一旦响应返回，我们确保结果是
    2.3。如果结果在 15 秒内没有返回，测试将失败。运行以下命令：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now you will see the following result:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将看到以下结果：
- en: '![RndDoubleGeneratorControllerTestSpec.scala - RndDoubleGeneratorController
    tests](img/image00280.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![RndDoubleGeneratorControllerTestSpec.scala - RndDoubleGeneratorController
    测试](img/image00280.jpeg)'
- en: All right, now we have a controller test fully working using Guice injections
    and the `WSClient` Play framework library. Let's now make controller tests for
    the product, image, and review controllers.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们已经使用 Guice 注入和 `WSClient` Play 框架库完全实现了控制器测试。现在让我们为产品、图像和评论控制器编写控制器测试。
- en: IntegrationSpec.scala
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IntegrationSpec.scala
- en: We can test our main page to check if it is okay. This is a very simple test,
    and gets you ready for the next tests. So, here we go.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以测试我们的主页以检查它是否正常。这是一个非常简单的测试，为接下来的测试做好准备。所以，我们开始吧。
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This test is very easy. We just call the main page, and we check if it contains
    the text `Welcome to Reactive WebStore`. Let's run it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试非常简单。我们只需调用主页，并检查它是否包含文本 `欢迎来到 Reactive WebStore`。让我们运行它。
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The result after running this test is shown in the following image:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此测试后的结果显示在下图中：
- en: '![IntegrationSpec.scala](img/image00281.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![IntegrationSpec.scala](img/image00281.jpeg)'
- en: ProductControllerTestSpec.scala
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ProductControllerTestSpec.scala
- en: 'Now we will look at the product controller test spec:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将查看产品控制器测试规范：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: So, for the product controller, we simulate a web browser using Selenium Play's
    framework support. We test basic controller functionality such as inserting a
    new product, details for a specific product, and updating and removing a product.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于产品控制器，我们使用 Selenium Play 框架的支持模拟一个网络浏览器。我们测试基本控制器功能，如插入新产品、特定产品的详细信息以及更新和删除产品。
- en: For insert, we go to the new product form using `goTo`. We use `$port` as a
    variable. We do this because the Play framework will boot up the application for
    us, but we don't know in which port. So we need to use this variable in order
    to get to the product controller.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于插入，我们使用 `goTo` 转到新产品表单。我们使用 `$port` 作为变量。我们这样做是因为 Play 框架将为我们启动应用程序，但我们不知道它在哪个端口。因此，我们需要使用这个变量来访问产品控制器。
- en: Then we click on each text field using the `click` function, and we enter values
    using the `enter` function. After filling in the whole form, we submit it using
    the `submit` function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `click` 函数点击每个文本字段，并使用 `enter` 函数输入值。填写完整个表单后，我们使用 `submit` 函数提交。
- en: For details, we just go to the product details page, and we check if the text
    fields have the values that we are expecting. We do that using the `textField.value`
    function.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于详情，我们只需转到产品详情页面，并检查文本字段是否具有我们期望的值。我们使用 `textField.value` 函数来做这件事。
- en: In order to check the product update function, we need to first update the product
    definition, and then go to details to see if the values we changed are there.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查产品更新功能，我们首先需要更新产品定义，然后进入详情查看我们更改的值是否在那里。
- en: Finally, we test the `delete` function. For this function, we need to click
    on a button. We need to set the ID of the button in order to have this working.
    We need to do a small refactoring in our UI to have the ID there.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们测试 `delete` 函数。对于此函数，我们需要点击一个按钮。我们需要设置按钮的 ID 以使其工作。我们需要在我们的 UI 中进行一些小的重构以使
    ID 存在。
- en: product_index.scala.html
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: product_index.scala.html
- en: 'Your `product_index.scala.html` file should contain the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `product_index.scala.html` 文件应包含以下代码：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: All set. Now we can run our tests on Activators using the console.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一切准备就绪。现在我们可以使用控制台在我们的 Activators 上运行我们的测试。
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This preceding command shows the result in the following screenshot:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令显示了以下截图中的结果：
- en: '![product_index.scala.html](img/image00282.jpeg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![product_index.scala.html](img/image00282.jpeg)'
- en: Since this test runs the application for real and calls the controller simulating
    the web browser, this test could take some time. Now it's time to move to the
    `ImageController` tests.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此测试实际运行应用程序并模拟网络浏览器调用控制器，此测试可能需要一些时间。现在是我们转向 `ImageController` 测试的时候了。
- en: ImageControllerTestSpec.scala
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ImageControllerTestSpec.scala
- en: 'Your `product_index.scala.html` should contain the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `product_index.scala.html` 应包含以下代码：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First of all, we need to go to the product controller to insert a product; otherwise,
    we cannot do image operations, since they all need a product ID.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要转到产品控制器以插入一个产品；否则，我们无法进行图像操作，因为它们都需要产品 ID。
- en: image_index.scala.html
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: image_index.scala.html
- en: 'Your `image_index.scala.html` file should contain the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `image_index.scala.html` 文件应包含以下代码：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: All set. Now we can run the `ImageController` tests.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一切准备就绪。现在我们可以运行 `ImageController` 测试。
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The result is shown in the following screenshot:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示在下图中：
- en: '![image_index.scala.html](img/image00283.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![image_index.scala.html](img/image00283.jpeg)'
- en: '`ImageController` has passed all its tests. Now we will move to the `ReviewController`
    tests.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageController` 已通过所有测试。现在我们将转向 `ReviewController` 测试。'
- en: ReviewControllerTestSpec.scala
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ReviewControllerTestSpec.scala
- en: 'Your `ReviewControllerTestSpec.scala` file should contain the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `ReviewControllerTestSpec.scala` 文件应包含以下代码：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: First of all, we need to go to the product controller to insert a product; otherwise,
    we cannot do image operations, since they all need a product ID.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要转到产品控制器以插入一个产品；否则，我们无法进行图像操作，因为它们都需要产品 ID。
- en: For insert, we go to the new product form using goto. We use `$port` as a variable.
    We do this because the Play framework will boot up the application for us, but
    we don't know on which port, so we need to use this variable in order to get to
    the product controller.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于插入，我们使用 `goto` 转到新产品表单。我们使用 `$port` 作为变量。我们这样做是因为 Play 框架会为我们启动应用程序，但我们不知道在哪个端口，因此我们需要使用这个变量来访问产品控制器。
- en: Then we click on each text field using the `click` function, and we enter values
    using the `enter` function. After filling in the whole form, we submit it using
    the `submit` function.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用 `click` 函数点击每个文本字段，并使用 `enter` 函数输入值。填写完整个表单后，我们使用 `submit` 函数提交它。
- en: For details, we just go to the product details page and check if the text fields
    have the values that we expect. We do that using the `textField.value` function.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 详细信息，我们只需转到产品详情页面，检查文本字段是否有我们期望的值。我们使用 `textField.value` 函数来完成这个操作。
- en: In order to check the product update function, we need to first update the product
    definition, and then go to the details to see if the values we changed are there.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查产品更新功能，我们首先需要更新产品定义，然后转到详情页面查看我们更改的值是否在那里。
- en: Finally, we test the `delete` function. For this function, we need to click
    on a button. We need to set the ID of the button in order to have this working.
    Then we do a small refactoring in our UI to have the ID there.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们测试 `delete` 函数。对于这个函数，我们需要点击一个按钮。我们需要设置按钮的 ID 以使其工作。然后我们在 UI 中进行一些小的重构，以便在那里设置
    ID。
- en: review_index.scala.html
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: review_index.scala.html
- en: 'Your `review_index.scala.html` file should contain the following code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `review_index.scala.html` 文件应包含以下代码：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Finally, we can run the tests on the console.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在控制台运行测试。
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The test will show the following output:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 测试将显示以下输出：
- en: '![review_index.scala.html](img/image00284.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![review_index.scala.html](img/image00284.jpeg)'
- en: Alright, `ReviewController` has passed all our tests.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，`ReviewController` 已经通过了我们所有的测试。
- en: It's a very good practice to have the tests separated by type. However, if you
    want, you could mix all the tests such as unit testing, controller testing, and
    route testing in one single file.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 将测试按类型分开是一个非常好的实践。然而，如果您愿意，您可以将所有测试，如单元测试、控制器测试和路由测试混合在一个单独的文件中。
- en: ApplicationSpec.scala
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ApplicationSpec.scala
- en: 'Your `ApplicationSpec.scala` should have the following code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `ApplicationSpec.scala` 应包含以下代码：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We can run these mixed tests, and they will all pass.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行这些混合测试，并且它们都会通过。
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You will see this result:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下结果：
- en: '![ApplicationSpec.scala](img/image00285.jpeg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![ApplicationSpec.scala](img/image00285.jpeg)'
- en: OK, we are almost done. We just need to add some tests for the microservice
    called `ng-microservice` , which we created in [Chapter 4](part0060.xhtml#aid-1P71O2
    "Chapter 4. Developing Reactive Backing Services"), *Developing Reactive Backing
    Services*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们几乎完成了。我们只需为名为 `ng-microservice` 的微服务添加一些测试，我们在 [第 4 章](part0060.xhtml#aid-1P71O2
    "第 4 章。开发响应式后端服务") *开发响应式后端服务* 中创建了它。
- en: NGServiceImplTestSpec.scala
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NGServiceImplTestSpec.scala
- en: 'Your NGServiceImplTestSpec.scala file should have the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 NGServiceImplTestSpec.scala 文件应包含以下代码：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: So here, in the preceding code, we have two methods to test the two operations
    that we have in our microservice. First we generate one double, and then we ask
    for a list of three doubles. As you can see, we just check if we get a positive
    double back from the service, and that's it. Since the result is not predictable,
    this is a good way to test it. Sometimes, even when the result is predictable,
    you want tests like this. Why? Because it makes the tests more reliable, and often,
    when we use too many hardcore values. The values could be changing and breaking
    our tests, and that's not cool. Let's run it on the console.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在前面代码中，我们有两种方法来测试我们微服务中的两个操作。首先我们生成一个双精度浮点数，然后请求三个双精度浮点数的列表。如您所见，我们只是检查是否从服务中得到了一个正的双精度浮点数，就这样。由于结果不可预测，这是一种很好的测试方式。有时，即使结果可预测，您也想进行这样的测试。为什么？因为这使测试更可靠，而且通常，当我们使用太多的硬编码值时，这些值可能会改变并破坏我们的测试，这可不是什么好事。让我们在控制台运行它。
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here is the result that we get:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们得到的结果：
- en: '![NGServiceImplTestSpec.scala](img/image00286.jpeg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![NGServiceImplTestSpec.scala](img/image00286.jpeg)'
- en: Now let's move on to the controller, and do some controller testing.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转到控制器，做一些控制器测试。
- en: NGServiceEndpointControllerTest.scala
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NGServiceEndpointControllerTest.scala
- en: 'Your `NGServiceEndpointControllerTest.scala` file should contain the following
    code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `NGServiceEndpointControllerTest.scala` 文件应包含以下代码：
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here we have to inject the `WSClient` library so we can call the controller.
    This controller has two methods like the service we tested before. The second
    method returns a JSON structure. Then we check for `"["and "]"` to make sure that
    the array is present, since this is a list of three numbers.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们必须注入 `WSClient` 库，这样我们就可以调用控制器。这个控制器有两个方法，就像我们之前测试的服务一样。第二个方法返回一个 JSON
    结构。然后我们检查 `"["和 "]"`，以确保数组存在，因为这是一个包含三个数字的列表。
- en: We use the assert function to check the response from the controller, and to
    be 100% sure that everything is okay. Let's run it.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 assert 函数来检查来自控制器的响应，并且要确保一切正常。让我们运行它。
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Refer to the following screenshot to see the test result:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下截图查看测试结果：
- en: '![NGServiceEndpointControllerTest.scala](img/image00287.jpeg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![NGServiceEndpointControllerTest.scala](img/image00287.jpeg)'
- en: Great! We have covered pretty much everything .
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们几乎涵盖了所有内容。
- en: In this chapter, we ran all kinds of tests. We always used the command `$ activator
    "test-only xxx"`; the reason for this is to save time. However, it is very common
    to run all tests. You can do that in both projects; we have to just type `$ activator
    test`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们运行了各种各样的测试。我们总是使用命令 `$ activator "test-only xxx"`；这样做的原因是为了节省时间。然而，运行所有测试是非常常见的。你可以在两个项目中都这样做；我们只需要输入
    `$ activator test`。
- en: 'When running all the tests in the `ng-microservice` project, we get the result
    shown in the following screenshot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行 `ng-microservice` 项目的所有测试时，我们得到以下截图所示的成果：
- en: '![NGServiceEndpointControllerTest.scala](img/image00288.jpeg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![NGServiceEndpointControllerTest.scala](img/image00288.jpeg)'
- en: 'On the other hand, running all the tests in the `ReactiveWebStore` project
    gives the result shown in the next screenshot:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，运行 `ReactiveWebStore` 项目的所有测试会得到下一张截图所示的成果：
- en: '![NGServiceEndpointControllerTest.scala](img/image00289.jpeg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![NGServiceEndpointControllerTest.scala](img/image00289.jpeg)'
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to do tests. We added several tests for your
    Scala and Play framework projects. You also learned about unit testing principles,
    testing Scala applications with JUnit, BDD principles, testing with `ScalaTest`,
    testing Play framework applications with `ScalaTest`, and running tests in Activator
    / SBT.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何进行测试。我们为你的 Scala 和 Play 框架项目添加了几个测试。你还了解了单元测试原则、使用 JUnit 测试 Scala
    应用程序、BDD 原则、使用 `ScalaTest` 进行测试、使用 `ScalaTest` 测试 Play 框架应用程序，以及在 Activator /
    SBT 中运行测试。
- en: In the next chapter, you will learn more about persistence using Slick, which
    is reactive. We will also change our tests a little bit in order to work with
    a database.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何使用响应式的 Slick 来了解更多关于持久性的知识。我们还将稍微修改一下测试，以便与数据库一起工作。
