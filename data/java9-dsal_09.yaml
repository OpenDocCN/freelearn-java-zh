- en: Chapter 9. Advanced General Purpose Data Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章. 高级通用数据结构
- en: 'In this chapter, we will take a look at some more interesting data structures
    that are commonly used. We will start with the concept of a priority queue. We
    will see some efficient implementations of a priority queue. In short, we will
    cover the following topics in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一些常用的有趣的数据结构。我们将从优先队列的概念开始。我们将看到一些优先队列的高效实现。简而言之，本章将涵盖以下主题：
- en: Priority queue ADT
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先队列抽象数据类型（ADT）
- en: Heap
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆
- en: Binomial forest
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二项式森林
- en: Sorting using a priority queue and heap
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用优先队列和堆进行排序
- en: Priority queue ADT
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优先队列ADT
- en: 'A priority queue is like a queue in that you can enqueue and dequeue elements.
    However, the element that gets dequeued is the one with the minimum value of a
    feature, called its priority. We will use a comparator to compare elements and
    learn which one has the lowest priority. We will use the following interface for
    the priority queue:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 优先队列就像一个队列，你可以入队和出队元素。然而，出队的元素是具有最小特征值的元素，称为其优先级。我们将使用比较器来比较元素并学习哪个具有最低优先级。我们将使用以下接口来实现优先队列：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We require the following set of behaviors from the methods:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从方法中获取以下行为集：
- en: '`checkMinimum`: This method must return the next value to be dequeued without
    dequeuing it. If the queue is empty, it must return null.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`checkMinimum`：这个方法必须返回下一个要移除的值，而不移除它。如果队列空，它必须返回null。'
- en: '`dequeueMinimum`: This must dequeue the element with the minimum priority and
    return it. It should return null when the queue is empty.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dequeueMinimum`：这个操作必须移除具有最小优先级的元素并返回它。当队列空时，它应该返回null。'
- en: '`enqueue`: This should insert a new element in the priority queue.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enqueue`：这个操作应该在优先队列中插入一个新元素。'
- en: We would also like to do these operations as efficiently as possible. We will
    see two different ways to implement it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也希望尽可能高效地执行这些操作。我们将看到两种不同的实现方式。
- en: Heap
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆
- en: 'A heap is a balanced binary tree that follows just two constraints:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 堆是一个遵循仅两个约束的平衡二叉树：
- en: The value in any node is less than the value in either of the children. This
    property is also called the heap property.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何节点中的值都小于其子节点中的值。这个特性也称为堆属性。
- en: The tree is as balanced as possible—in the sense that any level is completely
    filled before a single node is inserted in the next level.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树尽可能平衡——即在下一级插入单个节点之前，任何一级都是完全填满的。
- en: 'The following figure shows a sample heap:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了示例堆：
- en: '![Heap](img/00062.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![堆](img/00062.jpeg)'
- en: Figure 1\. A sample heap
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图1. 一个示例堆
- en: It would not be really clear until we actually discuss how to insert elements
    and remove the least element. So let's jump into it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 直到我们实际讨论如何插入元素和移除最小元素之前，这并不真正清楚。所以让我们直接进入正题。
- en: Insertion
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入
- en: The first step of insertion is to insert the element in the next available position.
    The next available position is either another position in the same level or the
    first position in the next level; of course, this applies when there is no vacant
    position in the existing level.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 插入的第一步是将元素插入到下一个可用的位置。下一个可用的位置是同一级别的另一个位置或下一级别的第一个位置；当然，这适用于现有级别没有空位的情况。
- en: 'The second step is to iteratively compare the element with its parent and keep
    switching until the element is bigger than the parent, thus restoring the constraints.
    The following figure shows the steps of an insertion:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是迭代比较元素与其父节点，并持续交换，直到元素大于父节点，从而恢复约束。以下图显示了插入的步骤：
- en: '![Insertion](img/00063.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![插入](img/00063.jpeg)'
- en: Figure 2\. Heap insertion
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图2. 堆插入
- en: The gray box represents the current node, and the yellow box represents the
    parent node, whose value is larger than the current node. First, the new element
    is inserted in the next available spot. It must be swapped until the constraint
    is satisfied. The parent is **6**, which is bigger than **2**, so it is swapped.
    If the parent is **3**, which is also larger than **2**, it is swapped. If the
    parent is **1**, which is less than **2**, we stop and the insertion is complete.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 灰色框代表当前节点，黄色框代表父节点，其值大于当前节点。首先，新元素被插入到下一个可用的位置。它必须交换，直到满足约束。父节点是**6**，比**2**大，所以它被交换。如果父节点是**3**，也比**2**大，它也被交换。如果父节点是**1**，比**2**小，我们停止并完成插入。
- en: Removal of minimum elements
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小元素的移除
- en: 'The constraint that the parent is always less than or equal to the children
    guarantees that the root is the element with the least value. This means the removal
    of the least element leads only to the removal of the top element. However, the
    empty space of the root must be filled, and elements can only be deleted from
    the last level to maintain the constraint **2**. To ensure this, the last element
    is first copied to the root and then removed. We must now iteratively move the
    new root element downward until the constraint **1** is satisfied. The following
    figure shows an example of a delete operation:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 父节点总是小于或等于子节点的约束保证了根节点是具有最小值的元素。这意味着移除最小元素只会导致移除顶部元素。然而，根节点的空位必须被填充，并且为了保持约束**2**，元素只能从最后一层删除。为了确保这一点，首先将最后一个元素复制到根节点，然后将其删除。现在必须迭代地将新根节点向下移动，直到满足约束**1**。以下图显示了删除操作的示例：
- en: '![Removal of minimum elements](img/00064.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![最小元素的移除](img/00064.jpeg)'
- en: Heap deletion
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 堆删除
- en: 'There is one question though, since any parent can have two children: which
    one should we compare and swap with? The answer is simple. We need the parent
    to be less than both the children; this means we must compare and swap with the
    minimum value of the children.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个问题，由于任何父节点都可以有两个子节点：我们应该比较和交换哪一个？答案是简单的。我们需要父节点小于两个子节点；这意味着我们必须比较和交换子节点的最小值。
- en: Analysis of complexity
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复杂度分析
- en: 'First, let''s check out the height of a heap for a given number of nodes. The
    first layer contains just the root. The second layer contains a maximum of two
    nodes. The third layer contains four. Indeed, if any layer contains m elements,
    the next layer will contain, at the maximum, the children of all these *m* elements.
    Since each node can have two children, the maximum number of elements in the next
    layer will be *2m*. This shows that the number of elements in layer l is *2* ^(l-1).
    So, a full heap of height *h* will have total *1+2+4+...+ 2* ^(h-1) *= 2* ^h*-1*
    nodes. Therefore, a heap of height *h* can have maximum *2* *h+1* *-1* nodes.
    What is the minimum number of nodes in a heap of height *h*. Well, since only
    the last level can have unfilled positions, the heap must be full, except the
    last layer. The last layer can have one node minimum. So, the minimum number of
    nodes in a heap of height *h* is *(2* ^(h-1) *-1) + 1 = 2* ^(h-1). Hence, if the
    number of nodes is *n*, then we have this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们检查给定节点数量的堆的高度。第一层只包含根节点。第二层最多包含两个节点。第三层包含四个。确实，如果任何一层包含*m*个元素，下一层将包含这些*m*个元素的所有子节点。由于每个节点可以有最多两个子节点，下一层的最大元素数将是*2m*。这表明第*l*层的元素数是*2*^(l-1)。因此，高度为*h*的满堆将有总节点数*1+2+4+...+
    2*^(h-1) *= 2*^h*-1*。因此，高度为*h*的堆可以有最大*2* *h+1* *-1*个节点。那么，高度为*h*的堆的最小节点数是多少呢？由于只有最后一层可以有未填充的位置，堆除了最后一层必须满。最后一层至少有一个节点。因此，高度为*h*的堆的最小节点数是*(2*^(h-1)
    *-1) + 1 = 2*^(h-1)。因此，如果节点数为*n*，那么我们有以下内容：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We also have the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有以下内容：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Combining the preceding two expressions, we get this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 结合前面的两个表达式，我们得到以下内容：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, let's assume that adding a new element to the end of the heap is a constant
    time operation or *θ(lg n)*. We will see that this operation can be made this
    efficient. Now we deal with the complexity of a trickle up operation. Since in
    each compare-and-swap operation, we only compare with the parent and never backtrack,
    the maximum number of swaps that can happen in a trickle up operation equals the
    height of the heap *h*. Hence, the insertion is *O(lg n)*. This means that the
    insert operation itself is *O(lg n)*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设向堆的末尾添加一个新元素是一个常数时间操作或*θ(lg n)*。我们将看到这个操作可以变得如此高效。现在我们来处理上滤操作的复杂度。由于在每次比较和交换操作中，我们只与父节点比较，而从不回溯，上滤操作中可能发生的最大交换次数等于堆的高度*h*。因此，插入操作是*O(lg
    n)*。这意味着插入操作本身也是*O(lg n)*。
- en: Similarly, for the trickle down operation, we can only do as many swaps as the
    height of the heap. So trickling down is also *O(lg n)*. Now if we assume that
    removing the root node and copying the last element to the root is at the maximum
    *O(lg n)*, we can conclude that the delete operation is also *O(lg n)*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于下滤操作，我们只能进行与堆高度相同的交换次数。因此，下滤操作也是*O(lg n)*。现在如果我们假设移除根节点并将最后一个元素复制到根节点的操作最多是*O(lg
    n)*，我们可以得出结论，删除操作也是*O(lg n)*。
- en: Serialized representation
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列化表示
- en: 'A heap can be represented as a list of numbers without any blanks in the middle.
    The trick is to list the elements in order after each level. Positions from 1
    through *n* for an *n* element heap adopt the following conventions:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 堆可以表示为一个没有中间空白的数字列表。技巧是在每级之后按顺序列出元素。对于具有 *n* 个元素的堆，位置从 1 到 *n* 采取以下约定：
- en: For any element at index *j*, the parent is at index *j/2*, where '*/*' represents
    an integer division. This means divide *j* by two and ignore the remainder if
    any.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于索引为 *j* 的任何元素，其父元素在索引 *j/2*，其中 '*/*' 表示整数除法。这意味着将 *j* 除以二并忽略任何余数。
- en: For any element at index *j*, the children are *j*2* and *j*2+1*. One can verify
    that this is the same as the first formula written the other way round.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于索引为 *j* 的任何元素，其子元素是 *j*2 和 *j*2+1。可以验证这和之前写的第一个公式相反。
- en: 'The representation of our example tree is shown in the following figure. We
    have just flattened the process of writing a tree one entire level before another.
    We retained the tree edges, and one can see that the parent-child relationships
    work as described previously:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例树的表示如图所示。我们只是将树的一级一级展开。我们保留了树边，可以看到父子和关系正如之前所描述的那样：
- en: '![Serialized representation](img/00065.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![序列化表示](img/00065.jpeg)'
- en: Array representation of a heap
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 堆的数组表示
- en: With the knowledge of the array-based storage function of a heap, we can proceed
    to implement our heap.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解堆的基于数组的存储函数后，我们可以继续实现我们的堆。
- en: Array-backed heap
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组支持的堆
- en: 'An array-backed heap is a fixed-sized heap implementation. We start with a
    partial implementation class:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 数组支持的堆是一个固定大小的堆实现。我们从一个部分实现类开始：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Given any index of the array (starting from `0`), find the index of the parent
    element. It involves converting the index to `1` based form (so add `1`), dividing
    by `2`, and then converting it back to `0` (so subtract `1`):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数组的任何索引（从 `0` 开始），找到父元素索引。这涉及到将索引转换为基于 `1` 的形式（因此加 `1`），除以 `2`，然后将其转换回基于 `0`
    的形式（因此减 `1`）：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Find the index of the left child using this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下方法找到左子元素的索引：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Swap the elements in the two indexes provided using this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下方法交换两个索引处的元素：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To implement the insertion, first implement a method that would trickle the
    value up until constraint `1` is satisfied. We compare the current node with the
    parent, and if the value of the parent is larger, then do a swap. We keep moving
    upwards recursively:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现插入，首先实现一个方法，将值逐级上移直到满足约束 `1`。我们比较当前节点和父节点，如果父节点的值更大，则进行交换。我们继续递归向上移动：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we can implement the insertion. The new element is always added to the
    end of the current list. A check is done to ensure that when the heap is full,
    an appropriate exception is thrown:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以实现插入。新元素总是添加到当前列表的末尾。进行检查以确保当堆满时，抛出适当的异常：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Similarly, for deletion, we first implement a trickle down method that compares
    an element with its children and makes appropriate swaps until constraint 1 is
    restored. If the right child exists, the left child must also exist. This happens
    because of the balanced nature of a heap. In this case, we must compare only with
    a minimum of two children and swap them if it is necessary. When the left child
    exists but the right child does not, we only need to compare it with one element:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对于删除，我们首先实现一个逐级下移方法，该方法比较一个元素与其子元素，并做出适当的交换，直到恢复约束 1。如果存在右子元素，则必须也存在左子元素。这是因为堆的平衡性质。在这种情况下，我们只需要与最少两个子元素进行比较，并在必要时进行交换。当左子元素存在但右子元素不存在时，我们只需要与一个元素进行比较：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With the `trickleDown` method available, removing the minimum element is simple.
    We first save the current root as the minimum element, then copy the last element
    to the root position. We then call the `trickleDown` method to restore constraint
    1:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `trickleDown` 方法可用后，删除最小元素变得简单。我们首先保存当前根节点作为最小元素，然后将最后一个元素复制到根位置。然后调用 `trickleDown`
    方法来恢复约束 1：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now we only have to use it as an implementation of the priority queue. So we
    implement the relevant methods using our `insert` and `removemin`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将其用作优先队列的实现。因此，我们使用我们的 `insert` 和 `removemin` 方法实现相关方法：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This completes our array-based heap implementation. It has the same problem
    as our array-based queue implementation, that is, we need to know its maximum
    size beforehand. Next, we will have an implementation of a heap that has an implementation
    in the form of a linked binary tree.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们的基于数组的堆实现。它和我们的基于数组的队列实现有相同的问题，即我们需要事先知道其最大大小。接下来，我们将有一个具有链式二叉树形式的堆实现。
- en: Linked heap
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链式堆
- en: 'A linked heap is an actual binary tree where every node holds references to
    its children. We first create a skeleton structure for our heap:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 链式堆是一个实际的二叉树，其中每个节点都持有对其子节点的引用。我们首先为我们的堆创建一个骨架结构：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To keep track of the next position, each position is given a number, just like
    we did in our array-based representation. We have the same calculation for the
    index of the parent and children. But, in this case, looking up the value at a
    particular index requires a traversal from the root to that node. We create a
    method to do this. Note that since we are not using an array, the position starts
    from 1\. We start by finding the parent node recursively. The parent node is of
    course the node at the position that is half the value of the children. The remainder,
    when divided by 2, is the bit that tells us whether the node is to the left or
    right of the parent. We return the node accordingly:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了追踪下一个位置，每个位置都被赋予一个数字，就像我们在基于数组的表示中做的那样。我们对父节点和子节点的索引也有相同的计算。但是，在这种情况下，查找特定索引的值需要从根节点遍历到该节点。我们创建一个方法来完成这个操作。请注意，由于我们不是使用数组，位置从1开始。我们首先通过递归查找父节点。父节点当然是子节点位置的一半。除以2的余数是告诉我们节点是在父节点的左边还是右边的位。我们相应地返回节点：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we turn to swapping. In the case of an array-based heap, we could swap
    the values between any two indexes. However, this general implementation would
    require multiple traversals in this case. We only need to swap the values between
    a node and its parent. The `swapWithParent` takes the parent node as an argument.
    Another argument is to know whether the current node is the left or right child
    of the parent and switch references appropriately:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们转向交换。在基于数组的堆的情况下，我们可以在任何两个索引之间交换值。然而，这个通用实现在这种情况下需要多次遍历。我们只需要在节点和其父节点之间交换值。`swapWithParent`方法接受父节点作为参数。另一个参数是知道当前节点是父节点的左子节点还是右子节点，并相应地切换引用：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Insertion
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入
- en: 'Insertion involves inserting a new element at the end first and then trickling
    it in the upward direction. First, we create a trickle up method, similar to the
    one in the `ArrayHeap` class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 插入涉及首先在末尾插入一个新元素，然后向上渗透。首先，我们创建一个向上渗透的方法，类似于`ArrayHeap`类中的方法：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we implement the insert method. If the tree is empty, we just have to
    add a root. Otherwise, the position of the new element is *(numElements+1)*. In
    this case, it''s parent must be *((numElements+1)/2)*. Whether it should be the
    left or right child of its parent is determined by the value of *( (numElements+1)%2)*.
    A new node is then created and added to the parent as a child. Finally, `numElements`
    is incremented to keep track of the number of elements:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们实现插入方法。如果树为空，我们只需添加一个根节点。否则，新元素的位子是*(numElements+1)*。在这种情况下，它的父节点必须是*((numElements+1)/2)*。它是否应该是其父节点的左子节点还是右子节点由*(
    (numElements+1)%2)*的值决定。然后创建一个新的节点并将其添加为父节点的子节点。最后，将`numElements`递增以跟踪元素数量：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Removal of the minimal elements
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小元素的移除
- en: 'Similar to the array-based heap, we need to implement a trickle down method.
    Since the left child must exist if the right child does, if the left child is
    null, the node does not have any child. But, if the right child is null and the
    left child is not, we only need to compare the current node''s value with that
    of the left child. Otherwise, compare and swap with the child that has the minimum
    value:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于数组的堆类似，我们需要实现一个向下渗透的方法。由于如果右子节点存在，则左子节点也必须存在，如果左子节点为空，则节点没有子节点。但是，如果右子节点为空且左子节点不为空，我们只需要比较当前节点的值与左子节点的值。否则，与具有最小值的子节点进行比较和交换：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now we can implement the method to remove the minimum element. If the root
    is null, it means the queue is empty. If the last element is the root, there is
    only one element and we just remove and return it. Otherwise, we copy the value
    of the root to a temporary variable, then copy the value of the last element to
    the root, and finally, trickle down the root:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以实现移除最小元素的方法。如果根为空，这意味着队列是空的。如果最后一个元素是根，只有一个元素，我们只需移除并返回它。否则，我们将根的值复制到一个临时变量中，然后将最后一个元素的值复制到根中，最后，将根向下传递：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we implement the methods required to make it a valid priority queue:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实现使它成为一个有效优先队列所需的方法：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This completes our priority queue implementation using heaps. We will now introduce
    a different way of implementing a priority queue. It is called a binomial forest,
    which comprises our next section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们使用堆实现的优先队列。现在我们将介绍实现优先队列的另一种方式。它被称为二项式森林，这是下一节的内容。
- en: Complexity of operations in ArrayHeap and LinkedHeap
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ArrayHeap和LinkedHeap中操作的复杂度
- en: We have already seen that if we can append an element to the end of a heap in
    at most *O(lg n)*, where n is the number of elements already in the heap, we can
    perform both insertion and removal of the minimum element *θ(lg n)* times. In
    the case of `ArrayHeap`, insertion of a new element implies just setting the value
    of an element in an array at a known index. This is a constant time operation.
    So, in `ArrayHeap`, both the insertion and removal of minimum element are *θ(lg
    n)*. Checking the minimum element is just the check the value at index zero of
    the array and hence is constant time.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，如果我们能在堆的末尾最多以*O(lg n)*的时间复杂度添加一个元素，其中n是堆中已有的元素数量，我们就可以以*θ(lg n)*的时间复杂度执行插入和删除最小元素的操作。在`ArrayHeap`的情况下，插入新元素意味着只需设置数组中已知索引的元素值。这是一个常数时间操作。因此，在`ArrayHeap`中，插入和删除最小元素的操作都是*θ(lg
    n)*。检查最小元素只是检查数组索引0的值，因此是常数时间。
- en: In the case of `LinkedHeap`, insertion of a new element at the end involves
    traversing the tree to the end position. Since the height of the tree is *θ(lg
    n)*, this operation is also *θ(lg n)*. This means, the insertion and deletion
    operation in `LinkedHeap` is also *θ(lg n)*. Checking the minimum element means
    just checking the value at the root, and this operation is constant time.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LinkedHeap`的情况下，在末尾插入新元素需要遍历树到末尾位置。由于树的高度是*θ(lg n)*，这个操作也是*θ(lg n)*。这意味着，在`LinkedHeap`中的插入和删除操作也是*θ(lg
    n)*。检查最小元素只是检查根的值，这个操作是常数时间。
- en: Binomial forest
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二项式森林
- en: 'A binomial forest is a very interesting data structure. But, to discuss it,
    we need to first start with a binomial tree. A binomial tree is a tree in which
    a combination of two smaller binomial trees of the same size are combined in a
    particular way:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 二项式森林是一种非常有趣的数据结构。但是，要讨论它，我们首先需要从二项式树开始。二项式树是一种树，其中两个相同大小的较小的二项式树以特定方式组合在一起：
- en: '![Binomial forest](img/00066.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![二项式森林](img/00066.jpeg)'
- en: Binomial tree
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 二项式树
- en: 'The preceding figure shows how binomial trees combine to create larger binomial
    trees. In the first row, two binomial trees of height 1 combine to create a new
    binomial tree of height 2\. In the second row, two binomial trees of height 2
    combine to create a new binomial tree of height 3\. In the final example, two
    binomial trees of height 3 combine to create a binomial tree of height 4, and
    it continues. The two trees that are combined together are not treated symmetrically.
    Instead, the root of one becomes the parent of the other. The next figure shows
    one more step in the sequence and then shows a different way to look at a binomial
    tree. In the last row, I have highlighted the subtrees differently. Notice how:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图显示了二项式树如何组合成更大的二项式树。在第一行，两个高度为1的二项式树组合成一个新的高度为2的二项式树。在第二行，两个高度为2的二项式树组合成一个新的高度为3的二项式树。在最后的例子中，两个高度为3的二项式树组合成一个高度为4的二项式树，以此类推。组合在一起的两个树不是对称处理的。相反，一个树的根成为另一个树的父节点。下一图显示了序列中的另一个步骤，然后展示了看待二项式树的不同方式。在最后一行，我以不同的方式突出了子树。注意：
- en: '![Binomial forest](img/00067.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![二项式森林](img/00067.jpeg)'
- en: Figure 6\. The other way of thinking about a binomial tree
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.看待二项式树的另一种方式
- en: Each subtree is a binomial tree. Not only that, the first subtree is a binomial
    tree of height 1, the second one of height 2, third one of height 3, and so on.
    So, another way of thinking about a binomial tree is that it is a root and a sequence
    of subtrees that are binomial trees of consecutive heights up to one less than
    the height of the entire tree. Both these views are required in our discussion.
    The first view is needed when analyzing the idea and the second when implementing
    it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子树都是一个二项树。不仅如此，第一个子树是一个高度为1的二项树，第二个子树的高度为2，第三个子树的高度为3，以此类推。所以，另一种思考二项树的方式是，它是一个根和一系列子树，这些子树是连续高度的二项树，直到比整个树的高度少一个。这两种观点在我们的讨论中都是必要的。分析想法时需要第一种观点，实现时需要第二种观点。
- en: Why call it a binomial tree?
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么叫它二项树？
- en: 'Remember the choose function we discussed in [Chapter 4](part0028_split_000.html#QMFO2-eeeded97b5e248ac807bb1bec4d7c800
    "Chapter 4. Detour – Functional Programming"), *Detour - Functional Programming*?
    There, I pointed out that it is also called the binomial coefficient. Let''s see
    how it is related to a binomial tree. Suppose we have a binomial tree of height
    h and we want to find out the number of nodes at level l. Let''s assume that for
    a tree of height h, the number of nodes is *f(t,r)*, where *t=h-1* and *r = l-1*.
    The reason for taking a variable that is one less than the height and level will
    become clearer a little later. Basically, *t* is the height of the tree that starts
    from *0* instead of *1*, and *r* is the level that starts from zero. Now this
    tree is obviously a tree of only one element or it is made up of two trees of
    height *h-1 = t*:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在[第4章](part0028_split_000.html#QMFO2-eeeded97b5e248ac807bb1bec4d7c800 "第4章.
    旁路 - 函数式编程")中讨论的**选择函数**吗？*旁路 - 函数式编程*？在那里，我指出它也被称为二项式系数。让我们看看它与二项树有何关联。假设我们有一个高度为h的二项树，我们想要找出第l层的节点数量。让我们假设对于高度为h的树，节点数量是*f(t,r)*，其中*t=h-1*和*r
    = l-1*。取比高度和级别小一的变量的原因稍后将会变得清晰。基本上，*t*是从*0*而不是*1*开始的树的高度，*r*是从零开始的级别。现在这棵树显然是只有一个元素的树，或者它是由两个高度为*h-1
    = t*的树组成的：
- en: '![Why call it a binomial tree?](img/00068.jpeg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![为什么叫它二项树？](img/00068.jpeg)'
- en: Figure 7\. The rationale for naming it a binomial tree
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图7. 将其命名为二项树的理由
- en: 'We will call these two subtrees this: red subtree and green subtree. This is
    because they are colored this way in the preceding figure. The levels are highlighted
    using dashed lines. It is clear from the picture that the nodes at the level *r*
    in the complete tree is either at level *r* in the red tree or at level *r-1*
    in the green tree. Both the red and green trees are trees of height *h-1*. This
    means the following: *f(t,r) = f(t-1,r) + f(t-1,r-1)*. This equation is the same
    as what we have for the choose function we have already discussed. The only thing
    we have to check is the boundary conditions. The top level (that is *t=0*) always
    has only one node, so *f(t,0) = 1*. We also know that the number of levels in
    the tree has to be less than or equal to the height of the tree, so we have *f(t,r)
    = 0* if *t <r*. So, *f(t,t) = f(t-1,t) + f(t-1,t-1) = 0 + f(t-1,t-1) = f(t-1,t-1)*
    for any *t*. In the same way, *f(t-1,t-1) = f(t-2,t-2) = f(t-3,t-3) = … = f(0,0)
    = 1* (because *f(t,0) = 1*). Therefore, all the conditions of the `choose` function
    are satisfied; hence we can see *f(t,r) = choose(t,r) = choose(h-1, l-1)*. Since
    the *choose* function is also called the binomial coefficient, this gives the
    binomial tree its name.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将称这两个子树为：红色子树和绿色子树。这是因为它们在前面的图中被这样着色。使用虚线突出显示级别。从图中可以看出，完整树中级别*r*的节点要么在红色树的级别*r*，要么在绿色树的级别*r-1*。红色和绿色树都是高度*h-1*的树。这意味着以下内容：*f(t,r)
    = f(t-1,r) + f(t-1,r-1)*。这个方程与我们已讨论的选择函数相同。我们唯一要检查的是边界条件。顶层（即*t=0*）总是只有一个节点，所以*f(t,0)
    = 1*。我们还知道树中的级别数量必须小于或等于树的高度，所以当*t <r*时，我们有*f(t,r) = 0*。因此，*f(t,t) = f(t-1,t)
    + f(t-1,t-1) = 0 + f(t-1,t-1) = f(t-1,t-1)*对于任何*t*都成立。同样，*f(t-1,t-1) = f(t-2,t-2)
    = f(t-3,t-3) = … = f(0,0) = 1*（因为*f(t,0) = 1*）。因此，所有`choose`函数的条件都得到了满足；因此我们可以看到*f(t,r)
    = choose(t,r) = choose(h-1, l-1)*。由于`choose`函数也被称为二项式系数，这为二项树提供了它的名字。
- en: Number of nodes
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节点数量
- en: 'What is the number of nodes n in a binomial tree of height *h*? When *h=1,*
    we only have one node. A tree of height 2 is made up of two trees of height 1,
    a tree of height 3 is made up of two trees of height 2, and so on. So, for the
    increment of 1 in height, the number of nodes must be twice as much as the original
    number. That is, when *h=1, n=1; h=2, n=2; h=3, n=4,...* In general, this should
    be the case: *n = 2* ^(h-1)*= 2* ^t. Here *t* is the height starting from zero.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在高度为*h*的二叉树中，节点数*n*是多少？当*h=1*时，我们只有一个节点。高度为2的树由两个高度为1的树组成，高度为3的树由两个高度为2的树组成，以此类推。因此，当高度增加1时，节点数必须是原始数的两倍。也就是说，当*h=1,
    n=1; h=2, n=2; h=3, n=4,...*。一般来说，情况应该是这样的：*n = 2*^(h-1)*= 2*t。这里的*t*是从零开始的树的高度。
- en: Notice also that we can say that the number of nodes *n* in a tree is the sum
    of the number of nodes in each level, which is *choose(t, r)*, where *r* is the
    level starting from *0* to *t*. The two formulas must be equal, so the sum *choose(t,
    0) + choose(t, 1) + choose(t, 2) + … + choose(t, t)* equals *2* ^t. This is a
    proof of this relationship. There are other proofs as well, but this is a valid
    proof too.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还可以说，树中的节点数*n*是每层节点数的总和，即*choose(t, r)*，其中*r*是从*0*开始的层。这两个公式必须相等，所以总和*choose(t,
    0) + choose(t, 1) + choose(t, 2) + … + choose(t, t)*等于*2*t。这是这个关系的证明。还有其他证明，但这也是一个有效的证明。
- en: The heap property
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆属性
- en: 'Of course, with only this structure, we have no way of making sure of having
    some easy way of figuring out the minimum element. So, we also enforce the heap
    property on a binomial tree:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，仅凭这种结构，我们无法确保有一种简单的方法来找出最小元素。因此，我们还在二叉树上强制执行堆属性：
- en: '![The heap property](img/00069.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![堆属性](img/00069.jpeg)'
- en: Figure 8\. Preserving heap property while merging.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图8. 合并时保持堆属性。
- en: 'This is the property: the value of any node is smaller than the value of each
    of its children. When merging two trees to make one, the only thing we need to
    do to preserve the heap property is to use the heap with the lesser value at its
    top node as the top subtree and the one with the higher value at its top node
    as the subordinate subtree. This is shown in the preceding figure. The red tree
    happens to have a higher value in the root node than that of the green tree. Hence,
    the red tree must be the subordinate tree. The heap property ensures that the
    root of any binomial tree holds the minimum element.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个属性：任何节点的值都小于其每个子节点的值。当合并两个树以形成一个树时，为了保持堆属性，我们只需要做的一件事就是使用顶部节点值较小的堆作为顶级子树，而顶部节点值较大的堆作为从属子树。这在前面的图中有所展示。红色树在根节点上的值恰好高于绿色树。因此，红色树必须是从属树。堆属性确保任何二叉树的根节点包含最小元素。
- en: Binomial forest
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二叉森林
- en: 'So how do we make a queue out of this? Firstly, note that any tree will have
    nodes with at least the power of 2\. But, in a queue, we want an arbitrary number
    of elements. So we store these elements in more than one tree. Any number can
    be expressed as the sum of the power of 2 because any number can be expressed
    in binary form. Suppose we need to store 20 nodes. The number 20 in binary is
    10100\. So we need two binomial trees: one with height 5 and 16 nodes and one
    with height 3 and four nodes. A queue is built using a collection of binomial
    trees to store the nodes. Hence it is called a binomial forest.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何从这构建一个队列呢？首先，请注意，任何树都将有至少2的幂次方的节点。但是，在队列中，我们希望有任意数量的元素。因此，我们在多个树中存储这些元素。任何数字都可以表示为2的幂次方的和，因为任何数字都可以用二进制形式表示。假设我们需要存储20个节点。数字20的二进制是10100。因此，我们需要两个二叉树：一个高度为5，有16个节点，另一个高度为3，有4个节点。队列是通过使用一组二叉树来存储节点来构建的。因此，它被称为二叉森林。
- en: 'Before we discuss how to insert new elements and remove the minimum element,
    we need to understand how to merge two binomial forests. We have already seen
    that the numbers of elements are represented according to binary form. Just write
    the number in binary form, and if 1 exists, it means there is a tree of height
    that is equal to one plus its position from right to left. When we merge two forests,
    the number of elements of the merged forest is the sum of the number of elements
    in the forests that need to be merged. This means the result will have trees of
    sizes where the binary representation of the sum will have the number 1\. We can
    find this binary representation by performing a binary addition of the binary
    representations of the node''s source number. For example, let''s merge two forests:
    one with 12 elements and one with 10 elements. Their binary representations will
    be 1100 and 1010, respectively. If we do a binary addition, we have 1100 + 1010
    = 10110\. This means the original trees had trees of heights 3, 5 and 4, 5 and
    the result must have trees of heights 3, 4, and 6\. The merge happens the same
    way we do a binary addition. The trees are stored in sequence, and we have empty
    places that represent zeros in the binary representation. While merging, each
    tree represents a bit and it has the number of nodes that the bit represents.
    We take the corresponding bit from each forest and also consider a carry. All
    these trees must either be empty or have exactly the same number of nodes. Then,
    we merge them to create the resulting bits.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论如何插入新元素和移除最小元素之前，我们需要了解如何合并两个二项森林。我们已经看到，元素的数量是按照二进制形式表示的。只需将数字写成二进制形式，如果存在1，则表示有一个高度等于从右到左位置加一的树。当我们合并两个森林时，合并后森林的元素数量是需要合并的森林中元素数量的总和。这意味着结果将具有大小为二进制表示中存在1的树。我们可以通过执行节点源数的二进制表示的二进制加法来找到这个二进制表示。例如，让我们合并两个森林：一个有12个元素，另一个有10个元素。它们的二进制表示分别是1100和1010。如果我们进行二进制加法，我们有1100
    + 1010 = 10110。这意味着原始树有高度为3、5和4、5的树，结果必须有高度为3、4和6的树。合并的方式与进行二进制加法相同。树按顺序存储，我们有空位代表二进制表示中的0。在合并过程中，每棵树代表一个比特，它有代表该比特的节点数。我们从每个森林中取出相应的比特，并考虑进位。所有这些树必须要么为空，要么有恰好相同数量的节点。然后，我们将它们合并以创建结果比特。
- en: 'To do any binary addition, we have input of three bits for each bit: one from
    each of the input and a carry. We need to compute both the output bit and the
    next carry. Similarly, while merging two trees, we need to compute the output
    tree and the carry tree from the given input trees (two) and a carry tree. Once
    the merging is done, inserting and removing `min` is simple.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行任何二进制加法，我们需要为每个位输入三个比特：一个来自输入，一个来自进位。我们需要计算输出位和下一个进位。同样，在合并两棵树时，我们需要从给定的输入树（两个）和一个进位树中计算输出树和进位树。一旦合并完成，插入和移除`min`就变得简单了。
- en: The `insert` simply merges a forest with a single tree using a single node.
    Removing the minimum element is a little more complicated operation. The first
    step is to find out the minimum. We know every tree has the minimum element at
    its root. So we need to walk through all the trees while comparing the root elements
    to find the minimum element and the tree that has it. Removing it is simply taking
    the root off, leaving a list of subtrees that make a forest of consecutive heights
    of trees. Therefore, we can merge the subtrees in the main forest to complete
    the removal process.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert`操作简单地将一棵树与一个森林合并，使用一个节点即可。移除最小元素的操作稍微复杂一些。第一步是找出最小元素。我们知道每个树的最小元素都在其根节点上。因此，我们需要遍历所有树，同时比较根节点以找到最小元素及其所在的树。移除它就是移除根节点，留下一个由连续树高度组成的森林的子树列表。因此，我们可以将主森林中的子树合并以完成移除过程。'
- en: 'Let''s see the implementation. First, we create a skeleton class. A binomial
    tree has a root, which contains a value and a list of subtrees. The list of subtrees
    is like a dense forest. The list of trees in the forest is stored in a linked
    list. We use `DoublyLinkedList` because we need to remove the last element:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实现。首先，我们创建一个骨架类。二项树有一个根节点，包含一个值和一系列子树。子树列表就像一个密集的森林。森林中的树列表存储在一个链表中。我们使用`DoublyLinkedList`是因为我们需要移除最后一个元素：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As discussed earlier, we will start with the merge operation now. First we
    need to merge two trees, which we will use to merge two forests. Merging two trees
    is a simple constant time operation. Merging with a null tree does not change
    the tree. The two trees being merged should be of the same size. We need to simply
    compare the root elements. The tree with the smaller value in its root will get
    the other as a child:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们现在将开始合并操作。首先，我们需要合并两棵树，我们将使用它们来合并两个森林。合并两棵树是一个简单的常数时间操作。与空树合并不会改变树。正在合并的两棵树应该具有相同的大小。我们需要简单地比较根元素。根值较小的树将作为子树获得：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Since we want to check the minimum element in constant time, just like in a
    heap, we will store the minimum element in a state variable. We will also store
    its position in the `allTrees` list:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望在常数时间内检查最小元素，就像在堆中一样，我们将最小元素存储在一个状态变量中。我们还将存储它在`allTrees`列表中的位置：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We will define a method to find out and update the variables. Since the smallest
    element in any tree is the root, we only have to go through the root to find the
    minimum element:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个方法来找出和更新变量。由于任何树中最小的元素是根，我们只需要遍历根来找到最小元素：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To implement the merging of two forests, we need to first implement how to
    compute the output and carry the tree out of the two input trees and a carry tree.
    These methods are fairly simple. We need to understand that both the input and
    the carry must be of the same size if they are not null. The height of the output
    must be the same as the height of the output, and the height of the carry must
    be one more than the height of the input:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现两个森林的合并，我们首先需要实现如何从两个输入树和一个携带树中计算输出并将树携带出来。这些方法相当简单。我们需要理解，如果它们不为空，输入和携带必须具有相同的大小。输出的高度必须与输出的高度相同，携带的高度必须比输入的高度多一个：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We also need to enhance the `ListIterator` class in our imperative `LinkedList`
    implementation so that we can modify the value of any node while iterating through
    it. We use the following implementation to do this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要增强我们命令式`LinkedList`实现中的`ListIterator`类，以便在遍历过程中修改任何节点的值。我们使用以下实现来完成这个任务：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With these methods available, we can implement the merging of two forests or
    two lists of trees:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有这些方法可用，我们可以实现两个森林或两个树列表的合并：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `Insert` method is very simple to implement with the merge available. Just
    merge a list containing one tree with the value 1:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`Insert`方法在合并可用时实现起来非常简单。只需合并一个包含值为1的树的列表：'
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Removal of the minimum element is a little more complex. It involves removing
    the tree with the minimum value and then considering its root as the minimum element.
    Once this is done, the subtrees need to be merged with the original forest. If
    the last tree is being removed, we must actually remove it from the list. This
    is the same as not writing a leading zero in binary representation. Otherwise,
    we only set the value to `null` so that we know it is a zero bit:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 移除最小元素稍微复杂一些。它涉及到移除具有最小值的树，然后将其根视为最小元素。一旦完成，子树需要与原始森林合并。如果正在移除最后一棵树，我们必须实际上从列表中移除它。这就像在二进制表示中不写前导零一样。否则，我们只设置值为`null`，这样我们知道它是一个零位：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, we can implement the methods required to use it as a priority queue:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以实现所需的方法，以便将其用作优先队列：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This completes our implementation of a binomial queue.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对二项队列的实现。
- en: Complexity of operations in a binomial forest
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二项森林中操作复杂度
- en: 'We already know that the number of nodes in a binomial tree of height *h* is
    *2h-1*. The question is, if we want to store n elements, what should be the maximum
    height of the trees in the forest? We have seen that the trees we need are as
    per the binary expression of the integer *n*. The most significant bit of the
    binary representation of *n* is the floor of (*lg n*), that is the greatest integer
    less than or equal to *lg n*. We will write this as *lg n*. The height of the
    tree representing this bit is *1 + lg n*. The length of the list holding the trees
    in the forest is also *1 + lg n= θ(lg n)*. Both in the case of an insertion and
    removal of a new element, a merge operation is involved. The merge operation is
    constant time for each pair of input trees and one carry. So, the number of operations
    for a merge operation of two forests is this: *constant times the number of trees
    in the largest forest = θ(lg n)*, where *n* is the number of trees in the largest
    forest.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道，高度为*h*的二项树中的节点数是*2h-1*。问题是，如果我们想存储n个元素，森林中树的最高高度应该是多少？我们已经看到，我们需要的树是按照整数*n*的二进制表示来确定的。*n*的二进制表示中最显著的位是(*lg
    n*)的floor值，即小于或等于*lg n*的最大整数。我们将这个值写成*lg n*。表示这个位的树的长度是*1 + lg n*。持有森林中树的列表的长度也是*1
    + lg n= θ(lg n)*。在插入和删除新元素的情况下，都涉及到合并操作。合并操作对于每一对输入树和一位进位来说是常数时间。所以，两个森林合并操作的次数是这个：*常数乘以最大森林中的树的数量
    = θ(lg n)*，其中*n*是最大森林中树的数量。
- en: At the time of insertion, we just merge a new forest of only one tree and one
    element. So this operation is *θ(lg n)*, where n is the number of elements in
    the original forest.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在插入时，我们只是合并一个只包含一棵树和一个元素的新的森林。所以这个操作是*θ(lg n)*，其中n是原始森林中元素的数量。
- en: The removal process involves two steps. The first is to remove the minimum element.
    This involves a constant time operation, which is used to remove the tree with
    the minimum element, and a merge operation, which is *θ(lg n)*, as seen already.
    The second step/operation is to update the tree with the minimum element. This
    involves scanning the roots of all the trees; therefore, it is *θ(lg n)*, just
    like the merge operation. So, as a whole, the removal process is also *θ(lg n)*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 删除过程涉及两个步骤。第一步是删除最小元素。这涉及到一个常数时间操作，用于删除包含最小元素的树，以及一个合并操作，如之前所见，其复杂度为*θ(lg n)*。第二步/操作是更新包含最小元素的树。这涉及到扫描所有树的根，因此，其复杂度也是*θ(lg
    n)*，就像合并操作一样。所以，整体上，删除过程也是*θ(lg n)*。
- en: Checking the minimum element is of course constant time, as we have it referenced
    already.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 检查最小元素当然是常数时间，因为我们已经引用了它。
- en: Sorting using a priority queue
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用优先队列进行排序
- en: 'Since a priority queue always returns the minimum element, if we insert all
    input elements and then keep dequeuing them, they would be dequeued in sorted
    order. This can be used to sort a list of elements. In our example, we will add
    a new method called the `LinkedList` implementation. This implementation sorts
    the elements using `PriorityQueue`. First insert all the elements into the priority
    queue. Then, dequeue the elements and append them back to the linked list:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于优先队列总是返回最小元素，如果我们插入所有输入元素然后不断出队，它们就会按顺序出队。这可以用来对元素列表进行排序。在我们的例子中，我们将添加一个名为`LinkedList`实现的新方法。这个实现使用`PriorityQueue`对元素进行排序。首先将所有元素插入到优先队列中。然后，出队元素并将它们重新连接到链表中：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Both enqueue and dequeue have *θ(lg n)* complexity, and we have to enqueue
    and dequeue each of the elements. We have already seen this: *lg 1 + lg 2 + …
    + lg n = θ(n lg n)*. So, the enqueueing and dequeueing of the elements is *θ(n
    lg n)*, which means the sort is *θ(n lg n)*, which is asymptotically optimal.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 入队和出队都具有*θ(lg n)*的复杂度，我们必须对每个元素进行入队和出队操作。我们已经看到了这一点：*lg 1 + lg 2 + … + lg n
    = θ(n lg n)*。所以，元素的入队和出队是*θ(n lg n)*，这意味着排序是*θ(n lg n)*，这是渐近最优的。
- en: In-place heap sort
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆排序的就地实现
- en: 'We can use an array-based heap implementation to do an in-place sort of the
    elements of an array. The trick is to use the same array for backing the heap.
    In the beginning, we simply insert the elements in the heap from the beginning
    of the array. We achieve this by replacing the array in the heap, except the one
    that is passed. Since the heap also uses the space from the beginning, it does
    not overwrite the elements we are still to insert. While dequeuing the elements,
    we start saving them from the end of the array, as this is the part that is being
    freed up by the heap. This means we want the largest element to be dequeued first.
    This is achieved by simply using a comparator that is the opposite of the one
    that is passed. We add this static method to our `ArrayHeap` class:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用基于数组的堆实现来对数组的元素进行原地排序。技巧是使用相同的数组来支持堆。一开始，我们只需从数组的开始处将元素插入堆中。我们通过替换堆中的数组来实现这一点，除了传递的那个。由于堆也使用从开始的空间，它不会覆盖我们尚未插入的元素。在出队元素时，我们从数组的末尾开始保存它们，因为这是堆正在释放的部分。这意味着我们希望首先出队的是最大的元素。这可以通过简单地使用一个与传递的相反的比较器来实现。我们将这个静态方法添加到我们的
    `ArrayHeap` 类中：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is actually a sort using a priority queue as shown before, except that
    here we are sharing the array with the priority queue. Hence, this sort is also
    *θ(n lg n)*, just as before.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一种使用先前所示优先队列的排序方法，只不过在这里我们与优先队列共享数组。因此，这种排序也是 *θ(n lg n)*，就像之前一样。
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed priority queues and their implementation. Priority
    queues are important data structures that are used in a lot of problems. We saw
    two implementations of a priority queue, a heap, and a binomial forest. We also
    saw how to use priority queues for sorting, which is asymptotically optimal. A
    variation of this allowed us to sort an array in place using an array-based heap.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了优先队列及其实现。优先队列是重要的数据结构，在许多问题中使用。我们看到了优先队列的两种实现，一个是堆，另一个是二叉森林。我们还看到了如何使用优先队列进行排序，这是渐近最优的。这种变化的变体允许我们使用基于数组的堆原地排序数组。
- en: In the next chapter, we will discuss the concept of graphs, which are very useful,
    almost ubiquitous ADTs, and data structures that are used in many real-life applications.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论图的概念，这是一种非常有用、几乎无处不在的ADT，以及用于许多实际应用的数据结构。
