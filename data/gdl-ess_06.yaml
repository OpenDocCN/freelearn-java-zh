- en: Chapter 6. The Real-world Project with Gradle
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章：使用Gradle的实战项目
- en: Until now, we have discussed about building the Java project, web project, Gradle
    life cycle, and multi-module feature of Gradle. As we know, before Gradle, there
    were many other build tools in the market, out of which the most popular ones
    are Ant and Maven. Since many project build scripts were already written in these
    two build tools. In this chapter, we will discuss different migration strategies
    to migrate the projects existing build scripts from Ant, Maven, to Gradle. Along
    with this, we will also focus on integrating Gradle build script to Continuous
    Integration tools like Jenkins and generating Java docs for the code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了构建Java项目、Web项目、Gradle生命周期和Gradle的多模块功能。正如我们所知，在Gradle之前，市场上有很多其他的构建工具，其中最受欢迎的是Ant和Maven。由于许多项目构建脚本已经用这两种构建工具编写。在本章中，我们将讨论不同的迁移策略，将现有项目的构建脚本从Ant、Maven迁移到Gradle。同时，我们还将关注将Gradle构建脚本集成到持续集成工具（如Jenkins）以及为代码生成Java文档。
- en: Migrating from an Ant-based project
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从基于Ant的项目迁移
- en: 'Ant is one of the initial and most popular build tools, which made build and
    deployment processes much simpler as compared to other native script-based build
    tools. Still, you can find many projects that use Ant build script to build the
    project. Ant was developed on the philosophy of imperative programming model,
    which tells the system what to do and also how to do it. Thus, you have the benefit
    of controlling each and every action or step of your build script. The following
    is the sample Ant build script to build any Java project. Here, we are considering
    only minimal required tasks to build a Java project, since our purpose is to discuss
    the strategies to migrate from Ant scripts to Gradle scripts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Ant是最初且最受欢迎的构建工具之一，与其他基于脚本的原生构建工具相比，它使构建和部署过程变得更加简单。尽管如此，你仍然可以找到许多使用Ant构建脚本来构建项目的项目。Ant是在命令式编程模型的哲学基础上开发的，它告诉系统做什么以及如何做。因此，你可以控制构建脚本中的每一个动作或步骤。以下是一个用于构建任何Java项目的示例Ant构建脚本。在这里，我们只考虑构建Java项目所需的最小任务，因为我们的目的是讨论从Ant脚本迁移到Gradle脚本的策略：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, we have defined three targets such as `clean`, `compile`, and `createJar`,
    which will delete the directories, create the directories, compile the Java file
    present in source directories, and finally create the `.jar` file, respectively.
    There are three different strategies that a developer can follow in order to migrate
    the build scripts from Ant to Gradle, as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了三个目标，例如`clean`、`compile`和`createJar`，分别用于删除目录、创建目录、编译源目录中存在的Java文件，并最终创建`.jar`文件。开发者可以遵循以下三种不同的策略来将构建脚本从Ant迁移到Gradle：
- en: Importing an Ant file
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入Ant文件
- en: Using AntBuilder API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AntBuilder API
- en: Rewriting Ant tasks to Gradle tasks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Ant任务重写为Gradle任务
- en: We will discuss each of them with an example.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用示例讨论每一个。
- en: Importing an Ant file
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入Ant文件
- en: 'The very first and simplest approach for migration is to directly import your
    Ant script file into a Gradle script. Consider the following structure:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移的最简单和最直接的方法是将你的Ant脚本文件直接导入到Gradle脚本中。考虑以下结构：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, the project name is `Chapter6`, the Java source directory is `src/main/java`,
    and the Ant build script file is `build.xml`. The source code of `build.xml` is
    mentioned above. Now, as a part of the migration, create the `build_import.gradle`
    file with the following contents:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，项目名称是`Chapter6`，Java源目录是`src/main/java`，Ant构建脚本文件是`build.xml`。上面提到了`build.xml`的源代码。现在，作为迁移的一部分，创建一个包含以下内容的`build_import.gradle`文件：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'That is all. Yes, we have successfully migrated the Ant build script to Gradle
    script. Now, try to execute the following command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。是的，我们已经成功将Ant构建脚本迁移到了Gradle脚本。现在，尝试执行以下命令：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After executing this, you can find the `build`/`classes` and `dist` directory
    in the project directory, and `dist` contains the `JavaProject.jar` file.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此操作后，你可以在项目目录中找到`build`/`classes`和`dist`目录，其中`dist`包含`JavaProject.jar`文件。
- en: Using AntBuilder API
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用AntBuilder API
- en: 'Another approach to migrate is using AntBuilder API. By default, Gradle provides
    an AntBuilder object `ant` to the user. The user can use this object directly
    in the Gradle script to call the Ant tasks. The following is the sample code of
    the `build_antbuilder.gradle` file using AntBuilder API:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移的另一种方法是使用AntBuilder API。默认情况下，Gradle为用户提供了一个AntBuilder对象`ant`。用户可以直接在Gradle脚本中使用此对象来调用Ant任务。以下是一个使用AntBuilder
    API的`build_antbuilder.gradle`文件的示例代码：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, you can see we have used different Ant tasks such as `mkdir`, `javac`,
    `jar`, and so on, as a method of an `ant` object. Now, execute the following command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们使用了不同的 Ant 任务，如`mkdir`、`javac`、`jar`等，作为`ant`对象的方法。现在，执行以下命令：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here also, you will find the same output, that is, it will create the `build`/`classes`
    directory in which you can find class files and the `dist` directory in which
    you can find the `.jar` file.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你也会发现相同的输出，即它会创建一个`build`/`classes`目录，其中你可以找到类文件，以及一个`dist`目录，其中你可以找到`.jar`文件。
- en: Rewriting Ant tasks to Gradle tasks
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Ant 任务重写为 Gradle 任务
- en: This is the final approach. Using this approach rather than using an `ant` object,
    you actually rewrite the complete build logic or functionality using the actual
    Gradle tasks. One simple approach to follow this strategy is that the user first
    needs to logically understand the complete flow file written in Ant and then convert
    it into a Gradle script step by step. For all the targets defined in Ant, the
    user can create tasks in Gradle, and for all the tasks defined in Ant, the user
    can use Gradle features to replicate the same behavior. Gradle provides different
    standard plugins to support most of the steps of the build requirement. A plugin
    has its own life cycle, and with the help of plugins, the user can avoid rewriting
    lot of boiler-plate scripts for a common build functionality. One such plugin
    is the `java` plugin. We have already seen the `java` plugin details in [Chapter
    2](part0019_split_000.html#I3QM2-e78ecbb3ac0544f19c59f96d594821c0 "Chapter 2. Building
    Java Projects"), *Building Java Projects*. If we want to migrate this Ant script
    to Gradle script in order to build a Java project, the user can simply use a `Java`
    plugin and job is done.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最终的方案。使用这种方法而不是使用`ant`对象，你实际上是用实际的 Gradle 任务重写了完整的构建逻辑或功能。遵循这一策略的一个简单方法就是用户首先需要逻辑上理解用
    Ant 编写的完整流程文件，然后逐步将其转换为 Gradle 脚本。对于 Ant 中定义的所有目标，用户可以在 Gradle 中创建任务，对于 Ant 中定义的所有任务，用户可以使用
    Gradle 功能来复制相同的行为。Gradle 提供了不同的标准插件来支持构建需求的大部分步骤。插件有自己的生命周期，借助插件，用户可以避免为常见的构建功能重写大量的样板脚本。其中一个这样的插件是`java`插件。我们已经在[第
    2 章](part0019_split_000.html#I3QM2-e78ecbb3ac0544f19c59f96d594821c0 "第 2 章。构建
    Java 项目")中看到了`java`插件的详细信息，即*构建 Java 项目*。如果我们想将这个 Ant 脚本迁移到 Gradle 脚本以构建一个 Java
    项目，用户可以简单地使用一个`Java`插件，任务就完成了。
- en: 'Consider the `build.gradle` file with the following contents:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下内容的`build.gradle`文件：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If a developer follows the default conventions of a `java` plugin, he only
    needs to write this one line to build a Java project, and on executing the `gradle
    build` command, all the required steps would be done such as compiling code, executing
    unit test cases, and preparing a `.jar` file. However, this is not the case always;
    many legacy projects do not follow the conventions and they might have their own
    conventions. The `gradle` plugin provides the flexibility to configure the plugin
    based on the project''s need. We will rewrite the Ant script into Gradle script
    in the following sample code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开发者遵循`java`插件的默认约定，他只需要写这一行就能构建一个 Java 项目，在执行`gradle build`命令后，所有必要的步骤都会完成，例如编译代码、执行单元测试用例，以及准备`.jar`文件。然而，这并不总是如此；许多遗留项目并不遵循约定，它们可能有自己的一套约定。`gradle`插件提供了根据项目需求配置插件的灵活性。以下示例代码将
    Ant 脚本重写为 Gradle 脚本：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Migrating from a Maven project
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Maven 项目迁移
- en: Maven, one of the another build tool, which got most popularity after Ant and
    it also came with dependency management solution to the problem that the users
    were facing in Ant. The first problem in Ant was imperative programing where user
    has to write lots of boiler plate code. Another problem was dependency management.
    Ant does not have any in-built dependency management solution (Ant later integrated
    with Ivy for dependency management). A user has to write each and every JAR file
    path in the build file that it needs to download, and in case of transitive dependencies,
    it is too complex for the user to identify each and every dependent JAR and mention
    the JAR name in the build file. Also, in case of version conflicts, it consumes
    lots of a developer's efforts. Maven came with the declarative programing model
    and in-built dependency management solution. Gradle is also built on the top of
    these principles; thus, migrating from Maven to Gradle seems very comfortable
    for the user.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Maven，另一个构建工具，在Ant之后获得了最多的普及，它还带来了依赖管理解决方案，以解决用户在Ant中遇到的问题。Ant的第一个问题是命令式编程，用户必须编写大量的样板代码。另一个问题是依赖管理。Ant没有内置的依赖管理解决方案（Ant后来与Ivy集成以进行依赖管理）。用户必须在每个构建文件中写入它需要下载的每个JAR文件的路径，在传递依赖的情况下，对用户来说识别每个依赖的JAR文件并在构建文件中提及JAR名称非常复杂。此外，在版本冲突的情况下，这消耗了开发者大量的精力。Maven带来了声明式编程模型和内置的依赖管理解决方案。Gradle也是基于这些原则构建的；因此，从Maven迁移到Gradle对用户来说似乎非常舒适。
- en: 'Like Ant migration, Gradle does not provide any import feature or in-built
    Maven object. A user needs to rewrite the Maven script to the Gradle script. The
    following are some of the concepts that will help you to smoothly migrate from
    Maven to Gradle:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 与Ant迁移类似，Gradle不提供任何导入功能或内置的Maven对象。用户需要将Maven脚本重写为Gradle脚本。以下是一些有助于您顺利从Maven迁移到Gradle的概念：
- en: Plugin declaration
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件声明
- en: Common conventions
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见约定
- en: Dependency management
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖管理
- en: Repositories configuration
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓库配置
- en: 'Let''s move towards the explanation of these concepts:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转向这些概念的解释：
- en: '**Plugin declaration**: The plugin is the key driver for both Maven and Gradle
    functionalities. Same as Maven plugins, Gradle also packages most of its functionalities
    into plugins. In Maven, a user includes the plugin in the following XML format:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插件声明**：插件是Maven和Gradle功能的关键驱动。与Maven插件相同，Gradle也将大部分功能打包成插件。在Maven中，用户可以通过以下XML格式包含插件：'
- en: '[PRE9]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To include a plugin, the user only needs to write the `apply plugin` statement
    as follows:'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要包含一个插件，用户只需写下以下`apply plugin`语句：
- en: '[PRE10]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Common conventions**: In both Maven and Gradle, a plugin always comes with
    some common conventions for its functionalities. For example, if a user includes
    a `java` plugin, the common convention is that the source code location should
    be `src/main/java`, test code location should be `src/test/java`, and so on. If
    a user includes a plugin and follows the same convention, then he can avoid writing
    any boiler-plate code that could save both his time and effort.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常见约定**：在Maven和Gradle中，插件总是为其功能提供一些常见约定。例如，如果用户包含一个`java`插件，常见约定是源代码位置应该是`src/main/java`，测试代码位置应该是`src/test/java`，等等。如果用户包含插件并遵循相同的约定，那么他可以避免编写任何样板代码，这可以节省他的时间和精力。'
- en: '**Dependency management**: Both Maven and Gradle come with in-built dependency
    management features. A user does not need to bother about each and every individual
    JAR required for the project. He just needs to mention the first-level dependency
    in the project, the rest all is taken care by the build tool.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖管理**：Maven和Gradle都自带内置的依赖管理功能。用户无需担心项目中每个单独的JAR文件。他只需在项目中提及一级依赖，其余的都由构建工具处理。'
- en: 'In Maven, a user can mention the dependency in the following format:'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Maven中，用户可以以下格式提及依赖：
- en: '[PRE11]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To define the dependency in Gradle, a user has to use the following syntax:'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要在Gradle中定义依赖，用户必须使用以下语法：
- en: '[PRE12]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What scope is to Maven, the dependency configuration is to Gradle. You might
    have observed the scope attribute in Maven and dependency configuration attributes
    in Gradle. In Maven, scope identifies at which phase of build dependency needs
    to be downloaded. In Gradle, dependency configurations fulfill the same need.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于Maven来说，作用域是针对依赖配置的。你可能已经注意到了Maven中的作用域属性和Gradle中的依赖配置属性。在Maven中，作用域标识了在构建的哪个阶段需要下载依赖。在Gradle中，依赖配置满足同样的需求。
- en: '**Repositories configuration**: Whenever we talk about dependencies, the first
    thing that comes into mind is the repository. This is the location from where
    you download dependencies. The following is the code snippet that can help you
    mention the repository location in Maven:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仓库配置**：每当谈到依赖项时，首先想到的是仓库。这是你下载依赖项的位置。以下是一个代码片段，可以帮助你在 Maven 中提及仓库位置：'
- en: '[PRE13]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In Gradle, you can mention the repository using the following syntax:'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Gradle 中，你可以使用以下语法提及仓库：
- en: '[PRE14]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As we have seen, both Maven and Gradle follow the same philosophy for building
    any project. The main difference is Maven uses XML that is good at structure,
    but can be a pain while configuring the build script, whereas Gradle uses Groovy
    script that is a DSL and offers great flexibility while managing and altering
    the default behavior.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，Maven 和 Gradle 在构建任何项目时遵循相同的哲学。主要区别是 Maven 使用 XML，它擅长结构，但在配置构建脚本时可能会很痛苦，而
    Gradle 使用 Groovy 脚本，它是一种 DSL，在管理和更改默认行为时提供了很大的灵活性。
- en: Publishing artifacts
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布工件
- en: Building a software does not make much sense unless you publish your software
    to some common repositories so that, if needed, it can be reused by other software
    or projects. We have discussed the repositories while downloading the dependencies.
    The other aspect of repositories is uploading the build outcome (JAR, WAR, EAR,
    and so on) to some common location so that it could be downloaded by other developers.
    The different plugins in Gradle provide an automated way to publish the default
    artifacts of the plugin. For example, a `java` plugin provides a task to upload
    a JAR file, a `war` plugin provides a task to upload a WAR file, a `scala` plugin
    provides a task to upload a JAR file, and so on. A user just needs to configure
    the *upload repository* location. If a user does not want to upload the default
    build artifact or a user wants to upload some custom artifacts, he can easily
    customize Gradle tasks to upload the other artifacts and also as per his custom
    requirements.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 构建软件没有多大意义，除非你将你的软件发布到一些常见的仓库，以便在需要时可以被其他软件或项目重用。我们已经讨论了在下载依赖项时的仓库。仓库的另一个方面是将构建结果（JAR、WAR、EAR
    等）上传到某个常见位置，以便其他开发者可以下载。Gradle 中的不同插件提供了一种自动化的方式来发布插件的默认工件。例如，一个 `java` 插件提供了一个任务来上传
    JAR 文件，一个 `war` 插件提供了一个任务来上传 WAR 文件，一个 `scala` 插件提供了一个任务来上传 JAR 文件，等等。用户只需要配置
    *上传仓库* 位置。如果用户不想上传默认的构建工件，或者用户想上传一些自定义工件，他可以轻松地自定义 Gradle 任务来上传其他工件，并按照他的自定义要求。
- en: As we have seen, a `java` plugin provides different configurations such as compile,
    testCompile, runtime, and so on, to download JAR for a specific scope. To upload
    artifacts, Gradle provides one additional configuration, **archives**. A user
    can configure the artifact in archives configuration, and using the `uploadArchive`
    task, he can upload the artifacts to a repository.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，一个 `java` 插件提供了不同的配置，如编译、测试编译、运行时等，以下载特定范围的 JAR 文件。为了上传工件，Gradle 提供了一个额外的配置，**存档**。用户可以在存档配置中配置工件，并使用
    `uploadArchive` 任务将工件上传到仓库。
- en: 'The following is the sample example of the build file (`build_uploadArtifact.gradle`)
    to upload a JAR file generated by a `java` plugin:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个构建文件（`build_uploadArtifact.gradle`）的示例，用于上传由 `java` 插件生成的 JAR 文件：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can execute the `gradle –b build_uploadArtifact.gradle uploadArchives` command
    to upload the artifacts. As a part of life cycle, it will build and upload the
    artifacts.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以执行 `gradle –b build_uploadArtifact.gradle uploadArchives` 命令来上传工件。作为生命周期的一部分，它将构建并上传工件。
- en: In the preceding example, the `uploadArchives` task uploads the artifact to
    a repository (mentioned in the URL). If it is a secured repository, you can provide
    a username and password, or else ignore it. You have noticed that we have not
    mentioned archives here, so what would get uploaded? As we have already discussed,
    a `java` plugin builds the JAR file, a `war` plugin builds the WAR file, and so
    on. Thus, the default artifact generated by a plugin would be uploaded by default
    as a part of the `uploadArchives` task. We will see another example as to how
    to upload your custom artifact.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`uploadArchives` 任务将工件上传到仓库（在URL中提及）。如果是一个受保护的仓库，你可以提供用户名和密码，否则忽略它。你已经注意到我们没有在这里提到存档，那么会上传什么？正如我们已经讨论过的，一个
    `java` 插件构建 JAR 文件，一个 `war` 插件构建 WAR 文件，等等。因此，插件默认生成的工件将默认作为 `uploadArchives`
    任务的一部分上传。我们将看到另一个示例，说明如何上传你的自定义工件。
- en: 'The following is the `build_uploadCustom.gradle` file:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `build_uploadCustom.gradle` 文件：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, execute the `gradle –b build_uploadCustom.gradle uploadArchives` command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行 `gradle –b build_uploadCustom.gradle uploadArchives` 命令：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, you can find that a new directory `tempRepo` is created after executing
    the build script. This contains all the above artifacts (ZIP, JAR, and XML files)
    that are published by the Gradle script.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以发现执行构建脚本后创建了一个新的目录 `tempRepo`。这个目录包含了 Gradle 脚本发布的所有上述工件（ZIP、JAR 和 XML
    文件）。
- en: 'In the preceding example, we have covered the following two cases:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们涵盖了以下两个情况：
- en: Uploading a custom file (a XML and ZIP file along with the default artifact)
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上传自定义文件（一个 XML 文件和一个 ZIP 文件以及默认的工件）
- en: Uploading to a local file system (not on a central repository)
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上传到本地文件系统（不在中央仓库上）
- en: If you configure any other custom file (JAR, WAR, or any other file) to the
    archives, it will also get uploaded to the repository. Here, we have configured
    two additional files, one `.xml` file and one `.zip` file along with the default
    Java artifact. If you want to share your artifacts with your team mates and at
    the same time do not want to upload the artifact to the repository, unless it
    passes integration tests, Gradle gives you the flexibility to upload the file
    to a local file system using `flatDir`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将任何其他自定义文件（JAR、WAR 或其他文件）配置到存档中，它也会被上传到仓库。在这里，我们配置了两个额外的文件，一个是 `.xml` 文件，另一个是
    `.zip` 文件，以及默认的 Java 工件。如果你想与你的团队成员共享工件，同时又不希望将工件上传到仓库，除非它通过了集成测试，Gradle 提供了使用
    `flatDir` 将文件上传到本地文件系统的灵活性。
- en: Gradle recently introduced a `maven-publish` plugin to have more control over
    the publishing process. It gives you many additional flexibilities along with
    the default publish tasks. A user can modify the POM file, publish multiple modules,
    and so on.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 最近引入了一个 `maven-publish` 插件，以便更好地控制发布过程。它提供了许多额外的灵活性，以及默认的发布任务。用户可以修改
    POM 文件，发布多个模块等等。
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more details at [https://docs.gradle.org/current/userguide/publishing_maven.html](https://docs.gradle.org/current/userguide/publishing_maven.html).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://docs.gradle.org/current/userguide/publishing_maven.html](https://docs.gradle.org/current/userguide/publishing_maven.html)
    找到更多详细信息。
- en: Continuous Integration
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成
- en: '**Continuous Integration** (**CI**) is one of the most popular buzzwords you
    can read everywhere. As is apparent from its name, CI is the process of integrating
    the code base each time; whenever any one makes commits to the repository. It
    compiles the code, run the unit test cases and prepare the build. One of the benefits
    a user gets here is, if there are compile issues and integration issues, a user
    can figure out at early stages, rather than it being too late. The following is
    the generic workflow the CI tool follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续集成**（**CI**）是你在任何地方都能看到的流行术语之一。从其名称可以看出，CI 是每次代码库有提交时进行代码集成的过程。它编译代码，运行单元测试并准备构建。用户在这里获得的一个好处是，如果存在编译问题和集成问题，用户可以在早期阶段发现，而不是等到太晚。以下是一个
    CI 工具遵循的通用工作流程：'
- en: '![Continuous Integration](img/00010.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![持续集成](img/00010.jpeg)'
- en: Figure 6.1
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1
- en: How does Gradle fit into this flow? To plan the build and deployment automation
    solution for any software, we need a different set of tools to work together to
    achieve the common goal. Jenkins is one of the integration tools that helps to
    integrate the complete workflow. It also works on the concept of plugins; you
    can add different plugins to Jenkins (for example, Gradle, Git, Svn, and so on)
    as per your need and configure them to plan the automation flow.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 如何融入这个流程？为了规划任何软件的构建和部署自动化解决方案，我们需要一套不同的工具协同工作以实现共同目标。Jenkins 是帮助整合完整工作流程的集成工具之一。它还基于插件的概念；你可以根据需要向
    Jenkins 添加不同的插件（例如，Gradle、Git、Svn 等），并配置它们以规划自动化流程。
- en: Here, we are assuming that you have installed Jenkins. You can install a **Gradle
    plugin** by navigating to **Manage Jenkins** | **Manage Plugins** | **Search for
    Gradle**.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们假设你已经安装了 Jenkins。你可以通过导航到 **管理 Jenkins** | **管理插件** | **搜索 Gradle** 来安装一个
    **Gradle 插件**。
- en: '![Continuous Integration](img/00011.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![持续集成](img/00011.jpeg)'
- en: Figure 6.2
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2
- en: 'Once a plugin is installed, you can configure jobs in Jenkins using the following
    screenshot:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了插件，你就可以使用以下截图在 Jenkins 中配置作业：
- en: '![Continuous Integration](img/00012.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![持续集成](img/00012.jpeg)'
- en: Figure 6.3
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3
- en: Under project configuration screen, you need to configure the repository path.
    By default, Jenkins provides CVS and SVN plugins. If you need any other repository
    (perforce or Git), you can add the respective plugins. After repository configuration,
    you need to configure the **Build Triggers**. It allows you to trigger build periodically
    or, if you want to build on every commit, you can choose **Poll SCM**. Now, it
    is time to configure your build script that will build your project.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目配置屏幕下，你需要配置仓库路径。默认情况下，Jenkins 提供了 CVS 和 SVN 插件。如果你需要其他仓库（如 Perforce 或 Git），你可以添加相应的插件。在仓库配置之后，你需要配置
    **构建触发器**。它允许你定期触发构建，或者如果你想在每个提交时构建，你可以选择 **轮询源代码管理**。现在，是时候配置你的构建脚本，该脚本将构建你的项目。
- en: 'Under the **Build** menu, you can choose **Invoke Gradle script**:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **构建** 菜单下，你可以选择 **调用 Gradle 脚本**：
- en: '![Continuous Integration](img/00013.jpeg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![持续集成](img/00013.jpeg)'
- en: Figure 6.4
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4
- en: If you are using the default build file name `build.gradle`, there is no need
    to configure the build file. Under **Task**, you can mention the name of the task
    you want to execute. For example, if you want to build the project, you can mention
    `build` in the text box.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是默认的构建文件名 `build.gradle`，则无需配置构建文件。在 **任务** 下，你可以提及你想要执行的任务名称。例如，如果你想构建项目，你可以在文本框中提及
    `build`。
- en: 'Once the configuration is done, you can click on **Build Now** on the left
    menu to build the project. Once done, click on the respective build number and
    it will display **Console Output** on the main screen:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成配置，你可以在左侧菜单中点击 **现在构建** 来构建项目。完成后，点击相应的构建编号，它将在主屏幕上显示 **控制台输出**：
- en: '![Continuous Integration](img/00014.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![持续集成](img/00014.jpeg)'
- en: Figure 6.5
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5
- en: Generating documentation
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成文档
- en: Documentation is one of the important part of development life cycle, which
    does not get enough attention from developers. If code is not properly documented,
    it always increases the maintenance efforts and also it takes time for the new
    team member to understand the code, if the code lacks the documentation. When
    you apply **Java plugin** to your build file, Gradle provides you a `javadoc`
    task. By default, Gradle generates the initial documentation for your code, even
    if the user does not mention any **Javadoc** in the file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 文档是开发生命周期的重要组成部分，但开发者对其关注不足。如果代码没有适当记录，它总是会增加维护工作量，而且如果代码缺乏文档，新团队成员理解代码也需要花费时间。当你将
    **Java 插件**应用到构建文件时，Gradle 会为你提供一个 `javadoc` 任务。默认情况下，即使用户在文件中没有提及任何 **Javadoc**，Gradle
    也会为你的代码生成初始文档。
- en: 'Consider the following Java sample code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下 Java 示例代码：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, try to execute the following command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试执行以下命令：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This command will generate the basic Java docs at `<project> \build\docs\javadoc`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在 `<project> \build\docs\javadoc` 生成基本的 Java 文档。
- en: As per requirements, you can add your own tags (`@description`, `@param`, and
    so on) and details to the above class and get the updated Java docs.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 根据要求，你可以在上述类中添加自己的标签（`@description`、`@param` 等）和详细信息，以获取更新的 Java 文档。
- en: Summary
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed different migration strategies from existing build
    tools to Gradle, which could be very handy for users who are planning to migrate
    their existing Ant and Maven scripts to Gradle. We also discussed how to publish
    artifacts to repositories, which is a key functionality of any build tool, which
    help the users to always fetch the latest artifacts from the repositories. We
    discussed CI framework with the help of Jenkins and how Gradle fits into this
    flow, while automating the build and deployment solution. Finally, we discussed
    how to generate documents for the Java code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了从现有的构建工具迁移到 Gradle 的不同迁移策略，这对于计划将现有的 Ant 和 Maven 脚本迁移到 Gradle 的用户来说非常有用。我们还讨论了如何将工件发布到仓库，这是任何构建工具的关键功能，它帮助用户始终从仓库获取最新的工件。我们借助
    Jenkins 讨论了 CI 框架，以及 Gradle 如何融入这一流程，从而自动化构建和部署解决方案。最后，我们讨论了如何为 Java 代码生成文档。
- en: In the next chapter, we will be discussing how to integrate TestNG with Gradle,
    which would help the user to run test cases as a part of the Gradle build. We
    will also be discussing integration testing strategies and Gradle integration
    with code analysis and code coverage tools.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何将 TestNG 与 Gradle 集成，这将帮助用户将测试用例作为 Gradle 构建的一部分运行。我们还将讨论集成测试策略以及
    Gradle 与代码分析和代码覆盖率工具的集成。
