- en: Evolution toward Microservices and Cloud-Native Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向微服务和云原生应用的演进
- en: In the last decade, Spring Framework has evolved into the most popular framework
    to develop Java Enterprise applications. Spring Framework has made it easy to
    develop loosely coupled, testable applications. It has simplified the implementation
    of cross-cutting concerns.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的十年中，Spring框架已经发展成为开发Java企业应用程序的最流行框架。Spring框架使开发松耦合、可测试的应用程序变得容易。它简化了横切关注点的实现。
- en: The world today, however, is very different from a decade back. Over a period
    of time, applications grew into monoliths, which became difficult to manage. And
    because of this problems, new architectures started evolving. The buzzwords in
    the recent past have been RESTful services, microservices, and Cloud-Native applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，今天的世界与十年前大不相同。随着时间的推移，应用程序变得庞大而难以管理。由于这些问题，新的架构开始演变。最近的热词是RESTful服务、微服务和云原生应用程序。
- en: In this chapter, we will start with reviewing the problems Spring Framework
    solved in the last decade. We will look at the problems with **monolithic applications**
    and get introduced to the world of smaller, independently deployable components.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从回顾Spring框架在过去十年中解决的问题开始。我们将了解**单片应用程序**的问题，并介绍更小、独立部署的组件的世界。
- en: We will explore why the world is moving toward microservices and Cloud-Native
    applications. We will end the chapter by looking at how Spring Framework and Spring
    projects are evolving to solve today's problems.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨为什么世界正在向微服务和云原生应用程序发展。我们将结束本章，看看Spring框架和Spring项目如何发展以解决当今的问题。
- en: 'This chapter will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Architecture of a typical Spring-based application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Spring的典型应用程序架构
- en: Problems solved by the Spring Framework in the last decade
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring框架在过去十年中解决的问题
- en: What are our goals when we develop applications?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们开发应用程序时的目标是什么？
- en: What are the challenges with monolithic applications?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单片应用程序存在哪些挑战？
- en: What are microservices?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是微服务？
- en: What are the advantages of microservices?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务的优势是什么？
- en: What are the challenges with microservices?
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务存在哪些挑战？
- en: What are the good practices that help in deploying microservices to the Cloud?
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有哪些好的实践可以帮助将微服务部署到云中？
- en: What are the Spring projects that help us in developing microservices and Cloud-Native
    applications?
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有哪些Spring项目可以帮助我们开发微服务和云原生应用程序？
- en: Typical web application architecture with Spring
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具有Spring的典型Web应用程序架构
- en: 'Spring has been the framework of choice to wire Java Enterprise applications
    during the last decade and half. Applications used a layered architecture with
    all cross-cutting concerns being managed using aspect-oriented programming. The
    following diagram shows a typical architecture for a web application developed
    with Spring:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的十五年中，Spring一直是连接Java企业应用程序的首选框架。应用程序使用分层架构，所有横切关注点都使用面向方面的编程进行管理。以下图表显示了使用Spring开发的Web应用程序的典型架构：
- en: '![](img/14f46f15-3f3d-47c6-b9da-b8094b076498.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/14f46f15-3f3d-47c6-b9da-b8094b076498.png)'
- en: 'The typical layers in such an application are listed here. We will list cross-cutting
    concerns as a separate layer, though in reality, they are applicable across all
    layers:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的应用程序中的典型层在这里列出。我们将把横切关注点列为一个单独的层，尽管在现实中，它们适用于所有层：
- en: '**Web layer**: This is typically responsible for controlling the web application
    flow (controller and/or Front Controller) and rendering the view.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web层**：通常负责控制Web应用程序流程（控制器和/或前端控制器）并呈现视图。'
- en: '**Business layer**: This is where all your business logic is written. Most
    applications have transaction management starting from the business layer.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**业务层**：这是您的所有业务逻辑所在。大多数应用程序从业务层开始进行事务管理。'
- en: '**Data layer**: It is also responsible for talking to the database. This is
    responsible for persisting/retrieving data in Java objects to the tables in the
    database.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据层**：它还负责与数据库通信。这负责将Java对象中的数据持久化/检索到数据库中的表中。'
- en: '**Integration layer**: Applications talk to other applications, either over
    queues or by invoking web services. The integration layer establishes such connections
    with other applications.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成层**：应用程序与其他应用程序通信，可以通过队列或调用Web服务来实现。集成层与其他应用程序建立这样的连接。'
- en: '**Cross-cutting concerns**: These are concerns across different layers--logging,
    security, transaction management, and so on. Since Spring IoC container manages
    the beans, it can weave these concerns around the beans through **Aspect-oriented
    programming** (**AOP**).'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**横切关注点**：这些是跨不同层的关注点--日志记录、安全性、事务管理等。由于Spring IoC容器管理bean，它可以通过**面向方面的编程**（**AOP**）在bean周围编织这些关注点。'
- en: Let's discuss each of the layers and the frameworks used in more detail.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们更详细地讨论每个层和使用的框架。 '
- en: Web layer
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web层
- en: Web layer is dependent on how you would want to expose the business logic to
    the end user. Is it a web application? Or are you exposing RESTful web services?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Web层取决于您希望如何向最终用户公开业务逻辑。它是Web应用程序吗？还是您正在公开RESTful Web服务？
- en: Web application - rendering an HTML View
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web应用程序-呈现HTML视图
- en: These web applications use a web MVC framework such as Spring MVC or Struts.
    The View can be rendered using JSP, JSF, or template-based frameworks such as
    Freemarker.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些Web应用程序使用Web MVC框架，如Spring MVC或Struts。视图可以使用JSP、JSF或基于模板的框架（如Freemarker）进行呈现。
- en: RESTful services
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful服务
- en: 'There are two typical approaches used to develop RESTful web services:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 用于开发RESTful Web服务的两种典型方法：
- en: '**JAX-RS**: The Java API for REST services. This is a standard from the Java
    EE specification. Jersey is the reference implementation.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JAX-RS**：用于REST服务的Java API。这是Java EE规范的标准。Jersey是参考实现。'
- en: '**Spring MVC or Spring REST**: Restful services can also be developed with
    Spring MVC.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring MVC或Spring REST**：Restful服务也可以使用Spring MVC开发。'
- en: Spring MVC does not implement JAX-RS so, the choice is tricky. JAX-RS is a Java
    EE standard. But Spring MVC is more innovative and more likely to help you build
    new features faster.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC没有实现JAX-RS，因此选择比较棘手。JAX-RS是一个Java EE标准。但是Spring MVC更具创新性，更有可能帮助您更快地构建新功能。
- en: Business layer
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 业务层
- en: The business layer typically contains all the business logic in an application.
    Spring Framework is used in this layer to wire beans together.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 业务层通常包含应用程序中的所有业务逻辑。在这一层中，使用Spring框架来连接bean。
- en: This is also the layer where the boundary of transaction management begins.
    Transaction management can be implemented using Spring AOP or AspectJ. A decade
    back, **Enterprise Java Beans** (**EJB**) were the most popular approach to implement
    your business layer. With its lightweight nature, Spring is now the framework
    of choice for the business layer.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是事务管理边界开始的地方。事务管理可以使用Spring AOP或AspectJ来实现。十年前，**企业Java Bean**（**EJB**）是实现业务层的最流行方法。由于其轻量级特性，Spring现在是业务层的首选框架。
- en: EJB3 is much simpler than EJB2\. However, EJB3 is finding it difficult to recover
    the ground lost to Spring.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: EJB3比EJB2简单得多。然而，EJB3发现很难赶上Spring失去的地位。
- en: Data layer
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据层
- en: 'Most applications talk to a database. The data layer is responsible for storing
    data from your Java objects to your database and vice versa. The following are
    the most popular approaches to building data layers:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序与数据库通信。数据层负责将Java对象的数据存储到数据库中，反之亦然。以下是构建数据层的最流行方法：
- en: '**JPA**: The **Java Persistence API** helps you to map Java objects (POJOs)
    to your database tables. Hibernate is the most popular implementation for JPA.
    JPA is typically preferred for all transactional applications. JPA is not the
    best choice for batch and reporting applications.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JPA**：**Java持久化API**帮助您将Java对象（POJOs）映射到数据库表。Hibernate是JPA最流行的实现。JPA通常适用于所有事务性应用程序。JPA不是批处理和报告应用程序的最佳选择。'
- en: '**MyBatis**: MyBatis (previously, iBatis) is a simple data-mapping framework.
    As its website ([http://www.mybatis.org/mybatis-3/](http://www.mybatis.org/mybatis-3/))
    says, *MyBatis is a first class persistence framework with support for custom
    SQL, stored procedures and advanced mappings. MyBatis eliminates almost all of
    the JDBC code and manual setting of parameters and retrieval of results*. MyBatis
    can be considered for batch and reporting applications where SQLs and stored procedures
    are more typically used.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MyBatis**：MyBatis（以前是iBatis）是一个简单的数据映射框架。正如其网站（[http://www.mybatis.org/mybatis-3/](http://www.mybatis.org/mybatis-3/)）所说，*MyBatis是一个支持自定义SQL、存储过程和高级映射的一流持久化框架。MyBatis几乎消除了所有的JDBC代码和手动设置参数以及检索结果*。MyBatis可以考虑用于更常用SQL和存储过程的批处理和报告应用程序。'
- en: '**Spring JDBC**: JDBC and Spring JDBC are not that commonly used anymore.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring JDBC**：JDBC和Spring JDBC不再那么常用。'
- en: We will discuss in detail the advantages and disadvantages of JDBC, Spring JDBC,
    MyBatis and JPA in [Chapter 8](b134d136-6980-440f-980c-227e8a46e532.xhtml), *Spring
    Data*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在《第8章》*Spring Data*中详细讨论JDBC、Spring JDBC、MyBatis和JPA的优缺点。
- en: Integration layer
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成层
- en: 'The integration layer is typically where we talk to other applications. There
    might be other applications exposing SOAP or RESTful services over HTTP (the web)
    or MQ:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 集成层通常是我们与其他应用程序交流的地方。可能有其他应用程序通过HTTP（Web）或MQ公开SOAP或RESTful服务。
- en: Spring JMS is typically used to send or receive messages on queues or service
    buses.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring JMS通常用于在队列或服务总线上发送或接收消息。
- en: Spring MVC RestTemplate can be used to invoke RESTful services.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring MVC RestTemplate可用于调用RESTful服务。
- en: Spring WS can be used to invoke SOAP-based web services.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring WS可用于调用基于SOAP的Web服务。
- en: Spring Integration provides a higher level of abstraction for building enterprise
    integration solutions. It enables testability with a clear separation of concerns
    between the application and integration code. It supports all popular enterprise
    integration patterns. We will discuss more about Spring Integration in [Chapter
    10](e6e89939-cdb1-470b-a052-e4688e5bacb1.xhtml), *Spring Cloud Data Flow*.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Integration提供了一个更高级的抽象层，用于构建企业集成解决方案。它通过清晰地分离应用程序和集成代码的关注点，实现了可测试性。它支持所有流行的企业集成模式。我们将在《第10章》*Spring
    Cloud Data Flow*中更多地讨论Spring Integration。
- en: Cross-cutting concerns
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 横切关注点
- en: 'Cross-cutting concerns are concerns that are typically common to multiple layers
    of an application--logging, security, and transaction management, among others.
    Let''s quickly discuss some of these:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 横切关注点是通常适用于应用程序的多个层的关注点--日志记录、安全性和事务管理等。让我们快速讨论其中一些：
- en: '**Logging**: Audit logging at multiple layers can be implemented using Aspect-Oriented
    Programming (Spring AOP or AspectJ).'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志记录**：可以使用面向方面的编程（Spring AOP或AspectJ）在多个层实现审计日志记录。'
- en: '**Security**: Security is typically implemented using the Spring Security framework.
    As discussed in the previous chapter, Spring Security makes the implementation
    of security very simple.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：通常使用Spring Security框架来实现安全性。正如前一章所讨论的，Spring Security使安全性的实现变得非常简单。'
- en: '**Transaction management**: Spring Framework provides a consistent abstraction
    for transaction management. More importantly, Spring Framework provides great
    support for declarative transaction management. The following are some of the
    transaction APIs that the Spring Framework supports:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事务管理**：Spring框架为事务管理提供了一致的抽象。更重要的是，Spring框架为声明式事务管理提供了很好的支持。以下是Spring框架支持的一些事务API：'
- en: The **Java Transaction API** (**JTA**) is a standard for transaction management.
    It is a part of Java EE's specifications.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java事务API**（**JTA**）是事务管理的标准。它是Java EE规范的一部分。'
- en: JDBC.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDBC。
- en: JPA (including Hibernate).
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JPA（包括Hibernate）。
- en: '**Error handling**: Most abstractions provided by Spring use unchecked exceptions
    so unless required by business logic, it is sufficient to implement error handling
    in the layer that is exposed to the client (user or other application). Spring
    MVC provides Controller Advice to implement consistent error handling across the
    application.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理：Spring提供的大多数抽象使用未检查的异常，因此除非业务逻辑需要，否则在暴露给客户（用户或其他应用程序）的层中实现错误处理就足够了。Spring
    MVC提供了Controller Advice来实现整个应用程序中一致的错误处理。
- en: The Spring Framework plays a major role in application architecture. Spring
    IoC is used to wire beans from different layers together. Spring AOP is used to
    weave cross-cutting concerns around the beans. Added to these is the fact that
    Spring provides great integration with frameworks in different layers.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架在应用程序架构中扮演着重要角色。Spring IoC用于将不同层中的bean连接在一起。Spring AOP用于在bean周围编织交叉关注点。除此之外，Spring还与不同层的框架提供了很好的集成。
- en: In the next section, we will quickly review some of the important problems Spring
    has solved in the last decade or so.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将快速回顾Spring在过去十年左右解决的一些重要问题。
- en: Problems solved by Spring
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring解决的问题
- en: 'Spring is the framework of choice to wire Enterprise Java applications. It
    has solved a number of problems that Enterprise Java applications have faced since
    the complexity associated with EJB2\. A few of them are listed as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Spring是连接企业Java应用程序的首选框架。它解决了自EJB2以来企业Java应用程序面临的许多问题。以下是其中的一些：
- en: Loose coupling and testability
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 松耦合和可测试性
- en: Plumbing code
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道代码
- en: Lightweight architecture
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻量级架构
- en: Architectural flexibility
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构灵活性
- en: Simplified implementation of cross-cutting concerns
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化交叉关注点的实现
- en: Best design patterns for free
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳的免费设计模式
- en: Loose coupling and testability
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 松耦合和可测试性
- en: Through dependency injection, Spring brings loose coupling between classes.
    While loose coupling is beneficial to application maintainability in the long
    run, the first benefits are realized with the testability that it brings in.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过依赖注入，Spring实现了类之间的松耦合。虽然松耦合对于长期应用的可维护性是有益的，但首先实现的好处是它带来的可测试性。
- en: Testability was not a forte of Java EE (or J2EE, as it was called then) before
    Spring. The only way to test EJB2 applications was to run them in the container.
    Unit testing them was incredibly difficult.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring之前，Java EE（或当时称为J2EE）并不擅长可测试性。测试EJB2应用程序的唯一方法是在容器中运行它们。对它们进行单元测试非常困难。
- en: That's exactly the problem Spring Framework set out to solve. As we saw in the
    earlier chapters, if objects are wired using Spring, writing unit tests becomes
    easier. We can easily stub or mock dependencies and wire them into objects.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是Spring框架要解决的问题。正如我们在前面的章节中看到的，如果使用Spring来连接对象，编写单元测试会变得更容易。我们可以轻松地存根或模拟依赖项并将它们连接到对象中。
- en: Plumbing code
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道代码
- en: The developer of the late 1990s and early-to mid-2000s will be familiar with
    the amount of plumbing code that had to be written to execute a simple query through
    JDBC and populate the result into a Java object. You had to perform a **Java Naming
    and Directory** **Interface** (**JNDI**) lookup, get a connection, and populate
    the results. This resulted in duplicate code. Usually, problems were repeated
    with exception handling code in every method. And this problem is not limited
    to JDBC.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 20世纪90年代末和21世纪初到中期的开发人员会熟悉必须编写大量管道代码来执行通过JDBC进行简单查询并将结果填充到Java对象中的情况。你必须执行Java命名和目录接口（JNDI）查找，获取连接并填充结果。这导致了重复的代码。通常，问题在每个方法中都会重复出现异常处理代码。而且这个问题并不仅限于JDBC。
- en: One of these problems Spring Framework solved was by eliminating all the plumbing
    code. With Spring JDBC, Spring JMS, and other abstractions, the developers could
    focus on writing business logic. Spring framework took care of the nitty-gritty.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架解决的问题之一是通过消除所有管道代码。通过Spring JDBC、Spring JMS和其他抽象，开发人员可以专注于编写业务逻辑。Spring框架处理了繁琐的细节。
- en: Lightweight architecture
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轻量级架构
- en: Using EJBs made the applications complex, and not all applications needed that
    complexity. Spring provided a simplified, lightweight way of developing applications.
    If distribution was needed, it could be added later.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用EJB使应用程序变得复杂，并非所有应用程序都需要那种复杂性。Spring提供了一种简化、轻量级的应用程序开发方式。如果需要分发，可以随后添加。
- en: Architecture flexibility
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构灵活性
- en: 'Spring Framework is used to wire objects across an application in different
    layers. In spite of its ever-looming presence, Spring Framework did not restrict
    the flexibility or choice of frameworks that application architects and developers
    had. A couple of examples are listed as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架用于在不同层中连接应用程序中的对象。尽管它一直存在，但Spring框架并没有限制应用架构师和开发人员的灵活性或选择框架的选择。以下是一些示例：
- en: Spring Framework provided great flexibility in the web layer. If you wanted
    to use Struts or Struts 2 instead of Spring MVC, it was configurable. You had
    the choice of integrating with a wider range of view and template frameworks.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring框架在Web层提供了很大的灵活性。如果你想使用Struts或Struts 2而不是Spring MVC，是可以配置的。你可以选择与更广泛的视图和模板框架集成。
- en: Another good example is the data layer, where you had possibilities to connect
    with JPA, JDBC, and mapping frameworks, such as MyBatis.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个很好的例子是数据层，你可以通过JPA、JDBC和映射框架（如MyBatis）来连接。
- en: Simplified implementation of cross-cutting concerns
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化交叉关注点的实现
- en: When Spring Framework is used to manage beans, the Spring IoC container manages
    the life cycle--creation, use, auto-wiring, and destruction--of the beans. It
    makes it easier to weave an additional functionality--such as the cross-cutting
    concerns--around the beans.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当Spring框架用于管理bean时，Spring IoC容器管理bean的生命周期——创建、使用、自动连接和销毁。这使得更容易在bean周围编织额外的功能，比如交叉关注点。
- en: Design patterns for free
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 免费的设计模式
- en: 'Spring Framework encourages the use of a number of design patterns by default.
    A few examples are as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Framework默认鼓励使用许多设计模式。一些例子如下：
- en: '**Dependency Injection or Inversion of Controller**: This is the fundamental
    design pattern Spring Framework is built to enable. It enables loose coupling
    and testability.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖注入或控制反转**：这是Spring Framework建立的基本设计模式。它实现了松散耦合和可测试性。'
- en: '**Singleton**: All Spring beans are singletons by default.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单例**：所有Spring bean默认都是单例。'
- en: '**Factory Pattern**: Using the bean factory to instantiate beans is a good
    example of the factory pattern.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工厂模式**：使用bean工厂来实例化bean是工厂模式的一个很好的例子。'
- en: '**Front Controller**: Spring MVC uses DispatcherServlet as the Front Controller.
    So we use the Front Controller pattern when we develop applications with Spring
    MVC.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前端控制器**：Spring MVC使用DispatcherServlet作为前端控制器。因此，当我们使用Spring MVC开发应用程序时，我们使用前端控制器模式。'
- en: '**Template Method**: Helps us avoid boilerplate code. Many Spring-based classes--JdbcTemplate
    and JmsTemplate--are implementations of this pattern.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板方法**：帮助我们避免样板代码。许多基于Spring的类--JdbcTemplate和JmsTemplate--都是这种模式的实现。'
- en: Application development goals
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序开发目标
- en: Before we move on to the concepts of REST services, microservices, and Cloud-Native
    applications, let's take some time to understand the common goals we have when
    we develop applications. Understanding these goals will help us understand why
    applications are moving toward the microservices architecture.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们转向REST服务、微服务和云原生应用程序的概念之前，让我们花些时间了解我们开发应用程序时的共同目标。了解这些目标将有助于我们理解为什么应用程序正在向微服务架构转变。
- en: First of all, we should remember that the software industry is still a relatively
    young industry. One thing that's been a constant in my decade and a half experience
    with developing, designing, and architecting software is that things change. The
    requirements of today are not the requirements of tomorrow. Technology today is
    not the technology we will use tomorrow. While we can try predicting what happens
    in the future, we are often wrong.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该记住，软件行业仍然是一个相对年轻的行业。在我十五年的软件开发、设计和架构经验中，一直有一件事是不变的，那就是事物的变化。今天的需求不是明天的需求。今天的技术不是明天我们将使用的技术。虽然我们可以尝试预测未来会发生什么，但我们经常是错误的。
- en: One of the things we did during the initial decades of software development
    was build software systems for the future. The design and architecture were made
    complex in preparation for future requirements.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发的最初几十年中，我们做的一件事是为未来构建软件系统。设计和架构被复杂化，以应对未来的需求。
- en: 'During the last decade, with **agile** and **extreme programming**, the focus
    shifted to being **lean** and building good enough systems, adhering to basic
    principles of design. The focus shifted to evolutionary design. The thought process
    is this: **If a system has good design for today''s needs, and is continuously
    evolving and has good tests, it can easily be refactored to meet tomorrow''s needs**.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的十年中，随着**敏捷**和**极限编程**，重点转向了**精益**和构建足够好的系统，遵循基本的设计原则。重点转向了演进式设计。思考过程是这样的：**如果一个系统对今天的需求有良好的设计，并且不断发展并且有良好的测试，它可以很容易地重构以满足明天的需求**。
- en: While we do not know where we are heading, we do know that a big chunk of our
    goals when developing applications have not changed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不知道我们的方向，但我们知道在开发应用程序时的大部分目标并没有改变。
- en: The key goals of software development, for a large number of applications, can
    be described with the statement s*peed and safety at scale*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大量应用程序的软件开发的关键目标可以用“规模上的速度和安全”来描述。
- en: We will discuss each of these in elements in the next section.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中讨论这些元素。
- en: Speed
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 速度
- en: The speed of delivering new requirements and innovations is increasingly becoming
    a key differentiator. It is not sufficient to develop (code and test) fast. It
    is important to deliver (to production) quickly. It is now common knowledge that
    the best software organizations in the world deliver software to production multiple
    times every day.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 交付新需求和创新的速度越来越成为一个关键的区分因素。快速开发（编码和测试）已经不够了。快速交付（到生产环境）变得很重要。现在已经普遍认识到，世界上最好的软件组织每天多次将软件交付到生产环境。
- en: 'The technology and business landscape is in a constant flux, and is constantly
    evolving. The key question is "How fast can an application adapt to these changes?".
    Some of the important changes in the technology and business landscape are highlighted
    here:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 技术和商业环境是不断变化和不断发展的。关键问题是“一个应用程序能够多快地适应这些变化？”。这里强调了技术和商业环境中的一些重要变化：
- en: New programming languages
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的编程语言
- en: Go
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go
- en: Scala
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala
- en: Closure
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包
- en: New programming paradigms
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的编程范式
- en: Functional programming
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程
- en: Reactive programming
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式编程
- en: New frameworks
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新框架
- en: New tools
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新工具
- en: Development
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发
- en: Code quality
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码质量
- en: Automation testing
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化测试
- en: Deployment
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署
- en: Containerizations
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器化
- en: New processes and practices
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的流程和实践
- en: Agile
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敏捷
- en: Test-driven development
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: Behavior-driven development
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为驱动开发
- en: Continuous integration
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成
- en: Continuous delivery
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续交付
- en: DevOps
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DevOps
- en: New devices and opportunities
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新设备和机会
- en: Mobile
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动
- en: Cloud
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云
- en: Safety
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全
- en: What is the use of speed without safety? Who would want to go in a car that
    can travel at 300 miles an hour but that has no proper safety features built in?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 速度没有安全有什么用？谁会想要乘坐一辆可以以每小时300英里的速度行驶但没有适当安全功能的汽车呢？
- en: 'Let''s consider a few characteristics of a safe application:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个安全应用程序的几个特点：
- en: Reliability
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可靠性
- en: Reliability is a measure of how accurately the system functions.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠性是系统功能的准确度的度量。
- en: 'The key questions to ask are as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要问的关键问题如下：
- en: Is the system meeting its functional requirements?
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统是否满足其功能要求？
- en: How many defects are leaked during different release phases?
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同的发布阶段泄漏了多少缺陷？
- en: Availability
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可用性
- en: Most external client-facing applications are expected to be available round
    the clock. Availability is a measure of how much percentage of time your application
    is available for your end user.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数外部面向客户的应用程序都希望全天候可用。可用性是衡量应用程序对最终用户可用的时间百分比。
- en: Security
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性
- en: The security of applications and data is critical to the success of organizations.
    There should be clear procedures for authentication (are you who you claim to
    be?), authorization (what access does a user have?), and data protection (is the
    data that is received or sent accurate? Is the data safe and not intercepted by
    unintended users?).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序和数据的安全对组织的成功至关重要。应该有明确的程序进行身份验证（你是你声称的那个人吗？）、授权（用户有什么访问权限？）和数据保护（接收或发送的数据是否准确？数据是否安全，不会被意外用户拦截？）。
- en: We will discuss more about implementing security using Spring Security in [Chapter
    6](09291379-92b0-4d7d-bff7-d77e089f33db.xhtml), *Extending Microservices*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在《第6章》中更多地讨论如何使用Spring Security实现安全性，*扩展微服务*。
- en: Performance
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能
- en: If a web application does not respond within a couple of seconds, there is a
    very high chance that the user of your application will be disappointed. Performance
    usually refers to the ability of a system to provide an agreed-upon response time
    for a defined number of users.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个Web应用程序在几秒内没有响应，你的应用程序的用户很有可能会感到失望。性能通常指的是系统在为定义数量的用户提供约定的响应时间的能力。
- en: High resilience
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高弹性
- en: As applications become distributed, the probability of failures increases. How
    does the application react in the case of localized failures or disruptions? Can
    it provide basic operations without completely crashing?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序变得分布式，故障的概率增加。应用程序在出现局部故障或中断的情况下会如何反应？它能否在完全崩溃的情况下提供基本操作？
- en: This behavior of an application to provide the bare minimum service levels in
    case of unexpected failures is called resilience.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序在出现意外故障时提供最低限度的服务水平的行为被称为弹性。
- en: As more and more applications move towards the Cloud, the resilience of applications
    becomes important.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 随着越来越多的应用程序向云迁移，应用程序的弹性变得重要。
- en: We will discuss building highly resilient microservices using *Spring Cloud
    and Spring Data Flow* in [Chapter 9](9d263fde-d65c-4222-8da9-b360de7ccc12.xhtml),
    *Spring Cloud* and [Chapter 10](e6e89939-cdb1-470b-a052-e4688e5bacb1.xhtml), *Spring
    Cloud Data Flow*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在《第9章》中讨论如何使用*Spring Cloud和Spring Data Flow*构建高度弹性的微服务，*Spring Cloud*和《第10章》*Spring
    Cloud Data Flow*。
- en: Scalability
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可伸缩性
- en: Scalability is a measure of how an application would react when the resources
    at its disposal are scaled up. If an application supports 10,000 users with a
    given infrastructure, can it support at least 20,000 users with double the infrastructure?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 可伸缩性是衡量应用在其可用资源被扩展时的反应能力。如果一个应用程序在给定基础设施支持10,000用户，它能否在双倍基础设施的情况下支持至少20,000用户？
- en: If a web application does not respond within a couple of seconds, there is a
    very high chance that the user of your application will be disappointed. Performance
    usually refers to the ability of a system to provide an agreed-upon response time
    for a defined number of users.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个Web应用程序在几秒内没有响应，你的应用程序的用户很有可能会感到失望。性能通常指的是系统在为定义数量的用户提供约定的响应时间的能力。
- en: In the world of Cloud, the scalability of applications becomes even more important.
    It's difficult to guess how successful a startup might be. Twitter or Facebook
    might not have expected such success when they were incubated. Their success,
    for large measure, depends on how they were able to adapt to a multi-fold increase
    in their user base without affecting the performance.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在云的世界中，应用程序的可伸缩性变得更加重要。很难猜测一个创业公司可能会有多成功。Twitter或Facebook在孵化时可能没有预料到这样的成功。他们的成功在很大程度上取决于他们如何能够适应用户基数的多倍增长而不影响性能。
- en: We will discuss building highly scalable microservices using Spring Cloud and
    Spring Data Flow in [Chapter 9](9d263fde-d65c-4222-8da9-b360de7ccc12.xhtml), *Spring
    Cloud* and [Chapter 10](e6e89939-cdb1-470b-a052-e4688e5bacb1.xhtml), *Spring Cloud
    Data Flow*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在《第9章》中讨论如何使用Spring Cloud和Spring Data Flow构建高度可伸缩的微服务，*Spring Cloud*和《第10章》*Spring
    Cloud Data Flow*。
- en: Challenges with monolithic applications
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单体应用的挑战
- en: Over the last few years, in parallel to working with several small applications,
    I had the opportunity to work on four different monolithic applications in varied
    domains--insurance, banking, and health care. All these applications had very
    similar challenges. In this section, we will start with looking at the characteristics
    of monoliths and then look at the challenges they bring in.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，除了与几个小应用程序一起工作，我还有机会在不同领域的四个不同的单体应用程序上工作--保险、银行和医疗保健。所有这些应用程序都面临着非常相似的挑战。在本节中，我们将首先看一下单体应用的特征，然后再看看它们带来的挑战。
- en: 'First of all: What is a monolith? An application with a lot of code--may be
    greater than 100K lines of code? Yeah.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先：什么是单体应用？一个有很多代码的应用--可能超过10万行代码？是的。
- en: For me, monoliths are those applications for which getting a release out to
    production is a big challenge. Applications that fall into this category have
    a number of user requirements that are immediately needed, but these applications
    are able to do new feature releases once every few months. Some of these applications
    even do feature releases once a quarter or sometimes even as less as twice a year.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，单体应用是那些在将发布推向生产环境时面临巨大挑战的应用。属于这一类别的应用有许多用户需求是迫切需要的，但这些应用可能每隔几个月才能发布新功能。有些应用甚至每季度发布一次功能，有时甚至少至一年两次。
- en: 'Typically, all monolithic applications have these characteristics:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，所有的单体应用都具有这些特征：
- en: '**Large size**: Most of these monolithic applications have more than 100K lines
    of code. Some have codebases with more than a million lines of code.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**体积庞大**：大多数这些单片应用有超过10万行的代码。有些代码库超过100万行代码。'
- en: '**Large teams**: The team size could vary from 20 to 300.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**团队庞大**：团队规模可能从20到300不等。'
- en: '**Multiple ways of doing the same thing**: Since the team is huge, there is
    a communication gap. This results in multiple solutions for the same problem in
    different parts of the application.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多种做同一件事的方式**：由于团队庞大，存在沟通障碍。这导致应用程序不同部分对同一问题有多种解决方案。'
- en: '**Lack of automation testing**: Most of these applications have very few unit
    tests and a complete lack of integration tests. These applications have great
    dependence on manual testing.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺乏自动化测试**：大多数这些应用几乎没有单元测试，也完全缺乏集成测试。这些应用高度依赖手动测试。'
- en: Because of these characteristics, there are a number of challenges faced by
    these monolithic applications.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些特点，这些单片应用面临许多挑战。
- en: Long release cycles
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布周期长
- en: Making a code change in one part of the monolith may impact some other part
    of the monolith. Most code changes will need a complete regression cycle. This
    results in long release cycles.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在单片的一个部分进行代码更改可能会影响单片的其他部分。大多数代码更改都需要完整的回归周期。这导致发布周期很长。
- en: Because there is a lack of automation testing, these applications depend on
    manual testing to find defects. Taking the functionality live is a major challenge.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缺乏自动化测试，这些应用依赖手动测试来发现缺陷。将功能上线是一个重大挑战。
- en: Difficult to scale
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 难以扩展
- en: Typically, most monolithic applications are not Cloud-Native, which means that
    they are not easy to deploy on the Cloud. They depend on manual installation and
    manual configuration. There is typically a lot of work put in by the operations
    team before a new application instance is added to the cluster. This makes scaling
    up and down a big challenge.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，大多数单片应用不是云原生的，这意味着它们不容易部署在云上。它们依赖手动安装和手动配置。通常在将新应用实例添加到集群之前，运维团队需要投入大量工作。这使得扩展规模成为一个重大挑战。
- en: The other important challenge is large databases. Typically, monolithic applications
    have databases running into **terabytes** (**TB**). The database becomes the bottleneck
    when scaling up.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的挑战是大型数据库。通常，单片应用的数据库容量达到**TB**级别。当扩展规模时，数据库成为瓶颈。
- en: Adapting new technologies
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整新技术
- en: Most monolithic applications use old technologies. Adding a new technology to
    the monolith only makes it more complex to maintain. Architects and developers
    are reluctant to bring in any new technologies.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数单片应用使用旧技术。将新技术添加到单片中只会使其更难以维护。架构师和开发人员不愿引入任何新技术。
- en: Adapting new methodologies
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整新方法
- en: 'New methodologies such as **agile** need small (four-seven team members), independent
    teams. The big questions with monolith are these: How do we prevent teams from
    stepping on each other''s toes? How do we create islands that enable teams to
    work independently? This is a difficult challenge to solve.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷等新方法需要小型（四至七人的团队）。单片的重要问题是：我们如何防止团队互相干扰？我们如何创建能够使团队独立工作的岛屿？这是一个难以解决的挑战。
- en: Adapting modern development practices
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代开发实践的调整
- en: Modern development practices such as **Test-Driven Development** (**TDD**),
    **Behavior-Driven Development** (**BDD**) need loosely coupled, testable architecture.
    If the monolithic application has tightly coupled layers and frameworks, it is
    difficult to unit test. It makes adapting modern development practices challenging.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现代开发实践，如**测试驱动开发**（**TDD**）、**行为驱动开发**（**BDD**）需要松耦合、可测试的架构。如果单片应用具有紧密耦合的层和框架，很难进行单元测试。这使得调整现代开发实践具有挑战性。
- en: Understanding microservices
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解微服务
- en: The challenges with monolithic applications lead to organizations searching
    for the silver bullet. How will we be able to make more features live more often?
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 单片应用的挑战导致组织寻找解决方案。我们如何能够更频繁地上线更多功能？
- en: Many organizations have tried different architectures and practices to find
    a solution.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 许多组织尝试了不同的架构和实践来寻找解决方案。
- en: In the last few years, a common pattern emerged among all the organizations
    that were successful at doing this. From this emerged an architectural style that
    was called **microservices architecture**.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，所有成功做到这一点的组织中出现了一个共同模式。从中产生了一种被称为**微服务架构**的架构风格。
- en: 'As Sam Newman says in the book Building Microservices: Many organizations have
    found that by embracing fine-grained, microservice architectures, they can deliver
    software faster and embrace newer technologies.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 正如Sam Newman在《构建微服务》一书中所说：许多组织发现，通过拥抱细粒度、微服务架构，他们可以更快地交付软件并采用更新的技术。
- en: What is a microservice?
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是微服务？
- en: One of the principles I love in software is *keep it small*. This principle
    is applicable irrespective of what you are talking about--the scope of a variable,
    the size of a method, class, package, or a component. You would want all of these
    to be as small as they possibly could be.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我在软件中喜欢的一个原则是*保持小型*。无论你在谈论什么，这个原则都适用——变量的范围、方法、类、包或组件的大小。你希望所有这些都尽可能小。
- en: Microservices is a simple extension of this principle. It's an architectural
    style focused on building small capability-based independently deployable services.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是这一原则的简单延伸。它是一种专注于构建小型基于能力的独立可部署服务的架构风格。
- en: 'There is no single accepted definition of a microservice. We will look at some
    of the popular definitions:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一个单一的微服务定义。我们将看一些流行的定义：
- en: '"Microservices are small, autonomous services that work together"'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: “微服务是小型、自治的服务，彼此协同工作”
- en: '- Sam Newman, Thoughtworks'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '- Sam Newman，Thoughtworks'
- en: '"Loosely coupled service-oriented architecture with bounded contexts"'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: “松耦合的面向服务的架构与有界上下文”
- en: '- Adrian Cockcroft, Battery Ventures'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '- Adrian Cockcroft, Battery Ventures'
- en: '"A microservice is an independently deployable component of bounded scope that
    supports interoperability through message-based communication. Microservice architecture
    is a style of engineering highly automated, evolvable software systems made up
    of capability-aligned microservices" in the book Microservice Architecture'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: “微服务是有界范围内的独立部署组件，通过基于消息的通信支持互操作性。微服务架构是一种由能力对齐的微服务组成的高度自动化、可演进的软件系统的工程风格”在《微服务架构》一书中
- en: '- Irakli Nadareishvili, ‎Ronnie Mitra, ‎Matt McLarty'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '- Irakli Nadareishvili, ‎Ronnie Mitra, ‎Matt McLarty'
- en: While there is no accepted definition, there are a few characteristics that
    are commonly featured in all definitions of microservice. Before we look at the
    characteristics of microservices, we will try and understand the big picture--we
    will look at how architecture without microservices compares with architecture
    using microservices.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有公认的定义，但所有微服务定义中通常具有一些特征。在我们看微服务的特征之前，我们将尝试了解整体情况-我们将看看没有微服务的架构与使用微服务的架构相比如何。
- en: The microservice architecture
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务架构
- en: Monolithic applications--even those that are modularized--have a single deployable
    unit. The following figure shows an example of a monolithic application with three
    modules, module 1, 2, and 3\. These modules can be a business capability that
    is part of the monolithic application. In a shopping application, one of the modules
    might be a product recommendation.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用程序-即使是模块化的-也有一个可部署的单元。下图显示了一个具有三个模块的单体应用程序的示例，模块1、2和3。这些模块可以是单体应用程序的一部分的业务能力。在购物应用程序中，其中一个模块可能是产品推荐。
- en: '![](img/55f0018d-98ab-4e04-832f-a78c693e8f53.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/55f0018d-98ab-4e04-832f-a78c693e8f53.png)'
- en: 'The following figure shows what the preceding monolith looks like when developed
    using microservice architecture:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了使用微服务架构开发的前一个单体应用程序的样子：
- en: '![](img/ea2b1e73-54dd-4612-8346-d95ee4392fef.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea2b1e73-54dd-4612-8346-d95ee4392fef.png)'
- en: 'A few important things to note are as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一些重要事项如下：
- en: Modules are identified based on business capabilities. What functionality is
    the module providing?
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块是基于业务能力进行识别的。模块提供了什么功能？
- en: Each module is independently deployable. In the following example, modules 1,
    2, and 3 are separate deployable units. If there is a change in the business functionality
    of module 3, we can individually build and deploy module 3.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个模块都可以独立部署。在下面的示例中，模块1、2和3是单独的可部署单元。如果模块3的业务功能发生变化，我们可以单独构建和部署模块3。
- en: Microservice characteristics
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务特征
- en: 'In the previous section, we looked at an example of the microservice architecture.
    An evaluation of experiences at organizations successful at adapting the microservices
    architectural style reveals that there are a few characteristics that are shared
    by teams and architectures. Let''s look at some of them:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们看了一个微服务架构的例子。对于成功适应微服务架构风格的组织的经验评估表明，团队和架构共享了一些特征。让我们看看其中一些：
- en: '![](img/c29a5bb1-1fcc-42eb-b70a-318000004230.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c29a5bb1-1fcc-42eb-b70a-318000004230.png)'
- en: Small and lightweight microservices
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小型和轻量级微服务
- en: A good microservice provides a business capability. Ideally, microservices should
    follow the **single responsibility principle**. Because of this, microservices
    are generally small in size. Typically, a rule of thumb I use is that it should
    be possible to build and deploy a microservice within 5 minutes. If the building
    and deployment takes any longer, it is likely that you are building a larger than
    recommended microservice.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的微服务提供了业务能力。理想情况下，微服务应遵循“单一责任原则”。因此，微服务通常规模较小。通常，我使用的一个经验法则是应该能够在5分钟内构建和部署一个微服务。如果构建和部署需要更长时间，很可能正在构建一个比推荐的微服务更大的服务。
- en: 'Some examples of small and lightweight microservices are as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一些小型和轻量级微服务的例子如下：
- en: Product recommendation service
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品推荐服务
- en: Email notification service
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子邮件通知服务
- en: Shopping cart service
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购物车服务
- en: Interoperability with message-based communication
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于消息的通信的互操作性
- en: The key focus of microservices is on interoperability--communication between
    systems using diverse technologies. The best way to achieve interoperability is
    using message-based communication.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的关键重点是互操作性-使用不同技术之间的系统通信。实现互操作性的最佳方式是使用基于消息的通信。
- en: Capability-aligned microservices
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 能力对齐的微服务
- en: It is essential that microservices have a clear boundary. Typically, every microservice
    has a single identified business capability that it delivers well. Teams have
    found success adapting the *Bounded Context* concept proposed in the book *Domain-Driven
    Design* by Eric J Evans.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务必须有清晰的边界是至关重要的。通常，每个微服务都有一个单一的业务能力，它能够很好地提供。团队发现成功地采用了Eric J Evans在《领域驱动设计》一书中提出的“有界上下文”概念。
- en: Essentially, for large systems, it is very difficult to create one domain model.
    Evans talks about splitting the system into different bounded contexts. Identifying
    the right bounded contexts is the key to success with microservice architecture.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，对于大型系统来说，创建一个领域模型非常困难。Evans谈到了将系统拆分为不同的有界上下文。确定正确的有界上下文是微服务架构成功的关键。
- en: Independently deployable units
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 独立部署单元
- en: Each microservice can be individually built and deployed. In the example discussed
    earlier, modules 1, 2, and 3 can each be independently built and deployed.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务都可以单独构建和部署。在前面讨论的示例中，模块1、2和3可以分别构建和部署。
- en: Stateless
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无状态
- en: An ideal microservice does not have a state. It does not store any information
    between requests. All the information needed to create a response is present in
    the request.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 理想的微服务没有状态。它不在请求之间存储任何信息。创建响应所需的所有信息都包含在请求中。
- en: Automated build and release process
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化构建和发布过程
- en: 'Microservices have automated build and release processes. Take a look at the
    following figure. It shows a simple build and release process for a microservice:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务具有自动化的构建和发布流程。看一下下面的图。它展示了微服务的简单构建和发布流程：
- en: '![](img/de250ec2-6ae1-4f5c-936e-0d9a760ac053.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de250ec2-6ae1-4f5c-936e-0d9a760ac053.png)'
- en: When a microservice is built and released, a version of the microservice is
    stored in the repository. The deploy tool has the capability of picking the right
    version of microservice from the repository, matching it with the configuration
    needed for the specific environment (from the configuration repository), and deploying
    the microservice to a specific environment.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个微服务被构建和发布时，微服务的一个版本被存储在仓库中。部署工具有能力从仓库中选择正确的微服务版本，将其与特定环境所需的配置（来自配置仓库）匹配，并将微服务部署到特定环境中。
- en: Some teams take it a step further and combine the microservice package with
    the underlying infrastructure needed to run the microservice. The deploy tool
    will replicate this image and match it with an environment-specific configuration
    to create an environment.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一些团队进一步将微服务包与运行微服务所需的基础设施结合起来。部署工具将复制此映像，并将其与特定环境的配置匹配以创建环境。
- en: Event-driven architecture
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件驱动架构
- en: 'Microservices are typically built with event-driven architecture. Let''s consider
    a simple example. Whenever a new customer is registered, there are three things
    that need to be performed:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务通常采用事件驱动架构构建。让我们考虑一个简单的例子。每当有新客户注册时，需要执行三件事：
- en: Store customer information to the database
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将客户信息存储到数据库中
- en: Mail a welcome kit
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送欢迎套件
- en: Send an email notification
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送电子邮件通知
- en: Let's look at two different approaches to design this.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看设计这个的两种不同方法。
- en: Approach 1 - sequential approach
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法1 - 顺序方法
- en: 'Let''s consider three services--`CustomerInformationService`, `MailService`,
    and `EmailService`, which can provide the capabilities listed earlier. We can
    create `NewCustomerService` with the following steps:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑三个服务--`CustomerInformationService`、`MailService`和`EmailService`，它们可以提供前面列出的功能。我们可以使用以下步骤创建`NewCustomerService`：
- en: Call `CustomerInformationService` to save customer information to the database.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`CustomerInformationService`将客户信息保存到数据库中。
- en: Call `MailService` to mail the welcome kit.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`MailService`发送欢迎套件。
- en: Call `EmailService` to send the e-mail notification.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`EmailService`发送电子邮件通知。
- en: '`NewCustomerService` becomes the central place for all business logic. Imagine
    if we have to do more things when a new customer is created. All that logic would
    start accumulating and bloating up `NewCustomerService`.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewCustomerService`成为所有业务逻辑的中心。想象一下，如果我们在创建新客户时需要做更多的事情。所有这些逻辑将开始累积并使`NewCustomerService`变得臃肿。'
- en: Approach 2 - event-driven approach
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法2 - 事件驱动方法
- en: 'In this approach, we use a message broker. `NewCustomerService` will create
    a new event and post it to the message broker. The following figure shows a high-level
    representation:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们使用消息代理。`NewCustomerService`将创建一个新事件并将其发布到消息代理。下图显示了一个高层表示：
- en: '![](img/38848057-d17b-462d-a224-4ee1b659f944.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/38848057-d17b-462d-a224-4ee1b659f944.png)'
- en: The three services--`CustomerInformationService`, `MailServic`e, and `EmailService`--will
    be listening on the message broker for new events. When they see the new customer
    event, they process it and execute the functionality of that specific service.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 三个服务--`CustomerInformationService`、`MailService`和`EmailService`--将在消息代理上监听新事件。当它们看到新的客户事件时，它们会处理它并执行该特定服务的功能。
- en: The key advantage of the event-driven approach is that there is no centralized
    magnet for all the business logic. Adding a new functionality is easier. We can
    create a new service to listen for the event on the message broker. Another important
    thing to note is that we don't need to make changes to any of the existing services.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动方法的关键优势在于没有所有业务逻辑的集中磁铁。添加新功能更容易。我们可以创建一个新服务来监听消息代理上的事件。还有一点需要注意的是，我们不需要对任何现有服务进行更改。
- en: Independent teams
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 独立团队
- en: The team developing a microservice is typically independent. It contains all
    the skills needed to develop, test, and deploy a microservice. It is also responsible
    for supporting the microservice in production.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 开发微服务的团队通常是独立的。它包含了开发、测试和部署微服务所需的所有技能。它还负责在生产中支持微服务。
- en: Microservice advantages
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务优势
- en: Microservices have several advantages. They help in keeping up with technology
    and getting solutions to your customers faster.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务有几个优势。它们有助于跟上技术并更快地为您的客户提供解决方案。
- en: Faster time to market
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更快的上市时间
- en: The faster time to market is one of the key factors in determining the success
    of an organization.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 更快的上市时间是确定组织成功的关键因素之一。
- en: Microservices architecture involves creating small, independently deployable
    components. Microservice enhancements are easier and less brittle because each
    microservice focuses on a single business capability. All the steps in the process--building,
    releasing, deployment, testing, configuration management, and monitoring--are
    automated. Since the responsibility of a microservice is bounded, it is possible
    to write great automation unit and integration tests.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构涉及创建小型、独立部署的组件。微服务的增强更容易，更不脆弱，因为每个微服务都专注于单一的业务能力。流程中的所有步骤--构建、发布、部署、测试、配置管理和监控--都是自动化的。由于微服务的责任是有界的，因此可以编写出色的自动化单元和集成测试。
- en: All these factors result in applications being able to react faster to customer
    needs.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些因素导致应用程序能够更快地对客户需求做出反应。
- en: Technology evolution
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术演进
- en: 'There are new languages, frameworks, practices, and automation possibilities
    emerging every day. It is important that the application architectures allow flexibility
    to adapt to emerging possibilities. The following figure shows how different services
    are developed in different technologies:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 每天都有新的语言、框架、实践和自动化可能性出现。应用程序架构必须具备灵活性，以适应新的可能性。以下图显示了不同服务是如何使用不同技术开发的：
- en: '![](img/6360b071-e610-4a12-a742-6e8534da43e5.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6360b071-e610-4a12-a742-6e8534da43e5.png)'
- en: The microservice architecture involves creating small services. Within some
    boundaries, most organizations give the individual teams the of technology to
    make some of the technology decisions. This allows teams to experiment with new
    technologies and innovate faster. This helps applications adapt and stay in tune
    with the evolution of technology.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构涉及创建小型服务。在某些边界内，大多数组织都允许个体团队做出一些技术决策。这使团队能够尝试新技术并更快地创新。这有助于应用程序适应并与技术的演进保持一致。
- en: Availability and scaling
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可用性和扩展性
- en: The load on different parts of the application is typically very different.
    For example, in the case of a flight booking application, a customer usually searches
    multiple times before making a decision on whether to book a flight. The load
    on the search module would typically be many times more than the load on the booking
    module. The microservices architecture provides the flexibility of setting up
    multiple instances of the search service with few instances of the booking service.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的不同部分的负载通常非常不同。例如，在航班预订应用程序的情况下，顾客通常在决定是否预订航班之前进行多次搜索。搜索模块的负载通常会比预订模块的负载多很多倍。微服务架构提供了设置多个搜索服务实例和少量预订服务实例的灵活性。
- en: 'The following figure shows how we can scale up specific microservices based
    on the load:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了如何根据负载扩展特定微服务：
- en: '![](img/f71c83f5-dfe6-44c3-9914-e031e7e9ee2e.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f71c83f5-dfe6-44c3-9914-e031e7e9ee2e.png)'
- en: Microservices **2** and **3** share a single box (the deployment environment).
    Microservice **1**, which has more load, is deployed into multiple boxes.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务**2**和**3**共享一个盒子（部署环境）。负载更大的微服务**1**被部署到多个盒子中。
- en: Another example is the need for start-ups. When a start-up begins its operations,
    they are typically unaware of the extent to which they might grow. What happens
    if the demand for applications grows very fast? If they adapt the microservice
    architecture, it enables them to scale better when the need arises.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是初创公司的需求。当初创公司开始运营时，他们通常不知道自己可能会增长到何种程度。如果应用程序的需求增长得非常快会发生什么？如果他们采用微服务架构，它可以使他们在需要时更好地扩展。
- en: Team dynamics
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 团队动态
- en: Development methodologies such as agile advocate small, independent teams. Since
    microservices are small, it is possible to build small teams around them. Teams
    are cross-functional, with end-to-end ownership of specific microservices.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷等开发方法倡导小型、独立的团队。由于微服务很小，围绕它们建立小团队是可能的。团队是跨职能的，对特定微服务拥有端到端的所有权。
- en: Microservice architecture fits in very well with agile and other modern development
    methodologies.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构非常适合敏捷和其他现代开发方法。
- en: Microservice challenges
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务挑战
- en: Microservice architecture has significant advantages. However, there are significant
    challenges too. Deciding the boundaries of microservices is a challenging but
    important decision. Since microservices are small, and there would be hundreds
    of microservices in a large enterprise, having great automation and visibility
    is critical.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构具有显著的优势。但是，也存在显著的挑战。确定微服务的边界是一个具有挑战性但重要的决定。由于微服务很小，在大型企业中可能会有数百个微服务，因此具有良好的自动化和可见性至关重要。
- en: Increased need for automation
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化需求增加
- en: With microservice architecture, you are splitting up a large application into
    multiple microservices, so the number of builds, releases, and deployments increases
    multifold. It would be very inefficient to have manual processes for these steps.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务架构，你将一个大型应用程序拆分成多个微服务，因此构建、发布和部署的数量会成倍增加。对于这些步骤采用手动流程将非常低效。
- en: Test automation is critical to enable a faster time to market. Teams should
    be focused on identifying automation possibilities as they emerge.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 测试自动化对于实现更快的上市时间至关重要。团队应该专注于识别可能出现的自动化可能性。
- en: Defining the boundaries of subsystems
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义子系统的边界
- en: Microservices should be intelligent. They are not weak CRUD services. They should
    model the business capability of the system. They own all the business logic in
    a bounded context. Having said this, microservices should not be large. Deciding
    the boundaries of microservices is a challenge. Finding the right boundaries might
    be difficult on the first go. It is important that as a team gains more knowledge
    about the business context, the knowledge flows into the architecture and new
    boundaries are determined. Generally, finding the right boundaries for microservices
    is an evolutionary process.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务应该是智能的。它们不是弱的CRUD服务。它们应该模拟系统的业务能力。它们在一个有界上下文中拥有所有的业务逻辑。话虽如此，微服务不应该很大。决定微服务的边界是一个挑战。第一次确定正确的边界可能会很困难。团队对业务上下文的了解越多，知识就会流入架构中，并确定新的边界。通常，找到微服务的正确边界是一个演进的过程。
- en: 'A couple of important points to note are as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是需要注意的几个重要点：
- en: Loose coupling and high cohesion are fundamental to any programming and architectural
    decisions. When a system is loosely coupled, changes in one part should not require
    a change in other parts.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 松耦合和高内聚对于任何编程和架构决策都是基本的。当系统松耦合时，对一个部分的更改不应该需要其他部分的更改。
- en: Bounded contexts represent autonomous business modules representing specific
    business capabilities.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有界上下文代表着具体业务能力的自治业务模块。
- en: As Sam Newman says in the book *Building Microservices--*"Specific responsibility
    enforced by explicit boundaries". Always think, "What capabilities are we providing
    to the rest of the domain?".
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 正如Sam Newman在书中所说的“构建微服务--”：“通过明确的边界强制执行特定的责任”。始终思考，“我们为域的其他部分提供了哪些能力？”。
- en: Visibility and monitoring
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可见性和监控
- en: With microservices, one application is split into several microservices. To
    conquer the complexity associated with multiple microservices and asynchronous
    event-based collaboration, it is important to have great visibility.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务，一个应用程序被拆分成多个微服务。为了征服与多个微服务和异步基于事件的协作相关的复杂性，具有良好的可见性是很重要的。
- en: Ensuring high availability means each microservice should be monitored. Automated
    health management of the microservices becomes important.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 确保高可用性意味着每个微服务都应该受到监控。自动化的微服务健康管理变得很重要。
- en: Debugging problems needs insights into what's happening behind multiple microservices.
    Centralized logging with aggregation of logs and metrics from different microservices
    is typically used. Mechanisms such as correlation IDs need to be used to isolate
    and debug issues.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 调试问题需要洞察多个微服务背后发生的情况。通常使用集中日志记录，从不同微服务中聚合日志和指标。需要使用诸如关联ID之类的机制来隔离和调试问题。
- en: Fault tolerance
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容错性
- en: Let's say we are building a shopping application. What happens if the recommendation
    microservice is down? How does the application react? Does it completely crash?
    Or will it let the customer shop? These kinds of situations happen more often
    as we adapt the microservices architecture.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在构建一个购物应用程序。如果推荐微服务宕机会发生什么？应用程序如何反应？会完全崩溃吗？还是会让顾客继续购物？随着我们适应微服务架构，这种情况会更加频繁发生。
- en: As we make the services small, the chance that a service is down increases.
    How the application reacts to these situations becomes an important question.
    In the earlier example, a fault-tolerant application would show some default recommendations
    while letting the customer shop.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们将服务变得更小，服务宕机的可能性增加。应用程序如何应对这些情况成为一个重要问题。在前面的例子中，一个容错应用程序会显示一些默认的推荐，同时让顾客继续购物。
- en: As we move into microservices architecture, applications should be more fault
    tolerant. Applications should be able to provide toned-down behavior when services
    are down.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进入微服务架构，应用程序应该更具有容错性。应用程序应该能够在服务宕机时提供降级行为。
- en: Eventual consistency
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终一致性
- en: It is important to have a degree of consistency between microservices in an
    organization. Consistency between microservices enables similar development, testing,
    release, deployment, and operational processes across the organization. This enables
    different developers and testers to be productive when they move across teams.
    It is important to be not very rigid and have a degree of flexibility within limits
    so as to not stifle innovation.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在组织中，微服务之间的一定程度的一致性是很重要的。微服务之间的一致性使得整个组织能够在开发、测试、发布、部署和运营过程中实现类似的流程。这使得不同的开发人员和测试人员在跨团队移动时能够保持高效。在一定程度上保持灵活性，而不是过于死板，以避免扼杀创新，这是很重要的。
- en: Shared capabilities (enterprise level)
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享能力（企业级）
- en: Let's look at a few capabilities that have to be standardized at an enterprise
    level.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在企业级必须标准化的一些能力。
- en: '**Hardware**: What hardware do we use? Do we use Cloud?'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬件**：我们使用什么硬件？我们使用云吗？'
- en: '**Code management**: What version control system do we use? What are our practices
    in branching and committing code?'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码管理**：我们使用什么版本控制系统？我们在分支和提交代码方面的做法是什么？'
- en: '**Build and deployment**: How do we build? What tools do we use to automate
    deployment?'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建和部署**：我们如何构建？我们使用什么工具来自动化部署？'
- en: '**Data store**: What kind of data stores do we use?'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据存储**：我们使用什么类型的数据存储？'
- en: '**Service orchestration**: How do we orchestrate services? What kind of message
    broker do we use?'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务编排**：我们如何编排服务？我们使用什么样的消息代理？'
- en: '**Security and identity**: How do we authenticate and authorize users and services?'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全和身份**：我们如何对用户和服务进行身份验证和授权？'
- en: '**System visibility and monitoring**: How do we monitor our services? How do
    we provide fault isolation across the system?'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统可见性和监控**：我们如何监控我们的服务？我们如何在整个系统中提供故障隔离？'
- en: Increased need for operations teams
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运维团队需求增加
- en: As we move into a microservice world, there is a distinct shift in the responsibilities
    of operations team. The responsibilities shift to identifying opportunities for
    automation compared to manual operations such as executing releases and deployments.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进入微服务世界，运维团队的责任发生了明显的转变。责任转移到识别自动化机会，而不是手动操作，比如执行发布和部署。
- en: With multiple microservices and an increase in communications across different
    parts of the system, the operations team becomes critical. It is important to
    involve operations as part of the team from the initial stages to enable them
    to identify solutions to make operations easier.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 随着多个微服务和系统不同部分之间通信的增加，运维团队变得至关重要。重要的是在初始阶段就将运维团队纳入团队，以便他们能够找到简化运维的解决方案。
- en: Cloud-Native applications
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云原生应用
- en: The Cloud is disrupting the world. A number of possibilities have emerged that
    were never possible before. Organizations are able to provision computing, network,
    and storage devices on demand. This has high potential to reduce costs in a number
    of industries.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 云正在改变世界。出现了以前从未可能的许多可能性。组织能够按需提供计算、网络和存储设备。这在许多行业中有很高的潜力来降低成本。
- en: Consider the retail industry, where there is high demand in pockets (Black Friday,
    holiday season, and so on). Why should they pay for hardware throughout the year
    when they could provision it on demand?
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑零售行业，在某些时段需求很高（黑色星期五，假日季等）。为什么他们要在整年都支付硬件费用，而不是按需提供呢？
- en: While we would like to be benefit from the possibilities of the Cloud, these
    possibilities are limited by architecture and the nature of applications.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们希望从云的可能性中受益，但这些可能性受到架构和应用程序性质的限制。
- en: How do we build applications that can be easily deployed on the Cloud? That's
    where Cloud-Native applications come into the picture.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何构建可以轻松部署到云上的应用程序？这就是云原生应用程序的作用。
- en: Cloud-Native applications are those that can easily be deployed on the Cloud.
    These applications share a few common characteristics. We will begin by looking
    at the Twelve-Factor App--a combination of common patterns among Cloud-Native
    applications.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生应用程序是那些可以轻松部署到云上的应用程序。这些应用程序共享一些共同的特征。我们将首先看一下 Twelve-Factor 应用程序--云原生应用程序中常见模式的组合。
- en: Twelve-Factor App
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Twelve-Factor 应用程序
- en: The Twelve-Factor App evolved from the experiences of engineers at Heroku. It
    is a list of patterns that are used in Cloud-Native application architectures.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Twelve-Factor 应用程序是由 Heroku 的工程师的经验演变而来的。这是一份在云原生应用程序架构中使用的模式列表。
- en: It is important to note that an app here refers to a single deployable unit.
    Essentially, every microservice is an app (because each microservice is independently
    deployable).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这里的应用程序是指一个单独的可部署单元。基本上，每个微服务都是一个应用程序（因为每个微服务都可以独立部署）。
- en: Maintain one code base
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 维护一个代码库
- en: Each app has one code base in revision control. There can be multiple environments
    where the app can be deployed. However, all these environments use code from a
    single codebase. An example antipattern is building a deployable from multiple
    codebases.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序在修订控制中有一个代码库。可以部署应用程序的多个环境。但是，所有这些环境都使用来自单个代码库的代码。一个反模式的例子是从多个代码库构建可部署的应用程序。
- en: Dependencies
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖项
- en: All dependencies must be explicitly declared and isolated. Typical Java applications
    use build management tools such as Maven and Gradle to isolate and track dependencies.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 所有依赖项必须明确声明和隔离。典型的 Java 应用程序使用构建管理工具，如 Maven 和 Gradle 来隔离和跟踪依赖项。
- en: 'The following figure shows typical Java applications managing dependencies
    using Maven:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了典型的 Java 应用程序使用 Maven 管理依赖项：
- en: '![](img/8e22e887-9a41-4542-880d-0bd0d8861a08.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e22e887-9a41-4542-880d-0bd0d8861a08.png)'
- en: 'The following figure shows `pom.xml`, where the dependencies are managed for
    a Java application:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了 `pom.xml`，其中管理了 Java 应用程序的依赖项：
- en: '![](img/4500d394-7dd1-4681-b0ea-5f6fa3a2d815.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4500d394-7dd1-4681-b0ea-5f6fa3a2d815.png)'
- en: Config
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置
- en: All applications have configuration that varies from one environment to another.
    Configuration is found at multiple locations; application code, property files,
    databases, environment variables, JNDI, and system variables are a few examples.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 所有应用程序的配置在不同环境之间都有所不同。配置可以在多个位置找到；应用程序代码、属性文件、数据库、环境变量、JNDI 和系统变量都是一些例子。
- en: A Twelve-Factor App
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Twelve-Factor 应用程序
- en: App should store configuration in the environment. While environment variables
    are recommended in order to manage configuration in a Twelve-Factor App, other
    alternatives, such as having a centralized repository for application configuration,
    should be considered for more complex systems.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序应在环境中存储配置。虽然在 Twelve-Factor 应用程序中建议使用环境变量来管理配置，但对于更复杂的系统，应考虑其他替代方案，例如为应用程序配置建立一个集中存储库。
- en: 'Irrespective of the mechanism used, we recommend that you do the following:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用何种机制，我们建议您执行以下操作：
- en: Manage configuration outside the application code (independent of the application's
    deployable unit)
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序代码之外管理配置（独立于应用程序的可部署单元）
- en: Use a standardized way of configuration
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准化的配置方式
- en: Backing services
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后备服务
- en: Applications depend on other services being available--data stores and external
    services, among others. The Twelve-Factor App treats backing services as attached
    resources. A backing service is typically declared via an external configuration.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序依赖于其他可用的服务--数据存储和外部服务等。Twelve-Factor 应用程序将后备服务视为附加资源。后备服务通常通过外部配置声明。
- en: Loose coupling to a backing service has many advantages, including the ability
    to gracefully handle an outage of a backing service.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 与后备服务的松耦合具有许多优势，包括能够优雅地处理后备服务的中断。
- en: Build, release, run
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建、发布、运行
- en: 'The build, release, and run phases are described as follows. We should maintain
    a clear separation between all these three phases:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 构建、发布和运行阶段的描述如下。我们应该在这三个阶段之间保持清晰的分离：
- en: '**Build**: Creates an executable bundle (EAR, WAR, or JAR) from code, as well
    as dependencies that can be deployed to multiple environments'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建**：从代码创建可执行包（EAR、WAR 或 JAR），以及可以部署到多个环境的依赖项'
- en: '**Release**: Combines the executable bundle with a specific environment configuration
    to deploy in an environment'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布**：将可执行包与特定环境配置结合起来，在环境中部署'
- en: '**Run**: Runs the app in an execution environment using a specific release'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行**：使用特定发布在执行环境中运行应用程序'
- en: 'The build and release phases are highlighted in the following screenshot:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图突出显示了构建和发布阶段：
- en: '![](img/01ede5e0-7a64-46c7-8474-66b8abc6a0ea.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](img/01ede5e0-7a64-46c7-8474-66b8abc6a0ea.png)'
- en: An antipattern is the building of separate executable bundles specific to each
    environment.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 一个反模式是构建针对每个环境特定的单独可执行包。
- en: Stateless
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无状态
- en: A Twelve-Factor App does not have a state. All the data that it needs is stored
    in a persistent store.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Twelve-Factor 应用程序没有状态。它需要的所有数据都存储在持久存储中。
- en: An antipattern is a sticky session.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 粘性会话是一种反模式。
- en: Port binding
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端口绑定
- en: A Twelve-Factor App exposes all services using port binding. While it is possible
    to have other mechanisms to expose services, these mechanisms are implementation-dependent.
    Port binding gives full control of receiving and handling messages irrespective
    of where an app is deployed.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: Twelve-Factor 应用程序通过端口绑定公开所有服务。虽然可能有其他机制来公开服务，但这些机制是依赖于实现的。端口绑定可以完全控制接收和处理消息，无论应用程序部署在何处。
- en: Concurrency
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发
- en: A Twelve-Factor App is able to achieve more concurrency by scaling out horizontally.
    Scaling vertically has its limits. Scaling out horizontally provides opportunities
    to expand without limits.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 十二要素应用通过水平扩展实现更多的并发。垂直扩展有其限制。水平扩展提供了无限扩展的机会。
- en: Disposability
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可处置性
- en: A Twelve-Factor App should promote elastic scaling. Hence, they should be disposable.
    They can be started and stopped when needed.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 十二要素应用应该促进弹性扩展。因此，它们应该是可处置的。它们可以在需要时启动和停止。
- en: 'A Twelve-Factor App should do the following:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 十二要素应用应该做到以下几点：
- en: Have minimum startup time. A long startup time means a long delay before an
    application can take requests.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有最小的启动时间。长时间的启动意味着应用程序在能够接受请求之前有很长的延迟。
- en: Shut down gracefully.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优雅地关闭。
- en: Handle hardware failures gracefully.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优雅地处理硬件故障。
- en: Environment parity
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境一致性
- en: All the environments--development, test, staging, and production--should be
    similar. They should use the same processes and tools. With continuous deployment,
    they should have very frequently have similar code. This makes finding and fixing
    problems easier.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 所有环境——开发、测试、暂存和生产——应该是相似的。它们应该使用相同的流程和工具。通过持续部署，它们应该非常频繁地具有相似的代码。这使得查找和修复问题更容易。
- en: Logs as event streams
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志作为事件流
- en: Visibility is critical to a Twelve-Factor App. Since applications are deployed
    on the Cloud and are automatically scaled, it is important that you have a centralized
    view of what's happening across different instances of the applications.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 对于十二要素应用来说，可见性至关重要。由于应用部署在云上并且自动扩展，重要的是你能够集中查看应用程序不同实例中发生的情况。
- en: Treating all logs as stream enables the routing of the log stream to different
    destinations for viewing and archival purposes. This stream can be used to debug
    issues, perform analytics, and create alerting systems based on error patterns.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有日志视为流使得可以将日志流路由到不同的目的地以进行查看和存档。这个流可以用于调试问题、执行分析，并基于错误模式创建警报系统。
- en: No distinction of admin processes
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有管理流程的区别
- en: Twelve-Factor Apps treat administrative tasks (migrations, scripts) similar
    to normal application processes.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 十二要素应用将管理任务（迁移、脚本）视为正常应用程序流程的一部分。
- en: Spring projects
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring项目
- en: As the world moves toward Cloud-Native applications and microservices, Spring
    projects are not far behind. There are a number of new Spring projects--Spring
    Boot, Spring Cloud, among others, that solve the problems of the emerging world.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 随着世界朝着云原生应用和微服务迈进，Spring项目也紧随其后。有许多新的Spring项目——Spring Boot、Spring Cloud等，解决了新兴世界的问题。
- en: Spring Boot
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot
- en: In the era of monoliths, we had the luxury of taking the time to set the frameworks
    up for an application. However, in the era of microservices, we want to create
    individual components faster. The Spring Boot project aims to solve this problem.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体架构时代，我们有时间为应用程序设置框架的奢侈。然而，在微服务时代，我们希望更快地创建单独的组件。Spring Boot项目旨在解决这个问题。
- en: As the official website highlights, Spring Boot makes it easy to create standalone,
    production-grade Spring-based applications that you can *just run*. We take an
    opinionated view of the Spring platform and third-party libraries so that you
    can get started with minimum fuss.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 正如官方网站强调的那样，Spring Boot使得创建独立的、生产级别的基于Spring的应用程序变得容易，你可以*直接运行*。我们对Spring平台和第三方库采取了一种有主见的观点，这样你就可以尽量少地开始。
- en: Spring Boot aims to take an opinionated view--basically making a lot of decisions
    for us--to developing Spring-based projects.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot旨在采取一种有主见的观点——基本上为我们做出许多决定——以开发基于Spring的项目。
- en: In the next couple of chapters, we will look at Spring Boot and the different
    features that enable us to create production-ready applications faster.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将看看Spring Boot以及不同的功能，使我们能够更快地创建适用于生产的应用程序。
- en: Spring Cloud
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud
- en: 'Spring Cloud aims to provide solutions to some commonly encountered patterns
    when building systems on the Cloud:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud旨在为在云上构建系统时遇到的一些常见模式提供解决方案：
- en: '**Configuration management**: As we discussed in the Twelve-Factor App section,
    managing configuration is an important part of developing Cloud-Native applications.
    Spring Cloud provides a centralized configuration management solution for microservices
    called Spring Cloud Config.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置管理**：正如我们在十二要素应用部分讨论的那样，管理配置是开发云原生应用的重要部分。Spring Cloud为微服务提供了一个名为Spring
    Cloud Config的集中式配置管理解决方案。'
- en: '**Service discovery**: Service discovery promotes loose coupling between services.
    Spring Cloud provides integration with popular service discovery options, such
    as Eureka, ZooKeeper, and Consul.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务发现**：服务发现促进了服务之间的松耦合。Spring Cloud与流行的服务发现选项（如Eureka、ZooKeeper和Consul）集成。'
- en: '**Circuit breakers**: Cloud-Native applications must be fault tolerant. They
    should be able to handle the failure of backing services gracefully. Circuit breakers
    play a key role in providing the default minimum service in case of failures.
    Spring Cloud provides integration with the Netflix Hystrix fault tolerance library.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断路器**：云原生应用必须具有容错能力。它们应该能够优雅地处理后端服务的故障。断路器在故障时提供默认的最小服务起着关键作用。Spring Cloud与Netflix
    Hystrix容错库集成。'
- en: '**API Gateway**: An API Gateway provides centralized aggregation, routing,
    and caching services. Spring Cloud provides integration with the API Gateway library
    Netflix Zuul.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API网关**：API网关提供集中的聚合、路由和缓存服务。Spring Cloud与API网关库Netflix Zuul集成。'
- en: Summary
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at how the world evolved toward microservices and
    Cloud-Native applications. We understood how Spring Framework and projects are
    evolving to meet the needs of today's world with projects such as Spring Boot,
    Spring Cloud, and Spring Data.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了世界是如何向微服务和云原生应用发展的。我们了解到Spring框架和项目如何发展以满足当今世界的需求，例如Spring Boot、Spring
    Cloud和Spring Data等项目。
- en: In the next chapter, we will start focusing on Spring Boot. We will look at
    how Spring Boot makes developing microservices easy.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始关注Spring Boot。我们将看看Spring Boot如何简化微服务的开发。
- en: The first version of Spring Framework 1.0 was released in March 2004\. For more
    than a decade and a half, Spring Framework remained the framework of choice to
    build Java applications.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架1.0的第一个版本于2004年3月发布。十五年多来，Spring框架一直是构建Java应用程序的首选框架。
- en: In the relatively young and dynamic world of Java frameworks, a decade is a
    long time.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在相对年轻和充满活力的Java框架世界中，十年是很长的时间。
- en: In this chapter, we start with understanding the core features of Spring Framework.
    We will look at why the Spring Framework became popular and how it adapted to
    remain the framework of choice. After taking a quick look at the important modules
    in the Spring Framework, we will jump into the world of Spring Projects. We will
    end the chapter by looking at the new features in Spring Framework 5.0.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始了解Spring框架的核心特性。我们将看看Spring框架为何变得受欢迎以及如何适应保持首选框架。在快速了解Spring框架的重要模块后，我们将进入Spring项目的世界。最后，我们将看看Spring框架5.0中的新功能。
- en: 'This chapter will answer the following questions:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将回答以下问题：
- en: Why is Spring Framework popular?
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring框架为何受欢迎？
- en: How has Spring Framework adapted to the evolution of application architectures?
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring框架如何适应应用架构的演变？
- en: What are the important modules in Spring Framework?
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring框架中的重要模块是什么？
- en: Where does Spring Framework fit in the umbrella of Spring Projects?
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring框架在Spring项目的伞下适用于哪里？
- en: What are the new features in Spring Framework 5.0?
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring框架5.0中的新功能是什么？
- en: Spring Framework
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring框架
- en: 'The Spring website ([https://projects.spring.io/spring-framework/](https://projects.spring.io/spring-framework/))
    defines Spring Framework as follows: *The Spring Framework provides a comprehensive
    programming and configuration model for modern Java-based enterprise applications*.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: Spring网站（[https://projects.spring.io/spring-framework/](https://projects.spring.io/spring-framework/)）将Spring框架定义如下：*Spring框架为现代基于Java的企业应用程序提供了全面的编程和配置模型*。
- en: Spring Framework is used to wire enterprise Java applications. The main aim
    of Spring Framework is to take care of all the technical plumbing that is needed
    in order to connect the different parts of an application. This allows programmers
    to focus on the crux of their jobs--writing business logic.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架用于连接企业Java应用程序。Spring框架的主要目的是处理连接应用程序不同部分所需的所有技术细节。这使程序员能够专注于他们的工作核心--编写业务逻辑。
- en: Problems with EJB
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EJB的问题
- en: Spring Framework was released in March 2004\. When the first version of Spring
    Framework was released, the popular way of developing an enterprise application
    was using **Enterprise Java Beans** (**EJB**) 2.1.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架于2004年3月发布。当Spring框架的第一个版本发布时，开发企业应用程序的流行方式是使用EJB 2.1。
- en: 'Developing and deploying EJBs was a cumbersome process. While EJBs made the
    distribution of components easier, developing, unit testing, and deploying them
    was not easy. The initial versions of EJBs (1.0, 2.0, 2.1) had a complex **Application
    Programmer Interface** (**API**), leading to a perception (and truth in most applications)
    that the complexity introduced far outweighed the benefits:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 开发和部署EJB是一个繁琐的过程。虽然EJB使组件的分发变得更容易，但开发、单元测试和部署它们并不容易。EJB的初始版本（1.0、2.0、2.1）具有复杂的应用程序接口（API），导致人们认为（在大多数应用程序中是真的）引入的复杂性远远超过了好处：
- en: Difficult to unit test. Actually, difficult to test outside the EJB Container.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 难以进行单元测试。实际上，在EJB容器外进行测试很困难。
- en: Multiple interfaces need to be implemented with a number of unnecessary methods.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要实现多个接口，其中包含许多不必要的方法。
- en: Cumbersome and tedious exception handling.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 繁琐和乏味的异常处理。
- en: Inconvenient deployment descriptors.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不方便的部署描述符。
- en: Spring Framework was introduced as a lightweight framework aimed at making developing
    Java EE applications simpler.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架被引入作为一个轻量级框架，旨在简化开发Java EE应用程序。
- en: Why is Spring Framework popular?
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring框架为什么受欢迎？
- en: The first version of Spring Framework was released in March 2004\. In the subsequent
    decade and a half, the use and popularity of Spring Framework only grew.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架的第一个版本于2004年3月发布。在随后的十五年中，Spring框架的使用和受欢迎程度不断增长。
- en: 'The important reasons behind the popularity of Spring Framework are as follows:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架受欢迎的重要原因如下：
- en: Simplified unit testing--because of dependency injection
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化单元测试--由于依赖注入
- en: Reduction in plumbing code
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少了管道代码
- en: Architectural flexibility
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构灵活性
- en: Keeping up with changing times
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟上时代的变化
- en: Let's discuss each of these in detail.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论每一个。
- en: Simplified unit testing
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化单元测试
- en: Earlier versions of EJBs were very difficult to unit test. In fact, it was difficult
    to run EJBs outside the container (as of version 2.1). The only way to test them
    was to deploy them in a container.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 早期版本的EJB非常难以进行单元测试。事实上，很难在容器外运行EJB（截至2.1版本）。测试它们的唯一方法是在容器中部署它们。
- en: Spring Framework brought in the concept of **Dependency Injection** (**DI**).
    We will discuss dependency injection in complete detail in Chapter 2, *Dependency
    Injection*.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架引入了依赖注入的概念。我们将在第2章“依赖注入”中详细讨论依赖注入。
- en: The dependency injection enables unit testing by making it easy to replace the
    dependencies with their mocks. We do not need to deploy the entire application
    to unit test it.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入通过轻松替换依赖项为其模拟使单元测试变得容易。我们不需要部署整个应用程序来进行单元测试。
- en: 'Simplifying unit testing has multiple benefits:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 简化单元测试具有多重好处：
- en: Programmers are more productive
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序员更加高效
- en: Defects are found earlier so they are less costly to fix
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺陷被更早地发现，因此修复成本更低
- en: Applications have automated unit tests, which can run in **Continuous Integration**
    builds, preventing future defects
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序具有自动化单元测试，可以在持续集成构建中运行，以防止未来的缺陷
- en: Reduction in plumbing code
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少管道代码
- en: 'Before Spring Framework, typical J2EE (or Java EE, as it is called now) applications
    contained a lot of plumbing code. For example: getting a database connection,
    exception handling code, transaction management code, logging code, and a lot
    more.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Framework之前，典型的J2EE（或现在称为Java EE）应用程序包含大量的管道代码。例如：获取数据库连接、异常处理代码、事务管理代码、日志记录代码等等。
- en: 'Let''s take a look at a simple example of executing a query using prepared
    statement:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用准备语句执行查询的简单例子：
- en: '[PRE0]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, there are four lines of business logic and more than
    10 lines of plumbing code.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，有四行业务逻辑和超过10行的管道代码。
- en: 'With Spring Framework, the same logic can be applied in a couple of lines:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring Framework，相同的逻辑可以应用在几行代码中：
- en: '[PRE1]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How does Spring Framework do this magic?
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Framework是如何做到这一点的呢？
- en: In the preceding example, Spring JDBC (and Spring, in general) converts most
    checked exceptions into unchecked exceptions. Typically, when a query fails, there
    is not a lot we can do--other than to close the statement and fail the transaction.
    Instead of implementing exception handling in every method, we can have centralized
    exception handling and inject it in using Spring **Aspect-Oriented Programming**
    (**AOP**).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，Spring JDBC（以及Spring总体）将大多数已检查异常转换为未检查异常。通常，当查询失败时，我们除了关闭语句并使事务失败之外，没有太多可以做的事情。我们可以集中处理异常并使用Spring
    **面向切面编程**（**AOP**）进行注入，而不是在每个方法中实现异常处理。
- en: Spring JDBC removes the need to create all the plumbing code involved in getting
    a connection, creating a prepared statement, and so on. The `jdbcTemplate` class
    can be created in the Spring context and injected into the **Data Access Object**
    (**DAO**) class wherever it is needed.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: Spring JDBC消除了创建所有涉及获取连接、创建准备语句等管道代码的需要。`jdbcTemplate`类可以在Spring上下文中创建，并在需要时注入到**数据访问对象**（**DAO**）类中。
- en: Similar to the preceding example, Spring JMS, Spring AOP, and other Spring modules
    help in reducing a lot of plumbing code.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的例子类似，Spring JMS、Spring AOP和其他Spring模块有助于减少大量的管道代码。
- en: Spring Framework lets the programmer focus on the primary job of a programmer--
    writing business logic.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Framework让程序员专注于程序员的主要工作--编写业务逻辑。
- en: Avoiding all the plumbing code also has another great benefit--reduced duplication
    in code. Since all code for transaction management, exception handling, and so
    on (typically, all your cross-cutting concerns) is implemented at one place, it
    is easier to maintain.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 避免所有管道代码还有另一个很大的好处--减少代码重复。由于所有事务管理、异常处理等代码（通常是所有横切关注点）都在一个地方实现，因此更容易维护。
- en: Architectural flexibility
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构灵活性
- en: Spring Framework is modular. It is built as a set of independent modules built
    on top of the core Spring modules. Most of the Spring modules are independent--you
    can use one of them without having to use others.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Framework是模块化的。它是建立在核心Spring模块之上的一组独立模块。大多数Spring模块都是独立的--您可以使用其中一个而不必使用其他模块。
- en: 'Let''s look at a few examples:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看几个例子：
- en: In the web layer, Spring offers a framework of its own--Spring MVC. However,
    Spring has great support for Struts, Vaadin, JSF, or any web framework of your
    choice.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Web层，Spring提供了自己的框架--Spring MVC。但是，Spring对Struts、Vaadin、JSF或您选择的任何Web框架都有很好的支持。
- en: Spring Beans can provide lightweight implementation for your business logic.
    However, Spring can be integrated with EJBs as well.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Beans可以为您的业务逻辑提供轻量级实现。但是，Spring也可以与EJB集成。
- en: In the data layer, Spring simplifies JDBC with its Spring JDBC module. However,
    Spring has great support for any of your preferred data layer frameworks--JPA,
    Hibernate (with or without JPA), or iBatis.
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据层，Spring通过其Spring JDBC模块简化了JDBC。但是，Spring对您喜欢的任何数据层框架--JPA、Hibernate（带有或不带有JPA）或iBatis都有很好的支持。
- en: You have the option of implementing your cross-cutting concerns (logging, transaction
    management, security, and so on) with Spring AOP. Or, you can integrate with a
    fully fledged AOP implementation such as AspectJ.
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以选择使用Spring AOP实现横切关注点（日志记录、事务管理、安全等）。或者，您可以集成一个完整的AOP实现，比如AspectJ。
- en: Spring Framework does not want to be the jack-of-all-trades. While focusing
    on its core job of reducing coupling between different parts of the application
    and making them testable, Spring provides great integration with frameworks of
    your choice. This means you have flexibility in your architecture--if you do not
    want to use a specific framework, you can easily replace it with another.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Framework不想成为万能工具。在专注于减少应用程序不同部分之间的耦合并使它们可测试的核心工作的同时，Spring与您选择的框架进行了很好的集成。这意味着您在架构上有灵活性--如果您不想使用特定的框架，可以轻松地用另一个替换它。
- en: Keep up with changing times
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟上时代的变化
- en: 'The first version of Spring Framework focused on making applications testable.
    However, as time moved on, there were new challenges. Spring Framework managed
    to evolve and stay ahead of the curve with the flexibility and modules that are
    offered. A couple of examples are listed as follows:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Framework的第一个版本专注于使应用程序可测试。然而，随着时间的推移，出现了新的挑战。Spring Framework设法通过提供的灵活性和模块来不断发展并保持领先地位。以下列举了一些例子：
- en: Annotations were introduced in Java 5\. Spring Framework (version 2.5 – Nov
    2007) was ahead of Java EE in introducing an annotation-based controller model
    for Spring MVC. Developers using Java EE had to wait until Java EE 6 (Dec 2009
    – 2 years) before having comparable functionality.
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注解是在Java 5中引入的。Spring Framework（版本2.5 - 2007年11月）在引入基于注解的Spring MVC控制器模型方面领先于Java
    EE。使用Java EE的开发人员必须等到Java EE 6（2009年12月 - 2年后）才能获得可比较的功能。
- en: Spring Framework introduced a number of abstractions ahead of Java EE to keep
    the application decoupled from specific implementation. Caching API provides a
    case in point. Spring provided a transparent caching support in Spring 3.1\. Java
    EE came up with *JSR-107* for JCache (in 2014)--support for which was provided
    in Spring 4.1.
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Framework在Java EE之前引入了许多抽象概念，以使应用程序与特定实现解耦。 缓存API就是一个例子。 Spring在Spring
    3.1中提供了透明的缓存支持。 Java EE推出了*JSR-107*用于JCache（2014年）--Spring 4.1提供了对其的支持。
- en: 'Another important thing Spring brings in is the umbrella of Spring Projects.
    Spring Framework is just one of the many projects under Spring Projects. We will
    discuss the different Spring Projects in a separate section. The following examples
    illustrate how Spring managed to stay ahead of times with new Spring Projects:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: Spring带来的另一个重要事项是Spring项目的总称。 Spring Framework只是Spring项目下的众多项目之一。 我们将在单独的部分讨论不同的Spring项目。
    以下示例说明了Spring如何通过新的Spring项目保持领先地位：
- en: '**Spring Batch** defines a new approach to building Java Batch applications.
    We had to wait until Java EE 7 (June 2013) to have comparable batch application
    specification in Java EE.'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring Batch**定义了构建Java批处理应用程序的新方法。 我们不得不等到Java EE 7（2013年6月）才有了Java EE中可比的批处理应用程序规范。'
- en: As architecture evolved toward Cloud and microservices, Spring came up with
    new Cloud-oriented Spring Projects. Spring Cloud helps in simplifying the development
    and deployment of microservices. Spring Cloud Data Flow provides orchestrations
    around microservice applications.
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着架构向云和微服务发展，Spring推出了新的面向云的Spring项目。 Spring Cloud有助于简化微服务的开发和部署。 Spring Cloud
    Data Flow提供了围绕微服务应用程序的编排。
- en: Spring modules
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring模块
- en: The modularity of Spring Framework is one of the most important reasons for
    its widespread used. Spring Framework is highly modular with more than 20 different
    modules--having clearly defined boundaries.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Framework的模块化是其广泛使用的最重要原因之一。 Spring Framework非常模块化，有20多个不同的模块--具有明确定义的边界。
- en: 'The following figure shows different Spring modules--organized by the layer
    of application they are typically used in:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了不同的Spring模块--按照它们通常在应用程序中使用的层进行组织：
- en: '![](img/05c2894a-a465-4c3a-88f4-ad2a4931bab7.png)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
  zh: '![](img/05c2894a-a465-4c3a-88f4-ad2a4931bab7.png)'
- en: We will start with discussing the Spring Core Container before moving on to
    other modules grouped by the application layer they are typically used in.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从讨论Spring核心容器开始，然后再讨论其他模块，这些模块按照它们通常在应用程序层中使用的方式进行分组。
- en: Spring Core Container
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring核心容器
- en: Spring Core Container provides the core features of Spring Framework--dependency
    injection, **IoC** (**Inversion of Control**) container, and the application context.
    We will learn more about DI and IoC Container in Chapter 2, *Dependency Injection*.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Core Container提供了Spring Framework的核心功能--依赖注入，**IoC**（控制反转）容器和应用程序上下文。
    我们将在第2章“依赖注入”中更多地了解DI和IoC容器。
- en: 'Important core Spring modules are listed in the following table:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的核心Spring模块列在以下表中：
- en: '| **Module/Artifact** | **Use** |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '| **模块/构件** | **用途** |'
- en: '| spring-core | Utilities used by other Spring modules. |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '| spring-core | 其他Spring模块使用的实用程序。 |'
- en: '| spring-beans | Support for Spring beans. In combination with spring-core
    provides the core feature of Spring Framework--dependency injection. Includes
    implementation of BeanFactory. |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '| spring-beans | 支持Spring beans。 与spring-core结合使用，提供了Spring Framework的核心功能--依赖注入。
    包括BeanFactory的实现。 |'
- en: '| spring-context | Implements ApplicationContext, which extends BeanFactory
    and provides support to load resources and internationalization, among others.
    |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '| spring-context | 实现了ApplicationContext，它扩展了BeanFactory，并提供了加载资源和国际化等支持。 |'
- en: '| spring-expression | Extends **EL** (**Expression Language** from JSP) and
    provides a language for bean property (including arrays and collections) access
    and manipulations. |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '| spring-expression | 扩展了JSP的**EL**（表达式语言）并提供了一种用于访问和操作bean属性（包括数组和集合）的语言。
    |'
- en: Cross-cutting concerns
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 横切关注点
- en: Cross-cutting concerns are applicable to all application layers--logging and
    security, among others. **AOP** is typically used to implement cross-cutting concerns.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 横切关注点适用于所有应用程序层--包括日志记录和安全性等。 **AOP**通常用于实现横切关注点。
- en: Unit tests and integration tests fit this category since they are applicable
    to all layers.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试和集成测试属于这个类别，因为它们适用于所有层。
- en: 'Important Spring modules related to cross-cutting concerns are listed as follows:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 与横切关注点相关的重要Spring模块列在以下表中：
- en: '| **Module/Artifact** | **Use** |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '| **模块/构件** | **用途** |'
- en: '| spring-aop | Provides basic support for Aspect-Oriented Programming--with
    method interceptors and pointcuts. |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '| spring-aop | 提供面向方面的编程的基本支持--具有方法拦截器和切入点。 |'
- en: '| spring-aspects | Provides integration with the most popular and fully featured
    AOP framework, AspectJ. |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '| spring-aspects | 提供与最受欢迎和功能齐全的AOP框架AspectJ的集成。 |'
- en: '| spring-instrument | Provides basic instrumentation support. |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '| spring-instrument | 提供基本的仪器支持。 |'
- en: '| spring-test | Provides basic support for unit testing and integration testing.
    |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '| spring-test | 提供基本的单元测试和集成测试支持。 |'
- en: Web
  id: totrans-448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web
- en: Spring provides its own MVC framework, Spring MVC, other than providing great
    integration with popular web frameworks such as Struts.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: Spring除了与流行的Web框架（如Struts）提供良好的集成外，还提供了自己的MVC框架Spring MVC。
- en: 'Important artifacts/modules are listed as follows:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的构件/模块列在以下表中：
- en: '**spring-web**: Provides basic web features, such as multi-part file upload.
    Provides support for integration with other web frameworks, such as Struts.'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**spring-web**: 提供基本的网络功能，如多部分文件上传。 提供与其他Web框架（如Struts）集成的支持。'
- en: '**spring-webmvc**: Provides a fully featured web MVC framework--Spring MVC,
    which includes features to implement REST services as well.'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**spring-webmvc**: 提供了一个功能齐全的Web MVC框架--Spring MVC，其中包括实现REST服务的功能。'
- en: We will cover Spring MVC and develop web applicaitions and rest services with
    it in Chapter 3, *Building Web Application with Spring MVC* and Chapter 5, *Building
    Microservices with Spring Boot.*
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第3章*使用Spring MVC构建Web应用程序*和第5章*使用Spring Boot构建微服务*中介绍Spring MVC并开发Web应用程序和REST服务。
- en: Business
  id: totrans-454
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 业务
- en: The business layer is focused on executing the business logic of the applications.
    With Spring, business logic is typically implemented in **Plain Old Java Object**
    (**POJO**).
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 业务层专注于执行应用程序的业务逻辑。使用Spring，业务逻辑通常在**普通的旧Java对象**（**POJO**）中实现。
- en: '**Spring Transactions** (**spring-tx**) provides declarative transaction management
    for POJO and other classes.'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring Transactions** (**spring-tx**)为POJO和其他类提供声明式事务管理。'
- en: Data
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据
- en: The data layer in applications typically talks to the database and/or the external
    interfaces.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中的数据层通常与数据库和/或外部接口通信。
- en: 'Some of the important Spring modules related to the data layer are listed in
    the following table:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与数据层相关的一些重要的Spring模块：
- en: '| **Module/Artifact** | **Use** |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| **模块/构件** | **用途** |'
- en: '| --- | --- |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| spring-jdbc | Provides abstraction around JDBC to avoid boilerplate code.
    |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| spring-jdbc | 提供对JDBC的抽象，避免样板代码。'
- en: '| spring-orm | Provides integration with ORM frameworks and specifications--
    JPA and Hibernate, among others. |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '| spring-orm | 与ORM框架和规范集成--包括JPA和Hibernate等。'
- en: '| spring-oxm | Provides an object to XML mapping integration. Supports frameworks
    such as JAXB, Castor, and so on. |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '| spring-oxm | 提供对象到XML映射集成。支持诸如JAXB、Castor等框架。'
- en: '| spring-jms | Provides abstraction around JMS to avoid boilerplate code. |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '| spring-jms | 提供对JMS的抽象，避免样板代码。'
- en: Spring Projects
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring项目
- en: While Spring Framework provides the base for core features of enterprise applications
    (DI, web, data), other Spring Projects explore integration and solutions to other
    problems in the enterprise space--deployment, Cloud, Big Data, Batch and Security,
    among others.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Spring框架为企业应用程序的核心功能（DI、Web、数据）提供了基础，但其他Spring项目探索了企业领域的集成和解决其他问题的解决方案--部署、云端、大数据、批处理和安全等。
- en: 'Some of the important Spring Projects are listed as follows:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些重要的Spring项目：
- en: Spring Boot
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot
- en: Spring Cloud
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud
- en: Spring Data
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data
- en: Spring Batch
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Batch
- en: Spring Security
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Security
- en: Spring HATEOAS
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring HATEOAS
- en: Spring Boot
  id: totrans-475
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot
- en: 'Some of the challenges while developing microservices and web applications
    are as follows:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发微服务和Web应用程序时遇到的一些挑战如下：
- en: Making framework choices and deciding compatible framework versions
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 做框架选择和决定兼容的框架版本
- en: Providing mechanisms for externalizing configuration--properties that can change
    from one environment to another
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供外部化配置的机制--可以从一个环境更改为另一个环境的属性
- en: Health checks and monitoring--providing alerts if a specific part of the application
    is down
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 健康检查和监控--如果应用程序的特定部分宕机，则提供警报
- en: Deciding the deployment environment and configuring the application for it
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定部署环境并为其配置应用程序
- en: Spring Boot solves all these problems out of the box by taking an *opinionated
    view* of how applications have to be developed.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot通过采取*主观的观点*来解决所有这些问题。
- en: We will look at Spring Boot in depth in two chapters--Chapter 5, *Building Microservices
    with Spring Boot* and [Chapter 7](c46a5b67-c5be-49c0-af8e-b0c4713f890b.xhtml),
    *Advanced Spring Boot Features*.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在两章中深入研究Spring Boot--第5章，*使用Spring Boot构建微服务*和[第7章](c46a5b67-c5be-49c0-af8e-b0c4713f890b.xhtml)，*高级Spring
    Boot功能*。
- en: Spring Cloud
  id: totrans-483
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud
- en: It is not an exaggeration to say *The world is moving to the Cloud*.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 可以毫不夸张地说*世界正在向云端迁移*。
- en: Cloud Native microservices and applications are the order of the day. We will
    discuss this in detail in Chapter 4, *Evolution toward Microservices and Cloud-Native
    Applications*.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生微服务和应用程序是当今的趋势。我们将在第4章*向微服务和云原生应用程序的演变*中详细讨论这一点。
- en: Spring is taking rapid strides toward making application development for the
    Cloud simpler with Spring Cloud.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: Spring正在快速迈向使云端应用程序开发更简单的方向。
- en: 'Spring Cloud provides solutions for common patterns in distributed systems.
    Spring Cloud enables developers to quickly create applications that implement
    common patterns. Some of the common patterns implemented in Spring Cloud are listed
    as follows:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud为分布式系统中的常见模式提供解决方案。Spring Cloud使开发人员能够快速创建实现常见模式的应用程序。Spring Cloud中实现的一些常见模式如下所示：
- en: Configuration management
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置管理
- en: Service discovery
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现
- en: Circuit breakers
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断路器
- en: Intelligent routing
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能路由
- en: We will discuss Spring Cloud and its varied range features in more detail in
    [Chapter 9](9d263fde-d65c-4222-8da9-b360de7ccc12.xhtml), *Spring Cloud.*
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第9章](9d263fde-d65c-4222-8da9-b360de7ccc12.xhtml)中更详细地讨论Spring Cloud及其各种功能，*Spring
    Cloud*。
- en: Spring Data
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Data
- en: There are multiple sources of data in today's world--SQL (relational) and a
    variety of NOSQL databases. Spring Data tries to provide a consistent data-access
    approach to all these different kinds of databases.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 当今世界有多个数据来源--SQL（关系型）和各种NOSQL数据库。Spring Data试图为所有这些不同类型的数据库提供一致的数据访问方法。
- en: 'Spring Data provides integration with a varied range of specifications and/or
    data stores:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data提供与各种规范和/或数据存储的集成：
- en: JPA
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JPA
- en: MongoDB
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB
- en: Redis
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redis
- en: Solr
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Solr
- en: Gemfire
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gemfire
- en: Apache Cassandra
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache Cassandra
- en: 'Some of the important features are listed as follows:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些重要特性：
- en: Provides abstractions around repository and object mappings--by determining
    queries from method names
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过从方法名称确定查询来提供对存储库和对象映射的抽象
- en: Simple Spring integration
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的Spring集成
- en: Integration with Spring MVC controllers
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Spring MVC控制器集成
- en: Advanced automatic auditing features--created by, created date, last changed
    by, and last changed date
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级自动审计功能--创建者、创建日期、最后更改者和最后更改日期
- en: We will discuss Spring Data in more detail in [Chapter 8](b134d136-6980-440f-980c-227e8a46e532.xhtml),
    *Spring Data*.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第8章](b134d136-6980-440f-980c-227e8a46e532.xhtml)中更详细地讨论Spring Data，*Spring
    Data*。
- en: Spring Batch
  id: totrans-508
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Batch
- en: Enterprise applications today process large volumes of data using batch programs.
    The needs of these applications are very similar. Spring Batch provides solutions
    for high- volume batch programs with high performance requirements.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的企业应用程序使用批处理程序处理大量数据。这些应用程序的需求非常相似。Spring Batch为具有高性能要求的高容量批处理程序提供解决方案。
- en: 'Important features in Spring Batch are as follows:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Batch中的重要功能如下：
- en: The ability to start, stop, and restart jobs--including the ability to restart
    failed jobs from the point where they failed
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动、停止和重新启动作业的能力，包括重新启动失败的作业从失败的地方重新开始
- en: The ability to process data in chunks
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理数据的能力
- en: The ability to retry steps or to skip steps on failure
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重试步骤或在失败时跳过步骤的能力
- en: Web-based administration interface
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Web的管理界面
- en: Spring Security
  id: totrans-515
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security
- en: '**Authentication** is the process of identifying the user. **Authorization**
    is the process of ensuring that a user has access to perform the identified action
    on the resource.'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '**身份验证**是识别用户的过程。**授权**是确保用户有权访问资源执行已识别的操作的过程。'
- en: Authentication and authorization are critical parts of Enterprise applications,
    both web applications and web services. Spring Security provides declarative authentication
    and authorization for Java based applications.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证和授权是企业应用程序的关键部分，包括Web应用程序和Web服务。Spring Security为基于Java的应用程序提供声明性身份验证和授权。
- en: 'Important features in Spring Security are as follows:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security中的重要功能如下：
- en: Simplified authentication and authorization
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化的身份验证和授权
- en: Great integration with Spring MVC and Servlet APIs
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Spring MVC和Servlet API的良好集成
- en: Support to prevent common security attacks--**cross-site forgery request** (**CSRF**)
    and Session Fixation
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持防止常见的安全攻击--**跨站请求伪造**（**CSRF**）和会话固定
- en: Modules available for integration with SAML and LDAP
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用于与SAML和LDAP集成的模块
- en: We will discuss how to secure web applications with Spring Security in Chapter
    3, *Building Web Application with Spring MVC*.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第3章中讨论如何使用Spring Security保护Web应用程序，*使用Spring MVC构建Web应用程序*。
- en: We will discuss how to secure REST Services with Basic and OAuth authentication
    mechanisms using Spring Security in [Chapter 6](09291379-92b0-4d7d-bff7-d77e089f33db.xhtml),
    *Extending Microservices*.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在《第6章》中讨论如何使用Spring Security来保护基本和OAuth身份验证机制的REST服务，*扩展微服务*。
- en: Spring HATEOAS
  id: totrans-525
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring HATEOAS
- en: '**HATEOAS** stands for **Hypermedia as The Engine of Application State**. Though
    it sounds complex, it is quite a simple concept. Its main aim is to decouple the
    server (the provider of the service) from the client (the consumer of the service).'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '**HATEOAS**代表**超媒体作为应用程序状态的引擎**。尽管听起来很复杂，但它是一个非常简单的概念。它的主要目的是将服务器（服务提供者）与客户端（服务消费者）解耦。'
- en: The service provider provides the service consumer with information about what
    other actions can be performed on the resource.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 服务提供者向服务消费者提供有关资源上可以执行的其他操作的信息。
- en: Spring HATEOAS provides a HATEOAS implementation--especially for the REST services
    implemented with Spring MVC.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: Spring HATEOAS提供了HATEOAS实现，特别是针对使用Spring MVC实现的REST服务。
- en: 'Important features in Spring HATEOAS are as follows:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: Spring HATEOAS中的重要功能如下：
- en: Simplified definition of links pointing to service methods, making the links
    less fragile
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化指向服务方法的链接的定义，使链接更加稳固
- en: Support for JAXB (XML-based) and JSON integration
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持JAXB（基于XML）和JSON集成
- en: Support for service consumer (client side)
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对服务消费者（客户端）的支持
- en: We will discuss how to use HATEOAS in [Chapter 6](09291379-92b0-4d7d-bff7-d77e089f33db.xhtml),
    *Extending Microservices*.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在《第6章》中讨论如何使用HATEOAS，*扩展微服务*。
- en: New features in Spring Framework 5.0
  id: totrans-534
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Framework 5.0中的新功能
- en: Spring Framework 5.0 is the first major upgrade in Spring Framework, almost
    four years after Spring Framework 4.0\. In this time frame, one of the major developments
    has been the evolution of the Spring Boot project. We will discuss the new features
    in Spring Boot 2.0 in the next section.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Framework 5.0是Spring Framework的首次重大升级，距离Spring Framework 4.0已经有将近四年的时间。在这段时间内，Spring
    Boot项目的主要发展之一就是Spring Boot项目的发展。我们将在下一节中讨论Spring Boot 2.0中的新功能。
- en: 'One of the biggest features of Spring Framework 5.0 is **Reactive Programming**.
    Core reactive programming features and support for reactive endpoints are available
    out of the box with Spring Framework 5.0\. The list of important changes includes
    the following:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Framework 5.0最大的特性之一是**响应式编程**。Spring Framework 5.0具有核心响应式编程功能，并且支持响应式端点。重要变化的列表包括以下内容：
- en: Baseline upgrades
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基线升级
- en: JDK 9 runtime compatibility
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK 9运行时兼容性
- en: Usage of JDK 8 features in the Spring Framework code
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Spring Framework代码中使用JDK 8功能
- en: Reactive programming support
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式编程支持
- en: A functional web framework
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能性的Web框架
- en: Java modularity with Jigsaw
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jigsaw中的Java模块化
- en: Kotlin support
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin支持
- en: Dropped features
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除的功能
- en: Baseline upgrades
  id: totrans-545
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基线升级
- en: Spring Framework 5.0 has JDK 8 and Java EE 7 baseline. Basically, it means that
    previous JDK and Java EE versions are not supported anymore.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Framework 5.0具有JDK 8和Java EE 7基线。基本上，这意味着不再支持以前的JDK和Java EE版本。
- en: 'Some of the important baseline Java EE 7 specifications for Spring Framework
    5.0 are listed as follows:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Framework 5.0的一些重要基线Java EE 7规范如下所示：
- en: Servlet 3.1
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Servlet 3.1
- en: JMS 2.0
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JMS 2.0
- en: JPA 2.1
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JPA 2.1
- en: JAX-RS 2.0
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JAX-RS 2.0
- en: Bean Validation 1.1
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bean Validation 1.1
- en: 'There are many changes to the minimum supported versions of several Java frameworks.
    The following list contains some of the minimum supported versions of prominent
    frameworks:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Java框架的最低支持版本发生了许多变化。以下列表包含一些知名框架的最低支持版本：
- en: Hibernate 5
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hibernate 5
- en: Jackson 2.6
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jackson 2.6
- en: EhCache 2.10
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EhCache 2.10
- en: JUnit 5
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JUnit 5
- en: Tiles 3
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tiles 3
- en: 'The following list shows the supported server versions:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了支持的服务器版本：
- en: Tomcat 8.5+
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tomcat 8.5+
- en: Jetty 9.4+
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jetty 9.4+
- en: WildFly 10+
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WildFly 10+
- en: Netty 4.1+ (for web reactive programming with Spring Web Flux)
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Netty 4.1+（用于使用Spring Web Flux进行Web响应式编程）
- en: Undertow 1.4+ (for web reactive programming with Spring Web Flux)
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Undertow 1.4+（用于使用Spring Web Flux进行Web响应式编程）
- en: Applications using earlier versions of any of the preceding specifications/frameworks
    need to be upgraded at least to the previously listed versions before they can
    use Spring Framework 5.0.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前版本的任何上述规范/框架的应用程序在使用Spring Framework 5.0之前，至少需要升级到前面列出的版本。
- en: JDK 9 runtime compatibility
  id: totrans-566
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JDK 9运行时兼容性
- en: JDK 9 is expected to be released mid-2017\. Spring Framework 5.0 is expected
    to have runtime compatibility with JDK 9.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 预计JDK 9将于2017年中期发布。Spring Framework 5.0预计将与JDK 9具有运行时兼容性。
- en: Usage of JDK 8 features in Spring Framework code
  id: totrans-568
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Spring Framework代码中使用JDK 8的特性
- en: The Spring Framework 4.x baseline version is Java SE 6\. This means that it
    supports Java 6, 7, and 8\. Having to support Java SE 6 and 7 puts constraints
    on the Spring Framework code. The framework code cannot use any of the new features
    in Java 8\. So, while the rest of the world upgraded to Java 8, the code in Spring
    Framework (at least the major parts) was restricted to using earlier versions
    of Java.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Framework 4.x的基线版本是Java SE 6。这意味着它支持Java 6、7和8。必须支持Java SE 6和7会对Spring
    Framework代码造成限制。框架代码不能使用Java 8的任何新功能。因此，尽管世界其他地方升级到了Java 8，Spring Framework中的代码（至少是主要部分）仍受限于使用较早版本的Java。
- en: 'With Spring Framework 5.0, the baseline version is Java 8\. Spring Framework
    code is now upgraded to use the new features in Java 8\. This will result in more
    readable and performant framework code. Some of the Java 8 features used are as
    follows:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Framework 5.0中，基线版本是Java 8。Spring Framework代码现在已升级以使用Java 8的新功能。这将导致更易读和更高性能的框架代码。其中使用的一些Java
    8特性如下：
- en: Java 8 default methods in core Spring interfaces
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心Spring接口中的Java 8默认方法
- en: Internal code improvements based on Java 8 reflection enhancements
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Java 8反射增强的内部代码改进
- en: Use of functional programming in the framework code--lambdas and streams
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在框架代码中使用函数式编程--lambda和streams
- en: Reactive programming support
  id: totrans-574
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式编程支持
- en: Reactive programming is one of the most important features of Spring Framework
    5.0.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程是Spring Framework 5.0最重要的特性之一。
- en: Microservices architectures are typically built around event-based communication.
    Applications are built to react to events (or messages).
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构通常建立在基于事件的通信之上。应用程序被构建为对事件（或消息）做出反应。
- en: Reactive programming provides an alternate style of programming focused on building
    applications that react to events.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程提供了一种专注于构建对事件做出反应的应用程序的替代编程风格。
- en: 'While Java 8 does not have built-in suppport for reactive programming, there
    are a number of frameworks that provide support for reactive programming:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Java 8没有内置对响应式编程的支持，但有许多框架提供了对响应式编程的支持：
- en: '**Reactive Streams**: Language-neutral attempt to define reactive APIs.'
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Reactive Streams**：语言中立的尝试定义响应式API。'
- en: '**Reactor**: Java implementation of Reactive Streams provided by the Spring
    Pivotal team.'
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Reactor**：由Spring Pivotal团队提供的Reactive Streams的Java实现。'
- en: '**Spring WebFlux**: Enables the development of web applications based on reactive
    programming. Provides a programming model similar to Spring MVC.'
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring WebFlux**：支持基于响应式编程的Web应用程序开发。提供类似于Spring MVC的编程模型。'
- en: We will discuss Reactive Programming and how you can implement it with Spring
    Web Flux in [Chapter 11](116716f1-7046-4aaa-b89b-9794b6079880.xhtml), *Reactive
    Programming*.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第11章](116716f1-7046-4aaa-b89b-9794b6079880.xhtml)中讨论响应式编程以及如何在Spring Web
    Flux中实现它，*响应式编程*。
- en: Functional web framework
  id: totrans-583
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能性Web框架
- en: Building on top of the reactive features, Spring 5 also provides a functional
    web framework.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 基于响应式特性，Spring 5还提供了一个功能性的Web框架。
- en: 'A functional web framework provides features to define endpoints using functional
    programming style. A simple hello world example is shown here:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 功能性Web框架提供了使用函数式编程风格定义端点的功能。下面是一个简单的hello world示例：
- en: '[PRE2]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A functional web framework can also be used to define more complex routes,
    as shown in the following example:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 功能性Web框架还可以用于定义更复杂的路由，如下面的示例所示：
- en: '[PRE3]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A couple of important things to note are as follows:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一些重要事项如下：
- en: '`RouterFunction` evaluates the matching condition to route requests to the
    appropriate handler function'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RouterFunction`评估匹配条件以将请求路由到适当的处理程序函数'
- en: We are defining three endpoints, two GETs, and one POST, and mapping them to
    different handler functions
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在定义三个端点，两个GET和一个POST，并将它们映射到不同的处理程序函数
- en: We will discuss Mono and Flux in more detail in [Chapter 11](116716f1-7046-4aaa-b89b-9794b6079880.xhtml),
    *Reactive Programming.*
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第11章](116716f1-7046-4aaa-b89b-9794b6079880.xhtml)中更详细地讨论Mono和Flux，*响应式编程*。
- en: Java modularity with Jigsaw
  id: totrans-593
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jigsaw的Java模块化
- en: 'Until Java 8, the Java platform was not modular. A couple of important problems
    resulted out of this:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 直到Java 8，Java平台并不是模块化的。由此产生了一些重要问题：
- en: '**Platform Bloat**: Java modularity has not been a cause of concern in the
    last couple of decades. However, with **Internet of Things** (**IOT**) and new
    lightweight platforms such as Node.js, there is an urgent need to address the
    bloat of the Java platform. (Initial versions of JDK were less than 10 MB in size.
    Recent versions of JDK need more than 200 MB.)'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台膨胀**：在过去的几十年里，Java模块化并不是一个令人担忧的问题。然而，随着**物联网**（**IOT**）和新的轻量级平台如Node.js的出现，迫切需要解决Java平台的膨胀问题。（JDK的初始版本小于10MB。最近的JDK版本需要超过200MB。）'
- en: '**JAR Hell**: Another important concern is the problem of JAR Hell. When Java
    ClassLoader finds a class, it will not see whether there are other definitions
    for the class available. It immediately loads the first class that is found. If
    two different parts of the application need the same class from different jars,
    there is no way for them to specify the jar from which the class has to be loaded.'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JAR地狱**：另一个重要问题是JAR地狱的问题。当Java ClassLoader找到一个类时，它不会查看是否有其他可用的类定义。它会立即加载找到的第一个类。如果应用程序的两个不同部分需要来自不同JAR的相同类，它们无法指定要从哪个JAR加载类。'
- en: '**Open System Gateway initiative** (**OSGi**) is one of the initiatives, started
    way back in 1999, to bring modularity into Java applications.'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放系统网关倡议**（OSGi）是 1999 年开始的倡议之一，旨在为 Java 应用程序带来模块化。'
- en: 'Each module (referred to as bundle) defines the following:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块（称为捆绑包）定义如下：
- en: '**imports**: Other bundles that the module uses'
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导入**：模块使用的其他捆绑包'
- en: '**exports**: Packages that this bundle exports'
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导出**：此捆绑包导出的包'
- en: Each module can have its own life cycle. It can be installed, started, and stopped
    on its own.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块都可以有自己的生命周期。它可以独立安装、启动和停止。
- en: 'Jigsaw is an initiative under **Java Community Process** (**JCP**), started
    with Java 7, to bring modularity into Java. It has two main aims:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: Jigsaw 是 Java 社区进程（JCP）的一个倡议，从 Java 7 开始，旨在为 Java 带来模块化。它有两个主要目标：
- en: Defining and implementing a modular structure for JDK
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 JDK 定义和实现模块化结构
- en: Defining a module system for applications built on the Java platform
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为构建在 Java 平台上的应用程序定义模块系统
- en: Jigsaw is expected to be part of Java 9 and Spring Framework 5.0 is expected
    to include basic support for Jigsaw modules.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: Jigsaw 预计将成为 Java 9 的一部分，Spring Framework 5.0 预计将包括对 Jigsaw 模块的基本支持。
- en: Kotlin support
  id: totrans-606
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin 支持
- en: Kotlin is a statically typed JVM language that enables code that is expressive,
    short, and readable. Spring framework 5.0 has good support for Kotlin.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 是一种静态类型的 JVM 语言，可以编写富有表现力、简短和可读的代码。Spring Framework 5.0 对 Kotlin 有很好的支持。
- en: 'Consider a simple Kotlin program illustrating a data class, as shown here:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个简单的 Kotlin 程序，演示一个数据类，如下所示：
- en: '[PRE4]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In fewer than 10 lines of code, we created and tested a data bean with three
    properties and the following functions:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 在不到 10 行代码的情况下，我们创建并测试了一个具有三个属性和以下函数的数据 bean：
- en: '`equals()`'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equals()`'
- en: '`hashCode()`'
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hashCode()`'
- en: '`toString()`'
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toString()`'
- en: '`copy()`'
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`copy()`'
- en: 'Kotlin is strongly typed. But there is no need to specify the type of each
    variable explicitly:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 是强类型的。但是不需要明确指定每个变量的类型：
- en: '[PRE5]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Named arguments allow you to specify the names of arguments when calling methods,
    resulting in more readable code:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 命名参数允许您在调用方法时指定参数的名称，从而使代码更易读：
- en: '[PRE6]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Kotlin makes functional programming simpler by providing default variables
    (`it`) and methods such as `take`, `drop`, and so on:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 通过提供默认变量（`it`）和诸如 `take`、`drop` 等方法，使函数式编程更简单：
- en: '[PRE7]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can also specify default values for arguments in Kotlin:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在 Kotlin 中为参数指定默认值：
- en: '[PRE8]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With all its features making the code concise and expressive, we expect Kotlin
    to be a language to be learned for the .
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 凭借其简洁和表达力的特点，我们期望 Kotlin 成为一个需要学习的语言。
- en: We will discuss more about Kotlin in [Chapter 13](116716f1-7046-4aaa-b89b-9794b6079880.xhtml),
    *Working with Kotlin in Spring.*
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 13 章《在 Spring 中使用 Kotlin》中更多地讨论 Kotlin。
- en: Dropped features
  id: totrans-625
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 已删除的功能
- en: 'Spring Framework 5 is a major Spring release with substantial increase in the
    baselines. Along with the increase in baseline versions for Java, Java EE and
    a few other frameworks, Spring Framework 5 removed support for a few frameworks:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Framework 5 是一个重要的 Spring 发布版本，基线版本大幅增加。随着 Java、Java EE 和其他一些框架的基线版本增加，Spring
    Framework 5 移除了对一些框架的支持：
- en: Portlet
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Portlet
- en: Velocity
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Velocity
- en: JasperReports
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JasperReports
- en: XMLBeans
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XMLBeans
- en: JDO
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDO
- en: Guava
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Guava
- en: If you are using any of the preceding frameworks, it is recommended that you
    plan a migration and stay with Spring Framework 4.3--which has support until 2019.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用了上述任何框架，建议您计划迁移并继续使用支持到 2019 年的 Spring Framework 4.3。
- en: Spring Boot 2.0 new features
  id: totrans-634
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot 2.0 新功能
- en: 'The first version of Spring Boot was released in 2014\. The following are some
    of the important updates expected in Spring Boot 2.0:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 的第一个版本于 2014 年发布。以下是 Spring Boot 2.0 中预期的一些重要更新：
- en: The baseline JDK version is Java 8
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基线 JDK 版本是 Java 8
- en: The baseline Spring Version is Spring Framework 5.0
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基线 Spring 版本是 Spring Framework 5.0
- en: Spring Boot 2.0 has support for Reactive Web programming with WebFlux
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot 2.0 具有对 WebFlux 的响应式 Web 编程的支持
- en: 'Minimum supported versions of some important frameworks are listed as follows:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 一些重要框架的最低支持版本如下所列：
- en: Jetty 9.4
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jetty 9.4
- en: Tomcat 8.5
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tomcat 8.5
- en: Hibernate 5.2
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hibernate 5.2
- en: Gradle 3.4
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gradle 3.4
- en: We will discuss Spring Boot extensively in Chapter 5, *Building Microservices
    with Spring Boot* and [Chapter 7](c46a5b67-c5be-49c0-af8e-b0c4713f890b.xhtml),
    *Advanced Spring Boot Features*.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 5 章《使用 Spring Boot 构建微服务》和第 7 章《高级 Spring Boot 功能》中广泛讨论 Spring Boot。
- en: Summary
  id: totrans-645
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Over the course of the last decade and a half, Spring Framework has dramatically
    improved the experience of developing Java Enterprise applications. With Spring
    Framework 5.0, it brings in a lot of features while significantly increasing the
    baselines.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的十五年中，Spring Framework 显著改善了开发 Java 企业应用程序的体验。Spring Framework 5.0 带来了许多功能，同时显著提高了基线。
- en: In the subsequent chapters, we will cover dependency injection and understand
    how we can develop web applications with Spring MVC. After that, we will move
    into the world of microservices. In Chapters 5, *Building Microservices with Spring
    Boot*, [Chapter 6](09291379-92b0-4d7d-bff7-d77e089f33db.xhtml), *Extending Microservices*,
    and [Chapter 7](c46a5b67-c5be-49c0-af8e-b0c4713f890b.xhtml), *Advanced Spring
    Boot Features*, we will cover how Spring Boot makes the creation of microservices
    simpler. We will then shift our attention to building applications in the Cloud
    with Spring Cloud and Spring Cloud Data Flow.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将介绍依赖注入，并了解如何使用 Spring MVC 开发 Web 应用程序。之后，我们将进入微服务的世界。在第 5 章《使用 Spring
    Boot 构建微服务》、第 6 章《扩展微服务》和第 7 章《高级 Spring Boot 功能》中，我们将介绍 Spring Boot 如何简化微服务的创建。然后我们将把注意力转向使用
    Spring Cloud 和 Spring Cloud Data Flow 在云中构建应用程序。
