- en: Chapter 3. Configuring Enterprise Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。配置企业服务
- en: 'This chapter covers the configuration of the Java Enterprise services that
    ship with the application server. Many of the services are configured within their
    own subsystem. These subsystems can be added or removed depending on whether or
    not the service is required in your application. We will look at the most common
    ones in the following order:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了与应用服务器一起提供的 Java 企业服务的配置。许多服务都在它们自己的子系统内进行配置。根据您的应用程序是否需要这些服务，可以添加或删除这些子系统。以下是我们将按顺序查看的最常见子系统：
- en: Connecting to a database
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: Configuring the Enterprise JavaBeans container
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置企业 JavaBeans 容器
- en: Configuring the messaging service
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置消息服务
- en: Configuring the transaction service
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置事务服务
- en: Configuring concurrency
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置并发
- en: Connecting to a database
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: 'To allow your application to connect to a database, you will need to configure
    your server by adding a datasource. Upon server startup, each datasource is prepopulated
    with a pool of database connections. Applications acquire a database connection
    from the pool by doing a `JNDI` lookup and then calling `getConnection()`. Take
    a look at the following code:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使您的应用程序能够连接到数据库，您需要通过添加数据源来配置您的服务器。在服务器启动时，每个数据源都会预先填充一个数据库连接池。应用程序通过执行 `JNDI`
    查找并调用 `getConnection()` 来从池中获取数据库连接。请查看以下代码：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After the connection has been used, you should always call `connection.close()`
    as soon as possible. This frees the connection and allows it to be returned to
    the connection pool—ready for other applications or processes to use.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接被使用后，您应尽快调用 `connection.close()`。这会释放连接，并允许它返回到连接池——以便其他应用程序或进程使用。
- en: Releases prior to JBoss AS 7 required a datasource configuration file (`ds.xml`)
    to be deployed with the application. Ever since the release of JBoss AS 7, this
    approach has no longer been mandatory due to the modular nature of the application
    server.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JBoss AS 7 之前发布的版本需要将数据源配置文件（`ds.xml`）与应用程序一起部署。自从 JBoss AS 7 发布以来，由于应用程序服务器的模块化特性，这种方法已不再是强制性的。
- en: Out of the box, the application server ships with the H2 open source database
    engine ([http://www.h2database.com](http://www.h2database.com)), which, because
    of its small footprint and browser-based console, is ideal for testing purposes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，应用程序服务器附带 H2 开源数据库引擎（[http://www.h2database.com](http://www.h2database.com)），由于其小巧的体积和基于浏览器的控制台，非常适合测试目的。
- en: However, a real-world application requires an industry-standard database, such
    as the Oracle database or MySQL. In the following section, we will show you how
    to configure a datasource for the MySQL database.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现实世界中的应用程序需要一个行业标准数据库，例如 Oracle 数据库或 MySQL。在下一节中，我们将向您展示如何为 MySQL 数据库配置数据源。
- en: 'Any database configuration requires a two step procedure, which is as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 任何数据库配置都需要两个步骤的过程，如下所示：
- en: Installing the JDBC driver
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 JDBC 驱动程序
- en: Adding the datasource to your configuration
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据源添加到您的配置中
- en: Let's look at each section in detail.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细查看每个部分。
- en: Installing the JDBC driver
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 JDBC 驱动程序
- en: In WildFly's modular server architecture, you have a couple of ways to install
    your JDBC driver. You can install it either as a module or as a deployment unit.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WildFly 的模块化服务器架构中，您有几种方式来安装您的 JDBC 驱动程序。您可以将其作为模块或作为部署单元安装。
- en: The first and recommended approach is to install the driver as a module. In
    the *Installing the driver as a deployment unit* section, we will look at a faster
    approach to installing the driver. However, it does have various limitations,
    which we will cover shortly.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种也是推荐的方法是将驱动程序作为模块安装。在 *将驱动程序作为部署单元安装* 部分中，我们将探讨一种更快的安装驱动程序的方法。然而，它确实存在各种限制，我们将在稍后讨论。
- en: Tip
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Please see the source code for this chapter for the complete module example.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅本章的源代码以获取完整的模块示例。
- en: The first step to install a new module is to create the directory structure
    under the modules folder. The actual path for the module is `JBOSS_HOME/modules/<module>/main`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 安装新模块的第一步是在模块文件夹下创建目录结构。模块的实际路径为 `JBOSS_HOME/modules/<module>/main`。
- en: 'The `main` folder is where all the key module components are installed, namely,
    the driver and the `module.xml` file. So, next, we need to add the following units:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 文件夹是所有关键模块组件安装的地方，即驱动程序和 `module.xml` 文件。因此，接下来，我们需要添加以下单元：'
- en: '`JBOSS_HOME/modules/com/mysql/main/mysql-connector-java-5.1.30-bin.jar`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JBOSS_HOME/modules/com/mysql/main/mysql-connector-java-5.1.30-bin.jar`'
- en: '`JBOSS_HOME/modules/com/mysql/main/module.xml`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JBOSS_HOME/modules/com/mysql/main/module.xml`'
- en: The MySQL JDBC driver used in this example, also known as Connector/J, can be
    downloaded for free from the MySQL site ([http://dev.mysql.com/downloads/connector/j/](http://dev.mysql.com/downloads/connector/j/)).
    At the time of writing, the latest version is 5.1.30.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中使用的MySQL JDBC驱动程序，也称为Connector/J，可以从MySQL网站免费下载（[http://dev.mysql.com/downloads/connector/j/](http://dev.mysql.com/downloads/connector/j/)）。在撰写本文时，最新版本是5.1.30。
- en: The last thing to do is to create the `module.xml` file. This file contains
    the actual module definition. It is important to make sure that the module name
    (`com.mysql`) corresponds to the `module` attribute defined in the your datasource.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要做的事情是创建`module.xml`文件。这个文件包含实际的模块定义。确保模块名称（`com.mysql`）与在您的数据源中定义的`module`属性相匹配非常重要。
- en: 'You must also state the path to the JDBC driver resource and finally add the
    module dependencies, as shown in the following code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您还必须声明JDBC驱动程序资源的路径，最后添加模块依赖项，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here is a diagram showing the final directory structure of this new module:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个显示这个新模块最终目录结构的图：
- en: '![Installing the JDBC driver](img/6232OS_03_01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![安装JDBC驱动](img/6232OS_03_01.jpg)'
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You will notice that there is a directory structure already within the `modules`
    folder. All the system libraries are housed inside the `system/layers/base` directory.
    Your custom modules should be placed directly inside the `modules` folder and
    not with the system modules.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到`modules`文件夹中已经存在目录结构。所有系统库都存放在`system/layers/base`目录中。您的自定义模块应直接放置在`modules`文件夹中，而不是与系统模块一起。
- en: Adding a local datasource
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加本地数据源
- en: Once the JDBC driver is installed, you need to configure the datasource within
    the application server's configuration file. In WildFly, you can configure two
    kinds of datasources, **local** **datasources** and **xa-datasources**, which
    are distinguishable by the element name in the configuration file.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了JDBC驱动程序，您需要在应用程序服务器的配置文件中配置数据源。在WildFly中，您可以配置两种类型的数据源，**本地**数据源和**xa数据源**，它们可以通过配置文件中的元素名称来区分。
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A local datasource does not support two-phase commits using a `java.sql.Driver`.
    On the other hand, an xa-datasource supports two-phase commits using a `javax.sql.XADataSource`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`java.sql.Driver`，本地数据源不支持两阶段提交。另一方面，xa数据源支持使用`javax.sql.XADataSource`进行两阶段提交。
- en: Adding a datasource definition can be completed by adding the datasource definition
    within the server configuration file or by using the management interfaces. The
    management interfaces are the recommended way, as they will accurately update
    the configuration for you, which means that you do not need to worry about getting
    the correct syntax.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在服务器配置文件中添加数据源定义或使用管理接口，可以完成添加数据源定义。管理接口是推荐的方法，因为它们会为您准确更新配置，这意味着您不需要担心语法是否正确。
- en: In this chapter, we are going to add the datasource by modifying the server
    configuration file directly. Although this is not the recommended approach, it
    will allow you to get used to the syntax and layout of the file. In [Chapter 7](ch07.html
    "Chapter 7. Using the Management Interfaces"), *Using the Management Interfaces*,
    we will show you how to add a datasource using the management tools.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过直接修改服务器配置文件来添加数据源。虽然这不是推荐的方法，但它将使您熟悉文件的语法和布局。在[第7章](ch07.html "第7章。使用管理接口")“使用管理接口”中，我们将向您展示如何使用管理工具添加数据源。
- en: 'Here is a sample MySQL datasource configuration that you can copy into your
    datasources subsystem section within the `standalone.xml` configuration file:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个可以复制到`standalone.xml`配置文件中的数据源配置示例：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, the configuration file uses the same XML schema definition from
    the earlier `-*.ds.xml` file, so it will not be difficult to migrate to WildFly
    from previous releases.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，配置文件使用与早期`-*.ds.xml`文件相同的XML架构定义，因此从先前的版本迁移到WildFly不会很困难。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In WildFly, it's mandatory that the datasource is bound into the `java:/` or
    `java:jboss/` JNDI namespace.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在WildFly中，将数据源绑定到`java:/`或`java:jboss/` JNDI命名空间是强制性的。
- en: 'Let''s take a look at the various elements of this file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个文件的各种元素：
- en: '`connection-url`: This element is used to define the connection path to the
    database.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connection-url`：此元素用于定义连接到数据库的路径。'
- en: '`driver`: This element is used to define the JDBC driver class.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`driver`：此元素用于定义JDBC驱动程序类。'
- en: '`pool`: This element is used to define the JDBC connection pool properties.
    In this case, we are going to leave the default values.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pool`: 此元素用于定义 JDBC 连接池属性。在这种情况下，我们将保留默认值。|'
- en: '`security`: This element is used to configure the connection credentials.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`security`: 此元素用于配置连接凭据。|'
- en: '`statement`: This element is added just as a placeholder for statement-caching
    options.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`statement`: 此元素仅作为语句缓存选项的占位符添加。|'
- en: '`timeout`: This element is optional and contains a set of other elements, such
    as `query-timeout`, which is a static configuration of the maximum seconds before
    a query times out. Also the included `idle-timeout-minutes` element indicates
    the maximum time a connection may be idle before being closed; setting it to `0`
    disables it, and the default is `15` minutes.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeout`: 此元素是可选的，包含一组其他元素，例如 `query-timeout`，它是对查询超时的静态配置，即查询在超时前允许的最大秒数。还包括的
    `idle-timeout-minutes` 元素表示在关闭之前连接可能空闲的最大时间；将其设置为 `0` 禁用它，默认为 `15` 分钟。|'
- en: Configuring the connection pool
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置连接池|
- en: One key aspect of the datasource configuration is the `pool` element. You can
    use connection pooling without modifying any of the existing WildFly configurations,
    as, without modification, WildFly will choose to use default settings. If you
    want to customize the pooling configuration, for example, change the pool size
    or change the types of connections that are pooled, you will need to learn how
    to modify the configuration file.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 数据源配置的一个关键方面是 `pool` 元素。您可以在不修改任何现有 WildFly 配置的情况下使用连接池，因为在不修改的情况下，WildFly 将选择使用默认设置。如果您想自定义池配置，例如，更改池大小或更改要池化的连接类型，您需要学习如何修改配置文件。|
- en: 'Here''s an example of pool configuration, which can be added to your datasource
    configuration:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个池配置的示例，可以添加到您的数据源配置中：|
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The attributes included in the `pool` configuration are actually borrowed from
    earlier releases, so we include them here for your reference:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`pool` 配置中包含的属性是从早期版本借用的，所以我们在这里包括它们供您参考：|
- en: '| Attribute | Meaning |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 含义 |'
- en: '| --- | --- |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `initial-pool-size` | This means the initial number of connections a pool
    should hold (default is `0` (zero)). |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `initial-pool-size` | 这意味着池应该持有的初始连接数（默认为 `0`（零））。|'
- en: '| `min-pool-size` | This is the minimum number of connections in the pool (default
    is `0` (zero)). |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `min-pool-size` | 这是池中的最小连接数（默认为 `0`（零））。|'
- en: '| `max-pool-size` | This is the maximum number of connections in the pool (default
    is `20`). |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `max-pool-size` | 这是池中的最大连接数（默认为 `20`）。|'
- en: '| `prefill` | This attempts to prefill the connection pool to the minimum number
    of connections. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `prefill` | 这尝试将连接池预填充到最小连接数。|'
- en: '| `use-strict-min` | This determines whether idle connections below `min-pool-size`
    should be closed. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `use-strict-min` | 这确定是否应该关闭低于 `min-pool-size` 的空闲连接。|'
- en: '| `allow-multiple-users` | This determines whether multiple users can access
    the datasource through the `getConnection` method. This has been changed slightly
    in WildFly. In WildFly, the line `<allow-multiple-users>true</allow-multiple-users>`
    is required. In JBoss AS 7, the empty element `<allow-multiple-users/>` was used.
    |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `allow-multiple-users` | 这确定是否可以通过 `getConnection` 方法让多个用户访问数据源。在 WildFly
    中，这略有变化。在 WildFly 中，需要 `<allow-multiple-users>true</allow-multiple-users>` 这一行。在
    JBoss AS 7 中，使用了 `<allow-multiple-users/>` 空元素。|'
- en: '| `capacity` | This specifies the capacity policies for the pool—either `incrementer`
    or `decrementer`. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `capacity` | 这指定了池的容量策略——要么是 `incrementer` 要么是 `decrementer`。|'
- en: '| `connection-listener` | Here, you can specify `org.jboss.jca.adapters.jdbc.spi.listener.ConnectionListener`
    that allows you to listen for connection callbacks, such as activation and passivation.
    |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `connection-listener` | 在这里，您可以指定 `org.jboss.jca.adapters.jdbc.spi.listener.ConnectionListener`，它允许您监听连接回调，例如激活和钝化。|'
- en: '| `flush-strategy` | This specifies how the pool should be flushed in the event
    of an error (default is `FailingConnectionsOnly`). |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `flush-strategy` | 这指定了在发生错误时如何刷新池（默认为 `FailingConnectionsOnly`）。|'
- en: Configuring the statement cache
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置语句缓存|
- en: 'For each connection within a connection pool, the WildFly server is able to
    create a statement cache. When a prepared statement or callable statement is used,
    WildFly will cache the statement so that it can be reused. In order to activate
    the statement cache, you have to specify a value greater than `0` within the `prepared-statement-cache-size`
    element. Take a look at the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于连接池中的每个连接，WildFly 服务器能够创建一个语句缓存。当使用预处理语句或可调用语句时，WildFly 将缓存该语句以便重用。为了激活语句缓存，您必须在
    `prepared-statement-cache-size` 元素中指定一个大于 `0` 的值。请看以下代码：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that we have also set `track-statements` to `true`. This will enable
    automatic closing of `statements` and `ResultSets`. This is important if you want
    to use prepared statement caching and/or don't want to prevent cursor leaks.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还将 `track-statements` 设置为 `true`。这将启用 `statements` 和 `ResultSets` 的自动关闭。如果您想使用预处理语句缓存并且/或者不想防止游标泄漏，这是很重要的。
- en: The last element, `share-prepared-statements`, can only be used when the prepared
    statement cache is enabled. This property determines whether two requests in the
    same transaction should return the same statement (default is `false`).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个元素 `share-prepared-statements` 只能在启用预处理语句缓存时使用。此属性确定同一事务中的两个请求是否应该返回相同的语句（默认为
    `false`）。
- en: Adding an xa-datasource
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加 xa 数据源
- en: Adding an `xa-datasource` requires some modification to the datasource configuration.
    The `xa-datasource` is configured within its own element, that is, within the
    datasource. You will also need to specify the `xa-datasource` class within the
    `driver` element.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 `xa-datasource` 需要对数据源配置进行一些修改。`xa-datasource` 在其自己的元素中配置，即在数据源内部。您还需要在 `driver`
    元素中指定 `xa-datasource` 类。
- en: 'In the following code, we will add a configuration for our MySQL JDBC driver,
    which will be used to set up an `xa-datasource`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们将为我们的 MySQL JDBC 驱动程序添加配置，该配置将用于设置 `xa-datasource`：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Datasource versus xa-datasource**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据源与 xa 数据源**'
- en: You should use an xa-datasource in cases where a single transaction spans multiple
    datasources, for example, if a method consumes a **Java Message Service** (**JMS**)
    and updates a **Java Persistence API** (**JPA**) entity.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个事务跨越多个数据源的情况下，例如，如果方法消耗 **Java 消息服务**（**JMS**）并更新 **Java 持久化 API**（**JPA**）实体时，您应该使用
    xa 数据源。
- en: Installing the driver as a deployment unit
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将驱动程序作为部署单元安装
- en: In the WildFly application server, every library is a module. Thus, simply deploying
    the JDBC driver to the application server will trigger its installation.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WildFly 应用程序服务器中，每个库都是一个模块。因此，只需将 JDBC 驱动程序部署到应用程序服务器即可触发其安装。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the JDBC driver consists of more than a single JAR file, you will not be
    able to install the driver as a deployment unit. In this case, you will have to
    install the driver as a core module.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 JDBC 驱动程序由多个 JAR 文件组成，您将无法将其作为部署单元安装。在这种情况下，您必须将驱动程序作为核心模块安装。
- en: 'So, to install the database driver as a deployment unit, simply copy the `mysql-connector-java-5.1.30-bin.jar`
    driver into the `JBOSS_HOME/standalone/deployments` folder of your installation,
    as shown in the following image:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要将数据库驱动程序作为部署单元安装，只需将 `mysql-connector-java-5.1.30-bin.jar` 驱动程序复制到您的安装目录中的
    `JBOSS_HOME/standalone/deployments` 文件夹，如下图中所示：
- en: '![Installing the driver as a deployment unit](img/6232OS_03_02.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![将驱动程序作为部署单元安装](img/6232OS_03_02.jpg)'
- en: 'Once you have deployed your JDBC driver, you still need to add the datasource
    to your server configuration file. The simplest way to do this is to paste the
    following datasource definition into the configuration file, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 部署您的 JDBC 驱动程序后，您仍然需要将其添加到服务器配置文件中。最简单的方法是将以下数据源定义粘贴到配置文件中，如下所示：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Alternatively, you can use the **command-line interface** (**CLI**) or the web
    administration console to achieve the same result, as shown later in [Chapter
    7](ch07.html "Chapter 7. Using the Management Interfaces"), *Using the Management
    Interfaces*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用 **命令行界面**（**CLI**）或网络管理控制台来实现相同的结果，如后续第 7 章[使用管理接口](ch07.html "第 7
    章。使用管理接口")中所述，*使用管理接口*。
- en: Tip
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**What about domain deployment?**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于域部署呢？**'
- en: In this chapter, we are discussing the configuration of standalone servers.
    The services can also be configured in the domain servers. Domain servers, however,
    don't have a specified folder scanned for deployment. Rather, the management interfaces
    are used to inject resources into the domain. [Chapter 5](ch05.html "Chapter 5. Configuring
    a WildFly Domain"), *Configuring a WildFly Domain*, will detail all the steps
    to deploy a module when using a domain server.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论的是独立服务器的配置。服务也可以在域服务器中进行配置。然而，域服务器没有指定用于部署的文件夹。相反，使用管理接口将资源注入域。[第 5
    章](ch05.html "第 5 章。配置 WildFly 域")，*配置 WildFly 域*，将详细介绍使用域服务器部署模块的所有步骤。
- en: Choosing the right driver deployment strategy
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择正确的驱动程序部署策略
- en: At this point, you might wonder about a best practice for deploying the JDBC
    driver. Installing the driver as a deployment unit is a handy shortcut; however,
    it can limit its usage. Firstly, it requires a JDBC 4-compliant driver.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您可能会想知道部署 JDBC 驱动程序的最佳实践。将驱动程序作为部署单元安装是一个方便的快捷方式；然而，它可能会限制其使用。首先，它需要一个
    JDBC 4 兼容的驱动程序。
- en: Deploying a non-JDBC-4-compliant driver is possible, but it requires a simple
    patching procedure. To do this, create a `META-INF/services` structure containing
    the `java.sql.Driver` file. The content of the file will be the driver name. For
    example, let's suppose you have to patch a MySQL driver—the content will be `com.mysql.jdbc.Driver`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 部署不兼容 JDBC 4 的驱动程序是可能的，但需要简单的修补程序。为此，创建一个包含 `java.sql.Driver` 文件的 `META-INF/services`
    结构。文件的内容将是驱动程序名称。例如，假设您需要修补 MySQL 驱动程序——内容将是 `com.mysql.jdbc.Driver`。
- en: Once you have created your structure, you can package your JDBC driver with
    any zipping utility or the `.jar` command, `jar -uf <your -jdbc-driver.jar> META-INF/services/java.sql.Driver`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了结构，您可以使用任何压缩工具或 `.jar` 命令打包您的 JDBC 驱动程序，`jar -uf <your-jdbc-driver.jar>
    META-INF/services/java.sql.Driver`。
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The most current JDBC drivers are compliant with JDBC 4 although, curiously,
    not all are recognized as such by the application server. The following table
    describes some of the most used drivers and their JDBC compliance:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管令人好奇，尽管不是所有驱动程序都被应用程序服务器识别为 JDBC 4 兼容，但最新的 JDBC 驱动程序都符合 JDBC 4 规范。以下表格描述了一些最常用的驱动程序及其
    JDBC 兼容性：
- en: '| Database | Driver | JDBC 4 compliant | Contains java.sql.Driver |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 数据库 | 驱动程序 | JDBC 4 兼容 | 包含 java.sql.Driver |'
- en: '| --- | --- | --- | --- |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| MySQL | `mysql-connector-java-5.1.30-bin.jar` | Yes, though not recognized
    as compliant by WildFly | Yes |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| MySQL | `mysql-connector-java-5.1.30-bin.jar` | 是，尽管 WildFly 并未将其识别为兼容 |
    是 |'
- en: '| PostgreSQL | `postgresql-9.3-1101.jdbc4.jar` | Yes, though not recognized
    as compliant by WildFly | Yes |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| PostgreSQL | `postgresql-9.3-1101.jdbc4.jar` | 是，尽管 WildFly 并未将其识别为兼容 | 是
    |'
- en: '| Oracle | `ojdbc6.jar`/`ojdbc5.jar` | Yes | Yes |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| Oracle | `ojdbc6.jar`/`ojdbc5.jar` | 是 | 是 |'
- en: '| Oracle | `ojdbc4.jar` | No | No |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| Oracle | `ojdbc4.jar` | 否 | 否 |'
- en: As you can see, the most notable exception to the list of drivers is the older
    Oracle `ojdbc4.jar`, which is not compliant with JDBC 4 and does not contain the
    driver information in `META-INF/services/java.sql.Driver`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，列表中一个最显著的例外是较旧的 Oracle `ojdbc4.jar`，它不符合 JDBC 4 规范，并且不包含 `META-INF/services/java.sql.Driver`
    中的驱动程序信息。
- en: The second issue with driver deployment is related to the specific case of xa-datasources.
    Installing the driver as deployment means that the application server by itself
    cannot deduce the information about the `xa-datasource` class used in the driver.
    Since this information is not contained inside `META-INF/services`, you are forced
    to specify information about the `xa-datasource` class for each xa-datasource
    you are going to create.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序部署的第二个问题与 xa-datasources 的特定情况相关。将驱动程序作为部署安装意味着应用程序服务器本身无法推断出驱动程序中使用的 `xa-datasource`
    类的信息。由于这些信息不包含在 `META-INF/services` 中，您被迫为要创建的每个 xa-datasource 指定 `xa-datasource`
    类的信息。
- en: When you install a driver as a module, the `xa-datasource` class information
    can be shared for all the installed datasources.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将驱动程序作为模块安装时，`xa-datasource` 类信息可以共享给所有已安装的数据源。
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So, if you are not too limited by these issues, installing the driver as a deployment
    is a handy shortcut that can be used in your development environment. For a production
    environment, it is recommended that you install the driver as a static module.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您对这些问题的限制不是太严格，将驱动程序作为部署安装是一个方便的快捷方式，可以在您的开发环境中使用。对于生产环境，建议您将驱动程序作为静态模块安装。
- en: Configuring a datasource programmatically
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以编程方式配置数据源
- en: 'After installing your driver, you may want to limit the amount of application
    configuration in the server file. This can be done by configuring your datasource
    programmatically This option requires zero modification to your configuration
    file, which means greater application portability. The support to configure a
    datasource programmatically is one of the cool features of Java EE that can be
    achieved by using the `@DataSourceDefinition` annotation, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 安装您的驱动程序后，您可能希望限制服务器文件中的应用程序配置量。这可以通过程序化配置数据源来完成。此选项不需要修改您的配置文件，这意味着更高的应用程序可移植性。通过使用`@DataSourceDefinition`注解，可以配置数据源程序化，如下所示：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, we defined a datasource for an Oracle database. It's important
    to note that, when configuring a datasource programmatically, you will actually
    bypass JCA, which proxies requests between the client and the connection pool.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们为Oracle数据库定义了一个数据源。重要的是要注意，当程序化配置数据源时，您实际上会绕过JCA，它代理客户端和连接池之间的请求。
- en: The obvious advantage of this approach is that you can move your application
    from one application server to another without the need for reconfiguring its
    datasources. On the other hand, by modifying the datasource within the configuration
    file, you will be able to utilize the full benefits of the application server,
    many of which are required for enterprise applications.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的明显优势在于，您可以在不重新配置其数据源的情况下，将应用程序从一个应用服务器移动到另一个应用服务器。另一方面，通过在配置文件中修改数据源，您将能够充分利用应用服务器的全部好处，其中许多对于企业应用程序是必需的。
- en: Configuring the Enterprise JavaBeans container
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置企业JavaBeans容器
- en: The **Enterprise** **JavaBeans** (**EJB**) container is a fundamental part of
    the Java Enterprise architecture. The EJB container provides the environment used
    to host and manage the EJB components deployed in the container. The container
    is responsible for providing a standard set of services, including caching, concurrency,
    persistence, security, transaction management, and locking services.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**企业** **JavaBeans** (**EJB**) 容器是Java企业架构的基本组成部分。EJB容器提供用于托管和管理容器中部署的EJB组件的环境。容器负责提供一组标准服务，包括缓存、并发、持久性、安全性、事务管理和锁定服务。'
- en: 'The container also provides distributed access and lookup functions for hosted
    components, and it intercepts all method invocations on hosted components to enforce
    declarative security and transaction contexts. Take a look at the following figure:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 容器还为主机组件提供分布式访问和查找功能，并且它拦截所有对主机组件的方法调用，以强制执行声明性安全和事务上下文。请看以下图示：
- en: '![Configuring the Enterprise JavaBeans container](img/6232OS_03_03.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![配置企业JavaBeans容器](img/6232OS_03_03.jpg)'
- en: 'As depicted in this image, you will be able to deploy the full set of EJB components
    within WildFly:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如此图中所示，您将能够在WildFly中部署完整的EJB组件集：
- en: '**Stateless session bean (SLSB)**: SLSBs are objects whose instances have no
    conversational state. This means that all bean instances are equivalent when they
    are not servicing a client.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态会话Bean (SLSB)**：SLSBs是实例没有对话状态的对象。这意味着当它们不服务客户端时，所有Bean实例都是等效的。'
- en: '**Stateful session bean (SFSB)**: SFSBs support conversational services with
    tightly coupled clients. A stateful session bean accomplishes a task for a particular
    client. It maintains the state for the duration of a client session. After session
    completion, the state is not retained.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有状态会话Bean (SFSB)**：SFSBs支持与紧密耦合的客户端进行对话服务。有状态会话Bean为特定客户端完成一项任务。它在客户端会话期间维护状态。会话完成后，状态不会保留。'
- en: '**Message-driven bean (MDB)**: MDBs are a kind of enterprise beans that are
    able to asynchronously process messages sent by any JMS producer.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息驱动Bean (MDB)**：MDBs是一种能够异步处理任何JMS生产者发送的消息的企业Bean。'
- en: '**Singleton EJB**: This is essentially similar to a stateless session bean;
    however, it uses a single instance to serve the client requests. Thus, you are
    guaranteed to use the same instance across invocations. Singletons can use a set
    of events with a richer life cycle and a stricter locking policy to control concurrent
    access to the instance. In the next chapter, which is about web applications,
    we will illustrate a Java EE 7 application that makes use of a Singleton EJB to
    hold some cached data.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单例 EJB**：这本质上与无状态会话 Bean 类似；然而，它使用单个实例来服务客户端请求。因此，您保证在调用之间使用相同的实例。单例可以使用一组具有更丰富生命周期和更严格锁定策略的事件来控制对实例的并发访问。在下一章，关于
    Web 应用程序的部分，我们将展示一个使用单例 EJB 来保存一些缓存数据的 Java EE 7 应用程序。'
- en: '**No-interface EJB**: This is just another view of the standard session bean,
    except that local clients do not require a separate interface, that is, all public
    methods of the bean class are automatically exposed to the caller. Interfaces
    should only be used in EJB 3.x if you have multiple implementations.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无接口 EJB**：这只是标准会话 Bean 的另一种视图，除了本地客户端不需要一个单独的接口，也就是说，Bean 类的所有公共方法都会自动暴露给调用者。接口仅在
    EJB 3.x 中使用，如果您有多个实现。'
- en: '**Asynchronous EJB**: These are able to process client requests asynchronously
    just like MDBs, except that they expose a typed interface and follow a more complex
    approach to processing client requests, which are composed of:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步 EJB**：这些能够像消息驱动 Bean（MDB）一样异步处理客户端请求，除了它们提供了一个类型化的接口，并采用更复杂的方法来处理客户端请求，这些请求由以下组成：'
- en: The `fire-and-forget` asynchronous void methods, which are invoked by the client
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由客户端调用的 `fire-and-forget` 异步 void 方法
- en: The `retrieve-result-later` asynchronous methods having a `Future<?>` return
    type
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retrieve-result-later` 异步方法具有 `Future<?>` 返回类型'
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: EJB components that don't keep conversational states (SLSB and MDB) can be optionally
    configured to emit timed notifications. See the *Configuring the timer service*
    section for more information about it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 不保持会话状态的 EJB 组件（SLSB 和 MDB）可以配置为发出定时通知。有关更多信息，请参阅 *配置定时服务* 部分。
- en: Configuring the EJB components
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 EJB 组件
- en: 'Now that we have briefly outlined the basic types of EJB, we will look at the
    specific details of the application server configuration. This comprises the following
    components:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经简要概述了 EJB 的基本类型，接下来我们将探讨应用服务器配置的具体细节。这包括以下组件：
- en: The SLSB configuration
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SLSB 配置
- en: The SFSB configuration
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SFSB 配置
- en: The MDB configuration
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MDB 配置
- en: The Timer service configuration
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时服务配置
- en: Let's see them all in detail.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看它们。
- en: Configuring the stateless session beans
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置无状态会话 Bean
- en: EJBs are configured within the `ejb3.2.0` subsystem. By default, no stateless
    session bean instances exist in WildFly at startup time. As individual beans are
    invoked, the EJB container initializes new SLSB instances.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: EJB 在 `ejb3.2.0` 子系统中进行配置。默认情况下，WildFly 启动时不存在无状态会话 Bean 实例。随着单个 Bean 的调用，EJB
    容器初始化新的 SLSB 实例。
- en: 'These instances are then kept in a pool that will be used to service future
    EJB method calls. The EJB remains active for the duration of the client''s method
    call. After the method call is complete, the EJB instance is returned to the pool.
    Because the EJB container unbinds stateless session beans from clients after each
    method call, the actual bean class instance that a client uses can be different
    from invocation to invocation. Have a look at the following diagram:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实例随后将被保存在一个池中，该池将用于服务未来的 EJB 方法调用。EJB 在客户端方法调用期间保持活动状态。方法调用完成后，EJB 实例将返回到池中。因为
    EJB 容器在每次方法调用后将无状态会话 Bean 从客户端解绑，所以客户端使用的实际 Bean 类实例可能在不同调用之间不同。请看以下图表：
- en: '![Configuring the stateless session beans](img/6232OS_03_04.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![配置无状态会话 Bean](img/6232OS_03_04.jpg)'
- en: If all instances of an EJB class are active and the pool's maximum pool size
    has been reached, new clients requesting the EJB class will be blocked until an
    active EJB completes a method call. Depending on how you have configured your
    stateless pool, an acquisition timeout can be triggered if you are not able to
    acquire an instance from the pool within a maximum time.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个 EJB 类的所有实例都是活动的，并且池的最大池大小已经达到，那么请求 EJB 类的新客户端将会被阻塞，直到一个活动的 EJB 完成一个方法调用。根据您如何配置您的无状态池，如果在最大时间内无法从池中获取实例，则可能会触发获取超时。
- en: You can either configure your session pool through your main configuration file
    or programmatically. Let's look at both approaches, starting with the main configuration
    file.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过主要配置文件或编程方式配置会话池。让我们看看这两种方法，从主要配置文件开始。
- en: 'In order to configure your pool, you can operate on two parameters: the maximum
    size of the pool (`max-pool-size`) and the instance acquisition timeout (`instance-acquisition-timeout`).
    Let''s see an example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置您的池，您可以操作两个参数：池的最大大小（`max-pool-size`）和实例获取超时（`instance-acquisition-timeout`）。让我们看看一个例子：
- en: '[PRE9]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, we have configured the SLSB pool with a *strict* upper limit
    of `25` elements. The strict maximum pool is the only available pool instance
    implementation; it allows a fixed number of concurrent requests to run at one
    time. If there are more requests running than the pool's strict maximum size,
    those requests will get blocked until an instance becomes available. Within the
    pool configuration, we have also set an `instance-acquisition-timeout` value of
    `5` minutes, which will come into play if your requests are larger than the pool
    size.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们已将 SLSB 池配置为具有 `25` 个元素的*严格*上限。严格的池最大值是唯一可用的池实例实现；它允许固定数量的并发请求同时运行。如果有更多请求正在运行，并且超过了池的严格最大大小，这些请求将阻塞，直到有实例可用。在池配置中，我们还设置了
    `instance-acquisition-timeout` 值为 `5` 分钟，如果您的请求大小超过池大小，该值将发挥作用。
- en: 'You can configure as many pools as you like. The pool used by the EJB container
    is indicated by the attribute `pool-name` on the `bean-instance-pool-ref` element.
    For example, here we have added one more pool configuration, `largepool`, and
    set it as the EJB container''s pool implementation. Have a look at the following
    code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以配置任意数量的池。EJB 容器使用的池由 `bean-instance-pool-ref` 元素上的 `pool-name` 属性指示。例如，这里我们添加了一个额外的池配置，`largepool`，并将其设置为
    EJB 容器的池实现。看看以下代码：
- en: '[PRE10]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using CLI to configure the stateless pool size
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 CLI 配置无状态池大小
- en: We have detailed the steps necessary to configure the SLSB pool size through
    the main configuration file. However, the suggested best practice is to use CLI
    to alter the server model.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经详细说明了通过主要配置文件配置 SLSB 池大小的步骤。然而，建议的最佳实践是使用 CLI 来更改服务器模型。
- en: 'Here''s how you can add a new pool named `large-pool` to your EJB 3 subsystem:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您如何将名为 `large-pool` 的新池添加到您的 EJB 3 子系统中的方法：
- en: '[PRE11]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, you can set this pool as the default to be used by the EJB container,
    as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以将此池设置为默认池，供 EJB 容器使用，如下所示：
- en: '[PRE12]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, you can, at any time, change the pool size property by operating on
    the `max-pool-size` attribute, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以通过操作 `max-pool-size` 属性来随时更改池大小属性，如下所示：
- en: '[PRE13]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Configuring the stateful session beans
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置有状态的会话豆
- en: 'SFSBs are bound to a particular client. The application server uses a cache
    to store active EJB instances in memory so that they can be quickly retrieved
    for future client requests. The cache contains EJBs that are currently in use
    by a client and instances that were recently in use. Take a look at the following
    diagram:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: SFSBs 绑定到特定的客户端。应用程序服务器使用缓存将活动 EJB 实例存储在内存中，以便它们可以快速检索以供未来的客户端请求使用。缓存包含客户端当前正在使用的
    EJBs 以及最近使用过的实例。看看以下图解：
- en: '![Configuring the stateful session beans](img/6232OS_03_05.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![配置有状态的会话豆](img/6232OS_03_05.jpg)'
- en: Having EJBs in memory is a costly operation, so you should move them out of
    memory as soon as possible by either passivating them or removing them.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存中保留 EJBs 是一项昂贵的操作，因此您应该尽快通过钝化或删除它们来将它们移出内存。
- en: '**Passivation** is a process by which the EJB container ensures that idle SFSB
    instances are freed from the cache by having their state saved to disk.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**钝化**是一种过程，通过该过程 EJB 容器确保空闲的 SFSB 实例通过将它们的状态保存到磁盘来从缓存中释放。'
- en: 'Removing a bean from the cache, on the other hand, is a process that can be
    triggered programmatically for the EJB container. To remove the EJB programmatically,
    add the `@javax.ejb.Remove` annotation to your method. When this method is invoked,
    the EJB will be removed. Take a look at the following code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，从缓存中删除豆是一个可以由 EJB 容器程序触发的过程。要程序化地删除 EJB，请将 `@javax.ejb.Remove` 注解添加到您的函数中。当调用此方法时，EJB
    将被删除。看看以下代码：
- en: '[PRE14]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following example shows a section of the `ejb3:2.0` subsystem, which shows
    the configuration of a SFSB along with its cache and passivation store configuration.
    Have a look at the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了 `ejb3:2.0` 子系统的部分内容，它显示了 SFSB 的配置以及其缓存和钝化存储配置。请看以下代码：
- en: '[PRE15]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, the stateful bean element references a cache definition (named
    `distributable`), which in turn is connected to a passivation store (named `infinispan`).
    Notice the optional `max-size` attribute that limits the amount of SFSBs that
    can be contained in the cache. You can also see that the clustered cache uses
    infinispan's `passivation-store` (see [Chapter 8](ch08.html "Chapter 8. Clustering"),
    *Clustering*, for more information about the infinispan cache).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有状态的豆元素引用了一个缓存定义（命名为 `distributable`），该定义反过来连接到一个钝化存储（命名为 `infinispan`）。请注意可选的
    `max-size` 属性，它限制了缓存中可以包含的 SFSB 数量。您还可以看到集群缓存使用 infinispan 的 `passivation-store`（有关
    infinispan 缓存的更多信息，请参阅第 8 章，*集群*，[Chapter 8](ch08.html "Chapter 8. Clustering")）。
- en: Tip
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In WildFly, the `file-passivation-store` and `cluster-passivation-store` elements
    have been deprecated in favor of `passivation-store`. Both deprecated elements
    will be removed completely in future releases.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WildFly 中，`file-passivation-store` 和 `cluster-passivation-store` 元素已被弃用，以支持
    `passivation-store`。这两个弃用元素将在未来的版本中完全删除。
- en: Configuring the message-driven beans
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置消息驱动的豆（Beans）
- en: '**Message-driven** **beans** (**MDBs**) are stateless, server-side, transaction-aware
    components that are used to process asynchronous JMS messages.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息驱动的** **豆**（**MDBs**）是无状态的、服务器端、事务感知的组件，用于处理异步 JMS 消息。'
- en: One of the most important aspects of MDBs is that they can consume and process
    messages concurrently.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: MDB 最重要的一点是它们可以并发地消费和处理消息。
- en: This capability provides a significant advantage over traditional JMS clients,
    which must be custom-built to manage resources, transactions, and security in
    a multithreaded environment.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这种能力在传统 JMS 客户端中提供了显著的优势，因为传统 JMS 客户端必须自定义构建以在多线程环境中管理资源、事务和安全。
- en: 'Just as the session beans have well-defined life cycles, so does an MDB. The
    MDB instance''s life cycle is pretty much the same as the stateless bean. An MDB
    has two states: **Does not Exist** and **Method ready Pool**. Take a look at the
    following figure:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 与会话豆有明确的生命周期一样，MDB 也有。MDB 实例的生命周期基本上与无状态豆相同。MDB 有两种状态：**不存在**和**方法就绪池**。请看以下图示：
- en: '![Configuring the message-driven beans](img/6232OS_03_06.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![配置消息驱动的豆](img/6232OS_03_06.jpg)'
- en: When a message is received, the EJB container checks whether any MDB instance
    is available in the pool. If a bean is available, WildFly uses that instance.
    After an MDB instance's `onMessage()` method returns, the request is complete,
    and the instance is placed back in the pool. This results in the best response
    time, as the request is served without waiting for a new instance to be created.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到消息时，EJB 容器会检查池中是否有任何可用的 MDB 实例。如果有一个豆可用，WildFly 会使用该实例。在 MDB 实例的 `onMessage()`
    方法返回后，请求完成，并将实例放回池中。这导致最佳响应时间，因为请求是在不等待创建新实例的情况下得到服务的。
- en: If no bean instances are available, the container checks whether there is room
    for more MDBs in the pool by comparing the MDB's `MaxSize` attribute with the
    pool size.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有可用的豆实例，容器会通过比较 MDB 的 `MaxSize` 属性与池大小来检查池中是否有更多 MDB 的空间。
- en: If `MaxSize` still has not been reached, a new MDB is initialized. The creation
    sequence, as pointed out in the preceding diagram, is the same as that of the
    stateless bean. Failure to create a new instance, on the other hand, will imply
    that the request will be blocked until an active MDB completes. If the request
    cannot acquire an instance from the pool within the time defined in `instance-acquisition-timeout`,
    an exception is thrown.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `MaxSize` 仍未达到，则会初始化一个新的 MDB。创建序列，如前图所示，与无状态豆相同。另一方面，如果无法创建新实例，则请求将被阻塞，直到一个活动的
    MDB 完成。如果在 `instance-acquisition-timeout` 定义的时时间内无法从池中获取实例，则会抛出异常。
- en: 'The configuration of the MDB pool is exactly the same as for the SLSB, so we
    will just include it here without further explanation:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: MDB 池的配置与 SLSB 的配置完全相同，所以我们在这里只包括它，不做进一步解释：
- en: '[PRE16]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about the various types of enterprise beans, you can refer to
    the Java EE 7 tutorial at [http://docs.oracle.com/javaee/7/tutorial/doc/ejb-intro002.htm](http://docs.oracle.com/javaee/7/tutorial/doc/ejb-intro002.htm).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于各种企业Bean的信息，你可以参考Java EE 7教程，链接为[http://docs.oracle.com/javaee/7/tutorial/doc/ejb-intro002.htm](http://docs.oracle.com/javaee/7/tutorial/doc/ejb-intro002.htm)。
- en: Configuring the timer service
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置定时器服务
- en: The EJB 3 timer service provides a way to allow methods to be invoked at specific
    times or time intervals. This is useful should your application business process
    need periodic notifications.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: EJB 3 定时器服务提供了一种方法，允许方法在特定时间或时间间隔被调用。如果你的应用程序业务流程需要周期性通知，这将非常有用。
- en: The EJB timer service can be used in any type of EJB 3, except for stateful
    session beans. Using the timer services is as simple as annotating a method with
    `@javax.ejb.Timeout`. This method will then be triggered by the container when
    the time interval expires.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: EJB 定时器服务可以在任何类型的 EJB 3 中使用，除了有状态的会话Bean。使用定时器服务就像在方法上标注 `@javax.ejb.Timeout`
    注解一样简单。当时间间隔到期时，容器将触发该方法。
- en: 'The following example shows you how to implement a very simple timer, which
    will be started by invoking the `scheduleTimer(long milliseconds)` method. Take
    a look at the following code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何实现一个非常简单的定时器，它将通过调用 `scheduleTimer(long milliseconds)` 方法来启动。请看以下代码：
- en: '[PRE17]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As far as configuration is concerned, you can store planned executions within
    the filesystem or in a database. To save them in the filesystem, you need to reference
    the `default-data-store` attribute from the `file-data-store` attribute (both
    called `file-store` in this example). The number of threads reserved for the timer
    service can be configured with the `thread-pool-name` attribute, which needs to
    reference a `thread-pool` element. Have a look at the following code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置方面，你可以在文件系统或数据库中存储计划执行的作业。要在文件系统中保存它们，你需要从`file-data-store`属性（在这个例子中称为`file-store`）引用`default-data-store`属性。定时器服务保留的线程数量可以通过`thread-pool-name`属性进行配置，该属性需要引用一个`thread-pool`元素。请看以下代码：
- en: '[PRE18]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Configuring the messaging system
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置消息系统
- en: Message-oriented middleware has always been an integral part of the application
    server. Messaging systems allow you to loosely couple heterogeneous systems together
    while typically providing reliability, transactions, and many other features.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 消息导向中间件一直是应用服务器的一个基本组成部分。消息系统允许你将异构系统松散耦合在一起，同时通常提供可靠性、事务以及许多其他功能。
- en: Messaging is not part of the Java EE web profile, so you will not find a configuration
    for the messaging subsystem in the `standalone.xml` file. However, the messaging
    subsystem is included in the configuration file named `standalone-full.xml`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 消息系统不是Java EE Web配置的一部分，因此你不会在`standalone.xml`文件中找到消息子系统的配置。然而，消息子系统包含在名为`standalone-full.xml`的配置文件中。
- en: Note
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Messaging systems normally support two main styles of asynchronous messaging:
    **Queues** (point-to-point messaging) and **Topics** (publish/subscribe messaging).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 消息系统通常支持两种主要的异步消息风格：**队列**（点对点消息）和**主题**（发布/订阅消息）。
- en: In the point-to-point model, a sender posts messages to a particular queue,
    and a receiver reads messages from the queue. Here, the sender knows the destination
    of the message and posts the message directly to the receiver's queue.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在点对点模型中，发送者将消息发布到特定的队列，接收者从队列中读取消息。在这里，发送者知道消息的目的地，并将消息直接发布到接收者的队列中。
- en: The publish/subscribe model supports the publishing of messages to a particular
    message topic. Subscribers may register interest in receiving messages on a particular
    message topic. In this model, neither the publisher nor the subscriber know about
    each other.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 发布/订阅模型支持将消息发布到特定的消息主题。订阅者可以注册对特定消息主题接收消息的兴趣。在这个模型中，发布者和订阅者都不知道对方的存在。
- en: 'The following table shows the characteristics of the two different models:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了两种不同模型的特点：
- en: '| Point-to-point messaging | Publish/Subscribe |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 点对点消息 | 发布/订阅 |'
- en: '| --- | --- |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Only one consumer gets the message. | Multiple consumers (or none) will receive
    the message. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 只有一个消费者获取消息。 | 多个消费者（或没有）将接收消息。 |'
- en: '| The producer does not need to run at the time the consumer consumes the message,
    nor does the consumer need to run at the time the message is sent. | The publisher
    has to create a message topic for clients to subscribe. The subscriber has to
    remain continuously active to receive messages unless he has established a durable
    subscription. In that case, messages published while the subscriber is not connected
    will be redistributed whenever he reconnects. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 生产者不需要在消费者消费消息时运行，消费者也不需要在消息发送时运行。 | 发布者必须为客户端创建一个消息主题，以便订阅。订阅者必须持续活跃以接收消息，除非他已经建立了持久订阅。在这种情况下，当订阅者未连接时发布的消息将在他重新连接时重新分发。
    |'
- en: '| Every message successfully processed is acknowledged by the consumer. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 每条成功处理的消息都会被消费者确认。 |'
- en: JBoss AS has used different JMS implementations across its releases. Since the
    release of Version 6.0, the default JMS provider is HornetQ ([http://www.jboss.org/hornetq](http://www.jboss.org/hornetq)),
    which provides a multi-protocol, embeddable, high-performance, clustered, asynchronous
    messaging system.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: JBoss AS在其各个版本中使用了不同的JMS实现。自6.0版本发布以来，默认的JMS提供者是HornetQ ([http://www.jboss.org/hornetq](http://www.jboss.org/hornetq))，它提供了一个多协议、可嵌入、高性能、集群的异步消息系统。
- en: At its core, HornetQ is designed simply as a set of **Plain** **Old** **Java**
    **Objects** (**POJOs**). It has only one JAR dependency, the Netty library, which
    leverages the Java **Non-blocking** **Input/Output** (**NIO**) API to build high-performance
    network applications.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，HornetQ被设计成一套**纯****旧****Java****对象**（**POJOs**）。它只有一个JAR依赖项，即Netty库，该库利用Java
    **非阻塞** **输入/输出**（**NIO**）API来构建高性能网络应用程序。
- en: Note
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Because of its easily adaptable architecture, HornetQ can be embedded in your
    own project or instantiated in any dependency injection framework, such as Spring
    or Google Guice.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其易于适应的架构，HornetQ可以嵌入到您的项目中，也可以在任何依赖注入框架中实例化，例如Spring或Google Guice。
- en: 'In this book, we will cover the scenario where HornetQ is embedded into a WildFly
    subsystem as a module. The following diagram shows how the HornetQ server fits
    in the overall picture:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将介绍HornetQ作为模块嵌入到WildFly子系统中的场景。以下图表显示了HornetQ服务器在整个系统中的位置：
- en: '![Configuring the messaging system](img/6232OS_03_07.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![配置消息系统](img/6232OS_03_07.jpg)'
- en: As you can see, a key part of the HornetQ integration is the **JCA** **Adaptor**
    that handles the communication between the application server and the HornetQ
    server.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，HornetQ集成的一个关键部分是处理应用程序服务器和HornetQ服务器之间通信的**JCA****适配器**。
- en: Tip
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Why can''t you simply connect your resources to the HornetQ server?**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么你不能简单地将你的资源连接到HornetQ服务器？**'
- en: This is theoretically possible; however, it violates Java EE specifications
    and will result in the loss of functionalities provided by the application server's
    JCA layer, such as connection pooling and automatic transaction enlistment. These
    functionalities are desirable when using messaging, say, from inside an EJB. For
    a description of JCA thread-pooling configuration, refer to the *The bounded-queue
    thread pool* section in [Chapter 2](ch02.html "Chapter 2. Configuring the Core
    WildFly Subsystems"), *Configuring the Core WildFly Subsystems*.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这在理论上是可能的；然而，它违反了Java EE规范，并将导致丢失应用程序服务器JCA层提供的功能，例如连接池和自动事务注册。当使用消息传递时，例如在EJB内部，这些功能是可取的。有关JCA线程池配置的描述，请参阅[第2章](ch02.html
    "第2章。配置核心WildFly子系统")中的*“有界队列线程池”*部分，*“配置核心WildFly子系统”*。
- en: Configuring the transport
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置传输
- en: Configuring the transport of a JMS message is a key part of the messaging system
    tuning. Out of the box, HornetQ uses Netty as its high-performance, low-level
    network library. Netty is a NIO client-server framework, which enables quick and
    easy development of network applications, such as **protocol** **servers** and
    **clients**. It greatly simplifies and streamlines network programming, such as
    those of the TCP and UDP socket servers.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 配置JMS消息的传输是消息系统调优的关键部分。默认情况下，HornetQ使用Netty作为其高性能、低级别的网络库。Netty是一个NIO客户端-服务器框架，它使得快速轻松地开发网络应用程序成为可能，例如**协议****服务器**和**客户端**。它极大地简化并简化了网络编程，例如TCP和UDP套接字服务器。
- en: One of the most important concepts in HornetQ transport is the definition of
    acceptors and connectors.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: HornetQ传输中最重要的概念之一是接受者和连接器的定义。
- en: An **acceptor** defines which type of connection is accepted by the HornetQ
    server. On the other hand, a **connector** defines how to connect to a HornetQ
    server. The connector is used by a HornetQ client.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**接受者**定义了HornetQ服务器接受的连接类型。另一方面，**连接器**定义了如何连接到HornetQ服务器。连接器由HornetQ客户端使用。'
- en: 'HornetQ defines three types of acceptors and connectors:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: HornetQ定义了三种类型的接受者和连接器：
- en: '**inVM**: This type can be used when both the HornetQ client and the server
    run in the same virtual machine (inVM stands for intra virtual machine)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**inVM**：当HornetQ客户端和服务器都在同一虚拟机中运行时，可以使用此类型（inVM代表虚拟机内部）'
- en: '**Netty**: This type defines a way for remote connections to be made over TCP
    (uses the Netty project to handle the I/O)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Netty**：此类型定义了通过TCP进行远程连接的方式（使用Netty项目处理I/O）'
- en: '**http**: This type is the default configuration in WildFly and defines a way
    for remote connections to be made to HornetQ over HTTP (it uses Undertow to upgrade
    from the HTTP protocol to the HornetQ protocol)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**http**：这是WildFly的默认配置，它定义了通过HTTP将远程连接到HornetQ的方式（它使用Undertow将HTTP协议升级到HornetQ协议）'
- en: 'To communicate, a HornetQ client must use a connector compatible with the server''s
    acceptor. A compatible client-server communication requires that it is carried
    out using the same type of acceptor/connector shown by the following diagram:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行通信，HornetQ客户端必须使用与服务器接受者兼容的连接器。兼容的客户端-服务器通信要求使用以下图中显示的相同类型的接受者/连接器进行：
- en: '![Configuring the transport](img/6232OS_03_08.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![配置传输](img/6232OS_03_08.jpg)'
- en: We can see that it's not possible to connect an InVM client connector to a Netty
    server acceptor. On the other hand, it's possible to connect a HTTP client connector
    to a HTTP server acceptor provided they are configured to run on the same host
    and port.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，无法将InVM客户端连接器连接到Netty服务器接受者。另一方面，如果它们配置在相同的主机和端口上运行，则可以将HTTP客户端连接器连接到HTTP服务器接受者。
- en: 'WildFly 8 comes with a preconfigured acceptor/connector pair that is part of
    the WildFly messaging subsystem, as shown in the following code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: WildFly 8自带一个预配置的接受者/连接器对，它是WildFly消息子系统的组成部分，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, besides the `in-vm` acceptor/connector pair, each section defines
    two kinds of acceptors/connectors, one of which relies on the default configuration,
    `http-connector`, and the other one (`http-acceptor-throughput`) is specialized
    for higher messaging throughputs.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，除了`in-vm`接受者/连接器对之外，每个部分都定义了两种类型的接受者/连接器，其中一种依赖于默认配置`http-connector`，另一种（`http-acceptor-throughput`）是针对更高的消息吞吐量而专门设计的。
- en: 'You can further tune HTTP transport when you have a more complete knowledge
    of the parameters that can be added to the acceptor/connector section. Here''s
    a comprehensive list of all parameters and their meanings:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当您对可以添加到接受者/连接器部分的参数有更完整的了解时，您可以进一步调整HTTP传输。以下是一个所有参数及其含义的完整列表：
- en: '| Parameter | Description |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `use-nio` | If this is `true`, then Java non-blocking I/O will be used. If
    set to `false`, then the old blocking Java I/O will be used. The default value
    is `true`. |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `use-nio` | 如果此值为`true`，则将使用Java非阻塞I/O。如果设置为`false`，则将使用旧的阻塞Java I/O。默认值为`true`。
    |'
- en: '| `host` | This specifies the host name or IP address to connect to (when configuring
    a connector) or to listen on (when configuring an acceptor). The default value
    for this property is `localhost`. Multiple hosts or IP addresses can be specified
    by separating them with commas. |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `host` | 此属性指定要连接到的主机名或IP地址（在配置连接器时）或要监听的主机名（在配置接受者时）。此属性的默认值是`localhost`。可以通过逗号分隔来指定多个主机或IP地址。
    |'
- en: '| `port` | This specifies the port to connect to (when configuring a connector)
    or to listen on (when configuring an acceptor). The default value for this property
    is `5445`. |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `port` | 此属性指定要连接到的端口（在配置连接器时）或要监听的端口（在配置接受者时）。此属性的默认值是`5445`。 |'
- en: '| `tcp-no-delay` | If this is `true`, then Nagle''s algorithm will be disabled.
    The default value for this property is `true`. |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `tcp-no-delay` | 如果此值为`true`，则将禁用Nagle算法。此属性的默认值是`true`。 |'
- en: '| `tcp-send-buffer-size` | This parameter determines the size of the TCP send
    buffer in bytes. The default value for this property is `32768` bytes. |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `tcp-send-buffer-size` | 此参数确定TCP发送缓冲区的大小（以字节为单位）。此属性的默认值是`32768`字节。 |'
- en: '| `tcp-receive-buffer-size` | This parameter determines the size of the TCP
    receive buffer in bytes. The default value for this property is `32768` bytes.
    |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `tcp-receive-buffer-size` | 此参数决定了 TCP 接收缓冲区的大小，单位为字节。此属性的默认值是 `32768` 字节。|'
- en: '| `batch-delay` | This parameter lets you configure HornetQ so that messages
    are batched up to be written for a maximum of batch-delay milliseconds before
    sending them for transport. This can increase overall throughput for very small
    messages. The default value for this property is `0` ms. |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `batch-delay` | 此参数允许你配置 HornetQ，以便在发送传输之前将消息批量写入，最多延迟 batch-delay 毫秒。这可以增加非常小的消息的整体吞吐量。此属性的默认值是
    `0` 毫秒。|'
- en: '| `direct-deliver` | This parameter lets you configure whether message delivery
    is done using the same thread as the one that carried the message. Setting this
    to `true` (default) reduces the thread context switch''s latency at the expense
    of message throughput. If your goal is a higher throughput, set this parameter
    to `false`. |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `direct-deliver` | 此参数允许你配置消息投递是否使用携带消息的同一线程完成。将此设置为 `true`（默认值）会以牺牲消息吞吐量为代价减少线程上下文切换的延迟。如果你的目标是更高的吞吐量，请将此参数设置为
    `false`。|'
- en: '| `nio-remoting-threads` | When using NIO, HornetQ will, by default, use a
    number of threads equal to three times the number of core processors required
    to process incoming packets. If you want to override this value, you can set the
    number of threads by specifying this parameter. The default value for this parameter
    is `-1`, which means use the value derived from `Runtime.getRuntime().availableProcessors()
    * 3`. |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `nio-remoting-threads` | 当使用 NIO 时，HornetQ 默认将使用等于处理传入数据包所需核心处理器数量的三倍的线程数。如果你想覆盖此值，你可以通过指定此参数来设置线程数。此参数的默认值是
    `-1`，表示使用从 `Runtime.getRuntime().availableProcessors() * 3` 计算得出的值。|'
- en: '| `http-client-idle-time` | This determines how long a client can be idle before
    sending an empty HTTP request to keep the connection alive. |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `http-client-idle-time` | 这决定了客户端在发送一个空的 HTTP 请求以保持连接活跃之前可以空闲多长时间。|'
- en: '| `http-client-idle-scan-period` | This determines how often we can scan for
    idle clients, in milliseconds |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `http-client-idle-scan-period` | 这决定了我们多久可以扫描一次空闲客户端，单位为毫秒。|'
- en: '| `http-response-time` | This determines how long the server can wait before
    sending an empty HTTP response to keep the connection alive. |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `http-response-time` | 这决定了服务器在发送一个空的 HTTP 响应以保持连接活跃之前可以等待多长时间。|'
- en: '| `http-server-scan-period` | This determines how often we can scan for clients
    needing responses, in milliseconds. |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `http-server-scan-period` | 这决定了我们多久可以扫描一次需要响应的客户端，单位为毫秒。|'
- en: '| `http-requires-session-id` | If `true`, the client will wait after the first
    call to receive a session ID. |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `http-requires-session-id` | 如果设置为 `true`，客户端在第一次调用后将会等待以接收一个会话 ID。|'
- en: 'One frequent source of confusion among HornetQ users is why connectors are
    included in the server configuration if the server is in charge of accepting connections
    and delivering messages. There are two main reasons for this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HornetQ 用户中，一个常见的混淆来源是，如果服务器负责接受连接和投递消息，为什么连接器会被包含在服务器配置中。这主要有两个原因：
- en: Sometimes the server acts as a client itself when it connects to another server,
    for example, when one server is bridged to another or when a server takes part
    in a cluster. In these cases, the server needs to know how to connect to other
    servers. That's defined by connectors.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时服务器在连接到另一个服务器时会充当客户端本身，例如，当一个服务器桥接到另一个服务器或服务器参与集群时。在这些情况下，服务器需要知道如何连接到其他服务器。这是由连接器定义的。
- en: If you're using JMS and the server-side JMS services to instantiate JMS `ConnectionFactory`
    instances and bind them in JNDI then, when creating the `HornetQConnectionFactory`,
    it needs to know what server that connection factory will create connections to.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在使用 JMS 以及服务器端的 JMS 服务来实例化 JMS `ConnectionFactory` 实例并将它们绑定到 JNDI，那么在创建
    `HornetQConnectionFactory` 时，它需要知道该连接工厂将连接到哪个服务器。
- en: Configuring connection factories
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置连接工厂
- en: 'A JMS `ConnectionFactory` object is used by the client to make connections
    to the server. The definition of `connection-factory` instances is included in
    the default server configuration. Take a look at the following code:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端使用 JMS `ConnectionFactory` 对象来连接到服务器。`connection-factory` 实例的定义包含在默认服务器配置中。请查看以下代码：
- en: '[PRE20]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can find two connection factory definitions, which are as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以找到两个连接工厂定义，具体如下：
- en: '`InVmConnectionFactory`: This connection factory is bound under `java:/ConnectionFactory`
    and is used when the server and the client are running in the same JVM (and hence
    in the same WildFly server)'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InVmConnectionFactory`：此连接工厂绑定到 `java:/ConnectionFactory`，并在服务器和客户端在同一个JVM（因此在同一WildFly服务器）中运行时使用。'
- en: '`RemoteConnectionFactory`: This connection factory, as the name implies, can
    be used when JMS connections are provided by a remote server. By default, this
    uses `http-connector` and is bound by the JNDI name, `java:jboss/exported/jms/RemoteConnectionFactory`.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoteConnectionFactory`：正如其名所示，当JMS连接由远程服务器提供时可以使用此连接工厂。默认情况下，它使用 `http-connector`
    并绑定到JNDI名称，`java:jboss/exported/jms/RemoteConnectionFactory`。'
- en: Configuring JMS destinations
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置JMS目的地
- en: 'Along with the definition of connection factories in the JMS subsystem, you
    can find the JMS destinations (queues and topics), which are part of the server
    distribution. Have a look at the following code:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在JMS子系统中的连接工厂定义之外，您还可以找到JMS目的地（队列和主题），它们是服务器分发的一部分。请看以下代码：
- en: '[PRE21]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `name` attribute of a queue defines the name of the queue. At the JMS level,
    the actual name of the queue follows a naming convention, so it will be `jms.queue.ExpiryQueue`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 队列的 `name` 属性定义了队列的名称。在JMS级别，队列的实际名称遵循命名约定，因此将是 `jms.queue.ExpiryQueue`。
- en: The `entry` element configures the name that will be used to bind the queue
    to JNDI. This is a mandatory element, and the queue can contain many of these
    to bind the same queue to different names.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`entry` 元素配置用于将队列绑定到JNDI的名称。这是一个强制性的元素，队列可以包含多个此类元素以将同一队列绑定到不同的名称。'
- en: 'So, for example, here''s how you would configure a `MessageDrivenBean` component
    to consume messages from the `ExpiryQueue`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是配置 `MessageDrivenBean` 组件以从 `ExpiryQueue` 消费消息的方法：
- en: '[PRE22]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Tip
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Why is it useful to know the actual destination name?**'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么知道实际的目的地名称是有用的？**'
- en: Apparently, it seems not important at all to know the server's destination name
    (in the example, `jms.queue.ExpiryQueue`). Rather, we would be concerned about
    the JNDI entry where the destination is bound. However, the actual destination
    name plays an important role if you want to define some properties across a set
    of destinations. See the next section, *Customizing destinations with an address*,
    for more information.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，了解服务器的目的地名称（例如，`jms.queue.ExpiryQueue`）似乎并不重要。我们更关心目的地绑定的JNDI条目。然而，如果要在多个目的地之间定义一些属性，实际的目的地名称就非常重要了。有关更多信息，请参阅下一节，*使用地址自定义目的地*。
- en: 'Queues and topic definitions can optionally include some non-mandatory elements,
    such as `selector` and `durable`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 队列和主题定义可以包含一些非强制性的元素，例如 `selector` 和 `durable`：
- en: '[PRE23]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `selector` element defines what JMS message selector the predefined queue
    will have. Only messages that match the selector will be added to the queue. This
    is an optional element with a default value of `null` when omitted.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`selector` 元素定义了预定义队列将具有的JMS消息选择器。只有与选择器匹配的消息才会被添加到队列中。这是一个可选元素，省略时默认值为 `null`。'
- en: The `durable` element specifies whether or not the queue will be persisted.
    This again is optional and defaults to `true` if omitted.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`durable` 元素指定队列是否将被持久化。这同样是可选的，如果省略则默认为 `true`。'
- en: Customizing destinations with an address
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用地址自定义目的地
- en: 'If you want to provide some custom settings for JMS destinations, you can use
    the `address-setting` block, which can be applied both to a single destination
    and to a set of destinations. The default configuration applies a set of minimal
    attributes to all destinations. Have a look at the following code:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想为JMS目的地提供一些自定义设置，可以使用 `address-setting` 块，该块可以应用于单个目的地和一组目的地。默认配置将一组最小属性应用于所有目的地。请看以下代码：
- en: '[PRE24]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here is a brief description of the address settings.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是关于地址设置的简要描述。
- en: 'The address setting''s `match` attribute defines a filter for the destinations.
    When using the wildcard, `#`, the properties will be valid across all destinations.
    For example:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 地址设置的 `match` 属性定义了目的地的过滤器。当使用通配符 `#` 时，属性将适用于所有目的地。例如：
- en: '[PRE25]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, the settings would apply to all queues defined in the `destination` section:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，这些设置将应用于 `destination` 部分中定义的所有队列：
- en: '[PRE26]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The settings would apply to the queue named `jms.queue.ExpiryQueue`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置将应用于名为 `jms.queue.ExpiryQueue` 的队列。
- en: 'A short description of the destination''s properties is as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 目的地属性的简短描述如下：
- en: '| Property | Description |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `dead-letter-address` | This specifies the destination for messages that
    could not be delivered. |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `dead-letter-address` | 这指定了无法投递的消息的目的地。 |'
- en: '| `expiry-address` | This defines where to send a message that has expired.
    |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `expiry-address` | 这定义了将过期消息发送到何处。 |'
- en: '| `expiry-delay` | This defines the expiration time that will be used for messages
    using the default expiration time. |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| `expiry-delay` | 这定义了使用默认过期时间的消息的过期时间。 |'
- en: '| `redelivery-delay` | This defines how long to wait before attempting redelivery
    of a cancelled message. |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| `redelivery-delay` | 这定义了在尝试重新投递取消的消息之前应等待多长时间。 |'
- en: '| `max-size-bytes` | This specifies the maximum size of the message in bytes
    before entering the `page` mode. |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| `max-size-bytes` | 这指定了在进入`page`模式之前消息的最大字节数。 |'
- en: '| `page-size-bytes` | This specifies the size of each page file used on the
    paging system. |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `page-size-bytes` | 这指定了分页系统中每个页面文件的大小。 |'
- en: '| `max-delivery-attempts` | This defines how many times a cancelled message
    can be redelivered before it is sent to the `dead-letter-address`. |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `max-delivery-attempts` | 这定义了在将取消的消息发送到`dead-letter-address`之前，可以重新投递消息的次数。
    |'
- en: '| `message-counter-history-day-limit` | This specifies how many days the message
    counter history will be kept. |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| `message-counter-history-day-limit` | 这指定了消息计数器历史记录将保留多少天。 |'
- en: '| `address-full-policy` | This is used when a destination maximum size is reached.
    When set to `PAGE`, further messages will be paged to the disk. If the value is
    `DROP`, further messages will be silently dropped. When `BLOCK` is used, client
    message producers will be blocked when they try to send further messages. |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| `address-full-policy` | 当达到目的地最大大小时使用此选项。当设置为`PAGE`时，进一步的消息将被分页到磁盘。如果值为`DROP`，进一步的消息将被静默丢弃。当使用`BLOCK`时，客户端消息生产者在尝试发送进一步的消息时将被阻塞。
    |'
- en: HornetQ persistence configuration
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HornetQ持久化配置
- en: The last HornetQ topic we need to cover is message persistence. HornetQ has
    its own optimized persistence engine, which can be further configured when you
    know all about its various components.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要讨论的最后一个HornetQ主题是消息持久化。HornetQ拥有自己的优化持久化引擎，当您了解其各种组件的所有信息时，可以进一步配置。
- en: Note
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The secret of HornetQ's high data persistence consists in appending data to
    the journal files instead of using the costly random-access operations, which
    require a higher degree of disk-head movement.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: HornetQ高数据持久化的秘密在于将数据附加到日志文件，而不是使用昂贵的随机访问操作，这需要更高的磁盘头移动程度。
- en: Journal files are precreated and filled with padding characters at runtime.
    By precreating files, as one is filled, the journal can immediately resume with
    the next one without pausing to create it.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 日志文件在运行时预先创建并填充了填充字符。通过预先创建文件，当其中一个被填满时，日志可以立即使用下一个文件继续，而无需暂停创建它。
- en: The following are the default journal values for the messaging subsystem. Although
    these values are not explicitly set in the `standalone-full.xml` file, their absence
    causes these default values to be used.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为消息子系统设置的默认日志值。尽管这些值在`standalone-full.xml`文件中没有明确设置，但它们的缺失会导致使用这些默认值。
- en: '[PRE27]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The default `journal-file-size` (expressed in bytes) is `100` KB. The minimum
    number of files the journal will maintain is indicated by the property `journal-min-files`,
    which states that at least two files will be maintained.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的`journal-file-size`（以字节为单位）是`100` KB。日志将维护的最小文件数由属性`journal-min-files`指示，该属性表示至少将维护两个文件。
- en: The property `journal-type` indicates the type of input/output libraries used
    for data persistence. The valid values are `NIO` or `ASYNCIO`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 属性`journal-type`指示用于数据持久化的输入/输出库的类型。有效的值是`NIO`或`ASYNCIO`。
- en: Choosing `NIO` sets the Java NIO journal. Choosing `AIO` sets the Linux asynchronous
    I/O journal. If you choose `AIO` but are not running Linux or you do not have
    `libaio` installed, then HornetQ will detect this and automatically fall back
    to using `NIO`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 选择`NIO`将设置Java NIO日志。选择`AIO`将设置Linux异步I/O日志。如果您选择`AIO`但未运行Linux或未安装`libaio`，则HornetQ将检测到这一点并自动回退到使用`NIO`。
- en: The `persistence-enabled` property, when set to `false`, will disable message
    persistence. That means no binding data, message data, large message data, duplicate
    ID caches, or paging data will be persisted. Disabling data persistence will give
    to your applications a remarkable performance boost; however, the other side of
    it is that your data messaging will inevitably lose reliability.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当`persistence-enabled`属性设置为`false`时，将禁用消息持久化。这意味着不会持久化绑定数据、消息数据、大消息数据、重复ID缓存或分页数据。禁用数据持久化将给您的应用程序带来显著的性能提升；然而，其另一面是您的数据消息不可避免地会失去可靠性。
- en: 'For the sake of completeness, we include some additional properties that can
    be included if you want to customize the messages/paging and journal storage directories.
    Have a look at the following code:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，我们包括一些额外的属性，如果您想自定义消息/分页和日志存储目录，可以包含这些属性。请查看以下代码：
- en: '[PRE28]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: For best performance, we recommend that the journal be located on its own physical
    volume in order to minimize disk-head movement. If the journal is on a volume
    that is shared with other processes, which might be writing other files (for example,
    bindings journal, database, or transaction coordinator), then the disk-head might
    move rapidly between these files as it writes them, thus drastically reducing
    performance.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得最佳性能，我们建议将日志存储在其自己的物理卷上，以最小化磁盘头移动。如果日志位于与其他进程共享的卷上，这些进程可能正在写入其他文件（例如，绑定日志、数据库或事务协调器），那么磁盘头在写入这些文件时可能会在这些文件之间快速移动，从而大幅降低性能。
- en: Configuring the transactions service
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置事务服务
- en: A transaction can be defined as a group of operations that must be performed
    as a unit and can involve persisting data objects, sending a message, and so on.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 事务可以被定义为必须作为一个单元执行的一组操作，可能包括持久化数据对象、发送消息等。
- en: When the operations in a transaction are performed across databases or other
    resources that reside on separate computers or processes, this is known as a distributed
    transaction. Such enterprise-wide transactions require special coordination between
    the resources involved and can be extremely difficult to program reliably. This
    is where **Java Transaction API** (**JTA**) comes in, providing the interface
    that resources can implement and to which they can bind in order to participate
    in a distributed transaction.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当事务中的操作跨越数据库或其他位于单独计算机或进程上的资源执行时，这被称为分布式事务。此类企业级事务需要在涉及的资源之间进行特殊协调，并且可能非常难以可靠地编程。这就是**Java事务API**（**JTA**）发挥作用的地方，它提供了资源可以实现的接口，并且它们可以绑定以参与分布式事务。
- en: The EJB container is a transaction manager that supports JTA and so can participate
    in distributed transactions involving other EJB containers as well as third-party
    JTA resources, such as many database management systems.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: EJB 容器是一个支持JTA的事务管理器，因此可以参与涉及其他EJB容器以及第三方JTA资源（如许多数据库管理系统）的分布式事务。
- en: 'Within WildFly 8, transactions are configured in their own subsystem. The transactions
    subsystem consists mainly of four elements:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在WildFly 8中，事务在其自己的子系统中进行配置。事务子系统主要由以下四个元素组成：
- en: Core environment
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心环境
- en: Recovery environment
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恢复环境
- en: Coordinator environment
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协调器环境
- en: Object store
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象存储
- en: 'The core environment includes the `TransactionManager` interface, which allows
    the application server to control the transaction boundaries on behalf of the
    resource being managed. Have a look at the following diagram:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 核心环境包括`TransactionManager`接口，该接口允许应用程序服务器代表被管理的资源控制事务边界。请查看以下图示：
- en: '![Configuring the transactions service](img/6232OS_03_09.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![配置事务服务](img/6232OS_03_09.jpg)'
- en: A transaction coordinator, in turn, manages communication with transactional
    objects and resources that participate in transactions.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 事务协调器反过来管理参与事务的事务对象和资源的通信。
- en: The recovery subsystem of JBossTS ensures that the results of a transaction
    are applied consistently to all resources affected by the transaction even if
    any of the application processes or the machine hosting them crashes or loses
    network connectivity.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: JBossTS的恢复子系统确保事务的结果一致地应用于受事务影响的所有资源，即使任何应用程序进程或托管它们的机器崩溃或失去网络连接。
- en: Within the transaction service, JBoss transaction service uses an object store
    to persistently record the outcomes of transactions for failure recovery. As a
    matter of fact, the recovery manager scans the object store and other locations
    of information looking for transactions and resources that require or might require
    recovery.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在事务服务中，JBoss事务服务使用对象存储来持久记录事务的结果以进行故障恢复。事实上，恢复管理器扫描对象存储和其他信息位置，寻找需要或可能需要恢复的事务和资源。
- en: The core and recovery environments can be customized by changing their socket-binding
    properties, which are referenced in the `socket-binding-group` configuration section.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 核心和恢复环境可以通过更改它们的套接字绑定属性进行自定义，这些属性在`socket-binding-group`配置部分中引用。
- en: 'You might find it more useful to define custom properties in the coordinator
    environment section, which might include the default timeout and logging statistics.
    Here''s a sample custom transaction configuration:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会发现定义自定义属性在协调器环境部分更有用，这可能包括默认超时和日志统计信息。以下是一个示例自定义事务配置：
- en: '[PRE29]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The value of `default-timeout` specifies the default transaction timeout to
    be used for new transactions, which is specified as an integer in seconds.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`default-timeout`的值指定了用于新事务的默认事务超时，该值以秒为整数指定。'
- en: Tip
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**How does the transaction timeout impact your** **applications?**'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**事务超时如何影响您的** **应用程序**？'
- en: The transaction timeout defines the timeout for all JTA transactions enlisted
    and thus severely affects your application behavior. A typical JTA transaction
    might be started by your EJBs or by a JMS session. So, if the duration of these
    transactions exceeds the specified timeout setting, the transaction service will
    roll back the transactions automatically.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 事务超时定义了所有JTA事务注册的超时时间，从而严重影响了您的应用程序行为。一个典型的JTA事务可能由您的EJB或JMS会话启动。因此，如果这些事务的持续时间超过指定的超时设置，事务服务将自动回滚事务。
- en: The value of `statistics-enabled` determines whether or not the transaction
    service should gather statistical information. The default is to not gather this
    information.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`statistics-enabled`的值决定了事务服务是否应该收集统计信息。默认情况下不收集此信息。'
- en: Tip
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In WildFly, the `enable-statistics` property has been deprecated in favor of
    `statistics-enabled`. If you are migrating from JBoss AS 7, the deprecated property
    will still work but may be removed in future releases.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在WildFly中，`enable-statistics`属性已被弃用，以`statistics-enabled`属性取而代之。如果您从JBoss AS
    7迁移，则弃用的属性仍然有效，但可能在未来的版本中删除。
- en: Configuring concurrency
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置并发
- en: Concurrency utilities is new to WildFly 8\. As part of Java EE 7, are aim is
    to ease the task of multithreading within enterprise applications. Prior to Java
    EE 7, there was no safe way to create a new thread programmatically in your application.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 并发实用工具是WildFly 8的新功能。作为Java EE 7的一部分，我们的目标是简化企业应用程序中的多线程任务。在Java EE 7之前，没有安全的方法在应用程序中以编程方式创建新线程。
- en: With the new concurrency utilities, your new threads are now guaranteed to have
    access to other enterprise services, such as transactions, and security.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的并发实用工具，您的新线程现在可以保证访问其他企业服务，例如事务和安全。
- en: 'The main concurrency components are:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 主要并发组件包括：
- en: '`ContextService`'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ContextService`'
- en: '`ManagedThreadFactory`'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ManagedThreadFactory`'
- en: '`ManagedExecutorService`'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ManagedExecutorService`'
- en: '`ManagedScheduledExecutorService`'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ManagedScheduledExecutorService`'
- en: Configuring the context service
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置上下文服务
- en: 'The context service is used to create contextual proxies from existent objects
    and is configured within the `ee` module of WildFly. The following is the default
    configuration in WildFly:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文服务用于从现有对象创建上下文代理，并在WildFly的`ee`模块中进行配置。以下是在WildFly中的默认配置：
- en: '[PRE30]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `name` attribute is the name of your context service, and the `use-transaction-setup-provider`
    attribute states whether or not the contextual proxies should suspend and resume
    active transactions.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`属性是您的上下文服务名称，而`use-transaction-setup-provider`属性表示上下文代理是否应该挂起和恢复活动事务。'
- en: Configuring the managed thread factory
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置托管线程工厂
- en: 'The `ManagedThreadFactory` component is used to create threads that are managed
    by the container. The default configuration is as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`ManagedThreadFactory`组件用于创建由容器管理的线程。默认配置如下：'
- en: '[PRE31]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To use the default thread factory in your Java code, simply use the `@Resource`
    annotation without providing a value for the `lookup` attribute, as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Java代码中使用默认的线程工厂，只需使用`@Resource`注解，而不为`lookup`属性提供值，如下所示：
- en: '[PRE32]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Configuring the managed executor service
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置托管执行器服务
- en: 'This class is used to execute tasks in a second thread within your enterprise
    application. You should always use this in preference over the executor service
    found within Java SE libraries. Here is an example of the configuration in WildFly:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 此类用于在您的企业应用程序中执行第二个线程的任务。您应该始终优先使用此服务，而不是Java SE库中找到的执行器服务。以下是在WildFly中的配置示例：
- en: '[PRE33]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following is the full list of attributes you can use to configure your
    `managed-executor-service` in WildFly:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在WildFly中配置您的`managed-executor-service`可以使用的完整属性列表：
- en: '| `context-service` | This defines which context service to use. |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| `context-service` | 这定义了要使用哪个上下文服务。 |'
- en: '| `core-threads` | This defines the number of threads within the executors
    thread pool, including idle threads. |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| `core-threads` | 这定义了执行器线程池中的线程数，包括空闲线程。 |'
- en: '| `hung-task-threshold` | This specifies how long, in milliseconds, the threads
    can be allowed to run before they are considered unresponsive. |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| `hung-task-threshold` | 这指定了在将线程视为无响应之前，线程可以运行多长时间（以毫秒为单位）。 |'
- en: '| `jndi-name` | This specifies the JNDI name for this resource. |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| `jndi-name` | 这指定了此资源的JNDI名称。 |'
- en: '| `keepalive-time` | This specifies how long threads can remain idle when the
    number of threads is greater than the core thread size. |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| `keepalive-time` | 这指定了当线程数大于核心线程大小时，线程可以保持空闲的时间长度。 |'
- en: '| `long-running-tasks` | This checks whether the thread is a short-running
    or long-running thread. |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| `long-running-tasks` | 这用于检查线程是短运行线程还是长运行线程。 |'
- en: '| `max-threads` | This specifies the maximum number of threads to allow in
    the executor''s pool. |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| `max-threads` | 这指定了执行器池中允许的最大线程数。 |'
- en: '| `name` | This specifies the name of the resource. |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| `name` | 这指定了资源的名称。 |'
- en: '| `queue-length` | This specifies the number of tasks that can be stored in
    the input queue. Zero means unlimited. |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| `queue-length` | 这指定了可以存储在输入队列中的任务数。零表示无限。 |'
- en: '| `reject-policy` | This defines how you can handle a failed task. An `ABORT`
    value will cause an exception to be thrown; `RETRY_ABORT`, which will cause a
    retry, and then an abort if the retry fails. |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| `reject-policy` | 这定义了如何处理失败的任务。`ABORT`值将导致抛出异常；`RETRY_ABORT`，这将导致重试，如果重试失败则终止。
    |'
- en: '| `thread-factory` | This specifies the name of the thread factory. If it''s
    not supplied, the default thread factory is used. |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| `thread-factory` | 这指定了线程工厂的名称。如果没有提供，则使用默认的线程工厂。 |'
- en: Configuring the managed schedule executor service
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置托管调度执行器服务
- en: 'This is the same as the `ManagedExecutorService`, except that it has additional
    functionality allowing you to schedule a thread to start at specific times. Here
    is an example of the configuration:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`ManagedExecutorService`相同，但它具有额外的功能，允许您在特定时间安排线程启动。以下是一个配置示例：
- en: '[PRE34]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The following is the list of attributes that can be used to configure your `managed-scheduled-executor-service`.
    Please see the preceding table in the `managed-executor-service` section for details
    of each property.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以用于配置您的`managed-scheduled-executor-service`的属性列表。请参阅`managed-executor-service`部分前面的表格，以了解每个属性的详细信息。
- en: '`context-service`'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context-service`'
- en: '`core-threads`'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`core-threads`'
- en: '`hung-task-threshold`'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hung-task-threshold`'
- en: '`jndi-name`'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jndi-name`'
- en: '`keepalive-time`'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keepalive-time`'
- en: '`long-running-tasks`'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long-running-tasks`'
- en: '`name`'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`'
- en: '`reject-policy`'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reject-policy`'
- en: '`thread-factory`'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thread-factory`'
- en: Summary
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we continued the analysis of the application server configuration
    by looking at Java's enterprise services.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们继续分析应用服务器配置，通过查看Java的企业服务。
- en: 'We first learned how to configure datasources, which can be used to add database
    connectivity to your applications. Installing a datasource in WildFly 8 requires
    two simple steps: installing the JDBC driver and adding the datasource into the
    server configuration.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先学习了如何配置数据源，这可以用于将数据库连接添加到您的应用程序中。在WildFly 8中安装数据源需要两个简单的步骤：安装JDBC驱动程序并将数据源添加到服务器配置中。
- en: We then looked at the enterprise JavaBeans subsystem, which allows you to configure
    and tune your EJB container. We looked at the basic EJB component configurations
    (SLSB, SFSB, and MDB) and then looked at the EJB timer service configuration that
    can be used to provide time-based services to your applications.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着看了企业JavaBeans子系统，它允许您配置和调整您的EJB容器。我们研究了基本的EJB组件配置（SLSB、SFSB和MDB），然后研究了可以用来为您的应用程序提供基于时间的服务的EJB定时器服务配置。
- en: Next, we described the configuration of the message-oriented middleware, which
    allows you to loosely couple heterogeneous systems together while typically providing
    reliability, transactions, and various other features.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们描述了面向消息的中间件的配置，它允许您将异构系统松散耦合在一起，同时通常提供可靠性、事务以及各种其他功能。
- en: Then we moved on to the transaction subsystem configuration, which can be used
    to collect transaction logs and define the timeout for all JTA transactions enlisted.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们转向事务子系统配置，它可以用来收集事务日志并定义所有JTA事务的超时时间。
- en: Finally, we completed our journey by taking a look at how to configure concurrency
    within WildFly using the `ee` subsystem.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过查看如何使用`ee`子系统在WildFly中配置并发性来完成我们的旅程。
- en: In the next chapter, we will discuss the web container configuration, providing
    a complete example, that uses a variety of enterprise technologies, and focusing
    on the structure and the packaging of the application.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论Web容器配置，提供一个完整的示例，该示例使用各种企业技术，并关注应用程序的结构和打包。
