- en: '*Chapter 11*: Decomposing into Finer-Grained Components'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 11 章*：分解为更细粒度的组件'
- en: In the previous chapter, we decomposed the *LC Application Processing* functionality
    out of the monolith. In this chapter, we will further decompose these components
    into even more fine-grained components. In addition, we will examine if and when
    such a decomposition is justified.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们将 *LC 应用处理* 功能从单体应用中分解出来。在本章中，我们将进一步将这些组件分解为更细粒度的组件。此外，我们还将探讨何时以及是否应该进行这种分解。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Continuing our design journey
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续我们的设计之旅
- en: Even more fine-grained decomposition
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更细粒度的分解
- en: Decomposing the frontend
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端的分解
- en: Where to draw the line
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪里应该划线
- en: At the end of this chapter, you will be able to appreciate both technical and
    non-technical factors that play toward where we should draw the line on decomposing
    these components.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将能够欣赏到在决定如何分解这些组件时，技术因素和非技术因素所起的作用。
- en: Continuing our design journey
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续我们的设计之旅
- en: 'Currently, our application resembles the diagram depicted here:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用类似于这里展示的图示：
- en: '![Figure 11.1 – Independent data persistence'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.1 – 独立数据持久化]'
- en: '](img/B16716_Figure_11.1.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.1](img/B16716_Figure_11.1.jpg)'
- en: Figure 11.1 – Independent data persistence
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – 独立数据持久化
- en: The *LC Application Processing* functionality lives as its own independent component
    from the rest of the application. It communicates with the monolith through the
    exchange of domain events using the event bus. It makes use of its own persistence
    store and exposes HTTP-based APIs that the frontend consumes. Let’s examine whether
    it is possible to further decompose the application into finer-grained components.
    The `AutoApprovalSaga` component currently lives within the confines of the monolith,
    but this is mostly an artifact of our previous design as opposed to an intentional
    design choice. Let’s look at how we can extract this into its own component next.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*LC 应用处理* 功能作为一个独立的组件存在于整个应用之外。它通过事件总线交换领域事件与单体应用进行通信。它使用自己的持久化存储，并暴露了前端消费的基于
    HTTP 的 API。让我们来探讨是否可以将应用进一步分解为更细粒度的组件。当前的 `AutoApprovalSaga` 组件生活在单体应用的范围内，但这主要是我们之前设计的一个副产品，而不是一个有意的设计选择。接下来，让我们看看如何将其提取为它自己的组件。'
- en: Saga as a standalone component
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Saga 作为独立组件
- en: 'Currently, the `AutoApprovalSaga` component (discussed in detail in [*Chapter
    8*](B16716_08_Final_NM_ePub.xhtml#_idTextAnchor129), Implementing *Long-Running
    Workflows*) works by listening to domain events, as shown here:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`AutoApprovalSaga` 组件（在第 [*第 8 章*](B16716_08_Final_NM_ePub.xhtml#_idTextAnchor129)
    “实现长期运行的工作流程”中详细讨论）通过监听领域事件来工作，如图所示：
- en: '![Figure 11.2 – The AutoApprovalSaga functionality dissected'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.2 – AutoApprovalSaga 功能分解]'
- en: '](img/B16716_Figure_11.2.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.2](img/B16716_Figure_11.2.jpg)'
- en: Figure 11.2 – The AutoApprovalSaga functionality dissected
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – AutoApprovalSaga 功能分解
- en: 'Given that these events are published by different bounded contexts onto the
    event bus, there is no need for `AutoApprovalSaga` to be embedded within the monolith.
    This means that it can be safely pulled out into its own deployable unit along
    with its private data store. This means that our system now looks like the diagram
    depicted here:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些事件是由不同的有界上下文发布到事件总线上的，因此不需要 `AutoApprovalSaga` 嵌入到单体应用中。这意味着它可以安全地与其私有数据存储一起提取为它自己的可部署单元。这意味着我们的系统现在看起来像这里展示的图示：
- en: '![Figure 11.3 – AutoApprovalSaga extracted into an independent component'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.3 – AutoApprovalSaga 提取为独立组件]'
- en: '](img/B16716_Figure_11.3.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.3](img/B16716_Figure_11.3.jpg)'
- en: Figure 11.3 – AutoApprovalSaga extracted into an independent component
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 将 AutoApprovalSaga 提取为独立组件
- en: Saga components can be characterized as a collection of stateful event listeners
    listening to events from more than one aggregate that can issue commands to more
    than aggregate. We saw earlier that we form bounded contexts along aggregate boundaries.
    Given that sagas tend to require interaction with more than one aggregate, they
    may not fall within the confines of those bounded contexts. In a lot of ways,
    sagas are components that can be viewed as their own bounded contexts. This makes
    it natural to have sagas work as standalone components that exist distinctly (both
    from a logical and physical perspective) from other parts of a solution.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Saga组件可以被描述为一系列有状态的监听器，它们监听来自多个聚合体的事件，并且可以向多个聚合体发出命令。我们之前看到，我们沿着聚合体的边界形成了边界上下文。鉴于sagas往往需要与多个聚合体交互，它们可能不会局限于这些边界上下文之内。在许多方面，sagas可以被视为它们自己的边界上下文。这使得sagas作为独立组件工作变得自然而合理，这些组件在逻辑和物理层面上都与其他解决方案的部分明显区分开来。
- en: As you can see, commands and queries within the *LC Application Processing*
    component continue to use a common data store. Let’s look at what is involved
    in segregating them into their own data store.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在*LC应用处理*组件中，命令和查询继续使用一个共同的数据存储。让我们看看将它们隔离到自己的数据存储中涉及的内容。
- en: Commands and queries as standalone components
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为独立组件的命令和查询
- en: 'As we saw in the *CQRS pattern* section in [*Chapter 2*](B16716_02_Final_NM_ePub.xhtml#_idTextAnchor037),
    *Where and How Does DDD Fit?*, the primary benefit that we derive is the ability
    to evolve and scale these components independently of each other. This is important
    because commands and queries have completely different usage patterns and thus
    require the use of distinct domain models. This makes it fairly natural to further
    split our bounded contexts along these boundaries. Thus far, the segregation is
    logical. A physical separation will enable us to truly scale these components
    independently, as shown here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第2章[*“哪里和如何适用DDD？”*](B16716_02_Final_NM_ePub.xhtml#_idTextAnchor037)中“CQRS模式”部分所看到的，我们从中获得的主要好处是能够独立于彼此地演进和扩展这些组件。这一点很重要，因为命令和查询具有完全不同的使用模式，因此需要使用不同的领域模型。这使得我们沿着这些边界进一步分割边界上下文变得相当自然。到目前为止，这种隔离是逻辑上的。物理分离将使我们能够真正独立地扩展这些组件，如下所示：
- en: '![Figure 11.4 – Commands and queries as independent components'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.4 – 命令和查询作为独立组件'
- en: '](img/B16716_Figure_11.4.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16716_Figure_11.4.jpg)'
- en: Figure 11.4 – Commands and queries as independent components
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 – 命令和查询作为独立组件
- en: 'It is pertinent to note that the command processing component is now shown
    to have access to two distinct data stores:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有必要指出，现在命令处理组件现在被显示为可以访问两个不同的数据存储：
- en: The **aggregate store**, which stores either an event-sourced or state-stored
    representation of an aggregate state.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合存储**，它存储聚合状态的基于事件源或状态存储的表示。'
- en: The **lookup store**, which can be used to store lookup data when performing
    business validations when processing commands. This is applicable when we need
    to access data that is/cannot be stored as part of the aggregate state.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查找存储**，在处理命令时执行业务验证时可以用来存储查找数据。这适用于我们需要访问作为聚合状态的一部分存储的数据/不能存储的数据。'
- en: The reason we bring this up is that we may have to continue making lookups for
    data that still remains in the monolith. To achieve full independence, this lookup
    data must also be migrated using techniques such as a historic event replay (as
    discussed in [*Chapter 7*](B16716_07_Final_NM_ePub.xhtml#_idTextAnchor112), *Implementing
    Queries*) or other conventional data migration techniques (as discussed in [*Chapter
    10*](B16716_10_Final_NM_ePub.xhtml#_idTextAnchor150), *Beginning the Decomposition
    Journey*).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提出这一点的原因是，我们可能需要继续对仍然存在于单体中的数据进行查找。为了实现完全的独立性，这些查找数据也必须使用诸如历史事件回放（如在第7章[*“实现查询”*](B16716_07_Final_NM_ePub.xhtml#_idTextAnchor112)中讨论）或其他传统数据迁移技术（如在第10章[*“开始分解之旅”*](B16716_10_Final_NM_ePub.xhtml#_idTextAnchor150)中讨论）进行迁移。
- en: Distributing individual query components
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分布独立的查询组件
- en: 'At this point, we have achieved segregation along command and query boundaries.
    But we do not need to stop here. Each of the queries we service need not necessarily
    remain a single component. Let’s consider an example where we need to implement
    a fuzzy LC search feature for the UI and a view of LC facts for analytical use
    cases. It is conceivable that these requirements may be implemented by a different
    set of teams, thereby necessitating the need for distinct components. Even if
    these are not distinct teams, the disparity in usage patterns may warrant the
    use of different persistence stores and APIs, again requiring us to look at implementing
    at least a subset of these as distinct components, as shown here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经实现了命令和查询边界的隔离。但我们不需要就此停止。我们服务的每个查询不一定必须保持为单个组件。让我们考虑一个例子，其中我们需要为UI实现模糊LC搜索功能，并为分析用例提供LC事实视图。可以想象，这些需求可能由不同的团队实现，从而需要不同的组件。即使这些不是不同的团队，使用模式的差异也可能需要使用不同的持久化存储和API，这又要求我们至少将这些中的某些作为独立的组件来实现，如图所示：
- en: '![Figure 11.5 – Queries split into individual components'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.5 – 查询分解为单个组件'
- en: '](img/B16716_Figure_11.5.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片/B16716_Figure_11.5.jpg]'
- en: Figure 11.5 – Queries split into individual components
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 – 查询分解为单个组件
- en: 'Owning domains should strive to create query APIs that exhibit the characteristics
    of a good domain data product. Some of these characteristics include being discoverable,
    trustworthy, valuable in their own right, and self-describing. For more information,
    please refer to this article on moving from a monolithic data lake to a distributed
    data mesh. Specifically, the section on domain data as a product is relevant in
    this context: [https://martinfowler.com/articles/data-monolith-to-mesh.html#DomainDataAsAProduct](https://martinfowler.com/articles/data-monolith-to-mesh.html#DomainDataAsAProduct).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有域的团队应努力创建表现出良好域数据产品特征的查询API。这些特征包括可发现性、可信度、自身价值以及自我描述。更多详细信息，请参阅关于从单体数据湖迁移到分布式数据网格的文章：[https://martinfowler.com/articles/data-monolith-to-mesh.html#DomainDataAsAProduct](https://martinfowler.com/articles/data-monolith-to-mesh.html#DomainDataAsAProduct)。
- en: Even more fine-grained decomposition
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更加细粒度的分解
- en: At this stage, is there any further decomposition that is required and feasible?
    These days, whether rightfully or otherwise, serverless architecture (specifically,
    *functions as a service*) is arguably becoming all the rage. As we pointed out
    in [*Chapter 2*](B16716_02_Final_NM_ePub.xhtml#_idTextAnchor037), *Where and How
    Does DDD Fit?*, this means that we may be able to decompose our command side in
    a manner that each command becomes its own independently deployable unit (hence
    a bounded context). In other words, `LCApplicationSubmitCommand` and the `LCApplicationCancelCommand`
    can be deployed independently.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，是否还需要进一步分解且可行？如今，无论是正确还是错误，无服务器架构（特别是*函数即服务*）可能正变得非常流行。正如我们在[*第二章*](B16716_02_Final_NM_ePub.xhtml#_idTextAnchor037)中指出的，“DDD如何适应？”，这意味着我们可能能够以这种方式分解我们的命令端，即每个命令都成为其独立可部署的单位（因此是边界上下文）。换句话说，`LCApplicationSubmitCommand`和`LCApplicationCancelCommand`可以独立部署。
- en: 'But just because this is technically possible, should we do it? While it is
    easy to dismiss this as a passing fad, there may be good reasons to split applications
    along command boundaries:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 但仅仅因为技术上可行，我们就应该这样做吗？虽然很容易将其视为一时的风尚，但沿着命令边界拆分应用程序可能有很好的理由：
- en: '**Risk profile**: Certain pieces of functionality present a higher risk when
    changes are made. For example, submitting an LC application may be deemed a lot
    more critical than the ability to cancel it. However, that is not to say that
    *canceling* is unimportant. Being decoupled from *submit* allows *cancel* changes
    to be made with a lot less scrutiny. This may make it easier to innovate quickly
    with more experimental features, with minimal fear of causing large disruptions.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**风险概况**：当进行更改时，某些功能组件的风险更高。例如，提交LC申请可能被认为比取消申请的能力更为关键。然而，这并不意味着*取消*不重要。与*提交*解耦使得*取消*更改可以以较少的审查进行。这可能会使快速创新并带有更多实验性功能变得更容易，同时最小化造成大规模中断的恐惧。'
- en: '**Scalability needs**: Scaling needs can differ wildly for various commands
    in a system. For example, *submit* may need to scale a lot more than *cancel*.
    However, being coupled will force us to treat them as equals, which can be inefficient.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性需求**：系统中的各种命令的可扩展性需求可能会有很大差异。例如，*提交* 可能需要比 *取消* 扩展得更多。然而，耦合将迫使我们将它们视为同等，这可能是低效的。'
- en: '**Cost attribution**: Having fine-grained components allows us to more accurately
    measure the amount of effort and the resulting ROI dedicated to each individual
    command. This can make it easier to focus our efforts on the most critical functionality
    (the “core” of the core) and minimize waste.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成本归属**：拥有细粒度的组件使我们能够更准确地衡量每个单独命令所投入的努力和产生的回报率。这可以使我们更容易将精力集中在最关键的功能（“核心”的核心）上，并最大限度地减少浪费。'
- en: Effects on the domain model
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对领域模型的影响
- en: 'These finer grainer components are leading us to a point where it may appear
    that the deployment model is starting to have a big influence on the design. The
    fact that it is now feasible to deploy individual “tasks” independently requires
    us to reexamine how we arrive at bounded contexts. For example, we started by
    working on the *LC Application Processing* bounded context, and our aggregate
    design was based on all functionality included in the scope of application processing.
    Now, our aggregate design can be a lot more fine-grained. This means that we can
    have an aggregate specifically for *start* functionality and another for *cancel*,
    as shown here:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更细粒度的组件正引导我们走向一个点，似乎部署模型开始对设计产生重大影响。现在能够独立部署单个“任务”的事实要求我们重新审视我们如何到达边界上下文。例如，我们最初从工作在
    *LC 应用处理* 边界上下文开始，我们的总体设计基于所有包含在应用处理范围内的功能。现在，我们的总体设计可以更加细粒度。这意味着我们可以有一个专门针对 *启动*
    功能的总体设计，另一个针对 *取消*，如图所示：
- en: '![Figure 11.6 – A fine-grained bounded contexts example'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.6 – 细粒度边界上下文示例'
- en: '](img/B16716_Figure_11.6.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16716_Figure_11.6.jpg]'
- en: Figure 11.6 – A fine-grained bounded contexts example
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 – 细粒度边界上下文示例
- en: 'The most fine-grained decomposition may lead us to a bounded context per command,
    but that does not necessarily mean that we have to decompose the system this way.
    In the preceding example, we have chosen to create a single bounded context for
    the *submit* and *approve* commands. However, *start* and *cancel* have their
    own bounded contexts. The actual decision that you make in your own ecosystems
    will depend on maintaining a balance among reuse, coupling, transactional consistency,
    and other considerations that we discussed earlier. It is important to note that
    the aggregate labeled as `LCApplication`, although named identically, is distinct
    from a domain model perspective in its respective bounded context. The only attribute
    they will need to share is a **common identifier**. If we choose to decompose
    the system into a bounded context per command, our overall solution will look
    like the diagram shown here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最细粒度的分解可能会引导我们为每个命令创建一个边界上下文，但这并不一定意味着我们必须以这种方式分解系统。在先前的例子中，我们选择为 *提交* 和 *批准*
    命令创建一个单独的边界上下文。然而，*启动* 和 *取消* 有它们自己的边界上下文。你自己在生态系统中所做的实际决策将取决于在重用、耦合、事务一致性以及其他我们之前讨论过的考虑因素之间保持平衡。重要的是要注意，标记为
    `LCApplication` 的聚合，尽管名称相同，但在各自的边界上下文中从领域模型的角度来看是不同的。它们唯一需要共享的属性是 **共同标识符**。如果我们选择将系统分解为每个命令一个边界上下文，我们的整体解决方案将类似于以下所示图：
- en: '![Figure 11.7 – Decomposition per command'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.7 – 按命令分解'
- en: '](img/B16716_Figure_11.7.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16716_Figure_11.7.jpg]'
- en: Figure 11.7 – Decomposition per command
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 – 按命令分解
- en: 'It is pertinent to note that the *command* functions continue to share a single
    event store, although they may make use of their own individual lookup stores.
    We understand that this decomposition likely feels unnecessary and forced. However,
    this does allow us to focus our energies on the *core of the core*. For example,
    LC application processing may be our business differentiator. However, an even
    more careful examination may reveal that it is our ability to *decision* LCs near
    real time that is our real business differentiator. This means that it may be
    prudent to isolate that functionality from the rest of the system. In fact, doing
    so may enable us to optimize our business process without adding risk to the overall
    solution. While it is not strictly necessary to decompose the system in this way
    to arrive at such insights, a fine-grained decomposition may enable us to refine
    the idea of what is most important to our business. Having to share a persistent
    store can be a wrinkle to achieve complete independence. Therefore, a final decomposition
    may look something like the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有必要指出，*命令*功能仍然共享一个单独的事件存储，尽管它们可能使用它们自己的单独查找存储。我们理解这种分解可能感觉是不必要的和强制的。然而，这确实允许我们集中精力在*核心的核心*上。例如，LC应用程序处理可能是我们的业务差异化。然而，更仔细的检查可能会揭示，我们真正区别于业务的能力是我们在接近实时的情况下对LC的*决策*能力。这意味着可能明智地将该功能从系统其他部分隔离出来。实际上，这样做可能使我们能够优化我们的业务流程，而不会增加整体解决方案的风险。虽然以这种方式分解系统并非严格必要以获得这些见解，但细粒度的分解可能使我们能够细化对我们业务最重要的概念。需要共享持久存储可能会成为实现完全独立的一个难题。因此，最终的分解可能看起来像以下这样：
- en: '![Figure 11.8 – Command components with individual event stores'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.8 – 具有个体事件存储的命令组件'
- en: '](img/B16716_Figure_11.8.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16716_Figure_11.8.jpg]'
- en: Figure 11.8 – Command components with individual event stores
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 – 具有个体事件存储的命令组件
- en: Obviously, there is no free lunch! This fine-grained decomposition may require
    additional coordination and duplication of data among these components – to a
    point where it may not be attractive anymore. However, we feel that it is important
    to illustrate the art of the possible.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，没有免费的午餐！这种细粒度的分解可能需要在这些组件之间进行额外的协调和数据复制 – 到一个可能不再具有吸引力的程度。然而，我们认为重要的是要展示可能的技艺。
- en: Decomposing the frontend
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分解前端
- en: 'Thus far, we have focused on decomposing and distributing the backend components
    while keeping the frontend untouched as part of the existing monolithic system.
    It is worth considering breaking down the frontend to align it more closely along
    functional boundaries. Patterns such as micro-frontends ([https://micro-frontends.org/](https://micro-frontends.org/),
    [https://martinfowler.com/articles/micro-frontends.html](https://martinfowler.com/articles/micro-frontends.html))
    extend the concepts of microservices to the frontend. Micro-frontends promote
    team structures to support end-to-end ownership of a set of features. It is conceivable
    that a cross-functional, polyglot team owns both the experience (frontend) and
    the business logic (backend) functions, eliminating communication overheads drastically
    (along the lines of the vertical slice architecture conversation, as discussed
    in [*Chapter 2*](B16716_02_Final_NM_ePub.xhtml#_idTextAnchor037), *Where and How
    Does DDD Fit?*). Even if such a team organization where the frontend and backend
    are one team is not feasible in your current ecosystem, this approach still has
    many merits, such as the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直专注于分解和分配后端组件，同时保持前端作为现有单体系统的一部分保持不变。值得考虑将前端分解，使其更紧密地与功能边界对齐。例如，微前端（[https://micro-frontends.org/](https://micro-frontends.org/)，[https://martinfowler.com/articles/micro-frontends.html](https://martinfowler.com/articles/micro-frontends.html)）将微服务概念扩展到前端。微前端促进团队结构以支持一组功能的端到端所有权。可以想象，一个跨职能、多语言团队既拥有体验（前端）又拥有业务逻辑（后端）功能，从而大大减少沟通成本（类似于垂直切片架构的讨论，如在第[*2章*](B16716_02_Final_NM_ePub.xhtml#_idTextAnchor037)中所述，“DDD如何适应？”）。即使在前端和后端由一个团队组成的团队组织在你的当前生态系统中不可行，这种方法仍然具有许多优点，例如以下内容：
- en: '**Increased end-to-end collaboration**: Creating solutions that work end to
    end is what ultimately provides value. Having a set of backend services isolated
    from their respective customer experiences will only cause us to accumulate unused
    inventory. To reduce the possibility of failure, the closer the collaboration
    between the backend capability and frontend experience teams, the greater our
    chance of reducing waste due to misaligned requirements. Including the customer
    experiences as part of the vertical slice allows us to apply the ubiquitous language
    through the entire stack.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强端到端协作**：创建端到端工作的解决方案最终提供了价值。将后端服务与其各自客户体验隔离开来只会导致我们积累未使用的库存。为了减少失败的可能性，后端能力与前端体验团队之间的协作越紧密，我们减少由于需求不匹配造成的浪费的机会就越大。将客户体验作为垂直切片的一部分，使我们能够在整个堆栈中应用通用语言。'
- en: '**Uniform omnichannel experiences**: These days, it is very common to surface
    the same functionality across more than one experience channel. Having an inconsistent
    experience across channels can lead to customer dissatisfaction and/or adverse
    business consequences. Aligning teams closely along functional boundaries (within
    the same *swim lane*) can promote high levels of collaboration and consistency
    when exposing business functionality. Consider the example shown here. Within
    a vertical slice, the allegiance is to the functionality being developed, although
    there may be a need to use disparate technologies to build each channel (iOS,
    Android, web, and so on). Within a vertical slice, each box depicted in the diagram
    may operate as a team of its own, while maintaining strong cohesion with the functional
    team within the same swim lane, as shown here:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统一的跨渠道体验**：如今，在多个体验渠道中展示相同的功能非常普遍。跨渠道体验不一致可能会导致客户不满和/或不良的商业后果。沿着功能边界（在同一个
    *泳道* 内）紧密对齐团队可以促进在展示业务功能时的高协作和一致性。考虑这里显示的例子。在一个垂直切片中，忠诚度是对正在开发的功能，尽管可能需要使用不同的技术来构建每个渠道（iOS、Android、Web
    等）。在一个垂直切片中，图中显示的每个框都可以作为一个团队独立运行，同时与同一泳道内的功能团队保持强烈的凝聚力，如这里所示：'
- en: '![Figure 11.9 – Teams aligned along functional boundaries'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.9 – 沿着功能边界对齐的团队'
- en: '](img/B16716_Figure_11.9_NEW.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_11.9_NEW.jpg)'
- en: Figure 11.9 – Teams aligned along functional boundaries
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9 – 沿着功能边界对齐的团队
- en: 'While there are many advantages in employing this approach, as with everything
    else, it does come with a few gotchas that you may need to be mindful of:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然采用这种方法有很多优点，但与其他任何事情一样，它也带来了一些需要注意的问题：
- en: '**End-to-end testing complexity**: While this is true for a lot of distributed
    architectures, this problem is exacerbated in the case of user experiences because
    of it being a visual medium. Especially if real components come together close
    to the end of the cycle, it may become harder to visualize the end-to-end flow
    until almost all the visual elements are in place. This may also be in conflict
    with how end users interact with a system as a whole. This may make end-to-end
    testing complex because it needs components from multiple teams to come together,
    possibly close to the end of the cycle.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端到端测试复杂性**：虽然这在很多分布式架构中都是真的，但由于用户体验是一个视觉媒介，这个问题在用户体验的情况下更为严重。特别是如果真实组件在周期接近结束时才合并，那么在所有视觉元素都就位之前，可能很难可视化端到端的流程。这也可能与最终用户如何整体交互系统相冲突。这可能会使端到端测试变得复杂，因为它需要来自多个团队在周期接近结束时共同参与。'
- en: '**Deployment complexity**: In the preceding example, we have split the application
    along functional boundaries. However, they have to come together as a single artifact
    at the time of deployment (this is especially true in the case of mobile applications).
    This can add quite a bit of deployment complexity when the complete application
    is assembled. It is important to be cognizant of the relationship patterns between
    teams (as covered in [*Chapter 9*](B16716_09_Final_NM_ePub.xhtml#_idTextAnchor138),
    *Integrating with External Systems*) to work through kinks.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署复杂性**：在前面的例子中，我们已经根据功能边界拆分了应用程序。然而，在部署时，它们必须作为一个单一的项目合并在一起（这在移动应用程序的情况下尤其如此）。当完整的应用程序组装时，这可能会增加相当多的部署复杂性。了解团队之间的关系模式（如第
    [*第9章*](B16716_09_Final_NM_ePub.xhtml#_idTextAnchor138)，*与外部系统集成*）对于解决难题非常重要。'
- en: '**Dependency management**: Given that teams may need to ultimately deploy the
    application as a unit, managing dependencies between individual modules may become
    cumbersome. This may manifest itself in the form of conflicting dependency versions,
    leading to unpredictable and inefficient runtime behavior and performance. For
    example, two teams may use different versions of the same frontend library, which
    may add to the overall payload that gets downloaded to the browser. In addition
    to being wasteful, this may also result in unpredictable, hard-to-diagnose errors,
    and eventually, poor customer experience.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖管理**：鉴于团队可能最终需要将应用程序作为一个单元部署，管理各个模块之间的依赖可能变得繁琐。这可能表现为依赖版本冲突，导致不可预测和低效的运行时行为和性能。例如，两个团队可能使用同一前端库的不同版本，这可能会增加下载到浏览器的总体负载。除了浪费之外，这也可能导致不可预测、难以诊断的错误，并最终导致糟糕的客户体验。'
- en: '**Inconsistent user experiences**: Although we may have split the application
    in a seemingly logical manner, if we don’t do it in a manner that is transparent
    to the end users, it may result in a confusing and likely frustrating experience.
    To mitigate this, there may be a need to build common assets, widgets, and so
    on. which may further add to the overall complexity and coordination required
    when shipping out the end product.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不一致的用户体验**：尽管我们可能以看似合理的方式拆分了应用程序，但如果我们没有以对最终用户透明的方式去做，这可能会导致令人困惑且可能令人沮丧的体验。为了减轻这种情况，可能需要构建共同的资产、小部件等，这可能会进一步增加交付最终产品时的整体复杂性和协调需求。'
- en: 'If we proceed to continue decomposing our application as suggested previously,
    our application will end up looking like the diagram shown here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续按照之前建议的方式继续分解我们的应用程序，我们的应用程序最终会看起来像这里所示的图表：
- en: '![Figure 11.10 – Commands and query frontends decomposed into individual functions'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.10 – 命令和查询前端分解为单个函数'
- en: '](img/B16716_Figure_11.10.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16716_Figure_11.10.jpg)'
- en: Figure 11.10 – Commands and query frontends decomposed into individual functions
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10 – 命令和查询前端分解为单个函数
- en: As we saw, there are multiple ways to approach decomposing an application into
    finer-grained components. Just because it is possible to do it, it doesn’t mean
    that we should. Let’s look at when decomposition starts to become too expensive
    to sustain productivity.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，有多种方法可以将应用程序分解成更细粒度的组件。尽管这样做是可能的，但这并不意味着我们应该这样做。让我们看看何时分解开始变得过于昂贵而无法维持生产力。
- en: Where to draw the line
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时划线
- en: 'In general, the smaller the size of our bounded contexts, the easier it becomes
    to manage complexity. Does that mean we should decompose our systems into as fine-grained
    a granularity as possible? On the other hand, having extremely fine-grained components
    can increase coupling among them to the extent where it becomes very hard to manage
    operational complexity. Hence, decomposing a system into well-factored, collaborating
    components can be a bit tricky, seeming to work more like an art rather than an
    exact science. There is no right or wrong answer here. In general, if things feel
    and become painful, you most likely got it more wrong than right. Here are some
    non-technical heuristics that might help guide this process:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们的边界上下文越小，管理复杂性的难度就越低。这意味着我们应该尽可能地将系统分解成更细粒度的组件吗？另一方面，拥有极其细粒度的组件可能会增加它们之间的耦合度，以至于管理操作复杂性变得非常困难。因此，将系统分解成结构良好、协作的组件可能有点棘手，看起来更像是一门艺术而不是一门精确的科学。这里没有对或错的答案。一般来说，如果事情感觉和变得痛苦，你很可能做错了而不是做对了。以下是一些可能有助于指导这一过程的非技术启发式方法：
- en: '**Existing organization boundaries**: Look to align along with current organizational
    structures. Identify which applications your business unit/department/team already
    owns and assign responsibilities in a manner that causes minimal disruption.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**现有的组织边界**：寻求与当前的组织结构保持一致。确定你的业务单元/部门/团队已经拥有的哪些应用程序，并按最小化干扰的方式分配责任。'
- en: '**End-user roles and responsibilities**: What work do your end users carry
    out? What enables them to do their work with the least friction possible? If too
    many people need to get involved to get a piece of work done, that may be a sign
    that the current decomposition may be suboptimal. On the other hand, if it is
    hard to assign a task to a specific user, it may again be a sign of incorrect
    decomposition.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最终用户角色和责任**：你的最终用户执行哪些工作？什么使他们能够以尽可能少的摩擦完成工作？如果太多人需要参与才能完成一项工作，这可能表明当前的分解可能不是最优的。另一方面，如果很难将一项任务分配给特定的用户，这也可能表明分解不正确。'
- en: '**Change in vernacular**: Look for subtle changes in the usage of common terms
    (the *ubiquitous language*). Does someone call something that is/feels the same
    in the physical world by different names? For example, a credit card can be called
    “plastic,” “payment instrument,” and “account” by different people or the same
    people in a different context. The point at which the vernacular changes may be
    the time to split functionality.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**术语变化**：寻找对常用术语（*通用语言*）使用的微妙变化。是否有人用不同的名字称呼在物理世界中相同或感觉相同的事物？例如，信用卡可以被不同的人或同一个人在不同情境下称为“塑料”、“支付工具”和“账户”。术语发生变化的时候，可能是分割功能的时候了。'
- en: '**Existing (modular/monolithic/distributed) applications**: How are your current
    applications segregated logically? How are they segregated physically? This might
    provide some inspiration.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**现有（模块化/单体/分布式）应用**：你的当前应用是如何在逻辑上隔离的？它们是如何在物理上隔离的？这可能会提供一些灵感。'
- en: Team organization
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 团队组织
- en: All of the preceding techniques draw inspiration from existing constructs. However,
    what if one or more of the preceding are wrong/cumbersome/suboptimal? In such
    a case, our work as developers/architects is a bit more involved.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的上述技术都从现有结构中汲取灵感。然而，如果上述一个或多个是错误的/繁琐的/次优的，我们的作为开发者/架构师的工作就会更加复杂。
- en: It is also pertinent to note that it is not uncommon to get domain boundaries
    wrong. Coming up with an initial breakdown that seems to make more sense and applying
    a series of *what if* questions to assess suitability can help. If the reasoning
    is able to stand up to scrutiny by domain experts, architects, and other stakeholders,
    you might be in a good place. If you do choose to go down this route, it may be
    prudent to adjust existing organizational structures to match your proposed architecture.
    This will help reduce friction (in other words, apply what is called the *inverse
    Conway maneuver* ([https://www.thoughtworks.com/en-us/radar/techniques/inverse-conway-maneuver](https://www.thoughtworks.com/en-us/radar/techniques/inverse-conway-maneuver)).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 也有必要指出，出错确定领域边界并不罕见。提出一个看似更有道理的初始分解，并应用一系列的“如果...怎么办”问题来评估适用性，可能会有所帮助。如果推理能够经得起领域专家、架构师和其他利益相关者的审查，那么你可能已经处于一个不错的位置。如果你确实选择走这条路，调整现有的组织结构以匹配你提出的架构可能是一个明智的选择。这将有助于减少摩擦（换句话说，应用所谓的*康威逆操作*([https://www.thoughtworks.com/en-us/radar/techniques/inverse-conway-maneuver](https://www.thoughtworks.com/en-us/radar/techniques/inverse-conway-maneuver))）。
- en: 'This style of team organization can be quite complex. The people at Spotify
    popularized the idea of a multidisciplinary, mostly autonomous team structure
    aligning closely along functional boundaries (called *squads*), as shown here:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这种团队组织方式可能相当复杂。Spotify的人普及了多学科、主要自主的团队结构，这种结构紧密地沿着功能边界（称为*squad*）对齐，如下所示：
- en: '![Figure 11.11 – The Spotify model of team organization'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.11 – Spotify团队组织模型'
- en: '](img/B16716_Figure_11.11.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_11.11.jpg)'
- en: Figure 11.11 – The Spotify model of team organization
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11 – Spotify团队组织模型
- en: 'The team structure has other components such as chapters, tribes, and guilds,
    which enable a better flow of change, clarify team responsibilities, promote better
    intra- and inter-team collaboration, and so on. You can find out more about it
    in this post: [https://blog.crisp.se/wp-content/uploads/2012/11/SpotifyScaling.pdf](https://blog.crisp.se/wp-content/uploads/2012/11/SpotifyScaling.pdf).
    However, there is no one-size-fits-all approach, and you will need to account
    for your own organizational structures and realities before looking to adopt this
    style. To find out more about the *limitations of the Spotify model* ([https://www.youtube.com/watch?v=4GK1NDTWbkY](https://www.youtube.com/watch?v=4GK1NDTWbkY))
    and how you can arrive at a team organization that better suits your own requirements,
    you may want to take a look at the work done by Matthew Skelton and Manuel Pais
    in their popular book *Team Topologies* ([https://teamtopologies.com/book](https://teamtopologies.com/book)).
    On a related note, it may also be helpful to look at the chapter on team design
    from the book *Agile IT Organization Design* ([https://www.amazon.com/Agile-Organization-Design-Transformation-Continuous/dp/0133903354](https://www.amazon.com/Agile-Organization-Design-Transformation-Continuous/dp/0133903354))
    by Sriram Narayan, where he talks about outcome-oriented versus activity-oriented
    teams.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 团队结构还包括其他组成部分，如章节、部落和行会，这些部分有助于更好地流动变化、明确团队责任、促进团队内和团队间的更好协作等。您可以在以下帖子中了解更多信息：[https://blog.crisp.se/wp-content/uploads/2012/11/SpotifyScaling.pdf](https://blog.crisp.se/wp-content/uploads/2012/11/SpotifyScaling.pdf)。然而，没有一种适合所有情况的解决方案，在考虑采用这种风格之前，您需要考虑自己的组织结构和现实情况。要了解更多关于*Spotify
    模型的局限性*([https://www.youtube.com/watch?v=4GK1NDTWbkY](https://www.youtube.com/watch?v=4GK1NDTWbkY))以及如何找到一个更适合您自己需求的团队组织，您可能想看看
    Matthew Skelton 和 Manuel Pais 在他们流行的书籍 *Team Topologies* ([https://teamtopologies.com/book](https://teamtopologies.com/book))
    中所做的工作。在相关方面，查看 Sriram Narayan 在其书籍 *Agile IT Organization Design* ([https://www.amazon.com/Agile-Organization-Design-Transformation-Continuous/dp/0133903354](https://www.amazon.com/Agile-Organization-Design-Transformation-Continuous/dp/0133903354))
    中的团队设计章节也可能有所帮助，他在书中讨论了以结果为导向的团队与以活动为导向的团队。
- en: 'Despite all our due diligence and noble intentions, it is still possible to
    get these boundaries wrong, or a change in business priorities or competitor offerings
    may render decisions that appeared perfectly valid at the time to become incorrect.
    Instead of looking to arrive at the perfect decomposition, it might be prudent
    to embrace change and invest in building designs that are flexible while being
    prepared to evolve and refactor the architecture iteratively. This book on building
    evolutionary architectures has some great advice on how to do precisely that:
    [https://evolutionaryarchitecture.com/](https://evolutionaryarchitecture.com/).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们尽职尽责和有崇高的意图，但仍然有可能出错这些边界，或者业务优先级或竞争对手的提供可能使当时看似完全有效的决策变得不正确。与其寻求达到完美的分解，不如接受变化，投资于构建灵活的设计，同时准备迭代地演进和重构架构。这本书关于构建演进式架构提供了一些很好的建议，如何做到这一点：[https://evolutionaryarchitecture.com/](https://evolutionaryarchitecture.com/)。
- en: 'In order to attain a reasonable level of success, there will be a need to maintain
    a fine balance between how domains are modeled, what the team organizations are,
    and how applications are architected. When all of these are in agreement, it is
    likely that you get pretty close to achieving high levels of success, as depicted
    in the following diagram:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到合理的成功水平，需要在如何对领域进行建模、团队组织是什么以及如何架构应用程序之间保持微妙的平衡。当所有这些都达成一致时，您很可能接近实现高水平的成功，如下面的图表所示：
- en: '![Figure 11.12 – Forces influencing component decomposition'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.12 – 影响组件分解的力'
- en: '](img/B16716_Figure_11.12.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_11.12.jpg)'
- en: Figure 11.12 – Forces influencing component decomposition
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12 – 影响组件分解的力
- en: As a general guideline, it helps to start with a coarse-grained decomposition
    at the outset when requirements and/or our understanding are likely still unclear,
    leaving finer-grained decomposition to a time when our understanding improves.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般性指南，当需求和/或我们的理解可能仍然不清楚时，从粗粒度分解开始是有帮助的，将更细粒度的分解留到我们的理解提高的时候。
- en: Summary
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how an already fine-grained application can be further
    decomposed to the level of individual functions, each of which may be deployed
    as its own independent unit. We looked at how we stand to benefit from keeping
    end-to-end functionality (a thin vertical slice) as a cohesive unit, which includes
    components from the frontend experience all the way to the backend.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何将已经细粒度的应用程序进一步分解到个体功能层面，每个功能都可以作为一个独立的单元部署。我们探讨了保持端到端功能（一个薄垂直切片）作为一个统一单元的好处，这包括从前端体验到后端的所有组件。
- en: Further, we looked at how Conway’s law can play an important role in the evolution
    of our architecture. We also looked at how we may be able to course correct cumbersome
    organizational structures by applying the inverse Conway maneuver. Finally, we
    briefly touched on popular methods of team organization that you can take inspiration
    from when designing your own organizational structures.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们探讨了康威定律如何在我们的架构演变中发挥重要作用。我们还探讨了如何通过应用逆康威机动来纠正笨拙的组织结构。最后，我们简要介绍了在设计自己的组织结构时可以从中获得灵感的流行团队组织方法。
- en: In the next chapter, we will look at a variety of non-functional characteristics
    that play a significant role in how we can decompose and distribute applications.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨各种非功能性特征，这些特征在我们如何分解和分配应用程序方面发挥着重要作用。
- en: Further reading
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '![](img/B16716_11_Table_01.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B16716_11_Table_01.jpg)'
