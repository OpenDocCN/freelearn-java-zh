- en: Introducing the Modular JDK
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍模块化JDK
- en: In the previous two chapters, you've learnt about the modular API in Java 9
    and how to create your own custom modules. There's much more to Java 9 modules
    than that! The introduction of modularity in Java is not just a new *feature*
    for developers to use; it has resulted in major changes to the Java platform itself.
    In fact, Java 9 also has had perhaps the biggest overhaul of the internal Java
    codebase ever. Java 9 not only comes with the ability for developers to create
    their own modules, the whole Java platform itself has been modularized. In this
    chapter, let's examine these important changes, both to learn what the changes
    are, and to understand *why* they came about. Now that you have warmed up to Java
    modules by writing modules yourself, it's time to put our thinking caps on and
    really understand the problems and the requirements that resulted in this major
    change in the Java language. Not only will it help us appreciate the changes better,
    learning how and why the JDK was modularized will help us apply these lessons
    when we learn how to migrate our own Java code to Java 9 in [Chapter 11](part0172.html#5410O0-ed2405f4162b4f86b565edd6b6d679fb),
    *Migrating Your Code to Java 9*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '在前两章中，你已经了解了Java 9的模块化API以及如何创建自己的自定义模块。Java 9模块的内容远不止这些！Java中模块化的引入不仅为开发者提供了一个新的*特性*来使用；它导致了Java平台本身的重大变化。实际上，Java
    9还可能对内部Java代码库进行了有史以来最大的改组。Java 9不仅为开发者提供了创建自己的模块的能力，整个Java平台本身也被模块化了。在本章中，让我们检查这些重要的变化，既要了解变化是什么，也要理解*为什么*会有这些变化。现在，你已经通过编写模块来熟悉了Java模块，是时候戴上我们的思考帽，真正理解导致Java语言这一重大变化的问题和需求。这不仅将帮助我们更好地欣赏这些变化，学习如何以及为什么JDK被模块化，还将帮助我们学习如何在[第11章](part0172.html#5410O0-ed2405f4162b4f86b565edd6b6d679fb)“将您的代码迁移到Java
    9”中迁移自己的Java代码。 '
- en: 'Here are the topics that we''ll cover in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: We'll start by examining two aspects of the JDK as they were before Java 9 and
    some problems with them. It's important for us to know the way things were, so
    that we can fully understand the effect of the new changes.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将从检查Java 9之前的JDK的两个方面以及它们的一些问题开始。了解过去的事情对我们来说很重要，这样我们才能完全理解新变化的影响。
- en: You'll learn how modularity has transformed the Java platform and be introduced
    to the built-in modules.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将学习模块化如何改变Java平台，并介绍内置模块。
- en: You'll learn how to browse built-in modules and get information about their
    module definitions.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将学习如何浏览内置模块并获取它们模块定义的信息。
- en: You'll learn how to understand module relationships in a module graph.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将学习如何理解模块图中的模块关系。
- en: Examining the legacy JDK
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查遗留的JDK
- en: 'Java has been around for over two decades now. For the most part of its lifetime,
    there have been a few things that haven''t changed. Let''s focus our attention
    on two aspects of the JDK the way they were in Java 8 or earlier:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Java已经存在二十多年了。在其生命周期的大部分时间里，有一些事情并没有改变。让我们关注Java 8或更早版本的JDK的两个方面：
- en: '**The JRE structure**: The file and directory structure that **Java Runtime
    Environment** (**JRE**) is installed as when it is set up on a computer'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JRE结构**：当在计算机上设置时，Java运行时环境（JRE）安装的文件和目录结构'
- en: '**The state of API encapsulation**: The differences between the *public* Java
    APIs and the internal platform classes'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API封装的状态**：公共Java API与内部平台类之间的差异'
- en: The JRE structure
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JRE结构
- en: 'When you install the Java 8 Runtime Environment on any machine and examine
    the installed directory, you''ll see, among other files and folders, the following
    two important directories:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在任何机器上安装Java 8运行时环境并检查安装目录时，你会在其他文件和文件夹中看到以下两个重要的目录：
- en: A `bin` directory with executable files, an important one of which is the Java
    executable that lets you run Java programs
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含可执行文件的`bin`目录，其中之一是Java可执行文件，它允许你运行Java程序
- en: The `lib` directory with some key `.jar` files including the all-important `rt.jar`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含一些关键`.jar`文件的`lib`目录，包括至关重要的`rt.jar`
- en: You may not have had to deal with the `rt.jar` directly when coding in Java,
    but you should know that it's the single most important `jar` file in the runtime.
    Can you guess what it's for?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在Java中编码时，你可能不需要直接处理`rt.jar`，但你应该知道它是运行时最重要的`jar`文件。你能猜到它是用来做什么的吗？
- en: Understanding rt.jar
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解rt.jar
- en: Let's say you build a Java application that uses some core library classes such
    as collections and threads. When you compile and distribute your application to
    be run on another machine with Java installed, you can get away with packaging
    just the classes you've written in your application, and *not* include the compiled
    `Collection` and `Thread` classes. That's because every runtime comes with all
    the compiled platform classes out-of-the-box, so that every developer doesn't
    have to distribute them with their applications. The way these classes are bundled
    into the JRE is through a single file--`rt.jar`. You'd place your application
    classes in the classpath for the runtime to find, but for any of the platform
    classes, it just finds them in `rt.jar`. The name `rt` stands for **Run Time**,
    and this single jar file holds the entire Java runtime. Yes, you read that right!
    `rt.jar` essentially contains all the compiled classes in the Java platform, all
    bundled into one JAR file. Every. Single. One. Of. Them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你构建了一个使用一些核心库类（如集合和线程）的Java应用程序。当你编译并将你的应用程序分发到另一个安装了Java的机器上运行时，你可以只打包你在应用程序中编写的类，而无需包含编译后的`Collection`和`Thread`类。这是因为每个运行时都自带所有编译的平台类，这样每个开发者就不必将它们与他们的应用程序一起分发。这些类捆绑到JRE中的方式是通过一个文件——`rt.jar`。你将你的应用程序类放在运行时的类路径中以便查找，但对于任何平台类，它只是在`rt.jar`中找到它们。`rt`这个名字代表**运行时**，这个单一的JAR文件包含了整个Java运行时的所有编译类。是的，你没听错！`rt.jar`本质上包含了Java平台中的所有编译类，全部捆绑在一个JAR文件中。每一个。单个。类。
- en: The problem with this model
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这个模型的问题
- en: This has been the state of affairs for multiple Java releases now. The decision
    to bundle all the platform classes into a single JAR file was made quite early
    in Java's life and it might have been a good idea at the time. But considering
    how much the platform has grown and how many new classes have been added to the
    platform over the years, it's clearly not a good idea anymore. With Java 8, the
    `rt.jar` measures close to 60 MB in size. And even if you might find it bearable
    now, imagine how it would scale, if say, Java continues to grow at a good pace
    for the next 10 years and ends up having a few thousands more classes added. Would
    we still be fine with bundling them all into a single jar file then?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况已经持续了多个Java版本。将所有平台类捆绑到单个JAR文件中的决定是在Java生命早期做出的，当时可能是个好主意。但考虑到平台已经增长了多少，以及多年来添加到平台中的新类有多少，显然这已经不再是个好主意了。Java
    8中，`rt.jar`的大小接近60 MB。即使你现在可能觉得这还可以忍受，想象一下，如果Java在未来10年内以良好的速度继续增长，并最终增加了几千个新类，那会怎样？我们还会对将它们全部捆绑到单个JAR文件中感到满意吗？
- en: In addition to the platform developers having to deal with the monolithic JAR
    file, here's another logistical challenge that this model brings up. A common
    practice for application developers to distribute their application is to bundle
    their app installers with the Java Runtime Environment. Any Java app requires
    the runtime anyway, but there's no knowing if the users of the Java application
    have the runtime installed on their machines beforehand. So, bundling the app
    with the runtime is a great way to make sure anyone who installs the app has the
    necessary runtime and can execute the app successfully. This is true not just
    for classic desktop application installers, but also for the newer practice of
    creating self-contained micro-services. Developers building micro-services create
    distributables that contain both the compiled micro-services as well as the Java
    runtime so that a micro-service instance can be kicked off on any virtual machine
    on the cloud by a single command.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除了平台开发者必须处理单体JAR文件之外，这个模型还带来了另一个物流挑战。对于应用开发者来说，将他们的应用程序分发的常见做法是将应用程序安装程序与Java运行时环境捆绑在一起。任何Java应用程序都需要运行时，但无法确定Java应用程序的用户在安装应用程序之前是否已经安装了运行时。因此，将应用程序与运行时捆绑在一起是确保任何安装应用程序的人都有必要的运行时并能成功执行应用程序的绝佳方式。这不仅适用于经典的桌面应用程序安装程序，也适用于创建自包含微服务的较新做法。构建微服务的开发者会创建包含编译后的微服务和Java运行时的可分发文件，这样就可以通过单个命令在任何云虚拟机上启动微服务实例。
- en: The size of the runtime is clearly a problem here. No matter the complexity
    of your micro-service or application, irrespective of how many classes in the
    platform you use, you have to bundle in the complete Java runtime with the `rt.jar`
    that contains every Java platform class that's known to exist. So, no matter how
    small your actual application is, bundled with it is at least 60 MB of `rt.jar`
    goodness! Also affected are Java applications that run on smaller devices with
    resource constraints such as IOT and mobile devices. We briefly discussed in [Chapter
    1](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb), *Introducing Java 9
    Modularity*, the CORBA classes in the Java platform and how it exists in all Java
    runtimes since a very long time, although hardly anyone seems to use it anymore.
    As someone creating a self-contained Java executable, it's very fair to ask the
    question--why do I need to include all these classes in the runtime when I don't
    need them?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时的大小显然是一个问题。无论你的微服务或应用程序的复杂性如何，无论你在平台上使用了多少个类，你都必须捆绑包含所有已知Java平台类的`rt.jar`完整的Java运行时。所以，无论你的实际应用程序有多小，捆绑其中的至少有60
    MB的`rt.jar`内容！这也影响了在资源受限的较小设备上运行的Java应用程序，如IOT和移动设备。我们在[第1章](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb)，“介绍Java
    9模块化”中简要讨论了Java平台中的CORBA类以及它存在于所有Java运行时中的情况，尽管似乎没有人再使用它了。作为一个创建自包含Java可执行文件的人，提出这样的问题是非常合理的——为什么我需要包含所有这些类在运行时中，而我不需要它们？
- en: The attempted solution - Compact profiles
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试的解决方案 - 紧凑配置文件
- en: 'With Java 8, there was an introduction of a new concept called **compact profiles**
    to attempt to solve this very problem. Compact profiles are essentially smaller
    versions of the Java runtime that does not have to include the entirety of the
    contents of `rt.jar`. The runtime was broken down at package level to identify
    a closed set of core packages and classes that only depend on themselves so that
    the rest can be broken off and removed. There were three different profiles introduced,
    varying on how much was stripped off. The smallest and the most minimum profile
    is called `compact1`. This version of the runtime contains the very basic language
    features such as IO, collections, util, security, and concurrency. If your needs
    aren''t met with `compact1`, you could also choose between `compact2` and `compact3`,
    and if none of the three work for you, you would go with the full runtime:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8中，引入了一个名为**紧凑配置文件**的新概念，试图解决这个问题。紧凑配置文件本质上是一个更小的Java运行时版本，它不需要包含`rt.jar`的全部内容。运行时在包级别上被分解，以确定一组封闭的核心包和类，这些类只依赖于自身，这样其余的就可以被分割并移除。引入了三个不同的配置文件，它们在移除的内容量上有所不同。最小且最基础的配置文件被称为`compact1`。这个版本的运行时包含了一些基本语言特性，如IO、集合、util、安全和并发。如果你的需求不能通过`compact1`满足，你也可以选择`compact2`或`compact3`，如果这三个都不适合你，你将使用完整的运行时：
- en: '![](img/00043.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00043.jpeg)'
- en: The smallest profile, `compact1`, measures just about 11 MB in size, and is
    a significant improvement from the 60 MB of the full `rt.jar`. But it's obvious
    that we still haven't eliminated the problem of bundling in runtime classes that
    aren't needed. We've just minimized them, and there are still going to be classes
    in whatever profile you choose that your application never uses, but you have
    to include anyway. Additionally, if you have an application that mostly uses classes
    from the `compact1` profile, but needs just a couple of classes from `compact2`,
    well, you have no choice but to bundle the bigger `compact2` profile instead.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最小的配置文件，`compact1`，其大小仅为大约11 MB，相较于完整的`rt.jar`的60 MB来说，这是一个显著的改进。但很明显，我们仍未消除在运行时捆绑不需要的类的问题。我们只是最小化了它们，无论你选择哪个配置文件，你的应用程序都不会使用其中的某些类，但你仍然必须包含它们。此外，如果你有一个主要使用`compact1`配置文件中的类的应用程序，但只需要`compact2`中的几个类，那么，你除了捆绑更大的`compact2`配置文件外别无选择。
- en: I would, however, hesitate to call this a failed attempt at solving this problem.
    In fact, runtime profiles are actually the first steps in the Java platform's
    journey to modularizing of the runtime. However, it is important to note that
    this is the best we could do pre-Java 9 to address the issue of a bulky monolithic
    runtime.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我可能会犹豫是否称这为解决这个问题的失败尝试。事实上，运行时配置文件实际上是Java平台在运行时模块化旅程中的第一步。然而，重要的是要注意，这是在Java
    9之前我们能做的最好的事情，以解决庞大单体运行时的问题。
- en: The state of API encapsulation
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API封装的状态
- en: To best explain the situation (and associated problems) with API encapsulation,
    all we need to do is recall from [Chapter 1](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb),
    *Introducing Java 9 Modularity,* Jack's trouble with his sorting library. He had
    an internal `public` class in his library that wasn't meant for external use,
    but it did end up getting used. If such a small library with the meagerly count
    of two classes could run into this problem, imagine the situation with the Java
    runtime with thousands of classes! The Java language provides documented APIs
    for developers to use. But it also has many supporting classes to facilitate the
    inner workings of those APIs that shouldn't be used by developers. However, surely
    enough, they are all a part of the sole `rt.jar`, so there's nothing stopping
    developers from using those classes either.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最好地解释API封装（及其相关问题）的情况，我们只需要回顾一下[第1章](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb)，“介绍Java
    9模块化”，杰克在排序库上的麻烦。在他的库中有一个内部`public`类，这个类并不是为了外部使用，但它最终还是被使用了。如果一个只有两个类的微小库都可能遇到这个问题，想象一下Java运行时成千上万个类的情况！Java语言为开发者提供了文档化的API。但它也包含许多支持类，以促进这些API的内部运作，这些类不应该被开发者使用。然而，足够的是，它们都是`rt.jar`的一部分，所以没有任何阻止开发者使用这些类的。
- en: Understanding internal APIs
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解内部API
- en: There are several internal classes in the Java runtime that developers aren't
    supposed to use. They aren't documented as part of the language specification,
    but are necessary for the internal functioning of the runtime, perhaps for other
    classes that *are* documented. A great example that's much discussed among Java
    developers in online communities is a class called `sun.misc.Unsafe`, which we
    briefly mentioned in [Chapter 1](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb),
    *Introducing Java 9 Modularity*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Java运行时中存在几个开发者不应该使用的内部类。它们不是作为语言规范的一部分进行文档化的，但对于运行时的内部运作是必要的，也许是为了其他已经文档化的类。在Java开发者在在线社区中广泛讨论的一个很好的例子是名为`sun.misc.Unsafe`的类，我们在[第1章](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb)，“介绍Java
    9模块化”中简要提到了它。
- en: The class `sun.misc.Unsafe` was never meant for public consumption. It was always
    supposed to be an internal class meant for use by the Java runtime only. It is
    not documented. It has no public constructors. The source code of the class is
    filled with warnings about the dangers of using the class. It's funny that even
    the fact that the class having the ominous sounding name `Unsafe` hasn't deterred
    some developers from using it. Of course, `sun.misc.Unsafe` is one of a handful
    of internal classes that have been misused by Java developers. But if it's just
    a handful of classes, you might ask, what's the big deal?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 类`sun.misc.Unsafe`从未打算供公众使用。它始终是一个仅用于Java运行时的内部类。它没有文档。没有公共构造函数。该类的源代码充满了关于使用该类的危险警告。有趣的是，即使类有一个不祥的名字`Unsafe`，也没有阻止一些开发者使用它。当然，`sun.misc.Unsafe`是少数几个被Java开发者误用的内部类之一。但如果你只是少数几个类，你可能会问，这有什么大不了的？
- en: The problem with this model
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这种模型的弊端
- en: Java is commonly known to be a very **backwards compatible** language. While
    the language itself has seen major changes over the years, almost all the changes
    have been additions to the language, while still retaining the functionality of
    the older versions. Let's say you picked up a Java codebase written with Java
    1.3 and you compiled and ran it with Java 8\. Would you be surprised if it ran
    without issues? Probably not! That's precisely because of the reputation Java
    has of being backward compatible. And it's a great thing in my opinion, because
    it gives adopters the confidence that there's not a lot of effort and rewrites
    required for every major upgrade. This is an aspect where Java has an edge over
    a few other development platforms.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Java通常被认为是一种非常**向后兼容**的语言。虽然该语言本身在多年中经历了重大变化，但几乎所有变化都是对语言的补充，同时仍然保留了旧版本的功能。假设你使用Java
    1.3编写的Java代码库，并用Java 8编译和运行它。如果你发现它没有问题地运行，你会感到惊讶吗？可能不会！这正是Java具有向后兼容声誉的原因。在我看来，这是一件好事，因为它给采用者带来了信心，即每次重大升级都不需要太多的努力和重写。这是Java相对于其他几个开发平台的一个优势。
- en: This backward compatibility comes with a cost, especially when you consider
    the lack of encapsulation of internal APIs. What if there is an internal API that
    developers have inadvertently used because of the lack of encapsulation? To maintain
    backward compatibility, the language team is compelled to not make breaking changes
    to those internal APIs even though they are, by definition, internal. So, the
    burden of backward compatibility gets worse for the language--not only do public
    APIs have to be backward compatible, even the internal runtime classes need to
    be as well!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这种向后兼容性是有代价的，特别是当你考虑到内部API缺乏封装时。如果由于缺乏封装，开发者意外地使用了内部API，那会怎么样？为了保持向后兼容性，语言团队被迫不对那些内部API进行破坏性更改，尽管按照定义，它们是内部的。因此，向后兼容性的负担对语言来说变得更重了——不仅公共API需要向后兼容，甚至内部运行时类也需要！
- en: The attempted solution - Deprecation, warnings, and documentation
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试的解决方案 - 弃用、警告和文档
- en: We routinely import classes from packages such as `java.*` and `javax.*` in
    our code because the classes in those packages house most of the public APIs in
    the Java language that are meant for public consumption. There are, however, classes
    in other packages such as `sun.*` that are JDK-internal and you wouldn't find
    in any API documentation. Many of these classes have been a part of Java since
    1.0.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的代码中通常从 `java.*` 和 `javax.*` 等包中导入类，因为这些包中的类包含了Java语言中大部分面向公共消费的公共API。然而，在其他包，如
    `sun.*` 中，也有一些JDK内部类，你不会在任何API文档中找到它们。许多这些类自1.0版本以来一直是Java的一部分。
- en: 'Since the language had no facility to prevent usage of these internal APIs,
    several other attempts have been made to discourage usage. There was an article
    on the Sun website titled *Why developers should not write programs that call
    ''sun'' packages*. The Sun website isn''t up anymore, but the article''s original
    webpage is still preserved for posterity, thanks to WayBack Machine, and is available
    here: [http://web.archive.org/web/19980215011039/http://java.sun.com/products/jdk/faq/faq-sun-packages.html](http://web.archive.org/web/19980215011039/http://java.sun.com/products/jdk/faq/faq-sun-packages.html):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于语言没有防止使用这些内部API的功能，已经尝试了其他几种方法来阻止使用。Sun网站上有一篇文章，标题为 *Why developers should
    not write programs that call 'sun' packages*。Sun网站已经不再存在，但多亏了WayBack Machine，文章的原始网页仍然被保存下来，并可在以下链接找到：[http://web.archive.org/web/19980215011039/http://java.sun.com/products/jdk/faq/faq-sun-packages.html](http://web.archive.org/web/19980215011039/http://java.sun.com/products/jdk/faq/faq-sun-packages.html)：
- en: '![](img/00044.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00044.jpeg)'
- en: Notice the year mentioned on the article! Yes, it's been around as a part of
    the official documentation since back in 1996 (then on java.sun.com)! The warning
    is still around on the Oracle documentation website, by the way. Clearly, 20 years
    of asking developers not to use certain classes hasn't solved the problem! You
    might very well ask, what good is such a warning in documentation if nobody pays
    attention to it? Well, in addition to warnings in documentation, since JDK 6,
    the compiler has been throwing out warnings if your application uses any APIs
    from the `sun.*` packages. However, this is also something that developers could
    easily ignore.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意文章中提到的年份！是的，它自1996年以来一直是官方文档的一部分（当时在java.sun.com上）。顺便说一句，Oracle文档网站上仍然有这个警告。显然，20年来要求开发者不要使用某些类并没有解决问题！你可能会问，如果没有人注意它，这样的警告在文档中有什么用？好吧，除了文档中的警告之外，自JDK
    6以来，编译器如果检测到你的应用程序使用了 `sun.*` 包中的任何API，就会抛出警告。然而，这也是开发者可以轻易忽略的事情。
- en: These approaches are clearly not good enough. We need to be able to enforce
    these rules and provide guardrails to *prevent* developers from using internal
    APIs. There was no such feature available in the language so far. The language
    just had to evolve.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法显然还不够好。我们需要能够强制执行这些规则，并为开发者提供护栏，以**防止**他们使用内部API。到目前为止，这种功能在语言中并不存在。语言只能不断进化。
- en: Enter Project Jigsaw
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入 Project Jigsaw
- en: '*Project Jigsaw* was the effort to apply the concepts and features of modularity
    to the Java platform itself. The modularization of the platform essentially solves
    both the problems described previously. We''ll look at how later in this chapter,
    but let''s begin looking at the work that was done for *Project Jigsaw* and how
    it affects developers interacting with the Java platform.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*Project Jigsaw* 是将模块化的概念和特性应用于Java平台本身的努力。平台的模块化本质上解决了之前描述的这两个问题。我们将在本章后面探讨这一点，但让我们先看看为
    *Project Jigsaw* 做的工作以及它如何影响与Java平台交互的开发者。'
- en: 'The project itself was a huge effort that involved the following high-level
    steps:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目本身是一个巨大的努力，涉及以下高级步骤：
- en: Re-organizing the platform source code to make it more conducive for modularization.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对平台源代码进行重新组织，使其更有利于模块化。
- en: Defining and building modules with predefined input and output interfaces and
    with a clear dependency map.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义和构建具有预定义输入和输出接口以及清晰的依赖映射的模块。
- en: Encapsulating *internal* classes and allowing usage for only *public* APIs.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 封装*内部*类，并允许仅使用*公共*API。
- en: Providing tools for generating smaller and modular runtime images as an alternative
    to the monolithic `rt.jar`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供生成更小、更模块化的运行时镜像的工具，作为对单体`rt.jar`的替代。
- en: Let's deep-dive into the changes now and see how it affects us.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们深入探讨这些变化，看看它对我们有什么影响。
- en: Platform modularity
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平台模块化
- en: With Java 9, the entire Java platform, with every class in it, has been segregated
    and grouped into modules. Yes, all of the platform Java classes from `Collections`
    and `Thread` to `Connection` and `Logger`! It doesn't really matter which one;
    every platform class is now housed in newly created Java modules that come out-of-the-box
    with the runtime and the JDK. The platform team achieved this by going through
    both the public APIs and internal classes, grouping them based on the types that
    usually go well together and are self-contained, and bundling such related classes
    into modules.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9中，整个Java平台，包括其中的每个类，都被隔离并分组到模块中。是的，从`Collections`和`Thread`到`Connection`和`Logger`的所有平台Java类！实际上哪个都无关紧要；每个平台类现在都存放在与运行时和JDK一起提供的全新Java模块中。平台团队通过检查公共API和内部类，根据通常很好地一起使用且自包含的类型进行分组，并将此类相关类捆绑到模块中，实现了这一点。
- en: 'Take Java logging for example. The native logging functionality in Java comprised
    of a group of classes in the package `java.util.logging`. These classes have now
    been grouped into a newly created module called `java.logging`. The JDBC and SQL
    related classes have all gone into a new module called `java.sql`. XML related
    classes have gone into the module `java.xml`. Here are a few more examples of
    modules that come out-of-the-box with Java 9:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以Java日志为例。Java中的原生日志功能由`java.util.logging`包中的一组类组成。这些类现在已被归类到一个新创建的模块中，称为`java.logging`。与JDBC和SQL相关的类都进入了一个名为`java.sql`的新模块。与XML相关的类进入了`java.xml`模块。以下是Java
    9自带的一些模块的更多示例：
- en: '`java.scripting`: Provides the scripting APIs for the Java scripting engine'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.scripting`：为Java脚本引擎提供脚本API'
- en: '`java.desktop`: Provides the Java desktop APIs, `awt`, and `swing` packages'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.desktop`：提供Java桌面API，包括`awt`和`swing`包'
- en: '`java.transaction`: Provides transaction related APIs in package `javax.transaction`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.transaction`：在`javax.transaction`包中提供事务相关API'
- en: There is also a special module named `java.base`. The module `java.base` contains
    APIs and classes that are fundamental to the Java platform and without which one
    could not possibly write any Java code. The `java.base` module contains APIs from
    packages such as `java.lang`, `java.io`, `java.util` and so on. As you can see,
    it covers a lot of basic Java APIs that most of our Java applications use. Now,
    why do I call this module special? Hold that thought! We'll get back to it in
    a bit.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个名为`java.base`的特殊模块。`java.base`模块包含Java平台的基本API和类，没有这些，就不可能编写任何Java代码。`java.base`模块包含来自`java.lang`、`java.io`、`java.util`等包的API。正如你所见，它涵盖了大多数Java应用程序使用的许多基本Java
    API。那么，为什么我会称这个模块为特殊呢？请记住这个想法！我们稍后会回到这个问题。现在，让我们继续：
- en: The impact of platform modularity
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平台模块化的影响
- en: "As you can imagine, the impact of this change is indeed significant, and it\
    \ pretty much affects the way we write all Java code from now on. In Java 8 and\
    \ earlier, you didn't have to think twice about using any Java API. All you had\
    \ to do is import the types you need into your code. Since the JVM knew where\
    \ to find `rt.jar`, the necessary classes were always found by the runtime. That's\
    \ no longer the case with Java 9\\. Remember in [Chapter 3](part0048.html#1DOR00-ed2405f4162b4f86b565edd6b6d679fb),\
    \ *Handling Inter-Module Dependencies* \uFEFF, when you needed a class in the\
    \ `packt.addressbook` module from the `packt.sortutil` module? You couldn't just\
    \ import the class in your code and use it. You had to go to the module definition\
    \ of `packt.addressbook` and specify the dependency on the module using the `requires`\
    \ clause. That's exactly what you'll need to do for native Java platform types\
    \ too!"
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，这种变化的冲击确实很大，并且几乎影响了从现在开始我们编写所有Java代码的方式。在Java 8及之前，你不必过多考虑使用任何Java API。你所要做的就是将所需的类型导入到你的代码中。由于JVM知道在哪里找到`rt.jar`，必要的类总是由运行时找到。但在Java
    9中就不再是这种情况了。记得在[第3章](part0048.html#1DOR00-ed2405f4162b4f86b565edd6b6d679fb)中，*处理模块间依赖*，当你需要从`packt.sortutil`模块中获取`packt.addressbook`模块中的类时？你无法只是将类导入到你的代码中并使用它。你必须去`packt.addressbook`模块的定义中，并使用`requires`子句指定对该模块的依赖。这正是你需要为本地Java平台类型所做的事情！
- en: 'Need to use Java SQL APIs? They are in the module `java.sql`, so in the module
    where you need them, you need to specify this in the module descriptor:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 需要使用Java SQL API？它们位于`java.sql`模块中，因此在你需要它们的模块中，你需要在模块描述符中指定这一点：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once you have required the necessary platform module, its APIs are then ready
    for use in your module. Since the `java.sql` module is built on the same Java
    module system that you use to write your code, you can bet that there's code in
    the `module-info` file of the `java.sql` module that exports the `java.sql` and
    `javax.sql` packages that contain the Java SQL API.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你要求了必要的平台模块，它的API就准备好在你的模块中使用。由于`java.sql`模块是基于你用来编写代码的相同的Java模块系统构建的，你可以确信在`java.sql`模块的`module-info`文件中存在代码，它导出了包含Java
    SQL API的`java.sql`和`javax.sql`包。
- en: This necessity to *require* modules before using them applies not just to our
    own modules; it applies to the Java modules too. For example, the `java.sql` module
    requires logging functionality (for obvious reasons). And the logging APIs are
    in the `java.logging` module. So, there's a `requires` declaration in `java.sql`
    module's `module-info.java` file specifying this requirement. That's the only
    way code in the `java.sql` module can import and use the logging APIs.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用模块之前必须*要求*模块的需求不仅适用于我们自己的模块，也适用于Java模块。例如，`java.sql`模块需要日志功能（出于明显的原因）。而日志API位于`java.logging`模块中。因此，在`java.sql`模块的`module-info.java`文件中有一个`requires`声明来指定这个需求。这是`java.sql`模块中的代码能够导入和使用日志API的唯一方式。
- en: 'This is how the `module-info.java` of `java.sql` module should look to enable
    the configuration we''ve discussed so far:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`java.sql`模块的`module-info.java`文件应该看起来像什么样子，以便启用我们之前讨论过的配置：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Module graph
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块图
- en: 'The result of these individual Java modules depending on one another is that
    we can now draw a complete graph of dependencies with the modules as nodes and
    the relationships between nodes as module dependencies. This kind of picture is
    called a **module graph** and is your new best friend to help you track and manage
    module dependencies in your Java 9 modular applications. We looked at a simple
    module graph of the address book application in the previous chapter. Here''s
    a simple module graph that specifies the dependencies between a handful of Java
    platform modules:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些单独的Java模块相互依赖的结果是，我们现在可以绘制一个完整的依赖图，其中模块作为节点，节点之间的关系作为模块依赖。这种图片被称为**模块图**，它是你追踪和管理Java
    9模块化应用程序中模块依赖的新最佳伙伴。我们在上一章中查看了一个地址簿应用程序的简单模块图。这是一个简单的模块图，它指定了一小批Java平台模块之间的依赖关系：
- en: '![](img/00045.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00045.jpeg)'
- en: A line drawn from module *A* to module *B* indicates that module *A* `requires`
    module *B*. So, as this diagram indicates, module `java.transaction` requires
    `java.rmi`, which in turn requires `java.base`. As mentioned before, since `java.base`
    contains APIs that are fundamental to the language, it is one module that every
    other module is sure to need. Which is why, this one module is treated a bit differently.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从模块*A*到模块*B*的线条表示模块*A* `requires` 模块*B*。所以，正如这个图所示，模块`java.transaction`需要`java.rmi`，而`java.rmi`又需要`java.base`。如前所述，由于`java.base`包含对语言基本而言的API，它是每个其他模块都肯定需要的模块。这就是为什么这个模块被稍微特殊对待的原因。
- en: The java.base module
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`java.base`模块'
- en: In [Chapter 2](part0033.html#VF2I0-ed2405f4162b4f86b565edd6b6d679fb), *Creating
    Your First Java Module*, and [Chapter 3](part0048.html#1DOR00-ed2405f4162b4f86b565edd6b6d679fb),
    *Handling Inter-Module Dependencies*, you wrote a few Java 9 modules that used
    some Java APIs such as `Collection` and `System.out`. These APIs happen to come
    from the `java.base` module. You might have noticed something wrong with the picture
    here. Since these core Java APIs are in its own module, shouldn't we have had
    to add the `requires java.base;` line in all our module descriptors before we
    used them? How did the compilation succeed without it? Well, let me assure you
    that there's no trickery involved here. The reason it worked is due to the special
    nature of the `java.base` module.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](part0033.html#VF2I0-ed2405f4162b4f86b565edd6b6d679fb)《创建您的第一个Java模块》和[第3章](part0048.html#1DOR00-ed2405f4162b4f86b565edd6b6d679fb)《处理模块间依赖》中，您编写了一些使用了一些Java
    API（如`Collection`和`System.out`）的Java 9模块。这些API恰好来自`java.base`模块。您可能已经注意到这里图片中的某些问题。由于这些核心Java
    API位于其自己的模块中，我们不应该在使用它们之前在所有模块描述符中添加`requires java.base;`行吗？为什么没有它编译也能成功？好吧，让我向您保证，这里没有涉及任何诡计。它之所以能工作，是因为`java.base`模块的特殊性质。
- en: When was the last time you had to write the line `import java.lang.*` in your
    Java class? Never, I hope! You don't need to import classes from the package `java.lang`
    because it is imported and available to your Java code by default. That's because
    the classes in that package are so commonly used that it's a sensible default
    to always have the types in the package imported.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 上次您在Java类中写`import java.lang.*`是在什么时候？我希望是永远不会！您不需要从`java.lang`包导入类，因为这个包默认导入并可供您的Java代码使用。这是因为该包中的类使用得非常普遍，因此默认总是导入这个包中的类型是合理的。
- en: Java 9 has a similar shortcut for requiring the `java.base` module. This module
    contains the `java.lang` package among other fundamental Java APIs that almost
    no Java module can be written without. So, rather than every Java module in existence
    having to *require* the `java.base` module, it is just required by default, so
    you don't have to explicitly specify it. Now, since the `java.lang` packages are
    in the `java.base` module, the default behavior is seamless in both cases! See
    how that works?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 为要求`java.base`模块提供了一个类似的快捷方式。这个模块包含了许多基本的Java API，例如`java.lang`包，几乎所有Java模块在编写时都离不开这些API。因此，并不是所有存在的Java模块都必须**要求**`java.base`模块，它默认就是必需的，所以你不需要显式指定它。现在，由于`java.lang`包位于`java.base`模块中，两种情况下的默认行为都是无缝的！看看这是怎么工作的？
- en: Remember, though, that this is the only module that has this behavior. Every
    other Java module in existence, platform or otherwise, will have to be explicitly
    *required*, if the module is needed as a dependency.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请记住，这是唯一具有这种行为的模块。存在于任何其他地方的Java模块，无论是平台模块还是其他类型的模块，如果需要作为依赖项，都必须显式**要求**。
- en: 'Since there is always an implicit dependency on `java.base`, a common practice
    when writing module graphs is to skip the dependency on this base module in order
    to make things more legible. The idea is to show a module depending on `java.base`
    only if the given module''s *only* dependency is `java.base`. If a module depends
    on other modules, we show only that and skip the `java.base` dependency. Here''s
    how the module graph from earlier looks with this approach:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于始终存在对`java.base`的隐式依赖，在编写模块图时，通常的做法是跳过对这个基础模块的依赖，以便使内容更易于阅读。其思路是，只有当给定模块的**唯一**依赖是`java.base`时，才显示模块依赖于`java.base`。如果一个模块依赖于其他模块，我们只显示这些依赖，并跳过`java.base`依赖。以下是使用这种方法之前模块图的样子：
- en: '![](img/00046.jpeg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00046.jpeg)'
- en: I hope you'll agree this graph looks a bit cleaner. This is a practice that
    people seem to be increasingly following, so when you come across such module
    graphs, don't forget the implicit `java.base` dependency. It's always there!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你会同意这个图表看起来有点更整洁。这似乎是人们越来越遵循的实践，所以当你遇到这样的模块图时，不要忘记隐含的`java.base`依赖。它始终存在！
- en: Browsing modules
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块浏览
- en: Now that you've looked at some of the modules that come with Java, you might
    be wondering how you can get more information about them. How can you find out
    what the list of modules are that come with the platform? Given an API, how can
    you know which platform module contains it? And given a module, how can you know
    what are the packages it exports?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经查看了一些Java附带的一些模块，你可能想知道如何获取更多关于它们的信息。你如何找到与平台一起提供的模块列表？给定一个API，你如何知道哪个平台模块包含它？以及给定一个模块，你如何知道它导出了哪些包？
- en: The answer is a couple of new arguments to the `java` command. First is an option
    called `--list-modules`. This command lets you examine the modules that are available
    for you from the platform.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是向`java`命令添加几个新的参数。第一个是一个名为`--list-modules`的选项。这个命令让你检查从平台可用的模块。
- en: 'When you run the following command from the Command Prompt, this is what you''ll
    see:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从命令提示符运行以下命令时，你会看到以下内容：
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The list you see there is the list of all the Java platform modules! As you
    scroll the list, notice that the modules we discussed previously are all there!
    This is a great way to browse through and get a good idea of what's available.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到的那张列表是所有Java平台模块的列表！当你滚动列表时，注意我们之前讨论的模块都在那里！这是浏览并了解可用内容的好方法。
- en: 'There''s another new option `-d`, which helps in examining the details of a
    single module. The syntax is:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另外还有一个新的选项 `-d`，它有助于检查单个模块的详细信息。语法是：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can also use the longer form  `--describe-module` to do the same:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用较长的形式`--describe-module`来完成同样的操作：
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For example, if you want to look at more details about the `java.base` module,
    run the following command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想查看`java.base`模块的更多详细信息，运行以下命令：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The output has been truncated for brevity, but as you scroll down the result
    of the command, you'll notice various details about the module listed.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁，输出已被截断，但当你向下滚动命令的结果时，你会注意到关于列出的模块的各种细节。
- en: 'Here''s the output of the command run on the module `java.sql`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是运行在`java.sql`模块上的命令输出：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In these module-level outputs, you''ll notice the following categories of information
    displayed:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些模块级别的输出中，你会注意到以下几类信息显示：
- en: '**Exports**: This is the list of all the packages exported by the module. In
    the `java.base` module, you''ll see familiar packages such as `java.io` and `java.lang`
    here. The `java.sql` module exports packages `java.sql` and `javax.sql`. These
    packages marked with `exports` are all the packages that the module exports. Thereby,
    when you `require` the module, (which you do by default with `java.base`), your
    module gets access to the types in the *required* module that also belong to those
    *exported* packages. In the output, you''ll notice some statements in the form 
    `exports <package-name> to <module-name>` . These are called qualified exports.
    We''ll be covering qualified exports in [Chapter 6](part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb),
    *Module Resolution, Readability, and Accessibility*.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导出**：这是模块导出的所有包的列表。在`java.base`模块中，你会看到熟悉的包，如`java.io`和`java.lang`。`java.sql`模块导出包`java.sql`和`javax.sql`。这些标记为`exports`的包是该模块导出的所有包。因此，当你`require`模块时（默认情况下使用`java.base`），你的模块将能够访问属于那些`exported`包的`required`模块中的类型。在输出中，你会注意到一些形式为`exports
    <package-name> to <module-name>`的语句。这些被称为限定导出。我们将在[第6章](part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb)中介绍限定导出，*模块解析、可读性和可访问性*。'
- en: '**Contains**: This is the list of internal packages that the module *contains*
    but does not export. These packages are, by definition, not visible outside the
    module. It is still handy for us developers to know what the packages are that
    belong to the *internal* module API because a lot of these had been APIs that
    existed in Java 8 and thus, used to be available publicly earlier. For example,
    look at the packages `jdk.internal.*` and `sun.util.*` in the `java.base` module.
    They are not in the `exports` list so they are now effectively encapsulated in
    the module.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包含**：这是模块*包含*但不导出的内部包列表。根据定义，这些包在模块外部是不可见的。对于我们开发者来说，了解属于*内部*模块API的包仍然很有用，因为其中许多曾是Java
    8中的API，因此以前是公开可用的。例如，看看`java.base`模块中的`jdk.internal.*`和`sun.util.*`包。由于它们不在`exports`列表中，因此现在实际上被封装在模块中。'
- en: '**Requires**: This is the list of modules that a given module requires. The
    `java.sql` module requires three other modules--`java.base`, `java.logging`, and
    `java.xml`. The requirement of `java.base` is by default, and so it is qualified
    with a `requires mandated` clause. Note that you *do not* have to do this in your
    own modules, since that''s default behavior. Ignore the `requires transitive`
    clause for now. That''s related to making modules available to dependent modules,
    a concept we''ll explore in detail in [Chapter 6](part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb),
    *Module Resolution, Accessibility, and Readability*. Also, as is obvious, `java.base`
    does not `require` any other module.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**需要**：这是给定模块需要的模块列表。`java.sql`模块需要另外三个模块--`java.base`、`java.logging`和`java.xml`。`java.base`的需求是默认的，因此它带有`requires
    mandated`子句。请注意，你*不需要*在自己的模块中这样做，因为这是默认行为。现在忽略`requires transitive`子句。这与使模块对依赖模块可用相关，我们将在[第6章](part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb)“模块解析、可访问性和可读性”中详细探讨。显然，`java.base`不需要任何其他模块。'
- en: '**Uses and** **provides**: These are related to the concept of Services, which
    we''ll be exploring in [Chapter 7](part0110.html#38STS0-ed2405f4162b4f86b565edd6b6d679fb),
    *Introducing Services*.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用和提供**：这与服务概念相关，我们将在[第7章](part0110.html#38STS0-ed2405f4162b4f86b565edd6b6d679fb)“介绍服务”中探讨。'
- en: I recommend using the `java --list-modules` and `java -d <module-name>` commands
    to explore other modules in the platform. As you start writing modular code in
    Java 9, you'll often need to import platform classes, and that requires the identification
    of modules that export them. Initially, you'll need to use these commands to get
    to the right module, but when you do this a few times, you'll be committing to
    your memory the common packages and the modules that have them available, and
    so you don't need to do this anymore. What also helps is the intuitive names for
    the modules. Need to use SQL classes? You just *know* they are in `java.sql`!
    Granted, some packages may not be all that intuitive, but still, the naming convention
    followed goes a long way in helping developers get to the right modules quickly.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议使用`java --list-modules`和`java -d <module-name>`命令来探索平台中的其他模块。当你开始在Java 9中编写模块化代码时，你通常会需要导入平台类，这需要识别导出它们的模块。最初，你需要使用这些命令来找到正确的模块，但当你这样做几次后，你将记住常见的包和包含它们的模块，因此你不再需要这样做。模块的直观名称也有帮助。需要使用SQL类？你只需*知道*它们在`java.sql`中！当然，一些包可能不是那么直观，但仍然，遵循的命名约定在很大程度上有助于开发者快速找到正确的模块。
- en: Module types
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块类型
- en: 'Speaking of naming conventions, you might have noticed the different prefixes
    to the module names when you ran the `java --list-modules` command. The three
    prefixes to the platform modules are--`java.`, `javafx.`, and `jdk.`. The prefix
    indicates the nature of the module:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 说到命名约定，当你运行`java --list-modules`命令时，你可能已经注意到了模块名称的不同前缀。平台模块有三个前缀--`java.`、`javafx.`和`jdk.`。前缀表示模块的性质：
- en: '`java`: Indicates the core Java platform module. These are what''s referred
    to in the official documentation as *standard modules*.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java`：表示核心Java平台模块。这些在官方文档中被称为*标准模块*。'
- en: '`javafx`: Indicates modules of Java FX, the platform for building desktop applications
    in Java.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx`：表示Java FX模块，这是用Java构建桌面应用程序的平台。'
- en: '`jdk`: Indicates core JDK modules. These are not part of the language specification,
    but contain valuable APIs and tools for the Java developer, including the `jdk.compiler`
    and `jdk.javadoc`, as well as debugging and serviceability tools and APIs such
    as `jdk.jdi` and `jdk.jconsole`.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jdk`: 表示核心 JDK 模块。这些模块不属于语言规范的一部分，但包含对 Java 开发者有价值的 API 和工具，包括 `jdk.compiler`
    和 `jdk.javadoc`，以及调试和服务性工具和 API，如 `jdk.jdi` 和 `jdk.jconsole`。'
- en: '`oracle`: If you''ve downloaded the Oracle Open JDK, you might see a couple
    of modules beginning with this prefix. Remember that these are non-standard modules
    that are specific to this flavor of the JDK implementation and they will not be
    available in other implementations. For this reason, it''s a good idea to completely
    ignore these modules.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oracle`: 如果你下载了 Oracle Open JDK，你可能会看到一些以这个前缀开始的模块。记住，这些是非标准模块，特定于这种 JDK 实现的版本，并且在其他实现中不可用。因此，完全忽略这些模块是一个好主意。'
- en: 'The `java.` prefixed modules themselves can be classified into three categories:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀为 `java.` 的模块本身可以分为三类：
- en: '**Core Java modules**: These are necessary for the Core Java functionality.
    Modules such as `java.base`, `java.xml`, and so on, which are APIs usually referred
    to as Core Java SE APIs. This is in contrast to Enterprise APIs, the next category.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**核心 Java 模块**：这些模块对于核心 Java 功能是必要的。例如 `java.base`、`java.xml` 等模块，通常被称为核心 Java
    SE API。这与下一类企业 API 相区别。'
- en: '**Enterprise modules**: This category contains modules such as `java.corba`
    that contains APIs leveraging CORBA technology and `java.transaction`, which provide
    database transaction APIs usually required in an Enterprise application context.
    Note that this is different from Java EE, which is the completely different spec.
    However, there has always been a small overlap between what got bundled with the
    Java SE and Java EE SDKs. To avoid this overlap, as of Java 9, these Enterprise
    modules have been marked as deprecated and might be removed in a future Java version.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**企业模块**：这一类别包含如 `java.corba` 这样的模块，它利用 CORBA 技术提供 API，以及 `java.transaction`，在企业应用程序环境中通常需要提供数据库事务
    API。请注意，这与 Java EE 完全不同的规范。然而，Java SE 和 Java EE SDK 之间始终存在一些重叠。为了避免这种重叠，从 Java
    9 开始，这些企业模块已被标记为已弃用，并且可能在未来的 Java 版本中删除。'
- en: '**Aggregator modules**: These are modules that do not contain any APIs by themselves,
    but instead act as a convenient way to bundle multiple modules together. Specifying
    a `requires` dependency on the aggregator module is equivalent to individually
    specifying the `requires` dependency on all the individual modules that the aggregator
    module aggregates. You''ll learn how to build your own custom aggregator modules
    in [Chapter 6](part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb), *Module
    Resolution, Accessibility, and Readability*. For now, note that there are a couple
    of aggregator modules that come bundled with the platform. They are:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合模块**：这些模块本身不包含任何 API，而是作为将多个模块捆绑在一起的一种方便方式。在聚合模块上指定 `requires` 依赖项相当于分别指定聚合模块所汇集的所有单个模块的
    `requires` 依赖项。你将在 [第 6 章](part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb)
    中学习如何构建自己的自定义聚合模块，*模块解析、可访问性和可读性*。现在，请注意，平台附带了一些聚合模块。它们是：'
- en: '`java.se`: This is a convenient aggregator module that gathers all the *standard*
    Java SE modules together.'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.se`: 这是一个方便的聚合模块，它将所有 *标准* Java SE 模块汇集在一起。'
- en: '`java.se.ee`: This aggregator module gathers all the `java.se` modules and
    adds in the APIs that overlap with the Java EE specification.'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.se.ee`: 这个聚合模块汇集了所有 `java.se` 模块，并添加了与 Java EE 规范重叠的 API。'
- en: While aggregator modules provide a level of convenience, I'd recommend using
    them with care. When writing a Java application, it can be tempting to just `require`
    the `java.se` module, for instance, to pull down the entire Java SE platform.
    That way, you don't have to bother with identifying which platform modules contain
    the APIs you want and thus need to import. With just one line--`requires java.se`,
    you have the whole platform at your disposal. But then, you are losing several
    advantages of the modularization of the platform. You then end up with a bulky
    Java platform with unnecessary classes, no different from Java 8 and earlier.
    The aggregator modules are provided for convenience to be used only when necessary.
    So, make sure you use them right.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然聚合模块提供了一定的便利性，但我建议您谨慎使用。在编写 Java 应用程序时，可能会诱使您仅仅 `require` `java.se` 模块，例如，以拉取整个
    Java SE 平台。这样，您就不必麻烦地识别包含您想要的 API 的平台模块，从而需要导入。只需一行——`requires java.se`，您就可以拥有整个平台。但这样，您就失去了平台模块化的几个优势。您最终会得到一个庞大的
    Java 平台，包含不必要的类，与 Java 8 及更早版本没有区别。聚合模块是为了便利性提供的，仅在必要时使用。因此，请确保您正确使用它们。
- en: Examining platform file structure
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查平台文件结构
- en: 'Let''s now examine how these changes to the platform manifest in the file structure
    of the installation. Historically, the Java platform has come in two flavors--The
    **Java Runtime environment** (**JRE**) and the **Java Development Kit** (**JDK**).
    The JDK is the superset, in that it contains the JRE. Here''s a high-level structure
    of the classic JDK with only a few important files shown for the sake of simplicity:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来检查这些对平台的影响如何在安装的文件结构中体现。历史上，Java 平台有两种类型——**Java 运行时环境**（**JRE**）和**Java
    开发工具包**（**JDK**）。JDK 是超集，因为它包含了 JRE。以下是一个经典的 JDK 的高层次结构，为了简化只显示了几个重要的文件：
- en: '![](img/00047.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00047.jpeg)'
- en: 'The Java 9 JDK looks very different. You can navigate to the directory using
    the `cd $JAVA_HOME` command. Here''s what the new JDK looks like, again with only
    a few important files displayed:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 JDK 的外观非常不同。您可以使用 `cd $JAVA_HOME` 命令导航到该目录。以下是新 JDK 的样子，同样只显示了几个重要的文件：
- en: '![](img/00048.jpeg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00048.jpeg)'
- en: 'There are a couple of important differences that should be noted:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个重要的区别需要注意：
- en: There is no JRE folder within the main folder anymore. The structure is now
    collapsed into one common folder. JDK 9 moves away from the distinction between
    JRE and JDK to create a common runtime binary file structure. This structure contains
    the `bin`, `lib`, and `conf` folders at the top level, with no nested folders
    for the runtime. This change was implemented to provide the ability to create
    custom runtime images that are now supported in Java 9\. You'll learn more about
    generating such images in [Chapter 8](part0124.html#3M85O0-ed2405f4162b4f86b565edd6b6d679fb),
    *Understanding Linking and Using jlink*.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主文件夹中不再有 JRE 文件夹。结构现在已合并到一个公共文件夹中。JDK 9 放弃了 JRE 和 JDK 之间的区别，以创建一个共同的运行时二进制文件结构。此结构在顶级包含
    `bin`、`lib` 和 `conf` 文件夹，没有嵌套的运行时文件夹。这一变化是为了提供创建自定义运行时图像的能力，现在在 Java 9 中得到了支持。您将在第
    8 章[理解链接和使用 jlink](part0124.html#3M85O0-ed2405f4162b4f86b565edd6b6d679fb)中了解更多关于生成此类图像的信息。
- en: There's a new folder called `jmods` that contains all the packaged platform
    modules that we've learnt about so far. With Java 9, it's time to say goodbye
    to `rt.jar`. There is no single monolithic jar file that houses the entire platform.
    Each platform module has a corresponding file in the `jmods` folder. So, what
    would have formerly been a single `rt.jar` file is now split into separate module
    files, one for each platform module.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个名为 `jmods` 的新文件夹，其中包含我们迄今为止所了解的所有打包的平台模块。随着 Java 9 的到来，是时候告别 `rt.jar` 了。不再有一个单一的、包含整个平台的单体
    jar 文件。每个平台模块在 `jmods` 文件夹中都有一个对应的文件。因此，原本是一个单独的 `rt.jar` 文件现在被分割成单独的模块文件，每个平台模块一个。
- en: Notice the `.jmod` file extension of the module files. Shouldn't those be `.jar`
    files? With Java 9, a new format called JMOD has been introduced as a new way
    of bundling libraries specifically for development time, and not for runtime.
    The traditional jar format is great for bundling classes for runtime use, but
    since they are just a ZIP file of compiled classes, they aren't very useful when
    using them during development time. The new JMOD format goes beyond the JAR format
    by including the ability to bundle in things such as native code and configuration
    files, which makes it useful for distributing libraries for development use. This
    is the format used by the JDK to bundle all built-in platform modules. The details
    of the format are beyond the scope of what we are covering here. Just think of
    it as the new dev-time-only alternative to the JAR format.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意模块文件的`.jmod`文件扩展名。难道它们不应该是`.jar`文件吗？从Java 9开始，引入了一种新的格式，称为JMOD，作为开发时间特定库捆绑的新方式，而不是运行时。传统的JAR格式非常适合捆绑用于运行时的类，但既然它们只是编译类的ZIP文件，那么在开发时使用它们并不是非常有用。新的JMOD格式在JAR格式的基础上增加了捆绑本地代码和配置文件等功能，这使得它对于分发用于开发用途的库非常有用。这是JDK用于捆绑所有内置平台模块的格式。该格式的详细信息超出了我们在此所涵盖的范围。只需将其视为JAR格式的仅开发时间替代方案即可。
- en: Observable modules
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可观察模块
- en: There are two module path values we pass to the `javac` and `java` commands--the
    module source path (passed to `javac`) containing the uncompiled Java source modules
    and the module path (passed to `javac` and  `java`) containing the compiled Java
    modules. These options point to the locations of all the modules that are available
    for the compiler and the runtime to look up and use when necessary. Notice that
    we didn't have to add the path to the Java platform modules. That's because the
    Java runtime modules are included by default in the module path for compiling
    with `javac` and executing with `java`. You have to add the path only to the modules
    that are not a part of the platform, but you intend to include for compilation
    or execution.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向`javac`和`java`命令传递了两个模块路径值——模块源路径（传递给`javac`），其中包含未编译的Java源模块，以及模块路径（传递给`javac`和`java`），其中包含编译后的Java模块。这些选项指向所有可供编译器和运行时查找和使用的位置。请注意，我们不必添加Java平台模块的路径。这是因为Java运行时模块默认包含在`javac`编译和`java`执行时的模块路径中。你只需添加不属于平台但打算用于编译或执行的模块的路径。
- en: This complete set of modules including modules in the module path that you supply
    to the platform *and* the out-of-the-box platform modules that are automatically
    available are together referred to as *observable modules*. As the name indicates,
    these are the modules that the platform *observes* in order to satisfy module
    dependencies. If a required module is not among the set of observable modules,
    the platform complains that the module is missing.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个完整的模块集包括你提供给平台的模块以及自动可用的开箱即用的平台模块，统称为*可观察模块*。正如其名所示，这些是平台为了满足模块依赖而*观察*的模块。如果所需的模块不在可观察模块集中，平台会抱怨该模块缺失。
- en: How do you know what the observable modules are? When we've used the `java --list-modules`
    command to list the platform modules, what we are actually doing is listing all
    observable modules. And, by default, only the platform modules are observable.
    You can also find out what are the observable modules for a given module path.
    You do that by specifying the `--module-path` option to the same command. You
    can specify as value a set of directory locations that form the module path. In
    that case, the command would display the list of observable modules *for that
    module path*, which would include all the platform modules along with any compiled
    modules in that module path.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何知道可观察模块是什么？当我们使用`java --list-modules`命令列出平台模块时，我们实际上是在列出所有可观察模块。默认情况下，只有平台模块是可观察的。你还可以找出给定模块路径的可观察模块。你可以通过指定命令的`--module-path`选项来完成此操作。你可以指定一组目录位置，这些位置形成模块路径。在这种情况下，命令将显示该模块路径的*可观察模块列表*，其中包括所有平台模块以及该模块路径中的任何编译模块。
- en: 'For example, if you were to run the command with the module path being the
    compiled modules in the `out` folder from the previous chapter (`03-two-modules`),
    here''s what you''ll see:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你要运行带有模块路径的命令，该路径是上一章（`03-two-modules`）中`out`文件夹中的编译模块，你将看到以下内容：
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that in addition to the platform modules, there are two of our own modules
    showing up in the list. This is because they are in the module path we've passed
    as a parameter to the command, thus adding them to the list of observable modules
    for that module path. For non-platform modules, the output also includes the path
    of the module. This makes it handy to locate modules when there are multiple directories
    passed to the  `--module-path` option.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，除了平台模块外，列表中还有两个我们自己的模块。这是因为它们位于我们传递给命令的模块路径中，因此被添加到该模块路径的观察模块列表中。对于非平台模块，输出还包括模块的路径。这使得在传递多个目录给`--module-path`选项时定位模块变得方便。
- en: Revisiting the two problems
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视两个问题
- en: 'We started this chapter looking at two issues with the Java platform:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章开始时探讨了Java平台存在的两个问题：
- en: The monolithic runtime
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单体运行时
- en: The lack of API encapsulation features
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺乏API封装功能
- en: Interestingly, the modularization of the Java platform provides solutions to
    both these problems.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，Java平台的模块化提供了解决这两个问题的方案。
- en: Solving the monolithic runtime
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决单体运行时
- en: There is a distinct advantage of knowing which platform modules your application
    belongs to. It is a clear indication of which platform modules it doesn't need--which
    is anything the modules in the application doesn't use! So, for example, if your
    application contains modules that only `require` the platform modules `java.base`
    and `java.logging`, you can essentially create a small subset of the Java platform
    consisting of just those two modules. That slice of the platform is all that your
    application needs to function. If you are bundling the runtime with your application,
    you now know the exact portion of the runtime you need to bundle, no more no less!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 了解您的应用程序属于哪个平台模块具有明显的优势。这是它不需要哪些平台模块的明确指示——即应用程序中不使用的任何模块！例如，如果您的应用程序包含仅`require`平台模块`java.base`和`java.logging`的模块，您实际上可以创建一个只包含这两个模块的Java平台的小子集。这个平台的部分就是您的应用程序运行所需的所有内容。如果您正在将运行时与应用程序捆绑在一起，现在您就知道需要捆绑的确切运行时部分，不多也不少！
- en: Java 9 comes with a brand-new *static linking* step that lets you create custom
    runtime images with only the modules that your applications need. This results
    in smaller and leaner application distributable, micro-service executables, and
    so on. You'll learn more about the linking phase and how to create your own runtimes
    in [Chapter 8](part0124.html#3M85O0-ed2405f4162b4f86b565edd6b6d679fb), *Understanding
    Linking and Using jlink*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9带来了全新的*静态链接*步骤，允许您仅使用应用程序需要的模块创建自定义运行时映像。这导致应用程序分发、微服务可执行文件等变得更小、更精简。您将在[第8章](part0124.html#3M85O0-ed2405f4162b4f86b565edd6b6d679fb)“理解链接和使用jlink”中了解更多关于链接阶段以及如何创建自己的运行时的信息。
- en: Solving the API encapsulation problem
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决API封装问题
- en: Thanks to Java platform modules leveraging the encapsulation concepts of modularity,
    the platform now has the means to effectively protect internal classes from external
    usage. The platform can evolve to modify or even completely remove and replace
    the internal APIs, and still ensure backward compatibility as long as the *public*
    exported APIs remain the same. I believe this enables better and faster evolution
    of the Java platform, and we all get to benefit from it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了Java平台模块利用模块化的封装概念，平台现在有了有效保护内部类免受外部使用的方法。平台可以进化，修改或甚至完全删除和替换内部API，只要公开导出的API保持不变，就可以确保向后兼容。我相信这使Java平台的演变更好、更快，我们都能从中受益。
- en: On the other hand, remember that there are some classes that were publicly accessible
    in earlier Java versions that are now encapsulated in Java platform modules. This
    implies that there are possibly some backward incompatibilities with applications
    that were formerly depending on those internal APIs (even though they really shouldn't)!
    This is a problem many of us will have to tackle when we migrate code written
    in Java 8 or earlier into Java 9\. We'll learn more about that, as well as strategies
    to handle such situations in [Chapter 10](part0161.html#4PHAI0-ed2405f4162b4f86b565edd6b6d679fb),
    *Preparing Your Code for Java 9*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，请记住，在早期的Java版本中，有一些公开可访问的类现在被封装在Java平台模块中。这意味着，可能存在一些与之前依赖于那些内部API的应用程序不兼容的问题（即使它们实际上不应该这样）！当我们将用Java
    8或更早版本编写的代码迁移到Java 9时，这将是许多人都必须解决的问题。我们将在[第10章](part0161.html#4PHAI0-ed2405f4162b4f86b565edd6b6d679fb)“为Java
    9准备您的代码”中了解更多关于这一点，以及处理此类情况的战略。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We've covered a lot of ground in this chapter. We started looking at a couple
    of problems with the earlier versions of the Java platform and how the language
    didn't really provide sufficient features to solve them. We then learned how the
    Java platform has been modularized, what the modules are, and how to browse and
    get information about them. We then wrapped up with how the new modular Java platform
    has effectively solved the two major problems we began the chapter with.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了大量的内容。我们开始探讨Java平台早期版本中的一些问题，以及语言本身并没有提供足够的功能来解决这些问题。然后我们学习了Java平台是如何模块化的，模块是什么，以及如何浏览和获取它们的信息。最后，我们总结了新的模块化Java平台如何有效地解决了我们在本章开始时提到的两个主要问题。
- en: In the next chapter, you'll put these concepts into practice by wiring in the
    Java platform modules into the address book application and getting familiar with
    the process of using platform modules and APIs in your custom Java code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将通过将Java平台模块连接到地址簿应用程序来将这些概念付诸实践，并熟悉在自定义Java代码中使用平台模块和API的过程。
