- en: Extending Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展微服务
- en: We built a basic component offering a few services in Chapter 5, *Building Microservices
    with Spring Boot*. In this chapter, we will focus on adding more features to make
    ;our microservice production ready.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5章《使用Spring Boot构建微服务》中，我们构建了一个基本组件，提供了一些服务。在本章中，我们将重点放在添加更多功能，使我们的微服务能够投入生产。
- en: 'We will discuss how to add these features to our microservice:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论如何将这些功能添加到我们的微服务中：
- en: Exception handling
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理
- en: HATEOAS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HATEOAS
- en: Caching
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存
- en: Internationalisation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国际化
- en: We will also discuss how to document our microservice using Swagger. We will
    look at the basics of securing the microservice with Spring Security.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将讨论如何使用Swagger文档化我们的微服务。我们将了解使用Spring Security保护微服务的基础知识。
- en: Exception handling
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理
- en: Exception handling is one of the important parts of developing web services.
    When something goes wrong, we would want to return a good description of what
    went wrong to the service consumer. You would not want the service to crash without
    returning anything useful to the service consumer.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理是开发Web服务的重要部分之一。当出现问题时，我们希望向服务使用者返回有关出现问题的良好描述。您不希望服务在不返回任何有用信息给服务使用者的情况下崩溃。
- en: Spring Boot provides good default exception handling. We will start with looking
    at the default exception handling features provided by Spring Boot before moving
    on to customizing them.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot提供了良好的默认异常处理。我们将从查看Spring Boot提供的默认异常处理功能开始，然后再进行自定义。
- en: Spring Boot default exception handling
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot默认异常处理
- en: To understand the default exception handling provided by Spring Boot, let's
    start with firing a request to a nonexistent URL.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解Spring Boot提供的默认异常处理，让我们从向不存在的URL发送请求开始。
- en: Nonexistent resource
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不存在的资源
- en: Let's send a `GET` request to `http://localhost:8080/non-existing-resource`
    using a header (Content-Type:application/json).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个头部（Content-Type:application/json）向`http://localhost:8080/non-existing-resource`发送一个`GET`请求。
- en: 'The following screenshot shows the response when we execute the request:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行请求时，下面的截图显示了响应：
- en: '![](img/51cba3ab-d570-4eb9-a226-3c27456647af.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51cba3ab-d570-4eb9-a226-3c27456647af.png)'
- en: 'The response is as shown in the following code snippet:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 响应如下代码片段所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Some important things to note are as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一些重要的事情需要注意：
- en: The response header has an HTTP status of `404 - Resource Not Found`
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应头具有HTTP状态码`404 - 资源未找到`
- en: Spring Boot returns a valid JSON ;message as a ;response with the ;message stating
    that the resource is not found
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot返回一个有效的JSON；响应，其中说明资源未找到
- en: Resource throwing an exception
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源抛出异常
- en: Let's create a resource that throws an exception, and send a `GET` request to
    it in order to understand how the application reacts to runtime exceptions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个抛出异常的资源，并向其发送一个`GET`请求，以了解应用程序对运行时异常的反应。
- en: 'Let''s create a dummy service that throws an exception. The following code
    snippet shows a simple service:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个抛出异常的虚拟服务。下面的代码片段显示了一个简单的服务：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Some important things to note are as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一些重要的事情需要注意：
- en: We are creating a `GET` service with the URI `/users/dummy-service`.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在创建一个带有URI `/users/dummy-service`的`GET`服务。
- en: The service throws ;`RuntimeException`. We chose `RuntimeException` to be able
    to create the exception easily. We can easily replace it with a custom exception
    ;if needed.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该服务抛出`RuntimeException`。我们选择了`RuntimeException`以便能够轻松创建异常。如果需要，我们可以轻松替换为自定义异常。
- en: 'Let''s fire a `GET` request to the preceding service at `http://localhost:8080/users/dummy-service`
    using Postman. The response is as shown in the following code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Postman向前述服务发送一个`GET`请求，网址为`http://localhost:8080/users/dummy-service`。响应如下所示的代码：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Some important things to note are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一些重要的事情需要注意：
- en: The response header has an HTTP status of `500`; `Internal server error`
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应头具有HTTP状态码`500`；`内部服务器错误`
- en: Spring Boot also returns the message with which the exception is thrown
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot还返回抛出异常的消息
- en: As we can see in the preceding two examples, Spring Boot provides good default
    exception handling. In the next section, we will focus on understanding how the
    application reacts to custom exceptions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的两个例子中所看到的，Spring Boot提供了良好的默认异常处理。在下一节中，我们将重点关注应用程序对自定义异常的反应。
- en: Throwing a custom exception
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抛出自定义异常
- en: 'Let''s create a custom exception and throw it from a service. Take a look at
    the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个自定义异常，并从服务中抛出它。看一下下面的代码：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It's a very simple piece of code that defines ;`TodoNotFoundException` .
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的代码片段，定义了`TodoNotFoundException`。
- en: 'Now let''s enhance our `TodoController` ;class to throw `TodoNotFoundException`
    when a `todo` with a given ID is not found:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们增强我们的`TodoController`类，当找不到具有给定ID的`todo`时抛出`TodoNotFoundException`：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If `todoService` returns a null `todo`, we throw ;`TodoNotFoundException`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`todoService`返回一个空的`todo`，我们抛出`TodoNotFoundException`。
- en: 'When we execute the service with a `GET` request to a nonexistent ;`todo` (`http://localhost:8080/users/Jack/todos/222`),
    we get the response shown in the following code snippet:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向一个不存在的`todo`（`http://localhost:8080/users/Jack/todos/222`）发送一个`GET`请求时，我们得到了下面代码片段中显示的响应：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we can see, a clear exception response is sent back to the service consumer.
    However, there is one thing that can be improved further--the response status.
    When a resource is not found, it is recommended that you return a `404 - Resource
    Not Found` status. We will look at how to customize the response ;status ;in the
    next example.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，清晰的异常响应被发送回服务使用者。然而，还有一件事情可以进一步改进——响应状态。当找不到资源时，建议返回`404 - 资源未找到`状态。我们将在下一个示例中看看如何自定义响应状态。
- en: Customizing the exception message
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义异常消息
- en: Let's look at how to customize the preceding exception and return the proper
    response status with a customized message.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何自定义前面的异常并返回带有自定义消息的适当响应状态。
- en: 'Let''s create a bean to define the structure of our custom exception message:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个bean来定义我们自定义异常消息的结构：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have created a simple exception response bean with an auto-populated timestamp
    with a few additional properties namely messages and details.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个简单的异常响应bean，其中包含自动填充的时间戳和一些额外属性，即消息和详细信息。
- en: 'When ;`TodoNotFoundException` is thrown, we would want to return a response
    using the `ExceptionResponse` bean. The following code shows how we can create
    a global exception handling for `TodoNotFoundException.class`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当抛出`TodoNotFoundException`时，我们希望使用`ExceptionResponse` bean返回响应。以下代码显示了如何为`TodoNotFoundException.class`创建全局异常处理：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Some important things to note are as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一些重要事项如下：
- en: '`RestResponseEntityExceptionHandler extends ResponseEntityExceptionHandler`:
    We are extending ;`ResponseEntityExceptionHandler`, which is the base class provided
    by Spring MVC for centralised exception handling `ControllerAdvice` classes.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RestResponseEntityExceptionHandler扩展ResponseEntityExceptionHandler`：我们正在扩展`ResponseEntityExceptionHandler`，这是Spring
    MVC为中心化异常处理`ControllerAdvice`类提供的基类。'
- en: '`@ExceptionHandler(TodoNotFoundException.class)`: This defines that the method
    to follow will handle the specific exception `TodoNotFoundException.class`. Any
    other exceptions for which custom exception handling is not defined will follow
    the default exception handling provided by Spring Boot.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ExceptionHandler(TodoNotFoundException.class)`: 这定义了接下来要处理特定异常`TodoNotFoundException.class`的方法。任何其他未定义自定义异常处理的异常将遵循Spring
    Boot提供的默认异常处理。'
- en: '`ExceptionResponse exceptionResponse = new ExceptionResponse(ex.getMessage(),
    "Any details you would want to add")`: This creates a custom exception response.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExceptionResponse exceptionResponse = new ExceptionResponse(ex.getMessage(),
    "您想要添加的任何细节")`：这创建了一个自定义异常响应。'
- en: '`new ResponseEntity<ExceptionResponse>(exceptionResponse,new HttpHeaders(),
    HttpStatus.NOT_FOUND)`: This is the definition to return a `404 Resource Not Found`
    response with the custom exception defined earlier.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new ResponseEntity<ExceptionResponse>(exceptionResponse,new HttpHeaders(),
    HttpStatus.NOT_FOUND)`: 这是返回`404资源未找到`响应的定义，其中包括先前定义的自定义异常。'
- en: 'When we execute the service with a `GET` request to a nonexistent ;`todo` (`http://localhost:8080/users/Jack/todos/222`),
    we get the following response:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`GET`请求执行服务到一个不存在的`todo`（`http://localhost:8080/users/Jack/todos/222`）时，我们会得到以下响应：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you want to create a generic exception message for all exceptions, we can
    add a method to `RestResponseEntityExceptionHandler` with the ;`@ExceptionHandler(Exception.class)`
    ;annotation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要为所有异常创建通用异常消息，我们可以向`RestResponseEntityExceptionHandler`添加一个带有`@ExceptionHandler(Exception.class)`注解的方法。
- en: 'The following code snippet shows how we can do this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了我们如何做到这一点：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Any exception for which a custom exception handler is not defined ;will be handled
    by the preceding method.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 任何未定义自定义异常处理程序的异常将由前面的方法处理。
- en: Response status
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应状态
- en: 'One of the important things to focus on with REST services is the response
    status of an error response. The following table shows the scenarios and the error
    response status to use:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在REST服务中要关注的重要事情之一是错误响应的响应状态。以下表格显示了要使用的场景和错误响应状态：
- en: '| **Situation** | **Response Status** |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **情况** | **响应状态** |'
- en: '| The request body does not meet the API specification. It does not contain
    enough details or contains validation errors. | ;400 BAD REQUEST |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 请求体不符合API规范。它没有足够的细节或包含验证错误。 | ;400错误请求 |'
- en: '| Authentication or authorization failure. | 401 UNAUTHORIZED |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 认证或授权失败。 | 401未经授权 |'
- en: '| The user cannot perform the operation due to various factor, such as exceeding
    limits. | 403 FORBIDDEN |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 用户由于各种因素无法执行操作，例如超出限制。 | 403禁止 |'
- en: '| The resource does not exist. | 404 NOT FOUND |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 资源不存在。 | 404未找到 |'
- en: '| Unsupported operation, for example, trying POST on a resource where only
    `GET` is allowed. ; | 405 METHOD NOT ALLOWED |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: 不支持的操作，例如，在只允许`GET`的资源上尝试POST。; | 405方法不允许 |
- en: '| Error on a server. Ideally, this should not happen. The consumer ;would not
    be able to fix this. ; | 500 INTERNAL SERVER ERROR |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 服务器上的错误。理想情况下，这不应该发生。消费者将无法修复这个问题。; | 500内部服务器错误 |'
- en: In this section, we looked at the default exception handling provided by Spring
    Boot and how we can customize it further to suit our needs.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们看了Spring Boot提供的默认异常处理以及我们如何进一步定制以满足我们的需求。
- en: HATEOAS
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HATEOAS
- en: '**HATEOAS** (**Hypermedia as the Engine of Application State**) is one of the
    constraints of the REST application architecture.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**HATEOAS**（**超媒体作为应用状态的引擎**）是REST应用程序架构的约束之一。'
- en: Let's consider a situation where a service consumer is consuming numerous services
    from a service provider. The easiest way to develop this kind of system is to
    have the service consumer store the individual resource URIs of every resource
    they need from the service provider. However, this would create tight coupling
    between the service provider and the service consumer. Whenever any of the resource
    URIs change on the service provider, the service consumer needs to be updated.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一种情况，即服务消费者从服务提供者那里消费大量服务。开发这种类型的系统的最简单方法是让服务消费者存储他们从服务提供者那里需要的每个资源的资源URI。然而，这将在服务提供者和服务消费者之间创建紧密耦合。每当服务提供者上的任何资源URI发生变化时，服务消费者都需要进行更新。
- en: Consider a ;typical web application. Let's say I navigate to my bank account
    details page. Almost all banking websites would show links to all the transactions
    that are possible on my bank account on the screen so that I can easily navigate
    using the link.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个典型的Web应用程序。假设我导航到我的银行账户详情页面。几乎所有银行网站都会在屏幕上显示我在银行账户上可以进行的所有交易的链接，以便我可以通过链接轻松导航。
- en: What if we can bring a ;similar concept to RESTful services so that a service
    returns not only the data about the requested resource, but also provides details
    of other related resources?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以将类似的概念引入RESTful服务，使得服务不仅返回有关请求资源的数据，还提供其他相关资源的详细信息，会怎么样？
- en: HATEOAS brings this concept of displaying related links for a given resource
    to RESTful services. When we return the details of a specific resource, we also
    return links to operations that can be performed on the resource, as well as links
    to related resources. If a service consumer can use the links from the response
    to perform transactions, then it would not need to hardcode all links.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: HATEOAS将这个概念引入了RESTful服务中，即为给定的资源显示相关链接。当我们返回特定资源的详细信息时，我们还返回可以对该资源执行的操作的链接，以及相关资源的链接。如果服务消费者可以使用响应中的链接执行事务，那么它就不需要硬编码所有链接。
- en: 'An extract of constraints related to HATEOAS presented by Roy Fielding ([http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven](http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven))
    is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Roy Fielding（[http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven](http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven)）提出的与HATEOAS相关的约束摘录如下：
- en: <q>A REST API must not define fixed resource names or hierarchies (an obvious
    coupling of client and server). Servers must have the freedom to control their
    own namespace. Instead, allow servers to instruct clients on how to construct
    appropriate URIs, such as is done in HTML forms and URI templates, by defining
    those instructions within media types and link relations.</q> A REST API should
    be entered with no prior knowledge beyond the initial URI (bookmark) and set of
    standardized media types that are appropriate for the intended audience (i.e.,
    expected to be understood by any client that might use the API). From that point
    on, all application state transitions must be driven by client selection of server-provided
    choices that are present in the received representations or implied by the user's
    manipulation of those representations. The transitions may be determined (or limited
    by) the client's knowledge of media types and resource communication mechanisms,
    both of which may be improved on-the-fly (e.g., code-on-demand).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <q>REST API不得定义固定的资源名称或层次结构（客户端和服务器的明显耦合）。服务器必须有自由控制自己的命名空间。相反，允许服务器指示客户端如何构造适当的URI，例如在HTML表单和URI模板中所做的那样，通过在媒体类型和链接关系中定义这些指令。</q>
    REST API应该在没有先前知识的情况下进入（书签）和一组适用于预期受众的标准化媒体类型（即，预计任何可能使用API的客户端都能理解）。从那时起，所有应用程序状态转换必须由客户端选择接收到的表示中存在的服务器提供的选择来驱动，或者由用户对这些表示的操作所暗示。转换可以由客户端对媒体类型和资源通信机制的知识确定（或受限于），这两者都可以即时改进（例如，按需代码）。
- en: 'An example response with HATEOAS link is shown here. This is the response to
    the `/todos` request in order to retrieve all todos:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示了一个带有HATEOAS链接的示例响应。这是对`/todos`请求的响应，以便检索所有todos：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding response includes links to the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 上述响应包括以下链接：
- en: Specific `todos` (`http://localhost:8080/todos/1`)
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定的`todos`(`http://localhost:8080/todos/1`)
- en: Search resource (`http://localhost:8080/todos/search`)
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索资源(`http://localhost:8080/todos/search`)
- en: If the service consumer wants to do a search, it has the option of taking the
    search URL from the response and sending the search request to it. This would
    reduce coupling between the service provider and the service consumer.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务消费者想要进行搜索，它可以选择从响应中获取搜索URL并将搜索请求发送到该URL。这将减少服务提供者和服务消费者之间的耦合。
- en: Sending HATEOAS links in response
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在响应中发送HATEOAS链接
- en: Now that we understand what HATEOAS is, let's look at how we can send links
    related to a resource in the response.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了HATEOAS是什么，让我们看看如何在响应中发送与资源相关的链接。
- en: Spring Boot starter HATEOAS
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot starter HATEOAS
- en: Spring Boot has a specific starter for HATEOAS called `spring-boot-starter-hateoas`.
    We need to add it to the `pom.xml` file.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot有一个专门的HATEOAS启动器，称为`spring-boot-starter-hateoas`。我们需要将其添加到`pom.xml`文件中。
- en: 'The following code snippet shows the dependency block:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了依赖块：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'One of the important dependencies of `spring-boot-starter-hateoas` is `spring-hateoas`,
    which provides the HATEOAS features:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`spring-boot-starter-hateoas`的一个重要依赖是`spring-hateoas`，它提供了HATEOAS功能：'
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s enhance the `retrieveTodo` resource (`/users/{name}/todos/{id}`) to
    return a link to retrieve all `todos` (`/users/{name}/todos`) in the response:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们增强`retrieveTodo`资源(`/users/{name}/todos/{id}`)以在响应中返回检索所有`todos`(`/users/{name}/todos`)的链接：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Some important points to note are as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一些重要点如下：
- en: '`ControllerLinkBuilder linkTo = linkTo(methodOn(this.getClass()).retrieveTodos(name))`:
    We want to get a link to the `retrieveTodos` method on the current class'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ControllerLinkBuilder linkTo = linkTo(methodOn(this.getClass()).retrieveTodos(name))`：我们想要获取当前类中`retrieveTodos`方法的链接'
- en: '`linkTo.withRel("parent")`: Relationship with the current resource is parent'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`linkTo.withRel("parent")`：当前资源的关系是parent'
- en: 'The following snippet shows the response when a `GET` request is sent to ;`http://localhost:8080/users/Jack/todos/1`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段显示了向`http://localhost:8080/users/Jack/todos/1`发送`GET`请求时的响应：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `_links` section will contain all the links. Currently, we have one link
    with the relation parent and `href` ; as `http://localhost:8080/users/Jack/todos`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`_links`部分将包含所有链接。目前，我们有一个带有关系parent和`href`为`http://localhost:8080/users/Jack/todos`的链接。'
- en: If you have problems executing the preceding request, ;try executing using an
    Accept header--`application/json`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在执行上述请求时遇到问题，请尝试使用Accept标头--`application/json`。
- en: HATEOAS is not something that is commonly used in most of the resources today.
    However, it has the potential to be really useful in reducing the coupling between
    the ;service provider and the consumer.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: HATEOAS并不是今天大多数资源中常用的东西。然而，它有潜力在服务提供者和消费者之间减少耦合。
- en: Validation
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证
- en: A good service always validates data before processing it. In this section,
    we will look at the ;Bean Validation API and use its reference implementation
    to implement validation in our services.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的服务在处理数据之前总是验证数据。在本节中，我们将研究Bean Validation API，并使用其参考实现来在我们的服务中实现验证。
- en: 'The Bean Validation API provides a number of annotations that can be used to
    validate beans. The ;*JSR 349* ;specification defines Bean Validation API 1.1\.
    Hibernate-validator is the reference implementation. ;Both are already defined
    as dependencies in the `spring-boot-web-starter` project:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Bean Validation API提供了许多注释，可用于验证bean。*JSR 349*规范定义了Bean Validation API 1.1。Hibernate-validator是参考实现。两者已经在`spring-boot-web-starter`项目中定义为依赖项：
- en: '`hibernate-validator-5.2.4.Final.jar`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hibernate-validator-5.2.4.Final.jar`'
- en: '`validation-api-1.1.0.Final.jar`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validation-api-1.1.0.Final.jar`'
- en: We will create a simple validation for the createTodo service method.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为createTodo服务方法创建一个简单的验证。
- en: 'Creating validations involves two steps:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 创建验证包括两个步骤：
- en: Enabling validation on the controller method.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器方法上启用验证。
- en: Adding validations on the bean.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在bean上添加验证。
- en: Enabling validation on ;the controller method
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在控制器方法上启用验证
- en: 'It''s very simple to enable validation on the controller method. The following
    snippet shows an example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制器方法上启用验证非常简单。以下代码片段显示了一个示例：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `@Valid(package javax.validation)` annotation is used to mark a parameter
    for validation. Any validation that is defined in the `Todo` bean is executed
    before the `add` method is executed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Valid（包javax.validation）`注释用于标记要验证的参数。在执行`add`方法之前，将执行`Todo` bean中定义的任何验证。'
- en: Defining validations on the bean
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在bean上定义验证
- en: 'Let''s define a few validations on the `Todo` bean:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Todo` bean上定义一些验证：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Some important points to note are as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一些重要点如下：
- en: '`@NotNull`: Validates that the user field is not empty'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@NotNull`：验证用户字段不为空'
- en: '`@Size(min = 9, message = "Enter atleast 10 Characters.")`: Checks whether
    the `desc` field has at least nine characters'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Size(min = 9, message = "Enter atleast 10 Characters.")`：检查`desc`字段是否至少有九个字符。'
- en: 'There are a number of other annotations that can be used to validate beans.
    The following are some of the Bean Validation annotations:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他注释可用于验证bean。以下是一些Bean Validation注释：
- en: '`@AssertFalse`, `@AssertTrue`: For Boolean elements. Checks the annotated element.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@AssertFalse`，`@AssertTrue`：对于布尔元素。检查被注释的元素。'
- en: '`@AssertFalse`: Checks for false. `@Assert` checks for true.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@AssertFalse`：检查是否为false。`@Assert`检查是否为true。'
- en: '`@Future`: The annotated element must be a date in the future.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Future`：被注释的元素必须是将来的日期。'
- en: '`@Past`: The annotated element must be a date in the past.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Past`：被注释的元素必须是过去的日期。'
- en: '`@Max`: The annotated element must be a number whose value must be lower or
    equal to the specified maximum.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Max`：被注释的元素必须是一个数字，其值必须小于或等于指定的最大值。'
- en: '`@Min`: The annotated element must be a number whose value must be higher or
    equal to the specified minimum.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Min`：被注释的元素必须是一个数字，其值必须大于或等于指定的最小值。'
- en: '`@NotNull`: The annotated element cannot be null.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@NotNull`：被注释的元素不能为空。'
- en: '`@Pattern`: The annotated `{@code CharSequence}` ;element must match the specified
    regular expression. The regular expression follows the Java regular expression
    conventions.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Pattern`：被注释的`{@code CharSequence}`元素必须与指定的正则表达式匹配。正则表达式遵循Java正则表达式约定。'
- en: '`@Size`: The annotated element size must be within the specified boundaries.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Size`：被注释的元素大小必须在指定的边界内。'
- en: Unit testing validations
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试验证
- en: 'The following example shows how we can unit test the validations we added in:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了如何对我们添加的验证进行单元测试：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Some important points to note are as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一些重要点如下：
- en: '`"desc":"Learn"`: We are using a desc value of length `5`. This would cause
    a validation failure for the `@Size(min = 9, message = "Enter atleast 10 Characters.")`
    check.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"desc":"Learn"`：我们使用长度为`5`的desc值。这将导致`@Size(min = 9, message = "Enter atleast
    10 Characters.")`检查失败。'
- en: '`.andExpect(status().is4xxClientError())`: Checks for validation error status.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.andExpect(status().is4xxClientError())`：检查验证错误状态。'
- en: Documenting REST services
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST服务文档
- en: 'Before a service provider can consume a service, they need a service contract.
    A service contract defines all the ;details about a service:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务提供者可以使用服务之前，他们需要一个服务合同。服务合同定义了有关服务的所有细节：
- en: How can I call a service? What is the URI of the service?
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我如何调用服务？服务的URI是什么？
- en: What should be the request format?
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求格式应该是什么？
- en: What kind of response should I expect?
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我应该期望什么样的响应？
- en: There are multiple options to define a service contract for RESTful services.
    The most popular one in the last couple of years is ;**Swagger**. ;Swagger is
    gaining a lot of ground, with support from major vendors in the last couple of
    years. In this section, we will generate Swagger documentation for our services.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种选项可用于为RESTful服务定义服务合同。在过去几年中最受欢迎的是**Swagger**。Swagger在过去几年中得到了很多支持，得到了主要供应商的支持。在本节中，我们将为我们的服务生成Swagger文档。
- en: 'The following quote from the Swagger website ([http://swagger.io](http://swagger.io))
    defines the purpose of the Swagger specification:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Swagger网站（[http://swagger.io](http://swagger.io)）的以下引用定义了Swagger规范的目的：
- en: Swagger specification creates the RESTful contract for your API, detailing all
    of its resources and operations in a human and machine readable format for easy
    development, discovery, and integration.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger规范为您的API创建RESTful合同，详细说明了所有资源和操作，以人类和机器可读的格式进行易于开发、发现和集成。
- en: Generating ;a Swagger specification
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成Swagger规范
- en: One of the interesting developments in the last few years of RESTful services
    development is the evolution of tools to generate service documentation (specification)
    from the code. This ensures that the code and documentation are always in sync.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful服务开发在过去几年中的一个有趣发展是工具的演变，可以从代码生成服务文档（规范）。这确保了代码和文档始终保持同步。
- en: '**Springfox Swagger** can be used to generate Swagger documentation from the
    RESTful services code. What''s more, there is a wonderful tool called **Swagger
    UI**, which, when integrated into the application, provides human-readable documentation.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**Springfox Swagger**可以用来从RESTful服务代码生成Swagger文档。此外，还有一个名为**Swagger UI**的精彩工具，当集成到应用程序中时，提供人类可读的文档。'
- en: 'The following code snippet shows how we can add both these tools ;to the ;`pom.xml`
    file:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了如何将这两个工具添加到`pom.xml`文件中：
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The next step is to add the configuration class to enable and generate Swagger
    documentation. The following snippet shows how to do it:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加配置类以启用和生成Swagger文档。以下代码片段显示了如何做到这一点：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Some important points to note are as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一些重要点如下：
- en: '`@Configuration`: Defines a Spring configuration file'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Configuration`：定义一个Spring配置文件'
- en: '`@EnableSwagger2`: The annotation to enable Swagger support'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@EnableSwagger2`：启用Swagger支持的注解'
- en: '`Docket` : A simple builder class to configure the generation of Swagger documentation
    using the Swagger Spring MVC framework'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Docket`：一个简单的构建器类，用于使用Swagger Spring MVC框架配置Swagger文档的生成'
- en: '`new Docket(DocumentationType.SWAGGER_2)` : Configures Swagger 2 as the Swagger
    version to be used'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new Docket(DocumentationType.SWAGGER_2)`：配置Swagger 2作为要使用的Swagger版本'
- en: '`.apis(RequestHandlerSelectors.any()).paths(PathSelectors.any())`: Includes
    all APIs and paths in the documentation'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.apis(RequestHandlerSelectors.any()).paths(PathSelectors.any())`：包括文档中的所有API和路径'
- en: 'When we bring the server up, we can launch the API Docs URL (`http://localhost:8080/v2/api-docs`).
    The following screenshot shows some of the generated documentation:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动服务器时，我们可以启动API文档URL（`http://localhost:8080/v2/api-docs`）。以下截图显示了一些生成的文档：
- en: '![](img/dfce5d48-ef55-4393-9a25-e6c695125f13.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dfce5d48-ef55-4393-9a25-e6c695125f13.png)'
- en: 'Let''s look at some of the generated documentation. Listed here is the documentation
    to retrieve the ;`todos` service:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些生成的文档。这里列出了检索`todos`服务的文档：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The service definition clearly defines the request ;and response ;of the service.
    Also defined are the different response statuses that the service can return in
    different situations.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 服务定义清楚地定义了服务的请求和响应。还定义了服务在不同情况下可以返回的不同响应状态。
- en: 'The following code snippet shows the definition of the `Todo` bean:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了`Todo` bean的定义：
- en: '[PRE21]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It defines all the elements in the `Todo` bean, along with their formats.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 它定义了`Todo` bean中的所有元素，以及它们的格式。
- en: Swagger UI
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swagger UI
- en: Swagger UI (`http://localhost:8080/swagger-ui.html`) can also be used to look
    at the documentation. Swagger UI is enabled by the dependency (`io.springfox:springfox-swagger-ui`)
    that was added in our `pom.xml`, in the previous step.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger UI（`http://localhost:8080/swagger-ui.html`）也可以用来查看文档。Swagger UI是通过在上一步中添加到我们的`pom.xml`中的依赖项（`io.springfox:springfox-swagger-ui`）启用的。
- en: Swagger UI ([http://petstore.swagger.io](http://petstore.swagger.io)) is also
    available online. We can visualise any Swagger documentation (swagger JSON) using
    Swagger UI.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger UI（[http://petstore.swagger.io](http://petstore.swagger.io)）也可以在线使用。我们可以使用Swagger
    UI可视化任何Swagger文档（swagger JSON）。
- en: 'The following screenshot shows the list of controller-exposing services. When
    we click on any controller, it expands to show the list of request methods and
    URIs each controller supports:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了公开控制器服务的列表。当我们点击任何控制器时，它会展开显示每个控制器支持的请求方法和URI列表：
- en: '![](img/3c9a0fb3-d07a-4b93-8a02-50c3d01812f7.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c9a0fb3-d07a-4b93-8a02-50c3d01812f7.png)'
- en: 'The following screenshot shows the details for the POST service to create a
    `todo` for the user in Swagger UI:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在Swagger UI中为创建用户的`todo`服务的POST服务的详细信息：
- en: '![](img/c29b7ef2-eb45-4e26-9310-cfb09e9f0950.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c29b7ef2-eb45-4e26-9310-cfb09e9f0950.png)'
- en: 'Some important things to note are as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一些重要事项如下：
- en: Parameters show all the important parameters including the request body
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数显示了所有重要的参数，包括请求体
- en: The Parameter Type body (for the ;`todo` parameter) shows the expected structure
    for the ;body of the request
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数类型body（对于`todo`参数）显示了请求体的预期结构
- en: The Response Messages sections show ;different HTTP status codes returned by
    the service
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应消息部分显示了服务返回的不同HTTP状态代码
- en: The Swagger UI provides an excellent way to expose service definitions for your
    API without a lot of additional effort.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger UI提供了一种出色的方式来在不需要太多额外工作的情况下公开API的服务定义。
- en: Customizing Swagger documentation using annotations
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用注解自定义Swagger文档
- en: The Swagger UI also provides annotations to further customize your documentation.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger UI还提供了注解来进一步自定义您的文档。
- en: 'Listed here is some of the ;documentation to retrieve the `todos` service:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了检索`todos`服务的一些文档：
- en: '[PRE22]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As you can see, the documentation generated is very raw. There are a number
    of things we can improve in the documentation to describe the services better.
    Here are a couple of examples:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，生成的文档非常原始。我们可以在文档中改进许多内容，以更好地描述服务。以下是一些示例：
- en: Provide a better summary
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供更好的摘要
- en: Add application/JSON to produces
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加application/JSON到produces
- en: 'Swagger provides annotations we can add to our RESTful services in order to
    customize the documentation. ;Let''s add a few annotations to the controller in
    order to improve the documentation:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger提供了我们可以添加到我们的RESTful服务中的注解，以自定义文档。让我们在控制器中添加一些注解以改进文档：
- en: '[PRE23]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A few important points to note are as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的几个重要点如下：
- en: '`@ApiOperation(value = "Retrieve all todos for a user by passing in his name")`:
    Produced in the documentation as a summary of the service'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ApiOperation(value = "Retrieve all todos for a user by passing in his name")`：在文档中作为服务摘要生成'
- en: '`notes = "A list of matching todos is returned. Current pagination is not supported."`:
    Produced in the documentation as a description of the service'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notes = "A list of matching todos is returned. Current pagination is not supported."`：在文档中生成作为服务描述的说明'
- en: '`produces = "application/json”`: Customizes the `produces` section of the service
    documentation'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`produces = "application/json”`：自定义服务文档的`produces`部分'
- en: 'Here is an extract of the documentation after the update:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是更新后的文档摘录：
- en: '[PRE24]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Swagger provides a lot of other annotations to customize the documentation.
    Listed here are some of the important annotations:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger提供了许多其他注解来自定义文档。以下列出了一些重要的注解：
- en: '`@Api`: Marks a class as a Swagger resource'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Api`：将类标记为Swagger资源'
- en: '`@ApiModel`: Provides additional information about Swagger models'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ApiModel`：提供有关Swagger模型的附加信息'
- en: '`@ApiModelProperty`: Adds and manipulates the data of a model property'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ApiModelProperty`：添加和操作模型属性的数据'
- en: '`@ApiOperation`: Describes an operation or an HTTP method against a specific
    path'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ApiOperation`：描述针对特定路径的操作或HTTP方法'
- en: '`@ApiParam`: Adds additional metadata for operation parameters'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ApiParam`：为操作参数添加附加元数据'
- en: '`@ApiResponse`: Describes an example response of an operation'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ApiResponse`：描述操作的示例响应'
- en: '`@ApiResponses`: A wrapper to allow a list of multiple `ApiResponse` objects.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ApiResponses`：允许多个`ApiResponse`对象的列表包装器。'
- en: '`@Authorization`: Declares an authorization scheme to be used on a resource
    or an operation'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Authorization`：声明要在资源或操作上使用的授权方案'
- en: '`@AuthorizationScope`: Describes an OAuth 2 authorization scope'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@AuthorizationScope`：描述OAuth 2授权范围'
- en: '`@ResponseHeader`: Represents a header that can be provided as part of the
    response'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ResponseHeader`：表示可以作为响应的一部分提供的标头'
- en: 'Swagger provides a few Swagger definition annotations that can be ;used to
    customize high-level information about a group of services--contacts, licensing,
    and other general information. Listed here are some of the important ones:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger提供了一些Swagger定义注解，可以用来自定义有关一组服务的高级信息--联系人、许可和其他一般信息。以下是一些重要的注解：
- en: '`@SwaggerDefinition`: Definition-level properties to be added to the generated
    Swagger definition'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@SwaggerDefinition`：要添加到生成的Swagger定义的定义级属性'
- en: '`@Info`: General metadata for a Swagger definition'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Info`：Swagger定义的一般元数据'
- en: '`@Contact`: ;Properties to describe the person to be contacted for a Swagger
    definition'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Contact`：用于描述Swagger定义的联系人的属性'
- en: '`@License`: Properties to describe the license for a Swagger definition'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@License`：用于描述Swagger定义的许可证的属性'
- en: Securing REST services with Spring Security
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Security保护REST服务
- en: All the services we have created up until ;now are unsecured. A consumer does
    not need to provide any credentials to access these services. However, all services
    in the real world are usually secured.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们创建的所有服务都是不安全的。消费者不需要提供任何凭据即可访问这些服务。然而，在现实世界中，所有服务通常都是受保护的。
- en: 'In this section, we will discuss two ways of authenticating REST services:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论验证REST服务的两种方式：
- en: Basic authentication
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本身份验证
- en: OAuth 2.0 authentication
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth 2.0身份验证
- en: We will implement these two types of authentication with Spring Security.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Spring Security实现这两种类型的身份验证。
- en: Spring Boot provides a starter for Spring Security using ;`spring-boot-starter-security`.
    We will start with adding Spring Security starter to our `pom.xml` file.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot提供了一个用于Spring Security的启动器；`spring-boot-starter-security`。我们将从向我们的`pom.xml`文件中添加Spring
    Security启动器开始。
- en: Adding Spring Security starter
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Spring Security启动器
- en: 'Add the following dependency to your file `pom.xml`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下依赖项添加到您的文件`pom.xml`中：
- en: '[PRE25]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `Spring-boot-starter-security` dependency ;brings in three important Spring
    Security dependencies:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spring-boot-starter-security`依赖项；引入了三个重要的Spring Security依赖项：'
- en: '`spring-security-config`'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-security-config`'
- en: '`spring-security-core`'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-security-core`'
- en: '`spring-security-web`'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-security-web`'
- en: Basic authentication
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本身份验证
- en: The `Spring-boot-starter-security` dependency ;also auto-configures basic authentication
    for all services by default.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spring-boot-starter-security`依赖项；还默认为所有服务自动配置基本身份验证。'
- en: If we try to access any of the services now, we would get `"Access Denied"`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试访问任何服务，我们将收到`"拒绝访问"`的消息。
- en: 'The response when we send a request to `http://localhost:8080/users/Jack/todos`
    is shown as an example in the following code snippet:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们发送请求到`http://localhost:8080/users/Jack/todos`时的响应如下代码片段中所示：
- en: '[PRE26]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The response status is `401 - Unauthorized`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 响应状态为`401 - 未经授权`。
- en: When a resource is secured with basic authentication, we would need to send
    a user ID and password to authenticate our request. Since we did not configure
    a user ID and password, Spring Boot auto-configures a default user ID and password.
    The default user ID is `user`. The default password is usually printed in the
    log.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当资源受基本身份验证保护时，我们需要发送用户ID和密码来验证我们的请求。由于我们没有配置用户ID和密码，Spring Boot会自动配置默认的用户ID和密码。默认用户ID是`user`。默认密码通常会打印在日志中。
- en: 'An example is shown in the following code snippet:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段中显示了一个示例：
- en: '[PRE27]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Underlined in the preceding code snippet is the default security password printed
    in the log.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中划线的是日志中打印的默认安全密码。
- en: 'We can use Postman to fire a request with basic authentication. The following
    screenshot shows how basic authentication details can be sent along with a request:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Postman发送带有基本身份验证的请求。以下截图显示了如何在请求中发送基本身份验证详细信息：
- en: '![](img/579ca5d7-bcc6-4814-8079-65b2b715a312.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/579ca5d7-bcc6-4814-8079-65b2b715a312.png)'
- en: As you can see, authentication succeeds and we get a proper response back.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，身份验证成功，我们得到了一个适当的响应。
- en: 'We can configure the user ID and password of our choice in `application.properties`,
    as shown here:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`application.properties`中配置我们选择的用户ID和密码，如下所示：
- en: '[PRE28]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Spring Security also provides options to authenticate with LDAP or JDBC or any
    other data source with user credentials.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security还提供了使用LDAP或JDBC或任何其他数据源进行用户凭据身份验证的选项。
- en: Integration testing
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: 'The integration test we wrote for the service earlier will start failing because
    of invalid credentials. We will now update the integration test to supply basic
    authentication credentials:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前为服务编写的集成测试将因为无效的凭据而开始失败。我们现在将更新集成测试以提供基本身份验证凭据：
- en: '[PRE29]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Some important things to note are as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一些重要事项如下：
- en: '`createHeaders("user-name", "user-password")`: This method creates `Base64\.
    getEncoder().encode` basic authentication headers'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createHeaders("user-name", "user-password")`：此方法创建`Base64\. getEncoder().encode`基本身份验证标头'
- en: '`ResponseEntity<String> response = template.exchange(createUrl("/users/Jack/todos"),
    ;HttpMethod.GET,new HttpEntity<String>(null, headers), String.class)`: The key
    change is the use of `HttpEntity` to supply the headers that we created earlier
    to the REST template'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResponseEntity<String> response = template.exchange(createUrl("/users/Jack/todos"),
    ;HttpMethod.GET,new HttpEntity<String>(null, headers), String.class)`: 关键变化是使用`HttpEntity`来提供我们之前创建的标头给REST模板'
- en: Unit testing
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'We would not want to use security for our unit tests. The following code snippet
    shows how we can disable security for the unit test:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望在单元测试中使用安全性。以下代码片段显示了如何在单元测试中禁用安全性：
- en: '[PRE30]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The key part is the `secure = false` parameter on the `WebMvcTest` annotation.
    This will disable Spring Security for the unit test.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 关键部分是`WebMvcTest`注解上的`secure = false`参数。这将禁用单元测试的Spring Security。
- en: OAuth 2 authentication
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth 2认证
- en: OAuth is a protocol that provides flows in order to exchange authorization and
    authentication information between a range of web-enabled applications and services.
    It enables third-party applications to get restricted access to user information
    from a service, for example, Facebook, Twitter, or GitHub.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth是一种协议，提供了一系列流程，用于在各种网络应用程序和服务之间交换授权和认证信息。它使第三方应用程序能够从服务中获取对用户信息的受限访问权限，例如Facebook、Twitter或GitHub。
- en: Before we get into the details, it would be useful to review the terminology
    typically used with respect to OAuth 2 authentication.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入细节之前，回顾一下通常与OAuth 2认证相关的术语将会很有用。
- en: Let's consider an example. Let's say we want to expose the Todo API to third-party
    applications on the internet.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子。假设我们想要将Todo API暴露给互联网上的第三方应用程序。
- en: 'The following are the important players in a typical OAuth 2 exchange:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是典型OAuth 2交换中的重要参与者：
- en: '**Resource owner**: This is the user of the third-party application that wants
    to use our Todo API. It decides how much of the information available with our
    API can be made available to the third-party application.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源所有者**：这是第三方应用程序的用户，希望使用我们的Todo API。它决定我们的API中的信息可以向第三方应用程序提供多少。'
- en: '**Resource server**: This hosts the Todo API, the resource ;we want to secure.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源服务器**：托管Todo API，我们想要保护的资源。'
- en: '**Client**: This is the third-party application that wants to consume our API.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：这是希望使用我们的API的第三方应用程序。'
- en: '**Authorization server**: This is the server that provides the OAuth service.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权服务器**：提供OAuth服务的服务器。'
- en: High-level ;flow
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级流程
- en: 'The following steps show a ;high-level flow of a typical OAuth authentication:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了典型OAuth认证的高级流程：
- en: The application requests that the user authorizes access to API resources.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序请求用户授权访问API资源。
- en: When the ;user provides access, the application receives an authorization grant.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户提供访问权限时，应用程序会收到授权授予。
- en: The application provides user authorization grant and its own client credentials
    to the authorization server.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序提供用户授权授予和自己的客户端凭据给授权服务器。
- en: If the authentication is successful, the authorization server responds with
    an access token.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果认证成功，授权服务器将以访问令牌回复。
- en: The application calls the API (the resource server) that provides the access
    token for authentication.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序调用提供认证访问令牌的API（资源服务器）。
- en: If the access token is valid, the resource server returns the details of the
    resource.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果访问令牌有效，资源服务器返回资源的详细信息。
- en: Implementing OAuth 2 authentication for our service
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的服务实现OAuth 2认证
- en: 'OAuth 2 for Spring Security (`spring-security-oauth2`) is the module to provide
    OAuth 2 support to Spring Security. We will add it as a dependency in our `pom.xml`
    file:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security的OAuth 2（`spring-security-oauth2`）是为Spring Security提供OAuth 2支持的模块。我们将在`pom.xml`文件中将其添加为依赖项：
- en: '[PRE31]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Setting up authorization and resource servers
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置授权和资源服务器
- en: spring-security-oauth2 has not yet been (June 2017) been updated with the changes
    for Spring Framework 5.x and Spring Boot 2.x. We will use Spring Boot 1.5.x for
    examples related to OAuth 2 authentication. Code examples are here in the GitHub
    repository ;[https://github.com/PacktPublishing/Mastering-Spring-5.0](https://github.com/PacktPublishing/Mastering-Spring-5.0).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: spring-security-oauth2截至2017年6月尚未更新以适应Spring Framework 5.x和Spring Boot 2.x的变化。我们将使用Spring
    Boot 1.5.x来举例说明OAuth 2认证。代码示例在GitHub存储库中；[https://github.com/PacktPublishing/Mastering-Spring-5.0](https://github.com/PacktPublishing/Mastering-Spring-5.0)。
- en: Typically, an authorization server would be a different server from the application
    where the API is exposed. To keep things simple, we will make our current API
    server act both as the resource server and as the authorization server.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，授权服务器会是一个不同的服务器，而不是API暴露的应用程序。为了简化，我们将使当前的API服务器同时充当资源服务器和授权服务器。
- en: 'The following code snippet shows how we can enable our application to act as
    the resource and authorization server:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了如何使我们的应用程序充当资源和授权服务器：
- en: '[PRE32]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here are a couple of important things to note:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些重要的事项：
- en: '`@EnableResourceServer`: A convenient annotation for OAuth 2 resource servers,
    enabling a Spring Security filter that authenticates requests via an incoming
    OAuth 2 token'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@EnableResourceServer`：OAuth 2资源服务器的便利注解，启用Spring Security过滤器，通过传入的OAuth 2令牌对请求进行身份验证'
- en: '`@EnableAuthorizationServer`: A convenience annotation to enable an authorization
    server with ;`AuthorizationEndpoint` and ;`TokenEndpoint` in the current application
    context, which must be a `DispatcherServlet` context'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@EnableAuthorizationServer`：一个便利注解，用于在当前应用程序上下文中启用授权服务器，必须是`DispatcherServlet`上下文，包括`AuthorizationEndpoint`和`TokenEndpoint`'
- en: 'Now we can configure the access details in `application.properties`, as shown
    in the following code snippet:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在`application.properties`中配置访问详情，如下所示：
- en: '[PRE33]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'A few important details are as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 一些重要的细节如下：
- en: '`security.user.name` and ;`security.user.password` are the authentication details
    of the resource owner that is an end user of a third-party application'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`security.user.name`和`security.user.password`是资源所有者的身份验证详细信息，是第三方应用程序的最终用户'
- en: '`security.oauth2.client.clientId` and ;`security.oauth2.client.clientSecret`
    are the authentication details of the client that is the third-party application
    (the service consumer)'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`security.oauth2.client.clientId`和`security.oauth2.client.clientSecret`是客户端的身份验证详细信息，是第三方应用程序（服务消费者）'
- en: Executing OAuth requests
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行OAuth请求
- en: 'We need a two-step process to access the APIs:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个两步骤的过程来访问API：
- en: Obtain an access token.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取访问令牌。
- en: Execute the request using the access token.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用访问令牌执行请求。
- en: Obtaining an access token
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取访问令牌
- en: 'To get an access token, we call the authorization server (`http://localhost:8080/oauth/token`),
    providing the client authentication details in the basic authentication mode and
    the user credentials as part of the form data. The following screenshot shows
    how we can configure the client authentication details in basic authentication:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取访问令牌，我们调用授权服务器（`http://localhost:8080/oauth/token`），在基本身份验证模式下提供客户端身份验证详细信息和用户凭据作为表单数据的一部分。以下截图显示了我们如何在基本身份验证中配置客户端身份验证详细信息：
- en: '![](img/d5c2d818-4bee-47bc-a05f-73b94568d12d.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5c2d818-4bee-47bc-a05f-73b94568d12d.png)'
- en: 'The following screenshot shows how to configure the user authentication details
    as part of the POST parameters:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了如何将用户身份验证详细信息配置为POST参数的一部分：
- en: '![](img/7bf1640a-be2f-4728-993b-9869b1f095bc.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7bf1640a-be2f-4728-993b-9869b1f095bc.png)'
- en: 'We are using `grant_type` ;as the password, indicating that we are sending
    the user authentication details to get the access token. When we execute the request,
    we get a response similar to the one shown in the following code snippet:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`grant_type`作为密码，表示我们正在发送用户身份验证详细信息以获取访问令牌。当我们执行请求时，我们会得到类似以下代码片段所示的响应：
- en: '[PRE34]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here are a couple of important details:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些重要细节：
- en: '`access_token`: Client application can use the access token to authenticate
    further API calls. However, the access token will expire, typically in a very
    short time period.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`access_token`: 客户端应用程序可以使用访问令牌来进行进一步的API调用身份验证。然而，访问令牌将在通常非常短的时间内过期。'
- en: '`refresh_token`: Client application can submit a new request to the authentication
    server with the `refresh_token` to get a new `access_token`.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`refresh_token`: 客户端应用程序可以使用`refresh_token`向认证服务器提交新请求，以获取新的`access_token`。'
- en: Executing the request using the access token
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用访问令牌执行请求
- en: 'Once we have ;`access_token`, we can execute the request using ;`access_token`,
    as shown in the following screenshot:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了`access_token`，我们可以使用`access_token`执行请求，如下截图所示：
- en: '![](img/c549b7c3-2c0e-41ec-bf28-57580a2d3173.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c549b7c3-2c0e-41ec-bf28-57580a2d3173.png)'
- en: As you can see in the preceding screenshot, we provide the access token in the
    request header called Authorization. We use the value of the format `"Bearer {access_token}"`.
    Authentication succeeds and we get the expected resource details.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的截图中所看到的，我们在请求标头中提供了访问令牌，称为Authorization。我们使用格式的值`"Bearer {access_token}"`。身份验证成功，我们得到了预期的资源详细信息。
- en: Integration test
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: 'We will now update our integration test to provide the OAuth 2 credentials.
    The following test highlights the important details:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将更新我们的集成测试以提供OAuth 2凭据。以下测试突出了重要细节：
- en: '[PRE35]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Some important things to note are as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 一些重要的事项如下：
- en: '`ResourceOwnerPasswordResourceDetails resource = new ResourceOwnerPasswordResourceDetails()`:
    We set up `ResourceOwnerPasswordResourceDetails` with the user credentials and
    the client credentials'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResourceOwnerPasswordResourceDetails resource = new ResourceOwnerPasswordResourceDetails()`:
    我们使用用户凭据和客户端凭据设置了`ResourceOwnerPasswordResourceDetails`'
- en: '`resource.setAccessTokenUri(createUrl("/oauth/token"))`: Configures the URL
    of the authentication server'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource.setAccessTokenUri(createUrl("/oauth/token"))`: 配置认证服务器的URL'
- en: '`OAuth2RestTemplate oauthTemplate = new OAuth2RestTemplate(resource,new DefaultOAuth2ClientContext())`:
    `OAuth2RestTemplate` is an extension of `RestTemplate`, which supports the OAuth
    2 protocol'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OAuth2RestTemplate oauthTemplate = new OAuth2RestTemplate(resource,new DefaultOAuth2ClientContext())`:
    `OAuth2RestTemplate`是`RestTemplate`的扩展，支持OAuth 2协议'
- en: In this section, we looked at how to enable OAuth 2 authentication in our resources.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看了如何在资源中启用OAuth 2身份验证。
- en: Internationalization
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 国际化
- en: '**Internationalization** (**i18n**) is the process of developing applications
    and services so that they can be customized for different languages and cultures
    across the world. It is also called ;**localization**. The goal of internationalization
    or localization is to build applications that can offer content in multiple languages
    and formats.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**国际化**（**i18n**）是开发应用程序和服务的过程，使它们可以为世界各地的不同语言和文化进行定制。它也被称为**本地化**。国际化或本地化的目标是构建可以以多种语言和格式提供内容的应用程序。'
- en: Spring Boot has built-in support for internationalization.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot内置支持国际化。
- en: Let's build a simple service to understand how we can build internationalization
    in our APIs.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个简单的服务，以了解如何在我们的API中构建国际化。
- en: 'We would need to add a `LocaleResolver` and a message source to our Spring
    Boot application. The following code snippet should be included in `Application.java`:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要向我们的Spring Boot应用程序添加`LocaleResolver`和消息源。以下代码片段应包含在`Application.java`中：
- en: '[PRE36]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Some important things to note are as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 一些重要的事项如下：
- en: '`sessionLocaleResolver.setDefaultLocale(Locale.US)`: We are a setting a default
    locale of `Locale.US`.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sessionLocaleResolver.setDefaultLocale(Locale.US)`: 我们设置了`Locale.US`的默认区域设置。'
- en: '`messageSource.setBasenames("messages")`: We''re setting the base name of the
    message source as `messages`. If we are in fr locale (France), we would use messages
    from `message_fr.properties`. If a message is not available in `message_fr.properties`,
    it would be searched for in the default `message.properties`.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`messageSource.setBasenames("messages")`: 我们将消息源的基本名称设置为`messages`。如果我们处于fr区域设置（法国），我们将使用`message_fr.properties`中的消息。如果在`message_fr.properties`中找不到消息，则将在默认的`message.properties`中搜索。'
- en: '`messageSource.setUseCodeAsDefaultMessage(true)`: If a message is not found,
    then the code is returned as the default message.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`messageSource.setUseCodeAsDefaultMessage(true)`: 如果未找到消息，则将代码作为默认消息返回。'
- en: 'Let''s configure the messages in the respective files. Let''s start with the
    `messages` properties. The messages in this file would act as the defaults:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们配置各自文件中的消息。让我们从`messages`属性开始。该文件中的消息将作为默认消息：
- en: '[PRE37]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s also configure `messages_fr.properties`. The messages in this file would
    be used for the locale. If a message is not present here, then the defaults from
    `messages.properties` will be used:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也配置`messages_fr.properties`。该文件中的消息将用于区域设置。如果此处不存在消息，则将使用`messages.properties`中的默认消息：
- en: '[PRE38]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s create a service that returns a specific message using the locale specified
    in the ;`"Accept-Language"` header:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个服务，根据`"Accept-Language"`头中指定的区域设置返回特定消息：
- en: '[PRE39]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here are a couple of things to note:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是需要注意的几点：
- en: '`@RequestHeader(value = "Accept-Language", required = false) Locale locale`:
    The locale is picked up from the request header `Accept-Language`. It is not required.
    If a locale is not specified, the default locale is used.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RequestHeader(value = "Accept-Language", required = false) Locale locale`：区域设置从请求头`Accept-Language`中获取。不是必需的。如果未指定区域设置，则使用默认区域设置。'
- en: '`messageSource.getMessage("welcome.message", null, locale)`: `messageSource`
    is autowired into the controller. We get the welcome message based on the given
    locale.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`messageSource.getMessage("welcome.message", null, locale)`: `messageSource`被自动装配到控制器中。我们根据给定的区域设置获取欢迎消息。'
- en: 'The following screenshot shows the response when the preceding service is called
    without specifying a default `Accept-Language`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了在不指定默认`Accept-Language`时调用前面的服务时的响应：
- en: '![](img/c66a5e37-0172-4460-a7d3-c17a862ae5ea.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c66a5e37-0172-4460-a7d3-c17a862ae5ea.png)'
- en: The default message from `messages.properties` is returned.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 从`messages.properties`返回默认消息。
- en: 'The following screenshot shows the response when the preceding service is called
    with `Accept-Language fr`:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了在使用`Accept-Language fr`调用前面的服务时的响应：
- en: '![](img/6da4bb0b-3be3-4efd-bd29-0f7aee72b0a5.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6da4bb0b-3be3-4efd-bd29-0f7aee72b0a5.png)'
- en: The localized message from `messages_fr.properties` is returned.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 从`messages_fr.properties`返回本地化消息。
- en: In the preceding example, we customized the service to return localized messages
    based on the locale in the request. A similar approach can be used to internationalize
    ;all services in a component.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们定制了服务，根据请求中的区域设置返回本地化消息。类似的方法可以用于国际化组件中的所有服务。
- en: Caching
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存
- en: Caching data from services plays a crucial role in improving the performance
    and scalability of applications. In this section, we will look at the implementation
    options that Spring Boot provides.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务中缓存数据在提高应用程序性能和可扩展性方面起着至关重要的作用。在本节中，我们将看一下Spring Boot提供的实现选项。
- en: Spring provides a caching abstraction based on annotations. We will start with
    using Spring caching annotations. Later, we will introduce *JSR-107* caching annotations
    and compare them with Spring abstractions.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了基于注解的缓存抽象。我们将首先使用Spring缓存注解。稍后，我们将介绍*JSR-107*缓存注解，并将它们与Spring抽象进行比较。
- en: Spring-boot-starter-cache
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring-boot-starter-cache
- en: 'Spring Boot provides a starter project for caching `spring-boot-starter-cache`.
    Adding this to an application brings in all the dependencies to enable *JSR-107*
    and Spring caching annotations. The following code snippet shows the dependency
    details for `spring-boot-starter-cache`. Let''s add this to our file `pom.xml`:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot为缓存提供了一个启动器项目`spring-boot-starter-cache`。将其添加到应用程序中会引入所有依赖项，以启用*JSR-107*和Spring缓存注解。以下代码片段显示了`spring-boot-starter-cache`的依赖项详细信息。让我们将其添加到我们的文件`pom.xml`中：
- en: '[PRE40]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Enabling caching
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用缓存
- en: 'Before we can start using caching, we need to enable caching on the application.
    The following code snippet shows how we can enable caching:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用缓存之前，我们需要在应用程序上启用缓存。以下代码片段显示了如何启用缓存：
- en: '[PRE41]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`@EnableCaching` would enable caching in a Spring Boot application.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`@EnableCaching`将在Spring Boot应用程序中启用缓存。'
- en: Spring Boot automatically configures a suitable CacheManager ;framework to serve
    as a provider for the relevant cache. We will look at the details of how Spring
    Boot decides the CacheManager a little later.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot会自动配置适当的CacheManager框架，作为相关缓存的提供者。稍后我们将详细了解Spring Boot如何决定CacheManager。
- en: Caching data
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存数据
- en: 'Now that we have enabled caching, we can add the ;`@Cacheable` annotation to
    the methods where we want to cache the data. The following code snippet shows
    how to enable caching on `retrieveTodos`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启用了缓存，我们可以在希望缓存数据的方法上添加`@Cacheable`注解。以下代码片段显示了如何在`retrieveTodos`上启用缓存：
- en: '[PRE42]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding example, the `todos` for a specific user are cached. On the
    first call to the method for a specific user, the `todos` will be retrieved from
    the service. On subsequent calls for the same user, the data will be returned
    from the cache.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，特定用户的`todos`被缓存。对于特定用户的方法的第一次调用，`todos`将从服务中检索。对于相同用户的后续调用，数据将从缓存中返回。
- en: 'Spring also provides conditional caching. In the following snippet, caching
    is enabled only if the specified condition is satisfied:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: Spring还提供了有条件的缓存。在以下代码片段中，仅当满足指定条件时才启用缓存：
- en: '[PRE43]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Spring also provides additional annotations to evict data from the cache and
    add some custom data to cache. A few important ones are listed as follows:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: Spring还提供了额外的注解来从缓存中清除数据并向缓存中添加一些自定义数据。一些重要的注解如下所示：
- en: '`@CachePut`: Used to explicitly add data to the cache'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@CachePut`：用于显式向缓存中添加数据'
- en: '`@CacheEvict`: Used to remove stale data from the cache'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@CacheEvict`：用于从缓存中删除过期数据'
- en: '`@Caching`: Allows multiple nested `@Cacheable`, `@CachePut` ;, and `@CacheEvict`
    ;annotations to be used on the same method'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Caching`：允许在同一个方法上使用多个嵌套的`@Cacheable`、`@CachePut`和`@CacheEvict`注解'
- en: JSR-107 caching annotations
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSR-107缓存注解
- en: '*JSR-107* aims to standardize caching annotations. Listed here are some of
    the important *JSR-107* annotations:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '*JSR-107*旨在标准化缓存注解。以下是一些重要的*JSR-107*注解：'
- en: '`@CacheResult`: Similar to `@Cacheable`'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@CacheResult`：类似于`@Cacheable`'
- en: '`@CacheRemove`: Similar to `@CacheEvict`; ;`@CacheRemove` supports conditional
    eviction if an exception occurs'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@CacheRemove`：类似于`@CacheEvict`；如果发生异常，`@CacheRemove`支持有条件的驱逐'
- en: '`@CacheRemoveAll`: Similar to `@CacheEvict(allEntries=true)`; used to remove
    all entries from the cache'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@CacheRemoveAll`：类似于`@CacheEvict(allEntries=true)`；用于从缓存中移除所有条目'
- en: '*JSR-107* and Spring''s caching annotations are fairly similar in terms of
    the features they offer. Either of them is a good choice. We lean slightly toward
    *JSR-107* because it''s a standard. However, make sure you are not using both
    in the same project.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '*JSR-107*和Spring的缓存注解在提供的功能方面非常相似。它们中的任何一个都是一个不错的选择。我们稍微倾向于*JSR-107*，因为它是一个标准。但是，请确保在同一个项目中不要同时使用两者。'
- en: Auto-detection order
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动检测顺序
- en: 'When caching is enabled, Spring Boot auto-configuration starts looking for
    a caching provider. The following list shows the order in which Spring Boot searches
    for caching providers. The list is in order of decreasing preference:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 启用缓存时，Spring Boot自动配置开始寻找缓存提供程序。以下列表显示了Spring Boot搜索缓存提供程序的顺序。列表按优先级递减的顺序排列：
- en: JCache (*JSR-107*) (EhCache 3, Hazelcast, Infinispan, and so on)
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JCache（*JSR-107*）（EhCache 3、Hazelcast、Infinispan等）
- en: EhCache 2.x
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EhCache 2.x
- en: Hazelcast
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hazelcast
- en: Infinispan
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Infinispan
- en: Couchbase
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Couchbase
- en: Redis
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redis
- en: Caffeine
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Caffeine
- en: Guava
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Guava
- en: Simple
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Simple
- en: Summary
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Spring Boot makes developing Spring-based applications easy. It enables us to
    create production-ready applications very quickly.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot使得开发基于Spring的应用变得简单。它使我们能够非常快速地创建生产就绪的应用程序。
- en: In this chapter, we covered how to add features such as exception handling,
    caching, and internationalization to our application. We discussed the best practices
    of documenting REST services using Swagger. We looked at the basics of securing
    our microservice with Spring Security.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何向我们的应用程序添加异常处理、缓存和国际化等功能。我们讨论了使用Swagger记录REST服务的最佳实践。我们了解了如何使用Spring
    Security保护我们的微服务的基础知识。
- en: In the next chapter, we will shift our attention toward advanced features in
    Spring Boot. We will look at how to provide monitoring on top of our REST services,
    learn how to deploy the microservice to the Cloud, and understand how to become
    more productive when developing applications with Spring Boot.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把注意力转向Spring Boot中的高级功能。我们将学习如何在我们的REST服务之上提供监控，学习如何将微服务部署到云上，并了解如何在使用Spring
    Boot开发应用程序时变得更加高效。
