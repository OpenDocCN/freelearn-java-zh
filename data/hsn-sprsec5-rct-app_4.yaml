- en: Authentication Using CAS and JAAS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CAS和JAAS进行身份验证
- en: This chapter picks up from where we left off in the previous chapter by looking
    at other authentication mechanisms, namely CAS and JAAS, supported by Spring Security.
    Again, this is also a fully hands-on coding chapter, and we will build small applications,
    most of them starting from the base application that we built in [Chapter 2](e43a2e26-5b28-4d37-a7f8-d3c992a07bc2.xhtml), *Deep
    Diving into Spring Security*. These authentication mechanisms are well-known in
    the industry and many enterprises have these as established mechanism by which
    they authenticate the user and give access to many of their employee and consumer
    facing applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从上一章结束的地方继续，探讨Spring Security支持的其他身份验证机制，即CAS和JAAS。同样，这也是一个完全动手编码的章节，我们将构建小型应用程序，其中大部分是从我们在[第2章](e43a2e26-5b28-4d37-a7f8-d3c992a07bc2.xhtml)中构建的基础应用程序开始的，*深入Spring
    Security*。这些身份验证机制在行业中广为人知，许多企业都将它们作为已建立的机制，用于对用户进行身份验证并允许访问他们的员工和消费者面向的许多应用程序。
- en: Each of the authentication mechanisms has a project that you can see in the
    book’s GitHub page. However, in the book, we will only cover important aspects
    of the sample code to reduce clutter within the chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每种身份验证机制都有一个项目，您可以在本书的GitHub页面上看到。但是，在本书中，我们只会涵盖样本代码的重要方面，以减少章节内的混乱。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: CAS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CAS
- en: Java Authentication and Authorization Service
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java身份验证和授权服务
- en: Kerberos
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 凯尔伯斯
- en: Custom AuthenticationEntryPoint
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义AuthenticationEntryPoint
- en: Password Encoder
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码编码器
- en: Custom Filter
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义过滤器
- en: CAS
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CAS
- en: <q>The</q> Central Authentication Service (CAS) <q>is a single-sign-on/single-sign-off
    protocol for the web. It permits a user to access multiple applications while
    providing their credentials (such as userid and password) only once to a central
    CAS Server application.</q>
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <q>中央认证服务（CAS）是Web的单点登录/单点注销协议。它允许用户访问多个应用程序，同时只需向中央CAS服务器应用程序提供其凭据（如用户ID和密码）一次。</q>
- en: <q>– CAS Protocol Specification</q>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <q>– CAS协议规范</q>
- en: 'CAS is an open source, platform-independent, central **single sign-on** (**SSO**)
    service supporting a variety of well-known protocols. Spring Security has first-class
    support for CAS, and the implementation is quite simple for an enterprise having
    a central CAS server. CAS is based on Spring Framework, and the architecture is
    quite simple, as shown in the following diagram:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: CAS是一个开源的、平台无关的、支持各种知名协议的中央**单点登录**（**SSO**）服务。Spring Security对CAS有一流的支持，对于拥有中央CAS服务器的企业来说，实现非常简单。CAS基于Spring
    Framework，其架构非常简单，如下图所示：
- en: '![](img/aed55c9b-b2b1-43d3-99ad-f9414a16474a.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aed55c9b-b2b1-43d3-99ad-f9414a16474a.png)'
- en: 'Figure 1: CAS architecture (figure adapted from https://apereo.github.io)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：CAS架构（图表改编自https://apereo.github.io）
- en: The **CAS server** is a Java servlet-based application built on Spring Framework
    (Spring MVC and Spring Web Flow). It authenticates and grants access to CAS-enabled
    services.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**CAS服务器**是一个基于Java Servlet的应用程序，构建在Spring Framework（Spring MVC和Spring Web
    Flow）上。它对CAS启用的服务进行身份验证并授予访问权限。'
- en: Upon the successful login of the user, an SSO session is created, and the server
    issues a **ticket-granting-ticket** (**TGT**), and this token is validated against
    the backend for subsequent calls from the client.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 用户成功登录后，将创建一个SSO会话，并且服务器将发出**票证授予票证**（**TGT**），并且该令牌将针对来自客户端的后续调用进行验证。
- en: The **CA****S** **client** is a CAS-enabled application that communicates with
    CAS using supported protocols (CAS, SAML, OAuth, and so on). A number of language
    supports are already available for CAS, and a number of applications have implemented
    this methodology. Some of the well-known applications are Atlassian products (JIRA
    and Confluence), Drupal, and so on.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**CAS客户端**是一个使用支持的协议（CAS、SAML、OAuth等）与CAS通信的CAS启用应用程序。已经有许多语言支持CAS，并且许多应用程序已经实现了这种方法。一些知名的应用程序是Atlassian产品（JIRA和Confluence）、Drupal等。'
- en: 'The following diagram shows the authentication flow (sequence diagram) involving
    a CAS server and client:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了涉及CAS服务器和客户端的身份验证流程（序列图）：
- en: '![](img/b60a7c9a-1ea7-4707-ab9f-066eeaec965c.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b60a7c9a-1ea7-4707-ab9f-066eeaec965c.png)'
- en: 'Figure 2: CAS authentication flow'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：CAS身份验证流程
- en: Let's see a working hands-on example now. We will have to create a CAS server
    and then a client that uses the CAS server to connect and get itself authenticated.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一个实际的动手示例。我们将创建一个CAS服务器，然后创建一个客户端，该客户端使用CAS服务器进行连接并进行身份验证。
- en: CAS server setup
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CAS服务器设置
- en: The CAS project source code can be found in GitHub at [https://github.com/apereo/cas](https://github.com/apereo/cas).
    It is not really required to check out the source code, build the CAS server,
    and then deploy it. WAR overlay is an approach wherein, rather than downloading
    the source and building, we get a pre-built CAS web application and then we can
    customize certain behavior as needed for achieving our use case. We will be using
    this approach to set up our CAS server. Also, we will use Maven-based WAR overlay,
    which can be found in GitHub at [https://github.com/apereo/cas-overlay-template](https://github.com/apereo/cas-overlay-template).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: CAS项目源代码可以在GitHub上找到，网址为[https://github.com/apereo/cas](https://github.com/apereo/cas)。实际上并不需要检出源代码，构建CAS服务器，然后部署它。WAR覆盖是一种方法，我们不是下载源代码并构建，而是获取一个预构建的CAS
    Web应用程序，然后根据需要自定义某些行为以实现我们的用例。我们将使用这种方法来设置我们的CAS服务器。此外，我们将使用基于Maven的WAR覆盖，可以在GitHub上找到，网址为[https://github.com/apereo/cas-overlay-template](https://github.com/apereo/cas-overlay-template)。
- en: Git clone
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git克隆
- en: 'Launch your favorite command prompt and clone the CAS overlay project into
    your desired project. I am going to create a folder named `cas-sample`, wherein
    I will clone the server in the `server` folder by executing the following command
    from the `cas-sample` folder:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 启动您喜欢的命令提示符，并将CAS覆盖项目克隆到您想要的项目中。我将创建一个名为`cas-sample`的文件夹，在其中我将通过从`cas-sample`文件夹执行以下命令来在`server`文件夹中克隆服务器：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Adding additional dependencies
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加额外的依赖项
- en: 'The CAS server doesn''t allow any client to connect to it. Each client has
    to be registered with the desired CAS server. There are multiple mechanisms by
    which we can register a client to the server. We will use the JSON/YML configuration
    to register our client to the server. Go ahead and add the following dependency
    to your `pom.xml` file within the server project that you just cloned:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: CAS服务器不允许任何客户端连接。每个客户端都必须在所需的CAS服务器上注册。我们可以使用多种机制将客户端注册到服务器。我们将使用JSON/YML配置将客户端注册到服务器。继续并将以下依赖项添加到您刚刚克隆的服务器项目的`pom.xml`文件中：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Most of the versions in the `pom.xml` file are managed by the parent POM.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`pom.xml`文件中的大多数版本由父POM管理。'
- en: Setting up the resources folder in the project
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在项目中设置资源文件夹
- en: 'In the `server` project, create a folder called `src/main/resources`. Copy
    the `etc` folder within the `server` folder into `src/main/resources`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在`server`项目中，创建一个名为`src/main/resources`的文件夹。将`server`文件夹中的`etc`文件夹复制到`src/main/resources`中：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Creating the application.properties file
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建application.properties文件
- en: 'Create a file named `application.properties`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`application.properties`的文件：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now fill in the following details in the `application.properties` file:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`application.properties`文件中填写以下细节：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding file sets the port and SSL keystore values (a very important step
    in setting up a CAS server), and also sets up the CAS server `config` folder.
    Clearly, we need to create a keystore as indicated in this file.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 上述文件设置了端口和SSL密钥库的值（在设置CAS服务器时非常重要），还设置了CAS服务器的`config`文件夹。显然，我们需要按照此文件中指示的方式创建一个密钥库。
- en: Please note, the overlay project has a file, namely the `build.sh` file, that
    contains most of these details in it. We are manually doing this to have a clear
    understanding.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，覆盖项目中有一个文件，即`build.sh`文件，其中包含大部分这些细节。我们手动执行这些操作是为了更清楚地理解。
- en: The last line in `application.properties` sets up a test user with the credentials `casuser`/`password`,
    which can be used to log into the CAS server for various demo purposes. This approach
    is not recommended in the production setup.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`application.properties`中的最后一行设置了一个测试用户，凭据为`casuser`/`password`，可用于登录CAS服务器进行各种演示目的。这种方法不建议在生产环境中使用。'
- en: Creating a local SSL keystore
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建本地SSL密钥库
- en: 'Navigate to the `cas-sample/server/src/main/resources/etc/cas` folder in a
    shell and execute the following command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在shell中导航到`cas-sample/server/src/main/resources/etc/cas`文件夹，并执行以下命令：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following figure shows the successful execution of the preceding command
    in a command prompt window:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了在命令提示符窗口中成功执行上述命令：
- en: '![](img/ca9b9d48-46a3-4470-aac9-c83c8c497c6c.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ca9b9d48-46a3-4470-aac9-c83c8c497c6c.png)'
- en: 'Figure 3: Creation of SSL keystore'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：SSL密钥库的创建
- en: It's important to note that for the SSL handshake to work properly, most of
    the values while generating the keystore are put as localhost. This is an important
    step and needs to be followed without fail.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，为了使SSL握手正常工作，生成密钥库时大多数值都设置为localhost。这是一个重要的步骤，需要严格遵循。
- en: Creating the .crt file to be used by the client
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建供客户端使用的.crt文件
- en: 'For the client to connect to the CAS server, out of the generated keystore,
    we need to create a `.crt` file. In the same folder (`cas-sample/server/src/main/resources/etc/cas`),
    run the following command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使客户端连接到CAS服务器，我们需要从生成的密钥库中创建一个`.crt`文件。在相同的文件夹（`cas-sample/server/src/main/resources/etc/cas`）中，运行以下命令：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When asked for a password, provide the same password (we have set the password
    as `password`). Executing the preceding command will create `thekeystore.crt` file.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当要求输入密码时，请提供相同的密码（我们已将密码设置为`password`）。执行上述命令将创建`thekeystore.crt`文件。
- en: Exporting the .crt file to Java and the JRE cacert keystore
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将.crt文件导出到Java和JRE cacert密钥库
- en: 'Execute the following command to find your Java installation directory:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令以查找您的Java安装目录：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Alternatively, execute the following command directly to add the `.crt` file
    to Java cacerts:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，直接执行以下命令将`.crt`文件添加到Java cacerts：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following figure shows successful execution of the preceding command in
    a command prompt window:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了在命令提示符窗口中成功执行上述命令：
- en: '![](img/7d6189e2-8121-45a1-84e2-d61464d841a4.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d6189e2-8121-45a1-84e2-d61464d841a4.png)'
- en: 'Figure 4: Exporting .crt file to Java keystore'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：将.crt文件导出到Java密钥库
- en: When setting up a client, make sure that the JDK used is the same as the one
    in which we have added the `.crt` file. To reflect the certification addition
    on to Java, a restart of the machine is suggested.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置客户端时，请确保使用的JDK与我们已添加`.crt`文件的JDK相同。为了将证书添加到Java上，建议重新启动机器。
- en: Building a CAS server project and running it
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建CAS服务器项目并运行它
- en: 'From within the cas-sample/cas-server folder, execute the following two commands:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cas-sample/cas-server`文件夹中，执行以下两个命令：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If everything goes well, as shown in the following figure, you should see a
    log message which says READY:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，如下图所示，您应该看到一条日志消息，其中显示READY：
- en: '![](img/60793f9a-7ac4-424f-8cb7-c3ed8951cf73.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60793f9a-7ac4-424f-8cb7-c3ed8951cf73.png)'
- en: 'Figure 5: CAS server ready logging'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：CAS服务器准备就绪日志
- en: 'Now open a browser and navigate to the URL `https://localhost:6443/cas`. This
    will navigate you to the default login form of the CAS server. Enter the default
    credentials (`casuser`/`Mellon`) and you are in. Most browsers would say that
    the connection is insecure. Add the domain as an exception and soon after that
    the application will work fine:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开浏览器，导航到URL `https://localhost:6443/cas`。这将导航您到CAS服务器的默认登录表单。输入默认凭据（`casuser`/`Mellon`）即可登录。大多数浏览器会显示连接不安全。将域名添加为异常情况，之后应用程序将正常工作：
- en: '![](img/6bae5e52-91be-4143-9e0e-4dd08597257a.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6bae5e52-91be-4143-9e0e-4dd08597257a.png)'
- en: 'Figure 6: Default CAS server login form'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图6：默认CAS服务器登录表单
- en: Log in with the demo test user (`testcasuser`/`password`) and you should be
    logged in and navigated to a user home page.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用演示测试用户（`testcasuser`/`password`）登录，您应该已登录并导航到用户主页。
- en: Registering a client with the CAS server
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将客户端注册到CAS服务器
- en: As mentioned earlier, every client has to be registered with the CAS server
    to allow participation in SSO. The section shows how we can register a client
    with the CAS server.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，每个客户端都必须在CAS服务器上注册，以允许参与SSO。本节显示了如何将客户端注册到CAS服务器。
- en: JSON service configuration
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON服务配置
- en: There are many ways by which a client/service can register itself to a CAS server. We
    will be using JSON configuration here and have already included dependencies to
    our `pom.xml` file in the earlier step. Apart from JSON, other formats such as
    YAML, Mongo, LDAP and others do exist.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 客户/服务可以通过多种方式注册到CAS服务器。我们将在这里使用JSON配置，并已在之前的步骤中将依赖项包含到我们的`pom.xml`文件中。除了JSON之外，还存在其他格式，如YAML、Mongo、LDAP等。
- en: 'Create a new folder named `clients` in the `src/main/resources` folder. Create
    a new file in the newly created folder with the following content:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/main/resources`文件夹中创建一个名为`clients`的新文件夹。在新创建的文件夹中创建一个新文件，内容如下：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Save the file with the name `newYmlFile-5000.yml`. Let''s go into the details
    of a couple of important attributes:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件保存为`newYmlFile-5000.yml`。让我们详细了解一些重要属性：
- en: '`serviceId`: URL, in a regular expression pattern, of clients who want to connect
    to the CAS server. In our example, we refer to a client Spring Boot application
    running on port `9090`, which connects to the CAS server.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serviceId`：客户端想要连接到CAS服务器的URL，以正则表达式模式表示。在我们的示例中，我们指的是运行在端口`9090`上的客户端Spring
    Boot应用程序，它连接到CAS服务器。'
- en: '`id`: unique identifier for this configuration.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：此配置的唯一标识符。'
- en: Other configurable attributes are documented in the official website at [https://goo.gl/CGsDp1](https://goo.gl/CGsDp1).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可配置属性在官方网站[https://goo.gl/CGsDp1](https://goo.gl/CGsDp1)上有文档记录。
- en: Additional application.properties file changes
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加的application.properties文件更改
- en: 'In this step, we let the CAS server about the usage of YML configuration and
    the location to find these YMLs in the server. Add the following property to the
    `application.properties` file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在此步骤中，我们让CAS服务器了解YML配置的使用以及在服务器中查找这些YML的位置。将以下属性添加到`application.properties`文件中：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It's good practice to separate CAS-related configuration properties into a different
    properties file. So, go ahead and create a `cas.properties` file and include CAS-related
    properties there.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将CAS相关的配置属性分离到不同的属性文件中是一个好习惯。因此，继续创建一个`cas.properties`文件，并在其中包含CAS相关属性。
- en: CAS client setup
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CAS客户端设置
- en: We will use Spring Initializr to create our CAS client project setup. We used
    a similar approach earlier. Let's go through it once again.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Spring Initializr来创建CAS客户端项目设置。我们之前使用了类似的方法。让我们再次看一下。
- en: Bootstrap Spring project using Spring Initializr
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Initializr引导Spring项目
- en: 'Visit [http://start.spring.io/](http://start.spring.io/) and enter the following
    details as shown in the following figure. Make sure you select the right dependencies:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[http://start.spring.io/](http://start.spring.io/)，并输入如下图所示的详细信息。确保选择正确的依赖项：
- en: '![](img/dbf118e6-2bf0-48f2-ab88-21c044d2548f.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dbf118e6-2bf0-48f2-ab88-21c044d2548f.png)'
- en: 'Figure 7: Spring Initializr for creating secured-cas-client project'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图7：用于创建secured-cas-client项目的Spring Initializr
- en: 'Click on the Generate Project button and download the ZIP file to a folder
    of your choice (I will be keeping this inside the `cas-sample` folder). Execute
    the `unzip` command as follows. I am using macOS for running all my sample application,
    so I will be using commands, if any, suitable for this platform:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 单击“生成项目”按钮，将ZIP文件下载到您选择的文件夹中（我将把它保存在`cas-sample`文件夹中）。执行以下`unzip`命令。我在macOS上运行所有示例应用程序，因此我将使用适用于此平台的命令（如果有的话）：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Including CAS libraries in pom.xml
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在pom.xml中包含CAS库
- en: 'Modify your project''s `pom.xml` by adding the following dependencies:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加以下依赖项修改项目的`pom.xml`：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Changing the application.properties file
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改application.properties文件
- en: 'Just to make sure that we don''t use any other commonly used ports, we are
    going to set the client to listen to port `9090`. In the CAS server, we have also
    configured it so that the client will be listening to port `9090`. Add the following
    property to the `application.properties` file:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们不使用任何其他常用端口，我们将设置客户端监听端口`9090`。在CAS服务器中，我们还配置了客户端将监听端口`9090`。将以下属性添加到`application.properties`文件中：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Additional bean configuration
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加的bean配置
- en: We will now set up various beans, as needed by the CAS Spring Security module.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将设置各种bean，CAS Spring Security模块需要。
- en: ServiceProperties bean
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ServiceProperties bean
- en: 'Convey to CAS that this is your CAS client/service by setting up this bean.
    Open `SpringBootCasClientApplication.java` and add the following bean definition:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置此bean来告诉CAS这是您的CAS客户端/服务。打开`SpringBootCasClientApplication.java`并添加以下bean定义：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The URL `http://localhost:9090/login/cas` that is configured will internally
    get mapped to `CasAuthenticationFilter`. The parameter `sendRenew `is set to `false`.
    Being set as `false`, this tells the login service that username/password is required
    to gain access to the service, every time. It also gives the user access to all
    services/client without having to enter a username/password (if already done once).
    When logged out, the user is logged out automatically from all services.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 配置的URL`http://localhost:9090/login/cas`将在内部映射到`CasAuthenticationFilter`。参数`sendRenew`设置为`false`。设置为`false`时，这告诉登录服务每次都需要用户名/密码才能访问服务。它还允许用户在不必再次输入用户名/密码的情况下访问所有服务/客户端。注销时，用户将自动注销所有服务。
- en: AuthenticationEntryPoint bean
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AuthenticationEntryPoint bean
- en: 'Take a look at the following code. Quite straightforward, isn''t it?. This
    is where we let  know where our CAS server is running. When a user tries to log
    in, the application will be redirected to this URL:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码。相当简单直接，不是吗？这是我们告诉的CAS服务器运行的位置。当用户尝试登录时，应用程序将被重定向到此URL：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: TicketValidator bean
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TicketValidator bean
- en: 'When the client application gets a ticket that has already been given to a
    particular user, this bean is used to validate its authenticity:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端应用程序获得已经分配给特定用户的票证时，将使用此bean来验证其真实性：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: CasAuthenticationProvider bean
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CasAuthenticationProvider bean
- en: 'Bind all the beans declared earlier to the authentication provider bean. We
    will be loading users from a static list provided as part of `UserDetailsService `in
    the authentication provider. In a production scenario, this will point to a database:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将之前声明的所有bean绑定到认证提供者bean。我们将从`UserDetailsService`中提供的静态列表中加载用户。在生产环境中，这将指向数据库：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With this we are ready to set up the all-important Spring Security configuration.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备设置非常重要的Spring Security配置。
- en: Setting up Spring Security
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Spring Security
- en: 'Let''s bring in the bean references that we have done in the previous step
    to the Spring Security configuration file. Create a new Java file called `SpringSecurityConfig` and
    add member variables. After that, create a constructor with `@Autowired` annotation
    as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将在上一步中完成的bean引用带入Spring Security配置文件中。创建一个名为`SpringSecurityConfig`的新的Java文件并添加成员变量。之后，创建一个带有`@Autowired`注解的构造函数如下：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When a user accesses a client application that is secured by a CAS server, the
    configured bean `AuthenticationEntryPoint` is triggered, and the user is taken
    to the CAS server URL that is configured in this bean. Once the user enters credentials
    and submits the page, the CAS server authenticates the user and creates a service
    ticket. This ticket is now appended to the URL and the user is taken to the requested
    client application. The client application uses the `TicketValidator `bean to
    validate the ticket with the CAS server and, if valid, allows user to access the
    requested page.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户访问由CAS服务器保护的客户端应用程序时，配置的bean`AuthenticationEntryPoint`将被触发，并且用户将被带到在此bean中配置的CAS服务器URL。一旦用户输入凭证并提交页面，CAS服务器将对用户进行身份验证并创建服务票证。现在，该票证被附加到URL，并且用户将被带到请求的客户端应用程序。客户端应用程序使用`TicketValidator`
    bean来验证CAS服务器的票证，并且如果有效，则允许用户访问请求的页面。
- en: 'We need to override a couple of important methods before we configure our HTTP
    security. The first method uses `AuthenticationManagerBuilder`, in which we tell
    it to use our `AuthenticationProvider`. Please create the method as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置HTTP安全性之前，我们需要重写一些重要的方法。第一个方法使用`AuthenticationManagerBuilder`，我们告诉它使用我们的`AuthenticationProvider`。请按照以下方式创建该方法：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We now override another method that indicates to the `AuthenticationManager `to
    put our created `AuthenticationProvider` in it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在重写另一个方法，指示`AuthenticationManager`将我们创建的`AuthenticationProvider`放入其中：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We are now ready to create a filter named `CasAuthenticationFilter `(as a bean),
    which actually intercepts the requests and does CAS ticket validation.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备创建一个名为`CasAuthenticationFilter`的过滤器（作为一个bean），它实际上拦截请求并进行CAS票证验证。
- en: Creating the CasAuthenticationFilter bean
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建CasAuthenticationFilter bean
- en: 'Creating the `CasAuthenticationFilter` bean is quite straightforward, as we
    just assign the `serviceProperties `that we created to the `CasAuthenticationFilter`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`CasAuthenticationFilter` bean非常简单，因为我们只需将我们创建的`serviceProperties`分配给`CasAuthenticationFilter`：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Setting up the controller
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置控制器
- en: This is the final setup in our CAS client project setup. We will have an unsecured
    page containing a link to a secured page. When the secured page is accessed, CAS
    SSO kicks in and the user is navigated to the CAS authentication page. Once you
    log in using the credentials (`casuser`/`password`), the user is taken to the
    secured page, where we display the authenticated username.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们CAS客户端项目设置的最终设置。我们将有一个包含指向受保护页面链接的未受保护页面。当访问受保护页面时，CAS SSO启动，用户被导航到CAS认证页面。一旦使用凭证（`casuser`/`password`）登录，用户将被带到受保护页面，我们将显示经过身份验证的用户名。
- en: We will create an `ndexController` that has the root folder routing (`/`). This
    navigates the user to the `index.html` page.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`ndexController`，它具有根文件夹路由（`/`）。这将把用户导航到`index.html`页面。
- en: 'Create `IndexController.java` in a new package (preferably in the controllers
    package):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个新的包中创建`IndexController.java`（最好在controllers包中）：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create the `index.html` file in the `src/resources/templates` folder with the
    following content:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/resources/templates`文件夹中创建`index.html`文件，内容如下：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now create a new controller named `CasController.java` within the same controllers
    package. We will be mapping all secured pages as well as setting up various request
    mappings in this controller. In the controller class, copy the following code
    snippet:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在相同的controllers包中创建一个名为`CasController.java`的新控制器。我们将映射所有受保护的页面，并在此控制器中设置各种请求映射。在控制器类中，复制以下代码片段：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create a new HTML file named `secured.html` with the following content. This
    is our secured page and will just display the authenticated username:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`secured.html`的新HTML文件，内容如下。这是我们的受保护页面，将显示经过身份验证的用户名：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Running the application
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: Start the CAS server (within `cas-server`, run `./build.sh run`). After that,
    start the spring boot project (`secured-cas-client`) by executing `./mvnw spring-boot:run`.
    Navigate your browser to `http://localhost:9090`. This will take the user to `index.html`,
    and when they click on the link (which navigates to the `secured.html` page),
    the user is taken to the CAS authentication page. To be authenticated, enter the
    CAS credentials and, with the ticket set as query string, you will then be taken
    to the secured page. The secured page validates the ticket with the CAS server
    and then displays the username.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 启动CAS服务器（在`cas-server`中运行`./build.sh run`）。之后，通过执行`./mvnw spring-boot:run`启动spring
    boot项目（`secured-cas-client`）。将浏览器导航到`http://localhost:9090`。这将带用户到`index.html`，当他们点击链接（导航到`secured.html`页面）时，用户将被带到CAS认证页面。要进行认证，请输入CAS凭证，然后将票证设置为查询字符串，然后您将被带到受保护的页面。受保护的页面将使用CAS服务器验证票证，然后显示用户名。
- en: With this, we complete our CAS sample using Spring Security. In the next section,
    similar to CAS, we will detail usage of JAAS authentication by employing Spring
    Security.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们完成了使用Spring Security的CAS示例。在下一节中，类似于CAS，我们将详细介绍如何使用JAAS认证来使用Spring Security。
- en: Java Authentication and Authorization Service
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java身份验证和授权服务
- en: '**Java Authentication and Authorization Service** (**JAAS**) ([https://docs.oracle.com/javase/6/docs/technotes/guides/security/jaas/JAASRefGuide.html](https://docs.oracle.com/javase/6/docs/technotes/guides/security/jaas/JAASRefGuide.html))
    implements a Java version of the standard **Pluggable Authentication Module**
    (**PAM**) framework. It was introduced as an optional package (extension) to the
    J2SDK (1.3) and then was integrated into the J2SDK 1.4.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java身份验证和授权服务**（**JAAS**）（[https://docs.oracle.com/javase/6/docs/technotes/guides/security/jaas/JAASRefGuide.html](https://docs.oracle.com/javase/6/docs/technotes/guides/security/jaas/JAASRefGuide.html)）实现了标准**可插拔身份验证模块**（**PAM**）框架的Java版本。它作为J2SDK（1.3）的可选包（扩展）引入，然后集成到J2SDK
    1.4中。'
- en: 'JAAS is a standard library which provides your application with the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: JAAS是一个标准库，为您的应用程序提供以下功能：
- en: A representation of identity (principal) by providing credentials (username/password
    – subject).
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过提供凭证（用户名/密码-主体）来表示身份（主体）。
- en: A login service that will call back your application to gather credentials from
    user and then returns a subject after successful authentication.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个登录服务，将回调您的应用程序以从用户那里收集凭证，然后在成功身份验证后返回一个主体。
- en: 'A mechanism to grant necessary grants (authorization) to a user after successful
    authentication:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在成功身份验证后，向用户授予必要的授权的机制：
- en: '![](img/0cdf1f55-cdf8-4ce3-a790-4a1a28c1f976.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0cdf1f55-cdf8-4ce3-a790-4a1a28c1f976.png)'
- en: 'Figure 8: Working of JAAS'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图8：JAAS的工作原理
- en: As shown in the preceding figure, JAAS has predefined login modules for most
    of the login mechanisms built in. Custom login modules can be imported or built
    according to application requirements. JAAS allows application to be independent
    from the actual authentication mechanism. It's truly pluggable, as new login modules
    can be integrated without any change to the application code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，JAAS具有大多数内置登录机制的预定义登录模块。可以根据应用程序要求导入或构建自定义登录模块。JAAS允许应用程序独立于实际的身份验证机制。它是真正可插拔的，因为可以集成新的登录模块而无需更改应用程序代码。
- en: 'JAAS is simple and the process is as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: JAAS很简单，流程如下：
- en: The application instantiates a `LoginContext` object and invokes appropriate
    (controlled by configuration) `LoginModule`, which performs authentication.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该应用程序实例化一个`LoginContext`对象，并调用适当的（由配置控制的）`LoginModule`，执行身份验证。
- en: Once the authentication is successful, the *s**ubject* (who runs the code) is
    updated with principle and credentials by `LoginModule`.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦身份验证成功，*主体*（运行代码的人）将通过`LoginModule`更新为*主体*和*凭证*。
- en: 'Soon after that, JAAS kick starts the authorization process (using standard
    Java SE access control model). Access is granted based on the following:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在那之后，JAAS启动授权过程（使用标准Java SE访问控制模型）。访问是基于以下内容授予的：
- en: '**Codesource**: where the code originated and who signed the code'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码源**：代码的来源地和签署代码的人'
- en: '**The user**: who (also called as **subject**) is running the code'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户**：运行代码的人（也称为**主体**）'
- en: Now that we have a rough idea of JAAS and its working, we will see working of
    JAAS using Spring Security by going through an example in the following section.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对JAAS及其工作原理有了大致的了解，接下来我们将通过以下部分中的示例来查看使用Spring Security的JAAS的工作原理。
- en: Setting up a project
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目
- en: The sample application that we are going to build is very similar to the one
    that we created at the start of [Chapter 3](69913c59-1186-44b2-8707-dceca721e206.xhtml),
    *Authentication Using SAML, LDAP, and OAuth/OIDC*. Many aspects are similar but
    differ in a subtle manner. Each step will be explained; however, at times we won't
    go into details as we have seen some aspects in earlier samples.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要构建的示例应用程序与[第3章](69913c59-1186-44b2-8707-dceca721e206.xhtml)开始时创建的应用程序非常相似，即使用SAML、LDAP和OAuth/OIDC进行身份验证。许多方面都是相似的，但在细微的方式上有所不同。每个步骤都将得到解释；但是，有时我们不会详细介绍，因为我们已经在之前的示例中看到了一些方面。
- en: Setting up Maven project
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Maven项目
- en: 'We will be creating a Maven project using the IntelliJ IDE. Add the following
    dependencies and build setup in your `pom.xml` file:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用IntelliJ IDE创建一个Maven项目。在您的`pom.xml`文件中添加以下依赖项和构建设置：
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We add Spring Framework, Spring Security, JSP/JSTL, and the logging framework
    (SLF4J and Logback) dependencies. We will be using an embedded jetty server (look
    at the build section) to run our application.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加Spring框架、Spring安全、JSP/JSTL和日志框架（SLF4J和Logback）的依赖项。我们将使用嵌入式jetty服务器（查看构建部分）来运行我们的应用程序。
- en: Setting up LoginModule
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置LoginModule
- en: '`LoginModule` is responsible for authenticating a user. We will be creating
    our own `LoginModule` named `JaasLoginModule `and then implementing the `login`
    method. Being a sample application, our login logic is quite trivial. The `LoginModule` interface
    has to be implemented for you to write your own custom login module.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoginModule`负责对用户进行身份验证。我们将创建自己的名为`JaasLoginModule`的`LoginModule`，然后实现`login`方法。作为示例应用程序，我们的登录逻辑非常简单。必须实现`LoginModule`接口，才能编写自定义的登录模块。'
- en: 'Create a class, `JaasLoginModule.java` (which implements `LoginModule`), and
    implement all the methods. In this class, we will be focusing on two important
    methods. In the `initialize` method, we get all the necessary information, such
    as username/password/subject, that is stored as field variables to be used in
    our main `login` method:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个类`JaasLoginModule.java`（实现`LoginModule`），并实现所有方法。在这个类中，我们将专注于两个重要的方法。在`initialize`方法中，我们获取所有必要的信息，如用户名/密码/主体，这些信息存储为字段变量，以便在我们的主要`login`方法中使用：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the `login` method, we will log in using the values stored in the `initialize`
    method. In our case, if the hard-coded username/password is valid, set the principal
    in the subject:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在`login`方法中，我们将使用`initialize`方法中存储的值进行登录。在我们的情况下，如果硬编码的用户名/密码有效，则在主体中设置主体：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Setting up a custom principal
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置自定义主体
- en: 'We have created our own custom principal class by implementing the `java.security.Principal`
    interface. It''s a very simple class in which we take in the username through
    a constructor and then use that to return in the `getName` method:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过实现`java.security.Principal`接口创建了我们自己的自定义主体类。这是一个非常简单的类，我们通过构造函数接收用户名，然后在`getName`方法中使用它返回：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Setting up a custom AuthorityGranter
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置自定义AuthorityGranter
- en: '`AuthorityGranter `is entrusted to provide relevant roles to the authenticated
    user. We will be creating our own custom class by implementing `org.springframework.security.authentication.jaas.AuthorityGranter`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthorityGranter`被委托为经过身份验证的用户提供相关角色。我们将通过实现`org.springframework.security.authentication.jaas.AuthorityGranter`来创建我们自己的自定义类：'
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Being a sample implementation, in this class, we look at the logged in users
    username and grant a hard-coded role to it. In real-life applications, we would
    be doing something more serious in here by actually querying a database and then
    granting appropriate roles to the logged in user.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个示例实现，在这个类中，我们查看已登录用户的用户名并为其授予硬编码角色。在实际应用程序中，我们将在这里做一些更严肃的事情，实际上查询数据库，然后为已登录用户授予适当的角色。
- en: Configuration files
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置文件
- en: We need to have a number of configuration files (Java configuration) in our
    sample, most of which have been covered earlier. For the remaining files (yet
    to be covered), we will either run through them quickly or go into details when
    they are covered.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在示例中有许多配置文件（Java配置），其中大部分已经在前面涵盖过。对于剩下的文件（尚未涵盖），我们要么快速浏览它们，要么在涵盖它们时进行详细讨论。
- en: Application configuration
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序配置
- en: We don't have any application-specific configuration here but it's always good
    to have such a file in your application. We have `ApplicationConfig.java` as our
    application-level Java configuration (it doesn't have any content in it).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里没有任何特定于应用程序的配置，但在您的应用程序中拥有这样的文件总是很好的。我们有`ApplicationConfig.java`作为我们的应用程序级Java配置（它里面没有任何内容）。
- en: Spring MVC configuration
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring MVC配置
- en: 'As shown in the following code, here we will be creating Spring MVC specific
    Java configurations (`SpringMVCConfig.java`):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，我们将创建Spring MVC特定的Java配置（`SpringMVCConfig.java`）：
- en: '[PRE32]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this configuration, set the view's *prefix* and *suffix*. Make sure that
    your login view controller is added explicitly, as we don't have a route defined
    in our controller (we will see the controller later).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配置中，设置视图的*前缀*和*后缀*。确保您的登录视图控制器被显式添加，因为我们的控制器中没有定义路由（我们稍后会看到控制器）。
- en: Spring Security configuration
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security配置
- en: This is a very important configuration example.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常重要的配置示例。
- en: 'We will create an `AuthenticationProvider `bean. We will be using our custom `LoginModule `and
    then use `org.springframework.security.authentication.jaas.DefaultJaasAuthenticationProvider` to
    set things up. We then set this authentication provider as the global provider.
    Any request will pass through this provider (`SpringSecurityConfig.java`):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`AuthenticationProvider`bean。我们将使用我们自定义的`LoginModule`，然后使用`org.springframework.security.authentication.jaas.DefaultJaasAuthenticationProvider`来设置一些内容。然后将此身份验证提供程序设置为全局提供程序。任何请求都将通过此提供程序（`SpringSecurityConfig.java`）：
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The next most important method is the `configure` method, in which we will
    make sure that we set the right path which need to be secured and we will also
    set up some important configurations:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个最重要的方法是`configure`方法，在其中我们将确保设置需要受保护的正确路径，并且我们还将设置一些重要的配置：
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Controllers
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器
- en: 'We just have one controller in which we will configure all the routes (`JaasController.java`):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只有一个控制器，我们将在其中配置所有路由（`JaasController.java`）：
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Setting up pages
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置页面
- en: 'We have a few trivial pages. I don''t want to paste the code in here, as it
    is quite self-explanatory:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些琐碎的页面。我不想在这里粘贴代码，因为它相当容易理解：
- en: '`login.jsp`: Our custom login page, which is used to collect username and password
    from the end user.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`login.jsp`：我们自定义的登录页面，用于从最终用户那里收集用户名和密码。'
- en: '`user.jsp`: The page that is set as root in the sample. After login, the user
    is navigated to this page. We just print the session ID and also the username
    to showcase the login.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user.jsp`：在示例中设置为根的页面。登录后，用户将被导航到此页面。我们只是打印会话ID和用户名，以展示登录。'
- en: '`moresecured.jsp`: This is just to showcase how the role of the user matters.
    This page can only be accessed by a user having the `ADMIN` role.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`moresecured.jsp`：这只是为了展示用户角色的重要性。只有具有`ADMIN`角色的用户才能访问此页面。'
- en: '`noaccess.jsp`: When the user doesn''t have access to any page, this dummy
    page comes in for the user.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`noaccess.jsp`：当用户无法访问任何页面时，这个虚拟页面就会出现。'
- en: A full sample project can be found in the book’s GitHub page within the *jetty-jaas-authentication *project.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在书的GitHub页面的*jetty-jaas-authentication*项目中找到完整的示例项目。
- en: Running the application
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'From the root of the project, execute the following command:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 从项目的根目录执行以下命令：
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Open a browser and navigate to `http://localhost:8080`. You will be provided
    with a dirty-looking login page. Enter username/password (admin/password or user/password)
    and you will be navigated to the root page (`user.jsp`).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器，导航到`http://localhost:8080`。您将看到一个看起来很简陋的登录页面。输入用户名/密码（admin/password或user/password），然后您将被导航到根页面（`user.jsp`）。
- en: This completes our JAAS example using Spring Security. As shown in Figure 8
    above, JAAS can be used to achieve authentication using other protocols. One of
    the well-known mechanism is authentication using Kerberos protocol. Next brief
    section gives you a rough idea of how JAAS can be used to achieve Kerberos based
    authentication.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们使用Spring Security的JAAS示例。如上图所示，JAAS可以用于使用其他协议进行身份验证。其中一个众所周知的机制是使用Kerberos协议进行身份验证。下一节简要介绍了JAAS如何用于实现基于Kerberos的身份验证的大致想法。
- en: Kerberos
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kerberos
- en: JAAS provides a number of built-in types of `LoginModule `and one of them is `rb5LoginModule`,
    which is used to authenticate users using the Kerberos protocol. So, indeed, JAAS
    methodology can be used to achieve Kerberos authentication within your Spring-based
    application with ease.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: JAAS提供了许多内置类型的`LoginModule`，其中之一是`rb5LoginModule`，用于使用Kerberos协议对用户进行身份验证。因此，确实可以使用JAAS方法来轻松实现基于Spring的应用程序中的Kerberos身份验证。
- en: Let's get into some more important details about authentication.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一些关于身份验证的重要细节。
- en: Custom AuthenticationEntryPoint
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义身份验证入口点
- en: A custom `AuthenticationEntryPoint` can be used to set necessary response headers,
    content-type, and so on before sending the response back to the client.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在将响应发送回客户端之前，可以使用自定义`AuthenticationEntryPoint`来设置必要的响应头、内容类型等。
- en: 'The `org.springframework.security.web.authentication.www.BasicAuthenticationEntryPoint` class is
    a built-in `AuthenticationEntryPoint` implementation, which will get invoked for
    basic authentication to commence. A custom entry point can be created by implementing
    the `org.springframework.security.web.AuthenticationEntryPoint` interface. The
    following is an example implementation:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`org.springframework.security.web.authentication.www.BasicAuthenticationEntryPoint`类是一个内置的`AuthenticationEntryPoint`实现，用于启动基本身份验证。可以通过实现`org.springframework.security.web.AuthenticationEntryPoint`接口来创建自定义入口点。以下是一个示例实现：'
- en: '[PRE37]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When a client accesses resources without authentication, this entry point kicks
    in and throws a 401 status code (`Unauthorized`).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端在没有身份验证的情况下访问资源时，此入口点会启动并抛出401状态码（`未经授权`）。
- en: 'In the Spring Security Java configuration file, make sure that the `configure`
    method has this custom `AuthenticationEntryPoint` defined, as shown in the following
    code snippet:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Security Java配置文件中，确保`configure`方法定义了这个自定义`AuthenticationEntryPoint`，如下面的代码片段所示：
- en: '[PRE38]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Multiple AuthenticationEntryPoint
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个AuthenticationEntryPoint
- en: Spring Security does allow you to configure multiple `AuthenticationEntryPoint` for
    your application, if needed.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security确实允许您为应用程序配置多个`AuthenticationEntryPoint`，如果需要的话。
- en: Since Spring Security 3.0.2, `org.springframework.security.web.authentication.DelegatingAuthenticationEntryPoint`
    looks at all declared `AuthenticationEntryPoint` in the configurations and executes
    them.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 自Spring Security 3.0.2以来，`org.springframework.security.web.authentication.DelegatingAuthenticationEntryPoint`查看配置中声明的所有`AuthenticationEntryPoint`并执行它们。
- en: Since Spring Security 5.x, we have `org.springframework.security.web.server.DelegatingServerAuthenticationEntryPoint`,
    which uses reactive data types and brings in asynchronous nature to its execution.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 自Spring Security 5.x以来，我们有`org.springframework.security.web.server.DelegatingServerAuthenticationEntryPoint`，它使用反应性数据类型，并为其执行带来了异步性质。
- en: 'The `defaultAuthenticationEntryPointFor()` method in the Spring Security configuration
    can also be employed to set up multiple entry points looking at different URL
    matching (see the following code snippet):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security配置中的`defaultAuthenticationEntryPointFor()`方法也可以用于设置查看不同URL匹配的多个入口点（请参见以下代码片段）：
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: PasswordEncoder
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PasswordEncoder
- en: 'Before Spring Security 5, the framework allowed only one `PasswordEncoder`
    throughout the application and also had weak password encoders such as MD5 and
    SHA. These encoders also didn''t have dynamic salt, rather it had more static
    salt which had to be supplied. With Spring Security 5, there have been huge changes
    in this area and with the new version, the password encoding concept employs delegation
    and allows multiple password encoding within the same application. The password
    which has been encoded has a identifier prefixed to indicate what algorithm has
    been used (see the following example):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Security 5之前，该框架只允许应用程序中有一个`PasswordEncoder`，并且还有弱密码编码器，如MD5和SHA。这些编码器也没有动态盐，而是更多的静态盐需要提供。通过Spring
    Security 5，在这个领域发生了巨大的变化，新版本中的密码编码概念采用了委托，并允许在同一应用程序中进行多次密码编码。已编码的密码有一个前缀标识符，指示使用了什么算法（请参见以下示例）：
- en: '[PRE40]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This approach enables multiple encoding as needed within the application to
    be employed. If no identifier is mentioned, this means it uses the default encoder,
    which is `StandardPasswordEncoder`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法允许根据需要在应用程序中使用多种编码。如果没有提到标识符，这意味着它使用默认编码器，即`StandardPasswordEncoder`。
- en: 'Once you decide on the password encoding, this can be used within the `AuthenticationManager`.
    One such example is the following code snippet:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您决定密码编码，这可以在`AuthenticationManager`中使用。一个示例是以下代码片段：
- en: '[PRE41]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Spring Security 5, as mentioned earlier, introduced a delegation approach by
    introducing `DelegationPasswordEncoder`. `DelegatingPasswordEncoder` has replaced `PasswordEncoder`
    and can be created by two approaches as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Spring Security 5通过引入`DelegationPasswordEncoder`引入了委托方法。`DelegatingPasswordEncoder`已取代`PasswordEncoder`，并可以通过以下两种方法创建：
- en: 'Approach 1:'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法1：
- en: '[PRE42]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Approach 2:'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法2：
- en: '[PRE43]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`DelegatingPasswordEncoder` allows passwords to be validated against old encoding
    approaches and upgrades the password over a period of time without any hassle.
    This approach can be used to automatically upgrade passwords (old encoding to
    new encoding) as and when the user authenticates.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`DelegatingPasswordEncoder`允许针对旧的编码方法验证密码，并在一段时间内升级密码，而无需任何麻烦。这种方法可以用于在用户进行身份验证时自动升级密码（从旧编码到新编码）。'
- en: Salt
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 盐
- en: 'To make brute force attacks harder, while encoding we also can supply a random
    string. This random string is called **salt**. Salt text is included in `PasswordEncoder` as
    shown in the following code snippet:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使暴力攻击更加困难，我们在编码时还可以提供一个随机字符串。这个随机字符串称为**盐**。盐文本包含在`PasswordEncoder`中，如下面的代码片段所示：
- en: '[PRE44]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Custom filters
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义过滤器
- en: 'As explained earlier, Spring Security works on servlet filters. There are number
    of built-in servlet filters that do almost all the necessary functionalities.
    If needed, Spring Security does provide a mechanism to write your own custom filter
    and can be plugged in at the right point in the filter chain execution. Create
    your own filter by extending `org.springframework.web.filter.GenericFilterBean`
    as shown in the following code snippet:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面所解释的，Spring Security是基于servlet过滤器工作的。有许多内置的servlet过滤器几乎可以完成所有必要的功能。如果需要，Spring
    Security确实提供了一种机制来编写自定义过滤器，并可以在过滤器链执行的正确位置插入。通过扩展`org.springframework.web.filter.GenericFilterBean`来创建自己的过滤器，如下面的代码片段所示：
- en: '[PRE45]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Once you create your own filter, plug it into the filter chain in the Spring
    Security configuration file as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您创建了自己的过滤器，请将其插入到Spring Security配置文件中的过滤器链中，如下所示：
- en: '[PRE46]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You can place the new filter before, after, or at a particular location in the
    filter chain. If you want to extend an existing filter, you have that provision
    as well.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将新的过滤器放置在过滤器链中的任何位置，之前、之后或特定位置。如果您想要扩展现有的过滤器，也可以这样做。
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered two more authentication mechanisms, namely
    CAS and JAAS, supported by Spring Security, through hands-on coding examples.
    Again, we have used the sample application build as part of [Chapter 2](e43a2e26-5b28-4d37-a7f8-d3c992a07bc2.xhtml), *Deep
    Diving into Spring Security*, as a base to explain the working and implementation
    of other authentication mechanisms. We then covered some important concepts and
    the customization possible in Spring Security.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过实际编码示例介绍了Spring Security支持的CAS和JAAS两种认证机制。同样，我们使用了作为[第2章](e43a2e26-5b28-4d37-a7f8-d3c992a07bc2.xhtml)的一部分构建的示例应用程序作为基础，以解释其他认证机制的工作和实现。然后，我们介绍了Spring
    Security中的一些重要概念和可定制性。
- en: In this chapter, we intentionally didn't use reactive programming in our coding
    examples. This chapter was aimed at making you understand the core concepts of
    each CAS and JAAS authentication mechanism by making use of the familiar Spring
    Web MVC application framework. We will cover reactive programming in more detail
    in [Chapter 5](df488f9c-24a7-4d0f-ac82-1d126a391fcc.xhtml), *Integrating with
    Spring WebFlux*. We will start the next chapter by introducing you to Spring WebFlux
    and, in due course, implement Spring Security. While going through the main contents
    of [Chapter 5](https://cdp.packtpub.com/hands_on_spring_security_5_for_reactive_applications/wp-admin/post.php?post=168&action=edit#post_29), *Integrating
    with Spring WebFlux*, you will clearly understand that making the code examples
    in this chapter comply to reactive is quite easy.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们故意没有在编码示例中使用响应式编程。本章的目的是让您通过使用熟悉的Spring Web MVC应用程序框架来理解每个CAS和JAAS认证机制的核心概念。我们将在[第5章](df488f9c-24a7-4d0f-ac82-1d126a391fcc.xhtml)中更详细地介绍响应式编程，即*与Spring
    WebFlux集成*。我们将在下一章中介绍Spring WebFlux，并在适当的时候实现Spring Security。在阅读[第5章](https://cdp.packtpub.com/hands_on_spring_security_5_for_reactive_applications/wp-admin/post.php?post=168&action=edit#post_29)的主要内容时，您将清楚地了解，使本章中的代码示例符合响应式是非常容易的。
