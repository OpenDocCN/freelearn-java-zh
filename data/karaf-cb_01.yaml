- en: Chapter 1. Apache Karaf for System Builders
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。Apache Karaf系统构建者指南
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Configuring production-ready logging in Apache Karaf
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Apache Karaf中配置生产就绪的日志记录
- en: Creating our own custom Karaf command using a Maven archetype
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Maven存档创建我们自己的自定义Karaf命令
- en: Branding the Apache Karaf console
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记Apache Karaf控制台
- en: Deploying applications as a feature
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序作为功能部署
- en: Using JMX to monitor and administer Apache Karaf
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JMX监控和管理Apache Karaf
- en: Reconfiguring SSH access to Apache Karaf
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新配置对Apache Karaf的SSH访问
- en: Installing Apache Karaf as a service
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Apache Karaf作为服务安装
- en: Setting up Apache Karaf for high availability
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Apache Karaf以实现高可用性
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Experienced users of Apache Karaf will tell you that out of the box, Karaf provides
    you with the features and tools you'll need to deploy your application. However,
    to build a production-ready environment, you'll want to tweak things.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有经验的Apache Karaf用户会告诉你，开箱即用，Karaf为你提供了部署应用程序所需的功能和工具。然而，为了构建一个生产就绪的环境，你可能需要调整一些设置。
- en: The recipes in this chapter are devoted to systems builders, the people who
    need to make their Apache Karaf instance production-ready and applications within
    it manageable.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的食谱是为系统构建者准备的，这些人需要使他们的Apache Karaf实例达到生产就绪状态，并使其中的应用程序易于管理。
- en: Tip
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**New to Apache Karaf and OSGi?**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**Apache Karaf和OSGi新手？**'
- en: Readers interested in obtaining a deeper understanding of Apache Karaf and its
    underlying technologies should consult Packt Publishing's *Instant OSGi Starter*,
    *Jamie Goodyear and Johan Edstrom*, and *Learning Apache Karaf*, *Jamie Goodyear,
    Johan Edstrom, and Heath Kesler*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对Apache Karaf及其底层技术有深入了解兴趣的读者应参考Packt Publishing出版的《Instant OSGi Starter》，作者为Jamie
    Goodyear和Johan Edstrom，以及《Learning Apache Karaf》，作者为Jamie Goodyear、Johan Edstrom和Heath
    Kesler。
- en: Configuring production-ready logging in Apache Karaf
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Apache Karaf中配置生产就绪的日志记录
- en: One of the first tasks administrators of Apache Karaf undertake is changing
    the default logging configuration to more production-ready settings.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Karaf管理员首先要做的第一项任务之一是更改默认的日志配置，以更符合生产就绪的设置。
- en: 'To improve the default logging configuration, we''ll perform the following
    tasks:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进默认的日志配置，我们将执行以下任务：
- en: Update the logfile location to be outside the data folder. This helps administrators
    avoid accidentally wiping out logfiles when deleting runtime data.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新日志文件位置，使其位于数据文件夹之外。这有助于管理员在删除运行时数据时避免意外删除日志文件。
- en: Increase the logfile size. The default size of 1 MB is too small for most production
    deployments. Generally, we set this to 50 or 100 MB, depending on the available
    disk space.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加日志文件大小。默认的1 MB大小对于大多数生产部署来说太小了。通常，我们会将其设置为50或100 MB，具体取决于可用的磁盘空间。
- en: Increase the number of logfiles we retain. There is no correct number of logfiles
    to retain. However, when disk space is cheap and available, keeping a large number
    of files is a preferred configuration.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加我们保留的日志文件数量。没有保留日志文件的正确数量。然而，当磁盘空间便宜且可用时，保留大量文件是一种首选的配置。
- en: How to do it…
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Configuring Karaf''s logging mechanism requires you to edit the `etc/org.ops4j.pax.logging.cfg`
    file. Open the file with your preferred editor and alter the following highlighted
    code entries:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 配置Karaf的日志机制需要你编辑`etc/org.ops4j.pax.logging.cfg`文件。使用你喜欢的编辑器打开文件，并更改以下突出显示的代码条目：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding configuration, we instruct Karaf to write logs to a log folder
    in the base installation directory, increase the logfile size to 10 MB, and increase
    the number of retained logfiles to 100.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配置中，我们指示Karaf将日志写入基础安装目录中的日志文件夹，将日志文件大小增加到10 MB，并将保留的日志文件数量增加到100。
- en: When finished editing the file, save the changes. They will take effect shortly.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 完成文件编辑后，保存更改。它们将很快生效。
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We can change the verbosity of logging by altering the `log4j.rootLogger` entry
    from `INFO` to `DEBUG`, `WARN`, `ERROR`, or `TRACE`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过更改`log4j.rootLogger`条目从`INFO`到`DEBUG`、`WARN`、`ERROR`或`TRACE`来改变日志记录的详细程度。
- en: How it works…
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The logging system for Karaf is based on **OPS4J Pax Logging** with the `log4j`
    library acting as its backend. The configuration file, `etc/org.ops4j.pax.logging.cfg`,
    is used to define appenders, log levels, and so on. Let''s take a look at the
    following default appender configuration and how we''ll tweak it to become more
    production-ready:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Karaf的日志系统基于**OPS4J Pax Logging**，其中`log4j`库作为其后端。配置文件`etc/org.ops4j.pax.logging.cfg`用于定义附加器、日志级别等。让我们看看以下默认附加器配置以及我们将如何调整它以使其更符合生产就绪：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the previous code, the `File appender` configuration sets up the default
    Karaf logging behavior. The initial configuration sets `RollingFileAppender` and
    constructs a log entry pattern. The remaining options dictate the location of
    the logfile, its size, and the number of logfiles to retain.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`File appender` 配置设置了默认的 Karaf 日志行为。初始配置设置了 `RollingFileAppender` 并构建了一个日志条目模式。其余选项指定了日志文件的位置、大小和保留的日志文件数量。
- en: 'Karaf monitors the configuration file in the `KARAF_HOME/etc` folder. When
    the updates to the configuration file are read, the logging service is updated
    with the new value(s). The mechanism that allows this behavior is provided by
    File Install (available at [http://felix.apache.org/site/apache-felix-file-install.html](http://felix.apache.org/site/apache-felix-file-install.html))
    and the OSGi Configuration Admin service. Have a look at the following figure:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Karaf 监控位于 `KARAF_HOME/etc` 文件夹中的配置文件。当读取配置文件的更新时，日志服务会更新为新值。允许此行为的机制由文件安装（可在
    [http://felix.apache.org/site/apache-felix-file-install.html](http://felix.apache.org/site/apache-felix-file-install.html)
    获取）和 OSGi 配置管理服务提供。请查看以下图示：
- en: '![How it works…](img/5081OS_01_02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/5081OS_01_02.jpg)'
- en: As illustrated in the preceding figure, when a file in the `KARAF_HOME/etc`
    directory is created, deleted, or modified, the file scanner will pick up on the
    event. Given a configuration file change (a change in the file format of the Java
    properties file), a configuration processor will process the entries and update
    the OSGi Configuration Admin service.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，当 `KARAF_HOME/etc` 目录中的文件被创建、删除或修改时，文件扫描器会检测到该事件。给定一个配置文件更改（Java 属性文件格式的更改），配置处理器将处理条目并更新
    OSGi 配置管理服务。
- en: Tip
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在 [http://www.packtpub.com](http://www.packtpub.com) 的账户中下载您购买的所有 Packt
    书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问 [http://www.packtpub.com/support](http://www.packtpub.com/support)
    并注册，以便将文件直接通过电子邮件发送给您。
- en: There's more…
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'To further improve logging, you can provide the `log4j` library with an external
    logging location, separating the I/O requirements of logging from the base system
    at the expense of increased network traffic. This architecture is shown in the
    following figure:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要进一步提高日志记录，您可以向 `log4j` 库提供一个外部日志位置，以牺牲增加的网络流量为代价，将日志记录的 I/O 需求与基本系统分离。以下图示显示了此架构：
- en: '![There''s more…](img/5081OS_01_01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多…](img/5081OS_01_01.jpg)'
- en: To achieve this logging architecture, you'll need to mount the external volume
    on the server on which Karaf is running.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现此日志架构，您需要在 Karaf 运行的服务器上挂载外部卷。
- en: See also
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关链接
- en: The *Creating our own custom Karaf command using a Maven archetype* recipe.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Maven 架构创建我们自己的自定义 Karaf 命令* 的配方。'
- en: Creating our own custom Karaf command using a Maven archetype
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Maven 架构创建我们自己的自定义 Karaf 命令
- en: The Karaf console provides a multitude of useful commands to interact with the
    OSGi runtime and manage deployed applications. As a systems builder, you may want
    to develop custom commands that integrate directly into Karaf so that you can
    automate tasks or interact directly with your applications.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Karaf 控制台提供了许多有用的命令，用于与 OSGi 运行时交互和管理已部署的应用程序。作为系统构建者，您可能希望开发直接集成到 Karaf 中的自定义命令，以便您可以自动化任务或直接与应用程序交互。
- en: 'Custom Karaf commands will appear in your container as a fully integrated component
    of the console, as shown in the following screenshot:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义 Karaf 命令将作为控制台的一个完全集成的组件出现在您的容器中，如下截图所示：
- en: '![Creating our own custom Karaf command using a Maven archetype](img/5081OS_01_03.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Maven 架构创建我们自己的自定义 Karaf 命令](img/5081OS_01_03.jpg)'
- en: The previous screenshot illustrates our sample cookbook command accepting an
    option flag and an argument. Let's dive into building your own command.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图说明了我们的示例食谱命令接受一个选项标志和一个参数。让我们深入了解构建您自己的命令。
- en: Getting ready
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The ingredients of this recipe include the Apache Karaf distribution kit, access
    to JDK, Maven, and a source code editor. The sample code for this recipe is available
    at [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter1/chapter1-recipe2](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter1/chapter1-recipe2).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱的成分包括 Apache Karaf 分发套件、对 JDK、Maven 和源代码编辑器的访问。此食谱的示例代码可在 [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter1/chapter1-recipe2](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter1/chapter1-recipe2)
    找到。
- en: How to do it…
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The first step is generating a template command project. To encourage building
    custom commands, the community has provided the following Maven archetype invocation
    to generate Karaf command projects:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是生成模板命令项目。为了鼓励构建自定义命令，社区提供了以下 Maven 架构调用以生成 Karaf 命令项目：
- en: '[PRE2]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding archetype invocation, we supply the Maven project group and
    artifact names. The process will request you to supply a command name. Maven then
    generates a project template for your command.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在先前的架构调用中，我们提供了 Maven 项目组和工件名称。该过程将要求您提供命令名称。Maven 然后为您生成命令的项目模板。
- en: The next step is implementing your custom code. The custom command template
    project will supply you with a Maven POM file, Blueprint wiring (in the `src/main/resources/OSGI-INF/blueprint`
    directory), and custom command stub implementation (in the `src/main/java/` directory).
    Edit these files as required to add your custom actions.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是实施您自定义的代码。自定义命令模板项目将为您提供 Maven POM 文件、Blueprint 连接（在 `src/main/resources/OSGI-INF/blueprint`
    目录中），以及自定义命令存根实现（在 `src/main/java/` 目录中）。根据需要编辑这些文件以添加您的自定义操作。
- en: 'The last step is building and deploying the custom command in Karaf. We build
    our command via the Maven invocation `mvn install`. Deploying it in Karaf only
    requires issuing a well-formed install command; to do this, invoke `install –s
    mvn:groupId/artifactId` in the Karaf console. Consider the following invocation:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是在 Karaf 中构建和部署自定义命令。我们通过 Maven 调用 `mvn install` 来构建我们的命令。在 Karaf 中部署它只需要发出一个格式良好的安装命令；为此，在
    Karaf 控制台中调用 `install –s mvn:groupId/artifactId`。考虑以下调用：
- en: '[PRE3]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding invocation has the `groupId` value as `com.packt.chapter1` and
    the `artifactId` value as `command`.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 先前的调用中，`groupId` 值为 `com.packt.chapter1`，`artifactId` 值为 `command`。
- en: How it works…
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The Maven archetype generates the POM build file, Java code, and Blueprint file
    for your custom command. Let's take a look at these key components.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 架构生成您的自定义命令的 POM 构建文件、Java 代码和 Blueprint 文件。让我们看看这些关键组件。
- en: The generated POM file contains all of the essential dependencies a Karaf command
    requires and sets up a basic Maven Bundle Plugin configuration. Edit this file
    to bring in additional libraries your command requires. Make sure that you update
    your bundle's build parameters accordingly. When this project is built, a bundle
    will be produced that can be installed directly into Karaf.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 POM 文件包含 Karaf 命令所需的全部基本依赖项，并设置了一个基本的 Maven Bundle 插件配置。编辑此文件以引入您的命令所需的额外库。确保相应地更新您的包的构建参数。当此项目构建时，将生成一个可以直接安装到
    Karaf 中的包。
- en: Our custom command logic resides in the generated Java source file, which will
    be named after the command name you supplied. The generated command extends Karaf's
    `OSGICommandSupport` class, which provides us with access to the underlying command
    session and OSGi environment. A `Command` annotation adorns our code. This provides
    the runtime with the scope, name, and description. Karaf provides the `Argument`
    and `Option` annotations to simplify adding a command-line argument and option
    processing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自定义命令逻辑位于生成的 Java 源代码文件中，该文件将根据您提供的命令名称命名。生成的命令扩展了 Karaf 的 `OSGICommandSupport`
    类，这为我们提供了访问底层命令会话和 OSGi 环境的权限。`Command` 注解装饰了我们的代码。这为运行时提供了范围、名称和描述。Karaf 提供了
    `Argument` 和 `Option` 注解来简化添加命令行参数和选项处理。
- en: The Blueprint container wires together our command implementation to the commands
    available in Karaf's console.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Blueprint 容器将我们的命令实现连接到 Karaf 控台中的可用命令。
- en: Tip
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For more information on extending Karaf's console, see [http://karaf.apache.org/manual/latest/developers-guide/extending.html](http://karaf.apache.org/manual/latest/developers-guide/extending.html).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有关扩展 Karaf 控台的信息，请参阅 [http://karaf.apache.org/manual/latest/developers-guide/extending.html](http://karaf.apache.org/manual/latest/developers-guide/extending.html)。
- en: There's more…
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Thanks to Apache Karaf's SSHD service and remote client, your custom commands
    can be leveraged to provide external command and control of your applications.
    Just pass your command and its parameters to the remote client and monitor the
    returned results.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢Apache Karaf的SSHD服务和远程客户端，您可以使用自定义命令来提供对应用程序的外部命令和控制。只需将您的命令及其参数传递给远程客户端，并监控返回的结果。
- en: See also
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Branding the Apache Karaf console* recipe
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*品牌化Apache Karaf控制台*配方'
- en: Branding the Apache Karaf console
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 品牌化Apache Karaf控制台
- en: Apache Karaf is used as the runtime environment for production application platforms.
    In such deployments, it is common to have Karaf sporting a custom branding.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Karaf被用作生产应用程序平台的运行环境。在这样的部署中，Karaf通常会有自定义的品牌标识。
- en: The Karaf community has made rebranding the runtime a simple task. Let's make
    our own for this book.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Karaf社区已经将运行时的重命名简化为一项简单任务。让我们为这本书创建自己的版本。
- en: Getting ready
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The ingredients of this recipe include the Apache Karaf distribution kit, access
    to JDK, Maven, and a source code editor. The sample code for this recipe is available
    at [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter1/chapter1-recipe3](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter1/chapter1-recipe3).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的原料包括Apache Karaf发行套件、对JDK、Maven和源代码编辑器的访问。这个配方的示例代码可在[https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter1/chapter1-recipe3](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter1/chapter1-recipe3)找到。
- en: How to do it…
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: The first step is generating a Maven-based project structure. For this recipe,
    we need to only create the bare of Maven POM files, set its packaging to `bundle`,
    and include a `build` section.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是生成基于Maven的项目结构。对于这个配方，我们只需要创建Maven POM文件的基础版本，将其打包设置为`bundle`，并包含一个`build`部分。
- en: 'The next step is adding a resource directive to our POM file''s build section.
    In our POM file, we add a resource directive to our build section, as shown in
    the following code:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是在我们的POM文件的构建部分添加一个资源指令。在我们的POM文件中，我们添加了一个资源指令到我们的构建部分，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We add a resource directive to our build section to instruct Maven to process
    the contents of our `resources` folder, filter any wildcards, and include the
    result in the generated bundle.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在我们的构建部分添加一个资源指令，以指示Maven处理我们的`resources`文件夹的内容，过滤任何通配符，并将结果包含在生成的包中。
- en: 'Next, we configure the Maven Bundle Plugin as shown in the following code:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们按照以下代码配置Maven Bundle插件：
- en: '[PRE5]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We configured the Maven Bundle Plugin to export `Bundle-SymbolicName` as the
    `artifactId` and set the `Export-Package` option to `org.apache.karaf.branding`.
    The symbolic name as the project's `artifactId` variable is a common convention
    among Karaf bundle developers. We export the Karaf branding package so that the
    Karaf runtime will identify the bundle as containing the custom branding.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们配置了Maven Bundle插件，将`Bundle-SymbolicName`导出为`artifactId`，并将`Export-Package`选项设置为`org.apache.karaf.branding`。将符号名称作为项目的`artifactId`变量是Karaf插件开发者中的一个常见约定。我们导出Karaf品牌包，以便Karaf运行时能够识别包含自定义品牌的包。
- en: 'The next step is creating our custom branding resource file. Returning to our
    project, we''ll create a `branding.properties` file in the `src/main/resource/org/apache/karaf/branding`
    directory. This `.properties` file will contain ASCII and Jansi text characters,
    organized to produce your custom look. Using Maven resource filtering, you can
    use variable substitutions in the `${variable}` format, as shown in the following
    code:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建我们的自定义品牌资源文件。回到我们的项目，我们将在`src/main/resource/org/apache/karaf/branding`目录中创建一个`branding.properties`文件。这个`.properties`文件将包含ASCII和Jansi文本字符，组织成你的自定义外观。使用Maven资源过滤，你可以使用`${variable}`格式的变量替换，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding code, we use a combination of ASCII characters and Jansi text
    markup in the `branding.properties` file to produce simple text effects in Karaf,
    as shown in the following screenshot:'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在`branding.properties`文件中使用ASCII字符和Jansi文本标记的组合来在Karaf中产生简单的文本效果，如下面的截图所示：
- en: '![How to do it…](img/5081OS_01_04.jpg)'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/5081OS_01_04.jpg)'
- en: The final step is building and deploying our custom branding. We build our branding
    via the Maven invocation `mvn install`. After we build our branding bundle, we
    place a copy inside Karaf's `KARAF_HOME/lib` folder and then start the container.
    Upon the first boot, you will see our custom branding displayed.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是构建和部署我们的自定义品牌。我们通过Maven调用`mvn install`来构建我们的品牌。在构建我们的品牌包之后，我们将一个副本放在Karaf的`KARAF_HOME/lib`文件夹中，然后启动容器。在第一次启动时，你会看到我们的自定义品牌被显示出来。
- en: How it works…
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: At the first boot, Apache Karaf will check for any bundle in its `lib` folder
    and will export the `org.apache.karaf.branding` package. Upon detection of this
    resource, it will access the `branding.properties` file content and display it
    as part of the runtime startup routine.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次启动时，Apache Karaf 将检查其 `lib` 文件夹中的任何包，并将导出 `org.apache.karaf.branding` 包。在检测到该资源后，它将访问
    `branding.properties` 文件的内容，并将其作为运行时启动程序的一部分显示。
- en: There's more…
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The Apache Karaf community maintains a web console that may also be branded
    to reflect your organization's branding. See [https://karaf.apache.org/index/subprojects/webconsole.html](https://karaf.apache.org/index/subprojects/webconsole.html)
    for more details.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Karaf 社区维护一个可能也带有品牌标志的 Web 控制台。有关更多详细信息，请参阅 [https://karaf.apache.org/index/subprojects/webconsole.html](https://karaf.apache.org/index/subprojects/webconsole.html)。
- en: Deploying applications as a feature
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将应用程序作为功能部署
- en: 'Managing the assembly and deployment of repository locations, bundles, configuration,
    and other artifacts quickly becomes a major headache for system builders. To combat
    this, the Karaf community has developed the concept of *features*. The following
    figure describes the concept of features:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 管理仓库位置、包、配置和其他工件的总装和部署很快就会成为系统构建者的一个主要头痛问题。为了解决这个问题，Karaf 社区开发了 *功能* 的概念。以下图描述了功能的概念：
- en: '![Deploying applications as a feature](img/5081OS_01_05.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![将应用程序作为功能部署](img/5081OS_01_05.jpg)'
- en: A feature descriptor is an XML-based file that describes a collection of artifacts
    to be installed together into the Karaf container. In this recipe, we'll learn
    how to make a feature, add it to Karaf, and then use it to install bundles.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 功能描述符是一个基于 XML 的文件，它描述了一组要一起安装到 Karaf 容器中的工件。在这个配方中，我们将学习如何创建一个功能，将其添加到 Karaf
    中，然后使用它来安装包。
- en: Getting ready
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The ingredients of this recipe include the Apache Karaf distribution kit, access
    to JDK, Maven, and a source code editor. The sample code for this recipe is available
    at [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter1/chapter1-recipe4](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter1/chapter1-recipe4).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的原料包括 Apache Karaf 分发套件、JDK 访问权限、Maven 和一个源代码编辑器。这个配方的示例代码可在 [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter1/chapter1-recipe4](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter1/chapter1-recipe4)
    找到。
- en: How to do it…
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The first step is generating a Maven-based project. For this recipe, we need
    to create a Maven POM file, set its packaging to `bundle`, and include a `build`
    section.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是生成一个基于 Maven 的项目。对于这个配方，我们需要创建一个 Maven POM 文件，将其打包设置为 `bundle`，并包含一个 `build`
    部分。
- en: 'The next step is editing the POM file''s `build` directives. We add a `resources`
    directive to our POM file''s `build` section and `maven-resources-plugin` and
    `build-helper-maven-plugin` to its plugin list. Consider the following code:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是编辑 POM 文件的 `build` 指令。我们在 POM 文件的 `build` 部分添加一个 `resources` 指令，并将其插件列表中的
    `maven-resources-plugin` 和 `build-helper-maven-plugin` 包括在内。考虑以下代码：
- en: '[PRE7]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding code, the `resources` directive indicates the location of
    the features file we''ll create for processing. Now, consider the following code:'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，`resources` 指令表示我们将创建用于处理的特征文件的存储位置。现在，考虑以下代码：
- en: '[PRE8]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding code, `maven-resources-plugin` is configured to process our
    resources. Now, consider the following code:'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，`maven-resources-plugin` 被配置为处理我们的资源。现在，考虑以下代码：
- en: '[PRE9]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Finally, `build-helper-maven-plugin` completes the build of our `features.xml`
    file as described in the preceding code.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，`build-helper-maven-plugin` 完成前面代码中描述的 `features.xml` 文件的构建。
- en: 'The third step is creating a `features.xml` resource. In the `src/main/resources`
    folder, add a file named `features.xml` with the details of your bundles, as shown
    in the following code:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三步是创建一个 `features.xml` 资源。在 `src/main/resources` 文件夹中，添加一个名为 `features.xml`
    的文件，其中包含您包的详细信息，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We provide each feature with a name that Karaf will use as a reference to install
    each element specified in the named feature''s configuration. Features may reference
    other features, thus providing fine-grained control over installation. In the
    preceding features file, we can see three named features: `moduleA`, `moduleB`,
    and `recipe4-all-modules`. The `recipe4-all-modules` feature includes the content
    of the other two features.'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们为每个功能提供了一个名称，Karaf 将使用该名称作为参考来安装配置中指定的每个元素。功能可以引用其他功能，从而提供对安装的精细控制。在前面的功能文件中，我们可以看到三个命名的功能：`moduleA`、`moduleB`
    和 `recipe4-all-modules`。`recipe4-all-modules` 功能包括其他两个功能的全部内容。
- en: Tip
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you need to include a JAR file that is not offered as a bundle, try using
    the `wrap` protocol to automatically provide the file with the OSGi manifest headers.
    For more information, see [https://ops4j1.jira.com/wiki/display/paxurl/Wrap+Protocol](https://ops4j1.jira.com/wiki/display/paxurl/Wrap+Protocol).
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您需要包含一个不作为捆绑包提供的JAR文件，请尝试使用`wrap`协议来自动提供带有OSGi清单头部的文件。更多信息，请参阅[https://ops4j1.jira.com/wiki/display/paxurl/Wrap+Protocol](https://ops4j1.jira.com/wiki/display/paxurl/Wrap+Protocol)。
- en: The final step is building and deploying our feature. Using our sample recipe
    project, we will build our feature by executing `mvn install`. This performs all
    of the feature file variable substitutions and installs a processed copy in your
    local `m2` repository.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是构建和部署我们的功能。使用我们的示例配方项目，我们将通过执行`mvn install`来构建我们的功能。这执行了所有功能文件变量替换，并在您的本地`m2`仓库中安装处理后的副本。
- en: 'To make our feature available to Karaf, we''ll add the feature file''s Maven
    coordinates as follows:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要使我们的功能对Karaf可用，我们将添加功能文件的Maven坐标，如下所示：
- en: '[PRE11]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we can use Karaf''s `feature` commands to install `moduleA` and `moduleB`,
    as shown in the following command-line snippet:'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们可以使用Karaf的`feature`命令安装`moduleA`和`moduleB`，如下面的命令行片段所示：
- en: '[PRE12]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Using `feature:install` in this fashion helps to promote repeatable deployments
    and avoid missing component installations that are not caught by the OSGi environment
    (if no bundle dependencies are missing, then as far as the container is concerned,
    all is well). We can verify whether our feature is installed by invoking the following
    command:'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用这种方式在`feature:install`中可以帮助促进可重复部署并避免OSGi环境（如果没有缺少捆绑包依赖项）未捕获的组件安装（如果一切顺利，从容器角度来看）。我们可以通过调用以下命令来验证我们的功能是否已安装：
- en: '[PRE13]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can then observe whether our feature is listed or not.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以观察我们的功能是否被列出。
- en: How it works…
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'When Karaf processes a feature descriptor as a bundle, hot deployment, or via
    a system start-up property, the same processing and assembly functions occur,
    as shown in the following figure:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当Karaf将功能描述符作为捆绑包、热部署或通过系统启动属性处理时，将发生相同的处理和组装功能，如下面的图所示：
- en: '![How it works…](img/5081OS_01_06.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/5081OS_01_06.jpg)'
- en: The feature descriptor invocation is transformed into a list of artifacts to
    be installed in the OSGi container. At the lowest level, individual elements in
    a feature have a handler to obtain the described artifact (such as a bundle, JAR
    file, or configuration file). Our sample feature uses Maven coordinates to obtain
    bundles, and the Maven handler will be called to process these resources. If an
    HTTP URL was specified, then the HTTP handler is called. Each artifact in the
    specified feature will be installed until the entire list is processed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 功能描述符调用被转换为一个要在OSGi容器中安装的工件列表。在最低级别，功能中的单个元素有一个处理程序来获取描述的工件（如捆绑包、JAR文件或配置文件）。我们的示例功能使用Maven坐标来获取捆绑包，并将调用Maven处理程序来处理这些资源。如果指定了HTTP
    URL，则调用HTTP处理程序。指定功能中的每个工件都将被安装，直到整个列表被处理。
- en: There's more…
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: The *How to do it…* section of this recipe outlines a general methodology to
    produce a feature file for your projects and automate the filtering of resource
    versions. From Apache Karaf's point of view, it just processes a well-formatted
    features file so that you can handwrite the file and deploy it directly into Karaf.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方中的*如何做…*部分概述了一种通用方法，用于为您的项目生成功能文件并自动化资源版本的过滤。从Apache Karaf的角度来看，它只是处理一个格式良好的功能文件，以便您可以手动编写文件并将其直接部署到Karaf。
- en: Feature files have additional attributes that can be used to set bundle start
    levels, flag bundles as being dependencies, and set configuration properties.
    For more information, visit [http://karaf.apache.org/manual/latest/users-guide/provisioning.html](http://karaf.apache.org/manual/latest/users-guide/provisioning.html).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 功能文件有额外的属性，可以用来设置捆绑包启动级别，将捆绑包标记为依赖项，并设置配置属性。更多信息，请访问[http://karaf.apache.org/manual/latest/users-guide/provisioning.html](http://karaf.apache.org/manual/latest/users-guide/provisioning.html)。
- en: An advanced use case of Karaf feature files is to build a **KAraf aRchive**
    (**KAR**). A KAR file is the processed form of a feature file, collecting all
    the required artifacts into a single deployable form. This archive is ideal for
    deployment when your Karaf instance will not have access to remote repositories,
    as all required resources are packaged in the KAR file.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Karaf 功能文件的先进用法之一是构建一个 **KAraf aRchive** （**KAR**）。KAR 文件是功能文件的加工形式，将所有必需的工件收集到一个可部署的单一形式中。当您的
    Karaf 实例无法访问远程仓库时，此存档非常适合部署，因为所有必需的资源都打包在 KAR 文件中。
- en: See also
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: We'll be using the features concept of Apache Karaf in several chapters of this
    book to simplify the installation of Apache Camel, ActiveMQ, and CXF among other
    projects.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在本书的几个章节中使用 Apache Karaf 的功能概念来简化 Apache Camel、ActiveMQ 和 CXF 等其他项目的安装。
- en: Using JMX to monitor and administer Apache Karaf
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JMX 监控和管理 Apache Karaf
- en: By default, Apache Karaf can be administered via Java Management Extensions
    (JMX). However, systems builders often need to tweak the default configurations
    to get their deployment integrated into their network. In this recipe, we'll show
    you how to make these changes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Apache Karaf 可以通过 Java 管理扩展 (JMX) 进行管理。然而，系统构建者通常需要调整默认配置，以便将他们的部署集成到网络中。在这个菜谱中，我们将向您展示如何进行这些更改。
- en: Getting ready
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The ingredients of this recipe include the Apache Karaf distribution kit, access
    to JDK, and a source code editor. The sample configuration for this recipe is
    available at [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter1/chapter1-recipe5](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter1/chapter1-recipe5).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱的配料包括 Apache Karaf 分发套件、对 JDK 的访问和源代码编辑器。此菜谱的示例配置可在 [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter1/chapter1-recipe5](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter1/chapter1-recipe5)
    找到。
- en: Tip
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Administrators should take care when exposing JMX access to their Karaf instance.
    Enabling of SSL and use of strong passwords is recommended.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员在向他们的 Karaf 实例公开 JMX 访问时应该小心谨慎。建议启用 SSL 和使用强密码。
- en: How to do it…
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The first step is editing the management configuration. Apache Karaf ships
    with a default management configuration. To make our modifications, we update
    the `etc/org.apache.karaf.management.cfg` file. Consider the following code:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是编辑管理配置。Apache Karaf 随带默认的管理配置。为了进行我们的修改，我们更新 `etc/org.apache.karaf.management.cfg`
    文件。考虑以下代码：
- en: '[PRE14]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The default ports, 1099 and 44444, are usually fine for general deployment.
    Change these ports only if you are experiencing port conflicts on your deployment.
    Now, consider the following snippet:'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认端口，1099 和 44444，通常适用于一般部署。只有在您的部署中遇到端口冲突时才更改这些端口。现在，考虑以下片段：
- en: '[PRE15]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Towards the bottom of the configuration file, there will be a commented-out
    entry for `jmxRole`; enable this by removing the hash character.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在配置文件的底部附近，将有一个注释掉的 `jmxRole` 条目；通过删除井号字符来启用它。
- en: 'The next step is updating the user''s file. We must now update the `etc/users.properties`
    file with the following code:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是更新用户文件。我们现在必须使用以下代码更新 `etc/users.properties` 文件：
- en: '[PRE16]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `users.properties` file is used to configure users, groups, and roles in
    Karaf. We append `jmxRole` to the admin group. The syntax for this file follows
    the `Username = password, groups` format.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`users.properties` 文件用于在 Karaf 中配置用户、组和角色。我们将 `jmxRole` 添加到管理员组中。此文件的语法遵循 `Username
    = password, groups` 格式。'
- en: The last step is testing our configuration. After making the previous configuration
    changes, we'll need to restart our Karaf instance. Now, we can test our JMX setup.
    Have a look at the following screenshot:![How to do it…](img/5081OS_01_07.jpg)
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是测试我们的配置。在做出之前的配置更改后，我们需要重新启动我们的 Karaf 实例。现在，我们可以测试我们的 JMX 设置。请看以下截图：![如何操作…](img/5081OS_01_07.jpg)
- en: After restarting Karaf, use a JMX-based admin tool of your choice (the previous
    screenshot shows JConsole) to connect to the container. Due to image size restrictions,
    the full URL couldn't be displayed. The full URL is `service:jmx:rmi://127.0.0.1:44445/jndi/rmi://127.0.0.1:11099/karaf-root`.
    The syntax of the URL is `service:jmx:rmi://host:${rmiServerPort}/jndi/rmi://host:${rmiRegistryPort}/${karaf-instance-name}`.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在重新启动 Karaf 后，使用您选择的基于 JMX 的管理工具（前面的截图显示了 JConsole）连接到容器。由于图像大小限制，完整的 URL 无法显示。完整的
    URL 是 `service:jmx:rmi://127.0.0.1:44445/jndi/rmi://127.0.0.1:11099/karaf-root`。URL
    的语法是 `service:jmx:rmi://host:${rmiServerPort}/jndi/rmi://host:${rmiRegistryPort}/${karaf-instance-name}`。
- en: Reconfiguring SSH access to Apache Karaf
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新配置 Apache Karaf 的 SSH 访问
- en: Using Apache Karaf via its local console provides the user with superb command
    and control capabilities over their OSGi container. Apache Karaf's remote console
    extends this experience to remote consoles, and as such, presents systems builders
    with an opportunity to further harden their systems. In this recipe, we'll change
    Karaf's default remote connection parameters.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过其本地控制台使用 Apache Karaf 为用户提供了对他们的 OSGi 容器的卓越命令和控制能力。Apache Karaf 的远程控制台扩展了这一体验，并将远程控制台呈现给系统构建者，从而为他们提供了进一步加固系统的机会。在本配方中，我们将更改
    Karaf 的默认远程连接参数。
- en: Getting ready
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The ingredients of this recipe include the Apache Karaf distribution kit, access
    to JDK, and a source code editor. The sample configuration for this recipe is
    available at [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter1/chapter1-recipe6](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter1/chapter1-recipe6).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的配料包括 Apache Karaf 分发套件、JDK 访问权限和源代码编辑器。本配方的示例配置可在 [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter1/chapter1-recipe6](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter1/chapter1-recipe6)
    找到。
- en: How to do it…
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The first step is editing the shell configuration. Apache Karaf ships with
    a default shell configuration file. It''s a good practice to edit entries in the
    `etc/org.apache.karaf.shell.cfg` file to point to the non-default ports as a security
    precaution. Consider the following code:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是编辑 shell 配置。Apache Karaf 随附一个默认的 shell 配置文件。将 `etc/org.apache.karaf.shell.cfg`
    文件中的条目编辑为指向非默认端口是一种安全预防措施。请考虑以下代码：
- en: '[PRE17]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding sample configuration, we defined the port for SSH access to
    `8102` and set `sshHost` to an IP address of the host machine (the default value,
    0.0.0.0, means the SSHD service is bound to all network interfaces). Restricting
    access to particular network interfaces can help reduce unwanted access.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的示例配置中，我们定义了 SSH 访问的端口为 `8102`，并将 `sshHost` 设置为主机机的 IP 地址（默认值 0.0.0.0 表示
    SSHD 服务绑定到所有网络接口）。限制对特定网络接口的访问可以帮助减少未授权的访问。
- en: 'The next step is restarting Karaf. After editing the configuration, we must
    restart Karaf. Once restarted, you''ll be able to connect to Karaf using an SSH
    client command as follows:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是重启 Karaf。在编辑配置后，我们必须重启 Karaf。重启后，您可以使用以下 SSH 客户端命令连接到 Karaf：
- en: '[PRE18]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Upon connection, you'll be prompted for your password.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 连接后，您将被提示输入密码。
- en: There's more…
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Changing the default remote access configuration is a good start. However, system
    builders should also consider changing the default `karafuser/password` combination
    found in the `users.properties` file.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 修改默认的远程访问配置是一个好的开始。然而，系统构建者还应考虑更改 `users.properties` 文件中找到的默认 `karafuser/password`
    组合。
- en: You might also decide to generate a server SSH key file to simplify remote access.
    Information regarding this configuration can be found at [http://karaf.apache.org/manual/latest/users-guide/remote.html](http://karaf.apache.org/manual/latest/users-guide/remote.html).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可能决定生成一个服务器 SSH 密钥文件以简化远程访问。有关此配置的信息可在 [http://karaf.apache.org/manual/latest/users-guide/remote.html](http://karaf.apache.org/manual/latest/users-guide/remote.html)
    找到。
- en: Installing Apache Karaf as a service
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Apache Karaf 作为服务安装
- en: When we install Apache Karaf, we'll want it to operate as a system service on
    our host platform (just like Windows or Linux). In this recipe, we'll set up Karaf
    to start when your system boots up.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们安装 Apache Karaf 时，我们希望它在我们的主机平台上作为系统服务运行（就像 Windows 或 Linux 一样）。在本配方中，我们将设置
    Karaf 在系统启动时启动。
- en: Getting ready
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The ingredients of this recipe include the Apache Karaf distribution kit, access
    to JDK, and a source code editor. The sample wrapper configuration for this recipe
    is available at [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter1/chapter1-recipe7](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter1/chapter1-recipe7).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的配料包括 Apache Karaf 分发套件、JDK 访问权限和源代码编辑器。本配方的示例包装配置可在 [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter1/chapter1-recipe7](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter1/chapter1-recipe7)
    找到。
- en: How to do it…
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The first step is installing the service wrapper feature. Apache Karaf utilizes
    a service wrapper feature to handle gathering and deploying of the required resources
    for your host operating environment. We begin its installation by invoking the
    following command:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是安装服务包装功能。Apache Karaf 利用服务包装功能来处理收集和部署主机操作环境所需资源。我们通过调用以下命令开始其安装：
- en: '[PRE19]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The service wrapper feature URL is included in Karaf by default; so, no additional
    step is required to make it available.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 服务包装功能URL默认包含在Karaf中；因此，不需要额外的步骤来使其可用。
- en: 'The next step is installing the wrapper service. Now, we must instruct the
    wrapper to configure and install the appropriate service scripts and resources
    for us. Consider the following command:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是安装包装服务。现在，我们必须指示包装服务为我们配置和安装适当的服务脚本和资源。考虑以下命令：
- en: '[PRE20]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding `wrapper:install` command invocation includes three flags: `-s`
    for the start type, `-n` for the service name, and `–D` for the service description.
    The start type can be one of two options: `AUTO_START`, to automatically start
    the service on boot, and `DEMAND_START`, to start only when manually invoked.
    The service name is used as an identifier in the host''s service registry. The
    description provides system administrators with a brief description of your Karaf
    installation. After executing the `install` command, the Karaf console will display
    the libraries, scripts, and configuration files that the wrapper generates. You''ll
    now need to exit Karaf to continue the service installation.'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的`wrapper:install`命令调用包括三个标志：`-s`用于启动类型，`-n`用于服务名称，`–D`用于服务描述。启动类型可以是两个选项之一：`AUTO_START`，在启动时自动启动服务，和`DEMAND_START`，仅在手动调用时启动。服务名称用作主机服务注册表中的标识符。描述为系统管理员提供了对您的Karaf安装的简要描述。执行`install`命令后，Karaf控制台将显示包装服务生成的库、脚本和配置文件。您现在需要退出Karaf以继续服务安装。
- en: The final step is integrating it in to the host operating system. This step
    will require administrator level permissions to execute the generated Karaf service
    wrapper installation scripts.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是将它集成到主机操作系统中。这一步将需要管理员级别的权限来执行生成的Karaf服务包装安装脚本。
- en: 'The following command installs the service natively into Windows:'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下命令将服务原生于Windows中安装：
- en: '[PRE21]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following `net` commands allow an administrator to start or stop the Karaf
    service:'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下`net`命令允许管理员启动或停止Karaf服务：
- en: '[PRE22]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Linux integration will vary based on distribution. The following commands will
    work on Debian- or Ubuntu-based systems:'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Linux集成将根据发行版而有所不同。以下命令适用于基于Debian或Ubuntu的系统：
- en: '[PRE23]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first command creates a symbolic link from the service script in Karaf's
    `bin` folder to the `init.d` directory and then updates the startup scripts to
    include the Karaf service to automatically start during boot. The remaining two
    commands can be used to manually start or stop the Karaf service.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个命令从Karaf的`bin`文件夹中的服务脚本创建到`init.d`目录的符号链接，然后更新启动脚本以包括Karaf服务，以便在启动时自动启动。其余两个命令可以用来手动启动或停止Karaf服务。
- en: How it works…
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The wrapper service feature integrates Karaf into the host operating system's
    service mechanism. This means that on a Windows- or Linux-based system, Karaf
    will avail of the available fault, crash, processing freeze, out of memory, or
    similar event detections and automatically attempt to restart Karaf.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 包装服务功能将Karaf集成到主机操作系统的服务机制中。这意味着在基于Windows或Linux的系统上，Karaf将利用可用的故障、崩溃、处理冻结、内存不足或类似事件检测，并自动尝试重新启动Karaf。
- en: See also
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Setting up Apache Karaf for high availability* recipe
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置Apache Karaf以实现高可用性**配方'
- en: Setting up Apache Karaf for high availability
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Apache Karaf以实现高可用性
- en: To help provide higher service availability, Karaf provides the option to set
    up a secondary instance of Apache Karaf to failover upon in case of an operating
    environment error. In this recipe, we'll configure a **Master/Slave** failover
    deployment and briefly discuss how you can expand the recipe to multiple hosts.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助提供更高的服务可用性，Karaf提供了设置Apache Karaf的二级实例以在操作环境错误时进行故障转移的选项。在本配方中，我们将配置一个**主/从**故障转移部署，并简要讨论如何将配方扩展到多个主机。
- en: Getting ready
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The ingredients of this recipe include the Apache Karaf distribution kit, access
    to JDK, and a source code editor. The sample configuration for this recipe is
    available at [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter1/chapter1-recipe8](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter1/chapter1-recipe8).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的原料包括Apache Karaf发行版套件、JDK访问权限和源代码编辑器。本配方的示例配置可在[https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter1/chapter1-recipe8](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter1/chapter1-recipe8)找到。
- en: How to do it…
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The first step is editing the system properties file. To enable a Master/Slave
    failover, we edit the `etc/system.properties` file of two or more Karaf instances
    to include the following Karaf locking configuration:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是编辑系统属性文件。为了启用 Master/Slave 故障转移，我们编辑两个或更多 Karaf 实例的 `etc/system.properties`
    文件，包括以下 Karaf 锁定配置：
- en: '[PRE24]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The previous configuration sample contains the essential entries for a file-based
    locking mechanism, that is, two or more Karaf instances attempt to gain exclusive
    ownership of a file over a shared filesystem.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之前的配置示例包含基于文件锁定机制的必要条目，即两个或更多 Karaf 实例尝试在共享文件系统上获取对文件的独占所有权。
- en: The next step is providing locking resources. If using a shared locking file
    approach is suitable to your deployment, then all you must do at this time is
    mount the filesystem on each machine that'll host Karaf instances in the Master/Slave
    deployment.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是提供锁定资源。如果使用共享锁定文件方法适合您的部署，那么您现在必须做的只是在每个将托管 Karaf 实例的 Master/Slave 部署机器上挂载文件系统。
- en: Tip
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you plan to use the shared file lock, consider using an NFSv4 filesystem,
    as it implements flock correctly.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您计划使用共享文件锁定，请考虑使用 NFSv4 文件系统，因为它正确实现了 flock。
- en: 'Each Karaf instance will include the same lock directory location on a shared
    filesystem common to each Karaf installation. If a shared filesystem is not practical
    between systems, then a JDBC locking mechanism can be used. This is described
    in the following code:'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个 Karaf 实例将在共享文件系统上包含相同的锁定目录位置，该文件系统对每个 Karaf 安装都是通用的。如果系统之间没有共享文件系统，则可以使用
    JDBC 锁定机制。这将在以下代码中描述：
- en: '[PRE25]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The JDBC configuration is similar to the SimpleFileLock configuration. However,
    it is expanded to contain the JDBC `url`, `driver`, `timeout`, `user`, and `password`
    options. Two additional JDBC options are included to allow for multiple Master/Slave
    Karaf deployments to use a single database. These are the JDBC `table` and `clustername`
    options. The JDBC `table` property sets the database table to use for the lock,
    and the JDBC `clustername` property specifies which pairing group a Karaf instance
    belongs to (for example, hosts A and B belong to a cluster prod group, and hosts
    C and D belong to a cluster dev group).
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: JDBC 配置与 SimpleFileLock 配置类似。但是，它已扩展以包含 JDBC `url`、`driver`、`timeout`、`user`
    和 `password` 选项。还包括两个额外的 JDBC 选项，允许多个 Master/Slave Karaf 部署使用单个数据库。这些是 JDBC `table`
    和 `clustername` 选项。JDBC `table` 属性设置用于锁定的数据库表，而 JDBC `clustername` 属性指定 Karaf
    实例属于哪个配对组（例如，主机 A 和 B 属于 prod 集群组，主机 C 和 D 属于 dev 集群组）。
- en: When using the JDBC locking mechanism, you'll have to provide the relevant JDBC
    driver JAR file to Karaf's `lib/ext` folder. For specific database configurations,
    consult Karaf's user manual ([http://karaf.apache.org/manual/latest/index.html](http://karaf.apache.org/manual/latest/index.html)).
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当使用 JDBC 锁定机制时，您必须向 Karaf 的 `lib/ext` 文件夹提供相关的 JDBC 驱动程序 JAR 文件。对于特定的数据库配置，请参阅
    Karaf 的用户手册 ([http://karaf.apache.org/manual/latest/index.html](http://karaf.apache.org/manual/latest/index.html))。
- en: The final step is verifying the lock behavior. Once you have configured each
    Karaf instance to be a participant of the Master/Slave deployment and ensured
    that any locking resources have been made available (mounted filesystems or database
    drivers/connectivity), you must now validate that it is all working as desired.
    The general test to perform is to start one instance of Karaf, allow it to gain
    the lock (you'll see this recorded in the logfile), and then start all additional
    instances. Only the first instance should be fully booted; the others should be
    trying to gain the lock. Stopping this first instance should result in another
    instance becoming the Master. This verification step is vital. Most Master/Slave
    deployment failures occur due to misconfigurations or shared resource permissions.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是验证锁定行为。一旦您已配置每个 Karaf 实例成为 Master/Slave 部署的参与者，并确保所有锁定资源都已提供（挂载的文件系统或数据库驱动程序/连接性），您现在必须验证所有操作是否按预期进行。要执行的一般测试是启动一个
    Karaf 实例，允许它获取锁定（您将在日志文件中看到这一记录），然后启动所有其他实例。只有第一个实例应该完全启动；其他实例应该正在尝试获取锁定。停止第一个实例应该导致另一个实例成为
    Master。这一验证步骤至关重要。大多数 Master/Slave 部署故障都是由于配置错误或共享资源权限问题引起的。
- en: How it works…
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: 'Each instance of Apache Karaf contains a copy of the locking configuration
    in its `etc/system.properties` file. This is described in the following figure:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Karaf 的每个实例在其 `etc/system.properties` 文件中包含一份锁定配置的副本。这将在以下图中描述：
- en: '![How it works…](img/5081OS_01_08.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/5081OS_01_08.jpg)'
- en: In the case of a SimpleFileLock configuration, Karaf attempts to utilize an
    exclusive lock upon a file to manage which Karaf instance will operate as a live
    (Master) container. The other instances in the set will try gaining lock file
    access for `karaf.lock.delay` seconds each. This can be easily simulated on a
    single host machine with two Karaf installations both configured to use the same
    locking file. If the lock file is located on a shared NFSv4 filesystem, then multiple
    servers may be able to use this configuration. However, a JDBC-based lock is the
    most often used in multihost architectures.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在SimpleFileLock配置的情况下，Karaf尝试在文件上使用独占锁来管理哪个Karaf实例将作为活动（主）容器运行。该集合中的其他实例将尝试在`karaf.lock.delay`秒内获取锁文件访问权限。这可以在单个主机机器上通过两个都配置为使用相同锁定文件的Karaf安装轻松模拟。如果锁文件位于共享的NFSv4文件系统上，那么多个服务器可能能够使用此配置。然而，在多主机架构中，基于JDBC的锁是最常使用的。
- en: There's more…
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: Karaf failover describes an active/passive approach to high availability. There
    is also a similar concept that provides active/active architecture via Apache
    Karaf Cellar.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Karaf故障转移描述了一种高可用性的活动/被动方法。还有一个类似的概念，通过Apache Karaf Cellar提供活动/活动架构。
