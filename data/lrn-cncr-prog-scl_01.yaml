- en: Chapter 1. Introduction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。简介
- en: '|   | *"For over a decade prophets have voiced the contention that the organization
    of a single computer has reached its limits and that truly significant advances
    can be made only by interconnection of a multiplicity of computers."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"For over a decade prophets have voiced the contention that the organization
    of a single computer has reached its limits and that truly significant advances
    can be made only by interconnection of a multiplicity of computers."* |   |'
- en: '|   | --*Gene Amdahl, 1967* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*吉恩·阿姆达尔，1967年* |'
- en: Although the discipline of concurrent programming has a long history, it has
    gained a lot of traction in recent years with the arrival of multi core processors.
    The recent development in computer hardware not only revived some classical concurrency
    techniques but also started a major paradigm shift in concurrent programming.
    At a time when concurrency is becoming so important, an understanding of concurrent
    programming is an essential skill for every software developer.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管并发编程学科有着悠久的历史，但随着多核处理器的出现，它在近年来获得了大量的关注。计算机硬件的最近发展不仅复兴了一些经典的并发技术，而且也引发了并发编程领域的一次重大范式转变。在并发性变得如此重要的今天，理解并发编程对于每一位软件开发者来说都是一项基本技能。
- en: 'This chapter explains the basics of concurrent computing and presents some
    Scala preliminaries required for this book. Specifically, it does the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了并发计算的基本原理，并介绍了本书所需的某些Scala基础知识。具体来说，它做了以下几件事：
- en: Shows a brief overview of concurrent programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示了并发编程的简要概述
- en: Studies the advantages of using Scala when it comes to concurrency
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究使用Scala进行并发时的优势
- en: Covers the Scala preliminaries required for reading this book
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 涵盖了阅读本书所需的Scala基础知识
- en: We will start by examining what concurrent programming is and why it is important.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从探讨并发编程是什么以及为什么它很重要开始。
- en: Concurrent programming
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发编程
- en: 'In **concurrent programming**, we express a program as a set of concurrent
    computations that execute during overlapping time intervals and coordinate in
    some way. Implementing a concurrent program that functions correctly is usually
    much harder than implementing a sequential one. All the pitfalls present in sequential
    programming lurk in every concurrent program, but there are many other things
    that can go wrong, as we will learn in this book. A natural question arises: why
    bother? Can''t we just keep writing sequential programs?'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在**并发编程**中，我们将程序表达为一组在重叠时间段内执行并按某种方式协调的并发计算。实现一个功能正确的并发程序通常比实现一个顺序程序要困难得多。顺序编程中存在的所有陷阱都潜伏在每一个并发程序中，但还有许多其他可能出错的地方，正如我们将在本书中学到的那样。一个自然的问题出现了：为什么还要费这个劲？我们难道不能只继续编写顺序程序吗？
- en: Concurrent programming has multiple advantages. First, increased concurrency
    can improve **program performance**. Instead of executing the entire program on
    a single processor, different subcomputations can be performed on separate processors,
    making the program run faster. With the spread of multicore processors, this is
    the primary reason why concurrent programming is nowadays getting so much attention.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程具有多个优点。首先，增加并发性可以提高**程序性能**。不是在单个处理器上执行整个程序，而是在不同的处理器上执行不同的子计算，从而使程序运行得更快。随着多核处理器的普及，这是并发编程如今受到如此多关注的主要原因。
- en: A concurrent programming model can result in faster I/O operations. A purely
    sequential program must periodically poll I/O to check if there is any data input
    available from the keyboard, the network interface, or some other device. A concurrent
    program, on the other hand, can react to I/O requests immediately. For I/O-intensive
    operations, this results in improved throughput, and is one of the reasons why
    concurrent programming support existed in programming languages even before the
    appearance of multiprocessors. Thus, concurrency can ensure the improved **responsiveness**
    of a program that interacts with the environment.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程模型可以实现更快的I/O操作。一个纯顺序程序必须定期轮询I/O以检查是否有来自键盘、网络接口或其他设备的数据输入。另一方面，并发程序可以立即对I/O请求做出反应。对于I/O密集型操作，这会导致吞吐量的提高，这也是为什么在多处理器出现之前，编程语言中就存在并发编程支持的原因之一。因此，并发性可以确保与环境的交互程序具有更好的**响应性**。
- en: Finally, concurrency can simplify the **implementation** and **maintainability**
    of computer programs. Some programs can be represented more concisely using concurrency.
    It can be more convenient to divide the program into smaller, independent computations
    than to incorporate everything into one large program. User interfaces, web servers,
    and game engines are typical examples of such systems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，并发可以简化计算机程序的**实现**和**可维护性**。一些程序可以使用并发更简洁地表示。将程序划分为更小、更独立的计算比将其全部纳入一个大程序更方便。用户界面、Web服务器和游戏引擎是这类系统的典型例子。
- en: In this book, we adopt the convention that concurrent programs communicate through
    the use of shared memory, and execute on a single computer. By contrast, a computer
    program that executes on multiple computers, each with its own memory, is called
    a **distributed program**, and the discipline of writing such programs is called
    **distributed programming**. Typically, a distributed program must assume that
    each of the computers can fail at any point, and provide some safety guarantees
    if this happens. We will mostly focus on concurrent programs, but we will also
    look at examples of distributed programs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们采用了一种约定，即并发程序通过使用共享内存进行通信，并在单个计算机上执行。相比之下，在多台计算机上执行，每台计算机都有自己的内存的计算机程序被称为**分布式程序**，编写此类程序的学科被称为**分布式编程**。通常，分布式程序必须假设每台计算机在任何时候都可能失败，并在这种情况发生时提供一些安全保证。我们将主要关注并发程序，但也会查看分布式程序的示例。
- en: A brief overview of traditional concurrency
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传统并发的简要概述
- en: In a computer system, concurrency can manifest itself in the computer hardware,
    at the operating system level, or at the programming language level. We will focus
    mainly on programming-language-level concurrency.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机系统中，并发可以在计算机硬件、操作系统级别或编程语言级别上体现出来。我们将主要关注编程语言级别的并发。
- en: The coordination of multiple executions in a concurrent system is called **synchronization**,
    and it is a key part in successfully implementing concurrency. Synchronization
    includes mechanisms used to order concurrent executions in time. Furthermore,
    synchronization specifies how concurrent executions communicate, that is, how
    they exchange information. In concurrent programs, different executions interact
    by modifying the shared memory subsystem of the computer. This type of synchronization
    is called **shared memory communication**. In distributed programs, executions
    interact by exchanging messages, so this type of synchronization is called **message-passing
    communication**.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发系统中，多个执行之间的协调被称为**同步**，这是成功实现并发的一个关键部分。同步包括用于在时间上对并发执行进行排序的机制。此外，同步还指定了并发执行如何进行通信，即它们如何交换信息。在并发程序中，不同的执行通过修改计算机的共享内存子系统来相互交互。这种类型的同步被称为**共享内存通信**。在分布式程序中，执行通过交换消息来交互，因此这种类型的同步被称为**消息传递通信**。
- en: At the lowest level, concurrent executions are represented by entities called
    processes and threads, covered in [Chapter 2](ch02.html "Chapter 2. Concurrency
    on the JVM and the Java Memory Model"), *Concurrency on the JVM and the Java Memory
    Model*. Processes and threads traditionally use entities such as locks and monitors
    to order parts of their execution. Establishing an order between the threads ensures
    that the memory modifications done by one thread are visible to a thread that
    executes later.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在最低级别，并发执行由称为进程和线程的实体表示，这在[第2章](ch02.html "第2章。JVM和Java内存模型上的并发")中有所介绍，*JVM和Java内存模型上的并发*。进程和线程传统上使用锁和监视器等实体来对其执行的部分进行排序。在线程之间建立顺序确保了一个线程所做的内存修改对后来执行的线程是可见的。
- en: Often, expressing concurrent programs using threads and locks is cumbersome.
    More complex concurrent facilities have been developed to address this, such as
    communication channels, concurrent collections, barriers, countdown latches, and
    thread pools. These facilities are designed to more easily express specific concurrent
    programming patterns, and some of them are covered in [Chapter 3](ch03.html "Chapter 3. Traditional
    Building Blocks of Concurrency"), *Traditional Building Blocks of Concurrency*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用线程和锁来表示并发程序是繁琐的。为了解决这个问题，已经开发了一些更复杂的并发设施，例如通信通道、并发集合、屏障、倒计时锁和线程池。这些设施旨在更容易地表达特定的并发编程模式，其中一些在[第3章](ch03.html
    "第3章。并发传统构建块")中有所介绍，*并发传统构建块*。
- en: Traditional concurrency is relatively low-level and prone to various kinds of
    errors, such as deadlocks, starvations, data races, and race conditions. You will
    usually not use low-level concurrency primitives when writing concurrent Scala
    programs. Still, a basic knowledge of low-level concurrent programming will prove
    invaluable in understanding high-level concurrency concepts later.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的并发相对较低级，容易发生各种错误，如死锁、饥饿、数据竞争和竞态条件。在编写并发Scala程序时，你通常不会使用低级并发原语。然而，对低级并发编程的基本了解将在以后理解高级并发概念时非常有价值。
- en: Modern concurrency paradigms
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现代并发范式
- en: Modern concurrency paradigms are more advanced than traditional approaches to
    concurrency. Here, the crucial difference lies in the fact that a high-level concurrency
    framework expresses *which* goal to achieve, rather than *how to achieve* that
    goal.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现代并发范式比传统的并发方法更先进。在这里，关键的区别在于，高级并发框架表达的是*要实现哪个目标*，而不是*如何实现这个目标*。
- en: In practice, the difference between low-level and high-level concurrency is
    less clear, and different concurrency frameworks form a continuum rather than
    two distinct groups. Still, recent developments in concurrent programming show
    a bias towards declarative and functional programming styles.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，低级并发和高级并发的区别并不那么明显，不同的并发框架形成了一个连续体，而不是两个截然不同的组。然而，最近在并发编程方面的发展显示出对声明式和函数式编程风格的偏好。
- en: As we will see in [Chapter 2](ch02.html "Chapter 2. Concurrency on the JVM and
    the Java Memory Model"), *Concurrency on the JVM and the Java Memory Model*, computing
    a value concurrently requires creating a thread with a custom `run` method, invoking
    the `start` method, waiting until the thread completes, and then inspecting specific
    memory locations to read the result. Here, what we really want to say is *compute
    some value concurrently, and inform me when you are done*. Furthermore, we would
    prefer to use a programming model that abstracts over the coordination details
    of the concurrent computation, to treat the result of the computation as if we
    already have it, rather than having to wait for it and then reading it from the
    memory. **Asynchronous programming using futures** is a paradigm designed to specifically
    support these kinds of statements, as we will learn in [Chapter 4](ch04.html "Chapter 4. 
    Asynchronous Programming with Futures and Promises"), *Asynchronous Programming
    with Futures and Promises*. Similarly, **reactive programming using event streams**
    aims to declaratively express concurrent computations that produce many values,
    as we will see in [Chapter 6](ch06.html "Chapter 6. Concurrent Programming with
    Reactive Extensions"), *Concurrent Programming with Reactive Extensions*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在[第二章](ch02.html "第二章。JVM和Java内存模型上的并发")中看到的那样，*JVM和Java内存模型上的并发*，并发计算一个值需要创建一个带有自定义`run`方法的线程，调用`start`方法，等待线程完成，然后检查特定的内存位置以读取结果。在这里，我们真正想说的是*并发计算某个值，并在完成后通知我*。此外，我们更倾向于使用一种编程模型，该模型抽象出并发计算的协调细节，将计算结果视为我们已经拥有它，而不是必须等待它并从内存中读取它。**使用未来异步编程**是一种旨在特别支持这些语句的范例，我们将在[第四章](ch04.html
    "第四章。使用未来和承诺的异步编程")中学习，*使用未来和承诺的异步编程*。同样，**使用事件流的响应式编程**旨在声明性地表达产生许多值的并发计算，正如我们将在[第六章](ch06.html
    "第六章。使用响应式扩展的并发编程")中看到的那样，*使用响应式扩展的并发编程*。
- en: The declarative programming style is increasingly common in sequential programming
    too. Languages such as Python, Haskell, Ruby, and Scala express operations on
    their collections in terms of functional operators and allow statements such as
    *filter all negative integers from this collection*. This statement expresses
    a goal rather than the underlying implementation, allowing to it easy to parallelize
    such an operation behind the scene. [Chapter 5](ch05.html "Chapter 5. Data-Parallel
    Collections"), *Data-Parallel Collections*, describes the **data-parallel** collections
    framework available in Scala, which is designed to accelerate collection operations
    using multicores.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式编程风格在顺序编程中也越来越普遍。例如，Python、Haskell、Ruby和Scala等语言使用函数运算符来表示其集合上的操作，并允许诸如*从这个集合中过滤出所有负整数*之类的语句。这个语句表达了一个目标，而不是底层的实现，使得在幕后并行化此类操作变得容易。[第五章](ch05.html
    "第五章。数据并行集合")，*数据并行集合*，描述了Scala中可用的**数据并行**集合框架，该框架旨在通过使用多核来加速集合操作。
- en: Another trend seen in high-level concurrency frameworks is specialization towards
    specific tasks. Software transactional memory technology is specifically designed
    to express memory transactions and does not deal with how to start concurrent
    executions at all. A **memory transaction** is a sequence of memory operations
    that appear as if they either execute all at once or do not execute at all. This
    is similar to the concept of database transactions. The advantage of using memory
    transactions is that this avoids a lot of errors typically associated with low-level
    concurrency. [Chapter 7](ch07.html "Chapter 7. Software Transactional Memory"),
    *Software Transactional Memory*, explains software transactional memory in detail.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在高级并发框架中，另一个趋势是向特定任务的专业化发展。软件事务内存技术专门设计用来表达内存事务，根本不涉及如何启动并发执行的问题。一个**内存事务**是一系列看起来要么同时执行要么根本不执行的内存操作。这与数据库事务的概念类似。使用内存事务的优势在于这避免了与低级并发相关的大量错误。[第7章](ch07.html
    "第7章。软件事务内存")，*软件事务内存*，详细解释了软件事务内存。
- en: Finally, some high-level concurrency frameworks aim to transparently provide
    distributed programming support as well. This is especially true for data-parallel
    frameworks and message-passing concurrency frameworks, such as the **actors**
    described in Chapter 8, *Actors*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一些高级并发框架旨在透明地提供分布式编程支持。这对于数据并行框架和消息传递并发框架尤其如此，例如第8章*Actor*中描述的**actor**。
- en: The advantages of Scala
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala的优势
- en: Although Scala is still a language on the rise, it has yet to receive the wide-scale
    adoption of a language such as Java; nonetheless its support for concurrent programming
    is rich and powerful. Concurrency frameworks for nearly all the different styles
    of concurrent programming exist in the Scala ecosystem and are being actively
    developed. Throughout its development, Scala has pushed the boundaries when it
    comes to providing modern, high-level application programming interfaces or APIs
    for concurrent programming. There are many reasons for this.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Scala仍然是一种正在兴起的语言，但它还没有像Java这样的语言得到广泛采用；然而，它对并发编程的支持丰富而强大。Scala生态系统中有针对几乎所有不同风格的并发编程的并发框架，并且正在积极开发中。在其发展过程中，Scala在提供现代、高级的应用程序编程接口或API方面推动了并发编程的边界。这有很多原因。
- en: The primary reason that so many modern concurrency frameworks have found their
    way into Scala is its inherent syntactic flexibility. Thanks to features such
    as first-class functions, byname parameters, type inference, and pattern matching
    explained in the following sections, it is possible to define APIs that look as
    if they are built-in language features.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代并发框架之所以能够进入Scala，主要原因是其固有的语法灵活性。多亏了以下章节中解释的一等函数、byname参数、类型推断和模式匹配等特性，可以定义看起来像是内置语言特性的API。
- en: 'Such APIs emulate various programming models as embedded domain-specific languages,
    with Scala serving as a host language: actors, software transactional memory,
    and futures are examples of APIs that look like they are basic language features when
    they are in fact implemented as libraries. On one hand, Scala avoids the need
    for developing a new language for each new concurrent programming model and serves
    as a rich nesting ground for modern concurrency frameworks. On the other hand,
    lifting the syntactic burden present in many other languages attracts more users.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的API模拟了各种编程模型，如嵌入式领域特定语言，Scala作为宿主语言：actor、软件事务内存和future是看起来像是基本语言特性但实际上作为库实现的API的例子。一方面，Scala避免了为每个新的并发编程模型开发新语言的需要，并作为现代并发框架丰富的嵌套基础。另一方面，减轻了许多其他语言中存在的语法负担，吸引了更多用户。
- en: The second reason Scala has pushed ahead lies in the fact that it is a safe
    language. Automatic garbage collection, automatic bound checks, and the lack of
    pointer arithmetic helps to avoid problems such as memory leaks, buffer overflows,
    and other memory errors. Similarly, static type safety eliminates a lot of programming
    errors at an early stage. When it comes to concurrent programming, which is in
    itself prone to various kinds of concurrency errors, having one less thing to
    worry about can make a world of difference.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Scala领先的第二原因是它是一种安全的语言。自动垃圾回收、自动边界检查以及没有指针运算有助于避免内存泄漏、缓冲区溢出和其他内存错误等问题。同样，静态类型安全性在早期阶段消除了许多编程错误。当涉及到本身容易发生各种并发错误的并发编程时，少了一件需要担心的事情可以产生巨大的影响。
- en: The third important reason is interoperability. Scala programs are compiled
    into Java bytecode, so the resulting executable code runs on top of the **Java
    Virtual Machine** (**JVM**). This means that Scala programs can seamlessly use
    existing Java libraries, and interact with Java's rich ecosystem. Often, transitioning
    to a different language is a painful process. In the case of Scala, a transition
    from a language such as Java can proceed gradually and is much easier. This is
    one of the reasons for its growing adoption, and also a reason why some Java-compatible
    frameworks choose Scala as their implementation language.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个重要原因是互操作性。Scala程序被编译成Java字节码，因此生成的可执行代码在**Java虚拟机**（**JVM**）上运行。这意味着Scala程序可以无缝地使用现有的Java库，并与Java的丰富生态系统进行交互。通常，转向不同的语言是一个痛苦的过程。在Scala的情况下，从Java等语言过渡可以逐步进行，并且要容易得多。这是其日益普及的原因之一，也是一些Java兼容框架选择Scala作为实现语言的原因之一。
- en: Importantly, the fact that Scala runs on the JVM implies that Scala programs
    are portable across a range of different platforms. Not only that, but the JVM
    has well-defined threading and memory models, which are guaranteed to work in
    the same way on different computers. While portability is important for the consistent
    semantics of sequential programs, it is even more important when it comes to concurrent
    computing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，Scala运行在JVM上这一事实意味着Scala程序可以在不同的平台上移植。不仅如此，JVM具有定义良好的线程和内存模型，这些模型在不同的计算机上保证以相同的方式工作。虽然可移植性对于顺序程序的一致语义很重要，但在并发计算中，它更为重要。
- en: Having seen some of Scala's advantages for concurrent programming, we are now
    ready to study the language features relevant for this book.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了Scala在并发编程方面的优势之后，我们现在可以研究本书相关的语言特性。
- en: Preliminaries
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前置知识
- en: This book assumes a basic familiarity with sequential programming. While we
    advise readers to get acquainted with the Scala programming language, an understanding
    of a similar language, such as Java or C#, should be sufficient for this book.
    A basic familiarity with concepts in object-oriented programming, such as classes,
    objects, and interfaces, is helpful. Similarly, a basic understanding of functional
    programming principles, such as first-class functions, purity, and type-polymorphism
    are beneficial in understanding this book but are not a strict prerequisite.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 本书假设读者对顺序编程有基本的了解。虽然我们建议读者熟悉Scala编程语言，但对于类似Java或C#这样的语言的理解应该足以应对本书。对面向对象编程中的概念，如类、对象和接口，有基本的了解是有帮助的。同样，对函数式编程原则，如一等函数、纯净性和类型多态，有基本的理解有助于理解本书，但这些并非严格的前提条件。
- en: Execution of a Scala program
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala程序的执行
- en: 'To better understand the execution model of Scala programs, let''s consider
    a simple program that uses the `square` method to compute the square value of
    the number `5`, and then prints the result to the standard output:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解Scala程序的执行模型，让我们考虑一个简单的程序，该程序使用`square`方法计算数字`5`的平方值，然后将结果打印到标准输出：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can run this program using the **Simple Build Tool** (**SBT**), as described
    in the *Preface*. When a Scala program runs, the JVM runtime allocates the memory
    required for the program. Here, we consider two important memory regions--the
    **call stack** and the **object heap**. The call stack is a region of memory in
    which the program stores information about the local variables and parameters
    of the currently executed methods. The object heap is a region of memory in which
    objects are allocated by the program. To understand the difference between the
    two regions, we consider a simplified scenario of this program's execution.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用在**前言**中描述的**简单构建工具**（**SBT**）运行此程序。当 Scala 程序运行时，JVM 运行时为程序分配所需的内存。在这里，我们考虑两个重要的内存区域——**调用栈**和**对象堆**。调用栈是一个内存区域，其中程序存储有关当前执行方法的局部变量和参数的信息。对象堆是一个程序在其中分配对象的内存区域。为了理解这两个区域之间的差异，我们考虑这个程序执行的一个简化场景。
- en: 'First, in figure **1**, the program allocates an entry to the call stack for
    the local variable `s`. Then, it calls the `square` method in figure **2** to
    compute the value for the local variable `s`. The program places the value `5`
    on the call stack, which serves as the value for the `x` parameter. It also reserves
    a stack entry for the return value of the method. At this point, the program can
    execute the `square` method, so it multiplies the `x` parameter by itself, and
    places the return value `25` on the stack in figure **3**. This is shown in the
    first row in the following illustration:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在图 **1** 中，程序为局部变量 `s` 在调用栈中分配了一个条目。然后，它在图 **2** 中调用 `square` 方法来计算局部变量 `s`
    的值。程序将值 `5` 放在调用栈上，作为 `x` 参数的值。它还为方法的返回值预留了一个栈条目。此时，程序可以执行 `square` 方法，因此它将 `x`
    参数自乘，并将返回值 `25` 放在图 **3** 中的栈上。这在上面的插图的第一行中显示：
- en: '![Execution of a Scala program](img/B05779_01_01.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![Scala 程序的执行](img/B05779_01_01.jpg)'
- en: After the `square` method returns the result, the result `25` is copied into
    the stack entry for the local variable `s`, as shown in figure **4**. Now, the
    program must create the string for the `println` statement. In Scala, strings
    are represented as object instances of the `String` class, so the program allocates
    a new `String` object to the object heap, as illustrated in figure **5**. Finally,
    in figure **6**, the program stores the reference to the newly allocated object
    into the stack entry `x`, and calls the `println` method.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `square` 方法返回结果后，结果 `25` 被复制到局部变量 `s` 的栈条目中，如图 **4** 所示。现在，程序必须为 `println`
    语句创建字符串。在 Scala 中，字符串被表示为 `String` 类的对象实例，因此程序在对象堆中分配了一个新的 `String` 对象，如图 **5**
    所示。最后，在图 **6** 中，程序将新分配的对象的引用存储到栈条目 `x` 中，并调用 `println` 方法。
- en: Although this demonstration is greatly simplified, it shows the basic execution
    model for Scala programs. In [Chapter 2](ch02.html "Chapter 2. Concurrency on
    the JVM and the Java Memory Model"), *Concurrency on the JVM and the Java Memory
    Model*, we will learn that each thread of execution maintains a separate call
    stack, and that threads mainly communicate by modifying the object heap. We will
    learn that the disparity between the state of the heap and the local call stack
    is frequently responsible for certain kinds of error in concurrent programs.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个演示被大大简化了，但它展示了 Scala 程序的基本执行模型。在[第 2 章](ch02.html "第 2 章。JVM 和 Java 内存模型上的并发")中，“JVM
    和 Java 内存模型上的并发”，我们将了解到每个执行线程维护一个独立的调用栈，并且线程主要通过修改对象堆来进行通信。我们将了解到堆的状态和局部调用栈之间的差异通常是并发程序中某些错误的原因。
- en: Having seen an example of how Scala programs are typically executed, we now
    proceed to an overview of Scala features that are essential to understand the
    contents of this book.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到 Scala 程序通常是如何执行的一个例子之后，我们现在继续概述 Scala 的特性，这些特性对于理解本书的内容至关重要。
- en: A Scala primer
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scala 入门
- en: In this section, we present a short overview of the Scala programming language
    features that are used in the examples in this book. This is a quick and cursory
    glance through the basics of Scala. Note that this section is not meant to be
    a complete introduction to Scala. This is to remind you about some of the language's
    features, and contrast them with similar languages that might be familiar to you.
    If you would like to learn more about Scala, refer to some of the books referred
    to in the *Summary* of this chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们简要概述了本书示例中使用的 Scala 编程语言特性。这是对 Scala 基础的快速浏览。请注意，本节并非旨在提供一个完整的 Scala
    介绍。这是为了提醒您一些语言特性，并将它们与您可能熟悉的类似语言进行对比。如果您想了解更多关于 Scala 的信息，请参考本章 *总结* 中提到的书籍。
- en: 'A `Printer` class, which takes a `greeting` parameter and has two methods named
    `printMessage` and `printNumber`, is declared as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为 `Printer` 的类，它接受一个 `greeting` 参数，并有两个名为 `printMessage` 和 `printNumber`
    的方法，声明如下：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, the `printMessage` method does not take any arguments and
    contains a single `println` statement. The `printNumber` method takes a single
    argument `x` of the `Int` type. Neither method returns a value, which is denoted
    by the `Unit` type.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`printMessage` 方法不接受任何参数，并包含一个单独的 `println` 语句。`printNumber` 方法接受一个名为
    `x` 的 `Int` 类型的单个参数。这两个方法都不返回任何值，这由 `Unit` 类型表示。
- en: 'We instantiate the class and call its methods as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样实例化类并调用其方法：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Scala allows the declaration of **singleton objects**. This is like declaring
    a class and instantiating its single instance at the same time. We saw the `SquareOf5`
    singleton object earlier, which was used to declare a simple Scala program. The
    following singleton object, named `Test`, declares a single `Pi` field and initializes
    it with the value `3.14`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 允许声明**单例对象**。这就像声明一个类并同时实例化它的单个实例一样。我们之前看到了 `SquareOf5` 单例对象，它被用来声明一个简单的
    Scala 程序。以下名为 `Test` 的单例对象声明了一个名为 `Pi` 的字段，并将其初始化为值 `3.14`：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'While classes in similar languages extend entities that are called interfaces,
    Scala classes can extend **traits**. Scala''s traits allow declaring both concrete
    fields and method implementations. In the following example, we declare the `Logging`
    trait, which outputs a custom error and warning messages using the abstract `log`
    method, and then mix the trait into the `PrintLogging` class:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当类似语言的类扩展称为接口的实体时，Scala 类可以扩展**特质**。Scala 的特质允许声明具体的字段和方法实现。在以下示例中，我们声明了 `Logging`
    特质，它使用抽象的 `log` 方法输出自定义的错误和警告消息，然后将特质混合到 `PrintLogging` 类中：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Classes can have **type parameters**. The following generic `Pair` class takes
    two type parameters, `P` and `Q`, which determines the types of its arguments,
    named `first` and `second`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以有**类型参数**。下面的通用 `Pair` 类有两个类型参数，`P` 和 `Q`，它们决定了其参数 `first` 和 `second` 的类型：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Scala has support for first-class function objects, also called **lambdas**.
    In the following code snippet, we declare a `twice` lambda, which multiplies its
    argument by two:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 支持一等函数对象，也称为**lambda**。在下面的代码片段中，我们声明了一个 `twice` lambda，它将其参数乘以二：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code:**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码：**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在 [http://www.packtpub.com](http://www.packtpub.com) 的账户下载您购买的所有 Packt
    书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问 [http://www.packtpub.com/support](http://www.packtpub.com/support)
    并注册，以便将文件直接通过电子邮件发送给您。
- en: 'In the preceding code, the `(x: Int)` part is the argument to the lambda, and
    `x * 2` is its body. The `=>` symbol must be placed between the arguments and
    the body of the lambda. The same `=>` symbol is also used to express the type
    of the lambda, which is `Int => Int`, pronounced as `Int` to `Int`. In the preceding
    example, we can omit the type annotation `Int => Int`, and the compiler will infer
    the type of the `twice` lambda automatically, as shown in the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的代码中，`(x: Int)` 部分是 lambda 的参数，而 `x * 2` 是它的主体。`=>` 符号必须放置在 lambda 的参数和主体之间。相同的
    `=>` 符号也用于表示 lambda 的类型，即 `Int => Int`，读作“Int 到 Int”。在先前的例子中，我们可以省略类型注解 `Int =>
    Int`，编译器会自动推断 `twice` lambda 的类型，如下面的代码所示：'
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Alternatively, we can omit the type annotation in the lambda declaration and
    arrive at a more convenient syntax, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以在 lambda 声明中省略类型注解，从而得到更方便的语法，如下所示：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, whenever the argument to the lambda appears only once in the body
    of the lambda, Scala allows a more convenient syntax, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当 lambda 参数在 lambda 体中只出现一次时，Scala 允许使用更方便的语法，如下所示：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'First-class functions allow manipulating blocks of code as if they were first-class
    values. They allow a more lightweight and concise syntax. In the following example,
    we use **byname parameters** to declare a `runTwice` method, which runs the specified
    block of code `body` twice:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首类函数允许将代码块作为首类值来操作。它们允许更轻量级和简洁的语法。在以下示例中，我们使用 **按名参数** 来声明一个 `runTwice` 方法，该方法运行指定的代码块
    `body` 两次：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A byname parameter is formed by putting the `=>` annotation before the type.
    Whenever the `runTwice` method references the `body` argument, the expression
    is re-evaluated, as shown in the following snippet:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 按名参数是通过在类型之前放置 `=>` 注解来形成的。每当 `runTwice` 方法引用 `body` 参数时，表达式将被重新评估，如下面的代码片段所示：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Scala `for` expressions are a convenient way to traverse and transform collections.
    The following `for` loop prints the numbers in the range from `0 until 10`; where
    `10` is not included in the range:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Scala `for` 表达式是遍历和转换集合的便捷方式。以下 `for` 循环打印了从 `0 until 10` 范围内的数字；其中 `10` 不包含在范围内：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, the range is created with the expression `0 until 10`;
    this is equivalent to the expression `0.until(10)`, which calls the method `until`
    on the value `0`. In Scala, the dot notation can sometimes be dropped when invoking
    methods on objects.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，范围是通过表达式 `0 until 10` 创建的；这相当于表达式 `0.until(10)`，它调用值 `0` 上的 `until`
    方法。在 Scala 中，在对象上调用方法时，有时可以省略点符号。
- en: 'Every `for` loop is equivalent to a `foreach` call. The preceding `for` loop
    is translated by the Scala compiler to the following expression:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `for` 循环都等价于一个 `foreach` 调用。前面的 `for` 循环被 Scala 编译器转换为以下表达式：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For-comprehensions are used to transform data. The following for-comprehension
    transforms all the numbers from `0 until 10` by multiplying them by `-1`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: For-comprehensions 用于转换数据。以下 for-comprehension 通过乘以 `-1` 转换 `0 until 10` 的所有数字：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `negatives` value contains negative numbers from `0` until `-10`. This
    for-comprehension is equivalent to the following `map` call:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`negatives` 值包含从 `0` 到 `-10` 的负数。这个 for-comprehension 等价于以下 `map` 调用：'
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It is also possible to transform data from multiple inputs. The following for-comprehension
    creates all pairs of integers between `0` and `4`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以从多个输入转换数据。以下 for-comprehension 创建了 `0` 到 `4` 之间的所有整数对：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding for-comprehension is equivalent to the following expression:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 for-comprehension 等价于以下表达式：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can nest an arbitrary number of generator expressions in a for-comprehension.
    The Scala compiler will transform them into a sequence of nested `flatMap` calls,
    followed by a `map` call at the deepest level.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 for-comprehension 中嵌套任意数量的生成表达式。Scala 编译器会将它们转换成一个嵌套的 `flatMap` 调用序列，然后是最深层的
    `map` 调用。
- en: 'Commonly used Scala collections include sequences, denoted by the `Seq[T]`
    type; maps, denoted by the `Map[K, V]` type; and sets, denoted by the `Set[T]`
    type. In the following code, we create a sequence of strings:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 常用的 Scala 集合包括序列，用 `Seq[T]` 类型表示；映射，用 `Map[K, V]` 类型表示；以及集合，用 `Set[T]` 类型表示。在以下代码中，我们创建了一个字符串序列：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Throughout this book, we rely heavily on the **string interpolation** feature.
    Normally, Scala strings are formed with double quotation marks. Interpolated strings
    are preceded with an `s` character, and can contain `$` symbols with arbitrary
    identifiers resolved from the enclosing scope, as shown in the following example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们大量依赖 **字符串插值** 功能。通常，Scala 字符串是用双引号形成的。插值字符串前面有一个 `s` 字符，并且可以包含 `$`
    符号和从封装作用域中解析的任意标识符，如下例所示：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Pattern matching** is another important Scala feature. For readers with Java,
    C#, or C background, a good way to describe it is to say that Scala''s `match`
    statement is like the `switch` statement on steroids. The `match` statement can
    decompose arbitrary datatypes and allows you to express different cases in the
    program concisely.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式匹配** 是 Scala 的另一个重要特性。对于有 Java、C# 或 C 背景的读者来说，一个好的描述方法是说 Scala 的 `match`
    语句就像强化的 `switch` 语句。`match` 语句可以分解任意数据类型，并允许你在程序中简洁地表达不同的案例。'
- en: 'In the following example, we declare a `Map` collection, named `successors`,
    used to map integers to their immediate successors. We then call the `get` method
    to obtain the successor of the number 5\. The `get` method returns an object with
    the `Option[Int]` type, which may be implemented either with the `Some` class,
    indicating that the number 5 exists in the map, or the `None` class, indicating
    that the number 5 is not a key in the map. Pattern matching on the `Option` object
    allows proceeding casewise, as shown in the following code snippet:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们声明一个名为`successors`的`Map`集合，用于将整数映射到它们的直接后继。然后我们调用`get`方法来获取数字5的后继。`get`方法返回一个具有`Option[Int]`类型的对象，该对象可以是`Some`类实现，表示数字5存在于映射中，或者`None`类实现，表示数字5不是映射中的键。在`Option`对象上使用模式匹配可以按情况继续，如下面的代码片段所示：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In Scala, most operators can be overloaded. **Operator overloading** is no
    different from declaring a method. In the following code snippet, we declare a
    `Position` class with a `+` operator:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，大多数运算符都可以重载。**运算符重载**与声明方法没有区别。在以下代码片段中，我们声明一个具有`+`运算符的`Position`类：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, Scala allows defining **package objects** to store top-level method
    and value definitions for a given package. In the following code snippet, we declare
    the package object for the `org.learningconcurrency` package. We implement the
    top level `log` method, which outputs a given string and the current thread name:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Scala允许定义**包对象**来存储给定包的顶级方法和值定义。在以下代码片段中，我们声明了`org.learningconcurrency`包的包对象。我们实现了顶级`log`方法，该方法输出给定的字符串和当前线程名称：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We will use the `log` method in the examples throughout this book to trace how
    concurrent programs are executed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的示例中使用`log`方法来跟踪并发程序是如何执行的。
- en: This concludes our quick overview of important Scala features. If you would
    like to obtain a deeper knowledge about any of these language constructs, we suggest
    that you check out one of the introductory books on sequential programming in
    Scala.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对重要Scala特性的快速概述。如果您想深入了解这些语言结构中的任何一种，我们建议您查阅关于Scala顺序编程的入门书籍之一。
- en: Overview of new features in Scala 2.12
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala 2.12新特性的概述
- en: At the time of writing, the next planned release of the language is Scala 2.12\.
    From the user and API perspective, Scala 2.12 does not introduce new ground-breaking
    features. The goal of the 2.12 release is to improve code optimization and make
    Scala compliant with the Java 8 runtime. Since Scala's primary target is the Java
    runtime, making Scala compliant with Java 8 runtime will reduce the size of compiled
    programs and JAR files, better performance and faster compilation. From the user
    perspective, the major change is that you will have to install the JDK 8 framework
    instead of JDK 7.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，语言的下一次计划发布版本是Scala 2.12。从用户和API的角度来看，Scala 2.12没有引入新的突破性特性。2.12版本的目标是改进代码优化并使Scala符合Java
    8运行时。由于Scala的主要目标是Java运行时，使Scala符合Java 8运行时将减少编译程序和JAR文件的大小，提高性能和加快编译速度。从用户的角度来看，主要变化是您将不得不安装JDK
    8框架而不是JDK 7。
- en: 'The particular changes in Scala 2.12 worth mentioning are the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 值得在Scala 2.12中提到的特定变化如下：
- en: In previous versions, traits compiled to a single interface if all of their
    methods were abstract. If the trait had a concrete method implementation, the
    compiler generated two class files--one containing the JVM interface, and another
    class file containing the implementations of the concrete methods. In Scala 2.12,
    the compiler will generate a single interface file containing the Java 8 **default
    methods**. The net effect is reduced code size.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在之前的版本中，如果所有方法都是抽象的，则特质编译为一个单独的接口。如果特质有一个具体方法实现，编译器将生成两个类文件——一个包含JVM接口，另一个类文件包含具体方法的实现。在Scala
    2.12中，编译器将生成一个包含Java 8 **默认方法**的单个接口文件。结果是代码大小减少。
- en: Previously, each Scala closure was compiled into a separate class. Starting
    with 2.12, Scala closures are compiled into Java 8-style lambdas. The consequence
    is reduced code size and potentially better optimizations by the Java 8 runtime.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以前，每个Scala闭包都被编译成一个单独的类。从2.12版本开始，Scala闭包被编译成Java 8风格的lambda表达式。结果是代码大小减少，并且可能通过Java
    8运行时进行更好的优化。
- en: Scala compiles into Java bytecodes, which are then interpreted on the Java Virtual
    Machine. In Scala 2.12, the old compiler backend is replaced with a new implementation
    that generates bytecode more quickly with a positive impact on compilation speed.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala 编译成 Java 字节码，然后在这些字节码上由 Java 虚拟机进行解释。在 Scala 2.12 中，旧的编译器后端被一个新的实现所取代，该实现可以更快地生成字节码，从而对编译速度产生积极影响。
- en: Scala 2.12 comes with a new optimizer, which is enabled with the `-opt` compiler
    flag. The new optimizer is more aggressive at inlining final methods, does better
    escape analysis for objects and functions that are created and used in a single
    method, and does dead code elimination. All this has a positive impact on the performance
    of Scala programs.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala 2.12 随带一个新优化器，可以通过 `-opt` 编译器标志启用。新的优化器在内联最终方法方面更加激进，对在单个方法中创建和使用的对象和函数进行更好的逃逸分析，并执行死代码消除。所有这些都有助于提高
    Scala 程序的性能。
- en: Scala 2.12 allows using lambdas for Single Abstract Method (SAM) types. SAM
    types are classes or traits that have exactly one abstract method, which is normally
    implemented by extending the class. Assume that we have a method invocation with
    an argument whose expected type is a SAM type. If the user passes a lambda, that
    is, a function literal, instead of a SAM type instance, the 2.12 compiler will
    automatically convert the function object into an instance of the SAM type.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala 2.12 允许使用 lambda 表达式为单抽象方法 (SAM) 类型。SAM 类型是具有恰好一个抽象方法的类或特质，通常通过扩展类来实现。假设我们有一个方法调用，其期望的类型是
    SAM 类型。如果用户传递一个 lambda，即函数字面量，而不是 SAM 类型实例，2.12 编译器将自动将函数对象转换为 SAM 类型的实例。
- en: Summary
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we studied what concurrent programming is and why Scala is
    a good language for concurrency. We gave a brief overview of what you will learn
    in this book, and how the book is organized. Finally, we stated some Scala preliminaries
    necessary for understanding the various concurrency topics in the subsequent chapters.
    If you would like to learn more about sequential Scala programming, we suggest
    that you read the book, *Programming in Scala*, *Martin Odersky, Lex Spoon, and
    Bill Venners*, *Artima Inc*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了并发编程是什么以及为什么 Scala 是一种适合并发的语言。我们简要概述了本书将介绍的内容以及本书的组织结构。最后，我们列举了一些理解后续章节中各种并发主题所需的
    Scala 基础知识。如果您想了解更多关于顺序 Scala 编程的知识，我们建议您阅读书籍，《Scala 编程》，作者：马丁·奥德斯基、莱克斯·斯波恩和比尔·文纳，出版社：Artima
    Inc。
- en: In the next chapter, we will start with the fundamentals of concurrent programming
    on the JVM. We will introduce the basic concepts in concurrent programming, present
    the low-level concurrency utilities available on the JVM, and learn about the
    Java Memory Model.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从 JVM 上的并发编程基础开始。我们将介绍并发编程的基本概念，展示 JVM 上可用的低级并发实用工具，并了解 Java 内存模型。
- en: Exercises
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: The following exercises are designed to test your knowledge of the Scala programming
    language. They cover the content presented in this chapter, along with some additional
    Scala features. The last two exercises contrast the difference between concurrent
    and distributed programming, as defined in this chapter. You should solve them
    by sketching out a pseudocode solution, rather than a complete Scala program.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下练习旨在测试你对 Scala 编程语言的知识。它们涵盖了本章介绍的内容，以及一些额外的 Scala 功能。最后两个练习对比了本章定义的并发编程和分布式编程之间的差异。你应该通过绘制伪代码解决方案来解决它们，而不是一个完整的
    Scala 程序。
- en: 'Implement a `compose`  method with the following signature:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个具有以下签名的 `compose` 方法：
- en: '[PRE23]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This method must return a function `h`, which is the composition of the functions
    `f` and `g`
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法必须返回一个函数 `h`，它是函数 `f` 和 `g` 的组合
- en: 'Implement a `fuse` method with the following signature:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个具有以下签名的 `fuse` 方法：
- en: '[PRE24]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The resulting `Option` object should contain a tuple of values from the `Option`
    objects `a` and `b`, given that both `a` and `b` are non-empty. Use for-comprehensions
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果的 `Option` 对象应包含来自 `Option` 对象 `a` 和 `b` 的值元组，前提是 `a` 和 `b` 都不为空。使用 for-表达式
- en: 'Implement a `check` method, which takes a set of values of type `T` and a function
    of type `T => Boolean`:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个 `check` 方法，它接受类型为 `T` 的值集合和一个类型为 `T => Boolean` 的函数：
- en: '[PRE25]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The method must return `true` if and only if the `pred` function returns `true`
    for all the values in `xs` without throwing an exception. Use the `check` method
    as follows:'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该方法必须返回 `true`，仅当 `pred` 函数对所有 `xs` 中的值返回 `true` 而不抛出异常时。如下使用 `check` 方法：
- en: '[PRE26]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Tip
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'The `check` method has a curried definition: instead of just one parameter
    list, it has two of them. Curried definitions allow a nicer syntax when calling
    the function, but are otherwise semantically equivalent to single-parameter list
    definitions.'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`check` 方法有一个柯里化定义：它不是只有一个参数列表，而是有两个。柯里化定义在调用函数时提供了更简洁的语法，但在其他方面与单参数列表定义在语义上是等价的。'
- en: Modify the `Pair` class from this chapter so that it can be used in a pattern
    match.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改本章中的 `Pair` 类，使其能够用于模式匹配。
- en: Tip
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you haven't already done so, familiarize yourself with pattern matching in
    Scala.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，请熟悉 Scala 中的模式匹配。
- en: 'Implement a `permutations` function, which, given a string, returns a sequence
    of strings that are lexicographic permutations of the input string:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个 `permutations` 函数，它接受一个字符串，并返回一个字符串序列，这些字符串是输入字符串的字典序排列：
- en: '[PRE27]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Implement a `combinations` function that, given a sequence of elements, produces
    an iterator over all possible combinations of length `n`. A combination is a way
    of selecting elements from the collection so that every element is selected once,
    and the order of elements does not matter. For example, given a collection `Seq(1,
    4, 9, 16)`, combinations of length 2 are `Seq(1, 4)`, `Seq(1, 9)`, `Seq(1, 16)`,
    `Seq(4, 9)`, `Seq(4, 16)`, and `Seq(9, 16)`. The combinations function has the
    following signature:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个 `combinations` 函数，它接受一个元素序列，并生成一个长度为 `n` 的所有可能组合的迭代器。组合是从集合中选择元素的一种方式，使得每个元素只被选中一次，且元素的顺序不重要。例如，给定一个集合
    `Seq(1, 4, 9, 16)`，长度为 2 的组合有 `Seq(1, 4)`、`Seq(1, 9)`、`Seq(1, 16)`、`Seq(4, 9)`、`Seq(4,
    16)` 和 `Seq(9, 16)`。组合函数具有以下签名：
- en: '[PRE28]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: See the `Iterator` API in the standard library documentation
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请参阅标准库文档中的 `Iterator` API。
- en: 'Implement a method that takes a regular expression, and returns a partial function
    from a string to lists of matches within that string:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个方法，该方法接受一个正则表达式，并返回一个从字符串到该字符串内匹配项列表的部分函数：
- en: '[PRE29]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The partial function should not be defined if there are no matches within the
    argument strings. Otherwise, it should use the regular expression to output the
    list of matches.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果在参数字符串中没有匹配项，则不应定义部分函数。否则，它应使用正则表达式输出匹配项的列表。
- en: Consider that you and three of your colleagues working in an office divided
    into cubicles. You cannot see each other, and you are not allowed to verbally
    communicate, as that might disturb other workers. Instead, you can throw pieces
    of paper with short messages at each other. Since you are confined in a cubicle,
    neither of you can tell if the message has reached its destination. At any point,
    you or one of your colleagues may be called to the boss's office and kept there
    indefinitely. Design an algorithm in which you and your colleagues can decide
    when to meet at the local bar. With the exception of the one among you who was
    called to the boss's office, all of you have to decide on the same time. What
    if some of the paper pieces can arbitrarily miss the target cubicle?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑这样一个场景：你和你的三位同事在一个被分成隔断的办公室里工作。你们彼此看不到对方，也不允许口头交流，因为这可能会打扰到其他工作人员。相反，你们可以通过互相扔带有简短信息的纸条来进行交流。由于你们被限制在隔断内，你们中的任何一个人都无法确定信息是否已经到达目的地。在任何时候，你或你的同事都可能被叫到老板的办公室，并且可能在那里无限期地等待。设计一个算法，让你们和你的同事能够决定何时在当地酒吧见面。除了被叫到老板办公室的那个人之外，你们所有人都必须决定相同的时间。如果有些纸条可以任意地错过目标隔断怎么办？
- en: Imagine that, in the previous exercise, you and your colleagues also have a
    whiteboard in the hall next to the office. Each one of you can occasionally pass
    through the hall and write something on the whiteboard, but there is no guarantee
    that either of you will be in the hall at the same time.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 想象一下，在上一个练习中，你和你的同事也在办公室旁边的走廊里有一个白板。你们中的任何一个人偶尔会经过走廊并在白板上写些东西，但无法保证你们中的任何一个人会在同一时间出现在走廊上。
- en: Solve the problem from the previous exercise, this time using the whiteboard.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用白板解决上一个练习中的问题。
