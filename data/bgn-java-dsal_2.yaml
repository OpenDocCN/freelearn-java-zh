- en: Sorting Algorithms and Fundamental Data Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序算法和基本数据结构
- en: In the previous chapter, we saw how the intersection problem can be improved
    by using a sorting algorithm. This is common with many problems. If the data is
    organized in an ordered manner, a more efficient algorithm can be developed. In
    this chapter, we will start by exploring three types of sorting techniques, which
    are bubble, quick, and merge sorting. Later, we will learn different ways to organize
    data using fundamental data structures.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何通过使用排序算法来改进交集问题。这在许多问题中都很常见。如果数据是有序的，就可以开发出更有效的算法。在本章中，我们将首先探讨三种排序技术，即冒泡排序、快速排序和归并排序。稍后，我们将学习使用基本数据结构组织数据的不同方法。
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Describe how bubble sorting works
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述冒泡排序的工作原理
- en: Implement faster sorting with quick sort
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用快速排序实现更快的排序
- en: Characterize merge sorting
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述归并排序
- en: Build a linked list data structure
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建链表数据结构
- en: Implement queues
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现队列
- en: Describe the stack data structure
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述栈数据结构
- en: Introducing Bubble Sorting
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍冒泡排序
- en: Bubble sorting is the simplest sorting algorithm out there. The technique involves making
    multiple passes over the input array and swapping unordered elements close to
    one another. The technique is called bubble sort, as the sorted list "bubbles"
    up from the tail end of the list.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序是现有最简单的排序算法。该技术涉及多次遍历输入数组并交换相邻的无序元素。该技术被称为冒泡排序，因为排序后的列表“冒泡”从列表的尾部向上移动。
- en: Understanding Bubble Sorting
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解冒泡排序
- en: All sorting algorithms accept a list of elements and return them ordered. The
    main difference between each algorithm is the manner in which the sorting is done.
    Bubble sorting works by swapping adjacent elements. This pushes the sorted elements
    toward the end of the list.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 所有排序算法都接受一个元素列表并返回它们按顺序排列。每种算法之间的主要区别在于排序的方式。冒泡排序通过交换相邻元素来实现，这会将排序后的元素推向列表的末尾。
- en: '*Snippet 2.1* shows the pseudocode for bubble sort. The algorithm involves
    three simple tasks, which involves repeatedly stepping through the list to sort,
    comparing adjacent elements, and swapping them around if the first element is
    bigger than the second.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*Snippet 2.1* 展示了冒泡排序的伪代码。该算法涉及三个简单的任务，包括反复遍历列表进行排序、比较相邻元素，并在第一个元素大于第二个元素时交换它们。'
- en: How many passes do we need to perform on the array until our list is sorted?
    It turns out that to guarantee that our list is sorted, we need to do *(n - 1)*
    passes on the list, *n* being the length of our array. We will show why *(n -
    1)* passes are needed in the next section, but this is the main reason why bubble
    sort has a runtime complexity of *O(n²)*, since we're processing *n* elements
    for *n - 1* times.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对数组进行多少次遍历才能使我们的列表排序？结果是，为了保证我们的列表排序，我们需要对列表进行 *(n - 1)* 次遍历，其中 *n* 是我们数组的长度。我们将在下一节中展示为什么需要
    *(n - 1)* 次遍历，但这是冒泡排序具有 *O(n²)* 时间复杂性的主要原因，因为我们处理 *n* 个元素 *n - 1* 次。
- en: 'The pseudocode for bubble sort is as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序的伪代码如下：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Snippet 2.1: Bubble sort pseudocode'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 'Snippet 2.1: 冒泡排序伪代码'
- en: The swap function in the *Snippet 2.1* switches the values of the two array
    pointers `j` and `j+1` using a temporary variable.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*Snippet 2.1* 中的交换函数使用一个临时变量交换了两个数组指针 `j` 和 `j+1` 的值。'
- en: Implementing Bubble Sort
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现冒泡排序
- en: 'To implement bubble sort in Java, follow these steps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Java中实现冒泡排序，请按照以下步骤操作：
- en: 'Apply the pseudocode shown in *Snippet 2.1* in Java. Create a class and a method,
    accepting an array to sort as follows:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Java中将 *Snippet 2.1* 中显示的伪代码应用于。创建一个类和一个方法，接受一个要排序的数组，如下所示：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The slightly tricky part of this algorithm is the swapping logic. This is done by
    assigning one of the elements to be swapped to a temporary variable, as shown
    in *Snippet 2.2*:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该算法的稍微棘手的部分是交换逻辑。这通过将一个要交换的元素分配给一个临时变量来实现，如 *Snippet 2.2* 所示：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Snippet 2.2: Bubble sort solution. Source class name: BubbleSort'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 'Snippet 2.2: 冒泡排序解决方案。源类名：BubbleSort'
- en: Go to [https://goo.gl/7atHVR](https://goo.gl/7atHVR) to access the code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://goo.gl/7atHVR](https://goo.gl/7atHVR) 访问代码。
- en: Although bubble sort is very easy to implement, it's also one of the slowest
    sorting methods out there. In the next section, we will look at how we can slightly
    improve the performance of this algorithm.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然冒泡排序非常容易实现，但它也是现有最慢的排序方法之一。在下一节中，我们将探讨如何略微提高该算法的性能。
- en: Improving Bubble Sorting
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进冒泡排序
- en: There are two main techniques we can adopt to improve the performance of bubble
    sort. It's important to realize that although both of these strategies improve
    the overall performance of bubble sort in the average case; in the worst case,
    the algorithm still has the same poor runtime complexity of *O(n²)*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采用两种主要技术来提高冒泡排序的性能。重要的是要认识到，尽管这两种策略在平均情况下都提高了冒泡排序的整体性能；在最坏的情况下，算法仍然具有相同的较差的运行时间复杂度
    *O(n²)*。
- en: The first small enhancement we can make to the original bubble sort is to make
    use of the fact that a sorted "bubble" is building at the end of the list. With
    every pass we make, another item is added at the end portion of this bubble. This
    is the reason why *(n - 1)* passes are needed.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对原始冒泡排序的第一个小改进是利用事实，即一个已排序的“气泡”正在列表的末尾构建。我们每进行一次遍历，就会在这个气泡的末尾部分添加另一个项目。这就是为什么需要
    *(n - 1)* 次遍历的原因。
- en: 'This is also shown in *Figure 2.1*. In this diagram, the items shown in the
    dotted circle are already sorted in the correct place:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这也在 *图 2.1* 中显示。在这个图中，显示在虚线圆圈中的项目已经排在了正确的位置：
- en: '![](img/35c38596-9b67-43de-9b6a-857729e91c1d.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/35c38596-9b67-43de-9b6a-857729e91c1d.png)'
- en: 'Figure 2.1: Bubble forming toward the end of the list'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：列表末尾形成气泡
- en: 'We can use this fact so we don''t try to sort the elements inside this bubble.
    We can do this by slightly modifying our Java code, as shown in *Snippet 2.3*.
    In the inner loop, instead of processing until the end of the list, we can stop
    just before the sorted bubble, until `numbers.length - i`. For brevity, in *Snippet
    2.3* we have replaced the swap logic with a method as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这个事实，所以我们不会尝试对这个气泡内的元素进行排序。我们可以通过稍微修改我们的 Java 代码来实现这一点，如 *代码片段 2.3* 所示。在内循环中，我们可以在到达列表末尾之前停止处理，直到
    `numbers.length - i`。为了简洁起见，在 *代码片段 2.3* 中，我们将交换逻辑替换为以下方法：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Snippet 2.3: Bubble sort improvement 1\. Source class name: BubbleSort'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段 2.3：冒泡排序改进 1\. 源类名：BubbleSort
- en: Go to [https://goo.gl/vj267K](https://goo.gl/vj267K) to access the code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://goo.gl/vj267K](https://goo.gl/vj267K) 访问代码。
- en: If we give a sorted list to our bubble sort algorithm, we will still make multiple
    passes on it without modifying it. We can further improve the algorithm by cutting
    short the outer loop when the list inside the array is fully sorted. We can check
    that the array is sorted by checking if any swaps were done during our last pass.
    In this manner, if we give our method an already sorted list, we just need to
    do one pass on the array and leave it untouched. This means that the best case
    is now *O(n)*, although the worst case stays the same.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们给冒泡排序算法一个已排序的列表，我们仍然会在它上面进行多次遍历而不修改它。我们可以通过在数组内部列表完全排序时截断外循环来进一步改进算法。我们可以通过检查在上一次遍历过程中是否进行了任何交换来检查数组是否已排序。这样，如果我们给我们的方法一个已经排序的列表，我们只需要在数组上执行一次遍历，然后保持它不变。这意味着现在最佳情况是
    *O(n)*，尽管最坏情况保持不变。
- en: Implementing Bubble Sort Improvement
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现冒泡排序改进
- en: We need to improve the bubble sort algorithm by reducing the number of passes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要通过减少遍历次数来改进冒泡排序算法。
- en: 'The steps to do this are as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此操作的步骤如下：
- en: Change the bubble sort method so that it stops sorting if the array is untouched
    after an inner loop pass.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改冒泡排序方法，使其在内部循环遍历后数组未发生变化时停止排序。
- en: 'The solution can be developed easily if the outer for loop is changed into
    a `while` loop and a flag is kept to indicate if any elements have been swapped
    while going through the array. This is shown in the following code snippet:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果将外部的 for 循环改为 while 循环，并保持一个标志来指示在遍历数组时是否交换了任何元素，那么解决方案可以很容易地开发出来。这在下述代码片段中显示：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Snippet 2.4: Bubble sort improvement 2\. Source class name: BubbleSort'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段 2.4：冒泡排序改进 2\. 源类名：BubbleSort
- en: Go to [https://goo.gl/HgVYfL](https://goo.gl/HgVYfL) to access the code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://goo.gl/HgVYfL](https://goo.gl/HgVYfL) 访问代码。
- en: In this section, we have seen some simple tricks on how to improve the bubble
    sort algorithm. In the following sections, we shall look at some other sorting
    techniques that perform much faster than bubble sort.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了一些关于如何改进冒泡排序算法的简单技巧。在接下来的章节中，我们将探讨一些其他排序技术，它们的性能比冒泡排序快得多。
- en: 'Activity: Implementing Selection Sort in Java'
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：在 Java 中实现选择排序
- en: '**Scenario**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: Selection sort is best understood by imagining that you have two lists, A and
    B. Initially, we have list A, containing all the unsorted elements, and list B
    is empty. The idea is to use B to store the sorted elements. The algorithm would
    work by finding the smallest element from A and moving it to the end of B. We
    keep on doing this until A is empty and B is full. Instead of using two separate
    lists, we can just use the same input array, but keeping a pointer to divide the
    array in two.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过想象你有两个列表，A和B，来更好地理解选择排序。最初，我们有一个包含所有未排序元素的列表A，而列表B为空。想法是使用B来存储排序后的元素。算法通过从A中找到最小的元素并将其移动到B的末尾来工作。我们继续这样做，直到A为空而B为满。而不是使用两个单独的列表，我们可以只使用相同的输入数组，但保持一个指针来将数组分成两部分。
- en: In real life, this can be explained by picturing how you would sort a deck of
    cards. Using a shuffled deck, you can go through the cards one by one until you
    find the lowest card. You set this aside as a new, second pile. You then look
    for the next-lowest card and once found, you put it at the bottom of the second
    pile. You repeat this until the first pile is empty.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，这可以通过想象你如何排序一副牌来解释。使用洗好的牌，你可以逐张检查牌，直到找到最低的牌。你将这张牌放在一边作为新的第二堆。然后，你寻找下一张最低的牌，一旦找到，你就把它放在第二堆的底部。你重复这个过程，直到第一堆为空。
- en: One way to arrive at the solution is to first write the pseudocode that uses
    two arrays (A and B, in the preceding description). Then, adopt the pseudocode
    to store the sorted list (array B) in the same input array by using the swapping
    method.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案的一种方法是在先使用两个数组（A和B，在先前的描述中）编写伪代码。然后，通过使用交换方法将排序后的列表（数组B）存储在相同的输入数组中。
- en: '**Aim**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Implement the selection sort in Java
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中实现选择排序
- en: '**Prerequisites**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**先决条件**'
- en: 'Implement the sort method found in the following class, which is available
    on the GitHub repository for the book at the following path:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在以下类中实现排序方法，该类可在GitHub存储库的以下路径找到：
- en: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson2/activity/selectionsort/SelectionSort.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson2/activity/selectionsort/SelectionSort.java)'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson2/activity/selectionsort/SelectionSort.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson2/activity/selectionsort/SelectionSort.java)'
- en: The `sort` method should accept an integer array and sort it
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort`方法应该接受一个整数数组并对其进行排序'
- en: 'If you have your project set up, you can run the unit test for this activity
    by running the following command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经设置了你的项目，你可以通过运行以下命令来运行此活动的单元测试：
- en: '**`gradlew test --tests com.packt.datastructuresandalg.lesson2.activity.selectionsort*`**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**`gradlew test --tests com.packt.datastructuresandalg.lesson2.activity.selectionsort*`**'
- en: '**Steps for Completion**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: Split the input array in two by using an array index pointer
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用数组索引指针将输入数组分成两部分
- en: The `sort` method should accept an integer array and sort it
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sort`方法应该接受一个整数数组并对其进行排序'
- en: Iterate over the unsorted portion of the array to find the minimum
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历数组的未排序部分以找到最小值
- en: The minimum item is then swapped so that it can be added to the end of the sorted
    portion
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将最小项交换，以便它可以添加到排序部分的末尾
- en: Understanding Quick Sort
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解快速排序
- en: 'Quick sort is a big improvement over bubble sort. This sorting technique was developed
    by British computer scientist Tony Hoare. The algorithm works in three main steps:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序是冒泡排序的一个重大改进。这种排序技术是由英国计算机科学家托尼·豪尔开发的。算法主要分为三个步骤：
- en: Select a pivot
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个枢轴
- en: Partition the list so that elements on the left of the pivot are less than the value
    of the pivot and the ones on the right are greater
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对列表进行分区，使得枢轴左边的元素小于枢轴的值，而右边的元素大于枢轴的值
- en: Repeat steps 1 and 2 on the left and right parts separately
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分别对左部和右部重复步骤1和2
- en: Since recursion is required for quick sort, we will begin this section by giving
    an example of recursion. Later, we will see how the partitioning in the quick
    sort algorithm works, and in the end, we will put the recursion techniques to
    use in the final part.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于快速排序需要递归，我们将从这个部分开始，给出递归的一个例子。稍后，我们将看到快速排序算法中的分区是如何工作的，最后，我们将把递归技术用于最终部分。
- en: Understanding Recursion
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解递归
- en: 'Recursion is a really useful tool for algorithm designers. It allows you to
    solve large problems by solving a smaller occurrence of the same problem. Recursive
    functions usually have a common structure with the following components:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是算法设计者的一项非常有用的工具。它允许你通过解决相同问题的较小实例来解决大问题。递归函数通常具有以下组件的通用结构：
- en: '*One or more stopping conditions*: Under certain conditions, it would stop
    the function from calling itself again'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个或多个停止条件*：在特定条件下，它会停止函数再次调用自身'
- en: '*One or more recursive calls*: This is when a function (or method) calls itself'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个或多个递归调用*：这是指一个函数（或方法）调用自身'
- en: 'In the next example, we will pick the binary search problem seen in the previous
    chapter and change the algorithm to work in a recursive manner. Consider the binary
    search problem discussed in [Chapter 1](52b469c2-7203-4188-9e37-6ab0bf659ca7.xhtml),
    *Algorithms and Complexities*, listed in *Snippet 1.7*. The implementation is
    iterative, that is, it loops until an item is found or the `end` parameter is
    equal or greater than the `start` variable. The following code snippet shows pseudocode
    on how we can change this method into a recursive function:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将选择前一章中看到的二分查找问题，并将算法改为递归方式。考虑在 [第1章](52b469c2-7203-4188-9e37-6ab0bf659ca7.xhtml)
    中讨论的二分查找问题，*算法和复杂性*，如 *Snippet 1.7* 所列。实现是迭代的，也就是说，它循环直到找到项或 `end` 参数等于或大于 `start`
    变量。以下代码片段显示了如何将此方法转换为递归函数的伪代码：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Snippet 2.5: Recursive binary search pseudocode'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 'Snippet 2.5: 递归二分查找伪代码'
- en: There are actually two stopping conditions in a recursive binary search. The
    function stops the recursive chain if it either finds the search item at the midpoint
    or if the start array pointer is greater than the end, meaning the item wasn't
    found. The stopping condition can easily be found by examining any return paths
    that don't involve further recursive calls.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，递归二分查找中有两个停止条件。如果函数在中间找到搜索项，或者起始数组指针大于结束指针，意味着未找到该项，则停止递归链。可以通过检查任何不涉及进一步递归调用的返回路径来轻松找到停止条件。
- en: Implementing Binary Search Recursively
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现递归二分查找
- en: 'To implement binary search recursively in Java, we''ll follow these steps:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中实现递归二分查找，我们将遵循以下步骤：
- en: Using the pseudocode shown in *Snippet 2.5*, implement a recursive binary search
    function.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用如 *Snippet 2.5* 所示的伪代码实现递归二分查找函数。
- en: 'Provide another method with a signature that only contains the search item
    and the sorted array as input. This method will then call the recursive function
    with appropriate values as follows:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供另一个方法，其签名只包含搜索项和排序数组作为输入。然后，该方法将使用适当的值调用递归函数，如下所示：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Output**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: 'The following code shows the additional method making the initial call and
    the recursive function as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了进行初始调用和递归函数的附加方法：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Snippet 2.6: Recursive binary search. Source class name: BinarySearchRecursive'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 'Snippet 2.6: 递归二分查找。源类名：BinarySearchRecursive'
- en: Go to [https://goo.gl/pPaZVZ](https://goo.gl/pPaZVZ) to access the code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 访问代码请前往 [https://goo.gl/pPaZVZ](https://goo.gl/pPaZVZ)。
- en: Recursion is an essential tool for any developer and we'll make use of it in
    many parts in this book. In this section, we implemented an example for binary
    searching. In the next section, we shall look at how partitioning works in the
    quicksort algorithm.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是任何开发者的基本工具，我们将在本书的许多部分中使用它。在本节中，我们实现了一个二分查找的示例。在下一节中，我们将探讨快速排序算法中的分区是如何工作的。
- en: Quicksort Partitioning
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速排序分区
- en: Partitioning is the process by which we reorder our array so that elements with
    a value less than our pivot are moved to the left of the pivot and those with
    a larger value are moved to the right (see *Figure 2.2*). There are numerous manners
    in which we can do this. Here, we will describe an easy-to-understand scheme known
    as **Lomuto Partitioning**.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 分区是我们重新排列数组的进程，使得值小于我们的枢轴的元素被移动到枢轴的左侧，而值较大的元素被移动到右侧（见 *图2.2*）。我们可以用多种方式来做这件事。在这里，我们将描述一个易于理解的方案，称为
    **Lomuto 分区**。
- en: 'Take a look at this diagram:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个图：
- en: '![](img/b53ef27e-6226-464d-9cbd-ff60637422d3.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b53ef27e-6226-464d-9cbd-ff60637422d3.png)'
- en: 'Figure 2.2: Before and after partitioning of an array'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：数组分区前后的情况
- en: Many other schemes exist. The Lomuto scheme has the drawback that it is not
    very performant when it is used on already-sorted lists. The original Hoare partition
    scheme performs better and works by having the array processed from both ends.The
    original Hoare scheme performs better as it does fewer swaps, although it also
    suffers from slow performance when a sorted list is used as input. Both the Lomuto
    and Hoare schemes result in non-stable sorting. A stable sort means that if two
    or more elements have the same key value, they will appear in the same input order
    as the sorted output. There are other schemes that can be used to make quick sort
    stable, but they utilize more memory.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多其他方案。Lomuto 方案的一个缺点是，当它用于已排序的列表时，性能并不很好。原始的 Hoare 分区方案性能更好，它通过从两端处理数组来实现。原始的
    Hoare 方案由于交换次数较少，性能更好，尽管当使用已排序的列表作为输入时，它也可能会遭受性能缓慢的问题。Lomuto 和 Hoare 方案都会导致非稳定排序。稳定排序意味着如果两个或多个元素具有相同的键值，它们将按照输入顺序出现在排序输出中。还有其他方案可以使快速排序变得稳定，但它们会使用更多的内存。
- en: 'To get a good perception on this partitioning scheme, it is best to simplify
    what the algorithm is doing in five simple steps, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这种分区方案，最好将其简化为以下五个简单的步骤：
- en: Pick the right most element of the array as the pivot.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择数组的最右侧元素作为枢轴。
- en: Start from the left and find the next element that is larger than the pivot.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左侧开始，找到下一个大于枢轴的元素。
- en: Swap this element with the next, which is smaller than pivot element.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此元素与下一个小于枢轴元素的元素交换。
- en: Repeat steps 2 and 3 until no more swapping is possible.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤 2 和 3，直到不再可能进行交换。
- en: Swap the first item which is larger than the pivot's value with the pivot itself.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第一个大于枢轴值的元素与枢轴本身交换。
- en: To perform efficient partitioning using the steps mentioned, we can make use
    of two pointers, one pointing to the first item larger than the pivot value and
    the other used to search for the value that is smaller than pivot value.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用提到的步骤执行高效的分区，我们可以使用两个指针，一个指向第一个大于枢轴值的元素，另一个用于搜索小于枢轴值的值。
- en: 'In the following code, these are the integer pointers named `x` and `i`, respectively.
    The algorithm starts by choosing the pivot as the last item on the input array.
    It then processes the array from left to right in a single pass using the variable
    `i`. If the element currently being processed at `i` is smaller than the pivot,
    `x` is incremented and swapped. Using this technique, variable `x` is either pointing
    to a value larger than the pivot or the value of `x` is the same as `i`, in which
    case swapping will not modify the array. Once the loop exits, we perform the final
    step of swapping the first item that is larger than the pivot''s value with the
    pivot. The code is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，这些是分别命名为 `x` 和 `i` 的整数指针。算法首先选择输入数组中的最后一个项目作为枢轴。然后它使用变量 `i` 从左到右单次遍历数组。如果当前正在处理的
    `i` 位置的元素小于枢轴，则 `x` 增加，并交换。使用这种技术，变量 `x` 要么指向一个大于枢轴的值，要么 `x` 的值与 `i` 相同，在这种情况下，交换不会修改数组。一旦循环退出，我们执行最后一步，将第一个大于枢轴值的元素与枢轴本身交换。代码如下：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Snippet 2.7: Partitioning for quick sort. Source class name: QuickSort'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 片段 2.7：快速排序的分区。源类名：QuickSort
- en: Go to [https://goo.gl/vrStai](https://goo.gl/vrStai) to access the code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://goo.gl/vrStai](https://goo.gl/vrStai) 访问代码。
- en: 'Activity: Understanding the Partitioning Method'
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：理解分区方法
- en: '**Scenario**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: To better understand the partitioning method used in *Snippet 2.7*, walk through
    it one step at a time using an example.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解 *片段 2.7* 中使用的分区方法，请一步一步地使用示例进行操作。
- en: '**Aim**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: To understand how the Lomuto partitioning works.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 Lomuto 分区是如何工作的。
- en: '**Steps for completion**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: Dry run the code mentioned in *Snippet 2.7* for each element in the array by incrementing
    the values of variables `x` and `i`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过递增变量 `x` 和 `i` 的值，为数组中的每个元素运行 *片段 2.7* 中提到的代码的干运行。
- en: 'Complete the following table, assuming that the pivot is the last element of the
    list, that is, 16:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在假设列表的最后一个元素作为枢轴的情况下完成以下表格：
- en: '| **i** | **Array** | **x** |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| **i** | **数组** | **x** |'
- en: '| `-` | `[4, 5, 33, 17, 3, 21, 1, 16]` | `-1` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `-` | `[4, 5, 33, 17, 3, 21, 1, 16]` | `-1` |'
- en: '| `0` | `[4, 5, 33, 17, 3, 21, 1, 16]` | `0` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `[4, 5, 33, 17, 3, 21, 1, 16]` | `0` |'
- en: '| `1` |  |  |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `1` |  |  |'
- en: '| `2` | `[4, 5, 33, 17, 3, 21, 1, 16]` | `1` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `2` | `[4, 5, 33, 17, 3, 21, 1, 16]` | `1` |'
- en: '| `3` |  |  |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `3` |  |  |'
- en: '| `4` | `[4, 5, 3, 17, 33, 21, 1, 16]` | `2` |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `4` | `[4, 5, 3, 17, 33, 21, 1, 16]` | `2` |'
- en: '| `5` |  |  |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `5` |  |  |'
- en: '| `6` |  |  |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `6` |  |  |'
- en: '| `7` |  |  |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `7` |  |  |'
- en: '| final | `[4, 5, 3, 1, 16, 21, 17, 33]` | `3` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 最终 | `[4, 5, 3, 1, 16, 21, 17, 33]` | `3` |'
- en: 'Table 2.1: Steps through the partitioning method'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1：划分方法的步骤
- en: In this section, we have gained an understanding of how partitioning in quick
    sort works. In the next section, we'll put the partitioning method to use by including
    it in the full quick sort algorithm.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了快速排序中的划分是如何工作的。在下一节中，我们将通过将其包含在完整的快速排序算法中来使用划分方法。
- en: Putting It All Together
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整合所有内容
- en: The quick sort is from a class of algorithms called divide and conquer. We will
    see many other examples from this class in the book, and we will go into detail
    on divide and conquer in [Chapter 4](da07fa18-a8ce-4d4c-91eb-9dc893de7273.xhtml),
    *Algorithm Design Paradigms*. For now, it's important to know that divide and
    conquer algorithms keep on splitting the problem into smaller ones until the problem
    is small enough that it becomes trivial to solve. This splitting can be easily
    implemented using recursion.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序属于一种称为分而治之的算法类别。在本书中，我们将看到这个类别中的许多其他示例，我们将在第4章*算法设计范式*中详细介绍分而治之。现在，重要的是要知道，分而治之算法持续将问题划分为更小的部分，直到问题足够小，变得容易解决。这种划分可以通过递归轻松实现。
- en: 'In quick sorting, we keep on recursively partitioning the array in this manner
    until the problem is small enough that we can easily solve it. When the array
    has only one element, the solution is simple: the array stays exactly as it is,
    as there is nothing to sort. This is the stopping condition of our recursive algorithm.
    When the array is larger than one element, we can keep dividing our array and
    use the partitioning method we developed in the previous section.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在快速排序中，我们持续以这种方式递归地划分数组，直到问题足够小，我们可以轻松解决它。当数组只有一个元素时，解决方案很简单：数组保持完全不变，因为没有东西需要排序。这是我们的递归算法的停止条件。当数组包含一个以上的元素时，我们可以继续划分我们的数组，并使用我们在上一节中开发的划分方法。
- en: There is also a non-recursive quick sort algorithm which makes use of a stack
    data structure, although it is a bit more complex to write. We will discuss stacks
    and lists later on in this chapter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一种非递归的快速排序算法，它使用堆栈数据结构，尽管编写起来稍微复杂一些。我们将在本章的后面讨论堆栈和列表。
- en: 'The following code snippet shows the pseudocode for the complete quick sort.
    Just like most recursive functions, the code starts by checking the stopping condition.
    In this case, we check if the array has at least two elements by ensuring that
    the start array pointer is less than the end. The pseudocode is as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了完整快速排序的伪代码。就像大多数递归函数一样，代码首先检查停止条件。在这种情况下，我们通过确保起始数组指针小于结束来检查数组是否至少有两个元素。伪代码如下：
- en: '[PRE9]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Snippet 2.8: Recursive quick sort pseudocode'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 片段2.8：递归快速排序伪代码
- en: When we have at least two elements in the array, we call the partitioning method.
    Then, using the pivot's last position (returned by the partitioning method), we
    recursively quick sort the left part and then the right part.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当数组中至少有两个元素时，我们调用划分方法。然后，使用枢轴的最后一个位置（由划分方法返回），我们递归地对左部分进行快速排序，然后对右部分进行快速排序。
- en: This is done by calling the same quick sort code using pointers of `(start,
    p - 1)` and
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过使用`(start, p - 1)`和
- en: '`(p + 1, end)`, not including the `p`, which is the pivot''s position.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`(p + 1, end)`，不包括`p`，即枢轴的位置。'
- en: The trick to understanding how quick sort works is to realize that once we perform
    the partition call on the array, the element at the returned position (the pivot)
    doesn't need to move within the array anymore. This is because all the elements
    on its right are larger and the ones on the left are smaller, so the pivot is
    in the correct final position.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 理解快速排序工作原理的技巧是意识到，一旦我们对数组执行了划分调用，返回位置（枢轴）的元素就不再需要在数组中移动了。这是因为其右侧的所有元素都更大，左侧的所有元素都更小，所以枢轴处于正确的最终位置。
- en: Implementing Quick Sort
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现快速排序
- en: 'To implement quick sort in Java, follow these steps:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Java中实现快速排序，请按照以下步骤操作：
- en: Implement the pseudocode shown in *Snippet 2.8* in Java, calling the partitioning
    method shown in *Snippet 2.7*.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Java中实现*片段2.8*中显示的伪代码，调用*片段2.7*中显示的划分方法。
- en: 'The following code shows the recursive implementation in Java, making use of
    the partition method developed in the preceding section:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码显示了Java中的递归实现，使用了上一节中开发的划分方法：
- en: '[PRE10]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Snippet 2.9: Solution for quick sort. Source class name: Quicksort'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段 2.9：快速排序的解决方案。源类名：Quicksort
- en: In this section, we have described the quick sort algorithm, which is much faster
    than the bubble sort algorithm that we saw in the previous section. On average,
    this algorithm performs in *O(n log n)*, a huge improvement over bubble sort's
    *O(n²)*. However, in the worst case, the algorithm still performs in *O(n²)*.
    The worst-case input of quick sort depends on the type of partitioning scheme
    in use. In the Lomuto scheme discussed in this section, the worst case occurs
    when the input is already sorted. In the next section, we will examine another
    sorting algorithm for which the worst runtime case is *O(n log n)*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们描述了快速排序算法，它比我们在上一节中看到的冒泡排序算法快得多。平均而言，该算法的性能为 *O(n log n)*，比冒泡排序的 *O(n²)*
    有很大改进。然而，在最坏的情况下，该算法仍然以 *O(n²)* 的性能运行。快速排序的最坏情况输入取决于所使用的分区方案类型。在本节讨论的 Lomuto 方案中，最坏情况发生在输入已经排序的情况下。在下一节中，我们将考察另一种排序算法，其最坏运行时间复杂度为
    *O(n log n)*。
- en: Using Merge Sort
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用归并排序
- en: Although the quicksort on average is pretty fast, it still has the theoretical
    worst time complexity of *O(n²)*. In this section, we shall examine another sorting
    algorithm, called **merge sort**, in which the worst time complexity is *O(n log
    n)*. Similar to quick sort, merge sort belongs to the divide and conquer class
    of algorithms.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管快速排序平均来说非常快，但它仍然具有理论上的最坏时间复杂度 *O(n²)*。在本节中，我们将考察另一种排序算法，称为 **归并排序**，其最坏时间复杂度为
    *O(n log n)*。与快速排序类似，归并排序属于分治算法类别。
- en: 'Merge sort can be summarized in three simple steps as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 归并排序可以总结为以下三个简单步骤：
- en: Split the array in the middle
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在中间分割数组
- en: Recursively sort each part separately
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分别递归排序每个部分
- en: Merge the two sorted parts together
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个已排序的部分合并在一起
- en: In the following section, we will develop the preceding steps gradually, at
    each turn slowly building our understanding of how merge sorting works.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐步开发前面的步骤，每次都慢慢构建我们对归并排序工作原理的理解。
- en: Although merge sort is theoretically faster than quick sort, in practice, some
    implementations of quick sort can be more efficient than merge sort. Additionally,
    the merge sort uses about *O(n)* memory as opposed to quick sort, which is *O(log
    n)*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管归并排序在理论上比快速排序快，但在实践中，一些快速排序的实现可能比归并排序更高效。此外，归并排序大约使用 *O(n)* 的内存，而快速排序是 *O(log
    n)*。
- en: Dividing the Problem
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分解问题
- en: In the preceding section, we saw how we can use a recursive technique to split
    the problem into smaller multiple ones until the solution becomes easy to solve.
    Merge sort uses the same approach. The base case for our recursive technique is
    the same as quick sort. This is when the array is only one element long. When
    the array to sort only contains one item, the array is already sorted.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们看到了如何使用递归技术将问题分解成更小的多个问题，直到解决方案变得容易解决。归并排序使用了相同的方法。我们递归技术的基例与快速排序相同。这是当数组只有一个元素长时。当要排序的数组只包含一个项目时，数组已经是排序好的。
- en: '*Figure 2.3* shows how merge sort array splitting occurs. At each step, we
    find the midpoint of the array and split the array in two. We then recursively
    sort the left and right part of the split array separately. We can stop the recursive
    call once the total elements to sort is equal to one as shown in the following
    figure:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2.3* 展示了归并排序数组分割的过程。在每一步中，我们找到数组的中间点并将数组分成两部分。然后我们分别递归地对分割数组的左右部分进行排序。一旦要排序的总元素数等于一，我们就可以停止递归调用，如下面的图所示：'
- en: '![](img/31934f86-5e69-48c3-8cf4-2917b9760159.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31934f86-5e69-48c3-8cf4-2917b9760159.png)'
- en: Figure 2.3 Showing the dividing steps for the merge sort algorithm
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2.3* 展示归并排序算法的分割步骤'
- en: Implementing Merge Sort
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现归并排序
- en: We need to complete the pseudocode for a merge sort algorithm.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要完成归并排序算法的伪代码。
- en: 'Keeping in mind that the merge sort''s recursive part is very similar to the
    quick sort algorithm we saw in the preceding section, complete the pseudocode
    shown in the following code as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 记住归并排序的递归部分与我们在前一节中看到的快速排序算法非常相似，完成以下代码中的伪代码：
- en: '[PRE11]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Snippet 2.10: Recursive merge sort pseudocode exercise'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段 2.10：递归归并排序伪代码练习
- en: 'The pseudocode for merge sort can be completed as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 归并排序的伪代码可以完成如下：
- en: '[PRE12]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Snippet 2.11: Recursive merge sort pseudocode solution'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段 2.11：递归归并排序伪代码解决方案
- en: The merge sort algorithm is from the same class of algorithms as quick sort;
    however, its runtime and space complexity are different. Instead of dividing the
    array from the pivot's position, the merge sort always partitions the array at
    the midpoint. This is a similar process to binary search and results in *log[2]
    n* array divisions. In the next section, we will introduce the merge part of the
    merge sort algorithm, where the two different parts of the split array are combined
    into a sorted one.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 归并排序算法与快速排序算法属于同一类算法；然而，它们的运行时间和空间复杂度不同。归并排序不是从枢轴位置分割数组，而是始终在数组的中点进行分割。这与二分搜索的过程类似，导致*log[2]
    n*次数组分割。在下一节中，我们将介绍归并排序算法的合并部分，即将分割数组的两个不同部分合并成一个排序好的数组。
- en: Merging the Problem
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并问题
- en: How do you merge two sorted lists into a sorted one? This is the task of the
    `merge()` function, which is found at the end of the pseudocode shown in the preceding
    section. This process is shown in *Figure 2.4*. Merging two sorted lists is an
    easier task than sorting from scratch.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何将两个排序列表合并成一个排序列表？这是`merge()`函数的任务，该函数位于前一个部分伪代码的末尾。这个过程在*图2.4*中展示。合并两个排序列表比从头开始排序更容易。
- en: This is similar to the intersection problem we saw in [Chapter 1](52b469c2-7203-4188-9e37-6ab0bf659ca7.xhtml),
    *Algorithms and Complexities*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在[第1章](52b469c2-7203-4188-9e37-6ab0bf659ca7.xhtml)，“算法与复杂度”中看到的交集问题类似。
- en: 'We can merge in linear time utilizing just two pointers and an empty array
    as shown in the following diagram:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用两个指针和一个空数组在线性时间内进行合并，如下面的图所示：
- en: '![](img/deeaf0cf-05a5-4e78-991f-1bf79f1cd9e2.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/deeaf0cf-05a5-4e78-991f-1bf79f1cd9e2.png)'
- en: 'Figure 2.4: Before and after merging two sorted arrays'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：合并两个排序数组前后的情况
- en: Since the two parts of the split array are both sorted, it's easy to merge the
    two together. A useful analogy is to refer back to how the intersection problem
    we saw in [Chapter 1](52b469c2-7203-4188-9e37-6ab0bf659ca7.xhtml), *Algorithms
    and Complexities*, got a lot easier once the input arrays were both sorted. A
    similar algorithm can be used here.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于分割数组的两部分都是排序好的，所以合并它们很容易。一个有用的类比是回想一下，当我们看到[第1章](52b469c2-7203-4188-9e37-6ab0bf659ca7.xhtml)，“算法与复杂度”中的交集问题时，一旦输入数组都是排序好的，问题就变得容易多了。这里可以使用类似的算法。
- en: '[PRE13]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Snippet 2.12: Merge pseudocode for the merge sort'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段2.12：归并排序的合并伪代码
- en: In the merging part of the merge sort, we create a temporary array which is
    of size equal to the size of two array parts together. We then do a single pass
    on this array, filling the temporary array one item at a time by picking the smallest
    item between the two input lists (represented by the start, middle, and end pointers).
    After picking an item from one of the lists, we advance the pointer of that list
    and repeat until the merge is complete.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在归并排序的合并部分，我们创建一个临时数组，其大小等于两个数组部分的总和。然后我们对这个数组进行单次遍历，通过从两个输入列表（由起始、中间和结束指针表示）中选择最小的项，一次填充临时数组中的一个项目。从其中一个列表中选取一个项目后，我们前进该列表的指针，并重复此过程，直到合并完成。
- en: There are various Java tools we can use to implement the `copyArray()` function
    shown at the end of *Snippet 2.12*. We can simply implement a `for` loop and implement
    the `copy()` function ourselves. Alternatively, we can make use of Java's streams
    and write the copy in a single line. Possibly the easiest manner is to make use
    of the `System.arrayCopy()` function.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用各种Java工具来实现*代码片段2.12*末尾的`copyArray()`函数。我们可以简单地实现一个`for`循环并自己实现`copy()`函数。或者，我们可以利用Java的流并在一行中写入复制。可能最简单的方法是使用`System.arrayCopy()`函数。
- en: Merge sort is theoretically one of the fastest sorting algorithms. The drawback
    of its speed is that it consumes a bit more memory, although some implementations
    exist that perform the merge step in place to save memory.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 归并排序在理论上是最快的排序算法之一。其速度的缺点是它消耗更多的内存，尽管一些实现可以在原地执行合并步骤以节省内存。
- en: 'For comparison, we present multiple sorting techniques with their runtime and
    memory performances in the following table:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较，我们在下表中展示了多种排序技术及其运行时间和内存性能：
- en: '| **Algorithm name** | **Average case** | **Worst case** | **Memory** | **Stability**
    |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| **算法名称** | **平均情况** | **最坏情况** | **内存** | **稳定性** |'
- en: '| Bubble | *O(n²)* | *O(n²)* | *O(1)* | Stable |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 冒泡排序 | *O(n²)* | *O(n²)* | *O(1)* | 稳定 |'
- en: '| Selection | *O(n²)* | *O(n²)* | *O(1)* | Unstable |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 选择排序 | *O(n²)* | *O(n²)* | *O(1)* | 不稳定 |'
- en: '| Insertion | *O(n²)* | *O(n²)* | *O(1)* | Stable |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 插入排序 | *O(n²)* | *O(n²)* | *O(1)* | 稳定 |'
- en: '| Quick | *O(n log n)* | *O(n²)* | *O(1)* | Unstable |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 快速排序 | *O(n log n)* | *O(n²)* | *O(1)* | 不稳定 |'
- en: '| Merge | *O(n log n)* | *O(n log n)* | *O(n)* | Stable |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 合并 | *O(n log n)* | *O(n log n)* | *O(n)* | 稳定 |'
- en: '| Heap | *O(n log n)* | *O(n log n)* | *O(1)* | Unstable |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 堆 | *O(n log n)* | *O(n log n)* | *O(1)* | 不稳定 |'
- en: 'Table 2.2: Sorting algorithms'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.2：排序算法
- en: 'Activity: Implementing Merge Sort in Java'
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：在Java中实现归并排序
- en: '**Scenario**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: Merge sorting is one of the fastest sorting techniques. It is used in many bundled libraries
    and APIs. In this activity, we will write an algorithm in Java to sort an array using
    merge sort.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 归并排序是一种最快的排序技术。它在许多库和API中使用。在这个活动中，我们将用Java编写一个算法来对数组进行归并排序。
- en: '**Aim**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: To use the pseudocode shown in this section to implement the full merge sort algorithm
    in Java.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用本节中显示的伪代码在Java中实现完整的归并排序算法。
- en: '**Prerequisites**'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**先决条件**'
- en: 'To solve this activity, you have to implement the methods found in the following class,
    which is available on the GitHub repository for the book at the following path:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决此活动，您必须实现以下类中找到的方法，该类可在以下GitHub存储库路径处的书籍中找到：
- en: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson2/activity/mergesort/MergeSort.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson2/activity/mergesort/MergeSort.java)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson2/activity/mergesort/MergeSort.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson2/activity/mergesort/MergeSort.java)'
- en: 'If you have your project set up, you can run the unit test for this activity
    by running the following command:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已设置好项目，可以通过运行以下命令来运行此活动的单元测试：
- en: '**`gradlew test --tests com.packt.datastructuresandalg.lesson2.activity.mergesort*`**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**`gradlew test --tests com.packt.datastructuresandalg.lesson2.activity.mergesort*`**'
- en: '**Steps for Completion**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: Start from the `mergeSort` method, which splits the array in two, recursively sorts
    both, and merges the result
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`mergeSort`方法开始，该方法将数组分成两部分，递归地对两部分进行排序，然后合并结果
- en: Then, implement the merge method, which merges both ends of the split array
    into another space
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，实现合并方法，该方法将拆分数组的两端合并到另一个空间
- en: After the merge is done, copy the new array back in place of the input array
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 合并完成后，将新数组复制到输入数组的位置
- en: Getting Started with Fundamental Data Structures
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用基本数据结构
- en: Data structures are a way to organize data so that it is efficiently accessible
    for the problem you are trying to solve. Choosing the right data structure will
    depend on the type of problem you're trying to solve (dictating the manner you
    access your data), the amount of data you need to organize, and the medium you
    use to store your data (memory, disk, and so on).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构是一种组织数据的方式，以便它对于您试图解决的问题可以高效地访问。选择正确的数据结构将取决于您试图解决的问题类型（决定了您访问数据的方式）、您需要组织的数据量以及您用于存储数据的介质（内存、磁盘等）。
- en: We have already seen and used one example of a data structure. In the preceding
    sections, we have made extensive use of arrays. Arrays are the most primitive
    of data structures. They provide access to your data using an index and are fixed
    in size (also called static). This is opposed to other dynamic data structures
    that can grow and make more space for data whenever it's needed.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到并使用了一个数据结构的例子。在前面的章节中，我们已经广泛使用了数组。数组是最基本的数据结构。它们通过索引访问您的数据，并且大小固定（也称为静态）。这与其他动态数据结构形成对比，这些数据结构可以根据需要增长并腾出更多空间来存储数据。
- en: Introducing Data Structures
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构介绍
- en: 'More formally, a data structure is an organization of data elements, a collection
    of functions that can be applied on the data (such as add, delete, and search)
    and any relations between the different data elements. The following table shows
    common operations that some data structures provide:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 更正式地说，数据结构是数据元素的组织，是一组可以应用于数据的功能（如添加、删除和搜索）以及不同数据元素之间的任何关系。以下表格显示了某些数据结构提供的常见操作：
- en: '| **Operation** | **Type** | **Description** |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **类型** | **描述** |'
- en: '| `search(key)` | Non-modifying | An operation that, given the key to a particular value,
    will return the value stored in the data structure if it can be found. |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `search(key)` | 非修改 | 给定特定值的键，如果可以找到，将返回存储在数据结构中的值。 |'
- en: '| `side()` | Non-modifying | The total number of values stored in the data
    structure. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `size()` | 非修改 | 数据结构中存储的值的总数。|'
- en: '| `add(value)` | Modifying | Inserts a value in the data structure. |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `add(value)` | 修改 | 在数据结构中插入一个值。|'
- en: '| `update(key, value)` | Modifying | Updates an existing entry using the provided key
    and value. |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `update(key, value)` | 修改 | 使用提供的键和值更新现有条目。|'
- en: '| `delete(value)` | Modifying | Removes an item of data from the data structure.
    |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `delete(value)` | 修改 | 从数据结构中删除数据项。|'
- en: '| `minimum()` | Non-modifying | An operation supported only by ordered data structures,
    which will return the value with the minimal key. |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `minimum()` | 非修改 | 仅由有序数据结构支持的运算，将返回具有最小键的值。|'
- en: '| `maximum()` | Non-modifying | An operation supported only by ordered data structures,
    which will return the value with the minimal key. |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `maximum()` | 非修改 | 仅由有序数据结构支持的运算，将返回具有最小键的值。|'
- en: 'Table 2.3: Some common operations on data structures'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.3：数据结构的一些常见操作
- en: In this section, we will see various types of dynamic data structures. We will
    start with linked lists, which are optimized for dynamic growth but are slow while
    searching. Then, we'll use these linked lists to implement other data structures
    on top, such as queues and stacks.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到各种类型的动态数据结构。我们将从链表开始，链表优化了动态增长，但在搜索时较慢。然后，我们将使用这些链表在顶部实现其他数据结构，例如队列和栈。
- en: Linked Lists Structure
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链表结构
- en: A linked list is a list of data items where each item only knows about the next
    item in the list if there is one. *Figure 2.5* shows one such example. Each box
    in the figure represents a container for a data item we need to store. This container,
    called a node, contains our data values and a pointer to the next node in the
    list. As the diagram shows, the node on the front of the list is called the head
    of the list and the last item of the list is called the tail.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 链表是一系列数据项的列表，其中每个项如果存在的话，只知道列表中的下一个项。*图 2.5* 展示了这样一个例子。图中的每个框代表一个用于存储所需数据项的容器。这个容器，称为节点，包含我们的数据值和指向列表中下一个节点的指针。如图所示，列表前面的节点称为列表的头部，而列表的最后一个项称为尾部。
- en: 'Separate pointers to these nodes are stored for easy access of the data structure:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为这些节点存储单独的指针，以便于访问数据结构：
- en: '![](img/335eb13f-be8e-4b8f-bcdd-09dab74fb329.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/335eb13f-be8e-4b8f-bcdd-09dab74fb329.png)'
- en: 'Figure 2.5: Linked list example'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5：链表示例
- en: The advantage of using a linked list as opposed to an array is that a linked
    list can grow dynamically. When using an array, you allocate space in the start
    and that space remains fixed. If you allocate too much and the space remains unused,
    you're wasting resources. On the other hand, if you make your array too small,
    the data might not ft. In a linked list, however, the space is not fixed. The
    structure grows dynamically as you add more data and it shrinks, freeing memory
    space as you remove it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组相比，使用链表的优点是链表可以动态增长。当使用数组时，你在开始时分配空间，该空间保持固定。如果你分配了过多的空间而空间未被使用，你正在浪费资源。另一方面，如果你使数组太小，数据可能无法容纳。然而，在链表中，空间不是固定的。随着你添加更多数据，结构会动态增长，当你删除数据时，它会缩小，释放内存空间。
- en: Using an object-oriented language, such as Java, let's model the linked list
    using separate node instances that are connected together to build our linked
    list. The following code shows how we can model a linked list node in a Java class.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 使用面向对象的语言，例如 Java，我们可以使用独立的节点实例来模拟链表，这些节点实例连接在一起以构建我们的链表。以下代码展示了我们如何在 Java 类中模拟链表节点。
- en: The class contains a self-reference so we can link multiple nodes in list fashion,
    as shown in the *Figure 2.5*.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 该类包含一个自引用，因此我们可以像 *图 2.5* 中所示的那样以列表方式链接多个节点。
- en: '[PRE15]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Snippet 2.13: Linked list node class, with getters and setters omitted for
    brevity. Source class name: Linkedlistnode'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 碎片 2.13：链表节点类，为了简洁省略了获取器和设置器。源类名称：Linkedlistnode
- en: Go to [https://goo.gl/SAefic](https://goo.gl/SAefic) to access the code.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://goo.gl/SAefic](https://goo.gl/SAefic) 访问代码。
- en: Notice how we use Java's optional classes (instead of returning null pointers)
    to represent whether there is a link to the next node. The tail node of a linked
    list will always have an empty optional. We also make use of generics to model
    the type of data we want to store. This way, we can keep the structure as general
    as possible so that it can used by any data type.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何使用Java的可选类（而不是返回null指针）来表示是否存在对下一个节点的链接。链表的尾节点将始终有一个空的optional。我们还利用泛型来模拟我们想要存储的数据类型。这样，我们可以保持结构尽可能通用，以便它可以用于任何数据类型。
- en: The `Optional` class was introduced in Java 8 to give the ability to represent
    optional values instead of using nulls.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional`类是在Java 8中引入的，以便能够表示可选值而不是使用null。'
- en: Converting the Linked List to a Doubly Linked List Structure
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将链表转换为双向链表结构
- en: We need to modify the Java node class to support the doubly linked list structure.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改Java节点类以支持双向链表结构。
- en: A doubly linked list is a linked list in which each node contains a relation
    to the following and previous nodes. Modify the preceding code in *Snippet 2.13*
    to support this.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 双向链表是一种链表，其中每个节点都包含对下一个和前一个节点的引用。将*片段2.13*中的代码修改为支持这一点。
- en: 'The following code shows the solution to this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了这一解决方案：
- en: '[PRE16]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Snippet 2.14: Doubly linked list node class, with getters and setters omitted
    for brevity. Source class name: Dbllinkedlistnode'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 片段2.14：双向链表节点类，省略了getters和setters以节省空间。源类名：Dbllinkedlistnode
- en: Go to [https://goo.gl/oJDQ8g](https://goo.gl/oJDQ8g) to access the code.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[https://goo.gl/oJDQ8g](https://goo.gl/oJDQ8g)访问代码。
- en: In a doubly linked list, the head node will have a null previous pointer while
    the tail node will have a null next pointer.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在双向链表中，头节点将有一个null的前一个指针，而尾节点将有一个null的下一个指针。
- en: In this section, we saw how to model a linked list node using classes, generics,
    and optional references. In the next section, we shall see how to implement some
    of the linked list operations.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何使用类、泛型和可选引用来模拟链表节点。在下一节中，我们将看到如何实现一些链表操作。
- en: Linked Lists Operations
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链表操作
- en: Before we can use any linked list operations, we need to initialize the data
    structure and mark it as empty. Conceptually, this is when the head of the list
    is pointing to nothing. We can do this in Java by adding this logic in a constructor.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使用任何链表操作之前，我们需要初始化数据结构并将其标记为空。从概念上讲，这是当列表头指向空时。我们可以在Java中通过在构造函数中添加此逻辑来实现这一点。
- en: 'The following code snippet shows this. Notice that, once again, we use generics
    to hold the type of the items we want to store in the linked list:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了这一点。注意，我们再次使用泛型来保存我们想要存储在链表中的项的类型：
- en: '[PRE17]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Snippet 2.15: Initializing the linked list data structure using constructors.
    Source class name: Linkedlist'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 片段2.15：使用构造函数初始化链表数据结构。源类名：Linkedlist
- en: Go to [https://goo.gl/vxpkRt](https://goo.gl/vxpkRt) to access the code.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[https://goo.gl/vxpkRt](https://goo.gl/vxpkRt)访问代码。
- en: 'How can we add and remove items from the head of the list? Adding a node in
    a linked list requires a two pointer reassignment. On the new node, you set the
    next pointer to point to whatever the head pointer is assigned to. Then, you set
    the head pointer to point to this newly created node. This process is shown in
    *Figure 2.6*. Deleting from the front of the list is the reverse. You set the
    head pointer to point to the next pointer of the node at the old head. For completeness,
    you can set this next pointer to point to nothing:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何从链表头部添加和删除项目？在链表中添加节点需要两个指针重新分配。在新节点上，你将下一个指针设置为指向头指针所分配的任何内容。然后，你将头指针设置为指向这个新创建的节点。这个过程在*图2.6*中展示。从列表头部删除是相反的过程。你将头指针设置为指向旧头节点的前一个指针。为了完整性，你可以将这个下一个指针设置为指向空：
- en: '![](img/9d869c0c-805c-4240-888a-808d38be4d54.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9d869c0c-805c-4240-888a-808d38be4d54.png)'
- en: 'Figure 2.6: Adding a node to the front of the list'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：向列表头部添加节点
- en: To locate an item in a list, we need to traverse the entire list until we find
    the item we're searching or reach the end of the list. This can be done easily
    by starting at the head pointer and always following the node's next pointer until
    you either find the node with the value you're looking for or you run out of nodes.
    For example, the next pointer is a null one.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 要在列表中定位一个项目，我们需要遍历整个列表，直到我们找到我们正在搜索的项目或到达列表的末尾。这可以通过从头指针开始，并始终跟随节点的下一个指针来实现，直到你找到你正在寻找的值的节点或没有更多的节点。例如，下一个指针是一个null。
- en: '[PRE18]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The code is as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE19]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Snippet 2.16: Adding and deleting from the front of the linked list. Source
    class name: Linkedlist'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段2.16：从链表的前端添加和删除。源类名：Linkedlist
- en: Go to [https://goo.gl/D5NAoT](https://goo.gl/D5NAoT) to access the code.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[https://goo.gl/D5NAoT](https://goo.gl/D5NAoT)访问代码。
- en: '[PRE20]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Snippet 2.17: Adding and deleting from the front of the linked list. Source
    class name: Linkedlist'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段2.17：从链表的前端添加和删除。源类名：Linkedlist
- en: Go to [https://goo.gl/6pQm3T](https://goo.gl/6pQm3T) to access the code. The
    `find()` method on a linked list has the worst runtime complexity of *O(n)*. This
    happens when either the matching item is at the end of the list or the item is
    not in the list at all.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[https://goo.gl/6pQm3T](https://goo.gl/6pQm3T)访问代码。链表上的`find()`方法具有最差的运行时间复杂度*O(n*)。这种情况发生在匹配项位于列表末尾或者项根本不在列表中时。
- en: 'In the preceding example, we have shown how to add an item at the head of the
    list. How can we insert this into a linked list at an arbitrary point? *Figure
    2.7* shows how we can do this in two steps:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们展示了如何将项添加到列表的头部。我们如何将这个操作插入到链表的任意位置？*图2.7*展示了如何分两步进行：
- en: '![](img/6bb7a80c-3e61-4cd4-940b-61298bba2e4d.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6bb7a80c-3e61-4cd4-940b-61298bba2e4d.png)'
- en: 'Figure 2.7: Adding a node at an arbitrary position in the list'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：在列表的任意位置添加节点
- en: '*Snippet 2.18* shows how we can do this. It is a Java method called `addAfter()` accepting
    a node and an item to insert. The method adds a node, containing the item, after
    the `aNode` argument. The implementation follows the steps shown in *Figure 2.7*.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码片段2.18*展示了如何进行此操作。这是一个名为`addAfter()`的Java方法，接受一个节点和一个要插入的项。该方法在`aNode`参数之后添加一个包含项的节点。实现遵循*图2.7*中显示的步骤。'
- en: '[PRE23]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Snippet 2.18: Solution method for addAfter operation. Source class name: Linkedlist'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段2.18：`addAfter`操作的解决方案方法。源类名：Linkedlist
- en: Go to [https://goo.gl/Sjxc6T](https://goo.gl/Sjxc6T) to access this code.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[https://goo.gl/Sjxc6T](https://goo.gl/Sjxc6T)访问此代码。
- en: 'Activity: Traversing the Linked List'
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：遍历链表
- en: '**Scenario**'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: We have a linked list containing some elements and we need to build a string
    of the form `[3,6,4,2,4]`. If the list is empty, it should output `[]`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个包含一些元素的链表，我们需要构建一个形式为`[3,6,4,2,4]`的字符串。如果列表为空，则应输出`[]`。
- en: '**Aim**'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: To write code in Java for traversing the linked list.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 为遍历链表编写Java代码。
- en: '**Steps for Completion**'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: 'Write a `toString()` method in the `LinkedList` class as follows:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LinkedList`类中编写一个`toString()`方法，如下所示：
- en: '[PRE24]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Use a `while` loop to traverse the linked list.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`while`循环遍历链表。
- en: In this section, we have seen how we can implement the various operations found
    in the linked list. The data structure will be a base tool that we will use to
    model queues and stacks. Linked lists will also be extensively used in more advanced
    algorithms further along the book.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何实现链表中找到的各种操作。这种数据结构将成为我们将用来模拟队列和栈的基本工具。链表也将在本书更后面的更高级算法中得到广泛的应用。
- en: Queues
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列
- en: Queues are abstract data structures that are meant to emulate the workings of
    real life queues. They are used extensively in various applications, such resource
    allocation, scheduling, sorting, and many others. They are typically implemented
    using a double linked list, although many other implementations exists. A queue
    usually consists of two operations; an `enqueue` operation, where items are added
    to the rear of the queue, and an opposite `dequeue` operation, where items are
    removed from the front of the queue. These two operations make the mode of operation
    of this data structure **First In First Out** (**FIFO**).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 队列是抽象数据结构，旨在模拟现实生活中的队列工作方式。它们在各种应用中被广泛使用，例如资源分配、调度、排序等。它们通常使用双链表实现，尽管存在许多其他实现。队列通常包含两个操作；一个`enqueue`操作，其中项被添加到队列的尾部，以及一个相反的`dequeue`操作，其中项从队列的前端被移除。这两个操作使得这种数据结构的操作模式为**先进先出**（**FIFO**）。
- en: 'We can implement an efficient queue using a double linked list. This enables
    us implement the `dequeue` operation by removing an item from the head of the
    linked list. `enqueue` is simply adding an item to the tail of the linked list.
    *Figure 2.8* shows how the two operations are performed:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用双链表实现一个高效的队列。这使我们能够通过从链表头部移除项来实现`dequeue`操作。`enqueue`操作简单地将项添加到链表的尾部。*图2.8*展示了这两个操作是如何执行的：
- en: '![](img/05f0f5c4-28b6-4eb2-8e4f-cfe31143e049.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/05f0f5c4-28b6-4eb2-8e4f-cfe31143e049.png)'
- en: 'Figure 2.8: Enqueuing and dequeuing using a double linked list'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8：使用双链表进行入队和出队
- en: 'To dequeue an item using a double linked list as a base data structure, we
    just need to move the head to the next item in the list and unlink the old head
    by pointing the previous pointer to nothing. Enqueuing at the tail is a three-step
    process. Point the new node''s preceding pointer to the current tail, then point
    the current tail''s next pointer to the new node, and finally moving the tail
    to the new node. The pseudocode for both of these operations is shown in the following
    code snippet:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用双链表作为基本数据结构来出队一个元素，我们只需将头部移动到列表中的下一个元素，并通过将前一个指针指向空来解除旧头部的链接。在尾部入队是一个三步过程。将新节点的先前指针指向当前尾部，然后将当前尾部的下一个指针指向新节点，最后将尾部移动到新节点。这两个操作的伪代码如下所示：
- en: '[PRE25]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Snippet 2.19: Enqueuing and dequeuing using a doubly linked list'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段2.19：使用双链表进行入队和出队。源类名：Queue
- en: Adding and Deleting the Elements from the Queue
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从队列中添加和删除元素
- en: 'To implement the `enqueue()` and `dequeue()` methods in Java, follow these
    steps:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Java 中实现 `enqueue()` 和 `dequeue()` 方法，请按照以下步骤操作：
- en: 'Using a double linked list, implement the dequeue and enqueue pseudocode shown
    in the preceding code in Java. Follow the structure and method signature shown
    in the following code snippet:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用双链表实现前述代码中的 dequeue 和 enqueue 伪代码。遵循以下代码片段中的结构和方法签名：
- en: '[PRE26]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Snippet 2.20: Exercise class structure and method signatures'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段2.20：练习类结构和方法签名
- en: 'The `enqueue()` method can be implemented as shown in the following code:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`enqueue()` 方法可以按照以下代码所示实现：'
- en: '[PRE27]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Snippet 2.21: Exercise class structure and method signatures. Source class
    name: Queue'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段2.21：练习类结构和方法签名。源类名：Queue
- en: Go to [https://goo.gl/FddeYu](https://goo.gl/FddeYu) to access the code for
    `dequeue()` method.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://goo.gl/FddeYu](https://goo.gl/FddeYu) 访问 `dequeue()` 方法的代码。
- en: Queues are dynamic data structures that have a FIFO ordering. In the next section, we
    shall explore another data structure with a different ordering called a stack.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 队列是具有 FIFO 排序的动态数据结构。在下一节中，我们将探讨另一种具有不同排序的数据结构，称为栈。
- en: Stacks
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈
- en: 'Stacks, typically also implemented using linked lists, work differently than
    queues. Instead of the FIFO ordering, they have a **Last In First Out** (**LIFO**)
    ordering (see *Figure 2.9*). They have two main operations called push, which
    adds an item on top of the stack, and pop, which removes and returns one item
    from the top of the stack. Like queues, stacks are heavily used in many algorithms,
    such as depth first search traversal, expression evaluations, and many others:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 栈通常也使用链表实现，其工作方式与队列不同。它们不是 FIFO 排序，而是具有 **后进先出**（**LIFO**）排序（见 *图2.9*）。它们有两个主要操作，称为
    push，它将一个项添加到栈顶，以及 pop，它从栈顶移除并返回一个项。像队列一样，栈在许多算法中都有广泛的应用，例如深度优先搜索遍历、表达式评估等：
- en: '![](img/9fcff6f4-1791-4ac3-a673-b1f420fdc65a.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9fcff6f4-1791-4ac3-a673-b1f420fdc65a.png)'
- en: 'Figure 2.9: Pushing and popping operations on a stack of papers'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9：在纸张栈上的push和pop操作
- en: To model a stack, it's enough to use a simple linked list. The head of the linked
    list can be used to reference the top of the stack. Every time we need to push
    something on the top of our stack, we can use the `addFront()` method we developed
    in the preceding sections. The implementations differ only in the fact that the
    pop operation returns the optional item on the top of the stack. Both push and
    pop can been seen in the Java implementation in the following code snippet. Notice
    how the pop operations return an optional value which is populated if the stack
    is not empty.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 要模拟一个栈，使用一个简单的链表就足够了。链表的头部可以用来引用栈顶。每次我们需要在栈顶添加某个元素时，我们都可以使用在前几节中开发的 `addFront()`
    方法。实现的不同之处仅在于弹出操作返回栈顶的可选项。以下代码片段中的 Java 实现显示了 push 和 pop 操作。注意，弹出操作返回一个可选值，如果栈不为空，则该值被填充。
- en: 'A one-way linked list is enough to model a stack since we only need to operate
    from one end of the list. For a queue, we needed to modify both the head and tail
    of the linked list, hence it was more efficient to use a double linked list. The
    following code shows the implementation of the `push()` and `pop()` methods:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只需要从列表的一端进行操作，因此使用单向链表就足以模拟栈。对于队列，我们需要修改链表的头部和尾部，因此使用双链表更有效率。以下代码显示了 `push()`
    和 `pop()` 方法的实现：
- en: '[PRE28]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Snippet 2.22: Push and pop operations in java. Source class name: Stack'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段2.22：Java中的push和pop操作。源类名：Stack
- en: Go to [https://goo.gl/uUhuqg](https://goo.gl/uUhuqg) to access the code.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[https://goo.gl/uUhuqg](https://goo.gl/uUhuqg)以获取代码。
- en: Reversing a String
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反转字符串
- en: We need to make use of a stack data structure for reversing a string.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用栈数据结构来反转字符串。
- en: 'Follow these steps:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行：
- en: 'To reverse the string, push of each character of the input string and then pop
    everything out, one at a time, building a reversed string. The method signature
    can be as follows:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要反转字符串，将输入字符串的每个字符推入栈中，然后逐个弹出所有字符，构建一个反转的字符串。方法签名可以如下所示：
- en: '[PRE29]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following code shows how a string can be reversed using the stack data structure:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码展示了如何使用栈数据结构来反转字符串：
- en: '[PRE30]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Snippet 2.23: Reverse a string solution Source class name: StringReverse'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 'Snippet 2.23: 反转字符串解决方案。源类名：StringReverse'
- en: Go to [https://goo.gl/UN2d5U](https://goo.gl/UN2d5U) to access the code.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[https://goo.gl/UN2d5U](https://goo.gl/UN2d5U)以获取代码。
- en: Stack data structures are extensively used in computer science for many algorithms.
    In this section, we have seen how to implement them in a dynamic fashion using
    linked lists. In the next section, we shall see how to model stacks and queue
    in a static manner using arrays.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 栈数据结构在计算机科学中广泛用于许多算法。在本节中，我们看到了如何使用链表动态实现它们。在下一节中，我们将看到如何使用数组以静态方式模拟栈和队列。
- en: Modeling Stacks and Queues Using Arrays
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数组模拟栈和队列
- en: Stacks and queues don't necessarily need to be dynamic. You may want a more
    concise implementation if you know your data requirements are of a fixed size.
    Using an array approach to model stacks and queues guarantees that your data structure
    will only grow up to a certain size. The other advantage of using an array is
    that the array approach is more memory efficient if you can live with having a
    static data structure. The catch with static data structures is that the queue
    or stack can only grow to a maximum fixed size of your initially allocated array.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 栈和队列不一定需要是动态的。如果你知道你的数据需求是固定大小的，你可能希望有一个更简洁的实现。使用数组方法来模拟栈和队列可以保证你的数据结构只会增长到一定的大小。使用数组的另一个优点是，如果你可以接受静态数据结构，数组方法在内存效率上更高。静态数据结构的缺点是，队列或栈只能增长到最初分配的数组的最大固定大小。
- en: 'Implementing a stack using an array involves first initializing an empty array
    with a fixed size. Then, it''s a matter of keeping an index pointer to the top
    of the stack, initially pointing to zero. As we push items on the stack, we place
    the item at this index and increment the pointer by one. When we need to pop an
    element, we reduce this pointer by one and read the value. This process is shown
    in the following code:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组实现栈首先需要初始化一个具有固定大小的空数组。然后，我们需要保持一个指向栈顶的索引指针，最初指向零。当我们向栈中推入项目时，我们将项目放置在这个索引处，并将指针递增一个。当我们需要弹出元素时，我们减少这个指针的值并读取值。这个过程在以下代码中展示：
- en: '[PRE31]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Snippet 2.24: Stack using an array instead of linked list. Source class name:
    Stackarray'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 'Snippet 2.24: 使用数组而不是链表实现栈。源类名：Stackarray'
- en: Go to [https://goo.gl/T61L33](https://goo.gl/T61L33) to access the code
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[https://goo.gl/T61L33](https://goo.gl/T61L33)以获取代码
- en: Implementing a queue using an array requires a little more thinking. The difficulty
    with a queue is that the structure is modified from both ends since it grows from
    the tail and shrinks from the head.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组实现队列需要更多的思考。队列的困难在于结构从两端都被修改，因为它从尾部增长，从头部缩小。
- en: 'As we enqueue and dequeue the contents of the queue, it seems to be moving
    towards the right of the array. We need to deal with what happens when the contents
    reaches the end of our array. To make the queue work in an array, we just need
    to let our data wrap around the edges (think *Pacman*, *Figure 2.10*):'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们入队和出队队列的内容时，它似乎正在向数组的右侧移动。我们需要处理当内容达到数组末尾时会发生什么。为了使队列在数组中工作，我们只需让我们的数据在边缘环绕（想想*吃豆人*，*图2.10*）：
- en: '![](img/2e942fe9-67f4-4fcd-9f60-bf6ba43bc06d.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e942fe9-67f4-4fcd-9f60-bf6ba43bc06d.png)'
- en: 'Figure 2.10: Array wrap around analogy'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10：数组环绕类比
- en: '[PRE32]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The implementation in *Snippet 2.25* does not check if the circular buffer is
    full before enqueuing another item. Implementing this check is given as an exercise
    in the next section.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Snippet 2.25*中的实现没有在入队另一个项目之前检查循环缓冲区是否已满。在下一节中，将此检查作为练习给出。
- en: '[PRE33]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Snippet 2.25: Enqueue and dequeue using an array. Source class name: QueueArray'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 'Snippet 2.25: 使用数组进行入队和出队。源类名：QueueArray'
- en: Go to [https://goo.gl/LJuYz9](https://goo.gl/LJuYz9) to access this code.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[https://goo.gl/LJuYz9](https://goo.gl/LJuYz9)以获取此代码。
- en: Safe Enqueuing in an Array
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组中的安全入队
- en: We need to write a safe `enqueue()` method that will fail when the queue is
    full.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编写一个安全的 `enqueue()` 方法，当队列满时将失败。
- en: 'Steps for completion:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 完成步骤：
- en: Modify the enqueue and dequeue methods shown in the preceding code so that the
    enqueue returns a Boolean value which is `false` when the queue is full and cannot
    accept further elements.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改前面代码中显示的入队和出队方法，以便入队返回一个布尔值，当队列满且无法接受更多元素时为 `false`。
- en: 'Implement the method signatures as follows:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式实现方法签名：
- en: '[PRE34]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following *Snippet 2.26* provides an implementation of the `enqueueSafe()` method,
    returning a Boolean value when the queue is full:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下 *代码片段2.26* 提供了 `enqueueSafe()` 方法的实现，当队列满时返回一个布尔值：
- en: '[PRE35]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Snippet 2.26: Safe Enqueue and dequeue solution. Source class name: QueueArray'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段2.26：安全的入队和出队解决方案。源类名：QueueArray
- en: Go to [https://goo.gl/cBszQL](https://goo.gl/cBszQL) to access the code for
    implementation of `dequeueSafe()` method.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://goo.gl/cBszQL](https://goo.gl/cBszQL) 获取 `dequeueSafe()` 方法实现的代码。
- en: We have seen how both queues and stacks can be implemented using a static array
    structure instead of using the dynamic linked list. This has the advantage of
    consuming less memory per element as a linked list has to store pointers to other
    nodes. However, this comes at the cost of having a limit on the structure size.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用静态数组结构而不是使用动态链表来实现队列和栈。这具有每个元素消耗更少内存的优点，因为链表必须存储指向其他节点的指针。然而，这以结构大小有限为代价。
- en: 'Activity: Evaluating the Postfix Expression'
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：评估后缀表达式
- en: '**Scenario**'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: 'We are used to writing mathematical expressions in the form of *1 + 2 * 3*.
    This type of notation is called an **infix**. Using infix notation, an operator
    is always in between two operators. There is a different notation called postfix,
    where the operator is after the operands. Examples of such expressions are shown
    in the following table:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们习惯于用 *1 + 2 * 3* 的形式编写数学表达式。这种表示法称为 **中缀**。使用中缀表示法，运算符始终位于两个运算符之间。还有一种不同的表示法称为后缀，其中运算符位于操作数之后。以下表格显示了此类表达式的示例：
- en: '| **Infix expression** | **Postfix expression** |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| **中缀表达式** | **后缀表达式** |'
- en: '| 1 + 2 | 1 2 + |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| 1 + 2 | 1 2 + |'
- en: '| 1 + 2 * 3 | 1 2 3 * + |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| 1 + 2 * 3 | 1 2 3 * + |'
- en: '| (1 + 2) * 3 | 1 2 + 3 * |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| (1 + 2) * 3 | 1 2 + 3 * |'
- en: '| 5 + 4 / 2 * 3 | 5 4 2 / 3 * + |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| 5 + 4 / 2 * 3 | 5 4 2 / 3 * + |'
- en: '**Aim**'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Implement an algorithm that accepts a postfix string, evaluates it, and returns the
    result.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个算法，该算法接受一个后缀字符串，评估它，并返回结果。
- en: '**Prerequisites**'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '**先决条件**'
- en: Implement the following method in the class which is available on the
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可用的类中实现以下方法
- en: 'GitHub repository for the book at the following path:'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下路径的GitHub书籍仓库：
- en: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson2/activity/postfix/EvalPostfix.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson2/activity/postfix/EvalPostfix.java)'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson2/activity/postfix/EvalPostfix.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson2/activity/postfix/EvalPostfix.java)'
- en: '[PRE36]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Assume the operator and operands are always separated by a space, such as *"5
    2 +"*. The input string will look like the examples shown in the preceding table.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设运算符和操作数总是由空格分隔，例如 *"5 2 +"*。输入字符串将类似于前面表格中显示的示例。
- en: 'If you have your project set up, you can run the unit test for this activity
    by running the following command:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经设置了项目，可以通过运行以下命令来运行此活动的单元测试：
- en: '**`gradlew test --tests com.packt.datastructuresandalg.lesson2.activity.postfix*`**'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '**`gradlew test --tests com.packt.datastructuresandalg.lesson2.activity.postfix*`**'
- en: The solution becomes a lot simpler if you use one of the data structures we
    studied in this section.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用本节学习的一种数据结构，解决方案会变得简单得多。
- en: '**Steps for Completion**'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: Use the stack data structure to solve this problem
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用栈数据结构来解决这个问题
- en: Start processing the expression from left to right
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左到右开始处理表达式
- en: If you encounter a numeric operand, push it on the stack
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果遇到数字操作数，将其推入栈中
- en: If you encounter an operator, pop two items from the stack and perform the operation
    accordingly (addition, subtraction, and so on) and push the result back on the
    stack
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果遇到运算符，从栈中弹出两个项目并相应地执行操作（加法、减法等），然后将结果推回栈中
- en: Once you have processed the entire expression, the result should be the on the
    top of the stack
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦处理完整个表达式，结果应该位于栈顶
- en: Summary
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we laid the foundations for the more complex upcoming sections.
    In the first few sections, we saw how a simple problem such as sorting can have
    many solutions, all with different performance properties. We explored three main
    implementations, which were bubble, quick, and merge sort.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为即将到来的更复杂章节奠定了基础。在前几节中，我们看到了一个简单问题，如排序，可以有多个解决方案，它们都具有不同的性能特性。我们探索了三种主要实现，即冒泡排序、快速排序和归并排序。
- en: In later sections, we introduced data structures and studied various implementations
    and use cases of linked lists, queues, and stacks. We also saw how some data structures
    can be used as building blocks to build more complex ones on top. In the next
    chapter, we will study hash tables and binary trees, two important and widely
    used data structures.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的章节中，我们介绍了数据结构，并研究了链表、队列和栈的各种实现和使用案例。我们还看到了一些数据结构如何作为构建块，在它们之上构建更复杂的数据结构。在下一章，我们将研究哈希表和二叉树，这两种重要且广泛使用的数据结构。
