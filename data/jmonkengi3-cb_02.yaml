- en: Chapter 2. Cameras and Game Controls
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 相机和游戏控制
- en: 'This chapter contains the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含以下食谱：
- en: Creating a reusable character control
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可重用的角色控制
- en: Attaching an input AppState object
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附加输入 AppState 对象
- en: Firing in FPS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 FPS 中开火
- en: Firing non-instant bullets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开射非即时子弹
- en: Creating an RTS camera AppState object
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 RTS 相机 AppState 对象
- en: Selecting units in RTS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 RTS 中选择单位
- en: Making the camera follow units
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让相机跟随单位
- en: Following a character with ChaseCamera
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ChaseCamera 追踪角色
- en: Adding a game controller and joystick input
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加游戏控制器和游戏手柄输入
- en: Leaning around corners
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在角落里倾斜
- en: Detecting cover automatically in a third-person game
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第三人称游戏中自动检测掩护
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter is about controlling avatars and cameras for various game types.
    Whether your game is a **first person shooter** (**FPS**), **role playing game**
    (**RPG**), or **real-time strategy** (**RTS**) game, you'll learn some tricks
    that will help you get past tricky obstacles.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于控制各种游戏类型的角色和相机。无论你的游戏是**第一人称射击**（**FPS**）、**角色扮演游戏**（**RPG**）还是**实时策略**（**RTS**）游戏，你将学习一些技巧，帮助你克服困难障碍。
- en: The chapter will rely heavily on the `ActionListener` and `AnalogListener` interfaces.
    These are essential when listening for the player input in jMonkeyEngine. The
    `ActionListener` interface will pick up any binary input such as keyboard keys
    or mouse buttons. The `AnalogListener` interface listens for mouse and joystick
    movements and other input that is either on or off.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将大量依赖 `ActionListener` 和 `AnalogListener` 接口。在 jMonkeyEngine 中监听玩家输入时，这些接口是必不可少的。`ActionListener`
    接口将捕获任何二进制输入，如键盘按键或鼠标按钮。`AnalogListener` 接口监听鼠标和游戏手柄的移动以及其他开/关输入。
- en: Creating a reusable character control
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可重用的角色控制
- en: To start off the chapter, we will create a class that we can use for various
    character-controlled purposes. The example describes an FPS character, but the
    method is the same for any player-controlled character.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始本章，我们将创建一个可以用于各种角色控制目的的类。示例描述了一个 FPS 角色，但这种方法适用于任何玩家控制的角色。
- en: The `Control` class we'll build will be based on `BetterCharacterControl`. It
    might be a good idea to have a look at the class or the `TestBetterCharacter`
    example from the jMonkeyEngine test package if you want to find out how this works.
    Another good starting point would be the input examples from the same package.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的 `Control` 类将基于 `BetterCharacterControl`。如果你想知道这是如何工作的，查看 jMonkeyEngine
    测试包中的类或 `TestBetterCharacter` 示例可能是个好主意。另一个好的起点是查看同一包中的输入示例。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `BetterCharacterControl` class is based on physics and requires a `BulletAppState`
    class to be set up in the application. The steps required to do this are described
    in the *The ImageGenerator class* section in [Appendix](apa.html "Appendix A. Information
    Fragments"), *Information Fragments*. To find out more about bullet and physics,
    refer to [Chapter 8](ch08.html "Chapter 8. Physics with Bullet"), *Physics with
    Bullet*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`BetterCharacterControl` 类基于物理，需要在应用程序中设置 `BulletAppState` 类。完成此所需的步骤在附录 *The
    ImageGenerator class* 部分的 *Information Fragments* 中描述，*信息片段*。要了解更多关于子弹和物理的信息，请参阅
    *第8章*，*使用 Bullet 的物理*。'
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Perform the following set of steps to create a reusable character control:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤集以创建可重用的角色控制：
- en: 'Start by creating a new class called `GameCharacterControl`, which extends
    `BetterCharacterControl`. This class also needs to implement `ActionListener`
    and `AnalogListener`. The idea here is to feed this class with actions that it
    can handle. To control the movement of a character, use a series of Booleans as
    follows:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个名为 `GameCharacterControl` 的新类，该类扩展 `BetterCharacterControl`。这个类还需要实现
    `ActionListener` 和 `AnalogListener`。这里的想法是将可以处理的操作传递给这个类。要控制角色的移动，可以使用以下一系列布尔值：
- en: '[PRE0]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Also, define a float field called `moveSpeed`, which will help you control how
    much the character will move in each update.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要定义一个名为 `moveSpeed` 的浮点字段，这将帮助你控制角色在每次更新中移动的距离。
- en: 'The control Booleans you added are set in the implemented `onAction` method.
    Note that a key will always trigger !isPressed when released (note that a key
    always triggers `isPressed == false` when released):'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你添加的控制布尔值是在实现的 `onAction` 方法中设置的。请注意，一个键在释放时总会触发 !isPressed（注意，一个键在释放时总会触发 `isPressed
    == false`）：
- en: '[PRE1]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that you have handled the key input, put the control Booleans to be used
    in the `update` method. You might recognize the code if you''ve looked at `TestBetterCharacter`.
    The first thing it does is get the current direction the `spatial` object is facing
    in order to move forward and backwards. It also checks which direction is left
    for strafing, as follows:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您已经处理了键盘输入，将要在`update`方法中使用的控制布尔值放在一起。如果您查看过`TestBetterCharacter`，可能会认出这段代码。它首先做的事情是获取`spatial`对象当前面对的方向，以便前进和后退。它还检查用于侧滑的方向，如下所示：
- en: '[PRE2]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Depending on your Booleans, the following code modifies `walkDirection`. Normally,
    you would multiply the result by `tpf` as well, but this is already handled in
    the `BetterCharacterControl` class as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据布尔值，以下代码修改`walkDirection`。通常，您会将结果乘以`tpf`，但这一点已经在`BetterCharacterControl`类中处理，如下所示：
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, in the `setWalkDirection` method, apply `walkDirection` as follows:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`setWalkDirection`方法中，按照以下方式应用`walkDirection`：
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code handles moving forward, backward, and to the side. The turning
    and looking up and down actions of a character is normally handled by moving the
    mouse (or game controller), which is instead an analog input. This is handled
    by the `onAnalog` method. From here, we take the name of the input and apply its
    value to two new methods, `rotate` and `lookUpDown`, as follows:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述代码处理了向前、向后和向侧移动。角色的转动和上下看通常是通过移动鼠标（或游戏控制器）来处理的，这实际上是一个模拟输入。这是由`onAnalog`方法处理的。从这里，我们获取输入的名称并将其值应用于两个新方法`rotate`和`lookUpDown`，如下所示：
- en: '[PRE5]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, start by handling the process of turning the character left and right.
    The `BetterCharacterControl` class already has nice support for turning the character
    (which, in this case, is the same thing as looking left or right), and you can
    access its `viewDirection` field directly. You should only modify the *y* axis,
    which is the axis that goes from head to toe, by a small amount as follows:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，首先处理角色左右转动的过程。`BetterCharacterControl`类已经提供了对角色转动（在这种情况下，等同于左右看）的良好支持，并且您可以直接访问其`viewDirection`字段。您应该只修改*Y*轴，即从头部到脚趾的轴，以微小的量进行如下修改：
- en: '[PRE6]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In order to handle looking up and down, you have to do some more work. The
    idea is to let the `spatial` object handle this. For this, you need to step back
    to the top of the class and add two more fields: a `Node` field called `head`
    and a float field called `yaw`. The `yaw` field will be the value with which you
    will control the rotation of the head up and down.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了处理上下查找，您需要做更多的工作。思路是让`spatial`对象来处理这个问题。为此，您需要回到类的顶部并添加两个额外的字段：一个名为`head`的`Node`字段和一个名为`yaw`的浮点字段。`yaw`字段将用于控制头部上下旋转的值。
- en: 'In the constructor, set the location of the `head` node. The location is relative
    to the `spatial` object to an appropriate amount. In a normally scaled world,
    `1.8f` would correspond to `1.8` m (or about 6 feet):'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，设置`head`节点的位置。位置相对于`spatial`对象是适当的。在一个正常缩放的世界中，`1.8f`对应于`1.8`米（或大约6英尺）：
- en: '[PRE7]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, you need to attach the `head` node to `spatial`. You can do this in the
    `setSpatial` method. When a `spatial` is supplied, first check whether it is a
    `Node` (or you wouldn''t be able to add the head). If it is, attach the head as
    follows:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您需要将`head`节点附加到`spatial`上。您可以在`setSpatial`方法中完成此操作。当提供`spatial`时，首先检查它是否是一个`Node`（否则您将无法添加头节点）。如果是的话，按照以下方式附加头节点：
- en: '[PRE8]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that you have a head that can rotate freely, you can implement the method
    that handles looking up and down. Modify the `yaw` field with the supplied value.
    Then, clamp it so that it can''t be rotated more than 90 degrees up or down. Not
    doing this might lead to weird results. Then, set the rotation for the head around
    the *x* axis (think ear-to-ear) as follows:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您已经有一个可以自由旋转的头部，您可以实现处理上下看的函数。使用提供的值修改`yaw`字段。然后，将其限制在不能向上或向下旋转超过90度。不这样做可能会导致奇怪的结果。然后，按照以下方式设置头部围绕*x*轴（想象耳朵到耳朵）的旋转：
- en: '[PRE9]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we have a character that can move and rotate like a standard FPS character.
    It still doesn''t have a camera tied to it. To solve this, we''re going to use
    the `CameraNode` class and hijack the application''s camera. `CameraNode` gives
    you the ability to control the camera as if it were a node. With `setControlDir`,
    we instruct it to use the location and rotation of `spatial` as follows:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们有一个可以像标准 FPS 角色一样移动和旋转的角色。它仍然没有与摄像机绑定。为了解决这个问题，我们将使用 `CameraNode` 类并劫持应用程序的摄像机。`CameraNode`
    允许你像操作节点一样控制摄像机。通过 `setControlDir`，我们指示它使用 `spatial` 的位置和旋转，如下所示：
- en: '[PRE10]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Cameras are logical objects and are not part of the scene graph. The `CameraNode`
    keeps an instance of Camera. It is a `Node` and propagates its own location to
    the Camera. It can also do the opposite and apply the Camera's location to `CameraNode`
    (and thus, any other `spatial` object attached to it).
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 摄像机是逻辑对象，不是场景图的一部分。`CameraNode` 保留一个摄像机实例。它是一个 `Node`，并将自己的位置传播到摄像机。它还可以执行相反的操作，将摄像机的位置应用到
    `CameraNode`（以及因此，任何附加到它的其他 `spatial` 对象）。
- en: 'To use `GameCharacterControl` in an application, add the following lines of
    code in the `simpleInit` method of an application. Instantiate a new (invisible)
    `Node` instance that you can add to the `GameCharacterControl` class. Set the
    application''s camera to be used as a character, and add it to `physicsSpace`
    as follows:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在应用程序中使用 `GameCharacterControl`，请将以下代码行添加到应用程序的 `simpleInit` 方法中。实例化一个新的（不可见）`Node`
    实例，并将其添加到 `GameCharacterControl` 类中。将应用程序的摄像机设置为用于角色，并按如下方式将其添加到 `physicsSpace`
    中：
- en: '[PRE11]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `BetterCharacterControl` class of jMonkeyEngine already has a lot of the
    functionalities to handle the movement of a character. By extending it, we get
    access to it and we can implement the additional functionality on top of it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: jMonkeyEngine 的 `BetterCharacterControl` 类已经有很多处理角色移动的功能。通过扩展它，我们可以访问它，并在其之上实现额外的功能。
- en: The reason we use Booleans to control movement is that the events in `onAction`
    and `onAnalog` are not fired continuously; they are fired only when they're changed.
    So, pressing a key wouldn't generate more than two actions, one on pressing it
    and one on releasing it. With the Boolean, we ensure that the action will keep
    getting performed until the player releases the key.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用布尔值来控制移动的原因是 `onAction` 和 `onAnalog` 事件不是连续触发的；它们只在发生变化时触发。所以，按下一个键不会生成超过两个动作，一个是在按下时，另一个是在释放时。通过布尔值，我们确保动作将持续执行，直到玩家释放按键。
- en: This method waits for an action to happen, and depending on the binding parameter,
    it will set or unset one of our Booleans. By listening for actions rather than
    inputs (the actual key strokes), we can reuse this class for **non-player characters**
    (**NPCs**).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法等待一个动作发生，并根据绑定参数，将设置或清除我们的布尔值之一。通过监听动作而不是输入（实际的按键），我们可以重用此类来处理**非玩家角色**（**NPC**）。
- en: We can't handle looking up and down in the same way as we perform sideways rotations.
    The reason is that the latter changes the actual direction of the movement. When
    looking up or down, we just want the camera to look that way. The character is
    usually locked to the ground (it would be different in a flight simulator, though!).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能像进行侧向旋转那样以相同的方式处理上下看。原因是后者改变了实际的运动方向。当我们向上或向下看时，我们只想让摄像机朝那个方向看。角色通常被锁定在地面上（在飞行模拟器中情况可能不同！）。
- en: As we can see, the `BetterCharacterControl` class already has ways to handle
    jumping and ducking. Nice!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`BetterCharacterControl` 类已经有处理跳跃和蹲下的方法。很好！
- en: There's more...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Let''s say we would rather have a third-person game. How difficult would it
    be to modify this class to support that? In a later recipe, we will look at jMonkeyEngine''s
    `ChaseCamera` class, but by inserting the following two lines of code at the end
    of our `setCamera` method, we will get a basic camera that follows the character:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们更愿意有一个第三人称游戏。修改这个类以支持第三人称会有多难？在后面的菜谱中，我们将查看 jMonkeyEngine 的 `ChaseCamera`
    类，但通过在 `setCamera` 方法的末尾插入以下两行代码，我们将得到一个基本的跟随角色的摄像机：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It's all handled by `CamNode`, which offsets the camera's location in relation
    to its own (which follows the `head` node). After moving `CamNode`, we make sure
    that the camera also looks at the head (rather than the default forward).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作都由 `CamNode` 处理，它相对于自身（跟随 `head` 节点）调整摄像机的位置。移动 `CamNode` 后，我们确保摄像机也朝向头部（而不是默认的前方）。
- en: Attaching an input AppState object
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将输入的 AppState 对象附加
- en: In this recipe, we will make an `AppState` object, which will handle the player
    input for a character. It's a great way to add functionality to the application
    in a modular way. The `AppState` object we create here could easily be added during
    the game and removed or disabled during cut scenes or while in the game menu.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个`AppState`对象，该对象将处理角色的玩家输入。这是一种以模块化方式向应用程序添加功能的好方法。我们在这里创建的`AppState`对象可以很容易地在游戏过程中添加，在剪辑场景或游戏菜单中移除或禁用。
- en: Getting ready
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: We won't require any special assets for this recipe, but it will be beneficial
    to have a basic understanding of how AppState works and its purpose in jMonkeyEngine.
    This particular implementation of the recipe will use the character-control class
    created in the previous example. It can still be used to manipulate a `spatial`
    object directly without the `GameCharacterControl` class. This recipe will provide
    pointers on where to do this.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们不需要任何特殊资源，但了解 AppState 的工作原理及其在 jMonkeyEngine 中的目的将是有益的。这个菜谱的特定实现将使用在先前的示例中创建的字符控制类。它仍然可以直接操作`spatial`对象，而无需`GameCharacterControl`类。这个菜谱将提供如何做到这一点的指导。
- en: How to do it...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To attach an input `AppState` object, perform the following steps:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要附加输入`AppState`对象，请执行以下步骤：
- en: Start off by creating a class called `InputAppState`, extending `AbstractAppState`,
    and implementing `ActionListener` and `AnalogListener`.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个名为`InputAppState`的类，它扩展了`AbstractAppState`并实现了`ActionListener`和`AnalogListener`。
- en: The `InputAppState` class needs a couple of fields to be functional. First of
    all, we're going to keep a reference to the application's `InputManager` in a
    field called `inputManager`. We're also adding a `GameCharacterControl` field
    called `character`. This can be replaced by any `spatial`. Lastly, we're going
    to have a value that controls the sensitivity of the analog controls. We do this
    with a float called sensitivity. Add getters and setters for character and sensitivity.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`InputAppState`类需要几个字段才能正常工作。首先，我们将保留一个指向应用程序`InputManager`的引用，在名为`inputManager`的字段中。我们还添加了一个名为`character`的`GameCharacterControl`字段。这可以被任何`spatial`替换。最后，我们将有一个控制模拟控制灵敏度的值。我们使用一个名为`sensitivity`的浮点数来完成此操作。为角色和灵敏度添加getter和setter。'
- en: 'Next, we''ll set up the kinds of input we''re going to handle. Strings are
    used by jMonkeyEngine for the mappings, but enums can be easier to manage across
    classes. Here, we''ll use an `enum` and supply the name of the value as the mapping.
    We use it to create some basic FPS controls as follows:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将设置我们将要处理的各种输入类型。jMonkeyEngine使用字符串进行映射，但枚举可以在类之间更容易地管理。在这里，我们将使用一个枚举并供应值的名称作为映射。我们使用它来创建一些基本的FPS控制，如下所示：
- en: '[PRE13]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We create a method called `addInputMappings` to add these to `inputManager`
    and make sure it listens to them. To do this, we supply the name of the `enum`
    value as the mapping and bind it to a certain input as follows:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`addInputMappings`的方法来添加这些映射并确保它监听它们。为此，我们提供`enum`值的名称作为映射并将其绑定到特定的输入，如下所示：
- en: '[PRE14]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's okay to assign several keys to the same mapping. For example, this recipe
    assigns both the arrow keys and the classical WASD pattern to the movement keys.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将多个键分配给相同的映射是可以的。例如，这个菜谱将箭头键和经典的WASD模式都分配给移动键。
- en: 'Finally, in the same method, we tell `InputManager` to listen to the commands,
    or it won''t actually fire on any of the inputs:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在同一个方法中，我们告诉`InputManager`监听命令，否则它实际上不会在任何输入上触发：
- en: '[PRE15]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, once `AppState` is attached, it runs the `initialize` method (in a thread-safe
    way). Here, we get the reference to the application''s `InputManager` object and
    run the `addMappings` method we just created, as follows:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，一旦`AppState`附加，它就会运行`initialize`方法（以线程安全的方式）。在这里，我们获取应用程序`InputManager`对象的引用并运行我们刚刚创建的`addMappings`方法，如下所示：
- en: '[PRE16]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once `InputManager` detects any of the actions and sends them our way, we will
    just forward them to the `GameCharacterControl` object by applying the sensitivity
    value to the analog input as follows:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦`InputManager`检测到任何动作并将它们发送给我们，我们只需将它们通过应用灵敏度值到模拟输入的方式转发给`GameCharacterControl`对象，如下所示：
- en: '[PRE17]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We''re actually almost done with this recipe. We just need to make sure that
    we reset everything when `AppState` is not to be used anymore. We do this by overriding
    the cleanup method. Here, we remove all the mappings and remove this instance
    from listeners of `inputManager` as follows:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实际上已经接近完成这个菜谱了。我们只需确保当不再使用`AppState`时重置一切。我们通过覆盖清理方法来完成此操作。在这里，我们移除所有映射，并按照以下方式从`inputManager`的监听器中移除此实例：
- en: '[PRE18]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `AppState` object works with the application in a way that is similar to
    how `Control` works with `spatial`. They give extended functionalities in a modular
    way. Once it has been attached to `stateManager`, its `update` method will be
    called every cycle. This gives us access to the application's thread as well.
    It also has the `stateAttached` and `stateDetached` methods, which can be used
    to turn functionality on and off easily.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppState`对象与应用程序一起工作的方式类似于`Control`与`spatial`一起工作的方式。它们以模块化的方式提供扩展功能。一旦它被附加到`stateManager`，它的`update`方法将在每个周期被调用。这使我们能够访问应用程序的线程。它还具有`stateAttached`和`stateDetached`方法，可以用来轻松地开启和关闭功能。'
- en: Firing in FPS
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在FPS中射击
- en: There are several ways to perform firing, and the requirements depend heavily
    on the type of game. This recipe will start off with the basics, which can then
    be extended to support the different forms of firing. We'll create the necessary
    functionalities to fire instant bullets; they are performance-friendly and suitable
    for a fairly close-quarters FPS.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种执行射击的方法，具体取决于游戏类型。这个配方将从基础知识开始，然后可以扩展以支持不同的射击形式。我们将创建必要的功能来发射瞬间子弹；它们性能友好，适合近距离FPS。
- en: Getting ready
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: This example will be based on `GameCharacterControl` and `InputAppState` from
    the *Creating a reusable character control* and *Attaching an input AppState*
    *object* recipes of this chapter, respectively. Familiarity with the recipes is
    beneficial. Further, we'll use the `Ray` class in combination with `CollisionResults`
    to check whether the bullet has hit anything or not.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将基于本章的*创建可重用角色控制*和*附加输入AppState对象*配方中的`GameCharacterControl`和`InputAppState`，分别。熟悉这些配方是有益的。此外，我们将结合使用`Ray`类和`CollisionResults`来检查子弹是否击中了任何东西。
- en: Rays can be imagined as infinite lines and are very common in game development.
    This is a fast way of detecting intersections with game objects and is thus suitable
    for instant firing. The targets might consist of any kind of `spatial`. In this
    case, it's a bunch of spheres generated by the recipe's test class.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 射线可以想象成无限长的线，在游戏开发中非常常见。这是一种快速检测与游戏对象交点的方法，因此适合即时射击。目标可能由任何类型的`spatial`组成。在这种情况下，它是由配方测试类生成的一组球体。
- en: We will let the `InputAppState` class handle the firing logic, and the `GameCharacterControl`
    class will keep track of cool down time of the weapon, or how long it takes between
    each shot. The reason we don't keep everything in `AppState` is that this way,
    the class can be used for things other than the player's character.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将让`InputAppState`类处理射击逻辑，而`GameCharacterControl`类将跟踪武器的冷却时间，或者每次射击之间的时间。我们不将所有内容都放在`AppState`中的原因是这样，这个类可以用于除了玩家的角色之外的其他事物。
- en: How to do it...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will start by making some updates to the `GameCharacterControl` class. For
    the `GameCharacterControl` class, we introduce two new variables, `cooldownTime`
    and `cooldown`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先对`GameCharacterControl`类进行一些更新。对于`GameCharacterControl`类，我们引入了两个新变量，`cooldownTime`和`cooldown`：
- en: The first is the time between shots.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一项是射击之间的时间。
- en: 'The second is the current countdown until the character can fire again. We
    need to add a getter for `cooldown` and the value itself is set in the following
    `onFire` method:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个是角色可以再次射击的当前倒计时。我们需要为`cooldown`添加一个获取器，其值在以下`onFire`方法中设置：
- en: '[PRE19]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Lastly, in the update method, we need to subtract `cooldown` by `tpf` if it's
    more than zero.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在更新方法中，如果`cooldown`大于零，我们需要从`tpf`中减去`cooldown`。
- en: 'In `InputAppState`, we also have to make some changes:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`InputAppState`中，我们还需要做一些修改：
- en: 'We begin by introducing a `List<Geometry>` called `targets`. This is the list
    of things the fired rays will check for collisions against. In the `addInputMapping`
    method, add another mapping for `Fire`. A suitable button is the left mouse button.
    This is implemented as follows:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先引入一个名为`targets`的`List<Geometry>`。这是发射射线将检查碰撞的物体的列表。在`addInputMapping`方法中，为`Fire`添加另一个映射。合适的按钮是左鼠标按钮。这是按照以下方式实现的：
- en: '[PRE20]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the `onAction` method, change the logic slightly. We add a new check for
    the fire action and we put the existing logic inside the `else` clause. We''re
    telling `character` to handle all actions, except when we fire. This is implemented
    as follows:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onAction`方法中，稍微改变一下逻辑。我们为射击动作添加了一个新的检查，并将现有的逻辑放在`else`子句中。我们告诉`character`处理所有动作，除了当我们射击时。这是按照以下方式实现的：
- en: '[PRE21]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, create a new method called `fire`. This is where we''re going to add most
    of the new functionalities. Inside this, we first define a new `Ray` class that
    we place at the camera''s location (if it is an FPS), and we set the direction
    to be the same as the camera''s direction, as shown in the following code:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为 `fire` 的新方法。这是我们将要添加大部分新功能的地方。在这个方法内部，我们首先定义一个新的 `Ray` 类，并将其放置在摄像机的位置（如果是一个FPS），并将方向设置为与摄像机的方向相同，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, create a new `CollisionResults` instance, which we will use to keep track
    of collisions. We parse through the target list to see whether `Ray` collides
    with any of them. All collisions are stored in the `CollisionResults` instance
    as follows:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个新的 `CollisionResults` 实例，我们将使用它来跟踪碰撞。我们遍历目标列表，查看 `Ray` 是否与其中任何一个发生碰撞。所有碰撞都按以下方式存储在
    `CollisionResults` 实例中：
- en: '[PRE23]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Afterwards, check whether there have been any collisions. If so, get the nearest
    one and display the location as follows:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，检查是否发生了任何碰撞。如果有，获取最近的一个并按以下方式显示位置：
- en: '[PRE24]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Finally, call the character's `onFire` method, `character.onFire();`.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，调用角色的 `onFire` 方法，`character.onFire();`。
- en: How it works...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: With this implementation, we handle most of the actual logic that happens when
    firing inside `InputAppState`. The `GameCharacterControl` class is left to keep
    control of whether firing is possible or not. Some further work on this could
    have the character play an animation and keep track of the ammunition.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此实现，我们处理了在 `InputAppState` 中射击时发生的实际逻辑的大部分。`GameCharacterControl` 类保留以控制是否可以进行射击。对此进行一些进一步的工作可以让角色播放动画并跟踪弹药。
- en: The `Ray` object we're using is being fired out of the camera. This makes it
    easy to set both the location and direction. This would be the case for a game
    in iron sights or sniper mode. If you want to fire from the hip, for example,
    it would be slightly more complicated.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用的 `Ray` 对象是从摄像机发射出来的。这使得设置位置和方向变得容易。如果是铁瞄准镜或狙击模式的游戏，情况就是这样。如果你想从腰间射击，例如，这会稍微复杂一些。
- en: Rays are normally very fast. Using them can, however, become performance-demanding
    in large game worlds with complex collision shapes. This is one reason for keeping
    track of the items to be checked against in a list rather than using the whole
    `rootNode`. In other cases, it's good to first filter down the list, maybe based
    on the distance from the player.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 射线通常非常快。然而，在具有复杂碰撞形状的大型游戏世界中使用它们可能会变得性能要求很高。这是在列表中跟踪要检查的项目而不是使用整个 `rootNode`
    的一个原因。在其他情况下，首先根据玩家距离过滤列表可能是个好主意。
- en: The `CollisionResults` class stores collisions between `spatial` or `ray`. It
    contains a list of `CollisionResult` objects, which in turn has a number of useful
    methods for determining where a collision has occurred and between what.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`CollisionResults` 类存储了 `spatial` 或 `ray` 之间的碰撞。它包含一个 `CollisionResult` 对象的列表，该列表包含确定碰撞发生位置和碰撞对象的许多有用方法。'
- en: Firing non-instant bullets
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 射出非即时子弹
- en: In the previous recipe, we implemented a basic form of firing that will work
    for many cases. The exit velocity for a bullet is usually around 300 m/s (or close
    to 1000 feet/s) and might seem near-instant at close range. For ranges over 30
    m (approximately 90 feet), the delay starts to get noticeable though, and more
    realistic games might need another model. In this recipe, we'll look into a type
    of bullet that travels in the game world. It's still an invisible bullet, but
    it can easily be visualized if required.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个菜谱中，我们实现了一种基本的射击形式，它适用于许多情况。子弹的出膛速度通常在 300 m/s（或接近 1000 英尺/s）左右，在近距离内可能看起来几乎是瞬间的。然而，对于超过
    30 m（大约 90 英尺）的距离，延迟开始变得明显，更逼真的游戏可能需要另一个模型。在这个菜谱中，我们将探讨一种在游戏世界中移动的子弹类型。它仍然是一个不可见的子弹，但在需要时可以轻松地可视化。
- en: Getting ready
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe can be seen as a more advanced version of the previous recipe and
    won't require many changes to what we did there but will mainly contain additions.
    Almost all of the functionalities will be implemented in a new class, called `Bullet`
    (not to be confused with the physics engine with the same name that we use in
    a [Chapter 8](ch08.html "Chapter 8. Physics with Bullet"), *Physics with Bullet*).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱可以看作是上一个菜谱的更高级版本，并且不会要求对之前所做的工作进行很多更改，但主要包含添加。几乎所有功能都将在一个名为 `Bullet` 的新类中实现（不要与我们在第
    8 章 [Physics with Bullet](ch08.html "Chapter 8. Physics with Bullet") 中使用的同名物理引擎混淆）。
- en: How to do it...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps to fire non-instant bullets:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以射出非即时子弹：
- en: Let's begin by defining our `Bullet` class. The `worldPosition` and `direction`
    variables are used by the `Ray` class as a starting position each step it takes.
    The `RANGE` field is a static field that defines the maximum range, inside which
    the bullet will be effective. The `distance` variable is the distance the bullet
    has traveled since it was instanced. It also needs to keep track of whether it's
    alive or not, for cleanup reasons. It should be said that this particular bullet
    is rather slow and short lived.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先定义我们的`Bullet`类。`worldPosition`和`direction`变量被`Ray`类用作每次移动的起始位置。`RANGE`字段是一个静态字段，定义了子弹有效的最大范围。`distance`变量是子弹自实例化以来所走过的距离。它还需要跟踪它是否存活，以便进行清理。应该指出的是，这个特定的子弹相当慢，寿命也较短。
- en: '[PRE25]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To avoid unnecessary object creation, we instance `Ray` in the constructor
    as follows, which we''ll reuse throughout the lifespan of the bullet:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了避免不必要的对象创建，我们在构造函数中实例化`Ray`，如下所示，我们将在子弹的生命周期中重用它：
- en: '[PRE26]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It''s in the `update` method that most of the work is done. At the beginning,
    we set the ray''s origin to be the current position of the bullet. The direction
    will stay the same, so no need to change that. We do, however, need to set limit
    factorized by the time passed for the update (`tpf`). The limit is also the distance
    the bullet has traveled since the last update, so we use this to update the current
    position of the bullet:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大部分工作是在`update`方法中完成的。一开始，我们将射线的起点设置为子弹的当前位置。方向将保持不变，因此无需更改。然而，我们需要设置由更新经过的时间（`tpf`）因子化的限制。这个限制也是子弹自实例化以来所走过的距离，因此我们使用这个值来更新子弹的当前位置：
- en: '[PRE27]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If the total distance is longer than the range, the bullet can be considered
    beyond its effective range. We set `alive` to `false` as follows so that it can
    be removed:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果总距离超过范围，子弹可以被认为是超出其有效范围。我们将其`alive`设置为`false`，如下所示，以便将其移除：
- en: '[PRE28]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `Bullet` class also has a `checkCollision` method. It takes a list of targets
    as input and tries a collision between each of them and the ray. If any collision
    is detected, `alive` will be set to `false` and the closest `CollisionResult`
    will be returned to the calling method as follows:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Bullet`类还有一个`checkCollision`方法。它接受一个目标列表作为输入，并尝试将每个目标与射线进行碰撞。如果检测到任何碰撞，`alive`将被设置为`false`，并将最近的`CollisionResult`返回给调用方法，如下所示：'
- en: '[PRE29]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Next, we'll add some code to the application class. It needs to keep track of
    `List<Collidable>`, called `targets` and `List<Bullet>`, called `bullets`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将向应用程序类添加一些代码。它需要跟踪名为`targets`的`List<Collidable>`和名为`bullets`的`List<Bullet>`。
- en: 'The `simpleUpdate` method updates the movement of all bullets by calling their
    update method before seeing whether any collisions have occurred or not. Any depleted
    bullets are removed in a way that avoids `ArrayIndexOutOfBounds` exceptions:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`simpleUpdate`方法通过在检查是否发生任何碰撞之前调用它们的更新方法来更新所有子弹的运动。任何耗尽的子弹都会以避免`ArrayIndexOutOfBounds`异常的方式被移除：'
- en: '[PRE30]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a `fire()` method that creates a new bullet by using the camera''s location
    and direction as follows:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`fire()`方法，该方法通过使用摄像机的位置和方向创建一个新的子弹，如下所示：
- en: '[PRE31]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The method is called from the InputAppState''s `onAction` method, which is
    similar to how it looked in the previous recipe:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该方法是从`InputAppState`的`onAction`方法中调用的，这与之前食谱中的样子相似：
- en: '[PRE32]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works...
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Bullet` class can almost be seen as a slow ray. The `Ray` instance we have
    in `Bullet` is mostly out of convenience, since it's already prepared to collide
    with targets. By incrementing the position of the ray and having a short limit
    for it, we have a `Ray` instance that takes little steps forward in the game world,
    checking for collisions in each update.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bullet`类几乎可以看作是一个慢速射线。在`Bullet`中我们拥有的`Ray`实例主要是为了方便，因为它已经准备好与目标发生碰撞。通过增加射线的位置并为其设置一个短距离限制，我们在游戏世界中创建了一个`Ray`实例，它在每次更新中向前迈出小步，并检查碰撞：'
- en: If a collision has occurred, the returned `CollisionResult` contains information
    about where the collision has occurred, with what, and whether it can be used
    to build further functionalities.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生碰撞，返回的`CollisionResult`将包含有关碰撞发生位置、碰撞对象以及是否可以用于构建进一步功能的信息。
- en: Creating an RTS camera AppState object
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个RTS摄像机`AppState`对象
- en: In this recipe, we'll try to mimic the camera and controls that are common in
    RTS games. The camera will mostly look down on the scene, and aside from basic
    movement and rotation of the camera, there will also be automatic scrolling when
    the mouse reaches the edges of the screen.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将尝试模仿在RTS游戏中常见的相机和控制。相机将主要向下看场景，除了基本移动和旋转相机外，当鼠标到达屏幕边缘时，还将自动滚动。
- en: Getting ready
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We're going to set up the camera and camera handling in this recipe. Loading
    a scene to make sure the camera works as expected would be helpful.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本食谱中设置相机和相机处理。加载一个场景以确保相机按预期工作将很有帮助。
- en: How to do it...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To create an RTS camera `AppState` object, perform the following steps:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个RTS相机`AppState`对象，请执行以下步骤：
- en: 'We start by creating a class that implements the `AnalogListener` and `ActionListener`
    interfaces so that we can receive user input from the mouse and keyboard. We''ll
    use these to control the camera as follows:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个实现`AnalogListener`和`ActionListener`接口的类，这样我们就可以从鼠标和键盘接收用户输入。我们将使用这些来控制相机，如下所示：
- en: '[PRE33]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we''ll define what controls we''ll handle. Using an `enum` will keep
    things tidy, so type the following code snippet:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将定义我们将要处理的控制。使用`enum`可以使事情变得整洁，所以输入以下代码片段：
- en: '[PRE34]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following screenshot shows you the difference between the camera''s position
    above the ground (half circle) and the camera''s focus point (at the center):'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了相机在地面以上（半圆形）的位置和相机焦点（在中心）之间的区别：
- en: '![How to do it...](img/6478OS_02_03.jpg)'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何实现...](img/6478OS_02_03.jpg)'
- en: 'We then set up some things in the `initialize` method. Rather than having a
    completely top-down perspective, we give the camera a little tilt with `lookAtDirection`
    and a unit vector. Then, we move the camera further away from the ground with
    the `camDistance` variable. There is a reason we do this and don''t simply set
    the camera''s location. By doing it this way, we can more easily get the location
    the camera is looking at. This will come in handy if we want to add more advanced
    features:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在`initialize`方法中设置了一些东西。而不是完全的从上到下的视角，我们用`lookAtDirection`和单位向量给相机一个轻微的倾斜。然后，我们用`camDistance`变量将相机从地面移开。我们这样做而不是简单地设置相机的位置是有原因的。通过这种方式，我们可以更容易地获取相机所看的地点。如果我们想添加更高级的功能，这将很有用：
- en: '[PRE35]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Lastly, add the keys that we''ll listen to `inputManager`:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加我们将监听的键到`inputManager`：
- en: '[PRE36]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now to the `onAction` method, where any calls to these mappings will end up.
    Since we have an `enum`, we can use a switch to see what kind of input it is and
    set our Booleans accordingly:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在来看`onAction`方法，其中任何对这些映射的调用都将结束。由于我们有`enum`，我们可以使用switch来查看输入的类型，并相应地设置我们的布尔值：
- en: '[PRE37]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s have a look at the `update` method, where we will put these Booleans
    to use. An `update` method is called automatically every frame, and we also get
    to know how much time (in seconds) has passed since the last update, in `tpf`.
    We start by storing the camera''s current location and initialize a `Vector3f`
    object, which we''ll use for our movement delta as follows:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看`update`方法，我们将在这里使用这些布尔值。`update`方法在每一帧都会自动调用，我们还可以知道自上次更新以来已经过去了多少时间（以秒为单位），在`tpf`中。我们首先存储相机的当前位置，并初始化一个`Vector3f`对象，我们将用它作为移动的增量，如下所示：
- en: '[PRE38]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, we look to see if any of our `movement` Booleans are `true` and apply
    this to `tempVector` as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们查看是否有任何我们的`movement`布尔值是`true`，并按照以下方式将其应用于`tempVector`：
- en: '[PRE39]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To keep the movement speed constant, regardless of the frame rate, we multiply
    `tempVector` by the `tpf`, and then we also multiply it by our `moveSpeed` variable.
    Then, we add it to `camLocation` as follows:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了保持移动速度恒定，无论帧率如何，我们将`tempVector`乘以`tpf`，然后我们也将它乘以我们的`moveSpeed`变量。然后，我们按照以下方式将其添加到`camLocation`：
- en: '[PRE40]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'At the end of the method, we set the camera''s location to the modified stored
    location as follows:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在方法末尾，我们将相机的位置设置为修改后的存储位置，如下所示：
- en: '[PRE41]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If we try `AppState` now, we would be able to scroll across the scene with our
    keys. We still have mouse controls and rotation to take care of.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在尝试使用`AppState`，我们就能用键盘滚动场景。我们仍然需要处理鼠标控制和旋转。
- en: 'Let''s begin with rotation. We will handle it through a method called `rotate`.
    The supplied value is our `rotateSpeed` variable, from which we''ll extract a
    `Quaternion` rotated around the *y* axis. We then multiply the Quaternion with
    the camera''s rotation as follows:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从旋转开始。我们将通过一个名为`rotate`的方法来处理它。提供的值是我们的`rotateSpeed`变量，我们将从中提取一个围绕*y*轴旋转的`Quaternion`。然后，我们将Quaternion与相机的旋转相乘，如下所示：
- en: '[PRE42]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Furthermore, we need to make a few alterations to the `update` method. First,
    we look to see whether the user has pressed any of the rotation keys and call
    the `rotate` method:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们还需要对 `update` 方法进行一些修改。首先，我们查看用户是否按下了任何旋转键，并调用 `rotate` 方法：
- en: '[PRE43]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The next piece is a bit trickier, and we perform it just above the line where
    we multiply `tempVector` by `moveSpeed` (highlighted). We multiply `tempVector`
    by the camera''s rotation to make sure that we get the movement across the correct
    axes. Then, since the camera is slightly tilted, we negate any movement along
    the *y* axis. The best way to understand what would happen is to probably remove
    this line and try it out as follows:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个部分稍微有点复杂，我们就在乘以 `tempVector` 和 `moveSpeed` 的行上方执行它（高亮显示）。我们通过将 `tempVector`
    乘以摄像机的旋转来确保我们能在正确的轴上获得移动。然后，由于摄像机略微倾斜，我们取消沿 *y* 轴的任何移动。理解会发生什么最好的方法可能是移除这一行并尝试如下操作：
- en: '[PRE44]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'That''s rotation taken care of! It''s pretty common in RTS or top-down games
    to scroll by moving the mouse to the extremes of the screen. So, let''s add functionalities
    for that. The following code snippet should be added in the `update` method above
    the rotation checks:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那个旋转问题解决了！在 RTS 或俯视游戏中，通过将鼠标移动到屏幕的边缘来滚动是很常见的。所以，让我们添加相应的功能。以下代码片段应该添加在上述 `update`
    方法中的旋转检查上方：
- en: '[PRE45]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works...
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `AppState` object listens for the input from the player via `InputManager`
    and applies it to the application's camera. In just one short class, we've produced
    an RTS-like camera behavior.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppState` 对象通过 `InputManager` 监听玩家的输入并将其应用于应用程序的摄像机。在短短的一个类中，我们已经产生了一个类似 RTS
    的摄像机行为。'
- en: Lastly, in this recipe, we added functionalities to pan the camera if the mouse
    cursor was near the edges of the screen. We used `InputManager.getCursorPosition()`,
    which is a very convenient method that returns the position of the mouse in the
    screen space. The bottom-left part of the screen has an x,y coordinate of 0,0\.
    The top-left part of the screen has an *x*, *y* coordinate that is the same as
    the height and width of the screen in pixels. The next `if` statements check whether
    the cursor is in the 10 percent of the outermost portion of the camera (which
    in this case is the same as the screen) and modify `tempVector` accordingly.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在这个菜谱中，我们添加了当鼠标光标靠近屏幕边缘时平移摄像机的功能。我们使用了 `InputManager.getCursorPosition()`，这是一个非常方便的方法，它返回鼠标在屏幕空间中的位置。屏幕左下角有一个
    x,y 坐标为 0,0。屏幕左上角有一个 *x*，*y* 坐标与屏幕的像素宽度和高度相同。接下来的 `if` 语句检查光标是否在摄像机（在这种情况下与屏幕相同）最外层部分的
    10% 内，并相应地修改 `tempVector`。
- en: There's more...
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'That''s nice and all, but if we have terrain in our scene, which is not flat,
    the camera might very well end up below the ground level. How can we remedy this?
    An easy way is to use ray casting to check for the height of the terrain where
    the camera is looking. This can be implemented as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但是如果我们场景中有地形，而且地形不是平的，摄像机可能会非常准确地低于地面水平。我们如何解决这个问题？一个简单的方法是使用射线投射来检查摄像机所在位置的地形高度。这可以按如下方式实现：
- en: 'First, we need to make sure the terrain has `CollisionShape`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要确保地形有 `CollisionShape`：
- en: '[PRE46]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: By supplying `0` to `RigidBodyControl`, we say that it doesn't have any mass
    (and it won't be affected by gravity, if there were any). Since we're not supplying
    `CollisionShape`, `MeshCollisionShape` will be created. Since the terrain is of
    an irregular shape, a primitive (such as a box) isn't usable.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过向 `RigidBodyControl` 提供一个 `0`，我们表示它没有任何质量（并且如果有的话，它不会受到重力的影响）。由于我们没有提供 `CollisionShape`，将创建
    `MeshCollisionShape`。由于地形形状不规则，原始形状（如盒子）是不可用的。
- en: Next, we need to create a field for the terrain in `AppState` and a setter as
    well.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在 `AppState` 中创建一个用于地形的字段以及一个设置器。
- en: To actually find out the height of the terrain, we create a method called `checkHeight`,
    which returns the height as float.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了实际上找出地形的高度，我们创建了一个名为 `checkHeight` 的方法，它返回一个浮点数的高度。
- en: 'Inside `checkHeight`, we shoot `Ray`, which originates from the camera''s location
    in the direction the camera is facing. An alternative could be to shoot it down
    to get the height directly below the camera, as follows:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `checkHeight` 内部，我们向摄像机所在位置并朝向摄像机面对的方向发射 `Ray`。另一种选择是将它向下发射以直接获取摄像机正下方的海拔，如下所示：
- en: '[PRE47]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If we get a result from our ray, we get the `y` value from the collision point
    and return it as follows:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们从射线得到结果，我们就从碰撞点获取 `y` 值并按如下方式返回：
- en: '[PRE48]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, in the `update` method, just above the line where we set the location,
    we call the `checkHeight` method. Be sure to apply the `camDistance` variable
    in order to get the correct offset! This is implemented as follows:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`update`方法中，在设置位置的行上方，我们调用`checkHeight`方法。务必应用`camDistance`变量以获取正确的偏移量！这是这样实现的：
- en: '[PRE49]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Selecting units in RTS
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在实时战略中选择单位
- en: In this recipe, we'll show you how the selection of units in an RTS can work
    and also implement functionalities to show you when a unit has been selected.
    We'll use `AppState`, which handles mouse selection and we will also create a
    new `Control` class to be used by any `spatial` we want to be made selectable.
    In the recipe, Control will display a marker at the feet of the selected `spatial`,
    but it can easily be extended to do other things as well.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将向您展示在实时战略游戏中如何选择单位，并实现显示单位被选中时的功能。我们将使用`AppState`，它处理鼠标选择，并且我们还将创建一个新的`Control`类，以便用于任何我们希望可选择的`spatial`。在菜谱中，`Control`将在选中的`spatial`脚下显示一个标记，但它可以很容易地扩展以执行其他操作。
- en: Getting ready
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe will work fine if you have already started creating a game where
    you would like to select things by clicking on them or if you've completed the
    previous recipe. The least you will need for this recipe is a scene with something
    to click on. In the text, we will refer to `TestScene`, which was created in [Chapter
    1](ch01.html "Chapter 1. SDK Game Development Hub"), *SDK Game Development Hub*,
    and the Jaime model which is used in it. It is assumed that you have some experience
    in action handling. If not, it's recommended that you refer to the *Attaching
    an input AppState object* recipe of this chapter to get an introduction to it.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经开始了创建一个您希望通过点击来选择事物的游戏，或者如果您已经完成了上一个菜谱，这个菜谱将运行得很好。为此菜谱，您至少需要一个可以点击的场景。在文本中，我们将引用在[第1章](ch01.html
    "第1章。SDK游戏开发中心")中创建的`TestScene`，*SDK游戏开发中心*，以及其中使用的Jaime模型。假设您在处理动作方面有一些经验。如果没有，建议您参考本章的*附加输入AppState对象*菜谱，以了解其简介。
- en: How to do it...
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to select units in RTS:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以在实时战略中选择单位：
- en: Let's start by creating the Control class and name it `SelectableControl`. It
    should extend `AbstractControl`.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建名为`SelectableControl`的`Control`类开始，并使其扩展`AbstractControl`。
- en: 'The class only has two fields: selected, which keeps track of whether the `spatial`
    field is selected or not (duh), and marker, which is another `spatial` field to
    show when selected is true.'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该类只有两个字段：selected，它跟踪`spatial`字段是否被选中（当然），以及marker，它是一个另一个`spatial`字段，当selected为true时显示。
- en: 'The only logic in the class is in the `setSelected` method; we let it handle
    attaching or detaching the marker:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类中的唯一逻辑在`setSelected`方法中；我们让它处理标记的附加或分离：
- en: '[PRE50]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The method assumes that the `spatial` is actually a `Node`. If it is not a `Node`,
    the class can do other things, such as changing the color parameter of `Material`
    to indicate that it is selected.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法假设`spatial`实际上是一个`Node`。如果不是`Node`，该类可以执行其他操作，例如，将`Material`的颜色参数更改为表示它已被选中。
- en: We might want to display different markers for different types of selections,
    so let's make it flexible by adding a setter method for the marker.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可能希望为不同类型的选中显示不同的标记，所以让我们通过添加一个设置标记的方法来使其更灵活。
- en: Now, we create a new `AppState` class called `SelectAppState`. It should extend
    `AbstractAppState` and implement `ActionListener` to receive mouse click events.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建一个新的`AppState`类，命名为`SelectAppState`。它应该扩展`AbstractAppState`并实现`ActionListener`以接收鼠标点击事件。
- en: 'We''ll add two fields, one static string to represent the mouse click, and
    a `List<Spatial>` called `selectables` where it will store anything that is selectable,
    as follows:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将添加两个字段，一个静态字符串来表示鼠标点击，以及一个名为`selectables`的`List<Spatial>`，它将存储任何可选择的项，如下所示：
- en: '[PRE51]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `initialize` method should look familiar if you've read any of the other
    game control recipes. We add a mapping for `LEFT_CLICK` and register it with the
    application's `InputManager` to ensure it listens for it.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您阅读过其他游戏控制菜谱，`initialize`方法应该很熟悉。我们为`LEFT_CLICK`添加映射，并将其注册到应用程序的`InputManager`，以确保它监听它。
- en: The only thing the `onAction` method will currently do is to trigger the `onClick`
    method when the left mouse button is pressed.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onAction`方法目前唯一要做的事情是在按下左鼠标按钮时触发`onClick`方法。'
- en: 'Mouse selection (or picking) works by shooting `Ray` from the position of the
    mouse cursor into the screen. We begin by getting the position of the mouse cursor
    on the screen as follows:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 鼠标选择（或拾取）是通过从鼠标光标位置向屏幕发射`Ray`来工作的。我们首先获取屏幕上鼠标光标的位置，如下所示：
- en: '[PRE52]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, we get the position this represents in the game world as follows:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们获取它在游戏世界中的位置，如下所示：
- en: '[PRE53]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, we can see what direction this would be by extending the position deeper
    into the camera''s projection, as follows:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过将位置延伸到摄像机的投影中更深处来查看这个方向，如下所示：
- en: '[PRE54]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The following figure shows you how `BoundingVolume`, in the shape of a box,
    can enclose the character:'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下图显示了以盒子形状的`BoundingVolume`如何包围角色：
- en: '![How to do it...](img/6478OS_02_04.jpg)'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/6478OS_02_04.jpg)'
- en: We define `Ray` using `mousePos3D` as the origin and `clickDir` as the direction
    and a `CollisionResults` instance to store any collisions that will occur.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`mousePos3D`作为原点，`clickDir`作为方向，并创建一个`CollisionResults`实例来存储可能发生的任何碰撞。
- en: 'Now, we can define a `for` loop that goes through our `selectables` list and
    checks whether `Ray` intersects with any of `BoundingVolumes`. The `CollisionResults`
    instance adds them to a list, and we can then retrieve the closest collision which,
    for most cases, is the most relevant one, as follows:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以定义一个`for`循环，遍历我们的`selectables`列表，并检查`Ray`是否与任何`BoundingVolumes`相交。`CollisionResults`实例将它们添加到列表中，然后我们可以检索最近的碰撞，对于大多数情况，这是最相关的，如下所示：
- en: '[PRE55]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Tip
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It's a good idea to have a look at the `CollisionResults` class as well as `CollisionResult`,
    as these classes already keep track of many useful things that will save valuable
    coding time.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 看一下`CollisionResults`类以及`CollisionResult`是个好主意，因为这些类已经跟踪了许多有用的东西，这将节省宝贵的编码时间。
- en: 'After this, we can parse through our `selectable` list to see whether the `spatial`
    that was clicked on has any of the items in the list. If it is, we call the following
    code:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后，我们可以遍历我们的`selectable`列表，查看被点击的`spatial`是否包含列表中的任何项目。如果是，我们调用以下代码：
- en: '[PRE56]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Depending on the requirements, we might want to deselect all other spatials
    at this point. If we're using nodes, we might also need to see whether it is any
    of the spatial's children that were hit by the ray as well.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据要求，我们可能想要在这个时候取消选择所有其他`spatial`。如果我们使用节点，我们也可能需要查看是否是任何被射线击中的空间的孩子。
- en: To test this, we can use the same class used in the previous recipe, with a
    few additional lines.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试这个，我们可以使用之前配方中使用的相同类，并添加几行代码。
- en: 'First of all, we need to create and attach `SelectAppState` as follows:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建并附加`SelectAppState`，如下所示：
- en: '[PRE57]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Create `SelectableControl` and something that can be used as a marker (in this
    case, it will be a simple Quad).
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`SelectableControl`以及可以作为标记的东西（在这个例子中，它将是一个简单的四边形）。
- en: 'Lastly, we need to add `SelectableControl` to our Jaime model, and then add
    Jaime as a selectable to `AppState` as follows:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要将`SelectableControl`添加到我们的Jaime模型中，然后将Jaime作为可选择的添加到`AppState`中，如下所示：
- en: '[PRE58]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: If we now run the example and click on Jaime, the Quad should be rendered near
    his feet.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在运行示例并点击Jaime，四边形应该渲染在他的脚边。
- en: How it works...
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This example shows you one of the strengths of using `Control` and `AppState`,
    as it's easy to add functionalities to a `spatial` object as long as the logic
    is kept modular. Another (although possibly less effective) way of performing
    the selection would be to run a collision check against all `spatial` objects
    in a scene and use `Spatial.getControl (SelectableControl.class)` to see whether
    any of the spatials should be possible to select.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了使用`Control`和`AppState`的一个优点，因为只要逻辑保持模块化，就很容易向`spatial`对象添加功能。另一种（尽管可能不太有效）执行选择的方法是对场景中的所有`spatial`对象运行碰撞检查，并使用`Spatial.getControl
    (SelectableControl.class)`来查看是否有任何`spatial`可以被选择。
- en: In this recipe, the items in the `selectables` list extend the `Spatial` class,
    but the only actual requirement is that the objects implement the `Collidable`
    interface.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，`selectables`列表中的项目扩展了`Spatial`类，但唯一实际的要求是对象实现`Collidable`接口。
- en: When shooting the ray, we get the position of the mouse cursor from `InputManager`.
    It's a `Vector2f` object, where `0,0` is the bottom-left corner, and the top-right
    corner equals the height and width of the screen (in units). After this, we use
    `Camera.getWorldCoordinates` to give us a 3D position of the mouse click (or any
    position on the screen). To do this, we must supply a depth value. This is between
    0, which is closest to the screen, and 1f, into infinity. The direction would
    then be the difference between the nearest and farthest value, and it would be
    normalized.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当射击射线时，我们从`InputManager`获取鼠标光标的当前位置。它是一个`Vector2f`对象，其中`0,0`是左下角，右上角等于屏幕的高度和宽度（以单位计）。之后，我们使用`Camera.getWorldCoordinates`来给我们鼠标点击（或屏幕上的任何位置）的3D位置。为此，我们必须提供一个深度值。这个值在0（最接近屏幕）和1f（无限远）之间。方向将是最近和最远值之间的差异，并且它将被归一化。
- en: Making the camera follow units
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让摄像机跟随单位
- en: This recipe will cover some principles on how to make the camera follow something
    in the game world. While it might seem like an easy task at first, there are some
    tricky bits too.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将涵盖一些如何在游戏世界中让摄像机跟随某些物体的原则。虽然一开始这可能看起来是一个简单的任务，但也有一些棘手的地方。
- en: Getting ready
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The recipe will build upon the *Creating an RTS camera AppState object* recipe
    of this chapter. All of the steps described in this recipe will be applied to
    `AppState`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将基于本章的*创建一个RTS摄像机AppState对象*配方。本配方中描述的所有步骤都将应用于`AppState`。
- en: How to do it...
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To make the camera follow units, perform the following steps:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要让摄像机跟随单位，执行以下步骤：
- en: We start by adding two new variables, which we'll use for the new functionality.
    A Vector3f variable, called `targetLocation`, will be used to track the target,
    and a Boolean variable called `follow`, will be used to declare whether the camera
    should track the target or not. These are set from external classes.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先添加两个新变量，我们将使用它们来实现新功能。一个名为`targetLocation`的Vector3f变量将用于跟踪目标，一个名为`follow`的布尔变量将用于声明摄像机是否应该跟踪目标。这些是从外部类设置的。
- en: Out of convenience, we also define a final Vector3f variable, called `UNIT_XZ`,
    which we set to`(1f, 0, 1f)`. We'll use this to convert 3D positions to 2D.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了方便起见，我们还定义了一个名为`UNIT_XZ`的最终Vector3f变量，并将其设置为`(1f, 0, 1f)`。我们将使用它将3D位置转换为2D。
- en: Then, we need to add some functionality in the `update` method just before `cam.setLocation(camLocation);`.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要在`cam.setLocation(camLocation);`之前在`update`方法中添加一些功能。
- en: 'First, we add a check to see whether the camera has been moved by the player.
    If so, we turn off the tracking as follows:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们添加一个检查以查看摄像机是否被玩家移动。如果是这样，我们按照以下方式关闭跟踪：
- en: '[PRE59]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Since the camera is up in the air and the target is (most likely) on the ground,
    we transform the camera''s location to a position on the same horizontal plane
    as the target. The `targetLocation` vector is pretty simple to handle. We just
    flatten it by zeroing on the `Y` value as follows:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于摄像机在空中而目标（很可能是）在地面，我们将摄像机的位置转换到与目标相同的水平平面上的位置。`targetLocation`向量处理起来相当简单。我们只需通过将`Y`值置零来展平它，如下所示：
- en: '[PRE60]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The camera is a bit trickier; since we''re interested in the target''s position
    in relation to the point the camera is looking at, we need to first find out where
    it is looking. First, we get the relative position of the point the camera is
    looking at by multiplying the height with the direction as follows:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 摄像机有点棘手；由于我们感兴趣的是目标相对于摄像机注视点的位置，我们首先需要找出它在哪里注视。首先，我们通过将高度与方向相乘来获取摄像机注视点的相对位置，如下所示：
- en: '[PRE61]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then, we add it to the camera''s location (you can say that we project it on
    the ground) to get its world position. Finally, we flatten this as well with `UNIT_XZ`
    as follows:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将它添加到摄像机的位置（你可以说是我们在地面上投影它）以获取其世界位置。最后，我们用`UNIT_XZ`将其也展平，如下所示：
- en: '[PRE62]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We''re using a linear interpolation that moves the camera''s focus point 30
    percent closer to the target location each cycle. Then, we reverse the addition
    we did earlier (or unproject) to get a new 3D position for the camera. The distance
    check is optional, but since we''re going to use interpolation, we might save
    a few calculations by only interpolating if the distance is above a certain threshold
    as follows:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用线性插值，每次循环将摄像机的焦点点移动到目标位置30%。然后，我们撤销我们之前所做的添加（或反投影）以获取摄像机的新的3D位置。距离检查是可选的，但由于我们将使用插值，如果我们只在上面的某个阈值以上进行插值，我们可能会节省一些计算，如下所示：
- en: '[PRE63]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'To show that these changes work, we need to change a few things in our test
    application. We can grab Jaime from our scene and use his translation as the target
    location. We use `worldTranslation` and not `localTranslation` in this case:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了证明这些更改有效，我们需要在我们的测试应用程序中更改一些东西。我们可以从场景中抓取Jaime，并使用他的平移作为目标位置。在这种情况下，我们使用`worldTranslation`而不是`localTranslation`：
- en: '[PRE64]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Then, in the `update` method of the test case, we make him slowly move along
    the *x* axis as follows:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在测试用例的`update`方法中，我们让他沿着*x*轴缓慢移动，如下所示：
- en: '[PRE65]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: While running the application, we should see the camera follow Jaime until we
    move it manually.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行应用程序时，我们应该看到相机跟随Jaime，直到我们手动移动它。
- en: How it works...
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Another way of handling it would be not to move the camera during the input
    but the actual point it looks at, and have the camera troll along. No matter which
    way you choose to do it though, practicing and thus getting a better understanding
    of these trigonometric problems is always a good idea.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种处理方式是在输入时不要移动相机，而是它实际注视的点，让相机沿着它滚动。不过，无论你选择哪种方式，练习并因此更好地理解这些三角学问题总是一个好主意。
- en: Since we're using linear interpolation here, `camLocation2D` will never actually
    reach `targetLocation`; it'll just get infinitely closer. This is why an `if`
    statement can be useful in these cases to see whether it's worth actually changing
    the distance or not. Finding the right threshold to break off is empiric and varies
    from case to case.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这里使用线性插值，`camLocation2D`实际上永远不会达到`targetLocation`；它只会无限接近。这就是为什么在这些情况下，`if`语句可以很有用，以查看是否真的值得改变距离。找到合适的阈值来中断是经验性的，并且因情况而异。
- en: Following a character with ChaseCamera
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ChaseCamera跟随角色
- en: In this recipe, we'll explore jMonkeyEngine's `ChaseCamera` class. This camera
    is a bit different from the previous cameras we've explored since we don't have
    direct control over its position. It is not like the camera-on-a-stick method
    we tried in the *Creating a reusable character control* recipe. While it still
    follows and looks at the character, it can float around the character more freely
    and also be controlled by the player.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探索jMonkeyEngine的`ChaseCamera`类。这个相机与我们之前探索的相机有点不同，因为我们无法直接控制其位置。它不像我们在*创建可重用角色控制*菜谱中尝试的“相机在棍子上”的方法。虽然它仍然跟随并注视角色，但它可以更自由地在角色周围浮动，也可以由玩家控制。
- en: The default control for the camera is to hold down the left mouse button and
    drag it to rotate the camera around the character. This is a very common control
    pattern in third-person games on consoles, where you rotate the camera with the
    left stick and control the character with the right.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 相机的默认控制方式是按住鼠标左键并拖动它来绕着角色旋转相机。这在游戏机上的第三人称游戏中是一个非常常见的控制模式，在那里你用左摇杆旋转相机，用右摇杆控制角色。
- en: We will implement a behavior where the character moves in the direction the
    camera is facing rather than the direction the character is facing when you press
    the forward key. This is common in console games.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一种行为，其中角色在按前进键时朝向相机的方向移动，而不是朝向角色面对的方向。这在游戏机上很常见。
- en: Getting ready
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Out of convenience, we'll extend, or modify, the `GameCharacterControl` class
    from earlier. This way, we'll get some of the basic functionality and save some
    time.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们将扩展或修改之前提到的`GameCharacterControl`类。这样，我们将获得一些基本功能并节省一些时间。
- en: How to do it...
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To start off, we can create a new `SimpleApplication` class in which we''ll
    apply the following steps:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，我们可以在新的`SimpleApplication`类中创建一个新类，我们将应用以下步骤：
- en: 'To initialize the camera, you supply the application''s camera, `spatial`,
    to be followed, and the input manager, as follows:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要初始化相机，你需要提供要跟随的应用程序相机`spatial`和输入管理器，如下所示：
- en: '[PRE66]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `ChaseCamera` class has lots of settings to suit different kinds of games.
    To start off, we turn off the need to hold down the left mouse button to rotate
    the camera. It''s not something we want for this recipe. This is implemented as
    follows:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ChaseCamera`类有很多设置来适应不同类型的游戏。为了开始，我们关闭了需要按住鼠标左键来旋转相机的需求。这不是我们在这个菜谱中想要的。这如下实现：'
- en: '[PRE67]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We do, however, want smooth movement for the camera. For this, type the following
    line of code:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，我们确实希望相机有平滑的运动。为此，输入以下代码行：
- en: '[PRE68]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: By default, the camera will focus on the origin point of `spatial`, which in
    this case, would be Jaime's feet. We can easily make it look at a higher-up point,
    such as `waist.chaseCam.setLookAtOffset(new Vector3f(0, 1f, 0));`.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，相机将聚焦于`spatial`的原点，在这种情况下，将是Jaime的脚。我们可以轻松地让它看向更高的点，例如`waist.chaseCam.setLookAtOffset(new
    Vector3f(0, 1f, 0));`。
- en: 'Next, we set some distance restrictions for the camera. There is no guarantee
    that it will stay within those boundaries though. It especially seems to violate
    `minDistance`:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们为相机设置一些距离限制。但是，不能保证它会保持在那些边界内。它尤其似乎违反了`minDistance`：
- en: '[PRE69]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The `ChasingSensitivity` method defines how quickly the camera will follow
    `spatial`. If it''s `1`, it will follow slowly and if it''s `5`, it will follow
    quickly. We want the camera to be pretty responsive in this recipe:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ChasingSensitivity`方法定义了相机跟随`spatial`的速度。如果它是`1`，它会缓慢跟随；如果它是`5`，它会快速跟随。我们希望在这个食谱中相机非常灵敏：'
- en: '[PRE70]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The following `RotationSpeed` method defines how quickly the camera moves when
    moving it:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下`RotationSpeed`方法定义了移动相机时的移动速度：
- en: '[PRE71]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Now, we have a basic setup for `ChaseCamera`. Let's see what we need to do to
    the `GameCharacterControl` class to suit this kind of game.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经为`ChaseCamera`设置了一个基本配置。让我们看看我们需要对`GameCharacterControl`类进行哪些修改以适应这种游戏。
- en: 'We can easily apply the behavior where forward is the direction of the camera
    by replacing the two lines, and setting `modelForwardDir` and `modelLeftDir` in
    the `update` method:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以轻松地应用这样的行为，即前进方向是相机的方向，通过替换两行，并在`update`方法中设置`modelForwardDir`和`modelLeftDir`：
- en: '[PRE72]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Since we don''t directly control the characters'' view direction anymore, we
    can set it to always be the last direction the character faced (when moving) as
    follows:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们不再直接控制角色的视图方向，我们可以将其设置为始终是角色面对的最后一个方向（当移动时），如下所示：
- en: '[PRE73]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'At the end of the method, we mustn''t forget to apply it to `PhysicsCharacter`
    as follows:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在方法末尾，我们别忘了将其应用到`PhysicsCharacter`上，如下所示：
- en: '[PRE74]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: How it works...
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `ChaseCamera` class is a convenient class that offloads a lot of camera
    handling from the coder. It has a lot of settings that can be tweaked to get the
    desired behavior. Camera tweaking is a delicate and time-consuming matter, and
    if you're working in a team, this is something a designer might do if the properties
    would be exposed in a text file and loaded during startup.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChaseCamera`类是一个方便的类，它将大量的相机处理工作从程序员那里卸载下来。它有许多可以调整的设置，以获得期望的行为。相机调整是一个细致且耗时的工作，如果你在一个团队中工作，如果这些属性以文本文件的形式公开并在启动时加载，那么这可能是一个设计师可能会做的事情。'
- en: There's more…
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: If you press forward and then rotate the camera, the character will move in
    that direction, instead. In many games of this type, however, the character would
    keep running in the direction it had before the player rotated the camera. We
    can apply this behavior to our character with a few tweaks.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按下前进然后旋转相机，角色将朝那个方向移动。然而，在许多这类游戏中，角色会继续沿着玩家旋转相机之前的方向奔跑。我们可以通过一些调整将这种行为应用到我们的角色上。
- en: 'To do this, we need to change `modelForwardDir` and `modelLeftDir` into private
    fields in the class. Then, we make sure we only update these when the character
    isn''t receiving any input from the player. In this recipe, this would mean an
    `if` statement, as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要将`modelForwardDir`和`modelLeftDir`改为类中的私有字段。然后，我们确保只有在角色没有从玩家那里接收任何输入时才更新这些字段。在这个食谱中，这意味着一个`if`语句，如下所示：
- en: '[PRE75]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Adding a game controller or joystick input
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加游戏控制器或摇杆输入
- en: So far, we've used the mouse and keyboard for input. It's the most common way
    to handle controls on a PC, but let's explore the game controller and joystick
    support in jMonkeyEngine a bit. Writing code for a game controller is not very
    difficult. The tricky part is being agnostic enough to support the wide range
    of devices out there. Gone are the days when a joystick only had four directions
    and a fire button.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用了鼠标和键盘进行输入。这是在PC上处理控制的最常见方式，但让我们在jMonkeyEngine中探索一下游戏控制器和摇杆支持。为游戏控制器编写代码并不困难。困难的部分是足够通用以支持广泛的各种设备。摇杆只有四个方向和一个开火按钮的时代已经过去了。
- en: Getting ready
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Like in many recipes in this chapter, we'll use `InputAppState` from the *Attaching
    an input AppState object* recipe. This recipe will be fine to apply to any input
    handling class. Naturally, some kind of input device is necessary as well.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 就像本章中的许多食谱一样，我们将使用来自*附加输入AppState对象*食谱的`InputAppState`。这个食谱适用于任何输入处理类。当然，还需要某种类型的输入设备。
- en: How to do it...
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To add a game controller or joystick input, perform the following steps:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加游戏控制器或摇杆输入，请执行以下步骤：
- en: First of all, any controllers that the system recognizes will be available through
    `inputManager.getJoysticks()`. We'll create a new method called `assignJoysticks()`
    where we apply this.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，系统识别到的任何控制器都可通过`inputManager.getJoysticks()`获取。我们将创建一个新的方法`assignJoysticks()`来应用这个方法。
- en: 'These controllers might turn up differently, in no particular order. It also
    seems as if they can sometimes show duplicate axes or some axes as separate controls.
    How can we handle this? The safest way might just be to have a `for` loop, parsing
    all controllers and trying to map them to the controls as follows:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些控制器可能以不同的方式出现，没有特定的顺序。有时它们似乎还会显示重复的轴或某些轴作为单独的控制。我们该如何处理这种情况？最安全的方法可能就是使用一个`for`循环，解析所有控制器并尝试将它们映射到以下控制上：
- en: '[PRE76]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'A difference between keyboard and mouse mapping is that we don''t actually
    need to add new mappings to `InputManager`. Instead, we tell the joystick what
    actions to emit. In this case, it''s the *x* axis on the left stick that is assigned
    the strafing action as follows:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 键盘和鼠标映射之间的一个区别是我们实际上不需要向`InputManager`添加新的映射。相反，我们告诉摇杆要发出哪些动作。在这种情况下，是左侧摇杆上的*x*轴被分配了移动动作，如下所示：
- en: '[PRE77]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Note
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *x* and *y* axes are often simple to map, usually on the left stick on the
    controller. The right one might not be as obvious. In this example, it's mapped
    to the rotation-X and rotation-Y axes, but might be mapped to the *z* axis, or
    rotation-Z as well.
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*x*轴和*y*轴通常很容易映射，通常位于控制器的左侧摇杆上。右侧的轴可能不那么明显。在这个例子中，它被映射到旋转-X和旋转-Y轴上，但也可能被映射到*z*轴或旋转-Z轴上。'
- en: 'In the same way, we can assign buttons to emit specific actions:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们可以将按钮分配给发出特定动作：
- en: '[PRE78]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: How it works...
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A joystick is an input device, just like the mouse or keyboard. While there
    is a way to map the actions in the same way, with `InputManager.addMapping()`,
    the recommended way is to do the reverse and assign actions to the joystick instead.
    Remember that `InputManager` still needs to listen to the mappings.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 摇杆是一种输入设备，就像鼠标或键盘一样。虽然可以通过`InputManager.addMapping()`以相同的方式映射动作，但推荐的方式是反过来，将动作分配给摇杆。记住，`InputManager`仍然需要监听映射。
- en: Mapping buttons is even trickier than axes. First of all, there are two types
    of buttons, analog and digital. On a controller, usually the lower-right and left
    buttons controlled by the index fingers are analog, whereas all other buttons
    usually are digital. In jMonkeyEngine, everything analog is an axis. So, you will
    find that most likely, these will be reported as an axis.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 映射按钮比映射轴更复杂。首先，有两种类型的按钮：模拟和数字。在控制器上，通常由食指控制的右下角和左下角的按钮是模拟的，而其他所有按钮通常是数字的。在jMonkeyEngine中，所有模拟的都视为轴。因此，你会发现这些很可能是作为轴来报告的。
- en: Note
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On my controller, a Razer Hydra, left and right triggers are reported as the
    *z* axis.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的控制器Razer Hydra上，左右扳机被报告为*z*轴。
- en: As if that's not enough, all you have to work with is a button index. Fortunately,
    with most game controllers emulating one of the big brands of console makers,
    some kind of standard can be expected. However, there are exceptions, and for
    any serious game, an interface where the user can remap their device is a must.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎还不够，你只能使用按钮索引来工作。幸运的是，由于大多数游戏控制器模拟了大型游戏机制造商的品牌，可以期待某种标准。然而，也有一些例外，对于任何严肃的游戏，一个允许用户重新映射其设备的界面是必需的。
- en: There's more…
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There's a good, visual test example in the jMonkeyEngine project called `TestJoystick`,
    where you can instantly see the mapping of the attached controller and the corresponding
    action of each input.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在jMonkeyEngine项目中有一个很好的、可视的测试示例，名为`TestJoystick`，你可以立即看到附加控制器的映射和每个输入的相应动作。
- en: 'The following figure shows you a view in the TestJoystick example:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了TestJoystick示例中的视图：
- en: '![There''s more…](img/6478OS_02_02.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多…](img/6478OS_02_02.jpg)'
- en: Leaning around corners
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在角落里学习
- en: If you're making a sneaker or tactical shooter game, a common feature is to
    be able to lean around corners. This is used to scout without being seen or shooting
    without exposing yourself too much. In this recipe, we'll develop a way to do
    this with our `GameCharacterControl` class. We will implement functionalities
    to both handle leaning with keys (such as the shoulder buttons on a gamepad) and
    freeform leaning with the mouse.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在制作运动鞋或战术射击游戏，一个常见的功能是能够绕角落倾斜。这用于侦察而不被发现或射击而不暴露自己太多。在这个菜谱中，我们将开发一种使用我们的`GameCharacterControl`类来实现这一功能的方法。我们将实现使用按键（如游戏手柄上的肩部按钮）处理倾斜和自由形式倾斜的鼠标。
- en: Getting ready
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe will expand on the `GameCharacterControl` and `InputAppState` classes
    from the beginning of the chapter, but it should be easy to adapt to your own
    project. It is mostly used in FPS games, and this is what we will build it for.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将扩展本章开头的`GameCharacterControl`和`InputAppState`类，但应该很容易适应你自己的项目。它主要用于FPS游戏，这就是我们将为它构建的。
- en: Leaning in this example will emulate the player character moving the upper body.
    To achieve this and to save us some calculations on how much the camera should
    be offset when leaning, we will use the built-in behavior of spatials and how
    translation and rotation is propagated through in a node.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，倾斜将模拟玩家角色移动上半身。为了实现这一点并节省我们在倾斜时如何偏移摄像机的计算，我们将使用spatials的内置行为以及如何在节点中传播平移和旋转。
- en: How to do it...
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First of all, we need a new `Node` instance called `centerPoint` in our `GameCharacterControl`.
    This will be the origin of our leaning, so to speak:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在`GameCharacterControl`中创建一个新的`Node`实例，称为`centerPoint`。这将是我们的倾斜原点，换句话说：
- en: '[PRE79]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We set the translation to be pretty much in the center of the character''s
    body (half the distance to the camera). We also attach the head node to `centerPoint`.
    In the `setSpatial` method, we add the following lines of code:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将平移设置为位于角色身体中心（到摄像机的距离的一半）。我们还把头部节点附加到`centerPoint`。在`setSpatial`方法中，我们添加以下代码行：
- en: '[PRE80]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The following figure shows you the relation between the `head` and `centerPoint`
    nodes:'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下图显示了`head`和`centerPoint`节点之间的关系：
- en: '![How to do it...](img/6478OS_02_01.jpg)'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/6478OS_02_01.jpg)'
- en: 'We continue to follow the pattern we have used in `GameCharacterControl` and
    use Booleans to define whether an action should happen and then handle any changes
    in the `update` method. So, let''s start by adding three new Booleans to handle
    leaning as follows:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们继续遵循在`GameCharacterControl`中使用的模式，并使用布尔值来定义是否应该发生某个动作，然后在`update`方法中处理任何变化。所以，让我们先添加三个新的布尔值来处理倾斜，如下所示：
- en: '[PRE81]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now, before we add the actual leaning functionality, we need to introduce two
    more fields. The `leanValue` field stores the current amount of leaning for the
    character. We use the `maxLean` field to have some kind of limit to how much the
    player can lean. This is in radians and is set to corresponding 22.5 degrees.
    Sounds too little? Feel free to experiment using the following lines of code:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在我们添加实际的倾斜功能之前，我们需要引入两个额外的字段。`leanValue`字段存储角色的当前倾斜量。我们使用`maxLean`字段来限制玩家可以倾斜的最大程度。这是以弧度为单位，设置为相应的22.5度。听起来太少？请随意使用以下代码行进行实验：
- en: '[PRE82]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'In the `onAction` method, we make sure that we handle the corresponding input.
    Again, after setting the Booleans like this, make sure our actions stay on until
    the key is released:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onAction`方法中，我们确保我们处理相应的输入。同样，在设置布尔值之后，确保我们的动作持续到按键释放：
- en: '[PRE83]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Applying the leaning value is pretty straightforward. We do this in a method
    called `lean`, which takes a float value as the input. First, we clamp `leanValue`
    to make sure we don''t exceed our `maxLean` value. Then, we set the rotation along
    the *z* axis to the negative value as follows:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用倾斜值相当直接。我们在一个名为`lean`的方法中这样做，该方法接受一个浮点值作为输入。首先，我们将`leanValue`夹具以确信我们不超过`maxLean`值。然后，我们将沿*z*轴设置旋转为以下负值：
- en: '[PRE84]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'One bit left now, and that''s where to call this method from. In the `update`
    method, we add two blocks of code. This reads as: if the button for leaning left
    is pressed and the leaning value is less than the maximum leaning value, lean
    more. Otherwise, if the button for free leaning is not pressed and the lean value
    is more than 0, lean less:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在还剩一个比特位，那就是调用这个方法的地方。在`update`方法中，我们添加了两块代码。这可以读作：如果按下向左倾斜的按钮并且倾斜值小于最大倾斜值，则倾斜更多。否则，如果未按下自由倾斜按钮并且倾斜值大于0，则倾斜较少：
- en: '[PRE85]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: This code block then needs to be mirrored to lean in the other direction.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后需要将此代码块镜像以实现向另一方向倾斜。
- en: 'That''s it for controlling leaning with buttons only. To add leaning using
    the mouse when `leanFree` is pressed, the `onAnalog` method needs a bit of work
    as well. We need to hijack the `RotateLeft` and `RotateRight` inputs when `leanFree`
    is set to `true`. The character shouldn''t turn then, but it should lean instead.
    This is easily done with an `if` statement. We apply the lean value instantly
    in this case. The code we added previously in the `update` method will take care
    of returning the leaning to zero when the button is released:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅使用按钮控制倾斜就到这里了。要添加在按下`leanFree`时使用鼠标进行倾斜的功能，`onAnalog`方法也需要做一些工作。当`leanFree`设置为`true`时，我们需要拦截`RotateLeft`和`RotateRight`输入。此时角色不应该转向，而应该倾斜。这可以通过一个`if`语句轻松实现。在这种情况下，我们立即应用倾斜值。我们在`update`方法中之前添加的代码将负责在按钮释放时将倾斜值返回到零：
- en: '[PRE86]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: We already have `InputAppState`, which handles our input, so let's add a few
    more buttons to it. Three more values to our `InputMapping` enum are `LeanLeft`,
    `LeanRight`, and `LeanFree`.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经有了`InputAppState`，它处理我们的输入，所以让我们给它添加一些更多的按钮。在`InputMapping`枚举中添加三个更多值：`LeanLeft`、`LeanRight`和`LeanFree`。
- en: Then, we assign those to *Q* and *E* keys to lean left and right, and V for
    free, or analog leaning.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将它们分配给*Q*和*E*键以实现向左和向右倾斜，V键用于自由倾斜或模拟倾斜。
- en: How it works...
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This is an easy way to handle leaning since we have very few calculations to
    do. The scene graph takes care of that for us. This works for the same reason;
    the turning of the `head` node in the *Creating a reusable character control*
    recipe could control the camera, which is normally not available in the scene
    graph. By attaching the `head` node to the center point (which, in turn, is attached
    to the main player node), any rotation or movement that the node does will be
    propagated to the `head` node, and thus, the camera.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种处理倾斜的简单方法，因为我们需要做的计算很少。场景图为我们处理了这一点。这同样适用于相同的原因；在*创建可重用角色控制*菜谱中`head`节点的旋转可以控制相机，这在场景图中通常是不可能的。通过将`head`节点附加到中心点（该中心点反过来又附加到主要玩家节点），节点所做的任何旋转或移动都将传播到`head`节点，从而影响相机。
- en: Detecting cover automatically in a third-person game
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在第三人称游戏中自动检测掩护
- en: Cover shooters is an ever-popular genre in today's console games. How does one
    code a system that recognizes and allows players to take cover? There are several
    ways to do this, but basically, there are two main branches, each with their benefits
    and drawbacks. The first branch is one where a level designer places logical cover
    items around the environments or where they are baked into models by an artist.
    This could be as simple as a bounding volume, or it could be complex with directional
    data as well. This has a benefit for the programmer in that it's easy to recognize
    when a player is inside them by comparing bounding volumes. Another benefit is
    that the designer has full control over where there is cover and where there isn't.
    A drawback is that it is labor-intensive for the designer or artist and might
    be inconsistent to the player.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖射击类游戏是当今主机游戏中的一个永受欢迎的流派。如何编写一个识别并允许玩家进行掩护的系统呢？有几种方法可以实现这一点，但基本上，主要有两个分支，每个分支都有其优势和劣势。第一个分支是设计师在环境中放置逻辑掩护物品，或者艺术家将它们嵌入模型中。这可能只是一个边界体积，也可能非常复杂，包含方向数据。这对程序员来说是一个好处，因为通过比较边界体积，很容易识别玩家是否在掩护物内。另一个好处是设计师可以完全控制掩护物的位置和不存在的地方。一个劣势是，对设计师或艺术家来说，这很费时，并且可能对玩家来说不够一致。
- en: The method we'll implement is one where there is no pregenerated cover, and
    it's checked in runtime. No additional work is required for a designer or artist,
    except that the models that are used need to be of a certain height to be recognized
    as cover (and work with animations).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现的方法是一个没有预生成掩护，而是在运行时检查的方法。除了使用的模型需要达到一定高度才能被识别为掩护（并且与动画一起工作）之外，设计师或艺术家不需要做任何额外的工作。
- en: 'Normally, there are two different kinds of cover: a low cover that characters
    can crouch behind and shoot over. The other one is full height cover, where characters
    stand next to the edge of it and shoot around the corner. In some games, it''s
    only possible to use full height covers where it''s also possible to shoot from
    them, such as corners.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，有两种不同类型的掩护：一种是低掩护，角色可以蹲在后面射击。另一种是全高度掩护，角色站在掩护的边缘并从角落射击。在某些游戏中，只有在可以从中射击的地方，才可能使用全高度掩护，例如角落。
- en: Once the character is in cover, certain movement restrictions usually apply.
    In most games, the player can move sideways along the cover. In some games, moving
    backwards will release the character from the cover, while in others, you have
    to toggle the cover button. We'll implement the latter.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦角色进入掩护，通常会有一些移动限制。在大多数游戏中，玩家可以沿着掩护侧向移动。在某些游戏中，向后移动会释放角色从掩护中出来，而在其他游戏中，你必须切换掩护按钮。我们将实现后者。
- en: Getting ready
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's define in more detail what we'll implement and how. We'll use `Rays` to
    detect whether the player is covered or not and `KeyTrigger` to toggle the entering
    or exiting cover. If you're not familiar with the concept of Rays, you can, for
    example, have a look at the *Firing in FPS* or *Selecting units in RTS* recipes
    in this chapter. Cover can be anything in the scene above a certain height. All
    of the action in this recipe will be handled by `GameCharacterControl` from the
    *Following a character with ChaseCamera* recipe. There are two separate areas
    we need to look at. One is the cover detection itself, and the other is related
    to how the character should behave when in cover.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地定义我们将要实现的内容以及如何实现。我们将使用 `Rays` 来检测玩家是否被掩护，并使用 `KeyTrigger` 来切换进入或退出掩护。如果你不熟悉
    `Ray` 的概念，例如，你可以查看本章中的 *FPS中的射击* 或 *RTS中的选择单位* 菜单。掩护可以是场景中高于一定高度的所有内容。本菜谱中的所有动作将由
    *跟随角色使用ChaseCamera* 菜谱中的 `GameCharacterControl` 处理。我们需要查看两个独立区域。一个是掩护检测本身，另一个是关于角色在掩护中应该如何表现的相关内容。
- en: How to do it...
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To implement automatic cover detection, perform the following steps:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现自动掩护检测，请执行以下步骤：
- en: 'There are a few new fields we need to introduce to keep track of things. It''s
    not enough to simply send one ray from the center to detect the cover, so we''ll
    need to cast from the edges or near edges of the player model as well. We call
    this offset `playerWidth`. The `inCover` variable is used to keep track of whether
    the player is in cover mode or not (toggled). The `hasLowCover` and `hasHighCover`
    variables are set in the cover-detection method and are a way for us to know whether
    the player is currently within limits of a cover (but not necessarily in the cover
    mode). The `lowHeight` and `highHeight` variables are the heights where we''ll
    cast `Ray` from in order to check for cover. The `structures` variable is everything
    we should check for cover against. Don''t supply `rootNode` here or we''ll end
    up colliding with ourselves:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要引入一些新的字段来跟踪事物。仅仅从中心发射一束光线来检测掩护是不够的，因此我们还需要从玩家模型的边缘或接近边缘发射。我们称这个偏移量为 `playerWidth`。`inCover`
    变量用于跟踪玩家是否处于掩护模式（切换）。`hasLowCover` 和 `hasHighCover` 变量在掩护检测方法中设置，这是我们了解玩家是否当前处于掩护范围内（但不一定处于掩护模式）的一种方式。`lowHeight`
    和 `highHeight` 变量是我们将从中发射 `Ray` 以检查掩护的高度。`structures` 变量是我们应该检查掩护的所有内容。这里不要提供
    `rootNode`，否则我们最终会与自己发生碰撞：
- en: '[PRE87]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Now let's move to the fun part, which is detecting cover. A new method called
    `checkCover` needs to be created. It takes `Vector3f` as the input and is the
    position from where the rays originate need to be originated.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们转到有趣的部分，即检测掩护。需要创建一个新的方法，称为 `checkCover`。它接受 `Vector3f` 作为输入，并且是从哪里发射光线需要起源的位置。
- en: 'Next, we define a new `Ray` instance. We don''t set the origin yet; we just
    set the direction to be the same as the character''s `viewDirection` and a maximum
    length for it (and this may vary depending on the context and game) as follows:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个新的 `Ray` 实例。我们还没有设置原点；我们只是设置方向与角色的 `viewDirection` 相同，并为其设置一个最大长度（这可能会根据上下文和游戏而变化），如下所示：
- en: '[PRE88]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: We define two integer fields called `lowCollisions` and `highCollisions` to
    keep a track of how many collisions we've had.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了两个整数字段，称为 `lowCollisions` 和 `highCollisions`，以跟踪我们发生了多少次碰撞。
- en: 'Next, we populate a new field called `leftDir`. This is the direction that
    is to the left of the character. We multiply this by `playerWidth` to get the
    left extreme to look for cover in, as follows:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们填充一个新的字段，称为 `leftDir`。这是角色左侧的方向。我们将其乘以 `playerWidth` 以获取左侧极限，以便检查掩护，如下所示：
- en: '[PRE89]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'We''ll start by checking for low covers and set `y` to `lowHeight` as follows:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先检查低掩护，并将 `y` 设置为 `lowHeight`，如下所示：
- en: '[PRE90]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Then, we create a `for` loop that sends three Rays: one at the left extreme
    of the player, one in the center, and one to the right. This is done by multiplying
    `leftDir` with `i`. The loop must then be duplicated for the upper Rays as well:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个`for`循环，发送三条射线：一条在玩家的左侧极限，一条在中心，一条在右侧。这是通过将`leftDir`乘以`i`来实现的。循环必须为上方的射线重复：
- en: '[PRE91]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'In order to be considered to be inside range of a cover, all three (left, middle,
    and right) Rays must hit something. A high cover always has a low cover as well,
    so we can check to see whether we''ve hit the low cover first. If we did, we do
    one more Ray check to find out the normal of the actual triangle hit. This will
    help us align the model with the cover:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了被认为是处于掩护范围内，三条射线（左、中、右）都必须击中某个物体。高掩护总是包含低掩护，因此我们可以检查是否首先击中了低掩护。如果我们击中了，我们将进行一次额外的射线检查，以找出实际击中三角形的法线。这将帮助我们使模型与掩护对齐：
- en: '[PRE92]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The opposite of the triangle''s normal should be the character''s new `viewDirection`:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三角形法线的相反方向应该是角色的新`viewDirection`：
- en: '[PRE93]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Finally, we check whether we also have high cover and set the `hasLowCover`
    and `hasHighCover` fields accordingly.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们检查是否也有高掩护，并相应地设置`hasLowCover`和`hasHighCover`字段。
- en: 'To restrict movement, the `onAction` method needs some modifications. The first
    criterion we check is whether the toggle cover button is pressed. If we''re already
    in cover, we''ll release the character from the cover. If we''re not in cover,
    we check whether it''s possible to go into cover:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了限制移动，`onAction`方法需要一些修改。我们首先检查是否按下了切换掩护按钮。如果我们已经在掩护中，我们将释放角色从掩护中出来。如果我们不在掩护中，我们检查是否有可能进入掩护：
- en: '[PRE94]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: In the following bracket, we limit movement to left and right if we're inside
    cover. If neither of the preceding statements applies, movement should be handled
    as usual. If we didn't want the player to be able to move inside cover, we'd be
    done by now.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下括号中，如果我们处于掩护中，我们限制左右移动。如果前面的任何一条语句都不适用，移动应按常规处理。如果我们不希望玩家能在掩护中移动，我们到现在就已经完成了。
- en: Since we want to mimic popular cover-based games though, we have some more work
    ahead of us.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管我们想要模仿流行的基于掩护的游戏，但我们还有更多的工作要做。
- en: At the top of the update method, we have code to set the direction of the character
    based on the camera's rotation. We need to change this a bit, since once the character
    is inside cover, it should move based on the direction of the cover rather than
    the camera. To achieve this, we add a `!inCover` criterion to the original `if`
    statement, since outside cover, this should work like it worked previously.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在更新方法顶部，我们有根据摄像机的旋转设置角色方向的代码。我们需要稍作修改，因为一旦角色进入掩护，它应该根据掩护的方向而不是摄像机的方向移动。为了实现这一点，我们在原始的`if`语句中添加了一个`!inCover`条件，因为在外部掩护的情况下，这应该像之前一样工作。
- en: 'Then, if we are in cover, we base `modelForwardDir` and `modelLeftDir` on the
    rotation of the spatial, as follows:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，如果我们处于掩护中，我们将`modelForwardDir`和`modelLeftDir`基于空间的旋转来设置，如下所示：
- en: '[PRE95]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Once the movement has been applied to the `walkDirection` vector but before
    it is applied it to the character, we check whether the character will still be
    inside cover after moving:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦将移动应用到`walkDirection`向量中，但在将其应用到角色之前，我们检查角色移动后是否仍然处于掩护中：
- en: '[PRE96]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: We add the current `walkDirection` vector to the position of the player and
    check for cover at that position. If there is none, the movement is not allowed
    and we set `walkDirection` to `0`.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将当前的`walkDirection`向量加到玩家的位置上，并检查该位置是否有掩护。如果没有掩护，则不允许移动，并将`walkDirection`设置为`0`。
- en: 'Now all that''s needed is a new mapping for `ToggleCover`, which is added to
    `InputAppState`:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在所需的就是为`ToggleCover`添加一个新的映射，该映射被添加到`InputAppState`中：
- en: '[PRE97]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: How it works...
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Each time the player presses the `ToggleCover` key or button, a check will be
    run to see whether there is cover within range. Three rays are cast forward from
    a low height, one at the left edge of the model, one from the center, and one
    from the right. Since `leftDir` is multiplied by -1, 0, and 1 on the *x* and *z*
    axes, we get the offset to the left- and right-hand side of the center position.
    To be considered inside cover, all three must have collided with something. This
    ensures that the player model is wholly covered.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 每次玩家按下`ToggleCover`键或按钮时，都会进行一次检查，以确定范围内是否有掩护。从低高度向前发射三条射线，一条在模型的左侧边缘，一条从中心发射，一条从右侧发射。由于`leftDir`在*x*和*z*轴上乘以-1、0和1，我们得到了中心位置左右两侧的偏移量。要被认为是处于掩护之下，三条射线都必须与某个物体发生碰撞。这确保了玩家模型完全被掩护。
- en: The Ray won't stop just because it collides with something, and if the cover
    is thin, it might continue through the back side of it, generating additional
    collisions. We only want to count one collision per ray, though (the closest),
    which is why we only increase `lowCollisions` by one.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 光线不会仅仅因为与物体碰撞就停止，如果掩体很薄，它可能会穿过它的背面，从而产生额外的碰撞。尽管如此，我们只想计算每条光线的一次碰撞（最近的），这就是为什么我们只增加`lowCollisions`一次。
- en: The high cover is checked after the low cover, because in general, there is
    never any cover that only covers the upper body.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查低掩体之后检查高掩体，因为一般来说，永远不会只有覆盖上半身的掩体。
- en: Once it's decided that the character is inside cover and the player wants to
    move, we need to check whether the player will still be inside cover at the new
    position. This is so that the player doesn't accidentally exit cover and end up
    getting killed. To avoid unnecessary performance hits, we don't want to do this
    every frame. We do this only if there has actually been some movement happening.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定角色在掩体内部并且玩家想要移动，我们需要检查玩家在新位置是否仍然在掩体内部。这样做是为了防止玩家意外地离开掩体而被杀。为了避免不必要的性能影响，我们不想每帧都做这个检查。只有在实际上发生了移动时，我们才进行这个检查。
- en: See also
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: To get the most out of this, we will need suitable animations. Refer to [Chapter
    4](ch04.html "Chapter 4. Mastering Character Animations"), *Mastering Character
    Animations*, to get a few ideas on how to do this.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了充分利用这一点，我们需要合适的动画。参考[第4章](ch04.html "第4章。掌握角色动画")，*掌握角色动画*，以获得一些关于如何做到这一点的想法。
