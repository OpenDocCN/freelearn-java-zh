- en: '*Chapter 6*: Observing and Monitoring Cloud-Native Applications'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 6 章*：观察和监控云原生应用程序'
- en: In the previous two chapters, we discussed and explained the varying capabilities
    of the MicroProfile 4.1 platform for building and enhancing your cloud-native
    application. At this point, your cloud-native application is built on a strong
    fundamental core with much credit due to the tried and true components of the
    Jakarta EE platform. On top of that, you've added a few bells and whistles to
    make your application more resilient, secure, configurable, and documentable.
    For all intents and purposes, you have yourself a fully capable cloud-native application
    that's ready for deployment. But as the savvy developer that you are, you know
    that the story of your cloud-native application is not complete once you deploy
    it. Nothing is truly perfect and, depending on the complexity of your application
    ecosystem, letting your applications run wild can be disastrous.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，我们讨论并解释了 MicroProfile 4.1 平台在构建和增强您的云原生应用程序方面的各种功能。此时，您的云原生应用程序建立在强大的基础核心之上，这得益于
    Jakarta EE 平台的经过验证的组件。在此基础上，您添加了一些功能，使您的应用程序更具弹性、安全性、可配置性和可文档化。从所有目的和意义上讲，您已经拥有了一个完全有能力的云原生应用程序，准备部署。但作为您这样的精明开发者，您知道一旦部署了您的云原生应用程序，故事还没有结束。没有任何事情是真正完美的，并且根据您的应用程序生态系统的复杂性，让您的应用程序随意运行可能会造成灾难。
- en: This brings forth the important task of monitoring your applications. You, your
    team, or your operations team will need to be able to monitor the activity and
    performance of your applications to identify any potential problems. Effective
    monitoring can be used as an early warning for impending trouble, shedding light
    on areas that may need optimizing, or aiding in the post-mortem analysis to see
    what might have gone wrong. Alternatively, from a more optimistic perspective,
    effective monitoring can simply provide beautiful data on the performance of your
    application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这带来了监控应用程序的重要任务。您、您的团队或您的运维团队需要能够监控应用程序的活动和性能，以识别任何潜在的问题。有效的监控可以用作即将到来的麻烦的早期预警，揭示可能需要优化的区域，或在事后分析中查看可能出错的地方。或者，从更乐观的角度来看，有效的监控可以简单地提供关于应用程序性能的美丽数据。
- en: This leads us to this chapter, where we will cover the last three specifications
    that are included in the MicroProfile platform's release scope. For observing
    and monitoring your cloud-native applications, the MicroProfile platform provides
    the **MicroProfile Health**, **MicroProfile Metrics**, and **MicroProfile OpenTracing**
    technologies.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这就引出了本章的内容，我们将介绍 MicroProfile 平台发布范围内包含的最后三个规范。为了观察和监控您的云原生应用程序，MicroProfile
    平台提供了 **MicroProfile Health**、**MicroProfile Metrics** 和 **MicroProfile OpenTracing**
    技术。
- en: 'In particular, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是以下内容：
- en: Determining the health of your cloud-native application using MicroProfile Health
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 MicroProfile Health 确定您的云原生应用程序的健康状况
- en: Instrumenting and using metrics on your cloud-native application using MicroProfile
    Metrics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 MicroProfile Metrics 对您的云原生应用程序进行仪表化和使用指标
- en: Tracing your cloud-native application using MicroProfile OpenTracing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 MicroProfile OpenTracing 跟踪您的云原生应用程序
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To build and run the samples mentioned in this chapter, you will need a Mac
    or PC (Windows or Linux) with the following software:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建和运行本章中提到的示例，您需要一个装有以下软件的 Mac 或 PC（Windows 或 Linux）：
- en: 'Java Development Kit, version 8 or higher: [https://adoptium.net/](https://adoptium.net/)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 开发工具包，版本 8 或更高：[https://adoptium.net/](https://adoptium.net/)
- en: 'Apache Maven: [https://maven.apache.org/](https://maven.apache.org/ )'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache Maven：[https://maven.apache.org/](https://maven.apache.org/ )
- en: 'A Git client: [https://git-scm.com/](https://git-scm.com/)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git 客户端：[https://git-scm.com/](https://git-scm.com/)
- en: All the source code used in this chapter is available on GitHub at
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的所有源代码均可在 GitHub 上找到
- en: 'Once you have cloned the GitHub repository, you can start the Open Liberty
    server that these code samples will execute in, by entering the `ch6` directory
    and entering the following command from the command line:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您已经克隆了 GitHub 仓库，您可以通过进入 `ch6` 目录并在命令行中输入以下命令来启动 Open Liberty 服务器，这些代码示例将在其中执行：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can then stop the server in the same command window by pressing *Ctrl* +
    *C*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在相同的命令窗口中按 *Ctrl* + *C* 来停止服务器。
- en: The application that's deployed to the Open Liberty server will be given a context
    root of `ch6`. For example, the full URL to a JAX-RS resource would be `http://localhost:9080/ch6/path/to/resource`.
    This will be reflected in the code samples in this chapter that illustrate sending
    requests to an endpoint.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 部署到 Open Liberty 服务器的应用程序将被分配一个上下文根 `ch6`。例如，一个 JAX-RS 资源的完整 URL 将是 `http://localhost:9080/ch6/path/to/resource`。这一点将在本章中展示如何向端点发送请求的代码示例中得到体现。
- en: Determining the health of your cloud-native application using MicroProfile Health
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MicroProfile Health 确定您的云原生应用程序的健康状况
- en: To begin our three-part journey of looking at the MicroProfile observability
    toolkit, we'll examine the MicroProfile Health technology. We chose to examine
    this technology first as its benefits and use cases are much broader in scope
    compared to the other two technologies in this chapter. The MicroProfile Health
    technology reports information regarding the health, or status, of your microservice.
    The expected health status is either *UP* or *DOWN*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始我们关于 MicroProfile 可观察性工具包的三部分之旅，我们将检查 MicroProfile Health 技术。我们选择首先检查这项技术，因为与本章中的其他两项技术相比，其优势和用例范围更广。MicroProfile
    Health 技术报告有关您的微服务健康或状态的信息。预期的健康状态是 *UP* 或 *DOWN*。
- en: The importance of MicroProfile Health in a cloud-native application
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MicroProfile Health 在云原生应用程序中的重要性
- en: We now know what the MicroProfile Health technology can do. But what purpose
    does it serve? To find out, we must take a step back. The driving force for developing
    applications with the MicroProfile technologies is that they will be cloud native.
    And if you recall [*Chapter 1*](B17377_01_Final_SB_epub.xhtml#_idTextAnchor021),
    *Cloud-Native Application*, the important distinction between a cloud-native application
    and a non-cloud-native application is its ability to take advantage of the capabilities
    provided by the cloud. The MicroProfile Health technology is a perfect example
    of this.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道了 MicroProfile Health 技术能做什么。但它有什么作用呢？为了找出答案，我们必须退一步。开发使用 MicroProfile
    技术的应用程序的驱动力是它们将是云原生的。如果您还记得 [*第 1 章*](B17377_01_Final_SB_epub.xhtml#_idTextAnchor021)，*云原生应用程序*，云原生应用程序与非云原生应用程序之间的重要区别在于其利用云提供的功能的能力。MicroProfile
    Health 技术是这一点的完美例子。
- en: At its very core, the MicroProfile Health technology strives to report the health
    of your application to some external observer. Since we are developing a cloud-native
    application, the application will live its life in a container that's been deployed
    on your cloud platform. Whether its tenure is short-lived or not is what the health
    statuses serve to dictate. In effect, these health statuses report the health
    of your container to your cloud platform. Using the status report of the container,
    the cloud platform's monitor service can use that data to make decisions to terminate
    and replace any troublesome containers. The circumstances of when your containers
    are terminated and restarted ultimately dependent on you, the developer. Your
    cloud platform may have rules on what to do, given the health of a container,
    but the context of how these health statuses are reported depends on how the MicroProfile
    Health technology is used throughout your application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，MicroProfile Health 技术致力于向某些外部观察者报告应用程序的健康状况。由于我们正在开发一个云原生应用程序，该应用程序将在您云平台上部署的容器中运行其生命周期。其任期是短暂还是长久，将由健康状况来决定。实际上，这些健康状况报告了容器健康状态给您的云平台。利用容器状态报告，云平台的监控服务可以使用这些数据来做出决定，终止并替换任何有问题的容器。您的容器何时终止和重启最终取决于您，即开发者。您的云平台可能对容器健康状况下的操作有规则，但这些健康状况报告的上下文取决于
    MicroProfile Health 技术在您的应用程序中的使用方式。
- en: Later in this chapter, we will examine a sample scenario of using the health
    status of your application/container with **Kubernetes**. Kubernetes is an open
    source project that provides a container orchestration solution for deploying,
    scaling, and managing your containers. As one of the more well-known container
    orchestration platforms, it will provide an excellent vehicle for demonstrating
    the benefits of using the MicroProfile Health technology. Kubernetes, along with
    other cloud infrastructure topics, will be covered in more detail in [*Chapter
    7*](B17377_07_Final_SB_epub.xhtml#_idTextAnchor146)*,* *MicroProfile Ecosystem
    with Open Liberty, Docker, and Kubernetes*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将探讨使用**Kubernetes**应用程序/容器的健康状态的示例场景。Kubernetes是一个开源项目，它为部署、扩展和管理容器提供了一种容器编排解决方案。作为更知名的容器编排平台之一，它将为展示使用MicroProfile
    Health技术的优势提供一个极好的工具。Kubernetes以及其他云基础设施主题将在[*第7章*](B17377_07_Final_SB_epub.xhtml#_idTextAnchor146)*，*与Open
    Liberty、Docker和Kubernetes的MicroProfile生态系统*中更详细地介绍。
- en: MicroProfile Health technology overview
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MicroProfile Health技术概述
- en: MicroProfile Health provides three types of health, or status, checks. They
    are the **liveness**, **readiness**, and **startup** health checks. We will explain
    these health checks in detail shortly, but for now, know that their purpose is
    to report whether an application is alive, ready, or if it has even completed
    starting up. The instrumentation and existence of a health check in an application
    is defined as a **procedure**. This procedure is called upon to check if the application
    has started, as well as its liveness or readiness for the instrumented components
    of the application. Moving forward, we will refer to health checks as either a
    health check, a procedure, or a combination of both.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile Health提供了三种类型的健康或状态检查：**存活**、**就绪**和**启动**健康检查。我们将在稍后详细解释这些健康检查，但现在是，要知道它们的目的是报告应用程序是否存活、就绪，或者它是否甚至已经完成了启动。应用程序中健康检查的实现和存在被定义为**流程**。这个流程被调用以检查应用程序是否已启动，以及其存活状态或就绪状态对于应用程序中实现组件。从现在开始，我们将把健康检查称为健康检查、流程或两者的组合。
- en: Health check procedures can be instrumented throughout your microservice and
    will return an *UP* or *DOWN* status to indicate the liveness or readiness of
    the various components of your application, as well as if the application has
    completed initialization. The liveness, readiness, and startup health checks will
    be reported through the `http://host:port/health/live`, `http://host:port/health/ready`,
    and `http://host:port/health/started` endpoints, respectively. An overall status
    is provided for each endpoint and is the logical conjunction of all procedures.
    If there are five readiness procedures instrumented in your application and all
    but one procedure returns *UP*, then the overall readiness of your application
    is *DOWN*. There is also the `http://host:port/health` endpoint, which provides
    an overall status of the whole application from the conjunction of the health
    check procedures for the liveness, readiness, and startup health checks. When
    using the `http://host:port/health` endpoint, there is no distinction between
    liveness, readiness, or startup health checks. All health check procedures, regardless
    of their type, must return *UP* for the `http://host:port/health` endpoint to
    return *UP*. It should be noted that the order in which procedures are invoked
    is arbitrary, so they can be invoked in any order. Moving forward, when referring
    to the health endpoints, we will omit `http://host:port` for brevity.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查流程可以在您的微服务中实现，并将返回*UP*或*DOWN*状态，以指示应用程序各个组件的存活状态或就绪状态，以及应用程序是否已完成初始化。存活状态、就绪状态和启动健康检查将通过`http://host:port/health/live`、`http://host:port/health/ready`和`http://host:port/health/started`端点分别报告。每个端点都提供了一个总体状态，它是所有流程的逻辑合取。如果您的应用程序中有五个就绪流程被实现，但只有一个流程返回*UP*，那么您应用程序的总体就绪状态将是*DOWN*。还有一个`http://host:port/health`端点，它提供了整个应用程序的总体状态，这是通过存活状态、就绪状态和启动健康检查的健康检查流程的合取得到的。当使用`http://host:port/health`端点时，存活状态、就绪状态或启动健康检查之间没有区别。所有健康检查流程，无论其类型如何，都必须返回*UP*，`http://host:port/health`端点才能返回*UP*。需要注意的是，调用流程的顺序是任意的，因此可以按任何顺序调用。从现在开始，当提到健康端点时，我们将为了简洁省略`http://host:port`。
- en: Before we move on, let's learn a little bit more about these three types of
    health checks.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们更深入地了解这三种健康检查类型。
- en: Liveness health check
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存活健康检查
- en: The purpose of the liveness health check procedure, as its name suggests, is
    to report whether the application is alive. In a cloud environment, this status
    can be used by the monitoring service to determine if the application is running
    as expected. Failing this health check may prompt your cloud platform's monitoring
    service to terminate the application's container. Depending on the policy that
    you've configured, this may cause the application's container to be restarted.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 活跃性健康检查程序的目的，正如其名称所暗示的，是报告应用程序是否处于活跃状态。在云环境中，这种状态可以被监控服务用来确定应用程序是否按预期运行。如果健康检查失败，可能会触发您的云平台监控服务终止应用程序的容器。根据您配置的策略，这可能会导致应用程序的容器被重新启动。
- en: Note that a failing liveness procedure does not mean that the application is
    no longer running. Instead, it means that the strategy that's been employed for
    instrumenting the check has deemed that the application has suffered or is suffering
    from a deterioration of service and can no longer be considered operationally
    effective. For example, a liveness procedure can be used to detect a memory leak
    in the JVM and at the rate of memory loss, so it would be prudent to terminate
    this container now instead of later. As a result, a *DOWN* status will be returned.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，失败的活跃性程序并不意味着应用程序不再运行。相反，它意味着用于检查的已采用策略认为应用程序已经或正在遭受服务质量的下降，并且不能再被视为操作上有效。例如，活跃性程序可以用来检测JVM中的内存泄漏以及内存损失的速度，因此现在终止此容器比以后更明智。因此，将返回*DOWN*状态。
- en: Startup health check
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动健康检查
- en: The purpose of the startup health check is to provide an intermediary check
    that is a precursor to the liveness health check. In a container environment,
    not all containers are made equal. Understandably, certain containers may be slow
    to start and initialize due to the complexity of the application that is running
    within them. In a compatible cloud environment, the startup check can be carried
    out for an *UP* before liveness checks are carried out.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 启动健康检查的目的在于提供一个中间检查，它是活跃性健康检查的前奏。在容器环境中，并非所有容器都是平等的。可以理解的是，某些容器可能由于容器内运行的应用程序的复杂性而启动和初始化较慢。在兼容的云环境中，启动检查可以在执行活跃性检查之前进行一个*UP*检查。
- en: Readiness health check
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备性健康检查
- en: The purpose of a readiness health check procedure is to allow external observers
    (for example, the cloud monitoring service) to identify if the application is
    ready to receive and conduct business logic. The application may have effectively
    started and be alive and running with no issues, as indicated by the liveness
    checks, but it isn't quite ready to receive traffic yet. This could be because
    the application is still attempting to initialize a resource or connect to another
    application that it depends on. The readiness check will report *DOWN* as it continues
    its attempt to secure a connection.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 准备性健康检查程序的目的在于允许外部观察者（例如，云监控服务）确定应用程序是否已准备好接收并执行业务逻辑。尽管活跃性检查表明应用程序已经有效启动并且运行良好，没有问题，但应用程序可能还没有准备好接收流量。这可能是因为应用程序仍在尝试初始化资源或连接到它所依赖的其他应用程序。准备性检查将在其尝试建立连接的过程中报告*DOWN*状态。
- en: Special Note About Default Health Checks
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 关于默认健康检查的特殊说明
- en: Depending on your underlying MicroProfile runtime, your runtime may provide
    `mp.health.disable-default-procedures` Config element and setting its value to
    `true`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您底层的MicroProfile运行时，您的运行时可能提供`mp.health.disable-default-procedures`配置元素，并设置其值为`true`。
- en: Instrumenting health check procedures
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 健康检查程序的仪表化
- en: A health check procedure is called upon by the MicroProfile runtime to find
    out the health of a particular component of an application, whether it be a liveness,
    readiness, or startup procedure. But it can also be the case that the health check
    reports on the liveness, readiness, and startup procedures simultaneously. This
    is due to how the MicroProfile Health runtime operates under the hood. Like the
    other MicroProfile technologies, MicroProfile Health is intrinsically integrated
    with `@Liveness`, `@Readiness`, and `@Startup` qualifier annotations. Using any
    of these annotations lets the MicroProfile Health runtime know what health statuses
    are being reported. But before we get too ahead of ourselves, what exactly is
    a health check in the application code?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查程序由MicroProfile运行时调用，以找出应用程序特定组件的健康状况，无论是存活、就绪还是启动程序。但健康检查报告也可能同时报告存活、就绪和启动程序。这是由于MicroProfile
    Health运行时在底层的工作方式。像其他MicroProfile技术一样，MicroProfile Health与`@Liveness`、`@Readiness`和`@Startup`限定符注解内在集成。使用这些注解之一可以让MicroProfile
    Health运行时知道正在报告哪些健康状态。但在我们过于领先之前，应用程序代码中的健康检查究竟是什么？
- en: The basis for every health check procedure is the functional interface, called
    `HealthCheck`. This consists of a single function, `call()`, that returns a `HealthCheckResponse`.
    In an application, the `HealthCheck` implementation is annotated with at least
    one of the `@Liveness`, `@Readiness`, or `@Startup` annotations. Remember that
    MicroProfile Health's integration with CDI means that every health check procedure
    (that is, the `HealthCheck` implementation) is a CDI bean and has a place in the
    application's life cycle context. It would be prudent to also define a CDI scope
    for your health check procedure. We will be using `@ApplicationScoped` in our
    examples.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 每个健康检查程序的基础是名为`HealthCheck`的功能接口。它由一个函数`call()`组成，该函数返回一个`HealthCheckResponse`。在应用程序中，`HealthCheck`实现至少注解了`@Liveness`、`@Readiness`或`@Startup`之一。记住，MicroProfile
    Health与CDI的集成意味着每个健康检查程序（即`HealthCheck`实现）都是一个CDI bean，并在应用程序的生命周期上下文中有一个位置。为你的健康检查程序定义一个CDI作用域也是明智的。在我们的示例中，我们将使用`@ApplicationScoped`。
- en: 'The following code snippet demonstrates how to instrument the liveness, readiness,
    and startup health checks in the same procedure. You can instrument a singular
    health check by using one annotation instead:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段演示了如何在同一程序中配置存活、就绪和启动健康检查。你可以通过使用一个注解来配置单个健康检查：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So, now that we know how to create and define the different types of health
    checks, we can learn how to build the health check response, whose data will be
    consumed by an external observer through one of the `/health/*` endpoints.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经知道了如何创建和定义不同类型的健康检查，我们可以学习如何构建健康检查响应，其数据将通过`/health/*`端点之一被外部观察者消费。
- en: As we mentioned earlier, we will be returning a `HealthCheckResponse` object.
    This data object contains all the information we need for uniquely identifying
    the health check and, most importantly, the health of your cloud-native application.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，我们将返回一个`HealthCheckResponse`对象。这个数据对象包含我们需要的所有信息，用于唯一标识健康检查，最重要的是，你的云原生应用程序的健康状况。
- en: '`HealthCheckResponse` consists of three fields:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`HealthCheckResponse`由三个字段组成：'
- en: '`String` field that distinguishes this health check procedure from other health
    check procedures.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`String`字段，用于区分这个健康检查程序与其他健康检查程序。
- en: '`enum` field with either an *UP* or *DOWN* value.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有*UP*或*DOWN*值的`enum`字段。
- en: '`Map<String, Object>`. When `String` key and its value can be either `String`,
    `long`, or `boolean`.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map<String, Object>`。当`String`键及其值可以是`String`、`long`或`boolean`时。'
- en: Now, let's look at the different ways of constructing health check procedures.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看构建健康检查程序的不同方法。
- en: Using HealthCheckResponseBuilder
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用HealthCheckResponseBuilder
- en: To create a `HealthCheckResponse`, you can call one of two static methods in
    `HealthCheckResponse` that will return a `HealthCheckResponseBuilder`. These two
    methods are `builder()` and `named(String name)`. The latter creates a `HealthCheckResponseBuilder`
    with a name that's already specified, whereas the former provides a *clean* instance.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个`HealthCheckResponse`，你可以在`HealthCheckResponse`中调用两种静态方法之一，这将返回一个`HealthCheckResponseBuilder`。这两种方法是`builder()`和`named(String
    name)`。后者创建一个已指定名称的`HealthCheckResponseBuilder`，而前者提供一个*干净的*实例。
- en: '`HealthCheckResponseBuilder` provides a builder pattern for constructing a
    `HealthCheckResponse` containing the required and optional fields. This is the
    preferred method if you intend to provide optional data.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`HealthCheckResponseBuilder` 提供了一个构建模式，用于构建包含所需和可选字段的 `HealthCheckResponse`。如果您打算提供可选数据，这是首选方法。'
- en: The following code example shows a scenario where we are performing a liveness
    health check based on the heap memory usage of the JVM.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了基于 JVM 堆内存使用情况执行存活健康检查的场景。
- en: 'The full source code for `LivenessCheck` can be found at [https://bit.ly/2WbiVyV](https://bit.ly/2WbiVyV):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`LivenessCheck` 的完整源代码可以在 [https://bit.ly/2WbiVyV](https://bit.ly/2WbiVyV)
    找到：'
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, we used the `named(String name)` static method to provide the
    health check with a name. We then used the `HealthCheckResponseBuilder` class's
    `up()`, `down()`, and `withData(String key, String value)` methods to specify
    the status of the health check and to provide any additional contextual data.
    The `withData(…)` method is an overloaded method and can accept `String`, `long`,
    and `boolean` values. In this example, if the memory usage is less than 90% (that
    is, a value less than `0.9` is returned by the `getMemUsage()` method), we will
    return an *UP* status. Otherwise, we will return a *DOWN* status.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用了 `named(String name)` 静态方法为健康检查提供名称。然后，我们使用了 `HealthCheckResponseBuilder`
    类的 `up()`、`down()` 和 `withData(String key, String value)` 方法来指定健康检查的状态并提供任何额外的上下文数据。`withData(…)`
    方法是一个重载方法，可以接受 `String`、`long` 和 `boolean` 类型的值。在这个示例中，如果内存使用率低于 90%（即 `getMemUsage()`
    方法返回的值小于 `0.9`），我们将返回 *UP* 状态。否则，我们将返回 *DOWN* 状态。
- en: Alternatively, if you're using `HealthCheckResponse.builder()` instead, you
    will need to use the `HealthCheckResponseBuilder` class's `name(String name)`
    to provide a name for the health check.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您使用的是 `HealthCheckResponse.builder()`，您将需要使用 `HealthCheckResponseBuilder`
    类的 `name(String name)` 为健康检查提供名称。
- en: 'Now, instead of having a bulky `if`-`else` block, we can use `HealthCheckResponseBuilder.status(boolean
    status)` in one line:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再需要一行多的 `if`-`else` 块，我们可以使用 `HealthCheckResponseBuilder.status(boolean
    status)` 在一行中完成：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, we've reduced eight lines of code to one line!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们将八行代码缩减到了一行！
- en: Using HealthCheckResponse
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 HealthCheckResponse
- en: Instead of using `HealthCheckResponseBuilder`, we can also use the `HealthCheckResponse`
    class's two static methods, which conveniently create an *UP* or *DOWN* `HealthCheckResponse`,
    as illustrated in the following example.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以不用 `HealthCheckResponseBuilder`，也可以使用 `HealthCheckResponse` 类的两个静态方法，它们方便地创建
    *UP* 或 *DOWN* 的 `HealthCheckResponse`，如下例所示。
- en: 'The full source code for `ReadinessCheck` can be found at [https://bit.ly/3iV3WBP](https://bit.ly/3iV3WBP):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadinessCheck` 的完整源代码可以在 [https://bit.ly/3iV3WBP](https://bit.ly/3iV3WBP)
    找到：'
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The methods that are being used here are aptly named `up(String name)` and `down(String
    name)` and accept a `String` parameter that defines the name of the health check.
    This approach assumes that there is no additional optional data to be incorporated
    with this health check procedure. In the following example, we will retrieve the
    current system time and if it is an even number, we will return a *DOWN* status
    (otherwise, it will be an *UP* status).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的方法名称恰如其分，分别是 `up(String name)` 和 `down(String name)`，它们接受一个 `String` 参数，用于定义健康检查的名称。这种方法假设没有额外的可选数据需要与这个健康检查过程结合。在以下示例中，我们将检索当前系统时间，如果它是偶数，我们将返回
    *DOWN* 状态（否则，将返回 *UP* 状态）。
- en: CDI producers
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CDI 生产者
- en: With MicroProfile Health's implicit reliance on CDI, health checks procedures
    can also be instrumented using a CDI method producer. You can instrument multiple
    health check procedures in one class by using CDI method producers. The following
    example shows the liveness, readiness, and startup health check procedures being
    instrumented as CDI method producers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 MicroProfile Health 对 CDI 的隐式依赖，健康检查过程也可以使用 CDI 方法生产者进行监控。您可以使用 CDI 方法生产者在单个类中监控多个健康检查过程。以下示例展示了存活、就绪和启动健康检查过程作为
    CDI 方法生产者进行监控。
- en: 'The full source code for `CDIMethodProducerCheck` can be found at [https://bit.ly/3k9GrUT](https://bit.ly/3k9GrUT):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`CDIMethodProducerCheck` 的完整源代码可以在 [https://bit.ly/3k9GrUT](https://bit.ly/3k9GrUT)
    找到：'
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The liveness procedure that's encapsulated by the `livenessCDIMethodProducer`
    method will return *UP* if the memory usage is below 90% (that is, a value less
    than 0.9 is returned by the `getMemUsage()` method). The readiness procedure that's
    encapsulated by the `readinessCDIMethodProducer` method will return *UP* if the
    CPU usage is below 90% (that is, a value less than 0.9 is returned by the `getCpuUsage()`
    method). The startup procedure that's encapsulated by the `startupCDIMethodProducer`
    method will execute the `getStatus()` business method to evaluate the condition
    of the application's startup state, and will return either `true` or `false` to
    invoke an *UP* or *DOWN* status, respectively.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由`livenessCDIMethodProducer`方法封装的存活性程序，如果内存使用率低于90%（即`getMemUsage()`方法返回的值小于0.9），则返回*UP*。由`readinessCDIMethodProducer`方法封装的准备性程序，如果CPU使用率低于90%（即`getCpuUsage()`方法返回的值小于0.9），则返回*UP*。由`startupCDIMethodProducer`方法封装的启动程序将执行`getStatus()`业务方法来评估应用程序启动状态的条件，并将返回`true`或`false`以调用*UP*或*DOWN*状态，分别。
- en: Retrieving health check data
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取健康检查数据
- en: As we mentioned previously, we can view the data through the `/health`, `/health/liveness`,
    `/health/readiness`, and `/health/started` endpoints. Due to this, these health
    checks can be consumed by requests over HTTP/REST. Through an HTTP/REST call,
    the health check procedures are presented in JSON format. The root level contains
    the overall health status with a `status` field, and it is calculated from the
    conjunction of all health check procedures defined in the `checks` JSON list.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，我们可以通过`/health`、`/health/liveness`、`/health/readiness`和`/health/started`端点查看数据。因此，这些健康检查可以通过HTTP/REST请求进行消费。通过HTTP/REST调用，健康检查程序以JSON格式呈现。根级别包含总体健康状态，有一个`status`字段，它是从`checks`
    JSON列表中定义的所有健康检查程序的交集计算得出的。
- en: The overall status dictates the HTTP response code. An *UP* status returns HTTP
    200, while a *DOWN* status returns HTTP 500\. Any failures or errors that are
    encountered by the health check procedure will result in an HTTP 503 return code,
    which equates to a *DOWN* status. Remember that if any health check reports are
    down, then the overall status is *DOWN*. Each health check JSON object in the
    list displays the contents of `HealthCheckReponse` (that is, its name, status,
    and optional key-value map). If there a no health check procedures, then an automatic
    *UP* (that is, HTTP 200) is returned. The formatting structure and behaviors listed
    previously apply to all four endpoints. The use of response codes is important
    as this may be the method in which the external observer is determining the health
    of your application (that is, the cloud platform).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 总体状态决定了HTTP响应代码。*UP*状态返回HTTP 200，而*DOWN*状态返回HTTP 500。健康检查程序遇到的任何故障或错误将导致返回HTTP
    503错误代码，这相当于*DOWN*状态。请记住，如果任何健康检查报告处于*DOWN*状态，则总体状态为*DOWN*。列表中的每个健康检查JSON对象都显示`HealthCheckReponse`的内容（即其名称、状态和可选的键值映射）。如果没有健康检查程序，则自动返回*UP*（即HTTP
    200）。之前列出的格式结构和行为适用于所有四个端点。使用响应代码很重要，因为这可能是外部观察者确定您的应用程序健康状态的方法（即云平台）。
- en: 'The following example output can be applied to any of the four health endpoints,
    so we will not define which endpoint it is from:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例输出可以应用于任何四个健康端点，因此我们不会定义它是从哪个端点来的：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output reports that we have a health check procedure named `"goodCheck"`
    that reports *UP*. We also have a procedure named `"questionableCheck"` that is
    reporting *DOWN*. This causes the overall status to report *DOWN* and will result
    in an HTTP 500 error being returned. As shown in the output, the `"questionableCheck"`
    procedure has incorporated the additional contextual map data; that is, `"application":
    "backend"` and `"locale": "en"`.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '输出报告称我们有一个名为`"goodCheck"`的健康检查程序报告*UP*。我们还有一个名为`"questionableCheck"`的程序报告*DOWN*。这导致总体状态报告*DOWN*，并将导致返回HTTP
    500错误。如输出所示，`"questionableCheck"`程序已包含额外的上下文映射数据；即`"application": "backend"`和`"locale":
    "en"`。'
- en: Special Note About Default Readiness and Startup Procedures
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 关于默认就绪和启动程序的特别说明
- en: The MicroProfile Health runtime provides a configuration value (through MicroProfile
    Config) called `mp.health.default.readiness.empty.response`. Its value can be
    either *UP* or *DOWN*. The default value is *DOWN*. This value is used to report
    the readiness of your microservice if the application is still starting up and
    the readiness procedures cannot be called yet. This is not applicable if no readiness
    health check procedures have been defined in the application code. If that is
    the case, then the default behavior for no health check procedures is to return
    an HTTP 200 response with an *UP* status on the `/health/readiness` endpoint.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile Health 运行时提供了一个配置值（通过 MicroProfile Config），称为 `mp.health.default.readiness.empty.response`。其值可以是
    *UP* 或 *DOWN*。默认值是 *DOWN*。当应用程序仍在启动且就绪程序尚未调用时，此值用于报告微服务的就绪状态。如果应用程序代码中没有定义就绪健康检查程序，则不适用。如果是这种情况，则没有健康检查程序的默认行为是在
    `/health/readiness` 端点上返回带有 *UP* 状态的 HTTP 200 响应。
- en: There is also a configuration value that exists for the startup health check
    called `mp.health.default.startup.empty.response`. If there are no startup health
    checks at all, then the default *UP* status is returned on the `/health/started`
    endpoint.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于启动健康检查，也存在一个配置值，称为 `mp.health.default.startup.empty.response`。如果没有启动健康检查，则
    `/health/started` 端点将返回默认的 *UP* 状态。
- en: Liveness checks, on the other hand, do not have configurable values. They follow
    the simple rule of returning an HTTP 200 response with an *UP* status if the application
    is still starting, and the liveness checks are not ready to be invoked yet.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，存活检查没有可配置的值。它们遵循简单的规则：如果应用程序仍在启动且存活检查尚未准备好被调用，则返回带有 *UP* 状态的 HTTP 200 响应。
- en: Other connections and payload formats
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他连接和有效载荷格式
- en: Depending on the runtime you chose, it may be the case that the results of the
    health check procedures can be obtained through additional means (for example,
    TCP or JMX). We're using the word *additional* here because, at the very minimum,
    a MicroProfile Health runtime must support an HTTP/REST request. However, as a
    cloud-native technology, MicroProfile Health understands that other strategies
    for obtaining the data may be preferred. The MicroProfile Health specification
    defines a set of protocols and wire format rules for how the data can be consumed
    and presented. Health check data should be presented in JSON format whenever possible.
    But failing that, the same payload of data must be made available.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您选择的运行时，健康检查程序的结果可能可以通过其他方式获得（例如，TCP 或 JMX）。我们在这里使用“额外”一词，因为至少，MicroProfile
    Health 运行时必须支持 HTTP/REST 请求。然而，作为一种云原生技术，MicroProfile Health 了解可能更倾向于其他获取数据的方法。MicroProfile
    Health 规范定义了一组协议和线格式规则，用于如何消费和展示数据。尽可能以 JSON 格式展示健康检查数据。如果不行，则必须提供相同的数据有效载荷。
- en: This book will not discuss the intricacies of the protocol and the wire format
    semantics defined in the MicroProfile Health specification. You can review the
    MicroProfile Health specification for such information at [https://bit.ly/3ecI6Gz](https://bit.ly/3ecI6Gz).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将不会讨论在 MicroProfile Health 规范中定义的协议和线格式语义的复杂性。您可以在 [https://bit.ly/3ecI6Gz](https://bit.ly/3ecI6Gz)
    查阅 MicroProfile Health 规范以获取此类信息。
- en: MicroProfile health checks with Kubernetes' liveness, readiness, and startup
    probes
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MicroProfile 健康检查与 Kubernetes 的存活、就绪和启动探测
- en: We will now look at how the health check data that's reported by health check
    procedures can be consumed in a real-life scenario. To do this, we will be using
    Kubernetes. As this is one of the more well-known cloud container orchestration
    platforms, this will serve as an excellent vehicle of demonstration. We will be
    using Kubernetes terminology and will try our best to describe these terms in
    this section. We will explore Kubernetes and the cloud infrastructure in more
    depth in [*Chapter 7*](B17377_07_Final_SB_epub.xhtml#_idTextAnchor146), *MicroProfile
    Ecosystem with Docker, Kubernetes, and Istio*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将探讨如何在实际场景中消费健康检查程序报告的健康检查数据。为此，我们将使用 Kubernetes。由于这是更知名的云容器编排平台之一，这将成为一个出色的演示工具。我们将使用
    Kubernetes 术语，并尽力在本节中描述这些术语。我们将在 [*第7章*](B17377_07_Final_SB_epub.xhtml#_idTextAnchor146)，*使用
    Docker、Kubernetes 和 Istio 的 MicroProfile 生态系统* 中更深入地探讨 Kubernetes 和云基础设施。
- en: In a cloud environment, the containers you deploy exist on an interconnected
    web of physical or virtual machines. Kubernetes serves to seamlessly manage and
    integrate your container deployments that reside in Kubernetes' **Pods**. Pods
    can contain one or more containers. To get a pulse on the activity of the Pods
    in this network (that is, your cloud), a **kubelet** is present on each machine.
    This acts as a node agent that manages the Pods on the machine and communicates
    with the central Kubernetes management facilities. As part of its duties, it can
    determine when the containers within these Pods are stale or broken, and it has
    the power to stop and restart them if the need arises. Kubelets are also given
    the task of evaluating when a container is ready to receive traffic or not. And,
    most fundamentally, they can check if the container has completed initializing.
    They accomplish these tasks by checking the liveness, readiness, and startup statuses
    of the containers within the Pods using liveness, readiness, and startup probes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在云环境中，您部署的容器存在于物理或虚拟机的互联网络中。Kubernetes 通过无缝管理和集成驻留在 Kubernetes 的 **Pods** 中的容器部署来提供服务。Pod
    可以包含一个或多个容器。为了了解这个网络（即您的云）中 Pods 的活动情况，每个机器上都有一个 **kubelet**。它充当节点代理，管理机器上的 Pods
    并与中央 Kubernetes 管理设施通信。作为其职责的一部分，它可以确定这些 Pods 内的容器何时过时或损坏，并在需要时有权停止和重启它们。Kubelets
    还被赋予评估容器何时准备好接收流量或不准备接收流量的任务。最基本的是，它们可以检查容器是否已初始化完成。它们通过检查 Pods 内容器的存活、就绪和启动状态来完成这些任务，使用存活、就绪和启动探测。
- en: This behavior is container-specific in that it must be enabled on a per-container
    basis. This is achieved when configuring the container in the Pod's configuration
    YAML file. The following example uses a snippet from the `broker.yaml` file, which
    configures the Broker microservice from the StockTrader application that we introduced
    in [*Chapter 3*](B17377_03_Final_SB_epub.xhtml#_idTextAnchor049), *Introducing
    the IBM Stock Trader Cloud-Native Application*, and will look at again in [*Chapter
    8*](B17377_08_Final_SB_epub.xhtml#_idTextAnchor159), *Step-by-Step Stock Trader
    Development*. The YAML file contains a Kubernetes `Deployment` definition, which
    provides the configuration needed to deploy the container(s) onto a Pod, including
    the container image to use, environment variables, and, of course, the liveness,
    readiness, and startup probes, which can be configured for each container that
    is defined. We've omitted the other parts of the file to only show the configuration
    of the liveness, readiness, and startup probes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为是容器特定的，必须在每个容器的基础上启用。这通过在 Pod 的配置 YAML 文件中配置容器来实现。以下示例使用了来自 `broker.yaml`
    文件的片段，该文件配置了我们在 [*第 3 章*](B17377_03_Final_SB_epub.xhtml#_idTextAnchor049) 中介绍的
    StockTrader 应用程序的 Broker 微服务，即 *介绍 IBM 股票交易云原生应用程序*，我们将在 [*第 8 章*](B17377_08_Final_SB_epub.xhtml#_idTextAnchor159)
    中再次探讨，*逐步开发股票交易应用程序*。YAML 文件包含 Kubernetes `Deployment` 定义，它提供了将容器（s）部署到 Pod 上的配置，包括要使用的容器镜像、环境变量，当然还有，当然，存活、就绪和启动探测，可以为每个定义的容器进行配置。我们省略了文件的其他部分，只显示存活、就绪和启动探测的配置。
- en: 'The full source code for `broker.yaml` can be found at [https://bit.ly/3sEvHAa](https://bit.ly/3sEvHAa):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`broker.yaml` 的完整源代码可以在 [https://bit.ly/3sEvHAa](https://bit.ly/3sEvHAa) 找到：'
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The liveness, readiness, and startup endpoints are defined in the `livenessProbe`,
    `readinessProbe`, and `startupProbe` sections, respectively. The probes are configured
    to use HTTP/S with `httpGet`. In our example, we will be using an unsecured HTTP
    endpoint. You will need to add a new field under `httpGet` named `scheme` and
    set the value to `HTTPS` if you want a secure connection. We specify `/health/live`,
    `/health/ready`, and `/health/started` with the `path` field and the port to reach
    it on with `port`. An initial delay of 60 seconds is configured with the `initialDelaySeconds`
    field for the readiness probe. This prevents the readiness probe from firing until
    this time has elapsed, to allow the container and its application to start up.
    When the probes are firing, requests will be sent every 15 seconds for the readiness
    and liveness probes and 30 seconds for the startup probe, as configured through
    `periodSeconds`. However, what's not defined in this example is the `timeoutSeconds`
    field. By default, the value is 1 second and it defines the period in which the
    kubelet should wait before it times out. `failureThreshold` defines how many times
    the probes will retry before it is considered a failure.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 存活性、就绪性和启动端点分别在 `livenessProbe`、`readinessProbe` 和 `startupProbe` 部分定义。探测被配置为使用
    HTTP/S 通过 `httpGet`。在我们的例子中，我们将使用一个未加密的 HTTP 端点。如果你想建立一个安全连接，你需要在 `httpGet` 下添加一个新的字段，命名为
    `scheme`，并将其值设置为 `HTTPS`。我们使用 `path` 字段指定 `/health/live`、`/health/ready` 和 `/health/started`，并使用
    `port` 指定到达它的端口。就绪性探测使用 `initialDelaySeconds` 字段配置了 60 秒的初始延迟，这可以防止就绪性探测在此时之前触发，以便容器及其应用程序启动。当探测正在触发时，就绪性和存活性探测每
    15 秒发送一次请求，启动探测每 30 秒发送一次请求，这是通过 `periodSeconds` 配置的。然而，在这个例子中没有定义的 `timeoutSeconds`
    字段。默认情况下，值为 1 秒，它定义了 kubelet 在超时之前应该等待的时间。`failureThreshold` 定义了探测在被视为失败之前将重试多少次。
- en: You may notice that the liveness probe does not specify the `initialDelaySeconds`
    field. You can do so, but this is unnecessary as we are using `startUpProbe`.
    Remember that (if defined) the startup probe will be queried first until it provides
    the *UP* status, and then the liveness probe will be checked. This is the behavior
    that Kubernetes provides.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到存活性探测没有指定 `initialDelaySeconds` 字段。你可以这样做，但这是不必要的，因为我们正在使用 `startUpProbe`。请记住，（如果已定义）启动探测将首先被查询，直到它提供
    *UP* 状态，然后才会检查存活性探测。这是 Kubernetes 提供的行为。
- en: If any of the probes fail completely, as in all attempts have transpired, then
    the container is subject to being restarted.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何一个探测完全失败，即所有尝试都失败了，那么容器将面临重启。
- en: It should be of no surprise now that the MicroProfile Health technology had
    the Kubernetes platform in mind with its availability of liveness, readiness,
    and startup endpoints, all of which match the specific Kubernetes liveness, readiness,
    and startup probes. However, the existence of the simple `/health` endpoint allows
    it to be used by other platforms that only care about a single health endpoint.
    But remember that when using the `/health` endpoint, the concept of liveness,
    readiness, and startup maybe no longer be applicable. On top of that, MicroProfile
    Health's straightforward protocol and wire format rules allow its health check
    data to be easily consumed by any external observer, sentient or not.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可能不会让人感到惊讶，MicroProfile Health 技术在设计时考虑到了 Kubernetes 平台，提供了存活性、就绪性和启动端点，所有这些都与
    Kubernetes 的特定存活性、就绪性和启动探测相匹配。然而，简单的 `/health` 端点的存在使得它能够被只关心单个健康端点的其他平台使用。但请记住，当使用
    `/health` 端点时，存活性、就绪性和启动的概念可能不再适用。除此之外，MicroProfile Health 的简单协议和线缆格式规则允许其健康检查数据被任何外部观察者（无论是有意识的还是无意识的）轻松消费。
- en: We've now come to the end of the MicroProfile Health section. As we mentioned
    earlier, in the introduction to MicroProfile Health, this technology serves to
    satisfy a broad monitoring scope. In the next section, we'll start to cover a
    more detailed monitoring scope with MicroProfile Metrics.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经到达了 MicroProfile Health 部分的结尾。正如我们之前提到的，在 MicroProfile Health 的介绍中，这项技术旨在满足广泛的监控范围。在下一节中，我们将开始详细介绍
    MicroProfile Metrics 的监控范围。
- en: Instrumenting metrics on your cloud-native application using MicroProfile Metrics
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MicroProfile Metrics 在你的云原生应用程序上度量指标
- en: This is the second part of our MicroProfile observability trilogy, where we
    find ourselves in the thick of things with MicroProfile Metrics. The previous
    technology we discussed – MicroProfile Health – strived to report on the overall
    health of your cloud-native application by allowing you, the developer, to strategically
    place health checks throughout your application. MicroProfile Metrics, on the
    other hand, strives to report on the performance and inner workings of the application
    and its environment using metrics instrumented in the application by you, as well
    as metrics provided by the MicroProfile Metrics runtime. This provides real-time
    statistics that can be recorded and/or aggregated to be analyzed with specialized
    monitoring tools. To accomplish this, the MicroProfile Metrics technology comes
    well-equipped with seven types of metrics that range in complexity and functionality.
    As we progress through this section of this chapter, we will come to know them
    very well.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的MicroProfile可观察性三部曲的第二部分，在这一部分中，我们发现自己正深入MicroProfile Metrics的细节。我们之前讨论的技术——MicroProfile
    Health——努力通过允许开发者有策略地在应用中放置健康检查来报告云原生应用的整体健康。另一方面，MicroProfile Metrics努力通过你在应用中配置的指标以及MicroProfile
    Metrics运行时提供的指标来报告应用及其环境的性能和内部工作。这提供了可以记录和/或聚合以供专用监控工具分析的实时统计数据。为了实现这一点，MicroProfile
    Metrics技术配备了七种不同类型和功能的指标。随着我们通过本章的这一部分继续前进，我们将非常熟悉它们。
- en: The importance of MicroProfile Metrics in a cloud-native application
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务指标在云原生应用中的重要性
- en: Being able to monitor the statistics and performance data of specific components
    throughout your application is not a cloud-native, development-specific idea.
    This should be a healthy practice, regardless of whether your endeavors are on
    the cloud. However, being able to monitor your microservices is critical when
    we're talking about a topology of highly scalable and diverse applications. Even
    if you don't command a sprawl of applications, but rather a few applications,
    the benefits of gathering metrics are indisputably invaluable. This is a way for
    your microservice to talk to you and tell you how it's feeling. This provides
    you with the opportunity to identify any patterns of concern before your application's
    liveness health checks unexpectedly decrees that it is *DOWN*. For example, in
    the previous section, we demonstrated a scenario where the liveness health check
    procedure was dependent on how much memory was being used. After it surpassed
    a certain threshold, it would fail and report *DOWN*. By just using MicroProfile
    Health, we wouldn't know anything was wrong until it was too late and by then,
    your cloud platform would have already restarted the container. And perhaps you
    may be blissfully unaware that anything has happened at all.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 能够监控应用中特定组件的统计和性能数据，并不是一个云原生或开发特定的想法。这应该是一种健康的实践，无论你的努力是否在云上。然而，当我们谈论一个高度可扩展和多样化的应用拓扑时，能够监控你的微服务是至关重要的。即使你管理的不是一个应用集群，而是几个应用，收集指标的好处也是无可争议的宝贵。这是你的微服务与你交流并告诉你它感受的方式。这为你提供了机会，在应用的生命活力健康检查意外宣布它处于*DOWN*状态之前，识别任何令人担忧的模式。例如，在前一节中，我们演示了一个场景，其中生命活力健康检查过程依赖于正在使用的内存量。一旦超过某个阈值，它就会失败并报告*DOWN*。仅仅使用MicroProfile
    Health，我们不会知道出了什么问题，直到为时已晚，那时，你的云平台可能已经重启了容器。也许你可能完全不知道发生了任何事情。
- en: Having MicroProfile Metrics report on such statistics allows you to anticipate
    such disasters ahead of time and to understand the performance of your application.
    As another example, we can have metrics reporting on the number of requests that
    have been made to the REST endpoints in your microservice and how long it took,
    on average, for the requests to be fulfilled. This metric information can shed
    light on how popular your microservice is and how well – or how poorly – your
    microservice is performing. This can then prompt the necessary steps for revising
    and modifying the deployment environment or even the application itself.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile Metrics报告此类统计数据允许你提前预见此类灾难，并了解应用的表现。作为另一个例子，我们可以让指标报告对微服务中REST端点发出的请求数量以及平均完成请求所需的时间。这些指标信息可以揭示你的微服务有多受欢迎，以及你的微服务表现得好还是不好。这可以促使采取必要的步骤来修订和修改部署环境，甚至可能是应用本身。
- en: However, MicroProfile Metrics can only report on the instantaneous value of
    the metrics. To properly harness this stream of information, we need to aggregate
    the metric data over time and, in effect, transform it into a **time series metric**.
    Neither MicroProfile Metrics itself, nor any other MicroProfile technology, serves
    to accomplish this task. MicroProfile Metrics is only here to provide a seamless
    and effective way of instrumenting metrics into your microservices. There is already
    an established ecosystem of tools and platforms that specializes in aggregating
    metrics and visualizing them. A popular monitoring stack to use is one that utilizes
    **Prometheus** and **Grafana**.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，MicroProfile Metrics只能报告指标的瞬时值。为了正确利用这一信息流，我们需要在时间上聚合指标数据，实际上将其转换为**时间序列指标**。MicroProfile
    Metrics本身，以及任何其他MicroProfile技术，都不用于完成这项任务。MicroProfile Metrics的存在只是为了提供一个无缝且有效的将指标仪器化的方式到您的微服务中。已经存在一个专门用于聚合指标和可视化的工具和平台生态系统。一个流行的监控堆栈是利用**Prometheus**和**Grafana**的。
- en: Prometheus is an open source monitoring solution for gathering, storing, and
    querying time series metrics. Prometheus is often combined with the use of another
    tool, called Grafana. Grafana is another open source monitoring solution that
    serves to display and visualize time series metrics through graphs, tables, and
    other types of visualizations by using customized queries that have been made
    to the time series database (for example, Prometheus). This can provide you or
    your operations team with the ability to monitor the performance of your microservices
    through meaningful visualizations in a human-friendly way.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus是一个开源的监控解决方案，用于收集、存储和查询时间序列指标。Prometheus通常与另一个名为Grafana的工具结合使用。Grafana是另一个开源监控解决方案，它通过使用针对时间序列数据库（例如Prometheus）进行的定制查询，通过图表、表格和其他类型的可视化来显示和可视化时间序列指标。这可以为您提供或您的运维团队以人性化的方式通过有意义的可视化监控微服务的性能的能力。
- en: At the end of this section, we will demonstrate how to use Grafana to visualize
    the metric data that's been gathered by the MicroProfile Metrics runtime. Being
    able to strategically instrument metrics to provide meaningful information is
    half the battle; effectively using that information is how the battle is won.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的结尾，我们将演示如何使用Grafana来可视化MicroProfile Metrics运行时收集的指标数据。能够战略性地仪器化指标以提供有意义的信息是战斗的一半；有效地使用这些信息才是赢得战斗的方式。
- en: MicroProfile Metrics technology overview
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MicroProfile Metrics技术概述
- en: You may have noticed that, in the introduction to this section, we mentioned
    that metrics can come from the application or the runtime itself. Just like MicroProfile
    Health, where default health checks may be provided, the MicroProfile Metrics
    runtime can provide default out-of-the-box metrics as well. The runtime must provide,
    for the most part, a certain set of metrics on top of any optional metrics that
    it wishes to provide. These metrics are referred to as **base metrics** and **vendor
    metrics**, respectively. However, not all base metrics are strictly required,
    and we will explain this shortly. The metrics that are instrumented in the application
    by the developer are referred to as **application metrics**. All these different
    sets of metrics live separately, agnostic of each other, under different **metric
    registries**. The metric registry is the control center and the heart of the MicroProfile
    Metrics technology. The metric registry is where metrics are registered, stored,
    retrieved, and deleted. This logical grouping of the different types of metrics
    into their own unique metric registries simplifies handling different scopes of
    metrics and, most importantly, avoids any metric name collisions that could occur
    if they resided together in one single metric registry.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在本节的介绍中，我们提到指标可以来自应用程序或运行时本身。就像MicroProfile Health，其中可能提供默认的健康检查一样，MicroProfile
    Metrics运行时也可以提供默认的即用型指标。运行时必须在很大程度上提供它希望提供的任何可选指标之上的某些指标集。这些指标被称为**基本指标**和**供应商指标**。然而，并非所有基本指标都是严格必需的，我们将在稍后解释这一点。开发者在应用程序中通过仪器化的指标被称为**应用程序指标**。所有这些不同的指标集都分别独立存在，不受彼此影响，在不同的**指标注册表**下。指标注册表是MicroProfile
    Metrics技术的控制中心和核心。指标注册表是指标注册、存储、检索和删除的地方。这种将不同类型的指标逻辑分组到它们自己的独特指标注册表中，简化了处理不同范围的指标，最重要的是，避免了如果它们在一个单一的指标注册表中存在时可能发生的任何指标名称冲突。
- en: To retrieve the metric data, the MicroProfile Metrics runtime provides four
    HTTP/REST endpoints. The first one is a general `http://host:port/metrics` endpoint,
    which displays all the metrics from all the scopes and registries. Metrics are
    prefixed with the name of their respective metric registries to avoid confusion.
    The other three endpoints are sub-resources of the `http://host:port/metrics`
    endpoint, and they report on the metrics in each specific registry. They are the
    `http://host:port/metrics/base`, `http://host:port/metrics/vendor`, and `http://host:hort/metrics/application`
    HTTP/REST endpoints. Metrics can be reported in either JSON or Prometheus exposition
    format. We will cover these two formats in detail later. Moving forward, when
    referring to the metrics endpoints, we will omit `http://host:port` for brevity.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索指标数据，MicroProfile Metrics 运行时提供了四个 HTTP/REST 端点。第一个是一个通用的 `http://host:port/metrics`
    端点，它显示所有作用域和注册表中的所有指标。指标以它们各自指标注册表的名字为前缀，以避免混淆。其他三个端点是 `http://host:port/metrics`
    端点的子资源，它们报告每个特定注册表中的指标。它们是 `http://host:port/metrics/base`、`http://host:port/metrics/vendor`
    和 `http://host:port/metrics/application` HTTP/REST 端点。指标可以以 JSON 或 Prometheus
    展示格式报告。我们将在稍后详细介绍这两种格式。在接下来的讨论中，当提到指标端点时，我们将为了简洁省略 `http://host:port`。
- en: 'In summary, the following diagram illustrates the general flow of the metric
    life cycle. First, metrics are instrumented into your microservice (or provided
    by the runtime!). These metrics are reported on the `/metrics` endpoint. Some
    monitoring tool or platform (for example, Prometheus) is then used to retrieve
    the metric data and store it, thus transforming it into time series metrics. Another
    monitoring tool or platform (for example, Grafana) is then used to visualize that
    data:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，以下图表展示了指标生命周期的总体流程。首先，指标被配置到您的微服务中（或由运行时提供！）。这些指标在 `/metrics` 端点上进行报告。然后，使用某些监控工具或平台（例如
    Prometheus）检索指标数据并将其存储，从而将其转换为时间序列指标。然后，使用另一个监控工具或平台（例如 Grafana）来可视化这些数据：
- en: '![Figure 6.1 – Life cycle of a metric'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.1 – 指标的生命周期'
- en: '](img/B17377_06_01.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B17377_06_01.jpg)'
- en: Figure 6.1 – Life cycle of a metric
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 指标的生命周期
- en: We will now describe the three different metric scopes in more detail; that
    is, **base metrics**, **vendor metrics**, and **application metrics**.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将更详细地描述三种不同的指标作用域；即，**基础指标**、**供应商指标**和**应用指标**。
- en: Base metrics
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基础指标
- en: Base metrics are a set of metrics that must be provided by all MicroProfile
    Metrics runtimes. There are, however, a few exceptions, where the metrics can
    be optionally implemented instead. This slight variability is due to what base
    metrics were meant to achieve. The list of base metrics was created in the hopes
    of capturing and reporting metrics that each runtime would have. Having base metrics
    defined and implemented by the runtime relieves the developer from the burden
    of having to instrument their own metrics to capture basic and/or common statistics.
    By providing these base metrics, they would always be available, regardless of
    whether they are needed.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 基础指标是一组所有 MicroProfile Metrics 运行时必须提供的指标。然而，也有一些例外情况，其中指标可以可选实现。这种轻微的变异性是由于基础指标旨在实现的目标。基础指标列表的创建是为了捕捉和报告每个运行时可能拥有的指标。由运行时定义和实现基础指标可以减轻开发者需要自己配置指标以捕获基本和/或常用统计数据的负担。通过提供这些基础指标，它们将始终可用，无论是否需要。
- en: The obvious target for base metrics would be to encompass the **Java Virtual
    Machine** (**JVM**) statistics. Base metrics cover a long list of metrics that
    target memory statistics, garbage collection statistics, thread usage, thread
    pool statistics, class loading statistics, as well as operating system statistics.
    However, not every JVM is made equal, and a few of these metrics are optional
    as the JVM under the hood may not hold such statistics. Base metrics also include
    optional REST metrics that track the request count, unmapped exceptions count,
    and time spent on each REST/JAX-RS endpoint. We encourage you to review the list
    of base metrics and their definitions by looking at the MicroProfile Metrics specification
    at [https://bit.ly/3mXpL42](https://bit.ly/3mXpL42).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 基础指标显然的目标是包括 **Java 虚拟机**（**JVM**）的统计数据。基础指标覆盖了针对内存统计、垃圾回收统计、线程使用、线程池统计、类加载统计以及操作系统统计的众多指标。然而，并非每个
    JVM 都是相同的，其中一些指标是可选的，因为底层的 JVM 可能不保留此类统计数据。基础指标还包括可选的 REST 指标，这些指标跟踪请求计数、未映射异常计数以及每个
    REST/JAX-RS 端点上的时间。我们鼓励您通过查看 MicroProfile Metrics 规范来审查基础指标及其定义，规范链接为 [https://bit.ly/3mXpL42](https://bit.ly/3mXpL42)。
- en: The MicroProfile Metrics specification only defines the aforementioned JVM and
    REST metrics explicitly as base metrics, but the metrics generated by MicroProfile
    Fault Tolerance are classified as base metrics as well. We covered the MicroProfile
    Fault Tolerance metrics in the *Fault Tolerance metrics* section of the previous
    chapter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile Metrics 规范仅明确定义了上述 JVM 和 REST 指标作为基础指标，但 MicroProfile 故障恢复生成的指标也被归类为基础指标。我们在上一章的“故障恢复指标”部分介绍了
    MicroProfile 故障恢复指标。
- en: Vendor metrics
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 供应商指标
- en: Vendor metrics are metrics that are provided by the vendor for their implementation
    of MicroProfile Metrics. Different implementations of MicroProfile Metrics will
    contain different sets of vendor metrics. Vendor metrics are completely optional,
    and it can be the case that your chosen MicroProfile Metrics runtime does not
    supply any vendor metrics at all. The purpose of vendor metrics is to allow the
    vendor's implementation to provide any metrics that can enhance the monitoring
    capabilities of the end user for the specific MicroProfile Metrics runtime. For
    example, if the runtime you are using is also Jakarta EE compliant, then it may
    be possible for it to provide metrics related to components under that platform.
    The vendor metrics can then be exclusively accessed on the `/metrics/vendor` endpoint
    or combined with metrics from other scopes on the `/metrics` endpoint.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 供应商指标是供应商为其 MicroProfile Metrics 的实现提供的指标。不同的 MicroProfile Metrics 实现将包含不同的供应商指标集。供应商指标是完全可选的，并且可能存在您选择的
    MicroProfile Metrics 运行时不提供任何供应商指标的情况。供应商指标的目的在于允许供应商的实现提供任何可以增强最终用户对特定 MicroProfile
    Metrics 运行时监控能力的指标。例如，如果您使用的运行时也符合 Jakarta EE 标准，那么它可能能够提供与该平台下组件相关的指标。供应商指标可以通过
    `/metrics/vendor` 端点独家访问，或者与 `/metrics` 端点上的其他作用域的指标结合访问。
- en: Application metrics
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用指标
- en: Application metrics are metrics that have been instrumented by you, the developer,
    in your application. These metrics report on statistics that interest you and
    your team for observing and monitoring the performance of the application. This
    is the metrics scope that you will be primarily interacting with when instrumenting
    metrics. The application metrics can then be exclusively accessed on the `/metrics/application`
    endpoint or combined with metrics from other scopes on the `/metrics` endpoint.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 应用指标是您，即开发者，在您的应用程序中实现的指标。这些指标报告了您和您的团队感兴趣并用于观察和监控应用程序性能的统计数据。这是您在实现指标时将主要与之交互的指标作用域。应用指标可以通过
    `/metrics/application` 端点独家访问，或者与 `/metrics` 端点上的其他作用域的指标结合访问。
- en: The seven metric types
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 七种指标类型
- en: 'Now that we understand the different scopes of the available metrics, we can
    list the seven types of application metrics:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了可用的指标的不同作用域，我们可以列出七种应用指标类型：
- en: Counter
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计数器
- en: Gauge
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 度量
- en: Concurrent Gauge
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发度量
- en: Histogram
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直方图
- en: Meter
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计数器
- en: Timer
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计时器
- en: Simple Timer
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单计时器
- en: Given the names, it's easy to deduce what the different types of metrics serve
    to achieve. If not, don't worry – we'll cover these metrics in detail when we
    cover how to instrument the different metrics later, in the *Instrumenting metrics*
    section.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 根据名称，很容易推断出不同类型的指标旨在实现什么。如果不清楚，请不要担心——在我们介绍如何在不同指标上实现时，我们将在“实现指标”部分详细讨论这些指标。
- en: The metric model
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指标模型
- en: Now that we know what type of metrics there are, and under what scopes they
    may live, it's time for us to understand the underlying metric model. This may
    sound like a dull topic, and you may be tempted to skip this, but understanding
    this is crucial if you wish to know how to instrument and handle metrics effectively.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了有哪些类型的指标以及它们可能存在的范围，现在是时候让我们了解其背后的指标模型了。这听起来可能像是一个枯燥的话题，你可能会有跳过它的冲动，但如果你希望了解如何有效地进行指标监控和处理，理解这一点是至关重要的。
- en: A metric, besides being one of the seven metric types, consists of a name, a
    set of optional key-value `/metrics/*` endpoints.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一个指标，除了是七种指标类型之一外，还包括一个名称，一组可选的键值`/metrics/*`端点。
- en: 'The purpose of the name is rather obvious: it is to uniquely identify the metric
    from others. However, that may not be sufficient in some cases because different
    metrics can share the same name. This is because MicroProfile Metrics supports
    **multi-dimensional metrics** with key-value tags.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 命名的目的是相当明显的：它是为了唯一地识别出与其他指标不同的指标。然而，在某些情况下，这可能还不够，因为不同的指标可能具有相同的名称。这是因为MicroProfile
    Metrics支持带有键值标签的多维指标。
- en: The combination of the metric's name and its tags is encapsulated in a `MetricID`
    object in the metric registry. `MetricID` is the primary identifier of a metric.
    It is tightly coupled with the metric instance itself in the metric registry.
    The use of tags for a metric is optional, and it can be the case that the metrics
    in your application all use distinct metric names with no tags. This results in
    a `MetricID` with just a name and no tags. However, you may find it useful to
    leverage the power of multi-dimensional metrics, if the need arises. Such a need
    may come if you are attempting to record the same type of data (for example, a
    counter to count something) from multiple similar sources. You can use the same
    metric name and provide a tag that uniquely identifies it from the other sources.
    An example of this would be if you are using metrics to count how many times the
    methods in a specific class are being invoked. You can name the metrics `classMethodInvocations`
    and provide each method with a tag, where the key is `method` and the value is
    the name of the method.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 指标的名称及其标签的组合封装在指标注册表中的`MetricID`对象中。`MetricID`是指标的标识符。它在指标注册表中与指标实例本身紧密耦合。对于指标的标签使用是可选的，并且可能存在你应用程序中的所有指标都使用没有标签的独立指标名称的情况。这导致`MetricID`只有一个名称而没有标签。然而，如果你需要利用多维指标的力量，这可能是有用的。这种需求可能出现在你试图从多个类似来源记录相同类型的数据（例如，一个计数器来计数某些东西）时。你可以使用相同的指标名称并提供一个标签，以唯一地识别它与其他来源的不同。一个例子是，如果你正在使用指标来计数特定类中的方法被调用的次数。你可以将指标命名为`classMethodInvocations`，并为每个方法提供一个标签，其中键是`method`，值是方法的名称。
- en: This use of multi-dimensional metrics is best taken advantage of when using
    one of the available visualization monitoring tools, such as Grafana. You can
    quickly retrieve and display all metrics with the same name, regardless of what
    their tags are, in one simple query.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用可用的可视化监控工具之一，如Grafana时，这种多维指标的使用最能发挥其优势。你可以通过一个简单的查询快速检索和显示所有具有相同名称的指标，无论它们的标签是什么。
- en: 'The last item that is used to identify a metric is its metadata. The metadata
    consists of the metric''s name, its type, the metric''s unit of measurement (if
    applicable), an optional description, and an optional human-readable display name.
    For each unique metric name, there is only one piece of metadata. As a result,
    there can be multiple MetricID linked to one piece of metadata. Being able to
    reuse the metric''s name in the metadata helps correlate the MetricIDs and the
    metadata as they are loosely coupled in the metric registry. The relationships
    described previously are illustrated in the following diagram. ***** denotes 0
    to many:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 用于识别指标的最后一项是它的元数据。元数据包括指标名称、其类型、指标的度量单位（如果适用）、可选的描述和可选的易读显示名称。对于每个唯一的指标名称，只有一个元数据。因此，可以有多个MetricID与一个元数据相关联。能够在元数据中重复使用指标的名称有助于将MetricIDs和元数据关联起来，因为它们在指标注册表中是松散耦合的。之前描述的关系在以下图中表示。*****表示0到多个：
- en: '![Figure 6.2 – Metric registry metric model'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2 – 指标注册表指标模型'
- en: '](img/B17377_06_02.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2 – 指标注册表指标模型](img/B17377_06_02.jpg)'
- en: Figure 6.2 – Metric registry metric model
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 指标注册表指标模型
- en: Retrieving metric data
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 获取指标数据
- en: Before we continue with the topic of instrumenting metrics, we will cover how
    metrics are made available. In the *Instrumenting metrics* section, we will be
    covering each metric individually and providing examples of its output, specifically
    its Prometheus output. Therefore, first, we must understand what we will be looking
    at.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续讨论指标仪表化的主题之前，我们将介绍指标是如何提供的。在 *仪表化指标* 部分，我们将逐个介绍每个指标并提供其输出的示例，特别是其 Prometheus
    输出。因此，首先，我们必须了解我们将要查看的内容。
- en: As we mentioned previously, metrics are available through HTTP/REST requests
    to either the `/metrics`, `/metrics/base`, `/metrics/vendor`, or `/metrics/application`
    endpoint in either JSON or Prometheus exposition format. The metric output for
    a specific metric name can be retrieved by sending a request to `/metrics/<scope>/<metric_name>`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，指标可以通过向 `/metrics`、`/metrics/base`、`/metrics/vendor` 或 `/metrics/application`
    端点发送 HTTP/REST 请求以 JSON 或 Prometheus 展示格式获取。可以通过向 `/metrics/<scope>/<metric_name>`
    发送请求来检索特定指标名称的指标输出。
- en: JSON format
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON 格式
- en: The output of the metrics in JSON format comes in two parts. We can obtain the
    metric and its data by invoking a `GET` request with the `Accept` header by specifying
    `application/json`. If we issue an `OPTION` request instead, we will be able to
    retrieve the metadata associated with the metrics.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 指标的 JSON 格式输出分为两部分。我们可以通过指定 `Accept` 报头为 `application/json` 来调用带有 `GET` 报头的请求，以获取指标及其数据。如果我们发出
    `OPTION` 请求，我们将能够检索与指标关联的元数据。
- en: 'Let''s look at what sending a `GET` request to `/metrics` will return. Notice
    that the metrics from the different scopes are in their own JSON array lists.
    We will only show the base metrics and hide any vendor or application metrics
    in the sample output. We will also look at an example of multi-dimensional metrics
    by using the first two metrics listed in the base scope. There are two `gc.total`
    metrics whose key-value pairs are `"name=scavenge"` and `"name=global"`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看向 `/metrics` 发送 `GET` 请求会返回什么。注意，来自不同作用域的指标都位于它们自己的 JSON 数组列表中。我们只展示基本指标，并在示例输出中隐藏任何供应商或应用程序指标。我们还将通过使用基本作用域中列出的前两个指标来查看多维指标的一个示例。存在两个
    `gc.total` 指标，其键值对为 `"name=scavenge"` 和 `"name=global"`：
- en: '[PRE8]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To find out what the `gc.total` metric was meant for, we can obtain the metadata
    of the metrics by sending an `OPTIONS` request to `/metrics`. Since the output
    of this request will be lengthy, we will only show the `gc.total` metric and obfuscate
    the rest. Like the `GET` request, the metrics from each scope/registry are separated
    into their own JSON arrays:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出 `gc.total` 指标的目的，我们可以通过向 `/metrics` 发送 `OPTIONS` 请求来获取指标的元数据。由于此请求的输出将很长，我们只展示
    `gc.total` 指标并模糊其余部分。像 `GET` 请求一样，每个作用域/注册表的指标都分开到它们自己的 JSON 数组中：
- en: '[PRE9]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we can see from the metadata, the `gc.total` metric is a counter that'sused
    to count the number of garbage collections that have occurred in this JVM. The
    tags are used to identify two different garbage collectors on the system that
    the two metrics monitor.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从元数据中看到的，`gc.total` 指标是一个计数器，用于统计在这个 JVM 中发生的垃圾回收次数。标签用于识别系统上两个不同的垃圾回收器，这两个指标正在监控。
- en: A request was made to `/metrics` to demonstrate how the metrics are partitioned
    from different scopes. We could have also invoked `/metrics/base/gc.total` to
    specifically retrieve the metadata of the `gc.total` metric.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 向 `/metrics` 发送请求是为了展示如何从不同作用域中划分指标。我们也可以调用 `/metrics/base/gc.total` 来特别检索 `gc.total`
    指标的元数据。
- en: Prometheus exposition format
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Prometheus 展示格式
- en: With the Prometheus exposition format, all metric data is provided together
    with a `GET` request to the `/metrics/*` endpoints. If `application/json` is not
    specified, the Prometheus format will be returned by default. As its name suggests,
    this format to be used directly by the Prometheus monitoring tool.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Prometheus 展示格式，所有指标数据都通过向 `/metrics/*` 端点发送 `GET` 请求一起提供。如果没有指定 `application/json`，则默认返回
    Prometheus 格式。正如其名称所暗示的，这种格式可以直接由 Prometheus 监控工具使用。
- en: 'A specific template must be followed for formatting the metrics. To describe
    this, we''ll only take a look at the output from the `gc.total` metrics. We''re
    only using a snippet here as the full output would be too lengthy:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化指标必须遵循特定的模板。为了描述这一点，我们只看一下 `gc.total` 指标的输出。这里只使用片段，因为完整的输出会太长：
- en: '[PRE10]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In Prometheus exposition format, metrics are organized by their metric name.
    The first grouping is for the `base_gc_total` metric. This corresponds to the
    `gc.total` metric we saw in the aforementioned JSON format examples. The true
    metric name is `gc.total`, but it must be transformed into `gc_total` as Prometheus
    formatted metrics are alphanumeric characters with underscores (`_`). The MicroProfile
    Metrics runtime also prepends the name of the registry scope that the metric belongs
    to. This is either `base_`, `vendor_`, or `application_`. Notice that the tags
    are appended to the end of the metric's name, within squiggly brackets.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Prometheus 展示格式中，指标按其指标名称组织。第一组是针对 `base_gc_total` 指标。这对应于我们在前面提到的 JSON 格式示例中看到的
    `gc.total` 指标。真正的指标名称是 `gc.total`，但必须转换为 `gc_total`，因为 Prometheus 格式的指标是包含下划线的字母数字字符。MicroProfile
    Metrics 运行时还会在指标名称前添加指标所属的注册表作用域的名称。这可能是 `base_`、`vendor_` 或 `application_`。请注意，标签附加到指标名称的末尾，在波浪线括号内。
- en: Each unique grouping of metrics by metric name is preceded by a `# TYPE` line
    and a `# HELP` line. These two lines define the metric's type and a description,
    if available. Remember that the description is an optional field in the metric's
    metadata.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 每个按指标名称唯一分组的指标前都有一个 `# TYPE` 行和一个 `# HELP` 行。这两行定义了指标的类型和描述（如果有的话）。请记住，描述是指标元数据中的一个可选字段。
- en: There are additional formatting rules for certain metrics. We will cover this
    in the next section.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些指标，存在额外的格式化规则。我们将在下一节中介绍。
- en: Instrumenting metrics
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置指标
- en: The MicroProfile Metrics technology provides a rich Java API for programmatically
    instrumenting metrics, as well as providing CDI annotations for easily instrumenting
    metrics for methods, fields, and even entire classes. We will not cover all the
    possible scenarios of using the Java API and its annotations, particularly regarding
    the usage of the `MetricRegistry` class. Instead, this section will explain the
    main uses of the API and its annotations to allow you to understand how to use
    the technology with confidence. We encourage you to review the Java documentation
    for MicroProfile Metrics if you wish to completely master everything.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile Metrics 技术提供了一个丰富的 Java API，用于编程配置指标，并提供 CDI 注解，以便轻松为方法、字段甚至整个类配置指标。我们不会涵盖使用
    Java API 和其注解的所有可能场景，特别是关于 `MetricRegistry` 类的使用。相反，本节将解释 API 和注解的主要用途，以便您能够自信地使用这项技术。我们鼓励您在希望完全掌握所有内容时，查阅
    MicroProfile Metrics 的 Java 文档。
- en: In this section, we'll cover how to instrument each metric programmatically
    and with annotations. This will be followed by an example of the output of the
    `/metrics` endpoint in Prometheus exposition format. Preceding that, we will cover
    the technical aspects of the metric registry, metadata, tags, and `MetricID`.
    They provide the fundamental knowledge needed to effectively instrument metrics.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何通过编程和注释来配置每个指标。这将随后通过 Prometheus 展示格式中 `/metrics` 端点的输出示例。在此之前，我们将介绍指标注册表、元数据、标签和
    `MetricID` 的技术方面。它们提供了有效配置指标所需的基本知识。
- en: As you may recall from the *MicroProfile Metrics technology overview* section,
    the metric registry is the nexus of operation for the MicroProfile Metrics runtime.
    Unless you are strictly using annotations to instrument metrics in your microservice,
    you will need to obtain a `MetricRegistry` (CDI) bean. It is through this `MetricRegistry`
    that we can create, register, and retrieve metrics programmatically. Even if you
    are strictly using annotations to instrument metrics, you will be interacting
    with `MetricRegistry` under the covers.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从 *MicroProfile Metrics 技术概述* 部分中回忆的那样，指标注册表是 MicroProfile Metrics 运行时的操作核心。除非您严格使用注解在您的微服务中配置指标，否则您将需要获取一个
    `MetricRegistry`（CDI）bean。正是通过这个 `MetricRegistry`，我们可以编程地创建、注册和检索指标。即使您严格使用注解来配置指标，您也会在底层与
    `MetricRegistry` 交互。
- en: 'This section contains a large amount of content. The following is a summary
    of what we will be covering:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含大量内容。以下是我们将要涵盖的摘要：
- en: Obtaining a metric registry
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取指标注册表
- en: 'Creating, registering, and retrieving metrics:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建、注册和检索指标：
- en: a) Metatadata, tags, and MetricIDs
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) 元数据、标签和 MetricIDs
- en: b) Counter
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) 计数器
- en: c) Concurrent gauge
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c) 并发仪表
- en: d) Meter
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d) 计量器
- en: e) Timer and simple timer
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: e) 计时器和简单计时器
- en: f) Gauge
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: f) 仪表
- en: The `@Metric` annotation
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Metric` 注解'
- en: Let's get started!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Obtaining a metric registry
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取指标注册表
- en: 'To obtain `MetricRegistry`, we can use injection, as demonstrated in the following
    code sample:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取`MetricRegistry`，我们可以使用注入，如下面的代码示例所示：
- en: '[PRE11]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Remember that there are three types of metric registry scopes: the base metric
    registry, the vendor metric registry, and the application metric registry. By
    default, when you inject a `MetricRegistry` into your application, the MicroProfile
    Metrics runtime will provide an application registry. You can inject the other
    types of registries if you wish. You will need to annotate your injection with
    a `@RegistryType` and with an annotation parameter specifying the type of registry
    to inject. The following example illustrates the usage of `@RegistryType`, where
    we specify the type as `MetricRegistry.Type.Application`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，存在三种类型的指标注册表作用域：基本指标注册表、供应商指标注册表和应用指标注册表。默认情况下，当你将`MetricRegistry`注入到你的应用程序中时，MicroProfile
    Metrics运行时会提供一个应用注册表。如果你愿意，你可以注入其他类型的注册表。你需要使用`@RegistryType`注解来注解你的注入，并使用一个注解参数指定要注入的注册表类型。以下示例说明了`@RegistryType`的使用，其中我们指定类型为`MetricRegistry.Type.Application`：
- en: '[PRE12]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can inject a base metric registry and a vendor metric registry if you specify
    a `@RegistryType(type=MetricRegistry.Type.BASE)` or `@RegistryType(type=MetricRegistry.Type.VENDOR)`
    annotation, respectively. However, in your application, you should NOT be registering
    metrics or manipulating the base or vendor metrics. These two metric registries
    should only be used to retrieve the metrics so that you can view their data.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你指定了`@RegistryType(type=MetricRegistry.Type.BASE)`或`@RegistryType(type=MetricRegistry.Type.VENDOR)`注解，则可以注入基本指标注册表和供应商指标注册表。然而，在你的应用程序中，你不应该注册指标或操作基本或供应商指标。这两个指标注册表应仅用于检索指标，以便你可以查看其数据。
- en: Note About `MetricRegistry` and Annotation Usage
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`MetricRegistry`和注解使用的说明
- en: When using annotations to instrument metrics, you will only be interacting with
    the application metric registry. You will not be able to choose which `MetricRegistry`
    the metric annotations apply to.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用注解来配置指标时，你将只与应用程序的指标注册表进行交互。你将无法选择指标注解应用于哪个`MetricRegistry`。
- en: Creating, registering, and retrieving metrics
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建、注册和检索指标
- en: 'Using `MetricRegistry`, you can create and register metrics using specific
    methods for each metric type. Each metric type, except for Gauge, will have the
    following method signatures. Invoking such methods from `MetricRegistry` will
    create, register, and return an instance of that metric if a metric with the given
    name, metadata, and tags does not already exist in the registry. If one does exist,
    then that existing metric is returned. It should be noted that using metric annotations,
    except for the gauge annotation, works similarly. We will demonstrate the method''s
    signature pattern with the `Counter` metric type:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`MetricRegistry`，你可以使用针对每种指标类型特定的方法来创建和注册指标。除了度量表（Gauge）之外，每种指标类型都将具有以下方法签名。从`MetricRegistry`调用此类方法将在注册表中不存在具有给定名称、元数据和标签的指标时创建、注册并返回该指标的实例。如果已经存在，则返回现有指标。需要注意的是，使用指标注解（除了度量表注解之外）的工作方式类似。我们将使用`Counter`指标类型来演示方法签名模式：
- en: '[PRE13]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The method names for the other metric types are `concurrentGauge`, `timer`,
    `simpleTimer`, `histogram`, and `meter`. We will demonstrate the various usages
    of these methods in the metric-specific sections. Gauge also has its own set of
    methods that `MetricRegistry` provides, but we will cover those in the *Gauge*
    section.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 其他指标类型的名称为`concurrentGauge`、`timer`、`simpleTimer`、`histogram`和`meter`。我们将在特定于指标的章节中演示这些方法的多种用法。度量表（Gauge）也有其自己的方法集，由`MetricRegistry`提供，但我们将这些内容放在*度量表（Gauge）*部分进行介绍。
- en: Note on Metric Reusability
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 关于指标重用性的说明
- en: Whether you're using `MetricRegistry` or the metric annotations to instrument
    your metrics, you can reuse an existing metric by specifying matching metadata
    or `MetricID` values.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 不论你是使用`MetricRegistry`还是使用指标注解来配置你的指标，你可以通过指定匹配的元数据或`MetricID`值来重用现有的指标。
- en: To only retrieve metrics, you can call one of the `getMetrics()`, `getCounters()`,
    `getGauges()`, `getConcurrentGauges()`, `getHistograms()`, `getMeters()`, `getTimers()`,
    or `getSimpleTimers()` methods from `MetricRegistry`. These calls will return
    a map of the desired metrics, with `MetricID` as the key.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只想检索指标，你可以从`MetricRegistry`调用`getMetrics()`、`getCounters()`、`getGauges()`、`getConcurrentGauges()`、`getHistograms()`、`getMeters()`、`getTimers()`或`getSimpleTimers()`方法之一。这些调用将返回一个包含所需指标的映射，其中`MetricID`作为键。
- en: There are other methods for creating, registering, retrieving, and deleting
    metrics from the metric registry, some of which use a `MetricFilter`, as well
    as other methods concerning retrieving metadata and metric IDs. You can even create
    your own implementation of the metrics and register that over the instances provided
    by the MicroProfile Metrics runtime. However, these methods will not be covered
    as there a simply too many! We encourage you to review the Java documentation
    of the `MetricRegistry` class. The information we've provided so far regarding
    the use of `MetricRegistry` s is to help you understand the subsequent sections.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他方法用于创建、注册、检索和从指标注册表中删除指标，其中一些使用`MetricFilter`，以及其他与检索元数据和指标ID有关的方法。你甚至可以创建自己的指标实现并将其注册到MicroProfile
    Metrics运行时提供的实例上。然而，这些方法将不会在本节中介绍，因为它们太多了！我们鼓励你查阅`MetricRegistry`类的Java文档。我们之前提供的关于使用`MetricRegistry`的信息是为了帮助你理解后续章节。
- en: Metadata, tags, and MetricIDs
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元数据、标签和`MetricID`
- en: As you may have noticed in the previous section, metadata, tags, and MetricIDs
    can and will be used in your application code by the metric registry. However,
    we must understand how to create and use them before we can learn how to instrument
    and utilize the different metrics.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上一节中可能已经注意到的，元数据、标签和`MetricID`可以被指标注册表在你的应用程序代码中使用。然而，在我们学习如何配置和使用它们之前，我们必须了解如何创建和使用它们。
- en: Every metric must contain metadata information. As you may recall, metadata
    information consists of its name, metric type, unit of measurement, a description,
    and a display name. The required fields from this set are the name and the metric
    type. The other metadata fields are optional. All this information is encompassed
    in a `Metadata` object. Every field in the `Metadata` object is a `String`. For
    the metric type field, you will need to specify an `enum` value from a `MetricType`
    `enum`. For the unit field, you will need to specify one of the static fields
    in `MetricUnits`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 每个指标都必须包含元数据信息。正如你可能记得的，元数据信息包括其名称、指标类型、度量单位、描述和显示名称。这个集合中必需的字段是名称和指标类型。其他元数据字段是可选的。所有这些信息都包含在一个`Metadata`对象中。`Metadata`对象中的每个字段都是`String`类型。对于指标类型字段，你需要指定来自`MetricType`枚举的一个`enum`值。对于单位字段，你需要指定`MetricUnits`中的静态字段之一。
- en: If you are instrumenting multi-dimensional metrics, then you will also need
    to provide tags for your metrics. Every tag is a key-value pair of `String` values
    and is represented by a `Tag` object. The tag's name must match the `[a-zA-Z_][a-zA-Z0-9_]*`
    regex. The value of the tag can be anything. A metric can contain 0 or more tags.
    This `Tag` is then set into a `MetricID` that also contains the `String` name
    of the metric.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在配置多维指标，那么你还需要为你的指标提供标签。每个标签都是一个`String`值的键值对，并由一个`Tag`对象表示。标签的名称必须匹配正则表达式`[a-zA-Z_][a-zA-Z0-9_]*`。标签的值可以是任何内容。一个指标可以包含0个或多个标签。然后这个`Tag`被设置到一个包含指标`String`名称的`MetricID`中。
- en: Note About Configurable Tags
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 关于可配置标签的说明
- en: Using MicroProfile Config, we can define two config values for setting tag values
    to all the metrics in the MicroProfile Metrics runtime. `mp.metrics.appName` takes
    a single string value that is used to identify the application's name. This will
    be appended to all the metrics as a key-value tag in the form of `_app=<application_name>.`
    The `mp.metrics.tags` config allows a comma-separated list of key-value tags to
    be defined in the form of `tag1=value1,tag2=value2`. These tags will then be applied
    to all metrics.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MicroProfile Config，我们可以为设置MicroProfile Metrics运行时中所有指标的标签值定义两个配置值。`mp.metrics.appName`接受一个用于标识应用程序名称的单个字符串值。这将作为键值标签`_app=<application_name>.`附加到所有指标上。`mp.metrics.tags`配置允许以`tag1=value1,tag2=value2`的形式定义逗号分隔的键值标签列表。这些标签将被应用到所有指标上。
- en: Using metadata and tags programmatically
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用元数据和标签进行编程
- en: 'When instrumenting metrics programmatically, we need to create a `Metadata`
    object. To accomplish this, we need to retrieve `MetadataBuilder` by invoking
    the static `Metadata.builder()` method. Using this `MetadataBuilder`, we can construct
    a `Metadata` object using a builder pattern. At the very minimum, we will want
    to specify its name and metric type. In the following example, we won''t be registering
    any metrics, so we will use the `MetricType.INVALID` metric type. When we demonstrate
    how to instrument each of the individual metrics in the rest of this section,
    we will use the appropriate `MetricType` there:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序化度量指标时，我们需要创建一个 `Metadata` 对象。为了完成这个任务，我们需要通过调用静态的 `Metadata.builder()` 方法来检索
    `MetadataBuilder`。使用这个 `MetadataBuilder`，我们可以使用构建器模式构造一个 `Metadata` 对象。至少，我们希望指定其名称和度量类型。在以下示例中，我们不会注册任何度量，所以我们将使用
    `MetricType.INVALID` 度量类型。在接下来的部分中，我们将演示如何为每个单独的度量使用适当的 `MetricType`：
- en: '[PRE14]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To create a `Metadata` object with all the fields specified, you can do the
    following. Once again, as this example is for the sake of demonstration, we will
    use the `MetricUnits.NONE` value. Since the upcoming sections will not be using
    the unit field heavily, we encourage you to explore the available unit values
    available by reviewing the source file at [https://bit.ly/3ds4IDK](https://bit.ly/3ds4IDK).
    The following example also includes the use of tags and a `MetricID`. Creating
    a `Tag` is a simple process in that you invoke the `Tag` constructor with the
    `String` name and value parameters. You can then construct a `MetricID` by passing
    the metric name and a variable-length amount of `Tag` parameters into the `MetricID`
    constructor.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个包含所有字段的 `Metadata` 对象，你可以这样做。再次强调，由于这个例子是为了演示，我们将使用 `MetricUnits.NONE`
    值。由于即将到来的部分不会大量使用单位字段，我们鼓励你通过查看源文件 [https://bit.ly/3ds4IDK](https://bit.ly/3ds4IDK)
    来探索可用的单位值。以下示例还包括了使用标签和 `MetricID`。创建一个 `Tag` 是一个简单的过程，你只需要使用 `String` 名称和值参数调用
    `Tag` 构造函数。然后，你可以通过将度量名称和可变长度的 `Tag` 参数传递给 `MetricID` 构造函数来构造一个 `MetricID`。
- en: 'The full source code for `MetricsResource` can be found at [https://bit.ly/2UzoczI](https://bit.ly/2UzoczI):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`MetricsResource` 的完整源代码可以在 [https://bit.ly/2UzoczI](https://bit.ly/2UzoczI)
    找到：'
- en: '[PRE15]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using a combination of MetricIDs, tags, and metadata, you can create, register,
    and retrieve metrics from `MetricRegistry`. As you may recall from the previous
    section, which listed the different method signatures, `MetricID` and `Metadata`
    are never used together as arguments. However, we know that the metric registry
    uses both to classify and identify the registered metrics. This is because the
    metric registry will be able to infer the minimum necessary data to construct
    the other object, whether it be `MetricID` or metadata, during processing.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通过组合 `MetricID`、标签和元数据，你可以创建、注册并从 `MetricRegistry` 中检索度量。如你所回忆的，在前面的部分中，列出了不同的方法签名，`MetricID`
    和 `Metadata` 从不作为参数一起使用。然而，我们知道度量注册表使用它们来分类和识别已注册的度量。这是因为度量注册表将在处理过程中推断出构建其他对象（无论是
    `MetricID` 还是元数据）所需的最小必要数据。
- en: Using metadata and tags with annotations
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用注解与元数据和标签
- en: When instrumenting metrics with annotations, the metadata and tags are provided
    through the annotation parameters. It is possible to not have to specify any parameters
    at all. The MicroProfile Metrics runtime, when using CDI, can infer the necessary
    information. This type of annotation already provides a metric type and if no
    name is provided, then a name is generated using the package name, class name,
    and method name. Alternatively, in a situation where the annotation is used on
    a constructor, it will be a combination of the package name, class name, and constructor
    name (that is, the class name again!).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用注解来度量指标时，元数据和标签通过注解参数提供。可能根本不需要指定任何参数。当使用 CDI 时，MicroProfile Metrics 运行时可以推断出必要的信息。这种类型的注解已经提供了一个度量类型，如果没有提供名称，则将使用包名、类名和方法名生成一个名称。或者，在注解用于构造函数的情况下，它将是包名、类名和构造函数名的组合（即类名再次！）。
- en: Even if a name is supplied, the full metric name is a combination of the class
    name and the metric name. However, this may prove undesirable. To address this,
    each metric annotation parameter contains an `absolute` parameter, which you can
    set to `true` so that the metric uses the provided metric name.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 即使提供了名称，完整的度量名称也是类名和度量名称的组合。然而，这可能会证明是不理想的。为了解决这个问题，每个度量注解参数都包含一个 `absolute`
    参数，你可以将其设置为 `true`，这样度量就会使用提供的度量名称。
- en: 'To demonstrate how to provide the metadata information with annotations, the
    following code snippet will use the Counter class'' `@Counted` annotation:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何使用注解提供元数据信息，以下代码片段将使用 Counter 类的 `@Counted` 注解：
- en: '[PRE16]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we can see, `name`, `displayName`, and `description` parameters exist that
    accept `String` values. The `absolute` parameter accepts a `Boolean` value. The
    unit accepts a static field from `MetricUnits`, and tags are accepted as a list
    of `String` values in *key-value* format.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，存在接受 `String` 值的 `name`、`displayName` 和 `description` 参数。`absolute` 参数接受一个
    `Boolean` 值。单位接受来自 `MetricUnits` 的静态字段，标签以 *键值* 格式接受为 `String` 值列表。
- en: Counter
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计数器
- en: 'We''ve finally arrived at our first metric: the counter. The counter metric,
    as its name suggests, is a metric that keeps count of the metrics. The counter
    can only monotonically increase. You can use this to keep track of how many times
    a method or block of business logic has been invoked, or the number of times a
    request was received or sent.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于到达了我们的第一个指标：计数器。计数器指标，正如其名称所暗示的，是一个记录指标数量的指标。计数器只能单调递增。你可以使用它来跟踪一个方法或业务逻辑块被调用的次数，或者接收或发送请求的次数。
- en: Instrumenting counters programmatically
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用编程方式对计数器进行度量
- en: The following code sample demonstrates how to create and retrieve a counter
    metric named `counterMetric` using two `GET` requests. In the first `GET` resource,
    the `/counter1` URI, we create `counterMetric` by invoking `MetricRegistry.counter(Metadata
    metadata, Tags… tags)`. This will return a new counter metric that we can increment
    by calling `counter.inc()`, which increments the counter by 1\. In the second
    `GET` resource, the `/counter2` URI, we do something different and call `MetricRegistry.counter(MetricID
    metricID)`. Here, `MetricID` matches the `MetricID` property that was generated
    by the metric registry when we first created and registered `counterMetric`. Since
    it already exists, we are returned the existing `counterMetric` using the metric
    registry. We then increment it by calling the `inc(long value`) method to increment
    the counter by a specified amount. In our example, we increment it by 3\. In both
    `GET` resources, we return a string that includes the current count of the counter
    by invoking `getCount()`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例演示了如何使用两个 `GET` 请求创建和检索名为 `counterMetric` 的计数器指标。在第一个 `GET` 资源，即 `/counter1`
    URI 中，我们通过调用 `MetricRegistry.counter(Metadata metadata, Tags… tags)` 创建 `counterMetric`。这将返回一个新的计数器指标，我们可以通过调用
    `counter.inc()` 来递增计数器，这将计数器递增 1。在第二个 `GET` 资源，即 `/counter2` URI 中，我们做了一些不同的事情，并调用
    `MetricRegistry.counter(MetricID metricID)`。在这里，`MetricID` 与我们在首次创建和注册 `counterMetric`
    时由度量注册器生成的 `MetricID` 属性相匹配。由于它已经存在，我们通过度量注册器返回现有的 `counterMetric`。然后我们通过调用 `inc(long
    value)` 方法来递增计数器，以指定的数量递增。在我们的示例中，我们递增了 3。在两个 `GET` 资源中，我们通过调用 `getCount()` 返回一个包含计数器当前计数的字符串。
- en: 'The full source code for `CounterResource` can be found at [https://bit.ly/2XGDDXZ](https://bit.ly/2XGDDXZ):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`CounterResource` 的完整源代码可以在 [https://bit.ly/2XGDDXZ](https://bit.ly/2XGDDXZ)
    找到：'
- en: '[PRE17]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let''s see what happens when we send requests to both `GET` resources
    and then view the results through `/metrics/application/counterMetric` directly:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看当我们向两个 `GET` 资源发送请求，然后通过 `/metrics/application/counterMetric` 直接查看结果时会发生什么：
- en: '[PRE18]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the output, we issue `GET` requests to the `/ch6/counterResource/counter1`
    and `/ch6/counterResource/counter2` endpoints and the counter metric is incremented
    by 1 and 3, respectively. We then issue a `GET` request to `/metrics/application/counterMetric`
    to view the Prometheus formatted output of our counter metric directly. `application_counterMetric_total{metricType="counter"}`
    is returned, which represents the counter metric with its tag of `metricType="counter"`.
    It holds a value of 4, as expected.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，我们向 `/ch6/counterResource/counter1` 和 `/ch6/counterResource/counter2` 端点发出
    `GET` 请求，计数器指标分别递增 1 和 3。然后我们向 `/metrics/application/counterMetric` 发出 `GET` 请求，直接查看计数器指标的
    Prometheus 格式输出。返回 `application_counterMetric_total{metricType="counter"}`，它代表具有
    `metricType="counter"` 标签的计数器指标。其值为 4，正如预期的那样。
- en: Note About Prometheus Formatting with Counters
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 关于计数器的 Prometheus 格式说明
- en: Counter metrics in Prometheus exposition format will have the `_total` suffix
    appended to the metric name.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus 展示格式中的计数器指标将在指标名称后附加 `_total` 后缀。
- en: Instrumenting counters with annotations
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用注解对计数器进行度量
- en: Using annotations is a much simpler affair. You can annotate the `@Counted`
    annotation on either a method, constructor, or even a whole class. When the annotated
    element is invoked, the counter is incremented by 1.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用注解是一个更简单的事情。您可以在方法、构造函数甚至整个类上注解`@Counted`注解。当注解的元素被调用时，计数器增加1。
- en: In our example, we'll annotate the `MetricsResource` class with `@Counted`.
    When a metric annotation is annotated on a class, it will apply to all applicable
    targets in the class for that annotation. For `@Counted`, this means that all
    the constructors and methods will be instrumented. This example will also demonstrate
    the metric names that are generated. Note that since we are using annotations,
    we do not need to inject `MetricRegistry`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将使用`@Counted`注解来注解`MetricsResource`类。当一个度量注解注解在类上时，它将应用于该注解的所有适用目标。对于`@Counted`，这意味着所有构造函数和方法都将被度量。此示例还将演示生成的度量名称。请注意，由于我们使用注解，我们不需要注入`MetricRegistry`。
- en: 'The full source code for `CounterAnnotatedResource` can be found at [https://bit.ly/3iZiL6D](https://bit.ly/3iZiL6D):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`CounterAnnotatedResource`的完整源代码可以在[https://bit.ly/3iZiL6D](https://bit.ly/3iZiL6D)找到：'
- en: '[PRE19]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s take the application for a drive. We''ll omit showing the `curl` command
    to the application''s REST endpoint and just show the output of querying `/metrics/application`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们驾驶一下应用程序。我们将省略显示到应用程序REST端点的`curl`命令，只显示查询`/metrics/application`的输出：
- en: '[PRE20]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: After issuing a single `GET` request to `/ch6/counterResource/getResource`,
    we should see the aforementioned values when viewing the metric data on the `/metrics/application`
    endpoint. `application_metrics_demo_CounterAnnotatedResource_getResource_total`
    is the counter metric that was created for the `getResource()` method, while `application_metrics_demo_CounterAnnotatedResource_CounterAnnotatedResource_total`
    is the counter metric that was created for the constructor of the class. Both
    values are *1*, as expected.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在向`/ch6/counterResource/getResource`发出单个`GET`请求后，我们应该在查看`/metrics/application`端点的度量数据时看到上述值。`application_metrics_demo_CounterAnnotatedResource_getResource_total`是针对`getResource()`方法创建的计数器度量，而`application_metrics_demo_CounterAnnotatedResource_CounterAnnotatedResource_total`是针对类构造函数创建的计数器度量。两个值都是*1*，正如预期的那样。
- en: Concurrent gauge
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并发度量
- en: The concurrent gauge metric is a metric that's used to count the parallel invocation
    of the instrumented component. Its values can increase or decrease. This metric
    can be used to count the number of parallel invocations of a method, business
    logic, requests, and more. Besides counting parallel invocations, the concurrent
    gauge metric also keeps track of the highest and lowest count that's been recorded
    within the previously **completed full minute**. A completed full minute denotes
    the period from 0:00:00.9999999 to 0:00:59.99999999 on the clock. A completed
    full minute does not mean the last 60 seconds from the current instantaneous time.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 并发度量指标是一种用于计算被测量组件的并行调用的度量。其值可以增加或减少。此度量可以用来计算方法、业务逻辑、请求等的并行调用次数。除了计算并行调用次数外，并发度量指标还跟踪之前**已完成的完整分钟**内记录的最高和最低计数。一个完成的完整分钟表示时钟从0:00:00.9999999到0:00:59.99999999的时间段。一个完成的完整分钟并不意味着从当前瞬时时间的最后60秒。
- en: Instrumenting concurrent gauges programmatically
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 以编程方式对并发度量指标进行度量
- en: In this section, we'll demonstrate how to use a concurrent gauge. They are typically
    invoked in parallel using a `Runnable` named `sleeper`. This creates – and subsequently
    retrieves – a concurrent gauge named `concurrentGaugeMetric`. In this example,
    we will use `MetricRegistry.concurrentGauge(String name)` in our interaction with
    the metric registry. This is the simplest creation or retrieval method provided
    by the metric registry as you only need to provide the name. This infers that
    there are no tags associated with this metric. The sleeper `Runnable` will then
    increment the concurrent gauge (for example, with `inc()`), sleep for 10 seconds,
    and then decrement it (for example, with `dec()`). You can only increment or decrement
    by 1\. We'll make parallel invocations using a `for` loop and an `ExecutorService`.
    However, what's not shown in this code example are the getter methods for the
    three values; that is, `getCount()`, `getMin()`, and `getMax()`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将演示如何使用并发量规。它们通常使用名为 `sleeper` 的 `Runnable` 并行调用。这创建并随后检索一个名为 `concurrentGaugeMetric`
    的并发量规。在这个例子中，我们将使用 `MetricRegistry.concurrentGauge(String name)` 与度量注册表进行交互。这是度量注册表提供的最简单的创建或检索方法，因为您只需要提供名称。这表示与此度量没有关联的标签。然后，`sleeper`
    `Runnable` 将增加并发量规（例如，使用 `inc()`），睡眠 10 秒，然后减少它（例如，使用 `dec()`）。您只能增加或减少 1。我们将使用
    `for` 循环和 `ExecutorService` 进行并行调用。然而，在此代码示例中没有显示三个值的获取方法；即 `getCount()`、`getMin()`
    和 `getMax()`。
- en: 'The full source code for `ConcurrentGaugeResource` can be found at [https://bit.ly/3ghFyZz](https://bit.ly/3ghFyZz):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentGaugeResource` 的完整源代码可以在 [https://bit.ly/3ghFyZz](https://bit.ly/3ghFyZz)
    找到：'
- en: '[PRE21]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For this example, we will send a `GET` request called `/ch6/concurrentGaugeResource/concurrentGauge`.
    Once the current minute has completed, we will view the output via `/metrics/application`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将发送一个名为 `/ch6/concurrentGaugeResource/concurrentGauge` 的 `GET` 请求。一旦当前分钟完成，我们将通过
    `/metrics/application` 查看输出：
- en: '[PRE22]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding output, we issued a `GET` request to `/ch6/concurentGaugeResource/concurrentGauge`.
    We then followed up with a `GET` request, `/metrics/application`, to view the
    output. `application_concurrentGaugeMetric_current` shows the current value, which
    is `10`, as expected. `application_concurrentGaugeMetric_max` and `application_concurrentGaugeMetric_min`,
    which show the maximum and minimum recorded values of the previous full minute,
    are `0`, as expected. After the current full minute has completed, we view the
    results again and we see that the current, max, and min values are `0`, `0`, and
    `10`, as expected.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们向 `/ch6/concurentGaugeResource/concurrentGauge` 发出了一个 `GET` 请求。然后，我们跟进了一个
    `GET` 请求，`/metrics/application`，以查看输出。`application_concurrentGaugeMetric_current`
    显示了预期的当前值 `10`。`application_concurrentGaugeMetric_max` 和 `application_concurrentGaugeMetric_min`，显示了上一分钟记录的最大和最小值，都是预期的
    `0`。在当前整分钟完成之后，我们再次查看结果，我们看到当前、最大和最小值都是预期的 `0`、`0` 和 `10`。
- en: Note About Metrics with Multiple Values
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 关于具有多个值的度量注意事项
- en: The concurrent gauge is our first metric with multiple output values. To display
    all the values with the same metric name, each value of the metric is given its
    own suffix. We will see this pattern in other complex metrics later.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 并发量规是我们第一个具有多个输出值的度量。为了使用相同的度量名称显示所有值，每个度量值都分配了自己的后缀。我们将在其他复杂度量中看到这种模式。
- en: Immediately after our `GET` request to `/ch6/concurrentGaugeResource/concurrentGaugeParallel`,
    we will see that the current count for the concurrent gauge is `10`. When the
    10 seconds have elapsed for each thread and a full minute has passed, we will
    see that the current value is `0` and that the maximum value is `10`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们向 `/ch6/concurrentGaugeResource/concurrentGaugeParallel` 发出 `GET` 请求后立即，我们将看到并发量规的当前计数为
    `10`。当每个线程的 10 秒已过并且已经过去整整一分钟时，我们将看到当前值是 `0`，最大值是 `10`。
- en: Instrumenting concurrent gauges with annotations
  id: totrans-237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用注解仪表化并发量规
- en: To instrument a concurrent gauge with annotations, you must use the `@ConcurrentGauge`
    annotation. This applies to methods, constructors, and classes.The concurrent
    gauge annotation will increment when the target is invoked and decrement when
    it is finished.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用注解对并发量规进行仪表化，您必须使用 `@ConcurrentGauge` 注解。这适用于方法、构造函数和类。当目标被调用时，并发量规注解将增加，当它完成时将减少。
- en: We'll demonstrate the usage of `@ConcurrentGauge` in a similar fashion to the
    programmatic example. The `sleeper` runnable will invoke the `sleeper()` method,
    which is annotated with the `@ConcurrentGauge` annotation. In this example, we
    will specify `absolute=true`, which will then cause the MicroProfile Metrics runtime
    to use the metric's name. The `/metrics/*` output will be the same as it was for
    the programmatic example, so it will not be shown here.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以与程序示例类似的方式演示 `@ConcurrentGauge` 的用法。`sleeper` 可运行对象将调用带有 `@ConcurrentGauge`
    注解的 `sleeper()` 方法。在这个例子中，我们将指定 `absolute=true`，这将导致 MicroProfile Metrics 运行时使用指标名称。`/metrics/*`
    输出将与程序示例相同，因此在此处不会展示。
- en: 'The full source code for `ConcurrentGaugeAnnotatedResource` can be found at
    [https://bit.ly/3xZZhD0](https://bit.ly/3xZZhD0):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentGaugeAnnotatedResource` 的完整源代码可以在 [https://bit.ly/3xZZhD0](https://bit.ly/3xZZhD0)
    找到：'
- en: '[PRE23]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Histogram
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 直方图
- en: 'The histogram metric, like a histogram graph, processes the data it has been
    provided with in a statistical distribution. A histogram metric outputs 12 values:
    count, sum, minimum value, maximum value, mean, standard deviation, and the 50th,
    75th, 95th, 98th, 99th, and 99.9th percentiles. Unlike the other metrics, the
    histogram metric can only be instrumented programmatically. There is no annotation
    support. You might use a histogram metric to record and calculate the distribution
    of the sizes of data that your application receives for processing.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图指标，就像直方图图表一样，以统计分布的方式处理它所提供的数据。直方图指标输出 12 个值：计数、总和、最小值、最大值、平均值、标准差以及第 50、75、95、98、99
    和 99.9 个百分位数。与其他指标不同，直方图指标只能通过编程方式进行仪表化。没有注解支持。您可以使用直方图指标来记录和计算应用程序在处理过程中接收到的数据大小的分布。
- en: 'For our demonstration, we''ll generate 1,000 random numbers within the range
    *0-999* and feed them into our histogram. This time, we will use `metricRegistry.histogram(Metadata
    metadata)` to create our histogram. We won''t be showing the `getCount()`, `getSum()`,
    and `getSnapshot()` getter methods here, which return `Snapshot` objects that
    contain the getter methods for the remaining statistical values. As this would
    be too lengthy to list, you can view the `Snapshot` class and its methods here:
    [https://bit.ly/2QndNFf](https://bit.ly/2QndNFf).'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的演示中，我们将生成 1,000 个介于 *0-999* 范围内的随机数，并将它们输入到我们的直方图中。这次，我们将使用 `metricRegistry.histogram(Metadata
    metadata)` 来创建我们的直方图。我们不会展示 `getCount()`、`getSum()` 和 `getSnapshot()` 获取器方法，这些方法返回包含剩余统计值获取器方法的
    `Snapshot` 对象。由于这会太长而无法列出，您可以在以下位置查看 `Snapshot` 类及其方法：[https://bit.ly/2QndNFf](https://bit.ly/2QndNFf)。
- en: 'The full source code for `HistogramResource` can be found at [https://bit.ly/3y4AoWK](https://bit.ly/3y4AoWK):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`HistogramResource` 的完整源代码可以在 [https://bit.ly/3y4AoWK](https://bit.ly/3y4AoWK)
    找到：'
- en: '[PRE24]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s see what results we get:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们会得到什么结果：
- en: '[PRE25]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding output, we issued a `GET` request to `/ch6/histogramResource/histogram`
    and we followed up with a `GET` request to `/metrics/application` to view the
    results. As expected, the count is 1,000, as reported by the `application_histogramMetric_seconds_count`
    value. The remaining metric values are the calculated values. As there are a large
    number of values, we will not be explicitly covering all of them. The names provided
    for the metric values are self-explanatory to indicate what values they represent.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们向 `/ch6/histogramResource/histogram` 发出了一个 `GET` 请求，并随后向 `/metrics/application`
    发出了一个 `GET` 请求以查看结果。正如预期的那样，计数为 1,000，这是由 `application_histogramMetric_seconds_count`
    值报告的。剩余的指标值是计算得出的值。由于值数量众多，我们不会明确覆盖所有这些值。提供的指标值名称是自解释的，以表明它们代表什么值。
- en: Note About Prometheus Formatting with Histograms
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用直方图的 Prometheus 格式说明
- en: If a unit has been defined, the metric name is appended to the unit as `_<unit>`.
    Prometheus only accepts certain **base units**, so the MicroProfile Metrics runtime
    will scale the value to the appropriate base unit. For example, if milliseconds
    were specified as the unit, the values will be scaled to a base unit of seconds.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已定义了单位，则将指标名称附加到单位上作为 `_<unit>`。Prometheus 只接受某些 **基本单位**，因此 MicroProfile
    Metrics 运行时将值缩放到适当的基单位。例如，如果指定了毫秒作为单位，则值将缩放到秒的基单位。
- en: Also, notice that the quantile metric values share the same name but use tags
    to identify which percentile it is representing.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，分位数指标值具有相同的名称，但使用标签来标识它代表的是哪个百分位数。
- en: Meter
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计数器
- en: The meter metric, like the histogram metric, aggregates input values and performs
    calculations to produce results. Instead of statistical distributions, the meter
    calculates rates in units per second. The unit that's specified for the metric
    will be ignored. This only applies to the Prometheus output. The meter outputs
    the mean rate and the 1, 5, and 15-minute exponentially weighted moving average
    rates. Meter can be useful for monitoring the traffic on a specific method or
    component in your microservice.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表度量，就像直方图度量一样，聚合输入值并执行计算以产生结果。仪表计算的是每秒的速率，而不是统计分布。指定的度量单位将被忽略。这仅适用于 Prometheus
    输出。仪表输出平均速率以及 1、5 和 15 分钟的指数加权移动平均速率。仪表对于监控微服务中特定方法或组件的流量非常有用。
- en: Instrumenting meters programmatically
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 以编程方式对仪表进行配置
- en: 'In our example, we''ll demonstrate using the meter metric to monitor the rate
    of requests to two `GET` resources: `/meter` and `/meter2`. With the first `GET`
    resource, we will use the last variant of the register/retrieve methods that we
    have yet to use with `MetricRegistry.meter(String metricName, Tags… tags)`. Once
    the metric has been created or retrieved, we will invoke the `mark()` method,
    which increases the meter''s recorded hits by 1\. With the second `GET` resource,
    we can pass a long parameter value so that we can invoke `mark(long value)`, which
    increments the number of hits to the meter by the specified value. Notice that
    we use `MetricID` in the `/meter2` `GET` resource to retrieve the metric we created
    and registered in the `/meter` resource.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将演示使用仪表度量来监控两个 `GET` 资源 `/meter` 和 `/meter2` 的请求速率。对于第一个 `GET` 资源，我们将使用我们尚未与
    `MetricRegistry.meter(String metricName, Tags… tags)` 一起使用的注册/检索方法的最后一个变体。一旦创建或检索到度量，我们将调用
    `mark()` 方法，该方法将仪表记录的点击次数增加 1。对于第二个 `GET` 资源，我们可以传递一个长参数值，以便调用 `mark(long value)`，这将按指定值增加仪表的点击次数。注意，我们在
    `/meter2` `GET` 资源中使用 `MetricID` 来检索在 `/meter` 资源中创建和注册的度量。
- en: 'The full source code for `MeterResource` can be found at [https://bit.ly/3ASCV8j](https://bit.ly/3ASCV8j):'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`MeterResource` 的完整源代码可以在 [https://bit.ly/3ASCV8j](https://bit.ly/3ASCV8j)
    找到：'
- en: '[PRE26]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Not shown are the getter methods for the values; that is, `getCount()`, `getMeanRate()`,
    `getOneMinuteRate()`, `getFiveMinuteRate()`, and `getFifteenMinuteRate()`. Let''s
    run through hitting both `GET` resources and view the result at `/metrics/application`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 未显示的是值的获取方法；即 `getCount()`、`getMeanRate()`、`getOneMinuteRate()`、`getFiveMinuteRate()`
    和 `getFifteenMinuteRate()`。让我们运行一下对 `GET` 资源的访问，并在 `/metrics/application` 查看结果：
- en: '[PRE27]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding output, we issued a `GET` request to `/ch6/meterResource/`
    meter, which increments the meter by 1, followed by a `GET` request to `/ch6/meterResource/meter2`,
    supplying it with a parameter value to increment the meter by 3\. We then viewed
    the resulting output in `/metrics/application`. `application_histogramMetric_total`
    shows that the count is 4, as expected, and that the remaining values are the
    calculated values. Once again, the names associated with the remaining metric
    values are self-explanatory and will not be explicitly explained.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们向 `/ch6/meterResource/` 仪表发送了一个 `GET` 请求，将其增加 1，然后向 `/ch6/meterResource/meter2`
    发送了一个 `GET` 请求，并提供了参数值以将仪表增加 3。然后我们在 `/metrics/application` 中查看了结果输出。`application_histogramMetric_total`
    显示计数为 4，正如预期的那样，其余的值是计算值。再次强调，与剩余度量值相关的名称是自解释的，将不会进行明确解释。
- en: Instrumenting meters with annotations
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用注释对仪表进行配置
- en: To instrument a meter metric with annotations, you must use the `@Metered` annotation.
    This annotation applies to methods, constructors, and classes. Like other annotated
    metrics, only a single value is incremented by using the annotation. We'll demonstrate
    a sample that uses the `@Metered` annotation and omit showing the results.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用注释对仪表度量进行配置，必须使用 `@Metered` 注解。此注解适用于方法、构造函数和类。与其他注解度量一样，使用注解只能增加单个值。我们将演示一个使用
    `@Metered` 注解的示例，并省略显示结果。
- en: 'The full source code for `MeterAnnotatedResource` can be found at [https://bit.ly/3mhnHpk](https://bit.ly/3mhnHpk):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`MeterAnnotatedResource` 的完整源代码可以在 [https://bit.ly/3mhnHpk](https://bit.ly/3mhnHpk)
    找到：'
- en: '[PRE28]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Timer and simple timer
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计时器和简单计时器
- en: Since both the timer and simple timer metrics are very similar, we will demonstrate
    how to use both metrics together.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 由于计时器和简单计时器度量非常相似，我们将演示如何一起使用这两个度量。
- en: The **timer** metric, as its name implies, records the time spent going through
    the instrumented component. At its core, it keeps track of the total elapsed time.
    Additionally, it provides the throughput/rate from the hits recorded, as well
    as the statistical distribution of the recorded times. These outputted values
    are the same as they are for the histogram and meter metrics.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**计时器**指标，正如其名称所暗示的，记录通过仪器组件所花费的时间。在其核心，它跟踪总经过时间。此外，它还提供了记录的击中次数的吞吐量/速率，以及记录时间的统计分布。这些输出的值与直方图和计量指标相同。'
- en: The **simple timer** metric, on the other hand, is a timer but with the extra
    bells and whistles stripped off. It only reports on the count, total elapsed time,
    and, like the concurrent gauge, the highest and lowest recorded time of the previous
    complete full minute. If you don't require all the extra values that the timer
    provides, or intend to calculate them yourself later, the simple timer should
    be your metric of choice.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**简单计时器**指标是一个计时器，但去掉了额外的功能。它只报告计数、总经过时间，以及，类似于并发计量器，上一完整分钟的最高和最低记录时间。如果你不需要计时器提供的所有额外值，或者打算稍后自己计算它们，那么简单计时器应该是你的首选指标。
- en: Instrumenting timers and simple timers programmatically
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 以编程方式仪器化计时器和简单计时器
- en: In our example, we'll instrument a timer and a simple timer in their own `GET`
    resources. In both resources, we will provide an example of how to record time
    using the `Context` object. This allows us to explicitly mark the beginning and
    end of what we want to time by calling the `time()` method from either the timer
    or simple timer, to start timing, and then calling the `Context` object's `close()`
    method to stop timing. Note that the `Context` object is an inner interface of
    both the `Timer` and `SimpleTimer` classes, and that you will need to use the
    appropriate `Context` object. Both the timer and simple timer metrics can time
    the execution of a `Runnable` or `Callable` object or lambda expression. The following
    two code snippets are from the same `TimersResource` class, and the full source
    code can be found at [https://bit.ly/37YaWYy](https://bit.ly/37YaWYy).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将在各自的`GET`资源中仪器化计时器和简单计时器。在这两个资源中，我们将提供一个使用`Context`对象记录时间的示例。这允许我们通过从计时器或简单计时器调用`time()`方法来显式标记我们想要计时的开始和结束，以开始计时，然后调用`Context`对象的`close()`方法来停止计时。请注意，`Context`对象是`Timer`和`SimpleTimer`类的内部接口，并且你需要使用适当的`Context`对象。计时器和简单计时器指标都可以计时`Runnable`或`Callable`对象或lambda表达式的执行。以下两个代码片段来自同一个`TimersResource`类，完整的源代码可以在[https://bit.ly/37YaWYy](https://bit.ly/37YaWYy)找到。
- en: 'The following code snippet shows the `GET` resource known as `/timer`, which
    demonstrates timing with a `Runnable` object with the timer metric:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了名为`/timer`的`GET`资源，它使用计时器指标演示了使用`Runnable`对象进行计时：
- en: '[PRE29]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following code snippet shows the `GET` resource called `/simpleTimer`,
    which demonstrates timing with a `Callable` object with the simple timer metric:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了名为`/simpleTimer`的`GET`资源，它使用简单计时器指标演示了使用`Callable`对象进行计时：
- en: '[PRE30]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Not shown are the getter methods for the metric values. For the timer, you can
    call `getCount()`, `getElapsedTime()`, `getSnapshot()`, `getMeanRate()`, `getOneMinuteRate()`,
    `getFiveMinuteRate()`, and `getFifteenMinuteRate()`. For the simple timer, you
    can call `getCount()`, `getElapsedTime()`, `getMinTimeDuration()`, and `getMaxTimeDuration()`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 未显示的是获取指标值的获取方法。对于计时器，你可以调用`getCount()`、`getElapsedTime()`、`getSnapshot()`、`getMeanRate()`、`getOneMinuteRate()`、`getFiveMinuteRate()`和`getFifteenMinuteRate()`。对于简单计时器，你可以调用`getCount()`、`getElapsedTime()`、`getMinTimeDuration()`和`getMaxTimeDuration()`。
- en: 'Let''s call both `GET` resources and see the results:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`GET`资源，并查看结果：
- en: '[PRE31]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: First, we issue `GET` requests to `/ch6/timersResource/timer` and `/ch6/timersResource/simpleTimer`
    to invoke both of our timers. We then send a request to `/metrics/application`
    to view the results. As we have already demonstrated the similar max and min behavior
    of the concurrent gauge, we will not be demonstrating that behavior for the simple
    timer here. Additionally, as the timer metric outputs a statistical distribution
    of the recorded times (which includes the total recorded durations) and the throughput
    of requests, similar to the histogram and meter metrics, the timer metric's output
    will be omitted. What remains is the output for the simple timer. Notice that
    the values for `application_simpleTimerMetric_maxTimeDuration_seconds` and `application_simpleTimerMetric_minTimeDuration_seconds`
    report `NaN`. This is because there are no recorded values for the previously
    completed minute. If you would like to view the full output, we encourage you
    to try out the samples directly. Take a look at the *Technical requirements* section
    at the beginning of this chapter for instructions on how to run the samples.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们向`/ch6/timersResource/timer`和`/ch6/timersResource/simpleTimer`发送`GET`请求以调用我们的两个计时器。然后，我们向`/metrics/application`发送请求以查看结果。由于我们已经展示了并发仪表的最大和最小行为的相似性，因此我们在此不会演示简单计时器的该行为。此外，由于计时器指标输出记录时间的统计分布（包括总记录持续时间）和请求吞吐量，类似于直方图和仪表指标，因此计时器指标的输出将被省略。剩下的就是简单计时器的输出。请注意，`application_simpleTimerMetric_maxTimeDuration_seconds`和`application_simpleTimerMetric_minTimeDuration_seconds`的值报告为`NaN`。这是因为之前完成的分钟内没有记录的值。如果您想查看完整的输出，我们鼓励您直接尝试样本。请查看本章开头的*技术要求*部分，了解如何运行样本的说明。
- en: Instrumenting timers and simple timers with annotations
  id: totrans-280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用注解仪表化计时器和简单计时器
- en: To instrument the timer and simple timer metric, you will need to use `@Timed`
    and `@SimplyTimed`, respectively. These annotations apply to methods, constructors,
    and classes. They will both record how long it takes to execute the target annotated
    element.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 要对计时器和简单计时器指标进行仪表化，您需要分别使用`@Timed`和`@SimplyTimed`。这些注解适用于方法、构造函数和类。它们都会记录目标注解元素执行所需的时间。
- en: We will show a simple example demonstrating how to annotate `@Timed` and `@SimplyTimed`
    on a JAX-RS endpoint.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示一个简单示例，演示如何在JAX-RS端点上注解`@Timed`和`@SimplyTimed`。
- en: 'The full source code for `TimersAnnotatedResource` can be found at [https://bit.ly/3xVroDb](https://bit.ly/3xVroDb):'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`TimersAnnotatedResource`的完整源代码可以在[https://bit.ly/3xVroDb](https://bit.ly/3xVroDb)找到：'
- en: '[PRE32]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Gauges
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仪表
- en: A gauge metric serves to report on some value that is provided by the application.
    This can be any value, but it is highly recommended that the value is a number
    as Prometheus only supports numeric gauges. This is not a limitation of JSON output.
    Additionally, you can only create a numeric gauge using the metric registry's
    methods for creating a gauge.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表指标用于报告应用程序提供的某些值。这可以是任何值，但强烈建议该值是一个数字，因为Prometheus仅支持数字仪表。这并不是JSON输出的限制。此外，您只能使用指标注册表的创建仪表的方法来创建数字仪表。
- en: Instrumenting gauges programmatically
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 程序化仪表化仪表
- en: As we mentioned earlier, the gauge metric does not follow the same pattern of
    the registration and retrieval method signatures like the other metrics do. This
    is due to the nature of what the gauge metric does. When registering or retrieving
    a gauge, you will need to specify a `Supplier` or `Function` object or lambda
    expression.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，仪表指标不遵循与其他指标相同的注册和检索方法签名模式。这是由于仪表指标的性质所致。在注册或检索仪表时，您需要指定一个`Supplier`或`Function`对象或lambda表达式。
- en: 'The following are the method signatures for registering or retrieving a gauge
    metric:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为注册或检索仪表指标的方法签名：
- en: '[PRE33]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The only notable method you can call with the gauge metric is `getValue()`.
    Since you should be familiar with the usage of the `MetricID` class, the `Metadata`
    class, how to create a metric, and Java functions (which we assume you are familiar
    with), we will not be providing any example code for instrumenting the gauge metric
    programmatically.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用仪表指标调用的唯一显著方法是`getValue()`。由于您应该熟悉`MetricID`类、`Metadata`类、如何创建指标以及Java函数（我们假设您熟悉），因此我们不会提供任何用于程序化仪表化仪表指标的示例代码。
- en: Instrumenting gauges with annotations
  id: totrans-292
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用注解仪表化仪表
- en: To instrument a gauge metric, you will need to use the `@Gauge` annotation.
    This annotation can only be applied to a method. With the gauge annotation, you
    must specify the unit parameter. We will show a simple example where the method,
    and therefore the gauge, will return the current millisecond since the last epoch.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 要对量规指标进行仪表化，您需要使用 `@Gauge` 注解。此注解只能应用于方法。使用量规注解时，您必须指定单位参数。我们将展示一个简单示例，其中方法（因此是量规）将返回自上次纪元以来的当前毫秒数。
- en: 'The full source code for `GaugeResource` can be found at [https://bit.ly/3mfj6Ux](https://bit.ly/3mfj6Ux):'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`GaugeResource` 的完整源代码可以在 [https://bit.ly/3mfj6Ux](https://bit.ly/3mfj6Ux)
    找到：'
- en: '[PRE34]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We''ll assume that a `GET` request invokes this method, so we''ll just show
    the resulting `/metrics/application` output here:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设一个 `GET` 请求调用此方法，所以我们只在这里展示结果 `/metrics/application` 输出：
- en: '[PRE35]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note About Prometheus Formatting with Gauges
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Prometheus 格式化量规的注意事项
- en: The unit that's defined for the gauge is appended as `_<unit>` and is scaled
    to the appropriate base unit.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为该量规定义的单位附加为 `_<unit>` 并将其缩放到适当的基单位。
- en: The @Metric annotation
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`@Metric` 注解'
- en: The `@Metric` annotation is a unique annotation that allows you to inject a
    metric that corresponds to the field or parameter type that it is being annotated
    on. The `@Metric` annotation contains the same annotation parameters as the other
    metric annotations. It will return a metric with the matching metadata, if it
    exists; otherwise, a new metric of the specified type will be created, registered,
    and injected. Let's look at an example of using both injection strategies.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Metric` 注解是一种独特的注解，允许您注入与被注解的字段或参数类型相对应的指标。`@Metric` 注解包含与其他指标注解相同的注解参数。如果存在匹配的元数据，它将返回一个指标；否则，将创建、注册并注入指定类型的新指标。让我们看看使用两种注入策略的示例。'
- en: 'The full source code for `MetricsResource` can be found at [https://bit.ly/3iBAz7E](https://bit.ly/3iBAz7E):'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`MetricsResource` 的完整源代码可以在 [https://bit.ly/3iBAz7E](https://bit.ly/3iBAz7E)
    找到：'
- en: '[PRE36]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the aforementioned example, `fieldInjectedCounter` is injected with field
    injection and `parameterInjectedCounter` is injected with parameter injection.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，`fieldInjectedCounter` 使用字段注入进行注入，而 `parameterInjectedCounter` 使用参数注入进行注入。
- en: Visualizing metric data with Prometheus and Grafana
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Prometheus 和 Grafana 可视化指标数据
- en: The MicroProfile Metrics runtime can only report on instantaneous metric values.
    To effectively use this data for monitoring purposes, we need to aggregate that
    data with a tool such as Prometheus. Then, using a tool such as Grafana, we can
    create a wide variety of visualizations that present the metric data over a configurable
    time period. Prometheus can scrape data from multiple sources and Grafana will
    then pull the data from it by performing queries against Prometheus using the
    `REST.request`, from the Broker microservice of the StockTrader application.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile 指标运行时只能报告瞬时指标值。为了有效地使用这些数据用于监控目的，我们需要使用 Prometheus 等工具聚合这些数据。然后，使用
    Grafana 等工具，我们可以创建各种可视化，展示可配置时间段内的指标数据。Prometheus 可以从多个来源抓取数据，然后 Grafana 通过对 Prometheus
    执行查询（使用 `REST.request`），从 StockTrader 应用程序的代理微服务中获取数据。
- en: Understanding the `REST.request` Metric
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 `REST.request` 指标
- en: The `REST.request` metric is a simple timer that is automatically instrumented
    to all REST endpoints by the MicroProfile Metrics runtime. The instrumented `REST.request`
    metrics are differentiated from each other with tags related to the class name
    and the method signature.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`REST.request` 指标是一个简单的计时器，由 MicroProfile 指标运行时自动仪表化到所有 REST 端点。仪表化的 `REST.request`
    指标通过与类名和方法签名相关的标签区分彼此。'
- en: The Broker microservice
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代理微服务
- en: The Broker service contains multiple JAX-RS/REST endpoints for creating, retrieving,
    and deleting Broker objects, as well as retrieving portfolio returns with `GET`,
    `POST`, and `DELETE` requests. This all occurs in the `AccountService` class.
    The full source code can be found at [https://bit.ly/3sBGvPE](https://bit.ly/3sBGvPE).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 代理服务包含多个 JAX-RS/REST 端点，用于创建、检索和删除代理对象，以及使用 `GET`、`POST` 和 `DELETE` 请求检索投资组合回报。所有这些都在
    `AccountService` 类中发生。完整源代码可以在 [https://bit.ly/3sBGvPE](https://bit.ly/3sBGvPE)
    找到。
- en: 'First, we''ll look at the sample output of a `REST.request` metric so that
    we can understand the format of the metric name and its tags, before we demonstrate
    querying it with Grafana. We''ll show the output of a `GET` endpoint that queries
    all accounts whose method is `getAccounts()`. The other base metrics – the max
    time and min time values and the metric description for `REST.request` – have
    been omitted from the output:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将查看`REST.request`指标的样本输出，以便在演示如何使用Grafana查询它之前，了解指标名称的格式及其标签。我们将展示一个`GET`端点的输出，该端点查询所有方法为`getAccounts()`的账户。其他基本指标（`REST.request`的最大时间和最小时间值以及指标描述）已从输出中省略：
- en: '[PRE37]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Visualizing with Grafana
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Grafana进行可视化
- en: 'In Grafana, we can create a visualization out of each metric by querying the
    metric name. For example, we can simply query `base_REST_request_total` and Grafana
    will display all instances of that metric, which counts the request invocations
    to a REST endpoint. Alternatively, if we want to see only the metrics from a single
    microservice, such as `AccountService`, we can issue the following query:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在Grafana中，我们可以通过查询指标名称来创建每个指标的可视化。例如，我们可以简单地查询`base_REST_request_total`，Grafana将显示该指标的所有实例，该指标计算对REST端点的请求调用次数。或者，如果我们只想查看单个微服务（如`AccountService`）的指标，我们可以发出以下查询：
- en: '[PRE38]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'However, just the total count of a counter doesn''t tell us much. We would
    be more interested in knowing how many times the metrics have increased in the
    past 10 minutes instead. Here, we can perform the following query:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅仅计数器的总计数并不能告诉我们太多。我们更感兴趣的是知道在过去10分钟内指标增加了多少次。在这里，我们可以执行以下查询：
- en: '[PRE39]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Or perhaps we want to know the rate at which requests have increased in the
    past 10 minutes:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，也许我们想知道在过去10分钟内请求增加的速率：
- en: '[PRE40]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When using a simple timer, what we would be most interested in is the timing
    data. However, the elapsed time by itself is nothing significant, but we can calculate
    a new value that may prove more useful. Using the elapsed time and count, we can
    calculate the average duration per request with the following query:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用简单的计时器时，我们最感兴趣的是计时数据。然而，仅凭经过的时间本身并没有什么意义，但我们可以计算一个新的值，这可能会更有用。使用经过的时间和计数，我们可以使用以下查询计算每个请求的平均持续时间：
- en: '[PRE41]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following is a graphical visualization of the aforementioned query. The
    details of the snapshot are not important; the snapshot serves to illustrate the
    layout of what you would expect to see when using Grafana. The query is entered
    at the top, with the visualization displayed in the middle, and a table or list
    of the queried metrics at the bottom:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对上述查询的图形可视化。快照的详细信息并不重要；快照的作用是说明使用Grafana时您期望看到的布局。查询输入在顶部，可视化显示在中间，底部是查询的指标表格或列表：
- en: '![Figure 6.3 – A Grafana graph visualization'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3 – Grafana图形可视化'
- en: '](img/B17377_06_03.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17377_06_03.jpg)'
- en: Figure 6.3 – A Grafana graph visualization
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – Grafana图形可视化
- en: These examples only show a sliver of the potential of using Prometheus and Grafana.
    In the preceding figure, we only used a graph visualization. There are a wide
    variety of visualizations that exist that suit any specific visualization needs
    you may have. On top of that, there is a vast array of functions available to
    use with PromQL to calculate any specific values that you and your team may find
    useful. It should also be noted that the preceding figure only shows a direct
    view of a single visualization. Remember that you can build dashboards with multiple
    visualizations displayed all at once.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例仅展示了使用Prometheus和Grafana的潜在能力的一小部分。在前面的图中，我们只使用了图形可视化。存在大量适合您可能需要的特定可视化需求的可视化。除此之外，还有大量可用于与PromQL一起使用的函数，以计算您和您的团队可能发现有用的任何特定值。还应注意的是，前面的图只显示了单个可视化的直接视图。请记住，您可以使用多个可视化同时显示的仪表板。
- en: We've now come to the end of the MicroProfile Metrics section. With the metrics
    instrumented in your microservice, you can monitor different parts of your application
    in detail. In the next section, we'll learn how to observe requests that span
    multiple microservices with MicroProfile OpenTracing.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经到达了MicroProfile Metrics部分的结尾。在您的微服务中配置了指标后，您可以详细监控应用程序的不同部分。在下一节中，我们将学习如何使用MicroProfile
    OpenTracing观察跨越多个微服务的请求。
- en: Tracing your cloud-native application using MicroProfile OpenTracing
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MicroProfile OpenTracing跟踪您的云原生应用程序
- en: We will conclude our MicroProfile observability journey by looking at the MicroProfile
    OpenTracing technology. Unlike the other two technologies we've examined in this
    chapter, MicroProfile OpenTracing is much more lightweight in comparison. We'll
    cover the importance of this technology while overviewing it and jump straight
    into learning how to use MicroProfile OpenTracing.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过探讨MicroProfile OpenTracing技术来结束我们的MicroProfile可观察性之旅。与本章中我们检查的其他两种技术相比，MicroProfile
    OpenTracing要轻量得多。我们将概述这项技术的重要性，并直接学习如何使用MicroProfile OpenTracing。
- en: The importance of and an overview of MicroProfile OpenTracing in a cloud-native
    application
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务原生应用中MicroProfile OpenTracing的重要性及概述
- en: The MicroProfile OpenTracing technology ties in with the concept of **distributed
    tracing**. In a cloud environment, applications or microservices communicate and
    interact with one another, which, in turn, can interact with other microservices.
    This chain of interactions can be quite lengthy, depending on the nature and context
    of your application deployments. When something unexpectantly fails, it can be
    a difficult and troublesome task to diagnose where things have gone wrong in such
    a complex and distributed topology.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile OpenTracing技术与**分布式跟踪**的概念相结合。在云环境中，应用程序或微服务相互通信和交互，反过来，它们还可以与其他微服务交互。这种交互链可能相当长，具体取决于应用程序部署的性质和上下文。当出现意外故障时，在如此复杂和分布式的拓扑结构中诊断问题可能是一个困难和麻烦的任务。
- en: This is where distributed tracing comes in. Distributed tracing allows us to
    track and monitor requests or processes as it navigates from one application to
    another. Throughout its journey, which is referred to as a **trace**, performance
    data (for example, time spent), contextual data in the form of tags, and any important
    logs are retrieved for a **span**. A span defines the individual hierarchal segments
    that make up a **trace**. Each span can be identified by name.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是分布式跟踪发挥作用的地方。分布式跟踪使我们能够跟踪和监控请求或过程，它在从应用程序到另一个应用程序的导航过程中。在其旅程中，被称为**跟踪**，性能数据（例如，花费的时间）、以标签形式存在的上下文数据以及任何重要的日志都会为**跨度**检索。跨度定义了构成**跟踪**的个体分层段。每个跨度都可以通过名称进行识别。
- en: For example, invocating a method creates a span named *method1*. This method
    can then invoke another method, which then creates a new **child span**, named
    *method2*, that is under the scope of the **parent span** from the first method.
    When the child span is complete (that is, the method finishes invoking), it returns
    to the first method and when the first method finishes, the trace is completed.
    There is no limit to how many child spans there can be. The resulting trace records
    are sent to an external tool or platform that gathers and stores these records,
    and can provide a way for us to view all the traces and the spans that it comprises.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，调用一个方法会创建一个名为*method1*的跨度。然后，这个方法可以调用另一个方法，这将创建一个新的**子跨度**，名为*method2*，它位于第一个方法的**父跨度**范围内。当子跨度完成（即，方法完成调用）时，它返回到第一个方法，当第一个方法完成时，跟踪完成。子跨度的数量没有限制。生成的跟踪记录将被发送到外部工具或平台，这些工具或平台收集并存储这些记录，并提供一种方式，使我们能够查看所有跟踪及其包含的跨度。
- en: It is through this that we can analyze and understand the performance and latency
    of a request, and any additional contextual information from individual spans,
    as it navigates through multiple microservices. With distributed tracing, we can
    easily profile the performance and latency of a request and diagnose any errors
    or failures that occur.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以分析和理解请求的性能和延迟，以及从单个跨度中检索的任何附加上下文信息，当它通过多个微服务导航时。有了分布式跟踪，我们可以轻松地分析请求的性能和延迟，并诊断发生的任何错误或故障。
- en: For distributed tracing to be effective in a system, all applications must use
    the same distributed tracing library. Now, you may be thinking that this is what
    MicroProfile OpenTracing serves to satisfy. This is not the case. The MicroProfile
    OpenTracing technology operates on top of the existing **OpenTracing** technology.
    The OpenTracing technology is a façade that defines a vendor-neutral API for instrumenting
    distributed tracing in an application. This OpenTracing technology is incorporated
    into the MicroProfile OpenTracing runtime. To be able to apply to trace instrumentation
    to your application, you will need to use a compatible **tracer** implementation.
    You can view the compatible tracers at [https://opentracing.io/docs/supported-tracers/](https://opentracing.io/docs/supported-tracers/).
    However, note that the different MicroProfile OpenTracing runtimes are compatible
    with different sets of tracer libraries. Consult the documentation of your chosen
    runtime for more details. It can even be the case that your chosen runtime may
    support a tracer that isn't on OpenTracing's list of officially supported tracers.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 要使分布式跟踪在系统中有效，所有应用程序都必须使用相同的分布式跟踪库。现在，你可能认为这正是 MicroProfile OpenTracing 旨在满足的。但这并非事实。MicroProfile
    OpenTracing 技术建立在现有的 **OpenTracing** 技术之上。OpenTracing 技术是一个定义了用于在应用程序中实施分布式跟踪的供应商中立
    API 的外观。这种 OpenTracing 技术被整合到 MicroProfile OpenTracing 运行时中。为了能够将跟踪仪器应用于您的应用程序，您需要使用兼容的
    **跟踪器** 实现。您可以在 [https://opentracing.io/docs/supported-tracers/](https://opentracing.io/docs/supported-tracers/)
    查看兼容的跟踪器。然而，请注意，不同的 MicroProfile OpenTracing 运行时与不同的跟踪库集兼容。请查阅您选择的运行时的文档以获取更多详细信息。甚至可能的情况是，您选择的运行时可能支持
    OpenTracing 官方支持跟踪器列表之外的跟踪器。
- en: Each application in the system will need to be configured to use the same tracer
    library. Different tracer libraries may differ in how they communicate the contextual
    identification data of a trace, which is called the **span context**. The span
    context contains stateful information that is accompanied by a request as it navigates
    through the network of microservices. This allows the OpenTracing technology to
    link spans together into a singular trace when they transcend application boundaries.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 系统中的每个应用程序都需要配置以使用相同的跟踪库。不同的跟踪库在如何传达跟踪的上下文识别数据方面可能有所不同，这被称为 **span 上下文**。span
    上下文包含伴随请求在网络微服务中导航的状态信息。这使得 OpenTracing 技术能够在跨越应用程序边界时将 span 链接在一起形成一个单一的跟踪。
- en: MicroProfile OpenTracing amends the OpenTracing technology by defining an additional
    `@Traced` annotation that complements the use of the OpenTracing technology. However,
    the main benefit of MicroProfile OpenTracing is that you can automatically instrument
    traces on inbound and outbound JAX-RS requests. Any JAX-RS application will be
    traced without the developer having to deal with the MicroProfile OpenTracing
    API or the OpenTracing API. We will not cover how to use the OpenTracing API in
    this book, only the amendments that MicroProfile OpenTracing provides. We leave
    it up to you to explore the OpenTracing API and its documentation at [https://bit.ly/3gEHLis](https://bit.ly/3gEHLis).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile OpenTracing 通过定义一个额外的 `@Traced` 注解来完善 OpenTracing 技术。然而，MicroProfile
    OpenTracing 的主要好处是您可以在入站和出站 JAX-RS 请求上自动检测跟踪。任何 JAX-RS 应用都将被跟踪，而无需开发者处理 MicroProfile
    OpenTracing API 或 OpenTracing API。本书中我们将不涵盖如何使用 OpenTracing API，只介绍 MicroProfile
    OpenTracing 提供的修改。我们将探索 OpenTracing API 及其文档的任务留给你。您可以在 [https://bit.ly/3gEHLis](https://bit.ly/3gEHLis)
    查看相关信息。
- en: The producer of the implementation library may also provide a platform/server
    that aggregates the tracing records. We will demonstrate this with the Jaeger
    Tracing platform at the end of this section.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 实现库的制作者也可能提供一个平台/服务器，用于聚合跟踪记录。我们将在本节末尾使用 Jaeger 跟踪平台来演示这一点。
- en: Special Note on OpenTracing
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 OpenTracing 的特别说明
- en: At the time of writing, the OpenTracing project has combined with OpenCensus
    to form OpenTelemetry. OpenTelemetry is an all-in-one technology that will satisfy
    your monitoring needs for tracing, logging, and metrics. Future iterations of
    the MicroProfile platform may see the incorporation of OpenTelemetry and its subcomponents.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，OpenTracing 项目已与 OpenCensus 合并，形成 OpenTelemetry。OpenTelemetry 是一种全能技术，将满足您在跟踪、日志记录和指标方面的监控需求。MicroProfile
    平台的未来迭代可能会看到 OpenTelemetry 及其子组件的整合。
- en: Auto-instrumenting JAX-RS requests
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动检测 JAX-RS 请求
- en: MicroProfile OpenTracing allows you to automatically instrument tracing on JAX-RS
    requests on both the client and server side. When a request is sent through a
    JAX-RS client or using MicroProfile Rest Client, a span will be automatically
    created. If an active span already exists, then it will be a child span of the
    active span. This span begins when the request is sent by the client.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile OpenTracing 允许您在客户端和服务器端自动插装 JAX-RS 请求的跟踪。当通过 JAX-RS 客户端或使用 MicroProfile
    Rest Client 发送请求时，将自动创建一个跨度。如果已存在活动跨度，则它将是活动跨度的子跨度。此跨度从客户端发送请求时开始。
- en: Similarly, when an incoming JAX-RS request is received, a span will be created.
    If the request is part of a trace, the MicroProfile OpenTracing runtime will automatically
    determine that by attempting to extract span context information from the incoming
    request. If such data exists, then the new span is a child span of a preceding
    span in this trace. If there are no active spans or extractable span context information,
    then a new span and, subsequently, a new trace is created. This span begins when
    the request is received and correlates with the JAX-RS resource method. This default
    behavior of auto-instrumentation on the JAX-RS resource method can be overridden
    with the use of the `@Traced` annotation, which will be covered in the *Instrumenting
    the @Traced annotation and injecting a Tracer* section.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当接收到传入的 JAX-RS 请求时，将创建一个跨度。如果请求是跟踪的一部分，MicroProfile OpenTracing 运行时将通过尝试从传入请求中提取跨度上下文信息来自动确定这一点。如果存在此类数据，则新创建的跨度将是此跟踪中先前跨度的子跨度。如果没有活动跨度或可提取的跨度上下文信息，则将创建一个新的跨度，随后创建一个新的跟踪。此跨度从接收到请求时开始，并与
    JAX-RS 资源方法相关联。这种在 JAX-RS 资源方法上自动插装的默认行为可以通过使用 `@Traced` 注解来覆盖，这将在 *插装 @Traced
    注解和注入 Tracer* 部分中介绍。
- en: There are some additional rules regarding names and tags that we will cover
    once we have described how to auto-instrument outbound and inbound JAX-RS requests.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在描述如何自动插装出站和传入 JAX-RS 请求之后，介绍有关名称和标签的一些附加规则。
- en: Outbound JAX-RS requests
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 出站的 JAX-RS 请求
- en: With outbound JAX-RS requests, the span that is created is given the name of
    the HTTP method to be invoked. For example, a `GET` request results in a span
    named `GET`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在出站的 JAX-RS 请求中，创建的跨度将使用要调用的 HTTP 方法的名称。例如，一个 `GET` 请求将导致名为 `GET` 的跨度。
- en: Note on Using JAX-RS Clients
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用 JAX-RS 客户端的说明
- en: If you are using a JAX-RS client to create outbound requests, you will need
    to pass the ClientBuilder you've created to `ClientTracingRegistrar` for the MicroProfile
    OpenTracing runtime to create a span for it. You can invoke either the `configure(ClientBuilder
    clientBuilder)` or `configure(ClientBuilder clientBduilder, ExecutorService executorService)`
    static methods, which will then return a `ClientBuilder` object that you can use.
    The implementation of the MicroProfile OpenTracing runtime may have been already
    configured so that any ClientBuilders used will create a span, thus not needing
    to invoke the `configure(…)` methods. Consult the documentation of your MicroProfile
    OpenTracing runtime for details.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用 JAX-RS 客户端创建出站请求，则需要将您创建的 `ClientBuilder` 传递给 `ClientTracingRegistrar`，以便
    MicroProfile OpenTracing 运行时为其创建一个跨度。您可以调用 `configure(ClientBuilder clientBuilder)`
    或 `configure(ClientBuilder clientBuilder, ExecutorService executorService)` 静态方法，这将返回一个
    `ClientBuilder` 对象，您可以使用它。MicroProfile OpenTracing 运行时的实现可能已经被配置，以便任何使用的 `ClientBuilder`
    都将创建一个跨度，因此不需要调用 `configure(…)` 方法。有关详细信息，请参阅您的 MicroProfile OpenTracing 运行时文档。
- en: Inbound JAX-RS requests
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传入的 JAX-RS 请求
- en: 'With inbound JAX-RS requests, the span that is created is given the name in
    the following format:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在传入的 JAX-RS 请求中，创建的跨度将使用以下格式的名称：
- en: '[PRE42]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This is referred to as the **class-method** naming format and is the default
    format. Alternatively, you can use the **http-path** naming format, which uses
    the following format:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为 **类-方法** 命名格式，是默认格式。或者，您可以使用 **http-path** 命名格式，它使用以下格式：
- en: '[PRE43]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: To enable the http-path format, use the MicroProfile Config configuration element
    known as `mp.opentracing.server.operation-name-provider` and specify `http-path`.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用 http-path 格式，请使用名为 `mp.opentracing.server.operation-name-provider` 的 MicroProfile
    Config 配置元素，并指定 `http-path`。
- en: Span tags
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跨度标签
- en: 'Spans that are created in both inbound and outbound requests use the following
    tags:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在传入和出站请求中创建的跨度使用以下标签：
- en: '`"Tags.SPAN_KIND_CLIENT"`. An inbound request has a value of `"Tags.SPAN_KIND_SERVER"`.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"Tags.SPAN_KIND_CLIENT"`。传入请求的值为 `"Tags.SPAN_KIND_SERVER"`。'
- en: '**Tags.HTTP_METHOD**: The value of this is the HTTP method that has been invoked.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Tags.HTTP_METHOD**：这个值是已调用的HTTP方法。'
- en: '**Tags.HTTP_URL**: This is the value of the HTTP URL that the request has been
    sent to.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Tags.HTTP_URL**：这是请求已发送到的HTTP URL的值。'
- en: '**Tags.HTTP_STATUS**: This is the status of the HTTP request. It specifies
    what response was received by the client or what response the server is returning.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Tags.HTTP_STATUS**：这是HTTP请求的状态。它指定了客户端收到的响应或服务器返回的响应。'
- en: '`jaxrs.`'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jaxrs.`'
- en: '`event=error` and `error.object=<error object instance>`.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event=error`和`error.object=<error object instance>`。'
- en: Instrumenting the @Traced annotation and injecting a tracer
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仪器化`@Traced`注解并注入跟踪器
- en: Provided with MicroProfile OpenTracing is the `@Traced` CDI annotation. This
    annotation can be applied to methods and classes. When applied to a class, every
    method in the class is annotated with `@Traced`. The `@Traced` annotation can
    be used to further fine-tune the spans that make up the trace. It can also be
    used to override the default auto-instrumentation of JAX-RS resource methods,
    such as disabling or renaming the span or to further specify spans on other methods
    in your application.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile OpenTracing提供了`@Traced` CDI注解。这个注解可以应用于方法和类。当应用于类时，类中的每个方法都被注解为`@Traced`。`@Traced`注解可以用来进一步微调构成跟踪的跨度。它也可以用来覆盖JAX-RS资源方法的默认自动仪器化，例如禁用或重命名跨度，或者进一步指定应用程序中其他方法的跨度。
- en: 'The `@Traced` annotation contains two parameters:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Traced`注解包含两个参数：'
- en: '**value**: This is a boolean parameter. It is true by default, which implies
    that the annotated method will be automatically instrumented for tracing. A false
    value disables automatic tracing for the method. This can be used to disable automatic
    instrumentation on JAX-RS endpoints.'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**value**：这是一个布尔参数。默认值为true，这意味着被注解的方法将被自动用于跟踪。false值将禁用方法的自动跟踪。这可以用来在JAX-RS端点上禁用自动仪器化。'
- en: '`String` and defines the name of the span that would be created when the method
    is invoked.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`并定义了当方法被调用时将创建的跨度的名称。'
- en: Note that when both a class and a method inside the class use the `@Traced`
    annotation, the method annotation and its parameters take priority.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当类及其内部的方法都使用了`@Traced`注解时，方法注解及其参数具有优先级。
- en: The MicroProfile OpenTracing runtime can also inject an optional `io.opentracing.Tracer`
    object. Using this OpenTracing object, you can programmatically create and manipulate
    spans using the OpenTracing API. You can add your own tags, logs, and baggage.
    We will not cover how to use the OpenTracing API in this book.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile OpenTracing运行时还可以注入一个可选的`io.opentracing.Tracer`对象。使用这个OpenTracing对象，你可以使用OpenTracing
    API编程创建和操作跨度。你可以添加自己的标签、日志和行李。我们不会在本书中介绍如何使用OpenTracing API。
- en: The following example shows how to inject the OpenTracing's `Tracer` object,
    as well as how to use `@Traced` on both a JAX-RS endpoint and a normal business
    method.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何注入OpenTracing的`Tracer`对象，以及如何在JAX-RS端点和普通业务方法上使用`@Traced`。
- en: 'The full source code for `TraceResource` can be found at [https://bit.ly/3AXmiIr](https://bit.ly/3AXmiIr):'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`TraceResource`的完整源代码可以在[https://bit.ly/3AXmiIr](https://bit.ly/3AXmiIr)找到：'
- en: '[PRE44]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the aforementioned example, `doNotTraceMe()` is annotated with `@Traced(value=false)`,
    which alerts the OpenTracing runtime to not trace this JAX-RS endpoint. `traceMe()`
    is a normal business method and is annotated with `@Traced(operationName="traceMe")`
    to alert the OpenTracing runtime to trace this as a span if the code path travels
    to this method. The span is called `"traceMe"`.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，`doNotTraceMe()`被注解为`@Traced(value=false)`，这会通知OpenTracing运行时不要跟踪这个JAX-RS端点。"traceMe()"是一个普通业务方法，并注解为`@Traced(operationName="traceMe")`，以通知OpenTracing运行时如果代码路径到达此方法，则将其跟踪为一个跨度。这个跨度被称为"traceMe"。
- en: Visualizing traces with Jaeger
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Jaeger可视化跟踪
- en: 'For this demonstration, we''ll use a simple application consisting of two JAX-RS
    resources called `OutboundRequestResource` and `InboundRequestResource`. We''ll
    issue a GET request to `OutboundRequestResource` at [http://localhost:9080/outbound/tracing](http://localhost:9080/outbound/tracing),
    which will then create a `ClientBuilder` to send a `GET` request to `InboundRequestResource`.
    This, in turn, will invoke the `epoch()` method in a `TracedExample` class that''s
    been annotated with `@Traced(operationName="epoch")`. The resulting trace visualization
    can be seen here:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在此演示中，我们将使用一个由两个名为`OutboundRequestResource`和`InboundRequestResource`的JAX-RS资源组成的简单应用程序。我们将向`OutboundRequestResource`的[http://localhost:9080/outbound/tracing](http://localhost:9080/outbound/tracing)发出GET请求，这将创建一个`ClientBuilder`来向`InboundRequestResource`发送`GET`请求。这将反过来调用一个带有`@Traced(operationName="epoch")`注解的`TracedExample`类中的`epoch()`方法。生成的跟踪可视化可以在此处看到：
- en: '![ Figure 6.4 – Trace inspection in Jaeger'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4 – 在Jaeger中的跟踪检查'
- en: '](img/B17377_06_04.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B17377_06_04.jpg)'
- en: Figure 6.4 – Trace inspection in Jaeger
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 在Jaeger中的跟踪检查
- en: Note
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the full source for `OutBoundTraceResource` at [https://bit.ly/3swFZEb](https://bit.ly/3swFZEb).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://bit.ly/3swFZEb](https://bit.ly/3swFZEb)找到`OutBoundTraceResource`的完整源代码。
- en: You can find the full source for `InBoundTraceResource` at [https://bit.ly/3xZxrXz](https://bit.ly/3xZxrXz).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://bit.ly/3xZxrXz](https://bit.ly/3xZxrXz)找到`InBoundTraceResource`的完整源代码。
- en: You can find the full source for `TracedExample` at [https://bit.ly/3y6pHmM](https://bit.ly/3y6pHmM).
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://bit.ly/3y6pHmM](https://bit.ly/3y6pHmM)找到`TracedExample`的完整源代码。
- en: 'This is a snapshot of what you may expect when inspecting a trace on the Jaeger
    web client. The preceding figure may be hard to discern, so we will describe it.
    The top left shows the name of the trace. The trace is named *book: GET:com.packt.microprofile.book.ch6.opentracing.OutBoundTraceResource.tracing*.
    The trace is given the name of the first span in this trace, which is the `GET`
    request that we issued to the `/tracing` endpoint in `OutBoundTraceResource`.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '这是在Jaeger网络客户端检查跟踪时您可能期望看到的快照。前面的图可能难以辨认，因此我们将对其进行描述。左上角显示了跟踪的名称。跟踪被命名为*book:
    GET:com.packt.microprofile.book.ch6.opentracing.OutBoundTraceResource.tracing*。跟踪被赋予了此跟踪中第一个span的名称，即我们向`OutBoundTraceResource`中的`/tracing`端点发出的`GET`请求。'
- en: The rest of the interface consists of the sequential listing of the spans that
    make up the trace. When minimized, it will display the duration of each span and
    their active durations compared to the other spans as solid horizontal bars. When
    you click on a span entry, it will expand to show more details, such as its contextual
    data. In the aforementioned figure, the span that was created from the inbound
    JAX-RS request from `InBoundTraceResource`, as well as the span that was instrumented
    from the `@Traced` annotation on the `epoch()` method, have been expanded.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 接口的其他部分由构成跟踪的span的顺序列表组成。当最小化时，它将显示每个span的持续时间以及与其他span相比的活跃持续时间，以实心水平条的形式显示。当您点击一个span条目时，它将展开以显示更多详细信息，例如其上下文数据。在上文提到的图中，从`InBoundTraceResource`的入站JAX-RS请求创建的span，以及从`epoch()`方法的`@Traced`注解中仪器化的span已被展开。
- en: Let's describe the first expanded span, which is the span that was created by
    the inbound request. It is called *GET:com.packt.microprofile.book.ch6.opentracing.InBoundTraceResource.waiting*.
    Included in the details are its tags, which we discussed earlier in this section;
    that is, *component*, *http.method*, *http.status_code*, *http.url*, and *span.kind*.
    A tag that's appended by Jaeger is in *internal.span.format*. The instrumented
    span does not contain any tags other than the ones provided by Jaeger.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述第一个展开的span，即由入站请求创建的span。它被称为*GET:com.packt.microprofile.book.ch6.opentracing.InBoundTraceResource.waiting*。在详细信息中包括我们在此部分前面讨论过的标签；即，*component*、*http.method*、*http.status_code*、*http.url*和*span.kind*。Jaeger附加的标签在*internal.span.format*中。仪器化的span不包含除Jaeger提供的标签之外的其他标签。
- en: With the combination of a summary view of a trace and having the ability to
    view the individual spans that make up the trace, using distributed tracing to
    profile the paths that a request takes is very useful for analyzing performance
    and latency. In the aforementioned example, we demonstrated distributed tracing
    with the Jaeger platform. Another distributed tracing platform that provides an
    instrumentation library and the facilities to view and analyze the traces is **Zipkin**.
    Zipkin isn't included on the list of official tracers in the OpenTracing documentation,
    but you may find that the MicroProfile OpenTracing runtime you chose supports
    it. Consult the documentation of your runtime for their list of supported libraries
    and the necessary steps for configuring it.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 结合对追踪的摘要视图和查看构成追踪的各个跨度（span）的能力，使用分布式追踪来剖析请求所采取的路径对于分析性能和延迟非常有用。在前面提到的示例中，我们展示了使用Jaeger平台进行分布式追踪。另一个提供仪表化库以及查看和分析追踪功能的分布式追踪平台是**Zipkin**。Zipkin并未包含在OpenTracing文档中官方追踪器的列表中，但您可能会发现您选择的MicroProfile
    OpenTracing运行时支持它。请查阅您运行时的文档，了解其支持的库列表以及配置它的必要步骤。
- en: Summary
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the three observability technologies offered by
    the MicroProfile platform; that is, MicroProfile Health, MicroProfile Metrics,
    and MicroProfile OpenTracing. From reporting the overall health of your application
    with health checks to the detailed statistical data that metrics provide, to tracking
    and profiling requests as they travel through your microservices with distributed
    tracing, each technology has an invaluable purpose that satisfies the important
    task of monitoring and observing your cloud-native application. Your application
    has now harnessed all the features and capabilities that the MicroProfile release
    platform has to offer. There are additional technologies that come with MicroProfile's
    standalone releases. We will cover these in the final chapters of this book.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了MicroProfile平台提供的三种可观测性技术；即MicroProfile Health、MicroProfile Metrics和MicroProfile
    OpenTracing。从通过健康检查报告应用程序的整体健康状况，到提供详细统计数据的指标，再到通过分布式追踪跟踪和剖析请求在微服务中的传输路径，每种技术都有其不可估量的用途，满足了监控和观察云原生应用程序的重要任务。现在，您的应用程序已经充分利用了MicroProfile发布平台所能提供的所有功能和能力。MicroProfile的独立发布还包含其他技术。我们将在本书的最后一章中介绍这些技术。
- en: In the next chapter, we will explore the topic of deploying your cloud-native
    application onto the cloud. We'll see how it interacts with cloud infrastructures
    such as Docker, Kubernetes, and Istio.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨将您的云原生应用程序部署到云上的主题。我们将看到它如何与Docker、Kubernetes和Istio等云基础设施交互。
