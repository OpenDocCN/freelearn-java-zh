- en: Understanding Linking and Using jlink
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解链接和使用 jlink
- en: In the previous chapters, we've learned about some advanced concepts relating
    to Java modularity, including handling readability and accessibility of module
    relationships, and the powerful concept of services. In this chapter, we'll move
    on to the final step in any application development--building and packaging your
    application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了与 Java 模块化相关的一些高级概念，包括处理模块关系的可读性和可访问性，以及强大的服务概念。在本章中，我们将继续进行任何应用程序开发的最后一步——构建和打包你的应用程序。
- en: 'Here''s what you''ll learn in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章你将学习以下内容：
- en: You'll learn about the module resolution process, an important process that
    happens every time you compile or execute a modular Java application.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将了解模块解析过程，这是一个在每次编译或执行模块化 Java 应用程序时都会发生的重要过程。
- en: You'll be introduced to a new phase in the development process--linking. Linking,
    or static linking, is a new step in Java 9 modular development. It sits between
    the familiar compilation and execution phases that you should already be familiar
    with. In this chapter, you'll understand what linking is and the benefits of this
    step.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将了解开发过程中的一个新阶段——链接。链接，或静态链接，是 Java 9 模块化开发中的一个新步骤。它位于你应已熟悉的熟悉的编译和执行阶段之间。在本章中，你将了解链接是什么以及这一步骤的好处。
- en: You'll learn how to use `jlink`, the new tool built into the platform to facilitate
    the linking phase and help build runtime images.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将学习如何使用 `jlink`，这是一个内置到平台中的新工具，用于简化链接阶段并帮助构建运行时镜像。
- en: You'll learn about some `jlink` plugins that optimize runtime images that are
    created by `jlink`.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将了解一些 `jlink` 插件，这些插件可以优化由 `jlink` 创建的运行时镜像。
- en: You'll learn how to build a modular JAR file, which is an alternative way to
    distribute your compiled library modules for use in other applications.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将学习如何构建一个模块化的 JAR 文件，这是分发编译库模块以供其他应用程序使用的一种替代方式。
- en: Module resolution process
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块解析过程
- en: Before we get into the details of the linking process and what it can do for
    us, let's understand an important step that happens every time you compile and
    execute a modular Java application. This is a step called **module resolution**.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解链接过程的细节以及它能为我们做什么之前，让我们了解一个重要的步骤，这个步骤在每次编译和执行模块化 Java 应用程序时都会发生。这是一个称为**模块解析**的步骤。
- en: Traditionally (pre-Java 9), the Java compiler and Java runtime would to look
    at a set of folders and JAR files that form the **classpath**. The classpath is
    a configurable option that you pass to the compiler during compilation and to
    the runtimes during execution. In order to have any class file be under the purview
    of the compiler or runtime, you'd need to first place it in the classpath. Once
    it's there, every Java type is *available* for the compiler or the runtime.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上（Java 9 之前），Java 编译器和 Java 运行时会查看一组文件夹和 JAR 文件，这些文件夹和 JAR 文件构成了**类路径**。类路径是一个可配置的选项，你在编译期间将其传递给编译器，在执行期间传递给运行时。为了使任何类文件都处于编译器或运行时的管辖之下，你首先需要将其放置在类路径中。一旦它在那里，每个
    Java 类型都对编译器或运行时*可用*。
- en: Things are different with modules. We don't have to use the generic classpath
    anymore. Since every module defines its *inputs* and *outputs*, there's now an
    option to know exactly what portion of the code is needed at any time.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与模块不同。我们不再需要使用通用的类路径。由于每个模块都定义了其*输入*和*输出*，现在有一个选项可以确切地知道在任何时候需要代码的哪个部分。
- en: 'Consider the following module dependency graph:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下模块依赖图：
- en: '![](img/00074.jpeg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00074.jpeg)'
- en: 'Let''s assume that you have the modules **A**, **B**, **C**, **D**, and **E**
    in the module path. Let''s imagine that you are playing the role of the Java runtime,
    and you want to execute the `main` method in module **C**. What is the minimal
    set of modules that are *required* for this to happen? You''ll obviously need
    module **C**, since that has the `main` method. Next you''ll need its dependencies,
    modules **B** and **D**. Next you''ll need those modules'' dependencies as well,
    which in this case is module **A**, which **B** depends on:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在模块路径中有模块 **A**、**B**、**C**、**D** 和 **E**。让我们想象你正在扮演 Java 运行时的角色，并想要执行模块
    **C** 中的 `main` 方法。为了实现这一点，需要哪些最小集合的模块？显然你需要模块 **C**，因为那里有 `main` 方法。接下来你需要它的依赖项，模块
    **B** 和 **D**。然后你还需要这些模块的依赖项，在这个例子中是模块 **A**，它是 **B** 依赖的：
- en: '![](img/00075.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00075.jpeg)'
- en: Using this process, it's safe to say that the minimum set of modules required
    to execute a `main` type in module **C** is **A**, **B**, **C**, and **D**--module
    **E** is unnecessary.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个流程，我们可以肯定地说，执行模块 **C** 中的 `main` 类型所需的最小模块集是 **A**、**B**、**C** 和 **D**——模块
    **E** 是不必要的。
- en: 'Let''s repeat the exercise, but this time to execute a type in module **E**.
    This time, we''ll just need modules **E** and **D**; all other modules can be
    skipped:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重复这个练习，但这次是在模块 **E** 中执行类型。这次，我们只需要模块 **E** 和 **D**；所有其他模块都可以跳过：
- en: '![](img/00076.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00076.jpeg)'
- en: Now why are we doing this? What's the advantage of finding this *minimal set
    of modules?* Contrast this with the older classpath model where every type in
    the classpath is a part of the application, and any type could be *in use*. There's
    no way for the compiler and runtime to figure out where a given type exists unless
    it scans the entire classpath. That's not the case anymore! Since both the compiler
    and runtime now have a precise idea about what part of the code base is *needed*
    to execute anything and what part is not, it puts this advantage to good use,
    as we'll soon see. But in order to get this information, the platform runs a process
    of resolving modules, which is, in principle, similar to what we did in the preceding
    example. This process is called the module resolution process.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为什么要这样做？找到这个 *最小模块集* 的优势是什么？与较旧的classpath模型进行对比，其中classpath中的每个类型都是应用程序的一部分，任何类型都可能被
    *使用*。编译器和运行时无法确定给定类型的位置，除非它扫描整个classpath。现在不再是这种情况了！由于编译器和运行时现在都对代码库的哪些部分是 *需要*
    执行任何内容的以及哪些部分不是有了一个精确的了解，这使得这个优势得到了很好的利用，正如我们很快就会看到的。但是，为了获取这些信息，平台运行了一个解析模块的过程，这个过程在原则上与我们在前面的例子中所做的是相似的。这个过程被称为模块解析过程。
- en: In graph theory, this process is referred to as finding *transitive closure*.
    Given a graph, the idea is to find a set of nodes that are *reachable* from a
    given node. The graph on which we perform transitive closure should be what's
    called a **directed acyclic graph** (**DAG**). The graph should be **directed**,
    in that the relationships between nodes are directional (with arrows), and **acyclic**,
    in that there shouldn't be cyclical relationships. Does the DAG remind you of
    any graphs you've seen recently? Yes! The Java module graph is a great example
    of a directed acyclic graph!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在图论中，这个过程被称为寻找 *传递闭包*。给定一个图，我们的想法是找到一个从给定节点可以 *到达* 的节点集。我们执行传递闭包的图应该是所谓的 **有向无环图**（**DAG**）。图应该是
    **有向的**，即节点之间的关系是方向性的（带有箭头），并且 **无环的**，即不应该有循环关系。这个DAG让你想起了你最近看到的任何图吗？是的！Java模块图是一个有向无环图的绝佳例子！
- en: Module resolution steps
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块解析步骤
- en: 'Here are the high-level steps that the platform runs through when it resolves
    modules:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是平台在解析模块时运行的高级步骤：
- en: Add the root module to the resolved set of modules. Remember that when you execute
    your code, you specify the type containing the main method and the module it belongs
    to. This module is the root module and forms the starting point for the module
    resolution process. Note that this starting point doesn't have to be just one
    module--there could be several modules, as we'll see shortly.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将根模块添加到已解析的模块集合中。记住，当你执行代码时，你需要指定包含主方法及其所属的模块的类型。这个模块是根模块，它是模块解析过程的起点。请注意，这个起点不一定是单个模块——可能会有多个模块，正如我们很快就会看到的。
- en: Identify all the `requires` dependencies of the module(s) added. Here, each
    module's descriptor file is looked up to identify all the modules that it *reads*.
    This includes both `requires` and `requires transitive`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别已添加模块的所有 `requires` 依赖项。在这里，每个模块的描述符文件被查找以识别它所 *读取* 的所有模块。这包括 `requires` 和
    `requires transitive`。
- en: From the list from step 2, remove all modules that are already in the resolved
    set of modules.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从步骤 2 的列表中删除所有已在已解析的模块集合中的模块。
- en: Add the remaining modules to the resolved set of modules. Repeat step 2 for
    this list.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将剩余的模块添加到已解析的模块集合中。对此列表重复步骤 2。
- en: 'As you can imagine, this is a recursive graph operation that starts with one
    or more modules and ends up with the minimal set of modules that are needed as
    dependencies. Since the platform does this during every compilation and runtime
    phase, it uses this opportunity to check for several different kinds of errors.
    In fact, many of the module errors we''ve encountered so far happen because of
    checks during and around the module resolution process. Here are a few of them:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想象的那样，这是一个递归图操作，从一个或多个模块开始，最终得到所需作为依赖的最小模块集。由于平台在每次编译和运行时阶段都会执行此操作，因此它利用这个机会来检查多种不同类型的错误。事实上，我们迄今为止遇到的许多模块错误都是由于模块解析过程期间和周围的检查引起的。以下是一些例子：
- en: '**Unavailable dependent modules**: This one is obvious. While looking up dependencies,
    if a module isn''t found among the observable modules, the process errors out.
    This, as we''ve seen, is the key to reliable configuration.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可用的依赖模块**：这一点很明显。在查找依赖项时，如果某个模块在可观察模块中找不到，则进程会出错。正如我们所见，这是可靠配置的关键。'
- en: '**Multiple modules**: Not only do all dependent modules have to be available,
    there needs to be only one of each. If there happen to be two modules in the module
    path that have the same name (even if they have entirely different contents),
    the platform catches this right away and throws an error.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多个模块**：不仅所有依赖模块都必须可用，而且每个模块只能有一个。如果模块路径中恰好有两个具有相同名称的模块（即使它们的内容完全不同），平台会立即捕捉到这一点并抛出一个错误。'
- en: '**Cyclic dependencies**: If two or more modules depend on each other and form
    a closed loop cycle in the module graph, the platform throws an error, as we''ve
    already seen.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**循环依赖**：如果有两个或更多模块相互依赖，并在模块图中形成一个闭环循环，平台会抛出一个错误，正如我们之前所看到的。'
- en: '**Split packages**: The platform assumes that each package is available in
    just one module. The class loaders maintain a map of each package to the module
    it is found in. Thus, if there are multiple modules that contain the same package,
    the process terminates with an error.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分割包**：平台假设每个包只在一个模块中可用。类加载器维护一个映射，将每个包映射到它所在的模块。因此，如果有多个模块包含相同的包，则进程会因错误而终止。'
- en: Examining module resolution in action
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查模块解析的实际操作
- en: There's a new command option added to Java that prints out debug information
    that describes the module resolution process. You can activate it by passing the
    option `--show-module-resolution`. When passed this option, the `java` command
    prints out console messages for each step of the module resolution. You can use
    this to see the process that the runtime goes through to resolve all the modules,
    much like we did in the preceding exercise.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Java 新增了一个命令选项，用于打印描述模块解析过程的调试信息。您可以通过传递选项 `--show-module-resolution` 来激活它。当传递此选项时，`java`
    命令会为模块解析的每个步骤打印控制台消息。您可以使用此功能查看运行时解析所有模块的过程，就像我们在前面的练习中所做的那样。
- en: 'This is how you ran the command-line address book module in the previous chapter,
    without the flag:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您在上一章中运行命令行地址簿模块的方式，但没有使用标志：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here''s how you run it with the module resolution diagnostics enabled:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您启用模块解析诊断时运行它的方法：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The verbose output gives a clear indication of what''s happening here. Things
    start off with the root module `packt.addressbook`, as expected:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 详细输出清楚地表明了这里发生的事情。一切从预期的根模块 `packt.addressbook` 开始：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, it finds the dependent modules from the module descriptor. For every
    module it finds, the output lists the name of the module, where it found it (the
    path), and why (which module required it):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，它从模块描述符中找到依赖模块。对于它找到的每个模块，输出会列出模块的名称、找到它的位置（路径）以及原因（哪个模块需要它）：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It also figures out the service providers based on the modules that declared
    themselves as consumers:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 它还根据声明自己为消费者的模块来确定服务提供者：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The runtime continues to look for subsequent dependencies as it traverses the
    nodes of the module graph. After it''s done adding all the necessary modules to
    the resolved set, it then executes the main method and the expected program output
    is printed on the console:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时继续在遍历模块图节点时查找后续依赖项。在将所有必要的模块添加到解析集合后，它然后执行主方法，并在控制台上打印出预期的程序输出：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that you've understood the process of module resolution and how it benefits
    the process of compile-time and runtime enforcement of reliable configuration,
    let's now look at another problem that it can solve. We briefly introduced the
    problem of the monolithic JDK in [Chapter 1](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb),
    *Introducing Java 9 Modularity*. We'll quickly recap the problem and then learn
    how that it is no longer a problem with Java 9.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了模块解析的过程以及它如何有助于编译时和运行时可靠配置的执行，现在让我们看看它还能解决的其他问题。我们在[第1章](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb)，“介绍Java
    9模块化”中简要介绍了单体JDK的问题。我们将快速回顾这个问题，然后了解为什么在Java 9中它不再是问题。
- en: Revisiting the state of the JDK
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾JDK的状态
- en: 'In [Chapter 1](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb), *Introducing
    Java 9 Modularity*, we examined the large size of the JDK, both in terms of the
    file size of `rt.jar` as well as the number of classes that are bundled in it.
    Typically, you wouldn''t think about the JDK when developing Java applications.
    Once you''ve installed the JDK on your development machine, it sits in a remote
    corner of your hard disk at `$JAVA_HOME` and it doesn''t bother you. There are,
    however, a few instances where you would need to worry about the size of the JDK,
    especially when bundling an application executable. Here are a couple of such
    occasions:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb)，“介绍Java 9模块化”中，我们探讨了JDK的庞大体积，无论是从`rt.jar`的文件大小还是包含其中的类数量来看。通常，在开发Java应用程序时，你不会考虑JDK。一旦你在开发机器上安装了JDK，它就会坐在你的硬盘的远程角落的`$JAVA_HOME`中，不会打扰你。然而，确实有一些情况下你需要担心JDK的大小，尤其是在捆绑应用程序可执行文件时。以下是一些这样的情况：
- en: '**Runtime bundles for embedded devices**: Java has been known to run on portable
    and embedded devices, such as compact music players, microwaves, and washing machines.
    Many of these are devices with scarce hardware capacities for memory and processing
    power, and for Java to run on those devices, the runtime should obviously be a
    part of the installed application. The size of the Java SE runtime is so prohibitive
    that there is a separate platform (Java ME) for such scenarios.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嵌入式设备的运行时捆绑包**：众所周知，Java可以在便携式和嵌入式设备上运行，例如紧凑型音乐播放器、微波炉和洗衣机。许多这些设备在内存和处理能力方面硬件资源有限，为了在这些设备上运行Java，运行时显然应该是安装应用程序的一部分。Java
    SE运行时的体积如此之大，以至于有一个专门的平台（Java ME）用于此类场景。'
- en: '**Runtime images for microservices**: A common trend in recent years is to
    deploy lightweight microservices in the cloud. Instead of having one centralized
    web application that does everything, the application is split into separate smaller
    services that run on different machine instances and communicate with each other
    over the network. The runtime image for each instance is a self-sufficient set
    of binaries that include the application classes and the Java runtime. These microservices
    are ideally stateless, scalable, and disposable, so they''d ideally need to be
    lightweight and performant. Bundling a 75 MB runtime that needs to be a part of
    every instance doesn''t really help.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务的运行时镜像**：近年来，在云中部署轻量级微服务已成为一种常见趋势。不再有一个集中式的、能够完成所有功能的Web应用程序，而是将应用程序拆分为运行在不同机器实例上的独立较小服务，并通过网络相互通信。每个实例的运行时镜像是一组自给自足的二进制文件，包括应用程序类和Java运行时。这些微服务理想状态下是无状态的、可扩展的、可丢弃的，因此它们理想上需要轻量级和高效。捆绑一个75MB的运行时文件，并使其成为每个实例的一部分，实际上并没有真正帮助。'
- en: Think for a minute about why this problem even exists. Well, it's because of
    the classpath model of previous versions of Java. Any piece of code can potentially
    refer to any other Java type in the classpath, and there's no saying what's required
    and what's not, so we had no choice but to add the whole platform.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 想想为什么这个问题甚至存在。嗯，这是因为Java先前版本中的类路径模型。任何代码都可能潜在地引用类路径中的任何其他Java类型，而且无法确定需要什么和不需什么，所以我们别无选择，只能添加整个平台。
- en: This is no longer the case with modular programming! We've seen that with module
    resolution, given a starting point, we can precisely identify which modules are
    required for its execution. This applies equally to both application and platform
    modules, since they both follow the same contract. Thanks to this, we can now
    apply the module resolution process and come up with a unique bare minimum set
    of platform *and* application modules that you'd need to run any application.
    Thus, when distributing an application with runtime, for example, you don't have
    to include the entire platform. Instead, you just include the platform modules
    that are necessary, and we do just that by introducing a whole new step in Java
    application development that we didn't have before--linking.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块化编程中，这种情况不再存在！我们已经看到，在模块解析中，给定一个起点，我们可以精确地识别出执行它所需的模块。这同样适用于应用程序模块和平台模块，因为它们都遵循相同的契约。正因为如此，我们现在可以应用模块解析过程，并得出一个独特的最小平台模块集和应用程序模块集，这是您运行任何应用程序所需的。因此，当分发带有运行时的应用程序时，例如，您不必包含整个平台。相反，您只需包含必要的平台模块，而我们正是通过引入一个全新的步骤来实现这一点，这是我们在之前的
    Java 应用程序开发中所没有的--链接。
- en: Linking using jlink
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 jlink 进行链接
- en: 'JDK 9 comes bundled with a new tool called `jlink` that lets you build your
    own complete runtime image that contains everything necessary to execute a given
    application. Remember the new structure of the JDK that we looked at in [Chapter
    4](part0058.html#1NA0K0-ed2405f4162b4f86b565edd6b6d679fb), *Introducing the Modular
    JDK*:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 9 随带了一个名为 `jlink` 的新工具，它允许您构建自己的完整运行时镜像，该镜像包含执行给定应用程序所需的一切。记住我们在[第4章](part0058.html#1NA0K0-ed2405f4162b4f86b565edd6b6d679fb)中讨论的
    JDK 的新结构，*介绍模块化 JDK*：
- en: '![](img/00077.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00077.jpeg)'
- en: 'With `jlink`, you can create a similar custom image of your own to distribute
    your application. The generated image contains:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `jlink`，您可以创建一个类似的自定义镜像来分发您的应用程序。生成的镜像包含：
- en: The minimal set of your application and library modules that you've authored
    or added
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您所编写的或添加的您的应用程序和库模块的最小集
- en: The minimal set of platform modules needed for your application to work
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为使您的应用程序正常运行所需的最小平台模块集
- en: This effectively solves the problem of the huge overhead incurred to ship the
    platform along with your application. What you ship is just what the application
    needs--no more, no less. There are further benefits to this process, but before
    we get into that, let's learn how to use `jlink` to create this image.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上解决了在运输平台的同时产生的巨大开销问题。您所运输的只是应用程序所需的，不多也不少。这个过程还有其他好处，但在我们深入探讨之前，让我们学习如何使用
    `jlink` 创建此镜像。
- en: The jlink command
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jlink 命令
- en: 'The `jlink` command needs the following inputs:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`jlink` 命令需要以下输入：'
- en: '**The module path**: This is where it needs to look for modules. This is the
    directory (or directories) where the compiled modules are available.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块路径**：这是它需要查找模块的地方。这是编译好的模块可用的目录（或目录）。'
- en: '**The starting module**: This is the module from which to begin the module
    resolution process. This could be one or many, separated by delimiters.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**起始模块**：这是模块解析过程开始的地方。这可能是一个或多个，由分隔符分隔。'
- en: '**The output directory**: This is the location where it stores the generated
    image.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出目录**：这是它存储生成的镜像的位置。'
- en: 'The usage looks something like this, with the command broken into separate
    lines for readability:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方式大致如下，命令被分成单独的行以提高可读性：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To run this command on our sample codebase and generate an image for the address
    book UI module, we first need to compile the modules in the same way that we usually
    do:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的示例代码库上运行此命令并生成地址簿 UI 模块的镜像，我们首先需要以通常的方式编译模块：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, `out` is the location of the compiled modules, and thus, that is the module
    path for `jlink`. The module that serves as the starting point is `packt.addressbook.ui`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`out` 是编译好的模块的位置，因此，这是 `jlink` 的模块路径。作为起点的模块是 `packt.addressbook.ui`。
- en: 'In the same directory that we ran the `javac` command, we can now run `jlink`.
    To run the command, either make sure the  `$JAVA_HOME/bin` directory is in your
    operating system''s  path, or use the path to access `jlink` directly:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行 `javac` 命令的同一目录中，我们现在可以运行 `jlink`。要运行该命令，请确保 `$JAVA_HOME/bin` 目录已添加到您的操作系统的路径中，或者直接使用路径访问
    `jlink`：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note that we get an error:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们会遇到错误：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We are missing the platform modules! Note that `java.base` is a core platform
    module and is not available in the module path we've specified in the preceding
    command. Platform modules don't get special treatment; their module location needs
    to be explicitly specified to the `jlink` command!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们缺少平台模块！请注意，`java.base`是一个核心平台模块，并且在我们之前命令中指定的模块路径中不可用。平台模块不会得到特殊处理；它们的模块位置需要显式地指定给`jlink`命令！
- en: 'We''ve already seen that the core Java modules are available in `$JAVA_HOME/jmods`.
    Let''s add that to the `--module-path` parameter. As before, in order to specify
    multiple paths there, we need to separate the paths with the `:` symbol (`;` on
    Windows operating systems):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到核心Java模块在`$JAVA_HOME/jmods`中可用。让我们将其添加到`--module-path`参数中。和之前一样，为了指定多个路径，我们需要用冒号符号（在Windows操作系统中是分号）分隔路径：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`jlink` will now get to work and quietly generate the runtime image for us.
    Let''s look at the structure of the image generated:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`jlink`现在将开始工作，并为我们静默地生成运行时映像。让我们看看生成的映像结构：'
- en: '![](img/00078.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00078.jpeg)'
- en: This should look familiar now. The structure is very similar to the JDK file
    structure we've already seen. One notable exception is that the `jmods` folder
    isn't here. This makes sense because this is a *runtime* image, and the `jmods`
    format is not designed to be used for runtime. Since this image contains only
    the modules necessary, they are all bundled into a common `modules` file in the
    `lib` folder.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这现在看起来应该很熟悉了。结构与我们之前看到的JDK文件结构非常相似。一个值得注意的例外是`jmods`文件夹不在这里。这是有道理的，因为这是一个*运行时*映像，而`jmods`格式并不是为运行时设计的。由于这个映像只包含必要的模块，它们都被打包到了`lib`文件夹中的公共`modules`文件中。
- en: Now that the image contains the runtime and the compiled application modules,
    it is a self-sufficient bundle. You can deploy this image on a computer that does
    not have the Java runtime installed and execute it without any problems.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在映像包含了运行时和编译的应用程序模块，它是一个自给自足的包。你可以在没有安装Java运行时的计算机上部署这个映像，并且可以无任何问题地执行它。
- en: 'Now, to execute our module from the runtime image, we need to execute the `java`
    executable that''s available in the `bin` directory of the image, not the one
    in `$PATH`. You also don''t have to specify the `--module-path` this time because
    the module resolution is already done! The generated image is already bundled
    with every module it needs, and thus already knows where to find them:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了从运行时映像中执行我们的模块，我们需要执行映像`bin`目录中的`java`可执行文件，而不是`$PATH`中的那个。这次你也不必指定`--module-path`，因为模块解析已经完成了！生成的映像已经包含了它需要的每一个模块，因此已经知道它们的位置在哪里：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should see the address book UI application pop up. That''s great, but you
    can probably tell something isn''t right:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到地址簿UI应用程序弹出。那很好，但你可能已经察觉到有些不对劲：
- en: '![](img/00079.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00079.jpeg)'
- en: 'The names aren''t sorted. Can you guess why? It''s because the sorting modules
    haven''t been bundled in! If you run the `java --list-modules` on the `java` executable
    in the image, you can see all the modules that have been bundled in. Note that
    the sorting service modules aren''t included:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 名称没有排序。你能猜到为什么吗？是因为排序模块还没有被打包进去！如果你在映像中的`java`可执行文件上运行`java --list-modules`，你可以看到所有被打包进来的模块。请注意，排序服务模块不包括在内：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Remember that the module resolution process traverses the module graph and adds
    modules that have a **direct dependency** using the `requires` clause. Services,
    by definition, are loosely coupled and so are not required by any module. Because
    of this reason, both the service modules--`packt.sort.bubblesort` and `packt.sort.javasort`--haven't
    been included. This behavior of `jlink` is intentional. The bundling of service
    modules needs to be explicitly stated to the command.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，模块解析过程遍历模块图，并使用`requires`子句添加具有**直接依赖**的模块。服务，按照定义，是松散耦合的，因此不需要任何模块。正因为这个原因，服务模块--`packt.sort.bubblesort`和`packt.sort.javasort`--都没有被包括在内。`jlink`的这种行为是有意为之的。服务模块的打包需要显式地告诉命令。
- en: Note that the `java --list-modules` command displays the observable modules
    that are available in the runtime image on which the command is run. All along,
    we've run the command on the installed JDK, so it listed all (and only) the platform
    modules. This time, we have run the command on the generated runtime image, which
    is a combination of our application modules and a select few platform modules.
    Thus, the output of the command reflects that accordingly.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`java --list-modules` 命令显示的是在运行时图像上可观察到的模块，该命令是在运行时执行的。一直以来，我们都是在已安装的 JDK
    上运行此命令，因此它列出了所有（且仅有的）平台模块。这次，我们是在生成的运行时图像上运行此命令，该图像是我们应用程序模块和少数几个平台模块的组合。因此，命令的输出相应地反映了这一点。
- en: 'There are a couple of ways we can fix our problem. The first way is to add
    the service modules to the list of **starting-point modules** for module resolution
    using the `--add-modules` option. Multiple module names can be specified for this
    option, with the names separated by commas. These modules and their dependencies
    will then also get bundled into the image, since the module resolution process
    will run starting from each of those modules, too, and add them to the resolved
    set:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采取几种方法来解决问题。第一种方法是通过使用 `--add-modules` 选项将服务模块添加到模块解析的起始模块列表中。可以为此选项指定多个模块名称，名称之间用逗号分隔。然后，这些模块及其依赖项也将被捆绑到图像中，因为模块解析过程将从每个这些模块开始运行，并将它们添加到解析集中：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, running `java --list-modules` in the generated image should show the sorting
    modules. Also, when executing the application, the UI should now show the list
    of contacts sorted by last name:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在生成的图像中运行 `java --list-modules` 应该会显示排序后的模块。此外，当执行应用程序时，UI 应该现在会显示按姓氏排序的联系人列表：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Another alternative to bundling in services is to use the `--bind-services`
    option of `jlink`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务捆绑的另一种选择是使用 `jlink` 的 `--bind-services` 选项：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This parameter automatically identifies any services consumed by modules when
    it checks each module through the module resolution process. Then, all observable
    modules that declare that they are providers for those services will be automatically
    bundled in. This is an easier option because you don't have to explicitly mention
    service modules yourself, but there's a chance that you might pull in more modules
    than you really require. Let's say there's some random module in the module path
    that your application doesn't use, but it just happens to implement one of the
    service types you've used. Well, that module gets pulled in with this option!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此参数在通过模块解析过程检查每个模块时自动识别模块所消耗的任何服务。然后，所有声明自己是这些服务提供者的可观察模块将被自动捆绑。这是一个更简单的选项，因为你不必自己明确提及服务模块，但有可能你会拉入比实际需要的更多模块。假设模块路径中有一个随机模块，你的应用程序没有使用它，但它恰好实现了你使用的一种服务类型。那么，这个模块就会通过这个选项被拉入！
- en: Link phase optimizations and jlink plugins
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接阶段优化和 jlink 插件
- en: There have always been two steps to get Java code to execute--the compile step
    (using `javac`) and the execution step (using `java`). During the compilation
    step, `javac` doesn't just try to convert Java code into byte code, it also tries
    to perform any optimizations it can and generate the most optimal and efficient
    byte code possible. Over the years, the Java compiler has learned several new
    tricks and strategies to better optimize the resulting byte code. But there has
    always been a challenge--the compiler works on a handful of classes at a time
    and it doesn't have the opportunity to see the big picture by looking at the entire
    application, which could have helped it implement better optimizations. That option
    is available for runtime, but some of the optimizations end up being too expensive
    when done at runtime. With the introduction of the new linking step in between
    the compile and execution phases, an opportunity opens up to do application-level
    optimization for our Java byte code. In fact, one of the goals of the platform
    team for the linking phase is to do **whole-world** optimizations--optimizations
    that span multiple classes and modules across the application, having been given
    the **bigger picture**.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 将Java代码执行分为两个步骤——编译步骤（使用`javac`）和执行步骤（使用`java`）。在编译步骤中，`javac`不仅仅尝试将Java代码转换为字节码，还尝试执行任何可能的优化，并生成尽可能最优和高效的字节码。多年来，Java编译器已经学会了几个新的技巧和策略来更好地优化生成的字节码。但一直存在一个挑战——编译器一次只处理几个类，它没有机会通过查看整个应用程序来了解全局情况，这可能会帮助它实现更好的优化。这个选项在运行时是可用的，但一些优化在运行时执行起来成本过高。随着在编译和执行阶段之间引入新的链接步骤，为我们的Java字节码进行应用程序级优化的机会就出现了。事实上，平台团队在链接阶段的一个目标就是进行**全局**优化——跨越应用程序中多个类和模块的优化，因为它们已经获得了**更大的视角**。
- en: Remember that the linking step is optional, of course. We've executed our application
    in the previous chapters without having to use `jlink`, and thereby without doing
    any such optimizations. However, if you were to use `jlink`, there's an opportunity
    to do optimizations--things such as compressing the image, identifying and removing
    unreachable code and types, pre-optimizing code, and methods where the possible
    inputs are constant and known ahead of time. These optimizations can happen when
    running `jlink` and are done using a series of `transformers`, which are built
    as plugins.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，链接步骤是可选的。在前面的章节中，我们已经执行了应用程序，而不需要使用`jlink`，因此没有进行任何此类优化。然而，如果您使用`jlink`，就有机会进行优化——例如压缩图像、识别并删除不可达的代码和类型、预优化代码和方法，其中可能的输入是常数且在事先已知。这些优化可以在运行`jlink`时进行，并且使用一系列`transformers`来完成，这些`transformers`作为插件构建。
- en: 'Here''s an approximation of how `jlink` works to create the runtime image:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`jlink`如何工作以创建运行时图像的近似描述：
- en: '![](img/00080.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00080.jpeg)'
- en: The process starts with gathering all the necessary resources and running them
    through a series of transformers that can do various tasks and optimizations.
    The `jlink` tool has a plugin API so that anyone can create custom plugins that
    hook into this process and have the opportunity to transform the resulting image.
    After the transformers are done, the image is written to the output directory,
    where, again, plugins can be written to control what happens.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程从收集所有必要的资源开始，并通过一系列可以执行各种任务和优化的`transformers`运行它们。`jlink`工具有一个插件API，这样任何人都可以创建自定义插件，将其钩入此过程，并有机会转换生成的图像。在`transformers`完成后，图像被写入输出目录，在那里，同样可以编写插件来控制发生的事情。
- en: 'The Java 9 platform comes with built-in plugins that do several of these optimizations.
    In fact, some of these optimizations are so important and have such a significant
    impact that they have been turned on by default! It''s important to know some
    of these options that are available to you while you generate your runtime image:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9平台自带内置插件，可以执行这些优化中的几个。事实上，其中一些优化非常重要，影响巨大，因此默认已启用！在您生成运行时图像时，了解一些可用的选项是很重要的：
- en: '**Module descriptor optimizations with the** **system-modules plugin**: During
    the initial development of modules in Java, it was noticed that the Java runtime
    ended up spending a significant amount of time and resources examining, parsing,
    and validating the module descriptors (`module-info.class`) of each module in
    the system image. Since the set of modules that are going to be bundled in an
    image is known at link time, the process of scanning and validating all the module
    descriptors can be done at link time too. There is a `jlink` plugin that does
    this bundled with the platform, and is called `system-modules`. This plugin generates
    a pre-processed and pre-validated system module graph so that the runtime doesn''t
    have to. The process results in such significant gains in performance that it''s
    enabled by default whenever you run `jlink`.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用** **system-modules插件**优化模块描述符：在Java模块的初始开发过程中，发现Java运行时花费了大量时间和资源来检查、解析和验证系统图像中每个模块的模块描述符（`module-info.class`）。由于要捆绑到图像中的模块集在链接时是已知的，因此扫描和验证所有模块描述符的过程也可以在链接时完成。平台捆绑了一个名为`system-modules`的`jlink`插件，用于执行此操作。此插件生成一个预处理的预验证的系统模块图，以便运行时不需进行。这个过程带来了如此显著的性能提升，以至于在运行`jlink`时默认启用。'
- en: '**Compressing the image with the** **compress plugin**: This plugin allows
    you to apply compression to the generated image to reduce the size of the output
    runtime image. There are two types of compression that this plugin can perform
    on the generated image. The first identifies all usages of UTF-8 strings and generates
    a global string table so that any common `String` values have to be stored only
    once and can be reused across the application. The second type of compression
    is the ZIP compression of files in the resulting image to shrink its overall size.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用** **compress插件**压缩图像：此插件允许您对生成的图像应用压缩以减小输出运行时图像的大小。此插件可以对生成的图像执行两种类型的压缩。第一种类型识别所有UTF-8字符串的使用，并生成一个全局字符串表，以便任何常见的`String`值只需存储一次，并且可以在应用程序中重复使用。第二种压缩类型是对结果图像中文件的ZIP压缩，以缩小其整体大小。'
- en: Unlike system-modules, this plugin is not enabled by default. To use it, you'll
    need to pass the `--compress` option to `jlink`. You can pass three values--`0`,
    which means no compression, `1`, which enables string sharing, and `2`, which
    does ZIP compression.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与系统模块不同，此插件默认未启用。要使用它，您需要将`--compress`选项传递给`jlink`。您可以传递三个值--`0`表示不压缩，`1`表示启用字符串共享，以及`2`表示ZIP压缩。
- en: 'Running the two levels of compression while generating the address book image
    on our sample code shows the gains in size of the generated images:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成地址簿图像时运行两个级别的压缩，展示了生成图像大小的增益：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Examining the sizes of the resulting images shows us how much space the compression
    has saved us. The following table summarizes the folder sizes on my machine after
    running these commands:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 检查结果图像的大小显示压缩为我们节省了多少空间。以下表格总结了运行这些命令后我机器上的文件夹大小：
- en: '| **Compression** | **Address book image size** |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| **压缩** | **地址簿图像大小** |'
- en: '| None | 167.5 MB |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 无 | 167.5 MB |'
- en: '| Level 1 | 129.4 MB |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 级别 1 | 129.4 MB |'
- en: '| Level 2 | 95.9 MB |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 级别 2 | 95.9 MB |'
- en: '**Locale information with the** **include-locales plugin**: By default, the
    runtime image bundles in all installed locale information. If you are targeting
    your application runtime only for certain locales, you can use the `--include-locales`
    option and pass the comma-separated list of locales you need. Only those locales
    will be included in the resulting image, thus freeing up more space:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用** **include-locales插件**包含区域信息：默认情况下，运行时图像捆绑了所有已安装的区域信息。如果您只为某些区域设置的应用程序运行时目标，可以使用`--include-locales`选项并传递所需的逗号分隔的区域列表。只有那些区域将被包含在结果图像中，从而释放更多空间：'
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding command regenerates the image with full compression, and with
    the English locale included (`--include-locales=en`). On my machine, this resulted
    in further space savings, with the image size at 88.2 MB.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令以完整压缩方式重新生成图像，并包含英语区域设置（`--include-locales=en`）。在我的机器上，这进一步节省了空间，图像大小为88.2
    MB。
- en: 'There are several other handy plugins that come bundled in the JDK. To get
    to know what plugins are available, and to learn how to use them, you can run
    `jlink` with the `--list-plugins` option. The complete list of installed plugins
    will be displayed, including the plugins we''ve just learned about and much more:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 中还包含几个实用的插件。要了解可用的插件以及如何使用它们，可以在运行 `jlink` 时使用 `--list-plugins` 选项。将显示已安装的插件完整列表，包括我们刚刚了解的插件以及更多：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Building a modular JAR file
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建模块化 JAR 文件
- en: We've looked at creating complete modular runtime images and learned about the
    advantages of the linking process, but sometimes that may not be what you want.
    Suppose you are a library developer and you just want to bundle a single utility
    module as a jar file. When building a jar file from a module, you have an option
    of creating a **modular JAR file**. A modular jar file is just like any other
    jar file, but with the `module-info.class` file in the root directory. You can
    use this to distribute compiled modules as a single file instead of the whole
    module folder. You can drop a modular JAR file in a module path when running the
    `java` command, and it behaves just like the compiled module folders that we've
    been dealing with.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了创建完整的模块化运行时镜像，并学习了链接过程的优势，但有时那可能不是你想要的。假设你是一个库开发者，你只想将单个实用模块打包成一个 jar
    文件。当从一个模块构建 jar 文件时，你可以选择创建一个 **模块化 JAR 文件**。模块化 jar 文件就像任何其他 jar 文件一样，但在根目录中有一个
    `module-info.class` 文件。你可以使用这个文件将编译好的模块作为单个文件分发，而不是整个模块文件夹。你可以在运行 `java` 命令时将模块化
    JAR 文件放入模块路径，它的行为就像我们一直在处理的编译好的模块文件夹一样。
- en: To illustrate this, let's replace a couple of modules in the `out` folder of
    the address book application with modular JAR files.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们将地址簿应用程序的 `out` 文件夹中的几个模块替换为模块化 JAR 文件。
- en: 'The way to create a modular JAR file is by using the `jar` utility. In order
    to convert the `packt.contact` module into a modular JAR file, we run the following
    command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 创建模块化 JAR 文件的方法是使用 `jar` 工具。为了将 `packt.contact` 模块转换为模块化 JAR 文件，我们运行以下命令：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `--create` option tells the `jar` utility that it needs to create a JAR
    file. The `-C` option specifies where it can find the classes. The value is of
    the format `<folder> <file>`. In our case, the folder is `out/packt.contact`.
    This is followed by  "`.`"  which indicates that all files in this location need
    to be included. The `--module-version` option specifies a module version for the
    `jar`. Finally, the `--file` option provides the JAR output file name.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`--create` 选项告诉 `jar` 工具它需要创建一个 JAR 文件。`-C` 选项指定了它可以从哪里找到类。其值格式为 `<folder>
    <file>`。在我们的例子中，文件夹是 `out/packt.contact`。这后面跟着一个 "`.`"，表示需要包含该位置下的所有文件。`--module-version`
    选项为 `jar` 指定一个模块版本。最后，`--file` 选项提供了 JAR 输出文件名。'
- en: 'Running this command will create a modular JAR file, with the `module-info.class`
    file at the root. There''s also a `META-INF` folder with a manifest file that
    records the version number specified: `Manifest-Version: 1.0`.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '运行此命令将创建一个模块化 JAR 文件，根目录中有 `module-info.class` 文件。还有一个包含记录指定版本的清单文件的 `META-INF`
    文件夹：`Manifest-Version: 1.0`。'
- en: 'Even modules with an executable `main` method can be converted to modular jars.
    Here''s how we''d convert the `packt.addressbook.ui` module into a modular JAR:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 即使带有可执行 `main` 方法的模块也可以转换为模块化 jar。以下是如何将 `packt.addressbook.ui` 模块转换为模块化 JAR
    的示例：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Most of the parameters should be familiar here, except for the `--main-class`.
    This option, as the name says, specifies the type with the `main` method.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数参数在这里应该是熟悉的，除了 `--main-class`。正如其名所示，此选项指定了具有 `main` 方法的类型。
- en: 'With these two modules converted to modular JAR files and placed in the module
    path, you can now delete the corresponding compiled module folders and still execute
    the application. The runtime treats the modular JAR file the same way as the expanded
    module folder:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两个模块转换为模块化 JAR 文件并放置在模块路径中后，你现在可以删除相应的编译模块文件夹，并且仍然可以执行应用程序。运行时将模块化 JAR 文件视为与展开的模块文件夹相同：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The application should still work the same way, although this time, it's executing
    two of the modules from the JAR file.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序应该仍然以相同的方式工作，尽管这次它正在执行 jar 文件中的两个模块。
- en: Summary
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter examined the part of the application development process after
    you are done writing code--building and packaging your application for distribution.
    We started the chapter by examining the module resolution process. We then looked
    at the process of linking, which uses module resolution to build a runtime image
    containing just the modules needed for a given application. We then looked at
    some of the built-in plugins that allow us to optimize and preprocess the generated
    image. Finally, we learned how to generate a modular JAR file to bundle reusable
    library modules for use in other applications.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了在编写代码完成后应用程序开发过程的部分——构建和打包应用程序以进行分发。我们通过检查模块解析过程开始本章。然后我们研究了链接过程，该过程使用模块解析来构建只包含给定应用程序所需模块的运行时镜像。接着我们查看了一些内置插件，这些插件允许我们优化和预处理生成的镜像。最后，我们学习了如何生成模块化JAR文件，以便在其他应用程序中使用可重用的库模块。
- en: We've looked at a lot of features so far and how they work. In the next chapter,
    we'll start looking at how to work with Java 9 modules in the context of an existing
    legacy Java codebase. You'll learn ways to write code that is interoperable between
    different Java versions. You'll also learn techniques and strategies to migrate
    existing code written using Java 8 or earlier to the new modular application development
    of Java 9\. See you in the next unit!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了众多特性及其工作原理。在下一章中，我们将开始探讨如何在现有的遗留Java代码库的背景下使用Java 9模块。你将学习如何编写在不同Java版本之间互操作的代码。你还将学习将使用Java
    8或更早版本编写的现有代码迁移到Java 9的新模块化应用程序开发的技巧和策略。下一单元再见！
