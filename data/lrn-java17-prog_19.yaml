- en: '*Chapter 16*: Java Microbenchmark Harness'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 16 章*：Java 微基准工具'
- en: In this chapter, you will learn about a **Java Microbenchmark Harness** (**JMH**)
    project that allows measuring various code performance characteristics. If performance
    is an important issue for your application, this tool can help you to identify
    bottlenecks with precision—up to the method level.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解一个**Java 微基准工具**（**JMH**）项目，它允许测量各种代码性能特征。如果你的应用程序性能是一个重要问题，这个工具可以帮助你精确地识别瓶颈，甚至到方法级别。
- en: In addition to theoretical knowledge, you will have a chance to run JMH using practical
    demo examples and recommendations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 除了理论知识，你还有机会通过实际演示示例和建议来运行 JMH。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What is JMH?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 JMH？
- en: Creating a JMH benchmark
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 JMH 基准
- en: Running the benchmark
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行基准测试
- en: Using the IDE plugin
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 IDE 插件
- en: JMH benchmark parameters
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JMH 基准参数
- en: JMH usage examples
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JMH 使用示例
- en: By the end of the chapter, you will be able to not only measure the average
    execution time of an application and other performance values (such as throughput,
    for example) but also to do it in a controlled manner—with or without the JVM optimizations,
    warm-up runs, and so on.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你不仅能够测量应用程序的平均执行时间和其他性能值（例如吞吐量），而且还能以受控的方式进行测量——无论是带有还是不带 JVM 优化、预热运行等。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To be able to execute the code examples provided in this chapter, you will
    need the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够执行本章提供的代码示例，你需要以下内容：
- en: A computer with a Microsoft Windows, Apple macOS, or Linux operating system
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搭载 Microsoft Windows、Apple macOS 或 Linux 操作系统的计算机
- en: Java SE version 17 or later
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java SE 版本 17 或更高版本
- en: The IDE or code editor you prefer
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你偏好的 IDE 或代码编辑器
- en: The instructions for how to set up a Java SE and IntelliJ IDEA editor were provided
    in [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015), *Getting Started with
    Java 17*. The files with the code examples for this chapter are available on GitHub
    in the [https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git)
    repository in the `examples/src/main/java/com/packt/learnjava/ch16_microbenchmark`
    folder.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如何设置 Java SE 和 IntelliJ IDEA 编辑器的说明已在 [*第 1 章*](B18388_01_ePub.xhtml#_idTextAnchor015)，*Java
    17 入门*中提供。本章的代码示例文件可在 GitHub 的 [https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git)
    仓库的 `examples/src/main/java/com/packt/learnjava/ch16_microbenchmark` 文件夹中找到。
- en: What is JMH?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 JMH？
- en: According to the Oxford English Dictionary, a **benchmark** is *a standard or
    point of reference against which things may be compared or assessed*. In programming, it
    is the way to compare the performance of applications, or just methods. The **micro
    preface** is focused on the latter—smaller code fragments rather than an application
    as a whole. JMH is a framework for measuring the performance of a single method.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 根据《牛津高阶英汉双解大词典》，**基准**是**一个标准或参考点，可以用来比较或评估事物**。在编程中，它是比较应用程序性能或方法性能的方式。**微基准**专注于后者——较小的代码片段而不是整个应用程序。JMH
    是一个用于测量单个方法性能的框架。
- en: That may appear to be very useful. Can we not just run a method 1,000 or 100,000
    times in a loop, measure how long it took, and then calculate the average of the
    method’s performance? We can. The problem is that JVM is a much more complicated
    program than just a code-executing machine. It has optimization algorithms focused
    on making the application code run as fast as possible.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来非常有用。我们能否只是将一个方法循环运行 1,000 或 100,000 次，测量它花费的时间，然后计算方法的平均性能？我们可以。问题是 JVM
    不仅仅是一个代码执行机器，它是一个更加复杂的程序。它有优化算法，旨在使应用程序代码尽可能快地运行。
- en: 'For example, let’s look at the following class:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看以下类：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We filled the `someMethod()` method with code that does not make much sense but
    keeps the method busy. To test the performance of this method, it is tempting
    to copy the code into a test method and run it in a loop:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `someMethod()` 方法中填充了一些没有太多意义但能让方法忙碌的代码。为了测试这个方法的性能，我们可能会倾向于将代码复制到测试方法中并循环运行：
- en: '[PRE12]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: However, JVM will see that the `res` result is never used and qualify the calculations
    as **dead code** (a code section that is never executed). So, why bother executing
    this code at all?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，JVM 会发现 `res` 结果从未被使用，并将这些计算视为**死代码**（从未被执行的代码段）。那么，为什么还要执行这段代码呢？
- en: You may be surprised to see that the significant complication or simplification of
    the algorithm does not affect the performance. That is because, in every case,
    the code is not actually executed.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会惊讶地发现，算法的显著复杂化或简化并不影响性能。这是因为，在所有情况下，代码实际上并没有被执行。
- en: 'You may change the test method and pretend that the result is used by returning
    it:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以更改测试方法，并假装返回的结果被使用：
- en: '[PRE29]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This may convince JVM to execute the code every time, but it is not guaranteed.
    JVM may notice that the input into the calculations does not change and this algorithm produces
    the same result every run. Since the code is based on constant input, this optimization is
    called **constant folding**. The result of this optimization is that this code
    may be executed only once and the same result is assumed for every run, without
    actually executing the code.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会让 JVM 每次都执行代码，但这并不是保证的。JVM 可能会注意到计算输入没有变化，并且这个算法每次运行都会产生相同的结果。由于代码基于常量输入，这种优化被称为**常量折叠**。这种优化的结果是，这段代码可能只执行一次，并且每次运行都假设得到相同的结果，而实际上并不执行代码。
- en: 'In practice though, the benchmark is often built around a method, not a block
    of code. For example, the test code may look as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实践中，基准测试通常围绕一个方法构建，而不是一段代码块。例如，测试代码可能看起来如下：
- en: '[PRE47]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: But even this code is susceptible to the same JVM optimization we have just
    described.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但即使这个代码也容易受到我们刚才描述的相同 JVM 优化的影响。
- en: JMH was created to help to avoid this and similar pitfalls. In the *JMH usage
    examples* section, we will show you how to use JMH to work around the dead code
    and constant folding optimization, using the `@State` annotation and the `Blackhole` object.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: JMH 是为了帮助避免这种和类似的陷阱而创建的。在 *JMH 使用示例* 部分，我们将向你展示如何使用 JMH 来绕过死代码和常量折叠优化，使用 `@State` 注解和 `Blackhole` 对象。
- en: Besides, JMH allows for measuring not only average execution time but also throughput
    and other performance characteristics.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，JMH 允许测量不仅平均执行时间，还包括吞吐量和其他性能特征。
- en: Creating a JMH benchmark
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 JMH 基准测试
- en: 'To start using JMH, the following dependencies have to be added to the `pom.xml` file:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 JMH，必须在 `pom.xml` 文件中添加以下依赖项：
- en: '[PRE59]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The name of the second `.jar` file, `annprocess`, provides a hint that JMH
    uses annotations. If you guessed so, you were correct. Here is an example of a
    benchmark created for testing the performance of an algorithm:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 `.jar` 文件名，`annprocess`，暗示了 JMH 使用注解。如果你猜对了，那么你是对的。以下是一个为测试算法性能而创建的基准测试示例：
- en: '[PRE69]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Please notice the `@Benchmark` annotation. It tells the framework that this
    method’s performance has to be measured. If you run the preceding `main()` method,
    you will see an output similar to the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意 `@Benchmark` 注解。它告诉框架这个方法的性能需要被测量。如果你运行前面的 `main()` 方法，你将看到类似于以下输出的结果：
- en: '![](img/B18388_Figure_16.1.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_16.1.jpg)'
- en: This is only one segment of an extensive output that includes multiple iterations
    under different conditions with the goal being to avoid or offset the JVM optimization.
    It also takes into account the difference between running the code once and running
    it multiple times. In the latter case, JVM starts using the just-in-time compiler,
    which compiles the often-used bytecodes’ code into native binary code and does
    not even read the bytecodes. The warm-up cycles serve this purpose—the code is
    executed without measuring its performance as a dry run that *warms up* the JVM.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是大量输出的一部分，包括在不同条件下多次迭代，目的是避免或抵消 JVM 优化。它还考虑了单次运行代码和多次运行代码之间的差异。在后一种情况下，JVM
    开始使用即时编译器，将常用字节码编译成原生二进制代码，甚至不读取字节码。预热循环就是为了这个目的——代码在没有测量其性能的情况下执行，作为预热 JVM 的干运行。
- en: There are also ways to tell the JVM which method to compile and use as binary
    directly, which method to compile every time, and to provide similar instructions
    to disable certain optimization. We will talk about this shortly.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种方法可以告诉 JVM 哪个方法需要编译并直接作为二进制使用，哪个方法每次都需要编译，并提供类似的指令来禁用某些优化。我们将在稍后讨论这个问题。
- en: Let’s now see how to run the benchmark.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何运行基准测试。
- en: Running the benchmark
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行基准测试
- en: 'As you have probably guessed, one way to run a benchmark is just to execute
    the `main()` method. It can be done using the `java` command directly or using
    the IDE. We talked about it in [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015), *Getting
    Started with Java 17*. Yet there is an easier and more convenient way to run a
    benchmark: by using an IDE plugin.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，运行基准的一种方法就是直接执行`main()`方法。这可以通过直接使用`java`命令或使用IDE来完成。我们已经在[*第1章*](B18388_01_ePub.xhtml#_idTextAnchor015)，“Java
    17入门”中讨论过。但还有更简单、更方便的方法来运行基准：通过使用IDE插件。
- en: Using an IDE plugin
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用IDE插件
- en: All major Java-supporting IDEs have such a plugin. We will demonstrate how to
    use the plugin for IntelliJ installed on a macOS computer, but it is equally applicable
    to Windows systems.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 所有主要的Java支持IDE都拥有这样的插件。我们将演示如何在macOS计算机上安装IntelliJ的插件，但它同样适用于Windows系统。
- en: 'Here are the steps to follow:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是遵循的步骤：
- en: To start installing the plugin, press the *command* key and comma (*,*) together,
    or just click the wrench symbol (with the hover text **Preferences**) in the top
    horizontal menu:![](img/B18388_Figure_16.2.jpg)
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始安装插件，按住*command*键和逗号(*,*)一起，或者只需点击顶部水平菜单中的扳手符号（悬停文本为**首选项**）![图16.2](img/B18388_Figure_16.2.jpg)
- en: 'It will open a window with the following menu in the left pane:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将打开一个窗口，左侧面板中有以下菜单：
- en: '![](img/B18388_Figure_16.3.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图16.3](img/B18388_Figure_16.3.jpg)'
- en: 'Select **Plugins**, as shown in the preceding screenshot, and observe the window
    with the following top horizontal menu:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前图所示，选择**插件**，并观察以下顶部水平菜单：
- en: '![](img/B18388_Figure_16.4.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图16.4](img/B18388_Figure_16.4.jpg)'
- en: Select `JMH` in the **Search plugins in marketplace** input field, and press *Enter*.
    If you have an internet connection, it will show you a **JMH plugin** symbol,
    similar to the one shown in the following screenshot:![](img/B18388_Figure_16.5.jpg)
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**在市场插件中搜索**输入字段中选择`JMH`，然后按*Enter*。如果你有互联网连接，它将显示一个**JMH插件**符号，类似于以下截图所示![图16.5](img/B18388_Figure_16.5.jpg)
- en: 'Click the **Install** button and then, after it turns into **Restart IDE**, click
    it again:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**安装**按钮，然后，当它变为**重启IDE**时，再次点击它：
- en: '![](img/B18388_Figure_16.6.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图16.6](img/B18388_Figure_16.6.jpg)'
- en: 'After the IDE restarts, the plugin is ready to be used. Now you can not only
    run the `main()` method but you can also pick and choose which of the benchmark
    methods to execute if you have several methods with the `@Benchmark` annotation.
    To do this, select **Run...** from the **Run** drop-down menu:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在IDE重启后，插件就准备好使用了。现在你不仅可以运行`main()`方法，如果你有多个带有`@Benchmark`注解的方法，你也可以选择并执行其中的基准方法。要做到这一点，从**运行**下拉菜单中选择**运行...**：
- en: '![](img/B18388_Figure_16.7.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图16.7](img/B18388_Figure_16.7.jpg)'
- en: 'It will bring up a window with a selection of methods you can run:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将弹出一个窗口，其中包含你可以运行的方法选择：
- en: '![](img/B18388_Figure_16.8.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图16.8](img/B18388_Figure_16.8.jpg)'
- en: 'Select the one you would like to run and it will be executed. After you have run
    a method at least once, you can just right-click on it and execute it from the
    pop-up menu:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你想要运行的，它将被执行。在你至少运行了一个方法之后，你只需右键单击它，然后从弹出菜单中执行它：
- en: '![](img/B18388_Figure_16.9.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图16.9](img/B18388_Figure_16.9.jpg)'
- en: You can also use the shortcuts shown to the right of each menu item.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以使用每个菜单项右侧显示的快捷键。
- en: Now let’s review the parameters that can be passed to the benchmark.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下可以传递给基准的参数。
- en: JMH benchmark parameters
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JMH基准参数
- en: There are many benchmark parameters that allow for fine-tuning the measurements for
    the particular needs of the task at hand. We are going to present only the major
    ones.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多基准参数允许针对手头任务的特定需求进行微调测量。我们将只介绍其中主要的。
- en: Mode
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式
- en: 'The first set of parameters defines the performance aspect (mode) the particular
    benchmark has to measure:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组参数定义了特定基准需要测量的性能方面（模式）：
- en: '`Mode.AverageTime`: Measures the average execution time'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mode.AverageTime`：测量平均执行时间'
- en: '`Mode.Throughput`: Measures the throughput by calling the benchmark method
    in an iteration'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mode.Throughput`：通过迭代调用基准方法来测量吞吐量'
- en: '`Mode.SampleTime`: Samples the execution time, instead of averaging it; allows
    us to infer the distributions, percentiles, and so on'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mode.SampleTime`：采样执行时间，而不是平均它；允许我们推断分布、百分位数等'
- en: '`Mode.SingleShotTime`: Measures the single method invocation time; allows for
    the testing of a cold startup without calling the benchmark method continuously'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mode.SingleShotTime`：测量单个方法调用时间；允许在不连续调用基准方法的情况下测试冷启动'
- en: 'These parameters can be specified in the annotation `@BenchmarkMode`, for example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数可以在`@BenchmarkMode`注解中指定，例如：
- en: '[PRE84]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'It is possible to combine several modes:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 可以组合几个模式：
- en: '[PRE85]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'It is also possible to request all of them:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以请求所有这些：
- en: '[PRE86]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The described parameters and all the parameters we are going to discuss later
    in this chapter can be set at the method and/or class level. The method-level
    set value overrides the class-level value.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 描述的参数以及我们将在本章后面讨论的所有参数都可以在方法和/或类级别设置。方法级别的设置值会覆盖类级别的值。
- en: Output time unit
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输出时间单位
- en: 'The unit of time used for presenting the results can be specified using the `@OutputTimeUnit` annotation:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 用于呈现结果的单位时间可以使用`@OutputTimeUnit`注解来指定：
- en: '[PRE87]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The possible time units come from the `java.util.concurrent.TimeUnit` enum.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的时间单位来自`java.util.concurrent.TimeUnit`枚举。
- en: Iterations
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代次数
- en: 'Another group of parameters defines the iterations used for the warm-ups and
    measurements, for example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 另一组参数定义了用于预热和测量的迭代次数，例如：
- en: '[PRE88]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Forking
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分叉
- en: 'While running several tests, the `@Fork` annotation allows you to set each
    test to be run in a separate process, for example:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行多个测试时，`@Fork`注解允许你将每个测试设置在单独的进程中运行，例如：
- en: '[PRE92]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The passed-in parameter value indicates how many times the JVM can be forked into
    independent processes. The default value is `-1`. Without it, the test’s performance
    can be mixed if you use several classes implementing the same interface in tests and
    they affect each other.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 传入的参数值表示JVM可以分叉成多少个独立进程。默认值是`-1`。如果没有它，如果你在测试中使用实现相同接口的几个类，并且它们相互影响，测试的性能可能会混合。
- en: 'The `warmups` parameter is another one that can be set to indicate how many
    times the benchmark has to execute without collecting measurements:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`warmups`参数是另一个可以设置的参数，用来指示基准测试必须执行多少次而不收集测量数据：'
- en: '[PRE93]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'It also allows you to add Java options to the java command line, for example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 它还允许你向java命令行添加Java选项，例如：
- en: '[PRE94]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The full list of JMH parameters and examples of how to use them can be found
    in the `openjdk` project ([http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples](http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples)).
    For example, we did not mention `@Group`, `@GroupThreads`, `@Measurement`, `@Setup`, `@Threads`, `@Timeout`, `@TearDown`,
    or `@Warmup`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: JMH参数的完整列表以及如何使用它们的示例可以在`openjdk`项目中找到（[http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples](http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples)）。例如，我们没有提到`@Group`、`@GroupThreads`、`@Measurement`、`@Setup`、`@Threads`、`@Timeout`、`@TearDown`或`@Warmup`。
- en: JMH usage examples
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JMH使用示例
- en: 'Let’s now run a few tests and compare them. First, we run the following test
    method:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们运行几个测试并比较它们。首先，我们运行以下测试方法：
- en: '[PRE95]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'As you can see, we have requested to measure all the performance characteristics
    and to use nanoseconds while presenting the results. On our system, the test execution
    took around 20 minutes and the final result summary looked like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们已经请求测量所有性能特征，并在呈现结果时使用纳秒。在我们的系统中，测试执行大约花费了20分钟，最终结果摘要如下所示：
- en: '![](img/B18388_Figure_16.10.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图16.10](img/B18388_Figure_16.10.jpg)'
- en: 'Let’s now change the test as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将测试修改如下：
- en: '[PRE107]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'If we run the `testTheMethod1()` now, the results will be slightly different:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行`testTheMethod1()`，结果将略有不同：
- en: '![](img/B18388_Figure_16.11.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图16.11](img/B18388_Figure_16.11.jpg)'
- en: The results are mostly different around sampling and single-shot running. You
    can play with these methods and change the forking and number of warm-ups.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 结果在采样和单次运行方面大多不同。你可以玩转这些方法，并更改分叉和预热的次数。
- en: Using the @State annotation
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用@State注解
- en: 'This JMH feature allows you to hide the source of the data from JVM, thus preventing
    dead code optimization. You can add a class as the source of the input data as
    follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: JMH的这个特性允许你将数据的来源隐藏于JVM中，从而防止死代码优化。你可以添加一个类作为输入数据来源，如下所示：
- en: '[PRE116]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: The `Scope` value is used for sharing data between tests. In our case, with
    only one test using the `TestCase` class object, we do not have a need for sharing.
    Otherwise, the value can be set to `Scope.Group` or `Scope.Benchmark`, which means
    we could add setters to the `TestState` class and read/modify it in other tests.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scope`值用于在测试之间共享数据。在我们的案例中，只有一个使用`TestCase`类对象的测试，我们没有共享的需求。否则，该值可以设置为`Scope.Group`或`Scope.Benchmark`，这意味着我们可以向`TestState`类添加设置器，并在其他测试中读取/修改它。'
- en: 'When we ran this version of the test, we got the following results:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个版本的测试时，我们得到了以下结果：
- en: '![](img/B18388_Figure_16.12.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图16.12](img/B18388_Figure_16.12.jpg)'
- en: The data has changed again. Notice that the average time for execution has increased
    three-fold, which indicates that more JVM optimization was not applied.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 数据再次发生了变化。注意，执行的平均时间增加了三倍，这表明没有应用更多的JVM优化。
- en: Using the Blackhole object
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Blackhole对象
- en: 'This JMH feature allows for simulating result usage, thus preventing JVM from
    implementing folding constants optimization:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个JMH特性允许模拟结果使用，从而防止JVM实现折叠常量优化：
- en: '[PRE128]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: As you can see, we have just added a parameter `Blackhole` object and called
    the `consume()` method on it, thus pretending that the result of the tested method
    is used.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们刚刚添加了一个`Blackhole`参数对象，并对其调用了`consume()`方法，从而假装测试方法的结果是已被使用。
- en: 'When we ran this version of the test, we got the following results:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个版本的测试时，我们得到了以下结果：
- en: '![](img/B18388_Figure_16.13.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图16.13](img/B18388_Figure_16.13.jpg)'
- en: This time, the results look not that different. Apparently, the constant folding
    optimization was neutralized even before the `Blackhole` usage was added.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，结果看起来并没有太大的不同。显然，在添加`Blackhole`使用之前，常量折叠优化已经被中和了。
- en: Using the @CompilerControl annotation
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用@CompilerControl注解
- en: 'Another way to tune up the benchmark is to tell the compiler to compile, inline
    (or not), and exclude (or not) a particular method from the code. For example,
    consider the following class:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 调整基准测试的另一种方法是告诉编译器编译、内联（或不内联）、排除（或不排除）代码中的特定方法。例如，考虑以下类：
- en: '[PRE136]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Assuming we are interested in how the method `anotherMethod()` compilation/inlining
    affects the performance, we can set the `CompilerControl` mode on it to the following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们感兴趣的是`anotherMethod()`方法的编译/内联如何影响性能，我们可以将其`CompilerControl`模式设置为以下：
- en: '`Mode.INLINE`: To force method inlining'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mode.INLINE`：强制方法内联'
- en: '`Mode.DONT_INLINE`: To avoid method inlining'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mode.DONT_INLINE`：避免方法内联'
- en: '`Mode.EXCLUDE`: To avoid method compiling'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mode.EXCLUDE`：避免方法编译'
- en: Using the @Param annotation
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用@Param注解
- en: Sometimes, it is necessary to run the same benchmark for a different set of
    input data. In such a case, the `@Param` annotation is very useful.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，有必要为不同的输入数据集运行相同的基准测试。在这种情况下，`@Param`注解非常有用。
- en: '`@Param` is a standard Java annotation used by various frameworks, for example,
    JUnit. It identifies an array of parameter values. The test with the `@Param` annotation
    will be run as many times as there are values in the array. Each test execution
    picks up a different value from the array.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Param`是一个标准的Java注解，被各种框架使用，例如JUnit。它标识了一个参数值的数组。带有`@Param`注解的测试将根据数组中的值运行多次。每次测试执行都会从数组中选取不同的值。'
- en: 'Here is an example:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE152]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: The `testTheMethod6()` benchmark is going to be used with each of the listed
    values of the parameter `m`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`testTheMethod6()`基准测试将使用参数`m`列出的每个值。'
- en: A word of caution
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 警告：请注意
- en: 'The described harness takes away most of the worries of the programmer who
    measures the performance. And yet, it is virtually impossible to cover all the
    cases of JVM optimization, profile sharing, and similar aspects of JVM implementation,
    especially if we take into account that JVM code evolves and differs from one
    implementation to another. The authors of JMH acknowledge this fact by printing
    the following warning along with the test results:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 所描述的测试框架移除了测量性能的程序员的大部分担忧。然而，几乎不可能覆盖JVM优化、性能分析共享以及JVM实现类似方面的所有情况，尤其是如果我们考虑到JVM代码会演变并且不同实现之间会有所不同。JMH的作者通过在测试结果中打印以下警告来承认这一事实：
- en: '![](img/B18388_Figure_16.14.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图16.14](img/B18388_Figure_16.14.jpg)'
- en: The description of the profilers and their usage can be found in the `openjdk` project
    ([http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples](http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples)).
    Among the same samples, you will encounter a description of the code generated
    by JMH, based on the annotations.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器的描述及其使用方法可以在`openjdk`项目中找到（[http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples](http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples)）。在相同的样本中，您将遇到JMH基于注解生成的代码的描述。
- en: If you would like to get really deep into the details of your code execution
    and testing, there is no better way to do it than to study the generated code.
    It describes all the steps and decisions JMH makes in order to run the requested
    benchmark. You can find the generated code in `target/generated-sources/annotations`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想深入了解代码执行和测试的细节，没有比研究生成的代码更好的方法了。它描述了JMH为了运行请求的基准测试所采取的所有步骤和决策。您可以在`target/generated-sources/annotations`中找到生成的代码。
- en: The scope of this book does not allow for going into too many details on how
    to read it, but it is not very difficult, especially if you start with a simple
    case of testing one method only. We wish you all the best in this endeavor.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书的范围不允许过多地详细介绍如何阅读，但它并不困难，尤其是如果您从仅测试一个方法的简单案例开始。我们希望您在这项努力中一切顺利。
- en: Summary
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned about the JMH tool and were able to use it
    for your applications. You have learned how to create and run a benchmark, how
    to set the benchmark parameters, and how to install IDE plugins if needed. We
    have also provided practical recommendations and references for further reading.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了JMH工具，并能够将其用于您的应用程序。您学习了如何创建和运行基准测试，如何设置基准测试参数，以及如果需要如何安装IDE插件。我们还提供了实际的建议和进一步阅读的参考。
- en: Now you are able to not only measure the average execution time of an application
    and other performance values (such as throughput, for example) but to do it in
    a controlled manner—with or without JVM optimizations, warm-up runs, and so on.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您不仅可以测量应用程序的平均执行时间和其他性能值（例如吞吐量），还可以以受控的方式进行测量——无论是带有还是不带JVM优化、预热运行等。
- en: In the next chapter, you will learn useful practices for designing and writing
    application code. We will talk about Java idioms, their implementation and usage,
    and provide recommendations for implementing `equals()`, `hashCode()`, `compareTo()`,
    and `clone()` methods. We will also discuss the difference between the usage of
    the `StringBuffer` and `StringBuilder` classes, how to catch exceptions, best
    design practices, and other proven programming practices.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习设计和编写应用程序代码的有用实践。我们将讨论Java惯用语的实现和使用，并提供实现`equals()`、`hashCode()`、`compareTo()`和`clone()`方法的建议。我们还将讨论`StringBuffer`和`StringBuilder`类使用上的区别，如何捕获异常，最佳设计实践以及其他经过验证的编程实践。
- en: Quiz
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测验
- en: 'Select all the correct statements:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: JMH is useless since it runs methods outside the production context.
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于JMH在非生产环境中运行方法，因此它毫无用处。
- en: JMH is able to work around some JVM optimizations.
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: JMH能够绕过一些JVM优化。
- en: JMH allows for measuring not only average performance time but other performance
    characteristics too.
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: JMH不仅可以测量平均性能时间，还可以测量其他性能特征。
- en: JMH can be used to measure the performance of small applications too.
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: JMH也可以用来测量小型应用程序的性能。
- en: Name two steps necessary to start using JMH.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出开始使用JMH的两个必要步骤。
- en: Name four ways JMH can be run.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出四种运行JMH的方式。
- en: Name two modes (performance characteristics) that can be used (measured) with
    JMH.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出两种可以使用（测量）JMH的模式（性能特征）。
- en: Name two of the time units that can be used to present JMH test results.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出两种可以用来表示JMH测试结果的时间单位。
- en: How can data (results, state) be shared between JMH benchmarks?
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在JMH基准测试之间共享数据（结果、状态）？
- en: How do you tell JMH to run the benchmark for the parameter with the enumerated
    list of values?
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何告诉JMH为具有枚举值列表的参数运行基准测试？
- en: How can the compilation of a method be forced or turned off?
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何强制或关闭方法的编译？
- en: How can the JVM's constant folding optimization be turned off?
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何关闭JVM的常量折叠优化？
- en: How can Java command options be provided programmatically for running a particular
    benchmark?
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何以编程方式提供Java命令选项以运行特定的基准测试？
