- en: Working with Implicits and Exceptions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与隐式和异常一起工作
- en: '"How ironic, when you do business you create exceptions to create new opportunities,
    when you write code (do a job) you handle exceptions to make it clean."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “多么讽刺，当你做生意时，你通过创造异常来创造新的机会，当你编写代码（做工作）时，你处理异常以使其变得干净。”
- en: '- Pushkar Saraf'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- Pushkar Saraf'
- en: 'Functional programs are expressions. When we say we want to run a functional
    program, we mean we want to evaluate the expressions. When we evaluate an expression,
    we get a value. We also know that functional programming is about composing and
    evaluating expressions. This means that the function signature you write down
    holds true for each evaluation. But there are scenarios where it''s unlikely to
    happen. Your code might not work as expected and might result in an exceptional
    behavior. How do we deal with such scenarios, and how do we handle exceptions
    in functional programming? These are some fundamental questions, and anyone who''s
    starting with functional programming might ask the same. So, in this chapter,
    we''ll try answering these questions, and then we''ll move forward to look at
    another important and much-talked-about concept in Scala known as **implicits**.
    We''ll take a look at what they are and the instances where we might want to use
    them. So here''s what we''ll go through in our chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式程序是表达式。当我们说我们想要运行一个函数式程序时，我们的意思是我们要评估表达式。当我们评估一个表达式时，我们得到一个值。我们还知道，函数式编程是关于组合和评估表达式。这意味着你写下的函数签名对每次评估都成立。但有些情况下，这种情况不太可能发生。你的代码可能不会按预期工作，并可能导致异常行为。我们如何处理这些情况，如何在函数式编程中处理异常？这些问题是基本的，任何刚开始学习函数式编程的人可能会问同样的问题。所以，在本章中，我们将尝试回答这些问题，然后我们将继续前进，看看另一个在
    Scala 中非常重要且广为人知的概念，称为 **隐式**。我们将看看它们是什么，以及我们可能想要使用它们的场景。所以，以下是我们在本章中将要讨论的内容：
- en: Exception handling - the old way
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理 - 旧方法
- en: Using the option way
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用选项方式
- en: Either left or right
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要么是左边，要么是右边
- en: Implicits - what and why
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式 - 什么是以及为什么
- en: Implicit class
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式类
- en: Implicit arguments
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式参数
- en: Let's start by introducing an exceptional behavior to a particular functionality
    and handling it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向特定功能引入异常行为并处理它开始。
- en: Exception handling – the old way
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理 – 旧方法
- en: 'Let''s write some code so that we can talk about exception handling. Take a
    look at the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，以便我们可以讨论异常处理。看看下面的代码：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding code, the `toInt` is a function that takes a `String` value,
    which supposedly can be converted to a corresponding `Int` value. The definition
    looks okay, but as functional programmers, we are so used to trying out the function
    to see whether it does what it says (in the definition). Let''s try out some calls
    to this function:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`toInt` 是一个接受 `String` 值的函数，理论上它可以转换成相应的 `Int` 值。定义看起来没问题，但作为函数式程序员，我们习惯于尝试函数以查看它是否如定义中所说那样工作。让我们尝试调用这个函数：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code gives the following result:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码给出了以下结果：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Things worked fine for us. We passed a number in a string format and got the
    corresponding integer values. But what if you try something like the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们来说，一切都很顺利。我们传递了一个字符串格式的数字，并得到了相应的整数值。但是，如果你尝试以下内容会怎样呢？
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Say that we get something unexpected, some exception saying this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们得到了一些意外的情况，一些异常信息如下：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Instead of responding with an integer result, what we got is an exception—that''s
    bad. But let''s be positive; there are a few things that we can learn from this
    failure:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有得到整数结果，而是一个异常——这很糟糕。但让我们保持积极；我们可以从这次失败中学到一些东西：
- en: The definition of our function was not right. It was telling us, *you give me
    a string and I'll give you back the corresponding integer.* But it didn't happen.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们函数的定义不正确。它告诉我们，“你给我一个字符串，我会给你相应的整数。”但事实并非如此。
- en: We knew that instead of the ideal cases, there might be scenarios where our
    operation might fail to complete.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们知道，除了理想情况外，可能还有我们的操作可能无法完成的情况。
- en: So, learning from this experience, we now have an idea that we might want to
    handle the unwanted scenarios. But how?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从这次经历中学习，我们现在有一个想法，我们可能想要处理这些不期望的情况。但怎么办呢？
- en: 'In some programming languages, we get a construct that wraps a block of code
    that might throw an exception and catches exceptions when thrown, and we are allowed
    to introduce our desired behaviour by putting in catch blocks. These are nothing
    but `try... catch` blocks. Why don''t we try out these blocks?:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些编程语言中，我们得到一个构造函数，它可以包装可能抛出异常的代码块，并在抛出异常时捕获异常，我们允许通过在捕获块中放入我们期望的行为来引入我们期望的行为。这些不过是`try...
    catch`块。我们为什么不尝试这些块呢？
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following is the result:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下就是结果：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Something unexpected happened; you may want to check the string you passed
    for conversion:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了意外的情况；你可能想检查你传递给转换的字符串：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Does this implementation seem reasonable? To some extent, it's a workaround
    and it does what it says in the function's signature. But returning zero in exceptional
    cases is still not a good option.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现看起来合理吗？在某种程度上，它是一个折衷方案，并且它确实做了函数签名中所说的。但在异常情况下返回零仍然不是一个好的选择。
- en: Using the Option way
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Option方法
- en: 'Let''s try and change the function signature in a way that we can reason about
    and modify it so that it does what it says:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试更改函数签名，以便我们可以推理和修改它，使其按其所说的那样工作：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding definition, we knew that the response was optional. We might
    or might not get a corresponding integer value for every string we pass to our
    function. Hence, we made the response type an `Option[Int]`*.* Also, as you may
    have noticed, we used another construct available to us from the `scala.util`
    package, named `Try`*.* How do we use `Try`*?* We pass a function for its evaluation
    to the `Try` block's constructor/apply method. As might be obvious, the `Try`
    block's `apply` method takes a function as a `by-name` parameter, which tries
    to evaluate that function. Based on the result or exception, it responds as a
    `Success(value)` or `Failure(exception)`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的定义中，我们知道响应是可选的。我们可能或可能不会为传递给我们的函数的每个字符串得到相应的整数值。因此，我们将响应类型设为`Option[Int]`。此外，正如你可能已经注意到的，我们使用了`scala.util`包中可用的另一个构造函数，名为`Try`。我们如何使用`Try`？我们传递一个函数给`Try`块的构造函数/`apply`方法。显然，`Try`块的`apply`方法接受一个函数作为`by-name`参数，尝试评估该函数。根据结果或异常，它响应为`Success(value)`或`Failure(exception)`。
- en: 'We used the `Try`  construct and passed logic as an argument. On success*,*
    we responded as `Some(value)`, and in case of failure, we returned `None`*.* Both
    worked well, as these are subtypes of the `Option` type*.* We''ve already seen
    `Option[+T]` in [Chapter 9](part0181.html#5CJLQ0-921a8f8dca2a47ea817d3e6755fa0e84),
    *Using Powerful Functional Constructs.* Let''s talk a bit about the `Try[+T]`
    type*.* We will start with the signature:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`Try`构造函数，并将逻辑作为参数传递。在成功的情况下，我们响应为`Some(value)`，在失败的情况下，我们返回`None`。两者都运行良好，因为它们都是`Option`类型的子类型。我们已经在[第9章](part0181.html#5CJLQ0-921a8f8dca2a47ea817d3e6755fa0e84)中看到了`Option[+T]`，*使用强大的函数式构造函数*。让我们简单谈谈`Try[+T]`类型。我们将从签名开始：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that we are comfortable working with parameterized types, it will be easier
    for us to understand the signature of `Try`*.* A couple of things to notice are
    the `Success` and `Failure` subtypes—no need to explain what they are here for.
    Let's take a look at the companion object of the type `Try`, which has an `apply`
    method, as discussed already. It expects a `by-name` parameter. Our famous `try...
    catch` block is taking care of the rest of the stuff.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了工作与参数化类型，理解`Try`的签名将更容易。要注意的两点是`Success`和`Failure`子类型——这里不需要解释它们在这里的作用。让我们看看`Try`类型的伴随对象，它有一个`apply`方法，正如之前讨论的那样。它期望一个`by-name`参数。我们著名的`try...
    catch`块正在处理其余的事情。
- en: 'That''s one of the ways you may want to change the function signature to handle
    exceptions and work as it says it''s going to work. Let''s talk about a scenario
    where we might want to pipeline a few operations—in other words, we want to perform
    functional composition. Take a look at the following function definitions:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你可能想要更改函数签名以处理异常并按其所说的那样工作的方法之一。让我们谈谈一个我们可能想要管道化几个操作的场景——换句话说，我们想要执行函数式组合。看看以下函数定义：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Seeing these two functions, it seems they can be pipelined together to perform
    logic in one go. But how? We can pass an account ID to our `getAccountInfo` function,
    which in turn returns an optional `AccountInfo`. We can take this account info
    and the amount and call `makeTransaction` to make a transaction. These two operations
    look good enough to be composed together, but the only problem we have is that
    the first one''s output is optional, and so the second function might or might
    not get called. So for this, the `flatMap` operation looks good. So let''s try
    that:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 看到这两个函数，它们似乎可以一起流水线化执行逻辑。但是如何实现呢？我们可以向我们的`getAccountInfo`函数传递一个账户ID，该函数随后返回一个可选的`AccountInfo`。我们可以使用这个账户信息和金额调用`makeTransaction`来执行交易。这两个操作看起来足够好，可以组合在一起，但我们唯一的问题是第一个操作的输出是可选的，因此第二个函数可能被调用也可能不被调用。所以对于这个问题，`flatMap`操作看起来是个不错的选择。那么让我们试试看：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following is the result:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下就是结果：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we take a look at the preceding code, we can see that our `getAccountInfo`
    and `makeTransaction` functions return optional values and either of these results
    can be `None`*.* It will be hard for us to know which operation went wrong as
    there's no good error message that tells us what went wrong. So to conclude, `Option`
    is a way to handle such scenarios, but it would have been better if we had a way
    of knowing what went wrong. For that purpose, we can use another construct from
    Scala, named `Either`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下前面的代码，我们可以看到我们的`getAccountInfo`和`makeTransaction`函数返回可选值，这两个结果中的任何一个都可能为`None`*.*
    由于没有好的错误信息告诉我们出了什么问题，所以很难知道哪个操作出了错。所以总结一下，`Option`是一种处理此类场景的方法，但如果我们能知道出了什么问题会更好。为此，我们可以使用Scala的另一个结构，名为`Either`。
- en: Either left or right
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 左或右
- en: 'Scala has an `Either[+A, +B]` type for us. But before we talk about `Either`,
    let''s use it. We''ll refactor our code with the `Either` type:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Scala为我们提供了一个`Either[+A, +B]`类型。但在我们谈论`Either`之前，让我们先使用它。我们将使用`Either`类型重构我们的代码：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following is the result:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下就是结果：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding code, we knew things might go wrong with the conversion from
    a `string` to an `int`. So the result can be either an exception or the intended
    integer. So we tried to do the same: we used the `Either` type with the left value
    as a `String` message when things go wrong, and an `Int` as the right value. Why
    so? Let''s take a look at the signature of the `Either` type to understand that:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们知道从`string`到`int`的转换可能会出错。所以结果可能是一个异常或预期的整数。所以我们尝试做同样的事情：我们使用`Either`类型，当出错时左值是一个`String`消息，而右值是一个`Int`。为什么这样做呢？让我们看一下`Either`类型的签名来理解这一点：
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'From the preceding signatures, we can see that the `Either` type takes two
    type parameters, `A` and `B`; by convention, we think of the `Left` value as the
    exceptional case value and the right value as the intended resulting value. That''s
    the reason we declared the response type as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的签名中，我们可以看到`Either`类型接受两个类型参数，`A`和`B`；按照惯例，我们认为`Left`值是异常情况值，而右值是预期的结果值。这就是为什么我们声明响应类型如下：
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This states that we expect either a `String` or an `Int` value. So the use
    case is clear. We got to know what happened with our operation—that is, the conversion
    from a string to the corresponding integer value. Now, why don''t we go ahead
    and try to do some function composition using the `Either` type? We can use the
    same scenario for this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示我们期望得到一个`String`或`Int`值。所以用例很清楚。我们知道了我们的操作发生了什么——即从字符串到相应整数的转换。现在，为什么我们不尝试使用`Either`类型进行一些函数组合呢？我们可以用同样的场景来做这件事：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following is the result:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下就是结果：
- en: '[PRE18]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is interesting. This new construct made our life easier and gave us meaningful
    messages about the failures. We're also now able to recognize what went wrong,
    as well as when things went wrong.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有趣。这个新的结构让我们的生活变得更简单，并给我们提供了关于失败的有意义的信息。现在我们也能识别出哪里出了问题，以及何时出了问题。
- en: We can see that `Either` helps us better in dealing with exceptions. Also, we've
    seen a couple of ways that we can deal with exceptional cases. What's the take
    away from the discussion? Let's conclude.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`Either`帮助我们更好地处理异常。我们也看到了几种处理异常情况的方法。这次讨论的收获是什么？让我们总结一下。
- en: We've seen a few of the constructs available for us to handle exceptional scenarios
    in Scala programs. You may argue that one of the constructs, `Try[+T]`, does nothing
    but use a *`try... catch` block to handle exceptions. So the response we have
    for the argument is in terms of *functional composition.* The reason you may want
    to go for `scala.util.Try[+T]` instead of a normal `try... catch` block is for
    reasons of functional composition*.**
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一些在Scala程序中处理异常场景的构造。你可能认为其中一个构造`Try[+T]`除了使用一个*`try... catch`块来处理异常之外，没有做什么。所以我们对这个论点的回应是关于*函数组合*的。你可能会选择使用`scala.util.Try[+T]`而不是普通的`try...
    catch`块，原因在于函数组合*。**
- en: '*The type provides us some functions, such as `map` for transformation and
    `flatMap` for composition, so that we can combine two operations together using
    the `flatMap` operation. If you''re wondering what this is, let me tell you that
    we have already seen examples of this. We wanted to compose two functions together
    to get the result using the `flatMap` method, which was possible only because
    our types `Try`*,* `Option`, and `Either` had this crazy-looking function named
    `flatMap`*.* It''s worth taking a look at the implementation of the `flatMap`
    method. This `flatMap` function for `Option` might look as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个类型提供了一些函数，例如`map`用于转换和`flatMap`用于组合，这样我们就可以使用`flatMap`操作将两个操作组合在一起。如果你想知道这是什么，让我告诉你，我们已经看到了这个例子。我们想要使用`flatMap`方法将两个函数组合起来得到结果，这之所以可能，仅仅是因为我们的类型`Try`*、*`Option`和`Either`有这个看起来很疯狂的功能`flatMap`*。看看`flatMap`方法的实现是值得的。这个`Option`的`flatMap`函数可能看起来如下：'
- en: '[PRE19]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: According to the signature, we're going to pass `Option[A]`. The `A` argument
    here is nothing but a type parameter and a function of the form `A => Option[B]`,
    and the definition is going to give us back the type `Option[B]`. That's powerful,
    and helps us in composing the two functions together. That's one of the reasons
    you might want to go for `Option`/`Either`/`Try` constructs. Which of the three
    is going to be used depends upon the use case. The `Either` type gives you the
    convenience of returning a message when things go wrong.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 根据签名，我们将传递`Option[A]`。这里的`A`参数不过是一个类型参数和一个形式为`A => Option[B]`的函数，定义将返回类型`Option[B]`。这很强大，并帮助我们组合这两个函数。这就是你可能想要选择`Option`/`Either`/`Try`构造的原因之一。三个中哪一个将被使用取决于用例。`Either`类型在你出错时提供了返回消息的便利。
- en: So that explains how we might want to handle exceptions in our Scala programs.
    Now let's go ahead and talk about a concept that Scala provides to let you do
    stuff implicitly. Let's talk about implicits in Scala.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就解释了我们在Scala程序中如何处理异常。现在让我们继续讨论Scala提供的一个概念，让你能够隐式地做事情。让我们来谈谈Scala中的隐式参数。
- en: Implicits - what and why
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式参数 - 什么是隐式参数以及为什么
- en: What are *implicits*? When we talk about implicits, we mean implicit parameters
    or conversions that happen implicitly. Implicit parameters are the ones that come
    along with a keyword, `implicit`, and we don't have to explicitly pass an argument
    for these parameters if they were in Scope. Let's see how.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是*隐式参数*？当我们谈论隐式参数时，我们指的是隐式参数或隐式转换。隐式参数是与关键字`implicit`一起出现的参数，如果这些参数在作用域内，我们不需要显式传递这些参数的参数。让我们看看它是如何工作的。
- en: 'Let''s take an example, and create a `Future` value. A `Future` is nothing
    but a computation (that we provide) that''s going to happen at a later point in
    time. It means a computation that''s going to happen in the future. We''ll talk
    about `Future` values in depth when we discuss concurrent programming techniques
    in [Chapter 13](part0240.html#74S700-921a8f8dca2a47ea817d3e6755fa0e84), *Concurrent
    Programming in Scala.* Let''s write a code snippet for now:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个例子，并创建一个`Future`值。`Future`不过是我们提供的将在未来某个时间点发生的计算。这意味着一个将在未来发生的计算。当我们讨论第13章中的并发编程技术时，我们将深入讨论`Future`值，*Scala中的并发编程*。现在我们先写一个代码片段：
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The Scala compiler greets us with two compilation errors. The first one says
    that it wasn''t able to find an implicit value of the `ExecutionContext` type*.*
    Okay, we don''t know what this `ExecutionContext` is, for now. Let''s look at
    the next error. It says `not enough arguments for method apply: (implicit executor:
    ExecutionContext) scala.concurrent.Future[Int]`*.*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 'Scala编译器给我们带来了两个编译错误。第一个错误说它找不到`ExecutionContext`类型的隐式值*.* 好的，我们现在还不知道`ExecutionContext`是什么。让我们看看下一个错误。它说`方法apply的参数不足：`(implicit
    executor: ExecutionContext) scala.concurrent.Future[Int]`*.*'
- en: 'Now, we''ve got this idea that there''s an argument that is needed that''s
    not available to our code. Let''s take a look at the `Future` block''s `apply`
    method for that:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个想法，即有一个需要但对我们代码不可用的参数。让我们看看`Future`块的`apply`方法来解决这个问题：
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Okay, this seems interesting. We''ve got this `implicit` keyword for the parameter
    `ExecutionContext`. It means that it''s okay to call the `Future` block''s `apply`
    method; the only thing we need to take care of is the implicit value of the type
    declared. So things should work fine if somehow we can get the value of type `ExecutionContext`
    available into our scope. What do we mean by scope? Let''s think of the current
    compilation unit (Scala file) as the scope, for now. So let''s do this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这似乎很有趣。我们为参数`ExecutionContext`提供了一个`implicit`关键字。这意味着调用`Future`块的`apply`方法是允许的；我们唯一需要关注的是声明类型的隐式值。所以，如果我们能以某种方式将`ExecutionContext`类型的值引入我们的作用域，事情应该会顺利。我们所说的作用域是什么意思呢？让我们暂时将当前的编译单元（Scala文件）视为作用域。那么，让我们这样做：
- en: '[PRE23]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following is the result:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果是：
- en: '[PRE24]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We''ve declared an `implicit` value named `ctx` of the type `ExecutionContext`*,*
    and then tried to run the application again, and magically things worked fine.
    We didn''t pass any context explicitly or do something extraordinary—we''ve just
    brought the value of the desired type into scope and things worked. We''ve got
    the results. One thing to note, though, is that we''ve used this `implicit` keyword*;*
    that''s the reason `Future.apply` was able to infer the value available in scope.
    If we tried this without the `implicit` keyword, we''d get similar compilation
    errors to those that we had previously. So the idea is to get an implicit value
    in scope, and now we know what''s implicit. There''s a big question though: why
    would you want to have this kind of behavior? We''re going to have a healthy discussion
    regarding this idea.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个名为`ctx`的`implicit`值，其类型为`ExecutionContext`，然后再次尝试运行应用程序，神奇的是一切正常。我们没有明确传递任何上下文或做任何特别的事情——我们只是将所需类型的值引入了作用域，事情就顺利了。我们得到了结果。不过，有一点需要注意，那就是我们使用了这个`implicit`关键字；这就是为什么`Future.apply`能够推断出作用域中可用的值。如果我们没有使用`implicit`关键字尝试这样做，我们会得到与之前类似的编译错误。所以，我们的想法是在作用域中获取一个隐式值，现在我们知道什么是隐式了。不过，有一个大问题：你为什么想要这种行为呢？我们将就这个想法进行一次有益的讨论。
- en: 'Let''s start with the idea that implicits in Scala can be used to automate
    the process of passing a value to an operation or conversion from one type to
    another type. Let''s talk about the first one: implicit parameters.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从这样的想法开始，即Scala中的隐式可以用来自动化将值传递给操作或从一种类型到另一种类型的转换的过程。让我们先谈谈第一个：隐式参数。
- en: Implicit parameters
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式参数
- en: We use implicit parameters when we want the compiler to help us find a value
    that's already available for a certain type. We've just seen an example of an
    implicit parameter when we talked about `Future`. Why don't we define something
    similar for ourselves?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要编译器帮助我们找到一个已经为某种类型可用的值时，我们会使用隐式参数。当我们谈论`Future`时，我们已经看到了一个隐式参数的例子。为什么我们不为自己定义一个类似的东西呢？
- en: 'We can think of a scenario where we need to show the present date in our application
    and we want to avoid passing a date''s instance explicitly again and again. Instead,
    we can make the `LocalDateTime.now` value implicit to the respective functions
    and let the current date and time be passed as an implicit parameter to them.
    Let''s write some code for this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象一个场景，我们需要在我们的应用程序中显示当前日期，并且我们希望避免再次明确传递日期实例。相反，我们可以使`LocalDateTime.now`值对相应的函数是隐式的，让当前日期和时间作为隐式参数传递给它们。让我们为这个写一些代码：
- en: '[PRE25]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following is the result:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果是：
- en: '[PRE26]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Think of the `showDateTime` function as the one that needs the date-time's current
    value—hence it's possible for us to make it available as an implicit one. That's
    what we did—in the definition of `showDateTime`*,* we declared an implicit parameter
    named `date` of the type `LocalDateTime`*.*  We also have an implicit value named
    `dateNow` in scope. That's why we didn't have to pass an argument at the call
    site  and things still worked out good for us.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 将`showDateTime`函数视为需要日期和时间当前值的函数——因此，我们可以将其作为隐式值提供。这就是我们做的——在`showDateTime`的定义中，我们声明了一个名为`date`的隐式参数，其类型为`LocalDateTime`。我们还有一个名为`dateNow`的隐式值在作用域中。这就是为什么我们不需要在调用点传递参数，事情仍然对我们很顺利。
- en: This seems a good use case. You can make your desired values automatically available
    for yourself using *implicits.*
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎是一个很好的用例。你可以使用*隐式*来使你需要的值自动对你自己可用。
- en: The implicitly method
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式方法
- en: 'Scala''s standard library provides a utility method to create concrete instances
    of types'' availability implicitly. The method''s name is also `implicitly`*.*
    Let''s take a look at the function signature:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Scala的标准库提供了一个创建类型具体实例的实用方法，该方法的名称也是`implicitly`*.* 让我们看看函数签名：
- en: '[PRE27]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This `implicitly` method simply expects a type parameter, finds the implicit
    value available in scope, and summons and returns it to us. This is a good option
    available to us to tell whether a particular type''s value is available in implicit
    scope. Let''s look at an application of this method:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`implicitly`方法只期望一个类型参数，找到作用域中可用的隐式值，并召唤并返回它给我们。这是我们用来判断特定类型的值是否在隐式作用域中可用的一个好选项。让我们看看这个方法的一个应用：
- en: '[PRE28]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following is the result:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果是：
- en: '[PRE29]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: So this is how we can use the `implicit` parameter in our definitions and make
    them available to respective scopes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这就是我们如何在定义中使用`implicit`参数，并使它们在相应的范围内可用。
- en: With some idea about implicits now, let's take a look at *implicit conversions.*
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对隐式转换有了些了解，让我们来看看*隐式转换*。
- en: Implicit conversions
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式转换
- en: 'The Standard Scala FAQ page describes implicit conversions as: *"*If one calls
    a method `m` on an object `o` of a class `C` and that class `C` does not support
    method `m`, then Scala compiler will look for an implicit conversion from `C`
    type to something that does support `m` method*"*.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 标准Scala FAQ页面将隐式转换描述为：“*如果在对象`o`的类`C`上调用方法`m`，而该类`C`不支持方法`m`，那么Scala编译器将寻找从`C`类型到支持`m`方法的类型的隐式转换*”。
- en: 'The idea is clear: it''s a synthetic behavior (using a method) that we''re
    forcing on instances of a particular type, and these behaviors (methods) aren''t
    a part of the defined type. It''s like we have a library with certain functionalities
    already available and we want to give some add-on functionality to a certain type
    from the library. Think about it—this is powerful. Having the ability to add on
    a functionality for a particular type is itself powerful. And that''s what implicits
    let us do. We''ll try our hand at something like the following.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 理念很清晰：这是一种合成行为（使用方法），我们正在强制应用于特定类型的实例，而这些行为（方法）并不是定义类型的一部分。这就像我们有一个具有某些功能的库，我们希望向库中的某个类型添加一些附加功能。想想看——这是强大的。能够为特定类型添加功能本身就是强大的。这正是隐式转换让我们做到的。我们将尝试做一些类似以下的事情。
- en: 'First, think of a scenario where we want to create some syntax methods. We
    have a few methods available for the date-time library `java.time.LocalDate` that
    can help us add or subtract days/weeks/months/years, and those methods are:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，考虑一个我们需要创建一些语法方法的场景。我们有一些可用于日期时间库`java.time.LocalDate`的方法，可以帮助我们添加或减去天数/周数/月数/年数，这些方法包括：
- en: '[PRE30]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: What we would like to have is a simple + or - for days/weeks/months/years to
    work as the `plusXXX` or  methods. What are all the options we have to achieve
    such a syntax?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望有一个简单的加号（+）或减号（-）用于表示天数/周数/月数/年数，以便它们能像`plusXXX`或`minusXXX`方法一样工作。我们有哪些选项可以实现这样的语法？
- en: 'One of the options is to create a `Wrapper` class over `LocalDate`*,* such
    as a `CustomDate(date: LocalDate)`, and define these methods for it. In that case,
    the code might look like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '其中一个选项是在`LocalDate`上创建一个`Wrapper`类，例如`CustomDate(date: LocalDate)`，并为它定义这些方法。在这种情况下，代码可能看起来像这样：'
- en: '[PRE31]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As you might have noticed in the preceding code, we have a `CustomDate` class wrapping
    over the type `LocalDate`, and are using the `LocalDate` type''s methods to define
    our own desired syntax methods. Let''s try using it. For this, we can create another
    object extending `App` trait:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的代码中所注意到的，我们有一个`CustomDate`类封装了`LocalDate`类型，并使用`LocalDate`类型的这些方法来定义我们自己的期望语法方法。让我们尝试使用它。为此，我们可以创建另一个扩展`App`特质的对象：
- en: '[PRE32]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following is the result:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果是：
- en: '[PRE33]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For this, we''re going to create an implicit class that takes nothing but a
    `val` of the type `LocalDate`*,* then similar logic to provide all of our syntax
    methods. Afterwards, we''ll bring that implicit class in scope by importing it.
    Let''s write that:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将创建一个隐式类，它只接受一个`val`类型的`LocalDate`*，然后使用类似的逻辑提供我们所有的语法方法。之后，我们将通过导入它来将这个隐式类引入作用域。让我们写下这个：
- en: '[PRE34]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, it's time to use the same in our `BeautifulDateApp` class*:*
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候在我们的`BeautifulDateApp`类中使用它了*：
- en: '[PRE35]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following is the result:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果是：
- en: '[PRE36]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We can see the difference in the two approaches we took. The second one seems
    the more native approach. As consumers of these syntax methods, we never tried
    to call the `CustomDate` class—rather, we created an instance of the `LocalDate`
    type*:*
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们采取的两种方法之间的区别。第二种方法似乎更符合本地方法。作为这些语法方法的消费者，我们从未尝试调用`CustomDate`类——相反，我们创建了一个`LocalDate`类型的实例*：*
- en: '[PRE37]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We used `+` and `-` like native methods defined in the `LocalDate` class. That's
    the power, or let's say magic, of *implicit conversions.* For those who want to
    know what happened in the background, let's look at the workings of the code in
    more detail.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`+`和`-`，就像在`LocalDate`类中定义的本地方法一样。这就是力量，或者说魔法，在于*隐式转换*。对于那些想知道幕后发生了什么的人来说，让我们更详细地看看代码的工作原理。
- en: 'The Scala compiler saw this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Scala编译器看到了以下内容：
- en: '[PRE38]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The compiler then tried to look for a method named `+` that takes a day as a
    parameter in the `LocalDate` class. It's not surprising that the compiler wasn't
    able to find such a method there, hence it tried to check whether there was any
    other class available in the implicit scope that is expecting a `LocalDate` and
    that was performing operations such as `+` with a day/week/month/year*.* Then,
    the compiler found our `CustomDate` implicit class. Finally, implicit conversion
    took place and this particular method call worked for us. We were then able to
    make such method syntax hacks possible.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，编译器试图在`LocalDate`类中寻找一个名为`+`的方法，该方法接受一个日期作为参数。编译器无法在那里找到这样的方法并不奇怪，因此它试图检查是否在隐式作用域中存在任何其他类，该类期望一个`LocalDate`，并且执行了诸如`+`这样的操作（日期/周/月/年）。然后，编译器找到了我们的`CustomDate`隐式类。最后，发生了隐式转换，这个特定的方法调用对我们有效。然后我们能够使这样的方法语法黑客成为可能。
- en: Now that we've seen such an example, one question that we might want to ask
    ourselves is what do we mean by *implicit scope?* We also need to see how the
    Scala compiler searches for implicit values. Let's try to get an answer to this.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了这样的例子，我们可能想要问自己一个问题：我们所说的*隐式作用域*是什么意思？我们还需要了解Scala编译器如何搜索隐式值。让我们尝试找到这个答案。
- en: Looking for implicits
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找隐式值
- en: 'Your usual application Scala code might contain some constructs that import
    other classes and objects, or it might also inherit other classes. You write methods
    that expect types as parameters and also declare parameters. So when the Scala
    compiler looks for an implicit value, where should it start looking for such a
    value? The compiler starts to look for an implicit value according to the following
    criteria:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您的常规Scala应用程序代码可能包含一些导入其他类和对象的构造，或者它也可能继承其他类。您编写的方法期望类型作为参数，并声明参数。因此，当Scala编译器寻找隐式值时，它应该在何处开始寻找这样的值？编译器开始根据以下标准寻找隐式值：
- en: Defined in current scope
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在当前作用域中定义
- en: Explicitly imported
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确导入
- en: Imported using wildcards
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用通配符导入
- en: Companion object of a type
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型伴生对象
- en: Implicit scope of an argument's type
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数类型的隐式作用域
- en: Implicit scope of type arguments
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型参数的隐式作用域
- en: Outer objects for nested types
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套类型的外部对象
- en: 'We know that if we define an implicit value in the current scope (block of
    code), it gets the highest precedence. Afterwards, you can also import it using
    an `import` statement, as shown in the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，如果我们当前作用域（代码块）中定义了一个隐式值，它将获得最高的优先级。之后，您也可以使用`import`语句导入它，如下面的代码所示：
- en: '[PRE39]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following is the result:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果是：
- en: '[PRE40]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'A wildcard import can also work for this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通配符导入也可以适用于此：
- en: '[PRE41]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'But life''s a bit uncomfortable for the compiler, as well as us, when it sees
    two implicit values eligible for the same type in the same scope. What we then
    see is a compilation error stating `ambiguous implicits`*.* Let''s try that:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当编译器看到同一作用域中存在两个适用于相同类型的隐式值时，生活和我们都感到有些不舒服。然后我们看到的是一个编译错误，指出存在`歧义隐式值`*。让我们试试看：
- en: '[PRE42]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'For the preceding code, we''ll face this compilation error:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面的代码，我们将面临以下编译错误：
- en: '[PRE43]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: So, we need to take care of the implicit value's ambiguity.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要注意隐式值的歧义。
- en: 'If the compiler isn''t able to find the implicit value in the current block
    of code or via imports, it searches for it in companion objects of the type. That''s
    how the compiler searches for implicit values. The standard Scala documentation
    explains the topic of finding implicits, which you can find at: [http://docs.scala-lang.org/tutorials/FAQ/finding-implicits.html](http://docs.scala-lang.org/tutorials/FAQ/finding-implicits.html).'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编译器无法在当前代码块或通过导入中找到隐式值，它将在类型的伴生对象中搜索它。这就是编译器搜索隐式值的方式。标准的 Scala 文档解释了查找隐式的主题，你可以在[http://docs.scala-lang.org/tutorials/FAQ/finding-implicits.html](http://docs.scala-lang.org/tutorials/FAQ/finding-implicits.html)找到它。
- en: With this discussion of implicits, we've seen few ways in which we can use the
    concept and let the magic work for us. It's widely used by library designers when
    they define type-classes and make their instances available via implicit values.
    We've covered what type classes are, and we can create one on our own. Let's try
    that.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对隐式的讨论，我们看到了我们可以使用这个概念并让魔法为我们工作的几种方式。当库设计者在定义类型类并通过隐式值提供它们的实例时，这被广泛使用。我们已经涵盖了类型类是什么，并且我们可以自己创建一个。让我们试试：
- en: Type-classes ahead!
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来是类型类！
- en: 'When creating type-classes to solve problems, such as providing a mechanism
    to encode types in a particular format, we have to unleash the power of languages
    such as Scala. What we desire is a way to encode values of a certain type in **comma-separated
    value** (**CSV**) format. For that purpose, we''ll create a type-class named `CSVEncoder`.
    In Scala, we can do this using a trait of some type by convention:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建类型类来解决像为特定格式提供编码类型机制这样的问题时，我们必须释放像 Scala 这样的语言的力量。我们想要的编码特定类型值的逗号分隔值（CSV）格式的方法。为此，我们将创建一个名为
    `CSVEncoder` 的类型类。在 Scala 中，我们可以通过使用某种类型的 trait 来做这件事：
- en: '[PRE44]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'What we defined is a functionality provider for our types. The functionality
    right now is to encode a value of some particular type and give back a list of
    string values that we can represent in CSV. Now, you might want to use this functionality
    by calling some functions on it, right? For a simple type such as `Person`, it
    can look like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的是一个为我们类型提供功能的功能提供者。目前的功能是将特定类型的值编码并返回一个我们可以表示为 CSV 的字符串值列表。现在，你可能想通过调用一些函数来使用这个功能，对吧？对于像
    `Person` 这样的简单类型，它可以看起来像这样：
- en: '[PRE45]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Some other syntax might look like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他的语法可能看起来像这样：
- en: '[PRE46]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To use something like these, what we need is this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用类似这些的东西，我们需要的是这个：
- en: A way to encode the type `Person` in CSV format
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种将 `Person` 类型编码为 CSV 格式的方法
- en: The utility function `toCSV`
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实用函数 `toCSV`
- en: 'Let''s define the ways our type-class-provided functionality can be used:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义我们的类型类提供的功能可以使用的方法：
- en: '[PRE47]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, we have defined a companion object for `CSVEncoder` and defined our utility
    function named `toCSV`, which takes a type parameter and sequence of values of
    the same type, except that it expects an implicit `CSVEncoder` instance for the
    same type. What it returns in turn is a `List[String]`*.* We know it's easy to
    convert a sequence of string values in CSV. The definition is something that we
    want from this function. Hence, we simply call `encoder.encode(value)` and convert
    the values in comma-separated format.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为 `CSVEncoder` 定义了一个伴生对象，并定义了一个名为 `toCSV` 的实用函数，它接受一个类型参数和相同类型的值序列，除了它期望一个相同类型的隐式
    `CSVEncoder` 实例。它返回的是一个 `List[String]`*.* 我们知道将字符串值序列转换为 CSV 很容易。这就是我们从这个函数中想要的东西。因此，我们简单地调用
    `encoder.encode(value)` 并将值转换为逗号分隔的格式。
- en: 'Now, let''s define a way to encode the `Person` type:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一种编码 `Person` 类型的方法：
- en: '[PRE48]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the preceding code, we provided a way to encode our `Person` type. Now,
    let''s use it:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们提供了一种编码我们的 `Person` 类型的方法。现在，让我们来使用它：
- en: '[PRE49]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The following is the result:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下就是结果：
- en: '[PRE50]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'What we did here in our `EncoderApp` is import `CSVEncoder[Person]` implicitly
    and call a `toCSV` function with the expected value. Calling this function gives
    us the desired result*.* We can now hack the `toCSV` function syntax using an
    implicit class and give the consumer of our type-class another way of using our
    encoder. Let''s do that:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `EncoderApp` 中，我们隐式地导入了 `CSVEncoder[Person]` 并调用一个带有预期值的 `toCSV` 函数。调用这个函数会给我们期望的结果*.*
    我们现在可以使用隐式类来修改 `toCSV` 函数的语法，并为我们的类型类的消费者提供另一种使用我们的编码器的方式。让我们这么做：
- en: '[PRE51]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The following is the result:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下就是结果：
- en: '[PRE52]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We achieved this syntax call using the implicit `CSVEncoderExt` class, which
    was the approach we took in the case of the syntax methods for `LocalDate`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用隐式 `CSVEncoderExt` 类实现了这种语法调用，这是我们为 `LocalDate` 的语法方法所采取的方法：
- en: '[PRE54]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: All we had to do was take care that this particular class was in the scope at
    the call site, so we imported it. This is how we have created and used our first
    type-class. It wasn't that hard, was it? Sure, we have covered enough about type-classes
    in this chapter. Let's go ahead and summarize what we've learned in this chapter.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所需要做的就是确保这个特定的类在调用点的作用域内，所以我们导入了它。这就是我们创建和使用我们的第一个类型类的方式。这并不难，对吧？当然，我们已经在本章中足够详细地介绍了类型类。让我们继续总结本章我们所学的知识。
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: First, we discussed exceptional cases that occur when we try programming. We
    saw how we handle these exceptional cases in functional programming. We even tried
    exception handling in functional composition. Then, we began to see the magic
    that implicits bring in Scala. We discussed implicit parameters and then *implicit
    conversion.* We saw the `implicitly` method, provided by the Scala standard library.
    Finally, we talked about the already much-talked-about type-classes, and defined/used
    our first one. Once you practice enough with the concepts that we have discussed,
    it's worth going through type-classes in detail. Most of the Scala libraries'
    frameworks heavily use this concept.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们讨论了在尝试编程时出现的异常情况。我们看到了在函数式编程中如何处理这些异常情况。我们甚至在函数组合中尝试了异常处理。然后，我们开始看到Scala中隐式带来的魔法。我们讨论了隐式参数和*隐式转换*。我们看到了由Scala标准库提供的`implicitly`方法。最后，我们谈论了已经讨论得很多的类型类，并定义/使用了我们的第一个类型类。一旦你足够多地练习了我们讨论的概念，详细学习类型类是值得的。Scala的大多数库框架都大量使用了这个概念。
- en: In the next chapter, we'll learn about the Akka toolkit. We'll cover *Actor
    System*, one of Akka's offerings, and much more.*
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习Akka工具包。我们将涵盖Akka提供的一项服务，即*Actor系统*，以及更多内容。
