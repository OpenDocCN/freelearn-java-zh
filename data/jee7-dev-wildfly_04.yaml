- en: Chapter 4. Learning Context and Dependency Injection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。学习上下文和依赖注入
- en: We saw that [Chapter 3](part0023_split_000.html#page "Chapter 3. Introducing
    Java EE 7 – EJBs"), *Introducing Java EE 7 – EJBs*, was challenging since we had
    to cover lots of ground, including Java Enterprise enhancements and a Maven-specific
    configuration. In this chapter, we'll discuss **Contexts and Dependency Injection**
    (**CDI**), which was added to the Java EE specification in Java EE 6 (starting
    from JSR 299). It provides several benefits to Java EE developers that were missing,
    such as allowing any JavaBean to be used as a JSF managed bean, including stateless
    and stateful session beans. You can find more information on CDI and the newest
    version of the specification itself (JSR 346) at [http://www.cdi-spec.org/](http://www.cdi-spec.org/).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，[第3章](part0023_split_000.html#page "第3章。介绍Java EE 7 – EJBs")，“介绍Java EE
    7 – EJBs”，由于我们必须涵盖大量的内容，包括Java企业增强和Maven特定的配置，因此具有挑战性。在本章中，我们将讨论**上下文和依赖注入**（**CDI**），它在Java
    EE 6（从JSR 299开始）中添加到Java EE规范中。它为Java EE开发者提供了许多缺失的好处，例如允许任何JavaBean作为JSF管理Bean使用，包括无状态和有状态会话Bean。你可以在[http://www.cdi-spec.org/](http://www.cdi-spec.org/)上找到有关CDI和规范最新版本（JSR
    346）的更多信息。
- en: 'Some of the topics that will be covered in this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖的一些主题如下：
- en: What Contexts and Dependency Injection is and how it relates to EJB
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文和依赖注入是什么以及它与EJB的关系
- en: How to rewrite our ticket-booking example to use the CDI and JavaServer Faces
    technology
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何重写我们的票务预订示例以使用CDI和JavaServer Faces技术
- en: How to run the project using Maven
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Maven运行项目
- en: This chapter assumes familiarity with **JavaServer Faces** (**JSF**), which
    will be used to provide a graphical interface for our applications. If you are
    looking for a start up guide for JSF, there are several excellent resources available
    online, including the relevant sections in the official Java EE 7 tutorial at
    [http://docs.oracle.com/javaee/7/tutorial/doc/jsf-develop.htm#BNATX](http://docs.oracle.com/javaee/7/tutorial/doc/jsf-develop.htm#BNATX).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设读者熟悉**JavaServer Faces**（**JSF**），它将被用来为我们提供图形界面。如果你正在寻找JSF的入门指南，网上有多个优秀的资源，包括官方Java
    EE 7教程中的相关部分[http://docs.oracle.com/javaee/7/tutorial/doc/jsf-develop.htm#BNATX](http://docs.oracle.com/javaee/7/tutorial/doc/jsf-develop.htm#BNATX)。
- en: Introducing Contexts and Dependency Injection
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍上下文和依赖注入
- en: CDI for the Java EE platform introduces a standard set of component management
    services to the Java EE platform. As a component of Java EE 7, CDI is in many
    ways a standardization of concepts that have been brewing in Spring for a long
    time, such as dependency injection and interceptors. In fact, CDI and Spring 3
    share many similar features. There are also other dependency injection frameworks
    available for developers that are more lightweight and easier to use in a Java
    SE environment. **Google Guice** ([https://github.com/google/guice](https://github.com/google/guice))
    is a notable example. Providing full-blown support for the CDI container in a
    standalone Java SE application and separation from the application server are
    one of the goals of the upcoming CDI 2.0 specification. This will allow developers
    to use a common programming model on both client and server sides.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: CDI（上下文和依赖注入）对于Java EE平台引入了一套标准的组件管理服务。作为Java EE 7的一个组成部分，CDI在许多方面是对Spring中长时间酝酿的概念的标准化，例如依赖注入和拦截器。实际上，CDI和Spring
    3共享许多相似的功能。对于开发者来说，也有其他更轻量级且在Java SE环境中更容易使用的依赖注入框架。**Google Guice** ([https://github.com/google/guice](https://github.com/google/guice))
    是一个显著的例子。为独立的Java SE应用程序提供对CDI容器的全面支持，并从应用服务器中分离出来，是即将到来的CDI 2.0规范的目标之一。这将允许开发者在使用客户端和服务器两端的通用编程模型。
- en: CDI lets you decouple concerns by what it refers to as loose coupling and strong
    typing. In doing so, it provides an almost liberating escape from the banalities
    of everyday Java programming, allowing injections of its objects and controlling
    their lifetimes.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: CDI通过所谓的松耦合和强类型来解耦关注点。这样做，它几乎提供了一种从日常Java编程的平凡中解放出来的感觉，允许注入其对象并控制它们的生命周期。
- en: Tip
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Why is CDI required for Java EE?**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么CDI对Java EE是必需的？**'
- en: If you have been programming with Java EE 5, you might argue that it already
    features resources injection of resources. However, this kind of injection can
    be used only for resources known to the container (for example, `@EJB`, `@PersistenceContext`,
    `@PersistenceUnit`, and `@Resource`). CDI, on the other hand, provides a general-purpose
    dependency injection scheme, which can be used for any component.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Java EE 5进行编程，你可能会争辩说它已经具有资源注入的功能。然而，这种注入只能用于容器已知的资源（例如，`@EJB`、`@PersistenceContext`、`@PersistenceUnit`和`@Resource`）。另一方面，CDI提供了一种通用的依赖注入方案，它可以用于任何组件。
- en: The CDI elementary unit is still the bean. Compared to EJBs, CDI features a
    different, more flexible kind of bean, which would often be a good place to put
    your business logic in. One of the most important differences between the two
    approaches is that CDI Beans are **contextual**; that is, they live in a well-defined
    scope.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: CDI的基本单元仍然是Bean。与EJB相比，CDI具有不同、更灵活的Bean类型，这通常是放置业务逻辑的好地方。这两种方法之间最重要的区别之一是CDI
    Bean是**上下文相关的**；也就是说，它们存在于一个定义良好的作用域中。
- en: 'Consider the following code snippet:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, the injected EJB proxy (let's just assume that it is a POJO class annotated
    with a `@Stateless` annotation) just points to a pool of stateless instances (or
    a single bean instance for stateful beans). There is no automatic association
    between the HTTP request or HTTP session and a given EJB instance.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，注入的EJB代理（让我们假设它是一个带有`@Stateless`注解的POJO类）仅指向一个无状态实例池（或对于有状态的Bean，是一个单个Bean实例）。HTTP请求或HTTP会话与给定的EJB实例之间没有自动关联。
- en: 'The opposite is true for CDI Beans, which live in well-defined scopes. For
    example, the following CDI Bean lives in `RequestScoped`; that is, it will be
    destroyed at the end of the request:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CDI Bean来说，情况正好相反，它们存在于定义良好的作用域中。例如，以下CDI Bean存在于`RequestScoped`中；也就是说，它将在请求结束时被销毁：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding CDI Bean can be safely injected into our former servlet; at the
    end of an HTTP session or HTTP request, all the instances associated with this
    scope are automatically destroyed, and thus, garbage collected:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的CDI Bean可以安全地注入到我们之前的servlet中；在HTTP会话或HTTP请求结束时，所有与这个作用域相关的实例都会自动销毁，从而进行垃圾回收：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Named beans
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名Bean
- en: 'In the earlier section, we came across the `@Named` annotation. Named beans
    allow us to easily inject our beans into other classes that depend on them and
    refer to them from JSF pages via the **Unified Expression Language** (**UEL**).
    Recall the earlier example:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们遇到了`@Named`注解。命名Bean允许我们轻松地将我们的Bean注入到依赖它们的其他类中，并通过**统一表达式语言**（**UEL**）从JSF页面中引用它们。回想一下前面的例子：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This class, decorated with the `@Named` annotation, can then be referenced
    from a JSF page:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类，被`@Named`注解装饰，然后可以从JSF页面中引用：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: By default, the name of the bean will be the class name with its first letter
    switched to lowercase; thus, the `Customer` bean can be referred to as `customer`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Bean的名称将是类名，其首字母转换为小写；因此，`Customer` Bean可以被称为`customer`。
- en: 'If you want to use a different naming policy for your bean, you could use the
    `@Named` annotation as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想为你的Bean使用不同的命名策略，你可以像下面这样使用`@Named`注解：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This way, we will be able to reference our CDI Beans using the identified `customNamed`
    value.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们将能够使用指定的`customNamed`值来引用我们的CDI Bean。
- en: Instead of two `@RequestScoped` and `@Named` annotations, we can just use the
    `@Model` annotation that aggregates them.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以不用两个`@RequestScoped`和`@Named`注解，而只需使用聚合它们的`@Model`注解。
- en: CDI scopes
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CDI作用域
- en: 'CDI Beans come with a set of predefined scopes and annotations, and each CDI
    Bean has a distinct life cycle determined by the scope it belongs to. The following
    table describes the built-in CDI scopes and annotations required to set these
    scopes:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: CDI Bean附带一组预定义的作用域和注解，每个CDI Bean都有由其所属的作用域确定的独特生命周期。以下表格描述了内置的CDI作用域和设置这些作用域所需的注解：
- en: '| Scope | Description |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 作用域 | 描述 |'
- en: '| --- | --- |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `@RequestScoped` | The `@RequestScoped` beans are shared during the length
    of a single request. This could be an HTTP request, a remote EJB invocation, a
    web services invocation, or message delivered to a Message Driven Bean (MDB).
    These beans are destroyed at the end of the request. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `@RequestScoped` | `@RequestScoped` Bean在单个请求的长度内共享。这可能是一个HTTP请求、远程EJB调用、Web服务调用，或者发送到消息驱动Bean（MDB）的消息。这些Bean在请求结束时被销毁。
    |'
- en: '| `@ConversationScoped` | The `@ConversationScoped` beans are shared across
    multiple requests in the same HTTP session but only if there is an active conversation
    maintained. Conversations are supported for JSF requests through the `javax.enterprise.context.Conversation`
    bean. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `@ConversationScoped` | `@ConversationScoped`作用域的Bean在同一个HTTP会话中的多个请求间共享，但仅当存在一个活跃的会话时。通过`javax.enterprise.context.Conversation`
    Bean支持JSF请求的会话。|'
- en: '| `@SessionScoped` | The `@SessionScoped` beans are shared between all the
    requests that occur in the same HTTP session and destroyed when the session is
    destroyed. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `@SessionScoped` | `@SessionScoped`作用域的Bean在同一个HTTP会话中的所有请求间共享，并在会话销毁时被销毁。|'
- en: '| `@ApplicationScoped` | An `@ApplicationScoped` bean will live for as long
    as the application is running and be destroyed when the application is shut down.
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `@ApplicationScoped` | `@ApplicationScoped`作用域的Bean将在应用程序运行期间存在，并在应用程序关闭时被销毁。|'
- en: '| `@Dependent` | The `@Dependent` beans are never shared between injection
    points. Any injection of a dependent bean is a new instance whose life cycle is
    bound to the life cycle of the object it is being injected into. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `@Dependent` | `@Dependent`作用域的Bean永远不会在注入点之间共享。任何对依赖Bean的注入都是一个新实例，其生命周期绑定到被注入的对象的生命周期。|'
- en: 'Other parts of Java EE can extend the list of available scopes. In Java EE
    7 (in the Java Transaction API specification), a new scope has been introduced:
    `@TransactionScoped`. It bounds the life cycle of a bean with the current transaction.
    It is of course possible to introduce your own custom scopes.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 其他Java EE部分可以扩展可用作用域的列表。在Java EE 7（Java事务API规范）中，引入了一个新的作用域：`@TransactionScoped`。它将Bean的生命周期与当前事务绑定。当然，也可以引入自己的自定义作用域。
- en: In this chapter example, we will use the `RequestScoped` and `SessionScoped`
    beans to drive our simple ticket-booking system. In the next chapter, we will
    further enhance our example using `ConversationScoped` beans, which are a peculiar
    scope of CDI Beans. Providing a detailed explanation of all the named beans scopes
    is beyond the scope of this book. However, you can quench your thirst for knowledge
    by having a look at CDI Reference Implementation (JBoss Weld) docs at [http://docs.jboss.org/weld/reference/latest/en-US/html/scopescontexts.html](http://docs.jboss.org/weld/reference/latest/en-US/html/scopescontexts.html).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的示例中，我们将使用`RequestScoped`和`SessionScoped` Bean来驱动我们的简单票务预订系统。在下一章中，我们将使用`ConversationScoped`
    Bean进一步增强我们的示例，这些Bean是CDI Bean的一个特殊作用域。对所有命名Bean作用域的详细解释超出了本书的范围。然而，您可以通过查看CDI参考实现（JBoss
    Weld）文档来满足您对知识的渴望，文档地址为[http://docs.jboss.org/weld/reference/latest/en-US/html/scopescontexts.html](http://docs.jboss.org/weld/reference/latest/en-US/html/scopescontexts.html)。
- en: WildFly CDI implementation
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WildFly CDI实现
- en: Weld is the CDI Reference Implementation that originated as part of the Seam
    3 project ([http://www.seamframework.org/](http://www.seamframework.org/)). Weld
    provides a complete CDI implementation, which can be a part of a Java EE 7 container
    such as WildFly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Weld是CDI参考实现，最初作为Seam 3项目的一部分([http://www.seamframework.org/](http://www.seamframework.org/))。Weld提供了一个完整的CDI实现，它可以成为Java
    EE 7容器（如WildFly）的一部分。
- en: 'Therefore, in order to run CDI-based applications on WildFly, you don''t need
    to download any extra libraries as Weld is part of the server modules, and it
    is included in all server configurations as stated by the following extension:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了在WildFly上运行基于CDI的应用程序，您不需要下载任何额外的库，因为Weld是服务器模块的一部分，并且如以下扩展所述，它包含在所有服务器配置中。
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Having your module installed, however, does not mean that you can blindly use
    it in your applications. The general rule is that on WildFly, every application
    module is isolated from other modules; this means, by default, it does not have
    visibility on the AS modules, nor do the AS modules have visibility on the application.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，安装了您的模块并不意味着您可以在应用程序中盲目使用它。一般规则是，在WildFly上，每个应用程序模块都是与其他模块隔离的；这意味着默认情况下，它对AS模块没有可见性，AS模块对应用程序也没有可见性。
- en: 'To be accurate, we could state that all WildFly modules fall into the following
    three categories:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准确起见，我们可以将所有WildFly模块分为以下三个类别：
- en: '**Modules that are implicitly added to your applications**: This category includes
    the most common APIs such as `javax.activation`, `javax.annotation`, `javax.security`,
    `javax.transaction`, `javax.jms`, and `javax.xml`. Using these modules does not
    require any extra effort as WildFly will add them for you if you are referencing
    them in your application.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐式添加到您的应用程序中的模块**：此类别包括最常用的API，如`javax.activation`、`javax.annotation`、`javax.security`、`javax.transaction`、`javax.jms`和`javax.xml`。使用这些模块不需要额外的工作，因为如果您的应用程序中引用了它们，WildFly会自动为您添加它们。'
- en: '**Modules that are added on conditions**: This category includes `javax.ejb`,
    `org.jboss.resteasy` and `org.hibernate`, `org.jboss.as.web`, and finally `org.jboss.as.weld`.
    All these modules will be added on the condition that you supply its core annotations
    (such as `@Stateless` for EJB) or its core configuration files, for example, `web.xml`
    for a web application.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**根据条件添加的模块**：此类别包括`javax.ejb`、`org.jboss.resteasy`、`org.hibernate`、`org.jboss.as.web`以及最后的`org.jboss.as.weld`。所有这些模块将在您提供其核心注解（例如EJB的`@Stateless`）或其核心配置文件（例如Web应用程序的`web.xml`）的条件下添加。'
- en: '**Modules that need to be explicitly enabled by the application deployer**:
    This includes all other modules, such as your custom modules, that you can add
    to the application server. The simplest way to allow you to have visibility to
    these modules is adding an explicit dependency to your `META-INF/MANIFEST.MF`
    file. For example, if you want to trigger the **log4j** dependency, you have to
    code your manifest file as follows:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**需要由应用程序部署者显式启用的模块**：这包括所有其他模块，例如您的自定义模块，您可以将其添加到应用程序服务器中。允许您查看这些模块的最简单方法是向您的`META-INF/MANIFEST.MF`文件添加一个显式依赖项。例如，如果您想触发**log4j**依赖项，您必须按照以下方式编写您的清单文件：'
- en: '[PRE7]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There is also a custom descriptor file available, which is used by WildFly to
    resolve dependencies – `jboss-deployment-structure.xml`. It allows the developer
    to configure the required dependencies in a fine-grained matter. The file is placed
    in the top-level deployment file, in the `META-INF` directory (or `WEB-INF` for
    a web archive). A sample content of the XML file (along with the XSD schema) is
    available at [https://docs.jboss.org/author/display/WFLY8/Class+Loading+in+WildFly](https://docs.jboss.org/author/display/WFLY8/Class+Loading+in+WildFly).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个自定义描述符文件可用，WildFly 使用该文件来解析依赖关系——`jboss-deployment-structure.xml`。它允许开发者以细粒度的方式配置所需的依赖项。该文件位于顶级部署文件中的`META-INF`目录（或Web存档的`WEB-INF`目录）。XML文件的示例内容（以及XSD模式）可在[https://docs.jboss.org/author/display/WFLY8/Class+Loading+in+WildFly](https://docs.jboss.org/author/display/WFLY8/Class+Loading+in+WildFly)找到。
- en: 'So, if you have followed our checklist carefully, you will be aware that in
    order to let Weld libraries kick in and automatically discover your CDI beans,
    you should add its core configuration file, which is `beans.xml`. This file can
    be placed in your application at the following locations:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您仔细遵循了我们的清单，您将知道为了让Weld库启动并自动发现您的CDI Bean，您应该添加其核心配置文件，即`beans.xml`。此文件可以放置在您的应用程序中的以下位置：
- en: In your `WEB-INF` folder if you are developing a web application
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您正在开发Web应用程序，请将其放置在`WEB-INF`文件夹中
- en: In your `META-INF` folder if you are deploying a JAR archive
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您正在部署JAR存档，请将其放置在`META-INF`文件夹中
- en: 'The `beans.xml` file is based on the following schema reference:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`beans.xml`文件基于以下模式引用：'
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: However, it is perfectly legal to place an empty `beans.xml` file in the correct
    location; if you do so, CDI will be enabled in your application. If you, however,
    do not place a `beans.xml` file, then only an annotated subset of classes will
    be considered as beans. In such a case, the container will create beans only for
    classes that are annotated with CDI-related annotations and ignore the rest. Most
    of the times, this is not the behavior we expect, and it differs from the default
    mode in Java EE 6 (when the `beans.xml` file was required).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在正确的位置放置一个空的`beans.xml`文件是完全合法的；如果您这样做，CDI将在您的应用程序中启用。如果您没有放置`beans.xml`文件，那么只有被标注为Bean的类子集将被考虑。在这种情况下，容器只为带有CDI相关注解的类创建Bean，并忽略其他类。大多数情况下，这不是我们期望的行为，并且与Java
    EE 6的默认模式（当时需要`beans.xml`文件）不同。
- en: You might have noticed that the `bean-discovery-mode` attribute is set to `all`
    in our `beans.xml` file. This allows us to configure the CDI discovery mode we
    discussed in the previous paragraph. It states that every legible class in our
    archive will be treated as a managed bean. You can place a `@Vetoed` annotation
    on a class to filter it out from the bean discovery process. It is also possible
    to set the discovery mode to `annotated` so that you can place a scope annotation
    for every class that you would like to use as a bean. This is the default value
    of the newest CDI version (also when there is no `beans.xml`), so be sure to set
    it on for all our samples.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，在 `beans.xml` 文件中，`bean-discovery-mode` 属性被设置为 `all`。这允许我们配置上一段中讨论的
    CDI 发现模式。它表示我们存档中的每个可读类都将被视为一个托管 Bean。您可以在一个类上放置一个 `@Vetoed` 注解来将其从 Bean 发现过程中过滤掉。也可以将发现模式设置为
    `annotated`，这样您就可以为每个您希望用作 Bean 的类放置一个作用域注解。这是最新 CDI 版本的默认值（在没有 `beans.xml` 的情况下也是如此），所以请确保在我们的所有示例中都将其设置为开启。
- en: Rethinking your ticketing system
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新思考您的票务系统
- en: Once you have learned the basics of CDI, we will start re-engineering the ticket-booking
    system using CDI Beans wherever necessary. We will turn it into a leaner application
    by dropping a few items such as remote interfaces or asynchronous methods, which
    are not needed in this example. By doing this, you will be able to focus just
    on the components that are actually used in the web application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您学会了 CDI 的基础知识，我们将开始使用 CDI Bean 重新设计票务预订系统。我们将通过删除一些不需要的项，如远程接口或异步方法，将其转变为一个更精简的应用程序。通过这样做，您将能够专注于
    Web 应用程序中实际使用的组件。
- en: 'Let''s create a new Maven project, just as we did in the previous chapter:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的 Maven 项目，就像我们在上一章所做的那样：
- en: From the **File** menu, go to **New** | **Maven Project**; follow the wizard
    as we did previously (remember to check the **Create a simple project** option).
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **文件** 菜单，转到 **新建** | **Maven 项目**；按照我们之前的方式遵循向导（记得勾选 **创建一个简单项目** 选项）。
- en: On the next screen, enter `com.packtpub.wflydevelopment.chapter4` as **Group
    Id**, `ticket-agency-cdi` as **Artifact Id**, and set packaging to **war**:![Rethinking
    your ticketing system](img/00040.jpeg)
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏中，输入 `com.packtpub.wflydevelopment.chapter4` 作为 **Group Id**，`ticket-agency-cdi`
    作为 **Artifact Id**，并将打包设置为 **war**：![重新思考您的票务系统](img/00040.jpeg)
- en: Click on **Finish**. The Maven plugin for Eclipse will generate a project structure
    for you that you know from the previous chapter.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **完成**。Eclipse 的 Maven 插件将为您生成一个您在上一章中熟悉的项目结构。
- en: The only difference is that besides the standard `java` (for Java classes) and
    `resources` (for configuration files) folders, a new directory named `webapp`
    that will host the web application views.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 唯一的不同之处在于，除了标准的 `java`（用于 Java 类）和 `resources`（用于配置文件）文件夹外，还有一个名为 `webapp` 的新目录，它将托管
    Web 应用程序的视图。
- en: Adding the required dependencies
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加所需的依赖项
- en: 'In order to compile and run the project, our Maven''s `pom.xml` file will require
    the following set of dependencies known from the previous chapter:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编译和运行项目，我们的 Maven 的 `pom.xml` 文件将需要上一章中已知的一组依赖项：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will also require two plugins from the previous chapter (note that we changed
    the extension of the filename from `jar` to `war`):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将需要上一章中的两个插件（注意我们将文件扩展名从 `jar` 改为了 `war`）：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In case you have any problems with the `POM` configuration file, be sure that
    you check the source code attached to this book and the material from the previous
    chapter.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在 `POM` 配置文件中遇到任何问题，请确保您检查这本书附带的源代码以及上一章的材料。
- en: Creating the beans
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Bean
- en: 'Once your project is properly configured, we can start modeling our beans.
    The first bean we will upgrade is `TheatreBooker`, which will drive the user session,
    accessing the ticket list from our `TheatreBox` bean:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的项目配置正确，我们就可以开始建模我们的 Bean。我们将首先升级的 Bean 是 `TheatreBooker`，它将驱动用户会话，从我们的 `TheatreBox`
    Bean 访问票务列表：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, the bean has been tagged as `Named [1]`, which means that it
    can be directly referenced in our JSF pages. The bean is `SessionScoped [2]` since
    it stores the amount of money available to the customer during its session.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，该 Bean 已被标记为 `Named [1]`，这意味着它可以直接在我们的 JSF 页面中引用。该 Bean 是 `SessionScoped
    [2]`，因为它在其会话期间存储客户可用的金额。
- en: We would also like to inject `logger [3]` and `FacesContextFacexContexts [5]`
    instead of manually defining it. To do this, we will need to register a bean that
    produces loggers, which are parameterized with the name of the class. We will
    cover this process of producing beans in a moment.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望注入`logger [3]`和`FacesContextFacexContexts [5]`，而不是手动定义它们。为此，我们需要注册一个生成日志记录器的Bean，这些日志记录器以类的名称作为参数。我们将在稍后介绍生成Bean的过程。
- en: Finally, notice that we can safely inject EJBs into our CDI Beans using the
    `Inject [4]` annotation. Also, the reverse is perfectly legal, that is, injecting
    CDI Beans into EJBs.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，我们可以安全地使用`Inject [4]`注解将EJB注入我们的CDI Bean中。同样，反向注入也是完全合法的，即，将CDI Bean注入EJB中。
- en: Compared to our earlier project, here we don't raise Java exceptions when the
    customer is not able to afford a ticket. Since the application is web based, we
    simply display a warning message to the client using `JSF Faces Messages [6]`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们早期的项目相比，当客户无法负担票价时，我们这里不会抛出Java异常。由于应用程序是基于Web的，我们只需使用`JSF Faces Messages
    [6]`向客户端显示警告消息。
- en: 'The other bean that we still use in our application is `TheatreInfo`, which
    has been moved to the `controller` package as it will actually provide the application
    with the list of available seats:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在应用程序中仍然使用的另一个Bean是`TheatreInfo`，它已被移动到`controller`包中，因为它实际上会为应用程序提供可用座位的列表：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'At first, have a look at the `@Model` annotation `[1]`, which is an alias (we
    call this kind of annotations **stereotypes**) for two commonly used annotations:
    `@Named` and `@RequestScoped`. Therefore, this bean will be named into our JSF
    page and will carry a request scope.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，看看`@Model`注解[1]，它是对两个常用注解`@Named`和`@RequestScoped`的别名（我们称这种注解为**类型化注解**）。因此，此Bean将被命名为我们的JSF页面，并将携带请求作用域。
- en: Next, pay attention to the `getSeats` method. This method returns a list of
    seats, exposing it as a `producer` method `[2]`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，注意`getSeats`方法。此方法返回一个座位列表，将其作为`producer`方法[2]公开。
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `producer` method allows you to have control over the production of the
    dependency objects. As a Java factory pattern, they can be used as a source of
    objects whose implementation may vary at runtime or if the object requires some
    custom initialization that is not to be performed in the constructor.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`producer`方法允许您控制依赖对象的生成。作为一个Java工厂模式，它们可以用作对象源，其实现在运行时可能不同，或者如果对象需要一些不在构造函数中执行的定制初始化。'
- en: It can be used to provide any kind of concrete class implementation; however,
    it is especially useful to inject Java EE resources into your application.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以用来提供任何类型的具体类实现；然而，它特别适用于将Java EE资源注入您的应用程序。
- en: One advantage of using a `@Producer` annotation for the `getSeats` method is
    that its objects can be exposed directly via JSF's **Expression Language** (**EL**),
    as we will see in a minute.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@Producer`注解为`getSeats`方法的一个优点是，其对象可以直接通过JSF的**表达式语言**（**EL**）公开，正如我们稍后将看到的。
- en: Finally, another feature of CDI that was unleashed in this example is the **observer**.
    An observer, as the name suggests, can be used to observe events. An observer
    method is notified whenever an object is created, removed, or updated. In our
    example, it allows the list of seats to be refreshed whenever they are needed.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，CDI在此示例中释放的另一个特性是**观察者**。正如其名所示，观察者可以用来观察事件。每当创建、删除或更新对象时，观察者方法都会被通知。在我们的示例中，它允许在需要时刷新座位列表。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To be precise, in our example, we are using a conditional observer that is denoted
    by the expression `notifyObserver = Reception.IF_EXISTS`. This means that in practice,
    the `observer` method is only called if an instance of the component already exists.
    If not specified, the default option (`ALWAYS`) will be that the observer method
    is always called. (If an instance doesn't exist, it will be created.)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，在我们的示例中，我们使用了一个条件观察者，表示为表达式`notifyObserver = Reception.IF_EXISTS`。这意味着在实践中，只有当组件的实例已经存在时，才会调用`observer`方法。如果没有指定，默认选项（`ALWAYS`）将是观察者方法始终被调用。（如果不存在实例，它将被创建。）
- en: In the newest CDI version, it is possible to get additional information about
    the fired event in the observer by adding an `EventMetadata` parameter to the
    observer's method.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在最新的CDI版本中，通过向观察者的方法添加`EventMetadata`参数，可以在观察者中获取有关已触发事件的额外信息。
- en: 'Whenever a change in our list of seats occurs, we will use the `javax.enterprise.event.Event`
    object to notify the observer about the changes. This will be done in our singleton
    bean, which gets injected with the seat''s event `[1]`, and notifies the observer
    by firing the event when a seat is booked `[2]`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们的座位列表发生变化时，我们将使用`javax.enterprise.event.Event`对象来通知观察者关于这些变化。这将在我们的单例Bean中完成，该Bean注入了座位的`[1]`事件，并在座位预订时通过触发事件来通知观察者`[2]`：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Earlier, we mentioned that a preconfigured logger should be injected to a bean
    if it requests it. We will create a simple logger producer that will use the information
    about the injection point (the bean that requests a logger) to configure an instance:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们提到，如果Bean请求，应该向其注入一个预配置的记录器。我们将创建一个简单的记录器生产者，它将使用注入点（请求记录器的Bean）的信息来配置一个实例：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We also allowed the injection of `FacesContext` instead of using the standard
    `FacesContext.getCurrentInstance()` static method. This context is used, for example,
    to display the stated error messages:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还允许注入`FacesContext`而不是使用标准的`FacesContext.getCurrentInstance()`静态方法。此上下文用于，例如，显示指定的错误消息：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The last class we will include in our project is the `Seat` bean, known from
    the previous chapter, which will be used as our model without any change (remember
    to include it in your project with a proper package).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在项目中包含的最后一个类是`Seat`实体，正如前一章所提到的，它将作为我们的模型使用，无需任何修改（请记住，使用适当的包将其包含在你的项目中）。
- en: Building the view
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建视图
- en: Once we have coded the server side of our example, creating the front end will
    be quite easy, as we have made all our resources available through CDI Beans.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们编码了示例的服务器端，创建前端将相当容易，因为我们已经通过CDI Beans提供了所有资源。
- en: One notable difference between some of the earlier editions of this book is
    that **Facelets** are now the preferred view technology for JSF. Earlier versions
    of JSF used **JavaServer Pages** (**JSP**) as their default view technology. As
    JSP technology predates JSF, using JSP with JSF sometimes felt unnatural or created
    problems. For example, the life cycle of JSPs is different from the life cycle
    of JSF.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书的一些早期版本相比，一个显著的不同之处在于**Facelets**现在是JSF的首选视图技术。JSF的早期版本使用**JavaServer Pages**（**JSP**）作为它们的默认视图技术。由于JSP技术在JSF之前，使用JSP与JSF有时感觉不自然或造成问题。例如，JSP的生命周期与JSF的生命周期不同。
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Compared to the simpler request-response paradigm on which the JSP life cycle
    is based, the JSF life cycle is much more complex since the core of JSF is the
    MVC pattern, which has several implications. User actions in JSF-generated views
    take place in a client that does not have a permanent connection to the server.
    The delivery of user actions or page events is delayed until a new connection
    is established. The JSF life cycle must handle this delay between event and event
    processing. Also, the JSF life cycle must ensure that the view is correct before
    rendering it, and also that the JSF system includes a phase to validate inputs
    and another to update the model only after all the inputs pass validation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与JSP生命周期所基于的更简单的请求-响应范式相比，JSF生命周期要复杂得多，因为JSF的核心是MVC模式，这有几个含义。在JSF生成的视图中，用户操作发生在没有与服务器建立永久连接的客户端。用户操作或页面事件的传递将延迟，直到建立新的连接。JSF生命周期必须处理事件和事件处理之间的延迟。此外，JSF生命周期必须确保在渲染之前视图是正确的，并且JSF系统包括一个阶段来验证输入，并在所有输入通过验证后更新模型。
- en: Most of the time Facelets are used to build JavaServer Faces views using HTML-style
    templates and component trees. Templating is a useful feature available with Facelets
    that allows you to create a page that will act as the template for the other pages
    in an application (something like Struts Tiles). The idea is to obtain portions
    of reusable code without repeating the same code on different pages.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，Facelets用于使用HTML风格的模板和组件树构建JavaServer Faces视图。模板是Facelets提供的一个有用功能，允许你创建一个将作为应用程序中其他页面模板的页面（类似于Struts
    Tiles）。想法是获取可重用代码的部分，而无需在不同的页面上重复相同的代码。
- en: So here's the main application structure that contains a template page named
    `default.xhtml` that is referenced by views in the template attribute of the page's
    composition element. The template contains two main HTML `div` elements that will
    be used to contain the main application panel (`content`) and a footer div (`footer`),
    which will barely output the application title.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里的主要应用程序结构包含一个名为 `default.xhtml` 的模板页面，该页面通过页面组成元素的模板属性被视图引用。模板包含两个主要的 HTML
    `div` 元素，将用于包含主要应用程序面板（`content`）和一个页脚 `div`（`footer`），它几乎只输出应用程序标题。
- en: 'In order to add the template at first, add a new JSF page to the `WEB-INF/templates`
    folder of your application and name it `default.xhtml`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了首先添加模板，将一个新的 JSF 页面添加到您的应用程序的 `WEB-INF/templates` 文件夹中，并将其命名为 `default.xhtml`：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we will add the main page view, which will be embedded into your template.
    For this purpose, add a JSF page named `index.xhtml` to the `webapp` folder of
    your Maven project:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加主页面视图，它将被嵌入到您的模板中。为此，将一个名为 `index.xhtml` 的 JSF 页面添加到您的 Maven 项目的 `webapp`
    文件夹中：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `ui:composition` element is a templating tag that wraps content to be included
    in another Facelet. Specifically, it will be included in the `default.xhtml[1]`
    template.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`ui:composition` 元素是一个模板标签，它将内容包装以包含在另一个 Facelet 中。具体来说，它将被包含在 `default.xhtml[1]`
    模板中。'
- en: The creation of the view is done in three steps. First, we will display the
    customer's money `[2]`, which is bound to the session variable called `money`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 视图的创建分为三个步骤。首先，我们将显示客户的金钱 `[2]`，它绑定到名为 `money` 的会话变量。
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice how we directly reference CDI Beans (for example, `TheatreBooker`) from
    JSF expressions, just as we used to do with JSF Managed Beans.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何直接从 JSF 表达式中引用 CDI Bean（例如，`TheatreBooker`），就像我们过去使用 JSF 管理Bean一样。
- en: The next thing on the checklist is printing all JSF messages `[3]` that are
    meant to be produced by the application via the `messages` element.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 清单上的下一件事是打印所有由应用程序通过 `messages` 元素产生的 JSF 消息 `[3]`。
- en: The main task of this view is to produce a view of all tickets and let the users
    purchase them. This is achieved by means of a `dataTable` object `[3]`that can
    be used to produce a tabular list of objects, which are generally stored as `java.util.List`
    in your beans.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图的主要任务是生成所有票务的视图，并允许用户购买它们。这是通过一个 `dataTable` 对象 `[3]` 实现的，它可以用来生成对象的表格列表，这些对象通常存储在您的
    beans 中的 `java.util.List`。
- en: 'Pay attention to the value attribute of the `dataTable` object:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `dataTable` 对象的值属性：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this case, we don''t directly reference a CDI Bean, but we reference an
    object that has been produced by a CDI Bean. To be precise, it has been produced
    by `TheatreInfo` that, as we have seen, has a `@Produces` and `@Named` annotation
    on our list of seats:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不是直接引用 CDI Bean，而是引用一个由 CDI Bean 生成的对象。更准确地说，它是由 `TheatreInfo` 生成的，正如我们所看到的，它在我们座位列表上有
    `@Produces` 和 `@Named` 注解：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This `dataTable` object will be displayed only if it contains some data in it
    (as dictated by the `not empty seats` EL expression). In one of the `dataTable`
    columns, we have added `commandButton [4]` that will be used to book the seat
    displayed on that row. Notice one of the JSF 2 goodies here, as we call the `bookSeat`
    method of `TheatreBooker` passing an argument as one parameter, which is the `seatId`
    field.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当 `dataTable` 对象中包含一些数据时（如 `not empty seats` EL 表达式所规定的），它才会显示。在 `dataTable`
    的一个列中，我们添加了一个 `commandButton [4]`，它将用于预订显示在该行上的座位。注意这里的一个 JSF 2 精美之处，因为我们通过传递一个参数（即
    `seatId` 字段）调用 `TheatreBooker` 的 `bookSeat` 方法。
- en: JSF 2 facet suggestions
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: JSF 2 面板建议
- en: By enabling JSF 2 facets on your project configuration, you can enjoy some additional
    benefits while designing your views.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在您的项目配置中启用 JSF 2 面板，您可以在设计视图时享受一些额外的优势。
- en: 'Enabling JSF 2 project facets takes half a minute. Right-click on your project
    and navigate to **Properties** | **Project Facets**. Then, select the **JSF 2.2
    Project facets** checkbox and click on the **OK** button:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 JSF 2 项目面板需要半分钟。右键单击您的项目，导航到 **属性** | **项目面板**。然后，选择 **JSF 2.2 项目面板** 复选框，并单击
    **确定** 按钮：
- en: '![JSF 2 facet suggestions](img/00041.jpeg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![JSF 2 面板建议](img/00041.jpeg)'
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Once the JSF facet is enabled, Eclipse will notify you that the JSF library
    configuration is missing; just disable the JSF library configuration that is a
    part of Maven's duty.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启用 JSF 面板，Eclipse 将通知您缺少 JSF 库配置；只需禁用 Maven 负责的 JSF 库配置即可。
- en: Once JSF 2 facets are configured, if you press *Ctrl* + Space bar before referencing
    a field or method, a suggestion pop-up window will let you choose the method or
    attribute of the Bean you want to reference.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置了 JSF 2 角色组件，如果您在引用字段或方法之前按下 *Ctrl* + 空格键，一个建议弹出窗口将允许您选择您想要引用的 Bean 的方法或属性。
- en: Getting ready to run the application
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备运行应用程序
- en: 'OK, now your application is almost ready. We just need to configure a JSF mapping
    in a `web.xml` file as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在您的应用程序几乎准备好了。我们只需要在 `web.xml` 文件中配置一个 JSF 映射，如下所示：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will then run the `FacesServlet` servlet for all the pages at `/faces/*
    url`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这将随后运行 `/faces/*` URL 上所有页面的 `FacesServlet` Servlet。
- en: Finally, as stated previously, in order to activate our `war` file as an explicit
    bean archive, we need to add an empty `beans.xml` file to the `WEB-INF` folder
    of your application.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，正如之前所述，为了激活我们的 `war` 文件作为显式的 Bean 存档，我们需要在应用程序的 `WEB-INF` 文件夹中添加一个空的 `beans.xml`
    文件。
- en: 'So, if you follow the same naming convention used in this chapter, you will
    end up with the following project structure:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您遵循本章中使用的相同命名约定，您将得到以下项目结构：
- en: '![Getting ready to run the application](img/00042.jpeg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![准备运行应用程序](img/00042.jpeg)'
- en: 'At this point, you must be familiar with building and deploying your Maven
    applications using Eclipse or a shell. Assuming that you are managing your application
    from a shell, start by building up the project using the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该已经熟悉了使用 Eclipse 或 shell 构建和部署您的 Maven 应用程序。假设您正在使用 shell 管理您的应用程序，请先使用以下命令构建项目：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Then, publish it using the WildFly Maven plugin, as we did in the previous chapter.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用我们在上一章中使用的 WildFly Maven 插件发布它。
- en: 'If the WildFly server is started, you can execute the following command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 WildFly 服务器已启动，您可以执行以下命令：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If the WildFly server is not started, you can execute the following command
    and then the WildFly Maven plugin will automatically start an instance:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 WildFly 服务器没有启动，您可以执行以下命令，然后 WildFly Maven 插件将自动启动一个实例：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The application will be available at `http://localhost:8080/ticket-agency-cdi`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将在 `http://localhost:8080/ticket-agency-cdi` 上可用。
- en: 'Then, to do this with a unique command, you can execute the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了执行一个独特的命令，您可以执行以下操作：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After so much work, you will be pleased to have your application running on
    your browser:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这么多工作，您将很高兴看到您的应用程序在浏览器上运行：
- en: '![Getting ready to run the application](img/00043.jpeg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![准备运行应用程序](img/00043.jpeg)'
- en: Right now, you will be able to book tickets up to the budget ($ 100) defined
    in your `SessionScoped` bean. So enjoy this first taste of JSF and CDI.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将能够预订预算（$ 100）内定义在您的 `SessionScoped` 实例中的票务。所以，享受 JSF 和 CDI 的第一次尝试吧。
- en: Of course, in this chapter, we only scratched the surface of JSF features. There
    is also a new higher-level approach introduced in JSF 2.2 that can be used for
    flow-based scenarios such as a shopping cart. The new feature is called **FacesFlow**
    and comes with a `@FlowScoped` annotation. However, we will now focus on adding
    some other features to our current application.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在本章中，我们只是对 JSF 特性进行了初步探讨。JSF 2.2 中还引入了一种新的高级方法，可用于基于流程的场景，例如购物车。这个新特性被称为
    **FacesFlow**，并附带一个 `@FlowScoped` 注解。然而，我们现在将专注于向我们的当前应用程序添加一些其他功能。
- en: Combining the scheduler into our application
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将调度器集成到我们的应用程序中
- en: Up to now, we have not included the scheduler, which was in charge of simulating
    other customer-requesting tickets, into our application. This was not an oversight;
    as a matter of fact, introducing an external system in a web application poses
    some challenges. For example, what if the scheduler updates some data used by
    the application? How will the user know it?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有将负责模拟其他客户请求票务的调度器包含到我们的应用程序中。这并不是疏忽；实际上，在 Web 应用程序中引入外部系统会带来一些挑战。例如，如果调度器更新了应用程序使用的一些数据，用户将如何得知？
- en: There are several strategies to address this requirement; however, they all
    boil down to using some intelligence in your client application. For example,
    if you are familiar with web scripting languages, you can use the popular jQuery
    API to poll the server for some updates. The newest version of JSF 2.2 comes with
    great support for HTML5 and JavaScript frameworks, thanks to the custom data attributes
    and pass-through elements. These are simple mechanisms that allow the JSF's render
    kit to render parts of the page without any further changes so that custom tags
    may be interpreted by the browser (or a JavaScript framework).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种策略可以解决这个需求；然而，它们都归结为在您的客户端应用程序中使用一些智能。例如，如果您熟悉网络脚本语言，您可以使用流行的jQuery API轮询服务器以获取一些更新。JSF
    2.2的最新版本对HTML5和JavaScript框架提供了很好的支持，这要归功于自定义数据属性和透传元素。这些是简单的机制，允许JSF的渲染套件渲染页面的一部分而无需任何进一步更改，以便自定义标签可以被浏览器（或JavaScript框架）解释。
- en: Since not all Java EE developers might be skilled in JavaScript, we would rather
    show a simple and effective way to fulfill our requirement using **RichFaces**
    libraries ([http://www.jboss.org/richfaces](http://www.jboss.org/richfaces)),
    which provide advanced Ajax support along with a rich set of ready-to-use components.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于并非所有Java EE开发者都擅长JavaScript，我们更愿意展示一种简单而有效的方法来使用**RichFaces**库（[http://www.jboss.org/richfaces](http://www.jboss.org/richfaces)）来满足我们的需求，这些库提供了高级Ajax支持以及一系列现成的组件。
- en: Installing RichFaces
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装RichFaces
- en: Installing RichFaces requires a set of core libraries that are generally available
    at the RichFaces download page.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 安装RichFaces需要一组核心库，这些库通常可在RichFaces下载页面上找到。
- en: 'Additionally, you need to provide a set of third-party dependencies that are
    used by the RichFaces API. Never mind, that''s what Maven is for! Start by adding
    the latest **Bill of Materials** (**BOM**) for the `RichFaces` API in the upper
    dependency-management section:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还需要提供一组由RichFaces API使用的第三方依赖项。没关系，这正是Maven的作用！首先，在上面的依赖管理部分添加`RichFaces`
    API的最新**物料清单**（**BOM**）：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, it''s just a matter of adding the rich UI libraries and the core API:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，只需添加丰富的UI库和核心API：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Making your application rich
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使您的应用程序丰富
- en: 'Once we have installed RichFaces libraries, we will just need to reference
    them on each XHTML page in your project. Here''s the new `index.xhtml` page using
    the RichFaces namespaces:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们安装了RichFaces库，我们只需在项目中的每个XHTML页面上引用它们。以下是使用RichFaces命名空间的新的`index.xhtml`页面：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We have highlighted the core enhancements added to this page. At first, as we
    said, we need to reference the RichFaces libraries at the top of the XHTML page.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经突出显示了添加到本页的核心增强功能。起初，正如我们所说的，我们需要在XHTML页面的顶部引用RichFaces库。
- en: Next, we added a rich Ajax component, **a4j:poll**, which does a simple but
    an effective job of polling the server for updates, allowing the re-rendering
    of our components—`grid` (which contains the main datatable), `poller` (to check
    whether it should still be running), and `bookedCounter`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加了一个丰富的Ajax组件，**a4j:poll**，它通过简单地轮询服务器以获取更新，允许重新渲染我们的组件——`grid`（包含主数据表），`poller`（检查是否应该继续运行），以及`bookedCounter`。
- en: 'Additionally, this component references a CDI bean named `Poller`, which acts
    just as an on/off flag for our poller. We expect to turn off polling as soon as
    all the seats are sold out:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，此组件引用了一个名为`Poller`的CDI Bean，它充当我们的轮询器的开/关标志。我们预计在所有座位售罄后关闭轮询：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Our seller service stays nearly the same as in the previous chapter (the only
    difference is the `logger` injection):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的销售服务与上一章几乎相同（唯一的区别是`logger`注入）：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, we''ll add a booking record, which will be bounded with the current
    view using the view scope. Its role will be to count the number of bookings done
    by the user in the current view (a single browser tab is considered a single view):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加一个预订记录，它将使用视图作用域与当前视图绑定。它的作用是计算用户在当前视图中完成的预订数量（单个浏览器标签页被视为单个视图）：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can experiment with the booked counter by trying to book tickets via two
    separate tabs in your browser.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在浏览器中的两个单独标签页尝试预订票务来实验预订计数器。
- en: 'You might have noticed that we placed two annotations on the bean: `@Named`
    and `@ViewScoped`. If you would like to define multiple beans with a specific
    set of CDI annotations, it would be a good idea to create your own custom annotation
    that already contains the desired ones. This kind of construction is called a
    stereotype. It is possible to incorporate the following elements:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们在豆子上放置了两个注解：`@Named` 和 `@ViewScoped`。如果你想要定义多个带有特定CDI注解的bean，创建一个包含所需注解的自定义注解是个好主意。这种结构被称为模式。可以包含以下元素：
- en: A default scope
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认作用域
- en: Optionally, interceptor bindings
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选，拦截器绑定
- en: Optionally, a `@Named` annotation
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选，一个 `@Named` 注解
- en: Optionally, an `@Alternative` annotation
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选，一个 `@Alternative` 注解
- en: 'To create a stereotype, you need to add the wanted annotations along with the
    `@Stereotype` annotation:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个模式，你需要添加所需的注解以及 `@Stereotype` 注解：
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now you can define the `BookinRecord` bean as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以按照以下方式定义 `BookinRecord` bean：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `@Model` stereotype is available in CDI by default. It defines a request
    scoped named bean, and you can use it on your beans right out of the box.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Model` 模式注解在CDI中默认可用。它定义了一个请求作用域的命名bean，你可以直接在你的bean上使用它。'
- en: Running the application
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'With all the libraries in place, you can now test run your new rich application.
    As you can see, every 30 seconds a ticket is sold out and buttons are turned,
    in real time, into **Not available**:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有库就绪后，你现在可以测试运行你的新丰富应用程序。正如你所见，每30秒就有一张票售罄，按钮实时变为**不可用**：
- en: '![Running the application](img/00044.jpeg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![运行应用程序](img/00044.jpeg)'
- en: Creating interceptors
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建拦截器
- en: 'There is one more CDI feature worth mentioning here, the interceptors. Sometimes,
    applications contain logic and cross-cutting multiple layers; the most simple
    example is logging. Under the Java EE platform, it can be achieved using interceptors.
    First, we need to create a new annotation:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个值得提到的CDI特性，即拦截器。有时，应用程序包含逻辑并跨越多个层；最简单的例子是日志记录。在Java EE平台上，可以使用拦截器来实现。首先，我们需要创建一个新的注解：
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This annotation defines an interceptor binding. It can be used to specify methods
    that you would like to intercept. The bindings can be used on types as well; in
    that case, every method call on that type is intercepted. The most important part
    of this definition is the `@InterceptorBinding [1]` annotation. Be sure to add
    it!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个注解定义了一个拦截器绑定。它可以用来指定你想要拦截的方法。绑定也可以用于类型；在这种情况下，对该类型的每个方法调用都会被拦截。这个定义最重要的部分是
    `@InterceptorBinding [1]` 注解。务必添加它！
- en: 'Then, we have to create the interceptor definition itself:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须创建拦截器定义本身：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We start by stating that our class is `@Interceptor` and it will be using the
    interceptor binding that we've defined earlier (`@Logged [1]`). Next, we create
    a method log that will be executed around every method execution (`@AroundInvoke
    [2]`) on annotated classes. Inside of it, we will call the `context.proceed()`
    method that will basically forward the call to the original receiver. Note that
    the interceptor can decide (based on some security logic, for instance) whether
    the call should be dropped. It could even analyze or change the returned value.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明我们的类是 `@Interceptor`，它将使用我们之前定义的拦截器绑定（`@Logged [1]`）。接下来，我们创建一个名为log的方法，它将在注解类上的每个方法执行（`@AroundInvoke
    [2]`）周围执行。在其中，我们将调用 `context.proceed()` 方法，它基本上会将调用转发到原始接收者。请注意，拦截器可以基于某些安全逻辑（例如）决定是否应该丢弃调用。它甚至可以分析或更改返回值。
- en: 'Finally, we have to enable it in the `beans.xml` file by adding the following
    code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须在 `beans.xml` 文件中启用它，通过添加以下代码：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, let''s move on to just the annotated classes or methods that you want
    to log using the `@Logged` annotation. For instance, refer to the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转到仅使用 `@Logged` 注解来记录的注解类或方法。例如，参考以下内容：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'All calls to the `TheatreBooker` public methods will now be logged in to the
    console:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有对 `TheatreBooker` 公共方法的调用都将记录到控制台：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the case of multiple interceptors, the order in which they are executed is
    determined by the `@Interceptor.Priority` annotation. Interceptors with lowest
    priorities will be called first. Be sure to check the constants defined in the
    `Priority` annotation. Your own interceptor's priorities should be between the
    `APPLICATION` and `LIBRARY_AFTER` scope.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个拦截器的情况下，它们的执行顺序由`@Interceptor.Priority`注解确定。优先级最低的拦截器将被首先调用。请确保检查`Priority`注解中定义的常量。您自己的拦截器的优先级应该在`APPLICATION`和`LIBRARY_AFTER`作用域之间。
- en: 'There are also other interesting CDI mechanisms that we will not cover in this
    book, but are definitely worth exploring: decorators and alternatives. Decorators
    are basically strongly typed interceptors that are focused on the business logic
    of your application. Alternatives can be used to provide alternative implementations
    for specific beans.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些有趣的CDI机制，我们在这本书中不会涉及，但绝对值得探索：装饰器和替代方案。装饰器基本上是强类型拦截器，专注于您应用程序的业务逻辑。替代方案可以用来为特定Bean提供替代实现。
- en: Are EJBs and JSF Managed Beans obsolete?
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EJBs和JSF管理Bean已经过时了吗？
- en: At the end of this chapter, we would like to give our honest opinion about a
    common question posed by developers, that is, how EJB, JSF Managed Beans, and
    CDI interact and where the boundary between them lies. Are there redundancies
    between them? It is indeed a bit confusing since there are now multiple component
    models available in Java EE.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们希望就开发者提出的一个常见问题给出我们诚实的意见，即EJB、JSF管理Bean和CDI如何交互以及它们之间的边界在哪里。它们之间有冗余吗？由于现在Java
    EE中提供了多个组件模型，这确实有点令人困惑。
- en: JSF Managed Beans have been, for a long time, the actual glue between the application
    view and the business methods. Since Release 2.0 of JSF, you can declare JSF Managed
    Beans via an annotation, and the scopes are expanded with a **view scope** and
    the ability to create custom scopes. However, there is very little still going
    on for JSF Managed Beans. Most of its features can be replaced by CDI Beans that
    are much more flexible and allow you to have a better integration with other Java
    EE components. Even the view scope, in the newest version of JSF, has been implemented
    as a CDI custom scope (`javax.faces.view.ViewScoped`), which replaces the old
    `javax.faces.bean.ViewScoped` (notice the name of the package; it's a common mistake
    to mix them up).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: JSF管理Bean长期以来一直是应用程序视图和业务方法之间的实际粘合剂。自从JSF 2.0版本发布以来，您可以通过注解声明JSF管理Bean，并且作用域通过**视图作用域**和创建自定义作用域的能力得到了扩展。然而，对于JSF管理Bean来说，仍然很少有活动。它的大多数功能都可以由CDI
    Bean替代，CDI Bean更加灵活，并允许您更好地与其他Java EE组件集成。即使在JSF最新版本中，视图作用域也被实现为一个CDI自定义作用域（`javax.faces.view.ViewScoped`），这取代了旧的`javax.faces.bean.ViewScoped`（注意包名；这是一个常见的错误，混淆了它们）。
- en: On the other hand, EJBs, even though they use a less flexible injection mechanism,
    still maintain some unique features such as schedulable timers, asynchronous operations,
    and pooling that are essential for throttling and assuring that the application
    provides a good quality of service. Beginning from Java EE 7, EJBs no longer are
    the only components that have a transactional nature. The new `@Transactional`
    annotation allows you to use declarative transactions in CDI beans by simply placing
    it on selected methods.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，尽管EJBs使用的是不太灵活的注入机制，但它们仍然保持了一些独特的功能，如可调度定时器、异步操作和池化，这对于节流和确保应用程序提供良好的服务质量至关重要。从Java
    EE 7开始，EJBs不再是唯一具有事务性的组件。新的`@Transactional`注解允许您通过简单地将它放在选定的方法上，在CDI Bean中使用声明式事务。
- en: Despite this, it's likely that EJBs are not disappearing from our code, rather
    it is likely (and desirable too) that they will continue to be used for some of
    their unique features. For the remaining part though, its functionality will be
    exposed via CDI instead of EJBs' own annotations such as `@Stateless` and `@EJB`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，EJBs可能不会从我们的代码中消失，而是很可能（并且也是所希望的）它们将继续被用于一些独特的功能。然而，对于剩余的部分，其功能将通过CDI而不是EJBs自己的注解（如`@Stateless`和`@EJB`）来公开。
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we provided an introduction to CDI. We covered how JSF pages
    can access CDI-named beans as if they were JSF Managed Beans. We also covered
    how CDI makes it easy to inject dependencies into our code via the `@Inject` annotation.
    Additionally, we explained how we can add another library of the JBoss ecosystem
    (RichFaces) uncovering just one aspect of its potentiality.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了CDI。我们涵盖了JSF页面如何访问CDI命名的bean，就像它们是JSF管理bean一样。我们还介绍了CDI如何通过`@Inject`注解使将依赖项注入我们的代码变得简单。此外，我们还解释了如何添加JBoss生态系统中的另一个库（RichFaces），仅揭露了其潜在性的一方面。
- en: Until now, we have worked with in-memory data, so it's time to introduce storage
    for our CDI applications using the Java Persistence API, which is the theme of
    the next chapter.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在处理内存中的数据，因此现在是时候介绍用于我们的CDI应用程序的存储，即使用Java持久化API，这是下一章的主题。
