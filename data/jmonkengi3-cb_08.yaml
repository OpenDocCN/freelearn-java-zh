- en: Chapter 8. Physics with Bullet
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。使用Bullet的物理
- en: 'This chapter contains the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含以下菜谱：
- en: Creating a pushable door
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可推动的门
- en: Building a rocket engine
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建火箭引擎
- en: Ballistic projectiles and arrows
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹道投射物和箭
- en: Handling multiple gravity sources
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理多个重力源
- en: Self-balancing using RotationalLimitMotors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用旋转限制电机实现自平衡
- en: The principles of a bridge-building game
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建桥游戏的原理
- en: Networked physics
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络物理
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Using physics in games has become very common and accessible, thanks to open
    source physics engines, such as Bullet. jMonkeyEngine supports both the Java-based
    jBullet and native Bullet in a seamless manner.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于开源物理引擎，如Bullet，的使用变得非常普遍和易于访问，游戏中的物理应用已经变得非常普遍。jMonkeyEngine无缝地支持基于Java的jBullet和本地的Bullet。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: jBullet is a Java-based library with JNI bindings to the original Bullet based
    on C++. jMonkeyEngine is supplied with both of these, and they can be used interchangeably
    by replacing the libraries in the classpath. No coding change is required. Use
    `jme3-libraries-physics` for the implementation of jBullet and `jme3-libraries-physics-native`
    for Bullet. In general, Bullet is considered to be faster and is full featured.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: jBullet是一个基于Java的库，具有对基于C++的原始Bullet的JNI绑定。jMonkeyEngine提供了这两个库，并且可以通过替换类路径中的库来互换使用。不需要进行任何编码更改。使用`jme3-libraries-physics`实现jBullet，使用`jme3-libraries-physics-native`实现Bullet。一般来说，Bullet被认为速度更快，功能更全面。
- en: Physics can be used for almost anything in games, from tin cans that can be
    kicked around to character animation systems. In this chapter, we'll try to reflect
    the diversity of these implementations.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 物理学在游戏中几乎可以用于任何事情，从可以被踢来踢去的罐头到角色动画系统。在本章中，我们将尝试反映这些实现的多样性。
- en: All the recipes in this chapter will require you to have a `BulletAppState`
    class in the application. To avoid repetition, the process of doing this is described
    in the *Adding Bullet physics to the application* section in [Appendix](apa.html
    "Appendix A. Information Fragments"), *Information Fragments*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有菜谱都需要你在应用程序中有一个`BulletAppState`类。为了避免重复，这个过程在[附录](apa.html "附录A.信息片段")，*信息片段*中的*将Bullet物理添加到应用程序*部分进行了描述。
- en: Creating a pushable door
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可推动的门
- en: Doors are useful in games. Visually, it is more appealing to not have holes
    in the walls but doors for the players to pass through. Doors can be used to obscure
    the view and hide what's behind them for a surprise later. In extension, they
    can also be used to dynamically hide geometries and increase the performance.
    There is also a gameplay aspect where doors are used to open new areas to the
    player and give a sense of progression.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，门非常有用。从视觉上看，没有洞的墙壁比门更吸引人，玩家可以通过门通过。门可以用来遮挡视线并隐藏后面的东西，以在之后制造惊喜。此外，它们还可以用来动态地隐藏几何形状并提高性能。在游戏玩法方面，门被用来为玩家打开新区域并给人一种进步的感觉。
- en: In this recipe, we will create a door that can be opened by pushing it, using
    a `HingeJoint` class.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个可以通过推来打开的门，使用`HingeJoint`类。
- en: 'This door consists of the following three elements:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这扇门由以下三个元素组成：
- en: '**Door object**: This is a visible object'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**门对象**：这是一个可见对象'
- en: '**Attachment**: This is the fixed end of the joint around which the hinge swings'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接点**：这是铰链旋转的固定端'
- en: '**Hinge**: This defines how the door should move'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**铰链**：这定义了门应该如何移动'
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Simply following the steps in this recipe won't give us anything testable. Since
    the camera has no physics, the door will just sit there and we will have no way
    to push it. If you have made any of the recipes that use the `BetterCharacterControl`
    class, many of them in [Chapter 2](ch02.html "Chapter 2. Cameras and Game Controls"),
    *Cameras and Game Controls*, we will already have a suitable test bed for the
    door. If not, jMonkeyEngine's `TestBetterCharacter` example can also be used.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地按照这个菜谱中的步骤操作不会给我们带来任何可测试的内容。由于摄像机没有物理属性，门将只是静止在那里，我们将无法推动它。如果你已经制作了任何使用`BetterCharacterControl`类的菜谱，其中许多在[第2章](ch02.html
    "第2章。摄像机和游戏控制")，*摄像机和游戏控制*中，我们已经有了一个合适的测试平台来测试门。如果没有，jMonkeyEngine的`TestBetterCharacter`示例也可以使用。
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'This recipe consists of two sections. The first will deal with the actual creation
    of the door and the functionality to open it. This will be made in the following
    six steps:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱由两个部分组成。第一部分将处理门的实际创建和打开功能。这将在以下六个步骤中完成：
- en: Create a new `RigidBodyControl` object called `attachment` with a small `BoxCollisionShape`.
    The `CollisionShape` should normally be placed inside the wall where the player
    can't run into it. It should have a mass of 0, to prevent it from being affected
    by gravity.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `RigidBodyControl` 对象，命名为 `attachment`，并带有一个小 `BoxCollisionShape`。`CollisionShape`
    应该通常放置在玩家无法撞到的墙壁内部。它应该有一个质量为 0，以防止它受到重力的影响。
- en: 'We move it some distance away and add it to the `physicsSpace` instance, as
    shown in the following code snippet:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将它移动一段距离，并将其添加到 `physicsSpace` 实例中，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, create a `Geometry` class called `doorGeometry` with a `Box` shape with
    dimensions that are suitable for a door, as follows:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为 `doorGeometry` 的 `Geometry` 类，它有一个 `Box` 形状，尺寸适合门，如下所示：
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Similarly, create a `RigidBodyControl` instance with the same dimensions, that
    is, `1` in `mass`; add it as a control to the `doorGeometry` class first and then
    add it to `physicsSpace` of `bulletAppState`. The following code snippet shows
    you how to do this:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，创建一个具有相同尺寸的 `RigidBodyControl` 实例，即 `1` 的质量；首先将其作为控制添加到 `doorGeometry` 类，然后将其添加到
    `bulletAppState` 的 `physicsSpace` 中。下面的代码片段显示了如何做到这一点：
- en: '[PRE2]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we''re going to connect the two with `HingeJoint`. Create a new `HingeJoint`
    instance called `joint`, as follows:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用 `HingeJoint` 将两者连接起来。创建一个新的 `HingeJoint` 实例，命名为 `joint`，如下所示：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we set the limit for the rotation of the door and add it to `physicsSpace`
    as follows:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们设置门的旋转限制并将其添加到 `physicsSpace` 中，如下所示：
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we have a door that can be opened by walking into it. It is primitive
    but effective. Normally, you want doors in games to close after a while. However,
    here, once it is opened, it remains opened. In order to implement an automatic
    closing mechanism, perform the following steps:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个可以通过走进去打开的门。它很简单但很有效。通常，你希望游戏中的门在一段时间后关闭。然而，在这里，一旦打开，它就会保持打开状态。为了实现自动关闭机制，请执行以下步骤：
- en: Create a new class called `DoorCloseControl` extending `AbstractControl`.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的名为 `DoorCloseControl` 的类，它扩展了 `AbstractControl`。
- en: Add a `HingeJoint` field called `joint` along with a setter for it and a float
    variable called `timeOpen`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `joint` 的 `HingeJoint` 字段以及为其设置的设置器和一个名为 `timeOpen` 的浮点变量。
- en: 'In the `controlUpdate` method, we get `hingeAngle` from `HingeJoint` and store
    it in a float variable called `angle`, as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `controlUpdate` 方法中，我们从 `HingeJoint` 获取 `hingeAngle` 并将其存储在一个名为 `angle` 的浮点变量中，如下所示：
- en: '[PRE5]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If the angle deviates a bit more from zero, we should increase `timeOpen` using
    `tpf`. Otherwise, `timeOpen` should be reset to `0`, as shown in the following
    code snippet:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果角度偏离零更多一些，我们应该使用 `tpf` 增加 `timeOpen`。否则，`timeOpen` 应该重置为 `0`，如下面的代码片段所示：
- en: '[PRE6]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If `timeOpen` is more than `5`, we begin by checking whether the door is still
    open. If it is, we define a speed to be the inverse of the angle and enable the
    door''s motor to make it move in the opposite direction of its angle, as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `timeOpen` 大于 `5`，我们首先检查门是否仍然打开。如果是，我们定义一个速度为角度的倒数并启用门的电机，使其向与角度相反的方向移动，如下所示：
- en: '[PRE7]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If `timeOpen` is less than `5`, we should set the speed of the motor to `0`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `timeOpen` 小于 `5`，我们应该将电机的速度设置为 `0`：
- en: '[PRE8]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we can create a new `DoorCloseControl` instance in the main class, attach
    it to the `doorGeometry` class, and give it the same joint we used previously
    in the recipe, as follows:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在主类中创建一个新的 `DoorCloseControl` 实例，将其附加到 `doorGeometry` 类，并给它之前在配方中使用的相同关节，如下所示：
- en: '[PRE9]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The attachment `RigidBodyControl` has no mass and will thus not be affected
    by external forces such as gravity. This means it will stick to its place in the
    world. The door, however, has mass and would fall to the ground if the attachment
    didn't keep it up with it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 附加的 `RigidBodyControl` 没有质量，因此不会受到如重力等外部力的影响。这意味着它将粘在世界的位置上。然而，门有质量，如果附加物不将其支撑起来，它就会掉到地上。
- en: The `HingeJoint` class connects the two and defines how they should move in
    relation to each other. Using `Vector3f.UNIT_Y` means the rotation will be around
    the *y* axis. We set the limit of the joint to be a little more than half PI in
    each direction. This means it will open almost 100 degrees to either side, allowing
    the player to step through.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`HingeJoint` 类连接两个对象并定义了它们相对于彼此的运动方式。使用 `Vector3f.UNIT_Y` 意味着旋转将围绕 *y* 轴进行。我们将关节的限制设置为略大于半
    PI 的每个方向。这意味着它将向两侧打开几乎 100 度，允许玩家穿过。'
- en: When we try this out, there may be some flickering as the camera passes through
    the door. To get around this, there are some tweaks that can be applied. We can
    change the collision shape of the player. Making the collision shape bigger will
    result in the player hitting the wall before the camera gets close enough to clip
    through. This has to be done considering other constraints in the physics world.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试这样做时，当摄像机穿过门时可能会有一些闪烁。为了解决这个问题，可以应用一些调整。我们可以更改玩家的碰撞形状。使碰撞形状更大将导致玩家在摄像机足够接近以剪辑之前先撞到墙上。这必须考虑到物理世界中的其他约束。
- en: You can consider changing the near clip distance of the camera. Decreasing it
    will allow things to get closer to the camera before they are clipped through.
    This might have implications on the camera's projection.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以考虑更改摄像机的近裁剪距离。减小它将允许物体在剪辑之前更接近摄像机。这可能会对摄像机的投影产生影响。
- en: One thing that will not work is making the door thicker, since the triangles
    on the side closest to the player are the ones that are clipped through. Making
    the door thicker will move them even closer to the player.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有一件事不会起作用，那就是使门变厚，因为靠近玩家的侧面上的三角形是那些被剪辑通过的。使门变厚将使它们更靠近玩家。
- en: In `DoorCloseControl`, we consider the door to be open if `hingeAngle` deviates
    a bit more from 0\. We don't use 0 because we can't control the exact rotation
    of the joint. Instead we use a rotational force to move it. This is what we do
    with `joint.enableMotor`. Once the door is open for more than five seconds, we
    tell it to move in the opposite direction. When it's close to 0, we set the desired
    movement speed to 0\. Simply turning off the motor, in this case, will cause the
    door to keep moving until it is stopped by an external force.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DoorCloseControl`中，我们认为如果`hingeAngle`偏离0度较多，门是打开的。我们不使用0，因为我们无法控制关节的精确旋转。相反，我们使用旋转力来移动它。这就是我们使用`joint.enableMotor`所做的事情。一旦门打开超过五秒钟，我们就告诉它向相反方向移动。当它接近0时，我们将期望的运动速度设置为0。在这种情况下，简单地关闭电机会导致门继续移动，直到被外部力量停止。
- en: Once we enable the motor, we also need to call `activate()` on `RigidBodyControl`
    or it will not move.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们启用电机，我们还需要在`RigidBodyControl`上调用`activate()`，否则它不会移动。
- en: Building a rocket engine
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建火箭发动机
- en: 'A rocket engine is crucial for most space-based games and many 2D games as
    well. In this recipe, we''ll cover the minimum that is required to create a thruster
    that can be used in many different contexts. The following figure shows a thruster
    with `ParticleEmitter`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 火箭发动机对于大多数太空游戏以及许多2D游戏来说都是至关重要的。在这个食谱中，我们将介绍创建一个可以在许多不同环境中使用的推进器的最小要求。以下图显示了带有`ParticleEmitter`的推进器：
- en: '![Building a rocket engine](img/6478OS_08_04.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![构建火箭发动机](img/6478OS_08_04.jpg)'
- en: Getting ready
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we need to make sure that we see the debug shapes of physics.
    To do this, we need to call the `bulletAppState.setDebugEnabled(true);` statement.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们需要确保我们看到物理的调试形状。为此，我们需要调用`bulletAppState.setDebugEnabled(true);`语句。
- en: How to do it...
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will begin by setting up some things that are not strictly needed for the
    rocket engine but will aid the testing. Perform the following steps to build a
    rocket engine:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先设置一些不是严格必需用于火箭发动机但将有助于测试的事情。按照以下步骤构建火箭发动机：
- en: First of all we add a floor mesh. For this, we create a new `Node` class called
    `ground`.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们添加一个地板网格。为此，我们创建一个新的`Node`类，称为`ground`。
- en: 'To do this, we add `RigidBodyControl` with `PlaneCollisionShape`. The plane
    should face upwards like floors normally do, as follows:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要做到这一点，我们添加带有`PlaneCollisionShape`的`RigidBodyControl`。平面应该向上，就像地板通常那样，如下所示：
- en: '[PRE10]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We then attach them both to `rootNode` of the application and `physicsSpace`
    of `bulletAppState`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们然后将它们两个都附加到应用的`rootNode`和`bulletAppState`的`physicsSpace`。
- en: Finally, we need to add a key to control the booster. For this, we implement
    an `AnalogListener` interface in our application.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要添加一个键来控制助推器。为此，我们在我们的应用程序中实现了一个`AnalogListener`接口。
- en: 'Then, add the application to `inputManager` along with a mapping object called
    boost that is bound to the Space bar:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将应用添加到`inputManager`中，同时添加一个名为boost的映射对象，它与空格键绑定：
- en: '[PRE11]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Most of this recipe will be implemented in a class that extends `SimpleApplication`.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这份食谱的大部分内容将在一个扩展`SimpleApplication`的类中实现。
- en: We begin by defining a `Node` class called `spaceShip` that will be our spaceship's
    representation.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义一个名为`spaceShip`的`Node`类，它将代表我们的宇宙飞船。
- en: 'We then create a `RigidBodyControl` instance with `BoxCollisionShape` and add
    it to the `spaceShip` node as follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个带有 `BoxCollisionShape` 的 `RigidBodyControl` 实例，并将其添加到 `spaceShip` 节点，如下所示：
- en: '[PRE12]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we create another `Node`, which will be our thruster. Give it the name
    `Thruster` to be able to identify it more easily later, as follows:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建另一个 `Node`，它将成为我们的推进器。给它命名为 `Thruster`，以便以后更容易识别，如下所示：
- en: '[PRE13]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We set `localTranslation` of this so that it will end up at the bottom of the
    spaceship, as shown in the following line of code:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置 `localTranslation`，使其最终位于飞船底部，如下代码行所示：
- en: '[PRE14]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then, we attach it to the `spaceShip` node.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将它附加到 `spaceShip` 节点。
- en: Now, we have to attach the `spaceShip` node to both the `rootNode` and `physicsSpace`
    of `bulletAppState`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须将 `spaceShip` 节点附加到 `bulletAppState` 的 `rootNode` 和 `physicsSpace`。
- en: To control the thruster and make it more reusable, we will create a class called
    `ThrusterControl`, extending `AbstractControl`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了控制推进器并使其更具可重用性，我们将创建一个名为 `ThrusterControl` 的类，它扩展了 `AbstractControl`。
- en: It'll have one field, a `Spatial` field called `thruster`, that will store the
    `thruster` node.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将有一个字段，一个名为 `thruster` 的 `Spatial` 字段，用于存储 `thruster` 节点。
- en: We will override the `setSpatial` method and set it by calling `getChild("Thruster")`
    on the supplied spatial.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将重写 `setSpatial` 方法，并通过在提供的空间上调用 `getChild("Thruster")` 来设置它。
- en: Lastly, we define a new method called `fireBooster()`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义了一个名为 `fireBooster()` 的新方法。
- en: 'Inside this, we subtract the thruster''s location from the spaceship''s location
    and store it in a new `Vector3f` field called `direction` as follows:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们从中减去推进器的位置和飞船的位置，并将其存储在一个新的 `Vector3f` 字段中，称为 `direction`，如下所示：
- en: '[PRE15]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we find the `RigidBodyControl` class in the spatial and call `applyImpulse`
    with the direction vector. We use the inverted direction as the relative position
    that the impulse should originate from. This can be implemented as follows:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在空间中找到 `RigidBodyControl` 类，并使用方向向量调用 `applyImpulse`。我们使用反转的方向作为脉冲应该起源的相对位置。这可以如下实现：
- en: '[PRE16]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the application class, we have to make it call the `fireBooster` method.
    We do this in the `onAnalog` method that was added when we implemented the `AnalogListener`
    interface:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序类中，我们必须让它调用 `fireBooster` 方法。我们在实现 `AnalogListener` 接口时添加的 `onAnalog` 方法中这样做：
- en: '[PRE17]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The graphics in this recipe are very minimalistic and mostly rely on the debug
    mode of `BulletAppState` to draw them. The physics shapes don't normally have
    a visual representation since they're not part of the scene graph. Using the debug
    mode can be very useful during early prototypes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方中的图形非常简约，主要依赖于 `BulletAppState` 的调试模式来绘制。物理形状通常没有视觉表示，因为它们不是场景图的一部分。在早期原型阶段使用调试模式非常有用。
- en: The `RigidBodyControl` instance of the spaceship makes sure it's affected by
    gravity and other forces.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 飞船的 `RigidBodyControl` 实例确保它受到重力和其他力的作用。
- en: The sole purpose of a thruster is to be able to easily retrieve the position
    that is relative to the spaceship from where the boosting force needs to be applied.
    This is why we place it at the bottom of the spaceship. The benefit of using the
    `Control` pattern to control a `Thruster` is that we can apply it to other geometries
    easily (and even use it in `SceneComposer`).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 推进器的唯一目的是能够轻松地检索相对于飞船的位置，从那里需要应用推力。这就是为什么我们将其放置在飞船底部的原因。使用 `Control` 模式控制 `Thruster`
    的好处是我们可以轻松地将它应用于其他几何形状（甚至可以在 `SceneComposer` 中使用）。
- en: The `fireBooster` method of `ThrusterControl` takes the position of `spaceShip`
    and subtracts the position of the thruster node to get the direction of the force
    to apply. The relative position of the force is the direct opposite of this direction.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThrusterControl` 类的 `fireBooster` 方法接受 `spaceShip` 的位置，并从中减去推进器节点的位置，以获取要应用力的方向。力的相对位置是此方向的直接相反。'
- en: Ballistic projectiles and arrows
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹道投射物和箭矢
- en: 'Applying physics to arrows can greatly improve the appearance and gameplay
    of a medieval or fantasy game. Setting up arrows that are affected by gravity
    is fairly simple; this recipe, however, will also set the arrows up in a way that
    they always face the direction they''re traveling in, making them more realistic.
    The following figure shows one of the arrows in flight:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将物理学应用于箭矢可以极大地提升中世纪或奇幻游戏的视觉效果和游戏玩法。设置受重力影响的箭矢相对简单；然而，这个配方还将箭矢设置为始终面向它们行进的方向，使其更加逼真。以下图显示了飞行中的其中一支箭矢：
- en: '![Ballistic projectiles and arrows](img/6478OS_08_01.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![弹道投射物和箭矢](img/6478OS_08_01.jpg)'
- en: Getting ready
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we need to make sure that we see the debug shapes of physics.
    To do this, we need to call the `bulletAppState.setDebugEnabled(true);` statement.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们需要确保我们看到物理的调试形状。为此，我们需要调用`bulletAppState.setDebugEnabled(true);`语句。
- en: How to do it...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this recipe, we''ll create three classes. Let''s begin by looking at the
    `Arrow` class, which contains most of the new functionalities. This will be done
    in the following eight steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将创建三个类。让我们首先看看`Arrow`类，它包含大部分新功能。这将在以下八个步骤中完成：
- en: We create a new class called `Arrow`, extending `Node`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个名为`Arrow`的新类，它扩展了`Node`。
- en: 'Its constructor takes two `Vector3f` variables as parameters. One of these
    is for the starting location of the arrow and one for the initial velocity, as
    shown in the following line of code:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它的构造函数接受两个`Vector3f`变量作为参数。其中一个是箭头的起始位置，另一个是初始速度，如下面的代码行所示：
- en: '[PRE18]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Inside the constructor, we define a `Geometry` instance for the body of the
    arrow with a `box` mesh as follows:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数内部，我们为箭头的身体定义一个`Geometry`实例，使用`box`网格，如下所示：
- en: '[PRE19]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we set `localTranslation` of `Geometry` so that one of its ends touches
    the center point of the node as follows:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们设置`Geometry`的`localTranslation`，使得其一个端点接触到节点的中心点，如下所示：
- en: '[PRE20]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We set `localTranslation` of this `Arrow` as the supplied location.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将这个`Arrow`的`localTranslation`设置为提供的位置。
- en: 'Next, we create `CollisionShape`. This will represent the head of the arrow
    and can be `SphereCollisionShape`, as follows:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建`CollisionShape`。这将代表箭头的头部，可以是`SphereCollisionShape`，如下所示：
- en: '[PRE21]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we define `RigidBodyControl` based on `CollisionShape`, as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们根据`CollisionShape`定义`RigidBodyControl`，如下所示：
- en: '[PRE22]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We set `LinearVelocity` of `RigidBodyControl` to be the supplied velocity and
    add it as a Control to Arrow, as follows:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`RigidBodyControl`的`LinearVelocity`设置为提供的速度，并将其作为控制添加到箭头中，如下所示：
- en: '[PRE23]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This would be enough for the arrow to follow the laws of physics; however,
    it will always face the forward direction. By adding another control, we can make
    it face the direction of the velocity. To do this, perform the following steps:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于箭头遵循物理定律就足够了；然而，它将始终面向前方。通过添加另一个控制，我们可以使其面向速度的方向。为此，执行以下步骤：
- en: Create another class called `ArrowFacingControl`, extending `AbstractControl`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`ArrowFacingControl`的类，它扩展了`AbstractControl`。
- en: We add a `Vector3f` field called `direction`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加一个名为`direction`的`Vector3f`字段。
- en: 'In the `controlUpdate` method, we get `linearVelocity` from `RigidBodyControl`
    of the spatial and normalize it. We then store it in `direction` as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`controlUpdate`方法中，我们从空间中的`RigidBodyControl`获取`linearVelocity`并将其归一化。然后我们将其存储在`direction`中，如下所示：
- en: '[PRE24]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, call the spatial and tell it to rotate to the supplied `direction` vector
    as follows:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，调用空间并告诉它旋转到提供的`direction`向量，如下所示：
- en: '[PRE25]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the constructor of the `Arrow` class, we add an instance of this control,
    as follows:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Arrow`类的构造函数中，我们添加了这个控制的一个实例，如下所示：
- en: '[PRE26]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The last section handles the firing of the arrow from `SimpleApplication`.
    This can be done with the following steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个部分处理从`SimpleApplication`发射箭头。这可以通过以下步骤完成：
- en: First of all, we need to implement `ActionListener` in the application.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在应用程序中实现`ActionListener`。
- en: 'Add the `ActionListener` class to `inputManager` as a listener, together with
    a key for firing arrows, as follows:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ActionListener`类添加到`inputManager`中作为监听器，以及一个用于发射箭头的键，如下所示：
- en: '[PRE27]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the `onAction` method, call a new method called `fireArrow` when the `fire`
    button is released. This can be implemented as follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onAction`方法中，当`fire`按钮被释放时，调用一个新的方法`fireArrow`。这可以如下实现：
- en: '[PRE28]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `fireArrow` method should begin by instancing a new `Arrow` instance and
    applying a (preloaded) material to it, as follows:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fireArrow`方法应该首先实例化一个新的`Arrow`实例，并给它应用一个（预加载的）材质，如下所示：'
- en: '[PRE29]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We attach it to `rootNode` as well as to `physicsSpace`, as shown in the following
    code snippet:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将它附加到`rootNode`以及`physicsSpace`上，如下面的代码片段所示：
- en: '[PRE30]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Arrow` object has two major components. One is `Geometry`, which is a simple
    elongated box. The other is `CollisionShape` for the head of the arrow, which
    is the only thing that will look for collisions. The geometry is conveniently
    moved so that its tip will be at the (0,0,0) position of the `Arrow` node. It
    is convenient since it means we don't have to do any conversions in `ArrowFacingControl`
    but can use `rotateUpTo` with the actual velocity (direction) of the arrow.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`Arrow`对象有两个主要组件。一个是`Geometry`，它是一个简单的长方形。另一个是用于箭头头的`CollisionShape`，这是唯一会寻找碰撞的东西。几何体被方便地移动，使其尖端位于`Arrow`节点的（0,0,0）位置。这很方便，因为它意味着我们不需要在`ArrowFacingControl`中进行任何转换，而可以直接使用`rotateUpTo`与箭头的实际速度（方向）。'
- en: Handling multiple gravity sources
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理多个重力源
- en: Some games require handling gravity from multiple variable sources. In this
    recipe, we'll handle this and create a simple miniature solar system to demonstrate
    it using `ThrusterControl` from the *Building a rocket engine* recipe. To (greatly)
    simplify the relation between the planets, they won't affect each other with their
    gravity, but only the ship. It will also be made in a 2D-asteroids-like fashion,
    although the gravity would still apply for a 3D game.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一些游戏需要从多个变量源处理重力。在这个菜谱中，我们将处理这个问题，并创建一个简单的微型太阳系来演示它，使用的是来自`Building a rocket
    engine`菜谱的`ThrusterControl`。为了（大大）简化行星之间的关系，它们不会相互影响重力，而只会影响飞船。它也将以类似2D-asteroids的方式制作，尽管对于3D游戏，重力仍然适用。
- en: We'll add some basic controls to rotate the ship to the left and right, and
    you can use the thruster to make the ship move forward.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一些基本控制来使飞船向左和向右旋转，并且你可以使用推进器使飞船向前移动。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Apart from `ThrusterControl`, we''ll create two more small classes and an application
    class that joins everything together. Let''s start with a class that represents
    the player''s ship. This will consist of the following six steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`ThrusterControl`之外，我们还将创建两个更小的类和一个应用程序类，将所有这些内容结合起来。让我们从一个代表玩家飞船的类开始。这包括以下六个步骤：
- en: Create a new class called `SpaceShip`, which has a `Node` field called `shipNode`
    in it.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`SpaceShip`的新类，其中包含一个名为`shipNode`的字段。
- en: 'In the constructor, we set up the physics for it by creating a new `RigidBodyControl`
    instance with `BoxCollisionShape`. To create it in a way that it is affected by
    gravity, we also give it a mass of `1` that will be supplied in the constructor
    as follows:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，我们通过创建一个新的`RigidBodyControl`实例并使用`BoxCollisionShape`来设置它的物理。为了使其受到重力的影响，我们还给它一个质量为`1`，这个质量将在构造函数中提供，如下所示：
- en: '[PRE31]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, we create a `Node` instance called `thruster`. We also set the name of
    `Node` to `Thruster` for the control to find it automatically, as shown in the
    following line of code:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建一个名为`thruster`的`Node`实例。我们还设置了`Node`的名称为`Thruster`，以便控制可以自动找到它，如下面的代码行所示：
- en: '[PRE32]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We set `localTranslation` to be at one of the sides of the spaceship and attach
    it to `shipNode`, as follows:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`localTranslation`设置在飞船的一侧，并将其附加到`shipNode`上，如下所示：
- en: '[PRE33]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, we rotate the ship''s spatial so that it''s facing sideways:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们旋转飞船的空间，使其朝向侧面：
- en: '[PRE34]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Finally, we add a new `ThrusterControl` instance to the spaceship's spatial.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们向飞船的空间中添加一个新的`ThrusterControl`实例。
- en: 'That''s it for the `SpaceShip` class. Now, we create a class for our planets,
    as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`SpaceShip`类来说，这就结束了。现在，我们创建一个用于我们行星的类，如下所示：
- en: 'We start off by defining a class called `StellarBody`, which extends `AbstractControl`.
    The `StellarBody` class has four float fields: `size`, `speed`, `orbit`, and `cycle`.'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义一个名为`StellarBody`的类，它扩展了`AbstractControl`。`StellarBody`类有四个浮点字段：`size`、`speed`、`orbit`和`cycle`。
- en: 'The constructor takes three of these (`size`, `speed`, and `orbit`) as the
    input, as shown in the following code:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数接受这三个（`size`、`speed`和`orbit`）作为输入，如下面的代码所示：
- en: '[PRE35]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We override the `setSpatial` method and add `RigidBodyControl` to the supplied
    spatial with `SphereCollisionShape`, using `size` as the radius and `0` for mass:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们重写了`setSpatial`方法，并在提供的空间中添加了`RigidBodyControl`，使用`size`作为半径，`0`作为质量：
- en: '[PRE36]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the `controlUpdate` method, we make it move along its orbit by increasing
    the speed of the cycle by multiplying it by `tpf`, as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`controlUpdate`方法中，我们通过将周期的速度乘以`tpf`来使其沿着轨道移动：
- en: '[PRE37]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, we set the actual position of the planet along the orbit using the `sin`
    and `cos` methods of the `FastMath` class:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`FastMath`类的`sin`和`cos`方法设置行星沿轨道的实际位置：
- en: '[PRE38]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We multiply the result by the orbit and set `localTranslation` of the spatial
    to the new location as follows:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将结果乘以轨道，并将空间体的`localTranslation`设置为新的位置，如下所示：
- en: '[PRE39]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Then, we also need to set `physicsLocation` of `RigidBodyControl` to the same
    location.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们还需要将`RigidBodyControl`的`physicsLocation`设置为相同的位置。
- en: We need a new method, `getGravity`, that will take the position of the ship
    as an input `Vector3f`.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个名为`getGravity`的新方法，它将船的位置作为输入`Vector3f`。
- en: 'The method begins by subtracting the input position by `worldTranslation`,
    to get the position of the ship relative to the `StellarBody` class, as follows:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该方法首先从输入位置减去`worldTranslation`，以获得相对于`StellarBody`类的船的位置，如下所示：
- en: '[PRE40]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The result is normalized and then modified by a formula to get a suitable gravity.
    This value is returned to the calling method, as follows:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果经过归一化，然后通过一个公式进行修改以获得合适的重力。这个值随后返回给调用方法，如下所示：
- en: '[PRE41]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To test all of this, we need to add a few things to `SimpleApplication`. To
    do this, perform the following set of steps:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试所有这些，我们需要向`SimpleApplication`添加一些内容。为此，执行以下步骤：
- en: First of all, we implement `AnalogListener`.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们实现`AnalogListener`。
- en: We add an `ArrayList<StellarBody>` list called `gravitationalBodies`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加一个名为`gravitationalBodies`的`ArrayList<StellarBody>`列表。
- en: 'In the `simpleInitApp` method, we should begin by initializing `bulletAppState`
    and set up some controls for the spaceship. We add actions to rotate the spaceship
    to the left and right as well as fire the ship''s thruster, as follows:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`simpleInitApp`方法中，我们应该首先初始化`bulletAppState`并为飞船设置一些控制。我们添加了使飞船向左和向右旋转以及发射飞船推进器的动作，如下所示：
- en: '[PRE42]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Since it''s a 2D representation, we move the camera some distance up and make
    it look as if it is at the center of the world. This can be implemented as follows:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这是一个二维表示，我们将摄像机向上移动一段距离，使其看起来像是位于世界的中心。这可以通过以下方式实现：
- en: '[PRE43]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We create an instance called `ship` of `SpaceShip` and attach its geometry to
    `rootNode` and `physicsSpace` of `bulletAppState`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个名为`ship`的`SpaceShip`实例，并将其几何形状附加到`rootNode`和`bulletAppState`的`physicsSpace`。
- en: 'Now we can create a number of `StellarBody` instances using the following steps:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下步骤创建多个`StellarBody`实例：
- en: For each instance, we should create a `Geometry` class with a `Sphere` shape
    that will have the same radius as the size we will supply to the `StellarBody`
    control.
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个实例，我们应该创建一个具有`Sphere`形状的`Geometry`类，其半径将与提供给`StellarBody`控制的大小相同。
- en: The `Geometry` class should both be attached to `rootNode` and `physicsSpace`
    of `bulletAppState`.
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Geometry`类应该同时附加到`bulletAppState`的`rootNode`和`physicsSpace`。'
- en: We add `StellarBody` as a control to the `Geometry` class and the `gravitationalBodies`
    list.
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`StellarBody`作为控制添加到`Geometry`类和`gravitationalBodies`列表中。
- en: Inside the `update` method, we have to take into account the gravity of the
    `StellarBody` instances.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`update`方法内部，我们必须考虑到`StellarBody`实例的重力。
- en: First, we define a new `Vector3f` instance called `combinedGravity`.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个新的`Vector3f`实例，称为`combinedGravity`。
- en: 'Then, we loop through our `gravitationalBodies` list and apply the following
    line of code to apply the gravity to `combinedGravity`:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们遍历我们的`gravitationalBodies`列表，并将以下代码行应用于将重力应用于`combinedGravity`：
- en: '[PRE44]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Finally, we call the `ship.setGravity(combinedGravity);` statement.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们调用`ship.setGravity(combinedGravity);`语句。
- en: How it works...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Due to the extreme difficulty in creating a stable solar system with more than
    three bodies, `StellarBody` controls the need to have a static orbit around the
    center of the system. Using `0` as mass ensures that they aren't affected by gravity.
    The orbit field represents the orbit's distance from the center of the system,
    and it will rotate around the center using speed as a factor. The cycle field
    stores information on how far along its orbit it has come, and will reset once
    it reaches two PI (a full circle).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于创建包含三个以上实体的稳定太阳系极端困难，`StellarBody`控制需要围绕系统中心有一个静态轨道。使用`0`作为质量确保它们不受重力影响。轨道字段表示轨道距离系统中心的距离，它将使用速度作为因素围绕中心旋转。周期字段存储有关其轨道进度的信息，并在达到两PI（一个完整圆周）时重置。
- en: The `getGravity` method returns the gravity relative to the position that is
    supplied, which in this case is the location of the ship. It first determines
    the direction and then applies the gravity based on the distance between the two.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`getGravity`方法返回相对于提供的位置的引力，在这种情况下是船的位置。它首先确定方向，然后根据两个位置之间的距离应用重力。'
- en: By using the `gravitationalBodies` list, we have a dynamic way to simply add
    up all the gravitational forces in the system to a single `Vector3f` object, which
    we then apply to the spaceship in the `update` method of the application.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`gravitationalBodies`列表，我们有一种动态的方法可以将系统中所有重力力的总和添加到一个单一的`Vector3f`对象中，然后我们在应用程序的`update`方法中将它应用到宇宙飞船上。
- en: Self-balancing using RotationalLimitMotors
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用旋转限制电机进行自我平衡
- en: Many games today use a blend of animations and physics to create realistic movement.
    For animated characters, this revolves around balance. It could take the shape
    of a runner who leans inwards through a curve to counter the centrifugal force.
    Creating a system like this is not easy and requires a lot of tweaking. In this
    recipe, we'll look into some of the fundamentals of this, and we'll create a new
    `Control` class that will try to balance itself using the rotational motors of
    `SixDofJoint`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 许多游戏今天使用动画和物理的混合来创建逼真的运动。对于动画角色，这围绕着平衡。它可能是一个跑步者在曲线中向内倾斜以对抗离心力的形状。创建这样一个系统并不容易，需要很多调整。在这个菜谱中，我们将探讨这个领域的某些基本原理，并创建一个新的`Control`类，该类将尝试使用`SixDofJoint`的旋转电机来自我平衡。
- en: Note
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Six Degrees of Freedom** (**SixDof**) relates to the six ways the joint can
    rotate: +x, -x, +y, -y, +z, and -z. One way it differs from a `point2point` joint
    is that in addition, it also has motors for each axis, which makes it possible
    for it to also apply force.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**六自由度**（**SixDof**）指的是关节可以旋转的六种方式：+x，-x，+y，-y，+z和-z。它与`point2point`关节的不同之处在于，它还具有每个轴的电机，这使得它也能够施加力。'
- en: How to do it...
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To simulate balancing, we will begin by creating the upper body of a stickman-shape
    figure with a torso and two rigid arms. To do this, perform the following set
    of steps:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟平衡，我们将首先创建一个由躯干和两条刚性手臂组成的stickman形状的人体上半身。为此，执行以下步骤：
- en: First of all, we should set up an application with `BulletAppState`.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们应该使用`BulletAppState`设置一个应用程序。
- en: In the `simpleInitApp` method, we create a small square `Box Geometry` to be
    the waist of the character. It can be `0.25f` in all the axes.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`simpleInitApp`方法中，我们创建了一个小的正方形`Box Geometry`作为角色的腰部。它在所有轴上可以是`0.25f`。
- en: We add `RigidBodyControl` to it with `0` in mass since it shouldn't move.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将它添加了`RigidBodyControl`，质量设置为`0`，因为它不应该移动。
- en: 'Then, we create an oblong box to be the torso and place it above the waist.
    It should have `RigidBodyControl` with `1` in mass and `BoxCollisionShape` should
    be of the same size as the geometry:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个长方体作为躯干，并将其放置在腰部上方。它应该有质量为`1`的`RigidBodyControl`，并且`BoxCollisionShape`应该与几何形状大小相同：
- en: '[PRE45]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, we create `SixDofJoint` between the waist and torso and afterwards add
    it to `physicsSpace` as follows:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在腰部和躯干之间创建一个`SixDofJoint`，然后按照以下方式将其添加到`physicsSpace`中：
- en: '[PRE46]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We should limit the joint so that it can''t rotate on any axes other than the
    *x* axis, and it shouldn''t be able to rotate too much. We can use the following
    `setAngularLowerLimit` and `setAngularUpperLimit` methods for this:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该限制关节，使其不能在除了*x*轴以外的任何轴上旋转，并且它不应该能够旋转太多。我们可以使用以下`setAngularLowerLimit`和`setAngularUpperLimit`方法来完成此操作：
- en: '[PRE47]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Next, we create one of the arms.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一只手臂。
- en: 'We create one of the arms by placing it at the same location as that of the
    torso and giving it a size of `Vector3f(0.25f, 0.25f, 2f)`, making it stretch
    out sideways, as shown in the following code snippet:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过将其放置在躯干相同的位置并给它一个大小为`Vector3f(0.25f, 0.25f, 2f)`来创建一只手臂，使其向侧面伸展，如下面的代码片段所示：
- en: '[PRE48]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We create another `SixDofJoint` for it using the pivot points of `Vector3f(0,
    2.5f, 0.25f)` and `Vector3f(0, 0, -2.5f)`, offsetting it some distance to the
    side of the torso's spatial.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`Vector3f(0, 2.5f, 0.25f)`和`Vector3f(0, 0, -2.5f)`的旋转点为它创建另一个`SixDofJoint`，并将其偏移一些距离到躯干的空侧。
- en: Then, we set the angular limits of the joint to `Vector3f(0, 0, 0)` and `Vector3f(FastMath.QUARTER_PI,
    0, 0)`.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将关节的角限制设置为`Vector3f(0, 0, 0)`和`Vector3f(FastMath.QUARTER_PI, 0, 0)`。
- en: We repeat the previous three steps to create the opposite arm, but we'll reverse
    the offset values to make the arm protrude in the opposite direction of the torso.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们重复前面的三个步骤来创建另一只手臂，但我们将反转偏移值，使手臂向躯干相反的方向突出。
- en: 'We now have the basics done for our recipe. Running it should show the character
    slumping to one side with the arms stretched out to the sides. Now, we can begin
    with balancing by performing the following steps:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了我们的菜谱的基本设置。运行它应该显示角色向一侧倾斜，手臂向两侧伸展。现在，我们可以通过执行以下步骤开始平衡：
- en: We create a new class called `BalanceControl`, extending `AbstractControl`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`BalanceControl`的新类，它扩展了`AbstractControl`。
- en: It should have a `SixDofJoint` field called `joint` and a `RotationalLimitMotor`
    field called `motorX`.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它应该有一个名为`joint`的`SixDofJoint`字段和一个名为`motorX`的`RotationalLimitMotor`字段。
- en: Create a `setJoint` method.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`setJoint`方法。
- en: 'Inside this method, after setting the joint, we also populate `motorX` with
    one of the `RotationalLimitMotor` instances, as follows:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此方法内部，在设置关节之后，我们还使用以下方式用`RotationalLimitMotor`实例之一填充`motorX`：
- en: '[PRE49]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Inside the `controlUpdate` method, we get `bodyA` from the joint and store
    it in `PhysicsRigidBody`. This is the torso:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`controlUpdate`方法内部，我们从关节获取`bodyA`并将其存储在`PhysicsRigidBody`中。这是躯干：
- en: '[PRE50]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We get the current rotation of `bodyA` to see how much it pivots. We then convert
    the rotation to angles and store them as follows:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们获取`bodyA`的当前旋转以查看它旋转了多少。然后我们将旋转转换为角度并按照以下方式存储：
- en: '[PRE51]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We then store `angles[0]` in a float variable called `x`.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将`angles[0]`存储在一个名为`x`的浮点变量中。
- en: 'If `x` is more than 0.01f or less than -0.01, we should start `motorX` and
    rotate it to compensate for the pivot, as follows:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`x`大于0.01f或小于-0.01，我们应该启动`motorX`并将其旋转以补偿旋转，如下所示：
- en: '[PRE52]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Otherwise, we turn off the motor as follows:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们按照以下方式关闭电机：
- en: '[PRE53]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: How it works...
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Running the result, we should see the stickman desperately trying to stay upright
    while flailing his arms up and down. The reason is that getting the forces right
    when balancing can be very difficult. With values that are too high, the stickman
    will constantly overshoot the target and instead rotate in the other direction.
    With values that are too low, it won't have the strength to get upright. With
    some further tweaking to `targetVelocity` and `maxMotorForce`, we might be able
    make him stable.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 运行结果，我们应该看到小人在拼命地试图保持直立，同时上下挥舞着双臂。原因是当平衡时获取正确的力可能非常困难。如果数值过高，小人会不断超出目标并相反地旋转。如果数值过低，它将没有足够的力量直立起来。通过进一步调整`targetVelocity`和`maxMotorForce`，我们可能使他变得稳定。
- en: We started by creating the basic shape of a figure that would try to keep the
    balance. The waist was made to not be affected by the physics, so it could be
    a solid point. We then added a torso and two arms, resulting in a center of mass
    somewhere in the upper part of the torso. By placing each of the body parts at
    some distance from each other with the joints, we give them more freedom of movement.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个基本形状的图形，试图保持平衡。腰部被设计为不受物理影响，因此它可以成为一个固定点。然后我们添加了躯干和两条手臂，使得质心位于躯干的上部。通过将身体各部分放置在一定的距离并通过关节连接，我们给予它们更多的运动自由度。
- en: The `BalanceControl` class we created has one simple strategy. It looks for
    the torso (bodyA)'s rotation along the *x* axis, and tries to keep it as close
    to 0 as possible. If it notices that it's anything but near 0, it will try to
    move the arms, shifting the center of the mass to the opposite direction.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的`BalanceControl`类有一个简单的策略。它寻找躯干（bodyA）沿*x*轴的旋转，并试图将其保持在尽可能接近0的位置。如果它注意到它不是接近0，它将尝试移动手臂，将质心移向相反方向。
- en: Despite the low number of components, getting it all to balance out is really
    difficult! Having more components, such as a whole human skeleton, requires a
    much more advanced strategy, with body parts moving in a synchronized fashion,
    rather than they trying to do so individually.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管组件数量不多，但要使所有组件平衡出来确实非常困难！如果添加更多组件，例如整个人体骨骼，则需要更高级的策略，身体各部分以同步的方式移动，而不是各自尝试这样做。
- en: The principles of a bridge-building game
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 桥梁建筑游戏的原则
- en: Variants of bridge-building games have been around for a long time. The classical
    *Bridge Builder* is a 2D physics game where the player is required connect beams
    to create a bridge strong enough for a train (or some other moving object) to
    pass.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 桥梁建筑游戏的变体已经存在很长时间了。经典的*桥梁建造者*是一款2D物理游戏，玩家需要连接梁以形成一个足够坚固的桥梁，以便火车（或其他移动物体）通过。
- en: This recipe will describe most of the core functionalities needed to create
    such a game, including making the objects stay 2D and not wander off on the *z*
    axis.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将描述创建此类游戏所需的大部分核心功能，包括使对象保持在2D并且不在*z*轴上漂移。
- en: 'We''ll have some basic controls for the game:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为游戏提供一些基本控制：
- en: Left-click will select a previously built node in the bridge
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左键点击将选择桥梁中之前构建的节点
- en: Right-click will add a new node or connect two previously built ones
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右键点击将添加一个新的节点或连接两个之前构建的节点
- en: The Space bar will turn on the physics
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空格键将开启物理效果
- en: 'The following figure shows a bridge:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了一座桥梁：
- en: '![The principles of a bridge-building game](img/6478OS_08_02.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![桥梁建造游戏的原则](img/6478OS_08_02.jpg)'
- en: Getting ready
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before we begin with more physics-related functions, we should set up the basic
    application.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始更多与物理相关的函数之前，我们应该设置基本应用程序。
- en: First of all, we create a new class that extends `SimpleApplication`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个新的类，它扩展了 `SimpleApplication`。
- en: 'Later on, we''re going to use the following two lists:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将使用以下两个列表：
- en: '[PRE54]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We also need some strings as input mappings: `LEFT_CLICK`, `RIGHT_CLICK`, and
    `TOGGLE_PHYSICS`.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一些字符串作为输入映射：`LEFT_CLICK`、`RIGHT_CLICK` 和 `TOGGLE_PHYSICS`。
- en: We add a `RigidBodyControl` field called `selectedSegment` that will contain
    the last selected segment in the game.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加一个名为 `selectedSegment` 的 `RigidBodyControl` 字段，它将包含游戏中最后选择的段。
- en: 'Since we''re strictly making a 2D game, we should change the camera to be orthographic.
    This can be done by performing the following steps:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们严格制作一个 2D 游戏，我们应该将摄像机更改为正交视图。这可以通过执行以下步骤来完成：
- en: Disable `flyCam`.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用 `flyCam`。
- en: Find out the aspect ratio by dividing the `cam` width by its height and storing
    it.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将 `cam` 的宽度除以其高度并存储它来找出纵横比。
- en: Set `cam.parallelProjection` to `true`.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `cam.parallelProjection` 设置为 `true`。
- en: 'Then, change `frustrum` of the camera to suit and orthographic view as follows:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将摄像机的 `frustrum` 更改为适合正交视图，如下所示：
- en: '[PRE55]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We move it some way along the *z* axis and rotate it back towards the center,
    as follows:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将其沿 *z* 轴移动一段距离，并将其旋转回中心，如下所示：
- en: '[PRE56]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now, we can initialize `bulletAppState` as we usually do. Turn on the debug
    mode, and most importantly, set `speed` to `0`. We don't want any physics on while
    we build the bridge.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以像通常一样初始化 `bulletAppState`。打开调试模式，最重要的是，将 `speed` 设置为 `0`。在我们构建桥梁时，我们不希望有任何物理效果。
- en: 'The world needs a gap to be bridged. So, for this, we''ll use `RigidBodyControl`
    to represent two cliffs, one on either side, as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 世界需要一座桥梁来连接缺口。因此，为此，我们将使用 `RigidBodyControl` 来表示两侧的两个悬崖，如下所示：
- en: Create one `RigidBodyControl` instance for each side and give it `BoxCollisionShape`
    with a size of `Vector3f(75f, 50f, 5f)` and `0` mass.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每一侧创建一个 `RigidBodyControl` 实例，并给它一个大小为 `Vector3f(75f, 50f, 5f)` 和 `0` 质量的 `BoxCollisionShape`。
- en: Place one of them at `Vector3f(-100f, -50f, 0)` and the other one at `Vector3f(100f,
    -50f, 0)`.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其中一个放置在 `Vector3f(-100f, -50f, 0)`，另一个放置在 `Vector3f(100f, -50f, 0)`。
- en: Then, add them to `physicsSpace`.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将它们添加到 `physicsSpace`。
- en: How to do it...
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We''re going to start by creating two methods that will help us add new bridge
    segments to the game:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建两个方法，这将帮助我们向游戏中添加新的桥梁段：
- en: We define a method called `createSegment` that takes a `Vector3f` parameter
    called `location` as the input.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个名为 `createSegment` 的方法，它接受一个名为 `location` 的 `Vector3f` 参数作为输入。
- en: The first thing we do is set the `z` value of `location` to `0`. This is because
    we're making a 2D game.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先要做的是将 `location` 的 `z` 值设置为 `0`。这是因为我们正在制作一个 2D 游戏。
- en: 'Then, we create a new `RigidBodyControl` instance called `newSegment`. We add
    `SphereCollisionShape` to it and then add `newSegment` to `physicsSpace`. It''s
    important that it has some mass. This can be implemented as follows:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个新的 `RigidBodyControl` 实例，称为 `newSegment`。我们将 `SphereCollisionShape`
    添加到其中，然后将 `newSegment` 添加到 `physicsSpace`。重要的是它必须有一些质量。这可以按以下方式实现：
- en: '[PRE57]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Now, we create a `Geometry` instance based on a `Sphere` shape with the same
    radius as `RigidBodyControl`. We will use this as a target for mouse clicks.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们根据与 `RigidBodyControl` 相同半径的 `Sphere` 形状创建一个 `Geometry` 实例。我们将将其用作鼠标点击的目标。
- en: The `Geometry` object needs `modelBound` for which we'll use `BoundingSphere`.
    The radius may be bigger than `RigidBodyControl`.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Geometry` 对象需要 `modelBound`，我们将使用 `BoundingSphere`。半径可能大于 `RigidBodyControl`。'
- en: 'The `RigidBodyControl` object is added to `Geometry` as a control and we use
    the `setPhysicsLocation` method to move it to the to the supplied location, as
    follows:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RigidBodyControl` 对象被添加到 `Geometry` 中作为控制，我们使用 `setPhysicsLocation` 方法将其移动到指定的位置，如下所示：'
- en: '[PRE58]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `Geometry` object is then added to the segments list we defined earlier
    and then it is attached to `rootNode`.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将 `Geometry` 对象添加到我们之前定义的 segments 列表中，并将其附加到 `rootNode`。
- en: 'If `selectedSegment` is not null, we will call a method we will define next:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `selectedSegment` 不为空，我们将调用我们接下来要定义的方法：
- en: '[PRE59]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Lastly, in the `createJoint` method, we set `selectedSegment` to be `newSegment`.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `createJoint` 方法中，我们将 `selectedSegment` 设置为 `newSegment`。
- en: 'Now, we can define the `createJoint` method. It takes two `RigidBodyControl`
    parameters as the input, as shown in the following code:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以定义 `createJoint` 方法。它接受两个 `RigidBodyControl` 参数作为输入，如下面的代码所示：
- en: '[PRE60]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'First, we find out the location that should be the pivot point of `body2`.
    This is the same as `physicsLocation` of `body2` subtracted from `physicsLocation`
    of `body1`, as follows:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们找出应该是`body2`的支点的位置。这等于`body2`的`physicsLocation`减去`body1`的`physicsLocation`，如下所示：
- en: '[PRE61]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then, we define `Point2PointJoint` by joining the two segments. The vectors
    supplied mean that `body2` will pivot in a way that is relative to `body1`; we
    do this using the following code:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过连接两个段来定义`Point2PointJoint`。提供的向量意味着`body2`将以相对于`body1`的方式旋转；我们使用以下代码来完成这项工作：
- en: '[PRE62]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We then add the newly created joint to the `joints` list and to `physicsSpace`.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将新创建的关节添加到`joints`列表和`physicsSpace`中。
- en: 'We''re now getting to the controls of the application and need another method
    to help us. The method will check whether a mouse click has hit any segment and
    return it. To do this, perform the following steps:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正在接近应用程序的控制部分，需要另一个方法来帮助我们。该方法将检查鼠标点击是否击中了任何段并返回它。为此，执行以下步骤：
- en: We define a new method called `checkSelection`, which returns `RigidBodyControl`.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`checkSelection`的新方法，它返回`RigidBodyControl`。
- en: 'Inside this method, we create a new `Ray` instance, which will have the current
    mouse cursor''s location as the origin; the following code tells you how to do
    this:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个方法内部，我们创建一个新的`Ray`实例，它将以当前鼠标光标的位置为原点；以下代码告诉您如何做到这一点：
- en: '[PRE63]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Since the view is orthographic, we let the direction be `Vector3f(0, 0, -1f)`.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于视图是正交的，我们让方向为`Vector3f(0, 0, -1f)`。
- en: Now, we define a new `CollisionResults` instance to store any segments that
    `Ray` collides with.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们定义一个新的`CollisionResults`实例来存储`Ray`与之碰撞的任何段。
- en: The next thing we do is parse through the segment's list and check whether the
    ray hits any of them.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们要做的是遍历段列表并检查射线是否击中它们中的任何一个。
- en: If it does, we're done, and then return `RigidBodyControl` of segment to the
    calling method.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这样做，我们就完成了，然后返回段的`RigidBodyControl`给调用方法。
- en: 'We defined a couple of input mappings earlier. Now, we can all implement the
    functionality for them in the `onAction` method by performing the following steps:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前定义了一些输入映射。现在，我们都可以通过执行以下步骤在`onAction`方法中实现它们的功能：
- en: 'If the left mouse button is clicked, we should call `checkSelection`. If the
    returned value is not null, we should set `selectedSegment` to that value, as
    follows:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果左键被点击，我们应该调用`checkSelection`。如果返回值不为null，我们应该将`selectedSegment`设置为该值，如下所示：
- en: '[PRE64]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'If the right mouse button is clicked, we should also call `checkSelection`.
    If the returned value is not null and it''s not `selectedSegment`, we call `createJoint`
    with `selectedSegment` and the value of `checkSelection` to create a link between
    `selectedSegment` and the segment returned from the method, as shown in the following
    code snippet:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果右键被点击，我们还应该调用`checkSelection`。如果返回值不为null，并且它不是`selectedSegment`，我们使用`selectedSegment`和`checkSelection`的值调用`createJoint`来在`selectedSegment`和从该方法返回的段之间创建一个链接，如下面的代码片段所示：
- en: '[PRE65]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Otherwise, if we didn''t hit anything, we call `createSegment` with the position
    of the mouse cursor to create a new segment at that location as follows:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，如果我们没有击中任何东西，我们使用鼠标光标的位置调用`createSegment`来在该位置创建一个新的段，如下所示：
- en: '[PRE66]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If the Space bar has been pressed, all we need to do is set the speed of `bulletAppState`
    to `1` to start the physics.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果空格键被按下，我们只需要将`bulletAppState`的速度设置为`1`以启动物理。
- en: 'We''re almost done with our simulation now, but we need to do a few more things.
    This last section will handle the `update` method and what happens when the physics
    is running and the bridge is being tested:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在几乎完成了我们的模拟，但我们需要做几件事情。这个最后的部分将处理`update`方法以及当物理运行并且桥梁正在测试时会发生什么：
- en: 'In the `update` method, we parse through all the items in the segment list
    and set the `z` value of `linearVelocity` to `0`, as follows:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`update`方法中，我们遍历段列表中的所有项目并将`linearVelocity`的`z`值设置为`0`，如下所示：
- en: '[PRE67]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'After this, we parse through all the items in the joint''s list. For each,
    we should check whether the joint''s `appliedImpulse` value is higher than a value,
    let''s say `10`. If it is, the joint should be removed from the list as well as
    from `physicsSpace`, as follows:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后，我们遍历关节列表中的所有项目。对于每一个，我们应该检查关节的`appliedImpulse`值是否高于一个值，比如说`10`。如果是，关节应该从列表中以及从`physicsSpace`中移除，如下所示：
- en: '[PRE68]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: How it works...
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `createSegment` method creates a new bridge segment that is sphere shaped,
    both in `physicsSpace` and the visible world. This is the part that has a mass
    and can be selected by clicking on it, since `Ray` only collides with spatials.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`createSegment` 方法创建一个新的球形桥段，既在 `physicsSpace` 中也在可见世界中。这是具有质量并且可以通过点击来选择的部分，因为
    `Ray` 只与空间体发生碰撞。'
- en: The `createJoint` method creates the visible connection between the newly created
    segment, and the currently selected one. It does this using `Point2PointJoin`t.
    This is different from, for example, `HingeJoint`, since it's not fixed in space,
    when several `Point2Pointjoints` are connected and you have something that resembles
    a bridge.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`createJoint` 方法创建新创建的段与当前选中段之间的可见连接。它使用 `Point2PointJoin`t 来实现。这与例如 `HingeJoint`
    不同，因为它在空间中不是固定的，当多个 `Point2Pointjoints` 连接在一起并且你有一个类似桥梁的东西时。'
- en: The mouse selection is covered more in depth in other chapters, but it works
    by shooting `Ray` from the mouse's position on the screen, inwards into the game
    world. Once `Ray` hits `Geometry` (which has `BoundingSphere` that is slightly
    larger than the visible mesh for increased selectability), the corresponding `RigidBodyControl`
    will be selected.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标选择在其它章节中有更深入的介绍，但它是通过从屏幕上鼠标的位置发射 `Ray` 到游戏世界内部来实现的。一旦 `Ray` 击中 `Geometry`（它具有比可见网格略大的
    `BoundingSphere` 以增加可选择性），相应的 `RigidBodyControl` 将被选中。
- en: There's no challenge in a bridge-building game if the segments don't have a
    maximum force they can handle before they break. This is what we take care of
    in the `update` method where we check `appliedImpulse` on each segment. If it
    goes above a certain threshold, it can be considered to be overloaded and removed,
    often with disastrous results. We also set `linearVelocity` along the *z* axis
    on each segment to `0` since it's a 2D game and we don't want anything to move
    to the depth layer.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果段没有最大承受力，那么桥梁建造游戏就没有挑战性。这就是我们在 `update` 方法中处理 `appliedImpulse` 的地方，我们检查每个段的
    `appliedImpulse`。如果它超过某个阈值，它可以被认为是超载并移除，通常会有灾难性的后果。我们还设置了每个段沿 *z* 轴的 `linearVelocity`
    为 `0`，因为这是一个 2D 游戏，我们不希望任何东西移动到深度层。
- en: We start the game with the physics simulation off by setting the speed of `bulletAppState`
    to `0`. Without doing so, building the game will get tricky pretty fast as everything
    will fall down. Pressing the Space bar will start the physics, and let the player
    know whether their engineering skills are up to par.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将 `bulletAppState` 的速度设置为 `0` 来关闭物理模拟开始游戏。如果不这样做，构建游戏会很快变得棘手，因为所有东西都会掉下来。按下空格键将启动物理模拟，并让玩家知道他们的工程技能是否足够。
- en: There's more…
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are a couple of things missing from the recipe to make it a full-blown
    bridge builder. First of all, there is usually a limit to the length the segments
    can have. There might also be a grid structure along which they have to be placed.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 要使它成为一个完整的桥梁建造者，还有一些东西缺失。首先，通常对段的最大长度有限制。它们可能还需要沿着网格结构放置。
- en: It's also quite easy since the bridge currently only has to support its own
    weight. In a full game, the difficulty is usually increased by adding a heavier
    object that needs to pass the bridge to complete the level.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这也很容易，因为桥梁目前只需要支撑自己的重量。在完整游戏中，难度通常通过添加一个需要通过桥梁才能完成关卡的重物来增加。
- en: Add some monetary constraints to this or a varied terrain and you have a challenging
    game.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一些货币限制或变化的地形，你就有了一个有挑战性的游戏。
- en: Networked physics
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络物理
- en: This recipe will go into something of a final frontier in game development.
    The topic is extremely application-dependent, and it is difficult to get right.
    Hopefully, after going through this recipe, you will have a basic framework in
    place that can be adapted to specific projects.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将进入游戏开发的一个最终领域。这个主题非常依赖于应用，很难做对。希望在这个配方之后，你将有一个基本的框架，可以适应特定的项目。
- en: Getting ready
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is for those who have a fundamental understanding of both [Chapter
    7](ch07.html "Chapter 7. Networking with SpiderMonkey"), *Networking with SpiderMonkey*,
    and [Chapter 8](ch08.html "Chapter 8. Physics with Bullet"), *Physics with Bullet*.
    This recipe will describe how to implement networked physics in the networked
    fps that was discussed previously in the book. Since this is built on top of the
    existing framework, an `AppState` pattern has been chosen to isolate as much of
    the physics code as possible. There will be some overlapping, though.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方是为那些对第七章[第七章](ch07.html "第七章。使用SpiderMonkey进行网络通信")，*使用SpiderMonkey进行网络通信*和第八章[第八章](ch08.html
    "第八章。使用Bullet进行物理")，*使用Bullet进行物理*有基本理解的人准备的。这个配方将描述如何在之前在书中讨论过的网络fps中实现网络物理。由于这是建立在现有框架之上的，因此选择了`AppState`模式来尽可能隔离大部分物理代码。尽管会有一些重叠。
- en: 'Physics can be expensive as it is and has its own problems and requirements.
    Sending translations and rotations for objects over the network with every tick
    will seriously affect the bandwidth load. The ground rule is this: send only what
    you must.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 物理本身可能很昂贵，并且有其自己的问题和要求。在每次更新时通过网络发送对象的平移和旋转将严重影响带宽负载。基本原则是：只发送必须发送的内容。
- en: Divide physics objects into those that you're interested in sharing and those
    that you don't. In most games, this means separating those that affect the gameplay
    and those that don't.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 将物理对象分为你感兴趣共享的和你不感兴趣共享的。在大多数游戏中，这意味着将影响游戏玩法的对象和那些不影响游戏玩法的对象分开。
- en: For example, a meter-sized crate that can be climbed upon will definitely affect
    the gameplay. It has to be networked.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个可以攀爬的、尺寸为一米的箱子肯定会影响游戏玩法。它必须联网。
- en: A bucket that can be kicked or small debris from an explosion do not affect
    the gameplay and should only have local physics. It doesn't matter if they show
    up in different places for different players.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 可以踢的桶或爆炸产生的小碎片不会影响游戏玩法，并且应该只有本地物理效果。它们出现在不同玩家的不同位置无关紧要。
- en: 'The second part of the rule is this: send only when you must. There''s no point
    in sending an update for an object that is not moving.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 规则的第二部分是：只有在必须时才发送。发送一个不移动的对象的更新没有意义。
- en: How to do it...
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Based on the first rule, we''ll start by defining a new `Control` class for
    our networked physics objects:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 根据第一条规则，我们将首先为我们的网络物理对象定义一个新的`Control`类：
- en: We create a new class called `PhysicsObjectControl` that extends `AbstractControl`.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`PhysicsObjectControl`的新类，它扩展了`AbstractControl`。
- en: 'It should have two fields: a Boolean field called `serverControlled` and an
    integer field called `id`.'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它应该有两个字段：一个名为`serverControlled`的布尔字段和一个名为`id`的整数字段。
- en: 'We now define a network message to handle updates to objects with physics:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在定义一个网络消息来处理具有物理特性的对象的更新：
- en: Let's call it `PhysicsObjectMessage` and have it extend `AbstractMessage`.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以称它为`PhysicsObjectMessage`，并让它扩展`AbstractMessage`。
- en: 'There are three mandatory fields for it; they are as follows:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它有三个强制字段；如下所示：
- en: The first is an integer field called `objectId`
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一部分是一个名为`objectId`的整数字段。
- en: It also needs a `Vector3f` field called `translation`
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还需要一个名为`translation`的`Vector3f`字段。
- en: Finally, we add a `Quaternion` field called `rotation`
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们添加一个名为`rotation`的`Quaternion`字段。
- en: Don't forget to add the `@Serializable` annotation, and add it to the list of
    messages in the `GameUtil` class!
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记添加`@Serializable`注解，并将其添加到`GameUtil`类中的消息列表中！
- en: 'The last common implementation we do is for the `Game` class where we add a
    list of `Spatials` called `physicsObjects`; the following code tells us how to
    do this:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们最后做的常见实现是为`Game`类添加一个名为`physicsObjects`的`Spatials`列表；以下代码告诉我们如何做到这一点：
- en: '[PRE69]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, we can dig into the server-side implementation by performing the following
    steps:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过以下步骤深入了解服务器端实现：
- en: We contain most of the code in a new `AppState` class called `ServerPhysicsAppState`.
    This `AppState` class will contain the reference to the `BulletAppState` class,
    and it will handle the initialization.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将大部分代码包含在一个新的`AppState`类中，称为`ServerPhysicsAppState`。这个`AppState`类将包含对`BulletAppState`类的引用，并处理初始化。
- en: 'Inside its `initialize` method, it should add the loaded level to `physicsSpace`
    as follows:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其`initialize`方法内部，它应该按照以下方式将加载的关卡添加到`physicsSpace`中：
- en: '[PRE70]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'A strategy is needed to collect all the objects that should be affected by
    server physics and assign them to `PhysicsObjectControl` (unless this has been
    done in **SceneComposer** already). Objects that should have server physics should
    also have `serverControlled` set to `true` and a unique ID, which is known by
    both the client and the server. The resulting spatials should be stored in the
    `physicsObject` class map, as follows:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要一种策略来收集所有应受服务器物理影响的对象，并将它们分配给 `PhysicsObjectControl`（除非这已经在 **SceneComposer**
    中完成）。应具有服务器物理的对象也应将 `serverControlled` 设置为 `true` 并具有一个唯一 ID，该 ID 服务器和客户端都知道。结果的空间应存储在
    `physicsObject` 类映射中，如下所示：
- en: '[PRE71]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'In the `update` method of `ServerPhysicsAppState`, we parse through the values
    of the `physicsObject` map. If any of the item in `physicsObjects` has `PhysicsObjectControl`
    that `isServerControlled()` and their `isActive()` is `true`, a new `PhysicsObjectMessage`
    should be created as follows:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ServerPhysicsAppState` 的 `update` 方法中，我们解析 `physicsObject` 映射的值。如果 `physicsObjects`
    中的任何项具有 `PhysicsObjectControl` 且 `isServerControlled()` 返回 true，并且它们的 `isActive()`
    为 true，则应创建一个新的 `PhysicsObjectMessage`，如下所示：
- en: '[PRE72]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'It should have the ID of `PhysicsObjectControl` as `objectId` and `physicsLocation`
    and `physicsRotation` of `RigidBodyControl`; refer to the following code:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它应该具有 `objectId` 为 `PhysicsObjectControl` 以及 `physicsLocation` 和 `physicsRotation`
    为 `RigidBodyControl` 的 ID；请参考以下代码：
- en: '[PRE73]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The message is then broadcasted to the clients.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消息随后被广播到客户端。
- en: We'll revisit the server code in a bit, but first let's look at what is needed
    for the client to receive messages.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会重新查看服务器代码，但首先让我们看看客户端接收消息所需的条件。
- en: First of all, the client has to have `BulletAppState` set up.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，客户端必须设置 `BulletAppState`。
- en: Next, it needs to have knowledge of the objects to be handled by the server
    physics. If the objects are gathered from the scene, a strategy is needed to make
    sure the IDs are the same, or they're read in the same order.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，服务器物理需要了解要处理的对象。如果对象是从场景中收集的，则需要一种策略来确保 ID 相同，或者以相同的顺序读取。
- en: They should then be stored in the `Game` class as on the server.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它们应该像在服务器上一样存储在 `Game` 类中。
- en: 'The second thing is a change to `ClientMessageHandler`. If the message is an
    instance of `PhysicsObjectMessage`, it should get the `physicsObject` `Map` from
    the `Game` class as follows:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二件事是对 `ClientMessageHandler` 的更改。如果消息是 `PhysicsObjectMessage` 的实例，它应从 `Game`
    类获取 `physicsObject` `Map`，如下所示：
- en: '[PRE74]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'A spatial should then be selected based on the `objectId` in the message as
    follows:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后应根据消息中的 `objectId` 选择一个空间，如下所示：
- en: '[PRE75]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The rotation and translation should be applied as `physicsLocation` and `physicsRotation`
    respectively on the spatial''s `RigidBodyControl`:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 旋转和平移应分别应用于空间的 `RigidBodyControl` 上的 `physicsLocation` 和 `physicsRotation`：
- en: '[PRE76]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Now, the pipeline for transmitting physics updates from the server to the clients
    should work. If we run it, not much is happening. This is because the players
    in the implementation in [Chapter 7](ch07.html "Chapter 7. Networking with SpiderMonkey"),
    *Networking with SpiderMonkey*, weren't using physics. They were simply coded
    to stick to the surface of the terrain. We can change the player's representation
    to handle this.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从服务器到客户端传输物理更新的管道应该可以工作。如果我们运行它，不会发生太多事情。这是因为 [第 7 章](ch07.html "第 7 章。使用
    SpiderMonkey 进行网络连接") 中实现中的玩家没有使用物理。他们只是被编码为粘附在地形表面。我们可以更改玩家的表示来处理这种情况。
- en: In `ServerPlayerControl`, we add a `BetterCharacterControl` field called `physicsCharacter`
    and a Boolean field called `usePhysics`.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ServerPlayerControl` 中，我们添加一个名为 `physicsCharacter` 的 `BetterCharacterControl`
    字段和一个名为 `usePhysics` 的布尔字段。
- en: 'Next, we override the `setSpatial` method, and perform a check to see whether
    the spatial supplied has `BetterCharacterControl`. If it does, `usePhysics` should
    be set to `true` and the local `physicsCharacter` field should be set to `spatial`
    as follows:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们重写 `setSpatial` 方法，并检查提供的空间是否有 `BetterCharacterControl`。如果有，则应将 `usePhysics`
    设置为 `true`，并将局部 `physicsCharacter` 字段设置为 `spatial`，如下所示：
- en: '[PRE77]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Finally, in the `controlUpdate` method, we check whether `usePhysics` is `true`.
    If it is, rather than updating the spatial like we normally do in the method,
    we should instead set `walkDirection` of `physicsCharacter` to the local one and
    set `viewDirection` to the forward vector of its rotation as follows:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `controlUpdate` 方法中，我们检查 `usePhysics` 是否为 `true`。如果是，则应将 `physicsCharacter`
    的 `walkDirection` 设置为局部方向，并将 `viewDirection` 设置为其旋转的前向向量，如下所示：
- en: '[PRE78]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'In our server''s main class, inside the `addPlayer` method, we should now add
    `BetterCharacterControl` to the player''s spatial before we add `ServerPlayerControl`,
    as shown in the following code snippet:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的服务器主类的`addPlayer`方法中，我们现在应该在添加`ServerPlayerControl`之前将`BetterCharacterControl`添加到玩家的空间中，如下面的代码片段所示：
- en: '[PRE79]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: There also needs to be some logic to add and remove `BetterCharacterControl`
    from `physicsSpace` as it joins and leaves the game.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还需要一些逻辑来在游戏开始和结束时从`physicsSpace`中添加和移除`BetterCharacterControl`。
- en: How it works...
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first thing we did in the recipe was to lay some ground work by defining
    a new control called `PhysicsObjectControl` to be applied to the objects that
    should be handled by bullet physics. This control can either be added at runtime;
    alternatively, if **Scene Composer** is used to lay out levels and scenes, it
    can be added to the objects beforehand. It's recommended that you define which
    ones should be handled by the server by setting `serverControlled` on the relevant
    objects before they're being added to the scenes. The ID should then be set in
    a deterministic way on both the client and the server when they parse the scene
    for the objects.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的配方中，我们首先通过定义一个新的控制`PhysicsObjectControl`来打下一个基础，这个控制将应用于需要由子弹物理处理的物体。这个控制可以在运行时添加；或者，如果使用**场景作曲家**来布局关卡和场景，它可以在物体之前添加。建议在将相关物体添加到场景之前，通过在物体上设置`serverControlled`来定义哪些应该由服务器处理。然后，当客户端和服务器解析场景中的物体时，应该在两者上以确定的方式设置ID。
- en: The architecture to handle the physics might very well look different in another
    implementation, but here, the `AppState` pattern was used so that it could be
    easily added as an extension to the existing framework from [Chapter 7](ch07.html
    "Chapter 7. Networking with SpiderMonkey"), *Networking with SpiderMonkey*. In
    this chapter, we didn't use any physics for the players but simply checked the
    height of the terrain to find out where the ground was. Hence, we added an optional
    `BetterCharacterControl` instance to the player—again, a change that would still
    make it compatible with the previous implementation. However, this was only added
    on the server side. For client-side physics, a similar change would have to be
    made there.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 处理物理的架构可能在其他实现中看起来很不同，但在这里，使用了`AppState`模式，以便它可以轻松地作为现有框架的扩展添加，如[第7章](ch07.html
    "第7章。使用SpiderMonkey进行网络连接")中所述，*使用SpiderMonkey进行网络连接*。在这一章中，我们没有为玩家使用任何物理，只是检查地形的高度以确定地面在哪里。因此，我们向玩家添加了一个可选的`BetterCharacterControl`实例——再次，这是一个仍然与先前实现兼容的更改。然而，这仅在服务器端添加。对于客户端物理，必须在那里进行类似更改。
- en: The server will check every update and see whether any of the objects with `serverControlled`
    enabled is active and will send any updates to the clients. Actually, you could
    leave out the physics all together on the client and simply update the spatial's
    rotation and translation, if you wanted. This would lower the requirements on
    the client's hardware, but this will only work if all of the physics are handled
    by the server of course.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将检查每个更新，查看是否启用了`serverControlled`的任何对象是活动的，并将任何更新发送到客户端。实际上，如果你愿意，可以在客户端完全省略物理，只需更新空间的位置和旋转。这将降低客户端硬件的要求，但当然，这只有在所有物理都由服务器处理的情况下才会有效。
- en: There's more…
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There is an opportunity here to introduce a third state on `PhysicsObjectControl`;
    a state in which the object is affected but not controlled by the server. This
    could be used for objects that are important in their initial state; however,
    once they've been moved, it's no longer important that all the clients have the
    same information, for example, a door that at some points get blown off its hinges.
    In this case, a new message type can be introduced that will apply an impulse
    or force to an object from the server side. Once the object has been activated,
    the client can take care of the calculations, lowering the network load.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，有机会在`PhysicsObjectControl`上引入第三个状态；一个对象受到但不受服务器控制的状态。这可以用于在初始状态下很重要的对象；然而，一旦它们被移动，所有客户端都有相同的信息就不再重要了，例如，某个时刻被吹离铰链的门。在这种情况下，可以引入一种新的消息类型，该类型将从服务器端对对象施加冲量或力。一旦对象被激活，客户端可以负责计算，降低网络负载。
